<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2289" clone_windows="0"/>
<globals body_outline_ratio="0.533116178067">
	<global_window_position top="10" left="511" height="921" width="693"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="edream.110203113231"><vh>@file-thin pluginsNotes.txt</vh></v>
<v t="edream.110203113231.618"><vh>Plugins</vh>
<v t="edream.110203113231.667"><vh>Commands &amp; directives</vh>
<v t="edream.110203113231.668"><vh> Importing Cisco configuration files</vh>
<v t="edream.110203113231.669"><vh>@thin import_cisco_config.py</vh></v>
<v t="edream.110203113231.677"><vh> Example of an imported config</vh>
<v t="edream.110203113231.678"><vh>plain configuration</vh></v>
<v t="edream.110203113231.679"><vh>cisco config: C:/Davide/Leo/CVS Version/example_conf.txt</vh>
<v t="edream.110203113231.680"><vh>&lt;&lt;access-list&gt;&gt;</vh></v>
<v t="edream.110203113231.681"><vh>&lt;&lt;boot&gt;&gt;</vh></v>
<v t="edream.110203113231.682"><vh>&lt;&lt;controller&gt;&gt;</vh>
<v t="edream.110203113231.683"><vh>controller E1 5/0/0</vh></v>
<v t="edream.110203113231.684"><vh>controller E1 5/0/1</vh></v>
<v t="edream.110203113231.685"><vh>controller SONET 1/0/0</vh></v>
</v>
<v t="edream.110203113231.686"><vh>&lt;&lt;interface&gt;&gt;</vh>
<v t="edream.110203113231.687"><vh>interface Async1</vh></v>
<v t="edream.110203113231.688"><vh>interface Dialer0</vh></v>
<v t="edream.110203113231.689"><vh>interface FastEthernet0/0/0</vh></v>
<v t="edream.110203113231.690"><vh>interface FastEthernet0/0/1</vh></v>
<v t="edream.110203113231.691"><vh>interface FastEthernet0/0/1.1</vh></v>
<v t="edream.110203113231.692"><vh>interface FastEthernet0/0/1.2</vh></v>
<v t="edream.110203113231.693"><vh>interface FastEthernet0/0/1.3</vh></v>
<v t="edream.110203113231.694"><vh>interface FastEthernet0/0/1.5</vh></v>
<v t="edream.110203113231.695"><vh>interface FastEthernet0/0/1.50</vh></v>
<v t="edream.110203113231.696"><vh>interface Loopback0</vh></v>
<v t="edream.110203113231.697"><vh>interface POS4/1/0</vh></v>
<v t="edream.110203113231.698"><vh>interface Serial5/0/0:1</vh></v>
<v t="edream.110203113231.699"><vh>interface Serial5/0/0:2</vh></v>
<v t="edream.110203113231.700"><vh>interface Serial5/0/1:0</vh></v>
<v t="edream.110203113231.701"><vh>interface Serial5/1/0</vh></v>
<v t="edream.110203113231.702"><vh>interface Serial5/1/1</vh></v>
</v>
<v t="edream.110203113231.703"><vh>&lt;&lt;ip community-list&gt;&gt;</vh></v>
<v t="edream.110203113231.704"><vh>&lt;&lt;ip route&gt;&gt;</vh></v>
<v t="edream.110203113231.705"><vh>&lt;&lt;line&gt;&gt;</vh>
<v t="edream.110203113231.706"><vh>line aux 0</vh></v>
<v t="edream.110203113231.707"><vh>line vty 0 4</vh></v>
</v>
<v t="edream.110203113231.708"><vh>&lt;&lt;logging&gt;&gt;</vh></v>
<v t="edream.110203113231.709"><vh>&lt;&lt;ntp&gt;&gt;</vh></v>
<v t="edream.110203113231.710"><vh>&lt;&lt;route-map&gt;&gt;</vh>
<v t="edream.110203113231.711"><vh>route-map only permit 2</vh></v>
<v t="edream.110203113231.712"><vh>route-map only1 permit 10</vh></v>
<v t="edream.110203113231.713"><vh>route-map only3 permit 10</vh></v>
<v t="edream.110203113231.714"><vh>route-map tag_com permit 10</vh></v>
<v t="edream.110203113231.715"><vh>route-map tag_com permit 20</vh></v>
</v>
<v t="edream.110203113231.716"><vh>&lt;&lt;router&gt;&gt;</vh>
<v t="edream.110203113231.717"><vh>router bgp 65001</vh></v>
<v t="edream.110203113231.718"><vh>router ospf 1</vh></v>
</v>
<v t="edream.110203113231.719"><vh>&lt;&lt;service&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="edream.110203113231.741"><vh>@thin add_directives.py</vh></v>
<v t="edream.110203113231.727"><vh>@thin mod_timestamp.py</vh></v>
<v t="edream.110203113231.720"><vh>@thin outline_export.py</vh></v>
<v t="edream.110203113231.722"><vh>mod_autosave</vh>
<v t="edream.110203113231.723" tnodeList="edream.110203113231.723"><vh>@file-nosent mod_autosave.ini</vh></v>
<v t="edream.110203113231.724"><vh>@thin mod_autosave.py</vh></v>
</v>
</v>
<v t="edream.110203113231.729"><vh>Debugging &amp;  testing</vh>
<v t="edream.110203113231.730"><vh>@thin dump_globals.py</vh></v>
<v t="edream.110203113231.732"><vh>@thin enable_gc.py</vh></v>
<v t="edream.110203113231.734"><vh>@thin quit_leo.py</vh></v>
<v t="edream.110203113231.735"><vh>@thin trace_gc.py</vh></v>
<v t="edream.110203113231.736"><vh>@thin trace_keys.py</vh></v>
<v t="edream.110203113231.738"><vh>@thin trace_tags.py</vh></v>
<v t="ekr.20040205071616"><vh>mnplugins.py</vh>
<v t="ekr.20040205071616.1"><vh>mnstamp</vh></v>
<v t="ekr.20040205071616.2"><vh>mnOKstamp</vh></v>
<v t="ekr.20040205071616.3"><vh>onStart</vh></v>
<v t="ekr.20040205071616.4"><vh>setHeadOK</vh></v>
<v t="ekr.20040205071616.5"><vh>insertBodystamp</vh></v>
<v t="ekr.20040205071616.6"><vh>is_subnodesOK</vh></v>
<v t="ekr.20040205071616.7"><vh>onRclick</vh></v>
<v t="ekr.20040205071616.8"><vh>insertOKcmd</vh></v>
<v t="ekr.20040205071616.9"><vh>insertUser</vh></v>
<v t="ekr.20040205071616.10"><vh>create_UserMenu</vh></v>
</v>
</v>
<v t="ekr.20040722141148"><vh>Example code</vh>
<v t="edream.110203113231.916"><vh>@thin __overrideClasses.py</vh></v>
<v t="edream.110203113231.919"><vh>@thin override_commands.py</vh></v>
<v t="edream.110203113231.921"><vh>@thin redefine_put.py</vh></v>
<v t="edream.110203113231.924"><vh>@thin redirect_to_log.py</vh></v>
<v t="edream.110203113231.925"><vh>@thin script_io_to_body.py</vh></v>
</v>
<v t="ekr.20040722135402"><vh>Enhancing the icon and status areas</vh>
<v t="EKR.20040517075915" tnodeList="EKR.20040517075915,EKR.20040517075915.1,EKR.20040517075915.2,EKR.20040517075915.3,EKR.20040517075915.4,EKR.20040517075915.5,EKR.20040517075915.6,EKR.20040517075915.7,EKR.20040517075915.8,EKR.20040517075915.9,EKR.20040517075915.10,EKR.20040517075915.11,EKR.20040517075915.12,EKR.20040517075915.13"><vh>@file-noref newButtons.py</vh>
<v t="EKR.20040517075915.1"><vh>Helper classes</vh>
<v t="EKR.20040517075915.2"><vh>class FlatOptionMenu</vh></v>
<v t="EKR.20040517075915.3"><vh>class Node</vh></v>
<v t="EKR.20040517075915.4"><vh>class NodeAdder</vh></v>
<v t="EKR.20040517075915.5"><vh>class Helper</vh></v>
</v>
<v t="EKR.20040517075915.6"><vh>Modifiable classes to add buttons</vh>
<v t="EKR.20040517075915.7"><vh>body text used by AddTestModule &amp; AddTestClass</vh></v>
<v t="EKR.20040517075915.8"><vh>class AddTestModule</vh></v>
<v t="EKR.20040517075915.9"><vh>class AddTestClass</vh></v>
<v t="EKR.20040517075915.10"><vh>class AddTestMethod</vh></v>
<v t="EKR.20040517075915.11"><vh>class AddClass</vh></v>
<v t="EKR.20040517075915.12"><vh>class AddClassMethod</vh></v>
</v>
<v t="EKR.20040517075915.13"><vh>main code</vh></v>
</v>
<v t="ekr.20040331072607"><vh>@thin hoist.py</vh></v>
<v t="EKR.20040613213623"><vh>@thin mod_scripting.py</vh></v>
<v t="edream.110203113231.758"><vh>@thin nav_buttons.py</vh></v>
<v t="ekr.20040108062655"><vh>@thin nodenavigator.py</vh></v>
<v t="ekr.20040108095351"><vh>@thin rowcol.py</vh></v>
<v t="ekr.20040107092135.2"><vh>@thin searchbox.py</vh></v>
</v>
<v t="ekr.20040722135402.1"><vh>Enhancing the body pane</vh>
<v t="EKR.20040517080517.1"><vh>@thin arrows.py</vh></v>
<v t="edream.110203113231.753"><vh>@thin image.py</vh></v>
<v t="ekr.20040422072343"><vh>@thin rClick.py</vh></v>
<v t="EKR.20040605181725"><vh>Autocompleter</vh>
<v t="EKR.20040605181725.1"><vh>Docs for v125</vh>
<v t="EKR.20040608070256"><vh>autocompleter.ini</vh></v>
<v t="EKR.20040608070256.1"><vh>.ato files in the autocompleter folder</vh></v>
</v>
<v t="ekr.20040722104914"><vh>@thin autocompleter.py</vh></v>
</v>
<v t="edream.110403140857"><vh>color_markup.py (requires add-directives plugin)</vh>
<v t="edream.110403140857.1"><vh>Plugin documentation</vh>
<v t="edream.110403140857.2"><vh>Installation</vh></v>
<v t="edream.110403140857.3"><vh>Use</vh>
<v t="edream.110403140857.4"><vh>Supported markups</vh></v>
<v t="edream.110403140857.5"><vh>Example</vh>
<v t="edream.110403140857.6"><vh>a subnode</vh></v>
</v>
</v>
<v t="edream.110403140857.7"><vh>Release notes</vh></v>
</v>
<v t="edream.110403140857.8" a="M"><vh>@thin color_markup.py</vh></v>
</v>
<v t="edream.110203113231.930"><vh>Spell Checking</vh>
<v t="edream.110203113231.932" tnodeList="edream.110203113231.932"><vh>@asis mod_spelling.ini</vh></v>
<v t="edream.110203113231.931"><vh>@asis mod_spelling.txt</vh></v>
<v t="edream.110203113231.933"><vh>@thin mod_spelling.py</vh></v>
</v>
</v>
<v t="ekr.20040722134535"><vh>Experimental plugins</vh>
<v t="EKR.20040609213754"><vh>@thin Configurator.py</vh></v>
<v t="ekr.20040722142445"><vh>@thin editAttributes.py</vh></v>
<v t="ekr.20040331153923"><vh>@thin scheduler.py</vh></v>
<v t="ekr.20040201060959"><vh>@thin status_line.py</vh></v>
<v t="EKR.20040517080250"><vh>http plugin</vh>
<v t="EKR.20040517080250.49"><vh>@thin mod_http.ini</vh></v>
<v t="EKR.20040517080250.1"><vh>@thin mod_http.py</vh></v>
</v>
<v t="ekr.20040331071919"><vh>Leo to AsciiDoc</vh>
<v t="ekr.20040331071919.1"><vh>Leo 2 AsciiDoc Developers Guide</vh>
<v t="ekr.20040331071919.2"><vh>About this document</vh>
<v t="ekr.20040331071919.3"><vh>License</vh>
<v t="ekr.20040331071919.4"><vh>License document</vh></v>
</v>
</v>
<v t="ekr.20040331071919.5"><vh>Version, Requirements</vh></v>
<v t="ekr.20040331071919.6"><vh>The General Approach</vh>
<v t="ekr.20040331071919.7"><vh>Markup Added</vh></v>
</v>
<v t="ekr.20040331071919.8"><vh>&lt;&lt; The Code &gt;&gt;</vh>
<v t="ekr.20040331071919.9"><vh>&lt;&lt; Key Functions &gt;&gt;</vh></v>
<v t="ekr.20040331071919.10"><vh>&lt;&lt; Declarations and Utilities &gt;&gt;</vh>
<v t="ekr.20040331071919.11"><vh>&lt;&lt; The Code -- Declarations and Utilities &gt;&gt;</vh></v>
</v>
<v t="ekr.20040331071919.12"><vh>&lt;&lt; Write the outline tree as AsciiDoc file &gt;&gt;</vh>
<v t="ekr.20040331071919.13"><vh>&lt;&lt; Write a node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040331071919.14"><vh>Other programs</vh></v>
<v t="ekr.20040331071919.15"><vh>&lt;&lt;Appendix: AsciiDoc &gt;&gt;</vh>
<v t="ekr.20040331071919.16"><vh>&lt;&lt; Configuration file &gt;&gt;</vh></v>
<v t="ekr.20040331071919.17"><vh>&lt;&lt; Patches &gt;&gt;</vh></v>
</v>
<v t="ekr.20040331071919.18"><vh>&lt;&lt;Appendix: DocBook&gt;&gt;</vh>
<v t="ekr.20040331071919.19"><vh>&lt;&lt; Tool Chain &gt;&gt;</vh></v>
<v t="ekr.20040331071919.20"><vh>&lt;&lt; Make File &gt;&gt;</vh></v>
<v t="ekr.20040331071919.21"><vh>&lt;&lt; Style Sheets &gt;&gt;</vh>
<v t="ekr.20040331071919.22"><vh>&lt;&lt; General &gt;&gt;</vh></v>
<v t="ekr.20040331071919.23"><vh>&lt;&lt; Customize &gt;&gt;</vh></v>
<v t="ekr.20040331071919.24"><vh>&lt;&lt; HTML: One File &gt;&gt;</vh></v>
<v t="ekr.20040331071919.25"><vh>&lt;&lt; HTML: Individual Pages &gt;&gt;</vh></v>
<v t="ekr.20040331071919.26"><vh>&lt;&lt; HTML: base css style sheet &gt;&gt;</vh></v>
<v t="ekr.20040331071919.27"><vh>&lt;&lt; HTML: css style sheet &gt;&gt;</vh></v>
<v t="ekr.20040331071919.28"><vh>&lt;&lt; HTML: common &gt;&gt;</vh></v>
<v t="ekr.20040331071919.29"><vh>&lt;&lt; PDF &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040331071919.30"><vh>&lt;&lt;Appendix: XEmacs Text Editor&gt;&gt;</vh>
<v t="ekr.20040331071919.31"><vh>&lt;&lt; Open_With Plugin &gt;&gt;</vh></v>
<v t="ekr.20040331071919.32"><vh>&lt;&lt; Open_Tree Plugin &gt;&gt;</vh></v>
<v t="ekr.20040331071919.33"><vh>&lt;&lt; Filename modification &gt;&gt;</vh></v>
<v t="ekr.20040331071919.34"><vh>&lt;&lt; Kill Temporary Buffers &gt;&gt;</vh></v>
<v t="ekr.20040331071919.35"><vh>&lt;&lt; MMM-mode &gt;&gt;</vh></v>
<v t="ekr.20040331071919.36"><vh>&lt;&lt; Insert indexterm &gt;&gt;</vh></v>
<v t="ekr.20040331071919.37"><vh>&lt;&lt; Indent Leo comments &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040331071919.38"><vh>Leo 2 AsciiDoc Users Guide</vh>
<v t="ekr.20040331071919.2"><vh>About this document</vh>
<v t="ekr.20040331071919.3"><vh>License</vh>
<v t="ekr.20040331071919.4"><vh>License document</vh></v>
</v>
</v>
<v t="ekr.20040331071919.39"><vh>Installation</vh></v>
<v t="ekr.20040331071919.40"><vh>Operation</vh>
<v t="ekr.20040331071919.41"><vh>Directives</vh>
<v t="ekr.20040331071919.42"><vh>Configuration</vh></v>
</v>
<v t="ekr.20040331071919.43"><vh>Markup</vh>
<v t="ekr.20040331071919.44"><vh>Standard AsciiDoc Markup</vh>
<v t="ekr.20040331071919.45"><vh>Headings</vh></v>
<v t="ekr.20040331071919.46"><vh>Lists</vh></v>
<v t="ekr.20040331071919.47"><vh>URLs</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="EKR.20040611044600"><vh>Mulder undo</vh>
<v t="bwmulder.20040601212737"><vh>basic_undo.py</vh>
<v t="bwmulder.20040601212737.1"><vh>class passthrough</vh>
<v t="bwmulder.20040601212737.2"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.3"><vh>__set__</vh></v>
<v t="bwmulder.20040601212737.4"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040601212737.5"><vh>class scalar_monitor</vh>
<v t="bwmulder.20040601212737.6"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.7"><vh>__set__</vh></v>
<v t="bwmulder.20040601212737.8"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040601212737.9"><vh>class list_monitor</vh>
<v t="bwmulder.20040605231305"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.10"><vh>set_monitor_object</vh></v>
<v t="bwmulder.20040601212737.11"><vh>__setitem__</vh></v>
<v t="bwmulder.20040601212737.12"><vh>__delitem__</vh></v>
<v t="bwmulder.20040601212737.13"><vh>append</vh></v>
<v t="bwmulder.20040602152548"><vh>pop</vh></v>
</v>
<v t="bwmulder.20040601212737.14"><vh>class list_monitor_in_instance</vh>
<v t="bwmulder.20040601212737.15"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.16"><vh>__set__</vh></v>
<v t="bwmulder.20040601212737.17"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040602153618"><vh>class dict_monitor</vh>
<v t="bwmulder.20040605231401"><vh>__init__</vh></v>
<v t="bwmulder.20040602153642"><vh>set_monitor_object</vh></v>
<v t="bwmulder.20040602153723"><vh>__setitem__</vh></v>
<v t="bwmulder.20040602153835"><vh>__delitem__</vh></v>
</v>
<v t="bwmulder.20040602154259"><vh>class  dict_monitor_in_instance</vh>
<v t="bwmulder.20040602154259.1"><vh>__init__</vh></v>
<v t="bwmulder.20040602154259.2"><vh>__set__</vh></v>
<v t="bwmulder.20040602154259.3"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040601212737.18"><vh>class monitor</vh>
<v t="bwmulder.20040601212737.19"><vh>__init__</vh></v>
<v t="bwmulder.20040601214251"><vh>scalars</vh>
<v t="bwmulder.20040601212737.20"><vh>monitor_scalar</vh></v>
<v t="bwmulder.20040601212737.24"><vh>scalar_set</vh></v>
<v t="bwmulder.20040601212737.25"><vh>scalar_modify</vh></v>
</v>
<v t="bwmulder.20040601215339"><vh>lists</vh>
<v t="bwmulder.20040601212737.21"><vh>monitor_list_attribute_in_class</vh></v>
<v t="bwmulder.20040601212737.26"><vh>list_create</vh></v>
<v t="bwmulder.20040601212737.27"><vh>list_set</vh></v>
<v t="bwmulder.20040601212737.28"><vh>list_del</vh></v>
<v t="bwmulder.20040601212737.29"><vh>list_append</vh></v>
</v>
<v t="bwmulder.20040602165344"><vh>dicts</vh>
<v t="bwmulder.20040602165402"><vh>monitor_dict_attribute_in_class</vh></v>
<v t="bwmulder.20040602165506"><vh>dict_create</vh></v>
<v t="bwmulder.20040602165513"><vh>dict_set</vh></v>
<v t="bwmulder.20040602165553"><vh>dict_del</vh></v>
</v>
<v t="bwmulder.20040601215339.1"><vh>switching on and off</vh>
<v t="bwmulder.20040601212737.22"><vh>enable</vh></v>
<v t="bwmulder.20040602164627"><vh>enable_put_in_removed_functions</vh></v>
<v t="bwmulder.20040602154259.4"><vh>enable_category</vh></v>
<v t="bwmulder.20040602161525"><vh>disable_category</vh></v>
<v t="bwmulder.20040601212737.23"><vh>disable</vh></v>
<v t="bwmulder.20040603081718"><vh>remove_overrides_in_list_and_dict_monitor</vh></v>
</v>
</v>
<v t="bwmulder.20040601222230"><vh>class basic_undomechanism</vh>
<v t="bwmulder.20040601222230.1"><vh>__init__</vh></v>
<v t="bwmulder.20040602171606"><vh>reset</vh></v>
<v t="bwmulder.20040601222230.2"><vh>scalars</vh>
<v t="bwmulder.20040601222230.3"><vh>scalar_set</vh></v>
<v t="bwmulder.20040601222230.4"><vh>scalar_set_undo</vh></v>
<v t="bwmulder.20040601222230.5"><vh>scalar_set_redo</vh></v>
<v t="bwmulder.20040601222230.6"><vh>scalar_modify</vh></v>
<v t="bwmulder.20040601222431"><vh>scalar_modify_undo</vh></v>
</v>
<v t="bwmulder.20040602075341"><vh>lists</vh>
<v t="bwmulder.20040602084701.1"><vh>creation</vh>
<v t="bwmulder.20040602175523"><vh>list_assignment_replace</vh></v>
<v t="bwmulder.20040602175523.1"><vh>list_assignment_replace_undo</vh></v>
<v t="bwmulder.20040602175740"><vh>list_assignment_replace_redo</vh></v>
<v t="bwmulder.20040602183806"><vh>list_assignment_new</vh></v>
<v t="bwmulder.20040602183814"><vh>list_assignment_new_undo</vh></v>
<v t="bwmulder.20040602183911"><vh>list_assignment_new_redo</vh></v>
<v t="bwmulder.20040602075341.1"><vh>list_create</vh></v>
<v t="bwmulder.20040602084701.2"><vh>list_create_undo</vh></v>
<v t="bwmulder.20040602084701.3"><vh>list_create_redo</vh></v>
</v>
<v t="bwmulder.20040602084701.4"><vh>setting</vh>
<v t="bwmulder.20040602085955"><vh>list_set</vh></v>
<v t="bwmulder.20040602085955.1"><vh>list_set_undo</vh></v>
</v>
<v t="bwmulder.20040602085955.2"><vh>deletion</vh>
<v t="bwmulder.20040602085955.3"><vh>list_del</vh></v>
<v t="bwmulder.20040602085955.4"><vh>list_del_undo</vh></v>
<v t="bwmulder.20040602085955.5"><vh>list_del_redo</vh></v>
</v>
<v t="bwmulder.20040602151709"><vh>append</vh>
<v t="bwmulder.20040602152051"><vh>list_append</vh></v>
<v t="bwmulder.20040602152051.1"><vh>list_append_undo</vh></v>
<v t="bwmulder.20040602152051.2"><vh>list_append_redo</vh></v>
</v>
<v t="bwmulder.20040602152548.1"><vh>pop</vh>
<v t="bwmulder.20040602152548.2"><vh>list_pop</vh></v>
</v>
</v>
<v t="bwmulder.20040602171032"><vh>dictionaries</vh>
<v t="bwmulder.20040602171032.1"><vh>creation</vh>
<v t="bwmulder.20040602175801"><vh>dictionary creation</vh></v>
<v t="bwmulder.20040602171032.2"><vh>dict_create</vh></v>
<v t="bwmulder.20040602171032.3"><vh>dict_create_undo</vh></v>
<v t="bwmulder.20040602171032.4"><vh>dict_create_redo</vh></v>
</v>
<v t="bwmulder.20040602171032.5"><vh>setting</vh>
<v t="bwmulder.20040602171032.6"><vh>dict_set</vh></v>
<v t="bwmulder.20040602171032.7"><vh>dict_set_undo</vh></v>
</v>
<v t="bwmulder.20040602171032.8"><vh>deletion</vh>
<v t="bwmulder.20040602171032.9"><vh>dict_del</vh></v>
<v t="bwmulder.20040602171032.10"><vh>dict_del_undo</vh></v>
<v t="bwmulder.20040602171032.11"><vh>dict_del_redo</vh></v>
</v>
</v>
<v t="bwmulder.20040601224447"><vh>the undo machinery</vh>
<v t="bwmulder.20040603211921"><vh>queries</vh>
<v t="bwmulder.20040601224447.5"><vh>canUndo</vh></v>
<v t="bwmulder.20040601224447.6"><vh>canRedo</vh></v>
<v t="bwmulder.20040603212552"><vh>commands</vh></v>
<v t="bwmulder.20040603212612"><vh>commands_to_undo</vh></v>
<v t="bwmulder.20040603212713"><vh>commands_to_redo</vh></v>
<v t="bwmulder.20040604165011"><vh>steps_stored</vh></v>
<v t="bwmulder.20040605220919"><vh>print_commands</vh></v>
</v>
<v t="bwmulder.20040601224447.2"><vh>mark</vh></v>
<v t="bwmulder.20040601224447.3"><vh>undo</vh></v>
<v t="bwmulder.20040601224447.4"><vh>redo</vh></v>
<v t="bwmulder.20040603212934"><vh>rollback</vh></v>
<v t="bwmulder.20040601222649"><vh>run_commands</vh></v>
</v>
</v>
</v>
<v t="bwmulder.20040602221559"><vh>basic_undo_test.py</vh>
<v t="bwmulder.20040602232337"><vh>test_variables</vh></v>
<v t="bwmulder.20040602223236"><vh>imports</vh></v>
<v t="bwmulder.20040602223236.1"><vh>class tracer</vh>
<v t="bwmulder.20040602223236.2"><vh>__getattr__</vh></v>
<v t="bwmulder.20040602223906"><vh>catchall</vh></v>
</v>
<v t="bwmulder.20040602224231"><vh>class delegator</vh>
<v t="bwmulder.20040602224413"><vh>__init__</vh></v>
<v t="bwmulder.20040602224332"><vh>__getattr__</vh></v>
<v t="bwmulder.20040602231914"><vh>catchall</vh></v>
<v t="bwmulder.20040602231934"><vh>enable_category</vh></v>
</v>
<v t="bwmulder.20040602225640"><vh>class basic_scalar_test</vh>
<v t="bwmulder.20040602230124"><vh>test_scalar_basic</vh></v>
<v t="bwmulder.20040604184443"><vh>test_linked_list</vh></v>
</v>
<v t="bwmulder.20040605104941"><vh>class basic_list_test</vh>
<v t="bwmulder.20040605105746"><vh>test_lists_basic</vh></v>
<v t="bwmulder.20040605174728"><vh>test_lists_replace</vh></v>
</v>
<v t="bwmulder.20040605180204"><vh>class basic_dict_test</vh>
<v t="bwmulder.20040605180225"><vh>test_dicts_basic</vh></v>
<v t="bwmulder.20040605180245"><vh>test_dicts_replace</vh></v>
</v>
<v t="bwmulder.20040602230426"><vh>test_main</vh></v>
</v>
</v>
<v t="EKR.20040609091913"><vh>Plugin generalizing marks (mulder)</vh>
<v t="EKR.20040609091913.1"><vh>@url http://home.pacbell.net/bwmulder/python/Leo/mod_label.leo</vh></v>
<v t="EKR.20040609091913.2"><vh>Crash</vh></v>
</v>
<v t="edream.110203113231.982"><vh>Plugin manager (demo)</vh>
<v t="edream.110203113231.984" tnodeList="edream.110203113231.984,edream.110203113231.985,edream.110203113231.986,edream.110203113231.987,edream.110203113231.988,edream.110203113231.989,edream.110203113231.990,edream.110203113231.991,edream.110203113231.992,edream.110203113231.993"><vh>@thin leopm_client.py</vh></v>
<v t="edream.110203113231.994" tnodeList="edream.110203113231.994,edream.110203113231.995,edream.110203113231.995,edream.110203113231.996,edream.110203113231.997,edream.110203113231.998,edream.110203113231.999,edream.110203113231.1000,edream.110203113231.1001"><vh>@thin leopm_server.py</vh></v>
<v t="edream.110203113231.983"><vh>Notes by Paul Paterson</vh></v>
</v>
<v t="ekr.20040717133342"><vh>Shadow files plugin</vh></v>
<v t="edream.110203113231.233"><vh>wxPython plugin (pre-alpha quality)</vh>
<v t="edream.110203113231.234"><vh> Diary</vh>
<v t="edream.111503110300"><vh>11/15/03  Leo becomes usuable (!)</vh></v>
<v t="edream.111403093253"><vh>11/13 &amp; 11/14</vh></v>
<v t="edream.110203113231.235"><vh>10/26 Code works with reorganized core</vh></v>
<v t="edream.110203113231.236"><vh>10/13/03: Added icons (Windows only)</vh></v>
<v t="edream.110203113231.237"><vh>10/12/03: Houston, we have ignition</vh></v>
<v t="edream.110203113231.238"><vh>10/11/03: converted code using c2py, then hand converted code</vh></v>
</v>
<v t="edream.111403093253.1"><vh>Projects</vh>
<v t="edream.110203113231.243"><vh>invoke c2py</vh></v>
<v t="edream.111503111146"><vh>Finished or mostly finished</vh>
<v t="edream.111303205442"><vh>(colorizing) (demo only)</vh>
<v t="edream.111303204025"><vh>Indices</vh>
<v t="edream.111303204025.1"><vh>adjustIndex</vh></v>
<v t="edream.111303204025.2"><vh>compareIndices</vh></v>
<v t="edream.111303204025.3"><vh>convertRowColumnToIndex</vh></v>
<v t="edream.111303204025.4"><vh>convertIndexToRowColumn</vh></v>
<v t="edream.111303204025.5"><vh>getImageIndex</vh></v>
<v t="edream.111403080609"><vh>maxWxIndex (internal use)</vh></v>
</v>
<v t="edream.111303204517"><vh>Color tags (hacks for styles)</vh>
<v t="edream.111403082513"><vh>tkColorToWxColor (internal use)</vh></v>
<v t="edream.111303205611"><vh>tag_add</vh></v>
<v t="edream.111303205611.1"><vh>tag_bind</vh></v>
<v t="edream.111303205611.2"><vh>tag_configure (hack for wxStyles)</vh></v>
<v t="edream.111303205611.3"><vh>tag_delete</vh></v>
<v t="edream.111303205611.4"><vh>tag_remove</vh></v>
</v>
</v>
</v>
<v t="edream.111503111350"><vh>Unfinished</vh>
<v t="edream.111303184347"><vh>(delete_range) doesn't work</vh>
<v t="edream.111303103141.3"><vh>delete_range</vh></v>
</v>
<v t="edream.111303100039"><vh>Gui-dependent commands (to do)</vh>
<v t="edream.111303100039.1"><vh>Edit Menu...</vh>
<v t="edream.111303101257"><vh>abortEditLabelCommand</vh></v>
<v t="edream.111303101257.1"><vh>endEditLabelCommand</vh></v>
<v t="edream.111303100039.6"><vh>insertHeadlineTime</vh></v>
</v>
<v t="edream.111303100039.7"><vh>Window Menu</vh>
<v t="edream.111303100039.8"><vh>cascade</vh></v>
<v t="edream.111303100039.9"><vh>equalSizedPanes</vh></v>
<v t="edream.111303100039.10"><vh>hideLogWindow</vh></v>
<v t="edream.111303100039.11"><vh>minimizeAll</vh></v>
<v t="edream.111303101709"><vh>toggleActivePane</vh></v>
<v t="edream.111303100039.12"><vh>toggleSplitDirection</vh></v>
</v>
<v t="edream.111703103908"><vh>Help Menu...</vh>
<v t="edream.111703103908.2"><vh>leoHelp</vh>
<v t="edream.111703103908.3"><vh>showProgressBar</vh>
<v t="edream.111703103908.4"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="edream.110203113231.242"><vh>Unused code</vh>
<v t="edream.110203113231.257"><vh>updateJoinedHeadlines</vh></v>
<v t="edream.111303202917.1"><vh>Syntax coloring REMOVED: now in base body class</vh></v>
</v>
<v t="edream.110203113231.302"><vh>@thin __wx_gui.py</vh></v>
</v>
</v>
<v t="EKR.20040517075715"><vh>External editors &amp; Open With</vh>
<v t="EKR.20040517080049.4"><vh>@thin open_shell.py</vh></v>
<v t="EKR.20040517075715.4"><vh>@thin open_with.py</vh></v>
<v t="EKR.20040422094618"><vh>@thin startfile.py</vh></v>
<v t="EKR.20040517075715.10"><vh>@thin vim.py</vh></v>
<v t="EKR.20040517075715.12"><vh>@thin xemacs.py</vh></v>
<v t="EKR.20040517075715.13"><vh>Word export</vh>
<v t="EKR.20040517075715.14"><vh>@thin word_export.py</vh></v>
<v t="EKR.20040517075715.20" tnodeList="EKR.20040517075715.20"><vh>@file-nosent word_export.ini</vh></v>
</v>
</v>
<v t="EKR.20040517080049"><vh>Files</vh>
<v t="EKR.20040517080049.1"><vh>@thin empty_leo_file.py</vh></v>
<v t="ekr.20040419105219"><vh>@thin lineNumbers.py</vh></v>
<v t="EKR.20040517075715.1"><vh>@thin mod_tempfname.py</vh></v>
<v t="ekr.20040331151007"><vh>@thin niceNosent.py</vh></v>
</v>
<v t="EKR.20040517080555"><vh>Menus</vh>
<v t="EKR.20040517080555.1"><vh> Plugins menu</vh>
<v t="EKR.20040517080555.2"><vh>@thin plugins_menu.py</vh></v>
<v t="EKR.20040517080555.25"><vh>@thin pluginsTest.py</vh></v>
<v t="EKR.20040517080555.32"><vh>Notes re plugins menu</vh>
<v t="EKR.20040517080555.33"><vh> Changes made by E.K.Ream</vh></v>
<v t="EKR.20040517080555.34"><vh> Design</vh></v>
<v t="EKR.20040517080555.35"><vh> Initial suggestion from Paul Paterson</vh></v>
</v>
</v>
<v t="EKR.20040517080202.3"><vh>@thin french_fm.py</vh></v>
<v t="EKR.20040517080555.36"><vh>@thin scripts_menu.py</vh></v>
</v>
<v t="edream.110203113231.872"><vh>New kinds of nodes</vh>
<v t="edream.110203113231.873"><vh>@thin at_folder.py</vh></v>
<v t="edream.110203113231.876"><vh>@thin read_only_nodes.py</vh></v>
<v t="edream.111803100242"><vh>@thin rst.py</vh></v>
<v t="ekr.20040408161258"><vh>rst2 plugin</vh>
<v t="ekr.20040408192158"><vh>Documentation for the rST plugin using rst</vh>
<v t="ekr.20040408192158.1"><vh>@rst ../doc/rstplugin.html</vh>
<v t="ekr.20040408192158.2"><vh>Overview</vh>
<v t="ekr.20040408192158.3"><vh>@rst</vh></v>
</v>
<v t="ekr.20040408192158.4"><vh>Formatting</vh>
<v t="ekr.20040408192158.5"><vh>@rst</vh></v>
</v>
<v t="ekr.20040409051841"><vh>Embedding documentation in @file trees</vh>
<v t="ekr.20040409051841.1"><vh>@rst</vh></v>
</v>
<v t="ekr.20040408192158.6"><vh>The code-block directive</vh>
<v t="ekr.20040408192158.7"><vh>@rst</vh></v>
</v>
<v t="ekr.20040408192158.8"><vh>Cascading style sheets</vh>
<v t="ekr.20040408192158.9"><vh>@rst</vh></v>
</v>
</v>
</v>
<v t="ekr.20040331071319"><vh>@thin rst2.py</vh></v>
</v>
</v>
</v>
<v t="EKR.20040517090508" a="M"><vh>Enable plugins by changing pluginsManager.txt</vh>
<v t="edream.120603093808"><vh>@thin pluginsManager.txt</vh></v>
</v>
<v t="ekr.20040723182839"><vh>To do</vh>
<v t="ekr.20040722115324"><vh>To do: a configurable pretty printer plugin</vh></v>
<v t="ekr.20040722122834"><vh>To do: reinstall spelling plugin</vh></v>
<v t="ekr.20040722134333.1"><vh>To do: install latest xemacs</vh></v>
</v>
<v t="ekr.20040723171510" a="E"><vh>New tree code</vh>
<v t="ekr.20040725053405"><vh>Ref...</vh>
<v t="ekr.20040723180507.1"><vh> note: editPosition is part of leoTree</vh></v>
<v t="ekr.20040725053107"><vh>Changed, probably bad</vh>
<v t="ekr.20040723173301.8"><vh>tree.select CHANGED,BAD?</vh>
<v t="ekr.20040723173301.9"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="ekr.20040723173301.10"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20040723173301.11"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040723173301.12"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20040723173301.13"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20040723173301.14"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723173301.6"><vh>endEditLabel CHANGED, BAD?</vh></v>
<v t="ekr.20040723173301.5"><vh>editLabel CHANGED, BAD?</vh></v>
</v>
<v t="ekr.20040724141115"><vh>Edit Position...  NEW, PROBABLY BAD</vh>
<v t="ekr.20040724142110.11"><vh>editPosition</vh></v>
<v t="ekr.20040724142110.12"><vh>setEditPosition</vh></v>
</v>
<v t="ekr.20040723173301.15"><vh>set...LabelState... CHANGED: TO BE FOLDED INTO ORIGINAL CODE</vh>
<v t="ekr.20040723180507.2"><vh>setNormalLabelState</vh></v>
<v t="ekr.20040723180507.3"><vh>setDisabledLabelState DISABLED</vh></v>
<v t="ekr.20040723180507.4"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20040723180507.5"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20040723181301"><vh>set...Colors...</vh>
<v t="ekr.20040723173301.17"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20040723173301.16"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20040723173301.18"><vh>setUnselectedHeadlineColors</vh></v>
</v>
</v>
<v t="ekr.20040725053337"><vh>&lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt; ORIGINAL</vh>
<v t="ekr.20040725053337.1"><vh>OnBoxClick</vh></v>
<v t="ekr.20040725053337.2"><vh>OnDrag</vh></v>
<v t="ekr.20040725053337.3"><vh>OnEndDrag</vh></v>
<v t="ekr.20040725053337.4"><vh>OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="ekr.20040725053337.5"><vh>OnHyperLinkControlClick</vh></v>
<v t="ekr.20040725053337.6"><vh>OnHeadlineKey</vh></v>
<v t="ekr.20040725053337.7"><vh>OnHyperLinkEnter</vh></v>
<v t="ekr.20040725053337.8"><vh>OnHyperLinkLeave</vh></v>
<v t="ekr.20040725053337.9"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="ekr.20040725053337.10"><vh>OnIconDoubleClick</vh></v>
</v>
</v>
<v t="ekr.20040725051909"><vh>Bindings...</vh>
<v t="ekr.20040723171712"><vh>__init__</vh>
<v t="ekr.20040723171712.1"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20040725051437"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723102245.2"><vh>createPermanentBindings</vh></v>
<v t="ekr.20040723184305.4"><vh>newText</vh></v>
</v>
<v t="ekr.20040724152715"><vh>Selection woes...</vh>
<v t="ekr.20040723203426"><vh>hideNewlyFreedWidgets</vh>
<v t="ekr.20040725073642"><vh>&lt;&lt; hide all the newly-freed widgets &gt;&gt;</vh></v>
<v t="ekr.20040725073642.1"><vh>&lt;&lt; move all newly-freed widgets to the free lists &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723194802"><vh>recycleWidgets</vh></v>
<v t="ekr.20040724125005"><vh>edit_text</vh></v>
<v t="ekr.20040724102927"><vh>findEditWidget</vh></v>
</v>
<v t="ekr.20040724163004" a="E"><vh>Text...</vh>
<v t="ekr.20040723101121.10" a="TV"><vh>drawText</vh>
<v t="ekr.20040723101121.12"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723184305.4"><vh>newText</vh></v>
<v t="ekr.20040723142845"><vh>Text Box...</vh>
<v t="ekr.20040724083359"><vh>configureTextState</vh></v>
<v t="ekr.20040723104427.5"><vh>onCtontrolT</vh></v>
<v t="ekr.20040723142710.4"><vh>onHeadlineClick</vh></v>
<v t="ekr.20040723142710.6"><vh>onHeadlineKey</vh></v>
<v t="ekr.20040723142710.5"><vh>onHeadlineRightClick</vh></v>
<v t="ekr.20040724100003"><vh>virtual event handlers: called from core</vh>
<v t="ekr.20040723104427.18"><vh>idle_head_key</vh>
<v t="ekr.20040723104427.19"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="ekr.20040723104427.20"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20040723104427.21"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20040723104427.22"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20040723104427.23"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20040723104427.24"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723104427.16"><vh>onHeadChanged</vh></v>
</v>
</v>
</v>
<v t="ekr.20040723100651" tnodeList="ekr.20040723100651,ekr.20040723173301,ekr.20040723173301.1,ekr.20040723101548,ekr.20040724144958,ekr.20040723173301.2,ekr.20040723171712,ekr.20040723171712.1,ekr.20040725051437,ekr.20040723102245.2,ekr.20040724161900,ekr.20040725050101,ekr.20040725050101.1,ekr.20040725050101.6,ekr.20040725050101.8,ekr.20040725050101.9,ekr.20040723173919,ekr.20040723173919.1,ekr.20040723173919.2,ekr.20040723173919.3,ekr.20040723173919.4,ekr.20040723101121.2,ekr.20040723101121.4,ekr.20040723101121.24,ekr.20040724072523,ekr.20040723101121.5,ekr.20040723101121.6,ekr.20040723190945,ekr.20040723101121.7,ekr.20040723101121.8,ekr.20040723101121.9,ekr.20040723101121.10,ekr.20040723101121.12,ekr.20040723101121.13,ekr.20040723101121.15,ekr.20040723102245,ekr.20040723101121.17,ekr.20040723101121.18,ekr.20040723101121.19,ekr.20040723101121.21,ekr.20040723101121.20,ekr.20040723101121.22,ekr.20040723101121.23,ekr.20040723101121.25,ekr.20040723101121.26,ekr.20040723101121.27,ekr.20040723101121.28,ekr.20040723101121.29,ekr.20040723101121.30,ekr.20040723101121.31,ekr.20040723103515,ekr.20040725060102,ekr.20040725055657,ekr.20040723141142,ekr.20040724125005,ekr.20040724102927,ekr.20040723142710.3,ekr.20040723104637,ekr.20040725053607,ekr.20040723142710,ekr.20040723104427.33,ekr.20040723142710.1,ekr.20040723142710.2,ekr.20040723142845,ekr.20040724083359,ekr.20040723104427.5,ekr.20040723142710.4,ekr.20040723142710.6,ekr.20040723142710.5,ekr.20040724100003,ekr.20040723104427.18,ekr.20040723104427.19,ekr.20040723104427.20,ekr.20040723104427.21,ekr.20040723104427.22,ekr.20040723104427.23,ekr.20040723104427.24,ekr.20040723104427.16,ekr.20040723104427.8,ekr.20040723104427.9,ekr.20040723104427.11,ekr.20040723104427.12,ekr.20040723104427.13,ekr.20040723104427.14,ekr.20040723104427.1,ekr.20040723104427.2,ekr.20040723104427.3,ekr.20040723104427.6,ekr.20040723104427.7,ekr.20040723104427.26,ekr.20040723104427.27,ekr.20040723104427.28,ekr.20040723104427.29,ekr.20040723104427.30,ekr.20040723104427.31,ekr.20040723104427.32,ekr.20040723104427.57,ekr.20040723174025,ekr.20040723174025.1,ekr.20040723174025.2,ekr.20040723174025.3,ekr.20040723174025.4,ekr.20040723174025.5,ekr.20040723174025.6,ekr.20040723173301.3,ekr.20040725053107.1,ekr.20040725052914,ekr.20040725052452,ekr.20040725052452.1,ekr.20040725052452.2,ekr.20040725052452.3,ekr.20040725052452.4,ekr.20040725052452.5,ekr.20040725052452.6,ekr.20040725052606,ekr.20040725052606.1,ekr.20040725052606.2,ekr.20040725052606.3,ekr.20040723173301.4,ekr.20040723173301.7,ekr.20040723173301.19,ekr.20040723141518,ekr.20040723141518.1,ekr.20040723141518.2,ekr.20040723141518.3,ekr.20040723141518.4,ekr.20040723141518.5,ekr.20040723141518.6,ekr.20040723141518.8,ekr.20040723183449.1,ekr.20040723184305,ekr.20040724072523.1,ekr.20040723184305.1,ekr.20040723184305.2,ekr.20040723184305.4,ekr.20040723194802,ekr.20040723203426,ekr.20040725073642,ekr.20040725073642.1,ekr.20040725071403,ekr.20040725072304,ekr.20040725074321"><vh>@file __outlineExperiments.py</vh>
<v t="ekr.20040723173301.1"><vh>&lt;&lt; About drawing &gt;&gt;</vh></v>
<v t="ekr.20040723173301"><vh>&lt;&lt; about the tree classes &gt;&gt;</vh></v>
<v t="ekr.20040723101548"><vh>&lt;&lt; drawing constants &gt;&gt;</vh></v>
<v t="ekr.20040724144958"><vh>&lt;&lt; override p.edit_text &gt;&gt;</vh></v>
<v t="ekr.20040723173301.2"><vh>Birth &amp; death</vh>
<v t="ekr.20040723171712"><vh>__init__</vh>
<v t="ekr.20040723171712.1"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20040725051437"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723102245.2"><vh>createPermanentBindings</vh></v>
<v t="ekr.20040724161900"><vh>textRepr</vh></v>
<v t="ekr.20040725050101"><vh>injectCallbacks</vh>
<v t="ekr.20040725050101.1"><vh>&lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;</vh>
<v t="ekr.20040725050101.6"><vh>onHyperLinkControlClick</vh></v>
<v t="ekr.20040725050101.8"><vh>onHyperLinkEnter</vh></v>
<v t="ekr.20040725050101.9"><vh>onHyperLinkLeave</vh></v>
</v>
</v>
</v>
<v t="ekr.20040723173919"><vh>Config &amp; Measuring</vh>
<v t="ekr.20040723173919.1"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
<v t="ekr.20040723173919.2"><vh>headWidth &amp; widthInPixels</vh></v>
<v t="ekr.20040723173919.3"><vh>setLineHeight</vh></v>
<v t="ekr.20040723173919.4"><vh>setTreeColorsFromConfig</vh></v>
</v>
<v t="ekr.20040723101121.2" a="E"><vh>Drawing</vh>
<v t="ekr.20040723101121.4"><vh>drawBox</vh></v>
<v t="ekr.20040723101121.24"><vh>drawClickBox</vh>
<v t="ekr.20040724072523"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723101121.5"><vh>drawIcon</vh>
<v t="ekr.20040723101121.6"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723190945"><vh>drawLine</vh></v>
<v t="ekr.20040723101121.7"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20040723101121.8"><vh>force_draw_node (new)</vh></v>
<v t="ekr.20040723101121.9"><vh>force_draw_node (old)</vh></v>
</v>
<v t="ekr.20040723101121.10"><vh>drawText</vh>
<v t="ekr.20040723101121.12"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723101121.13"><vh>drawTopTree</vh></v>
<v t="ekr.20040723101121.15"><vh>drawTree</vh></v>
<v t="ekr.20040723102245"><vh>Unchanged</vh>
<v t="ekr.20040723101121.17"><vh>drawUserIcon</vh>
<v t="ekr.20040723101121.18"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20040723101121.19"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20040723101121.20"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
<v t="ekr.20040723101121.21"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723101121.22"><vh>drawUserIcons</vh></v>
<v t="ekr.20040723101121.23"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20040723101121.25"><vh>getIconImage</vh></v>
<v t="ekr.20040723101121.26"><vh>idle_scrollTo</vh>
<v t="ekr.20040723101121.27"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20040723101121.28"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723101121.29"><vh>numberOfVisibleNodes</vh></v>
<v t="ekr.20040723101121.30"><vh>scrollTo</vh></v>
<v t="ekr.20040723101121.31"><vh>yoffset</vh></v>
</v>
</v>
<v t="ekr.20040723103515"><vh>Event handlers</vh>
<v t="ekr.20040725060102"><vh>checkWidgetList</vh></v>
<v t="ekr.20040725055657"><vh>dumpWidgetList</vh></v>
<v t="ekr.20040723141142"><vh>eventToPosition</vh></v>
<v t="ekr.20040724125005"><vh>edit_text</vh></v>
<v t="ekr.20040724102927"><vh>findEditWidget</vh></v>
<v t="ekr.20040723142710.3"><vh>Click Box...</vh>
<v t="ekr.20040723104637"><vh>onClickBoxClick</vh></v>
<v t="ekr.20040725053607"><vh>OnBoxClick ORIGINAL</vh></v>
</v>
<v t="ekr.20040723142710"><vh>Icon Box...</vh>
<v t="ekr.20040723104427.33"><vh>onIconBoxClick</vh></v>
<v t="ekr.20040723142710.1"><vh>onIconBoxDoubleClick</vh></v>
<v t="ekr.20040723142710.2"><vh>onIconBoxRightClick</vh></v>
</v>
<v t="ekr.20040723142845"><vh>Text Box...</vh>
<v t="ekr.20040724083359"><vh>configureTextState</vh></v>
<v t="ekr.20040723104427.5"><vh>onCtontrolT</vh></v>
<v t="ekr.20040723142710.4"><vh>onHeadlineClick</vh></v>
<v t="ekr.20040723142710.6"><vh>onHeadlineKey</vh></v>
<v t="ekr.20040723142710.5"><vh>onHeadlineRightClick</vh></v>
<v t="ekr.20040724100003"><vh>virtual event handlers: called from core</vh>
<v t="ekr.20040723104427.18"><vh>idle_head_key</vh>
<v t="ekr.20040723104427.19"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="ekr.20040723104427.20"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20040723104427.21"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20040723104427.22"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20040723104427.23"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="ekr.20040723104427.24"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723104427.16"><vh>onHeadChanged</vh></v>
</v>
</v>
<v t="ekr.20040723104427.8"><vh>Dragging</vh>
<v t="ekr.20040723104427.9"><vh>tree.onContinueDrag</vh>
<v t="ekr.20040723104427.11"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723104427.12"><vh>tree.onDrag</vh></v>
<v t="ekr.20040723104427.13"><vh>tree.onEndDrag</vh>
<v t="ekr.20040723104427.14"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040723104427.1"><vh>Unchanged Event handers</vh>
<v t="ekr.20040723104427.2"><vh>OnActivate</vh>
<v t="ekr.20040723104427.3"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723104427.6"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="ekr.20040723104427.7"><vh>tree.findVnodeWithIconId</vh></v>
<v t="ekr.20040723104427.26"><vh>tree.OnPopup &amp; allies</vh>
<v t="ekr.20040723104427.27"><vh>OnPopupFocusLost</vh></v>
<v t="ekr.20040723104427.28"><vh>createPopupMenu</vh>
<v t="ekr.20040723104427.29"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723104427.30"><vh>enablePopupMenuItems</vh>
<v t="ekr.20040723104427.31"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723104427.32"><vh>showPopupMenu</vh></v>
</v>
<v t="ekr.20040723104427.57"><vh>tree.OnIconClick &amp; OnIconRightClick</vh></v>
</v>
</v>
<v t="ekr.20040723174025"><vh>Incremental drawing</vh>
<v t="ekr.20040723174025.1"><vh>allocateNodes</vh></v>
<v t="ekr.20040723174025.2"><vh>allocateNodesBeforeScrolling</vh></v>
<v t="ekr.20040723174025.3"><vh>updateNode</vh></v>
<v t="ekr.20040723174025.4"><vh>setVisibleAreaToFullCanvas</vh></v>
<v t="ekr.20040723174025.5"><vh>setVisibleArea</vh></v>
<v t="ekr.20040723174025.6"><vh>tree.updateTree</vh></v>
</v>
<v t="ekr.20040723173301.3"><vh>Selecting &amp; editing (tree)</vh>
<v t="ekr.20040725053107.1"><vh>endEditLabel ORIGINAL</vh></v>
<v t="ekr.20040725052914"><vh>editLabel ORIGINAL</vh></v>
<v t="ekr.20040725052452"><vh>tree.select (ORIGINAL)</vh>
<v t="ekr.20040725052452.1"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="ekr.20040725052452.2"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20040725052452.3"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040725052452.4"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20040725052452.5"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20040725052452.6"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20040725052606"><vh>tree.set...LabelState (ORIGINAL)</vh>
<v t="ekr.20040725052606.1"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="ekr.20040725052606.2"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="ekr.20040725052606.3"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723173301.4"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20040723173301.7"><vh>tree.expandAllAncestors</vh></v>
</v>
<v t="ekr.20040723173301.19"><vh>tree.moveUpDown</vh></v>
<v t="ekr.20040723141518"><vh>Updating routines (tree)...</vh>
<v t="ekr.20040723141518.1"><vh>tree.redraw</vh></v>
<v t="ekr.20040723141518.2"><vh>tkTree.redrawAfterException</vh></v>
<v t="ekr.20040723141518.3"><vh>force_redraw</vh></v>
<v t="ekr.20040723141518.4"><vh>redraw_now</vh></v>
<v t="ekr.20040723141518.5"><vh>idle_redraw</vh>
<v t="ekr.20040723141518.6"><vh>&lt;&lt; return if disabled, or quitting or dragging &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723141518.8"><vh>idle_second_redraw</vh></v>
</v>
<v t="ekr.20040723183449.1" a="E"><vh>Widget allocation...</vh>
<v t="ekr.20040723184305"><vh>newBox</vh></v>
<v t="ekr.20040724072523.1"><vh>newClickBox</vh></v>
<v t="ekr.20040723184305.1"><vh>newIcon</vh></v>
<v t="ekr.20040723184305.2"><vh>newLine</vh></v>
<v t="ekr.20040723184305.4"><vh>newText</vh></v>
<v t="ekr.20040723194802"><vh>recycleWidgets</vh></v>
<v t="ekr.20040723203426"><vh>hideNewlyFreedWidgets</vh>
<v t="ekr.20040725073642"><vh>&lt;&lt; hide all the newly-freed widgets &gt;&gt;</vh></v>
<v t="ekr.20040725073642.1"><vh>&lt;&lt; move all newly-freed widgets to the free lists &gt;&gt;</vh></v>
</v>
<v t="ekr.20040725071403"><vh>totalTextWidgets</vh></v>
<v t="ekr.20040725072304"><vh>getTextStats</vh></v>
<v t="ekr.20040725074321"><vh>traceIds</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040517075715"></t>
<t tx="EKR.20040517075715.13"></t>
<t tx="EKR.20040517075715.20">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading

</t>
<t tx="EKR.20040517075915">'''Automatically add nodes for common tasks'''

# We must use @file-noref because data below might look like section references,
# so ORDER IS IMPORTANT throughout this tree (we can't use @others).

#@language python
#@tabwidth -4

__name__ = "New Buttons"
__version__ = "0.2" # Converted to @file-noref by EKR.
 
import leoGlobals as g
import leoPlugins

import leoFind

try: import Tkinter as Tk
except ImportError: Tk = None</t>
<t tx="EKR.20040517075915.1">"""Classes to add helpers to the toolbar 
 
A helper is a class that adds a set of preconfigured nodes to the outline. This 
can be used to generate boiler plate code to quickly build an outline. The nodes 
and body text added can have an adjustable parameter, which is defined from 
the text entry box. 
 
"""

USE_FIXED_SIZES = 1</t>
<t tx="EKR.20040517075915.2">class FlatOptionMenu(Tk.OptionMenu):

    """Flat version of OptionMenu which allows the user to select a value from a menu."""

    def __init__(self, master, variable, value, *values, **kwargs):
        """Construct an optionmenu widget with the parent MASTER, with 
        the resource textvariable set to VARIABLE, the initially selected 
        value VALUE, the other menu values VALUES and an additional 
        keyword argument command.""" 
        kw = {
            "borderwidth": 2, "textvariable": variable,
            "indicatoron": 1, "relief": "flat", "anchor": "c",
            "highlightthickness": 2}
        Tk.Widget.__init__(self, master, "menubutton", kw)
        self.widgetName = 'tk_optionMenu' 
        menu = self.__menu = Tk.Menu(self, name="menu", tearoff=0)
        self.menuname = menu._w
        # 'command' is the only supported keyword 
        callback = kwargs.get('command')
        if kwargs.has_key('command'):
            del kwargs['command']
        if kwargs:
            raise TclError, 'unknown option -'+kwargs.keys()[0]
        menu.add_command(label=value,
            command=Tk._setit(variable, value, callback))
        for v in values:
            menu.add_command(label=v,
                command=Tk._setit(variable, v, callback))
        self["menu"] = menu</t>
<t tx="EKR.20040517075915.3">class Node: 
    """A node to add"""

    def __init__(self, name="", body="", inherit=0, subnodes=None):
        """Initialise the node"""
        self.name = name
        self.body = body
        self.subnodes = subnodes or []
        self.inherit = inherit # Set True to inherit the first line from our immediate sibling 

    def processText(self, text, name):
        """Process some boiler plate text"""
        if name: 
            text = text.replace("XXX", name)
            text = text.replace("xxx", name.lower())
        return text.strip()

    def addTo(self, c, text, parent=None): 
        """Add our nodes etc"""
        if self.inherit:
            header = c.currentVnode().bodyString().split("\n")[0] + "\n"
        else:
            header = ""
        # 
        c.insertHeadline()
        main = c.currentVnode()
        main.setHeadString(self.processText(self.name, text))
        # 
        main.setBodyStringOrPane(self.processText(header+self.body, text))
        if parent: 
            c.currentVnode().moveToNthChildOf(parent, 0) 
        # 
        parent = c.currentVnode()
        for node in self.subnodes:
            node.addTo(c, text, parent)
            parent = None # Only want first node to be moved, others will go automatically </t>
<t tx="EKR.20040517075915.4">class NodeAdder:

    """A Class to add a helper button to the toolbar which adds nodes to the outline""" 

    button_name = "Add"

    nodes = () # Should be set in the subclasses 

    def doIt(self, entry):
        """Create the nodes"""
        c = g.top()
        name = entry.get()
        for node in self.nodes:
            node.addTo(c, name)</t>
<t tx="EKR.20040517075915.5">class Helper:

    """A Class to aid in the creating and maintenance of unit test files"""

    def __init__(self, adders):

        """Initialise with a set of adders"""
    
        self.adders = adders

    def addWidgets(self, tags, keywords):

        """Add the widgets to Leo"""
        self.commander = keywords['c']
        toolbar = self.commander.frame.iconFrame
        # 
        self.frame = Tk.Frame(toolbar)
        self.frame.pack(side="right", padx=2)
        # 
        self.text = Tk.Entry(self._getSizer(self.frame, 24, 130))
        self.text.pack(side="left", padx=3, fill="both", expand=1)
        self.text.bind("&lt;Return&gt;", self.doCallback)
        # 
        self.pseudobutton = Tk.Frame(self._getSizer(self.frame, 24, 142), relief="raised", borderwidth=2) 
        self.pseudobutton.pack(side="right")
        # 
        self.doit = Tk.Button(self._getSizer(self.pseudobutton, 25, 32), text="New", relief="flat", command=self.doCallback)
        self.doit.pack(side="left")
        # 
        options = [adder.button_name for adder in self.adders]
        self.option_value = Tk.StringVar()
        self.options = FlatOptionMenu(self._getSizer(self.pseudobutton, 29, 110), self.option_value, *options)
        self.option_value.set(options[0])
        self.options.pack(side="right", fill="both", expand=1)
        
    def _getSizer(self, parent, height, width, pack="left"):
    
        """Return a sizer object to force a Tk widget to be the right size"""
    
        if USE_FIXED_SIZES:
            sizer = Tk.Frame(parent, height=height, width=width)
            sizer.pack_propagate(0) # don't shrink 
            sizer.pack(side=pack)
            return sizer
        else:
            return parent
            
    def doCallback(self, event=None):

        """Generate a callback to call the specific adder"""
        for adder in self.adders:
            if adder.button_name == self.option_value.get():
                adder.doIt(self.text)
                break
        else:
            raise ValueError("Button name not found: '%s'" % self.option_value.get())</t>
<t tx="EKR.20040517075915.6"># Modify these classes or data as you like to create templates that suit you.</t>
<t tx="EKR.20040517075915.7">TEST_NODE_BODY = '''
import unittest

@others

if __name__ == "__main__":
    unittest.main()
'''

TEST_CLASS_BODY = '''
class TestXXX(unittest.TestCase):

    """Tests for the XXX class"""

    @others
'''

TEST_SETUP_BODY = '''
def setUp(self):

    """Create the test fixture"""

'''</t>
<t tx="EKR.20040517075915.8">class AddTestModule(NodeAdder):

    """Add unit testing node"""

    button_name = "test module"

    nodes = [
        Node(
            name="testxxx.py",
            body=TEST_NODE_BODY,
            subnodes=[ 
                Node(
                    name="TestXXX",
                    body=TEST_CLASS_BODY,
                    subnodes=[ 
                        Node(name="setUp",
                        body=TEST_SETUP_BODY)])])]</t>
<t tx="EKR.20040517075915.9">class AddTestClass(NodeAdder):

    """Add unit testing class"""

    button_name = "test class"

    nodes = [
        Node(
            name="TestXXX",
            body=TEST_CLASS_BODY,
            subnodes=[
                Node(
                    name="setUp",
                    body=TEST_SETUP_BODY)])]</t>
<t tx="EKR.20040517075915.10">TEST_METHOD_BODY = '''
def testXXX(self):

    """testXXX: TestDescriptionGoesHere"""

'''

class AddTestMethod(NodeAdder):

    """Add unit testing method"""

    button_name = "test method"

    nodes = [
    Node(
        name="testXXX",
        body=TEST_METHOD_BODY,
        inherit=0)] # EKR: was 1.</t>
<t tx="EKR.20040517075915.11">NEW_CLASS_BODY = '''
class XXX:

    """DocStringGoesHere"""

    @others
'''

NEW_INIT_BODY = '''
def __init__(self):

    """Initialise the XXX instance"""

'''

class AddClass(NodeAdder):
    
    """Add new class"""

    button_name = "class"

    nodes = [
        Node(
            name="class XXX",
            body=NEW_CLASS_BODY,
            subnodes=[
                #Node(
                #	name="&lt;&lt; class XXX declarations &gt;&gt;",
                #	body="@c\npass"),
                Node(
                    name="__init__",
                    body=NEW_INIT_BODY)] )]
</t>
<t tx="EKR.20040517075915.12">CLASS_METHOD_BODY = '''
def XXX(self):

    """MethodDocstringGoesHere"""

'''

class AddClassMethod(NodeAdder):

    """Add class method"""

    button_name = "method"

    nodes = [
        Node(
            name="XXX",
            body=CLASS_METHOD_BODY,
            inherit=0)] # EKR: was 1.</t>
<t tx="EKR.20040517075915.13">if Tk:

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":
    
        g.es("Activating newButtons", color="orange")

        buttonList = [
            AddTestModule(),AddTestClass(),
            AddTestMethod(),AddClass(),AddClassMethod()]
    
        helper = Helper(buttonList)

        leoPlugins.registerHandler("after-create-leo-frame", helper.addWidgets)
        g.plugin_signon("newButtons")</t>
<t tx="EKR.20040517080049"></t>
<t tx="EKR.20040517080250"></t>
<t tx="EKR.20040517080555"></t>
<t tx="EKR.20040517080555.1"></t>
<t tx="EKR.20040517080555.32">@nocolor</t>
<t tx="EKR.20040517080555.33">Reorganized the code so I can find various classes more easily.
Used @others to simply the outline.

Sorted all entries in dialogs.
Sorted all entries in Plugins menu, regardless of whether they are configurable.

For all dialogs:
    Added top ivar and removed root/master params and ivars.
    Added Leo icon and title.
    Centered dialogs.

Ctors now run all dialogs as modal dialogs: this could easily be undone.

Used a grid in the properties dialog to align widgets.</t>
<t tx="EKR.20040517080555.34">- We will use a new settings file called leoSettings.txt:
- Each setting will have its _own section_ in leoSettings.txt with the following items (most optional)
    val = present value of settings: Use parent setting if this does not exist.
    help = help string (displayed near setting if it exists)
    prompt = prompt string (defaults to setting name, i.e., the section name)
    group = name of group dialog containing this item (use general section if this does not exist)
    type = one of the following:
        value			meaning
        bool			followed by True/False prompts for radio buttons
        color			color picker
        font			font picker
        parent			name of parent config file (set/get setting in that file)
        entry			followed by arbitrary text in an entry widget
        text			followed by arbitrary text in a text widget
        number			any number, or followed by a range of valid values for an entry widget.
        numberlist  followed by a list valid values for a listbox.
        list			followed by a list of valid strings in a listbox.
Notes:
- We could use yaml or ConfigParser or Pickle.  yaml might be best.
- The options dialog will have a separate frame for each group or subgroup.
- We will want a Create Options file command (useful for converting old leoConfig.txt files)
- All options may have a use parent settings (for all widgets?)
- The separate "Groups" section may indicate which groups are subgroups of other groups for multi-level displays.</t>
<t tx="EKR.20040517080555.35">I wrote myself a plug-in which would automatically save the Leo file every so often and in doing so realized that it would be useful to be able to configure the interval between saves. Anyway, to cut a long story short, I generalized the idea and came up with the attached patch. 
 
All code resides under the "Plug in changes" node. The additions are all under the "create the plug-in menu" node with another couple of lines in "createMenuBar". Structurally this is ugly - but it helps keep all the changes in one place!
 
The basic idea is to allow plug-ins to be configured and also allow them to expose additional functions which can be accessed by a menu item. The advantage is that people don't have to mess with adding menus to Leo. Existing plug-ins don't need to be changed in any way to work with the new patch.
 
Ok, here's what it does	
 
1. A new "Plug-ins" menu item is added
 
2. Each plug-in gets an "About x	" entry.
 
    - clicking on "About x..." brings up an about box which shows name, version and documentation for the plug in
    - name comes from the module name
    - version is the module __version__ if present
    - documentation is the module docstring 
 
3. If the plug-in is configurable then a sub menu is created
 
    - configurable means that a corresponding ".ini" file is found with the same names as the plug-in (ie mod_image.py has mod_image.ini)
    - the sub menu contains
        - the "About x..." as before
        - a "Properties..." menu entry to edit the properties (*)
 
4. A further search is made for plug-in specific commands
 
    - we look for functions called "cmd_*" in the module
    - if found we add them to the plug-in menu
    - when you click on the menu item the function is called with a single parameter
 
(*) How does the property window work,
 
5. The property window reads the ini file which is assumed to be in standard ini file format (ie sections and parameters)
    - each section gets a frame in the window
    - each property gets an entry box
 
6. From the property window the user can "Cancel" or "OK", which saves changes
 
7. If the module contains an "applyConfiguration" function then there is also an "Apply" button on the form. The apply configuration function is called with the current configuration when the "Apply" button is pressed.
</t>
<t tx="EKR.20040517090508">@nocolor

Leo enables only those plugins whose filenames appear in PluginsManager.txt.

@color</t>
<t tx="EKR.20040605181725"></t>
<t tx="EKR.20040605181725.1">@nocolor

New in this version:

- Alt-Up, Alt-Down scroll the Autobox.
- Captialization and _ do not unsummon Autobox
- Ctrl now unsummons calltip box.GetSelection.</t>
<t tx="EKR.20040608070256">The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.</t>
<t tx="EKR.20040608070256.1">The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word(     ) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.</t>
<t tx="EKR.20040609091913"></t>
<t tx="EKR.20040609091913.1"></t>
<t tx="EKR.20040609091913.2">@nocolor

getUnknownTag: labels &lt;long string&gt;

exceptions opening: C:\Documents and Settings\default\Desktop\mod_label.leo
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 670, in openWithFileName
    frame.c.fileCommands.open(file,fileName) # closes file.
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 1121, in open
    ok, ratio = self.getLeoFile(fileName,atFileNodesFlag=True)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 525, in getLeoFile
    self.getVnodes()
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 927, in getVnodes
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 864, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 833, in getVnode
    v,skip = self.createVnode(parent,back,tref,headline,attrDict)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 145, in createVnode
    p.v.unknownAttributes = attrDict
NameError: global name 'p' is not defined</t>
<t tx="EKR.20040611044600"></t>
<t tx="bwmulder.20040601212737">"""
Define a general purpose monitor module.

Can be used for classes derived from "object" to intercept assignment to instance attributes.

For lists and dictionaries, it also offers drop-in replacements which monitor all changes to those list and mappings.

This module also includes a basic undo / redo mechanism.

For this undo / redo mechanism, it is important that the undo / redo steps do not trigger any monitoring calls. 
This module should fullfill that requirement.

For scalars, we put "scalar_monitor" into the attribute slot to intercept accesses to the attribute. The values
themselves live in a differnt, "private" attribute. These private attributes are accessed directly for the
undo / redo steps.

For dictionaries and lists, we extend the base types. The undo / redo mechanism 
uses the methods of the basic type.

If you assign a list or a dictionary to a monitored attribute, the list or mapping is automatically converted to
a monitored list or mapping (but only one level deep).

[Question: do we need a convenience function which does this recursively?]
"""

@language python
@tabwidth -4

@others
</t>
<t tx="bwmulder.20040601212737.1">class passthrough(object):
	"""
	Instances of this class are used to disable monitoring.
	The values are just passed through.
	"""
	@others

</t>
<t tx="bwmulder.20040601212737.2">def __init__(self, private_attributename):
   self.private_attributename = private_attributename
</t>
<t tx="bwmulder.20040601212737.3">def __set__( self, instance, value):
   setattr(instance, self.private_attributename, value)
</t>
<t tx="bwmulder.20040601212737.4">def __get__(self, instance, owner):
   return getattr(instance, self.private_attributename)
</t>
<t tx="bwmulder.20040601212737.5">   
class scalar_monitor(object):
	"""
   Monitor a scalar attribute.
   A scalar attribute is an attribute whose values do not have internal structure.
   Used for Integers and references.
	"""
	@others
</t>
<t tx="bwmulder.20040601212737.6">def __init__(self, external_attributename, monitor_object):
	self.external_attributename = external_attributename
	self.private_attributename = '__' + external_attributename
	self.monitor_object = monitor_object
</t>
<t tx="bwmulder.20040601212737.7">def __set__( self, instance, value):
	private_attributename = self.private_attributename
	external_attributename = self.external_attributename
	try:
		oldvalue = getattr(instance, private_attributename)
	except AttributeError:
		self.monitor_object.scalar_set(instance, private_attributename, external_attributename)
	else:
		if oldvalue != value:
			self.monitor_object.scalar_modify(instance, private_attributename, external_attributename, oldvalue)
	setattr(instance, private_attributename, value)

</t>
<t tx="bwmulder.20040601212737.8">def __get__(self, instance, owner):
   return getattr(instance, self.private_attributename)

</t>
<t tx="bwmulder.20040601212737.9">class list_monitor(list):
	"""
	Monitor changes to a list.
	
	Calls a "monitor_object" whenever changes are made to a list.
	
	You can use this class whenever you want to track changes to a list.
	"""
	@others
</t>
<t tx="bwmulder.20040601212737.10">def set_monitor_object(self, monitor_object):
	"""
	All changes to this list will trigger calls to monitor_object methods
	"""
	self.monitor_object = monitor_object

</t>
<t tx="bwmulder.20040601212737.11">def __setitem__( self, key, value):
	"""
	Intercept the l[key]=value operations.
	Also covers slice assignment.
	"""
	try:
		oldvalue = self.__getitem__(key)
	except KeyError:
		self.monitor_object.list_create(self, key)
	else:
		self.monitor_object.list_set(self, key, oldvalue)
	list.__setitem__(self, key, value)
</t>
<t tx="bwmulder.20040601212737.12">def __delitem__( self, key):
   oldvalue = list.__getitem__(self, key)
   self.monitor_object.list_del(self, key, oldvalue)
   list.__delitem__(self, key)
</t>
<t tx="bwmulder.20040601212737.13">def append(self, value):
   self.monitor_object.list_append(self)
   list.append(self, value)


</t>
<t tx="bwmulder.20040601212737.14">class list_monitor_in_instance(object):
	"""
	Monitor instance attributes which contain a list as a value.

	Assignments to this attributes, which must be lists, are replaced by instances of 'list_monitor'.
   """
	@others
</t>
<t tx="bwmulder.20040601212737.15">def __init__(self, external_attributename, monitor_object):
	self.external_attributename = external_attributename
	self.internal_attributename = '__' + external_attributename
	self.monitor_object = monitor_object
</t>
<t tx="bwmulder.20040601212737.16">def __set__(self, instance, value):
	"""Intercept assignments to the external attribute"""
	assert isinstance(value, type([]))
	if isinstance(value, list_monitor):
		newvalue = value
		# if the value is already a list monitor, assume that this value
		# is already monitored. Do not create a new value.
	else:
		newvalue = list_monitor(value, self.monitor_object)
	internal_attributename = self.internal_attributename
	try:
		oldvalue = getattr(instance, internal_attributename)
	except AttributeError:
		self.monitor_object.list_assignment_new(instance, internal_attributename)
	else:
		self.monitor_object.list_assignment_replace(instance, internal_attributename, oldvalue)
	setattr(instance, self.internal_attributename, newvalue)

</t>
<t tx="bwmulder.20040601212737.17">def __get__(self, instance, owner):
   try:
      return instance.__dict__[self.internal_attributename]
   except KeyError: 
      return instance.__dict__[self.external_attributename]

</t>
<t tx="bwmulder.20040601212737.18">class monitor:
	"""
   Monitor changes to (new style) classes.

   To use:
      1. 
			a) Call monitor_scalar(klass, external_attributename, internal_attributename)
         			for each scalar attribute you want to monitor.

				A scalar attribute is an attribute without internal structure (int and reference).

 				The normal Python comparison operation (=) is used to check if a new value is stored
				in an instance attribute.
				
			b) Call monitor_list(klass, external_attributename, internal_attributename) for each
			   list attribute you want to monitor.
				
		   c) Call monitor_dict(klass, external_attributename, internal_attributename) for each
			   dict attribute you want to monitor.
         
      2. 
		    Call enable / disable to enable / disable monitoring.

   This is an abstract class.
   
   Concrete subclasses are the classes "tracer" and "basic_undomechanism". The latter does most
   (almost all) of the work of a (fairly) general undo mechanism.

   Limitations:
   
      Assumes that instance attributes are used consistently with certain types.
      
   """
	@others
</t>
<t tx="bwmulder.20040601212737.19">def __init__(self):
   self.monitored_scalar_attributes = []
   self.monitored_list_attributes = []
   self.monitored_dict_attributes = []
   self.removed_functions = []
   
   self.monitor_object = self
   # See enable_category.
   
   # Overwriting this one attribute allows
   # Clients of this module to implemente tracing of all
   # calls to this module.
   
</t>
<t tx="bwmulder.20040601212737.20">def monitor_scalar(self, klass, external_attributename):
   """
   Put in a hook so that we can monitor modications to instances of classref'
   with respect to the attribute "attributename".

   It is assumed that the attribute only contains scalar objects. A scalar
   object is an object which is unstructured, and not shared.
   """
   self.monitored_scalar_attributes.append(
      (klass, external_attributename))
</t>
<t tx="bwmulder.20040601212737.21">def monitor_list_attribute_in_class(self, klass, external_attributename):
   self.monitored_list_attributes.append(
      (klass, external_attributename))
</t>
<t tx="bwmulder.20040601212737.22">def enable(self):
	for l, klass in ((self.monitored_scalar_attributes, scalar_monitor),
			 (self.monitored_list_attributes, list_monitor_in_instance),
			 (self.monitored_dict_attributes, dict_monitor_in_instance)):
		self.enable_category(l, klass)
		
	self.enable_put_in_removed_functions()
	

</t>
<t tx="bwmulder.20040601212737.23">def disable(self):
	"""
	Disable monitoring (temporarily).
	"""
	for l, klass in ((self.monitored_scalar_attributes, scalar_monitor),
					 (self.monitored_list_attributes, list_monitor_in_instance),
					 (self.monitored_dict_attributes, dict_monitor_in_instance)):
		self.disable_category(l, klass)
	
	self.remove_overrides_in_list_and_dict_monitor()
	
</t>
<t tx="bwmulder.20040601212737.24">def scalar_set(self, instance, private_attributename, external_attributename):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.25">def scalar_modify(self, instance, private_attributename, external_attributename, oldvalue):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.26">def list_create(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.27">def list_set(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.28">def list_del(self, array, key, oldvalue):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.29">def list_append(self, array, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601214251"></t>
<t tx="bwmulder.20040601215339"></t>
<t tx="bwmulder.20040601215339.1">@doc
Delayed activation of the monitor mechanism is probably useful.

Not clear of switching off and on is useful, though.</t>
<t tx="bwmulder.20040601222230">class basic_undomechanism(monitor):
	"""
	This class provides the basic operations for undoable operations.
	
	Records a list of changes which it will undone or redone one by one.
	
	The granularity of the undo / redo operations is determined by calls to
	the 'mark' procedure. Only immediately after the 'mark' call can undo be called.
	Redo can only be called after calling undo.
	
	'rollback' is a special case of undo: it is not redoable. The envisioned usage of
	this facility is in error recovery: if a command does not go through, you can call
	this command to undo all your changes (and leave the application in a consistent state).
	
	Use the monitor_scalar, monitor_list_attribute_in_class and monitor_dict_attribute_in_class
	methods to make assignment to instance variables undoable.
	
	Call 'enable' to activate the undo mechanism, 'disable' to temporarily
	stop the undo mechanism from collecting information about changes.
	
	The individual changes are bundled into "_commands'. The boundaries of
	these _commands are marked by a call to the procedure "mark".
	
	The procedure 'reset' can be called externally to erase all undo information.
	
	Individual lists and dictionaries can also be monitored for change with the
	list_monitor and dict_monitor classes.
	
	Possible optimizations later: special handling for string attributes.
	"""
	@others</t>
<t tx="bwmulder.20040601222230.1">def __init__(self):
	monitor.__init__(self)
	self.reset()
	</t>
<t tx="bwmulder.20040601222230.2"></t>
<t tx="bwmulder.20040601222230.3">def scalar_set(self, instance, private_attributename, external_attributename):
   self._steps.append((self.scalar_set_undo, (instance, private_attributename)))
	

</t>
<t tx="bwmulder.20040601222230.4">def scalar_set_undo(self, instance, private_attributename):
	"""Undo the changes done by the assignment of an instance"""
	newvalue = getattr(instance, private_attributename)
	delattr(instance, private_attributename)
	return self.scalar_set_redo, (instance, private_attributename, newvalue)
</t>
<t tx="bwmulder.20040601222230.5">def scalar_set_redo(self, instance, private_attributename, newvalue):
	setattr(instance, private_attributename, newvalue)
	return self.scalar_set_undo, (instance, private_attributename)
</t>
<t tx="bwmulder.20040601222230.6">def scalar_modify(self, instance, private_attributename, external_attributename, oldvalue):
  self._steps.append((self.scalar_modify_undo, (instance, private_attributename, oldvalue)))
</t>
<t tx="bwmulder.20040601222431">def scalar_modify_undo(self, instance, private_attributename, oldvalue):
	new_value = getattr(instance, private_attributename)
	setattr(instance, private_attributename, oldvalue)
	return self.scalar_modify_undo, (instance, private_attributename, new_value)</t>
<t tx="bwmulder.20040601222649">def run_commands(self, steps):
	"""
	Run the undo / redo _steps.
	Returns the list of steps to redo / undo the steps just made.
	"""
	steps.reverse()
	return [func(*args) for func, args in steps]
</t>
<t tx="bwmulder.20040601224447"></t>
<t tx="bwmulder.20040601224447.2">def mark(self):
	"""
	The current commmand ends.
	"""
	if self._steps:
		self._commands[self._index+1:] = [self._steps, None]
		self._index += 1
		self._steps = []</t>
<t tx="bwmulder.20040601224447.3">def undo(self):
	assert self.canUndo()
	self._commands[self._index] = self.run_commands(self._commands[self._index])
	self._index -= 1
	
</t>
<t tx="bwmulder.20040601224447.4">def redo(self):
	assert self.canRedo()
	self._commands[self._index+1] = self.run_commands(self._commands[self._index+1])
	self._index += 1</t>
<t tx="bwmulder.20040601224447.5">def canUndo(self):
	return self._commands[self._index] is not None and len(self._steps) == 0</t>
<t tx="bwmulder.20040601224447.6">def canRedo(self):
	return self._commands[self._index+1] is not None and len(self._steps) == 0</t>
<t tx="bwmulder.20040602075341"></t>
<t tx="bwmulder.20040602075341.1">def list_create(self, array, key):
	self._steps.append((self.list_create_undo, (array, key)))

</t>
<t tx="bwmulder.20040602084701.1"></t>
<t tx="bwmulder.20040602084701.2">def list_create_undo(self, array, key):
	value = list.__getitem__(array, key)
	list.__delitem__(array, key)
	return self.list_create_redo, (array, key, value)

</t>
<t tx="bwmulder.20040602084701.3">def list_create_redo(self, array, key, value):
	list.__setitem__(array, key, value)
	return self.list_create_undo, (array, key)</t>
<t tx="bwmulder.20040602084701.4"></t>
<t tx="bwmulder.20040602085955">def list_set(self, array, key, oldvalue):
	self._steps.append((self.list_set_undo, (array, key, oldvalue)))

</t>
<t tx="bwmulder.20040602085955.1">def list_set_undo(self, array, key, value):
	oldvalue = list.__getitem__(array, key)
	list.__setitem__(array, key, value)
	return self.list_set_undo, (array, key, oldvalue)
</t>
<t tx="bwmulder.20040602085955.2"></t>
<t tx="bwmulder.20040602085955.3">def list_del(self, array, key, oldvalue):
   self._steps.append((self.list_del_undo, (array, key, oldvalue)))
   
</t>
<t tx="bwmulder.20040602085955.4">def list_del_undo(self, array, key, oldvalue):
	if type(key) == type(1):
		list.__setitem__(array, slice(key, key), [oldvalue])
	else:
		list.__setitem__(array, key, oldvalue)
	return self.list_del_redo, (array, key, oldvalue)
</t>
<t tx="bwmulder.20040602085955.5">def list_del_redo(self, array, key, oldvalue):
	oldvalue = list.__getitem__(array, key)
	list.__delitem__(array, key)
	return self.list_del_undo, (array, key, oldvalue)
</t>
<t tx="bwmulder.20040602151709"></t>
<t tx="bwmulder.20040602152051">def list_append(self, array):
	self._steps.append((self.list_append_undo, (array,)))
	


</t>
<t tx="bwmulder.20040602152051.1">def list_append_undo(self, array):
	oldvalue = list.pop(array)
	return self.list_append_redo, (array, oldvalue)
</t>
<t tx="bwmulder.20040602152051.2">def list_append_redo(self, array, oldvalue):
	list.append(array, oldvalue)
	return self.list_append_undo, (array,)</t>
<t tx="bwmulder.20040602152548">def pop(self):
	oldvalue = list.pop(self)
	self.monitor_object.list_pop(self, oldvalue)
</t>
<t tx="bwmulder.20040602152548.1"></t>
<t tx="bwmulder.20040602152548.2">def list_pop(self, array, oldvalue):
	self._steps.append((self.list_append_redo, (array, oldvalue)))
</t>
<t tx="bwmulder.20040602153618">class dict_monitor(dict):
	"""
	Overwrite dictionaries so that we can monitor them.
	"""
	@others
</t>
<t tx="bwmulder.20040602153642">def set_monitor_object(self, monitor_object):
	"""
	All changes to this dictionary will trigger calls to monitor_object methods
	"""
	self.monitor_object = monitor_object

</t>
<t tx="bwmulder.20040602153723">def __setitem__( self, key, value):
	"""
	Intercept the l[key]=value operations.
	Also covers slice assignment.
	"""
	try:
		oldvalue = self.__getitem__(key)
	except KeyError:
		self.monitor_object.dict_create(self, key, value)
	else:
		self.monitor_object.dict_set(self, key, oldvalue)
	dict.__setitem__(self, key, value)
</t>
<t tx="bwmulder.20040602153835">def __delitem__( self, key):
   oldvalue = dict.__getitem__(self, key)
   self.monitor_object.dict_del(self, key, oldvalue)
   dict.__delitem__(self, key)
</t>
<t tx="bwmulder.20040602154259">class dict_monitor_in_instance(object):
	"""
	Monitor instance attributes which contain a list as a value.

	Assignments to this attributes, which must be lists, are replaced by instances of 'list_monitor'.
   """
	@others
</t>
<t tx="bwmulder.20040602154259.1">def __init__(self, external_attributename, monitor_object):
	self.external_attributename = external_attributename
	self.internal_attributename = '__' + external_attributename
	self.monitor_object = monitor_object
</t>
<t tx="bwmulder.20040602154259.2">def __set__(self, instance, value):
	"""Intercept assignments to the external attribute"""
	assert isinstance(value, type({}))
	if isinstance(value, dict_monitor):
		newvalue = value
		# if the value is already a dict_monitor,
		# assume that the value is already monitored.
	else:
		newvalue = dict_monitor(value, self.monitor_object)
	internal_attributename = self.internal_attributename
	try:
		oldvalue = getattr(instance, internal_attributename)
	except AttributeError:
		self.monitor_object.list_assignment_new(instance, internal_attributename)
	else:
		self.monitor_object.list_assignment_replace(instance, internal_attributename, oldvalue)
	setattr(instance, self.internal_attributename, newvalue)
</t>
<t tx="bwmulder.20040602154259.3">def __get__(self, instance, owner):
   try:
      return instance.__dict__[self.internal_attributename]
   except KeyError: 
      return instance.__dict__[self.external_attributename]

</t>
<t tx="bwmulder.20040602154259.4">def enable_category(self, l, monitor_class):
   for klass, external_attributename in l:
      setattr(klass, external_attributename, monitor_class(
         external_attributename, self.monitor_object))
	</t>
<t tx="bwmulder.20040602161525">def disable_category(self, l, monitor_class):
   for klass, external_attributename in l:
      setattr(klass, external_attributename, passthrough (internal_attributename))
	
</t>
<t tx="bwmulder.20040602164627">def enable_put_in_removed_functions(self):
	"""
	Reinstate the functions which were removed from list_monitor and dict_monitor.
	"""
	for klass, attribute, function in self.removed_functions:
		setattr(klass, attribute, function)
</t>
<t tx="bwmulder.20040602165344"></t>
<t tx="bwmulder.20040602165402">def monitor_dict_attribute_in_class(self, klass, external_attributename):
   self.monitored_dict_attributes.append(
      (klass, external_attributename))
</t>
<t tx="bwmulder.20040602165506">def dict_create(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040602165513">def dict_set(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040602165553">def dict_del(self, array, key, oldvalue):
   raise notImplementedError
</t>
<t tx="bwmulder.20040602171032"></t>
<t tx="bwmulder.20040602171032.1"></t>
<t tx="bwmulder.20040602171032.2">def dict_create(self, dictionary, key, value):
	self._steps.append((self.dict_create_undo, (dictionary, key)))

</t>
<t tx="bwmulder.20040602171032.3">def dict_create_undo(self, dictionary, key):
	value = dict.__getitem__(dictionary, key)
	dict.__delitem__(dictionary, key)
	return self.dict_create_redo, (dictionary, key, value)

</t>
<t tx="bwmulder.20040602171032.4">def dict_create_redo(self, dictionary, key, value):
	dict.__setitem__(dictionary, key, value)
	return self.dict_create_undo, (dictionary, key,)
</t>
<t tx="bwmulder.20040602171032.5"></t>
<t tx="bwmulder.20040602171032.6">def dict_set(self, dictionary, key, oldvalue):
	self._steps.append((self.dict_set_undo, (dictionary, key, oldvalue)))

</t>
<t tx="bwmulder.20040602171032.7">def dict_set_undo(self, dictionary, key, value):
	oldvalue = dict.__getitem__(dictionary, key)
	dict.__setitem__(dictionary, key, value)
	return self.dict_set_undo, (dictionary, key, oldvalue)
</t>
<t tx="bwmulder.20040602171032.8"></t>
<t tx="bwmulder.20040602171032.9">def dict_del(self, dictionary, key, oldvalue):
   self._steps.append((self.dict_del_undo, (dictionary, key, oldvalue)))
   
</t>
<t tx="bwmulder.20040602171032.10">def dict_del_undo(self, dictionary, key, oldvalue ):
	dict.__setitem__(dictionary, key, oldvalue)
	return self.dict_del_redo, (dictionary, key, oldvalue)
</t>
<t tx="bwmulder.20040602171032.11">def dict_del_redo(self, dictionary, key, oldvalue ):
	oldvalue = dict.__getitem__(dictionary, key)
	dict.__delitem__(dictionary, key)
	return self.dict_del_undo, (dictionary, key, oldvalue)
</t>
<t tx="bwmulder.20040602171606">def reset(self):
	self._steps = []
	self._commands = [None, None]
	self._index = 0
	


</t>
<t tx="bwmulder.20040602175523">def list_assignment_replace(self, instance, attributename, oldvalue):
	self._steps.append((self.list_assignment_replace_undo, (instance, attributename, oldvalue)))</t>
<t tx="bwmulder.20040602175523.1">def list_assignment_replace_undo(self, instance, attributename, oldvalue):
	newvalue = getattr(instance, attributename)
	setattr(instance, attributename, oldvalue)
	return self.list_assignment_replace_redo, (instance, attributename, newvalue)</t>
<t tx="bwmulder.20040602175740">def list_assignment_replace_redo(self, instance, attributename, newvalue):
	oldvalue = getattr(instance, attributename)
	setattr(instance, attributename, newvalue)
	return self.list_assignment_replace_undo, (instance, attributename, oldvalue)
</t>
<t tx="bwmulder.20040602175801"># Dictionary monitors are are really handled like
# list monitors.
# For now, just use the same methods.
dict_assignment_new = list_assignment_new
dict_assignment_new_undo = list_assignment_new_undo
dict_assignment_new_redo = list_assignment_new_redo

dict_assignment_replace      = list_assignment_replace
dict_assignment_replace_undo = list_assignment_replace_undo
dict_assignment_replace_redo = list_assignment_replace_redo</t>
<t tx="bwmulder.20040602183806">def list_assignment_new(self, instance, attributename):
	self._steps.append((self.list_assignment_new_undo, (instance, attributename)))</t>
<t tx="bwmulder.20040602183814">def list_assignment_new_undo(self, instance, attributename):
	newvalue = getattr(instance, attributename)
	delattr(instance, attributename)
	return self.list_assignment_new_redo, (instance, attributename, newvalue)</t>
<t tx="bwmulder.20040602183911">def list_assignment_new_redo(self, instance, attributename, newvalue):
	setattr(instance, attributename, newvalue)
	return self.list_assignment_new_undo, (instance, attributename)
</t>
<t tx="bwmulder.20040602221559">@others</t>
<t tx="bwmulder.20040602223236">from basic_undo import monitor, basic_undomechanism, list_monitor, dict_monitor
import unittest
from test import test_support
</t>
<t tx="bwmulder.20040602223236.1">class tracer(monitor):
	"""
	Simple class which can be used to trace all calls made from a monitor.
	
	The output format could be improved, but this is only for testing.
	"""
	@others

</t>
<t tx="bwmulder.20040602223236.2">def __getattr__(self, attributename):
	self.attributename = attributename
	return self.catchall</t>
<t tx="bwmulder.20040602223906">def catchall(self, *args, **kwrds):
	print "Tracer:", self.attributename, ":", args, kwds</t>
<t tx="bwmulder.20040602224231">class delegator(object):
	"""
	Simple class to print all arguments passed to a monitor.
	Allows you to watch the undoer in action...
	"""
	@others</t>
<t tx="bwmulder.20040602224332">def __getattr__(self, attributename):
	self.attributename = attributename
	return self.catchall</t>
<t tx="bwmulder.20040602224413">def __init__(self):
	self.undoer = basic_undomechanism()
	self.undoer.monitor_object = self
	
</t>
<t tx="bwmulder.20040602225640">class basic_scalar_test_class(object):
	"""Simple class for the basic_scalar_test"""
	pass

class basic_scalar_test(unittest.TestCase):
	@others</t>
<t tx="bwmulder.20040602230124">def test_scalar_basic(self):
	"""
	Some basic testing for the scalar undoer.
	"""
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()
	m.monitor_scalar(basic_scalar_test_class, "x")
	m.enable()
	# command 1
	c = basic_scalar_test_class()
	c.x = "First value"
	m.mark()
	# command 2	
	c.x = "second value"
	m.mark()
	# command 3
	c.x = "third value"
	m.mark()
	# command 4
	# Check that the second assignment can be undone
	assert c.x == "third value", c.x
	m.undo()
	# command 2
	assert c.x == "second value"
	m.undo()
	# command 1
	assert c.x == "First value", c.x
	m.undo()
	assert not hasattr(c, "x")
</t>
<t tx="bwmulder.20040602230426">def test_main():
    test_support.run_unittest(
		basic_scalar_test,
		basic_list_test,					
		basic_dict_test,	 
                  )

if __name__ == '__main__':
    test_main()
</t>
<t tx="bwmulder.20040602231914">def catchall(self, *args, **kwrds):
	print "delegator:", self.attributename, ":", args, kwrds
	getattr(self.undoer, self.attributename) (*args, **kwrds)
</t>
<t tx="bwmulder.20040602231934">def enable_category(self, l, monitor_class):
   for klass, external_attributename, internal_attributename in l:
      setattr(klass, external_attributename, monitor_class(
         external_attributename, internal_attributename, self))
	
</t>
<t tx="bwmulder.20040602232337">undo_tracing = False</t>
<t tx="bwmulder.20040603081718">def remove_overrides_in_list_and_dict_monitor(self):
	"""
	Deletes all function definitions in list_monitor and dict_monitor.
	The net effect of this is that instances of these classes should
	behave like regular lists and dictionaries.
	"""	
	import inspect
	for klass in (list_monitor, dict_monitor):
		for attribute in dir(klass):
			try:
				entity = getattr(klass, attribute)
			except AttributeError:
				pass
			else:
				if inspect.isfunction(entity):
					delattr(klass, attribute)
					self.removed_functions.append(klass, attribute, entity)</t>
<t tx="bwmulder.20040603211921"></t>
<t tx="bwmulder.20040603212552">def commands(self):
	return len(self._commands) - 2</t>
<t tx="bwmulder.20040603212612">def commands_to_undo(self):
	return self._index</t>
<t tx="bwmulder.20040603212713">def commands_to_redo(self):
	return self.commands() - self._index</t>
<t tx="bwmulder.20040603212934">def rollback(self):
	self.run_commands(self._steps)
</t>
<t tx="bwmulder.20040604165011">def steps_stored(self):
	"""
	Return the total number of steps stored in the undoer.
	"""
	result = 0
	for command in self._commands[1:-1]:
		result += len(command)
	return result</t>
<t tx="bwmulder.20040604184443">def test_linked_list(self):
	"""
	Shows that the basic undo mechanism can be used to undo the construction of a linked list.
	"""
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()

	# Create a linked list and check that the link operations can be undone.
	class root_class(object):
		pass
		
	class x(object):
		def __init__(self, name, next=None):
			self.name = name
			self.next = next
	
	def p(root):
		result = []
		r = root.root
		while r:
			result.append(r.name)
			r = r.next
		return result
			
	undoer = basic_undomechanism()
	
	m.monitor_scalar(root_class, "root")
	m.monitor_scalar(x, "name")
	m.monitor_scalar(x, "next")
	m.enable()
	
	root = root_class()
	root.root = x("first")
	root.root.next = x("second")
	m.mark()
	root.root.next.next = x("third")
	root.root.next.next.next = x("fourth")
	m.mark()
	assert p(root) == ["first", "second", "third", "fourth"]
	m.undo()
	assert  p(root) == ["first", "second"]
	m.redo()
	assert p(root) ==["first", "second", "third", "fourth"]
	
	# now try a few things with dictionaries.
	m.monitor_dict_attribute_in_class(root_class, "d")
	m.enable()
	root.d = {}
	m.mark()
	root.d = {'Some dict': 1}
	m.mark()
	root.d[1] = 2
	assert root.d == {'Some dict': 1, 1: 2}, root.d
	m.mark()
	m.undo()
	assert root.d == {'Some dict': 1}, root.d
	m.undo()
	assert root.d == {}, root.d
	
	
	</t>
<t tx="bwmulder.20040605104941">class basic_list_test_class(object):
	"""Simple class to test the list undoer"""
	pass

class basic_list_test(unittest.TestCase):
	"""
	Test the basic operations of the list class
	"""
	@others
		
</t>
<t tx="bwmulder.20040605105746">def test_lists_basic(self):
	"""
	Some basic testing for the list undoer.
	
	"""
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()
	m.monitor_list_attribute_in_class(basic_list_test_class, "a")
	m.enable()
	c = basic_list_test_class()
	c.a = [1, 2, 3]
	c.a = c.a
	m.mark()
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	c.a.append(5)
	m.mark()
	assert m.commands_to_undo() == 2, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	assert c.a == [1, 2, 3, 5], c.a
	m.undo()
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 1, m.commands_to_redo()
	assert c.a == [1, 2, 3], c.a
	m.redo()
	assert m.commands_to_undo() == 2, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	assert c.a == [1, 2, 3, 5], c.a
	m.undo()
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 1, m.commands_to_redo()
	m.undo()
	assert m.commands_to_undo() == 0, m.commands_to_undo()
	assert m.commands_to_redo() == 2, m.commands_to_redo()
	assert not hasattr(c, "a"), "A should not exist here"
	assert m.steps_stored() == 3, m.steps_stored()
	m.redo()
	m.redo()
	assert c.a == [1, 2, 3, 5], c.a
	del c.a[2]
	assert c.a == [1, 2, 5], c.a # 1
	m.mark()
	m.undo()
	assert c.a == [1, 2, 3, 5], c.a # 2
	m.redo()
	assert c.a == [1, 2, 5], c.a # 3
	x = c.a.pop()
	m.mark()
	assert c.a == [1, 2]
	m.undo()
	assert c.a == [1, 2, 5]

	

	


</t>
<t tx="bwmulder.20040605174728">def test_lists_replace(self):
	"""
	
	Test that list assignment works for an instance attribute that is put under the
	undo mechanism.
	
	"""
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()
	c = basic_list_test_class()
	m.monitor_list_attribute_in_class(basic_list_test_class, "a")
	m.enable()
	c.a = [1, 2, 3]
	m.mark()
	m.undo()
	assert not hasattr(c,"a")
	m.redo()
	c.a.append(4)
	c.a.append(5)
	assert c.a == [1, 2, 3, 4, 5]
	m.mark()
	m.undo()
	assert c.a == [1, 2, 3]
	m.redo()
	assert c.a == [1, 2, 3, 4, 5]
	b = list_monitor(('a', 'b', 'c'), m)
	m.enable()
	b.append('d')
	assert b == ['a', 'b', 'c', 'd']
	m.mark()
	m.undo()
	assert b == ['a', 'b', 'c']
	m.redo()
	assert b == ['a', 'b', 'c', 'd']
	
	
</t>
<t tx="bwmulder.20040605180204">class basic_dict_test_class(object):
	"""Simple class to test the list undoer"""
	pass

class basic_dict_test(unittest.TestCase):
	"""
	Test the basic operations of the list class
	"""
	@others
		

</t>
<t tx="bwmulder.20040605180225">def test_dicts_basic(self):
	"""
	Some basic testing for the dict undoer.
	
	"""
	trace_commands = False
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()
	m.monitor_dict_attribute_in_class(basic_dict_test_class, "a")
	m.enable()
	c = basic_dict_test_class()
	c.a = {1:1, 2:2, 3:3}
	c.a = c.a
	m.mark()
	if trace_commands:  print; m.print_commands(1)
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	c.a[5] = 5
	m.mark()
	if trace_commands: m.print_commands(2)
	assert m.commands_to_undo() == 2, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 1
	m.undo()
	if trace_commands: m.print_commands(3)
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 1, m.commands_to_redo()
	assert c.a == {1:1, 2:2, 3:3}, c.a # 2
	m.redo()
	if trace_commands: m.print_commands(4)
	assert m.commands_to_undo() == 2, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 3
	m.undo()
	if trace_commands: m.print_commands(5)
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 1, m.commands_to_redo()
	assert c.a == {1:1, 2:2, 3:3}, c.a # 4
	m.undo()
	if trace_commands: m.print_commands(6)
	assert m.commands_to_undo() == 0, m.commands_to_undo()
	assert m.commands_to_redo() == 2, m.commands_to_redo()
	assert not hasattr(c, "a"), "A should not exist here"
	assert m.steps_stored() == 3, m.steps_stored()
	m.redo()
	if trace_commands: m.print_commands(7)
	assert c.a == {1:1, 2:2, 3:3}, c.a # 5
	m.redo()
	if trace_commands: m.print_commands(8)
	assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 6
	del c.a[5]
	assert c.a == {1:1, 2:2, 3:3}, c.a # 7
	m.mark()
	if trace_commands: m.print_commands(9)
	m.undo()
	if trace_commands: m.print_commands(10)
	assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 8
	m.redo()
	if trace_commands: m.print_commands(11)
	assert c.a == {1:1, 2:2, 3:3}, c.a # 9
	del c.a[2]
	m.mark()
	if trace_commands: m.print_commands(12)
	assert c.a == {1:1, 3:3}, c.a # 10
	m.undo()
	if trace_commands: m.print_commands(13)
	assert c.a == {1:1, 2:2, 3:3}, c.a # 11



	

</t>
<t tx="bwmulder.20040605180245">def test_dicts_replace(self):
	"""
	
	Test that dict assignment works for an instance attribute that is put under the
	undo mechanism.
	
	"""
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()
	c = basic_dict_test_class()
	m.monitor_dict_attribute_in_class(basic_dict_test_class, "a")
	m.enable()
	c.a = {1:1, 2:2, 3:3}
	m.mark()
	m.undo()
	assert not hasattr(c,"a")
	m.redo()
	c.a[4] = 4
	c.a[5] = 5
	assert c.a == {1:1, 2:2, 3:3, 4:4, 5:5}, c.a # 1
	m.mark()
	m.undo()
	assert c.a == {1:1, 2:2, 3:3}, c.a # 2
	m.redo()
	assert c.a ==  {1:1, 2:2, 3:3, 4:4, 5:5}, c.a # 3
	b = dict_monitor({'a':'a', 'b':'b', 'c':'c'}, m)
	m.enable()
	b['d'] = 'd'
	assert b == {'a':'a', 'b':'b', 'c':'c', 'd':'d'}, b # 4
	m.mark()
	m.undo()
	assert b == {'a':'a', 'b':'b', 'c':'c'}, b # 5
	m.redo()
	assert b == {'a':'a', 'b':'b', 'c':'c', 'd':'d'}, b # 6
	
	</t>
<t tx="bwmulder.20040605220919">def print_commands(self, comment):
	"""
	rint a readable list of all commands
	"""
	print "===== Commands: %s ========" % comment
	i = 0
	while i &lt; len(self._commands):
		print "Command", i
		steps = self._commands[i]
		if steps:
			for step in steps:
				function, args = step
				print "  ",function.__name__, args
		if i == self._index:
			print "---------------------"
		i += 1
	print "========================"
</t>
<t tx="bwmulder.20040605231305">def __init__(self, value, monitor):
	list.__init__(self, value)
	self.set_monitor_object(monitor)
</t>
<t tx="bwmulder.20040605231401">def __init__(self, value, monitor):
	dict.__init__(self, value)
	self.set_monitor_object(monitor)
</t>
<t tx="edream.110203113231.233">@ To do:
    
*** WARNING: problems with locking out event handlers could cause Leo to drop Text!
    - Do not trust this version of Leo with important data !!!
    
- The find logic doesn't properly show the found selection (or the correct body text).
    - Remove traces.

- Replace body widget with something better.

- Update joined headlines when any headline changes.

- Minor:
    - Finish all callbacks.
    - Finish dragging code.
    - Handle exception when starting by double-clicking LeoPy.leo.</t>
<t tx="edream.110203113231.234">@nocolor</t>
<t tx="edream.110203113231.235"></t>
<t tx="edream.110203113231.236">
</t>
<t tx="edream.110203113231.237">

- Almost all events connected properly.
- Code draws the screen (after the file has been read in!)
- Removed idle-time pollution: created onUpdateAllMenus.</t>
<t tx="edream.110203113231.238"></t>
<t tx="edream.110203113231.242"></t>
<t tx="edream.110203113231.243"># Used 10/11/03 to convert old wxLeo code 

if 0: # This script calls c2py on the current node and all nodes of its subtree.
    import c2py
    c2py.convertCurrentTree()</t>
<t tx="edream.110203113231.257"># This updates the text of joined _headlines_, not body text.

if 0: # no longer used

    def updateJoinedHeadlines(self,text,v):
        guard = 0
        if guard &gt; 0: return
        guard += 1
        v2 = v.joinList()
        while v2 and v2 != v:
            id = v2.treeID()
            assert(id)
            self.tree.SetItemText(id,text)
            v2 = v2.joinList()
        guard -= 1</t>
<t tx="edream.110203113231.618">@ It is usually best not to catch exceptions in plugins:
doHook catches all exceptions and disables further calls to plugins.
@c

@language python
@tabwidth -4</t>
<t tx="edream.110203113231.667"></t>
<t tx="edream.110203113231.668"></t>
<t tx="edream.110203113231.677">@ignore
@language plain
@comment !
@ This node has an example of a flat configuration file (i.e. just the output of a 
'show running' command on a cisco router), and of the same configuration file 
imported by the plugin.
</t>
<t tx="edream.110203113231.678">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable
!
hostname rpr1
!
boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3
logging buffered 100000 debugging
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
!
controller SONET 1/0/0
 framing sdh
!
controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2
!
controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
!
interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast
!
interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex
!
interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex
!
interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.2
 no ip directed-broadcast
!
interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode
!
interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast
!
interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal
!
interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010
!
interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010
!
interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address
!
interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable
!
router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0
!
router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary
!
ip classless
ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3
ip bgp-community new-format
ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
logging facility local6
logging 10.10.10.1
access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any
route-map only permit 2
 match community 65001:2
 set origin igp
!
route-map only1 permit 10
 match community 1 65001:1
 set origin igp
!
route-map only3 permit 10
 match community 100
!
route-map tag_com permit 10
 match tag 1
 set community 65001:1
!
route-map tag_com permit 20
 match tag 3
 set community 65001:3
!
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware
line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0
!
ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer
end

rpr1#
</t>
<t tx="edream.110203113231.679">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
&lt;&lt;service&gt;&gt;
!
hostname rpr1
!
&lt;&lt;boot&gt;&gt;
&lt;&lt;logging&gt;&gt;
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
&lt;&lt;controller&gt;&gt;
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
&lt;&lt;interface&gt;&gt;
!
&lt;&lt;router&gt;&gt;
!
ip classless
&lt;&lt;ip route&gt;&gt;
ip bgp-community new-format
&lt;&lt;ip community-list&gt;&gt;
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
&lt;&lt;access-list&gt;&gt;
&lt;&lt;route-map&gt;&gt;
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
&lt;&lt;line&gt;&gt;
!
&lt;&lt;ntp&gt;&gt;
end

rpr1#</t>
<t tx="edream.110203113231.680">access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any</t>
<t tx="edream.110203113231.681">boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3</t>
<t tx="edream.110203113231.682"></t>
<t tx="edream.110203113231.683">controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2</t>
<t tx="edream.110203113231.684">controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1</t>
<t tx="edream.110203113231.685">controller SONET 1/0/0
 framing sdh</t>
<t tx="edream.110203113231.686"></t>
<t tx="edream.110203113231.687">interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address</t>
<t tx="edream.110203113231.688">interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable</t>
<t tx="edream.110203113231.689">interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex</t>
<t tx="edream.110203113231.690">interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex</t>
<t tx="edream.110203113231.691">interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="edream.110203113231.692">interface FastEthernet0/0/1.2
 no ip directed-broadcast</t>
<t tx="edream.110203113231.693">interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode</t>
<t tx="edream.110203113231.694">interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="edream.110203113231.695">interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="edream.110203113231.696">interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast</t>
<t tx="edream.110203113231.697">interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal</t>
<t tx="edream.110203113231.698">interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="edream.110203113231.699">interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="edream.110203113231.700">interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="edream.110203113231.701">interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010</t>
<t tx="edream.110203113231.702">interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010</t>
<t tx="edream.110203113231.703">ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3</t>
<t tx="edream.110203113231.704">ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3</t>
<t tx="edream.110203113231.705"></t>
<t tx="edream.110203113231.706">line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware</t>
<t tx="edream.110203113231.707">line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0</t>
<t tx="edream.110203113231.708">logging buffered 100000 debugging
logging facility local6
logging 10.10.10.1</t>
<t tx="edream.110203113231.709">ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer</t>
<t tx="edream.110203113231.710"></t>
<t tx="edream.110203113231.711">route-map only permit 2
 match community 65001:2
 set origin igp</t>
<t tx="edream.110203113231.712">route-map only1 permit 10
 match community 1 65001:1
 set origin igp</t>
<t tx="edream.110203113231.713">route-map only3 permit 10
 match community 100</t>
<t tx="edream.110203113231.714">route-map tag_com permit 10
 match tag 1
 set community 65001:1</t>
<t tx="edream.110203113231.715">route-map tag_com permit 20
 match tag 3
 set community 65001:3</t>
<t tx="edream.110203113231.716"></t>
<t tx="edream.110203113231.717">router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary</t>
<t tx="edream.110203113231.718">router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0</t>
<t tx="edream.110203113231.719">no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable</t>
<t tx="edream.110203113231.722"></t>
<t tx="edream.110203113231.723">[Main]
active = Yes
interval = 20</t>
<t tx="edream.110203113231.729"></t>
<t tx="edream.110203113231.872"></t>
<t tx="edream.110203113231.930"></t>
<t tx="edream.110203113231.931">colour
colourful
coloured
</t>
<t tx="edream.110203113231.932"># Configuration file for mod_spelling plugin.

[main]

aspell_dir=c:\aspell\bin\aspell.exe

local_leo_dictionary=c:\prog\leoCVS\leo\plugins\mod_spelling.txt

local_language_code=en</t>
<t tx="edream.110203113231.982">@ignore</t>
<t tx="edream.110203113231.983">@nocolor

Attached is some proof-of-concept code for a Leo Plugin manager.

To try it out ... (warning: it will write files to your c:\temp directory)

1. Start 'leopm_server.py' ... Should display a message saying "Listening on 8001"
2. Start 'leopm_client.py' ... Should bring up an ugly Tkinter window

How it works:

1. The client attaches to the remote server (via XMLRPC) 
2. Client asks for a list of plug-ins
3. Server responds
4. Client asks for details of files required + version for each plugin
5. Client checks local plugin directory to see if these files are there and if they are the right version.
6. Client displays list of available + installed plugins
7. User selects plugin and clicks 'Install'
8. Client requests files from server
9. Server sends back files
10. Client installs files in local directory (currently c:\temp)

In the current code, the client side is functional - the server side is
actually dummy methods just returning the right kind of data. There's no
point doing anything clever there until the client functionality is
fully fleshed out. Although it is all running locally in the demo there
aren't any code changes required to run remotely.

It is all pretty primitive, but I think the functionality maps quite
closely with jEdit. Tidying the Tkinter interface and fleshing out the
server side shouldn't take too long and then it could be wrapped as a
plugin itself.

Advantages of this (XMLRPC) approach,

- can go over HTTP port
- client and server are nicely decoupled (server needn't be in Python if the web host doesn't support it)
- client/server stuff is so transparent (look at the server implementation!) compared to other approaches.

Some kind of 'submit plugin' option would be interesting, but suddenly security issues start to loom!

Do you think this is worth pursuing?</t>
<t tx="edream.110203113231.984"></t>
<t tx="edream.110203113231.994"></t>
<t tx="edream.110403140857"></t>
<t tx="edream.110403140857.1"></t>
<t tx="edream.110403140857.2">@
--How to install the wiki markup plugin--

1) first make sure that the "add_directives" plugin is enabled. This plugin turns on support for @markup directives, and it can be found in leoPlugins.leo under the section "Plugins &amp; scripts" -&gt; Directives. In particular:
    a) check that the plugin code is enabled. You should have a line like (note the "if 1"):
        if 1: # Register the handlers...
    b) generate the plugin file. Right click with the mouse on the outline heading "@file add_directives.py" and select "Write @file nodes".

2) enable the "color_markup.py" plugin:
    a) check that the plugin code is enabled. You should have a line like:
        if Tkinter: # Register the handlers...
    b) generate the plugin file. Right click with the mouse on the outline heading "@file color_markup.py" and select "Write @file nodes".

</t>
<t tx="edream.110403140857.3">@
--How to use the wiki markup plugin--

Make sure first that both the add_directives and color_markup plugins are installed and enabled (see the Installation node for details). Make also sure that coloring is not disabled for your outline (i.e. you should not have @nocolor in an ancestor node).
    
Important: coloring via wiki markups is only supported in doc parts and Python triple-double-quoted strings (not in Python triple-single-quoted strings!).

To use the wiki markup, write

@markup wiki # turn on the wiki markup
@            # start a doc part
(here goes your marked-up text, see below)

To disable the wiki markup, write

@markup      # turn off the wiki markup

You can now use the markups either selecting the Wiki menu entries (or the corresponding keyboard shortcuts) found in the Edit-&gt;Edit Body-&gt;Wiki Tags menu, or manually inserting the tags yourself. 

If you use the menus, you can either select a word and choose the appropriate menu entry to appy styling to that word, or you can just choose a menu entry (e.g. "Bold") and start writing text with the correspongin style. Select the menu entry again to return to normal text.

See the "Supported markups" for the currently supported markups.

See also the "Example" subnode. If you have the add_directives and color_markup plugins enabled, you should see the text in that node displayed as styled text.</t>
<t tx="edream.110403140857.4">@
The currently supported markups are:

''text''                   # write text in italics
__text__                   # write text in bold
~~&lt;color&gt;:text~~           # write text in the color specified by &lt;color&gt; (e.g. blue, grey, etc)
{picture file=&lt;filename&gt;}  # load the picture indicated by &lt;filename&gt;
http://url                 # URL support: double clicking on the url will open it in the default browser.
https://url                # URL support: double clicking on the url will open it in the default browser.

Note 1: italics and bold markups can be nested, e.g.

''__text__''               # write text in italics and bold

Just remember to terminate the tags in the order they were opened.

Note 2: URLs must be terminated by a space.

By default, once the text has been markup up, the actual tags (e.g. __ for bold) are not displayed anymore. You can choose to display them selecting "Show Invisibles" from the Edit menu.
</t>
<t tx="edream.110403140857.5">@color
@markup wiki
@doc (this turns on a doc section; a '@ ' would do too)

This should be ''italic'' text
This should be __bold__ text
This text should be ~~pink:colored in pink~~, ~~blue:this one in blue~~.
This text should be ''__both bold and italic__''.
Leo's homepage is at http://webpages.charter.net/edreamleo/front.html 

You can also have wiki markups in python triple-double-quoted strings:

@c

def __dummy():
    """This is a __very important__ function."""
    return None
</t>
<t tx="edream.110403140857.6">@
Wiki markups are supported ''in subnodes too''.</t>
<t tx="edream.110403140857.7">@
Version 1.2.1, October 29, 2003.

Added documentation.
Added menu entries to tag selected text and to start/end wiki tagging.

Version 1.3, October 29, 2003.

Fixed bug in the creation of the wiki menu.
Added support for clickable http tags.

Version 1.4, November 4, 2003.
Put import tkinter in a try/except block.
Made changes for 4.1 g.app.gui architecture. (More work needed).</t>
<t tx="edream.111303100039"></t>
<t tx="edream.111303100039.1"></t>
<t tx="edream.111303100039.6">def insertHeadlineTime (self):
    
    es("insertHeadlineTime not ready yet")
    return

    frame = self ; c = frame.c ; v = c.currentVnode()
    h = v.headString() # Remember the old value.

    if v.edit_text():
        sel1,sel2 = g.app.gui.getTextSelection(v.edit_text())
        if sel1 and sel2 and sel1 != sel2: # 7/7/03
            v.edit_text().delete(sel1,sel2)
        v.edit_text().insert("insert",c.getTime(body=False))
        frame.idle_head_key(v)

    # A kludge to get around not knowing whether we are editing or not.
    if h.strip() == v.headString().strip():
        es("Edit headline to append date/time")</t>
<t tx="edream.111303100039.7"></t>
<t tx="edream.111303100039.8">def cascade(self):
    
    es("cascade not ready yet")
    return

    x,y,delta = 10,10,10
    for frame in g.app.windowList:
        top = frame.top
        # Compute w,h
        top.update_idletasks() # Required to get proper info.
        geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
        dim,junkx,junky = string.split(geom,'+')
        w,h = string.split(dim,'x')
        w,h = int(w),int(h)
        # Set new x,y and old w,h
        geom = "%dx%d%+d%+d" % (w,h,x,y)
        frame.setTopGeometry(geom) # frame.top.geometry("%dx%d%+d%+d" % (w,h,x,y))
        # Compute the new offsets.
        x += 30 ; y += 30
        if x &gt; 200:
            x = 10 + delta ; y = 40 + delta
            delta += 10
</t>
<t tx="edream.111303100039.9">def equalSizedPanes(self):
    
    es("equalSizedPanes not ready yet")
    return

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
</t>
<t tx="edream.111303100039.10">def hideLogWindow (self):
    
    es("hideLogWindow not ready yet")
    return
    
    frame = self
    frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)</t>
<t tx="edream.111303100039.11">def minimizeAll(self):
    
    es("minimizeAll not ready yet")
    return

    self.minimize(g.app.findFrame)
    self.minimize(g.app.pythonFrame)
    for frame in g.app.windowList:
        self.minimize(frame)
    
def minimize(self, frame):

    if frame:
        frame.Show(False)</t>
<t tx="edream.111303100039.12"># The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.
def toggleSplitDirection(self):
    
    es("toggleSplitDirection not ready yet")
    return

    # Abbreviations.
    frame = self
    bar1 = self.bar1 ; bar2 = self.bar2
    split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
    split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
    # Switch directions.
    verticalFlag = self.splitVerticalFlag = not self.splitVerticalFlag
    orientation = choose(verticalFlag,"vertical","horizontal")
    g.app.config.setWindowPref("initial_splitter_orientation",orientation)
    # Reconfigure the bars.
    bar1.place_forget()
    bar2.place_forget()
    self.configureBar(bar1,verticalFlag)
    self.configureBar(bar2,not verticalFlag)
    # Make the initial placements again.
    self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
    self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
    # Adjust the log and body panes to give more room around the bars.
    self.reconfigurePanes()
    # Redraw with an appropriate ratio.
    vflag,ratio,secondary_ratio = frame.initialRatios()
    self.resizePanesToRatio(ratio,secondary_ratio)</t>
<t tx="edream.111303101257">def abortEditLabelCommand (self):

    es("abortEditLabelCommand not ready yet")
    return
    
    c = self.c ; v = c.currentVnode ; tree = self.tree
    # trace(v)
    if self.revertHeadline and v.edit_text() and v == self.editVnode:
        
        # trace(`self.revertHeadline`)
        v.edit_text().delete("1.0","end")
        v.edit_text().insert("end",self.revertHeadline)
        tree.idle_head_key(v) # Must be done immediately.
        tree.revertHeadline = None
        tree.select(v)
        if v and len(v.t.joinList) &gt; 0:
            # 3/26/03: changed redraw_now to force_redraw.
            tree.force_redraw() # force a redraw of joined headlines.</t>
<t tx="edream.111303101257.1">def endEditLabelCommand (self):
    
    es("endEditLabelCommand not ready yet")
    return

    c = self.c ; tree = self.tree ; v = self.editVnode

    if v and v.edit_text():
        tree.select(v)

    if v: # Bug fix 10/9/02: also redraw ancestor headlines.
        # 3/26/03: changed redraw_now to force_redraw.
        tree.force_redraw() # force a redraw of joined headlines.

    gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02</t>
<t tx="edream.111303101709">def toggleActivePane(self):
    
    # This can't work from the menu...
    
    es("toggleActivePane not ready yet")
    return

    if self.FindFocus() == self.body.bodyCtrl:
        self.tree.SetFocus()
    else:
        self.body.bodyCtrl.SetFocus()</t>
<t tx="edream.111303103141.3">def delete_range (self,menu,n1,n2):
    
    if not menu:
        trace("no menu")
        return
        
    # trace(n1,n2,menu.GetTitle())
    
    items = menu.GetMenuItems()
    
    if 0: # debugging
        for item in items:
            id = item.GetId()
            item = menu.FindItemById(id)
            trace(item.GetText())
            
    ## Doesn't work:  a problem with wxPython.
    
    if len(items) &gt; n1 and len(items) &gt; n2:
        i = n1
        while i &lt;= n2:
            id = items[i].GetId()
            item = menu.FindItemById(id)
            trace("deleting:",item.GetText())
            menu.Delete(id)
            i += 1</t>
<t tx="edream.111303184347">@ The wxWindows menu code has problems:  changes do not take effect immediately.</t>
<t tx="edream.111303202917.1">def getColorizer(self):

    return self.colorizer

def recolor(self,v,incremental=False):

    if self.use_coloring:
        self.colorizer.colorize(v,incremental)

def recolor_now(self,v,incremental=False):

    if self.use_coloring:
        self.colorizer.colorize(v,incremental)
    
def recolor_range(self,v,leading,trailing):

    if self.use_coloring:
        self.colorizer.recolor_range(v,leading,trailing)
    
def updateSyntaxColorer (self,v):

    return self.colorizer.updateSyntaxColorer(v)</t>
<t tx="edream.111303204025"></t>
<t tx="edream.111303204025.1">def adjustIndex (self,index,offset):
    
    try:
        column, row = index
        return column, row + offset
    except:
        return index + offset</t>
<t tx="edream.111303204025.2">def compareIndices(self,i,rel,j):
    
    try:
        y1,x1 = i
        y2,x2 = j
        pos1 = self.bodyCtrl.XYToPosition(x1,y1)
        pos2 = self.bodyCtrl.XYToPosition(x2,y2)
    except:
        pos1 = i
        pos2 = j
    
    val = eval("%d %s %d" % (pos1,rel,pos2))
    trace(i,j,rel,val)
    return val</t>
<t tx="edream.111303204025.3">def convertRowColumnToIndex (self,row,column):
    
    index = self.bodyCtrl.XYToPosition(column,row-1)
    # trace(column,row,"-&gt;",index)
    return index</t>
<t tx="edream.111303204025.4">def convertIndexToRowColumn (self,index):
    
    x,y = self.bodyCtrl.PositionToXY(index)
    # trace(index,"-&gt;",y+1,x)
    return y+1,x</t>
<t tx="edream.111303204025.5">def getImageIndex (self,image):
    
    trace(image)</t>
<t tx="edream.111303204517"></t>
<t tx="edream.111303205442">@ The colorizer isn't ready for prime time:
    
    - It's too slow when selecting long text
    - The screen flashes too much
    - The tkColorToWxColor routine needs much more work.
    
wxLeo should use wxStc rather than wxText!</t>
<t tx="edream.111303205611">def tag_add (self,tagName,index1,index2):
    
    # trace(tagName,index1,index2)

    style = self.styles.get(tagName)
    if style:
        self.bodyCtrl.SetStyle(index1,index2,style)</t>
<t tx="edream.111303205611.1">def tag_bind (self,tagName,event,callback):
    
    # trace(tagName,event,callback)
    pass
</t>
<t tx="edream.111303205611.2">def tag_configure (self,colorName,**keys):
    
    foreground = keys.get("foreground")
    background = keys.get("background")

    if foreground:
        fcolor = self.tkColorToWxColor (foreground)
        bcolor = self.tkColorToWxColor (background)
        if fcolor and bcolor:
            # trace(colorName,foreground,keys)
            style = wx.wxTextAttr(fcolor,bcolor)
            self.styles[colorName] = style
        elif fcolor:
            style = wx.wxTextAttr(fcolor)
            self.styles[colorName] = style</t>
<t tx="edream.111303205611.3">def tag_delete(self,tagName):

    if tagName == "keyword": # A kludge.

        # trace(tagName)
        style = wx.wxTextAttr(wx.wxBLACK)
        last = self.maxWxIndex()
        
        if 1: # This may cause the screen flash.
            self.bodyCtrl.SetStyle(0,last,style)</t>
<t tx="edream.111303205611.4">def tag_remove (self,tagName,index1,index2):
    
    trace(tagName,index1,index2)
    pass
</t>
<t tx="edream.111403080609">def maxWxIndex (self):
    
    return self.bodyCtrl.GetLastPosition()</t>
<t tx="edream.111403082513">def tkColorToWxColor (self, color):
    
    d = {
        "red": wx.wxRED,
        "blue": wx.wxBLUE,
        "#00aa00": wx.wxGREEN,
        "firebrick3": wx.wxRED }
        
    return d.get(color)</t>
<t tx="edream.111403093253">The new code now works with the new reorg.  This means that wxLeo is using all the code in Leo's core.

In particular:

- wxLeo creates all menus using the base leoMenu class.
- wxLeo uses all commands in the Commands class.
- wxLeoFrame contains only gui-dependent commands.

The syntax colorer is working in demo mode.  Almost certainly wxLeo should use a better control than wxText.</t>
<t tx="edream.111403093253.1"></t>
<t tx="edream.111503110300">At this point, Leo is useable.

What I did:

- Added use_coloring ivar to the wxLeoFrame class.  The body text is syntax colored only if this is True.
    This is set to False at present because the default colors are very poor.
    Also, coloring causes the body pane to scroll for large text.  These are minor problems...

- Got find panel working.  This required creating dummy wxSearchWidget class.  Probably _all_ the search code should be in the base leoFind class, but that would making supporting regexp searches harder.

- Simplified the event handlers in the find panel.  We can use tables to _create_ the event handlers.

- Solved the problem with selecting new nodes: we must lock out further event handling once an event handler starts.  In particular, the syntax colorer generates a lot of other events.  This also prevents the outline from being marked dirty when a new node is selected.

- Added code to insject do-nothing callbacks into vnode class.  This is required by the syntax colorer.

Later:

- Completed Find panel.

- Made sure Leo prompts when closing a window.
    - The new code is very simple: it just calls g.app.closeLeoWindow.
        - Removed some gui dependencies from the g.app.finishQuit logic.
          (They are now in the g.app.tkinterGui.destroySelf routine.)

- Implemented the wx gui dialog code.
    - Only the number dialog remains...

Very little remains to be done, and nothing big.</t>
<t tx="edream.111503111146"></t>
<t tx="edream.111503111350"></t>
<t tx="edream.111703103908"></t>
<t tx="edream.111703103908.2">def leoHelp (self):
    
    es("leoHelp not ready yet")
    
    return ##
    
    file = os.path.join(g.app.loadDir,"..","doc","sbooks.chm")
    file = toUnicode(file,g.app.tkEncoding) # 10/20/03

    if os.path.exists(file):
        os.startfile(file)
    else:	
        answer = g.app.gui.runAskYesNoDialog(
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")

        if answer == "yes":
            try:
                if 0: # Download directly.  (showProgressBar needs a lot of work)
                    url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
                    import urllib
                    self.scale = None
                    urllib.urlretrieve(url,file,self.showProgressBar)
                    if self.scale:
                        self.scale.destroy()
                        self.scale = None
                else:
                    url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                    import webbrowser
                    os.chdir(g.app.loadDir)
                    webbrowser.open_new(url)
            except:
                es("exception dowloading sbooks.chm")
                es_exception()</t>
<t tx="edream.111703103908.3">def showProgressBar (self,count,size,total):

    # trace("count,size,total:" + `count` + "," + `size` + "," + `total`)
    if self.scale == None:
        &lt;&lt; create the scale widget &gt;&gt;
    self.scale.set(count*size)
    self.scale.update_idletasks()</t>
<t tx="edream.111703103908.4">top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()</t>
<t tx="ekr.20040205071616">"""
mnplugins.py

mnplugins shows how to :
define new Commands  "insertOK" + "insertUser"
create Usermenu with new Commands

new Commands:
insertOK: 
    insert 'OK' in headline and a stamp in the first bodyline
    are there childnodes without 'OK' verhindern OK in actual node
    (insertOK on iconrclick2 too)

insertUser : Shift-F6
    insert a &lt;user/date/time&gt; stamp at the current location in bodytext
    
"""

import leoGlobals as g
import leoPlugins

import leoCommands
import time

OKFLAG='OK '  # Space required.

@others

try: import Tkinter as Tk
except ImportError: Tk = None

if Tk: 

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":
        leoPlugins.registerHandler("start1", onStart)
        leoPlugins.registerHandler("create-optional-menus",create_UserMenu)
        leoPlugins.registerHandler("iconrclick2", onRclick)

        __version__ = "0.1"
        g.plugin_signon(__name__)
        g.es('mnplug OK+Commands+Menu aktiv',color='green')</t>
<t tx="ekr.20040205071616.1">def mnstamp():

    lt=time.localtime(time.time())
    mndatetime=time.strftime('%y%m%d %H:%M',(lt))
    return '### '+g.app.leoID+mndatetime
</t>
<t tx="ekr.20040205071616.2">def mnOKstamp():

    lt=time.localtime(time.time())
    mndatetime=time.strftime('%y%m%d %H:%M',(lt))
    return '###'+OKFLAG+g.app.leoID+mndatetime
</t>
<t tx="ekr.20040205071616.3">def onStart (tag,keywords):

    # insert function insertUser as method of class Commands at runtime
    g.funcToMethod(insertUser,leoCommands.Commands)
    g.funcToMethod(insertOKcmd,leoCommands.Commands)

</t>
<t tx="ekr.20040205071616.4">def setHeadOK(v):

    s = OKFLAG + v.headString()
    v.setHeadStringOrHeadline(s)

</t>
<t tx="ekr.20040205071616.5">def insertBodystamp(c,v):

    stamp=mnOKstamp()+'\n'

    # insertAtBegin - ??!! workaround ??!! 
    # insertPointFormat is  ('row.column')
    
    oldip=c.frame.body.getInsertionPoint()
    newip=str(int(string.split(oldip,'.')[0])+1)+'.'+string.split(oldip,'.')[1]

    c.frame.body.setInsertionPoint('0.0')
    c.frame.body.insertAtInsertPoint(stamp)
    c.frame.body.setInsertionPoint(newip)
    c.frame.body.onBodyChanged(v,"Typing")</t>
<t tx="ekr.20040205071616.6">def is_subnodesOK(v):

    if not v.hasChildren():
        return True
    else:
        ok = False
        child=v.firstChild()
        while child:
            s=child.headString()
            ok=s[0:len(OKFLAG)]==OKFLAG
            if not ok:break
            child=child.next()
    return ok

</t>
<t tx="ekr.20040205071616.7">def onRclick(tag,keywords):
    
    """Handle right click in body pane."""

    c=keywords.get('c')
    insertOKcmd(c)</t>
<t tx="ekr.20040205071616.8">def insertOKcmd(self,event=None):

    c=self; v=c.currentVnode()  
    
    if is_subnodesOK(v) :
        setHeadOK(v)
        insertBodystamp(c,v)
    else: 
        g.es('OK in child missing')</t>
<t tx="ekr.20040205071616.9">def insertUser (self,event=None):
    
    """Handle the Insert User command."""

    c = self ; v = c.currentVnode()
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    
    s = mnstamp()
    
    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(v,"Typing",oldSel=oldSel)</t>
<t tx="ekr.20040205071616.10">def create_UserMenu (tag,keywords):

    c = keywords.get("c")
    
    c.pluginsMenu = c.frame.menu.createNewMenu("UserMenu")

    table = [
        ("insUser", 'Shift+F6', c.insertUser),
        ("insOK",'Ctrl+Shift+O',c.insertOKcmd)]

    c.frame.menu.createMenuEntries(c.pluginMenu,table)</t>
<t tx="ekr.20040331071919"></t>
<t tx="ekr.20040331071919.1">@language plain
@ascfile "doc/mod_asc_dev.asc"
@doc                
@ascskip # Time-stamp: "Mon, Jan 19 15:30 CST 2004  michael@redpriest Leo_AsciiDoc_Developers_Guide_141612300.txt"
Preface
-------

Leo2AsciiDoc is a small Python program which has been built to be used as
a plugin module for the Leo outlining editor.

This is the Developer Documentation and source code listing of
Leo2AsciiDoc.

Leo2AsciiDoc enables the contents of Leo outlines to be published to
HTML or PDF via the DocBook XML set of publishing tools.  Plain text
from the Leo outline is transformed into a final result that has:

    - typeset body text, in which bulleted and numbered lists,
      variable lists, page numbers, URLs, index terms,and bold and
      italic text are automatically recognized.
    - typeset Headings
    - a Table of Contents
    - an Index containing any items marked by the user, and any
      Python classes or functions.

indexterm:[Literate Programming]
For programmers, Leo2AsciiDoc enables a simplified version of
Literate Programming: all the documentation and code for a program
can be written in a Leo outline, and published with just a few
keystrokes.  As is normal for a Leo outline, Leo can also extract
the source code from the outline and package it into text files,
ready to be run or compiled.

Specifically, what the Leo2AsciiDoc program does is:

    - wait to be called by the Leo menu (File; Export; Export to
      AsciiDoc), and then
    - read a part of a Leo outline, and
    - write the contents to a text file that can be understood by
      the AsciiDoc program.

From there:

    - the xref:AsciiDoc[] program can then convert that text file to
      another text file that is in the DocBook XML format.
    - the standard collection of xref:DocBook[] tools can then format the
      text in HTML (web page) files or as a typeset PDF file.
    - Once set up, the whole process happens quickly and
      automatically, usually with a simple "make" command.

Here are some web locations for the items I've referenced above:

Leo::    
    http://webpages.charter.net/edreamleo/front.html[]
Python::
    http://www.python.org[]
Docbook::    
    http://docbook.org/[]
Literate Programming::
    http://www.literateprogramming.com/[]
AsciiDoc::
    http://www.methods.co.nz/asciidoc/[]
PDF::
    Adobe provides a free program, Adobe Acrobat Reader (Windows &amp;
    Linux), that is used to read and print documents produced in the
    Adobe Portable Document Format.
    http://www.adobe.com/products/acrobat/readermain.html[]

---
Michael Dawson
Marshall Research
michael_dawson at marshallresearch dot com
---
@code</t>
<t tx="ekr.20040331071919.2">@doc
@ascskip # Time-stamp: "Fri, Jan  9 15:19 CST 2004  michael@redpriest About_this_document_140583820.txt"

If you are reading this document in HTML (in a web browser) or as a
PDF file (usually in Adobe Acrobat Reader), it may interest you to
know that this document was generated from a Leo outline.

The Leo outline (in the file mod_leo2ascd.leo) contained the
Leo2AsciiDoc Users Guide, the Leo2AsciiDoc Developers Guide, and all
the Leo2AsciiDoc source code.  All of them were created by simply
typing plain text.

The working source code was exported by Leo using the "File; Tangle;
Tangle" menu selection, which created the Python program file
"mod_leo2ascd.py".

The Users Guide and the Developers Guide were created by exporting
the text from Leo, using the menu selection "File; Export; Export
All to AsciiDoc".  This created the plain text files
"mod_asc_user.asc" and "mod_asc_dev.asc" (which are the file names I
told Leo to use.)

I then typed "make all" at the console in the directory, and the
make program:

    - ran the AsciiDoc program to produce the DocBook XML files.
    - ran the xsltproc program to produce the HTML files from the
      XML files.
    - ran the xsltproc program to produce "fo" files, and ran the
      fop program to produce PDF files from the fo files.

Everything was generated automatically without any further work on
my part.

@code</t>
<t tx="ekr.20040331071919.3">@doc
@ascskip # Time-stamp: "Mon, Jan 19 15:28 CST 2004  michael@redpriest License_141615068.txt"

This is part of the Leo2AsciiDoc software package, which is released
as open source.  

The license is the most "open" I know of, and is sometimes referred
to as the "X11" or "MIT" license.  Boiled down, in non-legal terms:

    - the software is yours for free -- to run, modify and
      distribute as you will
    - I have no legal liability for any of it
    - you may not use my name.

Michael Dawson
Marshall Research
michael_dawson at marshallresearch dot com

NOTE: The following license is often referred to as the "MIT/X
Consortium License", as the "MIT license" and as the "X11" license.
My source for the exact wording is the copy at the Open Source
Initiative:  http://opensource.org/licenses/mit-license.html[]


@code
</t>
<t tx="ekr.20040331071919.4">@doc
@ascskip # Time-stamp: "Fri, Jan  9 09:18 CST 2004  michael@redpriest License_document_140581532.txt"
---
Terms and Conditions
 
COPYRIGHT AND PERMISSION NOTICE

Copyright (c) 1999,2000,2001,2002,2003,2004 Michael W. Dawson

All rights reserved.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, provided
that the above copyright notice(s) and this permission notice appear
in all copies of the Software and that both the above copyright
notice(s) and this permission notice appear in supporting
documentation.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE
COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR
ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY
DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
OF THIS SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale,
use or other dealings in this Software without prior written
authorization of the copyright holder.
---
@code</t>
<t tx="ekr.20040331071919.5">@doc
@ascskip # Time-stamp: "Fri, Jan  9 16:13 CST 2004  michael@redpriest Version_Requirements_140584132.txt"

This is version 0.4 of Leo2AsciiDoc.  The major version of zero
indicates that it is an in-house version, not suitable for
production use elsewhere.

It was created and tested using:

    - Leo version 4.1 (release candidate 3).  Leo2AsciiDoc was
      upgraded to use the new features in 4.1 and is no longer
      compatible with previous versions.
    - AsciiDoc version 5.0.2.  Leo2AsciiDoc was upgraded to use the
      new features in 5.0.2, and is no longer compatible with older
      versions of AsciiDoc.
    - DocBook XML DTD version 4.2 and DocBook XSL stylesheets 1.60.1
    - xsltproc 1.0.30
    - fop 0.20.5

The last three items are the DocBook tool chain I'm currently using.
Any working DocBook XML tool chain you may have is likely to work,
since the major Leo2AsciiDoc effort is in producing the XML files
the tool chain uses as input.

@code</t>
<t tx="ekr.20040331071919.6">@language plain
@doc
@ascskip # Time-stamp: "Fri, Jan  9 16:00 CST 2004  michael@redpriest The_General_Approach_140588436.txt"

Leo2AsciiDoc simply copies the text from a portion of a Leo outline
to a text file.  That text file can then be processed by other
programs to produce HTML, PDF's, etc.

The text will be copied from each outline item, in outline order,
though you can skip individual nodes or sub-trees.

The idea is that you write the outline as a book, or series of
books.

If your book contains source code, you can break it up into pieces
that make it convenient to review with the reader.  Additionally,
you can discuss the pieces in any order that you like.  Using the
"tangle" command, Leo will be able to assemble and reorder the
pieces in the order required for a file of compilable source code.

As the text is copied from the outline, Leo2AsciiDoc adds minimal markup,
generally:

    - It marks up node headlines as Titles and Section Headings
      in the AsciiDoc format.
    - Program listings have AsciiDoc section markers inserted before
      and after.

A specific list follows.

@code</t>
<t tx="ekr.20040331071919.7">@language plain
@doc
@ascskip # Time-stamp: "Fri, Jan  9 16:05 CST 2004  michael@redpriest Markup_Added_140589620.txt"

    - headings:
        * By default, all outline node headings are underlined with
          the appropriate section underline character, which
          AsciiDoc will use to transform the headings into titles:
          chapter, section1, section2, etc.
        * code extracts are given an "example" heading.
    - source code sections are marked with delimiters, so that they
      can be assigned to the DocBook "programlisting" element.
    - source code sections are line-wrapped in the document output,
      for convenient html display.
    - wherever source code is exported to a source code file, the
      document with note this with an automatically generated "note"
      element.

@code
</t>
<t tx="ekr.20040331071919.8">@language python
@tabwidth -4

@doc
@ascskip on
 @silent
NB: remove leading space from above silent directive for final clean
code.

@ascskip off
@ascskip # Time-stamp: "Thu, Dec  4 11:58 CST 2003  michael@redpriest _The_Code__140751676.py"

This chapter contains all the source code for the Leo2AsciiDoc program.
The code is arranged in an order that is convenient for discussion.

On its way from the Leo outline to this document, the code has been
reformatted for printing.  Please note that:

    - code lines that are longer than the current publishing limit
      are wrapped.  Wrapped lines end in a "\" character and have
      the remainder of the text on the next line, preceeded by 4
      spaces. The real working code is not changed in this way when
      exported for actual use.
    - Some code has been extracted as Examples, and has a title
      saying something like "Example: Interesting Code".  Rather
      than repeat that code in the main code body, there is simply a
      reference to the name, enclosed in double angle brackets:
      \&lt;&lt;Interesting Code&gt;&gt;. All extracts are indexed, see "Python
      code, extracts used" in the Index at the end of the document.

@ascskip on
@root "mod_leo2ascd.py"
&lt;&lt; Declarations and Utilities &gt;&gt;
&lt;&lt; Write the outline tree as AsciiDoc file &gt;&gt;
&lt;&lt; Write a node &gt;&gt;
&lt;&lt; Key Functions &gt;&gt;
@code</t>
<t tx="ekr.20040331071919.9">@doc
@ascskip # Time-stamp: "Thu, Dec  4 16:05 CST 2003  michael@redpriest _Key_Functions__141128028.py"

These are the top-level functions that can be called from the Leo menu.

The next function writes the Leo outline tree of the current node to
a text file.  It first checks to see that there is an ascfile
directive in the current node, or above it, and then calls the
WriteTreeAsAsc function to write the tree starting at the ascfile
node.

If you have several documents in one Leo outline, this function will
write out the current one.

@code

def WriteTreeOfCurrentNode():
    c = g.top() ; f = c.frame
    vnode = c.currentVnode() # get the current vnode.
    while vnode:
        ascFileN = GetAscFilename(vnode)
        if ascFileN == None:
            vnode = vnode.parent()
        else:
            break

    if ascFileN == None:
        g.es("Sorry, there was no @ascfile directive in this outline tree.")
    else:
        WriteTreeAsAsc(vnode, ascFileN)

@doc

The next function exports all Leo2AsciiDoc documents in the entire Leo
outline, starting at the top and working through all nodes.

@code
def WriteAll():
    c = g.top() ; f = c.frame
    v = c.rootVnode()
    while v:
        ascFileN = GetAscFilename(v)
        if ascFileN != None:
            WriteTreeAsAsc(v, ascFileN)
            v = v.nodeAfterTree()
        else:
            v = v.threadNext()
@doc

This function is handy to see all the Leo2AsciiDoc sub-trees and source
code sub-trees in a Leo outline.  It prints the results in the log pane.

@code

def WriteAllRoots():
    "Writes @root directive and/or @ascfile directive to log pane."

    patternAscDirectiveFile = re.compile(r'^@ascfile')
    patternRoot = re.compile(r'^@root')

    g.es('Looking for @root or @ascfile.')
    c = g.top() ; f = c.frame
    vnode = c.rootVnode()
    while vnode:
        bodyString = vnode.bodyString()
        lines = bodyString.splitlines()
        printedHeading = False
        for line in lines:
            printLine = False
            containsAscFileDirective = patternAscDirectiveFile.match(line)
            if containsAscFileDirective:
                printLine = True
            containsRootDirective = patternRoot.match(line)
            if containsRootDirective:
                printLine = True
            if printLine:
                if not printedHeading:
                    g.es(vnode.headString())
                    printedHeading = True
                g.es('  ' + line)
        vnode = vnode.threadNext()

@doc

Next, we simply create Leo menu items for the above functions,
assuming Leo is loading this code as a module (i.e. the Python
source has been placed in the Leo plugins directory.)  As a module,
the phrase "if 0:" must be changed to "if 1:" to activate the
module.

But while the "if 0:" is left, this code can be used as a script
from the Leo scripts menu (assuming a copy of the code has been
placed in the Leo scripts directory), implementing the WriteAll
function above. This is useful in testing.

@code
def CreateAscMenu(tag,keywords):

    """Create the Outline to AsciiDoc menu item in the Export menu."""


    if  (tag=="open2" or
        (tag=="start2") or
        (tag=="command2" and keywords.get("label")=="new")):

        c = g.top()
        exportMenu = c.frame.menu.getMenu('export')
        newEntries = (
            ("-", None, None),
            ("Export all to &amp;AsciiDoc","Alt+Shift+A",WriteAll),
            ("Export current tree to AsciiDoc","Alt+Shift+T",WriteTreeOfCurrentNode),
            ("Log all root and ascfile to log pane","Alt+Shift+L",WriteAllRoots)
            )

        c.frame.menu.createMenuEntries(exportMenu, newEntries)
    

if 1:
    leoPlugins.registerHandler(("start2","open2","command2"), CreateAscMenu)

    __version__ = ".4" # Set version for the plugin handler.
    g.plugin_signon(__name__)
else:
    WriteTreeOfCurrentNode()

@doc

</t>
<t tx="ekr.20040331071919.10">@doc
@ascskip # Time-stamp: "Tue, Nov 25 11:25 CST 2003  michael@redpriest _Declarations_and_Utilities__140958380.py"

Next, we define new directives to control the way we export the Leo
text, as seen in this extract from the main code.  Directives start
with an "@" character as the first character in the line.

@code
&lt;&lt;New Leo2AsciiDoc directives&gt;&gt;=
patternAscDirectiveConfig = re.compile(r'^@ascconfig\W+(\w+)\s+(\S+)')
patternAscDirectiveFile = re.compile(r'^@ascfile *"*([\w\\/\.]*)"*')
patternAscDirectiveExit = re.compile(r"^@ascexit")
patternAscDirectiveIgnore = re.compile(r"^@ascignore")
patternAscDirectiveSkip = re.compile(r"^@ascskip")
patternAscDirectiveSkipToggle = re.compile(r"^@ascskip\s*(\w+)+.*")
@doc

Next, a class to simulate constants, and make it easy to use
them. We create a class whose variables can be assigned, but not
reassigned inadvertently. As well, the "Next" function gives us an
easy way to acquire a variable of unique value when we don't care
what that value actually is, just that it is unique.

@code
&lt;&lt;Simulate Python constants&gt;&gt;=
class   _AssignUniqueConstantValue:
    """ Provide unique value to be used as a constant """
    def __init__(self):
        self.UniqueInternalValue = 0
        self.Assign_at_start()

    class ConstError(TypeError): pass
    def __setattr__(self,name,value):
        if self.__dict__.has_key(name):
            if name != "UniqueInternalValue":
                raise self.ConstError, "Can't rebind const(%s)"%name
        self.__dict__[name]=value

    def Assign_at_start(self):
        self.END_PROGRAM = self.Next()   # signal abort
        self.LINE_WAS_NONE = self.Next() # describe last line printed
        self.LINE_WAS_CODE = self.Next()
        self.LINE_WAS_DOC  = self.Next()
        self.LINE_WAS_HEAD = self.Next()
        self.LINE_PENDING_NONE  = self.Next() # describe next line to be printed
        self.LINE_PENDING_CODE  = self.Next()
        self.LINE_PENDING_DOC   = self.Next()

    def Next(self):
        self.UniqueInternalValue += 1
        return(self.UniqueInternalValue)
@doc
@ascexit
@code
&lt;&lt;The Code -- Declarations and Utilities&gt;&gt;</t>
<t tx="ekr.20040331071919.11">@
@ascskip # Time-stamp: "Fri, Dec 19 10:42 CST 2003  michael@redpriest _The_Code_Declarations_and_Utilities__140568852.py"

Here we begin the Python program, importing the modules we need, and
signing on as the Leo2AsciiDoc module in the Leo log window.
@c

import leoGlobals as g
import leoPlugins

import re
import os

g.es("---mod_leo2asc 0.4-------")

@
Next, a class to hold our configuration data. Users can change the
Leo2AsciiDoc configuration by including an "@ascconfig" directive in the
body text of a Leo outline, either in the root node or in the same
node as an "@ascfile" directive.  User directives in the root node
override the Leo2AsciiDoc defaults. Further, directives in an ascfile
node not only override the Leo2AsciiDoc defaults, but also any user
directives in the root node.
@c

&lt;&lt;Simulate Python constants&gt;&gt;

class _ConfigOptions:
    """Hold current configuration options."""
    def __init__(self):
        self.current = {}
        self.default = {}
        self.default["maxCodeLineLength"] = '76'
        self.default["delimiterForCodeStart"] = '~-~--- code starts --------'
        self.default["delimiterForCodeEnd"]   = '~-~--- code ends ----------'
        self.default["delimiterForCodeSectionDefinition"] = '*example*'
        self.default["headingUnderlines"] = '=-~^+'
        self.default["asciiDocSectionLevels"] = '5'
        self.default["PrintHeadings"] = "on"

    def __GetNodeOptions(self, vnode):
        bodyString = vnode.bodyString()
        lines = bodyString.splitlines()
        for line in lines:
            containsAscConfigDirective = patternAscDirectiveConfig.match(line)
            if containsAscConfigDirective:
                # Leo uses unicode, convert to plain ascii
                name = str(containsAscConfigDirective.group(1))
                value = str(containsAscConfigDirective.group(2))
                if self.current.has_key(name):
                    self.current[name] = value
                else:
                    g.es(vnode.headString())
                    g.es("  No such config option: %s" % name)

    def GetCurrentOptions(self, vnode):
        self.current.clear()
        self.current = self.default.copy()
        c = g.top()
        v = c.rootVnode()
        self.__GetNodeOptions(v)             # root node
        self.__GetNodeOptions(vnode)         # current node

# ----- assign constants ---------------------------------------------------
CV = _AssignUniqueConstantValue()
CV.NODE_IGNORE = CV.Next()              # demo of adding in code
Conf = _ConfigOptions()

# ----- globals ------------------------------------------------------------
#   compile the patterns we'll be searching for frequently
patternSectionName = re.compile("\&lt;\&lt; *(.+?) *\&gt;\&gt;")
patternSectionDefinition = re.compile("(\&lt;\&lt; *)(.+?)( *\&gt;\&gt;)(=)")
patternDirective = re.compile(r"^@")
patternCodeDirective = re.compile(r"^(@c *$)|(@code)")
patternDocDirective = re.compile(r"^(@ |@doc)(.*)")
patternRootDirective = re.compile(r"^@root\s+(.+)")
patternAscDirective = re.compile(r"^@asc")
&lt;&lt;New Leo2AsciiDoc directives&gt;&gt;
@doc

AsciiDoc recognizes titles and section headings by the underlining (a
line of characters on the next line after the text) with a line
of flag characters.  This function calculates the section level
(considering the ascfile node to be the top or "book" level) and
creates the appropriate string of flag characters.

@code
def SectionUnderline(h,level,v):
    'Return a section underline string.'
    asciiDocSectionLevels = int(Conf.current["asciiDocSectionLevels"])
    if level &lt; 0:
        g.es("Section level is less than 1:\n  %s" % v.headString())
        level = 1
    elif level &gt; asciiDocSectionLevels - 1:
        g.es("Section level is more than maximum Section Levels: %d\n  %s" \
           % (asciiDocSectionLevels, v.headString()))
        level = asciiDocSectionLevels - 1
    str = Conf.current["headingUnderlines"][level]  #'
    return str*max(len(h),1)
@doc

GetAscFilename is a frequently used function that checks a node for
the presence of an "@ascfile" directive, which specifies the name
and location of the Leo2AsciiDoc output file.

Leo2AsciiDoc will not export text without finding a file name. If no path
is given, the file will be created in the same directory as the Leo
outline.

@code
def GetAscFilename(vnode):
    'Checks a node for a filename directive.'
    # f is the Leo outline
    c = g.top()
    ascFileName = None
    bodyString = vnode.bodyString()
    lines = bodyString.splitlines()
    for line in lines:
        containsAscFileDirective = patternAscDirectiveFile.match(line)
        if containsAscFileDirective:
            ascFileName = containsAscFileDirective.group(1)
            if (ascFileName != None):
                base = os.path.split(c.mFileName)[0]  # linux or windows
                if (((base[0]=="/") and (ascFileName[0] != "/")) or 
                   ((base[1]==":") and (ascFileName[1] != ":"))): 
                    # no full pathname specified
                    ascFileName = os.path.join(base, ascFileName)
                Conf.GetCurrentOptions(vnode)
    return ascFileName
        
@doc

CodeChunk splits a line of text into chunks of a maximum length.
This is used in exporting source code sections of the Leo outline
for publication.

@code
def CodeChunk(text, width=72):
    """Split a line of text into a list of chunks not longer
    than width."""
    chunkList = []
    chunkStart = 0
    chunkEnd = 0
    lastSpacePosition = 0
    shortWidth = width - 4
    prefix = ''
    suffix = ' \\'
    textLen = len(text)
    if width &gt; textLen:
        chunkList.append(text)
    else:
        while chunkEnd &lt; textLen:
            if len(chunkList) &gt; 0:
                prefix = '  '
            chunkEnd = chunkStart + shortWidth
            if chunkEnd &gt; textLen:
                chunkList.append(prefix + text[chunkStart:])
                chunkEnd = textLen          # get out of jail
            else:
                lastSpacePosition = text.rfind(' ',chunkStart, chunkEnd +1)
                if lastSpacePosition != -1:  # success
                    chunkList.append(prefix + text[chunkStart:lastSpacePosition] + ' \\')
                    chunkStart = lastSpacePosition + 1
                else:
                    chunkEnd = chunkStart + shortWidth
                    chunkList.append(prefix + text[chunkStart:chunkEnd] + ' \\')
                    chunkStart = chunkEnd
    return chunkList</t>
<t tx="ekr.20040331071919.12">@doc
@ascskip # Time-stamp: "Thu, Dec  4 15:28 CST 2003  michael@redpriest _Write_the_outline_tree_as_AsciiDoc_file__141131100.py"

This function opens the output file and walks the tree of outline
nodes under the node that is passed as the first parameter.  At each
node, it calls our workhorse "WriteNode".


@code
def WriteTreeAsAsc(vnode, ascFileN):
    'Writes the tree under vnode to the file ascFile'
    def CleanUp():
        'Cleanup on exit'
        ascFile.close()

    writeNodeReturnValue = None
    startinglevel = vnode.level()
    try:
        ascFile = file(ascFileN,'w')
    except IOError:
        g.es("Could not open output file: %s" % ascFileN)
        return
    stopHere = vnode.nodeAfterTree()
    v = vnode
    while v != stopHere:
        writeNodeReturnValue = WriteNode(v, startinglevel, ascFile)
        if  writeNodeReturnValue == CV.END_PROGRAM:
            CleanUp()
            return
        elif  writeNodeReturnValue == CV.NODE_IGNORE:
            v = v.nodeAfterTree()       # ran into an @ascignore
        else:
            v = v.threadNext()

    CleanUp()
    g.es('Wrote: '+`ascFileN`)





</t>
<t tx="ekr.20040331071919.13">@doc
@ascskip # Time-stamp: "Fri, Jan  9 13:58 CST 2004  michael@redpriest _Write_a_node__140596620.py"

This is the workhorse of the program, exporting the text in a node
to the output file in a way that the AsciiDoc program will
recognize.

The basic activity is:
    - output the node headline as a DocBook section heading (Book,
      Chapter, Section1, Section2, etc.)
    - scan each line of the body text for directives, and take the
      appropriate action.  Regular expressions do the heavy lifting.
    - mark the code sections and documentation sections, so that
      DocBook can print them in the correct styles.
    - ensure that code lines do not exceed a maximum length.



@code
def WriteNode(v,startinglevel, ascFile):

    'Writes the contents of the node v to the ascFile.'

    containsAscIignore = None          # initialize
    skippingDocLines = False
    startingCodeExtract = False
    inCodeExtract = False
    statusOfWriteOutputLine = None

    def WriteOutputLine(lineString):

        'Writes a line of text to the output file.'
        try:
            ascFile.write("%s\n" % lineString)
        except IOError:
            g.es("Could not write to output file: %s" % ascFile.name)
            statusOfWriteOutputLine = CV.END_PROGRAM


    # ----- get the headline text ------------------------------------------
    h = v.headString()
    markedupAsSection = patternSectionName.match(h)
    if markedupAsSection:
        h = markedupAsSection.group(1) # dump the angle brackets

    # ----- put the body text into a list of lines -------------------------
    bodyString = v.bodyString()
    lines = bodyString.splitlines()

    lastLinePrintedType = CV.LINE_WAS_NONE
    # ----- by default, nodes start with a code section --------------------
    pendinglineType = CV.LINE_PENDING_CODE

    for line in lines:
        containsRootDirective = None

@doc

If this line starts a code extract, called a Section Definition
here, then extract the text to use as the title and set the
"startingCodeExtract" flag to guide further processing.

@code
        containsSectionDefinition = patternSectionDefinition.match(line)
        if containsSectionDefinition:
            # dump the angle brackets, etc.
#             line = containsSectionDefinition.group(2)  + '\n' + \
#                    (SectionUnderline(containsSectionDefinition.group(2),2,v))
            line = '.' + containsSectionDefinition.group(2)
            pendinglineType = CV.LINE_PENDING_CODE
            startingCodeExtract = True
@doc

Check if this line starts a @doc or @code section.

@code
        containsCodeDirective = patternCodeDirective.match(line)
        if containsCodeDirective:
            pendinglineType = CV.LINE_PENDING_CODE
            skippingDocLines = False
            continue                    # don't print this line

        containsDocDirective = patternDocDirective.match(line)
        if containsDocDirective:
            pendinglineType = CV.LINE_PENDING_DOC
            if containsDocDirective.group(2):
                # it is legal to have text on the same line
                # as a doc directive.
                line = containsDocDirective.group(2)
            else:
                continue
@doc

Check line for a Leo2AsciiDoc directive, and if so, act on it.

@code
        containsAscDirective = patternAscDirective.match(line)
        if containsAscDirective:
            containsAscIignore = patternAscDirectiveIgnore.match(line)
            if containsAscIignore:
                break

            containsAscExit = patternAscDirectiveExit.match(line)
            if containsAscExit:
                break

            containsAscSkip = patternAscDirectiveSkip.match(line)
            if containsAscSkip:
                containsAscSkipDirectiveToggle = patternAscDirectiveSkipToggle.match(line)
                if containsAscSkipDirectiveToggle:
                    if containsAscSkipDirectiveToggle.group(1).lower() == "on":
                        skippingDocLines = True
                    elif containsAscSkipDirectiveToggle.group(1).lower() == "off":
                        skippingDocLines = False
                continue

        containsOtherDirective = patternDirective.match(line)
        if containsOtherDirective:
            containsRootDirective = patternRootDirective.match(line)
            if containsRootDirective:
                line = "*note*\nThe code sections that follow, when extracted from a " + \
                       "Leo outline, will be located in: %s\n*note*" % \
                       containsRootDirective.group(1)
            else:
                continue

        # ----- we have something to print, so print heading ---------------
        if lastLinePrintedType == CV.LINE_WAS_NONE:
            if (len(h) &gt; 0) and (Conf.current["PrintHeadings"] == "on"):
                WriteOutputLine("\n\n%s" % h)
                WriteOutputLine(SectionUnderline(h,v.level()-startinglevel,v))
                lastLinePrintedType = CV.LINE_WAS_HEAD
@doc

Here we manage the transitions between code and doc sections.

@code
        if pendinglineType == CV.LINE_PENDING_DOC:
            if lastLinePrintedType != CV.LINE_WAS_DOC and \
               lastLinePrintedType != CV.LINE_WAS_HEAD:
                WriteOutputLine("%s" % Conf.current["delimiterForCodeEnd"])
                if inCodeExtract:
                    WriteOutputLine("\n%s" % Conf.current["delimiterForCodeSectionDefinition"])
                    inCodeExtract = False
                lastLinePrintedType = CV.LINE_WAS_DOC
            if skippingDocLines:
                if not containsRootDirective: # always document a root directive
                    continue

        if pendinglineType == CV.LINE_PENDING_CODE:
            if lastLinePrintedType != CV.LINE_WAS_CODE:
                if startingCodeExtract:
                    WriteOutputLine("\n%s" % line)
                    WriteOutputLine("%s" % Conf.current["delimiterForCodeSectionDefinition"])
                    inCodeExtract = True
                    line = ''
                WriteOutputLine("%s" % Conf.current["delimiterForCodeStart"])
                lastLinePrintedType = CV.LINE_WAS_CODE
                if startingCodeExtract:
                    startingCodeExtract = False
                    continue
@doc

Check for maximum code line length.  Finally, output the text to the
export file.

@code
            maxCodeLineLength = int(Conf.current["maxCodeLineLength"])
            if len(line) &lt;= maxCodeLineLength:
                WriteOutputLine("%s" % line)
            elif len(line.rstrip()) &lt;= maxCodeLineLength:
                WriteOutputLine("%s" % line.rstrip())
            else:
                lineList = CodeChunk(line, maxCodeLineLength)
                for ln in lineList:
                    WriteOutputLine("%s" % ln)
            lastLinePrintedType = CV.LINE_WAS_CODE
        else:
            WriteOutputLine("%s" % line)

        if statusOfWriteOutputLine != None:
            return statusOfWriteOutputLine

@doc

Before we leave, make sure that any ending code section is marked as
ended.

@code
    if lastLinePrintedType == CV.LINE_WAS_CODE:
        WriteOutputLine("%s" % Conf.current["delimiterForCodeEnd"])
        if inCodeExtract:
            WriteOutputLine("\n%s" % Conf.current["delimiterForCodeSectionDefinition"])
            inCodeExtract = False

    if containsAscIignore != None:
        return CV.NODE_IGNORE                        # flag ignore tree to caller

@doc

</t>
<t tx="ekr.20040331071919.14">@doc
@ascskip # Time-stamp: "Tue, Jan 13 11:09 CST 2004  michael@redpriest Other_programs_140636444.txt"

The appendices are about other programs that are used with Leo.
I'm including them because they are examples of how my setup works,
for those who may be interested in setting up something similar.

    - AsciiDoc is the program that processes the output from Leo2AsciiDoc
      into a DocBook-ready XML file.
    - Setting up DocBook is a topic that is far too large for this
      little manual, but the DocBook section which follows contains
      documentation of exactly how my working system is configured.
    - The XEmacs text editor is the one I prefer, but it is not
      necessary for the use of Leo2AsciiDoc.  Others who also use XEmacs
      might find the documentation of my Leo integration and
      multi-mode support to be useful.
@code</t>
<t tx="ekr.20040331071919.15">@language plain
@ascskip Time-stamp: "Thu, Oct 30 10:58 CST 2003  michael@redpriest Appendix_AsciiDoc__140954356.txt"
@doc
anchor:AsciiDoc[AsciiDoc]

The AsciiDoc program is written by Stuart Rackham and has its own
web site at http://www.methods.co.nz/asciidoc/[], with full
documentation.

AsciiDoc is a small program, written in Python, that reads text
which is in the AsciiDoc text format. Generally speaking, ordinary
text (such as you would write in an email message) is already in the
AsciiDoc format.  The AsciiDoc program produces (among other
choices) output in the DocBook XML format.

Text exported from a Leo outline by Leo2AsciiDoc is ready to be processed
by AsciiDoc, once AsciiDoc has been configured to recognize it.

Leo2AsciiDoc comes with an AsciiDoc configuration file that will enable
AsciiDoc to process all Leo2AsciiDoc features.  The following section
describes that configuration file.

Of course, you don't need to read or understand the configuration
file to use it.  Simply put it (leo-docbook.conf) in the same
directory as AsciiDoc's "docbook.conf" file.  When you invoke
AsciiDoc (see the xref:Makefile[] section in the DocBook appendix for
examples), give the "leo-docbook.conf" file as the configuration
parameter ("-f leo-docbook.conf".)

@ascskip on
&lt;&lt; Appendix: AsciiDoc &gt;&gt;
@code
</t>
<t tx="ekr.20040331071919.16">@language python
@tabwidth -4

@doc
@ascskip # Time-stamp: "Tue, Jan 13 11:58 CST 2004  michael@redpriest _Configuration_file__140640380.py"

AsciiDoc is customized through the use of configuration files, which
cascade, so that you can include other configuration files and
then proceed to add your changes.

The main elements of the configuration file below:

    - adds chapter and web site document types
    - switches code listings to use the DocBook "programlisting"
      element 

    *note*

    If you choose to export this configuration file from the Leo
    outline, you will have to remove escape charactersfrom some
    lines after you have exported it.

    Specifically, some lines begin with the character "\".  That
    character should be removed.

    *note*

@ascskip on
@root "other/asciidoc/leo-docbook.conf"
&lt;&lt; Configuration File &gt;&gt;
@code
# Start with the standard docbook back end configuration.
# ensure the next line is uncommented before installing
\include::docbook.conf[]

@doc

I want tabs interpreted as 4 spaces.

@code
[options]
tabsize=4
@doc

Interpret an indented paragraph as a simple paragraph.

@code
[indentedparagraph]
&lt;simpara&gt;|&lt;/simpara&gt;


@doc

For our code listings we invent a new markup that will use the
DocBook programlisting element.

@code
[blockdef-leocode]
delimiter=^\~\-~--- code(.*?)$
section=programlistingblock
presubs=specialcharacters, replacements

[programlistingblock]
&lt;programlisting&gt;
|
&lt;/programlisting&gt;

@doc

We add new markup to signify the DocBook "note" element.  This
predates AsciiDoc 5.0, and is still useful.

@code
[blockdef-note]
delimiter=^ *\*note\*$
section=noteblock
presubs=specialcharacters,quotes,specialwords,replacements,macros,glossary

# Block macro
[noteblock]
&lt;note&gt;
|
&lt;/note&gt;

[blockdef-example]
delimiter=^ *\*example\*$
options=section
section=exampleblock
presubs=replacements

# Block macro
[exampleblock]
&lt;example&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/example&gt;


@doc

The following replacements ensure basic Python code indexing.

@code
[replacements]
#----- indexing markup -----------------------------------------------------
# using regular expressions because I don't want to introduce a filter, which
# would slow things down.
#
# index python classes and defs
^(def +)(.+?)(\(.+:)=\1\2\3&lt;indexterm&gt;&lt;primary&gt;Python code, functions&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 
^(class +)(.+?)(:)=\1\2\3&lt;indexterm&gt;&lt;primary&gt;Python code, classes&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 
^( +def +)(.+?)(\(.+:)=\1\2\3&lt;indexterm&gt;&lt;primary&gt;Python code, methods and nested functions&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 

# index code extracts
(\&amp;lt\;\&amp;lt\;)(.+?)(\&amp;gt\;\&amp;gt\;\=)=\2&lt;indexterm&gt;&lt;primary&gt;Python code, extracts explained&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt;
(\&amp;lt\;\&amp;lt\;)(.+?)(\&amp;gt\;\&amp;gt\;)(\s*$)=\1\2\3\4&lt;indexterm&gt;&lt;primary&gt;Python code, extracts used&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 

@doc

Change the standard AsciiDoc article, book and manpage definition to
use the DocBook 4.2 DTD.  Add an empty index element to the end of
the book definition so that DocBook will automatically generate an
index.

@code
#---------------------------------------------------------------------------
#----- article -------------------------------------------------------------
#---------------------------------------------------------------------------

# changing to our version of the docbook dtd
\ifdef::doctype-article[]

[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE article
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;

&lt;article lang="en"&gt;
&lt;articleinfo&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
    &lt;date&gt;{date}&lt;/date&gt;
    &lt;author&gt;
        &lt;firstname&gt;{firstname}&lt;/firstname&gt;
        &lt;othername&gt;{middlename}&lt;/othername&gt;
        &lt;surname&gt;{lastname}&lt;/surname&gt;
        &lt;affiliation&gt;
            &lt;address&gt;
                &lt;email&gt;{email}&lt;/email&gt;
            &lt;/address&gt;
        &lt;/affiliation&gt;
    &lt;/author&gt;
    &lt;authorinitials&gt;{authorinitials}&lt;/authorinitials&gt;
    &lt;revhistory&gt;&lt;revision&gt;&lt;revnumber&gt;{revision}&lt;/revnumber&gt;&lt;date&gt;{date}&lt;/date&gt;&lt;/revision&gt;&lt;/revhistory&gt;
    &lt;corpname&gt;{companyname}&lt;/corpname&gt;
&lt;/articleinfo&gt;

\endif::doctype-article[]


#---------------------------------------------------------------------------
#----- book ----------------------------------------------------------------
#---------------------------------------------------------------------------
# change to our version of docbook dtd

\ifdef::doctype-book[]

[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE book
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;

&lt;book lang="en"&gt;
&lt;bookinfo&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
    &lt;date&gt;{date}&lt;/date&gt;
    &lt;author&gt;
        &lt;firstname&gt;{firstname}&lt;/firstname&gt;
        &lt;othername&gt;{middlename}&lt;/othername&gt;
        &lt;surname&gt;{lastname}&lt;/surname&gt;
        &lt;affiliation&gt;
            &lt;address&gt;
                &lt;email&gt;{email}&lt;/email&gt;
            &lt;/address&gt;
        &lt;/affiliation&gt;
    &lt;/author&gt;
    &lt;authorinitials&gt;{authorinitials}&lt;/authorinitials&gt;
    &lt;revhistory&gt;&lt;revision&gt;&lt;revnumber&gt;{revision}&lt;/revnumber&gt;&lt;date&gt;{date}&lt;/date&gt;&lt;/revision&gt;&lt;/revhistory&gt;
    &lt;corpname&gt;{companyname}&lt;/corpname&gt;
&lt;/bookinfo&gt;


[footer]
&lt;index/&gt;
&lt;/book&gt;

\endif::doctype-book[]

#---------------------------------------------------------------------------
#----- manpage -------------------------------------------------------------
#---------------------------------------------------------------------------
\ifdef::doctype-manpage[]

[header]
&lt;!DOCTYPE refentry
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;
&lt;refentry&gt;
# The refentryinfo element is legal and should not normally be printed.
# Unfortunately some docbook processors do print it.
&lt;refentryinfo&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
    &lt;date&gt;{date}&lt;/date&gt;
    &lt;author&gt;
        &lt;firstname&gt;{firstname}&lt;/firstname&gt;
        &lt;othername&gt;{middlename}&lt;/othername&gt;
        &lt;surname&gt;{lastname}&lt;/surname&gt;
        &lt;affiliation&gt;
            &lt;address&gt;
                &lt;email&gt;{email}&lt;/email&gt;
            &lt;/address&gt;
        &lt;/affiliation&gt;
    &lt;/author&gt;
    &lt;authorinitials&gt;{authorinitials}&lt;/authorinitials&gt;
    &lt;revhistory&gt;&lt;revision&gt;&lt;revnumber&gt;{revision}&lt;/revnumber&gt;&lt;date&gt;{date}&lt;/date&gt;&lt;/revision&gt;&lt;/revhistory&gt;
    &lt;corpname&gt;{companyname}&lt;/corpname&gt;
&lt;/refentryinfo&gt;
&lt;refmeta&gt;
&lt;refentrytitle&gt;{mantitle}&lt;/refentrytitle&gt;
&lt;manvolnum&gt;{manvolnum}&lt;/manvolnum&gt;
&lt;/refmeta&gt;
&lt;refnamediv&gt;
    &lt;refname&gt;{manname}&lt;/refname&gt;
    &lt;refpurpose&gt;{manpurpose}&lt;/refpurpose&gt;
&lt;/refnamediv&gt;

\endif::doctype-manpage[]



@doc

Add chapter and website document types.

@code
#---------------------------------------------------------------------------
#----- new: chapter --------------------------------------------------------
#---------------------------------------------------------------------------
\ifdef::doctype-chapter[]

[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE chapter
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;
&lt;chapter&gt;
&lt;title&gt;{doctitle}&lt;/title&gt;

[footer]
&lt;/chapter&gt;


# Section macros
# Using &lt;abstract&gt; semantics restricts preface to &lt;simpara&gt; elements.
[preface]
|

[sect1]
&lt;sect1&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/sect1&gt;

[sect2]
&lt;sect2&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/sect2&gt;

[sect3]
&lt;sect3&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/sect3&gt;

[options]
outfilesuffix=.xml

\endif::doctype-chapter[]

@doc

Website requires a unique id for each page.  I've changed AsciiDoc
to provide the HTML filename as the id, and we use it here. We'll
use the date the XML file was created as the update date.

@code
#---------------------------------------------------------------------------
#----- new: website --------------------------------------------------------
#---------------------------------------------------------------------------
\ifdef::doctype-website[]
[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE webpage SYSTEM "website-full.dtd"&gt;
&lt;webpage id="{infilebase}"&gt;
  &lt;head&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
  &lt;/head&gt;
  &lt;config param="rcsdate" value="Updated: {localdate}  {localtime}"/&gt;
[footer]
&lt;/webpage&gt;

[options]
outfilesuffix=.xml

\endif::doctype-website[]

</t>
<t tx="ekr.20040331071919.17">@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 14:11 CST 2004  michael@redpriest _Patches__140641532.txt"

I've patched the source code for AsciiDoc (asciidoc.py) with a few
small changes to allow AsciiDoc to process chapters and DocBook
web site documents as well as the DocBook book format.  Since I use
Linux, I also changed the default line-ending code to the Linux
default.

For the exact changes I made, the following output at the end of
this section was created by GNU diff (version 2.8.4) with the
command

---
LC_ALL=C TZ=UTC0 diff -Naur 5.0.2-original 5.0.2-mrc-patched \
    &gt;mrc-asciidoc-5.0.2-patch-diff
---

I include this mainly so that you can see the exact changes I made.
However, you may want to patch a copy of the original in exactly the
same way. 

To patch a copy of the original asciidoc.py (version 5.0.2), one
would use the patch command as follows (when in the same directory
as the copy of asciidoc.py and mrc-asciidoc-5.0.2-patch-diff)

---
patch -Np1 &lt;mrc2-asciidoc-5.0.2-patch-diff
---

@ascskip on
@root "other/asciidoc/mrc-asciidoc-5.0.2-patch-diff"
&lt;&lt; Patches &gt;&gt;
@code
diff -Naur 5.0.2-original/asciidoc.py 5.0.2-mrc-patched/asciidoc.py
--- 5.0.2-original/asciidoc.py	2003-12-16 00:16:28.000000000 +0000
+++ 5.0.2-mrc-patched/asciidoc.py	2004-01-08 17:45:37.000000000 +0000
@@ -838,12 +838,15 @@
         '''Set predefined glossary entries that follow configuration file
         loading.'''
         self.glossary['infile'] = reader.fname
+        # mwd Monday, June 23, 2003 for use in website
+        self.glossary['infilebase'] = os.path.splitext(os.path.split(reader.fname)[1]) [0]
         self.glossary['outfile'] = reader.fname
         s = os.path.splitext(writer.fname)[1][1:]   # Output file extension.
         self.glossary['filetype'] = s
         self.glossary['filetype-'+s] = ''
     def translate(self):
-        assert self.doctype in ('article','manpage','book'), \
+        # mwd 2003-Jun-23 assert self.doctype in ('article','manpage','book'), \
+        assert self.doctype in ('article','chapter','website','manpage', 'book'), \
             'illegal document type'
         assert self.level == 0
         reader.tabsize = config.tabsize
@@ -864,7 +867,8 @@
             if not config.suppress_headers:
                 hdr = config.subs_section('header',{})
                 writer.write(hdr)
-            if self.doctype in ('article','book'):
+            # mwd 2003-Jun-23 if self.doctype in ('article','book'):
+            if self.doctype in ('article','book','chapter','website'):
                 # Translate 'preamble' (untitled elements between header
                 # and first section title).
                 if Lex.next() is not Title:
@@ -952,7 +956,7 @@
                 # Parse revision line.
                 s = reader.read()
                 s = subs_glossary([s])[0]
-                # Match RCS/CVS $Id$ marker format.
+                # Match RCS/CVS $Id$ marker format.
                 mo = re.match(r'^\$Id: \S+ (?P&lt;revision&gt;\S+)' \
                     ' (?P&lt;date&gt;\S+) \S+ \S+ \S+ \$$',s)
                 if not mo:
@@ -2573,7 +2577,8 @@
 
 class Writer:
     '''Writes lines to output file.'''
-    EOL = '\r\n'    # End of line terminator.
+    # mwd 2003-Jun-23 EOL = '\r\n'    # End of line terminator.
+    EOL = '\n'    # End of line terminator.
     f = None        # Output file object.
     fname= None     # Output file name.
     lines_out = 0   # Number of lines written.
@@ -3068,7 +3073,8 @@
     The AsciiDoc document is read from file object src the translated
     DocBook file written to file object dst.'''
     try:
-        if doctype not in ('article','manpage','book'):
+        # mwd-2004-Jan-05 if doctype not in ('article','manpage','book'):
+        if doctype not in ('article','chapter','website','manpage', 'book'):
             raise EAsciiDoc,'illegal document type'
         if backend == 'linuxdoc' and doctype != 'article':
             raise EAsciiDoc,'%s %s documents are not supported' \
</t>
<t tx="ekr.20040331071919.18">@language plain
@ascskip Time-stamp: "Fri, Dec 19 11:48 CST 2003  michael@redpriest Appendix_DocBook_140578660.txt"
@doc

anchor:DocBook[DocBook]
DocBook is a project that provides:

    - a specification for the text markup (DTD) of DocBook XML
      documents, and
    - a set of XSLT stylesheets that can be used by an XSLT engine
      to transform those XML documents to HTML, PDF, etc.
      
If you create your text documents using the rules in the DocBook
DTD, you can use the DocBook XSLT stylesheets to produce various
output formats, such as HTML and PDF.

The DocBook project is designed for the production of computer
documentation, but is actually used for a wide variety of documents.

Some web resources:

    - the official home page for DocBook: The Definitive Guide:
        http://docbook.org/[]
    - DocBook Basics:
        http://www.dpawson.co.uk/docbook/reference.html[]
    - DocBook Open Repository:
        http://sourceforge.net/projects/docbook/[]
    - DocBook XSL: The Complete Guide:
        http://www.sagehill.net/docbookxsl/index.html[]

I include this section as documentation of one setup that works --
it translates Leo2AsciiDoc output to HTML and PDF.

This is not a guide to the installation, setup and operation of
DocBook, just an example of a working system.

@ascskip on
&lt;&lt; Appendix: DocBook &gt;&gt;
@code
</t>
<t tx="ekr.20040331071919.19">@doc
@ascskip # Time-stamp: "Thu, Jan  8 13:57 CST 2004  michael@redpriest _Tool_Chain__140810780.txt"

Documents go through a number of stages in their creation.  Each
stage may involve one or more tools or programs, which form a tool
chain: each performing some processing and handing off to the next.

As a simple example, for this document:


    - text creation was handled by XEmacs, a text
      editor (which functioned as a Leo plugin.)
      indexterm:[XEmacs]
      indexterm:[GNU Make]
      indexterm:[AsciiDoc]
      indexterm:[xsltproc]
      indexterm:[FOP]
    - text storage and organization was handled by Leo, an outlining
      editor.
    - text was exported from Leo to a plain-text file, using the
      Leo2AsciiDoc program.
    - from there, all transformations are automated by the
      GNU Make program.
    - the DocBook XML document was created by the
      AsciiDoc program, which transformed the
      plain-text file to XML.
    - The HTML pages were created by the
      xsltproc program. xsltproc read the XML
      document, and the DocBook XSLT stylesheets, and then created
      each HTML page.
    - To make the PDF file, the xsltproc program used the same
      process as for the HTML pages, except that it created a
      Formatting Objects (FO) file instead.  Then the
      FOP program processed the FO file, producing
      the final PDF file.  This process was also automated.

All I did was type in text for each section, arranging it much as I
usually do for email.  The rest was handled automatically by
clicking on a Leo menu, or entering a short command at the console.
For example: "make all".

There are many, many choices of tools to put in your DocBook tool
chain.  You can even purchase complete packages, from text editing
to PDF generation.

@code</t>
<t tx="ekr.20040331071919.20">@language plain
@tabwidth 4
@doc
@ascskip # Time-stamp: "Thu, Jan 15 15:39 CST 2004  michael@redpriest _Make_File__140651828.txt"

anchor:Makefile[Makefile]
In my case, I use a standard unix-style "make" setup for processing
the text exported from a Leo outline.  It simply automates the
commands which I would otherwise have to type at the command line.

After Leo2AsciiDoc exports the text from the Leo outline to a disk file,
the Make program takes over.  It reads rules in a file named
"Makefile" and calls the necessary programs to make the
requested output.

This Makefile takes over where Leo2AsciiDoc leaves off.  It directs the
AsciiDoc conversion of the Leo2AsciiDoc text file to XML, and then the
DocBook conversion of the XML file to HTML pages or a PDF document.

indexterm:[GNU Make]
I use GNU Make.  For example, assuming I am in xterm and located in
the same directory as the Makefile, I just enter the command

---
make pdf-dev
---
and the make program guides the creation of the PDF version of The
Developers Guide, using the instructions in this Makefile.  The PDF
is available within seconds.

The Makefile instructions, in brief:

    - the AsciiDoc program is called to make an XML file.
    - the xsltproc program is called to process the XML file to
      either HTML or a Formatting Objects file for further
      translation to PDF
        * various XSLT style sheets (html.xsl, man.xsl, etc.) are
          used by xsltproc to guide the transformation of the XML
          file.  Typically, they call the DocBook stylesheets for
          the heavy lifting, and set a few simple options.
    - the FOP program is used to process the intermediate fo file to
      the final PDF file.

This is by no means a model Makefile.  It is included because it
works for me in my office, and may thus be useful as an example for
other people who want to set up Make for this purpose.

@ascskip xemacs-makefile-mode-on
@ascskip on
@root "doc/Makefile"
&lt;&lt; Make File &gt;&gt;
@code
#----- global variables -----------------------------------------
DEVGUIDE=mod_asc_dev
USERGUIDE=mod_asc_user
CSS=dbstyle.css

MAN=${DOC}.1
STYLESHEET_MAN=man.xsl
# default docbook, located by /etc/xml/catalog
STYLESHEET_MAN_HTML=docbook.xsl
MAN_OUTPUT_DIR=man

STYLESHEET_HTML=html.xsl
HTML_DEV_OUTPUT_DIR=html-dev
HTML_USER_OUTPUT_DIR=html-user
STYLESHEET_CHUNK=chunkit.xsl
CHUNK_DEV_OUTPUT_DIR=chunk-dev
CHUNK_USER_OUTPUT_DIR=chunk-user

STYLESHEET_FO_FOP=fo-fop.xsl
PDF_DEV_OUTPUT_DIR=pdf-dev
PDF_USER_OUTPUT_DIR=pdf-user

ASCIIDOC_COMMAND=python asciidoc/asciidoc.py -v -b docbook -d book
ASCIIDOC_CONFIG=asciidoc/leo-docbook.conf

#   $@ target file name
#   $&lt; name of the first prerequisite
#   $* stem that rule matched

#----- pattern rules -------------------------------------------------------
%.xml	:	%.asc
#	asciidoc -b docbook -d book -f ${ASCIIDOC_CONFIG} -o $@ $&lt;
    ${ASCIIDOC_COMMAND}  -f ${ASCIIDOC_CONFIG} -o $@ $&lt;
    xsltproc --output $*.final.xml customize.xsl $@


%.html	:	%.xml css
    xsltproc --xinclude --output ${OUTPUT} ${STYLESHEET}  $*.final.xml
    touch $*.xml

%.pdf	:	%.xml
    xsltproc --xinclude  --output ${OUTPUT}/$*.fo $(STYLESHEET) $*.final.xml
    fop -fo  ${OUTPUT}/$*.fo  -pdf ${OUTPUT}/$*.pdf 
    -$(RM) ${OUTPUT}/$*.fo

#----- usage ---------------------------------------------------------------
usage	:
    @echo; echo "primary make modules: html-dev chunk-dev pdf-dev"
    @echo       "                      html-user chunk-user pdf-user"
    @echo



#---------------------------------------------------------------------------
#----- modules -------------------------------------------------------------
#---------------------------------------------------------------------------

# docbook
#---------------------------------------------------------------------------

all	:	css pdf-dev html-dev sub-chunk-dev html-user sub-chunk-user pdf-user

#----- DocBook html stylesheet ---------------------------------------------
css:
    cat base.css   &gt;  $(CSS)
    cat docstyle.css &gt;&gt; $(CSS)

#----- Developers Guide ----------------------------------------------------
#   #----- one page -----------------------------------------------------
html-dev	:	STYLESHEET=$(STYLESHEET_HTML)
html-dev	:	OUTPUT=${HTML_DEV_OUTPUT_DIR}/$*.html
html-dev	:	mkdirhtmldev ${DEVGUIDE}.html
    cp ${CSS} ${HTML_DEV_OUTPUT_DIR}

mkdirhtmldev	:	cleanhtmldev
    mkdir ${HTML_DEV_OUTPUT_DIR}

#   #----- individual pages ------------------------------------------------
chunk-dev	:	STYLESHEET=$(STYLESHEET_CHUNK)
chunk-dev	:	OUTPUT=$(CHUNK_DEV_OUTPUT_DIR)/
chunk-dev	:	mkdirchunkdev ${DEVGUIDE}.html
    cp chunk-dev-frame*.html ${CHUNK_DEV_OUTPUT_DIR}
    cp ${CSS} ${CHUNK_DEV_OUTPUT_DIR}
    cp frametoc.css ${CHUNK_DEV_OUTPUT_DIR}
    cp -r ../graphics ${CHUNK_DEV_OUTPUT_DIR}
# put in frame target line
    sed -f sed-dev-frame ${CHUNK_DEV_OUTPUT_DIR}/index.html &gt;${CHUNK_DEV_OUTPUT_DIR}/chunk-dev-frame-toc.html

mkdirchunkdev	:	cleanchunkdev
    mkdir ${CHUNK_DEV_OUTPUT_DIR}

sub-chunk-dev	:
    ${MAKE} chunk-dev

#----- Users Guide ---------------------------------------------------------
#   #----- one page -----------------------------------------------------
html-user	:	STYLESHEET=$(STYLESHEET_HTML)
html-user:	OUTPUT=${HTML_USER_OUTPUT_DIR}/$*.html
html-user:	mkdirhtmluser ${USERGUIDE}.html
    cp ${CSS} ${HTML_USER_OUTPUT_DIR}

mkdirhtmluser	:	cleanhtmluser
    mkdir ${HTML_USER_OUTPUT_DIR}

#   #----- individual pages ------------------------------------------------
chunk-user	:	STYLESHEET=$(STYLESHEET_CHUNK)
chunk-user	:	OUTPUT=$(CHUNK_USER_OUTPUT_DIR)/
chunk-user	:	cleanchunkuser ${USERGUIDE}.html
    cp chunk-user-frame*.html ${CHUNK_USER_OUTPUT_DIR}
    cp ${CSS} ${CHUNK_USER_OUTPUT_DIR}
    cp frametoc.css ${CHUNK_USER_OUTPUT_DIR}
    cp -r ../graphics ${CHUNK_USER_OUTPUT_DIR}
# put in frame target line
    sed -f sed-user-frame ${CHUNK_USER_OUTPUT_DIR}/index.html &gt;${CHUNK_USER_OUTPUT_DIR}/chunk-user-frame-toc.html

mkdirchunkuser	:	cleanchunkuser
    mkdir ${CHUNK_USER_OUTPUT_DIR}

sub-chunk-user	:
    ${MAKE} chunk-user

#   #----- pdf -------------------------------------------------------------
pdf-dev		:	STYLESHEET=$(STYLESHEET_FO_FOP)
pdf-dev		:	OUTPUT=$(PDF_DEV_OUTPUT_DIR)
pdf-dev		:	mkdirpdf ${DEVGUIDE}.pdf

pdf-user		:	STYLESHEET=$(STYLESHEET_FO_FOP)
pdf-user		:	OUTPUT=$(PDF_USER_OUTPUT_DIR)
pdf-user		:	mkdirpdf ${USERGUIDE}.pdf

#   mkdirpdf exists only to make an empty directory for the pdf working files
mkdirpdf	:
    -mkdir $(PDF_DEV_OUTPUT_DIR)
    -mkdir $(PDF_USER_OUTPUT_DIR)




#----- clean ---------------------------------------------------------------
clean	: cleanhtml cleanchunk cleanpdf cleanman cleanclutter 

cleanhtml	:	cleanhtmluser cleanhtmldev

cleanhtmluser	:
    -$(RM) -r $(HTML_USER_OUTPUT_DIR)

cleanhtmldev	:
    -$(RM) -r $(HTML_DEV_OUTPUT_DIR)

cleanchunk	:	cleanchunkuser cleanchunkdev

cleanchunkuser	:
    -$(RM) -r $(CHUNK_USER_OUTPUT_DIR)

cleanchunkdev	:
    -$(RM) -r $(CHUNK_DEV_OUTPUT_DIR)

cleanpdf	:
    -$(RM) -r $(PDF_OUTPUT_DIR)

cleanman	:
    -$(RM) -r $(MAN_OUTPUT_DIR)

cleanclutter: 
    -$(RM) -r *.xml

.PRECIOUS	:	%.xml
@doc
@ascskip xemacs-makefile-mode-off
@code
</t>
<t tx="ekr.20040331071919.21">@silent
@doc
@ascskip # Time-stamp: "Wed, Oct  1 15:33 CST 2003  michael@redpriest _Style_Sheets__140741140.txt"

When the Makefile calls the xsltproc program, it gives it the name
of an XSLT stylesheet to guide the production of the result.

Following are simple XSLT stylesheets that are used to:
    - set formatting options, and
    - call the main DocBook XSLT stylesheets.

The stylesheets cascade (each adding its options to the total), with
the original stylesheet including others as needed, and always
calling the main DocBook stylesheets at some point.

@code
</t>
<t tx="ekr.20040331071919.22">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:01 CST 2004  michael@redpriest _General__139758588.txt"

indexterm:[Stylesheets, common-links.xsl]
This is the entire common-links style sheet ("common-links.xsl"),
which sets basic Table of Contents and chapter cross-reference
preferences.

This stylesheet is called by both HTML and PDF stylesheets.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/common-links.xsl"
&lt;&lt; General &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 

&lt;!--===== 
    This changes a chapter cross-reference to include the chapter
    title text. 
--&gt;
&lt;xsl:param name="local.l10n.xml" select="document('')"/&gt; 
&lt;l:i18n xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0"&gt; 
  &lt;l:l10n language="en"&gt; 
    &lt;l:context name="xref"&gt; 
      &lt;l:template name="chapter" text="Chapter %n: &amp;#8220;%t&amp;#8221;"/&gt; 
    &lt;/l:context&gt;   
  &lt;/l:l10n&gt;
&lt;/l:i18n&gt;

&lt;xsl:param name="generate.toc"&gt;
book      toc,title,figure,table,example,equation
chapter   title
&lt;/xsl:param&gt;

&lt;!-- only 1 toc in the doc --&gt;
&lt;xsl:param name="generate.section.toc.level" select="1"/&gt;

&lt;!-- toc shows 3 levels of sections --&gt;
&lt;xsl:param name="toc.section.depth"&gt;3&lt;/xsl:param&gt;

&lt;xsl:param name="generate.index" select="1"&gt;&lt;/xsl:param&gt;

&lt;!--===== omit the title for notes, tips ================================--&gt;
&lt;xsl:param name="admon.textlabel" select="0"&gt;&lt;/xsl:param&gt;

&lt;/xsl:stylesheet&gt;
@doc
@ascskip xemacs-xsl-mode-off


</t>
<t tx="ekr.20040331071919.23">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 20 11:42 CST 2004  michael@redpriest _Customize__141637044.txt"


indexterm:[customize.xsl]
This is the entire customize style sheet ("customize.xsl", which is
used by the Makefile to make changes to the standard xml file
produced from the AsciiDoc output.  It results in a file suffixed
".final.xml" which is used by both the HTML and PDF stylesheets.

Currently, the stylesheet copies the xml file:

    - changing any chapter elements that have a title beginning
      with "Appendix: " to DocBook appendix elements.  This is from
      AsciiDoc 3.2 days, when AsciiDoc didn't know about appendix
      elements. I haven't yet modified Leo2AsciiDoc to take
      advantage of the automatic appendix elements in AsciiDoc 5.0.
    - adding custom bookinfo elements

I've used XSLT for this, but it could have been done with python,
AWK, sed, or other tools.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/customize.xsl"
&lt;&lt; Customize &gt;&gt;
@code
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="1.0"&gt;

&lt;xsl:variable name="AppendBegin"&gt;Appendix: &lt;/xsl:variable&gt;

&lt;!--~~~~~~ copy everything ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--&gt;
&lt;xsl:template match="@*|node()"&gt;
   &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
   &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;!--~~~~~~ delete the appendix string from the title ~~~~~~~~~~~~~~~~~~~~--&gt;
&lt;xsl:template match="/book/chapter/title[starts-with(text(),$AppendBegin)]"&gt;
  &lt;title&gt;
  &lt;xsl:value-of select="substring-after(text(),$AppendBegin)"/&gt;
  &lt;/title&gt;
  &lt;xsl:apply-templates select="*" /&gt; 
&lt;/xsl:template&gt;

&lt;!--~~~~~~ change appendix chapter element to appendix element ~~~~~~~~~~--&gt;
&lt;xsl:template match="/book/chapter[starts-with(title,$AppendBegin)]"&gt;
  &lt;appendix&gt;
    &lt;xsl:apply-templates select="*" /&gt; 
  &lt;/appendix&gt;
&lt;/xsl:template&gt;

&lt;!--~~~~~~ bookinfo ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--&gt;
&lt;!--
From Leo2AsciiDoc, only the bookinfo title is filled in, with a
blank author.  Here, we replace the author element with any and all
bookinfo elements we please.
--&gt;
  
&lt;xsl:template match="/book/bookinfo/author"&gt;
  &lt;author&gt;
    &lt;firstname&gt;Michael&lt;/firstname&gt;&lt;surname&gt;Dawson&lt;/surname&gt;
    &lt;affiliation&gt;
      &lt;address&gt;
        &lt;otheraddr&gt;
          &lt;ulink url="http://www.marshallresearch.com/contact.html"&gt;
            at Marshall Research
          &lt;/ulink&gt;
        &lt;/otheraddr&gt;
      &lt;/address&gt;
    &lt;/affiliation&gt;
  &lt;/author&gt;
  &lt;revhistory&gt;
    &lt;revision&gt;
      &lt;revnumber&gt;0.4a&lt;/revnumber&gt;
      &lt;date&gt;Jan 21 2004&lt;/date&gt;
      &lt;authorinitials&gt;mwd&lt;/authorinitials&gt;
      &lt;revremark&gt;Formatting enhancements&lt;/revremark&gt;
    &lt;/revision&gt;
    &lt;revision&gt;
      &lt;revnumber&gt;0.4&lt;/revnumber&gt;
      &lt;date&gt;Jan 19 2004&lt;/date&gt;
      &lt;authorinitials&gt;mwd&lt;/authorinitials&gt;
      &lt;revremark&gt;First release&lt;/revremark&gt;
    &lt;/revision&gt;
  &lt;/revhistory&gt;
&lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;

@doc
@ascskip xemacs-xsl-mode-off

</t>
<t tx="ekr.20040331071919.24">@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:02 CST 2004  michael@redpriest _HTML_One_File__139289780.txt"

indexterm:[Stylesheets,html.xsl]
For one long page of HTML, we simply import the DocBook stylesheets
and our small custom stylesheets that set our standard options.
This is the "html.xsl" stylesheet.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/html.xsl"
&lt;&lt; HTML: One File &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 

&lt;!--===== the catalog (/etx/xml/catalog) will convert this to the local pathname --&gt;
&lt;xsl:import href="docbook.xsl"/&gt;

&lt;xsl:import href="common-links.xsl"/&gt;
&lt;xsl:import href="common-html.xsl"/&gt;

&lt;/xsl:stylesheet&gt; 
@doc
@ascskip xemacs-xsl-mode-off


</t>
<t tx="ekr.20040331071919.25">@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:40 CST 2004  michael@redpriest _HTML_Individual_Pages__141001292.txt"

For individual section pages of HTML, we import the DocBook stylesheets
and our small custom stylesheets that set our standard options.

Then we set our chunking options, and tell the web pages where to
find the header and footer graphics.

indexterm:[Stylesheets,chunkit.xsl]
The following code is the entire chunkit style sheet
("chunkit.xsl").

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/chunkit.xsl"
&lt;&lt; HTML: Individual Pages &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 

&lt;xsl:import href="chunk.xsl"/&gt;

&lt;xsl:import href="common-links.xsl"/&gt;
&lt;xsl:import href="common-html.xsl"/&gt;

&lt;xsl:param name="navig.graphics" select="1"/&gt;
&lt;xsl:param name=
  "navig.graphics.path"&gt;graphics/&lt;/xsl:param&gt;
    &lt;!--  "navig.graphics.path"&gt;/usr/share/xml/docbook/docbook-xsl-1.59.1/images/&lt;/xsl:param&gt;--&gt;
    &lt;!--&lt;xsl:param name="navig.graphics.path"&gt;graphics/dbook/navicons/&lt;/xsl:param&gt;--&gt;
&lt;xsl:param name="navig.graphics.extension"&gt;.png&lt;/xsl:param&gt;
&lt;xsl:param name="navig.showtitles"&gt;1&lt;/xsl:param&gt;

&lt;xsl:param name="chunk.first.sections" select="1"&gt;&lt;/xsl:param&gt;
&lt;xsl:param name="chunk.section.depth" select="2"&gt;&lt;/xsl:param&gt;
&lt;xsl:param name="section.autolabel" select="0"&gt;&lt;/xsl:param&gt;

&lt;xsl:param name="css.decoration"&gt;1&lt;/xsl:param&gt;

&lt;/xsl:stylesheet&gt;

@doc
@ascskip xemacs-xsl-mode-off
</t>
<t tx="ekr.20040331071919.26">@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:58 CST 2004  michael@redpriest _HTML_base_css_style_sheet__141160708.txt"

css style sheet

@ascskip on
@ascskip xemacs-css-mode-on
@root "doc/base.css"
&lt;&lt; HTML: base css style sheet &gt;&gt;
@code
/* base from http://www.w3.org/TR/CSS21/sample.html */

address,
blockquote,
body, dd, div,
dl, dt, fieldset, form,
frame, frameset,
h1, h2, h3, h4,
h5, h6, noframes,
ol, p, ul, center,
dir, hr, menu, pre   { display: block }
li              { display: list-item }
head            { display: none }
table           { display: table }
tr              { display: table-row }
thead           { display: table-header-group }
tbody           { display: table-row-group }
tfoot           { display: table-footer-group }
col             { display: table-column }
colgroup        { display: table-column-group }
td, th          { display: table-cell; }
caption         { display: table-caption }
th              { font-weight: bolder; text-align: center }
caption         { text-align: center }
body            { padding: 8px; line-height: 1.12em }
h1              { font-size: 2em; margin: .67em 0 }
h2              { font-size: 1.5em; margin: .75em 0 }
h3              { font-size: 1.17em; margin: .83em 0 }
h4, p,
blockquote, ul,
fieldset, form,
ol, dl, dir,
menu            { margin: 1.12em 0 }
h5              { font-size: .83em; margin: 1.5em 0 }
h6              { font-size: .75em; margin: 1.67em 0 }
h1, h2, h3, h4,
h5, h6, b,
strong          { font-weight: bolder }
blockquote      { margin-left: 40px; margin-right: 40px }
i, cite, em,
var, address    { font-style: italic }
pre, tt, code,
kbd, samp       { font-family: monospace }
pre             { white-space: pre }

/********** comment **********/
/* http://www.w3.org/TR/CSS21/visuren.html#propdef-display lists inline-block */
button, textarea,
input, object, 
select, img { display:inline-block; }

big             { font-size: 1.17em }
small, sub, sup { font-size: .83em }
sub             { vertical-align: sub }
sup             { vertical-align: super }
s, strike, del  { text-decoration: line-through }
hr              { border: 1px inset }
ol, ul, dir,
menu, dd        { margin-left: 40px }
ol              { list-style-type: decimal }
ol ul, ul ol,
ul ul, ol ol    { margin-top: 0; margin-bottom: 0 }
u, ins          { text-decoration: underline }
/*br:before       { content: "\A" }*/
center          { text-align: center }

/********** changed **********/
/*
abbr, acronym   { font-variant: small-caps; letter-spacing: 0.1em }
*/

:link, :visited { text-decoration: underline }
:focus          { outline: thin dotted invert }

/* Begin bidirectionality settings (do not change) */
BDO[DIR="ltr"]  { direction: ltr; unicode-bidi: bidi-override }
BDO[DIR="rtl"]  { direction: rtl; unicode-bidi: bidi-override }

*[DIR="ltr"]    { direction: ltr; unicode-bidi: embed }
*[DIR="rtl"]    { direction: rtl; unicode-bidi: embed }

@media print {
  h1            { page-break-before: always }
  h1, h2, h3,
  h4, h5, h6    { page-break-after: avoid }
  ul, ol, dl    { page-break-before: avoid }
}



@doc
@ascskip xemacs-css-mode-off
</t>
<t tx="ekr.20040331071919.27">@silent
@doc
@ascskip # Time-stamp: "Wed, Jan 21 09:13 CST 2004  michael@redpriest _HTML_css_style_sheet__140659188.txt"

css style sheet

@ascskip on
@ascskip xemacs-css-mode-on
@root "doc/docstyle.css"
&lt;&lt; HTML: css style sheet &gt;&gt;
@code

html, body {
  background-color: #CCCCCC;
  font-family: "Verdana", arial;
}

body {
  font-size: 9pt;
  line-height: 125%;
/*   margin: 1em; */
  padding: 2em;
  margin-top: 1em;
  margin-left: 3em;
/*   width: 39em; */
  min-height: 60em;
/*   margin-right: 0.5em; */
  background-color: white;
  border-top: 1px solid black;
  border-left: 1px solid black;
/*   border-right: 2px solid black; */
/*   border-bottom: 2px solid black; */
}

.strong {
  font-weight: bold;
}

h1, h2, h3, h4, h5, h6,
p
{
  margin-bottom: 0.5em;
  margin-top: 0.5em;
  line-height: 125%;
}

h1 { font-size: 2em;}
h2 { font-size: 1.4em; }
h3 { font-size: 1.2em; }
h4 { font-size: 1.0em; }
h5 { font-size: 1.0em; }
h6 { font-size: 1.0em; }

h1, h2, h3, h4, h5, h6 {
  color: #660000;
  margin-right: 20%;
}

* &gt; h1 {
  padding-top: 0.5em;
}

/* h2, h3 */
/* { */
/*   margin-right: 10em; */
/* } */

h1.title 
{
  margin-top: 3em;
  border-top: 3px solid #660000;
  border-bottom: 3px solid #660000;
  border-color: #660000;
  padding: .4em;
  text-align: center;
}

h2.title 
{
  margin-top: 3em;
  border-top: 3px solid #660000;
  border-bottom: 3px solid #660000;
  border-color: #660000;
  padding: .4em;
}

div.toc {
    line-height: 100%;
}

div.list-of-examples {
    margin-top: 3em;
}

div.sect1 h2 {
  font-size: 1.5em;
  margin-top: 4em;
  margin-left: 0em;
  margin-right: 25%;
  margin-bottom: 1em;
  /* border-color: #660000; */
  border-top: 0em;
  border-bottom: 1px solid;
  padding: 0em;
}

div.sect2 h3 {
  font-size: 1em;
  margin-top: 4em;
  margin-bottom: 1em;
  margin-right: 25%;
  /* border-color: #660000; */
  border-top: 0em;
  border-bottom: 1px solid;
}

div.sect3 h4 {
  font-size: small;
  color: black;
  margin-top: 4em;
  margin-bottom: 1em;
  margin-right: 25%;
  /* border-color: #660000; */
  border-top: 0em;
  border-bottom: 1px solid;
}

div.note
{
  margin-top: 1em;
  margin-bottom: 1em;
}
div.note .title
{
  color: black;
  font-size: x-small;
  margin-top: 0em;
  margin-bottom: 0em;
}
/* ----- links ---------------------------------------------------------- */
:link {
  color: #660000;
  text-decoration: none;
  font-weight: bold;
}

:visited {
  color: #333333;
  text-decoration: none;
  font-weight: bold;
}


div.toc :link, :visited {
  font-weight: normal;
 }

div.list-of-examples :link, :visited {
  font-weight: normal;
 }


a:link img {border-style: none;}
a:visited img {border-style: none;}

div.toc dd, dl
{
  margin-top: 0em;
  margin-bottom: 0em;
}
div.toc dt
{
  margin-top: 0.2em;
}

ul, ol
{
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

.para {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

.sect1,
.toplevel.section
{
  padding-bottom: 0.25em;
}


tt,pre {
    font-family: Courier New,Courier,monospace;
    font-size: smaller;
}

.programlisting {
    margin-top: 8pt;
    margin-bottom: 8pt;
    margin-left: 1em;
    background-color: #FFFFCC;
    white-space: pre;
    border-style: solid;
    border-width: 1pt;
    border-color: #999999;
    padding-left: 6pt;
    padding-top: 2pt;
    padding-bottom: 2pt;
    width: 100%;
    line-height: 100%;
}

table{
    background-color: #FFFFFF;
    width: 99.6%;
}

div.example {
    margin-top: 0pt;
    margin-bottom: 0pt;
    padding-top: 0pt;
    padding-bottom: 0pt;
}

div.example .title {
    color: black;
    margin-top: 0pt;
    margin-bottom: 0pt;
    padding-top: 8pt;
    padding-bottom: 0pt;
}

div.sidebar .title {
  font-weight: bold;
  color: black;
}

div.sidebar  {
  font-size: x-small;
  margin-top: 2em;
  margin-bottom: 0.5em;
  /* margin-left: 1em; */
  margin-right: 33%; 
  padding: 4pt;
  border-top: 1px solid black;
  border-bottom: 1px solid black;
  border-left: 1px solid black;
  border-right: 1px solid black;
}


h1 &gt; a,
h2 &gt; a {
  padding-top: 0.5em;
}

ol.vert, ol.inline {
  list-style-type: none;
  padding-left: 0;
  margin-left: 0;
}

hr, .toc, .title
{ color: #660000 
}


.navfooter
{
  margin-top: 2em;
}
.navheader
{
  margin-bottom: 1em;

}

/* ------ title page ---------------------------------------------------- */
h3.author
{
  padding: 0em;
  margin-top: 0em;
  margin-bottom: -1em;
}

.affiliation
{
  padding: 0em;
  margin-top: 0em;
  margin-bottom: 0em;
  font-size: smaller;
}


div.revhistory table, tr, td
{
  border-collapse: collapse;
  border: hidden;
  font-size: x-small;
 }

div.revhistory table
{
  width: auto;
  }

div.revhistory td[colspan="3"]
{
  padding-left: 2em;  
 }


/* div.draft { */
/*   background-image: url('pics/draft.png'); */
/* } */


@doc
@ascskip xemacs-css-mode-off

</t>
<t tx="ekr.20040331071919.28">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:03 CST 2004  michael@redpriest _HTML_common__140982180.txt"
@ascskip xemacs-xsl-mode-off

indexterm:[Stylesheets,common-html.xsl]
The following section is the entire common-html style sheet
("common-html.xsl"), which sets basic HTML options.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/common-html.xsl"
&lt;&lt; HTML: common&gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 
&lt;!--===== ==========================================================--&gt;
&lt;xsl:param name="default.table.width" select="'100%'"&gt;&lt;/xsl:param&gt;
&lt;xsl:param name="html.stylesheet" select="'dbstyle.css'"/&gt;
&lt;xsl:param name="shade.verbatim" select="1"/&gt;
&lt;xsl:attribute-set name="shade.verbatim.style"&gt;
  &lt;xsl:attribute name="border"&gt;0&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="bgcolor"&gt;#F3F3F3&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;


&lt;/xsl:stylesheet&gt;
@doc
@ascskip xemacs-xsl-mode-off
</t>
<t tx="ekr.20040331071919.29">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:03 CST 2004  michael@redpriest _PDF__139549436.txt"

indexterm:[Stylesheets, fo-fop.xsl]
This is the Formatting Objects style sheet ("fo-fop.xsl", which sets
the options for all printed output.

The actual output is a file with the ".fo" extension, which will be
used by a Formatting Object processor to produce a PDF file.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/fo-fop.xsl"
&lt;&lt; PDF &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 
&lt;!--===== ==========================================================--&gt;

&lt;!--===== catalog will convert the url to our file location =========--&gt;
&lt;xsl:import href="fo-docbook.xsl"/&gt;
&lt;xsl:import href="common-links.xsl"/&gt;

&lt;!--===== using the fop pdf processor ===================================--&gt;
&lt;xsl:param name="fop.extensions" select="1"/&gt;

&lt;!--===== single sided pages ============================================--&gt;
&lt;xsl:param name="double.sided" select="0"&gt;&lt;/xsl:param&gt;

&lt;!--===== body print ====================================================--&gt;
&lt;xsl:param name="body.font.master"&gt;12&lt;/xsl:param&gt;
&lt;xsl:param name="alignment"&gt;left&lt;/xsl:param&gt;
&lt;xsl:param name="hyphenate"&gt;true&lt;/xsl:param&gt;

&lt;!--===== set page margins ==============================================--&gt;
&lt;xsl:param name="page.margin.inner"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="$double.sided != 0"&gt;1.25in&lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;1.5in&lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:param&gt;

&lt;xsl:param name="body.margin.top" select="'.75in'"&gt;&lt;/xsl:param&gt;

&lt;!--===== set title fonts ===============================================
     Title fonts require replacing the standard
     titlepage.templates.xsl with a custom version.  This is done
     here by copying the fo/titlepage.templates.xml to
     mrc.titlepage.templates.xsl, editing it, and then processing it
     with
      xsltproc -output mrc.titlepage.templates.xsl \
         /usr/share/xml/docbook/docbook-xsl-1.60.1/template/titlepage.xsl  \
         mrc.titlepage.templates.xml
     Now we replace the old titlepage.templates.xsl with our new
     mrc.titlepage.templates.xsl
--&gt;
&lt;xsl:include href="mrc.titlepage.templates.xsl"/&gt;

&lt;!--===== blank verso titlepage =========================================--&gt;
&lt;xsl:template name="book.titlepage.verso"/&gt;

&lt;!--===== outdent titles ================================================--&gt;
&lt;xsl:param name="title.margin.left" select="'-2pc'"/&gt;

&lt;!--===== set section font, break ======================================--&gt;
&lt;xsl:attribute-set name="section.title.level1.properties"&gt;
  &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="break-before"&gt;page&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-bottom"&gt;1pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-bottom-style"&gt;solid&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-bottom-color"&gt;black&lt;/xsl:attribute&gt;  
  &lt;xsl:attribute name="margin-right"&gt;6em&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;xsl:attribute-set name="section.title.level2.properties"&gt;
  &lt;xsl:attribute name="break-before"&gt;page&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;xsl:attribute-set name="section.title.level3.properties"&gt;
  &lt;xsl:attribute name="break-before"&gt;page&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;!--===== Code extract titles are sidebars ==============================--&gt;
&lt;xsl:attribute-set name="sidebar.properties" use-attribute-sets="formal.object.properties"&gt;
  &lt;xsl:attribute name="border-style"&gt;solid&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-width"&gt;1pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-color"&gt;black&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="background-color"&gt;#EDEDED&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-left"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-right"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-top"&gt;2pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-bottom"&gt;4pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-left"&gt;0pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-right"&gt;4em&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-top"&gt;2pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-bottom"&gt;2pt&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;!--===== code (verbatim) font and spacing ==============================--&gt;
&lt;xsl:attribute-set name="verbatim.properties"&gt;
  &lt;xsl:attribute name="space-before.minimum"&gt;0.1pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-before.optimum"&gt;2pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-before.maximum"&gt;3pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-after.minimum"&gt;0.4em&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-after.optimum"&gt;.5em&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-after.maximum"&gt;1.2em&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;xsl:attribute-set name="monospace.verbatim.properties"
    use-attribute-sets="verbatim.properties monospace.properties"&gt;
  &lt;xsl:attribute name="text-align"&gt;start&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;9pt&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
    &lt;!--===== 2003-Oct-01 FOP does not appear to support shade.verbatim yet =--&gt;
&lt;xsl:param name="shade.verbatim" select="1"/&gt;
&lt;xsl:attribute-set name="shade.verbatim.style"&gt;
  &lt;xsl:attribute name="border"&gt;1&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="bgcolor"&gt;#E0E0E0&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

    &lt;!--===== FOP did not like this =========================================--&gt;
&lt;!--&lt;xsl:attribute-set name="xref.properties"&gt;--&gt;
&lt;!--  &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;--&gt;
&lt;!--  &lt;xsl:attribute name="font-style"&gt;bold&lt;/xsl:attribute&gt;--&gt;
&lt;!--&lt;/xsl:attribute-set&gt;--&gt;

&lt;/xsl:stylesheet&gt;

@doc
@ascskip xemacs-xsl-mode-off




</t>
<t tx="ekr.20040331071919.30">@language plain
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:21 CST 2004  michael@redpriest Appendix_XEmacs_Text_Editor_140657924.txt"

You can use Leo to enter all the text in an outline, but Leo also
allows you to use your familiar editing environment.  In my case,
that is XEmacs.  Fortunately, Leo integrates with XEmacs quite well.

The following items are code I use, some Leo Python plugins and some
XEmacs elisp functions.  You may find them useful.

@ascskip on
&lt;&lt; Appendix: XEmacs Text Editor &gt;&gt;
@code</t>
<t tx="ekr.20040331071919.31">@language python
@tabwidth -4

@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:10 CST 2004  michael@redpriest _OpenWith_Plugin__140659092.py"

Leo's Open_With plugin can be modified so that the body text of any
outline node can be edited in XEmacs by choosing "File; OpenWith;
XEmacs" or "File; OpenWith; XEmacs - noshow"  from the menu.

What actually happens is that Leo places the text in a temporary
file, and calls XEmacs with the address of that temporary file.  Leo
then watches for changes in the temporary file.  When and if the
temporary file changes, Leo copies the contents to the body text of
the Leo node.
      
Below is the standard open_with.py plugin that came with Leo 4.1-rc3
The only modification I've made is to insert
@code
&lt;&lt;call XEmacs&gt;&gt;=
table = (
    ("X&amp;Emacs", "Alt+Shift+O", ("os.system","/usr/bin/gnuclient -q ", None)),
    ("X&amp;Emacs - noshow", "Ctrl+Shift+O", ("os.system","/mrc2/linux-bin/gnuclient-noshow ", None))
    )
@doc
as noted below.  A similar alteration should work for future
versions.

Note: this alteration is for XEmacs running under Linux, but a
similar command should work in the Windows environment.

I use the "gnuclient-noshow" selection to load the temporary open_with file in
the background.  It is a small bash shell script:
---
#!/bin/bash
gnuclient -eval "(find-file-noselect \"${1}\")"
---

To implement this, edit a copy of the open_with.py file that comes
with your version of Leo.  Move the original copy to a safe place,
and put your edited copy in the Leo plugins directory.  Check to see
it is included in "pluginsManager.txt" in that directory.
@ascskip on
@root "other/xemacs/open_with.py"
&lt;&lt; Open_With Plugin&gt;&gt;
@code
"""Create menu for Open With command and handle the resulting commands"""

import leoGlobals as g
import leoPlugins

try:    import Tkinter as Tk
except: Tk = None

import os

if Tk: # Register the handlers...

    def on_idle (tag,keywords):
        a = g.app
        if g.app.killed: return
        for dict in a.openWithFiles:
            path = dict.get("path")
            c = dict.get("c")
            encoding = dict.get("encoding",None)
            v = dict.get("v")
            old_body = dict.get("body")
            if path and os.path.exists(path):
                try:
                    time = os.path.getmtime(path)
                    if time and time != dict.get("time"):
                        dict["time"] = time # inhibit endless dialog loop.
                        # The file has changed.
                        try:
                            # Update v from the changed temp file.
                            f=open(path)
                            s=f.read()
                            f.close()
                        except:
                            g.es("can not open " + g.shortFileName(path))
                            break
                        
                        # Convert body and s to whatever encoding is in effect.
                        body = v.bodyString()
                        body = g.toEncodedString(body,encoding,reportErrors=True)
                        s = g.toEncodedString(s,encoding,reportErrors=True) # 10/13/03
                        
                        conflict = body != old_body and body != s
                        
                        # Set update if we should update the outline from the file.
                        if conflict:
                            # See how the user wants to resolve the conflict.
                            g.es("conflict in " + g.shortFileName(path),color="red")
                            message = "Replace changed outline with external changes?"
                            result = g.app.gui.runAskYesNoDialog("Conflict!",message)
                            update = result.lower() == "yes"
                        else:
                            update = s != body
                        
                        if update:
                            g.es("updated from: " + g.shortFileName(path),color="blue")
                            v.setBodyStringOrPane(s,encoding) # 10/16/03
                            c.selectVnode(v)
                            dict["body"] = s
                        elif conflict:
                            g.es("not updated from: " + g.shortFileName(path),color="blue")
                except:
                    g.es_exception() ## testing
                    pass
    def create_open_with_menu (tag,keywords):
    
        if  (tag in ("start2","open2") or
            (tag=="command2" and keywords.get("label")=="new")):
    
            # Entries in the following table are the tuple 
            # (commandName,shortcut,data).
            # 
            # - data is the tuple (command,arg,ext).
            # - command is one of "os.system", "os.startfile", "os.spawnl", 
            # "os.spawnv" or "exec".
            # 
            # Leo executes command(arg+path) where path is the full path to 
            # the temp file.
            # If ext is not None, the temp file has the extension ext,
            # Otherwise, Leo computes an extension based on what @language 
            # directive is in effect.
            
            idle_arg = "c:/python22/tools/idle/idle.py -e "
            
@doc
Here is where we insert the &lt; Call XEmacs &gt; code fragment defined above:
@code
            if 1: # Default table.


&lt;&lt; Call XEmacs &gt;&gt;
#               table = (
#                   # Opening idle this way doesn't work so well.
#                   # ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
#                   ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
#                   ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
#           elif 1: # Test table.
#               table = ("&amp;Word","Alt+Shift+W",("os.startfile",None,".doc")),
#           else: # David McNab's table.
#               table = ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)),
            
            g.top().frame.menu.createOpenWithMenuFromTable(table)

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":

        g.app.hasOpenWithMenu = True
        leoPlugins.registerHandler("idle", on_idle)
        leoPlugins.registerHandler(("start2","open2","command2"), create_open_with_menu)
    
        __version__ = "1.4" # Set version for the plugin handler.
        g.plugin_signon(__name__)

</t>
<t tx="ekr.20040331071919.32">@language python
@tabwidth -4
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:14 CST 2004  michael@redpriest _OpenTree_Plugin__140660268.py"

This is a module that creates an "Open With" menu item that opens
Leo outline nodes in the tree below the current Leo node in the
XEmacs editor.  I frequently have a small tree of Leo nodes which
contain code that is usually edited in the same session.

NOTE: I use the "gnuclient-noshow" selection to load the temporary
open_with file in the background.  Leo calls a command with the
temporary file name at the end of the command, but the gnuclient
command needs to receive it enclosed in quotes and parentheses.  The
solution is a small intermediary bash shell script called
"gnuclient-noshow":

---
#!/bin/bash
gnuclient -eval "(find-file-noselect \"${1}\")"
---

I would rather have this operate in the background, but Leo's
openWith always operates on the current node, and openWith has much
good error checking that I want to use. So the fast solution was to
have OpenTreeInXEmacs visibly traverse the tree.

@ascskip on
@root "other/xemacs/mod_xemacsopentree.py"
&lt;&lt; Open_Tree Plugin &gt;&gt;
@code

import leoPlugins

def OpenTreeInXEmacs():
    import leoCommands
    #XEmacsCommand = "/usr/bin/gnuclient -q "
    XEmacsCommand = "/mrc2/linux-bin/gnuclient-noshow "
    c = g.top()
    vnode = c.currentVnode() # get the current vnode.
    stopHere = vnode.nodeAfterTree()
    v = vnode
    while v != stopHere:
        c.openWith(data=("os.system", XEmacsCommand, None))
        v = v.threadNext()
        if (not v) or (v == stopHere):
            break
        c.selectVnode(v)
    c.selectVnode(vnode)


def CreateOpenTreeMenu(tag,keywords):

    """Create the 'Xemacs: Open Tree' menu item in the Open With menu."""


    if  (tag=="open2" or
        (tag=="start2") or
        (tag=="command2" and keywords.get("label")=="new")):

        c = g.top()
        exportMenu = c.frame.menu.getMenu('Open With')
        newEntries = (
            ("-", None, None),
            ("XEmacs: Open nodes in sub-tree","None",OpenTreeInXEmacs),
            )

        c.frame.menu.createMenuEntries(exportMenu, newEntries)

if 1:
    leoPlugins.registerHandler(("start2","open2","command2"), CreateOpenTreeMenu)

    __version__ = ".4" # Set version for the plugin handler.
    g.plugin_signon(__name__)
@doc


@code
</t>
<t tx="ekr.20040331071919.33">@language python
@tabwidth -4
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:15 CST 2004  michael@redpriest _Filename_modification__140661308.py"

This is a small modification to Leo (via a Python plugin module) so
that Leo will open the temporary files with a name that can be
easily recognized in an XEmacs buffer listing.

On Linux, Leo opens files in the temporary files directory, all
prefixed with "LeoTemp_", which makes the names difficult to tell
apart when you have many different nodes loaded in XEmacs.

This code replaces the openWithTempFilePath method of the LeoFrame
class with code that opens temporary files in a subdirectory of the
temporary files directory, called "username_Leo", and omits the
"LeoTemp" prefix.

For example, I'm now editing this Leo node in XEmacs as
    "/tmp/michael_Leo/_Filename_modification__138976348.py"
In the XEmacs buffer list, the filename is shown as
    "_Filename_modification__138976348.py"
and all the Leo buffer names start with a leading underscore, so
they are grouped together.

For general use, this code should be considerably more robust about
creating the Leo subdirectory and signaling errors, but it is just a
quick hack that works for me on my machines.

This is distributed with Leo version 4.1rc3, so I've updated it with
Ed Ream's modifications to match that distribution.

@ascskip on
@root "other/xemacs/mod_tempfname.py"
&lt;&lt; Filename modification &gt;&gt;
@code

"""Replace Commands.openWithTempFilePath so Leo opens temporary
files with a filename that begins with the headline text, and
located in a 'username_Leo' subdirectory of the temporary
directory. The 'LeoTemp' prefix is omitted.  This makes it easier to
see which temporary file is related to which outline node.""" #'

import leoGlobals as g
import leoPlugins

import leoCommands
import getpass
import os
import tempfile

def onStart (tag,keywords):

    # g.trace("replacing openWithTempFilePath")

    g.funcToMethod(openWithTempFilePath,leoCommands.Commands,"openWithTempFilePath")

def openWithTempFilePath (self,v,ext):

    """Return the path to the temp file corresponding to v and ext.

    Replaces the Commands method."""    

    try:
        leoTempDir = getpass.getuser() + "_" + "Leo"
    except:
        leoTempDir = "LeoTemp"
        g.es("Could not retrieve your user name.")
        g.es("Temporary files will be stored in: %s" % leoTempDir)

    td = os.path.join(os.path.abspath(tempfile.gettempdir()), leoTempDir)
    if not os.path.exists(td):
        os.mkdir(td)

    name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
    path = os.path.join(td,name)
    return path

# Register the handlers...
leoPlugins.registerHandler("start2", onStart)

__version__ = "1.3"
g.plugin_signon(__name__)
</t>
<t tx="ekr.20040331071919.34">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 09:58 CST 2004  michael@redpriest _Kill_Temporary_Buffers__140661388.txt"

If you've opened a number of Leo temporary buffers in XEmacs, this
XEmacs function will kill them for you.  Just set the tempdir
variable to whatever matches your local value.

XEmacs will prompt you about any buffers that have unsaved changes.

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/kill-temporary-buffers.el"
&lt;&lt; Kill Temporary Buffers &gt;&gt;
@code
;;
;;-     mwd-leo-kill-buffers
(defun mwd-leo-kill-buffers ()
  "Kill any buffers for files in my Leo temporary directory."
  (interactive)
  (let ((bl (buffer-list))
        (tempdir "/tmp/michael_Leo" )  ;; change this to your temporary directory.
        )
    (while bl
      (setq test-buffer (car bl))
      (setq bname (buffer-file-name test-buffer))
      (if (and bname (string-match tempdir bname))
          (kill-buffer test-buffer)
        )
      (setq bl (cdr bl))
      )
    )
  )



@doc
@ascskip xemacs-lisp-mode-off
</t>
<t tx="ekr.20040331071919.35">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:18 CST 2004  michael@redpriest _MMMmode__140663340.txt"

There is an editing mode for XEmacs called Multiple Major Modes,
which allows us to edit the temporary text conveniently: with all
the syntax highlighting, special keymaps, etc. available, even
though Leo nodes may contain both plain text and program code.

When the XEmacs cursor is in a section of plain text, all the plain
text facilities are available, and there is no syntax
highlighting. When the XEmacs cursor is in a section of code
(Python, XSL, whatever) XEmacs invokes the syntax highlighting,
special keymaps, etc. appropriate for that code.

indexterm:[Multiple Major Modes]
indexterm:[Multiple Major Modes,mmm-mode.el]
If you have XEmacs installed, and you have also installed the
Multiple Major Modes mmm-mode.el package, the following code will
customize mmm-mode for use while editing Leo temporary files.

NOTE: mmm-mode is already installed by default in most
distributions.

Installation: Load mmm-leo-config.el from your .init.el file, or
just load it manually to try it out.

I won't go through it all, but for example, when editing a temporary
Leo file that is in XEmacs Python mode, and/or has a ".py" suffix:

    - when your cursor is any text between the @doc and @code
      directives XEmacs will enter text-mode.  Otherwise (e.g. with
      the cursor after the @code directive), XEmacs will be in
      Python mode.
    - when your cursor is between text that says
      "xemacs -makefile-mode-on" and text that says
      "xemacs -makefile-mode-off", XEmacs will enter makefile-mode.
      (You key in those text markers to mark out the area you want
      as makefile-mode.  See the Leo2AsciiDoc.leo outline for examples,
      e.g the "Make File" section in the Leo2AsciiDoc Users Guide.)

      Otherwise, XEmacs will be in Python mode in that buffer.

Similarly, makefile-mode, xsl-mode and emacs-lisp-mode are added to
temporary Leo files that created with a ".txt" extension.      

A future project may be to create a Leo module to use in the
Leo "openWith" function that examines each node for these mmm-mode
markers and creates the temporary file with the proper extension.

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/mmm-leo-config.el"
&lt;&lt; MMM-mode &gt;&gt;
@code
;;-     mmm-mode                multiple modes
(require 'mmm-auto)
(require 'mmm-vars)

;   mmm-mode-on and mmm-mode-off turn it on and off in a buffer.
;   \c-c % \c-b re-parses the whole buffer

;   set mode to activate on mode or extension
(setq mmm-global-mode 'maybe)

; turn off gray background
(setq mmm-submode-decoration-level 0)

;   add embedded modes in python
(mmm-add-group
 'py-embedded-text
 '(
   (py-leo
    :submode text-mode
    :face mmm-code-submode-face
    :front "^@doc.*"
    :back "^@code"
    :insert ((?l py-leo-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   (py-doc
    :submode text-mode
    :face mmm-code-submode-face
    :front "^\"\"\".*"
    :back "^.+\"\"\""
    )
   (py-makefile
    :submode makefile-mode
    :face mmm-code-submode-face
    :front "xemacs-makefile-mode-on"
    :back "xemacs-makefile-mode-off"
    )
   )
 )
;   add embedded modes in text
(mmm-add-group
 'text-embedded
 '(
   (txt-makefile-mode
    :submode makefile-mode
    :face mmm-code-submode-face
    :front "xemacs-makefile-mode-on"
    :back "xemacs-makefile-mode-off"
    :insert ((?l text-embedded-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   (txt-xsl-mode
    :submode xsl-mode
    :face mmm-code-submode-face
    :front "xemacs-xsl-mode-on"
    :back "xemacs-xsl-mode-off"
    :insert ((?l text-embedded-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   (txt-lisp-mode
    :submode emacs-lisp-mode
    :face mmm-code-submode-face
    :front "xemacs-lisp-mode-on"
    :back "xemacs-lisp-mode-off"
    :insert ((?l text-embedded-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   )
 )
(mmm-add-mode-ext-class 'python-mode "\\.py\\'" 'py-embedded-text)
(mmm-add-mode-ext-class 'text-mode "\\.txt\\'" 'text-embedded)

@doc
@ascskip xemacs-lisp-mode-off
</t>
<t tx="ekr.20040331071919.36">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:20 CST 2004  michael@redpriest _Insert_indexterm__140664580.txt"

indexterm:[XEmacs, Indexing]
Indexing is tedious work, and it interferes with the readability of
the ascii text as well.  However, used sparingly, it helps the
reader.

When editing a Leo node (in an XEmacs buffer), this function copies
a highlighted word or phrase and inserts an AsciiDoc index code on a
new line immediately before the paragraph.  I try to keep markup out
of the way of the reader.  In this case, AsciiDoc requires that the
index code be part of the same block of text, and the first line of
the block is the least annoying place I can find.

For example, if I wanted to index the words "XEmacs buffer" above, I
would highlight them (usually by pressing M-@ a couple of times) and
then call this function (I have it bound to C-k C-h C-i).  At the
beginning of the paragraph, my text would say "\indexterm:[XEmacs
buffer]".

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/index-leo-region.el"
&lt;&lt; Insert indexterm &gt;&gt;
@code
(defun mwd-index-leo-region (start end)
  "preface paragraph with AsciiDoc index macro of region."
  (interactive "r")
  (save-excursion
    (copy-region-as-kill start end)
    (backward-paragraph)
    (insert "\nindexterm:[")
    (yank)
    (insert "]")
    )
  )

@doc
@ascskip xemacs-lisp-mode-off

</t>
<t tx="ekr.20040331071919.37">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:56 CST 2004  michael@redpriest _Indent_Leo_comments__141202716.txt"

Leo derived files are sprinkled with comments, which Leo uses as
markers to be able to "untangle" files, i.e. import changes made to
a derived file back into the Leo outline.

Useful as they may be, the comments are an ugly distraction when
reading the source code.  One could have XEmacs flush them from the
file, but then the untangle feature is gone for that file.

This pair of XEmacs elisp functions moves them to the right, where
they aren't so distracting, and moves them back again if you should
want to untangle the file.

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/indent-leo-comments.el"
&lt;&lt; Indent Leo comments &gt;&gt;
@code
(defun mwd-leo-comments-indent ()
  "Indent Leo comments to make them less distracting."
  (interactive)
  (save-excursion
    (let* (
          (leading-spaces 40)
          (start-string (concat (make-string leading-spaces ? ) "\\1" ))
          (end-string (concat (make-string leading-spaces ? ) "\\1" ))
          )
      (goto-char (point-min))
      (while (search-forward-regexp "\\(^# &lt;&lt;\\)" nil t) (replace-match start-string))
      (goto-char (point-min))
      (while (search-forward-regexp "\\(^# -- end\\)" nil t) (replace-match end-string))
      )
    )
  )

(defun mwd-leo-comments-unindent ()
  "Reverse the effect of mwd-leo-comments-indent."
  (interactive)
  (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp "^\\(\\s-\\)+\\(# &lt;&lt;\\)" nil t) (replace-match "\\2" ))
      (goto-char (point-min))
      (while (search-forward-regexp "^\\(\\s-\\)+\\(# -- end\\)" nil t) (replace-match "\\2" ))
    )
  )
@doc
@ascskip xemacs-lisp-mode-off
</t>
<t tx="ekr.20040331071919.38">@language plain
@ascfile "doc/mod_asc_user.asc"
@ascconfig maxCodeLineLength 80
@doc
@ascskip # Time-stamp: "Mon, Jan 19 15:29 CST 2004  michael@redpriest Leo_AsciiDoc_Users_Guide_141652036.txt"

Preface
-------

Leo2AsciiDoc is a small Python program which has been
built to be used as a plugin module for the Leo outlining editor.

Leo2AsciiDoc enables the contents of Leo outlines to be published to HTML
or PDF via the DocBook set of publishing tools.  Plain text from the
Leo outline is transformed into a final result that has:

    - typeset body text, in which bulleted and numbered lists,
      variable lists, page numbers, URLs, index terms,and bold and
      italic text are automatically recognized.
    - typeset Headings
    - a Table of Contents
    - an Index containing any items marked by the user, and any
      Python classes or functions.

As you will see, there's not a lot involved in using the
Leo2AsciiDoc module.  It simply copies text from a Leo outline (or a
portion of a Leo outline) to a text file.  In turn that text file can
be automatically converted by the AsciiDoc program and a DocBook
system to properly typeset DocBook HTML, PDF or other formats.

If you keep your text plain, and use a few simple formatting
conventions, the final output can have typeset headings, bulleted
lists, indexing and cross-referencing, as well as many other
features.

---
Michael Dawson
Marshall Research
michael_dawson at marshallresearch dot com
---

*note*

Leo2AsciiDoc is suited for general text documents, most programming
documentation and most business documents.  Leo2AsciiDoc (being based on
DocBook) is not the choice for anyone needing detailed typographic
control of individual words or characters -- for example, typeset
equations.  In general, DocBook typesets blocks of text.

*note*

@code
</t>
<t tx="ekr.20040331071919.39">@doc
@ascskip # Time-stamp: "Mon, Jan 19 11:48 CST 2004  michael@redpriest Installation_140689076.txt"
Installation of this plugin is very straightforward, using Leo
version 4.1:

    - copy the python source code (mod_leo2ascd.py) to your Leo
      plugin directory (a subdirectory called "plugins" under your
      main Leo directory).
    - in that directory should be a text file called
      pluginsManager.txt, containing a list of all plugins that are
      to be loaded when Leo starts.  Add mod_leo2ascd.py to the
      list.
    - start or re-start Leo.
    - in the Leo Log Window you should see the Leo2AsciiDoc sign-on
      message "---mod_leo2asc 0.4-------".
    - in the Leo main menu "File; Export", there should be two menu
      items called something like "Export to AsciiDoc".

@code</t>
<t tx="ekr.20040331071919.40">@language plain
@doc
@ascskip # Time-stamp: "Thu, Oct 16 13:46 CST 2003  michael@redpriest Operation_140791428.txt"

Using Leo2AsciiDoc is as simple as choosing the Leo menu item: "File;
Export; Export All to AsciiDoc".  From there, you have the AsciiDoc
program and the DocBook system automatically convert your outline to
HTML or PDF (or to a manpage or a DocBook website.)

Step by step:

    - You need a Leo outline containing some plain text, or plain
      text and code.
    - You ensure that the top node in the outline (or part of the
      outline tree which you want to be a separate document) must
      have an @ascfile directive in the body text. The @ascfile
      directive is used to specify the filename in which the output
      text will be put.
    - You then use Leo's menu: "File; Export; Export All to
      AsciiDoc" (or one of the other Leo2AsciiDoc menu items) to
      have Leo2AsciiDoc automatically export the outline to a text file.
    - After that, you run the AsciiDoc program on the exported text
      file, and process it as a DocBook document.  Most often,
      people have a Make file set up to do this automatically.

In practice, people often want to use special features:

    - plain text formatting, sometimes referred to as "structured
      text" or "minimal markup"
    - Leo2AsciiDoc configuration options

The following sections cover this.  If you've downloaded the Leo2AsciiDoc
package, the mod_leo2asc.leo outline is available, and illustrates
all the features.  It is the outline from which all the Leo2AsciiDoc HTML
and PDF documentation and code were derived.

@code
</t>
<t tx="ekr.20040331071919.41">@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:19 CST 2004  michael@redpriest Directives_140672364.txt"

The following are non-printing directives that you can insert into
your outline text to control Leo2AsciiDoc behaviour.  All must be at the
beginning of the line.

{amp}commat;ascfile::
    e.g: `@ascfile "doc/mod_asc_user.asc" `

    Ascfile is the equivalent of a Leo @root directive. Ascfile
    signals the start of a document and specifies the file name to
    receive the text.

    The default directory is the directory containing the Leo
    outline.  If you were editing an outline that resided in
    /home/me then the above ascfile directive would create the file
    mod_asc/user.asc in the directory /home/me/doc.

{amp}commat;ascignore::
    Ascignore causes Leo2AsciiDoc to ignore the outline node, and any
    sub-nodes. It must be placed before any line in the node which
    will print.

{amp}commat;ascskip::
    Causes Leo2AsciiDoc to skip the line.  If followed by the word "on",
    causes Leo2AsciiDoc to skip all succeeding document lines until an
    "{amp}commat;ascskip off" directive is read, or a code section is reached.

{amp}commat;ascexit::
    Causes Leo2AsciiDoc to exit the outline node without processing any
    further lines.  Sub-nodes will be processed.

{amp}commat;ascconfig::
    e.g. `{amp}commat;ascconfig maxCodeLineLength 70` -- see
    Configuration below. 
    

@code
</t>
<t tx="ekr.20040331071919.42">@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:20 CST 2004  michael@redpriest Configuration_140673612.txt"

There are a few configuration settings which may be set in an
outline.  To take effect, they must be placed:

    - in the top node of the outline, or
    - the same node as an @ascfile directive.
    
Configuration settings in the top node of the outline are effective
for the whole outline, unless overridden by settings in sub-nodes.

maxCodeLineLength::
    e.g. `{amp}commat;ascconfig maxCodeLineLength 70` -- 
    sets the maximum length of code printout lines to 70 characters.
    Longer lines will be wrapped and a line continuation character
    displayed.

PrintHeadings::    
    e.g. `{amp}commat;ascconfig PrintHeadings off` -- turns off the
    export of outline node headings as section titles.  In that
    case, you must have correctly entered AsciiDoc section titles in
    the body text of your outline.

Readers of the code will note that there are other configuration
settings in the code. These will be used in future, and so I won't
document them yet.


@code</t>
<t tx="ekr.20040331071919.43">@language plain
@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:22 CST 2004  michael@redpriest Markup_140672220.txt"

The point of using a system like AsciiDoc is to get a document that
is properly typeset, while writing only plain text with as little
embedded formatting instruction as possible.

For the most part, you simply write chunks of text, which become
typeset paragraphs.

I've tried to use most commonly used markup in the Leo outline that
contains all the Leo2AsciiDoc source and documentation, so that you
can see exactly how markup may be used.

@code</t>
<t tx="ekr.20040331071919.44">@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:20 CST 2004  michael@redpriest Standard_AsciiDoc_Markup_140676540.txt"

This section illustrates a very small part of the standard AsciiDoc
markup.  However, AsciiDoc comes with extensive documentation of its
own, which any Leo2AsciiDoc user should read.


@code</t>
<t tx="ekr.20040331071919.45">@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:06 CST 2004  michael@redpriest Headings_141020668.txt"

indexterm:[Markup, Headings]
Leo2AsciiDoc will automatically create Headings from the headings of
your Leo outline.  You can turn this off (see Configuration), and
create your own headings in the body text of an outline node.  For
example, a Chapter heading is text at the left margin that has a
following line of dashes.  For example,

@code
 Operation
 ---------

@doc
is the heading of this chapter.  Chapter sub-sections have a
following line of tildes.  For example,

@code

 Markup
 ~~~~~~

@doc

is the heading of Section One of this chapter.  Section Two markup
is a following line of "^".  For example, 

@code

Standard AsciiDoc Markup
^^^^^^^^^^^^^^^^^^^^^^^^
@doc

is the heading of the section, which is a Section Two.

As I say, you normally don't need to do this, since Leo2AsciiDoc does all
this itself from the outline headings.


@code
</t>
<t tx="ekr.20040331071919.46">@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:06 CST 2004  michael@redpriest Lists_141018612.txt"

indexterm:[Markup, lists]
Bulleted lists start with a dash (or asterisk) followed by a space
or tab character.  I've extended this to allow leading spaces.  For
example,
    
@code
    - this is a list item
        * this is a sub-item
    - this is another list item
@doc

produces:

    - this is a list item
        * this is a sub-item
    - this is another list item


@code</t>
<t tx="ekr.20040331071919.47">@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:07 CST 2004  michael@redpriest URLs_140994492.txt"

indexterm:[Markup, URL]
The URL address of a web page will be "hot" in the HTML or PDF
document, when terminated with square brackets:

@code

http://www.docbook.org[The official home page for DocBook: The Definitive  Guide.]

@doc

results in:

http://www.docbook.org[The official home page for DocBook: The Definitive Guide.]


@code</t>
<t tx="ekr.20040408161258"></t>
<t tx="ekr.20040408192158">@nocolor</t>
<t tx="ekr.20040408192158.1">###########################
|leo| Using the rst2 plugin
###########################

This page documents a nifty new plugin created by Josef Dalcolmo, Timo Honkasalo, Steve Zatz, Paul Paterson and Edward Ream.  This page was created using the rst2 plugin.  You can find the source code in LeoPlugins.leo (on cvs).

.. contents::

.. Here are the links used in this document.

.. _LaTeX:                http://www.latex-project.org/
.. _reStructuredText:     http://docutils.sourceforge.net/rst.html
.. _docutils:             http://docutils.sourceforge.net
.. _ListManagerDocs.html: http://webpages.charter.net/edreamleo/ListManagerDocs.html
.. _wxListManager.leo:    http://webpages.charter.net/edreamleo/wxListManager.leo
.. _SilverCity:           http://silvercity.sourceforge.net
.. _front:                http://webpages.charter.net/edreamleo/front.html
.. _home:                 http://webpages.charter.net/edreamleo/front.html

.. |blank| image:: blank.gif
.. |leo|   image:: leo.gif
    :target: front_</t>
<t tx="ekr.20040408192158.2"></t>
<t tx="ekr.20040408192158.3">@ignore
@nocolor
@wrap

This plugin creates output files from Leo outlines containing reStructuredText_
(rST) The combination of Leo outlines and rST creates a simple, flexible and
powerful way of generating HTML, LaTeX_ and other text documents.
ReStructuredText is a simple and powerful text formatting markup language.

The file ListManagerDocs.html_ is an impressive example of the kind of output
that is possible to generate relatively easily using this plugin. The source
file for this example is wxListManager.leo_.

To use this plugin, you must have installed Python's docutils_ module. This
module will also use the SilverCity_ syntax coloring package if you have
installed it.

This plugin assumes that a node whose headline is @rst &lt;filename&gt; contains a
tree of nodes containing reStructuredText. Let us call such a node an **rst root**
node. The plugin passes the headline and body text of the rst root and all the
nodes of its subtree to Python's docutils module, which parses the
reStructuredText and creates the output file.

Double-clicking on an rst root node generates an output file from the
reStructured Text input contained in the rst root node and all the nodes of its
subtree. The output file will be HTML, LaTex or plain text depending on the
extension of the filename specified in the rst root node. If the filename ends
in .html or .htm the docutils module will create an HTML file. If the filename
ends in .tex the docutils module will create a LaTex file. Otherwise, a plain
.txt file is generated.

If the output file is a .html or .htm file, it will use three .css (cascading
style sheet) files provided they exist in the same directory as the output file.
You can control the formatting of the HTML file by altering these .css files.
See the node called "cascading style sheets" for more details.

See the tree called "Scripting chapter using the rst plugin" in LeoDocs.leo for
many examples of how to use this plugin.</t>
<t tx="ekr.20040408192158.4"></t>
<t tx="ekr.20040408192158.5">@ignore
@nocolor
@wrap

If an outline node contains @rst &lt;filename&gt;, that node is the root of a tree of
nodes that will create the named output file. Let's call such a node the **rst
root**.

Subnodes of the rst root nodes may have headlines that contain just @rst. Such
node should contain rst markup, possibly including the code-block directive
defined by this plugin to format blocks of code.

**Important:** All @rst nodes should start with the @ignore directive. This allows @rst to be embedded in @file-nosent trees: see the next section for details. This plugin strips leading @ignore, @nocolor and @wrap directives.  Such directives do not appear in the output.

The root node may contain any rST directives.  In particular, to create a table of contents put::

    .. contents:: Table of Contents

on its own line in the rst root node.

All other subnodes of the rst root, i.e., nodes whose headline is something
other than @rst, are **code nodes**. This plugin converts the headline text of
code nodes into an rST section headline whose level depends on the level of the
node in the Leo outline. Higher-level headlines in the outline correspond to
higher-level section headings; lower-level headlines in the outline correspond
to lower-level section headings. Any text in a code node is formatted as if it
were enclosed in a code-block directive.

The plugin reserves the '#' character for your own use so that you can
specify an rST headline explicitly. For example,::

    #####
    Title
    #####

You would typically put such a title in the rst root node.
Otherwise, section underlining is discouraged, since the plugin automaticaly
generates sections from headlines.</t>
<t tx="ekr.20040408192158.6"></t>
<t tx="ekr.20040408192158.7">@ignore
@nocolor
@wrap

This plugin defines a code-block rST directive if the SilverCity syntax coloring module has been installed. This directive takes one argument, a language name.  For example::

    .. code-block:: Python
    
        import leoGlobals as g

This directive syntax colors the code in the indented code block that follows the directive.  The result looks like this:

.. code-block:: Python
    
    import leoGlobals as g

See the tree called "Scripting chapter using the rst plugin" in LeoDocs.leo for many examples of how to use this directive.
</t>
<t tx="ekr.20040408192158.8"></t>
<t tx="ekr.20040408192158.9">@ignore
@nocolor
@wrap

When this plugin generates HTML files, this plugin assumes that three .css
(cascading style sheet) files exist in the directory containing the output file.
For the HTML output to look good the following .css files should exist in the
directory containing the generatated HTML file: default.css, leo_rst.css and
silver_city.css.

- default.css is the default style sheet that docutils expects to exist.
- leo_rst.css contains some style improvements based on Gunnar Schwant's DocFactory.
- silver_city.css is the style sheet that controls the syntax highlighting generated by SilverCity.

The latter two style sheets are imported at the end of the default.css.

**N.B.** You can use cascading style sheets to do things that otherwise wouldn't be possible with "plain" rST.  For instance, the background color of this page was specified in a body style.

-------------

|leo|</t>
<t tx="ekr.20040409051841"></t>
<t tx="ekr.20040409051841.1">As stated earlier, you must put an @ignore directive in any @rst node (except the root @rst node) whose rST text you want to contribute to the output.  This strange-looking convention allows you to embed documentation in @file-nosent trees *without* that documentation being included in the file derived from the @file-nosent tree.

For example, consider the following outline, in which all the @rst nodes (except the root @rst node) contain @others directives::

    @rst spamDocs.html
        @file-nosent spam.py
            code node 1
                @rst
            code node 2
                @rst
            code node 3
                @rst

The rst2 plugin will ouput all the reStructuredText contained in the three @rst nodes to spamDocs.html, but the contents of those @rst nodes will not become part of spam.py.  *Note:* The @ignore directive is valid only in @file-nosent trees, which is why we must use @file-noset to generate spam.py.

It would be also be possible to use cloned nodes to embed code nodes in .html files.  This would allow you to use regular @file trees to generate derived files.  For example, suppose all similarly named code nodes are clones of each other::

    @rst spamDocs.html
        code node 1
            @rst
        code node 2
            @rst
        code node 3
            @rst

    @file-nosent spam.py
        code node 1
        code node 2
        code node 3

The disadvantage of this organization is that you must update spamDocs.html by hand to keep it up-to-date with spam.py.
</t>
<t tx="ekr.20040717133342">@nocolor

https://sourceforge.net/forum/message.php?msg_id=2521345
By: bwmulder

I am working on a plugin which works with shadow files in a Leo subdirectory.

This is really the same code posted integrated with Leo. New is that
the goto linenumber command works properly as well.

The new code only kicks in if:
   - A leo subdirectory exists, and
   - both directories contain the file in question.
   
To get things started, create a Leo subdirectory, move the source
files there, and then create zero length strings instead of the moved
files. Whenever you change something in the sourcefile, both files
will be brought up to date automatically.

In the future, I might provide a script which provides this initial
setup automatically.

Implementation notes (relative to 4.1):

In order to use this mechanism to annotate foreign code, I am missing
two pieces:
   
   - The import command should import the source *exactly*.
   - I would like to add comments to the source which are *not* output into
source,
     and live in Leo only (or the shadowfile under Leo sentinel comments).
     
I changed the "message_comment" function to do nothing.

I do not think that this function is a good idea, since Leo can not know
if the line structure in a comment.

There might be more to do in this area.

It seems that I can get around the second limitation by writing "//@"
at the beginning of the line in the code sections, since this is
filtered away by the plugin.

Is there some other way to put comments only in the Leo document, but
not in the derived file?

I had to copy quite a bit of source code for the gotolinenr
command. It probably won't work for the next version of Leo

It seems that Leo somewhat encourages a coding style with long
routines, since complexity can be tugged away into subnodes rather
than creating functions to structure the code.

For the read and write command, I decided to inject a new "open"
function into the global namespace of leoAtFile.py. This function
checks if the caller is the read or write function of leoAtFile.py. In
this case, some special processing for synchronization is done.

I did this strange programming since I did not want to copy large
amounts of code and just add a few lines.

Currently the script works for C and python files. It looks at the
file extension to determine if C or python type annotations are
used. Maybe this information can be centralized.
</t>
<t tx="ekr.20040722115324"></t>
<t tx="ekr.20040722122834"></t>
<t tx="ekr.20040722134333.1"></t>
<t tx="ekr.20040722134535"></t>
<t tx="ekr.20040722135402"></t>
<t tx="ekr.20040722135402.1"></t>
<t tx="ekr.20040722141148"></t>
<t tx="ekr.20040723100651">"""Override outline drawing code to test optimized drawing"""

@language python
@tabwidth -4

import leoGlobals as g

print "overriding leoTkinterTree class"

&lt;&lt; about the tree classes &gt;&gt;

import leoTkinterTree
import leoFrame
import leoNodes
import Tkinter as Tk
import tkFont
import sys

&lt;&lt; about drawing &gt;&gt;
&lt;&lt; drawing constants &gt;&gt;

if 0: # Doesn't seem to work.
    # override the position class
    class myPositionClass (leoNodes.position):
        &lt;&lt; override p.edit_text &gt;&gt;
        
    leoNodes.position = myPositionClass

# class leoTkinterTree (leoFrame.leoTree):
class myLeoTkinterTree(leoFrame.leoTree):

    callbacksInjected = False
    
    @others

leoTkinterTree.leoTkinterTree = myLeoTkinterTree</t>
<t tx="ekr.20040723101121.2"></t>
<t tx="ekr.20040723101121.4">def drawBox (self,p,x,y):
    
    tree = self ; canvas = self.canvas
    y += 7 # draw the box at x, y+7
    
    if not g.doHook("draw-outline-box",tree=tree,p=p,v=p,x=x,y=y):

        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        id = self.newBox()
        canvas.itemconfigure(id,image=image)
        canvas.coords(id,x,y+self.lineyoffset)

        assert(not self.ids.get(id))
        self.ids[id] = p.copy()
        
        return id
</t>
<t tx="ekr.20040723101121.5">def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    tree = self ; canvas = self.canvas
    v = p.v # Make sure the bindings refer to the _present_ position.

    &lt;&lt; compute x,y and iconVal &gt;&gt;

    if not g.doHook("draw-outline-icon",tree=tree,p=p,v=v,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        id = self.newIcon()
        canvas.itemconfigure(id,image=image)
        canvas.coords(id,x,y+self.lineyoffset)
        
        p = p.copy()
        self.iconIds[id] = p # Remember which vnode belongs to the icon.
        self.ids[id] = p

    return 0,icon_width # dummy icon height,width</t>
<t tx="ekr.20040723101121.6">
if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 &lt;= val &lt;= 15)</t>
<t tx="ekr.20040723101121.7">def drawNode(self,p,x,y):
    
    tree = self ; canvas = self.canvas ; 
    
    p = p.copy() ; v = p.v
    
    data = g.doHook("draw-outline-node",tree=tree,p=p,v=v,x=x,y=y)
    if data is not None: return data

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(
        x,y+7+self.lineyoffset,
        x+box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20040723101121.8">def force_draw_node(self,p,x,y):

    h,w = self.drawUserIcons(p,"beforeBox",x,y)
    xw = w # The extra indentation before the icon box.
    if p.hasChildren():
        box_id = self.drawBox(p,x+w,y)
    else:
        box_id = None

    w += box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x+w,y)
    h = max(h,h2) ; w += w2 ; xw += w2

    h2,w2 = self.drawIcon(p,x+w,y)
    h = max(h,h2) ; w += w2

    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x+w,y)
    h = max(h,h2) ; w += w2

    expand_x = x+w # save this for later.
    h2 = self.drawText(p,x+w,y,box_id)
    h = max(h,h2)
    w += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x+w,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,xw</t>
<t tx="ekr.20040723101121.9">def force_draw_nodeOLD(self,p,x,y):

    if p.hasChildren():
        box_id = self.drawBox(p,x,y)
    w = box_width # Even if the box isn't drawn.

    h2,w2 = self.drawIcon(p,x+w,y)
    w += w2

    h = self.drawText(p,x+w,y)
    
    return h,0
</t>
<t tx="ekr.20040723101121.10">def drawText(self,p,x,y,box_id=None):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c ; canvas = self.canvas
    h = self.line_height
    x += text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,p=p,v=p.v,x=x,y=y)
    if data is not None: return data
    
    id,t = self.newText()
    
    # g.trace("%3d" % id,self.textAddr(t),p.headString())

    # This does not seem to be working reliably!
    t.delete("1.0","end")
    t.insert("end",p.headString())
    s = t.get("1.0","end")
    
    if s.strip() != p.headString().strip():
        g.trace("***** get new widget ***")
        # g.trace("%3d" % id,self.textAddr(t),s.strip(),p.headString().strip())
        
        # Hide the item, and move it from the visible list to the free list.  Jeeze.
        canvas.coords(id,-100,-100)
        data = id,t
        self.visibleText.remove(data)
        self.freeText.append(data)
    
        # Try again with a brand new widget.
        id,t = self.newText(forceAllocate=True)
        
        t.delete("1.0","end")
        t.insert("end",p.headString())
        s = t.get("1.0","end")
        if s.strip() != p.headString().strip():
            g.trace("***** second assignment failed ****")

    self.ids[id] = p.copy()
    t.configure(width=self.headWidth(p))
    canvas.coords(id,x,y+self.lineyoffset)

    if 0:
        &lt;&lt; highlight text widget on enter events &gt;&gt;

    t.leo_position = p.copy()
    self.editWidgets.append(t)
   
    if 0: # Something very bizarre is going on.
        self.configureTextState(p)
    
    return self.line_height</t>
<t tx="ekr.20040723101121.12">if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20040723101121.13">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        try: self.redrawCount += 1
        except: self.radrawCount = 1
        g.trace(self.redrawCount)
    
    self.lastClickFrameId = None # id of last entered clickBox.
    self.lastColoredText = None # last colored text widget.

    self.checkWidgetList("drawTopTree: before")
    
    # Recycle widgets and clear all state arrays.
    self.recycleWidgets()
    self.editWidgets = []
    self.ids = {}
    self.iconIds = {}
    
    g.trace("begin %s" % self.getTextStats())
    
    if c.hoistStack:
        p,junk = c.hoistStack[-1]
        self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),root_left,root_top,0,0)

    self.hideNewlyFreedWidgets()
    
    canvas.lower("textBox") # This is not the Tk.Text widget, so it should be low.
    canvas.lower("plusBox") 
    canvas.lower("lines")   # Lowest.
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.
    
    canvas.update_idletasks() # So recent changes will take.
    
    self.checkWidgetList("drawTopTree: after")
    g.trace("end   %s" % self.getTextStats())
    # self.traceIds()</t>
<t tx="ekr.20040723101121.15">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; v = p.v
    yfirst = ylast = y
    if level==0: yfirst += 10
    w = 0
    
    data = g.doHook("draw-sub-outline",tree=tree,p=p,v=v,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        h,w = self.drawNode(p,x,y)
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
            x += w2 ; w += w2
        if hoistFlag: break
        else:         p = p.next()
        
    # Draw the virtical line.
    self.drawLine(x, yfirst-hline_y,x, ylast+hline_y-h)
    return y,w</t>
<t tx="ekr.20040723101121.17">def drawUserIcon (self,where,x,y,dict):
    
    h,w = 0,0

    if where != dict.get("where","beforeHeadline"):
        return h,w
        
    # g.trace(where,x,y,dict)
    
    &lt;&lt; set offsets and pads &gt;&gt;
    type = dict.get("type")
    if type == "icon":
        s = dict.get("icon")
        &lt;&lt; draw the icon in string s &gt;&gt;
    elif type == "file":
        file = dict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif type == "url":
        url = dict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;
        
    # Allow user to specify height, width explicitly.
    h = dict.get("height",h)
    w = dict.get("width",w)

    return h,w</t>
<t tx="ekr.20040723101121.18">xoffset = dict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = dict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = dict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = dict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0</t>
<t tx="ekr.20040723101121.19">pass</t>
<t tx="ekr.20040723101121.20">pass</t>
<t tx="ekr.20040723101121.21">try:
    image = self.iconimages[file]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",file)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    id = self.canvas.create_image(x+xoffset,y+yoffset,anchor="nw",image=image)
    self.canvas.lift(id)
    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad</t>
<t tx="ekr.20040723101121.22">def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for dict in iconsList:
            h2,w2 = self.drawUserIcon(where,x+w,y,dict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    return h,w</t>
<t tx="ekr.20040723101121.23">def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 &gt;= vis1 and y1 &lt;= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 &gt;= vis1 and y1 &lt;= vis2
    else:
        return False</t>
<t tx="ekr.20040723101121.24">def drawClickBox (self,p,y):
    
    canvas = self.canvas
    h = self.line_height
    defaultColor = ""
    
    # Define a slighly larger rect to catch clicks.
    id = self.newClickBox()

    canvas.coords(id,0,y,1000,y+h-3)
    canvas.itemconfig(id,fill=defaultColor,outline=defaultColor)

    self.ids[id] = p.copy()
    
    if 0: # A major change to the user interface.
        &lt;&lt; change the appearance of headlines &gt;&gt;</t>
<t tx="ekr.20040723101121.25">def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20040723101121.26">def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that v is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""

    c = self.c ; frame = c.frame
    if not p: p = self.c.currentPosition()
    if not p: p = self.c.rootPosition() # 4/8/04.
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        &lt;&lt; compute approximate line height &gt;&gt;
        &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
        if frac &lt;= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) &gt;= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)
    except:
        g.es_exception()</t>
<t tx="ekr.20040723101121.27">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.</t>
<t tx="ekr.20040723101121.28">data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20040723101121.29">def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n</t>
<t tx="ekr.20040723101121.30">def scrollTo (self,p):
    
    def scrollToCallback(event=None,self=self,p=p):
        g.trace(event,self,p)
        self.idle_scrollTo(p)
    
    self.canvas.after_idle(scrollToCallback)</t>
<t tx="ekr.20040723101121.31">@ We can't just return icony because the tree hasn't been redrawn yet.  For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self, v1):

    # if not v1.isVisible(): print "yoffset not visible:",v1
    root = self.c.rootPosition()
    h, flag = self.yoffsetTree(root,v1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

# Returns the visible height of the tree and all sibling trees, stopping at p1

def yoffsetTree(self,p,p1):

    h = 0
    for p in p.siblings_iter():
        # print "yoffsetTree:", p
        if p == p1:
            return h, True
        h += self.line_height
        if p.isExpanded() and p.hasChildren():
            child = p.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    
    return h, False</t>
<t tx="ekr.20040723101548"># These should be ivars.  Sheesh.

box_padding = 5 # extra padding between box and icon
box_width = 9 + box_padding
icon_width = 20
icon_padding = 2
text_indent = 4 # extra padding between icon and tex
child_indent = 28 # was 20
hline_y = 7 # Vertical offset of horizontal line
root_left = 7 + box_width
root_top = 2
hiding = True # True if we don't reallocate items
line_height = 17 + 2 # To be replaced by Font height</t>
<t tx="ekr.20040723102245"></t>
<t tx="ekr.20040723102245.2">def createPermanentBindings (self):
    
    canvas = self.canvas
    
    canvas.tag_bind('clickBox','&lt;Button-1&gt;',   self.onClickBoxClick)

    canvas.tag_bind('iconBox','&lt;Button-1&gt;', self.onIconBoxClick)
    canvas.tag_bind('iconBox','&lt;Double-1&gt;', self.onIconBoxDoubleClick)
    canvas.tag_bind('iconBox','&lt;Button-3&gt;', self.onIconBoxRightClick)
    
    canvas.tag_bind('iconBox','&lt;B1-Motion&gt;',            self.onDrag)
    canvas.tag_bind('iconBox','&lt;Any-ButtonRelease-1&gt;',  self.onEndDrag)

    if self.useBindtags: # Create a dummy widget to hold all bindings.
        t = Tk.Text() # This _must_ be a Text widget.
        if 1: # This doesn't seem to matter.
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick)
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick)
            t.bind("&lt;Key&gt;",      self.onHeadlineKey)
        else:
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick, '+')
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick, '+')
            t.bind("&lt;Key&gt;",      self.onHeadlineKey, '+')
        t.bind("&lt;Control-t&gt;",self.onControlT)
    
        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
        print t.bindtags()</t>
<t tx="ekr.20040723103515"></t>
<t tx="ekr.20040723104427.1">@ Important note: most hooks are created in the vnode callback routines, _not_ here.
</t>
<t tx="ekr.20040723104427.2">def OnActivate (self,p,event=None):

    try:
        c = self.c ; gui = g.app.gui
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")</t>
<t tx="ekr.20040723104427.3">current = c.currentPosition()

if p == current:
    g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        self.undimEditLabel()
        gui.set_focus(c,self.canvas) # Essential for proper editing.
else:
    g.trace("not current")
    self.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    if p.v.t.insertSpot != None: # 9/1/02
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
    gui.set_focus(c,c.frame.bodyCtrl)

self.active = True</t>
<t tx="ekr.20040723104427.5"># This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"</t>
<t tx="ekr.20040723104427.6">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""

    tree = self ; c = self.c
    focus = g.app.gui.get_focus(c.frame)

    # Bug fix: 7/13/03: Only do this as needed.
    # Doing this on every click would interfere with the double-clicking.
    if not c.frame.log.hasFocus() and focus != c.frame.bodyCtrl:
        try:
            # g.trace(focus)
            tree.endEditLabel()
            tree.dimEditLabel()
        except:
            g.es_event_exception("deactivate tree")</t>
<t tx="ekr.20040723104427.7">def findVnodeWithIconId (self,id):
    
    # Due to an old bug, id may be a tuple.
    try:
        return self.iconIds.get(id[0])
    except:
        return self.iconIds.get(id)</t>
<t tx="ekr.20040723104427.8"></t>
<t tx="ekr.20040723104427.9">def onContinueDrag(self,event):
    
    canvas = self.canvas ; frame = self.c.frame

    p = self.drag_p
    if not p: return

    try:
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        
        # OnEndDrag() halts the scrolling by clearing self.drag_id when the mouse button goes up.
        if self.drag_id: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")</t>
<t tx="ekr.20040723104427.11"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()
if y &lt; 0 or y &gt; h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.OnContinueDrag,p,None) # Don't propagate the event.</t>
<t tx="ekr.20040723104427.12"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findVnodeWithIconId() should start looking for tree id's.

def onDrag(self,event):

    # Note: "drag" hooks handled by vnode callback routine.
    
    c = self.c ; p = self.drag_p
    if not event or not p: return
    v = p.v

    if not self.dragging():
        windowPref = g.app.config.getBoolWindowPref
        # Only do this once: greatly speeds drags.
        self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
        self.setDragging(True)
        if windowPref("allow_clone_drags"):
            self.controlDrag = c.frame.controlKeyIsDown
            if windowPref("look_for_control_drag_on_mouse_down"):
                if windowPref("enable_drag_messages"):
                    if self.controlDrag:
                        g.es("dragged node will be cloned")
                    else:
                        g.es("dragged node will be moved")
        else: self.controlDrag = False
        self.canvas['cursor'] = "hand2" # "center_ptr"

    self.onContinueDrag(event)</t>
<t tx="ekr.20040723104427.13">def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; canvas = self.canvas ; config = g.app.config
    p = self.drag_p
    if not p: return
    v = p.v

    if event:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        if config.getBoolWindowPref("allow_clone_drags"):
            if not config.getBoolWindowPref("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown

        if vdrag and vdrag.v.t != p.v.t: # 6/22/04: Disallow drag to joined node.
            if self.controlDrag: # Clone p and move the clone.
                if childFlag:
                    c.dragCloneToNthChildOf(p,vdrag,0)
                else:
                    c.dragCloneAfter(p,vdrag)
            else: # Just drag p.
                if childFlag:
                    c.dragToNthChildOf(p,vdrag,0)
                else:
                    c.dragAfter(p,vdrag)
        else:
            if p and self.dragging():
                pass # g.es("not dragged: " + p.headString())
            if 0: # Don't undo the scrolling we just did!
                self.idle_scrollTo(p)
    
    # 1216/02: Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"

    if self.drag_id:
        canvas.tag_unbind(self.drag_id,"&lt;B1-Motion&gt;")
        canvas.tag_unbind(self.drag_id,"&lt;Any-ButtonRelease-1&gt;")
        self.drag_id = None
        
    self.setDragging(False)
    self.drag_p = None</t>
<t tx="ekr.20040723104427.14">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

id = self.canvas.find_closest(canvas_x,canvas_y)
# id = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findVnodeWithIconId(id)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="ekr.20040723104427.16"># The &lt;Key&gt; event generates the event before the headline text is changed!
# We register an idle-event handler to do the work later.

def onHeadChanged (self,p):

    """Handle a change to headline text."""
    
    g.trace()
    
    self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p)</t>
<t tx="ekr.20040723104427.18">def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    g.trace()
    
    c = self.c ; v = p.v

    if not p or p != c.currentPosition():
        return "break"
        
    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    &lt;&lt; set head to vnode text &gt;&gt;
    done = ch in ('\r','\n')
    if done:
        &lt;&lt; set the widget text to head &gt;&gt;
    &lt;&lt; set s to the widget text &gt;&gt;
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        &lt;&lt; update v and all nodes joined to v &gt;&gt;
    if done or changed:
        &lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;
        &lt;&lt; update the screen &gt;&gt;

    g.doHook("headkey2",c=c,p=p,ch=ch)
    return "break"</t>
<t tx="ekr.20040723104427.19">head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")</t>
<t tx="ekr.20040723104427.20">edit_text.delete("1.0","end")
edit_text.insert("end",head)
edit_text.mark_set("insert",index)</t>
<t tx="ekr.20040723104427.21">s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i &gt; -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    if len(s) &gt; 250:
        g.es("Truncating headline to 250 characters",color="blue")
        s = s[:250]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')</t>
<t tx="ekr.20040723104427.22">c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    if not p.isDirty():
        p.setDirty()
    # Update v.
    v.initHeadString(s)
    edit_text.delete("1.0","end")
    edit_text.insert("end",s)
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.</t>
<t tx="ekr.20040723104427.23"># Reconfigure v's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(v))</t>
<t tx="ekr.20040723104427.24">if done:
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # Update v immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.</t>
<t tx="ekr.20040723104427.26">def OnPopup (self,p,event):
    
    """Handle right-clicks in the outline."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        if not g.doHook("create-popup-menu",c=c,p=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,event=event):
            self.showPopupMenu(event)

    return "break"</t>
<t tx="ekr.20040723104427.27">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

    self.popupMenu.unpost()
    
</t>
<t tx="ekr.20040723104427.28">def createPopupMenu (self,event):
    
    c = self.c ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createMenuEntries(menu,g.app.openWithTable,openWith=1)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)
        
    &lt;&lt; Create the menu table &gt;&gt;
    
    # 11/27/03: Don't actually set binding: it would conflict with previous.
    frame.menu.createMenuEntries(menu,table,dontBind=True)</t>
<t tx="ekr.20040723104427.29">table = (
    ("&amp;Read @file Nodes",None,c.readAtFileNodes),
    ("&amp;Write @file Nodes",None,c.fileCommands.writeAtFileNodes),
    ("-",None,None),
    ("&amp;Tangle","Shift+Ctrl+T",c.tangle),
    ("&amp;Untangle","Shift+Ctrl+U",c.untangle),
    ("-",None,None),
    # 2/16/04: Remove shortcut for Toggle Angle Brackets command.
    ("Toggle Angle &amp;Brackets",None,c.toggleAngleBrackets),
    ("-",None,None),
    ("Cut Node","Shift+Ctrl+X",c.cutOutline),
    ("Copy Node","Shift+Ctrl+C",c.copyOutline),
    ("&amp;Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("&amp;Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&amp;Insert Node","Ctrl+I",c.insertHeadline),
    ("&amp;Clone Node","Ctrl+`",c.clone),
    ("Sort C&amp;hildren",None,c.sortChildren),
    ("&amp;Sort Siblings","Alt-A",c.sortSiblings),
    ("-",None,None),
    ("Contract Parent","Alt+0",c.contractParent))</t>
<t tx="ekr.20040723104427.30">def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    c = self.c ; menu = self.popupMenu

    &lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)
    
    enable = self.frame.menu.enableMenu
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())</t>
<t tx="ekr.20040723104427.31">isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True
        
    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True</t>
<t tx="ekr.20040723104427.32">def showPopupMenu (self,event):
    
    """Show a popup menu."""
    
    c = self.c ; menu = self.popupMenu ; gui = g.app.gui

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Make certain we have focus so we know when we lose it.
    # I think this is OK for all OSes.
    gui.set_focus(c,menu)</t>
<t tx="ekr.20040723104427.33">def onIconBoxClick (self,event):
    
    c = self.c ; gui = g.app.gui
    tree = self ; canvas = tree.canvas
    
    p = self.eventToPosition(event)
    if not p: return

    # g.trace(p)

    p = p.copy() # Make sure callbacks use the _present_ position.

    if event:
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)
        id = canvas.find_closest(canvas_x,canvas_y)
        # id = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if id != None:
            try: id = id[0]
            except: pass
            self.drag_p = p
            self.drag_id = id
            
            if 0:
                # Create the bindings.
                id4 = canvas.tag_bind(id,"&lt;B1-Motion&gt;", self.onDrag)
                id5 = canvas.tag_bind(id,"&lt;Any-ButtonRelease-1&gt;", self.onEndDrag)
                
                # Remember the bindings so deleteBindings can delete them.
                self.tagBindings.append((id,id4,"&lt;B1-Motion&gt;"),)
                self.tagBindings.append((id,id5,"&lt;Any-ButtonRelease-1&gt;"),)
    tree.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20040723104427.57">def OnIconClick (self,p,event):
    
    # g.trace(p)
    
    p = p.copy() # Make sure callbacks use the _present_ position.

    tree = self ; canvas = tree.canvas
    if event:
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)
        id = canvas.find_closest(canvas_x,canvas_y)
        # id = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if id != None:
            try: id = id[0]
            except: pass
            self.drag_p = p
            self.drag_id = id
            
            # Create the bindings.
            id4 = canvas.tag_bind(id,"&lt;B1-Motion&gt;", p.OnDrag)
            id5 = canvas.tag_bind(id,"&lt;Any-ButtonRelease-1&gt;", p.OnEndDrag)
            
            # Remember the bindings so deleteBindings can delete them.
            self.tagBindings.append((id,id4,"&lt;B1-Motion&gt;"),)
            self.tagBindings.append((id,id5,"&lt;Any-ButtonRelease-1&gt;"),)
    tree.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    return "break" # disable expanded box handling.
    
def OnIconRightClick (self,p,event):

    self.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20040723104637">def onClickBoxClick (self,event):
    
    c = self.c ; gui = g.app.gui
    
    p = self.eventToPosition(event)
    
    # g.trace(p)

    if p:
        if p.isExpanded(): p.contract()
        else:              p.expand()
    
        self.active = True
        self.select(p)
        g.app.findFrame.handleUserClick(p)
        gui.set_focus(c,c.frame.bodyCtrl)
        self.redraw()</t>
<t tx="ekr.20040723141142">def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    
    # import traceback ; traceback.print_stack()
    
    # This won't work when we are doing a redraw!
    item = canvas.find_overlapping(x,y,x,y)

    # Item may be a tuple.
    try:    id = item[0]
    except: id = item

    p = self.ids.get(id)
    
    # g.trace(id,p)

    return p</t>
<t tx="ekr.20040723141518"></t>
<t tx="ekr.20040723141518.1"># Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
    
    # g.trace(self.updateCount,self.redrawScheduled)
    
    if self.updateCount == 0 and not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)</t>
<t tx="ekr.20040723141518.2">@ This is called only from doCommand.  The implicit assumption is that doCommand itself is not contained in a beginUpdate/endUpdate pair.
@c

def redrawAfterException (self):
    
    """Make sure drawing is enabled following an exception."""
        
    if not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)
        self.updateCount = 0 # would not work if we are in a beginUpdate/endUpdate pair.</t>
<t tx="ekr.20040723141518.3"># Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):
    
    # g.trace(self.redrawScheduled)
    # import traceback ; traceback.print_stack()

    if not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)</t>
<t tx="ekr.20040723141518.4"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):
    
    # g.trace()
    
    # Bug fix: 4/24/04: cancel any pending redraw "by hand".
    # Make _sure_ that no other redraws take place after this.
    self.disableRedraw = True
    self.canvas.update_idletasks()
    self.disableRedraw = False
        
    # Now do the actual redraw.
    self.idle_redraw(scroll=scroll)</t>
<t tx="ekr.20040723141518.5">def idle_redraw (self,scroll=True):
    
    c = self.c ; frame = c.frame

    self.redrawScheduled = False # Always do this here.

    &lt;&lt; return if disabled, or quitting or dragging &gt;&gt;

    # g.print_bindings("canvas",self.canvas)

    self.expandAllAncestors(c.currentPosition())

    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=self.c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        # Do a scrolling operation after the scrollbar is redrawn
        if scroll:
            self.canvas.after_idle(self.idle_scrollTo)
        if self.trace:
            self.redrawCount += 1
            print "idle_redraw allocated:",self.redrawCount
    g.doHook("after-redraw-outline",c=self.c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20040723141518.6">if self.disableRedraw:
    # We have been called as the result of an update_idletasks in the log pane.
    # Don't do anything now.
    return

if frame not in g.app.windowList or g.app.quitting:
    # g.trace("no frame")
    return

if self.drag_p:
    # g.trace("dragging",self.drag_p)
    return
</t>
<t tx="ekr.20040723141518.8">def idle_second_redraw (self):
    
    c = self.c
    
    g.trace()
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")
    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount</t>
<t tx="ekr.20040723142710"></t>
<t tx="ekr.20040723142710.1">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return

    g.trace(p)
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,event=event):
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("icondclick")
</t>
<t tx="ekr.20040723142710.2">def onIconBoxRightClick (self,event):

    p = self.eventToPosition(event)
    g.trace(p)
    
    if p:
        self.select(p)
        g.app.findFrame.handleUserClick(p)

    return "break" # disable expanded box handling.</t>
<t tx="ekr.20040723142710.3"></t>
<t tx="ekr.20040723142710.4">def onHeadlineClick (self,event):
    
    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
    
    try:
        if not g.doHook("headclick1",c=c,p=p,event=event):
            self.OnActivate(p)
        g.doHook("headclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headclick")
        
    return "continue"</t>
<t tx="ekr.20040723142710.5">def onHeadlineRightClick (self,event):

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"

    try:
        if not g.doHook("headrclick1",c=c,p=p,event=event):
            self.OnActivate(p)
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"</t>
<t tx="ekr.20040723142710.6">def onHeadlineKey (self,event):
    
    """Handle a key event in a headline."""
    
    w = event.widget ; ch = event.char

    try:
        p = w.leo_position
    except AttributeError:
        return "continue"

    self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p,ch)
    
    return "continue"</t>
<t tx="ekr.20040723142845"></t>
<t tx="ekr.20040723171510"></t>
<t tx="ekr.20040723171712">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.useBindtags = False
    
    self.createPermanentBindings()
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    self.editWidgets = []
        # List of Tk.Text widgets containing t.leo_position attributes.
    self.ids = {}
        # Keys are id's, values are unchanging positions.
    self.iconIds = {}
        # Keys are icon id's, values are unchanging positions.
    
    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = []
    
    # Lists of newly freed, not-yet-hidden widgets...
    self.newlyFreedBoxes = []
    self.newlyFreedClickBoxes = []
    self.newlyFreedIcons = []
    self.newlyFreedLines = []
    self.newlyFreedText = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = []</t>
<t tx="ekr.20040723171712.1"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.disableRedraw = False # True: reschedule a redraw for later.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()

# Recycling bindings.
if 0: # no longer used
    self.bindings = [] # List of bindings to be unbound when redrawing.
    self.tagBindings = [] # List of tag bindings to be unbound when redrawing.
    self.widgets = [] # Widgets that must be destroyed when redrawing.

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.
self.drag_id = None # To reset bindings after drag

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.trace = False # True enabling of various traces.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw)</t>
<t tx="ekr.20040723173301">@ This class implements a tree control similar to Windows explorer.  The draw code is based on code found in Python's IDLE program.  Thank you Guido van Rossum!

The tree class knows about vnodes.  The vnode class could be split into a base class (say a treeItem class) containing the ivars known to the tree class, and a derived class containing everything else, including, e.g., the bodyString ivar.  I haven't chosen to split the vnode class this way because nothing would be gained in Leo.
</t>
<t tx="ekr.20040723173301.1">@ Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.  The main challenges are eliminating flicker and handling events properly.

Eliminating flicker.  Leo must update the outline pane with minimum flicker.  Various versions of Leo have approached this problem in different ways.  The drawing code in leo.py is robust, flexible, relatively simple and should work in almost any conceivable environment.

Leo assumes that all code that changes the outline pane will be enclosed in matching calls to the c.beginUpdate and c.endUpdate  methods of the Commands class. c.beginUpdate() inhibits drawing until the matching c.endUpdate().  These calls may be nested; only the outermost call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.

In leo.py, code may call c.endUpdate(flag) instead of c.endUpdate().  Leo redraws the screen only if flag is True.  This allows code to suppress redrawing entirely when needed.  For example, study the idle_body_key event handler to see how Leo conditionally redraws the outline pane.

The leoTree class redraws all icons automatically when c.redraw() is called.  This is a major simplification compared to previous versions of Leo.  The entire machinery of drawing icons in the vnode class has been eliminated.  The v.computeIcon method tells what the icon should be.  The v.iconVal ivar that tells what the present icon is. The event handler simply compares these two values and sets redraw_flag if they don't match.</t>
<t tx="ekr.20040723173301.2"></t>
<t tx="ekr.20040723173301.3"></t>
<t tx="ekr.20040723173301.4"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setDisabledLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)</t>
<t tx="ekr.20040723173301.5">def editLabel (self,p):
    
    """Start editing at position p."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()
        self.frame.revertHeadline = None

    # Start editing
    if p:
        g.trace(p)
        self.setNormalLabelState(p)
        self.frame.revertHeadline = p.headString()
        # Set position returned by leoTree.editPosition()
        self.setEditPosition(p)</t>
<t tx="ekr.20040723173301.6">def endEditLabel (self):
    
    """End editing for self.editText."""

    c = self.c ; gui = g.app.gui
    
    #################### Depends on the timing when editPosition changes.
    p = self.editPosition()
    
    if p:
        g.trace(p)
        self.setUnselectedLabelState(p)
        self.setEditPosition(None)

        # force a redraw of joined and ancestor headlines.
        self.force_redraw() 

    gui.set_focus(c,c.frame.bodyCtrl)</t>
<t tx="ekr.20040723173301.7">def expandAllAncestors (self,p):
    
    redraw_flag = False

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    return redraw_flag

</t>
<t tx="ekr.20040723173301.8"># Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=True):

    if not p: return
    
    p = p.copy() # Make sure we don't change the caller's position.
    
    g.trace(p)
    
    &lt;&lt; define vars and stop editing &gt;&gt;

    if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
        &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # 3/26/03: Suppress duplicate call.
            try: # may fail during initialization
                self.idle_scrollTo(p)
            except: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_v=p,old_v=old_p)
    
    # g.printGc()</t>
<t tx="ekr.20040723173301.9">c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)</t>
<t tx="ekr.20040723173301.10"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p and old_p != p:
    # g.trace("different node")
    self.endEditLabel()
    self.setUnselectedLabelState(old_p)

if old_p and old_p == self.editPosition():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20040723173301.11">frame.setWrap(p)

# 6/14/04: Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
body.delete("1.0","end")
body.insert("1.0",s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")</t>
<t tx="ekr.20040723173301.12">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p)
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20040723173301.13"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p)</t>
<t tx="ekr.20040723173301.14">self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p)
g.app.gui.set_focus(c,c.frame.bodyCtrl)</t>
<t tx="ekr.20040723173301.15">





</t>
<t tx="ekr.20040723173301.16">def setEditHeadlineColors (self,w):
    
    config = g.app.config
    
    fg   = config.getWindowPref("headline_text_editing_foreground_color")
    bg   = config.getWindowPref("headline_text_editing_background_color")
    selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
    selbg = config.getWindowPref("headline_text_editing_selection_background_color")
    
    if not fg or not bg:
        fg,bg = "black","white"
    
    try:
        #s = w.get("1.0","end")
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        #s2 = w.get("1.0","end")
        #assert s==s2
    except:
        g.es_exception()</t>
<t tx="ekr.20040723173301.17">def setDisabledHeadlineColors (self,w):

    config = g.app.config

    fg = config.getWindowPref("headline_text_selected_foreground_color")
    bg = config.getWindowPref("headline_text_selected_background_color")
    
    if not fg or not bg:
        fg,bg = "black","gray80"
    
    try:
        #s = w.get("1.0","end")
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
        #s2 = w.get("1.0","end")
        #assert s==s2
    except:
        g.es_exception()</t>
<t tx="ekr.20040723173301.18">def setUnselectedHeadlineColors (self,w):
    
    config = g.app.config
    
    fg = config.getWindowPref("headline_text_unselected_foreground_color")
    bg = config.getWindowPref("headline_text_unselected_background_color")
    
    if not fg or not bg:
        fg,bg = "black","white"
    
    try:
        #s = w.get("1.0","end")
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
        #s2 = w.get("1.0","end")
        #assert s==s2
    except:
        g.es_exception()</t>
<t tx="ekr.20040723173301.19">def OnUpKey   (self,event=None): return self.moveUpDown("up")
def OnDownKey (self,event=None): return self.moveUpDown("down")

def moveUpDown (self,upOrDown):
    c = self.c ; body = c.frame.bodyCtrl
    # Make the insertion cursor visible so bbox won't return an empty list.
    body.see("insert")
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    ins =  body.index("insert")
    lines,char = g.scanf(ins,"%d.%d")
    x,y,junk,textH = body.bbox("insert")
    bodyW,bodyH = body.winfo_width(),body.winfo_height()
    junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if upOrDown == "up":
        if y &lt;= textH:
            body.yview("scroll",-1,"units")
        else: y = max(y-textH,0)
    else:
        if y &gt;= maxy:
            body.yview("scroll",1,"units")
        else: y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width/2:
        x = newx + width + 1
    result = body.index("@%d,%d" % (x,y))
    body.mark_set("insert",result)
    # g.trace("entry:  %s.%s" % (lines,char))
    # g.trace("result:",result)
    # g.trace("insert:",body.index("insert"))
    return "break" # Inhibit further bindings.</t>
<t tx="ekr.20040723173919"></t>
<t tx="ekr.20040723173919.1">def getFont (self):

    return self.font
        
# Called by leoFontPanel.
def setFont (self, font=None, fontName=None):
    
    if fontName:
        self.fontName = fontName
        self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font
        
    self.setLineHeight(self.font)
    
# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):

    font = g.app.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        g.app.config.defaultTreeFontSize)

    self.setFont(font)</t>
<t tx="ekr.20040723173919.2">def headWidth(self,v):

    """Returns the proper width of the entry widget for the headline."""

    return max(10,5 + len(v.headString()))
    
def widthInPixels(self,s):

    s = g.toEncodedString(s,g.app.tkEncoding)
    
    width = self.font.measure(s)
    
    # g.trace(width,s)
    
    return width</t>
<t tx="ekr.20040723173919.3">def setLineHeight (self,font):
    
    try:
        metrics = font.metrics()
        linespace = metrics ["linespace"]
        self.line_height = linespace + 5 # Same as before for the default font on Windows.
        # print metrics
    except:
        self.line_height = line_height # was 17 + 2
        g.es("exception setting outline line height")
        g.es_exception()</t>
<t tx="ekr.20040723173919.4">def setTreeColorsFromConfig (self):

    bg = g.app.config.getWindowPref("outline_pane_background_color")
    if bg:
        try: self.canvas.configure(bg=bg)
        except: pass
</t>
<t tx="ekr.20040723174025"></t>
<t tx="ekr.20040723174025.1">def allocateNodes(self,where,lines):
    
    """Allocate Tk widgets in nodes that will become visible as the result of an upcoming scroll"""
    
    assert(where in ("above","below"))

    # print "allocateNodes: %d lines %s visible area" % (lines,where)
    
    # Expand the visible area: a little extra delta is safer.
    delta = lines * (self.line_height + 4)
    y1,y2 = self.visibleArea

    if where == "below":
        y2 += delta
    else:
        y1 = max(0.0,y1-delta)

    self.expandedVisibleArea=y1,y2
    # print "expandedArea:   %5.1f %5.1f" % (y1,y2)
    
    # Allocate all nodes in expanded visible area.
    self.updatedNodeCount = 0
    self.updateTree(self.c.rootPosition(),root_left,root_top,0,0)
    # if self.updatedNodeCount: print "updatedNodeCount:", self.updatedNodeCount
</t>
<t tx="ekr.20040723174025.2">def allocateNodesBeforeScrolling (self, args):
    
    """Calculate the nodes that will become visible as the result of an upcoming scroll.

    args is the tuple passed to the Tk.Canvas.yview method"""

    if not self.allocateOnlyVisibleNodes: return

    # print "allocateNodesBeforeScrolling:",self.redrawCount,args

    assert(self.visibleArea)
    assert(len(args)==2 or len(args)==3)
    kind = args[0] ; n = args[1]
    lines = 2 # Update by 2 lines to account for rounding.
    if len(args) == 2:
        assert(kind=="moveto")
        frac1,frac2 = args
        if float(n) != frac1:
            where = g.choose(n&lt;frac1,"above","below")
            self.allocateNodes(where=where,lines=lines)
    else:
        assert(kind=="scroll")
        linesPerPage = self.canvas.winfo_height()/self.line_height + 2
        n = int(n) ; assert(abs(n)==1)
        where = g.choose(n == 1,"below","above")
        lines = g.choose(args[2] == "pages",linesPerPage,lines)
        self.allocateNodes(where=where,lines=lines)</t>
<t tx="ekr.20040723174025.3">def updateNode (self,v,x,y):
    
    """Draw a node that may have become visible as a result of a scrolling operation"""

    if self.inExpandedVisibleArea(y):
        # This check is a major optimization.
        if not v.edit_text():
            return self.force_draw_node(v,x,y)
        else:
            return self.line_height

    return self.line_height</t>
<t tx="ekr.20040723174025.4">def setVisibleAreaToFullCanvas(self):
    
    if self.visibleArea:
        y1,y2 = self.visibleArea
        y2 = max(y2,y1 + self.canvas.winfo_height())
        self.visibleArea = y1,y2</t>
<t tx="ekr.20040723174025.5">def setVisibleArea (self,args):

    r1,r2 = args
    r1,r2 = float(r1),float(r2)
    # print "scroll ratios:",r1,r2

    try:
        s = self.canvas.cget("scrollregion")
        x1,y1,x2,y2 = g.scanf(s,"%d %d %d %d")
        x1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)
    except:
        self.visibleArea = None
        return
        
    scroll_h = y2-y1
    # print "height of scrollregion:", scroll_h

    vy1 = y1 + (scroll_h*r1)
    vy2 = y1 + (scroll_h*r2)
    self.visibleArea = vy1,vy2
    # print "setVisibleArea: %5.1f %5.1f" % (vy1,vy2)
</t>
<t tx="ekr.20040723174025.6">def updateTree (self,v,x,y,h,level):

    yfirst = ylast = y
    if level==0: yfirst += 10
    while v:
        # g.trace(x,y,v)
        h = self.updateNode(v,x,y)
        y += h ; ylast = y
        if v.isExpanded() and v.firstChild():
            y = self.updateTree(v.firstChild(),x+child_indent,y,h,level+1)
        v = v.next()
    return y
</t>
<t tx="ekr.20040723180507.1"></t>
<t tx="ekr.20040723180507.2">def setNormalLabelState (self,p): # selected, editing

    w = self.findEditWidget(p,tag="setNormalLabelState")
    
    if w:
        g.trace(p)
        self.setEditHeadlineColors(w)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
        g.app.gui.set_focus(self.c,w)</t>
<t tx="ekr.20040723180507.3">def setDisabledLabelState (self,p): # selected, disabled

    # g.trace(p,g.callerName(2),g.callerName(3))
    
    return ###
 
    w = self.findEditWidget(p,tag="setDisabledLabelState")

    if w:
        g.trace(p)
        self.setDisabledHeadlineColors(w)</t>
<t tx="ekr.20040723180507.4">def setSelectedLabelState (self,p): # selected, not editing

    return ###

    w = self.findEditWidget(p,tag="setDisabledLabelState")

    if w:
        self.setDisabledHeadlineColors(w)
</t>
<t tx="ekr.20040723180507.5">def setUnselectedLabelState (self,p): # not selected.

    return ###

    w = self.findEditWidget(p,tag="setUnselectedLabelState")

    if w:
        assert(p == w.leo_position)
    
        self.setUnselectedHeadlineColors(w)</t>
<t tx="ekr.20040723181301"></t>
<t tx="ekr.20040723182839"></t>
<t tx="ekr.20040723183449.1"></t>
<t tx="ekr.20040723184305">def newBox (self):
    
    if self.newlyFreedBoxes:
        id = self.newlyFreedBoxes.pop()

    elif self.freeBoxes:
        id = self.freeBoxes.pop()

    else:
        id = self.canvas.create_image(0,0,tag="plusBox")
        assert(not self.ids.get(id))
        
    self.visibleBoxes.append(id)
    
    return id</t>
<t tx="ekr.20040723184305.1">def newIcon (self):

    if self.newlyFreedIcons:
        id = self.newlyFreedIcons.pop()

    elif self.freeIcons:
        id = self.freeIcons.pop()

    else:
        id = self.canvas.create_image(0,0,anchor="nw",tag="iconBox")
        assert(not self.ids.get(id))
        
    self.visibleIcons.append(id)
    return id
        
    </t>
<t tx="ekr.20040723184305.2">def newLine (self):
    
    if self.newlyFreedLines:
        id = self.newlyFreedLines.pop()

    elif self.freeLines:
        id = self.freeLines.pop()
    
    else:
        id = self.canvas.create_line(0,0,0,0,tag="lines",fill="gray50") # stipple="gray25")
        assert(not self.ids.get(id))
        
    self.visibleLines.append(id)
    return id</t>
<t tx="ekr.20040723184305.4">def newText (self,forceAllocate=False):
    
    # Never allocate newly-free widgets...
    if not forceAllocate and self.newlyFreedText:
                data = self.newlyFreedText.pop()
                id,t = data
                # t.configure(bg="blue")
    elif not forceAllocate and self.freeText:
        data = self.freeText.pop()
        id,t = data
        # t.configure(bg="red")
    else:
        # Tags are not valid in Tk.Text widgets, so we use class bindings instead.
        t = Tk.Text(self.canvas,state="normal",font=self.font,bd=0,relief="flat",height=1)
        # t.configure(bg="yellow")
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick)
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick)
            t.bind("&lt;Key&gt;",      self.onHeadlineKey)
            t.bind("&lt;Control-t&gt;",self.onControlT)
        
        id = self.canvas.create_window(0,0,anchor="nw",window=t,tag="textBox")
        assert(not self.ids.get(id))

    data = id,t
    self.visibleText.append(data)
    return id,t</t>
<t tx="ekr.20040723190945">def drawLine (self,x1,y1,x2,y2):
    
    id = self.newLine()
    
    self.canvas.coords(id,x1,y1,x2,y2)
    
    return id
</t>
<t tx="ekr.20040723194802">def recycleWidgets (self):
    
    for id in self.visibleBoxes:
        self.newlyFreedBoxes.append(id)
    self.visibleBoxes = []

    for id in self.visibleClickBoxes:
        self.newlyFreedClickBoxes.append(id)
    self.visibleClickBoxes = []
    
    for id in self.visibleIcons:
        self.newlyFreedIcons.append(id)
    self.visibleIcons = []
        
    for id in self.visibleLines:
        self.newlyFreedLines.append(id)
    self.visibleLines = []
    
    for data in self.visibleText:
        id,t = data
        t.leo_position = None
        self.newlyFreedText.append(data)
    self.visibleText  = []
    
    if 0:
        g.trace("boxes",len(self.newlyFreedBoxes))
        g.trace("boxes",len(self.newlyFreedClickBoxes))
        g.trace("icons",len(self.newlyFreedIcons))
        g.trace("lines",len(self.newlyFreedLines))
        g.trace("text",len(self.newlyFreedText))</t>
<t tx="ekr.20040723203426">def hideNewlyFreedWidgets (self):
    
    """Hide all newly-freed widgets and move them to the free lists."""
    
    canvas = self.canvas
    
    &lt;&lt; hide all the newly-freed widgets &gt;&gt;
    &lt;&lt; move all newly-freed widgets to the free lists &gt;&gt;
    
    # g.trace(len(self.freeBoxes)+len(self.freeIcons)+len(self.freeLines)+len(self.freeText))
    
    if 0:
        g.trace("boxes",len(self.freeBoxes))
        g.trace("icons",len(self.freeIcons))
        g.trace("lines",len(self.freeLines))
        g.trace("text",len(self.freeText))</t>
<t tx="ekr.20040724072523">
# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20040724072523.1">def newClickBox (self):

    if self.newlyFreedClickBoxes:
        id = self.newlyFreedClickBoxes.pop()

    elif self.freeClickBoxes:
        id = self.freeClickBoxes.pop()

    else:
        id = self.canvas.create_rectangle(0,0,0,0,tag="clickBox")
        assert(not self.ids.get(id))
        
    self.visibleClickBoxes.append(id)
    return id</t>
<t tx="ekr.20040724083359">def configureTextState (self,p):
    
    c = self.c
    
    if not p: return # should never happen...
    
    if p == c.currentPosition():
        if p == self.editPosition():
            self.setNormalLabelState(p)
        else:
            self.setDisabledLabelState(p) # selected, disabled
    else:
        self.setUnselectedLabelState(p) # unselected</t>
<t tx="ekr.20040724100003"></t>
<t tx="ekr.20040724102927"># Search the widget list for widget t with t.leo_position == p.

def findEditWidget (self,p,tag=""):
    
    """Return the Tk.Text item corresponding to p."""

    if not p: return None
    
    ok = self.checkWidgetList("findEditWidget")
    if not ok: return None

    for t in self.editWidgets:
        assert(t.leo_position)
            
        if t.leo_position == p:
            s = t.get("1.0","end")
            # checkWidgetList should have caught this.
            assert(p.headString().strip() == s.strip()) 
            return t

    return None</t>
<t tx="ekr.20040724125005">def edit_text (self,p):
    
    # g.trace(p)
    
    if self.editPosition:
        return self.findEditWidget(p,tag="tree:edit_text")
    else:
        return None</t>
<t tx="ekr.20040724141115"></t>
<t tx="ekr.20040724142110.11">def editPosition(self):
    
    return self._editPosition # An ivar in leoTree.
    </t>
<t tx="ekr.20040724142110.12">def setEditPosition(self,p):
    
    g.trace(p)
    self._editPosition = p</t>
<t tx="ekr.20040724144958">def edit_text (self):
    
    p = self
    
    if p:
        return self.c.frame.tree.findEditWidget(p,tag="p.edit_text(new)")
    else:
        return None</t>
<t tx="ekr.20040724152715"></t>
<t tx="ekr.20040724161900">def textAddr(self,t):
    
    """Return the address part of repr(Tk.Text)."""
    
    return repr(t)[-9:-1].lower()</t>
<t tx="ekr.20040724163004"></t>
<t tx="ekr.20040725050101">def injectCallbacks(self):
    
    import leoNodes
    
    &lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):
        
        g.funcToMethod(f,leoNodes.position)</t>
<t tx="ekr.20040725050101.1"># N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others

</t>
<t tx="ekr.20040725050101.6">def OnHyperLinkControlClick (self,event):
    
    """Callback injected into position class."""

    g.trace(self)
    try:
        p = self ; c = p.c
        if not g.doHook("hypercclick1",c=c,p=p,event=event):
            c.beginUpdate()
            c.selectVnode(p)
            c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hypercclick")
        
onHyperLinkControlClick = OnHyperLinkControlClick</t>
<t tx="ekr.20040725050101.8">def OnHyperLinkEnter (self,event=None):
    
    """Callback injected into position class."""

    g.trace(self)
    try:
        p = self ; c = p.c
        if not g.doHook("hyperenter1",c=c,p=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hyperenter")
        
onHyperLinkEnter = OnHyperLinkEnter</t>
<t tx="ekr.20040725050101.9">def OnHyperLinkLeave (self,event=None):
    
    """Callback injected into position class."""

    g.trace(self)
    try:
        p = self ; c = p.c
        if not g.doHook("hyperleave1",c=c,p=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hyperleave")
        
onHyperLinkLeave = OnHyperLinkLeave</t>
<t tx="ekr.20040725051437"># The new code injects 3 callbacks for the colorizer.

if not myLeoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20040725051909"></t>
<t tx="ekr.20040725052452"># Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=True):

    if not p: return
    
    &lt;&lt; define vars and stop editing &gt;&gt;
    
    # g.trace(p)
    # g.printGc()

    if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
        &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # 3/26/03: Suppress duplicate call.
            try: # may fail during initialization
                self.idle_scrollTo(p)
            except: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_v=p,old_v=old_p)
    
    # g.printGc()</t>
<t tx="ekr.20040725052452.1">c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)</t>
<t tx="ekr.20040725052452.2"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p and old_p != p:
    # g.trace("different node")
    self.endEditLabel()
    self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20040725052452.3">frame.setWrap(p)

# 6/14/04: Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
body.delete("1.0","end")
body.insert("1.0",s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")</t>
<t tx="ekr.20040725052452.4">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p)
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20040725052452.5"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p)</t>
<t tx="ekr.20040725052452.6">self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)</t>
<t tx="ekr.20040725052606">def setNormalLabelState (self,p): # selected, editing

    # g.trace(p)
    if p and p.edit_text():
        &lt;&lt; set editing headline colors &gt;&gt;
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        g.app.gui.set_focus(self.c,p.edit_text())

def setDisabledLabelState (self,p): # selected, disabled

    # g.trace(p,g.callerName(2),g.callerName(3))
    if p and p.edit_text():
        &lt;&lt; set selected, disabled headline colors &gt;&gt;

def setSelectedLabelState (self,p): # selected, not editing

    # g.trace(p)
    self.setDisabledLabelState(p)

def setUnselectedLabelState (self,p): # not selected.

    # g.trace(p)
    if p and p.edit_text():
        &lt;&lt; set unselected headline colors &gt;&gt;
</t>
<t tx="ekr.20040725052606.1">config = g.app.config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")

if not fg or not bg:
    fg,bg = "black","white"

try:
    if selfg and selbg:
        p.edit_text().configure(
            selectforeground=selfg,selectbackground=selbg,
            state="normal",highlightthickness=1,fg=fg,bg=bg)
    else:
        p.edit_text().configure(
            state="normal",highlightthickness=1,fg=fg,bg=bg)
except:
    g.es_exception()</t>
<t tx="ekr.20040725052606.2">config = g.app.config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")

if not fg or not bg:
    fg,bg = "black","gray80"

try:
    p.edit_text().configure(
        state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
    g.es_exception()</t>
<t tx="ekr.20040725052606.3">config = g.app.config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")

if not fg or not bg:
    fg,bg = "black","white"

try:
    p.edit_text().configure(
        state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
    g.es_exception()</t>
<t tx="ekr.20040725052914">def editLabel (self,p):
    
    """Start editing p.edit_text."""
    
    # g.trace(p)

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()
        self.frame.revertHeadline = None
        
    self.setEditPosition(p)

    # Start editing
    if p and p.edit_text():
        self.setNormalLabelState(p)
        self.frame.revertHeadline = p.headString()
        self.setEditPosition(p)</t>
<t tx="ekr.20040725053107"></t>
<t tx="ekr.20040725053107.1">def endEditLabel (self):
    
    """End editing for self.editText."""

    c = self.c ; gui = g.app.gui
    
    p = self.editPosition()

    if p and p.edit_text():
        self.setUnselectedLabelState(p)
        self.setEditPosition(None)

        # force a redraw of joined and ancestor headlines.
        self.force_redraw() 

    gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02</t>
<t tx="ekr.20040725053337"># N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others</t>
<t tx="ekr.20040725053337.1"># Called when the box is clicked.

def OnBoxClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("boxclick1",c=c,p=p,event=event):
            c.frame.tree.OnBoxClick(p)
        g.doHook("boxclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("boxclick")</t>
<t tx="ekr.20040725053337.2">def OnDrag(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if c.frame.tree.dragging():
            if not g.doHook("dragging1",c=c,p=p,event=event):
                c.frame.tree.OnDrag(p,event)
            g.doHook("dragging2",c=c,p=p,event=event)
        else:
            if not g.doHook("drag1",c=c,p=p,event=event):
                c.frame.tree.OnDrag(p,event)
            g.doHook("drag2",c=c,p=p,event=event)
    except:
        g.es_event_exception("drag")</t>
<t tx="ekr.20040725053337.3">def OnEndDrag(self,event=None):
    
    """Callback injected into vnode or position class."""
    
    # g.trace()

    try:
        p = self ; c = p.c
        # 7/10/03: Always call frame.OnEndDrag, regardless of state.
        if not g.doHook("enddrag1",c=c,p=p,event=event):
            c.frame.tree.OnEndDrag(p,event)
        g.doHook("enddrag2",c=c,p=p,event=event)
    except:
        g.es_event_exception("enddrag")</t>
<t tx="ekr.20040725053337.4">def OnHeadlineClick(self,event=None):
    """Callback injected into vnode or position class."""
    try:
        p = self ; c = p.c
        if not g.doHook("headclick1",c=c,p=p,event=event):
            c.frame.tree.OnActivate(p)
        g.doHook("headclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headclick")
    
def OnHeadlineRightClick(self,event=None):

    """Callback injected into vnode or position class."""

    #g.trace()
    try:
        p = self ; c = p.c
        if not g.doHook("headrclick1",c=c,p=p,event=event):
            c.frame.tree.OnActivate(p)
            c.frame.tree.OnPopup(self,event)
        g.doHook("headrclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headrclick")</t>
<t tx="ekr.20040725053337.5">def OnHyperLinkControlClick (self,event):
    
    """Callback injected into vnode or position class."""

    # g.trace()
    try:
        p = self ; c = p.c
        if not g.doHook("hypercclick1",c=c,p=p,event=event):
            c.beginUpdate()
            c.selectVnode(p)
            c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hypercclick")</t>
<t tx="ekr.20040725053337.6">def OnHeadlineKey (self,event=None):

    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("headkey1",c=c,p=p,event=event):
            c.frame.tree.OnHeadlineKey(p,event)
        g.doHook("headkey2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headkey")</t>
<t tx="ekr.20040725053337.7">def OnHyperLinkEnter (self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperenter1",c=c,p=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hyperenter")</t>
<t tx="ekr.20040725053337.8">def OnHyperLinkLeave (self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperleave1",c=c,p=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hyperleave")</t>
<t tx="ekr.20040725053337.9">def OnIconClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("iconclick1",c=c,p=p,event=event):
            c.frame.tree.OnIconClick(p,event)
        g.doHook("iconclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("iconclick")
    
def OnIconRightClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("iconrclick1",c=c,p=p,event=event):
            c.frame.tree.OnIconRightClick(p,event)
        g.doHook("iconrclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("iconrclick")
</t>
<t tx="ekr.20040725053337.10">def OnIconDoubleClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("icondclick1",c=c,p=p,event=event):
            c.frame.tree.OnIconDoubleClick(self)
        g.doHook("icondclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("icondclick")
</t>
<t tx="ekr.20040725053405"></t>
<t tx="ekr.20040725053607"># Called on click in box and double-click in headline.

def ORIGINAL_OnBoxClick (self,p):
    
    # g.trace(p)

    # Note: "boxclick" hooks handled by vnode callback routine.
    c = self.c ; gui = g.app.gui

    if p.isExpanded(): p.contract()
    else:              p.expand()

    self.active = True
    self.select(p)
    g.app.findFrame.handleUserClick(p) # 4/3/04
    gui.set_focus(c,c.frame.bodyCtrl) # 7/12/03
    self.redraw()</t>
<t tx="ekr.20040725055657">def dumpWidgetList (self,tag):
    
    print
    print "checkWidgetList: %s" % tag
    
    for t in self.editWidgets:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
    
            addr = self.textAddr(t)
            print "p:",addr,h
            if h != s:
                print "t:",'*' * len(addr),s
        else:
            print "t.leo_position == None",t</t>
<t tx="ekr.20040725060102">def checkWidgetList (self,tag):
    
    for t in self.editWidgets:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
            
            if h != s:
                self.dumpWidgetList(tag)
                return False
        else:
            self.dumpWidgetList(tag)
            return False
            
    return True</t>
<t tx="ekr.20040725071403">def totalTextWidgets (self):
    
    n = len(self.visibleText) + len(self.newlyFreedText) + len(self.freeText)
    return n # Each item is a 2-tuple.</t>
<t tx="ekr.20040725072304">def getTextStats (self):
    
    return "%3d %3d %3d tot: %4d" % (
        len(self.visibleText),
        len(self.newlyFreedText),
        len(self.freeText),

        len(self.visibleText) +
        len(self.newlyFreedText) +
        len(self.freeText)
    )</t>
<t tx="ekr.20040725073642">for id in self.newlyFreedBoxes:
    canvas.coords(id,-100,-100)
    
for id in self.newlyFreedClickBoxes:
    canvas.coords(id,-100,-100,-100,-100)

for id in self.newlyFreedIcons:
    canvas.coords(id,-100,-100)

for id in self.newlyFreedLines:
    canvas.coords(id,-100,-100,-100,-100)
    
for data in self.newlyFreedText:
    id,t = data
    canvas.coords(id,-100,-100)
    t.leo_position = None # Remove the reference immediately.</t>
<t tx="ekr.20040725073642.1">for id in self.newlyFreedBoxes:
    self.freeBoxes.append(id)
self.newlyFreedBoxes = []
    
for id in self.newlyFreedClickBoxes:
    self.freeClickBoxes.append(id)
self.newlyFreedClickBoxes = []
    
for id in self.newlyFreedIcons:
    self.freeIcons.append(id)
self.newlyFreedIcons = []
    
for id in self.newlyFreedLines:
    self.freeLines.append(id)
self.newlyFreedLines = []

for data in self.newlyFreedText:
    self.freeText.append(data)
self.newlyFreedText = []</t>
<t tx="ekr.20040725074321">def traceIds (self):
    
    keys = self.ids.keys()
    keys.sort
    for key in keys:
        p = self.ids.get(key)
        print key,p.headString()</t>
</tnodes>
</leo_file>
