<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="6191" clone_windows="0"/>
<globals body_outline_ratio="0.600997506234">
	<global_window_position top="11" left="364" height="802" width="865"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20041211035618"><vh>Scripts, buttons &amp; settings</vh>
<v t="EKR.20040517075110"><vh>replaceLeoGlobals</vh>
<v t="EKR.20040517075110.1"><vh>&lt;&lt; set nameList to the list of functions in leoGlobals.py &gt;&gt;</vh></v>
<v t="EKR.20040517075110.2"><vh>findFunctionsInTree</vh></v>
<v t="EKR.20040517075110.3"><vh>findDefs</vh></v>
<v t="EKR.20040517075110.4"><vh>prependNamesInTree</vh>
<v t="EKR.20040517075110.5"><vh>&lt;&lt; look for name followed by '(' &gt;&gt;</vh></v>
<v t="EKR.20040517075110.6"><vh>&lt;&lt; print before and after &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050217093214"><vh>@settings</vh>
<v t="ekr.20050328101812"><vh>@page http plugin</vh>
<v t="ekr.20050328101812.1"><vh>@bool http_active = True</vh></v>
<v t="ekr.20050328101812.2"><vh>@int  port = 8080</vh></v>
<v t="ekr.20050328101812.3"><vh>@string rst_http_attributename = rst_http_attribute</vh></v>
</v>
</v>
<v t="ekr.20041103052443"><vh>Script to find and replace all functions in leoGlobals.py</vh>
<v t="ekr.20041103052443.1"><vh>findFunctionsInTree</vh></v>
<v t="ekr.20041103052443.2"><vh>findDefs</vh></v>
<v t="ekr.20041103052443.3"><vh>prependNamesInTree</vh>
<v t="ekr.20041103052443.4"><vh>&lt;&lt; look for name followed by '(' &gt;&gt;</vh></v>
<v t="ekr.20041103052443.5"><vh>&lt;&lt; print before and after &gt;&gt;</vh></v>
</v>
<v t="ekr.20041103052443.6"><vh>&lt;&lt; set nameList to the list of functions in leoGlobals.py &gt;&gt;</vh></v>
</v>
<v t="ekr.20060109114710"><vh>@button settings.leo</vh></v>
<v t="ekr.20050724100334"><vh>@button Beautify</vh></v>
<v t="ekr.20051025144116"><vh>@button Spell</vh></v>
<v t="ekr.20050819055746"><vh>@button Save</vh></v>
<v t="ekr.20050722075812"><vh>Remove blank trailing lines</vh></v>
</v>
<v t="ekr.20060109105601"><vh>Abandoned plugins</vh>
<v t="ekr.20050421093045"><vh> dyna plugin (modified from 139i)</vh>
<v t="ekr.20060109001152"><vh>&lt;&lt; modifications by EKR from 139i &gt;&gt;</vh></v>
<v t="ekr.20050421093045.1"><vh>&lt;&lt; insertAplug &gt;&gt;</vh></v>
<v t="ekr.20050421093045.2"><vh>@@thin dyna_menu.py</vh>
<v t="ekr.20050421093045.3"><vh>&lt;&lt; doc &gt;&gt;</vh></v>
<v t="ekr.20050421093045.4"><vh>&lt;&lt; initilize &gt;&gt;</vh></v>
<v t="ekr.20050421093045.5"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20050421093045.6"><vh>macros</vh>
<v t="ekr.20050421093045.7"><vh>info macros</vh>
<v t="ekr.20050421093045.8"><vh> Clip_dtef</vh></v>
<v t="ekr.20050421093045.9"><vh>HELP!</vh>
<v t="ekr.20050421093045.10"><vh>&lt;&lt; stdredirect n &gt;&gt;</vh></v>
<v t="ekr.20050421093045.11"><vh>&lt;&lt; happydoc &gt;&gt;</vh></v>
<v t="ekr.20050421093045.12"><vh>&lt;&lt; stdredirect f &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.13"><vh>Graphviz node</vh>
<v t="ekr.20050421093045.14"><vh>&lt;&lt; code &gt;&gt;</vh>
<v t="ekr.20050421093045.15"><vh>addLeoNodesToGraph</vh></v>
<v t="ekr.20050421093045.16"><vh>tnode/vnodeLabel</vh></v>
<v t="ekr.20050421093045.17"><vh>tnode/vnodeRepr</vh></v>
</v>
</v>
<v t="ekr.20050421093045.18"><vh>linenumber</vh></v>
<v t="ekr.20050421093045.19"><vh>nflatten</vh></v>
<v t="ekr.20050421093045.20"><vh>fileinfo</vh>
<v t="ekr.20050421093045.21"><vh>print perms</vh></v>
</v>
</v>
<v t="ekr.20050421093045.22"><vh>text macros</vh>
<v t="ekr.20050421093045.23"><vh>geturls</vh></v>
<v t="ekr.20050421093045.24"><vh>swaper</vh></v>
<v t="ekr.20050421093045.25"><vh>flipper</vh></v>
<v t="ekr.20050421093045.26"><vh>dupe</vh></v>
<v t="ekr.20050421093045.27"><vh>clipappend</vh></v>
<v t="ekr.20050421093045.28"><vh>everycase</vh></v>
<v t="ekr.20050421093045.29"><vh>dyna_regexTk</vh></v>
<v t="ekr.20050421093045.30"><vh>wraper</vh></v>
<v t="ekr.20050421093045.31"><vh>+rsortnumb</vh></v>
<v t="ekr.20050421093045.32"><vh>+sortnumb</vh></v>
<v t="ekr.20050421093045.33"><vh>del_last_char</vh></v>
</v>
<v t="ekr.20050421093045.34"><vh>codeing macros</vh>
<v t="ekr.20050421093045.35"><vh>importnode</vh>
<v t="ekr.20050421093045.36"><vh>&lt;&lt; checkFileSyntax &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.37"><vh>disa</vh></v>
<v t="ekr.20050421093045.38"><vh>c2py</vh></v>
<v t="ekr.20050421093045.39"><vh>+dynaHexdump</vh></v>
<v t="ekr.20050421093045.40"><vh>_sfdots</vh></v>
<v t="ekr.20050421093045.41"><vh>+call_evaluator</vh></v>
<v t="ekr.20050421093045.42"><vh>astyle</vh>
<v t="ekr.20050421093045.43"><vh>&lt;&lt;tidy&gt;&gt;</vh></v>
<v t="ekr.20050421093045.44"><vh>&lt;&lt; runastyle &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.45"><vh>pylint</vh></v>
<v t="ekr.20050421093045.46"><vh>makatemp</vh></v>
<v t="ekr.20050421093045.47"><vh>tim_one_crunch</vh>
<v t="ekr.20050421093045.48"><vh>Bugfixcrunch</vh>
<v t="ekr.20050421093045.49"><vh>&lt;&lt; bfcrunch &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050421093045.50"><vh>pre/post macros</vh>
<v t="ekr.20050421093045.51"><vh>du_test-str</vh>
<v t="ekr.20050421093045.52"><vh>&lt;&lt; Classes &gt;&gt;</vh>
<v t="ekr.20050421093045.53"><vh>ExitError</vh></v>
<v t="ekr.20050421093045.54"><vh>importCode</vh></v>
</v>
<v t="ekr.20050421093045.55"><vh>guts</vh>
<v t="ekr.20050421093045.56"><vh>&lt;&lt; n_redirect &gt;&gt;</vh></v>
<v t="ekr.20050421093045.57"><vh>&lt;&lt; DocTest &gt;&gt;</vh></v>
<v t="ekr.20050421093045.58"><vh>&lt;&lt; f_redirect &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050421093045.59"><vh> htmlize</vh>
<v t="ekr.20050421093045.60"><vh>&lt;&lt;more doc&gt;&gt;</vh></v>
<v t="ekr.20050421093045.61"><vh>&lt;&lt; initilize &gt;&gt;</vh></v>
<v t="ekr.20050421093045.62"><vh>class Parser</vh>
<v t="ekr.20050421093045.63"><vh>__init__</vh></v>
<v t="ekr.20050421093045.64"><vh>format</vh></v>
<v t="ekr.20050421093045.65"><vh>__call__</vh></v>
</v>
<v t="ekr.20050421093045.66"><vh>&lt;&lt;hopts&gt;&gt;</vh></v>
<v t="ekr.20050421093045.67"><vh>&lt;&lt;header plain footer&gt;&gt;</vh></v>
<v t="ekr.20050421093045.68"><vh>&lt;&lt; plain or rst &gt;&gt;</vh>
<v t="ekr.20050421093045.69"><vh>&lt;&lt; define code-block &gt;&gt;</vh></v>
<v t="ekr.20050421093045.70"><vh>&lt;&lt; docutil out &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.71"><vh>&lt;&lt; src-highlight &gt;&gt;</vh></v>
<v t="ekr.20050421093045.72"><vh>&lt;&lt; silvercity &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.73"><vh>restoreStd</vh></v>
<v t="ekr.20050421093045.74"><vh>del first n char</vh></v>
</v>
<v t="ekr.20050421093045.75"><vh>cascade actions</vh>
<v t="ekr.20050421093045.76"><vh>+DQ3</vh>
<v t="ekr.20050421093045.77"><vh>&lt;&lt;doctest&gt;&gt;</vh></v>
<v t="ekr.20050421093045.78"><vh>&lt;&lt; tripleline &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.79"><vh>_actions</vh>
<v t="ekr.20050421093045.80"><vh>&lt;&lt;doctest&gt;&gt;</vh></v>
<v t="ekr.20050421093045.81"><vh>&lt;&lt; codecs.lookup &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.82"><vh>_backslashs</vh></v>
</v>
</v>
<v t="ekr.20050421093045.83"><vh>config</vh>
<v t="ekr.20050421093045.84"><vh>flipvers</vh>
<v t="ekr.20050421093045.85"><vh>cmd_flipverbosity</vh></v>
<v t="ekr.20050421093045.86"><vh>cmd_flipLeo_debug</vh></v>
<v t="ekr.20050421093045.87"><vh>cmd_flipjustPyChecker</vh></v>
<v t="ekr.20050421093045.88"><vh>flip_onoff_c_gotoline</vh></v>
</v>
<v t="ekr.20050421093045.89"><vh>cmd_SetAsDefault</vh></v>
<v t="ekr.20050421093045.90"><vh>cmd_ShowDefaults</vh></v>
<v t="ekr.20050421093045.91"><vh>@ test _Configuration</vh>
<v t="ekr.20050421093045.92"><vh>getConfiguration</vh></v>
<v t="ekr.20050421093045.93"><vh>applyConfiguration</vh>
<v t="ekr.20050421093045.94"><vh>&lt;&lt; anint(x) &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050421093045.95"><vh>load_menu</vh>
<v t="ekr.20050421093045.96"><vh>&lt;&lt; togprpa &gt;&gt;</vh></v>
<v t="ekr.20050421093045.97"><vh>&lt;&lt; add items &gt;&gt;</vh></v>
<v t="ekr.20050421093045.98"><vh>&lt;&lt; action &gt;&gt;</vh>
<v t="ekr.20050421093045.99"><vh>actions</vh></v>
<v t="ekr.20050421093045.100"><vh>_backslashs</vh></v>
<v t="ekr.20050421093045.101"><vh>show clip</vh></v>
</v>
</v>
<v t="ekr.20050421093045.102"><vh>init</vh></v>
</v>
<v t="ekr.20050421093045.103"><vh>@@thin dynacommon.py</vh>
<v t="ekr.20050421093045.104"><vh>others</vh>
<v t="ekr.20050421093045.105"><vh>_caller_symbols</vh></v>
</v>
<v t="ekr.20050421093045.106"><vh>functs w/doctest</vh>
<v t="ekr.20050421093045.107"><vh>deangle</vh></v>
<v t="ekr.20050421093045.108"><vh>commafy</vh></v>
<v t="ekr.20050421093045.109"><vh>stripSentinels</vh>
<v t="ekr.20050421093045.110"><vh>&lt;&lt; essential doctesting &gt;&gt;</vh></v>
<v t="ekr.20050421093045.111"><vh>&lt;&lt; linematch &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.112"><vh>sanitize_</vh>
<v t="ekr.20050421093045.113"><vh>&lt;&lt; chk sanitize &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.114"><vh>leotmp</vh></v>
</v>
<v t="ekr.20050421093045.115"><vh>dynastuff</vh>
<v t="ekr.20050421093045.116"><vh>fixbody</vh></v>
<v t="ekr.20050421093045.117"><vh>selecbody</vh></v>
<v t="ekr.20050421093045.118"><vh>AskYesNo</vh></v>
<v t="ekr.20050421093045.119"><vh>dynaBunch</vh></v>
<v t="ekr.20050421093045.120"><vh>names and colors</vh></v>
<v t="ekr.20050421093045.121"><vh>dynaerrout</vh></v>
<v t="ekr.20050421093045.122"><vh>dynaerrline</vh></v>
<v t="ekr.20050421093045.123"><vh>getsubnodes</vh></v>
<v t="ekr.20050421093045.124"><vh>captureStd</vh></v>
<v t="ekr.20050421093045.125"><vh>runcmd</vh>
<v t="ekr.20050421093045.126"><vh>&lt;&lt; subproc &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.127"><vh>dynadoc</vh>
<v t="ekr.20050421093045.128"><vh>&lt;&lt; formdoc &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.129"><vh>quiet warnings</vh></v>
</v>
<v t="ekr.20050421093045.130"><vh>dynaput</vh></v>
<v t="ekr.20050421093045.131"><vh>python -O</vh></v>
<v t="ekr.20050421093045.132"><vh>&lt;&lt; set filenames &gt;&gt;</vh></v>
</v>
<v t="ekr.20050421093045.133" tnodeList="ekr.20050421093045.133"><vh>@nosent dyna_menu.ini</vh></v>
<v t="ekr.20050421093045.134"><vh>@@thin dyna.txt</vh>
<v t="ekr.20050421093045.135"><vh>you need</vh>
<v t="ekr.20050421093045.136"><vh>get the pylint rc</vh></v>
</v>
<v t="ekr.20050421093045.137"><vh>rc</vh>
<v t="ekr.20050421093045.138"><vh>&lt;&lt; @home &gt;&gt;</vh>
<v t="ekr.20050421093045.139"><vh>windefs</vh></v>
<v t="ekr.20050421093045.140"><vh>macdefs</vh></v>
</v>
<v t="ekr.20050421093045.141"><vh>@test onetest</vh></v>
<v t="ekr.20050421093045.142"><vh>urls</vh>
<v t="ekr.20050421093045.143"><vh>@url http://www.logilab.org/projects/pylint</vh></v>
<v t="ekr.20050421093045.144"><vh>@url http://www.logilab.org/projects/common</vh></v>
<v t="ekr.20050421093045.145"><vh>@url http://pychecker.sourceforge.net/</vh></v>
</v>
<v t="ekr.20050421093045.146"><vh>@file-nosent .pdbrc</vh></v>
<v t="ekr.20050421093045.147"><vh>@file-nosent .pythonrc.py</vh></v>
<v t="ekr.20050421093045.148"><vh>@file-nosent .pycheckrc</vh></v>
<v t="ekr.20050421093045.149"><vh>@file-nosent .pylintrc</vh></v>
<v t="ekr.20050421093045.150"><vh>@nosent tags.j2h</vh></v>
</v>
<v t="ekr.20050421093045.151"><vh>leo css</vh>
<v t="ekr.20050421093045.152"><vh>@file default.css</vh>
<v t="ekr.20050421093045.153"><vh>leo_rst1.css</vh></v>
<v t="ekr.20050421093045.154"><vh>silver_city1.css</vh></v>
</v>
</v>
<v t="ekr.20050421093045.155"><vh>rpdb</vh>
<v t="ekr.20050421093045.156"><vh>@file-nosent rpdb.bat</vh></v>
<v t="ekr.20050421093045.157"><vh>@url file:///c|/bIn/bat/rpdb.bat</vh></v>
</v>
<v t="ekr.20050421093045.158"><vh>au3</vh>
<v t="ekr.20050421093045.159"><vh>@nosent leoopen1.au3</vh></v>
<v t="ekr.20050421093045.160"><vh>@url c:/c/chall/osix_Geek/leoopen1.au3</vh></v>
</v>
</v>
</v>
<v t="ekr.20050523073009"><vh> chapters</vh>
<v t="ekr.20050427102121"><vh>Calls to zipfile module in chapters.py</vh>
<v t="mork.20040926105355.29"><vh>newOpen</vh></v>
<v t="mork.20040926105355.9"><vh>openChaptersFile</vh></v>
<v t="mork.20040929090525.1"><vh>zipChapters</vh></v>
</v>
<v t="mork.20040926105355.1"><vh>chapters.py</vh>
<v t="ekr.20041109123143"><vh>&lt;&lt;docstring&gt;&gt;</vh></v>
<v t="ekr.20041103051117"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20041103050629"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="mork.20040926105355.2"><vh>&lt;&lt; globals &gt;&gt;</vh></v>
<v t="ekr.20060109063941"><vh>init</vh>
<v t="ekr.20041103054545"><vh>&lt;&lt; override various methods &gt;&gt;</vh></v>
</v>
<v t="mork.20040927092626"><vh>class Chapter</vh>
<v t="ekr.20041103051228"><vh>__init__</vh></v>
<v t="ekr.20041103051228.1"><vh>_saveInfo</vh></v>
<v t="ekr.20041103051228.2"><vh>setVariables</vh></v>
<v t="ekr.20041103051228.3"><vh>makeCurrent</vh></v>
</v>
<v t="mork.20040930090735"><vh>Creating widgets...</vh>
<v t="mork.20040926105355.21"><vh>newCreateControl</vh></v>
<v t="mork.20040929110556"><vh>createPanedWidget</vh></v>
<v t="mork.20040926105355.22"><vh>newEditorPane</vh></v>
<v t="mork.20040926105355.23"><vh>newCreateCanvas</vh></v>
<v t="mork.20040929120442"><vh>createBalloon</vh></v>
<v t="mork.20040929102107"><vh>createNoteBook</vh></v>
<v t="mork.20040929093051"><vh>getNameMaker</vh></v>
<v t="mork.20040926105355.24"><vh>newTreeinit</vh></v>
<v t="mork.20040926105355.25"><vh>constructTree</vh></v>
<v t="mork.20040926105355.26"><vh>addPage</vh></v>
<v t="mork.20040926105355.35"><vh>newEditor</vh></v>
</v>
<v t="mork.20040930091319"><vh>tab menu stuff</vh>
<v t="mork.20040926105355.41"><vh>makeTabMenu</vh></v>
<v t="mork.20040930091319.1"><vh>function factories</vh>
<v t="mork.20040928224349"><vh>getAddChapter</vh></v>
<v t="mork.20040928223221"><vh>getRemove</vh></v>
<v t="mork.20040928223738"><vh>getRename</vh></v>
<v t="mork.20040928224049"><vh>getMakeTrash</vh></v>
<v t="mork.20040928224621"><vh>getSetupMenu</vh></v>
</v>
</v>
<v t="mork.20040930092346"><vh>Multi-Editor stuff</vh>
<v t="mork.20040929104527"><vh>selectNodeForEditor</vh></v>
<v t="mork.20040929105638"><vh>activateEditor</vh></v>
<v t="mork.20040926105355.36"><vh>removeEditor</vh></v>
<v t="mork.20040926105355.44"><vh>addHeading</vh></v>
</v>
<v t="mork.20040930090547"><vh>Indexing</vh>
<v t="mork.20040926105355.3"><vh>viewIndex</vh></v>
<v t="mork.20040929121409"><vh>buildIndex</vh></v>
<v t="mork.20040926105355.4"><vh>regexViewIndex</vh></v>
</v>
<v t="mork.20040930094729"><vh>Chapter-Notebook ops</vh>
<v t="mork.20040926105355.5"><vh>renumber</vh></v>
<v t="mork.20040926105355.6"><vh>getGoodPage</vh></v>
<v t="mork.20040926105355.7"><vh>checkChapterValidity</vh></v>
<v t="mork.20040926105355.20"><vh>getSV</vh></v>
<v t="mork.20040926105355.27"><vh>setTree</vh></v>
<v t="mork.20040929084846"><vh>lowerPage</vh></v>
<v t="mork.20040926105355.40"><vh>walkChapters</vh></v>
</v>
<v t="mork.20040930091035"><vh>opening and closing (to be moved into Leo's core?)</vh>
<v t="mork.20040930091035.1"><vh>opening</vh>
<v t="mork.20040926105355.28"><vh>newGetLeoFile</vh></v>
<v t="mork.20040926105355.29"><vh>newOpen</vh></v>
<v t="mork.20040926105355.9"><vh>openChaptersFile</vh></v>
<v t="mork.20040926105355.8" a="M"><vh>insertChapters</vh></v>
</v>
<v t="mork.20040930091035.2"><vh>closing</vh>
<v t="mork.20040926105355.30"><vh>newWrite_LEO_file</vh></v>
<v t="mork.20040929092231"><vh>getMakeStringIO</vh></v>
<v t="mork.20040929090525"><vh>writeChapters</vh></v>
<v t="mork.20040929090525.1"><vh>zipChapters</vh></v>
</v>
</v>
<v t="mork.20040930091624"><vh>decorated Leo functions</vh>
<v t="mork.20040926105355.34"><vh>new_os_path_dirname</vh></v>
<v t="mork.20040926105355.45"><vh>newendEditLabel</vh></v>
<v t="mork.20040926105355.52"><vh>newselect</vh></v>
<v t="mork.20040926105355.49"><vh>newTrashDelete</vh></v>
</v>
<v t="mork.20040930091759"><vh>operation( node ) to Chapter</vh>
<v t="mork.20040926105355.31"><vh>cloneToChapter</vh></v>
<v t="mork.20040926105355.32"><vh>moveToChapter</vh></v>
<v t="mork.20040926105355.33"><vh>copyToChapter</vh></v>
<v t="mork.20040926105355.39"><vh>makeNodeIntoChapter</vh></v>
</v>
<v t="mork.20040930092027"><vh>conversions</vh>
<v t="mork.20040926105355.37"><vh>conversionToSimple</vh></v>
<v t="mork.20040926105355.38"><vh>conversionToChapters</vh></v>
</v>
<v t="mork.20040930092027.1"><vh>import/export</vh>
<v t="mork.20040926105355.47"><vh>importLeoFile</vh></v>
<v t="mork.20040926105355.48"><vh>exportLeoFile</vh></v>
</v>
<v t="mork.20040930092207"><vh>functions without classification</vh>
<v t="mork.20040926105355.46"><vh>swapChapters</vh></v>
<v t="mork.20040926105355.50"><vh>emptyTrash</vh></v>
<v t="mork.20040926105355.51"><vh>regexClone</vh></v>
</v>
<v t="mork.20040930091624.1"><vh>PDF</vh>
<v t="mork.20040926105355.42"><vh>doPDFConversion</vh>
<v t="ekr.20041109120739"><vh>&lt;&lt; define otherPages callback &gt;&gt;</vh></v>
</v>
<v t="mork.20040926105355.43"><vh>_changeTreeToPDF</vh></v>
</v>
</v>
</v>
<v t="ekr.20041107165824"><vh>temacs &amp; usetemacs</vh>
<v t="mork.20041013092542.1"><vh>usetemacs.py</vh>
<v t="ekr.20050513171201"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20041106100326"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="mork.20041013092542.2"><vh>&lt;&lt; globals &gt;&gt;</vh></v>
<v t="mork.20041101132349"><vh>&lt;&lt;version history&gt;&gt;</vh></v>
<v t="ekr.20041106100326.1"><vh>&lt;&lt; documentation &gt;&gt;</vh>
<v t="mork.20041104100514"><vh>future directions</vh></v>
<v t="mork.20041101204659"><vh>adding Emacs extensions via usetemacs</vh></v>
<v t="mork.20041104100856"><vh>where to put your temacs-Emacs Python extensions</vh></v>
<v t="mork.20041102102111"><vh>change Emacs keystrokes via configuration</vh></v>
<v t="mork.20041102094131"><vh>usetemacs design</vh></v>
<v t="mork.20041102094341"><vh>a note on loading temacs</vh></v>
</v>
<v t="ekr.20050311155753"><vh>init</vh>
<v t="ekr.20041106100326.2"><vh>&lt;&lt; override createBindings and onBodyKey &gt;&gt;</vh></v>
</v>
<v t="mork.20041013092542.3"><vh>utTailEnd</vh></v>
<v t="mork.20041013092542.6"><vh>seeHelp</vh></v>
<v t="mork.20041013092542.5"><vh>addMenu</vh></v>
<v t="mork.20041101124927"><vh>modifyOnBodyKey</vh></v>
<v t="mork.20041101205414"><vh>watchDelete</vh></v>
<v t="mork.20041102094928"><vh>changeKeyStrokes</vh></v>
<v t="mork.20041101210722"><vh>addTemacsAbbreviations</vh></v>
<v t="mork.20041101191351"><vh>loadConfig</vh></v>
<v t="mork.20041101202945"><vh>addTemacsExtensions</vh></v>
<v t="mork.20041103160433"><vh>setBufferGetters and Setters</vh></v>
<v t="mork.20041213112640"><vh>gotoPosition</vh></v>
<v t="mork.20041104145603"><vh>initialise</vh></v>
<v t="mork.20041204141826"><vh>addLeoCommands</vh></v>
<v t="mork.20041102091309"><vh>&lt;&lt;exampleTemacsExtension.py&gt;&gt;</vh></v>
<v t="mork.20041102092057"><vh>&lt;&lt;usetemacs.ini example&gt;&gt;</vh></v>
</v>
<v t="mork.20041030164547"><vh>temacs.py</vh>
<v t="mork.20041101100635"><vh>&lt;&lt;version history&gt;&gt;</vh></v>
<v t="ekr.20041106101311"><vh>&lt;&lt; documentation &gt;&gt;</vh>
<v t="mork.20041101203748"><vh>How to write an Emacs extension</vh></v>
<v t="mork.20041102081834"><vh>Coding convenions</vh></v>
<v t="mork.20041102082911"><vh>Known bugs</vh></v>
<v t="mork.20041102103822"><vh>Future directions</vh></v>
<v t="mork.20041104095745"><vh>A Note on Alt-X</vh></v>
<v t="mork.20041122151944"><vh>A Note on the volume of methods</vh></v>
<v t="mork.20041126091717"><vh>plans for .7</vh></v>
<v t="mork.20041123150836"><vh>the master command is the center of an Emacs instance</vh></v>
<v t="mork.20041122152311"><vh>adding stateful commands to temacs</vh></v>
<v t="mork.20041123150144"><vh>how to mix python regular expressions and the Text widget</vh></v>
</v>
<v t="mork.20041030164547.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="mork.20041104102456"><vh>Emacs helper classes</vh>
<v t="mork.20041031131847"><vh>class ControlXHandler</vh>
<v t="mork.20041031162953"><vh>__init__</vh></v>
<v t="mork.20041031132342"><vh>__call__</vh></v>
<v t="mork.20041031133146"><vh>processKey</vh></v>
<v t="mork.20041031134709"><vh>processRectangle</vh></v>
<v t="mork.20041031135748"><vh>processAbbreviation</vh></v>
</v>
<v t="mork.20041031145157"><vh>class MC_StateManager</vh>
<v t="mork.20041031162857"><vh>__init__</vh>
<v t="mork.20041031150125"><vh>&lt;&lt;statecommands&gt;&gt;</vh></v>
</v>
<v t="mork.20041031162857.1"><vh>setState</vh></v>
<v t="mork.20041031162857.2"><vh>getState</vh></v>
<v t="mork.20041031162857.3"><vh>hasState</vh></v>
<v t="mork.20041124094511"><vh>whichState</vh></v>
<v t="mork.20041031162857.4"><vh>__call__</vh></v>
<v t="mork.20041031162857.5"><vh>clear</vh></v>
</v>
<v t="mork.20041101083527"><vh>class MC_KeyStrokeManager  (hard-coded keystrokes)</vh>
<v t="mork.20041101083527.1"><vh>__init__</vh>
<v t="mork.20041101083527.2"><vh>&lt;&lt;keystrokes&gt;&gt; (hard-coded keystrokes)</vh></v>
</v>
<v t="mork.20041101084148"><vh>hasKeyStroke</vh></v>
<v t="mork.20041101084148.1"><vh>__call__</vh></v>
</v>
<v t="mork.20041102131352"><vh>class Tracker</vh>
<v t="mork.20041102131352.1"><vh>init</vh></v>
<v t="mork.20041102131352.2"><vh>setTabList</vh></v>
<v t="mork.20041102131352.3"><vh>_next</vh></v>
<v t="mork.20041102132710"><vh>next</vh></v>
<v t="mork.20041102160313"><vh>clear</vh></v>
</v>
</v>
<v t="mork.20041030165020"><vh>class Emacs</vh>
<v t="mork.20041030165020.1"><vh>Emacs.__init__</vh></v>
<v t="mork.20041030164547.41"><vh>getHelpText</vh></v>
<v t="mork.20041030164547.43"><vh>masterCommand</vh>
<v t="ekr.20050527112828"><vh>&lt;&lt; old insert code &gt;&gt;</vh></v>
<v t="ekr.20050527084754"><vh>&lt;&lt; old code &gt;&gt;</vh></v>
<v t="ekr.20050527084754.1"><vh>&lt;&lt; old code 2 &gt;&gt;</vh></v>
</v>
<v t="mork.20041102082023"><vh>keyboardQuit</vh></v>
<v t="mork.20041031182258"><vh>add command dictionary methods</vh>
<v t="mork.20041030183331"><vh>addCallBackDict (creates cbDict)</vh></v>
<v t="mork.20041030183633"><vh>addXCommands</vh></v>
<v t="mork.20041030190903"><vh>addAltXCommands</vh></v>
<v t="mork.20041030190729"><vh>addRegisterItems</vh></v>
</v>
<v t="mork.20041031183614"><vh>general utility methods</vh>
<v t="mork.20041031195549"><vh>buffer altering methods</vh>
<v t="mork.20041030164547.31"><vh>moveTo</vh></v>
<v t="mork.20041030164547.33"><vh>moveword</vh></v>
<v t="mork.20041030164547.39"><vh>capitalize</vh></v>
<v t="mork.20041030164547.40"><vh>swapWords</vh></v>
<v t="mork.20041030164547.103"><vh>insertParentheses</vh></v>
<v t="mork.20041123095436"><vh>replace-string and replace-regex</vh>
<v t="mork.20041030164547.115"><vh>replaceString</vh></v>
<v t="mork.20041123095123"><vh>activateReplaceRegex</vh></v>
</v>
<v t="mork.20041030164547.116"><vh>swapCharacters</vh></v>
<v t="mork.20041123095507"><vh>insert new line methods</vh>
<v t="mork.20041030164547.117"><vh>insertNewLine</vh></v>
<v t="mork.20041030164547.131"><vh>insertNewLineIndent</vh></v>
<v t="mork.20041103135515"><vh>insertNewLineAndTab</vh></v>
</v>
<v t="mork.20041030164547.148"><vh>transposeLines</vh></v>
<v t="mork.20041030164547.130"><vh>changePreviousWord</vh></v>
<v t="mork.20041030164547.150"><vh>removeBlankLines</vh></v>
<v t="mork.20041030164547.101"><vh>screenscroll</vh></v>
<v t="mork.20041030164547.22"><vh>exchangePointMark</vh></v>
<v t="mork.20041030164547.96"><vh>backToIndentation</vh></v>
<v t="mork.20041124130434"><vh>indent-relative</vh></v>
<v t="mork.20041030164547.129"><vh>negativeArgument</vh></v>
<v t="mork.20041030164547.114"><vh>movePastClose</vh></v>
<v t="mork.20041030164547.119"><vh>prevNexSentence</vh></v>
<v t="mork.20041031202438"><vh>selectAll</vh></v>
<v t="mork.20041120195951"><vh>suspend</vh></v>
</v>
<v t="mork.20041031195908"><vh>informational methods</vh>
<v t="mork.20041030164547.118"><vh>lineNumber</vh></v>
<v t="mork.20041102161859"><vh>viewLossage</vh></v>
<v t="mork.20041121195816"><vh>whatLine</vh></v>
</v>
<v t="mork.20041031195908.1"><vh>pure utility methods</vh>
<v t="mork.20041102151939"><vh>setEvent</vh></v>
<v t="mork.20041030164547.127"><vh>getWSString</vh></v>
<v t="mork.20041030164547.135"><vh>findPre</vh></v>
<v t="mork.20041030164547.100"><vh>measure</vh></v>
<v t="mork.20041030164547.95"><vh>manufactureKeyPress</vh></v>
<v t="mork.20041030164547.83"><vh>changecbDict</vh></v>
<v t="mork.20041030164547.92"><vh>removeRKeys</vh></v>
<v t="mork.20041030164547.142"><vh>_findMatch2</vh></v>
<v t="mork.20041102133805"><vh>_findMatch</vh></v>
</v>
</v>
<v t="mork.20041120223251"><vh>shutdown methods</vh>
<v t="mork.20041120222336"><vh>shutdown</vh></v>
<v t="mork.20041120223251.1"><vh>setShutdownHook</vh></v>
</v>
<v t="mork.20041031182215"><vh>Label( minibuffer ) and svar methods</vh>
<v t="mork.20041102183901"><vh>label( minibuffer ) methods</vh>
<v t="mork.20041030164547.2"><vh>setLabelGrey</vh></v>
<v t="mork.20041030164547.3"><vh>setLabelBlue</vh></v>
<v t="mork.20041030164547.86"><vh>resetMiniBuffer</vh></v>
</v>
<v t="mork.20041031182943"><vh>svar methods</vh>
<v t="mork.20041030164547.112"><vh>getSvarLabel</vh></v>
<v t="mork.20041030164547.113"><vh>setSvar</vh></v>
</v>
</v>
<v t="mork.20041031194746"><vh>configurable methods</vh>
<v t="mork.20041031182643"><vh>tailEnd methods</vh>
<v t="mork.20041030164547.4"><vh>_tailEnd</vh></v>
<v t="mork.20041030164547.5"><vh>setTailEnd</vh></v>
</v>
<v t="mork.20041031182643.1"><vh>undoer methods</vh>
<v t="mork.20041030164547.6"><vh>setUndoer</vh></v>
<v t="mork.20041030164547.7"><vh>doUndo</vh></v>
</v>
<v t="mork.20041030164547.30"><vh>setBufferStrokes</vh></v>
<v t="mork.20041101190309"><vh>extendAltX</vh></v>
<v t="mork.20041102094716"><vh>reconfigureKeyStroke</vh></v>
<v t="mork.20041103155347"><vh>buffer recognition and alterers</vh>
<v t="mork.20041104094826"><vh>configure buffer methods</vh>
<v t="mork.20041103155347.1"><vh>setBufferGetter</vh></v>
<v t="mork.20041103155347.2"><vh>setBufferSetter</vh></v>
<v t="mork.20041103155347.3"><vh>getBufferDict</vh></v>
<v t="mork.20041103162147"><vh>setBufferData</vh></v>
<v t="mork.20041103191311"><vh>setBufferGoto</vh></v>
<v t="mork.20041104090224"><vh>setBufferDelete</vh></v>
<v t="mork.20041104092349"><vh>setBufferRename</vh></v>
</v>
<v t="mork.20041104094826.1"><vh>buffer operations</vh>
<v t="mork.20041103155347.4"><vh>appendToBuffer</vh></v>
<v t="mork.20041103155347.5"><vh>prependToBuffer</vh></v>
<v t="mork.20041103155347.6"><vh>insertToBuffer</vh></v>
<v t="mork.20041103190332"><vh>listBuffers</vh></v>
<v t="mork.20041103155347.7"><vh>copyToBuffer</vh></v>
<v t="mork.20041103191311.1"><vh>switchToBuffer</vh></v>
<v t="mork.20041104090224.1"><vh>killBuffer</vh></v>
<v t="mork.20041104092058"><vh>renameBuffer</vh></v>
<v t="mork.20041103161202"><vh>chooseBuffer</vh></v>
<v t="mork.20041103161202.1"><vh>setInBufferMode</vh></v>
</v>
</v>
</v>
<v t="mork.20041031155753"><vh>macro methods</vh>
<v t="mork.20041030164547.8"><vh>startKBDMacro</vh></v>
<v t="mork.20041030164547.9"><vh>recordKBDMacro</vh></v>
<v t="mork.20041030164547.10"><vh>stopKBDMacro</vh></v>
<v t="mork.20041030164547.11"><vh>_executeMacro</vh></v>
<v t="mork.20041030164547.12"><vh>executeLastMacro</vh></v>
<v t="mork.20041030164547.13"><vh>nameLastMacro</vh></v>
<v t="mork.20041030164547.14"><vh>_addToDoAltX</vh></v>
<v t="mork.20041030164547.15"><vh>loadMacros</vh></v>
<v t="mork.20041030164547.16"><vh>_loadMacros</vh></v>
<v t="mork.20041030164547.17"><vh>getMacroName</vh></v>
<v t="mork.20041030164547.18"><vh>saveMacros</vh></v>
<v t="mork.20041030164547.19"><vh>_saveMacros</vh></v>
</v>
<v t="mork.20041031194703"><vh>comment column methods</vh>
<v t="mork.20041030164547.20"><vh>setCommentColumn</vh></v>
<v t="mork.20041030164547.21"><vh>indentToCommentColumn</vh></v>
</v>
<v t="mork.20041031182709"><vh>how many methods</vh>
<v t="mork.20041030164547.23"><vh>howMany</vh></v>
<v t="mork.20041030164547.24"><vh>startHowMany</vh></v>
</v>
<v t="mork.20041031155913"><vh>paragraph methods</vh>
<v t="mork.20041030164547.25"><vh>selectParagraph</vh></v>
<v t="mork.20041030164547.26"><vh>_selectParagraph</vh></v>
<v t="mork.20041030164547.27"><vh>killParagraph</vh></v>
<v t="mork.20041030164547.28"><vh>backwardKillParagraph</vh></v>
</v>
<v t="mork.20041031181929"><vh>kill methods</vh>
<v t="mork.20041030164547.34"><vh>kill</vh></v>
<v t="mork.20041030164547.36"><vh>walkKB</vh></v>
<v t="mork.20041030164547.35"><vh>deletelastWord</vh></v>
<v t="mork.20041030164547.37"><vh>killsentence</vh></v>
<v t="mork.20041030164547.91"><vh>killRegion</vh></v>
<v t="mork.20041030164547.42"><vh>addToKillBuffer</vh></v>
<v t="mork.20041030164547.29"><vh>iterateKillBuffer</vh></v>
<v t="mork.20041103120919"><vh>getClipboard</vh></v>
</v>
<v t="mork.20041031155642"><vh>register methods</vh>
<v t="mork.20041030164547.44"><vh>copyToRegister</vh></v>
<v t="mork.20041030164547.45"><vh>copyRectangleToRegister</vh></v>
<v t="mork.20041030164547.46"><vh>prependToRegister</vh></v>
<v t="mork.20041030164547.47"><vh>appendToRegister</vh></v>
<v t="mork.20041030164547.49"><vh>_ToReg</vh></v>
<v t="mork.20041030164547.48"><vh>_chckSel</vh></v>
<v t="mork.20041030164547.50"><vh>_checkIfRectangle</vh></v>
<v t="mork.20041030164547.51"><vh>insertFromRegister</vh></v>
<v t="mork.20041030164547.52"><vh>incrementRegister</vh></v>
<v t="mork.20041030164547.53"><vh>numberToRegister</vh></v>
<v t="mork.20041030164547.54"><vh>pointToRegister</vh></v>
<v t="mork.20041030164547.55"><vh>jumpToRegister</vh></v>
<v t="mork.20041030164547.56"><vh>invalidRegister</vh></v>
<v t="mork.20041030164547.57"><vh>setNextRegister</vh></v>
<v t="mork.20041030164547.58"><vh>executeRegister</vh></v>
<v t="mork.20041030164547.59"><vh>deactivateRegister</vh></v>
<v t="mork.20041102151545"><vh>viewRegister</vh></v>
</v>
<v t="mork.20041031181701"><vh>abbreviation methods</vh>
<v t="mork.20041030164547.60"><vh>abbreviationDispatch</vh></v>
<v t="mork.20041030164547.61"><vh>abbrevCommand1</vh></v>
<v t="mork.20041030164547.62"><vh>expandAbbrev</vh></v>
<v t="mork.20041030164547.63"><vh>regionalExpandAbbrev</vh>
<v t="ekr.20050527111832"><vh>&lt;&lt; define a new generator searchXR &gt;&gt;</vh></v>
</v>
<v t="mork.20041030164547.64"><vh>_setRAvars</vh></v>
<v t="mork.20041030164547.65"><vh>killAllAbbrevs</vh></v>
<v t="mork.20041030164547.66"><vh>toggleAbbrevMode</vh></v>
<v t="mork.20041030164547.67"><vh>listAbbrevs</vh></v>
<v t="mork.20041030164547.68"><vh>readAbbreviations</vh></v>
<v t="mork.20041030164547.69"><vh>_readAbbrevs</vh></v>
<v t="mork.20041030164547.70"><vh>writeAbbreviations</vh></v>
<v t="mork.20041030164547.71"><vh>_writeAbbrevs</vh></v>
</v>
<v t="mork.20041031182137"><vh>paragraph methods</vh>
<v t="mork.20041030164547.72"><vh>movingParagraphs</vh></v>
<v t="mork.20041030164547.74"><vh>fillParagraph</vh></v>
<v t="mork.20041030164547.76"><vh>fillRegionAsParagraph</vh></v>
</v>
<v t="mork.20041031182916"><vh>fill prefix methods</vh>
<v t="mork.20041030164547.73"><vh>setFillPrefix</vh></v>
<v t="mork.20041030164547.75"><vh>_addPrefix</vh></v>
</v>
<v t="mork.20041103085329"><vh>fill column and centering</vh>
<v t="mork.20041103085329.1"><vh>centerLine</vh></v>
<v t="mork.20041103095628"><vh>centerRegion</vh></v>
<v t="mork.20041103085329.2"><vh>setFillColumn</vh></v>
</v>
<v t="mork.20041031183136"><vh>region methods</vh>
<v t="mork.20041030164547.77"><vh>fillRegion</vh></v>
<v t="mork.20041030164547.87"><vh>setRegion</vh></v>
<v t="mork.20041030164547.93"><vh>indentRegion</vh></v>
<v t="mork.20041030164547.94"><vh>tabIndentRegion</vh></v>
<v t="mork.20041030164547.102"><vh>countRegion</vh></v>
<v t="mork.20041030164547.138"><vh>reverseRegion</vh></v>
<v t="mork.20041030164547.149"><vh>upperLowerRegion</vh></v>
</v>
<v t="mork.20041122190403"><vh>searching</vh>
<v t="mork.20041031182837"><vh>incremental search methods</vh>
<v t="mork.20041030164547.79"><vh>startIncremental</vh></v>
<v t="mork.20041030164547.38"><vh>search</vh></v>
<v t="mork.20041030164547.80"><vh>iSearch</vh></v>
<v t="mork.20041030164547.153"><vh>scolorizer</vh></v>
<v t="mork.20041121125455"><vh>useRegex</vh></v>
</v>
<v t="mork.20041122154604"><vh>non-incremental search methods</vh>
<v t="mork.20041122154604.1"><vh>nonincrSearch</vh></v>
<v t="mork.20041122155708"><vh>startNonIncrSearch</vh></v>
</v>
<v t="mork.20041122171601"><vh>word search methods</vh>
<v t="mork.20041122171601.1"><vh>startWordSearch</vh></v>
<v t="mork.20041122171601.2"><vh>wordSearch</vh></v>
</v>
<v t="mork.20041121103034"><vh>re-search methods</vh>
<v t="mork.20041121103034.1"><vh>reStart</vh></v>
<v t="mork.20041121103034.2"><vh>re_search</vh></v>
</v>
</v>
<v t="mork.20041121140620"><vh>diff methods</vh>
<v t="mork.20041121140620.1"><vh>diff</vh></v>
</v>
<v t="mork.20041031182332"><vh>Zap methods</vh>
<v t="mork.20041030164547.81"><vh>startZap</vh></v>
<v t="mork.20041030164547.82"><vh>zapTo</vh></v>
</v>
<v t="mork.20041031181740"><vh>ControlX methods</vh>
<v t="mork.20041030164547.84"><vh>startControlX</vh></v>
<v t="mork.20041030164547.85"><vh>stopControlX</vh></v>
<v t="mork.20041030164547.78"><vh>doControlX</vh></v>
</v>
<v t="mork.20041031183614.1"><vh>range methods</vh>
<v t="mork.20041030164547.88"><vh>inRange</vh></v>
<v t="mork.20041030164547.89"><vh>contRanges</vh></v>
<v t="mork.20041030164547.90"><vh>testinrange</vh></v>
</v>
<v t="mork.20041031182402"><vh>delete methods</vh>
<v t="mork.20041030164547.97"><vh>deleteIndentation</vh></v>
<v t="mork.20041030164547.98"><vh>deleteNextChar</vh></v>
<v t="mork.20041030164547.99"><vh>deleteSpaces</vh></v>
</v>
<v t="mork.20041031181701.1"><vh>query replace methods</vh>
<v t="mork.20041030164547.107"><vh>qreplace</vh></v>
<v t="mork.20041030164547.108"><vh>_qreplace</vh></v>
<v t="mork.20041030164547.109"><vh>getQuery</vh></v>
<v t="mork.20041030164547.110"><vh>getReplace</vh></v>
<v t="mork.20041030164547.111"><vh>masterQR</vh></v>
<v t="mork.20041123113640"><vh>startRegexReplace</vh></v>
<v t="mork.20041031194858"><vh>query search methods</vh>
<v t="mork.20041030164547.104"><vh>listenQR</vh></v>
<v t="mork.20041030164547.105"><vh>qsearch</vh></v>
<v t="mork.20041030164547.106"><vh>quitQSearch</vh></v>
</v>
</v>
<v t="mork.20041031155313"><vh>Rectangles methods</vh>
<v t="mork.20041031202908"><vh>activateRectangleMethods</vh></v>
<v t="mork.20041030164547.120"><vh>openRectangle</vh></v>
<v t="mork.20041030164547.121"><vh>clearRectangle</vh></v>
<v t="mork.20041030164547.122"><vh>deleteRectangle</vh></v>
<v t="mork.20041030164547.123"><vh>stringRectangle</vh></v>
<v t="mork.20041030164547.124"><vh>killRectangle</vh></v>
<v t="mork.20041030164547.125"><vh>closeRectangle</vh></v>
<v t="mork.20041030164547.126"><vh>yankRectangle</vh></v>
<v t="mork.20041030164547.128"><vh>getRectanglePoints</vh></v>
</v>
<v t="mork.20041031181701.2"><vh>dynamic abbreviations methods</vh>
<v t="mork.20041030164547.132"><vh>dynamicExpansion</vh></v>
<v t="mork.20041030164547.133"><vh>dynamicExpansion2</vh></v>
<v t="mork.20041030164547.134"><vh>getDynamicList</vh></v>
</v>
<v t="mork.20041031183018"><vh>sort methods</vh>
<v t="mork.20041030164547.136"><vh>sortLines</vh></v>
<v t="mork.20041030164547.137"><vh>sortColumns</vh></v>
<v t="mork.20041030164547.139"><vh>sortFields</vh></v>
</v>
<v t="mork.20041031181929.1"><vh>Alt_X methods</vh>
<v t="mork.20041030164547.140"><vh>alt_X</vh></v>
<v t="mork.20041030164547.141"><vh>doAlt_X</vh></v>
<v t="mork.20041123093234"><vh>execute last altx methods</vh>
<v t="mork.20041122223754"><vh>executeLastAltX</vh></v>
<v t="mork.20041122225107"><vh>repeatComplexCommand</vh></v>
</v>
</v>
<v t="mork.20041031155455"><vh>universal methods</vh>
<v t="mork.20041030164547.143"><vh>universalDispatch</vh></v>
<v t="mork.20041030164547.144"><vh>universalCommand1</vh></v>
<v t="mork.20041030164547.145"><vh>universalCommand2</vh></v>
<v t="mork.20041030164547.146"><vh>universalCommand3</vh></v>
<v t="mork.20041030164547.147"><vh>numberCommand</vh></v>
</v>
<v t="mork.20041121201041"><vh>line methods</vh>
<v t="mork.20041121201041.1"><vh>alterLines</vh></v>
<v t="mork.20041121210221"><vh>processLines</vh></v>
<v t="mork.20041121201112"><vh>startLines</vh></v>
</v>
<v t="mork.20041031160002"><vh>goto methods</vh>
<v t="mork.20041030164547.154"><vh>startGoto</vh></v>
<v t="mork.20041030164547.155"><vh>Goto</vh></v>
</v>
<v t="mork.20041122110739"><vh>directory methods</vh>
<v t="mork.20041122110739.1"><vh>makeDirectory</vh></v>
<v t="mork.20041122111431"><vh>removeDirectory</vh></v>
</v>
<v t="mork.20041031182449"><vh>file methods</vh>
<v t="mork.20041122112210"><vh>deleteFile</vh></v>
<v t="mork.20041030164547.151"><vh>insertFile</vh></v>
<v t="mork.20041030164547.152"><vh>saveFile</vh></v>
<v t="mork.20041121140620.2"><vh>getReadableFile</vh></v>
</v>
<v t="mork.20041123192555"><vh>Esc methods for Python evaluation</vh>
<v t="mork.20041123192555.1"><vh>watchEscape</vh></v>
<v t="mork.20041124095452"><vh>escEvaluate</vh></v>
<v t="mork.20041124102729"><vh>startEvaluate</vh></v>
</v>
<v t="mork.20041124123825"><vh>tabify/untabify</vh>
<v t="mork.20041124123825.1"><vh>tabify</vh></v>
</v>
<v t="mork.20041208120232"><vh>shell and subprocess</vh>
<v t="mork.20041208120232.1"><vh>def startSubprocess</vh></v>
<v t="mork.20041208120232.2"><vh>subprocess</vh></v>
<v t="mork.20041208121502"><vh>executeSubprocess</vh></v>
</v>
</v>
<v t="ekr.20041106100834"><vh>&lt;&lt; run standalone tests &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="edream.110203113231.618"><vh>Plugins</vh>
<v t="EKR.20040517090508"><vh>  Enable plugins by changing pluginsManager.txt or using plugin_manager plugin</vh>
<v t="edream.120603093808"><vh>@thin pluginsManager.txt</vh></v>
</v>
<v t="ekr.20050303051035"><vh> Templates: these show recommended ways of defining plugins.</vh>
<v t="ekr.20041114102139"><vh>Notes</vh>
<v t="ekr.20041114103913"><vh>About comments in the style guide</vh></v>
<v t="ekr.20041114102139.1"><vh>About the root node</vh></v>
<v t="ekr.20041114103913.1"><vh>About defining functions in separate nodes</vh></v>
<v t="ekr.20041114102139.2"><vh>About the &lt;&lt; imports &gt;&gt; section</vh></v>
<v t="ekr.20050306072156"><vh>About exceptions</vh></v>
</v>
<v t="ekr.20050306071629"><vh>Template for plugin that overrides commander methods</vh>
<v t="ekr.20050306071629.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050306071629.2"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20050306071629.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050306071629.4"><vh>init</vh></v>
<v t="ekr.20050306071540"><vh>onStart2</vh></v>
</v>
<v t="ekr.20050303051035.2"><vh>Template for Tk plugin with per-commander controller class</vh>
<v t="ekr.20050303051035.3"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050303051035.4"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20050303051035.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050303051101"><vh>init</vh></v>
<v t="ekr.20050303051150"><vh>onCreate</vh></v>
<v t="ekr.20050303051222"><vh>class pluginController</vh>
<v t="ekr.20050303051222.1"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="edream.110203113231.667"><vh>Commands &amp; directives</vh>
<v t="edream.110203113231.668"><vh> Importing Cisco configuration files</vh>
<v t="edream.110203113231.669"><vh>@thin import_cisco_config.py</vh></v>
<v t="edream.110203113231.677"><vh> Example of an imported config</vh>
<v t="edream.110203113231.678"><vh>plain configuration</vh></v>
<v t="edream.110203113231.679"><vh>cisco config: C:/Davide/Leo/CVS Version/example_conf.txt</vh>
<v t="edream.110203113231.680"><vh>&lt;&lt;access-list&gt;&gt;</vh></v>
<v t="edream.110203113231.681"><vh>&lt;&lt;boot&gt;&gt;</vh></v>
<v t="edream.110203113231.682"><vh>&lt;&lt;controller&gt;&gt;</vh>
<v t="edream.110203113231.683"><vh>controller E1 5/0/0</vh></v>
<v t="edream.110203113231.684"><vh>controller E1 5/0/1</vh></v>
<v t="edream.110203113231.685"><vh>controller SONET 1/0/0</vh></v>
</v>
<v t="edream.110203113231.686"><vh>&lt;&lt;interface&gt;&gt;</vh>
<v t="edream.110203113231.687"><vh>interface Async1</vh></v>
<v t="edream.110203113231.688"><vh>interface Dialer0</vh></v>
<v t="edream.110203113231.689"><vh>interface FastEthernet0/0/0</vh></v>
<v t="edream.110203113231.690"><vh>interface FastEthernet0/0/1</vh></v>
<v t="edream.110203113231.691"><vh>interface FastEthernet0/0/1.1</vh></v>
<v t="edream.110203113231.692"><vh>interface FastEthernet0/0/1.2</vh></v>
<v t="edream.110203113231.693"><vh>interface FastEthernet0/0/1.3</vh></v>
<v t="edream.110203113231.694"><vh>interface FastEthernet0/0/1.5</vh></v>
<v t="edream.110203113231.695"><vh>interface FastEthernet0/0/1.50</vh></v>
<v t="edream.110203113231.696"><vh>interface Loopback0</vh></v>
<v t="edream.110203113231.697"><vh>interface POS4/1/0</vh></v>
<v t="edream.110203113231.698"><vh>interface Serial5/0/0:1</vh></v>
<v t="edream.110203113231.699"><vh>interface Serial5/0/0:2</vh></v>
<v t="edream.110203113231.700"><vh>interface Serial5/0/1:0</vh></v>
<v t="edream.110203113231.701"><vh>interface Serial5/1/0</vh></v>
<v t="edream.110203113231.702"><vh>interface Serial5/1/1</vh></v>
</v>
<v t="edream.110203113231.703"><vh>&lt;&lt;ip community-list&gt;&gt;</vh></v>
<v t="edream.110203113231.704"><vh>&lt;&lt;ip route&gt;&gt;</vh></v>
<v t="edream.110203113231.705"><vh>&lt;&lt;line&gt;&gt;</vh>
<v t="edream.110203113231.706"><vh>line aux 0</vh></v>
<v t="edream.110203113231.707"><vh>line vty 0 4</vh></v>
</v>
<v t="edream.110203113231.708"><vh>&lt;&lt;logging&gt;&gt;</vh></v>
<v t="edream.110203113231.709"><vh>&lt;&lt;ntp&gt;&gt;</vh></v>
<v t="edream.110203113231.710"><vh>&lt;&lt;route-map&gt;&gt;</vh>
<v t="edream.110203113231.711"><vh>route-map only permit 2</vh></v>
<v t="edream.110203113231.712"><vh>route-map only1 permit 10</vh></v>
<v t="edream.110203113231.713"><vh>route-map only3 permit 10</vh></v>
<v t="edream.110203113231.714"><vh>route-map tag_com permit 10</vh></v>
<v t="edream.110203113231.715"><vh>route-map tag_com permit 20</vh></v>
</v>
<v t="edream.110203113231.716"><vh>&lt;&lt;router&gt;&gt;</vh>
<v t="edream.110203113231.717"><vh>router bgp 65001</vh></v>
<v t="edream.110203113231.718"><vh>router ospf 1</vh></v>
</v>
<v t="edream.110203113231.719"><vh>&lt;&lt;service&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="edream.110203113231.741"><vh>@thin add_directives.py</vh></v>
<v t="timo.20050213160555"><vh>@thin bibtex.py</vh></v>
<v t="ekr.20040916073636"><vh>@thin ConceptualSort.py</vh></v>
<v t="ekr.20040915105758.13"><vh>@thin FileActions.py</vh></v>
<v t="mork.20041018131258.1"><vh>@thin groupOperations.py</vh></v>
<v t="ekr.20050328092641.4"><vh>@thin Library.py</vh></v>
<v t="ekr.20040916084945"><vh>@thin macros.py</vh></v>
<v t="ekr.20050301083306"><vh>@thin mod_read_dir_outline.py</vh></v>
<v t="edream.110203113231.727"><vh>@thin mod_timestamp.py</vh></v>
<v t="edream.110203113231.720"><vh>@thin outline_export.py</vh></v>
<v t="ekr.20041021120118"><vh>@thin pretty_print.py</vh></v>
<v t="ekr.20040331153923"><vh>@thin scheduler.py</vh></v>
<v t="mork.20041022090036.1"><vh>@thin templates.py</vh></v>
<v t="ekr.20041215103252"><vh>datenodes</vh>
<v t="gfunch.20041207100416"><vh>@thin datenodes.py</vh></v>
<v t="gfunch.20041209063345.1"><vh>@thin datenodes.ini</vh></v>
</v>
<v t="edream.110203113231.722"><vh>mod_autosave</vh>
<v t="edream.110203113231.723" tnodeList="edream.110203113231.723"><vh>@file-nosent mod_autosave.ini</vh></v>
<v t="edream.110203113231.724"><vh>@thin mod_autosave.py</vh></v>
</v>
<v t="ekr.20041110104350"><vh>table plugin: requires tktable</vh>
<v t="ekr.20041017035937"><vh>@thin table.py</vh></v>
</v>
</v>
<v t="edream.110203113231.729"><vh>Debugging &amp;  testing</vh>
<v t="edream.110203113231.730"><vh>@thin dump_globals.py</vh></v>
<v t="edream.110203113231.732"><vh>@thin enable_gc.py</vh></v>
<v t="ekr.20050130120433"><vh>@thin failed_import.py</vh></v>
<v t="edream.110203113231.734"><vh>@thin quit_leo.py</vh></v>
<v t="ekr.20051016160700"><vh>@thin testRegisterCommand.py</vh></v>
<v t="edream.110203113231.735"><vh>@thin trace_gc.py</vh></v>
<v t="edream.110203113231.736"><vh>@thin trace_keys.py</vh></v>
<v t="edream.110203113231.738"><vh>@thin trace_tags.py</vh></v>
<v t="ekr.20040205071616"><vh>mnplugins.py</vh>
<v t="ekr.20050101090717"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050101090717.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20040205071616.1"><vh>mnstamp</vh></v>
<v t="ekr.20040205071616.2"><vh>mnOKstamp</vh></v>
<v t="ekr.20040205071616.3"><vh>onStart</vh></v>
<v t="ekr.20040205071616.4"><vh>setHeadOK</vh></v>
<v t="ekr.20040205071616.5"><vh>insertBodystamp</vh></v>
<v t="ekr.20040205071616.6"><vh>is_subnodesOK</vh></v>
<v t="ekr.20040205071616.7"><vh>onRclick</vh></v>
<v t="ekr.20040205071616.8"><vh>insertOKcmd</vh></v>
<v t="ekr.20040205071616.9"><vh>insertUser</vh></v>
<v t="ekr.20040205071616.10"><vh>create_UserMenu</vh></v>
</v>
</v>
<v t="ekr.20041030092101"><vh>Dyna plugins by e</vh>
<v t="ekr.20060110125615"><vh>@url http://rclick.netfirms.com/dyna_menu.py.html  (dyna plugin)</vh></v>
</v>
<v t="edream.110203113231.872"><vh>Enhanced nodes...</vh>
<v t="edream.110203113231.873"><vh>@thin at_folder.py</vh></v>
<v t="ekr.20040915085351"><vh>@thin at_produce.py</vh></v>
<v t="ktenney.20041211072654.1"><vh>@thin at_view.py</vh></v>
<v t="mork.20041020082242.1"><vh>@thin base64Packager.py</vh></v>
<v t="mork.20041018091414.1"><vh>@thin fastGotoNode.py</vh></v>
<v t="ekr.20050301095332"><vh>@thin mod_labels.py</vh></v>
<v t="edream.110203113231.876"><vh>@thin read_only_nodes.py</vh></v>
<v t="ekr.20040910070811.1"><vh>@thin run_nodes.py</vh></v>
<v t="ekr.20040828103325"><vh>@thin startfile.py</vh></v>
<v t="ekr.20050329082101"><vh>AutoTrees</vh>
<v t="ekr.20050329082101.1"><vh>AutoTrees plugin</vh>
<v t="ekr.20050329082101.2"><vh>Introduction</vh></v>
<v t="ekr.20050329082101.3"><vh>Why use this?</vh></v>
<v t="ekr.20050329082101.4"><vh>Details</vh></v>
<v t="ekr.20050329082101.5"><vh>How do I create my own handlers?</vh></v>
</v>
<v t="ekr.20050329082101.6" annotate="7d71002e"><vh>Example handlers</vh>
<v t="ekr.20050329082101.7"><vh>Testing</vh>
<v t="ekr.20050329082101.8" annotate="7d71002e"><vh>@auto-test something</vh>
<v t="ekr.20050329082101.9"><vh>one</vh></v>
<v t="ekr.20050329082101.10"><vh>two</vh></v>
<v t="ekr.20050329082101.11"><vh>three</vh>
<v t="ekr.20050329082101.12"><vh>three-one</vh></v>
<v t="ekr.20050329082101.13"><vh>three-two</vh></v>
<v t="ekr.20050329082101.14"><vh>three-three</vh></v>
</v>
</v>
</v>
<v t="ekr.20050329082101.15"><vh>RSS</vh>
<v t="ekr.20050329082101.16"><vh>@auto-rss http://news.bbc.co.uk/rss/newsonline_uk_edition/world/rss091.xml</vh>
<v t="ekr.20050329092553"><vh>Hundreds die in Indonesia quake</vh></v>
<v t="ekr.20050329092553.1"><vh>Ousted Kyrgyz president defiant</vh></v>
<v t="ekr.20050329092553.2"><vh>Hair 'good source of stem cells'</vh></v>
<v t="ekr.20050329092553.3"><vh>Ashdown sacks top Bosnian Croat</vh></v>
<v t="ekr.20050329092553.4"><vh>Splits paralyse Iraqi parliament</vh></v>
<v t="ekr.20050329092553.5"><vh>Mongolians protest for new poll</vh></v>
<v t="ekr.20050329092553.6"><vh>Libya's Bulgarian medics appeal</vh></v>
<v t="ekr.20050329092553.7"><vh>Schiavo rivals 'agree to autopsy'</vh></v>
<v t="ekr.20050329092553.8"><vh>Would-be sex tourist, 87, jailed</vh></v>
<v t="ekr.20050329092553.9"><vh>Golf: Funk claims Players title</vh></v>
<v t="ekr.20050329092553.10"><vh>Cricket: Series win for Aussies</vh></v>
<v t="ekr.20050329092553.11"><vh>Angola says virus 'under control'</vh></v>
<v t="ekr.20050329092553.12"><vh>Mugabe criticises MDC 'traitors'</vh></v>
<v t="ekr.20050329092553.13"><vh>Ex-US diplomats round on Bolton</vh></v>
<v t="ekr.20050329092553.14"><vh>Brazil quits loan accord with IMF</vh></v>
<v t="ekr.20050329092553.15"><vh>Japanese economy hit by weak data</vh></v>
<v t="ekr.20050329092553.16"><vh>Donors pledge $40m for KR trials</vh></v>
<v t="ekr.20050329092553.17"><vh>Three Romanians missing in Iraq</vh></v>
<v t="ekr.20050329092553.18"><vh>Wolfowitz 'to meet EU officials'</vh></v>
<v t="ekr.20050329092553.19"><vh>Knesset rejects Gaza referendum</vh></v>
<v t="ekr.20050329092553.20"><vh>Militants to attend PLO meeting</vh></v>
<v t="ekr.20050329092553.21"><vh>South Asia cancels tsunami alerts</vh></v>
<v t="ekr.20050329092553.22"><vh>Devastation as Afghan dam bursts</vh></v>
<v t="ekr.20050329092553.23"><vh>Kyrgyzstan's friendly revolution</vh></v>
</v>
<v t="ekr.20050329082101.40" annotate="7d71002e"><vh>@auto-rss http://slashdot.org/index.rss</vh>
<v t="ekr.20050329092553.24"><vh>Followup on MS and Brazil in NY Times</vh></v>
<v t="ekr.20050329092553.25"><vh>A9.com with Syndicated Search</vh></v>
<v t="ekr.20050329092553.26"><vh>What's Next At Apple</vh></v>
<v t="ekr.20050329092553.27"><vh>Berkeley Grads' Identity Data Stolen</vh></v>
<v t="ekr.20050329092553.28"><vh>South Korean Gov't. Advocates Linux</vh></v>
<v t="ekr.20050329092553.29"><vh>MS, EU Agree on Name for Windows Sans Media Player</vh></v>
<v t="ekr.20050329092553.30"><vh>Blackbox (Finally) Updated</vh></v>
<v t="ekr.20050329092553.31"><vh>Your Face On the Big Screen</vh></v>
<v t="ekr.20050329092553.32"><vh>Ars Technica Builds Make Magazine's Steadicam</vh></v>
<v t="ekr.20050329092553.33"><vh>New Photovoltaics Made with Titanium Foil</vh></v>
</v>
<v t="ekr.20050329082101.51"><vh>@auto-rss http://www.python.org/channews.rdf</vh>
<v t="ekr.20050329082101.52"><vh>Python 2.4.1 (release candidate 1)</vh></v>
<v t="ekr.20050329082101.53"><vh>Greg Stein, of Google and Apache Software Foundation, to deliver keynote at PyCon</vh></v>
<v t="ekr.20050329082101.54"><vh>New RSS feed for python-dev summaries</vh></v>
<v t="ekr.20050329082101.55"><vh>Guido van Rossum speaking in Palo Alto</vh></v>
<v t="ekr.20050329082101.56"><vh>Python 2.3.5 (final)</vh></v>
<v t="ekr.20050329082101.57"><vh>Security advisory for SimpleXMLRPCServer.py.</vh></v>
<v t="ekr.20050329082101.58"><vh>Deadline for OSCON proposals</vh></v>
<v t="ekr.20050329082101.59"><vh>PyCon abstracts now available</vh></v>
<v t="ekr.20050329082101.60"><vh>PyCon preliminary schedule now available</vh></v>
<v t="ekr.20050329082101.61"><vh>PSF has awarded three grants</vh></v>
<v t="ekr.20050329082101.62"><vh>Python for Nokia Series 60 now available</vh></v>
<v t="ekr.20050329082101.63"><vh>Python 2.4 (final)</vh></v>
<v t="ekr.20050329082101.64"><vh>PyZine issue 7</vh></v>
<v t="ekr.20050329082101.65"><vh>PyCon 2005 Call for Proposals</vh></v>
<v t="ekr.20050329082101.66"><vh>Cameron Laird receives the Frank Willison Award</vh></v>
</v>
</v>
<v t="ekr.20050329082101.67"><vh>Remote</vh>
<v t="ekr.20050329082101.68"><vh>@auto-remote http://www.bbc.co.uk/news.html</vh></v>
</v>
<v t="ekr.20050329082101.69"><vh>Documentation</vh>
<v t="ekr.20050329082101.70"><vh>@auto-doc docutils.core</vh>
<v t="ekr.20050329082101.71"><vh>Component</vh>
<v t="ekr.20050329082101.72"><vh>component_type</vh></v>
<v t="ekr.20050329082101.73"><vh>default_transforms</vh></v>
<v t="ekr.20050329082101.74"><vh>supports</vh></v>
</v>
<v t="ekr.20050329082101.75"><vh>ConfigParser</vh>
<v t="ekr.20050329082101.76"><vh>OPTCRE</vh></v>
<v t="ekr.20050329082101.77"><vh>SECTCRE</vh></v>
<v t="ekr.20050329082101.78"><vh>add_section</vh></v>
<v t="ekr.20050329082101.79"><vh>standard_config_files</vh></v>
<v t="ekr.20050329082101.80"><vh>validation</vh></v>
</v>
<v t="ekr.20050329082101.81"><vh>OptionParser</vh>
<v t="ekr.20050329082101.82"><vh>default_error_encoding_error_handler</vh></v>
<v t="ekr.20050329082101.83"><vh>relative_path_settings</vh></v>
<v t="ekr.20050329082101.84"><vh>settings_defaults</vh></v>
<v t="ekr.20050329082101.85"><vh>settings_spec</vh></v>
<v t="ekr.20050329082101.86"><vh>standard_option_list</vh></v>
<v t="ekr.20050329082101.87"><vh>threshold_choices</vh></v>
<v t="ekr.20050329082101.88"><vh>thresholds</vh></v>
<v t="ekr.20050329082101.89"><vh>version_template</vh></v>
</v>
<v t="ekr.20050329082101.90"><vh>Publisher</vh></v>
<v t="ekr.20050329082101.91"><vh>default_description</vh></v>
<v t="ekr.20050329082101.92"><vh>default_usage</vh></v>
<v t="ekr.20050329082101.93"><vh>frontend</vh></v>
<v t="ekr.20050329082101.94"><vh>io</vh></v>
<v t="ekr.20050329082101.95"><vh>parsers</vh></v>
<v t="ekr.20050329082101.96"><vh>publish_cmdline</vh></v>
<v t="ekr.20050329082101.97"><vh>publish_file</vh></v>
<v t="ekr.20050329082101.98"><vh>publish_string</vh></v>
<v t="ekr.20050329082101.99"><vh>readers</vh></v>
<v t="ekr.20050329082101.100"><vh>sys</vh></v>
<v t="ekr.20050329082101.101"><vh>writers</vh></v>
</v>
</v>
<v t="ekr.20050329082101.102"><vh>News Reader</vh>
<v t="ekr.20050329082101.103"><vh>@auto-news news-server.houston.rr.com/comp.lang.python</vh>
<v t="ekr.20050329082101.104"><vh>@auto-newsitem 356970 - Easy way to check modules for python version compatibility?</vh></v>
<v t="ekr.20050329082101.105"><vh>@auto-newsitem 356972 - Q: Module Shared Data</vh></v>
<v t="ekr.20050329082101.106"><vh>@auto-newsitem 356978 - Re: __contains__ inconsistencies between Python 2.2 and 2.3</vh></v>
<v t="ekr.20050329082101.107"><vh>@auto-newsitem 356979 - Re: [Numeric] column vector faster than row vector in mat multiply?</vh></v>
<v t="ekr.20050329082101.108"><vh>@auto-newsitem 356986 - Python 2.4 removes None data type?</vh></v>
<v t="ekr.20050329082101.109"><vh>@auto-newsitem 356987 - Re: Integer From A Float List?!?</vh></v>
<v t="ekr.20050329082101.110"><vh>@auto-newsitem 356988 - Suspicious header</vh></v>
<v t="ekr.20050329082101.111"><vh>@auto-newsitem 356991 - Re: Suspicious header</vh></v>
<v t="ekr.20050329082101.112"><vh>@auto-newsitem 356992 - survey</vh></v>
<v t="ekr.20050329082101.113"><vh>@auto-newsitem 356993 - Re: Python 2.4 removes None data type?</vh></v>
</v>
</v>
</v>
<v t="ekr.20050329082101.114"><vh>AutoTrees Code</vh>
<v t="ekr.20050329082101.115"><vh>@thin autotrees.py</vh></v>
<v t="ekr.20050329082101.145"><vh>@--thin trees\pluginsManager.txt</vh></v>
<v t="ekr.20050329082101.146"><vh>Example tree handlers</vh>
<v t="ekr.20050329082101.147"><vh>@--thin trees\test.py</vh>
<v t="ekr.20050329082101.148"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050329082101.149"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
</v>
<v t="ekr.20050329082101.150"><vh>@--thin trees\rss.py</vh>
<v t="ekr.20050329082101.151"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050329082101.152"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
</v>
<v t="ekr.20050329082101.153"><vh>@--thin trees\news.py</vh>
<v t="ekr.20050329082101.154"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050329082101.155"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20050329082101.156"><vh>Error Classes</vh></v>
<v t="ekr.20050329082101.157"><vh>getConnection</vh></v>
<v t="ekr.20050329082101.158"><vh>class News</vh>
<v t="ekr.20050329082101.159"><vh>initFrom</vh></v>
</v>
<v t="ekr.20050329082101.160"><vh>class NewsItem</vh>
<v t="ekr.20050329082101.161"><vh>initFrom</vh></v>
</v>
</v>
<v t="ekr.20050329082101.162"><vh>@--thin trees\remote.py</vh>
<v t="ekr.20050329082101.163"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050329082101.164"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
</v>
<v t="ekr.20050329082101.165"><vh>@--thin trees\doc.py</vh>
<v t="ekr.20050329082101.166"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050329082101.167"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040722135402.1"><vh>Enhancing the body pane</vh>
<v t="EKR.20040517080517.1"><vh>@thin arrows.py</vh></v>
<v t="edream.110203113231.753"><vh>@thin image.py</vh></v>
<v t="ekr.20040422072343"><vh>@thin rClick.py</vh></v>
<v t="EKR.20040605181725"><vh>Autocompleter</vh>
<v t="EKR.20040605181725.1"><vh>Configuration</vh>
<v t="EKR.20040608070256"><vh>autocompleter.ini</vh></v>
<v t="EKR.20040608070256.1"><vh>.ato files in the autocompleter folder</vh></v>
</v>
<v t="ekr.20041017043622"><vh>@thin autocompleter.py</vh></v>
</v>
<v t="edream.110403140857"><vh>color_markup.py (requires add-directives plugin)</vh>
<v t="edream.110403140857.1"><vh>Plugin documentation</vh>
<v t="edream.110403140857.2"><vh>Installation</vh></v>
<v t="edream.110403140857.3"><vh>Use</vh>
<v t="edream.110403140857.4"><vh>Supported markups</vh></v>
<v t="edream.110403140857.5"><vh>Example</vh>
<v t="edream.110403140857.6"><vh>a subnode</vh></v>
</v>
</v>
<v t="edream.110403140857.7"><vh>Release notes</vh></v>
</v>
<v t="edream.110403140857.8"><vh>@thin color_markup.py</vh></v>
</v>
<v t="edream.110203113231.925"><vh>@thin script_io_to_body.py</vh></v>
</v>
<v t="ekr.20040722135402"><vh>Enhancing the icon and status areas</vh>
<v t="edream.110203113231.758"><vh>@thin nav_buttons.py</vh></v>
<v t="pap.20051010170720"><vh>@thin newButtons.py</vh></v>
<v t="ekr.20040331072607"><vh>@thin hoist.py</vh></v>
<v t="ekr.20040108062655"><vh>@thin nodenavigator.py</vh></v>
<v t="ekr.20040108095351"><vh>@thin rowcol.py</vh></v>
<v t="ekr.20040107092135.2"><vh>@thin searchbox.py</vh></v>
<v t="rogererens.20041013082304"><vh>@thin UNL.py</vh></v>
</v>
<v t="ekr.20040915073259"><vh>Enhancing windows</vh>
<v t="ekr.20050227071948" annotate="5404010000376437313030323835353038373037323639366637323639373437393731303132383633363136653665366637343631373436353061353436623530363936333662366336353536363137323061373130323666373130333464306632373632353530343665366636343635373130353238363830323666373130363535303734363635363137343735373236353731303736323535303236323637373130383238363830323666373130393535303037313061363235353039363137323633363836353734373937303635373130623238363830323666373130633638306136323535303236363637373130643238363830323666373130653638306136323735326571002e"><vh> cleo</vh>
<v t="ekr.20050227072121"><vh>Notes</vh>
<v t="ekr.20050227071948.1" annotate="7d71002e"><vh>TODO</vh>
<v t="ekr.20050227071948.2" annotate="7d71002e"><vh>pixmap icons</vh></v>
<v t="ekr.20050227071948.3" annotate="7d71002e"><vh>colour selector</vh></v>
<v t="ekr.20050227071948.4" annotate="55f037643731303032383535303837303732363936663732363937343739373130313238363336313665366536663734363137343635306135343662353036393633366236633635353636313732306137313032366637313033346236343632353530343665366636343635373130353238363830323666373130363535303037313037363235353032363236373731303832383638303236663731303936383037363235353039363137323633363836353734373937303635373130613238363830323666373130623638303736323535303236363637373130633238363830323666373130643638303736323735326571002e"><vh>popup location</vh></v>
<v t="ekr.20050227071948.5" annotate="5592376437313030323835353038373037323639366637323639373437393731303132383633363136653665366637343631373436353061353436623530363936333662366336353536363137323061373130323666373130333462303136323535303936313732363336383635373437393730363537313035323836383032366637313036353530303731303736323735326571002e"><vh>EKR's intentions on @thin nodes</vh>
<v t="ekr.20050227071948.6" annotate="5592376437313030323835353038373037323639366637323639373437393731303132383633363136653665366637343631373436353061353436623530363936333662366336353536363137323061373130323666373130333462303136323535303936313732363336383635373437393730363537313035323836383032366637313036353530303731303736323735326571002e"><vh>No attributes for @thin nodes</vh></v>
</v>
<v t="ekr.20050227071948.7" annotate="7d71002e"><vh>group annotations</vh></v>
<v t="ekr.20050227071948.8" annotate="7d71002e"><vh>archetype based search,navigation</vh></v>
<v t="ekr.20050227071948.9" annotate="7d71002e"><vh>sort by type</vh></v>
<v t="ekr.20050227071948.10" annotate="7d71002e"><vh>fonts</vh></v>
<v t="ekr.20050227071948.11" annotate="55f037643731303032383535303837303732363936663732363937343739373130313238363336313665366536663734363137343635306135343662353036393633366236633635353636313732306137313032366637313033346230323632353530343665366636343635373130353238363830323666373130363535303037313037363235353032363236373731303832383638303236663731303936383037363235353039363137323633363836353734373937303635373130613238363830323666373130623638303736323535303236363637373130633238363830323666373130643638303736323735326571002e"><vh>question marks</vh></v>
</v>
<v t="ekr.20050227071948.12" annotate="54000100003764373130303238353530383730373236393666373236393734373937313031323836333631366536653666373436313734363530613534366235303639363336623663363535363631373230613731303236663731303334623634363235353034366536663634363537313035323836383032366637313036353530303731303736323535303236323637373130383238363830323666373130393535303635303735373237303663363537313061363235353039363137323633363836353734373937303635373130623238363830323666373130633638303736323535303236363637373130643238363830323666373130653638303736323735326571002e"><vh>Done</vh>
<v t="ekr.20050227071948.13" annotate="7d71005509617474656e74696f6e71014930300a732e"><vh>Clear All markings</vh></v>
<v t="ekr.20050227071948.14" annotate="54120100003764373130303238353530343665366636343635373130313238363336313665366536663734363137343635306135343662353036393633366236633635353636313732306137313032366637313033353530303731303536323535303236323637373130363238363830323666373130373638303536323535303936313734373436353665373436393666366537313038343933303331306135353038373037323639366637323639373437393731303932383638303236663731306134623634363235353032363636373731306232383638303236663731306336383035363235353039363137323633363836353734373937303635373130643238363830323666373130653638303536323735326571002e"><vh>autoleo node colouring</vh></v>
<v t="ekr.20050227071948.15" annotate="5592376437313030323835353038373037323639366637323639373437393731303132383633363136653665366637343631373436353061353436623530363936333662366336353536363137323061373130323666373130333462363436323535303936313732363336383635373437393730363537313035323836383032366637313036353530303731303736323735326571002e"><vh>arbitary colouring</vh></v>
<v t="ekr.20050227071948.16" annotate="55f037643731303032383535303837303732363936663732363937343739373130313238363336313665366536663734363137343635306135343662353036393633366236633635353636313732306137313032366637313033346236343632353530343665366636343635373130353238363830323666373130363535303037313037363235353032363236373731303832383638303236663731303936383037363235353039363137323633363836353734373937303635373130613238363830323666373130623638303736323535303236363637373130633238363830323666373130643638303736323735326571002e"><vh>rename to cleo</vh></v>
<v t="ekr.20050227071948.17" annotate="7d71002e"><vh>headline colours</vh></v>
<v t="ekr.20050227071948.18" annotate="7d71005509617474656e74696f6e71014930300a732e"><vh>priority colouring</vh></v>
<v t="ekr.20050227071948.19" annotate="7d71005509617474656e74696f6e71014930300a732e"><vh>archtetype colouring</vh></v>
</v>
<v t="ekr.20050227071948.20" annotate="7d71002e"><vh>Problems</vh>
<v t="ekr.20050227071948.6" annotate="5592376437313030323835353038373037323639366637323639373437393731303132383633363136653665366637343631373436353061353436623530363936333662366336353536363137323061373130323666373130333462303136323535303936313732363336383635373437393730363537313035323836383032366637313036353530303731303736323735326571002e"><vh>No attributes for @thin nodes</vh></v>
<v t="ekr.20050227071948.21" annotate="5592376437313030323835353038373037323639366637323639373437393731303132383633363136653665366637343631373436353061353436623530363936333662366336353536363137323061373130323666373130333462303236323535303936313732363336383635373437393730363537313035323836383032366637313036353530303731303736323735326571002e"><vh>features are not orthogonal</vh></v>
<v t="ekr.20050227071948.22" annotate="7d71002e"><vh>Too many colours !!</vh></v>
</v>
<v t="ekr.20050227071948.23" annotate="5404010000376437313030323835353038373037323639366637323639373437393731303132383633363136653665366637343631373436353061353436623530363936333662366336353536363137323061373130323666373130333464306632373632353530343665366636343635373130353238363830323666373130363535303734363635363137343735373236353731303736323535303236323637373130383238363830323666373130393535303037313061363235353039363137323633363836353734373937303635373130623238363830323666373130633638306136323535303236363637373130643238363830323666373130653638306136323735326571002e"><vh>BUGS</vh>
<v t="ekr.20050227071948.24" annotate="55f037643731303032383535303837303732363936663732363937343739373130313238363336313665366536663734363137343635306135343662353036393633366236633635353636313732306137313032366637313033346236343632353530343665366636343635373130353238363830323666373130363535303037313037363235353032363236373731303832383638303236663731303936383037363235353039363137323633363836353734373937303635373130613238363830323666373130623638303736323535303236363637373130633238363830323666373130643638303736323735326571002e"><vh>popup location</vh></v>
</v>
<v t="ekr.20050227071948.27" annotate="7d71002e"><vh>colour table</vh></v>
<v t="ekr.20050227071948.28" annotate="54060100003764373130303238353530383730373236393666373236393734373937313031323836333631366536653666373436313734363530613534366235303639363336623663363535363631373230613731303236663731303334643066323736323535303436653666363436353731303532383638303236663731303635353038343336663664366436353665373437333731303736323535303236323637373130383238363830323666373130393535303037313061363235353039363137323633363836353734373937303635373130623238363830323666373130633638306136323535303236363637373130643238363830323666373130653638306136323735326571002e"><vh>Notes</vh>
<v t="ekr.20050227071948.29" annotate="7d71002e"><vh>drawing hooks</vh></v>
</v>
</v>
<v t="ekr.20050227071948.33" annotate="540c0100003764373130303238353530383730373236393666373236393734373937313031323836333631366536653666373436313734363530613534366235303639363336623663363535363631373230613731303236663731303334643066323736323535303436653666363436353731303532383638303236663731303635353034363636393663363537313037363235353032363236373731303832383638303236663731303935353030373130613632353530393631373236333638363537343739373036353731306232383638303236663731306335353035346637343638363537323731306436323535303236363637373130653238363830323666373130663638306136323735326571002e"><vh>@thin cleo.py</vh></v>
</v>
<v t="ekr.20050303080042"><vh> footprints</vh>
<v t="ekr.20050303080236"><vh>To do</vh></v>
<v t="ekr.20050303080042.1" tnodeList="ekr.20050303080042.1"><vh>@nosent footprints.ini</vh></v>
<v t="pap.20041020001240"><vh>@thin footprints.py</vh></v>
</v>
<v t="mork.20041018162155.1"><vh>@thin EditAttributes.py</vh></v>
<v t="ekr.20040915073259.1"><vh>@thin maximizeNewWindows.py</vh></v>
<v t="mork.20041022155742.1"><vh>@thin nodebar.py</vh></v>
<v t="edream.110203113231.924"><vh>@thin redirect_to_log.py</vh></v>
<v t="ekr.20040915075530"><vh>@thin UASearch.py</vh></v>
<v t="ekr.20040831122004"><vh>@thin UniversalScrolling.py</vh></v>
<v t="ekr.20040831115238"><vh>@thin URLloader.py</vh></v>
</v>
<v t="ekr.20040722141148"><vh>Example code</vh>
<v t="edream.110203113231.916"><vh>@thin __overrideClasses.py</vh></v>
<v t="edream.110203113231.919"><vh>@thin override_commands.py</vh></v>
<v t="edream.110203113231.921"><vh>@thin redefine_put.py</vh></v>
</v>
<v t="ekr.20040722134535"><vh>Experimental/unfinished</vh>
<v t="ekr.20050915064008"><vh>@thin __vnx__.py</vh></v>
<v t="ekr.20050612074047"><vh>New colorizer</vh>
<v t="ekr.20050529180421"><vh>jEdit docs...</vh>
<v t="ekr.20050530065723"><vh>@url http://www.jedit.org/42docs/users-guide/writing-modes-part.html</vh></v>
<v t="ekr.20050529180421.1"><vh>Rule ordering</vh></v>
<v t="ekr.20050529180421.2"><vh>Attributes</vh>
<v t="ekr.20050529180421.3"><vh> Documentation of attributes</vh>
<v t="ekr.20050529180421.4"><vh> For 'seq', 'span', 'begin', 'end'</vh>
<v t="ekr.20050529180421.5"><vh>AT_LINE_START (bool)</vh></v>
<v t="ekr.20050529180421.6"><vh>AT_WHITESPACE_END (bool)</vh></v>
<v t="ekr.20050529180421.7"><vh>AT_WORD_START (bool)</vh></v>
</v>
<v t="ekr.20050529180421.8"><vh> For 'span' only</vh>
<v t="ekr.20050529180421.9"><vh>NO_WORD_BREAK (bool)</vh></v>
<v t="ekr.20050529180421.10"><vh>NO_LINE_BREAK (bool)</vh></v>
<v t="ekr.20050529180421.11"><vh>NO_ESCAPE (bool)</vh></v>
<v t="ekr.20050529180421.12"><vh>EXCLUDE_MATCH (bool)</vh></v>
</v>
<v t="ekr.20050529180421.13"><vh> For 'rules' only</vh>
<v t="ekr.20050529180421.14"><vh>DEFAULT</vh></v>
<v t="ekr.20050529180421.15"><vh>DIGIT_RE (re) &amp; HIGHLIGHT_DIGITS  (bool)</vh></v>
<v t="ekr.20050529180421.16"><vh>IGNORE_CASE (bool)</vh></v>
<v t="ekr.20050529180421.17"><vh>SET</vh></v>
<v t="ekr.20050529180421.18"><vh>NO_WORD_SEP</vh></v>
</v>
<v t="ekr.20050529180421.19"><vh>AT_CHAR (int) for 'terminate'</vh></v>
<v t="ekr.20050529180421.20"><vh>DELEGATE: for 'import', 'span' &amp; 'seq'</vh></v>
<v t="ekr.20050529180421.21"><vh>HASH_CHAR (char) For 'regx'</vh></v>
<v t="ekr.20050529180421.22"><vh>TYPE (Token Types)</vh></v>
</v>
<v t="ekr.20050529180421.23"><vh>Attributes for 'begin' &amp; 'end'</vh></v>
<v t="ekr.20050529180421.24"><vh>Attributes for 'import': delegate</vh></v>
<v t="ekr.20050529180421.25"><vh>Attributes for 'mark' </vh></v>
<v t="ekr.20050529180421.26"><vh>Attributes for 'property': name, value</vh></v>
<v t="ekr.20050529180421.27"><vh>Attributes for 'rules'</vh></v>
<v t="ekr.20050529180421.28"><vh>Attributes for 'span'</vh></v>
<v t="ekr.20050529180421.29"><vh>Attributes for 'seq' </vh></v>
</v>
<v t="ekr.20050529180421.30"><vh>Elements</vh>
<v t="ekr.20050529220821"><vh>Spans and seqs...</vh>
<v t="ekr.20050529180421.31"><vh>eol_span</vh></v>
<v t="ekr.20050529180421.32"><vh>eol_span_regexp</vh></v>
<v t="ekr.20050529180421.35"><vh>mark_following</vh></v>
<v t="ekr.20050529180421.36"><vh>mark_previous</vh></v>
<v t="ekr.20050529180421.40"><vh>seq</vh></v>
<v t="ekr.20050529180421.41"><vh>seq_regexp</vh></v>
<v t="ekr.20050529180421.42"><vh>span</vh></v>
<v t="ekr.20050529180421.43"><vh>span_regexp</vh></v>
</v>
<v t="ekr.20050529220821.1"><vh>All others...</vh>
<v t="ekr.20050529180421.33"><vh>import</vh></v>
<v t="ekr.20050529180421.34"><vh>keywords</vh></v>
<v t="ekr.20050529180421.37"><vh>mode</vh></v>
<v t="ekr.20050529180421.38"><vh>props &amp; property  (for auto-indent)</vh></v>
<v t="ekr.20050529180421.39"><vh>rules</vh></v>
<v t="ekr.20050529180421.44"><vh>terminate</vh></v>
</v>
</v>
</v>
<v t="ekr.20050529142847"><vh>@thin __jEdit_colorizer__.py</vh></v>
<v t="ekr.20050606214954"><vh>(state methods)</vh>
<v t="ekr.20050529143413.30"><vh>colorize (Main entry point)</vh></v>
<v t="ekr.20050529143413.31"><vh>colorizeAnyLanguage</vh></v>
<v t="ekr.20050602205810.4"><vh>colorRangeWithTag</vh></v>
</v>
<v t="ekr.20050606221357"><vh>(init)</vh>
<v t="ekr.20050602150619"><vh>init_mode</vh></v>
<v t="ekr.20050602152743"><vh>init_keywords</vh>
<v t="ekr.20050607073917"><vh>&lt;&lt; compute extra_word_chars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050530065723.47"><vh>parse_jEdit_file</vh></v>
</v>
<v t="ekr.20050607220512"><vh>(delegate)</vh>
<v t="ekr.20050601105358"><vh>colorOneChunk</vh>
<v t="ekr.20050605130806"><vh>&lt;&lt; queue up this method the first time &gt;&gt;</vh></v>
<v t="ekr.20050601162452.1"><vh>&lt;&lt; queue up this method &gt;&gt;</vh></v>
</v>
<v t="ekr.20050607212958"><vh>colorByDelegate</vh></v>
<v t="ekr.20050602205810.4"><vh>colorRangeWithTag</vh></v>
</v>
</v>
<v t="ekr.20040717133342"><vh>Shadow files plugin</vh>
<v t="ekr.20050126104457"><vh>Notes</vh></v>
<v t="bwmulder.20041017125718"><vh>@thin mod_shadow.py</vh></v>
</v>
<v t="ekr.20040918165427"><vh>To do</vh>
<v t="EKR.20040611044600"><vh>Mulder undo</vh>
<v t="bwmulder.20040601212737"><vh>basic_undo.py</vh>
<v t="bwmulder.20040601212737.1"><vh>class passthrough</vh>
<v t="bwmulder.20040601212737.2"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.3"><vh>__set__</vh></v>
<v t="bwmulder.20040601212737.4"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040601212737.5"><vh>class scalar_monitor</vh>
<v t="bwmulder.20040601212737.6"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.7"><vh>__set__</vh></v>
<v t="bwmulder.20040601212737.8"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040601212737.9"><vh>class list_monitor</vh>
<v t="bwmulder.20040605231305"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.10"><vh>set_monitor_object</vh></v>
<v t="bwmulder.20040601212737.11"><vh>__setitem__</vh></v>
<v t="bwmulder.20040601212737.12"><vh>__delitem__</vh></v>
<v t="bwmulder.20040601212737.13"><vh>append</vh></v>
<v t="bwmulder.20040602152548"><vh>pop</vh></v>
</v>
<v t="bwmulder.20040601212737.14"><vh>class list_monitor_in_instance</vh>
<v t="bwmulder.20040601212737.15"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.16"><vh>__set__</vh></v>
<v t="bwmulder.20040601212737.17"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040602153618"><vh>class dict_monitor</vh>
<v t="bwmulder.20040605231401"><vh>__init__</vh></v>
<v t="bwmulder.20040602153642"><vh>set_monitor_object</vh></v>
<v t="bwmulder.20040602153723"><vh>__setitem__</vh></v>
<v t="bwmulder.20040602153835"><vh>__delitem__</vh></v>
</v>
<v t="bwmulder.20040602154259"><vh>class  dict_monitor_in_instance</vh>
<v t="bwmulder.20040602154259.1"><vh>__init__</vh></v>
<v t="bwmulder.20040602154259.2"><vh>__set__</vh></v>
<v t="bwmulder.20040602154259.3"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040601212737.18"><vh>class monitor</vh>
<v t="bwmulder.20040601212737.19"><vh>__init__</vh></v>
<v t="bwmulder.20040601214251"><vh>scalars</vh>
<v t="bwmulder.20040601212737.20"><vh>monitor_scalar</vh></v>
<v t="bwmulder.20040601212737.24"><vh>scalar_set</vh></v>
<v t="bwmulder.20040601212737.25"><vh>scalar_modify</vh></v>
</v>
<v t="bwmulder.20040601215339"><vh>lists</vh>
<v t="bwmulder.20040601212737.21"><vh>monitor_list_attribute_in_class</vh></v>
<v t="bwmulder.20040601212737.26"><vh>list_create</vh></v>
<v t="bwmulder.20040601212737.27"><vh>list_set</vh></v>
<v t="bwmulder.20040601212737.28"><vh>list_del</vh></v>
<v t="bwmulder.20040601212737.29"><vh>list_append</vh></v>
</v>
<v t="bwmulder.20040602165344"><vh>dicts</vh>
<v t="bwmulder.20040602165402"><vh>monitor_dict_attribute_in_class</vh></v>
<v t="bwmulder.20040602165506"><vh>dict_create</vh></v>
<v t="bwmulder.20040602165513"><vh>dict_set</vh></v>
<v t="bwmulder.20040602165553"><vh>dict_del</vh></v>
</v>
<v t="bwmulder.20040601215339.1"><vh>switching on and off</vh>
<v t="bwmulder.20040601212737.22"><vh>enable</vh></v>
<v t="bwmulder.20040602164627"><vh>enable_put_in_removed_functions</vh></v>
<v t="bwmulder.20040602154259.4"><vh>enable_category</vh></v>
<v t="bwmulder.20040602161525"><vh>disable_category</vh></v>
<v t="bwmulder.20040601212737.23"><vh>disable</vh></v>
<v t="bwmulder.20040603081718"><vh>remove_overrides_in_list_and_dict_monitor</vh></v>
</v>
</v>
<v t="bwmulder.20040601222230"><vh>class basic_undomechanism</vh>
<v t="bwmulder.20040601222230.1"><vh>__init__</vh></v>
<v t="bwmulder.20040602171606"><vh>reset</vh></v>
<v t="bwmulder.20040601222230.2"><vh>scalars</vh>
<v t="bwmulder.20040601222230.3"><vh>scalar_set</vh></v>
<v t="bwmulder.20040601222230.4"><vh>scalar_set_undo</vh></v>
<v t="bwmulder.20040601222230.5"><vh>scalar_set_redo</vh></v>
<v t="bwmulder.20040601222230.6"><vh>scalar_modify</vh></v>
<v t="bwmulder.20040601222431"><vh>scalar_modify_undo</vh></v>
</v>
<v t="bwmulder.20040602075341"><vh>lists</vh>
<v t="bwmulder.20040602084701.1"><vh>creation</vh>
<v t="bwmulder.20040602175523"><vh>list_assignment_replace</vh></v>
<v t="bwmulder.20040602175523.1"><vh>list_assignment_replace_undo</vh></v>
<v t="bwmulder.20040602175740"><vh>list_assignment_replace_redo</vh></v>
<v t="bwmulder.20040602183806"><vh>list_assignment_new</vh></v>
<v t="bwmulder.20040602183814"><vh>list_assignment_new_undo</vh></v>
<v t="bwmulder.20040602183911"><vh>list_assignment_new_redo</vh></v>
<v t="bwmulder.20040602075341.1"><vh>list_create</vh></v>
<v t="bwmulder.20040602084701.2"><vh>list_create_undo</vh></v>
<v t="bwmulder.20040602084701.3"><vh>list_create_redo</vh></v>
</v>
<v t="bwmulder.20040602084701.4"><vh>setting</vh>
<v t="bwmulder.20040602085955"><vh>list_set</vh></v>
<v t="bwmulder.20040602085955.1"><vh>list_set_undo</vh></v>
</v>
<v t="bwmulder.20040602085955.2"><vh>deletion</vh>
<v t="bwmulder.20040602085955.3"><vh>list_del</vh></v>
<v t="bwmulder.20040602085955.4"><vh>list_del_undo</vh></v>
<v t="bwmulder.20040602085955.5"><vh>list_del_redo</vh></v>
</v>
<v t="bwmulder.20040602151709"><vh>append</vh>
<v t="bwmulder.20040602152051"><vh>list_append</vh></v>
<v t="bwmulder.20040602152051.1"><vh>list_append_undo</vh></v>
<v t="bwmulder.20040602152051.2"><vh>list_append_redo</vh></v>
</v>
<v t="bwmulder.20040602152548.1"><vh>pop</vh>
<v t="bwmulder.20040602152548.2"><vh>list_pop</vh></v>
</v>
</v>
<v t="bwmulder.20040602171032"><vh>dictionaries</vh>
<v t="bwmulder.20040602171032.1"><vh>creation</vh>
<v t="bwmulder.20040602175801"><vh>dictionary creation</vh></v>
<v t="bwmulder.20040602171032.2"><vh>dict_create</vh></v>
<v t="bwmulder.20040602171032.3"><vh>dict_create_undo</vh></v>
<v t="bwmulder.20040602171032.4"><vh>dict_create_redo</vh></v>
</v>
<v t="bwmulder.20040602171032.5"><vh>setting</vh>
<v t="bwmulder.20040602171032.6"><vh>dict_set</vh></v>
<v t="bwmulder.20040602171032.7"><vh>dict_set_undo</vh></v>
</v>
<v t="bwmulder.20040602171032.8"><vh>deletion</vh>
<v t="bwmulder.20040602171032.9"><vh>dict_del</vh></v>
<v t="bwmulder.20040602171032.10"><vh>dict_del_undo</vh></v>
<v t="bwmulder.20040602171032.11"><vh>dict_del_redo</vh></v>
</v>
</v>
<v t="bwmulder.20040601224447"><vh>the undo machinery</vh>
<v t="bwmulder.20040603211921"><vh>queries</vh>
<v t="bwmulder.20040601224447.5"><vh>canUndo</vh></v>
<v t="bwmulder.20040601224447.6"><vh>canRedo</vh></v>
<v t="bwmulder.20040603212552"><vh>commands</vh></v>
<v t="bwmulder.20040603212612"><vh>commands_to_undo</vh></v>
<v t="bwmulder.20040603212713"><vh>commands_to_redo</vh></v>
<v t="bwmulder.20040604165011"><vh>steps_stored</vh></v>
<v t="bwmulder.20040605220919"><vh>print_commands</vh></v>
</v>
<v t="bwmulder.20040601224447.2"><vh>mark</vh></v>
<v t="bwmulder.20040601224447.3"><vh>undo</vh></v>
<v t="bwmulder.20040601224447.4"><vh>redo</vh></v>
<v t="bwmulder.20040603212934"><vh>rollback</vh></v>
<v t="bwmulder.20040601222649"><vh>run_commands</vh></v>
</v>
</v>
</v>
<v t="bwmulder.20040602221559"><vh>basic_undo_test.py</vh>
<v t="bwmulder.20040602223236"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="bwmulder.20040602223236.1"><vh>class tracer</vh>
<v t="bwmulder.20040602223236.2"><vh>__getattr__</vh></v>
<v t="bwmulder.20040602223906"><vh>catchall</vh></v>
</v>
<v t="bwmulder.20040602224231"><vh>class delegator</vh>
<v t="bwmulder.20040602224413"><vh>__init__</vh></v>
<v t="bwmulder.20040602224332"><vh>__getattr__</vh></v>
<v t="bwmulder.20040602231914"><vh>catchall</vh></v>
<v t="bwmulder.20040602231934"><vh>enable_category</vh></v>
</v>
<v t="bwmulder.20040602225640"><vh>class basic_scalar_test</vh>
<v t="bwmulder.20040602230124"><vh>test_scalar_basic</vh></v>
<v t="bwmulder.20040604184443"><vh>test_linked_list</vh></v>
</v>
<v t="bwmulder.20040605104941"><vh>class basic_list_test</vh>
<v t="bwmulder.20040605105746"><vh>test_lists_basic</vh></v>
<v t="bwmulder.20040605174728"><vh>test_lists_replace</vh></v>
</v>
<v t="bwmulder.20040605180204"><vh>class basic_dict_test</vh>
<v t="bwmulder.20040605180225"><vh>test_dicts_basic</vh></v>
<v t="bwmulder.20040605180245"><vh>test_dicts_replace</vh></v>
</v>
<v t="bwmulder.20040602230426"><vh>test_main</vh></v>
</v>
</v>
<v t="ekr.20040918165144.9"><vh>Write script to find args to g.es()</vh></v>
<v t="ekr.20040918165427.4"><vh>Autocompletion dictionary files</vh></v>
<v t="ekr.20040918165427.5"><vh>Leo to docbook xml plugin: Leo2AsciiDoc</vh></v>
</v>
<v t="edream.110203113231.233"><vh>wxPython plugin (pre-alpha quality)</vh>
<v t="edream.110203113231.234"><vh> wx Diary</vh>
<v t="edream.111503110300"><vh>11/15/03  Leo becomes usuable (!)</vh></v>
<v t="edream.111403093253"><vh>11/13 &amp; 11/14</vh></v>
<v t="edream.110203113231.235"><vh>10/26 Code works with reorganized core</vh></v>
<v t="edream.110203113231.236"><vh>10/13/03: Added icons (Windows only)</vh></v>
<v t="edream.110203113231.237"><vh>10/12/03: Houston, we have ignition</vh></v>
<v t="edream.110203113231.238"><vh>10/11/03: converted code using c2py, then hand converted code</vh></v>
</v>
<v t="edream.111503111350"><vh>To do</vh>
<v t="edream.111303184347"><vh>(delete_range) doesn't work</vh>
<v t="edream.111303103141.3"><vh>delete_range</vh></v>
</v>
<v t="edream.111303100039"><vh>Gui-dependent commands (to do)</vh>
<v t="edream.111303100039.1"><vh>Edit Menu...</vh>
<v t="edream.111303101257"><vh>abortEditLabelCommand</vh></v>
<v t="edream.111303101257.1"><vh>endEditLabelCommand</vh></v>
<v t="edream.111303100039.6"><vh>insertHeadlineTime</vh></v>
</v>
<v t="edream.111303100039.7"><vh>Window Menu</vh>
<v t="edream.111303100039.8"><vh>cascade</vh></v>
<v t="edream.111303100039.9"><vh>equalSizedPanes</vh></v>
<v t="edream.111303100039.10"><vh>hideLogWindow</vh></v>
<v t="edream.111303100039.11"><vh>minimizeAll</vh></v>
<v t="edream.111303101709"><vh>toggleActivePane</vh></v>
<v t="edream.111303100039.12"><vh>toggleSplitDirection</vh></v>
</v>
<v t="edream.111703103908"><vh>Help Menu...</vh>
<v t="edream.111703103908.2"><vh>leoHelp</vh>
<v t="edream.111703103908.3"><vh>showProgressBar</vh>
<v t="edream.111703103908.4"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20050718142601"><vh>(Changes made 7/05)</vh>
<v t="ekr.20050718142601.1"><vh>Notes</vh></v>
<v t="edream.110203113231.347"><vh>OnInit  (wxLeoApp)</vh></v>
<v t="ekr.20050718151826"><vh>(wxGui Stuff)</vh>
<v t="edream.111303091300"><vh>app.gui.wx birth &amp; death</vh>
<v t="edream.110203113231.307"><vh> wxGui.__init__</vh></v>
<v t="edream.110203113231.308"><vh>createRootWindow &amp; allies</vh>
<v t="edream.110203113231.309"><vh>setDefaultIcon CONTAINS TK CODE</vh></v>
<v t="edream.110203113231.310"><vh>setEncoding</vh></v>
<v t="edream.110203113231.311"><vh>getDefaultConfigFont CONTAINS TK CODE</vh></v>
<v t="edream.110203113231.312"><vh>createGlobalWindows</vh></v>
</v>
<v t="edream.111303085447.1"><vh>destroySelf</vh></v>
<v t="edream.110203113231.317"><vh>runMainLoop</vh></v>
<v t="edream.110203113231.306"><vh>stubs</vh>
<v t="edream.110203113231.314"><vh>finishCreate</vh></v>
<v t="edream.110203113231.315"><vh>killGui</vh></v>
<v t="edream.110203113231.316"><vh>recreateRootWindow</vh></v>
</v>
</v>
<v t="edream.111303092328.4"><vh>createLeoFrame (wxGui panels)</vh></v>
</v>
<v t="edream.110203113231.350"><vh>Birth &amp; death (wxLeoFrame)</vh>
<v t="edream.110203113231.266"><vh>__init__</vh></v>
<v t="edream.110203113231.351"><vh>__repr__</vh></v>
<v t="edream.110203113231.260"><vh>finishCreate (wxLeoFrame)</vh>
<v t="edream.110203113231.261"><vh>&lt;&lt; create the splitters &gt;&gt;</vh></v>
<v t="edream.110203113231.265"><vh>&lt;&lt; set the window icon &gt;&gt;</vh></v>
<v t="edream.110203113231.264"><vh>&lt;&lt; declare event handlers for frame &gt;&gt;</vh></v>
</v>
<v t="edream.111403141810"><vh>initialRatios</vh></v>
<v t="edream.111503105816"><vh>injectCallbacks</vh></v>
<v t="edream.111303141147"><vh>signOnWithVersion</vh></v>
<v t="edream.111503213533"><vh>destroySelf</vh></v>
</v>
<v t="edream.110203113231.540"><vh>Birth &amp; death (wxLeoBody)</vh>
<v t="edream.110203113231.541"><vh>wxLeoBody.__init__</vh></v>
<v t="edream.110203113231.542"><vh>wxLeoBody.createControl</vh></v>
</v>
</v>
<v t="edream.111403093253.1"><vh>Projects</vh>
<v t="edream.111303205442"><vh>(colorizing) (demo only)</vh>
<v t="edream.111303204025"><vh>Indices</vh>
<v t="edream.111303204025.1"><vh>adjustIndex</vh></v>
<v t="edream.111303204025.2"><vh>compareIndices</vh></v>
<v t="edream.111303204025.3"><vh>convertRowColumnToIndex</vh></v>
<v t="edream.111303204025.4"><vh>convertIndexToRowColumn</vh></v>
<v t="edream.111303204025.5"><vh>getImageIndex</vh></v>
<v t="edream.111403080609"><vh>maxWxIndex (internal use)</vh></v>
</v>
<v t="edream.111303204517"><vh>Color tags (hacks for styles)</vh>
<v t="edream.111403082513"><vh>tkColorToWxColor (internal use)</vh></v>
<v t="edream.111303205611"><vh>tag_add</vh></v>
<v t="edream.111303205611.1"><vh>tag_bind</vh></v>
<v t="edream.111303205611.2"><vh>tag_configure (hack for wxStyles)</vh></v>
<v t="edream.111303205611.3"><vh>tag_delete</vh></v>
<v t="edream.111303205611.4"><vh>tag_remove</vh></v>
</v>
</v>
</v>
<v t="edream.110203113231.242"><vh>Unused code</vh>
<v t="ekr.20050718142601.3"><vh>From wxLeoApp.OnInit</vh></v>
<v t="edream.110203113231.257"><vh>updateJoinedHeadlines</vh></v>
<v t="edream.111303202917.1"><vh>Syntax coloring REMOVED: now in base body class</vh></v>
</v>
<v t="edream.110203113231.302"><vh>@thin __wx_gui.py</vh></v>
</v>
<v t="ekr.20051109021852"><vh>Tk Notebook</vh>
<v t="leo4u.20040924131405.1"><vh>@thin Tknotebook.py</vh></v>
<v t="leo4u.20040924130601.1"><vh>@thin TabWindow.py</vh></v>
</v>
</v>
<v t="EKR.20040517075715"><vh>External editors &amp; Open With</vh>
<v t="EKR.20040517075715.1"><vh>@thin mod_tempfname.py</vh></v>
<v t="EKR.20040517080049.4"><vh>@thin open_shell.py</vh></v>
<v t="EKR.20040517075715.4"><vh>@thin open_with.py</vh></v>
<v t="EKR.20040517075715.10"><vh>@thin vim.py</vh></v>
<v t="EKR.20040517075715.12"><vh>@thin xemacs.py</vh></v>
<v t="EKR.20040517075715.13"><vh>Word export</vh>
<v t="EKR.20040517075715.14"><vh>@thin word_export.py</vh></v>
<v t="EKR.20040517075715.20" tnodeList="EKR.20040517075715.20"><vh>@file-nosent word_export.ini</vh></v>
</v>
</v>
<v t="EKR.20040517080049"><vh>Files</vh>
<v t="EKR.20040517080049.1"><vh>@thin empty_leo_file.py</vh></v>
<v t="ekr.20040419105219"><vh>@thin lineNumbers.py</vh></v>
<v t="mork.20041018204908.1"><vh>@thin multifile.py</vh></v>
<v t="ekr.20040331151007"><vh>@thin niceNosent.py</vh></v>
</v>
<v t="ekr.20050402080206"><vh>LeoN</vh>
<v t="ekr.20050402080206.1"><vh>Readme file.</vh></v>
<v t="ekr.20050402080206.2"><vh>Overview</vh>
<v t="ekr.20050402080206.3"><vh>&lt;&lt; Step four, Realtime interaction &gt;&gt;</vh>
<v t="ekr.20050402080206.4"><vh>Design notes</vh>
<v t="ekr.20050402080206.5"><vh>LeoN devellopment status III</vh></v>
<v t="ekr.20050402080206.6"><vh>LeoN devellopment status IV</vh></v>
</v>
<v t="ekr.20050402080206.7"><vh>Notes</vh></v>
</v>
</v>
<v t="ekr.20050402080206.8"><vh>@thin LeoN.py</vh></v>
</v>
<v t="EKR.20040517080555"><vh>Menus &amp; translations</vh>
<v t="ekr.20041019072632"><vh>Chinese:  Must use @file due to problems with cvs</vh>
<v t="ekr.20040828105233" tnodeList="ekr.20040828105233,ekr.20040828105233.1,ekr.20040828105233.2,ekr.20040828105233.3,ekr.20040828105233.4,ekr.20040828105233.5,ekr.20040828105233.6,ekr.20040828105233.7"><vh>@file chinese_menu.py</vh>
<v t="ekr.20040828105233.1"><vh>onMenu</vh>
<v t="ekr.20040828105233.2"><vh>file menu</vh></v>
<v t="ekr.20040828105233.3"><vh>edit menu</vh></v>
<v t="ekr.20040828105233.4"><vh>outline menu</vh></v>
<v t="ekr.20040828105233.5"><vh>plugins menu</vh></v>
<v t="ekr.20040828105233.6"><vh>window menu</vh></v>
<v t="ekr.20040828105233.7"><vh>help menu</vh></v>
</v>
</v>
</v>
<v t="EKR.20040517080202.3"><vh>@thin french_fm.py</vh></v>
<v t="EKR.20040517080555.36"><vh>@thin scripts_menu.py</vh></v>
<v t="ekr.20040828122150"><vh>@thin pie_menus.py</vh></v>
</v>
<v t="ekr.20041009112303"><vh>Plugins manager, updater &amp; menu</vh>
<v t="EKR.20040517080555.1"><vh> Plugins menu</vh>
<v t="EKR.20040517080555.2"><vh>@thin plugins_menu.py</vh></v>
<v t="EKR.20040517080555.25"><vh>@thin pluginsTest.py</vh></v>
<v t="EKR.20040517080555.32"><vh>Notes re plugins menu</vh>
<v t="EKR.20040517080555.33"><vh> Changes made by E.K.Ream</vh></v>
<v t="EKR.20040517080555.34"><vh> Design</vh></v>
<v t="EKR.20040517080555.35"><vh> Initial suggestion from Paul Paterson</vh></v>
</v>
</v>
<v t="pap.20041006184225"><vh>@thin plugin_manager.py</vh></v>
<v t="pap.20050605183206"><vh>@thin leoupdate.py</vh></v>
</v>
<v t="ekr.20041001210557"><vh>Scripting</vh>
<v t="EKR.20040613213623"><vh>@thin mod_scripting.py</vh></v>
</v>
<v t="ekr.20050111122605"><vh>Servers</vh>
<v t="EKR.20040517080250.1"><vh>@thin mod_http.py</vh></v>
</v>
<v t="edream.110203113231.930"><vh>Spell Checking</vh>
<v t="ekr.20040809151600.52"><vh>Notes for creating aspell.pyd</vh>
<v t="ekr.20040809160744"><vh>Notes: e</vh></v>
<v t="ekr.20040809161108"><vh>Notes: Gary Bishop</vh></v>
<v t="ekr.20040809151600.53"><vh>@ file aspell.pyx</vh>
<v t="ekr.20040809160744.1"><vh>spell_checker.__init__</vh></v>
<v t="ekr.20040809160744.2"><vh>check</vh></v>
<v t="ekr.20040809160744.3"><vh>suggest</vh></v>
<v t="ekr.20040809160744.4"><vh>store_replacement</vh></v>
<v t="ekr.20040809160744.5"><vh>add_to_session</vh></v>
<v t="ekr.20040809160744.6"><vh>add_to_personal</vh></v>
</v>
<v t="ekr.20040809151600.54"><vh>@ file setup.py</vh></v>
</v>
</v>
<v t="ekr.20050306081349"><vh>Text formatting</vh>
<v t="mork.20041010095009"><vh>@thin xsltWithNodes.py</vh></v>
<v t="ekr.20040331071919"><vh>Leo to AsciiDoc</vh>
<v t="ekr.20050128070307"><vh>@url http://www.marshallresearch.com/michael-dawson/os/leo.html</vh></v>
<v t="ekr.20040331071919.38"><vh>Leo 2 AsciiDoc Users Guide</vh>
<v t="ekr.20040331071919.2"><vh>About this document</vh>
<v t="ekr.20040331071919.3"><vh>License</vh>
<v t="ekr.20040331071919.4"><vh>License document</vh></v>
</v>
</v>
<v t="ekr.20040331071919.39"><vh>Installation</vh></v>
<v t="ekr.20040331071919.40"><vh>Operation</vh>
<v t="ekr.20040331071919.41"><vh>Directives</vh>
<v t="ekr.20040331071919.42"><vh>Configuration</vh></v>
</v>
<v t="ekr.20040331071919.43"><vh>Markup</vh>
<v t="ekr.20040331071919.44"><vh>Standard AsciiDoc Markup</vh>
<v t="ekr.20040331071919.45"><vh>Headings</vh></v>
<v t="ekr.20040331071919.46"><vh>Lists</vh></v>
<v t="ekr.20040331071919.47"><vh>URLs</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040331071919.1"><vh>Leo 2 AsciiDoc Developers Guide</vh>
<v t="ekr.20040331071919.2"><vh>About this document</vh>
<v t="ekr.20040331071919.3"><vh>License</vh>
<v t="ekr.20040331071919.4"><vh>License document</vh></v>
</v>
</v>
<v t="ekr.20040331071919.5"><vh>Version, Requirements</vh></v>
<v t="ekr.20040331071919.6"><vh>The General Approach</vh>
<v t="ekr.20040331071919.7"><vh>Markup Added</vh></v>
</v>
<v t="ekr.20040331071919.8"><vh>&lt;&lt; root of mod_leo2ascd.py &gt;&gt;</vh>
<v t="ekr.20040331071919.9"><vh>&lt;&lt; Key Functions &gt;&gt;</vh></v>
<v t="ekr.20040331071919.10"><vh>&lt;&lt; Declarations and Utilities &gt;&gt;</vh>
<v t="ekr.20040331071919.11"><vh>&lt;&lt; The Code -- Declarations and Utilities &gt;&gt;</vh></v>
</v>
<v t="ekr.20040331071919.12"><vh>&lt;&lt; Write the outline tree as AsciiDoc file &gt;&gt;</vh>
<v t="ekr.20040331071919.13"><vh>&lt;&lt; Write a node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040331071919.14"><vh>Other programs</vh></v>
<v t="ekr.20040331071919.15"><vh>&lt;&lt;Appendix: AsciiDoc &gt;&gt;</vh>
<v t="ekr.20040331071919.16"><vh>&lt;&lt; Configuration file &gt;&gt;</vh></v>
<v t="ekr.20040331071919.17"><vh>&lt;&lt; Patches &gt;&gt;</vh></v>
</v>
<v t="ekr.20040331071919.18"><vh>&lt;&lt;Appendix: DocBook&gt;&gt;</vh>
<v t="ekr.20040331071919.19"><vh>&lt;&lt; Tool Chain &gt;&gt;</vh></v>
<v t="ekr.20040331071919.20"><vh>&lt;&lt; Make File &gt;&gt;</vh></v>
<v t="ekr.20040331071919.21"><vh>&lt;&lt; Style Sheets &gt;&gt;</vh>
<v t="ekr.20040331071919.22"><vh>&lt;&lt; General &gt;&gt;</vh></v>
<v t="ekr.20040331071919.23"><vh>&lt;&lt; Customize &gt;&gt;</vh></v>
<v t="ekr.20040331071919.24"><vh>&lt;&lt; HTML: One File &gt;&gt;</vh></v>
<v t="ekr.20040331071919.25"><vh>&lt;&lt; HTML: Individual Pages &gt;&gt;</vh></v>
<v t="ekr.20040331071919.26"><vh>&lt;&lt; HTML: base css style sheet &gt;&gt;</vh></v>
<v t="ekr.20040331071919.27"><vh>&lt;&lt; HTML: css style sheet &gt;&gt;</vh></v>
<v t="ekr.20040331071919.28"><vh>&lt;&lt; HTML: common &gt;&gt;</vh></v>
<v t="ekr.20040331071919.29"><vh>&lt;&lt; PDF &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040331071919.30"><vh>&lt;&lt;Appendix: XEmacs Text Editor&gt;&gt;</vh>
<v t="ekr.20040331071919.31"><vh>&lt;&lt; Open_With Plugin &gt;&gt;</vh></v>
<v t="ekr.20040331071919.32"><vh>&lt;&lt; Open_Tree Plugin &gt;&gt;</vh></v>
<v t="ekr.20040331071919.33"><vh>&lt;&lt; Filename modification &gt;&gt;</vh></v>
<v t="ekr.20040331071919.34"><vh>&lt;&lt; Kill Temporary Buffers &gt;&gt;</vh></v>
<v t="ekr.20040331071919.35"><vh>&lt;&lt; MMM-mode &gt;&gt;</vh></v>
<v t="ekr.20040331071919.36"><vh>&lt;&lt; Insert indexterm &gt;&gt;</vh></v>
<v t="ekr.20040331071919.37"><vh>&lt;&lt; Indent Leo comments &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050817132814"><vh>rst3</vh>
<v t="ekr.20050817120850.1" tnodeList="ekr.20050817120850.1,ekr.20050817122915,ekr.20050822123348,ekr.20050817124859,ekr.20050817165745,ekr.20050822172321,ekr.20050817124859.1,ekr.20050817165745.1,ekr.20050818033610,ekr.20050818095347,ekr.20050819055746.1,ekr.20050820112549,ekr.20050822065754,ekr.20050822125824,ekr.20050822172321.1,ekr.20050825101903,ekr.20050818103031,ekr.20050817115636.2,ekr.20050825101321,ekr.20050818103441,ekr.20050817115636.4,ekr.20050817115636.5,ekr.20050817115636.6,ekr.20050820092312,ekr.20050817115636.8,ekr.20050817115636.9,ekr.20050817115636.7,ekr.20050820100547,ekr.20050820101355,ekr.20050820103029,ekr.20050820101522,ekr.20050820101355.1,ekr.20050820094818,ekr.20050820092312.1,ekr.20050817120850.10,ekr.20050817120850.11,ekr.20050818094118.2,ekr.20050818090152,ekr.20050818090152.1,ekr.20050817120850.98,ekr.20050817120850.99,ekr.20050817120850.94,ekr.20050817120850.95,ekr.20050817120850.96,ekr.20050817120850.108,ekr.20050817142135.1,ekr.20050817120850.143,ekr.20050817120850.144,ekr.20050817120850.141,ekr.20050817135706.1,ekr.20050817120850.157,ekr.20050817120850.158,ekr.20050818105023,ekr.20050817120850.15,ekr.20050817120850.12,ekr.20050817120850.14,ekr.20050818081715,ekr.20050819072001,ekr.20050819072001.1,ekr.20050817120850.13,ekr.20050818083045,ekr.20050821153838,ekr.20050818022030,ekr.20050818084920,ekr.20050818130249,ekr.20050818090907,ekr.20050817120850.32,ekr.20050817120850.34,ekr.20050817120850.39,ekr.20050817120850.42,ekr.20050817120850.44,ekr.20050817120850.46,ekr.20050817120850.48,ekr.20050817120850.62,ekr.20050817120850.64,ekr.20050817120850.74,ekr.20050817120850.78,ekr.20050817120850.86,ekr.20050817120850.92,ekr.20050817120850.162,ekr.20050817120850.102,ekr.20050817120850.106,ekr.20050817120850.110,ekr.20050817120850.122,ekr.20050817120850.124,ekr.20050817120850.126,ekr.20050817120850.130,ekr.20050817120850.132,ekr.20050817120850.138,ekr.20050817120850.28,ekr.20050817120850.147,ekr.20050817120850.18,ekr.20050817120850.20,ekr.20050817120850.40,ekr.20050817120850.54,ekr.20050817120850.82,ekr.20050817120850.100,ekr.20050817120850.105,ekr.20050817120850.120,ekr.20050817120850.36,ekr.20050817120850.58,ekr.20050817120850.60,ekr.20050817120850.66,ekr.20050817120850.24,ekr.20050817120850.22,ekr.20050817120850.50,ekr.20050817120850.52,ekr.20050817120850.56,ekr.20050818094118.1,ekr.20050817120850.68,ekr.20050817120850.134,ekr.20050817120850.145,ekr.20050817120850.151,ekr.20050817120850.26,ekr.20050817120850.76,ekr.20050817120850.80,ekr.20050817120850.88,ekr.20050817120850.112,ekr.20050817120850.128,ekr.20050817142135,ekr.20050817120850.153,ekr.20050817120850.155,ekr.20050817120850.30,ekr.20050817135706,ekr.20050817120850.160,ekr.20050818094954,ekr.20050818105023.1,ekr.20050817120850.84,ekr.20050817120850.90,ekr.20050818094954.1,ekr.20050817120850.165,ekr.20050817120850.116,ekr.20050817120850.70,ekr.20050817120850.72,ekr.20050817120850.164,ekr.20050817120850.114,ekr.20050817120850.118,ekr.20050817120850.149,ekr.20050817120850.159,ekr.20050817120850.140"><vh>@file leo_pdf.py</vh>
<v t="ekr.20050817122915"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050817115636.2"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050822123348"><vh>&lt;&lt; about this code &gt;&gt;</vh></v>
<v t="ekr.20050817124859"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20050817165745"><vh>&lt;&lt; version history &gt;&gt;</vh>
<v t="ekr.20050822172321"><vh>Early versions</vh>
<v t="ekr.20050817124859.1"><vh>Initial conversion</vh></v>
<v t="ekr.20050817165745.1"><vh>0.0.1</vh></v>
<v t="ekr.20050818033610"><vh>0.0.2</vh></v>
<v t="ekr.20050818095347"><vh>0.0.3</vh></v>
<v t="ekr.20050819055746.1"><vh>0.0.4</vh></v>
<v t="ekr.20050820112549"><vh>0.0.5</vh></v>
</v>
<v t="ekr.20050822065754"><vh>0.1</vh></v>
<v t="ekr.20050822125824"><vh>0.2</vh></v>
<v t="ekr.20050822172321.1"><vh>0.3</vh></v>
<v t="ekr.20050825101903"><vh>0.4</vh></v>
</v>
<v t="ekr.20050818103031"><vh>&lt;&lt; to do &gt;&gt;</vh></v>
<v t="ekr.20050825101321"><vh>init</vh></v>
<v t="ekr.20050818103441"><vh>class Bunch (object)</vh></v>
<v t="ekr.20050817115636.4"><vh>class Writer (docutils.writers.Writer)</vh>
<v t="ekr.20050817115636.5"><vh>&lt;&lt; class Writer declarations &gt;&gt;</vh></v>
<v t="ekr.20050817115636.6"><vh>__init__ (Writer)</vh></v>
<v t="ekr.20050820092312"><vh>createParagraphsFromIntermediateFile</vh></v>
<v t="ekr.20050817115636.8"><vh>createPDF_usingPlatypus</vh></v>
<v t="ekr.20050817115636.9"><vh>lower</vh></v>
<v t="ekr.20050817115636.7"><vh>translate</vh></v>
</v>
<v t="ekr.20050820100547"><vh>class dummyPDFTranslator (docutils.nodes.NodeVisitor)</vh>
<v t="ekr.20050820101355"><vh>   __init__ (dummyPDFTranslator)</vh></v>
<v t="ekr.20050820103029"><vh>as_what</vh></v>
<v t="ekr.20050820101522"><vh>encode</vh></v>
<v t="ekr.20050820101355.1"><vh>visit/depart_document</vh></v>
<v t="ekr.20050820094818"><vh>buildFromIntermediateFile</vh></v>
<v t="ekr.20050820092312.1"><vh>putParaFromIntermediateFile</vh></v>
</v>
<v t="ekr.20050817120850.10"><vh>class PDFTranslator (docutils.nodes.NodeVisitor)</vh>
<v t="ekr.20050817120850.11"><vh>   __init__ (PDFTranslator)</vh></v>
<v t="ekr.20050818094118.2"><vh>Complex</vh>
<v t="ekr.20050818090152"><vh>footnotes</vh>
<v t="ekr.20050818090152.1"><vh>footnote_reference</vh>
<v t="ekr.20050817120850.98"><vh>visit_footnote_reference</vh></v>
<v t="ekr.20050817120850.99"><vh>depart_footnote_reference</vh></v>
</v>
<v t="ekr.20050817120850.94"><vh>footnote &amp; helpers</vh>
<v t="ekr.20050817120850.95"><vh>footnote_backrefs</vh></v>
<v t="ekr.20050817120850.96"><vh>footnote_backrefs_depart</vh></v>
</v>
<v t="ekr.20050817120850.108"><vh>label</vh></v>
</v>
<v t="ekr.20050817142135.1"><vh>reference...</vh>
<v t="ekr.20050817120850.143"><vh>visit_reference</vh></v>
<v t="ekr.20050817120850.144"><vh>depart_reference</vh></v>
</v>
<v t="ekr.20050817120850.141"><vh>target</vh></v>
<v t="ekr.20050817135706.1"><vh>title</vh>
<v t="ekr.20050817120850.157"><vh>visit_title</vh></v>
<v t="ekr.20050817120850.158"><vh>depart_title</vh></v>
</v>
</v>
<v t="ekr.20050818105023"><vh>Helpers</vh>
<v t="ekr.20050817120850.15"><vh> starttag</vh></v>
<v t="ekr.20050817120850.12"><vh>as_what</vh></v>
<v t="ekr.20050817120850.14"><vh>createParagraph</vh></v>
<v t="ekr.20050818081715"><vh>dumpContext</vh></v>
<v t="ekr.20050819072001"><vh>dumpNode</vh>
<v t="ekr.20050819072001.1"><vh>&lt;&lt; define keys to be printed &gt;&gt;</vh></v>
</v>
<v t="ekr.20050817120850.13"><vh>encode</vh></v>
<v t="ekr.20050818083045"><vh>inContext</vh></v>
<v t="ekr.20050821153838"><vh>pdfMunge</vh></v>
<v t="ekr.20050818022030"><vh>push, pop, peek</vh></v>
<v t="ekr.20050818084920"><vh>putHead &amp; putTail</vh></v>
</v>
<v t="ekr.20050818130249"><vh>Simple...</vh>
<v t="ekr.20050818090907"><vh> do nothings...</vh>
<v t="ekr.20050817120850.32"><vh>authors</vh></v>
<v t="ekr.20050817120850.34"><vh>block_quote</vh></v>
<v t="ekr.20050817120850.39"><vh>caption</vh></v>
<v t="ekr.20050817120850.42"><vh>citation</vh></v>
<v t="ekr.20050817120850.44"><vh>citation_reference</vh></v>
<v t="ekr.20050817120850.46"><vh>classifier</vh></v>
<v t="ekr.20050817120850.48"><vh>colspec</vh></v>
<v t="ekr.20050817120850.62"><vh>definition_list_item</vh></v>
<v t="ekr.20050817120850.64"><vh>description</vh></v>
<v t="ekr.20050817120850.74"><vh>document</vh></v>
<v t="ekr.20050817120850.78"><vh>entry</vh></v>
<v t="ekr.20050817120850.86"><vh>field_argument</vh></v>
<v t="ekr.20050817120850.92"><vh>field_body</vh></v>
<v t="ekr.20050817120850.162"><vh>generated</vh></v>
<v t="ekr.20050817120850.102"><vh>image</vh></v>
<v t="ekr.20050817120850.106"><vh>interpreted</vh></v>
<v t="ekr.20050817120850.110"><vh>legend</vh></v>
<v t="ekr.20050817120850.122"><vh>option</vh></v>
<v t="ekr.20050817120850.124"><vh>option_argument</vh></v>
<v t="ekr.20050817120850.126"><vh>option_group</vh></v>
<v t="ekr.20050817120850.130"><vh>option_list_item</vh></v>
<v t="ekr.20050817120850.132"><vh>option_string</vh></v>
<v t="ekr.20050817120850.138"><vh>problematic</vh></v>
<v t="ekr.20050817120850.28"><vh>system_message</vh></v>
<v t="ekr.20050817120850.147"><vh>visit_row</vh></v>
</v>
<v t="ekr.20050817120850.18"><vh>admonitions...</vh>
<v t="ekr.20050817120850.20"><vh>attention</vh></v>
<v t="ekr.20050817120850.40"><vh>caution</vh></v>
<v t="ekr.20050817120850.54"><vh>danger</vh></v>
<v t="ekr.20050817120850.82"><vh>error</vh></v>
<v t="ekr.20050817120850.100"><vh>hint</vh></v>
<v t="ekr.20050817120850.105"><vh>important</vh></v>
<v t="ekr.20050817120850.120"><vh>note</vh></v>
</v>
<v t="ekr.20050817120850.36"><vh>bullet_list</vh></v>
<v t="ekr.20050817120850.58"><vh>definition</vh></v>
<v t="ekr.20050817120850.60"><vh>definition_list</vh></v>
<v t="ekr.20050817120850.66"><vh>docinfos...</vh>
<v t="ekr.20050817120850.24"><vh>address</vh></v>
<v t="ekr.20050817120850.22"><vh>author</vh></v>
<v t="ekr.20050817120850.50"><vh>contact</vh></v>
<v t="ekr.20050817120850.52"><vh>copyright</vh></v>
<v t="ekr.20050817120850.56"><vh>date</vh></v>
<v t="ekr.20050818094118.1"><vh>docinfo</vh></v>
<v t="ekr.20050817120850.68"><vh>docinfo_item</vh></v>
<v t="ekr.20050817120850.134"><vh>organization</vh></v>
<v t="ekr.20050817120850.145"><vh>revision</vh></v>
<v t="ekr.20050817120850.151"><vh>status</vh></v>
<v t="ekr.20050817120850.26"><vh>version</vh></v>
</v>
<v t="ekr.20050817120850.76"><vh>emphasis</vh></v>
<v t="ekr.20050817120850.80"><vh>enumerated_list</vh></v>
<v t="ekr.20050817120850.88"><vh>field_list</vh></v>
<v t="ekr.20050817120850.112"><vh>list_item</vh></v>
<v t="ekr.20050817120850.128"><vh>option_list</vh></v>
<v t="ekr.20050817142135"><vh>paragraph...</vh></v>
<v t="ekr.20050817120850.153"><vh>strong</vh></v>
<v t="ekr.20050817120850.155"><vh>subtitle</vh></v>
<v t="ekr.20050817120850.30"><vh>term</vh></v>
<v t="ekr.20050817135706"><vh>Text...</vh></v>
<v t="ekr.20050817120850.160"><vh>topic</vh></v>
</v>
<v t="ekr.20050818094954"><vh>Unusual...</vh>
<v t="ekr.20050818105023.1"><vh> Does not set context</vh>
<v t="ekr.20050817120850.84"><vh>field</vh></v>
<v t="ekr.20050817120850.90"><vh>field_name</vh></v>
</v>
<v t="ekr.20050818094954.1"><vh> Raises SkipNode</vh>
<v t="ekr.20050817120850.165"><vh>comment</vh></v>
<v t="ekr.20050817120850.116"><vh> literal_blocks...</vh>
<v t="ekr.20050817120850.70"><vh>doctest_block</vh></v>
<v t="ekr.20050817120850.72"><vh>line_block</vh></v>
</v>
</v>
<v t="ekr.20050817120850.164"><vh>invisible_visit</vh></v>
<v t="ekr.20050817120850.114"><vh>literal (only changes context)</vh></v>
<v t="ekr.20050817120850.118"><vh>meta (appends to self.head)</vh></v>
<v t="ekr.20050817120850.149"><vh>section</vh></v>
<v t="ekr.20050817120850.159"><vh>unimplemented_visit</vh></v>
<v t="ekr.20050817120850.140"><vh>visit_raw</vh></v>
</v>
</v>
</v>
<v t="ekr.20050805162550"><vh>@thin rst3.py</vh></v>
</v>
</v>
<v t="ekr.20050830091910"><vh>Zodb</vh>
<v t="ekr.20050825154553"><vh>@thin zodb.py</vh></v>
</v>
</v>
<v t="ekr.20060107100005" a="TV"><vh>Fixed</vh>
<v t="ekr.20040108095351"><vh>@thin rowcol.py</vh></v>
<v t="mork.20041010095009"><vh>@thin xsltWithNodes.py</vh></v>
<v t="pap.20041006184225"><vh>@thin plugin_manager.py</vh></v>
<v t="EKR.20040517080555.2"><vh>@thin plugins_menu.py</vh></v>
<v t="EKR.20040517075715.14"><vh>@thin word_export.py</vh></v>
<v t="EKR.20040517080049.4"><vh>@thin open_shell.py</vh></v>
<v t="pap.20051010170720"><vh>@thin newButtons.py</vh></v>
<v t="edream.110403140857.8"><vh>@thin color_markup.py</vh></v>
<v t="edream.110203113231.724"><vh>@thin mod_autosave.py</vh></v>
<v t="ekr.20040331153923"><vh>@thin scheduler.py</vh></v>
<v t="ekr.20040910070811.1"><vh>@thin run_nodes.py</vh></v>
<v t="ekr.20040915105758.13"><vh>@thin FileActions.py</vh></v>
<v t="edream.110203113231.669"><vh>@thin import_cisco_config.py</vh></v>
<v t="ekr.20040422072343"><vh>@thin rClick.py</vh></v>
<v t="mork.20041018131258.1"><vh>@thin groupOperations.py</vh></v>
<v t="ekr.20050328092641.4"><vh>@thin Library.py</vh></v>
<v t="mork.20041018091414.1"><vh>@thin fastGotoNode.py</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040517075110">"""Script to find and replace all functions in leoGlobals.py."""
@color
@language python
@tabwidth -4

import leoPlugins
import string

@others

if 1:
    &lt;&lt; set nameList to the list of functions in leoGlobals.py &gt;&gt;
else:
    p = g.findNodeAnywhere("@file leoGlobals.py")
    nameList = findFunctionsInTree(p)

    nameList.sort() ; g.enl()
    for name in nameList: g.es("'%s'," % name)
    
    s = "%d functions in leoGlobals.py" % len(nameList)
    print s ; g.es(s)

if 1:
    g.enl() ; g.enl()
    count = prependNamesInTree(p,nameList,"g.",replace=True) # Just prints if replace==False.
    s = "%d --- done --- " % count
    print s ; g.es(s)
</t>
<t tx="EKR.20040517075110.1">nameList = (
'alert',
'angleBrackets',
'appendToList',
'callerName',
'CheckVersion',
'choose',
'clearAllIvars',
'clear_stats',
'collectGarbage',
'computeLeadingWhitespace',
'computeWidth',
'computeWindowTitle',
'createTopologyList',
'create_temp_name',
'disableIdleTimeHook',
'doHook',
'dump',
'ecnl',
'ecnls',
'enableIdleTimeHook',
'enl',
'ensure_extension',
'es',
'esDiffTime',
'es_error',
'es_event_exception',
'es_exception',
'escaped',
'executeScript',
'file_date',
'findNodeAnywhere',
'findNodeInTree',
'findTopLevelNode',
'findReference',
'find_line_start',
'find_on_line',
'flattenList',
'funcToMethod',
'getBaseDirectory',
'getOutputNewline',
'getTime',
'get_Sherlock_args',
'get_directives_dict',
'get_leading_ws',
'get_line',
'get_line_after',
'getpreferredencoding',
'idleTimeHookHandler',
'importFromPath',
'initScriptFind',
'init_sherlock',
'init_trace',
'isUnicode',
'isValidEncoding',
'is_c_id',
'is_nl',
'is_special',
'is_ws',
'is_ws_or_nl',
'joinLines',
'listToString',
'makeAllNonExistentDirectories',
'makeDict',
'match',
'match_c_word',
'match_ignoring_case',
'match_word',
'module_date',
'openWithFileName',
'optimizeLeadingWhitespace',
'os_path_abspath',
'os_path_basename',
'os_path_dirname',
'os_path_exists',
'os_path_getmtime',
'os_path_isabs',
'os_path_isdir',
'os_path_isfile',
'os_path_join',
'os_path_norm',
'os_path_normcase',
'os_path_normpath',
'os_path_split',
'os_path_splitext',
'pause',
'plugin_date',
'plugin_signon',
'printDiffTime',
'printGc',
'printGcRefs',
'printGlobals',
'printLeoModules',
'print_bindings',
'print_stats',
'readlineForceUnixNewline',
'redirectStderr',
'redirectStdout',
'removeLeadingWhitespace',
'removeTrailingWs',
'reportBadChars',
'restoreStderr',
'restoreStdout',
'sanitize_filename',
'scanAtEncodingDirective',
'scanAtFileOptions',
'scanAtLineendingDirective',
'scanAtPagewidthDirective',
'scanAtRootOptions',
'scanAtTabwidthDirective',
'scanDirectives',
'scanError',
'scanf',
'set_delims_from_language',
'set_delims_from_string',
'set_language',
'shortFileName',
'skip_blank_lines',
'skip_block_comment',
'skip_braces',
'skip_c_id',
'skip_heredoc_string',
'skip_leading_ws',
'skip_leading_ws_with_indent',
'skip_line',
'skip_long',
'skip_matching_delims',
'skip_nl',
'skip_non_ws',
'skip_parens',
'skip_pascal_begin_end',
'skip_pascal_block_comment',
'skip_pascal_braces',
'skip_pascal_string',
'skip_php_braces',
'skip_pp_directive',
'skip_pp_if',
'skip_pp_part',
'skip_python_string',
'skip_string',
'skip_to_char',
'skip_to_end_of_line',
'skip_to_semicolon',
'skip_typedef',
'skip_ws',
'skip_ws_and_nl',
'splitLines',
'stat',
'stdErrIsRedirected',
'stdOutIsRedirected',
'toEncodedString',
'toUnicode',
'toUnicodeFileEncoding',
'top',
'trace',
'trace_tag',
'update_file_if_changed',
'utils_rename',
'windows',
'wrap_lines')</t>
<t tx="EKR.20040517075110.2">def findFunctionsInTree(p):
    
    nameList = []
    for p in p.self_and_subtree_iter():
        names = findDefs(p.bodyString())
        if names:
            for name in names:
                if name not in nameList:
                    nameList.append(name)
    return nameList</t>
<t tx="EKR.20040517075110.3">def findDefs(body):
    
    lines = body.split('\n')
    names = []
    for s in lines:
        i = g.skip_ws(s,0)
        if g.match(s,i,"class"):
            return [] # The classes are defined in a single node.
        if g.match(s,i,"def"):
            i = g.skip_ws(s,i+3)
            j = g.skip_c_id(s,i)
            if j &gt; i:
                name = s[i:j]
                if g.match(name,0,"__init__"): 
                    return [] # Disallow other class methods.
                names.append(name)
    return names</t>
<t tx="EKR.20040517075110.4">def prependNamesInTree(p,nameList,prefix,replace=False):
    
    c = p.c
    
    assert(len(prefix) &gt; 0)
    ch1 = string.letters + '_'
    ch2 = string.letters + string.digits + '_'
    def_s = "def " ; def_n = len(def_s)
    prefix_n = len(prefix)
    total = 0
    c.beginUpdate()
    for p in p.self_and_subtree_iter():
        count = 0 ; s = p.bodyString()
        printFlag = False
        if s:
            for name in nameList:
                i = 0 ; n = len(name)
                while 1:
                    &lt;&lt; look for name followed by '(' &gt;&gt;
            if count and replace:
                if 0:
                    &lt;&lt; print before and after &gt;&gt;
                p.setBodyStringOrPane(s)
                p.setDirty()
        g.es("%3d %s" % (count,p.headString()))
        total += count
    c.endUpdate()
    return total</t>
<t tx="EKR.20040517075110.5">i = s.find(name,i)
if i == -1:
    break
elif g.match(s,i-1,'.'):
    i += n # Already an attribute.
elif g.match(s,i-prefix_n,prefix):
    i += n # Already preceded by the prefix.
elif g.match(s,i-def_n,def_s):
    i += n # preceded by "def"
elif i &gt; 0 and s[i-1] in ch1:
    i += n # Not a word match.
elif i+n &lt; len(s) and s[i+n] in ch2:
    i += n # Not a word match.
else:
    j = i + n
    j = g.skip_ws(s,j)
    if j &gt;= len(s) or s[j] != '(':
        i += n
    else: # Replace name by prefix+name
        s = s[:i] + prefix + name + s[i+n:]
        i += n ; count += 1
        # g.es('.',newline=False)
        if 1:
            if not printFlag:
                printFlag = True
                # print p.headString()
            print g.get_line(s,i-n)</t>
<t tx="EKR.20040517075110.6">print "-"*10,count,p.headString()
print "before..."
print p.bodyString()
print "-"*10,"after..."
print s</t>
<t tx="EKR.20040517075715"></t>
<t tx="EKR.20040517075715.13"></t>
<t tx="EKR.20040517075715.20">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading

</t>
<t tx="EKR.20040517080049"></t>
<t tx="EKR.20040517080555"></t>
<t tx="EKR.20040517080555.1"></t>
<t tx="EKR.20040517080555.32">@nocolor</t>
<t tx="EKR.20040517080555.33">Reorganized the code so I can find various classes more easily.
Used @others to simply the outline.

Sorted all entries in dialogs.
Sorted all entries in Plugins menu, regardless of whether they are configurable.

For all dialogs:
    Added top ivar and removed root/master params and ivars.
    Added Leo icon and title.
    Centered dialogs.

Ctors now run all dialogs as modal dialogs: this could easily be undone.

Used a grid in the properties dialog to align widgets.</t>
<t tx="EKR.20040517080555.34">- We will use a new settings file called leoSettings.txt:
- Each setting will have its _own section_ in leoSettings.txt with the following items (most optional)
    val = present value of settings: Use parent setting if this does not exist.
    help = help string (displayed near setting if it exists)
    prompt = prompt string (defaults to setting name, i.e., the section name)
    group = name of group dialog containing this item (use general section if this does not exist)
    type = one of the following:
        value			meaning
        bool			followed by True/False prompts for radio buttons
        color			color picker
        font			font picker
        parent			name of parent config file (set/get setting in that file)
        entry			followed by arbitrary text in an entry widget
        text			followed by arbitrary text in a text widget
        number			any number, or followed by a range of valid values for an entry widget.
        numberlist  followed by a list valid values for a listbox.
        list			followed by a list of valid strings in a listbox.
Notes:
- We could use yaml or ConfigParser or Pickle.  yaml might be best.
- The options dialog will have a separate frame for each group or subgroup.
- We will want a Create Options file command (useful for converting old leoConfig.txt files)
- All options may have a use parent settings (for all widgets?)
- The separate "Groups" section may indicate which groups are subgroups of other groups for multi-level displays.</t>
<t tx="EKR.20040517080555.35">I wrote myself a plug-in which would automatically save the Leo file every so often and in doing so realized that it would be useful to be able to configure the interval between saves. Anyway, to cut a long story short, I generalized the idea and came up with the attached patch. 
 
All code resides under the "Plug in changes" node. The additions are all under the "create the plug-in menu" node with another couple of lines in "createMenuBar". Structurally this is ugly - but it helps keep all the changes in one place!
 
The basic idea is to allow plug-ins to be configured and also allow them to expose additional functions which can be accessed by a menu item. The advantage is that people don't have to mess with adding menus to Leo. Existing plug-ins don't need to be changed in any way to work with the new patch.
 
Ok, here's what it does	
 
1. A new "Plug-ins" menu item is added
 
2. Each plug-in gets an "About x	" entry.
 
    - clicking on "About x..." brings up an about box which shows name, version and documentation for the plug in
    - name comes from the module name
    - version is the module __version__ if present
    - documentation is the module docstring 
 
3. If the plug-in is configurable then a sub menu is created
 
    - configurable means that a corresponding ".ini" file is found with the same names as the plug-in (ie mod_image.py has mod_image.ini)
    - the sub menu contains
        - the "About x..." as before
        - a "Properties..." menu entry to edit the properties (*)
 
4. A further search is made for plug-in specific commands
 
    - we look for functions called "cmd_*" in the module
    - if found we add them to the plug-in menu
    - when you click on the menu item the function is called with a single parameter
 
(*) How does the property window work,
 
5. The property window reads the ini file which is assumed to be in standard ini file format (ie sections and parameters)
    - each section gets a frame in the window
    - each property gets an entry box
 
6. From the property window the user can "Cancel" or "OK", which saves changes
 
7. If the module contains an "applyConfiguration" function then there is also an "Apply" button on the form. The apply configuration function is called with the current configuration when the "Apply" button is pressed.
</t>
<t tx="EKR.20040517090508">@nocolor

Leo enables those plugins whose filenames appear anywhere in this file without comments.

Warning: make sure plugins appear at most once without comments. Otherwise,
disabling a plugin in the Plugins Manageger plugin will have no effect.

Leo loads plugins in the order they appear in this file.

File names may be indented as desired.

@color</t>
<t tx="EKR.20040605181725"></t>
<t tx="EKR.20040605181725.1">@nocolor</t>
<t tx="EKR.20040608070256">The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.</t>
<t tx="EKR.20040608070256.1">The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word(     ) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.</t>
<t tx="EKR.20040611044600"></t>
<t tx="bwmulder.20040601212737">"""
Define a general purpose monitor module.

Can be used for classes derived from "object" to intercept assignment to instance attributes.

For lists and dictionaries, it also offers drop-in replacements which monitor all changes to those list and mappings.

This module also includes a basic undo / redo mechanism.

For this undo / redo mechanism, it is important that the undo / redo steps do not trigger any monitoring calls. 
This module should fullfill that requirement.

For scalars, we put "scalar_monitor" into the attribute slot to intercept accesses to the attribute. The values
themselves live in a differnt, "private" attribute. These private attributes are accessed directly for the
undo / redo steps.

For dictionaries and lists, we extend the base types. The undo / redo mechanism 
uses the methods of the basic type.

If you assign a list or a dictionary to a monitored attribute, the list or mapping is automatically converted to
a monitored list or mapping (but only one level deep).

[Question: do we need a convenience function which does this recursively?]
"""

@language python
@tabwidth -4

@others
</t>
<t tx="bwmulder.20040601212737.1">class passthrough(object):
    """
    Instances of this class are used to disable monitoring.
    The values are just passed through.
    """
    @others

</t>
<t tx="bwmulder.20040601212737.2">def __init__(self, private_attributename):
   self.private_attributename = private_attributename
</t>
<t tx="bwmulder.20040601212737.3">def __set__( self, instance, value):
   setattr(instance, self.private_attributename, value)
</t>
<t tx="bwmulder.20040601212737.4">def __get__(self, instance, owner):
   return getattr(instance, self.private_attributename)
</t>
<t tx="bwmulder.20040601212737.5">   
class scalar_monitor(object):
    """
   Monitor a scalar attribute.
   A scalar attribute is an attribute whose values do not have internal structure.
   Used for Integers and references.
    """
    @others
</t>
<t tx="bwmulder.20040601212737.6">def __init__(self, external_attributename, monitor_object):
    self.external_attributename = external_attributename
    self.private_attributename = '__' + external_attributename
    self.monitor_object = monitor_object
</t>
<t tx="bwmulder.20040601212737.7">def __set__( self, instance, value):
    private_attributename = self.private_attributename
    external_attributename = self.external_attributename
    try:
        oldvalue = getattr(instance, private_attributename)
    except AttributeError:
        self.monitor_object.scalar_set(instance, private_attributename, external_attributename)
    else:
        if oldvalue != value:
            self.monitor_object.scalar_modify(instance, private_attributename, external_attributename, oldvalue)
    setattr(instance, private_attributename, value)

</t>
<t tx="bwmulder.20040601212737.8">def __get__(self, instance, owner):
   return getattr(instance, self.private_attributename)

</t>
<t tx="bwmulder.20040601212737.9">class list_monitor(list):
    """
    Monitor changes to a list.
    
    Calls a "monitor_object" whenever changes are made to a list.
    
    You can use this class whenever you want to track changes to a list.
    """
    @others
</t>
<t tx="bwmulder.20040601212737.10">def set_monitor_object(self, monitor_object):
    """
    All changes to this list will trigger calls to monitor_object methods
    """
    self.monitor_object = monitor_object

</t>
<t tx="bwmulder.20040601212737.11">def __setitem__( self, key, value):
    """
    Intercept the l[key]=value operations.
    Also covers slice assignment.
    """
    try:
        oldvalue = self.__getitem__(key)
    except KeyError:
        self.monitor_object.list_create(self, key)
    else:
        self.monitor_object.list_set(self, key, oldvalue)
    list.__setitem__(self, key, value)
</t>
<t tx="bwmulder.20040601212737.12">def __delitem__( self, key):
   oldvalue = list.__getitem__(self, key)
   self.monitor_object.list_del(self, key, oldvalue)
   list.__delitem__(self, key)
</t>
<t tx="bwmulder.20040601212737.13">def append(self, value):
   self.monitor_object.list_append(self)
   list.append(self, value)


</t>
<t tx="bwmulder.20040601212737.14">class list_monitor_in_instance(object):
    """
    Monitor instance attributes which contain a list as a value.

    Assignments to this attributes, which must be lists, are replaced by instances of 'list_monitor'.
   """
    @others
</t>
<t tx="bwmulder.20040601212737.15">def __init__(self, external_attributename, monitor_object):
    self.external_attributename = external_attributename
    self.internal_attributename = '__' + external_attributename
    self.monitor_object = monitor_object
</t>
<t tx="bwmulder.20040601212737.16">def __set__(self, instance, value):
    """Intercept assignments to the external attribute"""
    assert isinstance(value, type([]))
    if isinstance(value, list_monitor):
        newvalue = value
        # if the value is already a list monitor, assume that this value
        # is already monitored. Do not create a new value.
    else:
        newvalue = list_monitor(value, self.monitor_object)
    internal_attributename = self.internal_attributename
    try:
        oldvalue = getattr(instance, internal_attributename)
    except AttributeError:
        self.monitor_object.list_assignment_new(instance, internal_attributename)
    else:
        self.monitor_object.list_assignment_replace(instance, internal_attributename, oldvalue)
    setattr(instance, self.internal_attributename, newvalue)

</t>
<t tx="bwmulder.20040601212737.17">def __get__(self, instance, owner):
   try:
      return instance.__dict__[self.internal_attributename]
   except KeyError: 
      return instance.__dict__[self.external_attributename]

</t>
<t tx="bwmulder.20040601212737.18">class monitor:
    """
   Monitor changes to (new style) classes.

   To use:
      1. 
            a) Call monitor_scalar(klass, external_attributename, internal_attributename)
                    for each scalar attribute you want to monitor.

                A scalar attribute is an attribute without internal structure (int and reference).

                The normal Python comparison operation (=) is used to check if a new value is stored
                in an instance attribute.
                
            b) Call monitor_list(klass, external_attributename, internal_attributename) for each
               list attribute you want to monitor.
                
           c) Call monitor_dict(klass, external_attributename, internal_attributename) for each
               dict attribute you want to monitor.
         
      2. 
            Call enable / disable to enable / disable monitoring.

   This is an abstract class.
   
   Concrete subclasses are the classes "tracer" and "basic_undomechanism". The latter does most
   (almost all) of the work of a (fairly) general undo mechanism.

   Limitations:
   
      Assumes that instance attributes are used consistently with certain types.
      
   """
    @others
</t>
<t tx="bwmulder.20040601212737.19">def __init__(self):
   self.monitored_scalar_attributes = []
   self.monitored_list_attributes = []
   self.monitored_dict_attributes = []
   self.removed_functions = []
   
   self.monitor_object = self
   # See enable_category.
   
   # Overwriting this one attribute allows
   # Clients of this module to implemente tracing of all
   # calls to this module.
   
</t>
<t tx="bwmulder.20040601212737.20">def monitor_scalar(self, klass, external_attributename):
   """
   Put in a hook so that we can monitor modications to instances of classref'
   with respect to the attribute "attributename".

   It is assumed that the attribute only contains scalar objects. A scalar
   object is an object which is unstructured, and not shared.
   """
   self.monitored_scalar_attributes.append(
      (klass, external_attributename))
</t>
<t tx="bwmulder.20040601212737.21">def monitor_list_attribute_in_class(self, klass, external_attributename):
   self.monitored_list_attributes.append(
      (klass, external_attributename))
</t>
<t tx="bwmulder.20040601212737.22">def enable(self):
    for l, klass in ((self.monitored_scalar_attributes, scalar_monitor),
             (self.monitored_list_attributes, list_monitor_in_instance),
             (self.monitored_dict_attributes, dict_monitor_in_instance)):
        self.enable_category(l, klass)
        
    self.enable_put_in_removed_functions()
    

</t>
<t tx="bwmulder.20040601212737.23">def disable(self):
    """
    Disable monitoring (temporarily).
    """
    for l, klass in ((self.monitored_scalar_attributes, scalar_monitor),
                     (self.monitored_list_attributes, list_monitor_in_instance),
                     (self.monitored_dict_attributes, dict_monitor_in_instance)):
        self.disable_category(l, klass)
    
    self.remove_overrides_in_list_and_dict_monitor()
    
</t>
<t tx="bwmulder.20040601212737.24">def scalar_set(self, instance, private_attributename, external_attributename):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.25">def scalar_modify(self, instance, private_attributename, external_attributename, oldvalue):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.26">def list_create(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.27">def list_set(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.28">def list_del(self, array, key, oldvalue):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.29">def list_append(self, array, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601214251"></t>
<t tx="bwmulder.20040601215339"></t>
<t tx="bwmulder.20040601215339.1">@doc
Delayed activation of the monitor mechanism is probably useful.

Not clear of switching off and on is useful, though.</t>
<t tx="bwmulder.20040601222230">class basic_undomechanism(monitor):
    """
    This class provides the basic operations for undoable operations.
    
    Records a list of changes which it will undo or redo one by one.
    
    The granularity of the undo / redo operations is determined by calls to
    the 'mark' procedure. Only immediately after the 'mark' call can undo be called.
    Redo can only be called after calling undo.
    
    'rollback' is a special case of undo: it is not redoable. The envisioned usage of
    this facility is in error recovery: if a command does not go through, you can call
    this command to undo all your changes (and leave the application in a consistent state).
    
    Uses the monitor_scalar, monitor_list_attribute_in_class and monitor_dict_attribute_in_class
    methods to make assignment to instance variables undoable.
    
    Call 'enable' to activate the undo mechanism, 'disable' to temporarily
    stop the undo mechanism from collecting information about changes.
    
    The individual changes are bundled into "_commands'. The boundaries of
    these _commands are marked by a call to the procedure "mark".
    
    The procedure 'reset' can be called externally to erase all undo information.
    
    Individual lists and dictionaries can also be monitored for change with the
    list_monitor and dict_monitor classes.
    
    Possible optimizations later: special handling for string attributes.
    """
    @others</t>
<t tx="bwmulder.20040601222230.1">def __init__(self):

    monitor.__init__(self)
    self.reset()
    </t>
<t tx="bwmulder.20040601222230.2"></t>
<t tx="bwmulder.20040601222230.3">def scalar_set(self, instance, private_attributename, external_attributename):
   self._steps.append((self.scalar_set_undo, (instance, private_attributename)))
    

</t>
<t tx="bwmulder.20040601222230.4">def scalar_set_undo(self, instance, private_attributename):

    """Undo the changes done by the assignment of an instance"""
    newvalue = getattr(instance, private_attributename)
    delattr(instance, private_attributename)
    return self.scalar_set_redo, (instance, private_attributename, newvalue)
</t>
<t tx="bwmulder.20040601222230.5">def scalar_set_redo(self, instance, private_attributename, newvalue):

    setattr(instance, private_attributename, newvalue)
    return self.scalar_set_undo, (instance, private_attributename)
</t>
<t tx="bwmulder.20040601222230.6">def scalar_modify(self, instance, private_attributename, external_attributename, oldvalue):

  self._steps.append((self.scalar_modify_undo, (instance, private_attributename, oldvalue)))
</t>
<t tx="bwmulder.20040601222431">def scalar_modify_undo(self, instance, private_attributename, oldvalue):

    new_value = getattr(instance, private_attributename)
    setattr(instance, private_attributename, oldvalue)
    return self.scalar_modify_undo, (instance, private_attributename, new_value)</t>
<t tx="bwmulder.20040601222649">def run_commands(self, steps):
    
    """
    Run the undo / redo _steps.
    Returns the list of steps to redo / undo the steps just made.
    """

    steps.reverse()
    return [func(*args) for func, args in steps]
</t>
<t tx="bwmulder.20040601224447"></t>
<t tx="bwmulder.20040601224447.2">def mark(self):
    
    """Mark the end of the current commmand."""

    if self._steps:
        self._commands[self._index+1:] = [self._steps, None]
        self._index += 1
        self._steps = []</t>
<t tx="bwmulder.20040601224447.3">def undo(self):

    assert self.canUndo()
    self._commands[self._index] = self.run_commands(self._commands[self._index])
    self._index -= 1
    
</t>
<t tx="bwmulder.20040601224447.4">def redo(self):

    assert self.canRedo()
    self._commands[self._index+1] = self.run_commands(self._commands[self._index+1])
    self._index += 1</t>
<t tx="bwmulder.20040601224447.5">def canUndo(self):
    
    return self._commands[self._index] is not None and len(self._steps) == 0
</t>
<t tx="bwmulder.20040601224447.6">def canRedo(self):
    return self._commands[self._index+1] is not None and len(self._steps) == 0</t>
<t tx="bwmulder.20040602075341"></t>
<t tx="bwmulder.20040602075341.1">def list_create(self, array, key):
    self._steps.append((self.list_create_undo, (array, key)))

</t>
<t tx="bwmulder.20040602084701.1"></t>
<t tx="bwmulder.20040602084701.2">def list_create_undo(self, array, key):
    value = list.__getitem__(array, key)
    list.__delitem__(array, key)
    return self.list_create_redo, (array, key, value)

</t>
<t tx="bwmulder.20040602084701.3">def list_create_redo(self, array, key, value):
    list.__setitem__(array, key, value)
    return self.list_create_undo, (array, key)</t>
<t tx="bwmulder.20040602084701.4"></t>
<t tx="bwmulder.20040602085955">def list_set(self, array, key, oldvalue):
    self._steps.append((self.list_set_undo, (array, key, oldvalue)))

</t>
<t tx="bwmulder.20040602085955.1">def list_set_undo(self, array, key, value):
    oldvalue = list.__getitem__(array, key)
    list.__setitem__(array, key, value)
    return self.list_set_undo, (array, key, oldvalue)
</t>
<t tx="bwmulder.20040602085955.2"></t>
<t tx="bwmulder.20040602085955.3">def list_del(self, array, key, oldvalue):
   self._steps.append((self.list_del_undo, (array, key, oldvalue)))
   
</t>
<t tx="bwmulder.20040602085955.4">def list_del_undo(self, array, key, oldvalue):
    if type(key) == type(1):
        list.__setitem__(array, slice(key, key), [oldvalue])
    else:
        list.__setitem__(array, key, oldvalue)
    return self.list_del_redo, (array, key, oldvalue)
</t>
<t tx="bwmulder.20040602085955.5">def list_del_redo(self, array, key, oldvalue):
    oldvalue = list.__getitem__(array, key)
    list.__delitem__(array, key)
    return self.list_del_undo, (array, key, oldvalue)
</t>
<t tx="bwmulder.20040602151709"></t>
<t tx="bwmulder.20040602152051">def list_append(self, array):
    self._steps.append((self.list_append_undo, (array,)))
    


</t>
<t tx="bwmulder.20040602152051.1">def list_append_undo(self, array):
    oldvalue = list.pop(array)
    return self.list_append_redo, (array, oldvalue)
</t>
<t tx="bwmulder.20040602152051.2">def list_append_redo(self, array, oldvalue):
    list.append(array, oldvalue)
    return self.list_append_undo, (array,)</t>
<t tx="bwmulder.20040602152548">def pop(self):
    oldvalue = list.pop(self)
    self.monitor_object.list_pop(self, oldvalue)
</t>
<t tx="bwmulder.20040602152548.1"></t>
<t tx="bwmulder.20040602152548.2">def list_pop(self, array, oldvalue):
    self._steps.append((self.list_append_redo, (array, oldvalue)))
</t>
<t tx="bwmulder.20040602153618">class dict_monitor(dict):
    """
    Overwrite dictionaries so that we can monitor them.
    """
    @others
</t>
<t tx="bwmulder.20040602153642">def set_monitor_object(self, monitor_object):
    """
    All changes to this dictionary will trigger calls to monitor_object methods
    """
    self.monitor_object = monitor_object

</t>
<t tx="bwmulder.20040602153723">def __setitem__( self, key, value):
    """
    Intercept the l[key]=value operations.
    Also covers slice assignment.
    """
    try:
        oldvalue = self.__getitem__(key)
    except KeyError:
        self.monitor_object.dict_create(self, key, value)
    else:
        self.monitor_object.dict_set(self, key, oldvalue)
    dict.__setitem__(self, key, value)
</t>
<t tx="bwmulder.20040602153835">def __delitem__( self, key):
   oldvalue = dict.__getitem__(self, key)
   self.monitor_object.dict_del(self, key, oldvalue)
   dict.__delitem__(self, key)
</t>
<t tx="bwmulder.20040602154259">class dict_monitor_in_instance(object):
    """
    Monitor instance attributes which contain a list as a value.

    Assignments to this attributes, which must be lists, are replaced by instances of 'list_monitor'.
   """
    @others
</t>
<t tx="bwmulder.20040602154259.1">def __init__(self, external_attributename, monitor_object):
    self.external_attributename = external_attributename
    self.internal_attributename = '__' + external_attributename
    self.monitor_object = monitor_object
</t>
<t tx="bwmulder.20040602154259.2">def __set__(self, instance, value):
    """Intercept assignments to the external attribute"""
    assert isinstance(value, type({}))
    if isinstance(value, dict_monitor):
        newvalue = value
        # if the value is already a dict_monitor,
        # assume that the value is already monitored.
    else:
        newvalue = dict_monitor(value, self.monitor_object)
    internal_attributename = self.internal_attributename
    try:
        oldvalue = getattr(instance, internal_attributename)
    except AttributeError:
        self.monitor_object.list_assignment_new(instance, internal_attributename)
    else:
        self.monitor_object.list_assignment_replace(instance, internal_attributename, oldvalue)
    setattr(instance, self.internal_attributename, newvalue)
</t>
<t tx="bwmulder.20040602154259.3">def __get__(self, instance, owner):
   try:
      return instance.__dict__[self.internal_attributename]
   except KeyError: 
      return instance.__dict__[self.external_attributename]

</t>
<t tx="bwmulder.20040602154259.4">def enable_category(self, l, monitor_class):
   for klass, external_attributename in l:
      setattr(klass, external_attributename, monitor_class(
         external_attributename, self.monitor_object))
    </t>
<t tx="bwmulder.20040602161525">def disable_category(self, l, monitor_class):
   for klass, external_attributename in l:
      setattr(klass, external_attributename, passthrough (internal_attributename))
    
</t>
<t tx="bwmulder.20040602164627">def enable_put_in_removed_functions(self):
    """
    Reinstate the functions which were removed from list_monitor and dict_monitor.
    """
    for klass, attribute, function in self.removed_functions:
        setattr(klass, attribute, function)
</t>
<t tx="bwmulder.20040602165344"></t>
<t tx="bwmulder.20040602165402">def monitor_dict_attribute_in_class(self, klass, external_attributename):
   self.monitored_dict_attributes.append(
      (klass, external_attributename))
</t>
<t tx="bwmulder.20040602165506">def dict_create(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040602165513">def dict_set(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040602165553">def dict_del(self, array, key, oldvalue):
   raise notImplementedError
</t>
<t tx="bwmulder.20040602171032"></t>
<t tx="bwmulder.20040602171032.1"></t>
<t tx="bwmulder.20040602171032.2">def dict_create(self, dictionary, key, value):
    self._steps.append((self.dict_create_undo, (dictionary, key)))

</t>
<t tx="bwmulder.20040602171032.3">def dict_create_undo(self, dictionary, key):
    value = dict.__getitem__(dictionary, key)
    dict.__delitem__(dictionary, key)
    return self.dict_create_redo, (dictionary, key, value)

</t>
<t tx="bwmulder.20040602171032.4">def dict_create_redo(self, dictionary, key, value):
    dict.__setitem__(dictionary, key, value)
    return self.dict_create_undo, (dictionary, key,)
</t>
<t tx="bwmulder.20040602171032.5"></t>
<t tx="bwmulder.20040602171032.6">def dict_set(self, dictionary, key, oldvalue):
    self._steps.append((self.dict_set_undo, (dictionary, key, oldvalue)))

</t>
<t tx="bwmulder.20040602171032.7">def dict_set_undo(self, dictionary, key, value):
    oldvalue = dict.__getitem__(dictionary, key)
    dict.__setitem__(dictionary, key, value)
    return self.dict_set_undo, (dictionary, key, oldvalue)
</t>
<t tx="bwmulder.20040602171032.8"></t>
<t tx="bwmulder.20040602171032.9">def dict_del(self, dictionary, key, oldvalue):
   self._steps.append((self.dict_del_undo, (dictionary, key, oldvalue)))
   
</t>
<t tx="bwmulder.20040602171032.10">def dict_del_undo(self, dictionary, key, oldvalue ):
    dict.__setitem__(dictionary, key, oldvalue)
    return self.dict_del_redo, (dictionary, key, oldvalue)
</t>
<t tx="bwmulder.20040602171032.11">def dict_del_redo(self, dictionary, key, oldvalue ):
    oldvalue = dict.__getitem__(dictionary, key)
    dict.__delitem__(dictionary, key)
    return self.dict_del_undo, (dictionary, key, oldvalue)
</t>
<t tx="bwmulder.20040602171606">def reset(self):

    self._steps = []
    self._commands = [None, None]
    self._index = 0
    


</t>
<t tx="bwmulder.20040602175523">def list_assignment_replace(self, instance, attributename, oldvalue):
    self._steps.append((self.list_assignment_replace_undo, (instance, attributename, oldvalue)))</t>
<t tx="bwmulder.20040602175523.1">def list_assignment_replace_undo(self, instance, attributename, oldvalue):
    newvalue = getattr(instance, attributename)
    setattr(instance, attributename, oldvalue)
    return self.list_assignment_replace_redo, (instance, attributename, newvalue)</t>
<t tx="bwmulder.20040602175740">def list_assignment_replace_redo(self, instance, attributename, newvalue):
    oldvalue = getattr(instance, attributename)
    setattr(instance, attributename, newvalue)
    return self.list_assignment_replace_undo, (instance, attributename, oldvalue)
</t>
<t tx="bwmulder.20040602175801"># Dictionary monitors are are really handled like
# list monitors.
# For now, just use the same methods.
dict_assignment_new = list_assignment_new
dict_assignment_new_undo = list_assignment_new_undo
dict_assignment_new_redo = list_assignment_new_redo

dict_assignment_replace      = list_assignment_replace
dict_assignment_replace_undo = list_assignment_replace_undo
dict_assignment_replace_redo = list_assignment_replace_redo</t>
<t tx="bwmulder.20040602183806">def list_assignment_new(self, instance, attributename):
    self._steps.append((self.list_assignment_new_undo, (instance, attributename)))</t>
<t tx="bwmulder.20040602183814">def list_assignment_new_undo(self, instance, attributename):
    newvalue = getattr(instance, attributename)
    delattr(instance, attributename)
    return self.list_assignment_new_redo, (instance, attributename, newvalue)</t>
<t tx="bwmulder.20040602183911">def list_assignment_new_redo(self, instance, attributename, newvalue):
    setattr(instance, attributename, newvalue)
    return self.list_assignment_new_undo, (instance, attributename)
</t>
<t tx="bwmulder.20040602221559">&lt;&lt; imports &gt;&gt;

undo_tracing = False

@others

if __name__ == '__main__':
    test_main()</t>
<t tx="bwmulder.20040602223236">from basic_undo import monitor, basic_undomechanism, list_monitor, dict_monitor
import unittest
from test import test_support
</t>
<t tx="bwmulder.20040602223236.1">class tracer(monitor):
    
    # The output format could be improved, but this is only for testing.
    """Simple class which can be used to trace all calls made from a monitor."""

    @others

</t>
<t tx="bwmulder.20040602223236.2">def __getattr__(self, attributename):
    self.attributename = attributename
    return self.catchall</t>
<t tx="bwmulder.20040602223906">def catchall(self, *args, **kwrds):

    print "Tracer:", self.attributename, ":", args, kwds</t>
<t tx="bwmulder.20040602224231">class delegator(object):
    """
    Simple class to print all arguments passed to a monitor.
    Allows you to watch the undoer in action...
    """
    @others</t>
<t tx="bwmulder.20040602224332">def __getattr__(self, attributename):
    self.attributename = attributename
    return self.catchall</t>
<t tx="bwmulder.20040602224413">def __init__(self):
    
    self.undoer = basic_undomechanism()
    self.undoer.monitor_object = self
    

</t>
<t tx="bwmulder.20040602225640">class basic_scalar_test_class(object):
    """Simple class for the basic_scalar_test"""
    pass

class basic_scalar_test(unittest.TestCase):
    @others</t>
<t tx="bwmulder.20040602230124">def test_scalar_basic(self):
    """
    Some basic testing for the scalar undoer.
    """
    if undo_tracing:
        self.m = m = delegator()
    else:
        self.m = m = basic_undomechanism()
    m.monitor_scalar(basic_scalar_test_class, "x")
    m.enable()
    # command 1
    c = basic_scalar_test_class()
    c.x = "First value"
    m.mark()
    # command 2	
    c.x = "second value"
    m.mark()
    # command 3
    c.x = "third value"
    m.mark()
    # command 4
    # Check that the second assignment can be undone
    assert c.x == "third value", c.x
    m.undo()
    # command 2
    assert c.x == "second value"
    m.undo()
    # command 1
    assert c.x == "First value", c.x
    m.undo()
    assert not hasattr(c, "x")
</t>
<t tx="bwmulder.20040602230426">def test_main():

    test_support.run_unittest(
        basic_scalar_test,
        basic_list_test,					
        basic_dict_test)</t>
<t tx="bwmulder.20040602231914">def catchall(self, *args, **kwrds):
    print "delegator:", self.attributename, ":", args, kwrds
    getattr(self.undoer, self.attributename) (*args, **kwrds)
</t>
<t tx="bwmulder.20040602231934">def enable_category(self, l, monitor_class):
    
   for klass, external_attributename, internal_attributename in l:
      setattr(klass, external_attributename, monitor_class(
         external_attributename, internal_attributename, self))
    

</t>
<t tx="bwmulder.20040603081718">def remove_overrides_in_list_and_dict_monitor(self):
    """
    Deletes all function definitions in list_monitor and dict_monitor.
    The net effect of this is that instances of these classes should
    behave like regular lists and dictionaries.
    """	
    import inspect
    for klass in (list_monitor, dict_monitor):
        for attribute in dir(klass):
            try:
                entity = getattr(klass, attribute)
            except AttributeError:
                pass
            else:
                if inspect.isfunction(entity):
                    delattr(klass, attribute)
                    self.removed_functions.append(klass, attribute, entity)</t>
<t tx="bwmulder.20040603211921"></t>
<t tx="bwmulder.20040603212552">def commands(self):

    return len(self._commands) - 2</t>
<t tx="bwmulder.20040603212612">def commands_to_undo(self):

    return self._index</t>
<t tx="bwmulder.20040603212713">def commands_to_redo(self):
    return self.commands() - self._index</t>
<t tx="bwmulder.20040603212934">def rollback(self):

    self.run_commands(self._steps)
</t>
<t tx="bwmulder.20040604165011">def steps_stored(self):
    """
    Return the total number of steps stored in the undoer.
    """
    result = 0
    for command in self._commands[1:-1]:
        result += len(command)
    return result</t>
<t tx="bwmulder.20040604184443">def test_linked_list(self):
    """
    Shows that the basic undo mechanism can be used to undo the construction of a linked list.
    """
    if undo_tracing:
        self.m = m = delegator()
    else:
        self.m = m = basic_undomechanism()

    # Create a linked list and check that the link operations can be undone.
    class root_class(object):
        pass
        
    class x(object):
        def __init__(self, name, next=None):
            self.name = name
            self.next = next
    
    def p(root):
        result = []
        r = root.root
        while r:
            result.append(r.name)
            r = r.next
        return result
            
    undoer = basic_undomechanism()
    
    m.monitor_scalar(root_class, "root")
    m.monitor_scalar(x, "name")
    m.monitor_scalar(x, "next")
    m.enable()
    
    root = root_class()
    root.root = x("first")
    root.root.next = x("second")
    m.mark()
    root.root.next.next = x("third")
    root.root.next.next.next = x("fourth")
    m.mark()
    assert p(root) == ["first", "second", "third", "fourth"]
    m.undo()
    assert  p(root) == ["first", "second"]
    m.redo()
    assert p(root) ==["first", "second", "third", "fourth"]
    
    # now try a few things with dictionaries.
    m.monitor_dict_attribute_in_class(root_class, "d")
    m.enable()
    root.d = {}
    m.mark()
    root.d = {'Some dict': 1}
    m.mark()
    root.d[1] = 2
    assert root.d == {'Some dict': 1, 1: 2}, root.d
    m.mark()
    m.undo()
    assert root.d == {'Some dict': 1}, root.d
    m.undo()
    assert root.d == {}, root.d
    
    
    </t>
<t tx="bwmulder.20040605104941">class basic_list_test_class(object):
    """Simple class to test the list undoer"""
    pass

class basic_list_test(unittest.TestCase):
    """
    Test the basic operations of the list class
    """
    @others
        
</t>
<t tx="bwmulder.20040605105746">def test_lists_basic(self):
    """
    Some basic testing for the list undoer.
    
    """
    if undo_tracing:
        self.m = m = delegator()
    else:
        self.m = m = basic_undomechanism()
    m.monitor_list_attribute_in_class(basic_list_test_class, "a")
    m.enable()
    c = basic_list_test_class()
    c.a = [1, 2, 3]
    c.a = c.a
    m.mark()
    assert m.commands_to_undo() == 1, m.commands_to_undo()
    assert m.commands_to_redo() == 0, m.commands_to_redo()
    c.a.append(5)
    m.mark()
    assert m.commands_to_undo() == 2, m.commands_to_undo()
    assert m.commands_to_redo() == 0, m.commands_to_redo()
    assert c.a == [1, 2, 3, 5], c.a
    m.undo()
    assert m.commands_to_undo() == 1, m.commands_to_undo()
    assert m.commands_to_redo() == 1, m.commands_to_redo()
    assert c.a == [1, 2, 3], c.a
    m.redo()
    assert m.commands_to_undo() == 2, m.commands_to_undo()
    assert m.commands_to_redo() == 0, m.commands_to_redo()
    assert c.a == [1, 2, 3, 5], c.a
    m.undo()
    assert m.commands_to_undo() == 1, m.commands_to_undo()
    assert m.commands_to_redo() == 1, m.commands_to_redo()
    m.undo()
    assert m.commands_to_undo() == 0, m.commands_to_undo()
    assert m.commands_to_redo() == 2, m.commands_to_redo()
    assert not hasattr(c, "a"), "A should not exist here"
    assert m.steps_stored() == 3, m.steps_stored()
    m.redo()
    m.redo()
    assert c.a == [1, 2, 3, 5], c.a
    del c.a[2]
    assert c.a == [1, 2, 5], c.a # 1
    m.mark()
    m.undo()
    assert c.a == [1, 2, 3, 5], c.a # 2
    m.redo()
    assert c.a == [1, 2, 5], c.a # 3
    x = c.a.pop()
    m.mark()
    assert c.a == [1, 2]
    m.undo()
    assert c.a == [1, 2, 5]

    

    


</t>
<t tx="bwmulder.20040605174728">def test_lists_replace(self):
    """
    
    Test that list assignment works for an instance attribute that is put under the
    undo mechanism.
    
    """
    if undo_tracing:
        self.m = m = delegator()
    else:
        self.m = m = basic_undomechanism()
    c = basic_list_test_class()
    m.monitor_list_attribute_in_class(basic_list_test_class, "a")
    m.enable()
    c.a = [1, 2, 3]
    m.mark()
    m.undo()
    assert not hasattr(c,"a")
    m.redo()
    c.a.append(4)
    c.a.append(5)
    assert c.a == [1, 2, 3, 4, 5]
    m.mark()
    m.undo()
    assert c.a == [1, 2, 3]
    m.redo()
    assert c.a == [1, 2, 3, 4, 5]
    b = list_monitor(('a', 'b', 'c'), m)
    m.enable()
    b.append('d')
    assert b == ['a', 'b', 'c', 'd']
    m.mark()
    m.undo()
    assert b == ['a', 'b', 'c']
    m.redo()
    assert b == ['a', 'b', 'c', 'd']
    
    
</t>
<t tx="bwmulder.20040605180204">class basic_dict_test_class(object):
    """Simple class to test the list undoer"""
    pass

class basic_dict_test(unittest.TestCase):
    """
    Test the basic operations of the list class
    """
    @others
        

</t>
<t tx="bwmulder.20040605180225">def test_dicts_basic(self):
    """
    Some basic testing for the dict undoer.
    
    """
    trace_commands = False
    if undo_tracing:
        self.m = m = delegator()
    else:
        self.m = m = basic_undomechanism()
    m.monitor_dict_attribute_in_class(basic_dict_test_class, "a")
    m.enable()
    c = basic_dict_test_class()
    c.a = {1:1, 2:2, 3:3}
    c.a = c.a
    m.mark()
    if trace_commands:  print; m.print_commands(1)
    assert m.commands_to_undo() == 1, m.commands_to_undo()
    assert m.commands_to_redo() == 0, m.commands_to_redo()
    c.a[5] = 5
    m.mark()
    if trace_commands: m.print_commands(2)
    assert m.commands_to_undo() == 2, m.commands_to_undo()
    assert m.commands_to_redo() == 0, m.commands_to_redo()
    assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 1
    m.undo()
    if trace_commands: m.print_commands(3)
    assert m.commands_to_undo() == 1, m.commands_to_undo()
    assert m.commands_to_redo() == 1, m.commands_to_redo()
    assert c.a == {1:1, 2:2, 3:3}, c.a # 2
    m.redo()
    if trace_commands: m.print_commands(4)
    assert m.commands_to_undo() == 2, m.commands_to_undo()
    assert m.commands_to_redo() == 0, m.commands_to_redo()
    assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 3
    m.undo()
    if trace_commands: m.print_commands(5)
    assert m.commands_to_undo() == 1, m.commands_to_undo()
    assert m.commands_to_redo() == 1, m.commands_to_redo()
    assert c.a == {1:1, 2:2, 3:3}, c.a # 4
    m.undo()
    if trace_commands: m.print_commands(6)
    assert m.commands_to_undo() == 0, m.commands_to_undo()
    assert m.commands_to_redo() == 2, m.commands_to_redo()
    assert not hasattr(c, "a"), "A should not exist here"
    assert m.steps_stored() == 3, m.steps_stored()
    m.redo()
    if trace_commands: m.print_commands(7)
    assert c.a == {1:1, 2:2, 3:3}, c.a # 5
    m.redo()
    if trace_commands: m.print_commands(8)
    assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 6
    del c.a[5]
    assert c.a == {1:1, 2:2, 3:3}, c.a # 7
    m.mark()
    if trace_commands: m.print_commands(9)
    m.undo()
    if trace_commands: m.print_commands(10)
    assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 8
    m.redo()
    if trace_commands: m.print_commands(11)
    assert c.a == {1:1, 2:2, 3:3}, c.a # 9
    del c.a[2]
    m.mark()
    if trace_commands: m.print_commands(12)
    assert c.a == {1:1, 3:3}, c.a # 10
    m.undo()
    if trace_commands: m.print_commands(13)
    assert c.a == {1:1, 2:2, 3:3}, c.a # 11</t>
<t tx="bwmulder.20040605180245">def test_dicts_replace(self):
    """
    
    Test that dict assignment works for an instance attribute that is put under the
    undo mechanism.
    
    """
    if undo_tracing:
        self.m = m = delegator()
    else:
        self.m = m = basic_undomechanism()
    c = basic_dict_test_class()
    m.monitor_dict_attribute_in_class(basic_dict_test_class, "a")
    m.enable()
    c.a = {1:1, 2:2, 3:3}
    m.mark()
    m.undo()
    assert not hasattr(c,"a")
    m.redo()
    c.a[4] = 4
    c.a[5] = 5
    assert c.a == {1:1, 2:2, 3:3, 4:4, 5:5}, c.a # 1
    m.mark()
    m.undo()
    assert c.a == {1:1, 2:2, 3:3}, c.a # 2
    m.redo()
    assert c.a ==  {1:1, 2:2, 3:3, 4:4, 5:5}, c.a # 3
    b = dict_monitor({'a':'a', 'b':'b', 'c':'c'}, m)
    m.enable()
    b['d'] = 'd'
    assert b == {'a':'a', 'b':'b', 'c':'c', 'd':'d'}, b # 4
    m.mark()
    m.undo()
    assert b == {'a':'a', 'b':'b', 'c':'c'}, b # 5
    m.redo()
    assert b == {'a':'a', 'b':'b', 'c':'c', 'd':'d'}, b # 6
    
    </t>
<t tx="bwmulder.20040605220919">def print_commands(self, comment):
    """
    rint a readable list of all commands
    """
    print "===== Commands: %s ========" % comment
    i = 0
    while i &lt; len(self._commands):
        print "Command", i
        steps = self._commands[i]
        if steps:
            for step in steps:
                function, args = step
                print "  ",function.__name__, args
        if i == self._index:
            print "---------------------"
        i += 1
    print "========================"
</t>
<t tx="bwmulder.20040605231305">def __init__(self, value, monitor):
    list.__init__(self, value)
    self.set_monitor_object(monitor)
</t>
<t tx="bwmulder.20040605231401">def __init__(self, value, monitor):
    dict.__init__(self, value)
    self.set_monitor_object(monitor)
</t>
<t tx="edream.110203113231.233">@ To do:
    
     WARNING: problems with locking out event handlers could cause Leo to drop Text!
    - Do not trust this version of Leo with important data !!!
    
- The find logic doesn't properly show the found selection (or the correct body text).
    - Remove traces.

- Replace body widget with something better.

- Update joined headlines when any headline changes.

- Minor:
    - Finish all callbacks.
    - Finish dragging code.
    - Handle exception when starting by double-clicking LeoPy.leo.</t>
<t tx="edream.110203113231.234">@nocolor</t>
<t tx="edream.110203113231.235"></t>
<t tx="edream.110203113231.236">
</t>
<t tx="edream.110203113231.237">

- Almost all events connected properly.
- Code draws the screen (after the file has been read in!)
- Removed idle-time pollution: created onUpdateAllMenus.</t>
<t tx="edream.110203113231.238"></t>
<t tx="edream.110203113231.242"></t>
<t tx="edream.110203113231.257"># This updates the text of joined _headlines_, not body text.

if 0: # no longer used

    def updateJoinedHeadlines(self,text,v):
        guard = 0
        if guard &gt; 0: return
        guard += 1
        v2 = v.joinList()
        while v2 and v2 != v:
            id = v2.treeID()
            assert(id)
            self.tree.SetItemText(id,text)
            v2 = v2.joinList()
        guard -= 1</t>
<t tx="edream.110203113231.260">def finishCreate (self,c):
    
    # g.trace('wxLeoFrame')
    
    frame = self
    frame.c = c
    c.frame = frame
    
    # Init the wxFrame base class.  The leoFrame base class has already been inited.
    wx.wxFrame.__init__(self, None, -1, self.title) # wx.wxNO_3D # hangs.
    #self.outerPanel = wx.wxPanel(self,-1)
    #self.iconPanel = wx.wxPanel(self.outerPanel, -1, "iconPanel")

    self.CreateStatusBar()
    &lt;&lt; create the splitters &gt;&gt;
    frame.tree = wxLeoTree(frame,self.splitter2)
    frame.log = wxLeoLog(frame,self.splitter2)
    frame.body = wxLeoBody(frame,self.splitter1)
    frame.bodyCtrl = frame.body
    g.app.setLog(frame.log,'wxLeoFrame:finishCreate') # writeWaitingLog hangs without this(!)

    # Attach the controls to the splitter.
    self.splitter1.SplitHorizontally(self.splitter2,self.body.bodyCtrl,0)
    self.splitter2.SplitVertically(self.tree.treeCtrl,self.log.logCtrl,cSplitterWidth/2)
    
    self.menu = wxLeoMenu(frame)
    self.menu.createMenuBar()
    
    &lt;&lt; set the window icon &gt;&gt;
    &lt;&lt; declare event handlers for frame &gt;&gt;
    
    if 0: # Not ready yet...
        self.wxApp.SetTopWindow(self.wxFrame)
        self.wxFrame.Show(True)
        if not g.app.root:
            g.app.root = self.wxFrame
            
    self.colorizer = self.body.colorizer
            
    c.initVersion()
    self.signOnWithVersion()
    
    self.injectCallbacks()

    # Add the frame to the global window list.
    g.app.windowList.append(self)
    self.tree.redraw()
    self.Show(True) # required on some platforms: a cross-platform bug.</t>
<t tx="edream.110203113231.261">self.splitter1 = wx.wxSplitterWindow(self,
    const("cSplitterWindow"),
    wx.wxDefaultPosition, wx.wxDefaultSize,
    wx.wxSP_NOBORDER)

# No effect, except to create a red flash.
if 0:
    self.splitter1.SetForegroundColour(wx.wxRED)
    self.splitter1.SetBackgroundColour(wx.wxRED)

self.splitter2 = wx.wxSplitterWindow(self.splitter1, -1,
    wx.wxDefaultPosition, wx.wxDefaultSize,
    wx.wxSP_NOBORDER)
    # wx.wxSP_BORDER | wx.wxSP_3D, "splitterWindow");

self.splitter1.SetMinimumPaneSize(4)
self.splitter2.SetMinimumPaneSize(4)</t>
<t tx="edream.110203113231.264">if wx.wxPlatform == "__WXMSW__": # Activate events exist only on Windows.
    wx.EVT_ACTIVATE(self,self.onActivate)
else:
    wx.EVT_SET_FOCUS(self,self.OnSetFocus)

wx.EVT_CLOSE(self,self.onCloseLeoFrame)

wx.EVT_MENU_OPEN(self,self.updateAllMenus) 

if 0: # Causes problems at present.  The screen isn't drawn properly.
    wx.EVT_SIZE(self,self.onResize)</t>
<t tx="edream.110203113231.265">if wx.wxPlatform == "__WXMSW__":

    path = os.path.join(g.app.loadDir,"..","Icons","LeoApp16.ico")
    icon = wx.wxIcon(path,wx.wxBITMAP_TYPE_ICO,16,16)
    self.SetIcon(icon)
</t>
<t tx="edream.110203113231.266">def __init__ (self,title):
    
    # Init the leoFrame base class.
    # We will init the wxFrame base class in finishCreate.
    leoFrame.leoFrame.__init__(self,g.app.gui)
    
    self.c = None # set in finishCreate.
    self.bodyCtrl = None # set in finishCreate
    self.title = title
    
    # g.trace("wxLeoFrame",title)
    self.activeFrame = None
    self.lockout = 0 # Suppress further events
    self.quitting = False
    self.updateCount = 0
    self.treeIniting = False
    self.drawing = False # Lockout recursive draws.
    self.menuIdDict = {}
    self.menuBar = None
    self.ratio = 0.5
    self.secondary_ratio = 0.5
    self.startupWindow=False
    self.use_coloring = False # set True to enable coloring
    
    # These vars have corresponding getters/setters.
    if 0: # now defined in base tree class.
        self.mDragging = False
        self.mRootVnode = None
        self.mTopVnode = None
        self.mCurrentVnode = None</t>
<t tx="edream.110203113231.306"></t>
<t tx="edream.110203113231.307">def __init__ (self):
    
    # g.trace("wxGui")
    
    # Initialize the base class.
    if 1: # in plugin
        leoGui.leoGui.__init__(self,"wxPython")
    else:
        leoGui.__init__(self,"wxPython")
        
    self.bitmap_name = None
    self.bitmap = None</t>
<t tx="edream.110203113231.308">def createRootWindow(self):

    self.wxApp = wxLeoApp(None) # This redirects stdout &amp; stderr to stupid console.
    self.wxFrame = None

    if 0: # Not ready yet.
        self.setDefaultIcon()
        self.getDefaultConfigFont(g.app.config)
        self.setEncoding()
        self.createGlobalWindows()

    return self.wxFrame</t>
<t tx="edream.110203113231.309">def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        if g.CheckVersion(version,"8.4.3"):
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = os.path.join(g.app.loadDir,"..","Icons")
            if os.path.exists(path):
                file = os.path.join(path,"LeoApp16.ico")
                if os.path.exists(path):
                    self.bitmap = Tk.BitmapImage(file)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        g.es_print("exception setting bitmap")
        traceback.print_exc()</t>
<t tx="edream.110203113231.310">@ According to Martin v. Lwis, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the g.getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

def setEncoding (self):

    for (encoding,src) in (
        (g.app.config.tkEncoding,"config"),
        #(locale.getdefaultlocale()[1],"locale"),
        (g.getpreferredencoding(),"locale"),
        (sys.getdefaultencoding(),"sys"),
        ("utf-8","default")):
    
        if g.isValidEncoding (encoding): # 3/22/03
            g.app.tkEncoding = encoding
            # g.trace(g.app.tkEncoding,src)
            break
        elif encoding and len(encoding) &gt; 0:
            g.trace("ignoring invalid " + src + " encoding: " + `encoding`)
            
    # g.trace(g.app.tkEncoding)</t>
<t tx="edream.110203113231.311">def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    t = Tk.Text()
    fn = t.cget("font")
    font = tkFont.Font(font=fn)
    config.defaultFont = font
    config.defaultFontFamily = font.cget("family")</t>
<t tx="edream.110203113231.312">def createGlobalWindows (self):
    
    """Create the global windows for the application."""
    
    g.app.findFrame = wxFindFrame()
    g.app.findFrame.top.withdraw()
    g.app.globalWindows.append(g.app.findFrame)</t>
<t tx="edream.110203113231.314">def finishCreate (self):

   pass
    
</t>
<t tx="edream.110203113231.315">def killGui(self,exitFlag=True):
    
    """Destroy a gui and terminate Leo if exitFlag is True."""

    pass # Not ready yet.

</t>
<t tx="edream.110203113231.316">def recreateRootWindow(self):
    """A do-nothing base class to create the hidden root window of a gui

    after a previous gui has terminated with killGui(False)."""

    g.trace('wx gui')

</t>
<t tx="edream.110203113231.317">def runMainLoop(self):

    """Run tkinter's main loop."""
    
    # g.trace("wxGui")
    self.wxApp.MainLoop()
    # g.trace("done")</t>
<t tx="edream.110203113231.347">def OnInit(self):

    self.SetAppName("Leo")

    return True</t>
<t tx="edream.110203113231.350"></t>
<t tx="edream.110203113231.351">def __repr__ (self):
    
    return "wxLeoFrame: " + self.title</t>
<t tx="edream.110203113231.540"></t>
<t tx="edream.110203113231.541">def __init__ (self,frame,parentFrame):

    # Init the base class: calls createControl.
    leoFrame.leoBody.__init__(self,frame,parentFrame)
    
    self.bodyCtrl = self.createControl(frame,parentFrame)

    self.colorizer = leoColor.colorizer(self.c)

    self.styles = {} # For syntax coloring.

    wx.EVT_TEXT(self.bodyCtrl,const("cBodyCtrl"),self.onBodyTextUpdated)</t>
<t tx="edream.110203113231.542">def createControl (self,frame,parentFrame):
    
    ctrl = wx.wxTextCtrl(parentFrame,
            const("cBodyCtrl"), "",
            wx.wxDefaultPosition, wx.wxDefaultSize,
            wx.wxTE_RICH | wx.wxTE_RICH2 | wx.wxTE_MULTILINE)

    return ctrl</t>
<t tx="edream.110203113231.618">@ It is usually best _not_ to catch exceptions in plugins:
doHook catches all exceptions and disables further calls to plugins.

If a plugin catches exceptions during startup it should either:
    
- raise the exception again.
- provide an init function at the top level that reports the failure.
@c

@language python
@tabwidth -4
@pagewidth 80
</t>
<t tx="edream.110203113231.667"></t>
<t tx="edream.110203113231.668"></t>
<t tx="edream.110203113231.677">@ignore
@language plain
@comment !
@ This node has an example of a flat configuration file (i.e. just the output of a 
'show running' command on a cisco router), and of the same configuration file 
imported by the plugin.
</t>
<t tx="edream.110203113231.678">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable
!
hostname rpr1
!
boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3
logging buffered 100000 debugging
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
!
controller SONET 1/0/0
 framing sdh
!
controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2
!
controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
!
interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast
!
interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex
!
interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex
!
interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.2
 no ip directed-broadcast
!
interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode
!
interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast
!
interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal
!
interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010
!
interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010
!
interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address
!
interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable
!
router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0
!
router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary
!
ip classless
ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3
ip bgp-community new-format
ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
logging facility local6
logging 10.10.10.1
access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any
route-map only permit 2
 match community 65001:2
 set origin igp
!
route-map only1 permit 10
 match community 1 65001:1
 set origin igp
!
route-map only3 permit 10
 match community 100
!
route-map tag_com permit 10
 match tag 1
 set community 65001:1
!
route-map tag_com permit 20
 match tag 3
 set community 65001:3
!
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware
line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0
!
ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer
end

rpr1#
</t>
<t tx="edream.110203113231.679">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
&lt;&lt;service&gt;&gt;
!
hostname rpr1
!
&lt;&lt;boot&gt;&gt;
&lt;&lt;logging&gt;&gt;
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
&lt;&lt;controller&gt;&gt;
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
&lt;&lt;interface&gt;&gt;
!
&lt;&lt;router&gt;&gt;
!
ip classless
&lt;&lt;ip route&gt;&gt;
ip bgp-community new-format
&lt;&lt;ip community-list&gt;&gt;
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
&lt;&lt;access-list&gt;&gt;
&lt;&lt;route-map&gt;&gt;
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
&lt;&lt;line&gt;&gt;
!
&lt;&lt;ntp&gt;&gt;
end

rpr1#</t>
<t tx="edream.110203113231.680">access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any</t>
<t tx="edream.110203113231.681">boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3</t>
<t tx="edream.110203113231.682"></t>
<t tx="edream.110203113231.683">controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2</t>
<t tx="edream.110203113231.684">controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1</t>
<t tx="edream.110203113231.685">controller SONET 1/0/0
 framing sdh</t>
<t tx="edream.110203113231.686"></t>
<t tx="edream.110203113231.687">interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address</t>
<t tx="edream.110203113231.688">interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable</t>
<t tx="edream.110203113231.689">interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex</t>
<t tx="edream.110203113231.690">interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex</t>
<t tx="edream.110203113231.691">interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="edream.110203113231.692">interface FastEthernet0/0/1.2
 no ip directed-broadcast</t>
<t tx="edream.110203113231.693">interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode</t>
<t tx="edream.110203113231.694">interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="edream.110203113231.695">interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="edream.110203113231.696">interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast</t>
<t tx="edream.110203113231.697">interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal</t>
<t tx="edream.110203113231.698">interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="edream.110203113231.699">interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="edream.110203113231.700">interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="edream.110203113231.701">interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010</t>
<t tx="edream.110203113231.702">interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010</t>
<t tx="edream.110203113231.703">ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3</t>
<t tx="edream.110203113231.704">ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3</t>
<t tx="edream.110203113231.705"></t>
<t tx="edream.110203113231.706">line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware</t>
<t tx="edream.110203113231.707">line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0</t>
<t tx="edream.110203113231.708">logging buffered 100000 debugging
logging facility local6
logging 10.10.10.1</t>
<t tx="edream.110203113231.709">ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer</t>
<t tx="edream.110203113231.710"></t>
<t tx="edream.110203113231.711">route-map only permit 2
 match community 65001:2
 set origin igp</t>
<t tx="edream.110203113231.712">route-map only1 permit 10
 match community 1 65001:1
 set origin igp</t>
<t tx="edream.110203113231.713">route-map only3 permit 10
 match community 100</t>
<t tx="edream.110203113231.714">route-map tag_com permit 10
 match tag 1
 set community 65001:1</t>
<t tx="edream.110203113231.715">route-map tag_com permit 20
 match tag 3
 set community 65001:3</t>
<t tx="edream.110203113231.716"></t>
<t tx="edream.110203113231.717">router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary</t>
<t tx="edream.110203113231.718">router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0</t>
<t tx="edream.110203113231.719">no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable</t>
<t tx="edream.110203113231.722"></t>
<t tx="edream.110203113231.723">[Main]
active = Yes
interval = 20</t>
<t tx="edream.110203113231.729"></t>
<t tx="edream.110203113231.872"></t>
<t tx="edream.110203113231.930"># The spellpyx plugin has been retired because the Spell Tab is more convenient to use.</t>
<t tx="edream.110403140857"></t>
<t tx="edream.110403140857.1"></t>
<t tx="edream.110403140857.2">@
--How to install the wiki markup plugin--

1) first make sure that the "add_directives" plugin is enabled. This plugin turns on support for @markup directives, and it can be found in leoPlugins.leo under the section "Plugins &amp; scripts" -&gt; Directives. In particular:
    a) check that the plugin code is enabled. You should have a line like (note the "if 1"):
        if 1: # Register the handlers...
    b) generate the plugin file. Right click with the mouse on the outline heading "@file add_directives.py" and select "Write @file nodes".

2) enable the "color_markup.py" plugin:
    a) check that the plugin code is enabled. You should have a line like:
        if Tkinter: # Register the handlers...
    b) generate the plugin file. Right click with the mouse on the outline heading "@file color_markup.py" and select "Write @file nodes".

</t>
<t tx="edream.110403140857.3">@
--How to use the wiki markup plugin--

Make sure first that both the add_directives and color_markup plugins are installed and enabled (see the Installation node for details). Make also sure that coloring is not disabled for your outline (i.e. you should not have @nocolor in an ancestor node).
    
Important: coloring via wiki markups is only supported in doc parts and Python triple-double-quoted strings (not in Python triple-single-quoted strings!).

To use the wiki markup, write

@markup wiki # turn on the wiki markup
@            # start a doc part
(here goes your marked-up text, see below)

To disable the wiki markup, write

@markup      # turn off the wiki markup

You can now use the markups either selecting the Wiki menu entries (or the corresponding keyboard shortcuts) found in the Edit-&gt;Edit Body-&gt;Wiki Tags menu, or manually inserting the tags yourself. 

If you use the menus, you can either select a word and choose the appropriate menu entry to appy styling to that word, or you can just choose a menu entry (e.g. "Bold") and start writing text with the correspongin style. Select the menu entry again to return to normal text.

See the "Supported markups" for the currently supported markups.

See also the "Example" subnode. If you have the add_directives and color_markup plugins enabled, you should see the text in that node displayed as styled text.</t>
<t tx="edream.110403140857.4">@
The currently supported markups are:

''text''                   # write text in italics
__text__                   # write text in bold
~~&lt;color&gt;:text~~           # write text in the color specified by &lt;color&gt; (e.g. blue, grey, etc)
{picture file=&lt;filename&gt;}  # load the picture indicated by &lt;filename&gt;
http://url                 # URL support: double clicking on the url will open it in the default browser.
https://url                # URL support: double clicking on the url will open it in the default browser.

Note 1: italics and bold markups can be nested, e.g.

''__text__''               # write text in italics and bold

Just remember to terminate the tags in the order they were opened.

Note 2: URLs must be terminated by a space.

By default, once the text has been markup up, the actual tags (e.g. __ for bold) are not displayed anymore. You can choose to display them selecting "Show Invisibles" from the Edit menu.
</t>
<t tx="edream.110403140857.5">@color
@markup wiki
@doc (this turns on a doc section; a '@ ' would do too)

This should be ''italic'' text
This should be __bold__ text
This text should be ~~pink:colored in pink~~, ~~blue:this one in blue~~.
This text should be ''__both bold and italic__''.
Leo's homepage is at http://webpages.charter.net/edreamleo/front.html 

You can also have wiki markups in python triple-double-quoted strings:

@c

def __dummy():
    """This is a __very important__ function."""
    return None
</t>
<t tx="edream.110403140857.6">@
Wiki markups are supported ''in subnodes too''.</t>
<t tx="edream.110403140857.7">@
Version 1.2.1, October 29, 2003.

Added documentation.
Added menu entries to tag selected text and to start/end wiki tagging.

Version 1.3, October 29, 2003.

Fixed bug in the creation of the wiki menu.
Added support for clickable http tags.

Version 1.4, November 4, 2003.
Put import tkinter in a try/except block.
Made changes for 4.1 g.app.gui architecture. (More work needed).</t>
<t tx="edream.111303085447.1">def destroySelf(self):
    
    pass # Nothing more needs to be done once all windows have been destroyed.</t>
<t tx="edream.111303091300"></t>
<t tx="edream.111303092328.4">def createLeoFrame(self,title):
    
    """Create a new Leo frame."""

    return wxLeoFrame(title)</t>
<t tx="edream.111303100039"></t>
<t tx="edream.111303100039.1"></t>
<t tx="edream.111303100039.6">def insertHeadlineTime (self):
    
    g.es("insertHeadlineTime not ready yet")
    return

    frame = self ; c = frame.c ; v = c.currentVnode()
    h = v.headString() # Remember the old value.

    if v.edit_widget():
        sel1,sel2 = g.app.gui.getTextSelection(v.edit_widget())
        if sel1 and sel2 and sel1 != sel2: # 7/7/03
            v.edit_widget().delete(sel1,sel2)
        v.edit_widget().insert("insert",c.getTime(body=False))
        frame.idle_head_key(v)

    # A kludge to get around not knowing whether we are editing or not.
    if h.strip() == v.headString().strip():
        g.es("Edit headline to append date/time")</t>
<t tx="edream.111303100039.7"></t>
<t tx="edream.111303100039.8">def cascade(self):
    
    g.es("cascade not ready yet")
    return

    x,y,delta = 10,10,10
    for frame in g.app.windowList:
        top = frame.top
        # Compute w,h
        top.update_idletasks() # Required to get proper info.
        geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
        dim,junkx,junky = string.split(geom,'+')
        w,h = string.split(dim,'x')
        w,h = int(w),int(h)
        # Set new x,y and old w,h
        frame.setTopGeometry(w,h,x,y)
        # Compute the new offsets.
        x += 30 ; y += 30
        if x &gt; 200:
            x = 10 + delta ; y = 40 + delta
            delta += 10</t>
<t tx="edream.111303100039.9">def equalSizedPanes(self):
    
    g.es("equalSizedPanes not ready yet")
    return

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
</t>
<t tx="edream.111303100039.10">def hideLogWindow (self):
    
    g.es("hideLogWindow not ready yet")
    return
    
    frame = self
    frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)</t>
<t tx="edream.111303100039.11">def minimizeAll(self):
    
    g.es("minimizeAll not ready yet")
    return

    self.minimize(g.app.findFrame)
    self.minimize(g.app.pythonFrame)
    for frame in g.app.windowList:
        self.minimize(frame)
    
def minimize(self, frame):

    if frame:
        frame.Show(False)</t>
<t tx="edream.111303100039.12"># The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.
def toggleSplitDirection(self):
    
    g.es("toggleSplitDirection not ready yet")
    return

    # Abbreviations.
    frame = self
    bar1 = self.bar1 ; bar2 = self.bar2
    split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
    split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
    # Switch directions.
    verticalFlag = self.splitVerticalFlag = not self.splitVerticalFlag
    orientation = g.choose(verticalFlag,"vertical","horizontal")
    g.app.config.setWindowPref("initial_splitter_orientation",orientation)
    # Reconfigure the bars.
    bar1.place_forget()
    bar2.place_forget()
    self.configureBar(bar1,verticalFlag)
    self.configureBar(bar2,not verticalFlag)
    # Make the initial placements again.
    self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
    self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
    # Adjust the log and body panes to give more room around the bars.
    self.reconfigurePanes()
    # Redraw with an appropriate ratio.
    vflag,ratio,secondary_ratio = frame.initialRatios()
    self.resizePanesToRatio(ratio,secondary_ratio)</t>
<t tx="edream.111303101257">def abortEditLabelCommand (self):

    g.es("abortEditLabelCommand not ready yet")
    return
    
    c = self.c ; v = c.currentVnode ; tree = self.tree
    # g.trace(v)
    if self.revertHeadline and v.edit_widget() and v == self.editVnode:
        
        # g.trace(`self.revertHeadline`)
        v.edit_widget().delete("1.0","end")
        v.edit_widget().insert("end",self.revertHeadline)
        tree.idle_head_key(v) # Must be done immediately.
        tree.revertHeadline = None
        tree.select(v)
        if v and len(v.t.joinList) &gt; 0:
            # 3/26/03: changed redraw_now to force_redraw.
            tree.force_redraw() # force a redraw of joined headlines.</t>
<t tx="edream.111303101257.1">def endEditLabelCommand (self):
    
    g.es("endEditLabelCommand not ready yet")
    return

    c = self.c ; tree = self.tree ; v = self.editVnode

    if v and v.edit_widget():
        tree.select(v)

    if v: # Bug fix 10/9/02: also redraw ancestor headlines.
        # 3/26/03: changed redraw_now to force_redraw.
        tree.force_redraw() # force a redraw of joined headlines.

    gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02</t>
<t tx="edream.111303101709">def toggleActivePane(self):
    
    # This can't work from the menu...
    
    g.es("toggleActivePane not ready yet")
    return

    if self.FindFocus() == self.body.bodyCtrl:
        self.tree.SetFocus()
    else:
        self.body.bodyCtrl.SetFocus()</t>
<t tx="edream.111303103141.3">def delete_range (self,menu,n1,n2):
    
    if not menu:
        g.trace("no menu")
        return
        
    # g.trace(n1,n2,menu.GetTitle())
    
    items = menu.GetMenuItems()
    
    if 0: # debugging
        for item in items:
            id = item.GetId()
            item = menu.FindItemById(id)
            g.trace(item.GetText())
            
    ## Doesn't work:  a problem with wxPython.
    
    if len(items) &gt; n1 and len(items) &gt; n2:
        i = n1
        while i &lt;= n2:
            id = items[i].GetId()
            item = menu.FindItemById(id)
            g.trace("deleting:",item.GetText())
            menu.Delete(id)
            i += 1</t>
<t tx="edream.111303141147">def signOnWithVersion (self):

    c = self.c
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d wxWindows %s" % (n1,n2,n3,wx.wxVERSION_STRING))
    g.enl()</t>
<t tx="edream.111303184347">@ The wxWindows menu code has problems:  changes do not take effect immediately.</t>
<t tx="edream.111303202917.1">def getColorizer(self):

    return self.colorizer

def recolor(self,v,incremental=False):

    if self.use_coloring:
        self.colorizer.colorize(v,incremental)

def recolor_now(self,v,incremental=False):

    if self.use_coloring:
        self.colorizer.colorize(v,incremental)
    
def recolor_range(self,v,leading,trailing):

    if self.use_coloring:
        self.colorizer.recolor_range(v,leading,trailing)
    
def updateSyntaxColorer (self,v):

    return self.colorizer.updateSyntaxColorer(v)</t>
<t tx="edream.111303204025"></t>
<t tx="edream.111303204025.1">def adjustIndex (self,index,offset):
    
    try:
        column, row = index
        return column, row + offset
    except:
        return index + offset</t>
<t tx="edream.111303204025.2">def compareIndices(self,i,rel,j):
    
    try:
        y1,x1 = i
        y2,x2 = j
        pos1 = self.bodyCtrl.XYToPosition(x1,y1)
        pos2 = self.bodyCtrl.XYToPosition(x2,y2)
    except:
        pos1 = i
        pos2 = j
    
    val = eval("%d %s %d" % (pos1,rel,pos2))
    g.trace(i,j,rel,val)
    return val</t>
<t tx="edream.111303204025.3">def convertRowColumnToIndex (self,row,column):
    
    index = self.bodyCtrl.XYToPosition(column,row-1)
    # g.trace(column,row,"-&gt;",index)
    return index</t>
<t tx="edream.111303204025.4">def convertIndexToRowColumn (self,index):
    
    x,y = self.bodyCtrl.PositionToXY(index)
    # g.trace(index,"-&gt;",y+1,x)
    return y+1,x</t>
<t tx="edream.111303204025.5">def getImageIndex (self,image):
    
    g.trace(image)</t>
<t tx="edream.111303204517"></t>
<t tx="edream.111303205442">@ The colorizer isn't ready for prime time:
    
    - It's too slow when selecting long text
    - The screen flashes too much
    - The tkColorToWxColor routine needs much more work.
    
wxLeo should use wxStc rather than wxText!</t>
<t tx="edream.111303205611">def tag_add (self,tagName,index1,index2):
    
    # g.trace(tagName,index1,index2)

    style = self.styles.get(tagName)
    if style:
        self.bodyCtrl.SetStyle(index1,index2,style)</t>
<t tx="edream.111303205611.1">def tag_bind (self,tagName,event,callback):
    
    # g.trace(tagName,event,callback)
    pass
</t>
<t tx="edream.111303205611.2">def tag_configure (self,colorName,**keys):
    
    foreground = keys.get("foreground")
    background = keys.get("background")

    if foreground:
        fcolor = self.tkColorToWxColor (foreground)
        bcolor = self.tkColorToWxColor (background)
        if fcolor and bcolor:
            # g.trace(colorName,foreground,keys)
            style = wx.wxTextAttr(fcolor,bcolor)
            self.styles[colorName] = style
        elif fcolor:
            style = wx.wxTextAttr(fcolor)
            self.styles[colorName] = style</t>
<t tx="edream.111303205611.3">def tag_delete(self,tagName):

    if tagName == "keyword": # A kludge.

        # g.trace(tagName)
        style = wx.wxTextAttr(wx.wxBLACK)
        last = self.maxWxIndex()
        
        if 1: # This may cause the screen flash.
            self.bodyCtrl.SetStyle(0,last,style)</t>
<t tx="edream.111303205611.4">def tag_remove (self,tagName,index1,index2):
    
    g.trace(tagName,index1,index2)
    pass
</t>
<t tx="edream.111403080609">def maxWxIndex (self):
    
    return self.bodyCtrl.GetLastPosition()</t>
<t tx="edream.111403082513">def tkColorToWxColor (self, color):
    
    d = {
        "red": wx.wxRED,
        "blue": wx.wxBLUE,
        "#00aa00": wx.wxGREEN,
        "firebrick3": wx.wxRED }
        
    return d.get(color)</t>
<t tx="edream.111403093253">The new code now works with the new reorg.  This means that wxLeo is using all the code in Leo's core.

In particular:

- wxLeo creates all menus using the base leoMenu class.
- wxLeo uses all commands in the Commands class.
- wxLeoFrame contains only gui-dependent commands.

The syntax colorer is working in demo mode.  Almost certainly wxLeo should use a better control than wxText.</t>
<t tx="edream.111403093253.1"></t>
<t tx="edream.111403141810">def initialRatios (self):

    config = g.app.config
    s = config.getWindowPref("initial_splitter_orientation")
    verticalFlag = s == None or (s != "h" and s != "horizontal")
    
    # Tweaked for tk.  Other tweaks may be best for wx.
    if verticalFlag:
        r = config.getFloatWindowPref("initial_vertical_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
        r2 = config.getFloatWindowPref("initial_vertical_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    else:
        r = config.getFloatWindowPref("initial_horizontal_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
        r2 = config.getFloatWindowPref("initial_horizontal_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

    return verticalFlag,r,r2</t>
<t tx="edream.111503105816">def injectCallbacks(self):
    
    import leoNodes
    
    # Some callback is required.
    def doNothingCallback(*args,**keys):
        pass

    for name in (
        "OnBoxClick","OnDrag","OnEndDrag",
        "OnHeadlineClick","OnHeadlineRightClick","OnHeadlineKey",
        "OnHyperLinkControlClick","OnHyperLinkEnter","OnHyperLinkLeave",
        "OnIconClick","OnIconDoubleClick","OnIconRightClick"):

        # g.trace(f)
        g.funcToMethod(doNothingCallback,leoNodes.vnode,name=name)</t>
<t tx="edream.111503110300">At this point, Leo is useable.

What I did:

- Added use_coloring ivar to the wxLeoFrame class.  The body text is syntax colored only if this is True.
    This is set to False at present because the default colors are very poor.
    Also, coloring causes the body pane to scroll for large text.  These are minor problems...

- Got find panel working.  This required creating dummy wxSearchWidget class.  Probably _all_ the search code should be in the base leoFind class, but that would making supporting regexp searches harder.

- Simplified the event handlers in the find panel.  We can use tables to _create_ the event handlers.

- Solved the problem with selecting new nodes: we must lock out further event handling once an event handler starts.  In particular, the syntax colorer generates a lot of other events.  This also prevents the outline from being marked dirty when a new node is selected.

- Added code to insject do-nothing callbacks into vnode class.  This is required by the syntax colorer.

Later:

- Completed Find panel.

- Made sure Leo prompts when closing a window.
    - The new code is very simple: it just calls g.app.closeLeoWindow.
        - Removed some gui dependencies from the g.app.finishQuit logic.
          (They are now in the g.app.tkinterGui.destroySelf routine.)

- Implemented the wx gui dialog code.
    - Only the number dialog remains...

Very little remains to be done, and nothing big.</t>
<t tx="edream.111503111350"></t>
<t tx="edream.111503213533">def destroySelf(self):
    
    self.Destroy()</t>
<t tx="edream.111703103908"></t>
<t tx="edream.111703103908.2">def leoHelp (self):
    
    g.es("leoHelp not ready yet")
    
    return ##
    
    file = os.path.join(g.app.loadDir,"..","doc","sbooks.chm")
    file = g.toUnicode(file,g.app.tkEncoding) # 10/20/03

    if os.path.exists(file):
        os.startfile(file)
    else:	
        answer = g.app.gui.runAskYesNoDialog(c,
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")

        if answer == "yes":
            try:
                if 0: # Download directly.  (showProgressBar needs a lot of work)
                    url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
                    import urllib
                    self.scale = None
                    urllib.urlretrieve(url,file,self.showProgressBar)
                    if self.scale:
                        self.scale.destroy()
                        self.scale = None
                else:
                    url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                    import webbrowser
                    os.chdir(g.app.loadDir)
                    webbrowser.open_new(url)
            except:
                g.es("exception dowloading sbooks.chm")
                g.es_exception()</t>
<t tx="edream.111703103908.3">def showProgressBar (self,count,size,total):

    # g.trace("count,size,total:" + `count` + "," + `size` + "," + `total`)
    if self.scale == None:
        &lt;&lt; create the scale widget &gt;&gt;
    self.scale.set(count*size)
    self.scale.update_idletasks()</t>
<t tx="edream.111703103908.4">top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()</t>
<t tx="ekr.20040205071616">&lt;&lt; docstring &gt;&gt;
&lt;&lt; imports &gt;&gt;

OKFLAG='OK '  # Space required.
__version__ = "0.1"

@others

if Tk and not g.app.unitTesting: # Not (yet) for unit testing.

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":
        leoPlugins.registerHandler("start1", onStart)
        leoPlugins.registerHandler("create-optional-menus",create_UserMenu)
        leoPlugins.registerHandler("iconrclick2", onRclick)
        g.plugin_signon(__name__)
        g.es('mnplug OK+Commands+Menu aktiv',color='green')</t>
<t tx="ekr.20040205071616.1">def mnstamp():

    lt=time.localtime(time.time())
    mndatetime=time.strftime('%y%m%d %H:%M',(lt))
    return '### '+g.app.leoID+mndatetime
</t>
<t tx="ekr.20040205071616.2">def mnOKstamp():

    lt=time.localtime(time.time())
    mndatetime=time.strftime('%y%m%d %H:%M',(lt))
    return '###'+OKFLAG+g.app.leoID+mndatetime
</t>
<t tx="ekr.20040205071616.3">def onStart (tag,keywords):

    # insert function insertUser as method of class Commands at runtime
    g.funcToMethod(insertUser,leoCommands.Commands)
    g.funcToMethod(insertOKcmd,leoCommands.Commands)

</t>
<t tx="ekr.20040205071616.4">def setHeadOK(v):

    s = OKFLAG + v.headString()
    v.setHeadStringOrHeadline(s)

</t>
<t tx="ekr.20040205071616.5">def insertBodystamp(c,v):

    stamp=mnOKstamp()+'\n'

    # insertAtBegin - ??!! workaround ??!! 
    # insertPointFormat is  ('row.column')
    
    oldip=c.frame.body.getInsertionPoint()
    newip=str(int(string.split(oldip,'.')[0])+1)+'.'+string.split(oldip,'.')[1]

    c.frame.body.setInsertionPoint('0.0')
    c.frame.body.insertAtInsertPoint(stamp)
    c.frame.body.setInsertionPoint(newip)
    c.frame.body.onBodyChanged("Typing")</t>
<t tx="ekr.20040205071616.6">def is_subnodesOK(v):

    if not v.hasChildren():
        return True
    else:
        ok = False
        child=v.firstChild()
        while child:
            s=child.headString()
            ok=s[0:len(OKFLAG)]==OKFLAG
            if not ok:break
            child=child.next()
    return ok

</t>
<t tx="ekr.20040205071616.7">def onRclick(tag,keywords):
    
    """Handle right click in body pane."""

    c=keywords.get('c')
    insertOKcmd(c)</t>
<t tx="ekr.20040205071616.8">def insertOKcmd(self,event=None):

    c=self; v=c.currentVnode()  
    
    if is_subnodesOK(v) :
        setHeadOK(v)
        insertBodystamp(c,v)
    else: 
        g.es('OK in child missing')</t>
<t tx="ekr.20040205071616.9">def insertUser (self,event=None):
    
    """Handle the Insert User command."""

    c = self ; v = c.currentVnode()
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    
    s = mnstamp()
    
    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged("Typing",oldSel=oldSel)</t>
<t tx="ekr.20040205071616.10">def create_UserMenu (tag,keywords):

    c = keywords.get("c")
    
    c.pluginsMenu = c.frame.menu.createNewMenu("UserMenu")

    table = [
        ("insUser", 'Shift+F6', c.insertUser),
        ("insOK",'Ctrl+Shift+O',c.insertOKcmd)]

    c.frame.menu.createMenuEntries(c.pluginMenu,table,dynamicMenu=True)</t>
<t tx="ekr.20040331071919"></t>
<t tx="ekr.20040331071919.1">@language plain
@ascfile "doc/mod_asc_dev.asc"
@doc                
@ascskip # Time-stamp: "Mon, Jan 19 15:30 CST 2004  michael@redpriest Leo_AsciiDoc_Developers_Guide_141612300.txt"
Preface
-------

Leo2AsciiDoc is a small Python program which has been built to be used as
a plugin module for the Leo outlining editor.

This is the Developer Documentation and source code listing of
Leo2AsciiDoc.

Leo2AsciiDoc enables the contents of Leo outlines to be published to
HTML or PDF via the DocBook XML set of publishing tools.  Plain text
from the Leo outline is transformed into a final result that has:

    - typeset body text, in which bulleted and numbered lists,
      variable lists, page numbers, URLs, index terms,and bold and
      italic text are automatically recognized.
    - typeset Headings
    - a Table of Contents
    - an Index containing any items marked by the user, and any
      Python classes or functions.

indexterm:[Literate Programming]
For programmers, Leo2AsciiDoc enables a simplified version of
Literate Programming: all the documentation and code for a program
can be written in a Leo outline, and published with just a few
keystrokes.  As is normal for a Leo outline, Leo can also extract
the source code from the outline and package it into text files,
ready to be run or compiled.

Specifically, what the Leo2AsciiDoc program does is:

    - wait to be called by the Leo menu (File; Export; Export to
      AsciiDoc), and then
    - read a part of a Leo outline, and
    - write the contents to a text file that can be understood by
      the AsciiDoc program.

From there:

    - the xref:AsciiDoc[] program can then convert that text file to
      another text file that is in the DocBook XML format.
    - the standard collection of xref:DocBook[] tools can then format the
      text in HTML (web page) files or as a typeset PDF file.
    - Once set up, the whole process happens quickly and
      automatically, usually with a simple "make" command.

Here are some web locations for the items I've referenced above:

Leo::    
    http://webpages.charter.net/edreamleo/front.html[]
Python::
    http://www.python.org[]
Docbook::    
    http://docbook.org/[]
Literate Programming::
    http://www.literateprogramming.com/[]
AsciiDoc::
    http://www.methods.co.nz/asciidoc/[]
PDF::
    Adobe provides a free program, Adobe Acrobat Reader (Windows &amp;
    Linux), that is used to read and print documents produced in the
    Adobe Portable Document Format.
    http://www.adobe.com/products/acrobat/readermain.html[]

---
Michael Dawson
Marshall Research
michael_dawson at marshallresearch dot com
---
@code</t>
<t tx="ekr.20040331071919.2">@doc
@ascskip # Time-stamp: "Fri, Jan  9 15:19 CST 2004  michael@redpriest About_this_document_140583820.txt"

If you are reading this document in HTML (in a web browser) or as a
PDF file (usually in Adobe Acrobat Reader), it may interest you to
know that this document was generated from a Leo outline.

The Leo outline (in the file mod_leo2ascd.leo) contained the
Leo2AsciiDoc Users Guide, the Leo2AsciiDoc Developers Guide, and all
the Leo2AsciiDoc source code.  All of them were created by simply
typing plain text.

The working source code was exported by Leo using the "File; Tangle;
Tangle" menu selection, which created the Python program file
"mod_leo2ascd.py".

The Users Guide and the Developers Guide were created by exporting
the text from Leo, using the menu selection "File; Export; Export
All to AsciiDoc".  This created the plain text files
"mod_asc_user.asc" and "mod_asc_dev.asc" (which are the file names I
told Leo to use.)

I then typed "make all" at the console in the directory, and the
make program:

    - ran the AsciiDoc program to produce the DocBook XML files.
    - ran the xsltproc program to produce the HTML files from the
      XML files.
    - ran the xsltproc program to produce "fo" files, and ran the
      fop program to produce PDF files from the fo files.

Everything was generated automatically without any further work on
my part.

@code</t>
<t tx="ekr.20040331071919.3">@doc
@ascskip # Time-stamp: "Mon, Jan 19 15:28 CST 2004  michael@redpriest License_141615068.txt"

This is part of the Leo2AsciiDoc software package, which is released
as open source.  

The license is the most "open" I know of, and is sometimes referred
to as the "X11" or "MIT" license.  Boiled down, in non-legal terms:

    - the software is yours for free -- to run, modify and
      distribute as you will
    - I have no legal liability for any of it
    - you may not use my name.

Michael Dawson
Marshall Research
michael_dawson at marshallresearch dot com

NOTE: The following license is often referred to as the "MIT/X
Consortium License", as the "MIT license" and as the "X11" license.
My source for the exact wording is the copy at the Open Source
Initiative:  http://opensource.org/licenses/mit-license.html[]


@code
</t>
<t tx="ekr.20040331071919.4">@doc
@ascskip # Time-stamp: "Fri, Jan  9 09:18 CST 2004  michael@redpriest License_document_140581532.txt"
---
Terms and Conditions
 
COPYRIGHT AND PERMISSION NOTICE

Copyright (c) 1999,2000,2001,2002,2003,2004 Michael W. Dawson

All rights reserved.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, provided
that the above copyright notice(s) and this permission notice appear
in all copies of the Software and that both the above copyright
notice(s) and this permission notice appear in supporting
documentation.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE
COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR
ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY
DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
OF THIS SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale,
use or other dealings in this Software without prior written
authorization of the copyright holder.
---
@code</t>
<t tx="ekr.20040331071919.5">@doc
@ascskip # Time-stamp: "Fri, Jan  9 16:13 CST 2004  michael@redpriest Version_Requirements_140584132.txt"

This is version 0.4 of Leo2AsciiDoc.  The major version of zero
indicates that it is an in-house version, not suitable for
production use elsewhere.

It was created and tested using:

    - Leo version 4.1 (release candidate 3).  Leo2AsciiDoc was
      upgraded to use the new features in 4.1 and is no longer
      compatible with previous versions.
    - AsciiDoc version 5.0.2.  Leo2AsciiDoc was upgraded to use the
      new features in 5.0.2, and is no longer compatible with older
      versions of AsciiDoc.
    - DocBook XML DTD version 4.2 and DocBook XSL stylesheets 1.60.1
    - xsltproc 1.0.30
    - fop 0.20.5

The last three items are the DocBook tool chain I'm currently using.
Any working DocBook XML tool chain you may have is likely to work,
since the major Leo2AsciiDoc effort is in producing the XML files
the tool chain uses as input.

@code</t>
<t tx="ekr.20040331071919.6">@language plain
@doc
@ascskip # Time-stamp: "Fri, Jan  9 16:00 CST 2004  michael@redpriest The_General_Approach_140588436.txt"

Leo2AsciiDoc simply copies the text from a portion of a Leo outline
to a text file.  That text file can then be processed by other
programs to produce HTML, PDF's, etc.

The text will be copied from each outline item, in outline order,
though you can skip individual nodes or sub-trees.

The idea is that you write the outline as a book, or series of
books.

If your book contains source code, you can break it up into pieces
that make it convenient to review with the reader.  Additionally,
you can discuss the pieces in any order that you like.  Using the
"tangle" command, Leo will be able to assemble and reorder the
pieces in the order required for a file of compilable source code.

As the text is copied from the outline, Leo2AsciiDoc adds minimal markup,
generally:

    - It marks up node headlines as Titles and Section Headings
      in the AsciiDoc format.
    - Program listings have AsciiDoc section markers inserted before
      and after.

A specific list follows.

@code</t>
<t tx="ekr.20040331071919.7">@language plain
@doc
@ascskip # Time-stamp: "Fri, Jan  9 16:05 CST 2004  michael@redpriest Markup_Added_140589620.txt"

    - headings:
        * By default, all outline node headings are underlined with
          the appropriate section underline character, which
          AsciiDoc will use to transform the headings into titles:
          chapter, section1, section2, etc.
        * code extracts are given an "example" heading.
    - source code sections are marked with delimiters, so that they
      can be assigned to the DocBook "programlisting" element.
    - source code sections are line-wrapped in the document output,
      for convenient html display.
    - wherever source code is exported to a source code file, the
      document with note this with an automatically generated "note"
      element.

@code
</t>
<t tx="ekr.20040331071919.8">@language python
@tabwidth -4

@doc
@ascskip on
 @silent
NB: remove leading space from above silent directive for final clean
code.

@ascskip off
@ascskip # Time-stamp: "Thu, Dec  4 11:58 CST 2003  michael@redpriest _The_Code__140751676.py"

This chapter contains all the source code for the Leo2AsciiDoc program.
The code is arranged in an order that is convenient for discussion.

On its way from the Leo outline to this document, the code has been
reformatted for printing.  Please note that:

    - code lines that are longer than the current publishing limit
      are wrapped.  Wrapped lines end in a "\" character and have
      the remainder of the text on the next line, preceeded by 4
      spaces. The real working code is not changed in this way when
      exported for actual use.
    - Some code has been extracted as Examples, and has a title
      saying something like "Example: Interesting Code".  Rather
      than repeat that code in the main code body, there is simply a
      reference to the name, enclosed in double angle brackets:
      \&lt;&lt;Interesting Code&gt;&gt;. All extracts are indexed, see "Python
      code, extracts used" in the Index at the end of the document.

@ascskip on
@root "mod_leo2ascd.py"
__version__ = ".5" # Set version for the plugin handler.
&lt;&lt; Declarations and Utilities &gt;&gt;
&lt;&lt; Write the outline tree as AsciiDoc file &gt;&gt;
&lt;&lt; Write a node &gt;&gt;
&lt;&lt; Key Functions &gt;&gt;
@code</t>
<t tx="ekr.20040331071919.9">@doc
@ascskip # Time-stamp: "Thu, Dec  4 16:05 CST 2003  michael@redpriest _Key_Functions__141128028.py"

These are the top-level functions that can be called from the Leo menu.

The next function writes the Leo outline tree of the current node to
a text file.  It first checks to see that there is an ascfile
directive in the current node, or above it, and then calls the
WriteTreeAsAsc function to write the tree starting at the ascfile
node.

If you have several documents in one Leo outline, this function will
write out the current one.

@code

def WriteTreeOfCurrentNode(c):
    f = c.frame
    vnode = c.currentVnode() # get the current vnode.
    while vnode:
        ascFileN = GetAscFilename(vnode)
        if ascFileN == None:
            vnode = vnode.parent()
        else:
            break

    if ascFileN == None:
        g.es("Sorry, there was no @ascfile directive in this outline tree.")
    else:
        WriteTreeAsAsc(vnode, ascFileN)

@doc

The next function exports all Leo2AsciiDoc documents in the entire Leo
outline, starting at the top and working through all nodes.

@code
def WriteAll(c):
    f = c.frame
    v = c.rootVnode()
    while v:
        ascFileN = GetAscFilename(v)
        if ascFileN != None:
            WriteTreeAsAsc(v, ascFileN)
            v = v.nodeAfterTree()
        else:
            v = v.threadNext()
@doc

This function is handy to see all the Leo2AsciiDoc sub-trees and source
code sub-trees in a Leo outline.  It prints the results in the log pane.

@code

def WriteAllRoots(c):
    "Writes @root directive and/or @ascfile directive to log pane."

    patternAscDirectiveFile = re.compile(r'^@ascfile')
    patternRoot = re.compile(r'^@root')

    g.es('Looking for @root or @ascfile.')
    f = c.frame
    vnode = c.rootVnode()
    while vnode:
        bodyString = vnode.bodyString()
        lines = bodyString.splitlines()
        printedHeading = False
        for line in lines:
            printLine = False
            containsAscFileDirective = patternAscDirectiveFile.match(line)
            if containsAscFileDirective:
                printLine = True
            containsRootDirective = patternRoot.match(line)
            if containsRootDirective:
                printLine = True
            if printLine:
                if not printedHeading:
                    g.es(vnode.headString())
                    printedHeading = True
                g.es('  ' + line)
        vnode = vnode.threadNext()

@doc

Next, we simply create Leo menu items for the above functions,
assuming Leo is loading this code as a module (i.e. the Python
source has been placed in the Leo plugins directory.)  As a module,
the phrase "if 0:" must be changed to "if 1:" to activate the
module.

But while the "if 0:" is left, this code can be used as a script
from the Leo scripts menu (assuming a copy of the code has been
placed in the Leo scripts directory), implementing the WriteAll
function above. This is useful in testing.

@code
def CreateAscMenu(tag,keywords):

    """Create the Outline to AsciiDoc menu item in the Export menu."""
    
    c = keywords.get('c')
    if not c: return

    exportMenu = c.frame.menu.getMenu('export')
    newEntries = (
        ("-", None, None),
        ("Export all to &amp;AsciiDoc","Alt+Shift+A",WriteAll),
        ("Export current tree to AsciiDoc","Alt+Shift+T",WriteTreeOfCurrentNode),
        ("Log all root and ascfile to log pane","Alt+Shift+L",WriteAllRoots),
    )

    c.frame.menu.createMenuEntries(exportMenu, newEntries,dynamicMenu=True)
    
if 1:
    def init():
        ok = True
        leoPlugins.registerHandler(('new','open2'), CreateAscMenu)
        g.plugin_signon(__name__)
        return ok
else:
    WriteTreeOfCurrentNode()

@doc</t>
<t tx="ekr.20040331071919.10">@doc
@ascskip # Time-stamp: "Tue, Nov 25 11:25 CST 2003  michael@redpriest _Declarations_and_Utilities__140958380.py"

Next, we define new directives to control the way we export the Leo
text, as seen in this extract from the main code.  Directives start
with an "@" character as the first character in the line.

@code
&lt;&lt;New Leo2AsciiDoc directives&gt;&gt;=
patternAscDirectiveConfig = re.compile(r'^@ascconfig\W+(\w+)\s+(\S+)')
patternAscDirectiveFile = re.compile(r'^@ascfile *"*([\w\\/\.]*)"*')
patternAscDirectiveExit = re.compile(r"^@ascexit")
patternAscDirectiveIgnore = re.compile(r"^@ascignore")
patternAscDirectiveSkip = re.compile(r"^@ascskip")
patternAscDirectiveSkipToggle = re.compile(r"^@ascskip\s*(\w+)+.*")
@doc

Next, a class to simulate constants, and make it easy to use
them. We create a class whose variables can be assigned, but not
reassigned inadvertently. As well, the "Next" function gives us an
easy way to acquire a variable of unique value when we don't care
what that value actually is, just that it is unique.

@code
&lt;&lt;Simulate Python constants&gt;&gt;=
class   _AssignUniqueConstantValue:
    """ Provide unique value to be used as a constant """
    def __init__(self):
        self.UniqueInternalValue = 0
        self.Assign_at_start()

    class ConstError(TypeError): pass
    def __setattr__(self,name,value):
        if self.__dict__.has_key(name):
            if name != "UniqueInternalValue":
                raise self.ConstError, "Can't rebind const(%s)"%name
        self.__dict__[name]=value

    def Assign_at_start(self):
        self.END_PROGRAM = self.Next()   # signal abort
        self.LINE_WAS_NONE = self.Next() # describe last line printed
        self.LINE_WAS_CODE = self.Next()
        self.LINE_WAS_DOC  = self.Next()
        self.LINE_WAS_HEAD = self.Next()
        self.LINE_PENDING_NONE  = self.Next() # describe next line to be printed
        self.LINE_PENDING_CODE  = self.Next()
        self.LINE_PENDING_DOC   = self.Next()

    def Next(self):
        self.UniqueInternalValue += 1
        return(self.UniqueInternalValue)
@doc
@ascexit
@code
&lt;&lt;The Code -- Declarations and Utilities&gt;&gt;</t>
<t tx="ekr.20040331071919.11">@
@ascskip # Time-stamp: "Fri, Dec 19 10:42 CST 2003  michael@redpriest _The_Code_Declarations_and_Utilities__140568852.py"

Here we begin the Python program, importing the modules we need, and
signing on as the Leo2AsciiDoc module in the Leo log window.
@c

import leoGlobals as g
import leoPlugins

import re
import os

g.es("---mod_leo2asc 0.4-------")

@
Next, a class to hold our configuration data. Users can change the
Leo2AsciiDoc configuration by including an "@ascconfig" directive in the
body text of a Leo outline, either in the root node or in the same
node as an "@ascfile" directive.  User directives in the root node
override the Leo2AsciiDoc defaults. Further, directives in an ascfile
node not only override the Leo2AsciiDoc defaults, but also any user
directives in the root node.
@c

&lt;&lt;Simulate Python constants&gt;&gt;

class _ConfigOptions:
    """Hold current configuration options."""
    def __init__(self):
        self.current = {}
        self.default = {}
        self.default["maxCodeLineLength"] = '76'
        self.default["delimiterForCodeStart"] = '~-~--- code starts --------'
        self.default["delimiterForCodeEnd"]   = '~-~--- code ends ----------'
        self.default["delimiterForCodeSectionDefinition"] = '*example*'
        self.default["headingUnderlines"] = '=-~^+'
        self.default["asciiDocSectionLevels"] = '5'
        self.default["PrintHeadings"] = "on"

    def __GetNodeOptions(self, vnode):
        bodyString = vnode.bodyString()
        lines = bodyString.splitlines()
        for line in lines:
            containsAscConfigDirective = patternAscDirectiveConfig.match(line)
            if containsAscConfigDirective:
                # Leo uses unicode, convert to plain ascii
                name = str(containsAscConfigDirective.group(1))
                value = str(containsAscConfigDirective.group(2))
                if self.current.has_key(name):
                    self.current[name] = value
                else:
                    g.es(vnode.headString())
                    g.es("  No such config option: %s" % name)

    def GetCurrentOptions(self,c,vnode):
        self.current.clear()
        self.current = self.default.copy()
        v = c.rootVnode()
        self.__GetNodeOptions(v)             # root node
        self.__GetNodeOptions(vnode)         # current node

# ----- assign constants ---------------------------------------------------
CV = _AssignUniqueConstantValue()
CV.NODE_IGNORE = CV.Next()              # demo of adding in code
Conf = _ConfigOptions()

# ----- globals ------------------------------------------------------------
#   compile the patterns we'll be searching for frequently
patternSectionName = re.compile("\&lt;\&lt; *(.+?) *\&gt;\&gt;")
patternSectionDefinition = re.compile("(\&lt;\&lt; *)(.+?)( *\&gt;\&gt;)(=)")
patternDirective = re.compile(r"^@")
patternCodeDirective = re.compile(r"^(@c *$)|(@code)")
patternDocDirective = re.compile(r"^(@ |@doc)(.*)")
patternRootDirective = re.compile(r"^@root\s+(.+)")
patternAscDirective = re.compile(r"^@asc")
&lt;&lt;New Leo2AsciiDoc directives&gt;&gt;
@doc

AsciiDoc recognizes titles and section headings by the underlining (a
line of characters on the next line after the text) with a line
of flag characters.  This function calculates the section level
(considering the ascfile node to be the top or "book" level) and
creates the appropriate string of flag characters.

@code
def SectionUnderline(h,level,v):
    'Return a section underline string.'
    asciiDocSectionLevels = int(Conf.current["asciiDocSectionLevels"])
    if level &lt; 0:
        g.es("Section level is less than 1:\n  %s" % v.headString())
        level = 1
    elif level &gt; asciiDocSectionLevels - 1:
        g.es("Section level is more than maximum Section Levels: %d\n  %s" \
           % (asciiDocSectionLevels, v.headString()))
        level = asciiDocSectionLevels - 1
    str = Conf.current["headingUnderlines"][level]  #'
    return str*max(len(h),1)
@doc

GetAscFilename is a frequently used function that checks a node for
the presence of an "@ascfile" directive, which specifies the name
and location of the Leo2AsciiDoc output file.

Leo2AsciiDoc will not export text without finding a file name. If no path
is given, the file will be created in the same directory as the Leo
outline.

@code
def GetAscFilename(c,vnode):
    'Checks a node for a filename directive.'
    # f is the Leo outline
    ascFileName = None
    bodyString = vnode.bodyString()
    lines = bodyString.splitlines()
    for line in lines:
        containsAscFileDirective = patternAscDirectiveFile.match(line)
        if containsAscFileDirective:
            ascFileName = containsAscFileDirective.group(1)
            if (ascFileName != None):
                base = os.path.split(c.mFileName)[0]  # linux or windows
                if (((base[0]=="/") and (ascFileName[0] != "/")) or 
                   ((base[1]==":") and (ascFileName[1] != ":"))): 
                    # no full pathname specified
                    ascFileName = os.path.join(base, ascFileName)
                Conf.GetCurrentOptions(vnode)
    return ascFileName
        
@doc

CodeChunk splits a line of text into chunks of a maximum length.
This is used in exporting source code sections of the Leo outline
for publication.

@code
def CodeChunk(text, width=72):
    """Split a line of text into a list of chunks not longer
    than width."""
    chunkList = []
    chunkStart = 0
    chunkEnd = 0
    lastSpacePosition = 0
    shortWidth = width - 4
    prefix = ''
    suffix = ' \\'
    textLen = len(text)
    if width &gt; textLen:
        chunkList.append(text)
    else:
        while chunkEnd &lt; textLen:
            if len(chunkList) &gt; 0:
                prefix = '  '
            chunkEnd = chunkStart + shortWidth
            if chunkEnd &gt; textLen:
                chunkList.append(prefix + text[chunkStart:])
                chunkEnd = textLen          # get out of jail
            else:
                lastSpacePosition = text.rfind(' ',chunkStart, chunkEnd +1)
                if lastSpacePosition != -1:  # success
                    chunkList.append(prefix + text[chunkStart:lastSpacePosition] + ' \\')
                    chunkStart = lastSpacePosition + 1
                else:
                    chunkEnd = chunkStart + shortWidth
                    chunkList.append(prefix + text[chunkStart:chunkEnd] + ' \\')
                    chunkStart = chunkEnd
    return chunkList</t>
<t tx="ekr.20040331071919.12">@doc
@ascskip # Time-stamp: "Thu, Dec  4 15:28 CST 2003  michael@redpriest _Write_the_outline_tree_as_AsciiDoc_file__141131100.py"

This function opens the output file and walks the tree of outline
nodes under the node that is passed as the first parameter.  At each
node, it calls our workhorse "WriteNode".


@code
def WriteTreeAsAsc(vnode, ascFileN):
    'Writes the tree under vnode to the file ascFile'
    def CleanUp():
        'Cleanup on exit'
        ascFile.close()

    writeNodeReturnValue = None
    startinglevel = vnode.level()
    try:
        ascFile = file(ascFileN,'w')
    except IOError:
        g.es("Could not open output file: %s" % ascFileN)
        return
    stopHere = vnode.nodeAfterTree()
    v = vnode
    while v != stopHere:
        writeNodeReturnValue = WriteNode(v, startinglevel, ascFile)
        if  writeNodeReturnValue == CV.END_PROGRAM:
            CleanUp()
            return
        elif  writeNodeReturnValue == CV.NODE_IGNORE:
            v = v.nodeAfterTree()       # ran into an @ascignore
        else:
            v = v.threadNext()

    CleanUp()
    g.es('Wrote: '+`ascFileN`)





</t>
<t tx="ekr.20040331071919.13">@doc
@ascskip # Time-stamp: "Fri, Jan  9 13:58 CST 2004  michael@redpriest _Write_a_node__140596620.py"

This is the workhorse of the program, exporting the text in a node
to the output file in a way that the AsciiDoc program will
recognize.

The basic activity is:
    - output the node headline as a DocBook section heading (Book,
      Chapter, Section1, Section2, etc.)
    - scan each line of the body text for directives, and take the
      appropriate action.  Regular expressions do the heavy lifting.
    - mark the code sections and documentation sections, so that
      DocBook can print them in the correct styles.
    - ensure that code lines do not exceed a maximum length.



@code
def WriteNode(v,startinglevel, ascFile):

    'Writes the contents of the node v to the ascFile.'

    containsAscIignore = None          # initialize
    skippingDocLines = False
    startingCodeExtract = False
    inCodeExtract = False
    statusOfWriteOutputLine = None

    def WriteOutputLine(lineString):

        'Writes a line of text to the output file.'
        try:
            ascFile.write("%s\n" % lineString)
        except IOError:
            g.es("Could not write to output file: %s" % ascFile.name)
            statusOfWriteOutputLine = CV.END_PROGRAM


    # ----- get the headline text ------------------------------------------
    h = v.headString()
    markedupAsSection = patternSectionName.match(h)
    if markedupAsSection:
        h = markedupAsSection.group(1) # dump the angle brackets

    # ----- put the body text into a list of lines -------------------------
    bodyString = v.bodyString()
    lines = bodyString.splitlines()

    lastLinePrintedType = CV.LINE_WAS_NONE
    # ----- by default, nodes start with a code section --------------------
    pendinglineType = CV.LINE_PENDING_CODE

    for line in lines:
        containsRootDirective = None

@doc

If this line starts a code extract, called a Section Definition
here, then extract the text to use as the title and set the
"startingCodeExtract" flag to guide further processing.

@code
        containsSectionDefinition = patternSectionDefinition.match(line)
        if containsSectionDefinition:
            # dump the angle brackets, etc.
#             line = containsSectionDefinition.group(2)  + '\n' + \
#                    (SectionUnderline(containsSectionDefinition.group(2),2,v))
            line = '.' + containsSectionDefinition.group(2)
            pendinglineType = CV.LINE_PENDING_CODE
            startingCodeExtract = True
@doc

Check if this line starts a @doc or @code section.

@code
        containsCodeDirective = patternCodeDirective.match(line)
        if containsCodeDirective:
            pendinglineType = CV.LINE_PENDING_CODE
            skippingDocLines = False
            continue                    # don't print this line

        containsDocDirective = patternDocDirective.match(line)
        if containsDocDirective:
            pendinglineType = CV.LINE_PENDING_DOC
            if containsDocDirective.group(2):
                # it is legal to have text on the same line
                # as a doc directive.
                line = containsDocDirective.group(2)
            else:
                continue
@doc

Check line for a Leo2AsciiDoc directive, and if so, act on it.

@code
        containsAscDirective = patternAscDirective.match(line)
        if containsAscDirective:
            containsAscIignore = patternAscDirectiveIgnore.match(line)
            if containsAscIignore:
                break

            containsAscExit = patternAscDirectiveExit.match(line)
            if containsAscExit:
                break

            containsAscSkip = patternAscDirectiveSkip.match(line)
            if containsAscSkip:
                containsAscSkipDirectiveToggle = patternAscDirectiveSkipToggle.match(line)
                if containsAscSkipDirectiveToggle:
                    if containsAscSkipDirectiveToggle.group(1).lower() == "on":
                        skippingDocLines = True
                    elif containsAscSkipDirectiveToggle.group(1).lower() == "off":
                        skippingDocLines = False
                continue

        containsOtherDirective = patternDirective.match(line)
        if containsOtherDirective:
            containsRootDirective = patternRootDirective.match(line)
            if containsRootDirective:
                line = "*note*\nThe code sections that follow, when extracted from a " + \
                       "Leo outline, will be located in: %s\n*note*" % \
                       containsRootDirective.group(1)
            else:
                continue

        # ----- we have something to print, so print heading ---------------
        if lastLinePrintedType == CV.LINE_WAS_NONE:
            if (len(h) &gt; 0) and (Conf.current["PrintHeadings"] == "on"):
                WriteOutputLine("\n\n%s" % h)
                WriteOutputLine(SectionUnderline(h,v.level()-startinglevel,v))
                lastLinePrintedType = CV.LINE_WAS_HEAD
@doc

Here we manage the transitions between code and doc sections.

@code
        if pendinglineType == CV.LINE_PENDING_DOC:
            if lastLinePrintedType != CV.LINE_WAS_DOC and \
               lastLinePrintedType != CV.LINE_WAS_HEAD:
                WriteOutputLine("%s" % Conf.current["delimiterForCodeEnd"])
                if inCodeExtract:
                    WriteOutputLine("\n%s" % Conf.current["delimiterForCodeSectionDefinition"])
                    inCodeExtract = False
                lastLinePrintedType = CV.LINE_WAS_DOC
            if skippingDocLines:
                if not containsRootDirective: # always document a root directive
                    continue

        if pendinglineType == CV.LINE_PENDING_CODE:
            if lastLinePrintedType != CV.LINE_WAS_CODE:
                if startingCodeExtract:
                    WriteOutputLine("\n%s" % line)
                    WriteOutputLine("%s" % Conf.current["delimiterForCodeSectionDefinition"])
                    inCodeExtract = True
                    line = ''
                WriteOutputLine("%s" % Conf.current["delimiterForCodeStart"])
                lastLinePrintedType = CV.LINE_WAS_CODE
                if startingCodeExtract:
                    startingCodeExtract = False
                    continue
@doc

Check for maximum code line length.  Finally, output the text to the
export file.

@code
            maxCodeLineLength = int(Conf.current["maxCodeLineLength"])
            if len(line) &lt;= maxCodeLineLength:
                WriteOutputLine("%s" % line)
            elif len(line.rstrip()) &lt;= maxCodeLineLength:
                WriteOutputLine("%s" % line.rstrip())
            else:
                lineList = CodeChunk(line, maxCodeLineLength)
                for ln in lineList:
                    WriteOutputLine("%s" % ln)
            lastLinePrintedType = CV.LINE_WAS_CODE
        else:
            WriteOutputLine("%s" % line)

        if statusOfWriteOutputLine != None:
            return statusOfWriteOutputLine

@doc

Before we leave, make sure that any ending code section is marked as
ended.

@code
    if lastLinePrintedType == CV.LINE_WAS_CODE:
        WriteOutputLine("%s" % Conf.current["delimiterForCodeEnd"])
        if inCodeExtract:
            WriteOutputLine("\n%s" % Conf.current["delimiterForCodeSectionDefinition"])
            inCodeExtract = False

    if containsAscIignore != None:
        return CV.NODE_IGNORE                        # flag ignore tree to caller

@doc

</t>
<t tx="ekr.20040331071919.14">@doc
@ascskip # Time-stamp: "Tue, Jan 13 11:09 CST 2004  michael@redpriest Other_programs_140636444.txt"

The appendices are about other programs that are used with Leo.
I'm including them because they are examples of how my setup works,
for those who may be interested in setting up something similar.

    - AsciiDoc is the program that processes the output from Leo2AsciiDoc
      into a DocBook-ready XML file.
    - Setting up DocBook is a topic that is far too large for this
      little manual, but the DocBook section which follows contains
      documentation of exactly how my working system is configured.
    - The XEmacs text editor is the one I prefer, but it is not
      necessary for the use of Leo2AsciiDoc.  Others who also use XEmacs
      might find the documentation of my Leo integration and
      multi-mode support to be useful.
@code</t>
<t tx="ekr.20040331071919.15">@language plain
@ascskip Time-stamp: "Thu, Oct 30 10:58 CST 2003  michael@redpriest Appendix_AsciiDoc__140954356.txt"
@doc
anchor:AsciiDoc[AsciiDoc]

The AsciiDoc program is written by Stuart Rackham and has its own
web site at http://www.methods.co.nz/asciidoc/[], with full
documentation.

AsciiDoc is a small program, written in Python, that reads text
which is in the AsciiDoc text format. Generally speaking, ordinary
text (such as you would write in an email message) is already in the
AsciiDoc format.  The AsciiDoc program produces (among other
choices) output in the DocBook XML format.

Text exported from a Leo outline by Leo2AsciiDoc is ready to be processed
by AsciiDoc, once AsciiDoc has been configured to recognize it.

Leo2AsciiDoc comes with an AsciiDoc configuration file that will enable
AsciiDoc to process all Leo2AsciiDoc features.  The following section
describes that configuration file.

Of course, you don't need to read or understand the configuration
file to use it.  Simply put it (leo-docbook.conf) in the same
directory as AsciiDoc's "docbook.conf" file.  When you invoke
AsciiDoc (see the xref:Makefile[] section in the DocBook appendix for
examples), give the "leo-docbook.conf" file as the configuration
parameter ("-f leo-docbook.conf".)

@ascskip on
&lt;&lt; Appendix: AsciiDoc &gt;&gt;
@code
</t>
<t tx="ekr.20040331071919.16">@language python
@tabwidth -4

@doc
@ascskip # Time-stamp: "Tue, Jan 13 11:58 CST 2004  michael@redpriest _Configuration_file__140640380.py"

AsciiDoc is customized through the use of configuration files, which
cascade, so that you can include other configuration files and
then proceed to add your changes.

The main elements of the configuration file below:

    - adds chapter and web site document types
    - switches code listings to use the DocBook "programlisting"
      element 

    *note*

    If you choose to export this configuration file from the Leo
    outline, you will have to remove escape charactersfrom some
    lines after you have exported it.

    Specifically, some lines begin with the character "\".  That
    character should be removed.

    *note*

@ascskip on
@root "other/asciidoc/leo-docbook.conf"
&lt;&lt; Configuration File &gt;&gt;
@code
# Start with the standard docbook back end configuration.
# ensure the next line is uncommented before installing
\include::docbook.conf[]

@doc

I want tabs interpreted as 4 spaces.

@code
[options]
tabsize=4
@doc

Interpret an indented paragraph as a simple paragraph.

@code
[indentedparagraph]
&lt;simpara&gt;|&lt;/simpara&gt;


@doc

For our code listings we invent a new markup that will use the
DocBook programlisting element.

@code
[blockdef-leocode]
delimiter=^\~\-~--- code(.*?)$
section=programlistingblock
presubs=specialcharacters, replacements

[programlistingblock]
&lt;programlisting&gt;
|
&lt;/programlisting&gt;

@doc

We add new markup to signify the DocBook "note" element.  This
predates AsciiDoc 5.0, and is still useful.

@code
[blockdef-note]
delimiter=^ *\*note\*$
section=noteblock
presubs=specialcharacters,quotes,specialwords,replacements,macros,glossary

# Block macro
[noteblock]
&lt;note&gt;
|
&lt;/note&gt;

[blockdef-example]
delimiter=^ *\*example\*$
options=section
section=exampleblock
presubs=replacements

# Block macro
[exampleblock]
&lt;example&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/example&gt;


@doc

The following replacements ensure basic Python code indexing.

@code
[replacements]
#----- indexing markup -----------------------------------------------------
# using regular expressions because I don't want to introduce a filter, which
# would slow things down.
#
# index python classes and defs
^(def +)(.+?)(\(.+:)=\1\2\3&lt;indexterm&gt;&lt;primary&gt;Python code, functions&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 
^(class +)(.+?)(:)=\1\2\3&lt;indexterm&gt;&lt;primary&gt;Python code, classes&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 
^( +def +)(.+?)(\(.+:)=\1\2\3&lt;indexterm&gt;&lt;primary&gt;Python code, methods and nested functions&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 

# index code extracts
(\&amp;lt\;\&amp;lt\;)(.+?)(\&amp;gt\;\&amp;gt\;\=)=\2&lt;indexterm&gt;&lt;primary&gt;Python code, extracts explained&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt;
(\&amp;lt\;\&amp;lt\;)(.+?)(\&amp;gt\;\&amp;gt\;)(\s*$)=\1\2\3\4&lt;indexterm&gt;&lt;primary&gt;Python code, extracts used&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 

@doc

Change the standard AsciiDoc article, book and manpage definition to
use the DocBook 4.2 DTD.  Add an empty index element to the end of
the book definition so that DocBook will automatically generate an
index.

@code
#---------------------------------------------------------------------------
#----- article -------------------------------------------------------------
#---------------------------------------------------------------------------

# changing to our version of the docbook dtd
\ifdef::doctype-article[]

[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE article
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;

&lt;article lang="en"&gt;
&lt;articleinfo&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
    &lt;date&gt;{date}&lt;/date&gt;
    &lt;author&gt;
        &lt;firstname&gt;{firstname}&lt;/firstname&gt;
        &lt;othername&gt;{middlename}&lt;/othername&gt;
        &lt;surname&gt;{lastname}&lt;/surname&gt;
        &lt;affiliation&gt;
            &lt;address&gt;
                &lt;email&gt;{email}&lt;/email&gt;
            &lt;/address&gt;
        &lt;/affiliation&gt;
    &lt;/author&gt;
    &lt;authorinitials&gt;{authorinitials}&lt;/authorinitials&gt;
    &lt;revhistory&gt;&lt;revision&gt;&lt;revnumber&gt;{revision}&lt;/revnumber&gt;&lt;date&gt;{date}&lt;/date&gt;&lt;/revision&gt;&lt;/revhistory&gt;
    &lt;corpname&gt;{companyname}&lt;/corpname&gt;
&lt;/articleinfo&gt;

\endif::doctype-article[]


#---------------------------------------------------------------------------
#----- book ----------------------------------------------------------------
#---------------------------------------------------------------------------
# change to our version of docbook dtd

\ifdef::doctype-book[]

[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE book
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;

&lt;book lang="en"&gt;
&lt;bookinfo&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
    &lt;date&gt;{date}&lt;/date&gt;
    &lt;author&gt;
        &lt;firstname&gt;{firstname}&lt;/firstname&gt;
        &lt;othername&gt;{middlename}&lt;/othername&gt;
        &lt;surname&gt;{lastname}&lt;/surname&gt;
        &lt;affiliation&gt;
            &lt;address&gt;
                &lt;email&gt;{email}&lt;/email&gt;
            &lt;/address&gt;
        &lt;/affiliation&gt;
    &lt;/author&gt;
    &lt;authorinitials&gt;{authorinitials}&lt;/authorinitials&gt;
    &lt;revhistory&gt;&lt;revision&gt;&lt;revnumber&gt;{revision}&lt;/revnumber&gt;&lt;date&gt;{date}&lt;/date&gt;&lt;/revision&gt;&lt;/revhistory&gt;
    &lt;corpname&gt;{companyname}&lt;/corpname&gt;
&lt;/bookinfo&gt;


[footer]
&lt;index/&gt;
&lt;/book&gt;

\endif::doctype-book[]

#---------------------------------------------------------------------------
#----- manpage -------------------------------------------------------------
#---------------------------------------------------------------------------
\ifdef::doctype-manpage[]

[header]
&lt;!DOCTYPE refentry
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;
&lt;refentry&gt;
# The refentryinfo element is legal and should not normally be printed.
# Unfortunately some docbook processors do print it.
&lt;refentryinfo&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
    &lt;date&gt;{date}&lt;/date&gt;
    &lt;author&gt;
        &lt;firstname&gt;{firstname}&lt;/firstname&gt;
        &lt;othername&gt;{middlename}&lt;/othername&gt;
        &lt;surname&gt;{lastname}&lt;/surname&gt;
        &lt;affiliation&gt;
            &lt;address&gt;
                &lt;email&gt;{email}&lt;/email&gt;
            &lt;/address&gt;
        &lt;/affiliation&gt;
    &lt;/author&gt;
    &lt;authorinitials&gt;{authorinitials}&lt;/authorinitials&gt;
    &lt;revhistory&gt;&lt;revision&gt;&lt;revnumber&gt;{revision}&lt;/revnumber&gt;&lt;date&gt;{date}&lt;/date&gt;&lt;/revision&gt;&lt;/revhistory&gt;
    &lt;corpname&gt;{companyname}&lt;/corpname&gt;
&lt;/refentryinfo&gt;
&lt;refmeta&gt;
&lt;refentrytitle&gt;{mantitle}&lt;/refentrytitle&gt;
&lt;manvolnum&gt;{manvolnum}&lt;/manvolnum&gt;
&lt;/refmeta&gt;
&lt;refnamediv&gt;
    &lt;refname&gt;{manname}&lt;/refname&gt;
    &lt;refpurpose&gt;{manpurpose}&lt;/refpurpose&gt;
&lt;/refnamediv&gt;

\endif::doctype-manpage[]



@doc

Add chapter and website document types.

@code
#---------------------------------------------------------------------------
#----- new: chapter --------------------------------------------------------
#---------------------------------------------------------------------------
\ifdef::doctype-chapter[]

[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE chapter
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;
&lt;chapter&gt;
&lt;title&gt;{doctitle}&lt;/title&gt;

[footer]
&lt;/chapter&gt;


# Section macros
# Using &lt;abstract&gt; semantics restricts preface to &lt;simpara&gt; elements.
[preface]
|

[sect1]
&lt;sect1&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/sect1&gt;

[sect2]
&lt;sect2&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/sect2&gt;

[sect3]
&lt;sect3&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/sect3&gt;

[options]
outfilesuffix=.xml

\endif::doctype-chapter[]

@doc

Website requires a unique id for each page.  I've changed AsciiDoc
to provide the HTML filename as the id, and we use it here. We'll
use the date the XML file was created as the update date.

@code
#---------------------------------------------------------------------------
#----- new: website --------------------------------------------------------
#---------------------------------------------------------------------------
\ifdef::doctype-website[]
[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE webpage SYSTEM "website-full.dtd"&gt;
&lt;webpage id="{infilebase}"&gt;
  &lt;head&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
  &lt;/head&gt;
  &lt;config param="rcsdate" value="Updated: {localdate}  {localtime}"/&gt;
[footer]
&lt;/webpage&gt;

[options]
outfilesuffix=.xml

\endif::doctype-website[]

</t>
<t tx="ekr.20040331071919.17">@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 14:11 CST 2004  michael@redpriest _Patches__140641532.txt"

I've patched the source code for AsciiDoc (asciidoc.py) with a few
small changes to allow AsciiDoc to process chapters and DocBook
web site documents as well as the DocBook book format.  Since I use
Linux, I also changed the default line-ending code to the Linux
default.

For the exact changes I made, the following output at the end of
this section was created by GNU diff (version 2.8.4) with the
command

---
LC_ALL=C TZ=UTC0 diff -Naur 5.0.2-original 5.0.2-mrc-patched \
    &gt;mrc-asciidoc-5.0.2-patch-diff
---

I include this mainly so that you can see the exact changes I made.
However, you may want to patch a copy of the original in exactly the
same way. 

To patch a copy of the original asciidoc.py (version 5.0.2), one
would use the patch command as follows (when in the same directory
as the copy of asciidoc.py and mrc-asciidoc-5.0.2-patch-diff)

---
patch -Np1 &lt;mrc2-asciidoc-5.0.2-patch-diff
---

@ascskip on
@root "other/asciidoc/mrc-asciidoc-5.0.2-patch-diff"
&lt;&lt; Patches &gt;&gt;
@code
diff -Naur 5.0.2-original/asciidoc.py 5.0.2-mrc-patched/asciidoc.py
--- 5.0.2-original/asciidoc.py	2003-12-16 00:16:28.000000000 +0000
+++ 5.0.2-mrc-patched/asciidoc.py	2004-01-08 17:45:37.000000000 +0000
@@ -838,12 +838,15 @@
         '''Set predefined glossary entries that follow configuration file
         loading.'''
         self.glossary['infile'] = reader.fname
+        # mwd Monday, June 23, 2003 for use in website
+        self.glossary['infilebase'] = os.path.splitext(os.path.split(reader.fname)[1]) [0]
         self.glossary['outfile'] = reader.fname
         s = os.path.splitext(writer.fname)[1][1:]   # Output file extension.
         self.glossary['filetype'] = s
         self.glossary['filetype-'+s] = ''
     def translate(self):
-        assert self.doctype in ('article','manpage','book'), \
+        # mwd 2003-Jun-23 assert self.doctype in ('article','manpage','book'), \
+        assert self.doctype in ('article','chapter','website','manpage', 'book'), \
             'illegal document type'
         assert self.level == 0
         reader.tabsize = config.tabsize
@@ -864,7 +867,8 @@
             if not config.suppress_headers:
                 hdr = config.subs_section('header',{})
                 writer.write(hdr)
-            if self.doctype in ('article','book'):
+            # mwd 2003-Jun-23 if self.doctype in ('article','book'):
+            if self.doctype in ('article','book','chapter','website'):
                 # Translate 'preamble' (untitled elements between header
                 # and first section title).
                 if Lex.next() is not Title:
@@ -952,7 +956,7 @@
                 # Parse revision line.
                 s = reader.read()
                 s = subs_glossary([s])[0]
-                # Match RCS/CVS $Id$ marker format.
+                # Match RCS/CVS $Id$ marker format.
                 mo = re.match(r'^\$Id: \S+ (?P&lt;revision&gt;\S+)' \
                     ' (?P&lt;date&gt;\S+) \S+ \S+ \S+ \$$',s)
                 if not mo:
@@ -2573,7 +2577,8 @@
 
 class Writer:
     '''Writes lines to output file.'''
-    EOL = '\r\n'    # End of line terminator.
+    # mwd 2003-Jun-23 EOL = '\r\n'    # End of line terminator.
+    EOL = '\n'    # End of line terminator.
     f = None        # Output file object.
     fname= None     # Output file name.
     lines_out = 0   # Number of lines written.
@@ -3068,7 +3073,8 @@
     The AsciiDoc document is read from file object src the translated
     DocBook file written to file object dst.'''
     try:
-        if doctype not in ('article','manpage','book'):
+        # mwd-2004-Jan-05 if doctype not in ('article','manpage','book'):
+        if doctype not in ('article','chapter','website','manpage', 'book'):
             raise EAsciiDoc,'illegal document type'
         if backend == 'linuxdoc' and doctype != 'article':
             raise EAsciiDoc,'%s %s documents are not supported' \
</t>
<t tx="ekr.20040331071919.18">@language plain
@ascskip Time-stamp: "Fri, Dec 19 11:48 CST 2003  michael@redpriest Appendix_DocBook_140578660.txt"
@doc

anchor:DocBook[DocBook]
DocBook is a project that provides:

    - a specification for the text markup (DTD) of DocBook XML
      documents, and
    - a set of XSLT stylesheets that can be used by an XSLT engine
      to transform those XML documents to HTML, PDF, etc.
      
If you create your text documents using the rules in the DocBook
DTD, you can use the DocBook XSLT stylesheets to produce various
output formats, such as HTML and PDF.

The DocBook project is designed for the production of computer
documentation, but is actually used for a wide variety of documents.

Some web resources:

    - the official home page for DocBook: The Definitive Guide:
        http://docbook.org/[]
    - DocBook Basics:
        http://www.dpawson.co.uk/docbook/reference.html[]
    - DocBook Open Repository:
        http://sourceforge.net/projects/docbook/[]
    - DocBook XSL: The Complete Guide:
        http://www.sagehill.net/docbookxsl/index.html[]

I include this section as documentation of one setup that works --
it translates Leo2AsciiDoc output to HTML and PDF.

This is not a guide to the installation, setup and operation of
DocBook, just an example of a working system.

@ascskip on
&lt;&lt; Appendix: DocBook &gt;&gt;
@code
</t>
<t tx="ekr.20040331071919.19">@doc
@ascskip # Time-stamp: "Thu, Jan  8 13:57 CST 2004  michael@redpriest _Tool_Chain__140810780.txt"

Documents go through a number of stages in their creation.  Each
stage may involve one or more tools or programs, which form a tool
chain: each performing some processing and handing off to the next.

As a simple example, for this document:


    - text creation was handled by XEmacs, a text
      editor (which functioned as a Leo plugin.)
      indexterm:[XEmacs]
      indexterm:[GNU Make]
      indexterm:[AsciiDoc]
      indexterm:[xsltproc]
      indexterm:[FOP]
    - text storage and organization was handled by Leo, an outlining
      editor.
    - text was exported from Leo to a plain-text file, using the
      Leo2AsciiDoc program.
    - from there, all transformations are automated by the
      GNU Make program.
    - the DocBook XML document was created by the
      AsciiDoc program, which transformed the
      plain-text file to XML.
    - The HTML pages were created by the
      xsltproc program. xsltproc read the XML
      document, and the DocBook XSLT stylesheets, and then created
      each HTML page.
    - To make the PDF file, the xsltproc program used the same
      process as for the HTML pages, except that it created a
      Formatting Objects (FO) file instead.  Then the
      FOP program processed the FO file, producing
      the final PDF file.  This process was also automated.

All I did was type in text for each section, arranging it much as I
usually do for email.  The rest was handled automatically by
clicking on a Leo menu, or entering a short command at the console.
For example: "make all".

There are many, many choices of tools to put in your DocBook tool
chain.  You can even purchase complete packages, from text editing
to PDF generation.

@code</t>
<t tx="ekr.20040331071919.20">@language plain
@tabwidth 4
@doc
@ascskip # Time-stamp: "Thu, Jan 15 15:39 CST 2004  michael@redpriest _Make_File__140651828.txt"

anchor:Makefile[Makefile]
In my case, I use a standard unix-style "make" setup for processing
the text exported from a Leo outline.  It simply automates the
commands which I would otherwise have to type at the command line.

After Leo2AsciiDoc exports the text from the Leo outline to a disk file,
the Make program takes over.  It reads rules in a file named
"Makefile" and calls the necessary programs to make the
requested output.

This Makefile takes over where Leo2AsciiDoc leaves off.  It directs the
AsciiDoc conversion of the Leo2AsciiDoc text file to XML, and then the
DocBook conversion of the XML file to HTML pages or a PDF document.

indexterm:[GNU Make]
I use GNU Make.  For example, assuming I am in xterm and located in
the same directory as the Makefile, I just enter the command

---
make pdf-dev
---
and the make program guides the creation of the PDF version of The
Developers Guide, using the instructions in this Makefile.  The PDF
is available within seconds.

The Makefile instructions, in brief:

    - the AsciiDoc program is called to make an XML file.
    - the xsltproc program is called to process the XML file to
      either HTML or a Formatting Objects file for further
      translation to PDF
        * various XSLT style sheets (html.xsl, man.xsl, etc.) are
          used by xsltproc to guide the transformation of the XML
          file.  Typically, they call the DocBook stylesheets for
          the heavy lifting, and set a few simple options.
    - the FOP program is used to process the intermediate fo file to
      the final PDF file.

This is by no means a model Makefile.  It is included because it
works for me in my office, and may thus be useful as an example for
other people who want to set up Make for this purpose.

@ascskip xemacs-makefile-mode-on
@ascskip on
@root "doc/Makefile"
&lt;&lt; Make File &gt;&gt;
@code
#----- global variables -----------------------------------------
DEVGUIDE=mod_asc_dev
USERGUIDE=mod_asc_user
CSS=dbstyle.css

MAN=${DOC}.1
STYLESHEET_MAN=man.xsl
# default docbook, located by /etc/xml/catalog
STYLESHEET_MAN_HTML=docbook.xsl
MAN_OUTPUT_DIR=man

STYLESHEET_HTML=html.xsl
HTML_DEV_OUTPUT_DIR=html-dev
HTML_USER_OUTPUT_DIR=html-user
STYLESHEET_CHUNK=chunkit.xsl
CHUNK_DEV_OUTPUT_DIR=chunk-dev
CHUNK_USER_OUTPUT_DIR=chunk-user

STYLESHEET_FO_FOP=fo-fop.xsl
PDF_DEV_OUTPUT_DIR=pdf-dev
PDF_USER_OUTPUT_DIR=pdf-user

ASCIIDOC_COMMAND=python asciidoc/asciidoc.py -v -b docbook -d book
ASCIIDOC_CONFIG=asciidoc/leo-docbook.conf

#   $@ target file name
#   $&lt; name of the first prerequisite
#   $* stem that rule matched

#----- pattern rules -------------------------------------------------------
%.xml	:	%.asc
#	asciidoc -b docbook -d book -f ${ASCIIDOC_CONFIG} -o $@ $&lt;
    ${ASCIIDOC_COMMAND}  -f ${ASCIIDOC_CONFIG} -o $@ $&lt;
    xsltproc --output $*.final.xml customize.xsl $@


%.html	:	%.xml css
    xsltproc --xinclude --output ${OUTPUT} ${STYLESHEET}  $*.final.xml
    touch $*.xml

%.pdf	:	%.xml
    xsltproc --xinclude  --output ${OUTPUT}/$*.fo $(STYLESHEET) $*.final.xml
    fop -fo  ${OUTPUT}/$*.fo  -pdf ${OUTPUT}/$*.pdf 
    -$(RM) ${OUTPUT}/$*.fo

#----- usage ---------------------------------------------------------------
usage	:
    @echo; echo "primary make modules: html-dev chunk-dev pdf-dev"
    @echo       "                      html-user chunk-user pdf-user"
    @echo



#---------------------------------------------------------------------------
#----- modules -------------------------------------------------------------
#---------------------------------------------------------------------------

# docbook
#---------------------------------------------------------------------------

all	:	css pdf-dev html-dev sub-chunk-dev html-user sub-chunk-user pdf-user

#----- DocBook html stylesheet ---------------------------------------------
css:
    cat base.css   &gt;  $(CSS)
    cat docstyle.css &gt;&gt; $(CSS)

#----- Developers Guide ----------------------------------------------------
#   #----- one page -----------------------------------------------------
html-dev	:	STYLESHEET=$(STYLESHEET_HTML)
html-dev	:	OUTPUT=${HTML_DEV_OUTPUT_DIR}/$*.html
html-dev	:	mkdirhtmldev ${DEVGUIDE}.html
    cp ${CSS} ${HTML_DEV_OUTPUT_DIR}

mkdirhtmldev	:	cleanhtmldev
    mkdir ${HTML_DEV_OUTPUT_DIR}

#   #----- individual pages ------------------------------------------------
chunk-dev	:	STYLESHEET=$(STYLESHEET_CHUNK)
chunk-dev	:	OUTPUT=$(CHUNK_DEV_OUTPUT_DIR)/
chunk-dev	:	mkdirchunkdev ${DEVGUIDE}.html
    cp chunk-dev-frame*.html ${CHUNK_DEV_OUTPUT_DIR}
    cp ${CSS} ${CHUNK_DEV_OUTPUT_DIR}
    cp frametoc.css ${CHUNK_DEV_OUTPUT_DIR}
    cp -r ../graphics ${CHUNK_DEV_OUTPUT_DIR}
# put in frame target line
    sed -f sed-dev-frame ${CHUNK_DEV_OUTPUT_DIR}/index.html &gt;${CHUNK_DEV_OUTPUT_DIR}/chunk-dev-frame-toc.html

mkdirchunkdev	:	cleanchunkdev
    mkdir ${CHUNK_DEV_OUTPUT_DIR}

sub-chunk-dev	:
    ${MAKE} chunk-dev

#----- Users Guide ---------------------------------------------------------
#   #----- one page -----------------------------------------------------
html-user	:	STYLESHEET=$(STYLESHEET_HTML)
html-user:	OUTPUT=${HTML_USER_OUTPUT_DIR}/$*.html
html-user:	mkdirhtmluser ${USERGUIDE}.html
    cp ${CSS} ${HTML_USER_OUTPUT_DIR}

mkdirhtmluser	:	cleanhtmluser
    mkdir ${HTML_USER_OUTPUT_DIR}

#   #----- individual pages ------------------------------------------------
chunk-user	:	STYLESHEET=$(STYLESHEET_CHUNK)
chunk-user	:	OUTPUT=$(CHUNK_USER_OUTPUT_DIR)/
chunk-user	:	cleanchunkuser ${USERGUIDE}.html
    cp chunk-user-frame*.html ${CHUNK_USER_OUTPUT_DIR}
    cp ${CSS} ${CHUNK_USER_OUTPUT_DIR}
    cp frametoc.css ${CHUNK_USER_OUTPUT_DIR}
    cp -r ../graphics ${CHUNK_USER_OUTPUT_DIR}
# put in frame target line
    sed -f sed-user-frame ${CHUNK_USER_OUTPUT_DIR}/index.html &gt;${CHUNK_USER_OUTPUT_DIR}/chunk-user-frame-toc.html

mkdirchunkuser	:	cleanchunkuser
    mkdir ${CHUNK_USER_OUTPUT_DIR}

sub-chunk-user	:
    ${MAKE} chunk-user

#   #----- pdf -------------------------------------------------------------
pdf-dev		:	STYLESHEET=$(STYLESHEET_FO_FOP)
pdf-dev		:	OUTPUT=$(PDF_DEV_OUTPUT_DIR)
pdf-dev		:	mkdirpdf ${DEVGUIDE}.pdf

pdf-user		:	STYLESHEET=$(STYLESHEET_FO_FOP)
pdf-user		:	OUTPUT=$(PDF_USER_OUTPUT_DIR)
pdf-user		:	mkdirpdf ${USERGUIDE}.pdf

#   mkdirpdf exists only to make an empty directory for the pdf working files
mkdirpdf	:
    -mkdir $(PDF_DEV_OUTPUT_DIR)
    -mkdir $(PDF_USER_OUTPUT_DIR)




#----- clean ---------------------------------------------------------------
clean	: cleanhtml cleanchunk cleanpdf cleanman cleanclutter 

cleanhtml	:	cleanhtmluser cleanhtmldev

cleanhtmluser	:
    -$(RM) -r $(HTML_USER_OUTPUT_DIR)

cleanhtmldev	:
    -$(RM) -r $(HTML_DEV_OUTPUT_DIR)

cleanchunk	:	cleanchunkuser cleanchunkdev

cleanchunkuser	:
    -$(RM) -r $(CHUNK_USER_OUTPUT_DIR)

cleanchunkdev	:
    -$(RM) -r $(CHUNK_DEV_OUTPUT_DIR)

cleanpdf	:
    -$(RM) -r $(PDF_OUTPUT_DIR)

cleanman	:
    -$(RM) -r $(MAN_OUTPUT_DIR)

cleanclutter: 
    -$(RM) -r *.xml

.PRECIOUS	:	%.xml
@doc
@ascskip xemacs-makefile-mode-off
@code
</t>
<t tx="ekr.20040331071919.21">@silent
@doc
@ascskip # Time-stamp: "Wed, Oct  1 15:33 CST 2003  michael@redpriest _Style_Sheets__140741140.txt"

When the Makefile calls the xsltproc program, it gives it the name
of an XSLT stylesheet to guide the production of the result.

Following are simple XSLT stylesheets that are used to:
    - set formatting options, and
    - call the main DocBook XSLT stylesheets.

The stylesheets cascade (each adding its options to the total), with
the original stylesheet including others as needed, and always
calling the main DocBook stylesheets at some point.

@code
</t>
<t tx="ekr.20040331071919.22">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:01 CST 2004  michael@redpriest _General__139758588.txt"

indexterm:[Stylesheets, common-links.xsl]
This is the entire common-links style sheet ("common-links.xsl"),
which sets basic Table of Contents and chapter cross-reference
preferences.

This stylesheet is called by both HTML and PDF stylesheets.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/common-links.xsl"
&lt;&lt; General &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 

&lt;!--===== 
    This changes a chapter cross-reference to include the chapter
    title text. 
--&gt;
&lt;xsl:param name="local.l10n.xml" select="document('')"/&gt; 
&lt;l:i18n xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0"&gt; 
  &lt;l:l10n language="en"&gt; 
    &lt;l:context name="xref"&gt; 
      &lt;l:template name="chapter" text="Chapter %n: &amp;#8220;%t&amp;#8221;"/&gt; 
    &lt;/l:context&gt;   
  &lt;/l:l10n&gt;
&lt;/l:i18n&gt;

&lt;xsl:param name="generate.toc"&gt;
book      toc,title,figure,table,example,equation
chapter   title
&lt;/xsl:param&gt;

&lt;!-- only 1 toc in the doc --&gt;
&lt;xsl:param name="generate.section.toc.level" select="1"/&gt;

&lt;!-- toc shows 3 levels of sections --&gt;
&lt;xsl:param name="toc.section.depth"&gt;3&lt;/xsl:param&gt;

&lt;xsl:param name="generate.index" select="1"&gt;&lt;/xsl:param&gt;

&lt;!--===== omit the title for notes, tips ================================--&gt;
&lt;xsl:param name="admon.textlabel" select="0"&gt;&lt;/xsl:param&gt;

&lt;/xsl:stylesheet&gt;
@doc
@ascskip xemacs-xsl-mode-off


</t>
<t tx="ekr.20040331071919.23">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 20 11:42 CST 2004  michael@redpriest _Customize__141637044.txt"


indexterm:[customize.xsl]
This is the entire customize style sheet ("customize.xsl", which is
used by the Makefile to make changes to the standard xml file
produced from the AsciiDoc output.  It results in a file suffixed
".final.xml" which is used by both the HTML and PDF stylesheets.

Currently, the stylesheet copies the xml file:

    - changing any chapter elements that have a title beginning
      with "Appendix: " to DocBook appendix elements.  This is from
      AsciiDoc 3.2 days, when AsciiDoc didn't know about appendix
      elements. I haven't yet modified Leo2AsciiDoc to take
      advantage of the automatic appendix elements in AsciiDoc 5.0.
    - adding custom bookinfo elements

I've used XSLT for this, but it could have been done with python,
AWK, sed, or other tools.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/customize.xsl"
&lt;&lt; Customize &gt;&gt;
@code
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="1.0"&gt;

&lt;xsl:variable name="AppendBegin"&gt;Appendix: &lt;/xsl:variable&gt;

&lt;!--~~~~~~ copy everything ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--&gt;
&lt;xsl:template match="@*|node()"&gt;
   &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
   &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;!--~~~~~~ delete the appendix string from the title ~~~~~~~~~~~~~~~~~~~~--&gt;
&lt;xsl:template match="/book/chapter/title[starts-with(text(),$AppendBegin)]"&gt;
  &lt;title&gt;
  &lt;xsl:value-of select="substring-after(text(),$AppendBegin)"/&gt;
  &lt;/title&gt;
  &lt;xsl:apply-templates select="*" /&gt; 
&lt;/xsl:template&gt;

&lt;!--~~~~~~ change appendix chapter element to appendix element ~~~~~~~~~~--&gt;
&lt;xsl:template match="/book/chapter[starts-with(title,$AppendBegin)]"&gt;
  &lt;appendix&gt;
    &lt;xsl:apply-templates select="*" /&gt; 
  &lt;/appendix&gt;
&lt;/xsl:template&gt;

&lt;!--~~~~~~ bookinfo ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--&gt;
&lt;!--
From Leo2AsciiDoc, only the bookinfo title is filled in, with a
blank author.  Here, we replace the author element with any and all
bookinfo elements we please.
--&gt;
  
&lt;xsl:template match="/book/bookinfo/author"&gt;
  &lt;author&gt;
    &lt;firstname&gt;Michael&lt;/firstname&gt;&lt;surname&gt;Dawson&lt;/surname&gt;
    &lt;affiliation&gt;
      &lt;address&gt;
        &lt;otheraddr&gt;
          &lt;ulink url="http://www.marshallresearch.com/contact.html"&gt;
            at Marshall Research
          &lt;/ulink&gt;
        &lt;/otheraddr&gt;
      &lt;/address&gt;
    &lt;/affiliation&gt;
  &lt;/author&gt;
  &lt;revhistory&gt;
    &lt;revision&gt;
      &lt;revnumber&gt;0.4a&lt;/revnumber&gt;
      &lt;date&gt;Jan 21 2004&lt;/date&gt;
      &lt;authorinitials&gt;mwd&lt;/authorinitials&gt;
      &lt;revremark&gt;Formatting enhancements&lt;/revremark&gt;
    &lt;/revision&gt;
    &lt;revision&gt;
      &lt;revnumber&gt;0.4&lt;/revnumber&gt;
      &lt;date&gt;Jan 19 2004&lt;/date&gt;
      &lt;authorinitials&gt;mwd&lt;/authorinitials&gt;
      &lt;revremark&gt;First release&lt;/revremark&gt;
    &lt;/revision&gt;
  &lt;/revhistory&gt;
&lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;

@doc
@ascskip xemacs-xsl-mode-off

</t>
<t tx="ekr.20040331071919.24">@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:02 CST 2004  michael@redpriest _HTML_One_File__139289780.txt"

indexterm:[Stylesheets,html.xsl]
For one long page of HTML, we simply import the DocBook stylesheets
and our small custom stylesheets that set our standard options.
This is the "html.xsl" stylesheet.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/html.xsl"
&lt;&lt; HTML: One File &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 

&lt;!--===== the catalog (/etx/xml/catalog) will convert this to the local pathname --&gt;
&lt;xsl:import href="docbook.xsl"/&gt;

&lt;xsl:import href="common-links.xsl"/&gt;
&lt;xsl:import href="common-html.xsl"/&gt;

&lt;/xsl:stylesheet&gt; 
@doc
@ascskip xemacs-xsl-mode-off


</t>
<t tx="ekr.20040331071919.25">@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:40 CST 2004  michael@redpriest _HTML_Individual_Pages__141001292.txt"

For individual section pages of HTML, we import the DocBook stylesheets
and our small custom stylesheets that set our standard options.

Then we set our chunking options, and tell the web pages where to
find the header and footer graphics.

indexterm:[Stylesheets,chunkit.xsl]
The following code is the entire chunkit style sheet
("chunkit.xsl").

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/chunkit.xsl"
&lt;&lt; HTML: Individual Pages &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 

&lt;xsl:import href="chunk.xsl"/&gt;

&lt;xsl:import href="common-links.xsl"/&gt;
&lt;xsl:import href="common-html.xsl"/&gt;

&lt;xsl:param name="navig.graphics" select="1"/&gt;
&lt;xsl:param name=
  "navig.graphics.path"&gt;graphics/&lt;/xsl:param&gt;
    &lt;!--  "navig.graphics.path"&gt;/usr/share/xml/docbook/docbook-xsl-1.59.1/images/&lt;/xsl:param&gt;--&gt;
    &lt;!--&lt;xsl:param name="navig.graphics.path"&gt;graphics/dbook/navicons/&lt;/xsl:param&gt;--&gt;
&lt;xsl:param name="navig.graphics.extension"&gt;.png&lt;/xsl:param&gt;
&lt;xsl:param name="navig.showtitles"&gt;1&lt;/xsl:param&gt;

&lt;xsl:param name="chunk.first.sections" select="1"&gt;&lt;/xsl:param&gt;
&lt;xsl:param name="chunk.section.depth" select="2"&gt;&lt;/xsl:param&gt;
&lt;xsl:param name="section.autolabel" select="0"&gt;&lt;/xsl:param&gt;

&lt;xsl:param name="css.decoration"&gt;1&lt;/xsl:param&gt;

&lt;/xsl:stylesheet&gt;

@doc
@ascskip xemacs-xsl-mode-off
</t>
<t tx="ekr.20040331071919.26">@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:58 CST 2004  michael@redpriest _HTML_base_css_style_sheet__141160708.txt"

css style sheet

@ascskip on
@ascskip xemacs-css-mode-on
@root "doc/base.css"
&lt;&lt; HTML: base css style sheet &gt;&gt;
@code
/* base from http://www.w3.org/TR/CSS21/sample.html */

address,
blockquote,
body, dd, div,
dl, dt, fieldset, form,
frame, frameset,
h1, h2, h3, h4,
h5, h6, noframes,
ol, p, ul, center,
dir, hr, menu, pre   { display: block }
li              { display: list-item }
head            { display: none }
table           { display: table }
tr              { display: table-row }
thead           { display: table-header-group }
tbody           { display: table-row-group }
tfoot           { display: table-footer-group }
col             { display: table-column }
colgroup        { display: table-column-group }
td, th          { display: table-cell; }
caption         { display: table-caption }
th              { font-weight: bolder; text-align: center }
caption         { text-align: center }
body            { padding: 8px; line-height: 1.12em }
h1              { font-size: 2em; margin: .67em 0 }
h2              { font-size: 1.5em; margin: .75em 0 }
h3              { font-size: 1.17em; margin: .83em 0 }
h4, p,
blockquote, ul,
fieldset, form,
ol, dl, dir,
menu            { margin: 1.12em 0 }
h5              { font-size: .83em; margin: 1.5em 0 }
h6              { font-size: .75em; margin: 1.67em 0 }
h1, h2, h3, h4,
h5, h6, b,
strong          { font-weight: bolder }
blockquote      { margin-left: 40px; margin-right: 40px }
i, cite, em,
var, address    { font-style: italic }
pre, tt, code,
kbd, samp       { font-family: monospace }
pre             { white-space: pre }

/            * comment             */
/* http://www.w3.org/TR/CSS21/visuren.html#propdef-display lists inline-block */
button, textarea,
input, object, 
select, img { display:inline-block; }

big             { font-size: 1.17em }
small, sub, sup { font-size: .83em }
sub             { vertical-align: sub }
sup             { vertical-align: super }
s, strike, del  { text-decoration: line-through }
hr              { border: 1px inset }
ol, ul, dir,
menu, dd        { margin-left: 40px }
ol              { list-style-type: decimal }
ol ul, ul ol,
ul ul, ol ol    { margin-top: 0; margin-bottom: 0 }
u, ins          { text-decoration: underline }
/*br:before       { content: "\A" }*/
center          { text-align: center }

/            * changed             */
/*
abbr, acronym   { font-variant: small-caps; letter-spacing: 0.1em }
*/

:link, :visited { text-decoration: underline }
:focus          { outline: thin dotted invert }

/* Begin bidirectionality settings (do not change) */
BDO[DIR="ltr"]  { direction: ltr; unicode-bidi: bidi-override }
BDO[DIR="rtl"]  { direction: rtl; unicode-bidi: bidi-override }

*[DIR="ltr"]    { direction: ltr; unicode-bidi: embed }
*[DIR="rtl"]    { direction: rtl; unicode-bidi: embed }

@media print {
  h1            { page-break-before: always }
  h1, h2, h3,
  h4, h5, h6    { page-break-after: avoid }
  ul, ol, dl    { page-break-before: avoid }
}



@doc
@ascskip xemacs-css-mode-off
</t>
<t tx="ekr.20040331071919.27">@silent
@doc
@ascskip # Time-stamp: "Wed, Jan 21 09:13 CST 2004  michael@redpriest _HTML_css_style_sheet__140659188.txt"

css style sheet

@ascskip on
@ascskip xemacs-css-mode-on
@root "doc/docstyle.css"
&lt;&lt; HTML: css style sheet &gt;&gt;
@code

html, body {
  background-color: #CCCCCC;
  font-family: "Verdana", arial;
}

body {
  font-size: 9pt;
  line-height: 125%;
/*   margin: 1em; */
  padding: 2em;
  margin-top: 1em;
  margin-left: 3em;
/*   width: 39em; */
  min-height: 60em;
/*   margin-right: 0.5em; */
  background-color: white;
  border-top: 1px solid black;
  border-left: 1px solid black;
/*   border-right: 2px solid black; */
/*   border-bottom: 2px solid black; */
}

.strong {
  font-weight: bold;
}

h1, h2, h3, h4, h5, h6,
p
{
  margin-bottom: 0.5em;
  margin-top: 0.5em;
  line-height: 125%;
}

h1 { font-size: 2em;}
h2 { font-size: 1.4em; }
h3 { font-size: 1.2em; }
h4 { font-size: 1.0em; }
h5 { font-size: 1.0em; }
h6 { font-size: 1.0em; }

h1, h2, h3, h4, h5, h6 {
  color: #660000;
  margin-right: 20%;
}

* &gt; h1 {
  padding-top: 0.5em;
}

/* h2, h3 */
/* { */
/*   margin-right: 10em; */
/* } */

h1.title 
{
  margin-top: 3em;
  border-top: 3px solid #660000;
  border-bottom: 3px solid #660000;
  border-color: #660000;
  padding: .4em;
  text-align: center;
}

h2.title 
{
  margin-top: 3em;
  border-top: 3px solid #660000;
  border-bottom: 3px solid #660000;
  border-color: #660000;
  padding: .4em;
}

div.toc {
    line-height: 100%;
}

div.list-of-examples {
    margin-top: 3em;
}

div.sect1 h2 {
  font-size: 1.5em;
  margin-top: 4em;
  margin-left: 0em;
  margin-right: 25%;
  margin-bottom: 1em;
  /* border-color: #660000; */
  border-top: 0em;
  border-bottom: 1px solid;
  padding: 0em;
}

div.sect2 h3 {
  font-size: 1em;
  margin-top: 4em;
  margin-bottom: 1em;
  margin-right: 25%;
  /* border-color: #660000; */
  border-top: 0em;
  border-bottom: 1px solid;
}

div.sect3 h4 {
  font-size: small;
  color: black;
  margin-top: 4em;
  margin-bottom: 1em;
  margin-right: 25%;
  /* border-color: #660000; */
  border-top: 0em;
  border-bottom: 1px solid;
}

div.note
{
  margin-top: 1em;
  margin-bottom: 1em;
}
div.note .title
{
  color: black;
  font-size: x-small;
  margin-top: 0em;
  margin-bottom: 0em;
}
/* ----- links ---------------------------------------------------------- */
:link {
  color: #660000;
  text-decoration: none;
  font-weight: bold;
}

:visited {
  color: #333333;
  text-decoration: none;
  font-weight: bold;
}


div.toc :link, :visited {
  font-weight: normal;
 }

div.list-of-examples :link, :visited {
  font-weight: normal;
 }


a:link img {border-style: none;}
a:visited img {border-style: none;}

div.toc dd, dl
{
  margin-top: 0em;
  margin-bottom: 0em;
}
div.toc dt
{
  margin-top: 0.2em;
}

ul, ol
{
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

.para {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

.sect1,
.toplevel.section
{
  padding-bottom: 0.25em;
}


tt,pre {
    font-family: Courier New,Courier,monospace;
    font-size: smaller;
}

.programlisting {
    margin-top: 8pt;
    margin-bottom: 8pt;
    margin-left: 1em;
    background-color: #FFFFCC;
    white-space: pre;
    border-style: solid;
    border-width: 1pt;
    border-color: #999999;
    padding-left: 6pt;
    padding-top: 2pt;
    padding-bottom: 2pt;
    width: 100%;
    line-height: 100%;
}

table{
    background-color: #FFFFFF;
    width: 99.6%;
}

div.example {
    margin-top: 0pt;
    margin-bottom: 0pt;
    padding-top: 0pt;
    padding-bottom: 0pt;
}

div.example .title {
    color: black;
    margin-top: 0pt;
    margin-bottom: 0pt;
    padding-top: 8pt;
    padding-bottom: 0pt;
}

div.sidebar .title {
  font-weight: bold;
  color: black;
}

div.sidebar  {
  font-size: x-small;
  margin-top: 2em;
  margin-bottom: 0.5em;
  /* margin-left: 1em; */
  margin-right: 33%; 
  padding: 4pt;
  border-top: 1px solid black;
  border-bottom: 1px solid black;
  border-left: 1px solid black;
  border-right: 1px solid black;
}


h1 &gt; a,
h2 &gt; a {
  padding-top: 0.5em;
}

ol.vert, ol.inline {
  list-style-type: none;
  padding-left: 0;
  margin-left: 0;
}

hr, .toc, .title
{ color: #660000 
}


.navfooter
{
  margin-top: 2em;
}
.navheader
{
  margin-bottom: 1em;

}

/* ------ title page ---------------------------------------------------- */
h3.author
{
  padding: 0em;
  margin-top: 0em;
  margin-bottom: -1em;
}

.affiliation
{
  padding: 0em;
  margin-top: 0em;
  margin-bottom: 0em;
  font-size: smaller;
}


div.revhistory table, tr, td
{
  border-collapse: collapse;
  border: hidden;
  font-size: x-small;
 }

div.revhistory table
{
  width: auto;
  }

div.revhistory td[colspan="3"]
{
  padding-left: 2em;  
 }


/* div.draft { */
/*   background-image: url('pics/draft.png'); */
/* } */


@doc
@ascskip xemacs-css-mode-off

</t>
<t tx="ekr.20040331071919.28">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:03 CST 2004  michael@redpriest _HTML_common__140982180.txt"
@ascskip xemacs-xsl-mode-off

indexterm:[Stylesheets,common-html.xsl]
The following section is the entire common-html style sheet
("common-html.xsl"), which sets basic HTML options.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/common-html.xsl"
&lt;&lt; HTML: common&gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 
&lt;!--===== ==========================================================--&gt;
&lt;xsl:param name="default.table.width" select="'100%'"&gt;&lt;/xsl:param&gt;
&lt;xsl:param name="html.stylesheet" select="'dbstyle.css'"/&gt;
&lt;xsl:param name="shade.verbatim" select="1"/&gt;
&lt;xsl:attribute-set name="shade.verbatim.style"&gt;
  &lt;xsl:attribute name="border"&gt;0&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="bgcolor"&gt;#F3F3F3&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;


&lt;/xsl:stylesheet&gt;
@doc
@ascskip xemacs-xsl-mode-off
</t>
<t tx="ekr.20040331071919.29">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:03 CST 2004  michael@redpriest _PDF__139549436.txt"

indexterm:[Stylesheets, fo-fop.xsl]
This is the Formatting Objects style sheet ("fo-fop.xsl", which sets
the options for all printed output.

The actual output is a file with the ".fo" extension, which will be
used by a Formatting Object processor to produce a PDF file.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/fo-fop.xsl"
&lt;&lt; PDF &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 
&lt;!--===== ==========================================================--&gt;

&lt;!--===== catalog will convert the url to our file location =========--&gt;
&lt;xsl:import href="fo-docbook.xsl"/&gt;
&lt;xsl:import href="common-links.xsl"/&gt;

&lt;!--===== using the fop pdf processor ===================================--&gt;
&lt;xsl:param name="fop.extensions" select="1"/&gt;

&lt;!--===== single sided pages ============================================--&gt;
&lt;xsl:param name="double.sided" select="0"&gt;&lt;/xsl:param&gt;

&lt;!--===== body print ====================================================--&gt;
&lt;xsl:param name="body.font.master"&gt;12&lt;/xsl:param&gt;
&lt;xsl:param name="alignment"&gt;left&lt;/xsl:param&gt;
&lt;xsl:param name="hyphenate"&gt;true&lt;/xsl:param&gt;

&lt;!--===== set page margins ==============================================--&gt;
&lt;xsl:param name="page.margin.inner"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="$double.sided != 0"&gt;1.25in&lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;1.5in&lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:param&gt;

&lt;xsl:param name="body.margin.top" select="'.75in'"&gt;&lt;/xsl:param&gt;

&lt;!--===== set title fonts ===============================================
     Title fonts require replacing the standard
     titlepage.templates.xsl with a custom version.  This is done
     here by copying the fo/titlepage.templates.xml to
     mrc.titlepage.templates.xsl, editing it, and then processing it
     with
      xsltproc -output mrc.titlepage.templates.xsl \
         /usr/share/xml/docbook/docbook-xsl-1.60.1/template/titlepage.xsl  \
         mrc.titlepage.templates.xml
     Now we replace the old titlepage.templates.xsl with our new
     mrc.titlepage.templates.xsl
--&gt;
&lt;xsl:include href="mrc.titlepage.templates.xsl"/&gt;

&lt;!--===== blank verso titlepage =========================================--&gt;
&lt;xsl:template name="book.titlepage.verso"/&gt;

&lt;!--===== outdent titles ================================================--&gt;
&lt;xsl:param name="title.margin.left" select="'-2pc'"/&gt;

&lt;!--===== set section font, break ======================================--&gt;
&lt;xsl:attribute-set name="section.title.level1.properties"&gt;
  &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="break-before"&gt;page&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-bottom"&gt;1pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-bottom-style"&gt;solid&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-bottom-color"&gt;black&lt;/xsl:attribute&gt;  
  &lt;xsl:attribute name="margin-right"&gt;6em&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;xsl:attribute-set name="section.title.level2.properties"&gt;
  &lt;xsl:attribute name="break-before"&gt;page&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;xsl:attribute-set name="section.title.level3.properties"&gt;
  &lt;xsl:attribute name="break-before"&gt;page&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;!--===== Code extract titles are sidebars ==============================--&gt;
&lt;xsl:attribute-set name="sidebar.properties" use-attribute-sets="formal.object.properties"&gt;
  &lt;xsl:attribute name="border-style"&gt;solid&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-width"&gt;1pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-color"&gt;black&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="background-color"&gt;#EDEDED&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-left"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-right"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-top"&gt;2pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-bottom"&gt;4pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-left"&gt;0pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-right"&gt;4em&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-top"&gt;2pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-bottom"&gt;2pt&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;!--===== code (verbatim) font and spacing ==============================--&gt;
&lt;xsl:attribute-set name="verbatim.properties"&gt;
  &lt;xsl:attribute name="space-before.minimum"&gt;0.1pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-before.optimum"&gt;2pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-before.maximum"&gt;3pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-after.minimum"&gt;0.4em&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-after.optimum"&gt;.5em&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-after.maximum"&gt;1.2em&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;xsl:attribute-set name="monospace.verbatim.properties"
    use-attribute-sets="verbatim.properties monospace.properties"&gt;
  &lt;xsl:attribute name="text-align"&gt;start&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;9pt&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
    &lt;!--===== 2003-Oct-01 FOP does not appear to support shade.verbatim yet =--&gt;
&lt;xsl:param name="shade.verbatim" select="1"/&gt;
&lt;xsl:attribute-set name="shade.verbatim.style"&gt;
  &lt;xsl:attribute name="border"&gt;1&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="bgcolor"&gt;#E0E0E0&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

    &lt;!--===== FOP did not like this =========================================--&gt;
&lt;!--&lt;xsl:attribute-set name="xref.properties"&gt;--&gt;
&lt;!--  &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;--&gt;
&lt;!--  &lt;xsl:attribute name="font-style"&gt;bold&lt;/xsl:attribute&gt;--&gt;
&lt;!--&lt;/xsl:attribute-set&gt;--&gt;

&lt;/xsl:stylesheet&gt;

@doc
@ascskip xemacs-xsl-mode-off




</t>
<t tx="ekr.20040331071919.30">@language plain
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:21 CST 2004  michael@redpriest Appendix_XEmacs_Text_Editor_140657924.txt"

You can use Leo to enter all the text in an outline, but Leo also
allows you to use your familiar editing environment.  In my case,
that is XEmacs.  Fortunately, Leo integrates with XEmacs quite well.

The following items are code I use, some Leo Python plugins and some
XEmacs elisp functions.  You may find them useful.

@ascskip on
&lt;&lt; Appendix: XEmacs Text Editor &gt;&gt;
@code</t>
<t tx="ekr.20040331071919.31">@language python
@tabwidth -4

@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:10 CST 2004  michael@redpriest _OpenWith_Plugin__140659092.py"

Leo's Open_With plugin can be modified so that the body text of any
outline node can be edited in XEmacs by choosing "File; OpenWith;
XEmacs" or "File; OpenWith; XEmacs - noshow"  from the menu.

What actually happens is that Leo places the text in a temporary
file, and calls XEmacs with the address of that temporary file.  Leo
then watches for changes in the temporary file.  When and if the
temporary file changes, Leo copies the contents to the body text of
the Leo node.
      
Below is the standard open_with.py plugin that came with Leo 4.1-rc3
The only modification I've made is to insert
@code
&lt;&lt;call XEmacs&gt;&gt;=
table = (
    ("X&amp;Emacs", "Alt+Shift+O", ("os.system","/usr/bin/gnuclient -q ", None)),
    ("X&amp;Emacs - noshow", "Ctrl+Shift+O", ("os.system","/mrc2/linux-bin/gnuclient-noshow ", None))
    )
@doc
as noted below.  A similar alteration should work for future
versions.

Note: this alteration is for XEmacs running under Linux, but a
similar command should work in the Windows environment.

I use the "gnuclient-noshow" selection to load the temporary open_with file in
the background.  It is a small bash shell script:
---
#!/bin/bash
gnuclient -eval "(find-file-noselect \"${1}\")"
---

To implement this, edit a copy of the open_with.py file that comes
with your version of Leo.  Move the original copy to a safe place,
and put your edited copy in the Leo plugins directory.  Check to see
it is included in "pluginsManager.txt" in that directory.
@ascskip on
@root "other/xemacs/open_with.py"
&lt;&lt; Open_With Plugin&gt;&gt;
@code
"""Create menu for Open With command and handle the resulting commands"""

import leoGlobals as g
import leoPlugins

Tk = g.importExtension('Tkinter',pluginName=__name__,verbose=True)

import os

if Tk: # Register the handlers...

    def on_idle (tag,keywords):
        a = g.app
        if g.app.killed: return
        for dict in a.openWithFiles:
            path = dict.get("path")
            c = dict.get("c")
            encoding = dict.get("encoding",None)
            v = dict.get("v")
            old_body = dict.get("body")
            if path and os.path.exists(path):
                try:
                    time = os.path.getmtime(path)
                    if time and time != dict.get("time"):
                        dict["time"] = time # inhibit endless dialog loop.
                        # The file has changed.
                        try:
                            # Update v from the changed temp file.
                            f=open(path)
                            s=f.read()
                            f.close()
                        except:
                            g.es("can not open " + g.shortFileName(path))
                            break
                        
                        # Convert body and s to whatever encoding is in effect.
                        body = v.bodyString()
                        body = g.toEncodedString(body,encoding,reportErrors=True)
                        s = g.toEncodedString(s,encoding,reportErrors=True) # 10/13/03
                        
                        conflict = body != old_body and body != s
                        
                        # Set update if we should update the outline from the file.
                        if conflict:
                            # See how the user wants to resolve the conflict.
                            g.es("conflict in " + g.shortFileName(path),color="red")
                            message = "Replace changed outline with external changes?"
                            result = g.app.gui.runAskYesNoDialog(c,"Conflict!",message)
                            update = result.lower() == "yes"
                        else:
                            update = s != body
                        
                        if update:
                            g.es("updated from: " + g.shortFileName(path),color="blue")
                            v.setBodyStringOrPane(s,encoding) # 10/16/03
                            c.selectVnode(v)
                            dict["body"] = s
                        elif conflict:
                            g.es("not updated from: " + g.shortFileName(path),color="blue")
                except:
                    g.es_exception() ## testing
                    pass
    def create_open_with_menu (tag,keywords):
    
        if  (tag in ("start2","open2") or
            (tag=="command2" and keywords.get("label")=="new")):
    
            # Entries in the following table are the tuple 
            # (commandName,shortcut,data).
            # 
            # - data is the tuple (command,arg,ext).
            # - command is one of "os.system", "os.startfile", "os.spawnl", 
            # "os.spawnv" or "exec".
            # 
            # Leo executes command(arg+path) where path is the full path to 
            # the temp file.
            # If ext is not None, the temp file has the extension ext,
            # Otherwise, Leo computes an extension based on what @language 
            # directive is in effect.
            
            idle_arg = "c:/python22/tools/idle/idle.py -e "
            
@doc
Here is where we insert the &lt; Call XEmacs &gt; code fragment defined above:
@code
            if 1: # Default table.


&lt;&lt; Call XEmacs &gt;&gt;
#               table = (
#                   # Opening idle this way doesn't work so well.
#                   # ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
#                   ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
#                   ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
#           elif 1: # Test table.
#               table = ("&amp;Word","Alt+Shift+W",("os.startfile",None,".doc")),
#           else: # David McNab's table.
#               table = ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)),
            
            c.frame.menu.createOpenWithMenuFromTable(table)

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":

        g.app.hasOpenWithMenu = True
        leoPlugins.registerHandler("idle", on_idle)
        leoPlugins.registerHandler(("start2","open2","command2"), create_open_with_menu)
    
        __version__ = "1.4" # Set version for the plugin handler.
        g.plugin_signon(__name__)

</t>
<t tx="ekr.20040331071919.32">@language python
@tabwidth-4
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:14 CST 2004  michael@redpriest _OpenTree_Plugin__140660268.py"

This is a module that creates an "Open With" menu item that opens
Leo outline nodes in the tree below the current Leo node in the
XEmacs editor.I frequently have a small tree of Leo nodes which
contain code that is usually edited in the same session.

NOTE: I use the "gnuclient-noshow" selection to load the temporary
open_with file in the background.Leo calls a command with the
temporary file name at the end of the command, but the gnuclient
command needs to receive it enclosed in quotes and parentheses.The
solution is a small intermediary bash shell script called
"gnuclient-noshow":

- - -
#!/bin/bash
gnuclient- eval "(find-file-noselect \"${1}\")"
- - -

I would rather have this operate in the background, but Leo ' s
openWith always operates on the current node, and openWith has much
good error checking that I want to use.So the fast solution was to
have OpenTreeInXEmacs visibly traverse the tree.

@ascskip on
@root "other/xemacs/mod_xemacsopentree.py"
&lt;&lt; Open_Tree Plugin &gt;&gt;
@code

import leoPlugins

def OpenTreeInXEmacs (c):
    import leoCommands
    #XEmacsCommand = "/usr/bin/gnuclient -q "
    XEmacsCommand = "/mrc2/linux-bin/gnuclient-noshow "
    vnode = c.currentVnode() # get the current vnode.
    stopHere = vnode.nodeAfterTree()
    v = vnode
    while v != stopHere:
        c.openWith(data=("os.system",XEmacsCommand,None))
        v = v.threadNext()
        if (not v) or (v==stopHere):
            break
        c.selectVnode(v)
    c.selectVnode(vnode)


def CreateOpenTreeMenu (tag,keywords):

    """Create the 'Xemacs: Open Tree' menu item in the Open With menu."""


    if (tag=="open2" or
        (tag=="start2") or
        (tag=="command2" and keywords.get("label")=="new")):

        c = keyword.get('c')
        exportMenu = c.frame.menu.getMenu('Open With')
        newEntries = (
            ("-",None,None),
            ("XEmacs: Open nodes in sub-tree","None",OpenTreeInXEmacs),
        )
        c.frame.menu.createMenuEntries(exportMenu,newEntries,dynamicMenu=True)

if 1:
    leoPlugins.registerHandler(("start2","open2","command2"),CreateOpenTreeMenu)

    __version__ = ".4" # Set version for the plugin handler.
    g.plugin_signon(__name__)
@doc


@code
</t>
<t tx="ekr.20040331071919.33">@language python
@tabwidth -4
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:15 CST 2004  michael@redpriest _Filename_modification__140661308.py"

This is a small modification to Leo (via a Python plugin module) so
that Leo will open the temporary files with a name that can be
easily recognized in an XEmacs buffer listing.

On Linux, Leo opens files in the temporary files directory, all
prefixed with "LeoTemp_", which makes the names difficult to tell
apart when you have many different nodes loaded in XEmacs.

This code replaces the openWithTempFilePath method of the LeoFrame
class with code that opens temporary files in a subdirectory of the
temporary files directory, called "username_Leo", and omits the
"LeoTemp" prefix.

For example, I'm now editing this Leo node in XEmacs as
    "/tmp/michael_Leo/_Filename_modification__138976348.py"
In the XEmacs buffer list, the filename is shown as
    "_Filename_modification__138976348.py"
and all the Leo buffer names start with a leading underscore, so
they are grouped together.

For general use, this code should be considerably more robust about
creating the Leo subdirectory and signaling errors, but it is just a
quick hack that works for me on my machines.

This is distributed with Leo version 4.1rc3, so I've updated it with
Ed Ream's modifications to match that distribution.

@ascskip on
@root "other/xemacs/mod_tempfname.py"
&lt;&lt; Filename modification &gt;&gt;
@code

"""Replace Commands.openWithTempFilePath so Leo opens temporary
files with a filename that begins with the headline text, and
located in a 'username_Leo' subdirectory of the temporary
directory. The 'LeoTemp' prefix is omitted.  This makes it easier to
see which temporary file is related to which outline node.""" #'

import leoGlobals as g
import leoPlugins

import leoCommands
import getpass
import os
import tempfile

def onStart (tag,keywords):

    # g.trace("replacing openWithTempFilePath")

    g.funcToMethod(openWithTempFilePath,leoCommands.Commands,"openWithTempFilePath")

def openWithTempFilePath (self,v,ext):

    """Return the path to the temp file corresponding to v and ext.

    Replaces the Commands method."""    

    try:
        leoTempDir = getpass.getuser() + "_" + "Leo"
    except:
        leoTempDir = "LeoTemp"
        g.es("Could not retrieve your user name.")
        g.es("Temporary files will be stored in: %s" % leoTempDir)

    td = os.path.join(os.path.abspath(tempfile.gettempdir()), leoTempDir)
    if not os.path.exists(td):
        os.mkdir(td)

    name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
    path = os.path.join(td,name)
    return path

# Register the handlers...
leoPlugins.registerHandler("start2", onStart)

__version__ = "1.3"
g.plugin_signon(__name__)
</t>
<t tx="ekr.20040331071919.34">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 09:58 CST 2004  michael@redpriest _Kill_Temporary_Buffers__140661388.txt"

If you've opened a number of Leo temporary buffers in XEmacs, this
XEmacs function will kill them for you.  Just set the tempdir
variable to whatever matches your local value.

XEmacs will prompt you about any buffers that have unsaved changes.

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/kill-temporary-buffers.el"
&lt;&lt; Kill Temporary Buffers &gt;&gt;
@code
;;
;;-     mwd-leo-kill-buffers
(defun mwd-leo-kill-buffers ()
  "Kill any buffers for files in my Leo temporary directory."
  (interactive)
  (let ((bl (buffer-list))
        (tempdir "/tmp/michael_Leo" )  ;; change this to your temporary directory.
        )
    (while bl
      (setq test-buffer (car bl))
      (setq bname (buffer-file-name test-buffer))
      (if (and bname (string-match tempdir bname))
          (kill-buffer test-buffer)
        )
      (setq bl (cdr bl))
      )
    )
  )



@doc
@ascskip xemacs-lisp-mode-off
</t>
<t tx="ekr.20040331071919.35">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:18 CST 2004  michael@redpriest _MMMmode__140663340.txt"

There is an editing mode for XEmacs called Multiple Major Modes,
which allows us to edit the temporary text conveniently: with all
the syntax highlighting, special keymaps, etc. available, even
though Leo nodes may contain both plain text and program code.

When the XEmacs cursor is in a section of plain text, all the plain
text facilities are available, and there is no syntax
highlighting. When the XEmacs cursor is in a section of code
(Python, XSL, whatever) XEmacs invokes the syntax highlighting,
special keymaps, etc. appropriate for that code.

indexterm:[Multiple Major Modes]
indexterm:[Multiple Major Modes,mmm-mode.el]
If you have XEmacs installed, and you have also installed the
Multiple Major Modes mmm-mode.el package, the following code will
customize mmm-mode for use while editing Leo temporary files.

NOTE: mmm-mode is already installed by default in most
distributions.

Installation: Load mmm-leo-config.el from your .init.el file, or
just load it manually to try it out.

I won't go through it all, but for example, when editing a temporary
Leo file that is in XEmacs Python mode, and/or has a ".py" suffix:

    - when your cursor is any text between the @doc and @code
      directives XEmacs will enter text-mode.  Otherwise (e.g. with
      the cursor after the @code directive), XEmacs will be in
      Python mode.
    - when your cursor is between text that says
      "xemacs -makefile-mode-on" and text that says
      "xemacs -makefile-mode-off", XEmacs will enter makefile-mode.
      (You key in those text markers to mark out the area you want
      as makefile-mode.  See the Leo2AsciiDoc.leo outline for examples,
      e.g the "Make File" section in the Leo2AsciiDoc Users Guide.)

      Otherwise, XEmacs will be in Python mode in that buffer.

Similarly, makefile-mode, xsl-mode and emacs-lisp-mode are added to
temporary Leo files that created with a ".txt" extension.      

A future project may be to create a Leo module to use in the
Leo "openWith" function that examines each node for these mmm-mode
markers and creates the temporary file with the proper extension.

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/mmm-leo-config.el"
&lt;&lt; MMM-mode &gt;&gt;
@code
;;-     mmm-mode                multiple modes
(require 'mmm-auto)
(require 'mmm-vars)

;   mmm-mode-on and mmm-mode-off turn it on and off in a buffer.
;   \c-c % \c-b re-parses the whole buffer

;   set mode to activate on mode or extension
(setq mmm-global-mode 'maybe)

; turn off gray background
(setq mmm-submode-decoration-level 0)

;   add embedded modes in python
(mmm-add-group
 'py-embedded-text
 '(
   (py-leo
    :submode text-mode
    :face mmm-code-submode-face
    :front "^@doc.*"
    :back "^@code"
    :insert ((?l py-leo-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   (py-doc
    :submode text-mode
    :face mmm-code-submode-face
    :front "^\"\"\".*"
    :back "^.+\"\"\""
    )
   (py-makefile
    :submode makefile-mode
    :face mmm-code-submode-face
    :front "xemacs-makefile-mode-on"
    :back "xemacs-makefile-mode-off"
    )
   )
 )
;   add embedded modes in text
(mmm-add-group
 'text-embedded
 '(
   (txt-makefile-mode
    :submode makefile-mode
    :face mmm-code-submode-face
    :front "xemacs-makefile-mode-on"
    :back "xemacs-makefile-mode-off"
    :insert ((?l text-embedded-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   (txt-xsl-mode
    :submode xsl-mode
    :face mmm-code-submode-face
    :front "xemacs-xsl-mode-on"
    :back "xemacs-xsl-mode-off"
    :insert ((?l text-embedded-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   (txt-lisp-mode
    :submode emacs-lisp-mode
    :face mmm-code-submode-face
    :front "xemacs-lisp-mode-on"
    :back "xemacs-lisp-mode-off"
    :insert ((?l text-embedded-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   )
 )
(mmm-add-mode-ext-class 'python-mode "\\.py\\'" 'py-embedded-text)
(mmm-add-mode-ext-class 'text-mode "\\.txt\\'" 'text-embedded)

@doc
@ascskip xemacs-lisp-mode-off
</t>
<t tx="ekr.20040331071919.36">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:20 CST 2004  michael@redpriest _Insert_indexterm__140664580.txt"

indexterm:[XEmacs, Indexing]
Indexing is tedious work, and it interferes with the readability of
the ascii text as well.  However, used sparingly, it helps the
reader.

When editing a Leo node (in an XEmacs buffer), this function copies
a highlighted word or phrase and inserts an AsciiDoc index code on a
new line immediately before the paragraph.  I try to keep markup out
of the way of the reader.  In this case, AsciiDoc requires that the
index code be part of the same block of text, and the first line of
the block is the least annoying place I can find.

For example, if I wanted to index the words "XEmacs buffer" above, I
would highlight them (usually by pressing M-@ a couple of times) and
then call this function (I have it bound to C-k C-h C-i).  At the
beginning of the paragraph, my text would say "\indexterm:[XEmacs
buffer]".

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/index-leo-region.el"
&lt;&lt; Insert indexterm &gt;&gt;
@code
(defun mwd-index-leo-region (start end)
  "preface paragraph with AsciiDoc index macro of region."
  (interactive "r")
  (save-excursion
    (copy-region-as-kill start end)
    (backward-paragraph)
    (insert "\nindexterm:[")
    (yank)
    (insert "]")
    )
  )

@doc
@ascskip xemacs-lisp-mode-off

</t>
<t tx="ekr.20040331071919.37">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:56 CST 2004  michael@redpriest _Indent_Leo_comments__141202716.txt"

Leo derived files are sprinkled with comments, which Leo uses as
markers to be able to "untangle" files, i.e. import changes made to
a derived file back into the Leo outline.

Useful as they may be, the comments are an ugly distraction when
reading the source code.  One could have XEmacs flush them from the
file, but then the untangle feature is gone for that file.

This pair of XEmacs elisp functions moves them to the right, where
they aren't so distracting, and moves them back again if you should
want to untangle the file.

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/indent-leo-comments.el"
&lt;&lt; Indent Leo comments &gt;&gt;
@code
(defun mwd-leo-comments-indent ()
  "Indent Leo comments to make them less distracting."
  (interactive)
  (save-excursion
    (let* (
          (leading-spaces 40)
          (start-string (concat (make-string leading-spaces ? ) "\\1" ))
          (end-string (concat (make-string leading-spaces ? ) "\\1" ))
          )
      (goto-char (point-min))
      (while (search-forward-regexp "\\(^# &lt;&lt;\\)" nil t) (replace-match start-string))
      (goto-char (point-min))
      (while (search-forward-regexp "\\(^# -- end\\)" nil t) (replace-match end-string))
      )
    )
  )

(defun mwd-leo-comments-unindent ()
  "Reverse the effect of mwd-leo-comments-indent."
  (interactive)
  (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp "^\\(\\s-\\)+\\(# &lt;&lt;\\)" nil t) (replace-match "\\2" ))
      (goto-char (point-min))
      (while (search-forward-regexp "^\\(\\s-\\)+\\(# -- end\\)" nil t) (replace-match "\\2" ))
    )
  )
@doc
@ascskip xemacs-lisp-mode-off
</t>
<t tx="ekr.20040331071919.38">@language plain
@ascfile "doc/mod_asc_user.asc"
@ascconfig maxCodeLineLength 80
@doc
@ascskip # Time-stamp: "Mon, Jan 19 15:29 CST 2004  michael@redpriest Leo_AsciiDoc_Users_Guide_141652036.txt"

Preface
-------

Leo2AsciiDoc is a small Python program which has been
built to be used as a plugin module for the Leo outlining editor.

Leo2AsciiDoc enables the contents of Leo outlines to be published to HTML
or PDF via the DocBook set of publishing tools.  Plain text from the
Leo outline is transformed into a final result that has:

    - typeset body text, in which bulleted and numbered lists,
      variable lists, page numbers, URLs, index terms,and bold and
      italic text are automatically recognized.
    - typeset Headings
    - a Table of Contents
    - an Index containing any items marked by the user, and any
      Python classes or functions.

As you will see, there's not a lot involved in using the
Leo2AsciiDoc module.  It simply copies text from a Leo outline (or a
portion of a Leo outline) to a text file.  In turn that text file can
be automatically converted by the AsciiDoc program and a DocBook
system to properly typeset DocBook HTML, PDF or other formats.

If you keep your text plain, and use a few simple formatting
conventions, the final output can have typeset headings, bulleted
lists, indexing and cross-referencing, as well as many other
features.

---
Michael Dawson
Marshall Research
michael_dawson at marshallresearch dot com
---

*note*

Leo2AsciiDoc is suited for general text documents, most programming
documentation and most business documents.  Leo2AsciiDoc (being based on
DocBook) is not the choice for anyone needing detailed typographic
control of individual words or characters -- for example, typeset
equations.  In general, DocBook typesets blocks of text.

*note*

@code
</t>
<t tx="ekr.20040331071919.39">@doc
@ascskip # Time-stamp: "Mon, Jan 19 11:48 CST 2004  michael@redpriest Installation_140689076.txt"
Installation of this plugin is very straightforward, using Leo
version 4.1:

    - copy the python source code (mod_leo2ascd.py) to your Leo
      plugin directory (a subdirectory called "plugins" under your
      main Leo directory).
    - in that directory should be a text file called
      pluginsManager.txt, containing a list of all plugins that are
      to be loaded when Leo starts.  Add mod_leo2ascd.py to the
      list.
    - start or re-start Leo.
    - in the Leo Log Window you should see the Leo2AsciiDoc sign-on
      message "---mod_leo2asc 0.4-------".
    - in the Leo main menu "File; Export", there should be two menu
      items called something like "Export to AsciiDoc".

@code</t>
<t tx="ekr.20040331071919.40">@language plain
@doc
@ascskip # Time-stamp: "Thu, Oct 16 13:46 CST 2003  michael@redpriest Operation_140791428.txt"

Using Leo2AsciiDoc is as simple as choosing the Leo menu item: "File;
Export; Export All to AsciiDoc".  From there, you have the AsciiDoc
program and the DocBook system automatically convert your outline to
HTML or PDF (or to a manpage or a DocBook website.)

Step by step:

    - You need a Leo outline containing some plain text, or plain
      text and code.
    - You ensure that the top node in the outline (or part of the
      outline tree which you want to be a separate document) must
      have an @ascfile directive in the body text. The @ascfile
      directive is used to specify the filename in which the output
      text will be put.
    - You then use Leo's menu: "File; Export; Export All to
      AsciiDoc" (or one of the other Leo2AsciiDoc menu items) to
      have Leo2AsciiDoc automatically export the outline to a text file.
    - After that, you run the AsciiDoc program on the exported text
      file, and process it as a DocBook document.  Most often,
      people have a Make file set up to do this automatically.

In practice, people often want to use special features:

    - plain text formatting, sometimes referred to as "structured
      text" or "minimal markup"
    - Leo2AsciiDoc configuration options

The following sections cover this.  If you've downloaded the Leo2AsciiDoc
package, the mod_leo2asc.leo outline is available, and illustrates
all the features.  It is the outline from which all the Leo2AsciiDoc HTML
and PDF documentation and code were derived.

@code
</t>
<t tx="ekr.20040331071919.41">@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:19 CST 2004  michael@redpriest Directives_140672364.txt"

The following are non-printing directives that you can insert into
your outline text to control Leo2AsciiDoc behaviour.  All must be at the
beginning of the line.

{amp}commat;ascfile::
    e.g: `@ascfile "doc/mod_asc_user.asc" `

    Ascfile is the equivalent of a Leo @root directive. Ascfile
    signals the start of a document and specifies the file name to
    receive the text.

    The default directory is the directory containing the Leo
    outline.  If you were editing an outline that resided in
    /home/me then the above ascfile directive would create the file
    mod_asc/user.asc in the directory /home/me/doc.

{amp}commat;ascignore::
    Ascignore causes Leo2AsciiDoc to ignore the outline node, and any
    sub-nodes. It must be placed before any line in the node which
    will print.

{amp}commat;ascskip::
    Causes Leo2AsciiDoc to skip the line.  If followed by the word "on",
    causes Leo2AsciiDoc to skip all succeeding document lines until an
    "{amp}commat;ascskip off" directive is read, or a code section is reached.

{amp}commat;ascexit::
    Causes Leo2AsciiDoc to exit the outline node without processing any
    further lines.  Sub-nodes will be processed.

{amp}commat;ascconfig::
    e.g. `{amp}commat;ascconfig maxCodeLineLength 70` -- see
    Configuration below. 
    

@code
</t>
<t tx="ekr.20040331071919.42">@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:20 CST 2004  michael@redpriest Configuration_140673612.txt"

There are a few configuration settings which may be set in an
outline.  To take effect, they must be placed:

    - in the top node of the outline, or
    - the same node as an @ascfile directive.
    
Configuration settings in the top node of the outline are effective
for the whole outline, unless overridden by settings in sub-nodes.

maxCodeLineLength::
    e.g. `{amp}commat;ascconfig maxCodeLineLength 70` -- 
    sets the maximum length of code printout lines to 70 characters.
    Longer lines will be wrapped and a line continuation character
    displayed.

PrintHeadings::    
    e.g. `{amp}commat;ascconfig PrintHeadings off` -- turns off the
    export of outline node headings as section titles.  In that
    case, you must have correctly entered AsciiDoc section titles in
    the body text of your outline.

Readers of the code will note that there are other configuration
settings in the code. These will be used in future, and so I won't
document them yet.


@code</t>
<t tx="ekr.20040331071919.43">@language plain
@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:22 CST 2004  michael@redpriest Markup_140672220.txt"

The point of using a system like AsciiDoc is to get a document that
is properly typeset, while writing only plain text with as little
embedded formatting instruction as possible.

For the most part, you simply write chunks of text, which become
typeset paragraphs.

I've tried to use most commonly used markup in the Leo outline that
contains all the Leo2AsciiDoc source and documentation, so that you
can see exactly how markup may be used.

@code</t>
<t tx="ekr.20040331071919.44">@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:20 CST 2004  michael@redpriest Standard_AsciiDoc_Markup_140676540.txt"

This section illustrates a very small part of the standard AsciiDoc
markup.  However, AsciiDoc comes with extensive documentation of its
own, which any Leo2AsciiDoc user should read.


@code</t>
<t tx="ekr.20040331071919.45">@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:06 CST 2004  michael@redpriest Headings_141020668.txt"

indexterm:[Markup, Headings]
Leo2AsciiDoc will automatically create Headings from the headings of
your Leo outline.  You can turn this off (see Configuration), and
create your own headings in the body text of an outline node.  For
example, a Chapter heading is text at the left margin that has a
following line of dashes.  For example,

@code
 Operation
 ---------

@doc
is the heading of this chapter.  Chapter sub-sections have a
following line of tildes.  For example,

@code

 Markup
 ~~~~~~

@doc

is the heading of Section One of this chapter.  Section Two markup
is a following line of "^".  For example, 

@code

Standard AsciiDoc Markup
^^^^^^^^^^^^^^^^^^^^^^^^
@doc

is the heading of the section, which is a Section Two.

As I say, you normally don't need to do this, since Leo2AsciiDoc does all
this itself from the outline headings.


@code
</t>
<t tx="ekr.20040331071919.46">@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:06 CST 2004  michael@redpriest Lists_141018612.txt"

indexterm:[Markup, lists]
Bulleted lists start with a dash (or asterisk) followed by a space
or tab character.  I've extended this to allow leading spaces.  For
example,
    
@code
    - this is a list item
        * this is a sub-item
    - this is another list item
@doc

produces:

    - this is a list item
        * this is a sub-item
    - this is another list item


@code</t>
<t tx="ekr.20040331071919.47">@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:07 CST 2004  michael@redpriest URLs_140994492.txt"

indexterm:[Markup, URL]
The URL address of a web page will be "hot" in the HTML or PDF
document, when terminated with square brackets:

@code

http://www.docbook.org[The official home page for DocBook: The Definitive  Guide.]

@doc

results in:

http://www.docbook.org[The official home page for DocBook: The Definitive Guide.]


@code</t>
<t tx="ekr.20040717133342"></t>
<t tx="ekr.20040722134535"></t>
<t tx="ekr.20040722135402"></t>
<t tx="ekr.20040722135402.1"></t>
<t tx="ekr.20040722141148">@

You would typically not enable any of the following "plugins".

These plugins contain example code only.</t>
<t tx="ekr.20040809151600.52"># Leo comes with aspell23.pyd and aspell24.pyd pre-made.
# The following notes are for reference only.</t>
<t tx="ekr.20040809151600.53">"""A Pyrex wrapper for the aspell api."""

cdef extern from "aspell.h":
  ctypedef struct AspellConfig
  AspellConfig* new_aspell_config()
  void delete_aspell_config(AspellConfig*)
  int aspell_config_replace(AspellConfig*, char*, char*)
  ctypedef struct AspellCanHaveError
  AspellCanHaveError* new_aspell_speller(AspellConfig*)
  #ctypedef struct AspellManager
  unsigned int aspell_error_number(AspellCanHaveError*)
  char* aspell_error_message(AspellCanHaveError*)
  ctypedef struct AspellSpeller
  AspellSpeller* to_aspell_speller(AspellCanHaveError*)
  int aspell_speller_check(AspellSpeller*, char*, int)
  ctypedef struct AspellWordList
  AspellWordList* aspell_speller_suggest(AspellSpeller*, char*, int)
  ctypedef struct AspellStringEnumeration
  AspellStringEnumeration * aspell_word_list_elements(AspellWordList*)
  char* aspell_string_enumeration_next(AspellStringEnumeration*)
  int aspell_speller_store_replacement(AspellSpeller*, char*, int, char*, int)
  int aspell_speller_add_to_session(AspellSpeller*, char*, int)
  int aspell_speller_add_to_personal(AspellSpeller*, char*, int)
  int aspell_speller_error(AspellSpeller*)
  char* aspell_speller_error_message(AspellSpeller*)
  int aspell_speller_save_all_word_lists(AspellSpeller*)

class Error(Exception):
  pass

cdef class spell_checker:
  '''A simple wrapper for the Aspell API'''
  cdef AspellConfig* config
  cdef AspellSpeller* checker
  
  @others</t>
<t tx="ekr.20040809151600.54">@language python
@tabwidth -4

from distutils.core import setup, Extension
from Pyrex.Distutils import build_ext
import os

if os.name == 'nt':
  #c:/Program Files/Aspell
  aspell_home = './aspell-dev-0-50-3-3'
  libraries = ['aspell-15']
  include_dirs = [aspell_home+'/include']
  library_dirs = [aspell_home+'/lib']
else:
  raise RuntimeError, 'you need to modify setup.py to work with %s' % os.name

ext = Extension('aspell', ['aspell.pyx' ],
                libraries = libraries,
                include_dirs = include_dirs,
                library_dirs = library_dirs,
                )
                
setup(name="aspell", version="1.1",
      ext_modules = [ext],
      cmdclass = {'build_ext': build_ext}
)</t>
<t tx="ekr.20040809160744">@killcolor

You also need from aspell the include and lib dev packages
if on windows the dlls and a sutible dictionary

included here for redistribution as a convience only
unmodifyed except for path to the include &amp; lib path

A Pyrex wrapper for the aspell api.

&lt;http://prdownloads.sourceforge.net/uncpythontools/aspell-1.0.zip?download&gt;
&lt;http://sourceforge.net/project/showfiles.php?group_id=82407&gt;</t>
<t tx="ekr.20040809160744.1">def __init__(self, lang="en_US", prefix="c:/Program Files/Aspell", **kwargs):

    self.config = new_aspell_config()
    aspell_config_replace(self.config, "prefix", prefix)
    aspell_config_replace(self.config, "lang", lang)
    for key,value in kwargs.items():
      aspell_config_replace(self.config, key, value)
    cdef AspellCanHaveError* possible_err
    possible_err = new_aspell_speller(self.config)
    if aspell_error_number(possible_err) != 0:
      msg = aspell_error_message(possible_err)
      raise Error, msg
    else:
      self.checker = to_aspell_speller(possible_err)</t>
<t tx="ekr.20040809160744.2">def check(self, word):
    '''Return 0 if word is misspelled, 1 otherwise.'''
    return aspell_speller_check(self.checker, word, len(word))</t>
<t tx="ekr.20040809160744.3">def suggest(self, word):
    '''Return a list of suggested replacements for a misspelled word.'''
    cdef AspellWordList* suggestions
    # I need a cast here to stop the C compiler from complaining about const mismatch
    suggestions = &lt;AspellWordList*&gt;aspell_speller_suggest(self.checker, word, len(word))
    cdef AspellStringEnumeration* elements
    elements = aspell_word_list_elements(suggestions)
    result = []
    cdef char* suggestion
    while 1:
      # this cast is the hush the C compiler which knows this function is const char*
      suggestion = &lt;char*&gt;aspell_string_enumeration_next(elements)
      if suggestion == NULL:
        break
      result.append(suggestion)
    return result</t>
<t tx="ekr.20040809160744.4">def store_replacement(self, wrongword, rightword):
    '''Tell Aspell about the correction so it can learn about your mistakes.'''
    return aspell_speller_store_replacement(self.checker, wrongword, len(wrongword),
                                            rightword, len(rightword))</t>
<t tx="ekr.20040809160744.5">def add_to_session(self, word):
    '''Tell Aspell to allow word for this session.'''
    return aspell_speller_add_to_session(self.checker, word, len(word))

</t>
<t tx="ekr.20040809160744.6">def add_to_personal(self, word):
    '''Tell Aspell to allow word permanently.'''
    r = aspell_speller_add_to_personal(self.checker, word, len(word))
    aspell_speller_save_all_word_lists(self.checker)
    return r</t>
<t tx="ekr.20040809161108">@killcolor

Pyrex is *SO* great! I wrote this in about 1 hour from the
Aspell doc. I spent most of that hour figuring out that I needed to
set the Aspell "prefix" to get it to work!

Intended usage is:

1) create a spell_checker object for each document.

2) check a word by calling the check method

3) if you get 0 back indicating a misspelling, use the suggest method
   to get a list of possible correct spellings.
   
4) tell aspell about the correct choice so it can learn from your
   errors using the store_replacement method
   
5) add words to either the session dictionary or to your personal
   dictionary using the add_to_session or add_to_personal methods.

import aspell
sc = aspell.spell_checker()
word = 'flarg'
if not sc.check(word):
  print word, 'is incorrect'
  print 'suggestions include:', sc.suggest(word)

To get this to build and work on Windows I downloaded the Windows
version of aspell from http://aspell.net/win32/. I got the Full
Installer, a dictionary, and the libraries for MS VisualC++ as
separate downloads. I let the first two go to their default locations
and I unpacked the zip file for the last into the C:\Program
Files\Aspell top directory. Then I copied the aspell-15.dll from
C:\Program Files\Aspell\bin to a folder on my path.

You will also, of course, need Pyrex from
http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/.

With the above completed the standard 'python setup.py install' should
build and install the extension.

I believe this should work on Linux with trivial modification.

This software is free for anyone to use for any purpose. If you or your
lawyer are stupid enough to believe that I have any liability for this
code then do not use it.

23 May 2004
Gary Bishop</t>
<t tx="ekr.20040828105233">@first # -*- coding: utf-8 -*-
@language python
@tabwidth -4

"""
Translate a few menu items into Simplified Chinese
Leo
   By Zhang Le &lt;ejoy@xinhuanet.com&gt;
   
"""

# Chinese translation completed by Zhang Le, May 2004
# based on the french_fm.py

# NOTE: The accelerated key (&amp;) failed to work on Chinese text, probably because 
# the width of one Chinese character is 2 not 1, which confuses Tk. I'm not sure 
# whether this is a bug of Tk or a bug of Leo. Although I do not use &amp; in the 
# Chinese menu, Tk places an underline below the first character of each menu
# entry. Another bug in Tk?

# Note 2 (EKR):  The menu names themselves did not translate on my XP machine.
# All the headlines appear as "??".

import leoPlugins
import leoGlobals as g

@others

if not g.app.unitTesting: # Unpleasant for unit testing.

    # Register the handlers...
    leoPlugins.registerHandler("menu1", onMenu)
    
    __version__ = "1.1" # Set version for the plugin handler.
    g.plugin_signon(__name__)</t>
<t tx="ekr.20040828105233.1">def onMenu (tag,keywords):

    c = keywords.get("c")
    table = (
        @others
    )

    # Call the convenience routine to do the work.
    c.frame.menu.setRealMenuNamesFromTable(table)</t>
<t tx="ekr.20040828105233.2">("File","File"),
    ("New",""),
    ("Open...",""),
    ("Open With...","..."),
    ("Close",""),
    ("Save",""),
    ("Save As","..."),
    ("Save To","..."),
    ("Revert To Saved",""),
    ("Recent Files...","..."),
        ("Clear Recent Files",""),
    ("Read/Write...", "/..."),
        ("Read Outline Only", ""),
        ("Read @file Nodes", " @file "),
        ("Write Dirty @file Nodes", " @file "),
        ("Write missing @file Nodes", "(missing) @file "),
        ("Write Outline Only", ""),
        ("Write @file Nodes", " @file "),
        ("Write 4.x Derived Files", " 4.x "),
        ("Write 3.x Derived Files", " 3.x "),
    ("Tangle...", "Tangle ..."),
        ("Tangle All", " Tangle"),
        ("Tangle Marked", " Tangle "),
        ("Tangle", "Tangle "),
    ("Untangle...", "Untangle ..."),
        ("Untangle All", " Untangle"),
        ("Untangle Marked", " Untangle "),
        ("Untangle", "Untangle "),
    ("Import...", "..."),
        ("Import Derived File", ""),
        ("Import To @file", " @file"),
        ("Import To @root", " @root"),
        ("Import CWEB Files", " CWEB "),
        ("Import noweb Files", " noweb "),
        ("Import Flattened Outline", " (Flattened)  (MORE )"),
    ("Export...", "..."),
        ("Export Headlines", " (Headlines)"),
        ("Outline To CWEB", " CWEB"),
        ("Outline To Noweb", " Noweb"),
        ("Flatten Outline", " (Flattened)  (MORE )"),
        ("Remove Sentinels", " (Sentinelles)"),
        ("Weave", " Weave  (Listing)"),
        ("Export all to AsciiDoc", " AsciiDoc "),
        ("Export current tree to AsciiDoc", " AsciiDoc "),
    ("Exit",""),
</t>
<t tx="ekr.20040828105233.3">("Edit","Edit"),
    ("Undo Typing",""),
    ("Undo Cut Node",""),
    ("Redo Typing",""),
    ("Can't Undo", ""),
    ("Can't Redo", ""),
    ("Cut", ""),
    ("Copy", ""),
    ("Paste", ""),
    ("Delete", ""),
    ("Select All", ""),
    ("Edit Body...", "..."),
        ("Extract Section", "Extract Section"),
        ("Extract Names", "Extract Names"),
        ("Extract", "Extract"),
        ("Convert All Blanks", "Convert All Blanks"),
        ("Convert All Tabs", "Convert All Tabs"),
        ("Convert Blanks", "Convert Blanks"),
        ("Convert Tabs", "Convert Tabs"),
        ("Insert Body Time/Date", "/"),
        ("Reformat Paragraph", ""),
        ("Indent", ""),
        ("Unindent", ""),
        ("Match Brackets", ""), #  &lt;({["), #EKR
    ("Edit Headline...", "..."),
        ("Edit Headline", ""),
        ("End Edit Headline", ""),
        ("Abort Edit Headline", ""),
        ("Insert Headline Time/Date", "/"),
        ("Toggle Angle Brackets", ""),
    ("Find...", "..."),
        ("Find Panel", ""),
        ("Find Next", ""),
        ("Find Previous", ""),
        ("Replace", ""),
        ("Replace, Then Find", ""),
    ("Go To Line Number", "..."),
    ("Execute Script", "Python"),
    ("Set Font...", "..."),
    ("Set Colors...", "..."),
    ("Show Invisibles", ""),
    ("Hide Invisibles", ""),
    ("Preferences", ""),
</t>
<t tx="ekr.20040828105233.4">("Outline", "Outline"),
    ("Cut Node", ""),
    ("Copy Node", ""),
    ("Paste Node", ""),
    ("Delete Node", ""),
    ("Insert Node", ""),
    ("Clone Node", ""),
    ("Sort Children", ""),
    ("Sort Siblings", ""),
    ("Check Outline", ""),
    ("Dump Outline", " (Dump)"),
    ("Hoist", " (Hoist)"),
    ("De-Hoist", " (De-Hoist)"),
    ("Expand/Contract...", "/"),
        ("Contract All", ""),
        ("Contract Node", ""),
        ("Contract Parent", ""),
        ("Expand Prev Level", ""),
        ("Expand Next Level", ""),
        ("Expand To Level 1", "1"),
        ("Expand To Level 2", "2"),
        ("Expand To Level 3", "3"),
        ("Expand To Level 4", "4"),
        ("Expand To Level 5", "5"),
        ("Expand To Level 6", "6"),
        ("Expand To Level 7", "7"),
        ("Expand To Level 8", "8"),
        ("Expand All", ""),
        ("Expand Node", ""),
    ("Move...", "..."),
        ("Move Down", ""),
        ("Move Left", ""),
        ("Move Right", ""),
        ("Move Up", ""),
        ("Promote", "Promote"),
        ("Demote", "Demote"),
    ("Mark/Unmark...", "..."),
        ("Mark", ""),
        ("Unmark", ""),
        ("Mark Subheads", ""),
        ("Mark Changed Items", ""),
        ("Mark Changed Roots", " (Roots)"),
        ("Mark Clones", ""),
        ("Unmark All", ""),
    ("Go To...", "..."),
        ("Go Back", ""),
        ("Go Forward", ""),
        ("Go To Next Marked", ""),
        ("Go To Next Changed", ""),
        ("Go To Next Clone", ""),
        ("Go To First Node", ""),
        ("Go To Last Node", ""),
        ("Go To Parent", ""),
        ("Go To Prev Sibling", ""),
        ("Go To Next Sibling", ""),
        ("Go To Prev Visible", ""),
        ("Go To Next Visible", ""),
        ("Go To Prev Node", ""),
        ("Go To Next Node", ""),</t>
<t tx="ekr.20040828105233.5">("Plugins", "Plugins"),
    ("chinese", "Chinese ()"),
</t>
<t tx="ekr.20040828105233.6">("Window", "Window"),
    ("Equal Sized Panes", ""),
    ("Toggle Active Pane", ""),
    ("Toggle Split Direction", ""),
    ("Cascade", ""),
    ("Minimize All", ""),
    ("Open Compare Window", "..."),
    ("Open Python Window", "Python(IDLE)..."),
</t>
<t tx="ekr.20040828105233.7">("Help", "Help"),
    ("About Leo...", "Leo..."),
    ("Online Home Page", ""),
    ("Open Online Tutorial", ""),
    ("Open Offline Tutorial", " (CHM)"),
    ("Open LeoDocs.leo", " LeoDocs.leo"),
    ("Open LeoConfig.leo", " LeoConfig.leo"),
    ("Apply Settings", "")</t>
<t tx="ekr.20040915073259"></t>
<t tx="ekr.20040918165144.9"></t>
<t tx="ekr.20040918165427"></t>
<t tx="ekr.20040918165427.4">@nocolor

Developers
By: jasonic ( Jason Cunliffe ) 
 @dictionary   
2003-08-21 07:51

Auto-completion dictionary files would be excellent.
Ideally each Leo language extension could just point to a separate .dict file. 

Hopefully we can build some Leo plugin utilities to generate these .dict files by parsing any file you'd like to use a 'source' for Leo dictionary. They might need manual cleanup, but vcould be big timesaver, especially for XML formats and the like. Great to be able to sahre these easily. 

Interesting uses for Leo dictionaries beyond just autocompletion. 
I am thinking they might open the door to some powerful macro/template behavior. 

For example, you load a special dictionary to help certain kinds of repetitive formatted content. CSS and XSLT could be good candidates, but also any kind of mild databases or lists. Documentation.

So first we need basic dicts for Leo supported languages: Python, Perl, Javascript etc..

Then we need to consider that any Leo Node could have its own dictionary defined inline..

@dictionary filepath-to-custom-leo-dict

With collaborative LeoN this would be very useful because connected Leo sessions could invoke each other's dictionaries!!

- Jason  
</t>
<t tx="ekr.20040918165427.5">http://sourceforge.net/forum/message.php?msg_id=2388444
By: mdawson

I use DocBook XML for my computer documentation, and lately for
publishing just about any text document.  Naturally, I wanted an
easy way to use DocBook to publish Leo outlines.

I've written a small Leo module, called Leo2AsciiDoc, that enables
automatic publication of a plain text Leo outline to HTML or PDF, or
as a web site or man page.  Stuart Rackham's AsciiDoc program (in
Python) is what makes this possible.
    Leo2AsciiDoc exports a Leo outline to a text file, from whence
it can be converted to DocBook XML by AsciiDoc, and then
automatically published via DocBook to HTML or PDF.

One Leo outline can contain any number of documents, or web sites
(via DocBook Website).

I'm also learning Literate Programming, and am happy to be able to
automatically publish (via make) a program's source and
documentation from Leo.

An example of the product is the paged HTML documentation for the
module at:
    http://devguide.leo.marshallresearch.ca

The web page for Leo2AsciiDoc is
at:
    http://leo.marshallresearch.ca

That web site is produced from a Leo outline.

    ----------------------------------------
    Michael Dawson</t>
<t tx="ekr.20041001210557"></t>
<t tx="ekr.20041009112303"></t>
<t tx="ekr.20041019072632"></t>
<t tx="ekr.20041030092101">@ Notes by EKR:  The dyna plugin is a remarkable body of work by 'e'.  Have fun with it.

You may download the latest version at: http://rclick.netfirms.com/dyna_menu.py.html
</t>
<t tx="ekr.20041103050629">import leoGlobals as g

import leoColor
import leoCommands
import leoFileCommands
import leoFrame
import leoNodes
import leoPlugins
import leoTkinterFrame
import leoTkinterMenu
import leoTkinterTree

Tk  = g.importExtension('Tkinter',pluginName=__name__,verbose=True)
Pmw = g.importExtension("Pmw",    pluginName=__name__,verbose=True)
   
from leoTkinterFrame import leoTkinterLog
from leoTkinterFrame import leoTkinterBody

import os
import string
import sys
import time
import zipfile</t>
<t tx="ekr.20041103051117">@killcolor
@

v .2

1. Trash. If there is a Chapter in the Leo project called 'Trash' all deleted nodes are deposited there. Then when deleted in the 'Trash' chapter it is finally removed. There is an option to quickly add a Trash barrel in the menu.
2. Menu moved from Outline to being summoned by right clicking on a chapter tab or in the area of the tabs.
3. Swapping Chapters. Swap one Chapter for another one.
4. Conversion ops. Take one Outline and turn each node into a Chapter. The convers operation is also there, take each top level node in each Chapter and add it to one Chapter.
5. Import/Export. You are now able to load leo files as Chapters. This means, for example, that if you have 5 Outlines that you would like to bind together as one Leo file but keep their separateness you can now import those 5 Outlines into there own Chapters. You can also Export a single Chapter into it's own separate Leo file.
6. Search and Clone. This functionality is very similar to the Filtered Hoist concept. You decide which Chapter you want your search results to appear in and a dialog will pop up. You can enter simple text or a more complex regular expression and the function will search all the outlines and create a node with the results as children.
7. Editors now have headlines indicating what Chapters and what node are being worked on.

v .6 EKR: Based on version .5 by Leo User.

- Added g. before all functions in leoGlobals.py.
- Right clicking on Chapter tab crashes.

.61 fixed up a couple of spots.

.62 EKR: Restored conditional call to g.app.createTkGui(__file__) in startup code.

.63 EKR: Added long docstring.

.64 fixed cloneWalk and PDF Convertor.

.65 EKR: added new keyword args to newGetLeoFile and newOpen.
    - This is needed because of changes to the corresponding method's in Leo's core.

.66 EKR: use notebooks.get(c) throughout.
    - c may not exist during unit testing.  Not a complete fix, not tested!

.67 EKR:
    - Added 'silent' keywords to newGetLeoFile and newOpen.
.68 EKR:
    - Use 'c._xPosition. or c.nullPosition()' to init so that c._xPosition is never None.</t>
<t tx="ekr.20041103051228">def __init__( self, c, tree, frame, canvas ):
        
    self.c = c
    self.tree = tree
    self.frame = frame
    self.canvas = canvas
    self.treeBar = frame.treeBar

    if hasattr( c, 'cChapter' ):
        tn = leoNodes.tnode( '', 'New Headline' )
        vn = leoNodes.vnode( c, tn )
        pos = leoNodes.position(c, vn, [] )
        self.cp = pos.copy()
        self.rp = pos.copy()
        self.tp = pos.copy()
    else:
        c.cChapter = self
        self.cp = c._currentPosition or c.nullPosition()
        self.tp = c._topPosition or c.nullPosition()
        self.rp = c._rootPosition or c.nullPosition()</t>
<t tx="ekr.20041103051228.1">def _saveInfo( self ):
    
    c = self.c

    self.cp = c._currentPosition or c.nullPosition()
    self.rp = c._rootPosition or c.nullPosition()
    self.tp = c._topPosition or c.nullPosition()</t>
<t tx="ekr.20041103051228.2">def setVariables( self ):
    
    c = self.c
    frame = self.frame
    frame.tree = self.tree
    frame.canvas = self.canvas
    frame.treeBar = self.treeBar
    c._currentPosition = self.cp
    c._rootPosition = self.rp
    c._topPosition = self.tp</t>
<t tx="ekr.20041103051228.3">def makeCurrent( self ):
    
    c = self.c
    c.cChapter._saveInfo()
    c.cChapter = self
    self.setVariables()
    c.redraw()
    self.canvas.update_idletasks()</t>
<t tx="ekr.20041103052443"># Execute this in a script button.

import string

@others

if 1:
    &lt;&lt; set nameList to the list of functions in leoGlobals.py &gt;&gt;
else:
    p = g.findNodeAnywhere("@file leoGlobals.py")
    nameList = findFunctionsInTree(p)

    nameList.sort() ; g.enl()
    for name in nameList: g.es("'%s'," % name)
    
    s = "%d functions in leoGlobals.py" % len(nameList)
    print s ; g.es(s)


p = c.currentPosition()
g.enl() ; g.enl()
count = prependNamesInTree(p,nameList,"g.",replace=True) # Just prints if replace==False.
s = "%d --- done --- " % count
print s ; g.es(s)</t>
<t tx="ekr.20041103052443.1">def findFunctionsInTree(p):
    
    nameList = []
    for p in p.self_and_subtree_iter():
        names = findDefs(p.bodyString())
        if names:
            for name in names:
                if name not in nameList:
                    nameList.append(name)
    return nameList</t>
<t tx="ekr.20041103052443.2">def findDefs(body):
    
    lines = body.split('\n')
    names = []
    for s in lines:
        i = g.skip_ws(s,0)
        if g.match(s,i,"class"):
            return [] # The classes are defined in a single node.
        if g.match(s,i,"def"):
            i = g.skip_ws(s,i+3)
            j = g.skip_c_id(s,i)
            if j &gt; i:
                name = s[i:j]
                if g.match(name,0,"__init__"): 
                    return [] # Disallow other class methods.
                names.append(name)
    return names</t>
<t tx="ekr.20041103052443.3">def prependNamesInTree(p,nameList,prefix,replace=False):
    
    c = p.c
    
    assert(len(prefix) &gt; 0)
    ch1 = string.letters + '_'
    ch2 = string.letters + string.digits + '_'
    def_s = "def " ; def_n = len(def_s)
    prefix_n = len(prefix)
    total = 0
    c.beginUpdate()
    for p in p.self_and_subtree_iter():
        count = 0 ; s = p.bodyString()
        printFlag = False
        if s:
            for name in nameList:
                i = 0 ; n = len(name)
                while 1:
                    &lt;&lt; look for name followed by '(' &gt;&gt;
            if count and replace:
                if 0:
                    &lt;&lt; print before and after &gt;&gt;
                p.setBodyStringOrPane(s)
                p.setDirty()
        g.es("%3d %s" % (count,p.headString()))
        total += count
    c.endUpdate()
    return total</t>
<t tx="ekr.20041103052443.4">i = s.find(name,i)
if i == -1:
    break
elif g.match(s,i-1,'.'):
    i += n # Already an attribute.
elif g.match(s,i-prefix_n,prefix):
    i += n # Already preceded by the prefix.
elif g.match(s,i-def_n,def_s):
    i += n # preceded by "def"
elif i &gt; 0 and s[i-1] in ch1:
    i += n # Not a word match.
elif i+n &lt; len(s) and s[i+n] in ch2:
    i += n # Not a word match.
else:
    j = i + n
    j = g.skip_ws(s,j)
    if j &gt;= len(s) or s[j] != '(':
        i += n
    else: # Replace name by prefix+name
        s = s[:i] + prefix + name + s[i+n:]
        i += n ; count += 1
        # g.es('.',newline=False)
        if 1:
            if not printFlag:
                printFlag = True
                # print p.headString()
            print g.get_line(s,i-n)</t>
<t tx="ekr.20041103052443.5">print "-"*10,count,p.headString()
print "before..."
print p.bodyString()
print "-"*10,"after..."
print s</t>
<t tx="ekr.20041103052443.6">nameList = (
'alert',
'angleBrackets',
'appendToList',
'callerName',
'CheckVersion',
'choose',
'clearAllIvars',
'clear_stats',
'collectGarbage',
'computeLeadingWhitespace',
'computeWidth',
'computeWindowTitle',
'createTopologyList',
'create_temp_name',
'disableIdleTimeHook',
'doHook',
'dump',
'ecnl',
'ecnls',
'enableIdleTimeHook',
'enl',
'ensure_extension',
'es',
'esDiffTime',
'es_error',
'es_event_exception',
'es_exception',
'escaped',
'executeScript',
'file_date',
'findNodeAnywhere',
'findTopLevelNode',
'findNodeInTree',
'findReference',
'find_line_start',
'find_on_line',
'flattenList',
'funcToMethod',
'getBaseDirectory',
'getOutputNewline',
'getTime',
'get_Sherlock_args',
'get_directives_dict',
'get_leading_ws',
'get_line',
'get_line_after',
'getpreferredencoding',
'idleTimeHookHandler',
'importFromPath',
'initScriptFind',
'init_sherlock',
'init_trace',
'isUnicode',
'isValidEncoding',
'is_c_id',
'is_nl',
'is_special',
'is_ws',
'is_ws_or_nl',
'joinLines',
'listToString',
'makeAllNonExistentDirectories',
'makeDict',
'match',
'match_c_word',
'match_ignoring_case',
'match_word',
'module_date',
'openWithFileName',
'optimizeLeadingWhitespace',
'os_path_abspath',
'os_path_basename',
'os_path_dirname',
'os_path_exists',
'os_path_getmtime',
'os_path_isabs',
'os_path_isdir',
'os_path_isfile',
'os_path_join',
'os_path_norm',
'os_path_normcase',
'os_path_normpath',
'os_path_split',
'os_path_splitext',
'pause',
'plugin_date',
'plugin_signon',
'printDiffTime',
'printGc',
'printGcRefs',
'printGlobals',
'printLeoModules',
'print_bindings',
'print_stats',
'readlineForceUnixNewline',
'redirectStderr',
'redirectStdout',
'removeLeadingWhitespace',
'removeTrailingWs',
'reportBadChars',
'restoreStderr',
'restoreStdout',
'sanitize_filename',
'scanAtEncodingDirective',
'scanAtFileOptions',
'scanAtLineendingDirective',
'scanAtPagewidthDirective',
'scanAtRootOptions',
'scanAtTabwidthDirective',
'scanDirectives',
'scanError',
'scanf',
'set_delims_from_language',
'set_delims_from_string',
'set_language',
'shortFileName',
'skip_blank_lines',
'skip_block_comment',
'skip_braces',
'skip_c_id',
'skip_heredoc_string',
'skip_leading_ws',
'skip_leading_ws_with_indent',
'skip_line',
'skip_long',
'skip_matching_delims',
'skip_nl',
'skip_non_ws',
'skip_parens',
'skip_pascal_begin_end',
'skip_pascal_block_comment',
'skip_pascal_braces',
'skip_pascal_string',
'skip_php_braces',
'skip_pp_directive',
'skip_pp_if',
'skip_pp_part',
'skip_python_string',
'skip_string',
'skip_to_char',
'skip_to_end_of_line',
'skip_to_semicolon',
'skip_typedef',
'skip_ws',
'skip_ws_and_nl',
'splitLines',
'stat',
'stdErrIsRedirected',
'stdOutIsRedirected',
'toEncodedString',
'toUnicode',
'toUnicodeFileEncoding',
'top',
'trace',
'trace_tag',
'update_file_if_changed',
'utils_rename',
'windows',
'wrap_lines')</t>
<t tx="ekr.20041103054545">leoTkinterFrame.leoTkinterFrame.createCanvas = newCreateCanvas
leoTkinterFrame.leoTkinterBody.createControl = newCreateControl

leoTkinterTree.leoTkinterTree.select = newselect
leoTkinterTree.leoTkinterTree.endEditLabel = newendEditLabel
leoTkinterTree.leoTkinterTree.__init__ = newTreeinit

g.os_path_dirname = new_os_path_dirname

leoFileCommands.fileCommands.write_LEO_file = newWrite_LEO_file
leoFileCommands.fileCommands.write_Leo_file = newWrite_LEO_file
leoFileCommands.fileCommands.getLeoFile = newGetLeoFile
leoFileCommands.fileCommands.open = newOpen

if hasattr( leoNodes.vnode, 'doDelete' ):
    leoNodes.vnode.doDelete = newTrashDelete
else:
    leoNodes.position.doDelete = newTrashDelete</t>
<t tx="ekr.20041106100326">import leoGlobals as g
import leoNodes
import leoPlugins
import leoTkinterFrame

try:
    import Tkinter as Tk
    import ScrolledText
    import tkFont
except:
    Tk = None

import ConfigParser
import os
import sys
import weakref

try:
    pth = os.path.split( g.app.loadDir ) 
    ppath = pth[ 0 ] + os.sep + 'plugins'
    ext_path = pth[ 0 ] + os.sep + 'plugins' + os.sep + 'temacs_ext'
    try:
        if not os.path.exists( ext_path ):
            os.mkdir( ext_path )
    except Exception, x:
        g.es( "Attempt to create %s failed because of %s" %( ext_path, x ) )
    sys.path.append( ppath )
    sys.path.append( ext_path )
    temacs = __import__( 'temacs', globals(), locals())
except Exception, x:
    g.es( "temacs not loadable. Aborting load of usetemacs because of: " + str( x ))
    temacs = None
</t>
<t tx="ekr.20041106100326.1">@others
@nocolor</t>
<t tx="ekr.20041106100326.2">orig_Bindings = leoTkinterFrame.leoTkinterBody.createBindings
leoTkinterFrame.leoTkinterBody.createBindings = initialise() #createBindings

orig_OnBodyKey = leoTkinterFrame.leoTkinterBody.onBodyKey
leoTkinterFrame.leoTkinterBody.onBodyKey = modifyOnBodyKey</t>
<t tx="ekr.20041106100834">@
This part runs Temacs with a Text widget.
It should be accessible by typing python temacs.py at the command prompt
Note: There is no configuration as to buffers and such, so dont access that functionality.  Just a proof of concept.

@c

Tl = Tkinter.Tk()
Tl.title( 'temacs Emacs test' )
Tx = Tkinter.Text( background = 'white', foreground = 'blue' )
f2 = Tkinter.Frame()
f2.pack( side = 'bottom' )
def onQuit():
    import sys
    sys.exit( 0 )
    
minibuffer = Tkinter.Label( f2 )
minibuffer.pack( side = 'right', expand = 1, fill = 'both' )
quitb = Tkinter.Button( f2, text = 'Quit' , command = onQuit )
quitb.pack( side = 'left' )
Tx.pack( side = 'top' )
emacs = Emacs( Tx, minibuffer, True, True )
Tl.mainloop()</t>
<t tx="ekr.20041106101311">@nocolor

@others</t>
<t tx="ekr.20041107165824"></t>
<t tx="ekr.20041109120739">def otherPages( canvas, doc , pageinfo = pinfo):

    canvas.saveState()
    canvas.setFont('Times-Roman',9) 
    canvas.drawString(inch, 0.75 * inch, "Page %d %s" % (doc.page, pageinfo)) 
    canvas.restoreState()</t>
<t tx="ekr.20041109123143">'''This plugin creates separate outlines called "chapters" within a single .leo file.  Clones work between Chapters.

**Warning**: This plugin must be considered **buggy** and **unsafe**.  Use with extreme caution.

Requires Python Mega Widgets and Leo 4.2 or above.

Numbered tabs at the top of the body pane represent each chapter.  Right clicking the tab will show a popup menu containing commands.  These commands allow you to:
    
- insert and delete chapters.
- add names to chapters.
- split the body pane to create multiple "editors".
- create a "trash barrel that hold all deleted nodes.
- import and export outlines and chapters.
- create a pdf file from your chapters (requires reportlab toolkit at http://www.reportlab.org).
- and more...
 
Warnings:
    
- This plugin makes substantial changes to Leo's core.
- Outlines containing multiple chapters are stored as a zipped file that can only be read when this plugin has been enabled.
'''</t>
<t tx="ekr.20041110104350"></t>
<t tx="ekr.20041114102139">@nocolor</t>
<t tx="ekr.20041114102139.1">- Several plugins show the docstring, so please take care to do a good job of
describing what the plugin does and how to use it.

- Please put the following immediately following the plugin's docstring.

    @language python
    @tabwidth -4

- There is no need to use sections if they are empty.

- The code should test whether modules have been imported only if those modules
may not be available on all platforms.

- Use following three lines only if your plugin uses a gui.

    if g.app.gui is None: 
        g.app.createTkGui(__file__)
    if g.app.gui.guiName() == "tkinter":
        ...

- Please use g.plugin_signon as shown, not leoPlugins.signon.</t>
<t tx="ekr.20041114102139.2">Please use the general format as shown in &lt;&lt; imports &gt;&gt;.  In partular:

- Please do _not_ assume that modules like Tkinter, Pmw, etc. are always available.
  Use g.importExtension.

- Good Python style is to put each import on a separate line.

- Please abbreviate Tkinter as Tk.  Please do NOT abbreviate Pmw or leoPlugins.

- Please do NOT use either of the following kinds of imports.
    from m import *
    from m import x,y,z

- Do not import leoNodes unless your plugin creates nodes directly.</t>
<t tx="ekr.20041114103913">Most of the comments in the style guide are comments _about_ the style guide.
You would replace these comments with your own, or eliminate them entirely in
your plugin.</t>
<t tx="ekr.20041114103913.1">PLEASE define each function or method in a separate node! To make this work,
just put @others in the root of your plugin as shown. Note that @others may be
nested, as shown in class myClass.</t>
<t tx="ekr.20041211035618"></t>
<t tx="ekr.20041215103252"></t>
<t tx="ekr.20050101090717">"""
mnplugins.py

mnplugins shows how to :
define new Commands  "insertOK" + "insertUser"
create Usermenu with new Commands

new Commands:
insertOK: 
    insert 'OK' in headline and a stamp in the first bodyline
    are there childnodes without 'OK' verhindern OK in actual node
    (insertOK on iconrclick2 too)

insertUser : Shift-F6
    insert a &lt;user/date/time&gt; stamp at the current location in bodytext
"""</t>
<t tx="ekr.20050101090717.1">import leoGlobals as g
import leoPlugins

import leoCommands
import time

Tk = g.importExtension('Tkinter',pluginName=__name__,verbose=True)</t>
<t tx="ekr.20050111122605"></t>
<t tx="ekr.20050126104457">@nocolor

https://sourceforge.net/forum/message.php?msg_id=2521345
By: bwmulder

I am working on a plugin which works with shadow files in a Leo subdirectory.

This is really the same code posted integrated with Leo. New is that
the goto linenumber command works properly as well.

The new code only kicks in if:
   - A leo subdirectory exists, and
   - both directories contain the file in question.
   
To get things started, create a Leo subdirectory, move the source
files there, and then create zero length strings instead of the moved
files. Whenever you change something in the sourcefile, both files
will be brought up to date automatically.

In the future, I might provide a script which provides this initial
setup automatically.

Implementation notes (relative to 4.1):

In order to use this mechanism to annotate foreign code, I am missing
two pieces:
   
   - The import command should import the source *exactly*.
   - I would like to add comments to the source which are *not* output into
source,
     and live in Leo only (or the shadowfile under Leo sentinel comments).
     
I changed the "message_comment" function to do nothing.

I do not think that this function is a good idea, since Leo can not know
if the line structure in a comment.

There might be more to do in this area.

It seems that I can get around the second limitation by writing "//@"
at the beginning of the line in the code sections, since this is
filtered away by the plugin.

Is there some other way to put comments only in the Leo document, but
not in the derived file?

I had to copy quite a bit of source code for the gotolinenr
command. It probably won't work for the next version of Leo

It seems that Leo somewhat encourages a coding style with long
routines, since complexity can be tugged away into subnodes rather
than creating functions to structure the code.

For the read and write command, I decided to inject a new "open"
function into the global namespace of leoAtFile.py. This function
checks if the caller is the read or write function of leoAtFile.py. In
this case, some special processing for synchronization is done.

I did this strange programming since I did not want to copy large
amounts of code and just add a few lines.

Currently the script works for C and python files. It looks at the
file extension to determine if C or python type annotations are
used. Maybe this information can be centralized.
</t>
<t tx="ekr.20050128070307"></t>
<t tx="ekr.20050217093214">@nocolor</t>
<t tx="ekr.20050227071948"></t>
<t tx="ekr.20050227071948.1">
- move the clone marker to the same place as the blue square
  content indicator. They can overlap.  Make room for annotations.
  



</t>
<t tx="ekr.20050227071948.2">
copy icons from freemind.

expandable box of icons at the head of a headline.
but manipulation vnode's iconx and icony positions.
vnode.computeIcon &amp; setIcon

icons in popup menus too ?

</t>
<t tx="ekr.20050227071948.3">
There seems to be a colour selector in leo.
</t>
<t tx="ekr.20050227071948.4"></t>
<t tx="ekr.20050227071948.5">
He haven't thought about it.
</t>
<t tx="ekr.20050227071948.6"></t>
<t tx="ekr.20050227071948.7"></t>
<t tx="ekr.20050227071948.8"></t>
<t tx="ekr.20050227071948.9"></t>
<t tx="ekr.20050227071948.10">
font
size
style
</t>
<t tx="ekr.20050227071948.11"></t>
<t tx="ekr.20050227071948.12"></t>
<t tx="ekr.20050227071948.13"></t>
<t tx="ekr.20050227071948.14">White or black on some Background
@file
@ignore
features
main branches


Automatically hilight @ nodes

</t>
<t tx="ekr.20050227071948.15"></t>
<t tx="ekr.20050227071948.16"></t>
<t tx="ekr.20050227071948.17">
Store semantics instead of colours.  Semantics then map to colours.


headline colours are reseted by the tree select and unselect methods.
maybe need to override them via the after (re)draw hook.


Offending Methods are all in leoTkinterTree.py
setNormalLabelState (self,v): # selected, editing
setDisabledLabelState (self,v): # selected, disabled
setUnselectedLabelState (self,v): # not selected.


</t>
<t tx="ekr.20050227071948.18">
Different coloured arrows for different priorities.

VeryHigh Red
High Orange
* Medium Green
Low Blue  (whatever)
Done  (tick)
</t>
<t tx="ekr.20050227071948.19">
archtetype based vnode attributes, not colour.
</t>
<t tx="ekr.20050227071948.20"></t>
<t tx="ekr.20050227071948.21">
The colouring conflicts.
</t>
<t tx="ekr.20050227071948.22"></t>
<t tx="ekr.20050227071948.23"></t>
<t tx="ekr.20050227071948.24">Not always predictable.

src/leoTkinterTree.py: menu.post(event.x_root, event.y_root)

</t>
<t tx="ekr.20050227071948.27">
# XXX merge: my model, coad &amp; de luca and holy trinity

# change colours: only foreground !
colour_table = {
    'interface': ["black", "OliveDrab2"],
    'logic':  ("black", "LightSkyBlue2"),
    'data':  ("black", "SandyBrown"),
    }

# Leo nodes.  Background hilite ?
Dead @ignore nodes + Documentat nodes  =&gt; Grey out
@File nodes, sub tree root

# Archetype Colouring

# Holy Trinity
Interface
Logic/Transform Centers/Functions
Data  =&gt; Description

# Coad and De Luca  --- Contrast against their meta-model
# It is a hiearchy going up from Description.
Description/Attributes/Data Catalog:  Purple
Party/Place/Thing:  Green
Role/Participation:  Yellow (Khaki or straw)
Moment/Interval/Event: Pink
Interface: White

# Me
Entity =&gt; Place or thing
  Core  =&gt;  Thing
  Interface =&gt;
  
Relationship (Loading and wiring code) =&gt; Moment(Init)
     =&gt; Special moment
     
* Interaction  =&gt; Moment/Interval + more !

# Unified : 5 Categories Max!!
Attributes, Data, Description, Lookup Tables.   =&gt; Brown
Entity Core, Place, Thing, Party    =&gt; Green
Logic, Pure Functions               =&gt; Blue
Role/Interface/Participation/Trait  =&gt; Straw/Khaki
Dynamic Stuff, Moment/Interaction   =&gt; Pinkish

</t>
<t tx="ekr.20050227071948.28">3. Various drawing hooks. I've restored the drawing hooks that used to exists. These are so-called "stub" hooks. The entries of these hooks in leoDocs.leo and leoPlugins.leo are as follows:
 
 tag argument keys in keywords
 (hook name) overrides when called dictionary argument
 --------- --------- ----------- -------------------
 ...
 "draw-outline-box" yes start of drawBox tree,p,v,x,y (note 6)
 "draw-outline-icon" yes start of tree.drawIcon tree,p,v,x,y (note 6)
 "draw-outline-node" yes start of tree.drawNode tree,p,v,x,y (note 6)
 "draw-outline-text-box" yes start of tree.drawText tree,p,v,x,y (note 6)
 "draw-sub-outline" yes start of tree.drawTree tree,p,v,x,y,h,level (note 6)
 ...
 
 These probably work exactly as the old hooks did, though I didn't use the old (4.0?) code as a base. The only change is the new p keyword argument. In all cases v = p.v. I probably should a p keyword argument to most other hooks, and I'm lazy...
 
 Warning: all these hooks "override" the existing code, which doesn't get executed if the hook returns anything except None. This means that the hook had better return what the "host" code returns, and this has changed recently to support user icons, and may change in the future as needed.
 
 For example, here is the code in drawNode
 
 data = g.doHook("draw-outline-node",tree=tree,p=p,v=v,x=x,y=y)
 if data is not None: return data
 
 At present, drawNode typically returns what return force_draw_node returns, which is a tuple (h,xw). This is needed to support icons of various sizes.
 
 In short, I'm not real sure how useful these hooks are going to be, or how stable.
 

</t>
<t tx="ekr.20050227071948.29">
add the colour menu to rclickhead1


 "draw-outline-box" yes start of drawBox tree,p,v,x,y (note 6)
    It works, but not sure when it is called.

 "draw-outline-icon" yes start of tree.drawIcon tree,p,v,x,y (note 6)
    The box obscures it.  If True is return, rlick wont work anymore.

 "draw-outline-node" yes start of tree.drawNode tree,p,v,x,y (note 6)
    This calls -icon and -box ?
 "draw-outline-text-box" yes start of tree.drawText tree,p,v,x,y (note 6)
    Does not obscure the box area !!

 "draw-sub-outline" yes start of tree.drawTree tree,p,v,x,y,h,level (note 6)
     Use this for head highlighting ? Probally called after the node is draw
     but before drawing the children.
yay ! they work with the CVS version.

@c

#registerHandler("draw-outline-box", draw0)
#registerHandler("draw-outline-node", draw0)
#registerHandler("draw-outline-text-box", draw0)

#registerHandler("iconrclick1",show_colour_menu)
</t>
<t tx="ekr.20050227072121"></t>
<t tx="ekr.20050303051035">@

Note: the newButtons.py now has templates for the following plugin nodes.
    
- init: A generic init function.
- init(tk): An init function for a plugin that uses Tk (or Pmw).
- &lt;&lt; imports &gt;&gt;:  The &lt;&lt;imports&gt;&gt; section.
- &lt;&lt; version history &gt;&gt;: The &lt;&lt;version history&gt;&gt; section.</t>
<t tx="ekr.20050303051035.2">&lt;&lt; docstring &gt;&gt;

__version__ = '0.0'
&lt;&lt; version history &gt;&gt;

&lt;&lt; imports &gt;&gt;

@others</t>
<t tx="ekr.20050303051035.3">'''This docstring should be a clear, concise description of
what the plugin does and how to use it.
'''
</t>
<t tx="ekr.20050303051035.4">@killcolor
@

Put notes about each version here.</t>
<t tx="ekr.20050303051035.5">import leoGlobals as g
import leoPlugins

Pmw = g.importExtension('Pmw',    pluginName=__name__,verbose=True,required=True)
Tk  = g.importExtension('Tkinter',pluginName=__name__,verbose=True,required=True)

# Whatever other imports your plugins uses.</t>
<t tx="ekr.20050303051101">def init ():
    
    ok = Pmw and Tk
    
    if ok:
        if g.app.gui is None:
            g.app.createTkGui(__file__)
            
        ok = g.app.gui.guiName() == "tkinter"

        if ok:
            if 1: # Use this if you want to create the commander class before the frame is fully created.
                leoPlugins.registerHandler('before-create-leo-frame',onCreate)
            else: # Use this if you want to create the commander class after the frame is fully created.
                leoPlugins.registerHandler('after-create-leo-frame',onCreate)
            g.plugin_signon(__name__)
        
    return ok</t>
<t tx="ekr.20050303051150">def onCreate (tag, keys):
    
    c = keys.get('c')
    if not c: return
    
    thePluginController = pluginController(c)</t>
<t tx="ekr.20050303051222">class pluginController:
    
    @others</t>
<t tx="ekr.20050303051222.1">def __init__ (self,c):
    
    self.c = c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.</t>
<t tx="ekr.20050303080042"></t>
<t tx="ekr.20050303080042.1">[Main]

RefreshInterval = 60
ColdColour = blue
HotColour = red
HitsToHeatUp = 2
</t>
<t tx="ekr.20050303080236">@killcolor

- Crashes if .ini file does not exist.</t>
<t tx="ekr.20050306071540">def onStart2 (tag, keywords):
    
    """
    Showing how to define a global hook that affects all commanders.
    """

    import leoTkinterFrame
    log = leoTkinterFrame.leoTkinterLog
    
    # Replace frame.put with newPut (not shown).
    g.funcToMethod(newPut,log,"put")</t>
<t tx="ekr.20050306071629">&lt;&lt; docstring &gt;&gt;

__version__ = '0.0'
&lt;&lt; version history &gt;&gt;

&lt;&lt; imports &gt;&gt;

@others</t>
<t tx="ekr.20050306071629.1">'''This docstring should be a clear, concise description of
what the plugin does and how to use it.
'''
</t>
<t tx="ekr.20050306071629.2">@killcolor
@

Put notes about each version here.</t>
<t tx="ekr.20050306071629.3">import leoGlobals as g
import leoPlugins

# Whatever other imports your plugins uses.</t>
<t tx="ekr.20050306071629.4">def init ():
    
    ok = True # This might depend on imports, etc.
    
    if ok:
        leoPlugins.registerHandler('start2',onStart2)
        g.plugin_signon(__name__)
        
    return ok</t>
<t tx="ekr.20050306072156">It is usually best _not_ to catch exceptions in plugins:
doHook catches all exceptions and disables further calls to plugins.

If a plugin catches exceptions during startup it should do one of the following:
    
- raise the exception again.
- provide an init function at the top level that reports the failure.</t>
<t tx="ekr.20050306081349"></t>
<t tx="ekr.20050311155753">def init ():
    
    ok = temacs and Tk and not g.app.unitTesting
    
    if ok:
        if g.app.gui is None: 
            g.app.createTkGui(__file__)
    
        if g.app.gui.guiName() == "tkinter":
            global orig_Bindings,orig_OnBodyKey
            &lt;&lt; override createBindings and onBodyKey &gt;&gt;
            loadConfig()
            g.plugin_signon(__name__)
            leoPlugins.registerHandler( ('open2', "new") , addMenu )
            
    return ok</t>
<t tx="ekr.20050328101812"> 
        
        
        </t>
<t tx="ekr.20050328101812.1"></t>
<t tx="ekr.20050328101812.2"></t>
<t tx="ekr.20050328101812.3"></t>
<t tx="ekr.20050329082101"></t>
<t tx="ekr.20050329082101.1">@nocolor</t>
<t tx="ekr.20050329082101.2">The AutoTrees plugin is a helper plugin designed to make it very easy to write "hanlder" plugins to manage dynamic content in Leo outlines. 

AutoTrees provides 

- convenient handler base classes which can be specialized for particular uses
- a manager to turn handlers on and off
- a set of example handlers to show the kinds of things that are possible

AutoTrees doesn't do anything that you cannot do in other ways, but it does provide a consistent way of adding dynamic content. This means that individual plugin writers don't have to rewrite all the same kinds of code each time and also makes it easier to maintain Leo, since it standardizes the way that certain classes of plugin interact with the Leo core.

</t>
<t tx="ekr.20050329082101.3">I'm a plugin writer and I want to write a plugin to display dynamic content - ie content not directly contained in the .leo or derived files, eg

- email messages 
- news feeds
- news groups
- documentation
- remote files
- statistics
- file system data
- data base records

You can do this as a standard plugin, but as an AutoTrees handler you,

- don't need to write code that interacts with the tree (this is done for you)
- get centralized management
- can still do everything else you could as a normal plugin

</t>
<t tx="ekr.20050329082101.4">AutoTrees is itself a plugin. When it starts it,

1. Scans the leo\plugins\trees folder to find handlers
2. Activates specific handlers (this is managed via a plugin manager type window)
3. Waits for clicks and double-clicks on special nodes

To create an AutoTree node, you add a node with @auto-my_handler. The @auto tells the plugin to go and look for the "my_handler" handler, if it is enabled. The handler is then called and this is then used to populate the node body and child nodes below this node.

eg, for an @auto-rss node, the node headline is "@auto-rss http://myurl/news.xml". The handler goes to the URL mentioned and downloads the news stories. It then creates child nodes for each story and populates the bodies. 

The handler doesn't have to worry about interacting with the Leo tree view, it just returns a tree object. 

</t>
<t tx="ekr.20050329082101.5">The best way is to use the existing examples as templates. Look at the "test" handler first as this is the "Hello world" of trees.

</t>
<t tx="ekr.20050329082101.6">@nocolor</t>
<t tx="ekr.20050329082101.7">Just some simple testing nodes</t>
<t tx="ekr.20050329082101.8"></t>
<t tx="ekr.20050329082101.9">this is one</t>
<t tx="ekr.20050329082101.10">this is two !!!</t>
<t tx="ekr.20050329082101.11">this is three</t>
<t tx="ekr.20050329082101.12"></t>
<t tx="ekr.20050329082101.13"></t>
<t tx="ekr.20050329082101.14"></t>
<t tx="ekr.20050329082101.15">Reads a remote news service.

@auto-rss &lt;url to news service&gt;

Requires feedparser installed:
    http://sourceforge.net/projects/feedparser/</t>
<t tx="ekr.20050329082101.16">title

summary_detail</t>
<t tx="ekr.20050329082101.40">title (slash_section, category)

summary_detail

link</t>
<t tx="ekr.20050329082101.51">title (modified)

link</t>
<t tx="ekr.20050329082101.52">Python 2.4.1 (release candhttp://www.python.org/2.4.1/index.htmlate 1) (2005-03-10)

http://www.python.org/2.4.1/index.html</t>
<t tx="ekr.20050329082101.53">Greg Stein, of Google and Apache Software Foundation, to deliver keynote at PyCon (2005-03-06)

http://www.python.org/pycon/2005/keynotes.html</t>
<t tx="ekr.20050329082101.54">New RSS feed for python-dev summaries (2005-02-24)

http://www.python.org/dev/summary/channews.rdf</t>
<t tx="ekr.20050329082101.55">Guhttp://www.sdforum.org/SDForum/Templates/CalendarEvent.aspx?CID=1547&amp;mo=2&amp;yr=2005o van Rossum speaking in Palo Alto (2005-02-17)

http://www.sdforum.org/SDForum/Templates/CalendarEvent.aspx?CID=1547&amp;mo=2&amp;yr=2005</t>
<t tx="ekr.20050329082101.56">Python 2.3.5 (final) (2005-02-08)

http://www.python.org/2.3.5/index.html</t>
<t tx="ekr.20050329082101.57">Security advisory for SimpleXMLRPCServer.py. (2005-02-03)

http://python.org/security/PSF-2005-001/</t>
<t tx="ekr.20050329082101.58">Deadline for OSCON proposals (2005-02-01)

http://mail.python.org/pipermail/python-announce-list/2005-January/003683.html</t>
<t tx="ekr.20050329082101.59">PyCon abstracts now available (2005-01-23)

http://www.python.org/moin/PyConDC2005/Presentations</t>
<t tx="ekr.20050329082101.60">PyCon preliminary schedule now available (2005-01-20)

http://www.python.org/pycon/2005/schedule.html</t>
<t tx="ekr.20050329082101.61">PSF has awarded three grants (2004-12-30)

http://www.python.org/psf/grants/index.html</t>
<t tx="ekr.20050329082101.62">Python for Nokia Series 60 now available (2004-12-23)

http://www.forum.nokia.com/main/0,,034-821,00.html</t>
<t tx="ekr.20050329082101.63">Python 2.4 (final) (2004-11-30)

http://www.python.org/2.4/index.html</t>
<t tx="ekr.20050329082101.64">PyZine issue 7 (2004-11-23)

http://www.pyzine.com/Issue007/</t>
<t tx="ekr.20050329082101.65">PyCon 2005 Call for Proposals (2004-10-23)

http://www.python.org/pycon/2005/cfp.html</t>
<t tx="ekr.20050329082101.66">Cameron Laird receives the Frank Willison Award (2004-10-18)

http://press.oreilly.com/pub/pr/1237</t>
<t tx="ekr.20050329082101.67">Reads a remote file

@auto-remote &lt;url to file&gt;

Requires pyCurl:
    http://pycurl.sourceforge.net/</t>
<t tx="ekr.20050329082101.68">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;BBC - Error 404: Page not found&lt;/title&gt;
&lt;meta name="description" content="Error 404 - page not found" /&gt;
&lt;meta name="keywords" content="" /&gt;
&lt;meta name="created" content="20040506" /&gt;
&lt;meta name="updated" content="20040506" /&gt;
&lt;base href="http://www.bbc.co.uk" /&gt;
&lt;style&gt;
body {margin:0; padding:0;}
em {color:#900;}
p, ul {font-size:80%}
h4,h3,h2,h1,p, ul {font-family: verdana,arial,helvetica,sans-serif;}
h4,h3 {font-size:100%}
h4,h1 {margin:0}
div.main {padding:8px;margin:0px;width:770;}
form {margin:0;padding:0;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body bgcolor="#ffffff" link="#333366" text="#000000" vlink="#333366" alink="#000000" marginheight="0" marginwidth="0"&gt;

&lt;!-- toolbar 1.4 toolbar.page 770 666666 --&gt;&lt;table width="100%" cellpadding="0" cellspacing="0" border="0"&gt;&lt;tr&gt;&lt;td colspan="2" style="background-color:#828282;" &gt;&lt;a name="top"&gt;&lt;img src="/f/t.gif" width="590" height="2" alt="" /&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style="background-color:#828282;"&gt;&lt;img src="/f/t.gif" width="1" height="2" alt="" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;form action="http://www.bbc.co.uk/cgi-bin/search/results.pl"&gt;&lt;tr&gt;&lt;td style="border-left:2px solid #828282;background-color:#999999;" width="54"&gt;&lt;a href="http://www.bbc.co.uk/go/toolbar/-/"&gt;&lt;img src="/images/logo04.gif" width="50" height="20" alt="BBC" border="0" hspace="2" vspace="5" /&gt;&lt;/a&gt;&lt;/td&gt;&lt;td style="background:#999999;" align="right"&gt;&lt;table cellpadding="0" cellspacing="0" border="0" style="float:right;"&gt;&lt;tr&gt;&lt;td style="background:#999999;"&gt;&lt;font size="1"&gt;&lt;b&gt;&lt;a href="http://www.bbc.co.uk/go/toolbar/text/-/" style="color:#ffffff;text-decoration:none;font-family:verdana,arial,helvetica,sans-serif;padding:1px 4px;"&gt;Home&lt;/a&gt;&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;&lt;td style="background:#999999 url(/images/v.gif) repeat-y;" width="6"&gt;&lt;br /&gt;&lt;/td&gt;&lt;td&gt;&lt;font size="1"&gt;&lt;b&gt;&lt;a href="/go/toolbar/-/tv/" style="color:#ffffff;text-decoration:none;font-family:verdana,arial,helvetica,sans-serif;padding:1px 4px;"&gt;TV&lt;/a&gt;&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;&lt;td style="background:#999999 url(/images/v.gif) repeat-y;" width="6"&gt;&lt;br /&gt;&lt;/td&gt;&lt;td&gt;&lt;font size="1"&gt;&lt;b&gt;&lt;a href="/go/toolbar/-/radio/" style="color:#ffffff;text-decoration:none;font-family:verdana,arial,helvetica,sans-serif;padding:1px 4px;"&gt;Radio&lt;/a&gt;&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;&lt;td style="background:#999999 url(/images/v.gif) repeat-y;" width="6"&gt;&lt;br /&gt;&lt;/td&gt;&lt;td&gt;&lt;font size="1"&gt;&lt;b&gt;&lt;a href="/go/toolbar/-/talk/" style="color:#ffffff;text-decoration:none;font-family:verdana,arial,helvetica,sans-serif;padding:1px 4px;"&gt;Talk&lt;/a&gt;&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;&lt;td style="background:#999999 url(/images/v.gif) repeat-y;" width="6"&gt;&lt;br /&gt;&lt;/td&gt;&lt;td&gt;&lt;font size="1"&gt;&lt;b&gt;&lt;a href="/go/toolbar/-/whereilive/" style="color:#ffffff;text-decoration:none;font-family:verdana,arial,helvetica,sans-serif;padding:1px 4px;"&gt;Where&amp;nbsp;I&amp;nbsp;Live&lt;/a&gt;&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;&lt;td style="background:#999999 url(/images/v.gif) repeat-y;" width="6"&gt;&lt;br /&gt;&lt;/td&gt;&lt;td&gt;&lt;nobr&gt;&lt;font size="1"&gt;&lt;b&gt;&lt;a href="/go/toolbar/-/a-z/" style="color:#ffffff;text-decoration:none;font-family:verdana,arial,helvetica,sans-serif;padding:1px 4px;"&gt;A-Z&amp;nbsp;Index&lt;/a&gt;&lt;/b&gt;&lt;/font&gt;&lt;/nobr&gt;&lt;/td&gt;&lt;td style="background:#666666 url(/images/sl3.gif) no-repeat;" width="8"&gt;&lt;br /&gt;&lt;/td&gt;&lt;td style="background:#666666 url(/images/st.gif) repeat-x 0 0;"&gt;&lt;input type="text" id="bbcpageSearchbox" name="q" size="6" style="margin:3px 0 0;font-family:arial,helvetica,sans-serif;width:100px;" title="BBC Search" /&gt;&lt;/td&gt;&lt;td style="background:#666666 url(/images/st.gif) repeat-x;"&gt;&lt;input type="image" src="/images/srchb.gif" name="go" value="go" alt="Search" width="64" height="25" border="0" /&gt;&lt;/td&gt;&lt;td style="background:#999999 url(/images/sra.gif) no-repeat;" width="1"&gt;&lt;img src="/f/t.gif" width="1" height="30" alt="" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;td style="background:#999999 url(/images/srb.gif) no-repeat;"&gt;&lt;img src="/f/t.gif" width="1" height="1" alt="" /&gt;&lt;input type="hidden" name="uri" value="/news.html" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/form&gt;&lt;tr&gt;&lt;td colspan="2" style="background-color:#000000;"&gt;&lt;img src="/f/t.gif" width="770" height="1" alt="" /&gt;&lt;/td&gt;&lt;td width="100%" style="background-color:#000000;"&gt;&lt;img src="/f/t.gif" width="1" height="1" alt="" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;!-- end toolbar 1.4 --&gt;

&lt;table cellspacing="0" cellpadding="8" border="0" width="770" bgcolor="#cccccc"&gt;&lt;tr&gt;&lt;td width="335"&gt;&lt;font size="-2" face="arial,helvetica"&gt;TUESDAY&lt;br /&gt;29th March 2005&lt;br /&gt;&lt;a href="/cgi-bin/education/betsie/parser.pl"&gt;Text only&lt;/a&gt; &lt;/font&gt;&lt;/td&gt;&lt;td width="435"&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;div class="main"&gt;
&lt;div align="center"&gt;
&lt;h2&gt;Page not found&lt;/h2&gt;
&lt;p&gt;Unfortunately the following page was not available:&lt;br /&gt;
&lt;em&gt;http://www.bbc.co.uk/news.html&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;This might be because:&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;You may have typed the web address incorrectly. Please check the address and spelling ensuring that it does &lt;b&gt;not&lt;/b&gt; contain capital letters or spaces&lt;/li&gt;
&lt;li&gt;It is possible that the page you were looking for may have been moved, updated or deleted.&lt;/li&gt;&lt;/ul&gt;

&lt;h3&gt;Please try the following options instead:&lt;/h3&gt;

&lt;form action="/cgi-bin/search/results.pl"&gt;
&lt;table cellpadding="4" cellspacing="2" border="0" align="center" bgcolor="#000000"&gt;
&lt;tr&gt;&lt;td bgcolor="#99ccff"&gt;&lt;h4&gt;Search bbc.co.uk&lt;/h4&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td bgcolor="#ffffcc"&gt;&lt;input type="text" name="q" size="45" /&gt;&amp;nbsp;&lt;input type="submit" value="Go" /&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;

&lt;ul&gt;
&lt;li&gt;Return to the &lt;a href="/"&gt;bbc.co.uk Home Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Use our &lt;a href="/a-z/"&gt;site index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;If you still encounter problems then please try the &lt;a href="/help/"&gt;help&lt;/a&gt; section.&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;!-- inc.footer.page --&gt;&lt;br clear="all" /&gt;&lt;table width="770" cellpadding="0" cellspacing="0" border="0"&gt;&lt;tr&gt;&lt;td width="110"&gt;&lt;img src="/furniture/tiny.gif" alt="" width="110" height="1"&gt;&lt;/td&gt;&lt;td width="10"&gt;&lt;img src="/furniture/tiny.gif" alt="" width="10" height="1"&gt;&lt;/td&gt;&lt;td align="center" width="100%"&gt;&lt;font face="arial, helvetica, sans-serif" size="1"&gt;&lt;a href="/terms/"&gt;Terms of Use&lt;/a&gt; | &lt;a href="/privacy/"&gt;Privacy&lt;/a&gt;&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;!-- end inc.footer.page --&gt;

&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20050329082101.69">Produces documentation for a module

@auto-doc &lt;module name&gt;</t>
<t tx="ekr.20050329082101.70"></t>
<t tx="ekr.20050329082101.71">Base class for Docutils components.</t>
<t tx="ekr.20050329082101.72"></t>
<t tx="ekr.20050329082101.73">tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items

If the argument is a tuple, the return value is the same object.</t>
<t tx="ekr.20050329082101.74">
        Is `format` supported by this component?

        To be used by transforms to ask the dependent component if it supports
        a certain input context or output format.
        </t>
<t tx="ekr.20050329082101.75"></t>
<t tx="ekr.20050329082101.76">No documentation for OPTCRE</t>
<t tx="ekr.20050329082101.77">No documentation for SECTCRE</t>
<t tx="ekr.20050329082101.78">Create a new section in the configuration.

        Raise DuplicateSectionError if a section by the specified name
        already exists.
        </t>
<t tx="ekr.20050329082101.79">tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items

If the argument is a tuple, the return value is the same object.</t>
<t tx="ekr.20050329082101.80">dict() -&gt; new empty dictionary.
dict(mapping) -&gt; new dictionary initialized from a mapping object's
    (key, value) pairs.
dict(seq) -&gt; new dictionary initialized as if via:
    d = {}
    for k, v in seq:
        d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)</t>
<t tx="ekr.20050329082101.81">
    Parser for command-line and library use.  The `settings_spec`
    specification here and in other Docutils components are merged to build
    the set of command-line options and runtime settings for this process.

    Common settings (defined below) and component-specific settings must not
    conflict.  Short options are reserved for common settings, and components
    are restrict to using long options.
    </t>
<t tx="ekr.20050329082101.82">str(object) -&gt; string

Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</t>
<t tx="ekr.20050329082101.83">tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items

If the argument is a tuple, the return value is the same object.</t>
<t tx="ekr.20050329082101.84">dict() -&gt; new empty dictionary.
dict(mapping) -&gt; new dictionary initialized from a mapping object's
    (key, value) pairs.
dict(seq) -&gt; new dictionary initialized as if via:
    d = {}
    for k, v in seq:
        d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)</t>
<t tx="ekr.20050329082101.85">tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items

If the argument is a tuple, the return value is the same object.</t>
<t tx="ekr.20050329082101.86">list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</t>
<t tx="ekr.20050329082101.87">list() -&gt; new list
list(sequence) -&gt; new list initialized from sequence's items</t>
<t tx="ekr.20050329082101.88">dict() -&gt; new empty dictionary.
dict(mapping) -&gt; new dictionary initialized from a mapping object's
    (key, value) pairs.
dict(seq) -&gt; new dictionary initialized as if via:
    d = {}
    for k, v in seq:
        d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)</t>
<t tx="ekr.20050329082101.89">str(object) -&gt; string

Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</t>
<t tx="ekr.20050329082101.90">
    A facade encapsulating the high-level logic of a Docutils system.
    </t>
<t tx="ekr.20050329082101.91">str(object) -&gt; string

Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</t>
<t tx="ekr.20050329082101.92">str(object) -&gt; string

Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</t>
<t tx="ekr.20050329082101.93">
Command-line and common processing for Docutils front-end tools.

Exports the following classes:

- `OptionParser`: Standard Docutils command-line processing.
- `Values`: Runtime settings; objects are simple structs
  (``object.attribute``).
- `ConfigParser`: Standard Docutils config file processing.
</t>
<t tx="ekr.20050329082101.94">
I/O classes provide a uniform API for low-level input and output.  Subclasses
will exist for a variety of input/output mechanisms.
</t>
<t tx="ekr.20050329082101.95">
This package contains Docutils parser modules.
</t>
<t tx="ekr.20050329082101.96">
    Set up &amp; run a `Publisher`.  For command-line front ends.

    Parameters:

    - `reader`: A `docutils.readers.Reader` object.
    - `reader_name`: Name or alias of the Reader class to be instantiated if
      no `reader` supplied.
    - `parser`: A `docutils.parsers.Parser` object.
    - `parser_name`: Name or alias of the Parser class to be instantiated if
      no `parser` supplied.
    - `writer`: A `docutils.writers.Writer` object.
    - `writer_name`: Name or alias of the Writer class to be instantiated if
      no `writer` supplied.
    - `settings`: Runtime settings object.
    - `settings_spec`: Extra settings specification; a `docutils.SettingsSpec`
      subclass.  Used only if no `settings` specified.
    - `settings_overrides`: A dictionary containing program-specific overrides
      of component settings.
    - `enable_exit`: Boolean; enable exit status at end of processing?
    - `argv`: Command-line argument list to use instead of ``sys.argv[1:]``.
    - `usage`: Usage string, output if there's a problem parsing the command
      line.
    - `description`: Program description, output for the "--help" option
      (along with command-line option descriptions).
    </t>
<t tx="ekr.20050329082101.97">
    Set up &amp; run a `Publisher`.  For programmatic use with file-like I/O.

    Parameters:

    - `source`: A file-like object (must have "read" and "close" methods).
    - `source_path`: Path to the input file.  Opened if no `source` supplied.
      If neither `source` nor `source_path` are supplied, `sys.stdin` is used.
    - `destination`: A file-like object (must have "write" and "close"
      methods).
    - `destination_path`: Path to the input file.  Opened if no `destination`
      supplied.  If neither `destination` nor `destination_path` are supplied,
      `sys.stdout` is used.
    - `reader`: A `docutils.readers.Reader` object.
    - `reader_name`: Name or alias of the Reader class to be instantiated if
      no `reader` supplied.
    - `parser`: A `docutils.parsers.Parser` object.
    - `parser_name`: Name or alias of the Parser class to be instantiated if
      no `parser` supplied.
    - `writer`: A `docutils.writers.Writer` object.
    - `writer_name`: Name or alias of the Writer class to be instantiated if
      no `writer` supplied.
    - `settings`: Runtime settings object.
    - `settings_spec`: Extra settings specification; a `docutils.SettingsSpec`
      subclass.  Used only if no `settings` specified.
    - `settings_overrides`: A dictionary containing program-specific overrides
      of component settings.
    - `enable_exit`: Boolean; enable exit status at end of processing?
    </t>
<t tx="ekr.20050329082101.98">
    Set up &amp; run a `Publisher`, and return the string output.
    For programmatic use with string I/O.

    For encoded string output, be sure to set the "output_encoding" setting to
    the desired encoding.  Set it to "unicode" for unencoded Unicode string
    output.  Here's how::

        publish_string(..., settings_overrides={'output_encoding': 'unicode'})

    Similarly for Unicode string input (`source`)::

        publish_string(..., settings_overrides={'input_encoding': 'unicode'})

    Parameters:

    - `source`: An input string; required.  This can be an encoded 8-bit
      string (set the "input_encoding" setting to the correct encoding) or a
      Unicode string (set the "input_encoding" setting to "unicode").
    - `source_path`: Path to the file or object that produced `source`;
      optional.  Only used for diagnostic output.
    - `destination_path`: Path to the file or object which will receive the
      output; optional.  Used for determining relative paths (stylesheets,
      source links, etc.).
    - `reader`: A `docutils.readers.Reader` object.
    - `reader_name`: Name or alias of the Reader class to be instantiated if
      no `reader` supplied.
    - `parser`: A `docutils.parsers.Parser` object.
    - `parser_name`: Name or alias of the Parser class to be instantiated if
      no `parser` supplied.
    - `writer`: A `docutils.writers.Writer` object.
    - `writer_name`: Name or alias of the Writer class to be instantiated if
      no `writer` supplied.
    - `settings`: Runtime settings object.
    - `settings_spec`: Extra settings specification; a `docutils.SettingsSpec`
      subclass.  Used only if no `settings` specified.
    - `settings_overrides`: A dictionary containing program-specific overrides
      of component settings.
    - `enable_exit`: Boolean; enable exit status at end of processing?
    </t>
<t tx="ekr.20050329082101.99">
This package contains Docutils Reader modules.
</t>
<t tx="ekr.20050329082101.100">This module provides access to some objects used or maintained by the
interpreter and to functions that interact strongly with the interpreter.

Dynamic objects:

argv -- command line arguments; argv[0] is the script pathname if known
path -- module search path; path[0] is the script directory, else ''
modules -- dictionary of loaded modules

displayhook -- called to show results in an interactive session
excepthook -- called to handle any uncaught exception other than SystemExit
  To customize printing in an interactive session or to install a custom
  top-level exception handler, assign other functions to replace these.

exitfunc -- if sys.exitfunc exists, this routine is called when Python exits
  Assigning to sys.exitfunc is deprecated; use the atexit module instead.

stdin -- standard input file object; used by raw_input() and input()
stdout -- standard output file object; used by the print statement
stderr -- standard error object; used for error messages
  By assigning other file objects (or objects that behave like files)
  to these, it is possible to redirect all of the interpreter's I/O.

last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception
  These three are only available in an interactive session after a
  traceback has been printed.

exc_type -- type of exception currently being handled
exc_value -- value of exception currently being handled
exc_traceback -- traceback of exception currently being handled
  The function exc_info() should be used instead of these three,
  because it is thread-safe.

Static objects:

maxint -- the largest supported integer (the smallest is -maxint-1)
maxunicode -- the largest supported character
builtin_module_names -- tuple of module names built into this interpreter
version -- the version of this interpreter as a string
version_info -- version information as a tuple
hexversion -- version information encoded as a single integer
copyright -- copyright notice pertaining to this interpreter
platform -- platform identifier
executable -- pathname of this Python interpreter
prefix -- prefix used to find the Python library
exec_prefix -- prefix used to find the machine-specific Python library
dllhandle -- [Windows only] integer handle of the Python DLL
winver -- [Windows only] version number of the Python DLL
__stdin__ -- the original stdin; don't touch!
__stdout__ -- the original stdout; don't touch!
__stderr__ -- the original stderr; don't touch!
__displayhook__ -- the original displayhook; don't touch!
__excepthook__ -- the original excepthook; don't touch!

Functions:

displayhook() -- print an object to the screen, and save it in __builtin__._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- return thread-safe information about the current exception
exc_clear() -- clear the exception state for the current thread
exit() -- exit the interpreter by raising SystemExit
getdlopenflags() -- returns flags to be used for dlopen() calls
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function
</t>
<t tx="ekr.20050329082101.101">
This package contains Docutils Writer modules.
</t>
<t tx="ekr.20050329082101.102"></t>
<t tx="ekr.20050329082101.103">Reads messages from a news server. Only does the last 10 as this is very slow ... it is only meant as an example. 

@auto-news &lt;news server name&gt;/&lt;news group name&gt;

</t>
<t tx="ekr.20050329082101.104">

Given some Python source, is there any tool which can tell the mimimum 
level of Python required to run that source? If I distribute some code, 
I need to be able to say which level of Python users require to run it.

-- 
Steve Toledo-Brown
Speaking for myself only.
Humans please use domain uk.ibm.com</t>
<t tx="ekr.20050329082101.105">

Disclaimer #1: I am a Python newbie, and I appreciate the vast
documentation at python.org -- some of which I expect has the answer to
my question if I can find it.

I am working on a custom computational fluid dynamics code.  I will
create one or more compiled Python modules in C/C++ to provide new
types and functions for manipulating those types.  I have a *lot* of
data.  Efficiency requires that the new data structures be shared
freely within the scope of the module, without directly exposing the
data to the standard Python runtime environment.

Stated another way, I need the data to persist in virtual memory across
seprate invocations of functions in the module(s) and to be accessible
only through methods explicitly provided by the module(s).

How can I do this?  What are some good examples to study?

Disclaimer #2: I am a aware that strong opinions exist about closing
off data from users.  But it's a requirement for this application.  I
don't like it, but I need the job!

Thanks for your time
CatManDo
</t>
<t tx="ekr.20050329082101.106">

Anand S Bisen wrote:
&gt; Hello
&gt; 
&gt; I have been developing a code that works pretty well on my python 2.3 
&gt; and now when i am running it on my server where it is programmed to run 
&gt; it's giving me errors. I have been using __contains__ method and it 
&gt; fails on python 2.2
&gt; 
&gt; For example
&gt; 
&gt; (Python 2.3)
&gt;  &gt;&gt; x="Hello World"
&gt;  &gt;&gt; print x.__contains__("Hello")
&gt; True
&gt; 
&gt; (Python 2.2)
&gt; 
&gt;  &gt;&gt;&gt; x="Hello world"
&gt;  &gt;&gt;&gt; print x.__contains__("Hello")
&gt; 
&gt; Traceback (most recent call last):
&gt;  File "&lt;stdin&gt;", line 1, in ?
&gt; TypeError: 'in &lt;string&gt;' requires character as left operand
&gt; 
&gt; 
&gt; Is there any woraround for this or what am i doing wrong in 2.2 ?
&gt; 
&gt; Thanks
&gt; 
Any use of double-underscores is an indication that magic is at work. In 
this case the __contains__ method is intended to be called by the 
interpreter when you write

     x in s

The __contains__ method was extended for strings in 2.3 so that 
construct could be used as a test to see whether s contained x as a 
substring. Before that, as the error message explains, it will only test 
to see whether a single character is contained in the string (by analogy 
with

     1 in [3, 4, 5, 2]

in case you are interested).

So you'll need to use the .find() string method and say

     if x.find("Hello") != -1:
         ... you found "Hello"

because your ISP appears to be using an older version of Python than you.

regards
  Steve
-- 
Meet the Python developers and your c.l.py favorites March 23-25
Come to PyCon DC 2005                      http://www.pycon.org/
Steve Holden                           http://www.holdenweb.com/</t>
<t tx="ekr.20050329082101.107">


"Zhang Le" &lt;sigu4wa02@sneakemail.com&gt; wrote in message 
news:1109952846.225378.136210@o13g2000cwo.googlegroups.com...
&gt; Hi,
&gt;  I did a small benchmark of matrix-vector multiply operation using
&gt; Numeric module. I'm a bit suprised to find matrix*col-vector is much
&gt; faster than row-vector*matrix. I wonder whether other people have
&gt; observed this fact too,

Yes, common knowledge in numerical analysis community.  Using the faster 
direction for a particular system as much as possible is part of tuning 
linear algebra software.

&gt; and why?

I presume that Numeric, like Python, stores matrices by row.  So M*v 
multiplies contiguous rows by a contiguous vector.  Multiplying a vector by 
non-contiguous columns requires requires skipping thru the matrix, which 
may require more computation and generate more cache misses and page 
faults.

Terry  J. Reedy


</t>
<t tx="ekr.20050329082101.108">

I just read in the 'What's New in Python 2.4' document that the None
data type was converted to a constant:
http://python.org/doc/2.4/whatsnew/node15.html

"""
# None is now a constant; code that binds a new value to the name
"None" is now a syntax error.
"""

So, what's the implications of this?  I find the lack of explanation a
little puzzling, since I've written code that compares a variable's
type with the 'None' type.  For example, a variable would be
initialized to 'None' and if it went through a loop unchanged, I could
determine this at the end by using a conditional type(var) ==
type(None).  What will type(None) return now?
</t>
<t tx="ekr.20050329082101.109">

On Fri, 4 Mar 2005 22:35:48 +0100, andrea_gavana@tin.it
&lt;andrea_gavana@tin.it&gt; wrote:
&gt; Hello NG,
&gt; 
&gt;     I was wondering if there is a way to obtain, from a list of floats,
&gt; a list of integers without loops. Probably is a basic question, but I can't
&gt; find an answer... I have had my eyes blinded by Matlab for years, but now
&gt; that I discovered Python+wxPython there seems to be no limit on what one
&gt; can do with these 2 tools. Anyway, following the Matlab style, I would like
&gt; to do something like this:
&gt; 
&gt; matrix = [1.5, 4.3, 5.5]
&gt; integer_matrix = int(matrix)       (float for Matlab)

You're going to have to use loops. I don't know how Matlab can do it
without them, unless it maintains the matrix as a list of floats and
simply *views* it as a list of ints. More likely, it simply hides the
loop away from you. Anyway, here's some ways to do it:

preferable: int_matrix = [int(x) for x in matrix]
old way: int_matrix = map(int, matrix)
explicit:
int_matrix = []
for x in matrix:
    int_matrix.append(int(x))

Any of these methods should be neither really slow nor really fast,
but the list comprehension should be the fastest (I think). Anyway, if
you're going to be doing lots of large matrices, and want some of your
old matlab stuff, check out numpy and numarray at
http://numeric.scipy.org/ .

Also, somebody was recently posting on here about a python &lt;-&gt; matlab
bridge that they developed; you should search the archives for that
(it was in february, I think).

And, finally, when doing scientific stuff, I found IPython
(http://ipython.scipy.org/) to be an invaluable tool. It's a much
improved Python interpreter.

Peace
Bill Mill
bill.mill at gmail.com

&gt; 
&gt; (In Matlab, "integer_matrix" is always a double anyway, here I would like
&gt; only to show the vector-matrix operation).
&gt; 
&gt; Obviously, Python complains about:
&gt; 
&gt; Traceback (most recent call last):
&gt;   File "&lt;interactive input&gt;", line 1, in ?
&gt; TypeError: int() argument must be a string or a number
&gt; 
&gt; I would like to avoid loops because, having been blinded by Matlab vector-matrix
&gt; abilities (and corresponding SLOW for-while loops operations), I tend to
&gt; think that also Python will be slow if I use loops.
&gt; 
&gt; Does anyone have a suggestion (or maybe could anyone show me that I'm wrong
&gt; about loops?)
&gt; 
&gt; Thanks you a lot.
&gt; 
&gt; Andrea.
&gt; 
&gt; --
&gt; http://mail.python.org/mailman/listinfo/python-list
&gt;</t>
<t tx="ekr.20050329082101.110">news-server.houston.rr.com/comp.lang.python</t>
<t tx="ekr.20050329082101.111">

This was happening to me for a while but stopped. I think it has to do with 
your mail server. Perhaps you could find another. If you are at a company, 
you might want to talk to your sysadmin and see if he can change the mail 
program. How did you get this latest message through? You know, with the 
proper email client you can have identities and such that have "from" and 
"return addresses" that are completely unrelated to the mail server you are 
using, if you would rather the mail list did not know about your most favored 
address.

James

On Friday 04 March 2005 01:56 pm, phil wrote:
&gt; everything I post to this list bounces awaiting moderator
&gt; approval, due to suspicious header.
&gt; COuld someone tell me what's wrong.  I'm on lots of list
&gt; with no problem.

-- 
James Stroud, Ph.D.
UCLA-DOE Institute for Genomics and Proteomics
Box 951570
Los Angeles, CA 90095</t>
<t tx="ekr.20050329082101.112">news-server.houston.rr.com/comp.lang.python</t>
<t tx="ekr.20050329082101.113">news-server.houston.rr.com/comp.lang.python</t>
<t tx="ekr.20050329082101.114"></t>
<t tx="ekr.20050329082101.145"># This file allows you to turn handlers on and off
doc.py
remote.py
rss.py
test.py
news.py

plugin_manager.py</t>
<t tx="ekr.20050329082101.146"></t>
<t tx="ekr.20050329082101.147">&lt;&lt; docstring &gt;&gt;

from autotrees import BaseTreeHandler, TreeNode

__version__ = "0.1"
__plugin_requires__ = ["autotrees"]
__plugin_group__ = "Test"

&lt;&lt; version history &gt;&gt;


# This module contains multiple handlers for testing only
# This isn't recommended since the Manager dialog cannot
# cope with it very well - it assumes a single handler per
# file.

class Test(BaseTreeHandler):
    """A test handler"""
    
    def initFrom(self, parameter):
        """Initialize the tree"""
        self.children = [
            TreeNode("one", "this is one"),
            TreeNode("two", "this is two !!!"),
            TreeNode("three", "this is three",[
                TreeNode("three-one"),
                TreeNode("three-two"),
                TreeNode("three-three"),
            ])
        ]
        
class Test2(BaseTreeHandler):
    """A test2 handler - wont do much!"""
    
class Test3(Test):
    """A test3 handler - much like Test but the nodes don't get deleted"""
    
    def preprocessNode(self):
        """Override the default deleting of child nodes"""
        pass
        
    </t>
<t tx="ekr.20050329082101.148">"""A Test handler.

This defines
    @auto-test = adds some nodes
    @auto-test2 = doesn't do anything
    @auto-test3 = adds nodes but doesn't delete the old ones
     
"""

</t>
<t tx="ekr.20050329082101.149">@

Version history

0.1 Paul Paterson:
    - Initial version</t>
<t tx="ekr.20050329082101.150">&lt;&lt; docstring &gt;&gt;

from autotrees import BaseTreeHandler, TreeNode
import feedparser
import leoGlobals as g

__version__ = "0.1"
__plugin_requires__ = ["feedparser", "autotrees", "plugin_manager"]
__plugin_group__ = "Network"

&lt;&lt; version history &gt;&gt;

class RSS(BaseTreeHandler):
    """RSS auto tree handler"""
        
    def initFrom(self, parameter):
        """Initialize the tree"""
        node_body = self.node.bodyString().strip()
        self.children = []
        #
        g.es("Starting download", color="blue")
        try:
            feed = feedparser.parse(parameter)
        except Exception, err:
            g.es("Failed: %s" % (err,), color="red")
            self.children.append(TreeNode("error", str(err)))
        #
        else:
            g.es("Done!", color="blue")
            for item in feed['items']:
                if not node_body:
                    content = '\n'.join(['%s:\n%s\n' % (name, item[name]) for name in item.keys()])
                else:
                    content = self.replaceAll(node_body, item)
                self.children.append(TreeNode(
                        item.get('title', 'No title1'),
                        content))
        
    def replaceAll(self, text, dct):
        """Replace all suitable looking names in text with their dictionary values"""
        for name in dct.keys():
            item = dct[name]
            if isinstance(item, dict):
                item = item.get('value', item)
            text = text.replace(name, str(item))
        return text
</t>
<t tx="ekr.20050329082101.151">"""A handler that downloads RSS feeds

The parameter in the @auto-rss headline is the URL to load from. The
body of the node contains the keys to display in the created node
bodies.

To begin with, leave the main body empty - this signifies to use *all*
the data in the bodies of the node. You can then use the keys identified
there to select which things you want to see.

Details will appear as "key:" followed by the content. If you want to 
see the keyed value, then put "key" in the body of the @auto-rss node.
Actually the body text is a series of keywords which will be replaced
by their values in the stream, so the formatting is kept too!

Requires feedparser installed:
    http://sourceforge.net/projects/feedparser/
    
"""
</t>
<t tx="ekr.20050329082101.152">@

Version history

0.1 Paul Paterson:
    - Initial version</t>
<t tx="ekr.20050329082101.153">&lt;&lt; docstring &gt;&gt;

from autotrees import BaseTreeHandler, TreeNode
import feedparser
import leoGlobals as g
import nntplib
import sets

__version__ = "0.1"
__plugin_requires__ = ["autotrees"]
__plugin_group__ = "Network"

&lt;&lt; version history &gt;&gt;

@others</t>
<t tx="ekr.20050329082101.154">"""A handler that downloads messages from a news server

The parameter in the @auto-rss headline is the news server followed
by the group name in the form:
    
    @auto-news newserver.myisp.com/comp.lang.python
    
Messages will be downloaded directly as nodes. Doesn't support threading
but message bodies are downloaded lazily, ie only when you click on the
header. This is achieved by using the @auto-newsitem headline. 
    
"""
</t>
<t tx="ekr.20050329082101.155">@

Version history

0.1 Paul Paterson:
    - Initial version</t>
<t tx="ekr.20050329082101.156">class NewsTreeError(Exception):
    """Something went wrong with the tree"""
    
</t>
<t tx="ekr.20050329082101.157">def getConnection(parameter):
    """Return a connection to a news server group"""
    try:
        server, group = parameter.split(r"/")
    except ValueError:
        g.es("Could not decifer server/group from '%s'" % (parameter,), color="red")
        raise NewsTreeError
    #
    try:
        connection = nntplib.NNTP(server)
    except Exception, err:
        g.es("Unable to connect to '%s': %s" % (server, err), color="red")
        raise NewsTreeError
    #
    try:
        resp, count, first, last, name = connection.group(group)
    except Exception, err:
        g.es("Unable to talk to group '%s': %s" % (group, err), color="red")
        raise NewsTreeError
    #
    return (connection, resp, count, first, last, name)</t>
<t tx="ekr.20050329082101.158">class News(BaseTreeHandler):
    """News auto tree handler"""
        
    @others</t>
<t tx="ekr.20050329082101.159">def initFrom(self, parameter):
    """Initialize the tree"""
    self.children = []
    #
    try:
        connection, resp, count, first, last, name = getConnection(parameter)
    except NewsTreeError:
        return
    #
    resp, subs = connection.xhdr('subject', first + '-' + last)
    #
    for item in subs[:10]: # First 10 articles .... just for testing as this is slooooow!
        id, subject = item
        self.children.append(
            TreeNode("@auto-newsitem %s - %s" % (id, subject),
                     parameter
            )
        )
    
    connection.quit()</t>
<t tx="ekr.20050329082101.160">class NewsItem(BaseTreeHandler):
    """Handlers news item bodies"""
    
    handles = sets.Set(["headclick1"])    
    
    @others
</t>
<t tx="ekr.20050329082101.161">def initFrom(self, parameter):
    """Initialize the tree"""
    self.children = []
    #
    # Get the server name which we conveniently left in the body
    body = self.node.bodyString().splitlines()[0]
    try:
        connection, resp, count, first, last, name = getConnection(body)
    except NewsTreeError:
        return
    #
    # Now get the article 
    id = self.node.headString().split(" - ", 1)[0][15:]
    article = connection.body(id)
    self.node.setBodyTextOrPane("\n".join(article[-1]))
    #
    connection.quit()

</t>
<t tx="ekr.20050329082101.162">&lt;&lt; docstring &gt;&gt;

from autotrees import BaseTreeHandler, TreeNode
import pycurl
import StringIO

import leoGlobals as g

__version__ = "0.1"
__plugin_requires__ = ["pycurl", "autotrees", "plugin_manager"]
__plugin_group__ = "Network"

&lt;&lt; version history &gt;&gt;


class Remote(BaseTreeHandler):
    """A handler for remote files"""
        
    def initFrom(self, parameter):
        """Initialize the tree"""
        self.children = []

        content = StringIO.StringIO()
        #
        g.es("Starting download", color="blue")
        connection = pycurl.Curl()
        connection.setopt(pycurl.URL, str(parameter)) # Cannot take unicode!
        connection.setopt(pycurl.WRITEFUNCTION, content.write)
        #
        try:
            connection.perform()
        except Exception, err:
            g.es("Failed: %s" % (err,), color="red")
            self.children.append(TreeNode("error", str(err)))
        #
        else:
            g.es("Done!", color="blue")
            self.node.setBodyTextOrPane(content.getvalue())
        
</t>
<t tx="ekr.20050329082101.163">"""A handler that downloads remote files

The parameter in the @auto-remote headline is the URL to load from. You
can pass username passwords in the URL, eg
    ftp://username:password@mysite.org/myfile.txt

Requires pyCurl:
    http://pycurl.sourceforge.net/
    
"""
</t>
<t tx="ekr.20050329082101.164">@

Version history

0.1 - Paul Paterson:
      Initial version
</t>
<t tx="ekr.20050329082101.165">&lt;&lt; docstring &gt;&gt;

from autotrees import BaseTreeHandler, TreeNode
import inspect
import sets

import leoGlobals as g

__version__ = "0.1"
__plugin_requires__ = ["autotrees"]
__plugin_group__ = "Coding"

&lt;&lt; version history &gt;&gt;


class Doc(BaseTreeHandler):
    """Handler for documentation nodes"""
        
    def initFrom(self, parameter):
        """Initialize the tree"""
        self.children = []
        self.done = sets.Set()
        try:
            module = __import__(parameter)
        except Exception, err:
            g.es("Failed: %s" % (err,), color="red")
        else:
            components = parameter.split('.')
            for comp in components[1:]:
                module = getattr(module, comp)
            self.children.extend(self.getDocsFor(module))
            
    def getDocsFor(self, object):
        """Return a list of child nodes documenting the object"""
        #print object
        children = []
        for name in dir(object):
            item = getattr(object, name)
            if not name.startswith("_") and not id(item) in self.done:
                self.done.add(id(item))
                if inspect.isclass(item):
                    #print "Class", item.__name__
                    grandchildren = self.getDocsFor(item)
                else:
                    #print "item", item
                    grandchildren = []
                children.append(
                    TreeNode(
                        name,
                        getattr(item, "__doc__", "No documentation for %s" % name),
                        grandchildren
                    )
                )
        return children
            
</t>
<t tx="ekr.20050329082101.166">"""A handler that documents a module

The parameter in the @auto-doc headline is the module to document.
    
"""
</t>
<t tx="ekr.20050329082101.167">@

Version history

0.1 - Paul Paterson:
      Initial version
</t>
<t tx="ekr.20050329092553">Hundreds die in Indonesia quake

Hundreds are believed to have died in Indonesia after a strong earthquake which sparked fears of a tsunami.</t>
<t tx="ekr.20050329092553.1">Ousted Kyrgyz preshttp://news.bbc.co.uk/1/hi/world/asia-pacific/4391139.stment defiant

Ousted Kyrgyz leader Askar Akayev says he remains the "sole legitimate preshttp://news.bbc.co.uk/1/hi/world/asia-pacific/4391139.stment" of his country.</t>
<t tx="ekr.20050329092553.2">Hair 'good source of stem cells'

Scientists have found hair follicles are a plentiful source of stem cells, which can become body tissue.</t>
<t tx="ekr.20050329092553.3">Ashdown sacks top Bosnian Croat

The top administrator in Bosnia, Lord Ashdown, sacks the Croat member of Bosnia's joint preshttp://news.bbc.co.uk/1/hi/world/europe/4390635.stmency.</t>
<t tx="ekr.20050329092553.4">Splits paralyse Iraqi parliament

Iraq's parliament reconvenes, but remains deadlocked over the formation of a new government.</t>
<t tx="ekr.20050329092553.5">Mongolians protest for new poll

Activists in Mongolia call for fresh elections, 
in an action apparently inspired by the situation in Kyrgyzstan.</t>
<t tx="ekr.20050329092553.6">Libya's Bulgarian medics appeal

Six medics appeal against the death sentence imposed in Libya for deliberately infecting children with HIV.</t>
<t tx="ekr.20050329092553.7">Schiavo rivals 'agree to autopsy'

Terri Schiavo's husband and parents seek to discover the extent of her brain-damage after her death.</t>
<t tx="ekr.20050329092553.8">Would-be sex tourist, 87, jailed

An octogenarian US man is jailed for 20 years for trying to travel to the Philippines for sex with young girls.</t>
<t tx="ekr.20050329092553.9">Golf: Funk claims Players title

Fred Funk's final-round 70 gives him victory in the lucrative Players Championship at Sawgrass.</t>
<t tx="ekr.20050329092553.10">Cricket: Series win for Aussies

Australia beat New Zealand by nine wickets in the third Test to wrap up a 2-0 series win.</t>
<t tx="ekr.20050329092553.11">Angola says virus 'under control'

Angola says an outbreak of the deadly Marburg virus is under control as DR Congo takes precautions.</t>
<t tx="ekr.20050329092553.12">Mugabe criticises MDC 'traitors'

Preshttp://news.bbc.co.uk/1/hi/world/africa/4391087.stment Mugabe condemns opposition supporters as traitors, as parliamentary elections draw near.</t>
<t tx="ekr.20050329092553.13">Ex-US diplomats round on Bolton

Dozens of former US diplomats urge Congress to block the appointment of John Bolton as UN ambassador.</t>
<t tx="ekr.20050329092553.14">Brazil quits loan accord with IMF

Brazil announces it will not renew a $41.75bn loan accord with the International Monetary Fund.</t>
<t tx="ekr.20050329092553.15">Japanese economy hit by weak data

An unexpected rise in Japan's jobless rate and falls in household spending and retail sales hit Japanese stocks.</t>
<t tx="ekr.20050329092553.16">Donors pledge $40m for KR trials

A UN-supported Khmer Rouge tribunal, due to try Cambodia's rulers from the 1970s, could open soon.</t>
<t tx="ekr.20050329092553.17">Three Romanians missing in Iraq

Three Romanian journalists are missing, feared khttp://news.bbc.co.uk/1/hi/world/middle_east/4389391.stmnapped, in Iraq after one called on a mobile.</t>
<t tx="ekr.20050329092553.18">Wolfowitz 'to meet EU officials'

Paul Wolfowitz, the US's controversial nomination to head the World Bank, is expected to meet with EU officials on Wednesday, reports say.</t>
<t tx="ekr.20050329092553.19">Knesset rejects Gaza referendum

Israel's parliament rejects an attempt by opponents of the planned Gaza pullout to force a referendum.</t>
<t tx="ekr.20050329092553.20">Militants to attend PLO meeting

Islamic Jihad is to sit in on a meeting of the top Palestinian decision-making body for the first time.</t>
<t tx="ekr.20050329092553.21">South Asia cancels tsunami alerts

India and Sri Lanka withdraw the tsunami alerts issued after an earthquake hit the coast of Indonesia.</t>
<t tx="ekr.20050329092553.22">Devastation as Afghan dam bursts

A dam has burst in south-eastern Afghanistan killing at least six people and causing whttp://news.bbc.co.uk/1/hi/world/south_asia/4391251.stmespread devastation, officials say.</t>
<t tx="ekr.20050329092553.23">Kyrgyzstan's friendly revolution

The BBC's Ian MacWilliam reports from Kyrgyzstan on an unusual people's revolution.</t>
<t tx="ekr.20050329092553.24">Followup on MS and Brazil in NY Times (mainpage, microsoft)

putko was one of dozens to submit a story running on the NY Times about Open Source and Brazil. The choice quote is "We're not going to spend taxpayers' money on a program so that Microsoft can further consolhttp://slashdot.org/article.pl?sid=05/03/29/1359253&amp;from=rssate its monopoly..."

http://slashdot.org/article.pl?shttp://slashdot.org/article.pl?sid=05/03/29/1359253&amp;from=rss=05/03/29/1359253&amp;from=rss</t>
<t tx="ekr.20050329092553.25">A9.com with Syndicated Search (mainpage, internet)

joeykiller writes "Search Engine Watch reports that Amazon now lets you add your own search to their A9 search engine. Users can opt-in to use additional search engines in addition to A9.com's own when searching. Amazon has chosen to use an extension of RSS 2.0 for this, and hopes that this format will enable search syndication in the same way RSS dhttp://slashdot.org/article.pl?sid=05/03/29/1337250&amp;from=rss for content. Several add-on searches are available already, among them New York Times, Wikipedia and NASA."

http://slashdot.org/article.pl?shttp://slashdot.org/article.pl?sid=05/03/29/1337250&amp;from=rss=05/03/29/1337250&amp;from=rss</t>
<t tx="ekr.20050329092553.26">What's Next At Apple (apple, apple)

pinqkandi writes "Business 2.0 is running a fascinating article on what might be coming up in Apple's future. Beshttp://apple.slashdot.org/article.pl?sid=05/03/29/132202&amp;from=rsses speculation, some interesting statistics are included, such as how the iPod should create equal revenue to the Mac for Apple in 2006, if not surpassing it. A good read for the Apple lover or loather."

http://apple.slashdot.org/article.pl?shttp://apple.slashdot.org/article.pl?sid=05/03/29/132202&amp;from=rss=05/03/29/132202&amp;from=rss</t>
<t tx="ekr.20050329092553.27">Berkeley Grads' Identity Data Stolen (yro, privacy)

yali writes "Dhttp://yro.slashdot.org/article.pl?sid=05/03/29/036237&amp;from=rss you get a graduate degree from Berkeley? Or maybe you just applied but dhttp://yro.slashdot.org/article.pl?sid=05/03/29/036237&amp;from=rssn't go there? If so, your http://yro.slashdot.org/article.pl?sid=05/03/29/036237&amp;from=rssentity may have been stolen. A laptop was stolen containing names, social security numbers, birthdates, and addresses of grad students, alumni, and applicants. University police suspect that the thief just wanted the laptop, but the irony of California's mandatory notification law is that the thief may now know they have something even more valuable. Berkeley has set up a website with information on the breach."

http://yro.slashdot.org/article.pl?shttp://yro.slashdot.org/article.pl?sid=05/03/29/036237&amp;from=rss=05/03/29/036237&amp;from=rss</t>
<t tx="ekr.20050329092553.28">South Korean Gov't. Advocates Linux (linux, linuxbiz)

Anonymous Coward writes "Korea has now taken the plunge on the Linux operating system, and is now starting to advocate Linux for use in government and public sector applications. South Korea's Ministry of Information and Communications announced the move today, which will result in decreased Microsoft market share in the region." According to the article, Korea's Ministry of Information and Communication "will provhttp://linux.slashdot.org/article.pl?sid=05/03/29/0322248&amp;from=rsse a total of 3 billion won (US$2.95 million) for government agencies which want to use the Linux and other open-source computer programs this year."

http://linux.slashdot.org/article.pl?shttp://linux.slashdot.org/article.pl?sid=05/03/29/0322248&amp;from=rss=05/03/29/0322248&amp;from=rss</t>
<t tx="ekr.20050329092553.29">MS, EU Agree on Name for Windows Sans Media Player (mainpage, windows)

An anonymous reader writes "Microsoft has agreed with European Union antitrust regulators on a new name for Windows software sold in Europe. Officials at the U.S. software giant sahttp://slashdot.org/article.pl?sid=05/03/28/1951251&amp;from=rss they had accepted the European Union's offer to call the European version of Windows sold without Media Player "Windows XP Home Edition N" - with "N" standing for "not with media player." Microsoft's "XP Professional Edition" will also include the "N" for versions sold without the media player. The prior nme for the OS was Windows XP Reduced Media Edition." News.com also mentions the choice.

http://slashdot.org/article.pl?shttp://slashdot.org/article.pl?sid=05/03/28/1951251&amp;from=rss=05/03/28/1951251&amp;from=rss</t>
<t tx="ekr.20050329092553.30">Blackbox (Finally) Updated (mainpage, gui)

mpeg4codec writes "OSNews reported earlier this month that the lightweight Blackbox window manager has been updated to 0.70. Among the new features are EWMH compliance, anti-aliased fonts, unicode support, and backwards compatibility with previous versions' styles. Of course, it brings you all these new features (well, some are optional) while retaining its small binary size, small memory footprint, and short list of dependencies. I for one think it's about time."

http://slashdot.org/article.pl?shttp://slashdot.org/article.pl?sid=05/03/29/0253245&amp;from=rss=05/03/29/0253245&amp;from=rss</t>
<t tx="ekr.20050329092553.31">Your Face On the Big Screen (mainpage, ent)

blamanj writes "In another case of SciFi becoming reality, you can now star in an animated film as your FutureCast (tm) face-scan is edited into the picture in real-time. John Brunner, in his Hugo-winning novel, Stand on Zanzibar predicted a similar development in television, lampooning people sitting at home while watching travologues of themselves 'on vacation.' Brunner, in addition to being an excellent writer, had some spot-on predictions of a virus-laden Internet in Shockwave Rhttp://slashdot.org/article.pl?sid=05/03/29/0123247&amp;from=rsser. Fortunately, the predictions of his eco-dystopia The Sheep Look Up have not come to pass. Yet."

http://slashdot.org/article.pl?shttp://slashdot.org/article.pl?sid=05/03/29/0123247&amp;from=rss=05/03/29/0123247&amp;from=rss</t>
<t tx="ekr.20050329092553.32">Ars Technica Builds Make Magazine's Steadicam (hardware, hardhack)

An anonymous reader writes "Make magazine has been out for a little over a month now and was given high marks in a Slashdot review. Ars Technica has taken their review one step further by building the $14 steadicam project and testing it out. (be sure to check out the QuickTime vhttp://hardware.slashdot.org/article.pl?sid=05/03/29/0056206&amp;from=rsseo at the end to see their results...)"

http://hardware.slashdot.org/article.pl?shttp://hardware.slashdot.org/article.pl?sid=05/03/29/0056206&amp;from=rss=05/03/29/0056206&amp;from=rss</t>
<t tx="ekr.20050329092553.33">New Photovoltaics Made with Titanium Foil (science, tech)

Memorize writes "A company called Daystartech has released a new type of photovoltaic cell which, unlike almost all the cells currently in use, does not silicon. This is based on a thin titanium film. Given the current shortage of solar-grade silicon, and all-time high oil prices, maybe titanium solar panels are here at the right time. The questions are, will they release it as a consumer solar product, and what will be the price per kilowatt hour?"

http://science.slashdot.org/article.pl?shttp://science.slashdot.org/article.pl?sid=05/03/28/2320211&amp;from=rss=05/03/28/2320211&amp;from=rss</t>
<t tx="ekr.20050402080206">@

This is LeoN-0.0.1 as created by Rodrigo Benenson, very slightly reorganized form.

An important project for Leo's long-term development.

See leo/doc/LeoN for important research papers that form the basis of this project.</t>
<t tx="ekr.20050402080206.1">@killcolor

Read the docustrings in the code.

Run the code LeoN.py to test it. 

You need to read sun98acheiving.pdf to understand what is all this stuff about.  This and other .pdf files are now in the leo/doc/LeoN folder.

Rodrigo Benenson. 2003. LeoN project. &lt;rodrigob@elo.utfsm.cl&gt;</t>
<t tx="ekr.20050402080206.2">@language plain

LeoN is Leo over the Network.

LeoN is Collaborative Leo.

Leo is http://leo.sf.net

@language plain

Leo over network requirements
-----------------------------

This is my rsum of the Requirements and design issues for Leo over the Network. (LeoN).

First in sake of simplicity a N-clients/One server architecture is imposed, being much more easy to design and implement.
Also it's required that the code could be as most Plugin as possible and as most python Modules independent as possible (one and only one instalation required).

Now, the list presented approximately in the logic order of implementation:

&lt;Step one, Merging&gt;

&lt;Step two, Publishing&gt;

&lt;Step three, Interacting by turns&gt;

&lt;&lt;Step four, Realtime interaction&gt;&gt;

Please comment this document.

RodrigoB. </t>
<t tx="ekr.20050402080206.3">Step four, "Realtime interaction":
- There should be a way that multiple online users edit on realtime the same Node.
This is the final step and is truly difficult. Probably this code should be merged from a parallel (but related) project.
(Guy X,Y,Z having a code party.)

- The client should show the editors cursors and edition on realtime.
Adquire the status, of Hydra Open Source, Multiplatform, Clone.
(Guy X,Y,Z enjoying the code party.)

Some features were intentionally omited:
- Versioning system. (there exists better solutions)
- Voice chat. (there exists parallel solutions)


</t>
<t tx="ekr.20050402080206.4">The realtime edition  could be implemented initially on a lock/unlock fashion automatized on a per line basis, very much like an online CVS editor...

The complications should be left to a parallel project, or maybe to another community (search, propose and merge/translate)

@nocolor</t>
<t tx="ekr.20050402080206.5">29/06/03

Hi!

It's time to news again. This last weeks were my final exams weeks but LeoN devellopment is going on as planned.

The last two weeks where focused on the Gui control, intercepting the whole list of actions that the user can do into the collaborative outline. There still some importants events to manage, but I think almost the base code is there. As mentioned this stage is absolutelly non trivial nor little; and is characterised to be some how frustating ("Tk marks are before or bellow a charater? Event occurs before or after effects?", and similars) and slow (because you have to test by hand the gui to debug it). The important elements missing will be done at the time it becomes strictly necessary.


The LeoN code is already pretty big and relativelly complex (3500 raw lines count) and there is a big list of things to do. Anyway no one said it would be easy.
Somes days ago I drafted the code base for Step4, hopefully the more important piece of code, due of it reusability and because I think it will give to LeoN an important sparky effect (near realtime multiuser text edition).


So now the actual plan is:
- Focus the next two weeks on the implementation of Step4 and his unit tests.
- Release the Step4 code. (because it is usefull without Leo and could be used in parallel projects)
- Integrate Step4 and Step(2,3) (one week)
- Move the code over Leo 3.1x  and Twisted 1.0.6 (which unfortunelly changed some classes used in LeoN (cred module)) (horizont: one week)
- After that I will focus strictly on finishing the usability elements and (if everything go fine) will start the releases iterations. This stage will have at least the following milestones:
	- Finish and debug the interface hooks (this can be long...)
	- Implement server persistence (should be easy)
	- Implement the admin interface (should be boring)
	- Implement Clones (two weeks if things go fine)
	- Improve the LeoN web views (implement more than one view  model?)
	- Allow as easy as possible instalations

Of course the releases will be all alpha during a probably long period until the devellopers are happy and then we will switch to beta and when everyone will be happy : the first stable Release !

I'm pretty impacient to finish the vapourware status of LeoN, we have the luck that the timing are acceptable, and Leo has some importants things to do before LeoN will become the first priority. This will give me the time to work on the mentioned plan.

RodrigoB.</t>
<t tx="ekr.20050402080206.6">As said, it is times to news. Briefly.

about step4
-----------

The code is ready and running since wednesday (mercredi) on the morning, but until now I'm  grumbling-grumbling with the code to get it working as supposed; I have found some minor bugs and solved some conceptuals problems and bugs. Debugging code of someelse algorithm is notoriously harder than working on your own ideas but the work give his fruits and each day we are one step nearer to us dreams.
Most of the hard problems are due to some ambiguities or not so clear ideas in the papers, so I have to crunch my brain to guess the correct way to manage the presented abstractions (or apply a 'guess, try, evaluate' strategy).

Due to this problems, and after five days of debugging work I will delay the code release until I get the unit test passed, this should not take more than a week more (I hope so, but you never know if the actual bug is or not the last one).


what is next
------------

- Finish debug of step4
- Implement and test the one server various clients collaborative editing (a special case of the above class)
- move codebase to 3.12b* and twisted 1.0.6
- merge step2, step3, step4 
- start the release of the code snapshots.
- start working on last frozen elements and on the Todo List:
	- hooks installations and debug (starting by node renaming)
	- admin interface
	- server side persistence 
	- clone support
	- cut and paste (with download interface)
	- better web server views
	- design a web plugin system ?
	- debugging, debugging
	- as easy as possible instalations
	- work on the design of LeoN2 features

I will stay working on a two weeks devellopment cycles, and post news at the end of each cycle.


RodrigoB.</t>
<t tx="ekr.20050402080206.7">@nocolor

25/06/03 Copying of the main algorithms into the code. RodrigoB.
01/07/03 Programming. RodrigoB.
02/07/03 Programming. RodrigoB.
05/07/03 Reading about the garbage collector stuff. RodrigoB.
07/07/03 Programming. RodrigoB.
08/07/03 Programming, operations herit from dict, support splitted ops, working on tests, syntax debugging. RodrigoB.
09/07/03 Implementing operations relations, starting debug iterations based on unittests.
		 Added another parameters form for receive_operation. RodrigoB.
10/07/03 Debugging conceptual aspects; management of timestamps on transformed operations. minor bugs fixed. Splitted special cases appears.RodrigoB.
12/07/03 Searching bugs. bugfixes. RodrigoB.
13/07/03 Implementing the garbage collector. Searching bugs. bugfixes. Testing garbage collector. RA problems. RodrigoB.
14/07/03 (vive la France!) Testing an idea (__eq__). Little edit to the root docustring. RodrigoB.
15/07/03 Hunting the Last Bug. Eureka. First successful execution. Code cleanup. Using unittest module. Release 1. RodrigoB.

Todo

- Find a good TestConcurrentEditable2 to test LostInformation cases

- LI is absolutelly not verified
- Find the Recover_LI specifications.
- Find a better way to quit the ambiguities on the 'if else {}' operation pertenence. (save_RA, save_LI conditions ?)

- collect garbage do not work anymore exactly like in the example. (is this a problem ?)

- Implement ConcurrentEditableServer
- Implement the  client-server tests

- Debug.

@color
@language python

</t>
<t tx="ekr.20050421093045">@
You may download the latest version at: http://rclick.netfirms.com/dyna_menu.py.html

several plugins of the dyna variety and support files
newer than the version included in Leo4.3 alpha 4, March 15, 2005
exS all but retired, newer dynaclick not ready for distribution.
look in version history for a few minor changes to bring
dyna_menu up to Leo4.3 code. and some cosmetic changes
for htmlize and du_test and their config and a few option flippers.

had to move a few macros to get under my host single filesize limit.
look them up in older versions of dyna menu. pychecker2, leoglobals, etc.

executeScript on this node to insert your plugin path
if it looks ok remove the #comment
@c

&lt;&lt; modifications by EKR from 139i &gt;&gt;

&lt;&lt; insertAplug &gt;&gt;
insertAplug(c)

@language python
@color
@tabwidth -4</t>
<t tx="ekr.20050421093045.1">def insertAplug (c,wch='i'): #i/r
    """use to insertAt 1.0 #@path plugindir
    """
    import leoGlobals as g
    import os, sys

    k = g.os_path_split(g.app.loadDir) [0]
    #this should fix the slashes and lower cases' it on win9x
    path = g.os_path_normpath(g.os_path_abspath(g.os_path_join(k,"plugins")))

    if not g.os_path_isdir(path):
        print 'give up', path ; raise NameError

    if 'i' in wch:
        Tx = c.frame.body
        Tx.setInsertionPoint(1.0)
        Tx.insertAtInsertPoint('#@path %s\n' % (path,))
        Tx.onBodyChanged("Typing")
</t>
<t tx="ekr.20050421093045.2">#be sure and add dyna_menu.py to pluginsManager.txt
#you don't need to enable dynacommon.py in pluginsManager.txt
#you do need dynacommon.py in the plugins directory 
# 

&lt;&lt; doc &gt;&gt;
__version__ = '0.0139i' #u05417a10:51
__plugin_requires__ = ["dynacommon"]
__plugin_files__ = ["dyna_menu.ini", "dynacommon.py", "dyna.txt"]
#__plugin_group__ = "ex"
 
#__plugin_optional__ = 'pyparsing csv pydot graphviz textwrap silviecity source-highlight docutils pylint pychecker pyrex mingw astyle elementtree'.split()

&lt;&lt; initilize &gt;&gt;
&lt;&lt; version history &gt;&gt;
dynaMvar = None
menudefault =-4  #help4, linenumber5
@others

#makeup an alias for importing and for keybindings
#import dyna_menu; print dir(dyna_menu)
#would be slicker if could use alais inside macros but they aren't defined yet
htmlize = dynaZ_htmlize
dtef = dynaB_Clip_dtef
dupe = dynaM_dupe
DQ3 = dynax_DQ3
helps = dynaB_help

#you can use a macro in other ways
def timestamp(tag, keywords):
    """stolen from the timestamp plugin
    chged hook from command1 to save1
    how to hook write @file so can timestamp that?
    
    add nag you if changed and not saved over 5 minutes
    add nag if typing after sunset over 3 hours, yea right~
    """
    cmd = keywords.get('label', 'save')

    if cmd.startswith("save") or cmd.startswith("tangle"):
        c = keywords.get('c')
        if c:
            dynaB_Clip_dtef(c, ret= 'p')  #just print
            g.es('at node:' + (c.currentVnode().headString().strip())[:128])


</t>
<t tx="ekr.20050421093045.3">"""this plugin creates a dyna menu of macro items.
 Alt+y the dyna menu accelerator key.   
 every time you save the leo one of the macros prints a timestamp.
 macros perform any actions you could have with execute script,
 with the added bonus, they work on the selected text or body text.
 they work as well from the dynatester node or dynabutton, insuring
 when they are included in the plugin, minimal time is lost debugging.
see dyna_menu.ini for options you can set, even while Leo is running.
and edit the paths in dynacommon.py to suit your system.
as time goes by, this part will become smarter and require less editing.

 add exS may re-install exS button on the toolbar.
 set doc and hit DQ3 with nothing selected to see docstring of all macros.
 toggle print/paste/doc on the menu. 
 you click on print, paste or doc to enable that action.
 the action refers to the output of the macro in most cases.
 open another leo resets back to print 
 because all dyna share an instance.

 most output actions are to the log,
 or using print redirected to log if you set that in config.
 'print' gets redirected to console if the macro is in the plugin.
 you have to change the macro accordingly from print x to g.es(x) 
 
some macros do need some non standard modules,
will fallback to standard modules if possible.
some are available from python cvs 
or from later python versions.
the only way to know is to try them or read the code.

do post a bug report or feature request
on my comment page from:
 http://rclick.netfirms.com/rCpython.htm
or sourceforge forum:
&lt;http://sourceforge.net/forum/forum.php?thread_id=1255533&amp;forum_id=10226&gt;

expect constant maintance and additions

"""</t>
<t tx="ekr.20050421093045.4">from __future__ import generators  # + enumerate for less than py2.3
@
from future has to be first...
but to check py version you have to import sys
isn't that some kind of catch 22?
@c
import sys

import leoGlobals as g
Tk   = g.importExtension('Tkinter',pluginName=__name__,verbose=True)

#at this point in Leo, code from plugins isn't importable. later it is.
#replace w/importfromfile
#or patch leo to add plugindir sooner rather than later...

k = g.os_path_split(g.app.loadDir)[0]
#this should fix the slashes and lower cases' it on win9x
k = g.os_path_normpath(g.os_path_abspath(g.os_path_join(k, "plugins")))

#path being unicode can affect less than py2.3
if sys.version_info[:2] &lt; (2, 3):
    k = str(k)

#might not be found in sys path on win9x, there is no unicode paths
if k not in sys.path:
    sys.path.append(k)
del k

#should this even be imported if batch mode or no Tk?
try: 
    #import dynacommon as dynacom
    from dynacommon import *
    dynacom = True
except ImportError: 
    dynacom = None
    #no gui maybe print better here? should guard the error too?
    g.es('you have to copy dynacommon.py to plugins')

"""
 to disable the timestamp thing, comment out this line below:
   ...registerHandler("save1", timestamp) 

for refrence, dynabutton and exS were other plugins from the URL below.

with the dyna plugin loaded you can do things in your scripts like:
    
import sys
#theres probably an easier way than this.
sys.modules['dyna_menu'].dynaM_Clip_dtef(0, 'p')

#another way
import dyna_menu
#print help(dyna_menu)
#print dir(dyna_menu)  #dynaM_
print dyna_menu.dynaHexdump('testing 123')


lightly tested with py2.2 or Leo4.3a3,4+ from cvs
tested Python 2.3, 2.4.1 win9x

should not be a problem anywhere else.
but don't quote me on that. make a bug report.

"""</t>
<t tx="ekr.20050421093045.5">@
0.0138 few changes since forum post

0.0139 e
  - updates re Leo4.3 normpath and c for a few dialogs
  - some config options for htmlize and du_test
  - htmlize
   - code folding: still in process
   - improvements suggested by EKR &amp; Bill P. not fully implimented
      change fonts to css as an option  no
      add a plain or RST output option  no
      hey I could use that myself quite  bit!
      did add option to stripnodesents, and stripdirectives &amp; stripcomments now works
 - use subprocess if available when calling external pychecker &amp; pylint
 - made justPychecker an option not to print source after checking
  - if you dont want to run pylint you have to edit the source.
  - pylint is more configurable and doesn't fail on import errors now
  - highly recomended. see dyna.txt for rc file and URLs'
  - added a few more flippers from the plugin_menu
    - for Leodebug, justPychecker and verbosity for @test and doctest
  - added back a macro uses dynaplay to comment out a python selected text
    many people asked for this, should get comment for whatever language is active.
    Leo can do this natively now but dyna can also put arbitrary text if you like.
  - cmd_flip_onoff_c_gotoline
  - htmlze
    -   switch on plain or rst, force @others and send to for docutils
       and there if there are subnodes of @language preprocess them
       somehow and this gets recursive and complicated...
    -  option on hilighter or silvercity for the remaining languages
  + fix evaluator to select between Leo perttyprint, evaluator and astyle?
  + just add call to astyle for now for c &amp; java output to htmlize or log

  work code in runcmd for commands that accept stdin
  for source-highlight and astyle means no tempfile.

-a,b,d leapahead to fix htmlize for plain and @rst as simple as possible
e special bug fix release
f this version history skips around a little from b and beyond.
 did some cleanup in various fixbody calls, consolidated selectbody
 not calls getScript and optionally stripSentinals
 or comment them if in selected text as for disa.
 playback broke somehow
g - make htmlize callable for display of report from pylint
  - after astyle now too so can see output syntax highlighted.
h - subprocess.startupinfo from cookbook solves no dos window flash!
  - still renames the console if its open on windows.
  - renamed unittest testcase to g.tester instead of g.app._t
  - added actions lower, upper etc reworked DQ3 and slashes too
  began help to eventually parse python w/o import as pydoc does
  pydoc fallback if not epydoc or docutils sandbox available
i - began parser and reverser which isn't going terribly well.
j - fixup pydent so it works in other @language and change the name


 adding more tests, still a few that fail in DQ3 and htmlize
 testing slightly different in py2.2 and 2.4 as well

still todo
remove more bare Exception.
bribe someone to test it on mac and nix and give some feedback.

</t>
<t tx="ekr.20050421093045.6">@

in theses macro nodes, copy or clone the macros
you want to appear in dynamenu

dynaM_ or dynaS_ for macro and system macro
arbitrary to segment into cascading menus at build time
see load_menu, dont use beyond Z as a macroname dynaZ_whatever
change the letter to change the order the macros are created
change the name of the macro to change the alphabetical order.

not alot of error checking is done
each macro must have the same name prefix, dyna*_
and either take *a or c as argument
dynaM_DQ3(c)  they appear in the menu in sorted order


for other less used macros,
use the dynabutton or the scriptButton

some of these are calling function further in the file
that only works becase all parsing is done before calling


need new macro indexer of selected text or body
simple words contained and count place found

need to catagorize them all for print/paste
and also which are to Log always and only
or print and if redirect enabled will be to log
and what about a file toggle would output to file? or to clipboard
so can tag them in the in the menu as using print/paste.

many don't care which,
two are destructive no undo and there is a popup first.

some are action orientated.</t>
<t tx="ekr.20050421093045.7"></t>
<t tx="ekr.20050421093045.8">def dynaB_Clip_dtef(c, ret= 'cp'):
    """(c, ret= 'cp') clip, print, return
    ret='cpr' decide if to add to clipboard, print or return 
    time text 
    
    """
    try:
        if g.app.dynaMvar.bugimport: raise ImportError
        #custom datetime format
        import binaryfun as bf
        dt = bf.dtef()
    except ImportError:
        if c:
            #what Leo has for time in body
            dt = c.getTime(body=True)
        else:
            import time
            Leoconfigformat = '%m/%d/%Y %H:%M.%S'
            dt = time.strftime(Leoconfigformat) 

    if 'p' in ret: g.es('%s%s '%(EOLN, dt,) )
    if 'c' in ret: g.app.gui.replaceClipboardWith(dt)
    #ret = r necessary, if dont specify it clips &amp; prints by default
    if 'r' in ret: return dt  
</t>
<t tx="ekr.20050421093045.9">def dynaB_help(c):
    """(c)
    call epydoc or pydoc on selected text display in webbrowser.
    pydoc simple output doesn't have links to additional levels.

    pydoc code posted awhile ago on Leo forums
    trees plugin has something similar which creates subnodes
    of the help but that is not too easy to navigate.
    please suggest options for @language other than python.
  ~EOT
    this mirrors the dev rClick action of the same name
    eventually will be one code for both or neither. maybe clone them?
    need to get a master redirect to avoid this code duplication

    doesn't trigger PMW popup like in rClick 
    pydoc can takes quite awhile to produce output
    eventually replace w/twisted happydoc or docutils sandbox code for python
    and maybe call doxegen or something else for other @language
    possibly a local indexer? and/or an 'I feel lucky' from google or yahoo
    """
    newSel = dynaput(c, [])
    if not newSel: return

    try:
        #works ok w/o this as well. but likely help is in ascii
        newSel = g.toEncodedString(newSel, "ascii", reportErrors= True)
    except Exception:
        pass

    #might make sense to distinguish simple from help on a module

    try:
        #import happydoclib  #Assignment to None error in py2.4
        import epydoc
        happydoc = True
    except ImportError:
        happydoc = None

    #double layer of redirection seems necessary
    g.redirectStdout(); g.redirectStderr()
    &lt;&lt; stdredirect n&gt;&gt;
    &lt;&lt; happydoc &gt;&gt;
            
    if happydoc is None:  #or module not found
        import pydoc
        #there may be better ways to call this to get other than text
        #which would have links to sub modules
        #BTW, this prints anyway somehow if not redirected well
        H = pydoc.Helper(input= None, output= sys.stdout )
        H.help(str(newSel))

    &lt;&lt; stdredirect f&gt;&gt;
    #redirect is now screwed untill return
    g.restoreStdout(); g.restoreStderr()

    if oo.strip()[:9] == 'no Python' or oo.strip()[:5] == 'Sorry':
        g.es(oo + oe)
    else:
        htmlize(c, (oo + oe), 'report') </t>
<t tx="ekr.20050421093045.10">sys.stdout = g.fileLikeObject() #'cato'
sys.stderr = g.fileLikeObject() #'cate'

#usually you dont want to do this,
_sosav = sys.__stdout__
sys.__stdout__ = sys.stdout
_sesav = sys.__stderr__
sys.__stderr__ = sys.stderr
</t>
<t tx="ekr.20050421093045.11">#actually epydoc which imports, docutils will work soon?
#and it might require its own css?
#another hopelessly unscriptable app

if happydoc: 
    from epydoc.html import HTMLFormatter
    from epydoc.objdoc import DocMap, report_param_mismatches
    from epydoc.imports import import_module, find_modules
    from epydoc.objdoc import set_default_docformat

    err = None
    try: import_module(newSel)
    except ImportError, err:
        happydoc = None

    if not err: 
        options = {}
        g.es('using epydoc')
        set_default_docformat( 'plaintext')
        htmldoc = HTMLFormatter(d, **options)
        print htmldoc</t>
<t tx="ekr.20050421093045.12">oo = sys.stdout.get()  #read get()
oe = sys.stderr.get()  #get()
sys.stdout.close()
sys.stderr.close()

#if you didnt do this it wouldent need to be reversed
sys.__stdout__ = _sosav
sys.__stderr__ = _sesav

sys.stdout = sys.__stdout__
sys.stderr = sys.__stderr__

</t>
<t tx="ekr.20050421093045.13">def dynaB_Graphviznode(c):
    """(c= None) create jpg popup associated viewer
    take the EKR Graphviz pydot demo
    see the 4.2+ test.leo for the origional and other info
    http://www.dkbza.org/pydot.html
    http://www.research.att.com/sw/tools/graphviz/download.html
    pydot, python setup.py install
    install the full Graphviz in a subdir somewhere on  the path
    pydot has a path walker that will find it.
    works on win.

    bring it back down to 4.1 standards and macroize it
    put in a switch for &gt;4.1 use the origional calls
    
    works on any node now. best if there are not too many subnodes
    the graph gets too dense and small
  ~EOT  
    the other demo graph node outline builder worked 4.1.
    also have to refocus. the demo was to visualize 4.2 t\/v nodes
    I dont need to see the numbers just the headlines
    some things are compatable some not. 
    need to dev a good list of what works
    list of cvs commits would help here maybe if the docs dont keep up.
    its not going to make a whole lot of sense in less than 4.2
    untill I find out about the diferences
    makes a nice looking graph though!

 a dependancy graph of which modules a program uses might be doable.
 more nodes for pieces in the module and other filesystem dependancies.
 
 
    numberOfChildren() nthChild(n) lastChild()
    """
    import leoGlobals as g
    import os
    import string  #why?
    try:
        import pydot
    except ImportError:
        g.es('you need http://www.dkbza.org/pydot.html')
        return

    try:
        import dynacommon as dy
        #reload(dy)
        fname = dy.leotmp('pydotOut.jpg')
    except ImportError:
        fname = 'pydotOut.jpg'

    p = c.currentPosition()

    &lt;&lt; code &gt;&gt;
        
    graph = pydot.Dot(simplify= True, ordering= "out")

    root = p  #g.findNodeInTree(p, "Root") #another 4.2ism or in leotest

    addLeoNodesToGraph(root, graph, top= True)
    graph.write_jpeg(fname, prog= 'dot')

    g.es('graph of outline written to \n' + fname)
    import webbrowser
    webbrowser.open(fname, new= 1)</t>
<t tx="ekr.20050421093045.14">@others</t>
<t tx="ekr.20050421093045.15">def addLeoNodesToGraph(p, graph, top= False):
    """
    p.v attribute is 4.2, this might be a dealbreaker for 4.1?
    butchering it up just to get some output
    the node ovals are too large
    
    """

    # Create p's vnode.
    if Leo &gt; 4.1:
        n = vnodeRepr(p.v)
        l = vnodeLabel(p.v)
    else:
        n = vnodeRepr(p)
        l = vnodeLabel(p)

    thisNode = pydot.Node(name= n, label= l)
    graph.add_node(thisNode)

    if p.hasChildren():
        child = p.firstChild()
        childNode = addLeoNodesToGraph(child, graph)
        graph.add_node(childNode)

        if Leo &gt; 4.1:
            e1 = tnodeRepr(p.v.t)
            e2 = vnodeRepr(child.v)
        else:
            e1 = tnodeRepr(p)
            e2 = vnodeRepr(child)

        edge2 = pydot.Edge(e1, e2)
        graph.add_edge(edge2)

        
        #     child.next() could error?  hasattr(child, 'next()')?
        while child.next():  #child.hasNext() 4.2
            next = child.next()
            
            if Leo &gt; 4.1:
                e1 = vnodeRepr(child.v)
                e2 = vnodeRepr(next.v)
            else:
                e1 = vnodeRepr(child)
                e2 = vnodeRepr(next)

            edge =  pydot.Edge(e1, e2, dir="both")

            nextNode = addLeoNodesToGraph(next, graph)
            graph.add_node(nextNode)
            graph.add_edge(edge)
            child = next
            
    if 1:
        if Leo &gt; 4.1:
            n = tnodeRepr(p.v.t)
            l = tnodeLabel(p.v.t)
        else:
            n = tnodeRepr(p)
            l = tnodeLabel(p)

        tnode = pydot.Node(name= n, shape="box", label= l)
        
        if Leo &gt; 4.1:
            e1 = vnodeRepr(p.v)
            e2 = tnodeRepr(p.v.t)
        else:
            e1 = vnodeRepr(p)
            e2 = tnodeRepr(p)

        edge1 = pydot.Edge(e1, e2, arrowhead= "none")
        graph.add_edge(edge1)
        graph.add_node(tnode)
    
    if 0: # Confusing.
        if not top and p.v._parent:
            edge = pydot.Edge(vnodeRepr(p.v),vnodeRepr(p.v._parent),
                style="dotted",arrowhead="onormal")
            graph.add_edge(edge)

    if 0: # Marginally useful.
        for v in p.v.t.vnodeList:
            edge = pydot.Edge(tnodeRepr(p.v.t),vnodeRepr(v),
                style="dotted",arrowhead="onormal")
            graph.add_edge(edge)

    return thisNode</t>
<t tx="ekr.20050421093045.16">def tnodeLabel(t):

    if Leo &gt; 4.1:
        tl = len(t.vnodeList)
    else:
        tl = 0

    return "t %d [%d]" % (id(t), tl)
    
def vnodeLabel(v):
    
    return "v %d %s" % (id(v),v.t.headString)
</t>
<t tx="ekr.20050421093045.17">def dotId(s):
    """Convert s to a C id"""

    s2 = [ch for ch in s if ch in (string.letters + string.digits + '_')]
    return string.join(s2,'')

def tnodeRepr(t):

    return "t_%d" % id(t)
    
def vnodeRepr(v):
    
    return "v_%d_%s" % (id(v),dotId(v.headString()))</t>
<t tx="ekr.20050421093045.18">def dynaB_linenumber(c):
    """(c)  print w/sentinals
   selected text or body as Leo sees it, 
   numbering lines or if there is an integer in copybuffer,
    show just +- a few lines around that number.
   selected text doesn't show sentinalsm but exscript uses them
   so lineenumber on selected text may not jive after an error.
   (for more rambling debugging tips see my website)
   syntax errors, indentation errors ,  missing closing paren
   missing colon ':'  in def, if, class
   the actual error can be ahead or behind of the reported error line.
   often at the top of the block continuing the error.
   it wouldn't hurt to examine the bottom and middle either.
  ~EOT   further enhancement, keep track of last section ref node
    last def last method of last class and output all the lines together
    rather than one at a time which can tie up Leo on long programs.
    should output current path and language and wrap to current wrap
    -n +n could be under/over the abs(int) in copy buffer

    could make it jump to linenumber based on env variable
    that way you wouldn't have to remake the plugin to change behavior
    several other macro also could use settable params at ex script time.
    
    """
    #nothing selected will include sentinals
    data = fixbody(c,dynaput(c, [])) 
    datalines = data.splitlines()

    pln = g.app.gui.getTextFromClipboard()
    try:
        pln = int(pln)
        g.es('using line # %d'%(pln,), color= 'turquoise4')
    except Exception, err:
        g.es('no int in copy buffer', color= 'turquoise4')
        pln = 0

    if pln &gt; len(datalines) or pln &lt; 0:
        #who would select zero to print the first line?
        #maybe zero should be all lines as it would be if zero
        g.es('int found is out of range', color= 'turquoise4')
        #still possible to break and maybe too many messages
        if pln &gt; len(datalines): pln = len(datalines) - 5
        if pln &lt; 0: pln = 5

    for i, x in enumerate(datalines):
        if pln and i &lt; (pln - 5): continue
        if pln and i &gt; (pln + 5): break

        #would rather not go thru this every time thru the loop
        if pln and i == pln:
            colr = 'gray'
        else: 
            colr = 'slategray'

        g.es('%- 3d '%(i,), newline= False, color= colr)

        g.es('%s'%(x,))
    g.es('There are %s lines in ? nodes size=%s'%(
            len(datalines),
             sum([len(x) for x in datalines]), 
             ), color= 'turquoise4')</t>
<t tx="ekr.20050421093045.19">def dynaB_nflatten(c):
    """c= None  print
    like flatten but in macro so can
    print/paste or copy to buffer eventually. now out to log.
    should limit the recursion to less than the normal limit
    isn't following the more format of +-
    chg to int, add index level, seperate out the recursive function
    so can return body size and assmble totals
    what is the meaning of the totals if index is one though?
    obviously have to get all and total in here, next refactor for that.
  ~EOT   show if there are subnodes even if dont enumerate.
    dynacolors being a global when run from dyna_menu makes this
    problematic when run from scriptButton now while debugging...
    going to have to exS with dynacommon namespace or something
    or import common if any macr needs them. more complications.
    should just extend g and be done with it

    uses dynacommon deangle, commafy 
    an ini setting could select just @nodes or just @file
    another could leave off the node counts and totals
    
    silly to create a newline connected string of rendered ints
    then splitlines and int on the split string! 
    better just return list of tupple?
    will make no sense to anyone except if they've seen previous version
    but is a major simplification, 
    why it happened in the first place, is surely a mystry.
    there may be a marginal tradeoff of computation for size of list
    and in a recursive function this might matter, we'll see how it goes.
    next will have to resolve why the total of all nodes != filesize
    not even counting @thin etc
    """    
    import leoGlobals as g

    tbytes = 0
    oline = _nflatten(c, index= 1, sx= [])
    g.es("headString, +nodes, bytes")
    for st in oline:
        try:
            i, hs, sz, nz = st
            g.es("%s%s, +%d, %s"%(
                (' '*i), hs, nz, 
                      g.choose(sz&lt;1024,
                       '%s'%sz, '%sk'% commafy(sz, '.')) ),
                     color= dycolors.gFuchsia)
            tbytes += sz
        except Exception:
            g.es(" ", s, dynaerrline(), color= dycolors.gError)  #

    if len(oline) &gt; 1:
        g.es(" =%s"%(
            g.choose(tbytes&lt;1024,'%s'%tbytes, '%sk'% commafy(tbytes, '.')),
            ), color= dycolors.gFuchsia)
        

def _nflatten(c, current= None, indent= 0, index= 0, sx= None):
    """may be trying to combine too many things
     efficency out the window to boot.
    """
    if current is None:
        current = c.currentPosition()
        t = (indent, deangle(current.headString()[:50]),
            len(current.bodyString()), len(list(current.children_iter())) )
        #g.es(t, color="purple")
        sx.append(t)
        indent += 2

    for p in current.children_iter():
        t = ( indent, deangle(p.headString()[:50]),
            len(p.bodyString()), len(list(p.children_iter()))  )
        #g.es(t)
        sx.append(t)
        if p.hasChildren() and index &gt;0:
            _nflatten(c, p, indent +2, index -1, sx)
            continue

    return sx</t>
<t tx="ekr.20050421093045.20">@others
def dynaB_fileinfo(c, fname= None):
    """(c= None, fname= None)  print
     show some basic file info size, create date etc.
    try to get filename from selected text then copybuffer,
    if none of these are valid filenames using os.isfile,
    then will try to get current @file @rst path &amp; name,
    then finally c.mFileName of current leo.
    if more than one of these is True, 
    then its up to you to move out of that node, select or whatever.
    feel free to impliment the more stodgy browse to file name first idiom.
  ~EOT  py22 fixed
    AttributeError: 'module' object has no attribute 'getctime'
    
    might popup a dlg to set attributes in v9
    should get user name also
    winUserName = win32api.GetUserName()
    macUserName = ?
    nuxUserName = expand('~')?

    add mode to walk from root and list all the @thin filenames
    and sublist any @file @nosent contained
    then all other @file for backup if you aren't careful with @thin
    you might just backup the leo's and forget the derived files    
    """
    import leoGlobals as g
    import os, time

    drif = 0 #do report intermediate failures 

    def normit(fn): 
        #seems redundant till you get a weird join it fixes
        return fn  #g.os_path_norm()

    if fname is None:
        fname = c.frame.body.getSelectedText()
        if not g.os_path_isfile(normit(fname)):
            if drif and fname: g.es("- ", fname[:53])
            fname = g.app.gui.getTextFromClipboard()

        #chg 1 to 0 or will never try for @file
        if 0 and not g.os_path_isfile(normit(fname)):
            if drif and fname: g.es("- ", fname[:53])
            fname = 'python.txt' #testing default

    if not g.os_path_isfile(normit(fname)):
        if drif and fname: g.es("- ", fname[:53])
        fname = 'the current @file'
        p = c.currentPosition()
        #leocommands has goto should be using an API call to get filename.
        #coping some of the relevent code, its a jungle in there...
        #seems ok on @nosent, goto should be fixed since it skips them

        fileName = None
        for p in p.self_and_parents_iter():
            fileName = p.anyAtFileNodeName()
            if fileName: 
                break
            if p.headString()[:4] == '@rst':
                #this can fail if not the first @rst
                fileName = p.headString()[4:]
                #c:\c\leo\V42leos\ /c/leo/HTML/Colortest.html via join
                break

        if not fileName:
            if drif: g.es("ancestor not @file node")
        else:
            root = p.copy()
            d = g.scanDirectives(c)
            path = d.get("path")
            #need the directive length, thin, file-thin etc [1:] 

            fname = root.headString()
            fname = fname[fname.find(' ')+1:]
            fname = g.os_path_join(path, normit(fname))
            if not g.os_path_isfile(normit(fname)):
                #will double the msg if drif, 
                #but you might want to know
                g.es("not exists", fname[:53])

    if not g.os_path_isfile(normit(fname)):
        if drif and fname: g.es("- ", fname[:53])
        fname = c.mFileName #can fail if not saved

    if not g.os_path_isfile(normit(fname)):
        g.es("no valid filename found %s"% str(fname[:53]))
        return 

    #print g.file_date(fname, format=None)
    #print os.path.getatime(fname)
    fname = normit(fname)
    try:
        if not hasattr(os.path, 'getctime'): #py22
            os.path.getctime = os.path.getmtime
        h = "%s % 5dK  %s\n%- 18s c) %24s m) %24s"%(
            perms(fname),
            os.path.getsize(fname)/1024L,       #comafy
            g.os_path_split(fname)[0],          #dirname
            g.os_path_split(fname)[1],          #text
            time.ctime(os.path.getctime(fname)), #is this locale?
            time.ctime(os.path.getmtime(fname)),
        )
    except (OSError, Exception):
        g.es_exception()
        h = fname

    g.es(h)</t>
<t tx="ekr.20050421093045.21">def perms(name):
    """
    a=\xc3 Padraig Brady - http://www.pixelbeat.org
     -rw-rw-rw- leo\src\..\config\leoConfig.txt
    """
    import sys
    import stat
    import os
     
    mode = stat.S_IMODE(os.lstat(name )[stat.ST_MODE ])
    #print mode
    perms = "-"
    for who in "USR", "GRP", "OTH":
        for what in "R", "W", "X":
            if mode &amp; getattr(stat, "S_I" + what + who ):
                perms = perms + what.lower()
            else:
                perms = perms + "-"
    return perms
 
</t>
<t tx="ekr.20050421093045.22"></t>
<t tx="ekr.20050421093045.23">def dynaM_geturls(c):
    """(c) selected text print/paste
    extract all urls from selected text. included som extra text.
    doesnt span line endings. misses any number of other mal formed urls.
    might use some ideas from the extend rclick post on sf.
    not 100% reliable and not intended to be the last word in re use.
    reconstruction of the found url is at this point just exploratory.

    testing in redemo, modifyed to include rClickclass 
    and multiline text for re's instead of single line entry.
    kodos and redemo work too, but always seeems a little less reliable

    some might want the ability to open the default browser with the url
    thats best let to another plugin or macro or could optionally
    add it to the clipboard.
  ~EOT  
    split out into a dev version.
    add email harvester stage.
    view partial source on a list of url links will add cvrt to &amp;amp;

click enable for geturls, create a page on the fly with the urls
pass it to IE so you can rclick on them
create a numbered range creator 

    added a sort step
   does py2.2 urllib have unquote_plus? remove %20 %7E stuff

    """
    newSel = dynaput(c, [])
    if not newSel: return
    try:
        data = str(newSel)
    except (UnicodeEncodeError, Exception):
        g.es_exception(full= False)
        data = newSel


    import re, urllib

    #from leo
    # A valid url is (according to D.T.Hein):
    # 3 or more lowercase alphas, followed by,
    # one ':', followed by,
    # one or more of: (excludes !"#;&lt;&gt;[\]^`|)
    #   $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
    # followed by one of: (same as above, except no minus sign or 
    # comma).
    #   $%&amp;'()*+/0-9:=?@A-Z_a-z}~
    #thers problems with this, I forget what just now.
    #
    #http etc from rClick plugin extension idea posted to leo forum, works
    #scan_url_re="(http|https|ftp)://([^/?#\s]*)([^?#\s]*)(\\?([^#\s]*))?(#(.*))?"
    #re.sub(scan_url_re,new_url_caller,text)  #leaves out a few types
    #
    #r04422a05:03:35 mine still doesnt match everything, and doesnt submatch as well
    #w04519p05:58:10 make a try at verbose,
    #shold relax it from expecting perfect links
    

    #leaves out a few types wais
    # excluding all invalid chars is always for security &amp; sanity
    # worse than including all valid chars, there will be ommisions
    scan_url = r"""
   ([s]*http[s]*|ftp[s]*|[s]*news|gopher|telnet|prospero|link|mailto|file|ur[il])(://)
    ([_0-9a-z%]+?
    :?
    [_0-9a-z%]+?@?)  #takeing some liberties
    ([^/?#\s"']*)
   ([^?#\s"']*)
    (\?*[a-z0-9, %_.:+/-~=]*)
    (\#*[a-z0-9, %_.:+/-~=]*)  #lookup exact name ref link standard
     (&amp;*[a-z0-9, %_.:+/-~=]*)  #needs work
     ([^"&lt;'&gt;\n[\]]*)  #catch the rest till learn repeat
 #   (#|&amp;*[^&amp;?]*.*)
    """
    #(\?*[^&amp;#"'/&gt;\\]*[a-z0-9, %_-~]*?)
    #(\?([^#\s]*?))  #this is doubling the params
    #(&amp;(.*)*?)
    #(#(.*)*?)  
    #end game, this fails
    #urllib.unquote_plus( urllib.quote(

    scan_url_re = re.compile(scan_url, re.IGNORECASE | re.MULTILINE | re.VERBOSE)
    ndata = scan_url_re.findall(data)  #leaves out :// and /
    sx = []
    if ndata:
        g.es('just urls:')
        for x in ndata:
            if not x: continue
            xfixed = list(x)
            #print xfixed
            # some cnet addresses use quot?
            xfixed = [s.replace('&amp;amp;', '&amp;').replace('&amp;quot;', '"')\
                            for s in xfixed]
            try:
                xfixed = [urllib.unquote_plus(s) for s in xfixed]
            except Exception:
                pass

            sx.append( ''.join(xfixed) + '\n')
            #note, this can totally screw things up...
    else: g.es('no urls')  #, data

    #sets another way to get uniq
    #sx = [x for x in dict(sx)] #uniqs it, has problems
    d = {}
    for x in sx:
        d[x] = 1
    sx = [x for x in d.keys()]
    sx.sort()
    dynaput(c, sx)
</t>
<t tx="ekr.20050421093045.24">def dynaM_swaper(c):
    """(c) selected text print/paste
    swap selected and copybuffer. a common task is to cut
    one word or sentance, paste in another place then repete
    with the other word or sentance back to the first position.
    you now can copy the one you want moved, select where you
    want to replace it. and hit swapper. you will have the other
    in the copy buffer and can now paste it over the first.
    
    much harder to describe than to do.
    """
    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)

    sx = []

    repchar = g.app.gui.getTextFromClipboard()
    if repchar:
        g.app.gui.replaceClipboardWith(newSel) 
        sx.append(repchar)

    if sx:        
        dynaput(c, sx)
</t>
<t tx="ekr.20050421093045.25">def dynaM_flipper(c):
    """(c) selected text print/paste
    flip selected True to False, 1 to 0 or vice versa
    add your favorite flippable words to the dict below.
    """
    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)

    sx = []
    
    #only need one instance of each flip pair, updates w/reverse dict
    flip = {'true':'false',
            'True':'False', 
            # 1/'1' not the same hash, but maybe interchangeable?
             '1':'0',
              1:0,   
             'YES':'NO',
             'yes':'no',
             'right':'left',
             'top':'bottom',
             'up':'dn',
             'n':'f',
             'after':'before',
             'or':'and',
              }
    #print flip

    flip.update(dict([[v, k] for k, v in flip.items()]) )

    #print flip

    if newSel in flip.keys():
        sx.append(flip[newSel])

    if sx:        
        dynaput(c, sx)</t>
<t tx="ekr.20050421093045.26">def dynaM_dupe(c):
    """(c) selected text print/paste
    very often I want to copy a line or 2, but I only realize
    after I already have something in the buffer to paste over.
    this will duplicate the selected lines after the selected lines
    takeing advantage of the insert point selected being before of after
    pot luck asto which it will be before or after.
  ~EOT  have to unselect first, also makes dependant on the body
    was hopeing to keep those depandancys in dynaput
    incase I allow changes to other widgets or the log
    or even virtual bodys.
    if unselect, or virtual event return to end select kluge
    then dynaput complains nothing selected!
    try just doubling the selected text
    works for single line select anyway. 90% use case
    maybe if nothing selected, copy &amp; paste the node?
    you may need to swith node then back after undo a duped line
    redraw isnt perfect
    """
    newSel = dynaput(c, [])
    if not newSel: return

    sx = newSel.splitlines(True)
    sx += newSel.splitlines(True)

    dynaput(c, sx)</t>
<t tx="ekr.20050421093045.27">def dynaM_clipappend(c):
    """(c) selected text 
    append selected to Clipboard
    """
    newSel = dynaput(c, [])
    if not newSel: return

    Clip = g.app.gui.getTextFromClipboard()
    Clip += newSel
    g.app.gui.replaceClipboardWith(Clip)
</t>
<t tx="ekr.20050421093045.28">def dynaM_everycase(c):
    """(c) selected text print
    take the word or sentance and output in every case
     you can then copy from the log pane which you want.
     this seems easier than trying to consequetively 
     flip through all th possibilities.
     rClick dev version rightclick context menu has this.
    """
    newSel = dynaput(c, [])
    if not newSel: return
    s = str(newSel)

    sx = []

    for x in [
        s.upper(), '  ',
        s.lower(), '  ',
        s.capitalize(), EOLN,
        
        s.swapcase(), '  ',
        s.title(), '  ',
        s.title().swapcase(), EOLN,

        "'%s'"%s, '  ',
        "(%s)"%s, '  ',
        "('%s')"%s.lower(), EOLN,
         ]:
        sx.append(x)

    #here wordwrap or otherwise format and relist it.
    
    if sx:        
        dynaput(c, sx)
</t>
<t tx="ekr.20050421093045.29">def dynaM_regexTk(c):
    """(c) selected text print
    changing Tk pack options to dict's
    match alphanumeric on either side of =: or space or coma delimited
    build a dict or list from it. properly quote and verify numbers.
    its only been 3 minutes and I have better results 
    than in plex or pyparsing in more time than I care to admit.
    maybe need re, space double in space delimited means cant ignore
    avoided re for now. probably woulve been easiest

    cuts after the decimal on floats. might want = as an option too
  ~EOT 
    reWhitespace = re.compile( r'[,\s\n]+', re.MULTILINE )
    fields = reWhitespace.split( line )
    
    partially convert to EOLN, need to setup more tests first
        
    """
    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)

    g.es('text is', newSel)

    sx = []

    #premassage the data
    newSel = newSel.replace(' ', ',').replace(',,', ',').replace(',,', ',')
    #print 'newSel is %r'%(newSel,)

    for x in newSel: 

        if x in '\'"':
            continue

        if x in [' ', ',', EOLN]: #may fail in py2.2 w/\r\n
            sx.append(EOLN)
            continue

        if x in '=:':
            sx.append(':')
            continue
        
        sx.append(x)


    data = ''.join(sx)
    data = data.replace('\n\n', '\n').replace('\n\n', '\n')
    data = data.replace('\n,\n', ',').replace('\n:\n', ':').replace(',', '\n')
    data = data.replace('\n:', ':').replace(':\n', ':').replace('::', ':')
    #print 'data is %r'%(data,)

    sx = []
    sx.append('{')
    for x in data.splitlines():
        #print 'for x', x

        if not x: 
            continue

        if x in [' ', ',', EOLN]: 
            sx.append(", ")
            continue

        if x.find(':') != -1: 
            x1 = x.split(':') 
            for i, y in enumerate(x1):
                #print 'for y', y

                if i == 1: 
                    sx.append(":")

                try:
                    #sx.append("%d"%int(y) )
                    sx.append("%d"%float(y) )
        
                #maybe float and int will have different errors
                #maybe if int it isnt coerced to float? works for me.
                except Exception, e:
                    #print 'exception', e.args
        
                    s = y.replace('Tk.', "").replace('Tkinter.', "")
                    sx.append("'%s'"%(s.lower(),) )
                #else: sx.append(":") else is only if except tripped

        else: #no : seperator assume is a plain delimited list
            sx.append("'%s':1"%(x,)) 
        sx.append(", ")


    sx.append("}")
    dynaput(c, sx)</t>
<t tx="ekr.20050421093045.30">def dynaM_wraper(c):
    """(c) selected text print/paste
    wrap selected to the len of the first line
    uses the py2.3 textwrap or g.wrap_lines
    http://cvs.sourceforge.net/viewcvs.py/python/
    """
    try:
        if g.app.dynaMvar.bugimport: raise ImportError
        import textwrap as tw
    except ImportError:
        tw = None
        g.es('get textwrap from python cvs or py2.3')
        #return

    newSel = dynaput(c, [])
    if not newSel: return

    data = str(newSel)

    datalines = data.splitlines(True)
    if datalines: width = len(datalines[0])

    width = width or 40
    #get starting indent from first line too

    if tw is None:
        sx = g.wrap_lines(datalines, pageWidth= width, firstLineWidth= width)
        
    else:
        sx = []
    
        t = tw.TextWrapper(
             width= width,
            initial_indent=' ',
           subsequent_indent= ' ',
           expand_tabs= True,
          replace_whitespace= True,
         fix_sentence_endings= False,
        break_long_words= True )

        st = t.fill(data)
        sx.append(st)

    if sx:
        dynaput(c, sx)
    g.es( "len= %d lines= %d len firstline= %d words= %d"%(
        len(data), len(datalines), width, len(data.split())) )</t>
<t tx="ekr.20050421093045.31">def dynaM_rsortnumb(c):
    """(c) selected text print/paste
    caller to dyna_sortnumb(c, d= 1 )
    the reverse list will be called before output there
    """
    dynaM_sortnumb.direction = 1
    dynaM_sortnumb(c)

</t>
<t tx="ekr.20050421093045.32">def dynaM_sortnumb(c):
    """(c) selected text print/paste
    do a numeric aware sort, add field selection later
    maybe even a regex selection or other field specifyer
    can sort a list by copying the seperator then selecting some words
    default seperator is space, \n for multilines
    I realize other options might sometimes be required
    for those times, copy DQ3 and make something specilized.
    checking for multiple lines could be less redundant, ok for now.
    now how do I do a reverse sort?
    have a little helper function to call this with d=1
    need to preserve lineending if selected multiline,
     splitlines(True) ok if body
     how. each choice gets me deeper into trying to guess everything
  ~EOT    keeping indented lines together would allow sorting headlines
     and possibly functions. using a script in the copy buffer?

    """    
    nothingselected = False
    data = dynaput(c, [])
    g.es("selected ")
    if not data:
        nothingselected = True
        g.es("...skip, dump the body")
        v = c.currentVnode() # may chg in 4.2
        data = v.bodyString()

    #maybe use DQ3 thing of the copybuffer to select the splitchar
    splitchar = g.app.gui.getTextFromClipboard()

    multiline = ''
    if not splitchar:
        splitchar = ' '

    
    if 1 == len(data.splitlines(True)):
        sx = [x + splitchar for x in data.split(splitchar)]
    else: 
        multiline = EOLN
        sx = data.splitlines() #True
        
        
    sx.sort(compnum)

    try:
        if dynaM_sortnumb.direction == 1:
            sx.reverse()
            dynaM_sortnumb.direction = 0

    except AttributeError:
        pass

    #deal with nothing selected, must be sort of whole body as lines
    if nothingselected:
        #nothing selected so cant be paste over
        for x in sx:
            print x #might this double line?
    else:
        if multiline:
            sx = [x + multiline for x in sx]
        dynaput(c, sx)

def compnum(x, y ):
    """214202 Pretty_sorting_.htm
    Submitter: Su'\xe9'bastien Keim
    Last Updated: 2003/08/05 
    Sorting strings whith embeded numbers.
    #  sample
    &gt;&gt;&gt; L1 = ["file~2%d.txt"%i for i in range(2, 50, 10)]
    &gt;&gt;&gt; L2 = L1[:]

    &gt;&gt;&gt; L1.sort()
    &gt;&gt;&gt; L2.sort(compnum)
    
    &gt;&gt;&gt; for i,j in zip(L1, L2):
    ...     print "%15s %15s" % (i,j)
       file~212.txt     file~22.txt
        file~22.txt    file~212.txt
       file~222.txt    file~222.txt
       file~232.txt    file~232.txt
       file~242.txt    file~242.txt
    """
    import re
    DIGITS = re.compile(r'[0-9]+')

    nx = ny = 0
    while True:
        a = DIGITS.search(x, nx )
        b = DIGITS.search(y, ny )
        if None in (a, b ):
            return cmp(x[nx:], y[ny:])
        r = (cmp(x[nx:a.start()], y[ny:b.start()])or
            cmp(int(x[a.start():a.end()]), int(y[b.start():b.end()])))
        if r:
            return r
        nx, ny = a.end(), b.end()
</t>
<t tx="ekr.20050421093045.33">def dynaM_del_last_char(c):
    """(c) selected text print/paste
    like del first char in the line except
    delete the last char in all the selected lines

    """
    newSel = dynaput(c, [])
    if not newSel: return
    
    try:
        newSel = str(newSel)
    except (UnicodeEncodeError, Exception):
        g.es_exception(full= False)


    sx = []
    for x in newSel.splitlines():
        sx.append(x[:-1] + EOLN )

    dynaput(c, sx)
</t>
<t tx="ekr.20050421093045.34"></t>
<t tx="ekr.20050421093045.35">&lt;&lt; checkFileSyntax &gt;&gt;

#was pyimportwithindent
def dynaS_importnode(c):
    """(c) selected text/body overwrites.
   combines sfdots, and import to @file.
    assumes code is all in one node. will undo properly,
    but modifys the current node and will write to a temp file,
    then create a subnode from that file.
    @language whatever, you might have to tweek the file extension manually
    if not python c or java, maybe a few others ok, css html.

    will reindent  and syntax check and run evaluator if python.
    for other @language might call astyle.

    should be free of any obvious syntax error.
    when done, you move left, delete the temp node,
    set @path or whatever and fix the headline.
  ~EOT    overwrite False, no sfdots or evaluator
    do I need a pause or update between the selectall and an action?
    added some sense of other lang than python, untested.
    """
    import dyna_menu as dy
    select = g.app.gui.setTextSelection
    overwrite = True

    p = c.currentPosition()
    lang = g.scanForAtLanguage(c, p)
    lang = str(lang).lower()
    tfile = dy.tmpfile

    start = dy.dynaB_Clip_dtef(c, ret='rp')

    if overwrite: 
        #enable to overwrite else will print to log
        dy.dynaMvar.dynapasteFlag.set('paste')
        select(p.c.frame.bodyCtrl, '0.0', 'end')
        dy.dynaS_sfdots(p.c, nodotreturn= True)


    #getsctipy now and check syntax... before/after evaluator
    #what about the undo? can I roll that back too?
    s = g.getScript(c, p)
    
    if lang == 'python':
        if checkFileSyntax(s): g.es(s, 'do undo twice'); return

    #now reindent isn't overwrite and want to run evaluator first
    #but I guess after is ok too.
    #tim1 leaves reindented code in the tmp.py

    if lang == 'python':
        if overwrite: 
            select(p.c.frame.bodyCtrl, '0.0', 'end')
            dy.dynaS_evaluator(p.c)


    if lang == 'python':
        s = g.getScript(c, p)
        if checkFileSyntax(s): g.es(s, 'do undo thrice'); return

    if lang != 'python': #tempfile should already have py extension
        tfile += '.lang' #and pray, there should be a cross ref somewhere
        g.es('writing %s'%tfile)
        fo = open(tfile, 'w')
        fo.write(s+EOLN)
        fo.close()
    else:
        #not sure this shouldn't be a user option instead of hardwired
        dy.doreindent = 1

        #this was depending on reindent being true and file getting written
        select(p.c.frame.bodyCtrl, '0.0', 'end')
        dy.dynaS_tim_one_crunch(p.c)


    c.beginUpdate()
    #might still have to remove a few sentinal lines start &amp; end
    #can this return a sucess or fail? and the maybe the node pointer

    try:
        c.importCommands.importFilesCommand([tfile], '@file')
    except Exception:
        g.es_exception()

    #else: is this if the exception? I can never remember
    #p.selectVnode('after') or something...
    #if headline == ('@file ' + dy.tmpfile):
    #    p.setHeadline('@file some.py')
    #   move before, then select node after, selectall &amp; delete
    c.endUpdate()
    c.redraw()  #update no, redraw seems to work

    dy.dynaMvar.dynapasteFlag.set('print')
    g.es('st:%s\n sp:%s\n may have to wait \nand click to see the new node'%(
        start, dy.dynaB_Clip_dtef(c, ret='r')) )

    #should select child and move left. what if it failed?</t>
<t tx="ekr.20050421093045.36">#from leoTest params opposit from there
def checkFileSyntax(s, fileName= 'Script'):
    """too hard to get the traceback exact in full= False
    &gt;&gt; checkFileSyntax(''' eros''')
      File "&lt;string&gt;", line 1
        eros
        ^
    SyntaxError: invalid syntax
    True
    &gt;&gt;&gt; checkFileSyntax('''\\n#ok''')
    False
    """
    import leoGlobals as g
    import compiler
    try:
        compiler.parse(s.replace('\r\n', '\n') + '\n')  
        #,"&lt;string&gt;" parse(buf, mode='exec')
        #compile( string, filename, kind[, flags[, dont_inherit]]) 

    except SyntaxError:
        g.es("Syntax error in: %s" % fileName, color= "blue")
        g.es_exception(full= False, color= "orangered")
        return True  #raise

    return False</t>
<t tx="ekr.20050421093045.37">def dynaS_pydisa(c):
    """(c= None) selected text/body print
    produce a dissasembly into python bytecodes
    of selected text lines of code or the full script
    sentinals are striped to avoid confusing the output
    but of course in execute script they are there
    as should be noted in any timeit type usage
    """
    import leoGlobals as g
    import dis, sys

    import dyna_menu as dy

    p = c.currentPosition()

    #get selected text if any or the whole script
    newSel = dy.fixbody(c,dy.dynaput(c, []))

    if not newSel or len(newSel) == 0:
        return

    newSel = stripSentinels(newSel)

    g.es('dissasembly of: '+ p.headString()[:50])
    g.es(newSel, color= 'MediumOrchid4')
    nc = compile(newSel, '&lt;string&gt;', 'exec')

    #have to find a way to encapsulate this better
    o = g.fileLikeObject()
    sys.stdout = o

    dis.dis(nc)

    s = o.get()
    sys.stdout = sys.__stdout__

    g.es(s.replace('   ', ' '), color= 'sienna3')
</t>
<t tx="ekr.20050421093045.38">def dynaS_c2py(c):
    """(c) body+ subnodes overwrite, should backup node first.
    call the fantastic first cut EKR c2py script
    you still have to make it more pythonic but it does quite allot for you.
    c2py doesn't generate an undo event so there is no turning back.    
    @language c, works on other c like language too.

    c2py causing a direct line by line translation of c, you would
    often be served well to rethink some of the program flow.
    dropping just the relevant algorithm translated to python
    into a more generic pythonic wrapper can save allot of time.

    please, be sure to attribute any snippets of code you convert and use.
    I doubt c2py author intends this utility to make plagiarism easy.
  ~EOT  still some things to work out. if the c file is in one node
    it might be better to import it first as c, then let c2py convert it
    using convertCurrentTree it converts in place.
     that might be dangerous if it
    fails or if you need to refer to it later
    OTOH, from a tempfile you wouldn't be able to import
    as there may be logic problems left over from the conversion.

    on selected text or body written to tempfile.
    previously found it easier to call c2py with a filename
    then import the modified file. which did work well.
    usually stick with what works. glad I didn't this time.
    having dyna provide the currentvnode was the missing piece
    and should allow the import as well without a filewrite.
    
    might still make  a backup to another node or to a derived file.
    it also might make sense to run the c thru indent or astyle first
    you definitely want the original to refer to.
    need to run thru reindent or remove tabs maybe too before usage.
    there are clues to give c2py which might help with some specific
    conversions which I haven't examined.
    in the case of declarations I would've left comments on the type
    int x, becomes just x. might have been char or double who knows.
# 
# c2py removes all type definitions correctly; it converts
# 	new aType(...)
# to
# 	aType(...)


classList = [
    "vnode", "tnode", "Commands",
    "wxString", "wxTreeCtrl", "wxTextCtrl", "wxSplitterWindow" ]
    
typeList = ["char", "void", "short", "long", "int", "double", "float"]

 Please change ivarsDict so it represents the instance variables (ivars) used  by your program's classes.
ivarsDict is a dictionary used to translate ivar i of class c to self.i.  
It  also translates this-&gt;i to self.i.

    
ivarsDict = {
    "atFile": [ "mCommands", "mErrors", "mStructureErrors",
        "mTargetFileName", "mOutputFileName", "mOutputStream",
        "mStartSentinelComment", "mEndSentinelComment", "mRoot"],

    "vnode": ["mCommands", "mJoinList", "mIconVal", "mTreeID", "mT", "mStatusBits"],

    "tnode": ["mBodyString", "mBodyRTF", "mJoinHead", "mStatusBits", "mFileIndex",
        "mSelectionStart", "mSelectionLength", "mCloneIndex"],
        
    "LeoFrame": ["mNextFrame", "mPrevFrame", "mCommands"],

    "Commands": [
        # public
        "mCurrentVnode", "mLeoFrame", "mInhibitOnTreeChanged", "mMaxTnodeIndex",
        "mTreeCtrl", "mBodyCtrl", "mFirstWindowAndNeverSaved",
        #private
        "mTabWidth", "mChanged", "mOutlineExpansionLevel", "mUsingClipboard",
        "mFileName", "mMemoryInputStream", "mMemoryOutputStream", "mFileInputStream",
        "mInputFile", "mFileOutputStream", "mFileSize", "mTopVnode", "mTagList",
        "mMaxVnodeTag",
        "mUndoType", "mUndoVnode", "mUndoParent", "mUndoBack", "mUndoN",
        "mUndoDVnodes", "mUndoLastChild", "mUndoablyDeletedVnode" ]}  

  maybe I can modify the list dynamically with user input cycle?
  based on an xref of the code to be converted.
  
def convertCurrentTree(c):
    import c2py
    import leo
    import leoGlobals
    v = c.currentVnode()
    c2py.convertLeoTree(v,c) 
    
    wouldn't this obviate any changes to ivars or other code?
    might have to do the same setup w/o the fresh import
    and where to get th custom info from if using M_c2py from plugin?


    messages are going to console instead of log
    converting: NewHeadline
    end of c2py
    might have to capture stdout/err
    or more deviously add a runtime method to change its sys.stdout

   x = {}  will have the {} removed. not sure why...
   removeBlankLines never?
    run tabs to spaces    y/n

    py2.2 coulden't find c2py? try g.import
    """
    import sys
    
    #try g.import, may still fail on py2.2 win9x because
    #uses g.toEncodedString(path,app.tkEncoding) which is utf8 default?
    #it takes verbose as a param, default False, then ignores it on error!
    c2py = g.importFromPath('c2py.py',
        g.os_path_join(g.app.loadDir, '../scripts'))

    if not c2py:
        g.es("can't find the leo/scripts/c2py.py script")
        return

    mess = """\
    the current node &amp; subnodes will be changed
     and there is no undo
     you may have to convert tabs to spaces when done.
     syntax error free code will work the best.
     click ok, then wait for a bit...
     """
    #g.alert(mess)  #g.app.gui
    ans = runAskYesNoCancelDialog(c, "c2py",
                 message= mess, yesMessage= 'ok')

    if 'ok' != ans: g.es('c2py cancled'); return

    #get selected or body... getbody language sensitive
    #write the temp

    #c2py.convertCurrentTree()  #reimports c2py but does work

    #this might fail, but want to try and set some things
    #if it reimports they might get lost...
    c2py.convertLeoTree(c.currentVnode(), c)
    
    #convertLeoTree just node walks, might pass from fixbody
    #then try and reimport to @file from that.
    
    #tmpfile should just be a basename you add extension to?
    #temp = tmpfile[:-3] + '.c'

    #c2py.convertCFileToPython(file) #another way to go
    #cmd = py + c2py + temp
    #out, err = runcmd(cmd)

    c.redraw()  #update nor redraw seems to work every time
    g.es('add an @language python\nand convert tabs to spaces')</t>
<t tx="ekr.20050421093045.39">def dynaS_dump_body(c, ret= 'p'):
    """(c, , ret= 'p') selected text/body print or ret= 'r' return
      yadayada call dynaHexdump(src, length=8), on selected text or body
      if you need an exact output, including any lineendings?
      Leo translates to unicode first so that might be relevant

need feedback from someone who cares about unicode.
UnicodeDecodeError: 'ascii' codec can't decode byte 0x9f in position 1: ordinal not in range(128)
since its not a char at a time, this is going to be hard to trap
maybe will have to filter first. 
    """

    data = dynaput(c, [])
    g.es("selected ")
    if not data:
        g.es("...skip, dump the body")
        v = c.currentVnode() # may chg in 4.2
        data = v.bodyString()

    if data and len(data) &gt; 0:
        #newdata = re.sub("\n", "\r\n", data)
        newdata = dynaHexdump(data)
        if newdata != data:
            #v.setBodyStringOrPane(newdata)
            if 'p' in ret: g.es(newdata)
            if 'r' in ret: return newdata

#had to unicode the FILTER for Leo plugin use
FILTER= u''.join([(len(repr(chr(x)))==3) and chr(x) or '.' for x in range(256)])

def dynaHexdump(src, length=8):
    """
    m02A14p6:31 ASPN Python Cookbook
    Title: Hexdumper.py  Submitter: S?stien Keim  2002/08/05 Version no: 1.0
    Hexadecimal display of a byte stream
    later, output to logwindow of selected text add as a menu option
    maybe can make it read from a file and output as hex
    #r04408ap11:16 chg += to append &amp; join,  not that its particularly slow
    &gt;&gt;&gt; dynaHexdump('ASPN Python Cook')
    u'0000   41 53 50 4E 20 50 79 74    ASPN Pyt    0d\\n0008   68 6F 6E 20 43 6F 6F 6B    hon Cook    8d'
    """
    N = 0; result = []
    while src:
        s, src = src[:length], src[length:]
        hexa = ' '.join(["%02X"%ord(x) for x in s] )
        s = s.translate(FILTER)
        result.append("%04X   %-*s   %s  % 3dd" % (N, length * 3, hexa, s, N) )
        N += length
    return '\n'.join(result)
</t>
<t tx="ekr.20050421093045.40">def dynaS_sfdots(c, nodotreturn= False, stripsentinals= True):
    """(c, nodotreturn= False, stripsentinals= True) print/paste
    process code from sourceforge forum
    which replaces . for leading indentation which sourceforge eats.
     the reverse too so posters can run their code thru first.
    it would be nice if it could standardize to 4spaces per level
    maybe replacing and rerunning or something to catch max indentation
    run thru reindent and pychecker could be usefull
    the UPL adds only 3 dots when you have 4 spaces and nothing else
    that would probably be an error
    if starts with dots, convert to space DNL
    if all spaces or tabs then is UPL convert to dots
    should check the users tab setting, might want one dot to equal one tab
    other times 4 dots= one tab. you edit in what you want I guess.
  ~EOT  t04323a12:31 optomizing for python indentation, adding use,is at first line
    later make that selectable so can do anything, and or put thru reindent
    and allow add or eat first n chars for command to add to rClick
    using a section header to put the code into a subnode
    precedence of i+1 % n slightly different than c, use (i+1)%n
    messedup indentation this wont fix! shoulve saved a copy of the org...
    this version adds indentation numbers and fails if i&gt;n as yet.
    \n was interpreted from the section literlly as a newline in the output...
    need a slick way to check or switch triple Sq/Dq
    its not transforming 2space into 4spacem it eats \t also
    maybe would be better to change dots to tabs then '\t\tfoo'.expandtabs(2)
    sf eats long lines &amp; spaces ? in view source too. 
    the wiki eats angle brackets and moost html and if you click edit it retranslates 
    f04514a11:22:06 convert to dyna, some sillyness to handle inconsistant dots
    you can run it thru reindent after tim1crunch, copy over then c2py
    which defaults to using tabs. which I will change if I find out how.
    I guess c2py doesnt fail if it finds only python, it tabs it up.
    most of the time that should get standrd indenting no matter what.
   
  I think it still screws up \n literal in strings. not tested w/tabs or unicode
  also will hit a limit on indentation if greater than typical for sf post
  can look weird if printed to log w/non proportional font


This means that the code would refer to Tk.widget instead of Tkinter.widget.  Also, please avoid the use of the completely useless Tk constants such as Tk.RIGHT, Tk.TOP.  Use "right" or "top" instead.  
havent done any replace on the incomming or outgoing data.
chg to fixbody except not sure paste makes sence if it isnt in one node  
might send a download automatically thru reindent then evaluator

allowing conversion of full body, if you try and paste over it will
not follow nodes but probably just overwrite the selected node.

add select leading char ini option 
allow from/to of intrepreter &gt;&gt;&gt; ... for doctest prep
 """
    data = fixbody(c,dynaput(c, []))

    if not data or len(data) == 0: return
    import re
    respc = re.compile(r'^[\s.]*$')

    isdots = [x[:1] for x in data.splitlines() if x.startswith('.')]
    #print 'isdotslist', isdots
    isdots = len(isdots) &gt; 0

    if nodotreturn and not isdots: return

    #py &lt;2.3 YOYO isdots == True , works w/o 
    direction=['UPL', 'DNL',][isdots]  

    #doesnt python have a simpler way to swap varbs? 
    #is this clearer to read though. a='.';b=' '; if UPL: a,b=b,a; 
    #could you have '....' be the eat char in a perfect world?
    
    if direction == 'UPL':
        eatchar=' '
        repchar='.'
    else:
        eatchar='.'
        repchar=' '
    
    if stripsentinals:
        data = stripSentinels(data, stripnodesents=0 )

    #4,3
    lines = ('4,4\n' + str(data.expandtabs(4))).splitlines(True)
    
    #fixes dopy dots, starting off with 3 then continuing with 2
    
    
    n, nm = lines[0].split(',')
    n = int(n) or 4  #what one dot equals
    nm = int(nm) or 3

    #print 'len &amp; direction', len(data), len(lines), direction,
    #print n, nm 

    def chkout(t):
        if respc.findall(t): #cut lines on ., ,\t,\f,\n
            t = '\n'
        return t

    sx = []
    for lt in lines[1:]:
        i = 0
        ix = 0
        for o in lt:
            if o == eatchar: 
                i += 1
                continue
            break
        #print i,
        if i &gt; 0 and len(lt) &gt; 0:
            #this should handle 2 4 or 3 on the first then 2 dots,
            #it will get confused if starts and continues with 3
            if nm == 4: ix = i
            elif i==3 or i == 2: ix = n
            elif i==5 or i == 4: ix = n*2
            elif i==7 or i == 6: ix = n*3
            elif i==9 or i == 8: ix = n*4
            elif i==11 or i == 10: ix = n*5
            elif i==13 or i == 12: ix = n*6
            elif i==15 or i == 14: ix = n*7
            elif i==17 or i == 16: ix = n*8
            else: g.es('**bad ix',i)
            #print (repchar*(ix))+lt[i:]
            sx.append(chkout((repchar*(ix))+lt[i:]) )
            continue
        elif i &gt; 0:
            g.es('')
            continue
        
        #print lt
        sx.append(chkout(lt))

    #print sx
    #reindent or evaluator would help too. before the dots obiously
    dynaput(c, sx)    
    
</t>
<t tx="ekr.20050421093045.41">def dynaS_evaluator(c):
    """(c) selected text/body print/paste
    calc_util.py and its unit tests and rClickclass 
    ******* not available yet *********
   from http://rclick.netfirms.com/rCpython.htm

    parsing python programs perfectly presumes perfect programming.
    its so close, I use it all the time to verify code.
    but I know its limitations and I cant realease it yet,
  ~EOT   does good job of reindenting, but still can make mistakes indenting after dedent or comment or before an indent
   compare to origional code carefully!
   
    forgot to tell evaluator to skip to @c if it finds @ alone
    output to log doesnt colorize so isnt immediatly obvious
    the html mode should be reparsed to change to es color output
    need to add an eval mode so can get expression outpt as well
    have to trap stdout so can use to paste if thats selected
    capture seems to be working now from plugin or button
    fixbody takes care of commenting out @directives now.

    if nothing selected, it seems to have nothing?
    weird, its now going to the console again from the button
    and from plugin nothing if nothing selected.
    this is easily the 3rd time it was then wasnt working.
    all the calls are same as pychecker2, it sometimes prints the data
    inside the if. something is erroring and getting masked.
    
    """
    try:
        if g.app.dynaMvar.bugimport: raise ImportError
        import calc_util ;#reload(calc_util) #if working on calc_util
    except ImportError:
        #can I use Leo prettyprinter instead?
        g.es('you have to get the evaluator first')
        return

    data = fixbody(c,dynaput(c, []))

    if data and len(data) &gt; 0:

        #ta = g.stdOutIsRedirected()
        #g.restoreStdout()
            

        #print repr(data)

        o = captureStd()
        o.captureStdout()

        try:
            #this has print on line by line as parsed
            newdata = calc_util.file_test(data, q= 1,
                 doEval= 0, formater= 'py2py',  #py2py raw html
                    onlyPrintFails= 0, printAny= 0 )

        except Exception, err:
            dynaerrout(err,'evaluator ')

        output = o.releaseStdout()
        #if ta:
        #    g.redirectStdout()
            

        dynaput(c, output.splitlines(True))

    #elif len(data) &lt; 80: maybe check for newlines better?
    #    eror, result, ppir = calc_util.evalcall(data)

#
</t>
<t tx="ekr.20050421093045.42">def dynaS_astyle(c):
    """(c) selected text/body popup browser
      http://astyle.sourceforge.net/  
    astyle.exe?--pad=oper --style=kr %
    find some other options to try on their homepage.
    A Free , Fast and Small Automatic Formatter
    for C , C++ , C# , Java Source Codes

    mx.Tidy for html

    assumes its on program path.
  ~EOT  possibly add --force  to highlighter or an @force htmlize
    @force node creation &amp; import, many posibilities
    """

    p = c.currentPosition()

    lang = g.scanForAtLanguage(c, p)
    lang = str(lang).lower()
    
    #might be fragile with update of Leo @language
    #and might want to force a mode
    if lang in 'c cpp'.split():
        mode ='c'
    elif lang in 'java javascript jscript'.split():
        mode ='java'
    elif lang in 'html cml css'.split():
        #send thru tidy gets more complicated
        mode ='html'
    else:
        mode = None

    if not mode in 'html c java'.split(): 
        g.es('unsupported language')
        return

    bypass = 2
    source = dynaput(c, [])
    if source: bypass = 0

    source = fixbody(c,source)
    if not source or len(source) &lt;= 0: 
        return

    if bypass: 
        #by pass the problem w/first 2 sentinals syntax errors
        source = ''.join(source.splitlines(True)[bypass:])
        source = stripSentinels(source)

    if mode == 'html': 
        &lt;&lt;tidy&gt;&gt;
    else:
        &lt;&lt; runastyle &gt;&gt;

    if out:
        htmlize(c, source= (out + err), lang= lang)

    else:
        for x in (out + err).splitlines():
            g.es(x)</t>
<t tx="ekr.20050421093045.43">try:
    from mx.Tidy import tidy 
except ImportError:
    g.es('need to install mx.Tidy')
    return

(nerrors, nwarnings, out, err) = \
   tidy(source,
        uppercase_tags=1,
        #alt_text="", 
        char_encoding="utf8",  #raw, ascii, latin1, utf8 or iso2022 
        quiet=0,
        wrap=0,
        indent="yes",  #no, yes or auto 
        clean="yes",
        drop_font_tags=1,
        word_2000="yes", # yes, Tidy will strip out all the surplus stuff 
        )</t>
<t tx="ekr.20050421093045.44">astyle = ["astyle", "--pad=oper", 
        "--style=kr", "-s4", '--mode=%s'%mode]
g.es(lang, 'running astyle virtual', astyle)
out, err = runcmd(astyle, source)</t>
<t tx="ekr.20050421093045.45">def dynaS_pylint(c):
    """(c) selected text/body popup browser
    create a file and run it thru reindent if enabled then pylint
     default to a tmp filename
    pylint checks over your python code for good form and style
  ~EOTmaybe pylint - options would be best in ini so can override
 or have a dropdown of popular commands for a command
 --generate-rcfile, --help

--statistics=y_or_n 
  Compute statistics on collected data. 
--persistent=y_or_n 
  Pickle collected data for later comparisons. 
--comment=y_or_n 
  Add a comment according to your evaluation note. 
--parseable=y_or_n 
  Use a parseable output format. 
--html=y_or_n Use HTML as output format instead of text. 
--enable-msg=msgids 
  Enable the given messages. 
--disable-msg=msgids 
  Disable the given messages. 
--enable-msg-cat=cats 
  Enable all messages in the given categories. 
--disable-msg-cat=cats 
  
getting no --statistics option error w/pylint 6
not sure I like the html output but spool to log not great either
set html=y, writehead=False and lang=ishtml otherwise
set html=n, writehead=True and lang=report and dohtmlize = 1 for both

    """
    try: import logilab.pylint
    except ImportError:
        g.es('need to install pylint')
        return

    dohtmlize = 1 #show in browser instead of log.    

    data = fixbody(c,dynaput(c, []))

    if not data or len(data) == 0: 
        return

    import sys

    #pylint has to be able to import the file on sys.path

    #this could be trouble on nix or mac. YOYO
    #might not even be necessary in the app, maybe some other
    #if sys.platform[:3] == 'win':
    oldpSath = sys.path[:]
    if not g.os_path_normpath(g.os_path_abspath(
             g.os_path_split(tmpfile)[0])) in sys.path:
        sys.path.append(g.os_path_split(tmpfile)[0] )

    g.es('writeing tmpfile', tmpfile )
    fo = file(tmpfile,'w')
    fo.writelines(data + "%s#e%s"%(EOLN, EOLN, ))
    fo.close()
    
    if doreindent:
        g.es('running reindent', py + reindent + tmpfile )
        out, err = runcmd(py + reindent + tmpfile)
        for x in (out + err).splitlines():
            g.es(x)

    if dohtmlize: html = '--html=n' #y
    else: html = '--html=n'
    
    junk, pylname = g.os_path_split(tmpfile)
    pylname, junk = g.os_path_splitext(pylname) #[:-3] #cut off .py
    g.es('pylint module', pylname )
    pylint = \
    " -c \"import sys; from logilab.pylint import lint;\
             lint.Run(['%s','%s', '%s', '%s', r'%s',])\" "%(
      html, '--comment=n', '--persistent=n', '', pylname,) #--statistics=n

    g.es('running pylint', py + pylint )
    out, err = runcmd( py + pylint)
    
    #should be restored even if error. oh well
    sys.path = oldpSath

    if dohtmlize and out: 
        #the plain text report gets doublespaced in htmlize
        g.es(err)
        htmlize(c, source= out.replace('\n\n', '\n'),
         lang = 'report', writehead= True, show= True) 
    else:
        for x in (out + err).splitlines():
            g.es(x)

    if not g.app.dynaMvar.justpychecker:
        g.es('#source for ', tmpfile, color='blue' ) 
        TextFile = file(tmpfile)
        Text = TextFile.read()
        TextFile.close()
        g.es(Text)

    g.es('done ', color='blue' ) </t>
<t tx="ekr.20050421093045.46">def dynaS_makatemp(c):
    """(c) selected text/body print
    create a file and lightly test it.
     default to a tmp filename

     write out the file and run it thru reindent then pychecker
   then pylint
  external pychecker still has a problem resolveing from import leo*
  not sure how to resolve that. 
  maybe import pythecker.pychecker in the macro?

  using expandtabs(4)
  ***************
    warning, this makes asumptions about where python is, 
    what and where reindent and pychecker is
    at least you have to edit in your correct paths.
    I could guess more but still wouldent be totally sure.
    see the .rc file usefull for pychecker in leoPy.leo
    pylint the same thing.
    url's ...

    I have no idea if pychecker is safe to run on insecure code
    it will create a py and pyc or pyo and maybe a bak file in tmp
    hold me harmless or delete this now.
  ***************
  all paths below are woefully hardwired, you must edit them all.
  you may have to download pychecker and or pylint and install it too.
  ~EOT  wpp[s, this whole thing is breaking down. I forgot one other thing
  the import phase will cause the code to be run. this may or may not be a problem,
  adding a name == main if one doesnt exist might be better
  \nif __name__ == '__main__': pass
  which wont help unless all the indentation on executable lines are indented
  that is too much work I think.

  checking selected text or filenames of generated modules still usefull
  pylint still complaining it cant find the py in temp in sys modules
  may have to dig deeper into that as well
  adding tempdir where the file is doesnt seem to be enough for pylint
    

  for some reason only the @ is getting thru from exS in dynatest
  the re isnt commenting them out either. I HATE re's
  doh, comedy of errors again. forgot the * after .
  was testing date instead of data, misnamed single use varb.
  generated new macro idea to scan for those mistakes.

  have to tell it to skip from @ to @c as well
  
  the name verifyer re isnt workring yet. not fully implimented
     or maybe what is wanted is to take from the copy buffer
     makeatemp and run it thru pychecker then create a subnode with it
     usecsae, posting from c.l.py or from other artical
     handling @directives,
     if copy buffer has a valid path like name, use that
     take the selected text or body (eventually @other &amp; section ref too)
  

  checking plugins would have to add import pychecker; pychecker.pychecker()?
  
    have to abstract the get path thing out to return a tuple of 
    leo, python, scripts, site-packages
    so all macros can find and user only has to change one place
    

  
should   we insert # -*- coding: utf8 -*-
 at the top of the file? or cp1252 or mbswhatever if on windows
 should getscript have that option?
 and dyna does this in several places, need to cosolidate them into one place
    """
    data = fixbody(c,dynaput(c, []))

    if not data or len(data) == 0: 
        return

    tmpname = tmpfile #global or from copybuffer

    import re, os, sys



    #you might not have to fix leo/src either
    #better to get basepath or something, look it up later
    #one run and its in sys.path, sys.path is global for all leo's?
    #another append will be twice in there
    #Leo prepends its src dir but pychecker isnt finding it.

    #this could be trouble on nix or mac. YOYO
    #might not even be necessary in the app, maybe some other
    #if sys.platform[:3] == 'win':
        
    oldpSath = sys.path[:]
    #these changes will be compounded at every run of the script

    if not leosrc in sys.path:
        sys.path.append(leosrc)

    if not g.os_path_split(tmpname)[0] in sys.path:
        sys.path.append(g.os_path_split(tmpname)[0] )
        
    

    g.es('writeing tmpname', tmpname )
    fo = file(tmpname,'w')
    fo.writelines(data + "%s#e%s"%(EOLN, EOLN, ))
    fo.close()
    
    if doreindent:
        g.es('running reindent', py + reindent + tmpname )
        out, err = runcmd(py + reindent + tmpname)
        for x in (out + err).splitlines():
            g.es(x)
        
    g.es('running pychecker', py + pycheck + tmpname )
    out, err = runcmd(py + pycheck + tmpname)
    for x in (out + err).splitlines():
        g.es(x)

    if dopylint:
        pylname = g.os_path_split(tmpname)[1][:-3] #cut off .py
        g.es('pylint module', pylname )
        pylint = \
        " -c \"import sys; from logilab.pylint import lint;\
                   lint.Run([r\'%s\',])\" "%(pylname,)

        g.es('running pylint', py + pylint )
        out, err = runcmd( py + pylint)
        for x in (out + err).splitlines():
            g.es(x)
    
    if not g.app.dynaMvar.justpychecker:
        g.es('#source for ', tmpname, color='blue' ) 
        TextFile = file(tmpname)
        Text = TextFile.read()
        TextFile.close()
        g.es(Text)
    
    #should be restored even if error. oh well
    sys.path = oldpSath  #Leo discards this?

    g.es('done ', color='blue' ) </t>
<t tx="ekr.20050421093045.47">def dynaS_tim_one_crunch(c):
    """(c) selected text/body print
    bit of old code from tim peters,
    had to un-htmlify it, then uu.decode it. then un py1.5 it, quite a PITA.
    checks for single use variable and module names. 
    helps catch errors in python code

    write a file only if reindent enabled.
    it can generate alot of false positives.
    
   using the bugfix, slightly more complicated from a later post.
   double check the name polution, uses regex and string too
   woh, was not going to work or needs some updateing.
   more info is better than not hwhen trouble starts.
    its alot faster than you would think too.
~EOT
    might run the makatmp first to create the file and just parse it with this
    rather than pulling in the reindent call. few more lines, what the hell
    reindent doesnt fix to standard indentation. why do I keep thinking it does?
    OTOH, reindent proves the thing has correct syntax so may as well keep it

    have to wait till the last few bugs worked out of evaluator.
    could use to test against known methods and modules in use by the code
    could reduce the false positives.
    if you make the same mistake twice, its no longer unique. is that caught?

    try compile as a way to verify code will import? is it safe?

   patched in import keyword
   added dir(list,dict from the older version
   commented out __modules__ __builtins__ for now
   building a more complete keyword list is the holy grail
   of autocomplete and debuggers and code evaluators of all kinds.

----
    Tim Peters tim_one+msn.com    Thu, 27 Feb 97 09:00:30 UT 
    Attached is a Python program that reports identifiers used only once in a .py (text) file, except for keywords, builtins, and methods on dicts &amp; lists (&amp; the way to expand that set should be obvious). 
    This is much dumber than the other approaches on the table, but has the clear advantage that it's written &lt;wink&gt;, and catches things like "bound but never used" (including-- and this is a mixed blessing! --functions &amp; classes defined but not referenced in their file). ----
    """

    data = fixbody(c,dynaput(c, []))

    if not data or len(data) == 0: 
        return

    tmpname = tmpfile #global or from copybuffer?

    if doreindent:
        g.es('writeing tmpname', tmpname )
        fo = file(tmpname,'w')
        fo.writelines(data + "%s#e%s"%(EOLN, EOLN, ))
        fo.close()
    
        g.es('running reindent', py + reindent + tmpname )
        out, err = runcmd(py + reindent + tmpname)
        for x in (out + err).splitlines():
            g.es(x)

        o = file(tmpname)
        so = StringIO.StringIO(o.read())
        o.close()
    else:
        so = StringIO.StringIO(data + "%s#e%s"%(EOLN, EOLN, ))

    p = c.currentPosition(); 
    #made a caller to hide some of the globals
    Bugfixcrunch(so.readline, '%s '%p.headString()[:15])
    
    if not g.app.dynaMvar.justpychecker:

        g.es('#source for ', tmpname, color='blue' ) 
        
        so.seek(0, 0)
        #.read() and .readlines() doubled up because of \n\r on win
        for x in so.getvalue().splitlines(True):
            g.es(x, newline= false)
    g.es('done ', color='blue' ) </t>
<t tx="ekr.20050421093045.48">
def Bugfixcrunch(getline, headline='Ex'):
    """u04523p12:01:20  madifying use of globals with 
    calling functions bfcrunch embeded
    the origional crunch has alot of false positives
    
    &gt;Bugfix (RE: Patch to Tim Peters python lint)
    
     (that is, a quote followed by a backslash followed by
     a newline) &lt;/I&gt;&lt;BR&gt;&gt;&lt;i&gt; seems to cause an infinite
     loop... &lt;/I&gt;&lt;BR&gt;&lt;P&gt; More, *any* unclosed uni-quoted
     string fell into that loop -- continued  uni-quoted
     strings are a feature of Python I never used, so was
     blind to the  possibility at first; then conveniently
     convinced myself nobody else used that  misfeature
     &lt;wink&gt; either so I could ignore it.  I lose! &lt;P&gt;
     Attached version fixes that by treating uni-quoted
     and triple-quoted strings  pretty much the same [...]
    """

    [NOTE, CAUTION, WARNING, ERROR] = range(4)
    _level_msg = ['note', 'caution', 'warning', 'error']

    # The function bound to module vrbl "format_msg" defaults to the
    # following, and is used to generate all output; if you don't
    # like this one, you know what to do &lt;wink&gt;.
    
    def _format_msg(
          # the error msg, like "unique id"
          msg,
    
          # sequence of details, passed thru str &amp; joined with
          # space; if empty, not printed
          details = (),
    
          # name of source file
          filename = '???.py',
    
          # source file line number of offending line
          lineno = 0,
    
          # the offending line, w/ trailing newline;
          # or, if null string, not printed
          line = '',
    
          # severity (NOTE, CAUTION, WARNING, ERROR)
          level = CAUTION ):
        try:
            severity = _level_msg[level]
        except:
            raise ValueError, 'unknown error level ' + `level`

        g.es('%(filename)s:%(lineno)d:[%(severity)s]' % locals() )
        if details:
            from string import join
            g.es("%s:" % msg, join(map(str, details)) )
        else:
            g.es(msg)
        if line:
            g.es(line)
    
    format_msg = _format_msg
    
    # Create sets of 'safe' names.
    import sys

    _system_name = {}   # set of __xxx__ special names
    for name in """\
          abs add and
          bases builtins
          call class cmp coerce copy copyright
          deepcopy del delattr delitem delslice
              dict div divmod doc
          file float
          getattr getinitargs getitem getslice getstate
          hash hex
          init int invert
          len long lshift
          members methods mod mul
          name neg nonzero
          oct or
          pos pow
          radd rand rdiv rdivmod repr rlshift rmod rmul ror
              rpow rrshift rshift rsub rxor
          self setattr setitem setslice setstate str sub
          version
          xor""".strip().split():
        _system_name['__' + name + '__'] = 1
    _is_system_name = _system_name.has_key

    import keyword
    
    _keyword = {}   # set of Python keywords
    for name in keyword.kwlist + ['as', 'str'] + dir(__builtins__) + \
            dir(list) + dir(dict):
        _keyword[name] = 1

    #builtins isnt the same from exec as from script outside Leo
    #maybe import builtins? same with methods if it even exists

    _builtin = {}   # set of builtin names
    """for name in dir(__builtins__) + sys.builtin_module_names:
        _builtin[name] = 1
    """
    _methods = {}   # set of common method names
    """for name in [].__methods__ + {}.__methods__:
        _methods[name] = 1"""
    
    _lotsa_names = {}   # the union of the preceding
    for dct in (_system_name, _keyword, _builtin, _methods):
        for name in dct.keys():
            _lotsa_names[name] = 1
    
    #del sys, name  #, dct string,  dict


    
    # Compile helper regexps.
    import regex
    
    # regexps to find the end of a triple quote, given that
    # we know we're in one; use the "match" method; .regs[0][1]
    # will be the index of the character following the final
    # quote
    _dquote3_finder = regex.compile(
        '\([^\\\\"]\|'
        '\\\\.\|'
        '"[^\\\\"]\|'
        '"\\\\.\|'
        '""[^\\\\"]\|'
        '""\\\\.\)*"""' )
    _squote3_finder = regex.compile(
        "\([^\\\\']\|"
        "\\\\.\|"
        "'[^\\\\']\|"
        "'\\\\.\|"
        "''[^\\\\']\|"
        "''\\\\.\)*'''" )
    
    # regexps to find the end of a "uni"-quoted string, given that
    # we know we're in one; use the "match" method; .regs[0][1]
    # will be the index of the character following the final
    # quote
    _dquote1_finder = regex.compile( '\([^"\\\\]\|\\\\.\)*"' )
    _squote1_finder = regex.compile( "\([^'\\\\]\|\\\\.\)*'" )
    
    # _is_junk matches pure comment or blank line
    _is_junk = regex.compile( "^[ \t]*\(#\|$\)" ).match
    
    # find leftmost splat or quote
    _has_nightmare = regex.compile( """["'#]""" ).search
    
    # find Python identifier; .regs[2] bounds the id found;
    # &amp; it's a decent bet that the id is being used as an
    # attribute if and only if .group(1) == '.'
    _id_finder = regex.compile(
        "\(^\|[^_A-Za-z0-9]\)"  # bol or not id char
        "\([_A-Za-z][_A-Za-z0-9]*\)" ) # followed by id

    #del regex, keyword
    &lt;&lt; bfcrunch &gt;&gt;
    bfcrunch(getline, filename= headline)
</t>
<t tx="ekr.20050421093045.49">def bfcrunch(getline, filename='???.py' ):
    # for speed, give local names to compiled regexps
    is_junk, has_nightmare, id_finder, is_system_name = \
        _is_junk, _has_nightmare, _id_finder, _is_system_name

    end_finder = { "'": { 1: _squote1_finder,
                          3: _squote3_finder },
                   '"': { 1: _dquote1_finder,
                          3: _dquote3_finder }
                 }

    multitudinous = {}  # 'safe' names + names seen more than once
    for name in _lotsa_names.keys():
        multitudinous[name] = 1

    trail = {}  # maps seen-once name to (lineno, line) pair
    in_quote = last_quote_lineno = lineno = 0
    while 1:
        # eat one line
        where = lineno, line = lineno + 1, getline()
        if not line:
            break
        if in_quote:
            if in_quote.match(line) &lt; 0:
                # not out of the quote yet, in which case a uni-
                # quoted string *must* end with a backslash
                if quote_length == 3 or (len(line) &gt; 1 and
                                         line[-2] == '\\'):
                    continue
                format_msg( "continued uni-quoted string must \
end with backslash",  # making this line its own test case &lt;wink&gt;
                            filename=filename,
                            lineno=lineno,
                            line=where[1],
                            level=ERROR )
                # the source code is so damaged that more
                # msgs would probably be spurious, so just
                # get out
                return
            # else the quote has ended; get rid of everything thru the
            # end of the string &amp; continue
            end = in_quote.regs[0][1]
            line = line[end:]
            in_quote = 0
        # get rid of junk early, for speed
        if is_junk(line) &gt;= 0:
            continue
        # awaken from the nightmares
        while 1:
            i = has_nightmare(line)
            if i &lt; 0:
                break
            ch = line[i]    # splat or quote
            if ch == '#':
                # chop off comment; and there are no quotes
                # remaining because splat was leftmost
                line = line[:i]
                break
            else:
                # a quote is leftmost
                last_quote_lineno = lineno
                quote_length = 1  # assume uni-quoted
                if ch*3 == line[i:i+3]:
                    quote_length = 3
                in_quote = end_finder[ch][quote_length]
                if in_quote.match(line, i + quote_length) &gt;= 0:
                    # remove the string &amp; continue
                    end = in_quote.regs[0][1]
                    line = line[:i] + line[end:]
                    in_quote = 0
                else:
                    # stuck in the quote, but anything
                    # to its left remains fair game
                    if quote_length == 1 and line[-2] != '\\':
                        format_msg( 'continued uni-quoted string \
must end with backslash',
                                    filename=filename,
                                    lineno=lineno,
                                    line=where[1],
                                    level=ERROR )
                        # the source code is so damaged that more
                        # msgs would probably be spurious, so just
                        # get out
                        return
                    line = line[:i]
                    break

        # find the identifiers &amp; remember 'em
        idi = 0     # index of identifier
        while 1:
            if id_finder.search(line, idi) &lt; 0:
                break
            start, idi = id_finder.regs[2]
            word = line[start:idi]
            if multitudinous.has_key(word):
                continue
            if trail.has_key(word):
                # saw it before; don't want to see it again
                del trail[word]
                multitudinous[word] = 1
            else:
                trail[word] = where
                if word[:2] == '__' == word[-2:] and \
                   not is_system_name(word):
                    format_msg( 'dubious reserved name',
                                details=[word],
                                filename=filename,
                                lineno=where[0],
                                line=where[1],
                                level=WARNING )

    if in_quote:
        format_msg( 'still in string at EOF',
                    details=['started on line', last_quote_lineno],
                    filename=filename,
                    lineno=lineno,
                    level=ERROR)

    inverted = {}
    for oddball, where in trail.items():
        if inverted.has_key(where):
            inverted[where].append(oddball)
        else:
            inverted[where] = [oddball]
    bad_lines = inverted.keys()
    bad_lines.sort()    # i.e., sorted by line number
    for where in bad_lines:
        words = inverted[where]
        format_msg( 'unique id' + 's'[:len(words)&gt;1],
                    details=words,
                    filename=filename,
                    lineno=where[0],
                    line=where[1],
                    level=CAUTION )
</t>
<t tx="ekr.20050421093045.50">#show in the main menu</t>
<t tx="ekr.20050421093045.51">""" if you runthis script on itself it can get infinate on you.
not anymore, but if you do get some recursion in your script,
  if you have a console hit ^C once. save your work often.
  python -i leo your.leo is how to get the console
 @test error reporting seems to go only to the console as yet.
 
 also import of leo* files might be a problem. 
 best used in named sections for functions, 
 you can also put the doc under test in its own node.
 you can also put the code in a named function in a subnode
 inside triple quotes so that the code still has syntax highlighting.
 care to include an extra &gt;&gt;&gt; #blank at the end if used this way.
 there are a few examples in dynacommon, sanitizte_ , ??

 fixed problem for py2.4, master removed from doctest __all__ 
verbosity= fails if leoTest 4.3a1 or earlier

can an option be the first time you click on a dyna item
it becomes a button. 
du_test, delfirstchar often you can't stop at just once.

0 passed and 0 failed. shoud report even if verbosity 0
"""
@

DO NOT LOAD leo*.py files with load_module it will crash Leo
leoTest.py is ok, is more or less a standalone to provide @test

Leo has a safeimport, once it stabalizes can use it for @file.
you must not run python -OO to use doctest! we detect this
-O is ok but note, this removes asserts, maybe counter productive!

uses parts of Rollbackimporter and fileLikeObject
many thanks to python cookbook providers and contributers
@c

import leoGlobals as g

&lt;&lt; Classes &gt;&gt;

def dynaZ_du_test(c):
    """(c= None) selected text/body docstrings + exec any code, print
    run a doctest unittest from a docstring in the script/selected 
    or run @test, see test.leo and leoTest.py
    or @suite all subnodes run.

 _function single underscored ignored in doctest 
 nested sub functions ignored in doctest,
 note also you have to double backslashes or use r raw triple quote strings.

    in your script you can use:
    g.tester.assertTrue(1 == 2, 'help unittest for other compares')
    you may have to import leoGlobals to use.
    which isn't a much of a deal breaker.
    
   care required because the script under test is exec with any sideeffects.
  if __name__ == 'mymod': will be run only under du_test doctest, not @test
  if __name__ == '__main__': standard way to guard from execution
  ~EOT  
    is redirecting the unittest error to log properly. 
    try append -v to argv, no luck.
    need setting for verbose in leoTest instead of hardwired call
    dyna_menu.ini verbosity=0/1/2

    must be in leoText. run w/console python -i open to see
    need version 2.3. convert a doctest into a unittest if use leoTest
    du_test doesn't create temp files and doesn't require @file
  seems I have developed a superstition about reload of sys and unittest. 
  but dammed if @test nodes stoped redirecting, so reloads are back in again!
  put all 3 back but one or the other might be enough. subject closed again.
  flip verbose now flips 0 to 1, 1 to 2 and 2 to 0, default starts out at 0

  is this wrongly bailing after the first failed test?
  sometimes you fix one test of a multiple then another failed test shows up!
    """
    import doctest
    import sys, os

    #1 leo globals, 0 forcefull sys, 2 underlying file stdio nfg
    use_Leo_redirect = 0 

    p = c.currentPosition() 

    #solve the doc/unittest infinate problem if run test on this node
    if p.headString().startswith('du_test-str'): g.es('infinate'); return

    c.frame.putStatusLine('testing '+ p.headString()[:25], color= 'blue')
    #c.frame.statusText.configure(
    #    state="disabled", background="AntiqueWhite1")


    if pyO[0] == 'O':
        g.es('assert disabled, use g.app._t.assert_()',
            color= 'tomato')
        #unreliable as yet...
        if 0 and dynaZ_du_test.__doc__ is None:
            g.es('YOU HAVE RUN python -OO \ndoctest fails, @test ok',
                color= 'tomato')

    s = '*'*10
    g.es(win_version, time.strftime(
        #why is this not available? 
        #g.app.config.body_time_format_string or 
        '%H:%M.%S %m/%d/%Y'
    ))
    

    g.es('%s \ntesting in %s\n%s\n'%(
        s, p.headString()[:25], s), color= 'DodgerBlue')

    reload(sys)
    #print sys.argv
    #if not '-v' in sys.argv:
    #    sys.argv.append('-v')
    #    g.es(sys.argv)

    &lt;&lt; n_redirect &gt;&gt;  #a bad named section is ignored when run
    #import/reload after redirect fixes redirect to log from unittest
    import leoTest
    import unittest

    reload(unittest)
    reload(leoTest)
    

    if p.headString().startswith('@test ') or\
         p.headString().startswith('@suite '):
        leoTest.doTests(all= False,
         verbosity= g.app.dynaMvar.verbosity) #

    else:
        &lt;&lt; DocTest &gt;&gt;

    &lt;&lt; f_redirect &gt;&gt;

    g.es('nonews is goodnews%s'%(g.choose(pyO[0] == 'O', ' +-O', ''),),
        color= 'DodgerBlue')

    #not sure why but this dissapears in a few seconds, 
    #maybe script end clears it? add an idle 200ms
    c.frame.putStatusLine(' fini ', color= 'DodgerBlue')
    #bad color here causes too much traceback
    #c.frame.statusText.configure(background="AntiqueWhite2")
</t>
<t tx="ekr.20050421093045.52">import os, sys, time

import StringIO #will this be cStringIO from dynacommon?

#__metaclass__ = type

#is sys.platform in less than py2.3?
if sys.platform[:3] == 'win':  
    if sys.version_info[:2] &gt;= (2, 3):
        win_version = {4: "NT", 5: "2K", 6: "XP",
            }[os.sys.getwindowsversion()[0]]
    else: win_version = 'NT' #os.name?
else: win_version = 'NM'

if sys.version_info[:2] &gt;= (2, 5): win_version += ' py&gt;24'
elif sys.version_info[:2] &gt;= (2, 4): win_version += ' py&gt;23'
elif sys.version_info[:2] &gt;= (2, 3): win_version += ' py&gt;22'
elif sys.version_info[:2] &gt;= (2, 2): win_version += ' py&gt;21'
elif sys.version_info[:3] == (1, 5, 2): win_version += ' py152'
else: win_version += ' py&lt;21'

#@suite unittestfromdoctest needs py2.3

try:
    g.tester
except AttributeError:
    import unittest
    class tester(unittest.TestCase):
        def runTest(self):
            pass
    g.tester = tester()  #now use g.tester in your script
    del unittest

#works exS but points to line 309 in unittest.py instead of here...
#does display in cpmtext better when used in an @test node
#g.tester.assertTrue(1 != 1, 'some message')

@others</t>
<t tx="ekr.20050421093045.53">class ExitError(Exception):
    """
    this is a cleaner way to exit a script
    raise SystemExit or something else causes much traceback
    so does this but maybe can solve that eventually
    maybe del frames from sys.exception
    also may be called after printing trace from real error
    """
    def __init__(self, value= 'Script decided to bail\n'):
        self.value = value

    def __str__(self):
        return `self.value`
</t>
<t tx="ekr.20050421093045.54">"""aspncookbook/82234
Importing a dynamically generated module
by Anders Hammarquist
Last update: 2001/10/17, Version: 1.0, Category: System
This recipe will let you import a module from code that is dynamically
generated. My original use for it was to import a module stored in a
database, but it will work for modules from any source.
had to add \n and chg name module and del if already in modules
"""

def importCode(c,code, name, add_to_sys_modules= 0):
    """
    Import dynamically generated code as a module. code is the
    object containing the code (a string, a file handle or an
    actual compiled code object, same types as accepted by an
    exec statement). The name is the name to give to the module,
    and the final argument says wheter to add it to sys.modules
    or not. If it is added, a subsequent import statement using
    name will return this module. If it is not added to sys.modules
    import will try to load it in the normal fashion.

    import foo

    is equivalent to

    foofile = open("/path/to/foo.py")
    foo = importCode(c,foofile, "foo", 1)

    Returns a newly generated module.

    tried to inject a sample unittest sub class
    just to get assert_ and maybe the other tests automatically
    it is shown in the verbose though doctest can be told to ignore.
    next problem, if the test class is injected first, 
    the scripts first docstring is no longer the __doc__ of the module
    if its injected last then _t is undefined...
    do I exec it first to get the doc, then set mymod.__doc__ = doc?
    cant have any code before the doc. might be an acceptable price to pay
    but unittest also doesnt know it then the scripts cant do both
    """
    import sys, imp
    try:
        if hasattr(sys.modules, name):
            del(sys.modules[name])
    
        modl = imp.new_module(name )  #was module

        #problem if run du_test now on new Leo4.3 scripts w/o c,g,p defined
        #shoulden't matter if its other than c,g,p then still errors?
        #might not even be necessary. had a script that was a getscript on itself
        try:
            exec code + '\n' in modl.__dict__ #du_test
        except AttributeError, e:
            g.es('%s\npossibly no doc string defined?'%(e,))
            g.g.es_exception(full= True)

        except NameError:
            p = c.currentPosition()
            d = {'c':c, 'p':p, 'g':g}
            g.es('*** defining c,g &amp; p ***')
            modl.__dict__.update(d)
            exec code + '\n' in modl.__dict__ #du_test w/c,g,p

        if add_to_sys_modules:
            sys.modules[name ] = modl

    except Exception:  #probably not exactly correct
        #g.es_exception()
        raise # ImportError
   
    return modl

if 0: # Example
    code = """
def testFunc():
    print "spam!"

class testClass:
    def testMethod(self):
        print "eggs!"

import unittest
class _t_(unittest.TestCase):
    def runTest(self):
        pass
_t = _t_()
"""

    m = importCode(c,code, "test")
    m.testFunc()
    o = m.testClass()
    t = m._t_()
    o.testMethod()

#</t>
<t tx="ekr.20050421093045.55"></t>
<t tx="ekr.20050421093045.56">#when run on @test print goes to console
#this simple redirect isnt working
#might need to set stdout/err more forcefully
#have the same problem with evaluator 
#and it screwsup log redirect after its done.
if use_Leo_redirect == 1:
    g.redirectStdout(); g.redirectStderr()

elif use_Leo_redirect == 0:
    sys.stdout = g.fileLikeObject() #'cato'
    sys.stderr = g.fileLikeObject() #'cate'

    #usually you dont want to do this,
    _sosav = sys.__stdout__
    sys.__stdout__ = sys.stdout
    _sesav = sys.__stderr__
    sys.__stderr__ = sys.stderr

elif use_Leo_redirect == 2: #c.l.py suggested
    #how ironic, I can remove the requirement for temp file
    #for docutils, but not for redirecting IO? dup needs fileno
    _sosav = sys.__stderr__
    #_sesav = sys.stderr
    def myfileno(self= None, *argy, **kews):
        print 'fn', argy, kews
        return 1
    #g.funcToMethod(myfileno, g.fileLikeObject, 'fileno')
    #g.funcToMethod(fileno, g.fileLikeObject)

    #g.fileLikeObject.fileno = myfileno
    f = g.fileLikeObject()
    #f.fileno = 1  
    f.fileno = myfileno  #()
    #not callable, when it is callable it says not attribute!
    #AttributeError: redirectClass instance has no attribute 'fileno'
    #it goes deeper than I first thought, the redirecttolog is still there


    #f = file('out.txt', 'a')
    #os.dup2(1, sys.__stderr__.fileno())
    os.dup2(f.fileno, sys.__stderr__.fileno())
    #os.dup2(f.fileno(), sys.stderr.fileno())
</t>
<t tx="ekr.20050421093045.57">
tmpimp = tmp = 'mymod' #name for the mock module

#g.es('mock writeing ', tmpimp)  #
fo = None

try:
    #could add a real/mock mode default mock, 
    #need to simulate file open for write+ since read will fail

    #fo = g.fileLikeObject(tmpimp) 
    script = g.getScript(c, p) #.strip()
    if not script: g.es('no script no test'); return

    #fo.write(script + "\n#e\n")
    #fo.seek(0, 0)  #rewind
    #fo.geek()  #test unknown attribute

except Exception:
    g.es_exception(full= False)
    raise ExitError  #be nice if this happened w/o extra exytax error

mod = None
try:

    #mod = __import__(fo, {}, {}, ["*"])
    mod = importCode(c,script, tmpimp, add_to_sys_modules= 1)

#could be other errors the way this is setup isnt there yet.
except ImportError, err:
    g.es('error importing tmpimp\n', tmpimp, color='tomato')
    g.es_exception()
    #except needs a break or maybe the doctest goes in else?
    #you cant mix except and finally...
    #an exit w/o rais would belp too still need to close the file

try:
    if mod:
        #need to tell it to ignore testing class t_

        doctest.testmod(mod, verbose= g.app.dynaMvar.verbosity,
             report= 1, globs=None, isprivate= doctest.is_private)
        #doctest.master.summarize()
        #ValueError: line 10 docstring xyz inconsistent leading whitespace: 
        #could mean need to double the backslashes like \\n or raw the docstring

        try:
            #no longer exposed in py2.4
            del doctest.master #bad idea if don't set to None
            doctest.master = None
        except Exception:
            pass

except Exception, err:
    g.es('error doctest mod\n', mod, color='tomato')
    g.es_exception()

if fo: fo.close() </t>
<t tx="ekr.20050421093045.58">#code below may cause problem if not run 
#if except traps further up
#needs its own try/finally
#is the __ mangling causing sys.__std* not to work corectly?

if use_Leo_redirect == 1:
    g.restoreStdout(); g.restoreStderr()

elif use_Leo_redirect == 0:
    oo = sys.stdout.get()  #read get()
    oe = sys.stderr.get()  #get()
    sys.stdout.close()
    sys.stderr.close()

    #if you didnt do this it wouldent need to be reversed
    sys.__stdout__ = _sosav
    sys.__stderr__ = _sesav

    sys.stdout = sys.__stdout__
    sys.stderr = sys.__stderr__

elif use_Leo_redirect == 2:
    #if this works eliminate choice 0
    oo = 'stderr'  #sys.stderr.read()  #read get()
    #oe = sys.stderr.get()  #get()
    oe =''
    #sys.stderr.close()
    #sys.stderr.close()
    sys.__stderr__ = _sosav
    #sys.__stderr__ = _sesav

if use_Leo_redirect != 1:
    for x in (oo + oe).splitlines():
        g.es('%s'%x, color= 'chocolate')</t>
<t tx="ekr.20050421093045.59">def dynaZ_htmlize(c, source= None, lang= 'plain', 
        writehead= True, show= True):
    r"""(c= None, source= None, lang= 'plain', 
        writehead= True, show= True)
        lang = report or ishtml or @language
    htmlize a script, popup webbrowser if show is True.
    if you set BROWSER env variable I think you can force
    a particular browser otherwise it uses your default.
    
    grabed parser fromfrom the moinmoin for python code, 
    default is to strip leo sentinal linesm leave node &amp; directives.

    you must edit in browser &amp; filename, 
       explorer c:\WINDOWS\TEMP\python.html
       or use %tmp%/htmlfile.html defined in dynacommon
    
    wonder still about how to solve encoding?
    rst/plain option not fully realized
    source-highlite still wants to make verbose to stderr?
    finish implementing EOLN and check in plain per body
    for new directives of wrap and lineending and language
    will any of this output survive various encoding
    will it validate as error free html?
 ~EOT
    &lt;&lt;more doc&gt;&gt;

    global EOLN had to import dynacommon
    is somewhat in need of some flow refactoring 
    and -quiet via verbosity
    another dependancie.
    and I'm checking for \n but using EOLN everywhere
    and will fail in less than py2.4 docutils no BLANKLINE
    if silvercity then will output fullhtml so far

    &lt;BLANKLINE&gt; doesn't exist for doctest less than 2.4 maybe will fail?
    not even sure its the proper result at this point either.
    a test that has the wrong output at least shows htmlize is runnable.
    
    &gt;&gt;&gt; dynaZ_htmlize(c,None, '\n', lang= 'checker', writehead=0, show=0)
    &lt;BLANKLINE&gt;
    &lt;BLANKLINE&gt;
    &lt;BLANKLINE&gt;
    &gt;&gt;&gt; dynaZ_htmlize(c,None, '\n', 'c', writehead=0, show=0)
    '&lt;pre&gt;&lt;tt&gt;\n\n&lt;/tt&gt;&lt;/pre&gt;\n'

    that one is output instead of returned
    the redirection of stdout shoulden't always happen if show=0

    would be nice if there were a find for variable/keywords not just text
    if source is one line and a URL maybe it should try to open it?
    

    adding a debugging switch to force ImportError fallback for testing
    should extend it to raise any specific errors that might be caught.
    going to have to rethink some of the testing under test.leo
    what will the namespace be, will g.app.dynaMvar.verbosity be defined?
    replace a few of the verboaity with if not source 
    want to get output feedback unless under test
    """
    &lt;&lt; initilize &gt;&gt;

    @others

    p = c.currentPosition() 
    fullhtml = err = out = None
    
    #to remind, really need to get keywords from Leo for some languages
    #then could handle odd languages better w/same parser
    #c.frame.body.colorizer.python_keywords.append("as")
    &lt;&lt;hopts&gt;&gt;

    if not source:
        lang = g.scanForAtLanguage(c, p)
    
        #str only fails is there is no current encoding for a char.
        #was erroniously thinking it always fails on Unicode.
        lang = str(lang).lower()

        #think this trips an assert if you pass a vnode    
        #redundant if @rst or plain and fails if the first node is empty
        #will have to redesign this flow
        #think getscript Leo4.3a4 doesnt do selected text w/directives?
    
        source = g.getScript(c, p)  #.strip()

    titl = "%s Leo %s script %s"%(
            p.headString()[:75], lang, hopts['timestring'])

    if hasattr(g.app.dynaMvar, 'htmlize_hilighter'):
        htmlize_hilighter = g.app.dynaMvar.htmlize_hilighter
    else: htmlize_hilighter = ''

    #if no path set getScript will return empty script, bug &lt;4.3a4
    #must get text other way and do another type of htmlize

    _sysstdsav = sys.__stdout__
    &lt;&lt;header plain footer&gt;&gt;
    try:
        if not source: raise ValueError

        # write colorized version to "python.html"/filename
        if show: 
            sys.stdout = open(hopts['filename'], 'wb')  # wt, wb, w
            g.es('output', p.headString())

        if lang in ['checker', 'report', ]:
            if writehead:
                sys.stdout.write(outheader())
            sys.stdout.write(plainout(source))

        elif lang in ['ishtml', ]:
            sys.stdout.write(source)
            fullhtml = 'y'

        elif lang in ['plain', 'rst', ] or \
              c.currentPosition().headString().strip()[:4] == '@rst':
            g.es('rst or %s , wait...'% lang)
            if writehead:
                sys.stdout.write(outheader())
            &lt;&lt; plain or rst &gt;&gt;

        elif lang == 'python':
            #this may no longer be advantagouus 
            #for every option to do first. and in the same order
            if writehead:
                sys.stdout.write(outheader())
            pars = Parser(source)
            pars.format(None, None)

        else:
            if g.app.dynaMvar.verbosity: g.es('hilight %s , wait...'% lang)
            #should decide somehow if can do the language
            #before commiting to a colorizer
            #plain should always be the fallback instead of first
            #this will get some reflow analisis

            source = stripSentinels(source, **hopts)

            if htmlize_hilighter and htmlize_hilighter != 'silvercity' :
                if writehead:
                    sys.stdout.write(outheader())
                &lt;&lt; src-highlight &gt;&gt;

            elif htmlize_hilighter == 'silvercity':
                &lt;&lt; silvercity &gt;&gt;

            else:
                if writehead:
                    sys.stdout.write(outheader())
                out = plainout(source)
        
            if out and show:
                sys.stdout.write(out)
            if err and g.app.dynaMvar.verbosity: 
                g.es(' ** '.join(err.splitlines()), color='tomato')

        #getmetrics(source)
        #tack on fileinfo as a comment
        #generate linkable index of keywords

        if fullhtml is None: #fix when can get it to do fragments
            if writehead:
                sys.stdout.write(outfooter())

        if show:     
            sys.stdout.close()
            sys.stdout = _sysstdsav #missing from org cgi.
    
        # load HTML page into browser, py2.2?
        if 0 and show:
            #might want this if to use other than default browser
            if os.name == "nt":
                os.system(r'explorer %s'%hopts['filename'])
            else:
                os.system("netscape %s &amp;"%hopts['filename'])
        elif 1 and show:
            import webbrowser
            webbrowser.open(hopts['filename'], new= 0) #

    except ValueError:
        g.es('no @path set, unsupported lang or empty script', 
                color= 'tomato')
        g.es(lang, p.headString())

    except Exception:
        g.es('htmlize malfunction?', color= 'tomato')
        g.es_exception(full= True)

    sys.stdout = _sysstdsav #twice is nice
    return out</t>
<t tx="ekr.20050421093045.60">you can tweek the title in the format and sanitize_ method
edit in your favorite style bits there too.
copy combined default.css silvercity.css where the filename will be

uses psyco if available.

script should be python, free from most syntax errors 
but accepts other languages 
and eveutually will use the keywords from that language
for now call another parser, silvercity if it exists.
sends @language css html perl c java and others to silvercity
(not fully tested in all languages for all syntax)

you can choose to colorize Names, Operators and Numbers seperately
or not at all by editing the htmlize macro hopts dictionary. 
Note: filesize larger if all 3 different than Text color.

needs Leo4.2 but is easily revertable.

could add linenumber and code metrics options.

can make it capable of reading writing a file as well?
wonder can I open browser and send it virtual html like in js?
might mod for class &amp; span instead of pre &amp; font

have to have path set for getScript to work. 
in new leo it will traceback if not saved once?
added some traps for empty script. 
meaningfull errors messages can't really be determiate
w/o some novice/expert clue from the system. 
have a few depandancies on dyna otherwise could be scriptButton
use python webbrowser.
add experimental code folding on def &amp; class for python only
 works in IE5 and firefox1 and shouldent affect others much
 might just be an extra header above def and class
 eventually will option it invisable for printing and copy&amp;paste
 enable/disable in the htmlize options bunch as with other options
 and there would be an ini option available too in the great beyond.
its cutting the def/class name and not enclosing the body of it

this guy took it to the next level, like the idea of color themes.
http://bellsouthpwp.net/m/e/mefjr75 /python/PySourceColor.py

more advanced stripSentinals suggested by EKR.
getconfig for ini options in hopts
need another option to looklikeLeo
show directives but not commented out, 
others w/o excess space, verbatim as it is etc
then can almost use extract named section to recreate nodes

if showdefaults, it doesn't take into account
the override factor in the defaults in hopts
complicated by Properties dialog not being able to handle them all
need to have more than one ini seletable as well
for various class or color schemes or some other way to select them
which css to embed. maybe get it from parsing a parent node or ???

seems to be taking little longer to popup browser in py2.4.1, not always.
if not python should check for silvercity, then one of the others
maybe need option default colorizer, otherwise there is too much guessing.
if neither then output as text. as it is now, temfile is written first
and only output as text if it is not one of silvercity languages
the others have more or less languages supported. a config nightmare.
check is @file and offer to produce file.xyz.html
check is @rst and if option dorst then send plain to docutils?
add option css/font and if css 
then eliminate dups is mandatory, css triples filesize.

option   silvercity or src-hilite for other than plain or rst or @rst
sent plain or rst to docutils if if available 
  else pre/pre w/wraping and headlines made of any node healines

there should be an @language rst to help with REST syntax 
possibly this would be a major pain just because.
idea for further study though. @rst for now good enough
and should not interfere with any rst* plugin

    seems obvious now, but call the plain text output if
    none of the colorizers can do it, just set silver!=didit &amp; break!
    also explore calling leo colorizer, does it act or can  it be made
    to return a pseudo body one can parse for Tk tags to get color info
    dl jthon port and see how that handles colorizer for various languages
    uses the combined default.css for rst and silvercity in dyna.txt

    another thing would be to extract the essential html generation parts
    so it could be called by rst for code-blocks using existing colorizer
    rather than internally attempting to ifdef around the problem.

       
- sgbotsford
What I want to do is print the outline showing 
the indents, with all outlines expanded, and optionally: 
*Don't print any of the body text. 
*Print the first N lines of body text in each node 
*Print all the body text. 
 
Nice to have: 
Outline and body text is in the respective fonts 
chosen in preferences. 



might have to define some lang options, 
lang=ishtml will assume is complete escaped html
 that will mean nothing can be controeled about the font or css?
 mabe should mean we extract the body
lang=checker
</t>
<t tx="ekr.20050421093045.61">#trick from aspn/299485
#htmlize is really plenty fast even on &gt;100k source, 
#but may as well see if this ever causes errors
#forgot to get some base timeings before and after.
#doesnt help the silvercity branch
import os, sys

base_class = object #is object in py2.2
if 1:
    try:
        # If available use the psyco optimizing
        #might psyco be enabled elsewhere and still work in here?
        import psyco.classes
        if sys.version_info[:2] &gt;= (2, 3):
            base_class = psyco.classes.psyobj
    except ImportError:
        pass 

import leoGlobals as g

import cgi, StringIO, re
import keyword, token, tokenize

#so can test, idealy done only if __doctest__ or in some test
from dynacommon import stripSentinels, sanitize_, runcmd, EOLN 


#this well could be version dependant
_KEYWORD = token.NT_OFFSET + 1
_TEXT    = token.NT_OFFSET + 2

_colors = {
    token.NUMBER:     '#483D8B', #black/darkslateblue
    token.OP:         '#000080', #black/navy
    token.STRING:     '#00AA00', #green 00cc66
    tokenize.COMMENT: '#DD0000', #red cc0033
    token.NAME:       '#4B0082', #black/indigo
    token.ERRORTOKEN: '#FF8080', #redred bare null does it
    _KEYWORD:         '#0066ff', #blue
    _TEXT:            '#000000', #black /is text fg color too
    '_leodir':        '#228B22', #directive, forest comment
    '_leosen':        '#BC8F8F', #sentinal, tan fade comment
    'bg':             '#FFFAFA', #snow
}</t>
<t tx="ekr.20050421093045.62">
class Parser(base_class):
    """ prep the source for any language
        parse and Send colored python source.
    """
	@others
</t>
<t tx="ekr.20050421093045.63">def __init__(self, raw):
    """ Store the source text.
    """
    #self.raw = string.strip(string.expandtabs(raw) )
    self.raw = raw.strip().expandtabs(4) 
    #might normalize nl too
    
    #need to know delim
    cmtdelim = '#'
    if lang != 'python':
        sdict = g.scanDirectives(c, p) 
        #obviously for other language have to check is valid
        #or need open/close comment. 
        #misses the opening html cmt, [0] only for singles
        #not sure I even know all the comment specifyers
        # its @, // html, ' are there any that screwup regex?
        cmtdelim = sdict.get('delims', ['#'])
        cmtdelim = cmtdelim[0] or cmtdelim[1]
    
    self.posspan = 0 #keep pos for collapse links on def &amp; class
    self.spancnt = 0
    
    self.fnd = re.compile(r"%s@\s*@+."%(cmtdelim,) )

    #g.es('using delim=', cmtdelim)
    
    #if hopts['stripsentinals']: almost always do something
    self.raw = stripSentinels(self.raw, **hopts)

</t>
<t tx="ekr.20050421093045.64">def format(self, formatter, form):
    """ Parse and send the colored source.
    """

    # store line offsets in self.lines
    self.lines = [0, 0]
    pos = 0
    while 1:
        pos = self.raw.find(EOLN, pos) + 1
        if not pos: break
        self.lines.append(pos)
    self.lines.append(len(self.raw))


    self.pos = 0
    text = StringIO.StringIO(self.raw)

    #use of \n not sure if will follow users lineending, but it should
    #anywhere htmlize adds it should use EOLN

    # parse the source and write it
    try:
        tokenize.tokenize(text.readline, self)
    except tokenize.TokenError, ex:
        msg = ex[0]
        line = ex[1][0]
        print "&lt;h3&gt;ERROR: %s&lt;/h3&gt;%s" % (
            msg, self.raw[self.lines[line]:])
</t>
<t tx="ekr.20050421093045.65">def __call__(self, toktype, toktext, (srow,scol), (erow,ecol), line):
    """ Token handler.
    """
    if 0: print "type", toktype, token.tok_name[toktype], "text",\
            toktext, "start", srow,scol, "end", erow,ecol, "&lt;br&gt;"


    # calculate new positions
    oldpos = self.pos
    newpos = self.lines[srow] + scol
    self.pos = newpos + len(toktext)

    # handle newlines
    if toktype in [token.NEWLINE, tokenize.NL]:
        print
        return

    if hopts['codefold']: 
        if self.posspan &gt;= self.pos:
            dospan = False
        else: dospan = True

    style = ''
    if toktype == tokenize.COMMENT:
        #setrip comment a little more complicated than sentinals
        #sentinals are always exactly one line, sometimes indented
        #comments after code would need to do NL?
        
        if toktext.lstrip().startswith('#@'):
            
            #if hopts['stripsentinals']: return  #do in __init__
                
            if self.fnd.findall(toktext):
                toktype = '_leodir'
            else:
                toktype = '_leosen'

    # send the original whitespace, if needed
    if newpos &gt; oldpos:
        sys.stdout.write(self.raw[oldpos:newpos])

    # skip indenting tokens
    if toktype in [token.INDENT, token.DEDENT]:
        self.pos = newpos
        return

    # map token type to a color group
    if token.LPAR &lt;= toktype and toktype &lt;= token.OP:
        toktype = token.OP

    elif toktype == token.NAME and keyword.iskeyword(toktext):
        toktype = _KEYWORD

        if hopts['codefold'] and toktext in ['def', 'class',]:
            dospan = True
            self.posspan = self.pos
            self.spancnt += 1
            tag = '%s%s'%(cgi.escape(toktext), self.spancnt,)
            sys.stdout.write("""\
&lt;a onclick="toggle(%s)" onmouseover="this.style.color='red'" onmouseout="this.style.color='black'"&gt;
&lt;h5&gt;%s&lt;img src="rarrow.gif" width="14" height="14"&gt;&lt;/h5&gt;&lt;/a&gt;
&lt;span ID=%s Style=Display:''&gt;
"""%(tag, tag, tag,  # None, none turns it off by default
    )) #need a 2pass to do this right, or look 1ahead to def/class name


    #this could be a decorator if run on py2.4 code from &lt;py2.4
    if toktype == token.ERRORTOKEN:
        style = ' style="border: solid 1.5pt #FF0000;"'

    #color = _colors.get(toktype, _colors[_TEXT])
    #instead use try to bail if no key defaulting to body fg color

    dofont = True
    try:
        color = _colors[toktype]
        sys.stdout.write('&lt;font color="%s"%s&gt;' % (color, style))
    except Exception:
        dofont = False

    sys.stdout.write(cgi.escape(toktext))
    if dofont: sys.stdout.write('&lt;/font&gt;')

    if hopts['codefold']: 
        #this is going to need allot more work to be reliable
        if dospan: #set when out of the def or class
            self.posspan = 0
            sys.stdout.write('&lt;/span&gt;')</t>
<t tx="ekr.20050421093045.66">#dyna would have read the ini already into a global Bunch
#that will be one of the options for htmlize
#its probably still possible to screwup the ini and dyna won't import

#need to use a getter in Bynch so nonesistant ivar returns None?
#possibly could set it with a get and default if doesn't exist property?

if not hasattr(g.app.dynaMvar, 'htmlize_filename') or\
         g.app.dynaMvar.htmlize_filename == 'default':
    filename = sys.modules['dyna_menu'].htmlfile
else:
    #and don't blame me or Leo if you make this a URI and get burned...
    filename = g.app.dynaMvar.htmlize_filename

if not hasattr(g.app.dynaMvar, 'htmlize_timestring') or\
        g.app.dynaMvar.htmlize_timestring == 'default':
    timestring = sys.modules['dyna_menu'].dynaB_Clip_dtef(c, ret= 'r')
elif g.app.dynaMvar.htmlize_timestring == 'leodefault':
    timestring = c.getTime(body=True)

else:
    #effectively a string because I'm not planning on using eval
    timestring = g.app.dynaMvar.htmlize_timestring

#decide which options to apply
#strip sentinals, comments, syntaxcheck for only python?
#then create alternate reality for c, c++, other language
#assume text only nodes are language plain? respect killcolor?
#to simplify the output 
#set True for noNUMBER, noOP or noNAME 
#to disable seperate colors for that entity.
# the more colors the bigger the output html
#have to switch to lowerrunoncase names, ini is not case sensitive for items
#could make another run thru to use the proper cased attributes but life is too short
#or make it a caseinsensitive Bunch subclass
#why isnt this a Bunch already?
hopts = {
  'codefold':False, #experimental, can be more confusing
  'stripcomments':False, #think this can still allow nodesents
  'stripsentinals':True,   #you can have directives if no sentinals.
  'stripnodesents': False, # False: leave node sentinels.
  'stripdirectives':False,
  #no color key, that item defaults to text color
  'nonumber':False,
  'noop':False,
  'noname':True,  
  'filename': filename,  #in dynacommon or ini
  'timestring': timestring,
   #path to silvercity css file, that might be too hard to debug.
}

#syncup ini with default hopts
for k,v in hopts.items():
    if k in ['filename', 'timestring', ]: continue
    #g.trace(k, v)
    if not hasattr(g.app.dynaMvar, 'htmlize_'+k.lower()): continue
    #g.trace('has :', getattr(g.app.dynaMvar, 'htmlize_'+k.lower()))
    #these should already be verified T/F
    hopts[k] = getattr(g.app.dynaMvar, 'htmlize_'+k.lower())

#much as I hate to admit it, the colors will have to be changable
#and color might be different for each language
#should allow external css or settable style options same way
#the Properties dialog only can handle a dozzen options on a large screen

#I know there is a way to do this inside the _color dict
#it would involve setting hopts before calling initilize
if hopts['nonumber']: del _colors[token.NUMBER]
if hopts['noop']:     del _colors[token.OP]
if hopts['noname']:  del _colors[token.NAME]</t>
<t tx="ekr.20050421093045.67">def outheader(fontface= 'Lucida,Courier New'):
    sx = []
    #this will have to get actual encoding but its a start
    meta = ['&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;']
    #append anyo ther meta required
    sx.append('&lt;html&gt;&lt;head&gt;%s%s&lt;title&gt;'%(EOLN, EOLN.join(meta),))
    sx.append('%s &lt;/title&gt;%s'%(sanitize_(titl), EOLN))

    #here would be a good spot for @noindent directive but skip a line
    #or build the string in the outermost indentation
    sx.append("""&lt;STYLE TYPE="text/css"&gt;&lt;!--
pre, H1 {color:%s; FONT-SIZE: 80%%; FONT-WEIGHT: bold; }
Text {background:%s;}
--&gt;&lt;/STYLE&gt;
&lt;SCRIPT LANGUAGE="JavaScript"&gt;&lt;!-- 
//Serenity Right Mouse Click Customisation
function toggle(e) 
{  
if (e.style.display == "none") 
	{
	e.style.display = "";
	 } 
else 
	{     
	e.style.display = "none";  
	}
}
//--&gt;&lt;/SCRIPT&gt;"""%(
       _colors[_TEXT], _colors['bg'])) #was both #cc9999

    sx.append('&lt;/head&gt;&lt;body text="%s" bgColor="%s"&gt;'%(
        _colors[_TEXT], _colors['bg']))
    sx.append('&lt;H3&gt;# %s&lt;/H3&gt;%s'%(cgi.escape(titl), EOLN,))
    sx.append('&lt;pre&gt;')  # style
    sx.append('&lt;font face="%s, courier"&gt;'%(fontface, ))

    return EOLN.join(sx)
    
def plainout(src):
    #g.es('bad or no hilighter language or option=', htmlize_hilighter)
    #return '%s%s%s'%(EOLN, cgi.escape(src), EOLN)
    return '%s%s%s'%(EOLN, src, EOLN)

def outfooter():
    sx = []
    sx.append('&lt;/font&gt;&lt;/pre&gt;')
    sx.append('&lt;/body&gt;&lt;/html&gt;')
    return EOLN.join(sx)
</t>
<t tx="ekr.20050421093045.68">
#do a linear node crawl, 
# htmlize @language nodes
# append docutils or plain text wrapped output
#can you want plain or rst and also not stripsentinals?
#might have to add option or flipper to not follow subnodes
#thats the theory anyway...  FIXME

#codeblock and latex not supported
#don't want to reimpliment rst2
#individual bodys are not getting enough &lt;Br&gt;
#collect all output and send to docutils once
#otherwise indexes and content links can't work
#have to insert some Rest at various points

try:
    import docutils
except:
    docutils = None
else:
    #have to investigate custom config files
    #please evolve faster docutils.
    import docutils.parsers.rst
    from docutils.core import Publisher
    from docutils.io import StringOutput, StringInput
    pub = Publisher()
    &lt;&lt; define code-block &gt;&gt;
 
current = c.currentPosition()
def outheadline(cur ):
    ''' eventually supply Rest command as well for headline '''
    hl = g.choose(cur.headString().startswith('@rst'), 5, 4)
    return '&lt;H%d&gt;%s&lt;/H%d&gt;%s'%(hl, cur.headString(), hl, EOLN )

sys.stdout.write(outheadline(current))

sx = []
for psib in current.self_and_subtree_iter():
    #sys.stdout.write(outheadline(psib))
    #need to add Rest directive for headline
    sx.append(outheadline(psib))

    s = psib.bodyString()
    #.. code-block:: Python
    #@ignore
    #need to process some directives
    #dynawrap defaults textwrap or will do Leo wrap
    #have to fixit do it returns rather than prints though
    #also check for @language &amp; few others and highlight
    #so will have to functionalize the highliters eventually
    #also might want some nodes line numbered, 
    #using docutils css on some nodes and on other elements 
    #H3 maybe should include a class=
    #subnodes should be indented? that could cause Rest errors

    sx.append(s)

s = EOLN.join(sx)
&lt;&lt; docutil out &gt;&gt;
sys.stdout.write(output)</t>
<t tx="ekr.20050421093045.69">#silvercity + fallback to code-block

try:
    import silvercity
except ImportError:
    silvercity = None

def code_format(value):
    html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n'
    raw = docutils.nodes.raw('',html%(value, ), format='html') 
    #(self, rawsource='', text='', *children, **attributes):
    return raw

def code_block(name,arguments,options,content,lineno,content_offset,block_text,state,state_machine):
    
    """Create a code-block directive for docutils.
    lifted from rst2 and attempt to use 
    in either src-hilite or silvercity while @language plain
    or provide own generator if neither active
    where is it listed which languages are supported?
    """
    
    # See http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252170
    language = arguments[0]
    if silvercity:
        module = getattr(SilverCity,language)
    
        generator = getattr(module,language+"HTMLGenerator")
        io = StringIO.StringIO()
        generator().generate_html(io, EOLN.join(content))
        code_format(io.getvalue())
    else:
        #can I convert to another directive here?
        raw = ['++ other-directive']
        raw += [name, arguments, options,]
        print `raw`
        raw = code_format(EOLN.join(raw + content))

    return [raw]
    
# These are documented at http://docutils.sourceforge.net/spec/howto/rst-directives.html.
code_block.arguments = (
    1, # Number of required arguments.
    0, # Number of optional arguments.
    0) # True if final argument may contain whitespace.

# A mapping from option name to conversion function.
code_block.options = {
    'language' :
    docutils.parsers.rst.directives.unchanged # Return the text argument, unchanged
}

code_block.content = 1 # True if content is allowed.
 
# Register the directive with docutils.
docutils.parsers.rst.directives.register_directive('code-block',code_block)</t>
<t tx="ekr.20050421093045.70">#here let docutils have the body, but what about
#previous Rest commands that might still be active?

# This code snipet has been mangled from code in rst2
#snipped from code contributed by Paul Paterson 2002-12-05.
if docutils and s.strip():
    pub.source = StringInput(source=s)

    # need to set output so doesn't generate
    #its own footers and headers on every other block
    #nowhere does it mention other options! 
    #docutils docs heal thyself.
    writer='html' ; enc="utf-8"
    #standalone, pep, python
    pub.set_reader('standalone', None, 'restructuredtext')

    pub.destination = StringOutput(pub.settings, encoding=enc)
    pub.set_writer(writer)

    
    try:
        output = pub.publish(argv=['--traceback']) #--traceback or ''
    except Exception:
        #docutils puts errors to stderr, not redirected
        g.es('ERRORS Found in rstText', psib.headString())
        output = s
else:
    #output = s.replace(' ', '&amp;nbsp').replace('\n', '&lt;Br&gt;\n')
    output = s

#till I get more docutil aware
output = output.replace('&lt;body&gt;','').replace('&lt;html&gt;','')
output = output.replace('&lt;/body&gt;','').replace('&lt;/html&gt;','')</t>
<t tx="ekr.20050421093045.71">@
does better job on java than silvercity and has more languages
what no elisp in a gnu language?

need to get the css option without the bloated size
which might mean a post processing step.
why can't I inject font color default on the command line?

sourceforge.net/sourceforge/gnuwin32/src-highlite-1.11-bin.zip win32
other systems will have to build or find their own

source-highlight -s cpp -f html $*
source-highlight -s java -f html $*
java, javascript, cpp, prolog, perl, php3, python, ruby, flex, changelog, lua, caml, sml, log)
       keyword blue b ;      for language keywords
       type darkgreen ;      for basic types
       string red ;          for strings and chars
       comment brown i ;     for comments
       number purple ;       for literal numbers
       preproc darkblue b ;  for preproc directives (e.g. #include, import)
       symbol darkred ;      for simbols (e.g. &lt;, &gt;, +)
       function black b;     for function calls and declarations
       cbracket red;         for block brackets (e.g. {, })
much nicer than silvercity and it does more langs
have to play w/the tags.j2h file for colors
not sure about the css option yet from htmlize but the file will be huge!


? -f html  --doc --tags-file="c:\UTIL\DLL\xtags.j2h" %N
-v source-highlight 1.11 Trying with... tags.j2h c:/progra~1/Src-Highlite/share/source-highlight/tags.j2h C:\UTIL/share/source-highlight/tags.j2h No tags.j2h file, using defaults ...
damm,. what ugly default colors source-highlight has
putting tags in $HOME and why don't they check there?

java and javascript are not equilevent
there is no jscript or javascript in Leo yet.
its turning into more and more of a rats nest.

sml out put for html is in a frame unviewable.
not sure what happens if there is no tags file
@c

if lang in [  #leo may not have all of these yet
       'csharp', 'c', 'c++', 'cpp',
        'css', 
      'htm', 'html', #
        'perlpod', 'perl', 
        'ruby',
        'sql',
        'xml',
        'xslt',
        'yaml',
        'elisp', 'php', 'java', 'rapidq', 'actionscript', 'css',
    ]:
    if lang in ['htm', 'html', 
                    'actionscript', 'css', ]: lang = 'sml'

    elif lang in ['java', 'rapidq',]: lang = 'javascript'
    elif lang in ['jscript', 'javascript',]: lang = 'javascript'
    elif lang in ['c', 'c++', 'cpp']: lang = 'cpp'
    elif lang in ['php', ]: lang = 'php3'
    elif lang in ['perlpod', 'perl',]: lang = 'perl'
    elif lang in ['elisp',]: lang = 'perl'

    #little foggy here, options for src-hilite might be different
    #than any other unknown and so should use hilighter options
    #but I have no other hilighter in mind yet, so punting.
    cmd = htmlize_hilighter

    #dont want it to create the file, send to stdout
    #
    #
    #have to account for quoted path with space in them and no comma?
    params = cmd.split(',')

    if len(params) &lt; 2:  #must be source-highlight
        params = ' -s %s -f html -T %s %s --tags-file=%s --no-doc '%( #-i %s
           lang, sanitize_(titl),
           g.choose(g.app.dynaMvar.verbosity != 0, '-v', ' '), #!''
            g.os_path_join(g.app.homeDir,'tags.j2h'),
            #tmpfile,  #source-highlight can accept stdin
            )  
    else:
        #not the best way to handle shell commands, but ok YMMV.
        params = ' '.join(params[1:])

    if g.app.dynaMvar.verbosity: g.es('running %s \n'% (cmd + params,) )
    out, err = runcmd(cmd + params, source + EOLN )

else:
    out = plainout(source)
</t>
<t tx="ekr.20050421093045.72">@
have to do a multitute of things for this to work
sc cant read script so have to write tmpfile
can view or redirect and use our viewer caller

default colors in silvercity.css need to be matched to Leo
@c

if lang in [  #leo may not have all of these yet
       'csharp', 'c', 'c++', 'cpp', # (C and C++)
        'css', # (Cascading Style Sheets)
      'htm', 'html', # HTML/PHP w/ JavaScript, VBScript, Python
        'perlpod', 'perl', # (Perl)
        #'python', # (Python)
        'ruby', # (Ruby)
        'smart_python', # (Python with styled strings)
        'sql', # (SQL)
        'xml', # (XML)
        'xslt', # (XSLT)
        'yaml', # (YAML)
        #basic &amp; java? missing. might send java as c?
        'elisp', 'php', 'java', 'rapidq', 'actionscript', 'css',
    ]:
    if lang in ['htm', 'html', 'php', 'java', 'rapidq',
                    'actionscript', 'css', ]: lang = 'html'
    elif lang in ['c', 'c++', 'cpp']: lang = 'cpp'
    elif lang in ['perlpod', 'perl',]: lang = 'perl'
    elif lang in ['elisp',]: lang = 'perl'


    #dont want it to create the file, send to stdin
    #should btry
    # won't complain if it isn't the right extension
    g.es('writeing tmpname', tmpfile )
    fo = file(tmpfile, 'w')
    fo.writelines(source + "%s"%EOLN)
    fo.close()
    
    cmd = g.os_path_join(pypath, 'Scripts', 'source2html.py')

    #dont want it to create the file, send to stdout
    #" --view %N  %N.html"
    # --css=file copy silver_city.css where the filename will be
    # source2html.py --list-generators
    params = ' --generator=%s --title=%s --css=default.css %s'%(
       lang, sanitize_(titl), tmpfile,)  

    if not g.os_path_exists(cmd):
        g.es('cant find source2html install silvercity')
        print 'cant find source2html from silvercity'

    else:

        if g.app.dynaMvar.verbosity:
            g.es('running silvercity \n', py + cmd + params )
        out, err = runcmd(py + cmd + params )
        fullhtml = 'FIXME'
else:
    out = plainout(source)

</t>
<t tx="ekr.20050421093045.73">def dynaZ_restoreStd(c):
    """(c) 
    every now and again run this if prints are blocked"""
    import leoGlobals as g
    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()
    g.redirectStderr()
    g.redirectStdout()

    g.restoreStdout()
    g.restoreStderr()
</t>
<t tx="ekr.20050421093045.74">def dynaZ_del_first_char(c):
    """(c) selected text print/paste
    del first char in the line
    abstracted everything get/insert related to dynaput
    del_2nd_char would occasionally be usefuil

    applying the logical reverse, what about an add first char?
    might use that to comment out a section of code
    always remembering to have something selected &amp; copyed could get to be a pain
    decided best to have that in another macro, using dynaplayer
    could defl 2 at a time, but make one at a time changes 
    so you could undo one if you only want one. usually its 4 for me anyway.

    """
    newSel = dynaput(c, [])
    if not newSel: return
    
    try:
        newSel = str(newSel)
    except (UnicodeEncodeError, Exception):
        g.es_exception(full= False)


    sx = []
    for x in newSel.splitlines():
        sx.append(x[1:] + EOLN )

    dynaput(c, sx)
</t>
<t tx="ekr.20050421093045.75">#these get cascades and act on selected text and can print or paste
#choice of action is sometimes from the copybuffer too

#add one for Clip, to call a macro and tell it to work from the clipboard
#print or paste to the clipboard</t>
<t tx="ekr.20050421093045.76">def dynax_DQ3(c, repchar='Do', source= None):
    r'''(c) selected text print/paste
    has its own cascade in dyna menu and the choices act directly.
    or you choose DQ3 to use what is in the clipboard as a pair.
    
    enclose the selected txt in  whatever is in the copy buffer 
    gets put before and the matching after
    if '(' is in the copy then (selected) is put/
    (:) {:} [:] &lt;!--:--&gt; /*:*/  &lt;:&gt;
    currently no match if space before or after pair, but hope to fix that.
    
    special pairs.
    try/except  if/else &gt;&gt;&gt;/...

     chose SQ, DQ DQ3 SQ3 SHow Pairs
    is there a DQ2 SQ2?
    used for commenting out sections of code or to create docstrings

    have to have something selected to insert anything even an empty.
    if nothing selected put a blank docstring.
    its not easy to have an empty copy buffer with the present Tk,
     copy or cut with nothing selected. no change takes place.
  ~EOT  does 'is None' work in py2.2?

    &gt;&gt;&gt; dynax_DQ3(None, repchar='/*', source='\\n ')
    ['/*\\n */']
    &gt;&gt;&gt; #
    #Leo expands \n from inside name section . this makes \n in return tricky
    #and rawstring makes it more counterintuitive but possible

    &lt;&lt;doctest&gt;&gt;

    might be usefull to backtrack to the previous line, insert enter
    that will put the insertpoint on the right indent
    maybe too much magic though
    add reverse dict to allow selection of either start or end char
    add try/except if/else
    subfunction the replace so can add doctest to it. same elsewhere.
    
    need to allow any space before or after the typical repchars
    and to use similar space before and then no extra space before the afterchar?
    might even make sense to force space after and before double comments
    added a Show pairs option

   repchar = g.app.gui.getTextFromClipboard()
 UnboundLocalError: local variable 'g' referenced before assignment
 why didn't I need an import as g before?
 could have a mode where only the begining or end of the line was added to.
 could have a line by line for that mode and normal mode begin/end each line.

    '''
    import leoGlobals as g  #if __name__ == 'mymod': du_test

    if source is None:
        newSel = dynaput(c, [])
    else:
        newSel = source

    #print '%r'%newSel
    if not newSel: 
        data = '\n'
    else:
        try:
            data = str(newSel)
        except Exception:
            pass

    repdict = {'(':')', '{':'}', '[':']', '&lt;!--':'--&gt;', '/*':'*/', '&lt;':'&gt;'}
    #get cute and use a reverse dict if repchar in .values()
    revdict = dict([[v, k] for k, v in repdict.items()])

    #add some specialized sourounders, need to add to choice menu in putmenu
    repdict.update({'try':'except', 'if':'else', '&gt;&gt;&gt;':'...',})
    
    #could also use a method if # or //, then put at front of every line
    # could have a given repchar to signal get comment from @language dbl/sng
    #what if 2 anglebrackets, should 2 reverse angles be trailing?
    
    if repchar == 'Show':
        #import pprint
        #g.es( pprint.pprint(repdict), color= 'sienna3') 
        #pprint needs redirect, but how did doctest capture it?
        g.es( 'DQ3 pairs\n', repdict, color= 'sienna3')
        return


    #need something to reselect wtith the newsel inserted in case it was empty
    #in circular logic land

    if repchar == 'Do': #was hard to pass in '' from DQ3 menu
        repchar = g.app.gui.getTextFromClipboard()

    if not repchar or not newSel:
        repchar = '"""'

    if repchar in repdict.keys():
        rep2char = repdict[repchar]

    elif repchar in revdict.keys():
        #allow user to copy or either start or end char
        #output will be in the correct order of the pair
        repchar = revdict[repchar]
        rep2char = repdict[repchar]

    else: rep2char = repchar  #rep2char.reverse()?
 
    &lt;&lt; tripleline &gt;&gt;
    sx = []
    #   these may messup because they don't force proper indent
    #  for language another than python obviously you would need more
    #potential to read pairs and code to impliment them from ini?
    if repchar == 'try':
        sx.append(tripleline(
            repchar+':\n', data, rep2char+' Exception:\n',
                '', 'g.es_exception(full= True)\n'))

    elif repchar == 'if':
        sx.append(tripleline(
                repchar, data, rep2char+':\n',
                 ' 1 == 1:\n', 'pass\n'))

    elif repchar == '&gt;&gt;&gt;':
        sx.append(tripleline(
                repchar, data, '',
                 '', rep2char+'\n'))
    else:
        sx.append('%s%s%s'%(repchar, data, rep2char))
        
    if source is None: 
        dynaput(c, sx)
        return
    else:
        return sx
    if not newSel: g.es(''.join(sx) ) #life is too short</t>
<t tx="ekr.20050421093045.77">&gt;&gt; dynax_DQ3(None, repchar='Do', source="#")  #w/nothing selected
['#']

&gt;&gt;&gt; dynax_DQ3(None, repchar='Show ', source='')  #rmv spc to retest Show
['"""\n"""']
&gt;&gt;&gt; dynax_DQ3(None, repchar='/*', source="""\n """)  #Leo expands \n see in DQ3
['/*\n */']
&gt;&gt;&gt; dynax_DQ3(None, repchar='&gt;', source='hey')
['&lt;hey&gt;']
&gt;&gt;&gt; dynax_DQ3(None, repchar='--&gt;', source='hey')
['&lt;!--hey--&gt;']
&gt;&gt;&gt; dynax_DQ3(None, repchar='&lt;!-- ', source='hey')  #make this work any +-spc+-
['&lt;!-- hey&lt;!-- ']
&gt;&gt;&gt; dynax_DQ3(None, repchar='try', source='  goto 34')
['\n  try:\n     goto 34\n  except Exception:\n   g.es_exception(full= True)\n']
&gt;&gt;&gt; dynax_DQ3(None, repchar='if', source='  goto 3\n  pass\n') #multiline
['\n  if 1 == 1:\n     goto 3\n     pass\n\n  else:\n   pass\n']
&gt;&gt;&gt; dynax_DQ3(None, repchar='if', source='  goto 34') #space
['\n  if 1 == 1:\n     goto 34\n  else:\n   pass\n']
&gt;&gt;&gt; dynax_DQ3(None, repchar='if', source='goto 34') #nospace
['\n    if 1 == 1:\n        goto 34\n    else:\n        pass\n']
&gt;&gt;&gt; dynax_DQ3(None, repchar='&gt;&gt;&gt;', source=' goto 34')
['\n &gt;&gt;&gt;   goto 34\n   ...\n']
&gt;&gt;&gt; #</t>
<t tx="ekr.20050421093045.78">def tripleline(r1, s, r2, extra1='', extra2=''):
    """
    need to extract the leading space from data and match it
    #will tabs get converted to space? probably not
    #not ideal but should get you close enough
    &gt;&gt;&gt; tripleline('r1', 's', 'r2', extra1='e1', extra2='e2')
    '\\n    r1e1        s\\n    r2        e2'
    """
    spcs = g.skip_ws(s, 0)
    if not spcs: 
        spc = '    '
        spcs = 1
    else: 
        spc = s[0]

    sz = '\n%s%s%s'%(spcs*spc, r1, extra1, )

    for xz in s.splitlines(True):
        sz += '%s%s%s'%(spcs*spc, spc, xz,)

    sz += '\n%s%s'%(spcs*spc, r2,)


    sz += '%s%s'%(
            spcs*spc+spc, extra2,)
    
    return sz</t>
<t tx="ekr.20050421093045.79">def dynax_actions(c, act='lower', script= None):
    r"""(c= None, action) select text print/paste
    action def for macroless action on text or selected text 
    current actions are lowercase uppercase caps and reverse all the lines
    
    caps could easily only cap only the first of a line or of a sentance.
    I have no idea what reverse might be used for.
    rot13 is insecure, b64 as well but its your data.
    ~EOT   need dynatester for this one
     make a few slight transparent changes so can doctest it
     have to recheck in py2.2 because strings aren't iterable there
     py2.3 complains about strict in b64 py2,2 has neither b64 or ror13?

     why did I not see a tuple returned yesterday?
     py2.4 you can just a = codex.encoder and it worked
     going to have to reimpliment unokunebts si ut keaves off b64
     untill I can get the syntax correct
     have to use base64 module in less than py2.4
     and rot13.py in less than py2.3
     
   &lt;&lt;doctest&gt;&gt;
    
    """
    from dynacommon import EOLN
    import leoGlobals as g
    #this may cause trouble later pep245 
    _impliments__ = 'reverse upper lower caps base64 rot13'

    if script is None:
        newSel = dynaput(c, [])
    else: newSel = script
    
    if not newSel: return

    if act == 'reverse':
        sx = []
        for x in newSel.splitlines(True):
            x = list(iter(x))
            x.reverse()
            sx.append(''.join(x))
        sx.reverse()
    elif act == 'lower':
        #lower or upper or some normal string operation
        #x.act() isn't working like I hoped it would
        #maybe need str.lower  print dir('')
        sx = [x.lower() for x in newSel.splitlines(True)]

    elif act == 'upper':
        sx = [x.upper() for x in newSel.splitlines(True)]

    elif act[1:] == 'md5':
        import md5
        if act[0] == '&gt;': #encode
            sx = [md5.md5(x).hexdigest() for x in newSel.splitlines(True)]
        else:
            #you can supply your own algo for here...
            pass
    elif act[1:] in ['rot13', 'base64', 'hex']:
        &lt;&lt; codecs.lookup &gt;&gt;
    elif act == 'caps':
        sx = [' '.join([y.capitalize() for y in x.split(' ')])\
             for x in newSel.splitlines(True)]
    else:
        return script.splitlines(True)

    if script is None:
        dynaput(c, sx)
    return sx</t>
<t tx="ekr.20050421093045.80">&gt;&gt;&gt; dynax_actions(c,act='lower', script='testO@#\n45SIX')
['testo@#\n', '45six']
&gt;&gt;&gt; dynax_actions(c,act='uppeS', script='testO@#\n45SIX')
['testO@#\n', '45SIX']
&gt;&gt;&gt; dynax_actions(c,act='reverse', script='testO@#\n45SIX')
['XIS54', '\n#@Otset']
&gt;&gt;&gt; dynax_actions(c,act='caps', script='test !@#$ 123@#\nlist of things')
['Test !@#$ 123@#\n', 'List Of Things']
&gt;&gt;&gt; dynax_actions(c,act='&gt;base64', script='another-fun-toy\n\n')#-ly y'rs
['YW5vdGhlci1mdW4tdG95Cgo=\n']
&gt;&gt;&gt; dynax_actions(c,act='&lt;base64', script='YW5vdGhlci1mdW4tdG95\n\n')
['another-fun-toy']
&gt;&gt;&gt; dynax_actions(c,act='&gt;rot13', script="Hello World !\n")
['Uryyb Jbeyq !\n']
&gt;&gt;&gt; dynax_actions(c,act='&lt;rot13', script='Uryyb Jbeyq !\n\n')
[u'Hello World !\n\n']
&gt;&gt;&gt; dynax_actions(c,act='&gt;hex', script='test\n')
['746573740a']
&gt;&gt;&gt; dynax_actions(c,act='&lt;hex', script='746573740a')
['test\n']
&gt;&gt;&gt; dynax_actions(c,act='&gt;md5', script='neato')
['9c53098eeab0c2457972453bae3248ff']
&gt;&gt;&gt; #</t>
<t tx="ekr.20050421093045.81">import codecs
#could possibly say actor = '',decode?
#should just import base64 for all
ac = None

if act[0] == '&gt;': #encode
    try:
        actor = codecs.lookup(act[1:])[0]
        #actor = codecs.getencoder(act[1:])
        #actor = g.toEncodedString
    except LookupError:
        if act[1:] == 'base64':
            try:
                ac = __import__(act[1:])
                ac.encodestring
            except (Exception, ImportError):
                g.es_exception(full= True)
                return
        elif act[1:] == 'rot13':
            try:
                ac = __import__('rotor')
                ac.encodestring
                rt = ac.newrotor(s, 12) 
                actor = rt.encrypt
                ac = None
            except (Exception, ImportError):
                g.es_exception(full= True)
                return
        else:
            return

elif act[0] == '&lt;': #decoder
    try:
        if ac is None: #decoder
            #actor = codecs.lookup(act[1:])[1]
            #actor = g.toUnicode  #
            actor = codecs.getdecoder(act[1:])
        else:
            actor = ac.decodestring

    except (Exception, LookupError):
    
        if act == '&lt;rot13':
            g.es('try import rotor')
            return
        g.es_exception(full= True)
        return
try:
    if ac is None:
        s = actor(newSel)
    else:
        s = actor(newSel, act[1:])
    #can they possibily be serious sometimes returning tuple?
    if isinstance(s, tuple):
        #g.es('converted chars %s only %s'%(len(newSel), s[1]))
        s = s[0]

except (Exception, LookupError, AssertionError):
    #g.es_exception(full= True)
    return

sx = [s]</t>
<t tx="ekr.20050421093045.82">def dynax_slashs(c, repchar='Do'):
    """(c) print/paste
    create a file monicur out of a path for IE or NS4
    it has its own cascade in dyna menu and the choices act directly.
    @url file://some.bat will work, not sure with %20 can add params
    or chg forward or backslash to the other. add "'s or %20 for spaces
    r04212p7:05 whiped up out of my head in few mins
    some editors can't handle path with forwardslashes, most can.
    dblclick on @url might not open IE for some reason but doesn't error.
    it might even be simpler to force a translation from one to the other
    as is you might have to transition thru several stops to get there.
    best use case is from \\ to /. or from either to file:/// so it is.
  ~EOT
    u04509p08:56 cvrt to dyna, somehow need to select which...
    using copy buffer or just flip b\/f slashes
    should add 8.3 to longfilename and back
    dblbs isn't working, it want to flip bs/fs if they exist whatever else
    should probably just output the path in every way possible
    folowed by space delimited words make into valid get url
    backslash doesn't seem to flip back from slash again
    """
    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)

    if repchar == 'Do': #
        repchar = g.app.gui.getTextFromClipboard()

    if not repchar in ['/', '\\' '\\\\', ':', '|', ' ',]:
        #if nothing in copy buffer flip the back/forward slashes
        if newSel.find('/') != -1:
            repchar = '\\'
        elif newSel.find('\\') != -1:
            repchar = '/'
        elif newSel.find('~') != -1:  #could be 8.3 also
            repchar = ':'
        
    sx = []
    for x in newSel.splitlines(True):
    
        if x == '': continue
    
        #check is valid, starts with drive : and has no non printables
    
        if repchar == ':':
            s =  x.replace('\\\\','\\').replace('\\','/').replace(':','|') 
            s = s.replace(' ','%20')
            sx.append('file:///' + s)
        elif repchar == '|':
            s = x.replace('file:///','').replace('|',':').replace('/','\\') 
            s = s.replace('%20',' ')
            sx.append(s)
    
        elif repchar == '\\\\':
            sx.append(x.replace('/','\\').replace('\\','\\\\') )
    
        elif repchar == '\\':
            sx.append(x.replace('/','\\') )
    
        elif repchar == '/':
            sx.append(x.replace('\\\\','\\').replace('\\','/') )
    
        elif repchar == ' ':
            sx.append(x.replace(' ','%20') )

        else:
            #sx.append(' " ",/,\\,:, %s'%(x,) )
            g.es(' err', x)
        
        g.es(' repchar= %r x=%r'%(repchar,x) )
        dynaput(c, sx)
</t>
<t tx="ekr.20050421093045.83">#for the plugin manager using the ini
#some of these should be dyna menu items anyway in case no plugin_menu
#calling them prototypes for now. so many switches so little time
#maybe can have some to flip styles &amp; colors for htmlize
#later add @settings compatible options 

#would be nice to find out how to assign a keyboard shortcut to dupe
#and a few others
#at this point maybe I could try a default bind?
#need a macro to look thru Leo config and see which key combos are free</t>
<t tx="ekr.20050421093045.84"></t>
<t tx="ekr.20050421093045.85">def cmd_flip_du_test_verbosity(): 
    """in some macros overall feeback on some operations.
    for @test nodes. 
    you still get traceback on syntax and other errors with just dots ==1
     ==2 is verbosity in unittest @test and @suite. slightly different
     either 1 or 2 is verbose for doctest and 0 is nothing except errors reported.
  ~EOT  requires change in leoTest, (added Leo4.3a2 no objections)
    
    validating config options hasn't been implimented yet either
    can I call a more general flipper for other vars too?
    can there be a cascade of flip vars in plugin_menu?
    """
    g.app.dynaMvar.verbosity += 1
    # is 1 or 0? True or False not sure 2.2 even has this option too?
    #this, like debug,  should increment in a connected range 0..3
    g.app.dynaMvar.verbosity = g.choose(
        g.app.dynaMvar.verbosity &gt;= 3, 0, g.app.dynaMvar.verbosity)
    g.es('now is', g.app.dynaMvar.verbosity)</t>
<t tx="ekr.20050421093045.86">def cmd_flip_Leo_debug(): 
    """0,1,2,3 for Leo debug switch
    careful, 3 starts pdb which has some unpredictable results
    maybe it should start rpdb or the debugger of your choice
    and in a seperate thread and in its own window.
    with no console open on windows this could hang Leo?
    no place even to type control C to signal a break.
    """
    g.app.debugSwitch += 1
    g.app.debugSwitch = g.choose(
        g.app.debugSwitch &gt;= 4, 0, g.app.debugSwitch)

    g.es('debugSwitch now is', g.app.debugSwitch)
    if g.app.debugSwitch &gt;= 2: g.es('pdb is now active on errors', color='tomato')</t>
<t tx="ekr.20050421093045.87">def cmd_flip_justPyChecker(): 
    """for tim1crunch makeatemp and pylint.
    1 is don't print source after running the check.
    """
    g.app.dynaMvar.justpychecker = g.choose(
        g.app.dynaMvar.justpychecker != 0, 0, 1)
    g.es('now is', g.app.dynaMvar.justpychecker)</t>
<t tx="ekr.20050421093045.88">def cmd_flip_onoff_c_gotoline(c): 
    """this totally violates the goto feature in executeScript
    presently broken if called from selected text.
      unselects the text and goes to the line in the full script.
    broken if error happens in another module
    and you are working in a subnode from a scriptButton
    you probably don't want to goto the top of the script.
      you might not even want or need to see the error
      by then its all too painful what the problem is
      the traceback is just a reminder it isn't fixed yet.
    this solves the one thing. 
    
    subsequent calls turn goto back on or off
    for those vanishingly fewer and fewer times when goto is wrong.
    mean time, take no prisoners. this works today.
  ~EOT   no one wants to see the error wrongly reported ever.
    the other thing is a problem with exec and python and tracebacks.
    compiling the script first would get you a better filename than &lt;SCRIPT&gt;
    but showing exec and leoCommands as part of the problem isn't helpful,
    to old and new alike. grin and bear it I guess.
    
    and why do I need to know Leo knows this:  
     'No ancestor @file node: using script line numbers'
    when gotolinenumber from Edit menu? (no problem if flipped off)

    no idea if c.goToLineNumber called from other scripts 
    or parts of Leo or other leos' will be adversely impacted if off.
    
    of course a config setting or option to turn off goto,
    option to turn off show error in context, would be better.
    """

    import leoGlobals as g
    atribs = cmd_flip_onoff_c_gotoline

    if hasattr(atribs, 'flip'):
        atribs.flip = not atribs.flip
    else:
        atribs.gotolinesave = c.goToLineNumber
        atribs.flip = True

    if atribs.flip:
        def dummygotoline(n, *a, **k):
            'goto is fliped off'
            pass
        c.goToLineNumber = dummygotoline
        g.es('turning off goToLineNumber', color= 'purple')
    else:
        c.goToLineNumber = atribs.gotolinesave
        g.es('turning on goToLineNumber', color= 'purple')

</t>
<t tx="ekr.20050421093045.89">def cmd_SetAsDefault(): 
    """
    set default would be too hard, 
    no interest in maintaing seperate per leo defaults.
    """
    #g.alert('no ini, check back in 5 minutes')
    #getConfiguration(rw= 'w') #force write
    g.es('no change at this time')
    
</t>
<t tx="ekr.20050421093045.90">def cmd_ShowDefault(): 
    """
    no need to show all the defaults actually, just user configurables
    shoud show hopts also and make a function so can have the intersection
    with the ini overriding hardwired default values. maybe next time.
    """
    g.es(g.app.dynaMvar)
</t>
<t tx="ekr.20050421093045.91">#there may be a problem with @test and others, I forget why
#that is annoying because I don't want to import to get access. may have to

#  getConfiguration
#  applyConfiguration
# test_Configuration(): 
import ConfigParser
@others

@
if __name__ == '__builtin__':
    #from dynacommon import *
    print 'should only see this from test'
    g.es('should only see this from test2')
    import leoGlobals as g
    import ConfigParser
    g.app.unitTesting = True
@c

def atest_Configuration(): 
    """ pack a config and see how apply applys it to a Mvar
    not ready to test
    just calling each macro would better check syntax errors 
    """ 
    
    #why does Bunch not have a deepcopy method?
    dynasve = g.app.dynaMvar.__dict__.copy()
    
    #otherwise you bork the current dyna
    dyna = g.app.dynaMvar = g.Bunch(nothing=0)

    try:
        print dyna
        print dynasve

        if g.app.unitTesting: 
            __file__ = 'dyna_menu.py'
    
        #permuter needed with all none and either section and use real defaults
        #some have to be defaulted and make sure the ini can't override them
        
        #how to build a config compatible dictionary?
        td = {'main':{'var1':1, 'var2':'2',}, 'htmlize':{}}
        #config = ConfigParser.ConfigParser(td)  #

        config = getConfiguration(
            g.os_path_join(g.app.loadDir,"..","plugins", "dyna_menu.ini"))
    
        if hasattr(config, 'items'): #
            #need something to iterate sections as well as items
            print config.items('main')
        
        applyConfiguration(config)
        
        #compare this config with getconfig and do in try/except
        #need to not screwup some existing dyba vars as well as add new ones
        #create and initilize and @settings not and rerun etc etc
        print dyna

    finally:    
        g.app.dynaMvar = dynasve.__dict__.copy()
    g.es(g.app.dynaMvar)
    
    return
    #does this need an element by element comparison?
    return g.es(liba != libc)
    
@ comment this out to test with g.app.unitTesting
if __name__ == '__builtin__':
    #@test based on assert fails if python -O, -OO
    assert test_Configuration() is not None</t>
<t tx="ekr.20050421093045.92">def getConfiguration(fileName): 
    """Return the config object
    should this look in homeDir first then plugins?   
    check __file__ works in py2.2 and under test.leo of plugin 

     Default values can be specified by passing them into the
     ConfigParser constructor as a dictionary. Additional
     defaults may be passed into the get() method which will
     override all others.

    maybe any @settings starting with the plugin name
    could be added to the config dictionary
     g.os_path_split(__file__)[1][:-3]+".ini" fails on XP
    """ 

    #if ini doesn't exist, should we create it?

    #g.trace(fileName)
    config = ConfigParser.ConfigParser() 
    config.read(fileName) 
    return config </t>
<t tx="ekr.20050421093045.93">def applyConfiguration(config):
    """plugin menu calls this after ini edit 
    and on first menu creation or first dyna click if I can swing it.
    
    True/False config saves as string? seems to work ok though
    also if non existant will be error, have to trap
    so default written in plugin can override if no attribute
    or attribute contains nonsense or whole ini or section doesn't exist.
    this addhockism has to go, 
    the ini format is 20 years old an im winging it here again.
    is it lowercasing items but not section names? what about values?
    seems to preserve case now, but decided better if dumenu doesn't
    this way lies maddness to debug otherwise. not everyone is a coder.

    another way to look at it is:
        if you don't want no errors, don't make any mistakes.
    all required options are hardwired defaulted 
    and should be ok if ini is wrong or missing
    
    """
    if not config: 
        config = getConfiguration(
            g.os_path_join(g.app.loadDir,"..","plugins", "dyna_menu.ini"))
    badini = ''
    dyna = g.app.dynaMvar
    &lt;&lt; anint(x) &gt;&gt;

    #should warn if no section header found?
    #not even sure all of these are properly guarded
    #if not appearing in the ini.

    sections = [] 
    if config.has_section('main'):
        sections += ['main'] 
    if config.has_section('htmlize'):
        sections += ['htmlize'] 

    if not hasattr(config, 'items'): #py22
        config.items = config.options

    items = g.flattenList([config.items(x) for x in sections])
    #g.es(items)

    for x in items:
        xl = x[0].lower()

        #still needs a little something
        #some of these would be better if anint defaulted 2 or 1 or 0
        #some should be defined even if nothing in ini or @settings
        if xl in ('tabstrip', 'verbosity', 'justpychecker', 'bugimport', ):
            setattr(dyna, xl, anint(x[1]))

        elif xl in ('filename', ):
            setattr(dyna, xl, x[1])


    if 'htmlize' not in sections: 
        return

    lx = """\
        hilighter timestring
        codefold stripcomments stripsentinals
        stripnodesents stripdirectives 
        noNAME noOP noNUMBER

        token_NUMBER      token_OP
        token_STRING      token_COMMENT
        token_NAME        token_ERRORTOKEN
        token_KEYWORD     token_TEXT
        token_LeoDir      token_LeoSen
        token_bg""".replace('\n',' ').split()

    #g.es(lx)
    for xini in [xl.strip().lower() for xl in lx]:
        x = 'bad'

        try:
            #this actually needs another step to be caseinsensitive
            #but well leave it to FIXME later as above was done
            x = config.get('htmlize', xini).lower()

        except (ConfigParser.NoOptionError, ConfigParser.NoSectionError, Exception):
            #g.trace('not found', xini, x)
            badini += '.'
            continue

        #no attribute or sometimes default means let dyna handle it
        if not x or x == 'bad': 
            #g.trace('not xImped', xini, x)
            badini += '.'
            continue

        elif xini.startswith('token_') or\
             xini in ('timestring', 'hilighter',): 
            #maybe validate is proper hex and has # or good color name
            #or whatever the user wants the user gets in this case
            xval = x

        #getboolean might work for these few
        #do people say y for yes but never n for no while I use n=on and f=off
        elif ('%s'%(x, )).strip().lower() in (
                'true', '1', 'on', 'n', 't', 'y', 'yes'):
            xval = True
        elif ('%s'%(x, )).strip().lower() in (
                'false', '0', 'off', 'f', '', 'no'): 
            xval = False

        else: 
            #must be user mispelling
            g.es('dyna ini not recognized', xini, x)
            badini += '.'
            continue

        setattr(dyna, 'htmlize_'+xini, xval)

    
    #might want to write the unnamed options commented out?
    #g.es(config.items('htmlize'))

    #g.es('current dyna configized w/%s defaulted values'% len(badini))
    #cmd_ShowDefault()</t>
<t tx="ekr.20050421093045.94">def anint(x):
    """
    &gt;&gt;&gt; [anint(x) for x in ('t', 'False', 2, 4, '5', 'n', '/')]
    [1, 0, 2, 4, 5, 1, 0]
    """
    try:  
        i = int(x)
    except ValueError:
        if x.lower() in ['true', 't', 'on', 'n', 'y', 'yes',]:
            i = 1
        elif x.lower() in ['false', 'f', 'off', '', 'no',]:
            i = 0
        else:
            i = 0
    return i</t>
<t tx="ekr.20050421093045.95">
#no user code besides cascade names tuple

def load_menu (tag,keywords):
    global dynaMvar

    c = keywords.get("c")
    cf = c.frame

    if dynaMvar is None:
        dynaMvar = g.app.dynaMvar = init_dyna(c)

        #maybe pospone ini read further, till first time dyna is clicked?
        if not hasattr(g.app.dynaMvar,'htmlize_filename'):
            dynaMvar.htmlize_filename = 'default'
            #initfilenames()
            applyConfiguration(None)
            quietwarnings()

    &lt;&lt; togprpa &gt;&gt;
    casnamtup = (
        'infos', #B   clipdtef, linenumber
        'mod text', #M
        'codeing', #S

        'pre/post', #A:y restoreST, htmlize,
        'zzzzz', #never gets here don't use past Z as a sentinal
    )

    table = [] #first table is built then some items use .add

    #need to option the menu names and expose a list of all menu text
    nu = dynaMvar.dynasMenu = c.frame.menu.createNewMenu("D&amp;yna","top")


    #eventually build some entries outside submenus
    #maybe the first and last letter save for this reason A:z
    #then work from copy lst with those items subtracted
    lst = dynaMvar.dynadeflst [:]
    lst.reverse() #makes no sense but we do it anyway.

    #you change the macro order you assume full responsinility
    #this could be fragile if you use less macros than are standard
    #know B_clipdtef is the first one add B_linenumber now B_help
    #picks the one to appear on main menu from the infos cascade
    #-4 currently is help sorted z..a
    try:
        table.append(
            (lst[menudefault][6:],None,
                lambda c = c, f = globals() [lst [menudefault]]: f(c)))
    except Exception:
        pass

    &lt;&lt; add items &gt;&gt;

    #nu.add_separator()  #gets out of synch w/table here
    table.append(('-',None,None))

    c.frame.menu.createMenuEntries(nu,table,dynamicMenu=True)

    dynaMvar.dynapasteFlag.set('print')

    nu.add_radiobutton(label='print',
            variable = dynaMvar.dynapasteFlag,
            command = togprpa(cf=cf))
    nu.add_radiobutton(label='paste',
            variable = dynaMvar.dynapasteFlag,
            command = togprpa(cf=cf))
    nu.add_radiobutton(label='doc',
            variable = dynaMvar.dynapasteFlag,
            command = togprpa(cf=cf))

    &lt;&lt; action &gt;&gt;</t>
<t tx="ekr.20050421093045.96">def togprpa(cf= cf, *a):
    """called from the menu to set status and Flag
    """
    def doprpa(*a):
        if 'print' == dynaMvar.dynapasteFlag.get():
            dynaMvar.dynapasteFlag.set('print') 
        elif 'paste' == dynaMvar.dynapasteFlag.get():
            dynaMvar.dynapasteFlag.set('paste') 
        elif 'doc' == dynaMvar.dynapasteFlag.get():
            dynaMvar.dynapasteFlag.set('doc') 

        cf.clearStatusLine()
        cf.putStatusLine("dynamenu " + dynaMvar.dynapasteFlag.get())

    return doprpa</t>
<t tx="ekr.20050421093045.97">#there better be at least one macro in lst and one cas entry
a = 0
ch = dynaMvar.dynadeflst [0] [4]
subtable = []
sub = None
#dynaMvar.dynadeflst.append('dynaz_') #add break sentinal

#the way Leo menu add works is 
#A. similar to Tk, B. incomprehensable C. it just "works"
#and why is submenu text  smaller? and how can't I change it.
#submenus seem to get sorted? forced to the top at some point.

#add items till the 5th char changes, then get next subname
#does not always degrade gracefully if you go out of bounds
for s in dynaMvar.dynadeflst:

    if s.startswith('dynax_'): continue

    if s [4] != ch or sub is None:
        #g.es('a=', a, 's=', s, `subtable`, color= 'orange')
        if sub:
            c.frame.menu.createMenuEntries(sub,subtable,dynamicMenu=True)
            subtable = []
            a += 1 #yada yada test end of cas
            ch = s [4]
        if s [4] &gt;= 'Z': break
        sub = c.frame.menu.createNewMenu(casnamtup[a],"dyna") #nu

    subtable.append(
        (s[6:],None,lambda c=c,f=globals()[s]: f(c)))

    lst.pop() #quick if not efficent

#append z entries, see above and below above
for s in lst:
    if s.startswith('dynax_'): continue #actions get cascades
    table.append(
        (s[6:],None,lambda c=c,f=globals()[s]: f(c)))
</t>
<t tx="ekr.20050421093045.98">#create a cascade and act on the actions presented
#why is the PMW error handler catching error in here
# and not Leo redirected to log?

@others</t>
<t tx="ekr.20050421093045.99">dynai = Tk.Menu(None, tearoff= 0, takefocus= 0 )

#for x in dynax_actions._impliments__.split(): dwim
for x in 'lower upper reverse caps &lt;base64  &gt;base64 &lt;rot13 &gt;rot13 &gt;hex &lt;hex &gt;md5'.split():
    dynai.add_command(label= x, 
          command= lambda x= x, c= c: dynax_actions(c, x) ) 

nu.add_cascade(menu= dynai, label= 'actions' )</t>
<t tx="ekr.20050421093045.100">dynai = Tk.Menu(None, tearoff= 0, takefocus= 0 )
for x in  'Do bs, : file, | !file, \\\\ Dbs'.split(', '):
    dynai.add_command(label= x, 
          command= lambda c= c, r= x.split()[0]:  dynax_slashs(c, r) ) 

nu.add_cascade(menu= dynai, label= 'slashs' )</t>
<t tx="ekr.20050421093045.101">#show whats in the clipboard, replace clipboard with left side of pair
#this isn't dynamically updated each menu invocation in plugin
#nu.add_command(label= "Clip=%r"%(
#            g.app.gui.getTextFromClipboard()[:6],), )
#changing to direct action instead of add choice to clipboard

dynai = Tk.Menu(None, tearoff= 0, takefocus= 0 )
for x in  'Do DQ3, \' Sq, " Dq, \'\'\' Sq3, """ Dq3, ( ), { }, [  ], /* */, &lt;!-- --&gt;, try /ex, if /else, &gt;&gt;&gt; /..., Show Pairs'.split(', '):
    dynai.add_command(label= x, 
          command= lambda c= c, r= x.split()[0]:  dynax_DQ3(c, r) ) 

nu.add_cascade(menu= dynai, label= 'DQ3' )</t>
<t tx="ekr.20050421093045.102">def init():
    """this is one less than one too many ok's."""
    ok = Tk and dynacom and not g.app.unitTesting
    if ok:
        if g.app.gui is None:
            g.app.createTkGui(__file__ )
    
        ok = g.app.gui.guiName() == "tkinter"
        if ok:
            import leoPlugins
            leoPlugins.registerHandler("create-optional-menus", load_menu)
    
            #no finer grained control than command1?
            #seems like this would slow things down conciderable
            #probably because wanted to catch tangle too
            # save1 should be less overhead
            leoPlugins.registerHandler("save1", timestamp)
            
            #plugin_signon reloads the plugin, can forgo that
            #g.plugin_signon(__name__)  # + __version__

            #have to lopkup how to enable these
            #.bind('&lt;Alt-z&gt;', lambda c= c: htmlize(c))
            #.bind('&lt;Alt-x&gt;', lambda c= c: dupe(c))

    return ok</t>
<t tx="ekr.20050421093045.103">"""not needed in pluginManager.txt
generate this file to exist in the Leo plugins directory.
you have to edit in your correct paths. &lt; set filenames &gt; section 

helper code your macro can call from dyna_menu or other Leo script/plugin.

check your sys.path that plugins is there before import
from dynacommon import *
was clone, is common to dynabutton, dynatester &amp; dyna_menu

some things common like the dynaBunch &amp; init you probably wont call

    rearrange things carelessly at your own peril

have to lazy eval the filename creation till after leoID is defined"""

#__all__ = 'tmpfile py pypath leosrc reindent pycheck2 pycheck  _caller_symbols deangle commafy stripSentinels sanitize_ leotmp scriptbody runAskYesNoCancelDialog init_dyna dycolors dynaBunch dynaerrout dynaerrline dyna_getsubnodes captureStd runcmd dynadoc dynaput dynaplayer pyO'.split()
#this needs its own dictionary dopylint doreindent

import sys, os
import leoGlobals as g
import Tkinter as Tk

__not_a_plugin__ = True
__version__ = '0.0139i' #u05417a10:51
@others

#depandance on sanitize_ and leoID
&lt;&lt; set filenames &gt;&gt;
#</t>
<t tx="ekr.20050421093045.104">
#possibly there are unicode anomalies in cStringIO?
try:
    import cStringIO as StringIO
except ImportError:
    import StringIO

try:
    True and False
except NameError:
    # match the 2.2 definition
    (True, False) = (1==1), (1==0)
    
#needed in several macros. what if import htmlize from menu?
try:
    enumerate
except NameError:
    def enumerate(seq):
        '''
        &gt;&gt;&gt; enumerate('123') #does 2.2 enumerate a string ok?
        [(0, '1'), (1, '2'), (2, '3')]
        '''
        import sys
        return zip(xrange(sys.maxint), seq)
    print 'now have enumerate'

try:
    sum #no sum in 2.2, not fully tested compatible
except NameError:
    from operator import add
    def sum(seq, m=0, add=add):
        '''
        &gt;&gt;&gt; sum([1, 4, 5, 2], 0)
        12
        &gt;&gt;&gt; sum([len(x) for x in ['12','23','45']], 0)
        6
        
        '''
        return reduce(add, seq, m)
    print 'now have sum'
    del add


</t>
<t tx="ekr.20050421093045.105">def _caller_symbols():
    """aspncookbook/52278
    Print an expression and its value, 
    along with filename and linenumber
    by Itamar Shtull-Trauring

    thanks I.! returns the callers callers globals and locals
    """
    try:
        raise StandardError
    except StandardError:
        t = sys.exc_info()[2].tb_frame
        return (t.f_back.f_back.f_globals, t.f_back.f_back.f_locals)
</t>
<t tx="ekr.20050421093045.106">@others
@
others not required except to enable du_test for all these subnodes
candidates for adding to g. or g.app at least while dyna running
have to weigh scripts and macros import common or just assume exists in g.
comafy, sanitize_ actually more usefull in site-packages/myutils.py
but I script and run nearly everything in Leo anyway.

0 failed.
all over htmlize and config isn't fully tested and the one test fails.
with py2.2, 2 places Expected: True Got: 1 same w/False in dyna_menu
but I don't think any code depends on True or False being 1 or 0
except for doctest.
</t>
<t tx="ekr.20050421093045.107">def deangle(s, repl=  '+'):
    """
    use repl so output can be pasted w/o appearing as named nodes to leo
    
    &gt;&gt;&gt; deangle( '&lt;%s'%'&lt; whatever &gt;&gt;')
    '&lt;+&lt; whatever &gt;&gt;'
    &gt;&gt;&gt; deangle('&lt; whatever &gt;&gt;')
    '&lt; whatever &gt;&gt;'
    &gt;&gt;&gt; deangle('''|\\ /!@=\\#$%,^&amp;?:;."\'&lt;&gt;`~*+''')
    \'|\\\\ /!@=\\\\#$%,^&amp;?:;."\\\'&lt;&gt;`~*+\'

    """
    if s.startswith('&lt;&lt;') and s.endswith('&gt;'+'&gt;'):
        return '&lt;%s%s'%(repl, s[1:])
    return s</t>
<t tx="ekr.20050421093045.108">def commafy(val, sep= ','):
    """Bengt , added sep
    mod to use leading seperator if . maybe
    also explore using locale instead. ok for now,
    could using specifyer like k so under 1024 is leading zero?
    &gt;&gt;&gt; commafy(2222)
    '2,222'
    &gt;&gt;&gt; commafy(2222, '.')
    '2.222'
    """
    sign, val = '-'[:val&lt;0], str(abs(val))
    val, dec =  (val.split('.')+[''])[:2]
    if dec: dec = '.'+dec
    rest = ''
    while val: val, rest = val[:-3], '%s%s%s'%(val[-3:], sep, rest)
    return '%s%s%s' %(sign, rest[:-1], dec)</t>
<t tx="ekr.20050421093045.109">def stripSentinels(s, stripsentinals=1,
           stripcomments=0, stripnodesents=1, stripdirectives=1, **ignored):
    r""" r for doctest, ignored so can pass **hopts from htmlize

    Strip sentinal lines from s. from EKR for test.leo htmlize.
    called by htmlize, disa and sfdots. 

    rewritten to save a few microseconds?, (in case anyone is still on a 486)
      lstrip instead of strip, no excess strip.
      save users newlines and join with '' instead of /n
      break out early if not a comment and stripping everything anyway.
      added raw/end_raw in addition to verbatim

    and not create a superfluous lines list. wherever it is found.
    OTOH, splitlines in the forloop still creates a list, so is a style point I guess.
    
    is startswith Unicode safe? is slice? slice over *with next up.

  &lt;&lt; essential doctesting &gt;&gt;
  not every possible corner case.

    should also have option to strip only comments other than sentinals
    should have option not to mangle node sentinals.
    
    possiblity of a python decorator comment out is very high
    to be sure, will later have to either do this all in the parser
    or get smarter about what is a directive and allow everything else
    no matter the strip setting. or label/warn about the conflict.
    if in &lt;py2.4 deco is a syntax error in the parser, thats fixable.
    and if Leo adds user configurable leadin chars will have to hack it in.

  Leo write logic adds verbatim, like right here.
    #@@c looks strange without coresponding #@+at

    first file opening and last closing node sentinals could probably be eliminated
    the @others and named section &amp; nodesents should be enough.
    skip namedsection,
    going to be screwed if a lang uses @ for comments
    
    add forced delims check for c,perl,java, html &amp; python
    if other @lang the first 2 are always #python, might have to fix that
    luckily all the tests passed before thought of this hack
    add @first/@last if simple on the same line 

    add another option to mangle namesection refrences &lt;+&lt; xyz &gt;&gt;
    to allow copy&amp;paste into a node without needing to edit them.

    """
    import leoGlobals as g
    result = []
    verbatim = 0
    first = last = ''

    cmts = ('//', '/*', ';', '&lt;!--')    
    for line in s.splitlines(True):
        s = line.lstrip()
        
        #much trickier if need to know @language &amp; delims
        # otherwise need seperate strippers. 
        #and gets especially screwy in mixed languages

        for icmt, x in enumerate(cmts):
            if not s.startswith(x):   continue
            cmt = cmts[icmt]
            break
        else:
            #print 'didnt find anything'
            cmt = '#'

        #should't hsve to recalc these each time
        tag1 = cmt+'@+node:'
        tag2 = cmt+'@-node:'
        n = len(tag1)

        &lt;&lt; linematch &gt;&gt;


    return ''.join([first]+result+[last])  #user might have other ideas about \n</t>
<t tx="ekr.20050421093045.110">&gt;&gt;&gt; s = '#@+leo=4\n#@+node:sent\nhay\n#@nonl\n#@-node: chk \n#@verbatim\n@deco\n#@  @others\n#cmt'
&gt;&gt;&gt; stripSentinels(s,0,0,0,0)
'#@+leo=4\n#@+sent\nhay\n#@nonl\n#@- chk \n#@verbatim\n@deco\n#@  @others\n#cmt'
&gt;&gt;&gt; stripSentinels(s,1,0,1,1)
'hay\n@deco\n#cmt'
&gt;&gt;&gt; stripSentinels(s)
'hay\n@deco\n#cmt'
&gt;&gt;&gt; stripSentinels(s,1,0,0,1)
'#@+sent\nhay\n#@- chk \n@deco\n#cmt'
&gt;&gt;&gt; stripSentinels(s,1,0,1,0)
'hay\n#@verbatim\n@deco\n#@  @others\n#cmt'
&gt;&gt;&gt; stripSentinels(s,1,1,1,1)
'hay\n@deco\n'
&gt;&gt;&gt; stripSentinels(s,1,1,1,0)
'hay\n#@verbatim\n@deco\n#@  @others\n'
&gt;&gt;&gt; stripSentinels(s,1,1,0,0)
'#@+sent\nhay\n#@- chk \n#@verbatim\n@deco\n#@  @others\n'
&gt;&gt;&gt; stripSentinels('#@+node:&lt;&lt;sent&gt;+&gt;\nhay\n#@- chk \n##@cmt',1,0,0,0)
'#@+&lt;+&lt;sent&gt;+&gt;\nhay\n##@cmt'
&gt;&gt;&gt; stripSentinels('')
''
&gt;&gt;&gt; stripSentinels('\n##\n')
'\n##\n'
&gt;&gt;&gt; o = {'stripcomments':0, 'stripsentinals':0, 'stripnodesents':0, 'stripdirectives':0, 'invalidarg':3} 
&gt;&gt;&gt; stripSentinels(s, **o)
'#@+leo=4\n#@+sent\nhay\n#@nonl\n#@- chk \n#@verbatim\n@deco\n#@  @others\n#cmt'
&gt;&gt;&gt; #this should be fixed to allow commented decorators that look like sentinals
&gt;&gt;&gt; stripSentinels(u'\r#@verb\r#cmt')
u'\r#cmt'
&gt;&gt;&gt; stripSentinels('#@@raw\nbetween raw\n#@@end_raw\n', 1,0,1,1)
'between raw\n'
&gt;&gt;&gt; stripSentinels('#@@raw\nbetween raw\n#@@end_raw\n', 1,0,1,0)
'#@@raw\nbetween raw\n#@@end_raw\n'
&gt;&gt;&gt; #mixed lang
&gt;&gt;&gt; stripSentinels(';@@raw\nbetween raw\n;@@end_raw\n//cmt')#, 1,0,1,1
'between raw\n//cmt'
&gt;&gt;&gt; stripSentinels('be\n;@@first &lt;...&gt;\n')#, 1,0,1,1
'&lt;...&gt;\nbe\n'
&gt;&gt;&gt; #

</t>
<t tx="ekr.20050421093045.111">#we'll assume no one would use verbatim\n#@@end_raw!
if verbatim &gt; 0 and not s.startswith(cmt+'@@end_raw'):
    if verbatim == 1: verbatim = 0
    result.append(line)
    continue

elif verbatim &gt; 0 and s.startswith(cmt+'@@end_raw'):
    verbatim = 0
    if not stripdirectives:
        result.append(line)

elif s.startswith(cmt+'@verbatim') or s.startswith(cmt+'@@raw'):
    verbatim = g.choose(s.startswith(cmt+'@verbatim'), 1, 2)
    if not stripdirectives:
        result.append(line)

elif not s.startswith(cmt+'@') and (not stripcomments and s.startswith(cmt)): 
    result.append(line)
    continue

#need a regex here could be #@[ \t]@VALIDDIRECIVE 
#\t unlikely to work in startswith, fix if you care about tabs
#otherwise could strip valid comments, but whould a real Leo user do that?
elif s.startswith(cmt+'@@') or s.startswith(cmt+'@ ') or\
     s.startswith(cmt+'@\t') or s.startswith(cmt+'@&lt;&lt;'):

    #actually might be a little more complicated first1 first2
    #might stripsentinal allow too
    if s.startswith(cmt+'@@first'):
        first = line[s.find(' ')+1:]; continue
    if s.startswith(cmt+'@@last'):
        last = line[s.find(' ')+1:]; continue

    #skip namedsection, could opt this in
    if stripsentinals and s.find('&lt;&lt;') != -1 and\
          s.find('&gt;&gt;') != -1: 
        continue
    if not stripdirectives:
        result.append(line)

elif s.startswith(tag1):
    if not stripnodesents:
        i = line.find(tag1)
        result.append(
          line[:i] + cmt+'@+' + line[i+n:].replace('&lt;&lt;','&lt;+&lt;'))

elif s.startswith(tag2):
    if not stripnodesents:
        i = line.find(tag2)
        result.append(
          line[:i] + cmt+'@-' + line[i+n:].replace('&lt;&lt;','&lt;+&lt;')) #.strip() happy

elif stripsentinals and s.startswith(cmt+'@'):
    continue

elif stripcomments and s.startswith(cmt):
    continue

else: #could this possibly be sentinals?
    #print s
    result.append(line)</t>
<t tx="ekr.20050421093045.112">def sanitize_(s):
    """ Leo's sanitize_filename is too aggressive and too lax
    origional regex from away.js
    this should make nobody happy equally.
    strips most characters, space and replaces with underscore, len&lt;128
    the doctest is in a subnode to allow syntax highlighting
    &lt;&lt; chk sanitize &gt;&gt;
    """
    #if not s: return
    import re

    res = re.compile(r"""
    [|\\ /!@=\#\$%,\x5E&amp;\x3F:;.\x22\x27&lt;&gt;`~\*\+\t\n\f\r\b\a]
    """, re.IGNORECASE | re.VERBOSE);  
    #  ^?"' \xnn,  [],(),{} ok, * not sure always ok

    #should test for unicode before str()
    return res.sub('_', s.strip()).replace('__','_')[:128]</t>
<t tx="ekr.20050421093045.113">the best of both worlds, doctest with syntax highlighting!
&gt;&gt;&gt; sanitize_("|\\ /!@=#$%,^&amp;?:;.\\"'&lt;&gt;`~*+")
'_____________'
&gt;&gt;&gt; sanitize_("")
''
&gt;&gt;&gt; sanitize_("@abc123[],(),{}")
'_abc123[]_()_{}'
&gt;&gt;&gt; #one comment line required when use subnode this way 
&gt;&gt;&gt; #to avoid doctest seeing node sentinals. don't ask...</t>
<t tx="ekr.20050421093045.114">def leotmp(name = None, tmp= None):
    """ attempt to divine the user tmp dir add to input name
    later prepend leoID unless no leoID flag or something
    print os.path.realpath(tempfile.tempdir) simpler?

    """
    #factor out later into combined find @home thing + leoID
    for x in ['tmp', 'temp', 'home']:
        try:
            tmp = os.environ[x]
            break
        except KeyError:
            pass
    else:
        tmp = './'

    if not g.os_path_isdir(tmp):
        tmp = './'

    if name is None:
        return tmp
    return g.os_path_join(tmp, name)

</t>
<t tx="ekr.20050421093045.115"></t>
<t tx="ekr.20050421093045.116">#previouslky fixscript selectscript and a few other things
#Leo always outputs sentinals now and follows subnodes
#and stripSentinals has more options
#and default is usually no tabs so expandtabs less critical

def fixbody(c,data=None):
    """ return script following subnodes and @others
    strips all sentinals
    if addscript its prepended to the output or something?
    """

    p = c.currentPosition()

    if not data:
        data = g.getScript(c, p)

    else: #selected text, so comment out directives in the @language
        data = selecbody(data, g.scanDirectives(c, p))

    if not data:  
        data = EOLN  #avoid error on empty script
    else:
        #could work the other way too if anyone wanted tabs.
        if hasattr(g.app.dynaMvar, 'tabstrip'):
            if g.app.dynaMvar.tabstrip: 
                data = data.expandtabs(g.app.dynaMvar.tabstrip)
    return data</t>
<t tx="ekr.20050421093045.117">def selecbody(data, sdict):
    r"""for commenting out directives in selected text.
    should start by commenting out all lines that start with @
    then strip sentinals. not going to follow @others?
    multiline delims probably not currently handled well
    have to add some tests 
    and get back into understanding the full use case.
    
    if selected starts after @ it should be commented anyway?
    
    backslash inside string literal, always skips the next char 
    \s might have to be \\s in raw?
    
    &gt;&gt;&gt; selecbody(None, {'language':'python'})
    
    &gt;&gt;&gt; selecbody('@language python\n#cmt', {'language':'python'})
    '#@language python\n#cmt'
    &gt;&gt;&gt; cdct = {'language':'java', 'delims': ('/*', '*/', '//')}
    &gt;&gt;&gt; selecbody('@language python\n#cmt', cdct)
    '/*@language python\n#cmt'

    have to do some reserch and fix this
    """
    if not data: return
    import leoGlobals as g

    cmtdelim = '#'
    if sdict['language'] != u'python':
        #obviously for other language have to check is valid
        # is more than one, then have to trail each line etc
        #was delims[0] not sure where that came from
        #coverage tool might have caught that so far untested
        #think it needs to be 0+1 if [2] is None
        #wouldv'e made more sense to always have the single in 0?
        cmtdelim = sdict.get('delims', ['#'])[0]
        
    import re
    datalines = data.splitlines(True)
    #g.es('data is %r'%(datalines,))


    #not sure why &lt;\&lt; works
    #does \s work like s, apparently not. 
    #though \s was only for rawstring w/o it misses indented @|&lt;
    repATang = re.compile('\s*&lt;\&lt;.*?&gt;&gt;.*')  #^$ 
    repATc = re.compile('\s*@.*', re.MULTILINE )
    #could use it on the whole string, ok line by line too.


    sx = []
    inATc = False  #a comment, not @c. poor name choice here.
    for x in datalines:
        
        if inATc:  #chances are Leo already does this somewhere
            #what about the foolish @color inside already started comment?
            #any @ is end of comment directive, 
            if x.startswith('@c'): #@ but its not stopping till @x!
                inATc = False
            sx.append('%s%s'%(cmtdelim, x) )
            continue

        if repATc.match(x):  #is start of comment
            if x == '@\n' or x.startswith('@ ') or \
                x.startswith('@\t') or x.startswith('@doc'):
                inATc = True
            sx.append('%s%s'%(cmtdelim, x) )
            continue

        if repATang.match(x): #is sectionname
            #would need to get more fancy here
            sx.append('%s%s'%(cmtdelim, x) )
            continue
        
        #if x == '\n': continue  #delete blank lines?

        sx.append(x)

    return ''.join(sx)
</t>
<t tx="ekr.20050421093045.118">#file leoTkinterGui.py
#import tkFont,Tkinter,tkFileDialog leoTkinterDialog
#class tkinterGui(leoGui.leoGui):
#when it works add some way to up the damm fonts!

def runAskYesNoCancelDialog(c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    import leoTkinterDialog
    d = leoTkinterDialog.tkinterAskYesNoCancel(c,
        title,message,yesMessage,noMessage,defaultButton)
    #d.configure(font=(("Lucida", "Console"), 12)) #nfg
#AttributeError: tkinterAskYesNoCancel instance has no attribute 'configure'
    #d.buttonsFrame.configure(font=(("Lucida", "Console"), 12)) #nfg
    #tryed buttonsFrame, frame, top, root...

    return d.run(modal=True)</t>
<t tx="ekr.20050421093045.119">import operator

def init_dyna(c, *a, **k):
    """same for both button and menu
    """    
    caller_globals, caller_locals = _caller_symbols()

    dynainst = dynaBunch(
        dynadefaultFlag = Tk.IntVar(),
        dynapastelst = ['print', 'paste', 'doc'],
        dynapasteFlag = Tk.StringVar(),
        #getsubnodes different in button &amp; menu, lst is a list of macros
        dynadeflst = dyna_getsubnodes(c,  globs= caller_globals),
        verbosity = 0, #0or1 just dots in @test from du_test
        justpychecker =  1, #show source after running pychecker &amp; pylint
        htmlize_hilighter = '',  #other language colorizer
        bugimport =  0,  #test fallbacks on ImportError
        )
    
    #print to start, paste over selection later

    dynainst.dynapasteFlag.set(dynainst.dynapastelst[0] )
    dynainst.dynadefaultFlag.set(0)
    return dynainst


class dynaBunch(object):
    """tieing an instance of dynaBunch to c.frame is responsibility of caller
    Bunch aspn python cookbook 52308
    point = Bunch(datum=y, squared=y*y, coord=x)
    if point.squared &gt; threshold:
        point.isok = 1
    in Leo From The Python Cookbook. used setattr &amp; getattr
     not sure of the ivar stuff for now
    repr lifted from c.l.py
    clear might still use, need gc tests
     http://www.norvig.com/python-iaq.html  (Struct class)

    in the sprit of one obvious way to do it.
    the idom appears to be to change the name of the class
    and hype it as a way to turn a dict into a lot of instance vars
    alot are taking credit for this idea through the years,

        """
    
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def __repr__(self):
        return '%s(%s)' % (self.__class__.__name__, '\n'.join(
            ['%s=%r' % keyval for keyval in self.__dict__.items()]))

    def __clear(self):
        g.es('attempting to clear')
        for key in self.__dict__.keys():
            g.es(';k=',key)
            del key
            g.es('deleted')
        g.es('\ndone clear')

    def set_ivars(self, c):
        """Set the ivars for the find, from searchbox
        might want to use this
        """
        # Modified from leoTkinterFind.set_ivars
        #for key in self.intKeys:
        #    setattr(c, key + "_flag", 0)  

    def ivars(self):
        return self.__dict__.keys()
        
    def __setitem__ (self,key,value):
        #allows access like dyna['dynalst']?
        return operator.setitem(self.__dict__,key,value)
        
    def __getitem__ (self,key):
        return operator.getitem(self.__dict__,key)

    """
    def load(infile):
        strng = infile.read()
        exec( 'bag = Bag(\n' + strng + ')' )
        return bag
    load = staticmethod(load)

    def save(self, outfile):"""</t>
<t tx="ekr.20050421093045.120">#Leo log Tk names &amp; HTML names and colors
dycolors = dynaBunch( 
    gAqua = 'aquamarine3',
    gBlack = 'black',
    gBlue = 'blue',
    gFuchsia = 'DeepPink3',
    gGray = 'gray48',
    gGreen = 'LimeGreen',
    gLime = 'PaleGreen2',
    gMaroon = 'maroon4',
    gNavy = 'midnightblue',
    gOlive = 'OliveDrab4',
    gPurple = 'purple3',
    gRed = 'red',
    gSilver = 'SlateGray3',
    gTeal = 'steelblue4',
    gWhite = 'white',
    gYellow = 'Yellow2',
    gError = 'tomato',

    hAqua = '#00FFFF',
    hBlack = '#000000',
    hBlue = '#0000FF',
    hFuchsia = '#FF00FF',
    hGray = '#808080',
    hGreen = '#008000',
    hLime = '#00FF00',
    hMaroon = '#800000',
    hNavy = '#000080',
    hOlive = '#808000',
    hPurple = '#800080',
    hRed = '#FF0000',
    hSilver = '#C0C0C0',
    hTeal = '#008080',
    hWhite = '#FFFFFF',
    hYellow = '#FFFF00',
    )
#print dycolors.gYellow
</t>
<t tx="ekr.20050421093045.121">#maybe can turn on full exception reporting 
#rather than rolling my own
# es_event_exception (eventName,full=false):

def what_line_am_i_on():
    #from the snippits collection
    import sys
    try:
        raise "Hack"
    except:
        return sys.exc_info()[2].tb_frame.f_back.f_lineno

#    g.es('lineno= ' + what_line_am_i_on() )

def dynaerrout(err, msg):
    """from fuzzy cmd
    previous Leo masked the errors 
    making debuggin of some scripts more painful than not.
    often enough you don't want to gotoline number either.
    """
    from traceback import print_exc

    g.es(msg, color= dycolors.gError)
    f = StringIO.StringIO()
    print_exc(file= f)
    a = f.getvalue().splitlines()
    for line in a:
        #c.goToLineNumber(n=int(newSel))
        g.es(line, color= dycolors.gError)</t>
<t tx="ekr.20050421093045.122">def dynaerrline():
    """for debuggin, return just the error string on one line
    call in an except after an error.

    &gt;&gt;&gt; try:
    ...    a = 1 / 0
    ... except Exception:
    ...    print dynaerrline()[:49]
    ZeroDivisionError integer division or modulo by z
    """
    import sys
    exctype, value, tb = sys.exc_info()

    if type(exctype) == type(''):
        exc_type_name = exctype
    else: exc_type_name = exctype.__name__

    el = ['%s = %s .'%(k, repr(v)) for k, v in vars(exctype).items()]

    return '%s %s %s '%(exc_type_name, value, el)

</t>
<t tx="ekr.20050421093045.123">#code to operate dynamenu, no user code

def dyna_getsubnodes(c, globs= {}):
    """ changed API slightly, macros now need a common first 5 chars
    if I can change it to dont care about the name I will.
    
    from the plugin, the old way of walking the node to find macros
    is not going to work I just realized
    there is no current node, this has to run before the plugin is made
    and somehow encode the macros and decode them, 
    and insert them into the plugins namespace. yikes
    maybe if I put @others in a stratigic place, they will be included
    all that would remain is to get their names from a __dict__
    
    glitch, they arent added in the order defined in macros node.
    sorting
    glitch when in dynacommon globals isnt the callers globals!
    fails from test.leo
    """
    lst = []

    try:
        lst = [x for x in globs
                if x.startswith('dyna')
                if x[5] == '_'   #x[4] specifys type of macro
                ]

        #possibly decorate somehow to respect the order defined in the py
        #maybe add a user char after _ to specify numeric position
        
    except Exception, e:
        # d=rew  Leo caught syntax error, space
        #Leo caught TypeError: ut() takes exactly 1 argument (2 given)
        #d=rew might not have caught this, or not printed full traceback
        dynaerrout(e, "initMdyna ")

    lst.sort()
    #es('dynamenu macros %s'%(lst,) )
    return lst</t>
<t tx="ekr.20050421093045.124">class captureStd(object):
    """the typical redirect stdout
    add stderr and stdin later
    borrowing the class from PH testsuite for redirect stdout

    leo also has filelike objects and its own redirect    
    there isa config option and a plugin to redirect to log
    and to append to body of captured output

    another way
    sys.displayhook = mydisplayhook

    &gt;&gt; def mydisplayhook(a):
    ...     if a is not None:
    ...             sys.stdout.write("%r\n" % (a,))
    ...
    
    only used in evaluator, why not in du_test
    or if it doens't work there why does it work in evaluator w/calc_util?
    maybe can replace now?
        """
    def captureStdout(self):
        sys.stdout = StringIO.StringIO()

    def releaseStdout(self):
        captured = sys.stdout.getvalue()
        sys.stdout = sys.__stdout__
        return captured
</t>
<t tx="ekr.20050421093045.125">def runcmd(cmdlst, to_stdin= None):
    """cmdlst is either a list or string for subprocess
    think is string for popen
    
    for win9x this works better than other popen for me.
    on *nix you can import commands or something else popen5 maybe
    this does wait and leo is inactive so if there is a chance
    the process will infinate loop, better use a spawner
    you get the return output outerr stdout stderr

    use subprocess if available and not on pythonw till that bug fixed
    see forums for usage and download from effbot.org if &lt;py2.4
    
    py2.2 think prints 1 as True and so fails
    &gt;&gt;&gt; 'pythonw.exe'[-5:].upper() == 'W.EXE'
    True
    
    mostly used to run checkers on py file in site-packages
    or wherever you set the defaults
    if Leo or temacs core gets an executeFile we will use that if it works
    shell=True still fails for me on win9x so fork still up in the air.
    and so a flash if no console, latest test seem to deconfirm this.
    
    and a title change on the console if already open to the last command
    seems to be a subprocess bug
    
    adding stdin driver to feed input to command and options
    leave it up to caller to use the -- or no filename conventions

    shell metacharacters?
    
    startupinfo
    ASPN/Cookbook/Python/Recipe/409002

    """
    import os, sys

    try: 
        if g.app.dynaMvar.bugimport: raise ImportError
        import subprocess
    except ImportError:
        #not going to concider name collision if you have an older
        #python with one of the previous incarnations of subprocess
        subprocess = None

    outstd = outerr = ''
    #think only windows pythonw fails stdout/stderr duplication
    #if sys.executable[-5:].upper() == 'W.EXE': subprocess = None

    if not subprocess:
        #should try to get return code its &lt;&lt;128 or something on stderr
        if to_stdin:
            #just haven't programmed it in yet, but get subprocess anyway!
            g.es('stdin redirection not avaiable \nw/o subprocess module')
            return outstd, outerr

        if isinstance(cmdlst, list):
            cmdlst = ' '.join(cmdlst)

        child_stdin, child_stdout, child_stderr = os.popen3(cmdlst)
        #better to_stdin.replace('\n', os.lineterm())
        #do I have to child_stdin.write(to_stdin) &amp; wait?
        outstd = child_stdout.read()
        outerr = child_stderr.read()
    else:
        &lt;&lt; subproc &gt;&gt;
    #will probably add ret and force=0 if not subprocess
    return outstd, outerr</t>
<t tx="ekr.20050421093045.126">try:
    if to_stdin: #could hang w/bad or insufficent data
        if g.app.dynaMvar.verbosity: g.es('piping to stdin')  #, BLINK

    startupinfo = subprocess.STARTUPINFO()

    #depends on if pywin32 or _subprocess?
    if hasattr(subprocess, 'STARTF_USESHOWWINDOW'):
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        
    ps = subprocess.Popen(cmdlst, #cwd= fdir,
        universal_newlines= True,
        stdin= subprocess.PIPE,
        stdout= subprocess.PIPE, stderr= subprocess.PIPE
        #,close_fds=True
        , startupinfo=startupinfo
        )

    (outstd, outerr) = ps.communicate(to_stdin)
    ret = ps.wait()

except ValueError:  #if Popen is called with invalid arguments. 
    g.es('invalid args?\n', cmdlst)

except Exception:
    g.es_exception(full= True)
    g.es(' args?\n', cmdlst)</t>
<t tx="ekr.20050421093045.127">def dynadoc(c, sub= 'all', globs= {}):
    """read dynadeflst and createdoc for them
        was previously print, but that doesnt work well in plugin
        add a simple wrap, which isn't appending dash in midword like expected
        could set wrap on for the log. then off again, 
        would probably unwrap  though

    combined the call to all and removed else. works because
    a list is made from sub, will preclude docing a macro named all

    using now \python23\lib\textwrap.py, if available
    too many amonalies in fordoc too little time.
    made a wraper macro, don't really want another depency
    would have to extract the relevant code and have the 
    macro call it too. ok a little code duplication for now
    
    expand to show macro's internal __dict__
    getting doc for fliper for ex, might be nice to know
    add quit sentinal to docs to limit display
    use Leo g.wrap and in dynawrapper or call dynawrapper
    add some reST formatting to docs
    could add some slight blurb on each ini option value.
    a few in dynacommon like runcmd could be doced
  """
    import sys
    try:
        import textwrap as tw
    except ImportError:
        tw = None  #or overwrite formdoc
        g.es('textwrap is going to produce better results.')
        g.es('get it from the python cvs archive\n')
        
    #from pydoc import resolve, describe, inspect, text, plain
    &lt;&lt; formdoc &gt;&gt;
    lst = [sub ] 
    if sub == 'all':
        lst = g.app.dynaMvar.dynadeflst
        lst += [x for x in globs if x.startswith('cmd_')]
        lst.reverse()

    #g.es(g.__dict__.keys()) {}
    #g.es(g.app.__dict__.keys()) Leo ivars

    for x in lst:
        #need to get the callers globals
        #f = g.app.dynaMvar.globals()[x]  nor globals()[x]
        #f = g.app.__dict__[x]  #is this same as app.globals()[x]
        try:
            f = globs[x]  #
        except Exception:
            g.es('cant find', x)
            continue
        
        #if no doc problems
        #try to get len of unsized object or unscriptable object
        #hasattr(f, '__doc__') always true for a function
        elip = ''
        if f.__doc__:

            coln = f.__doc__.find('~EOT') 
            if coln == -1: coln = 520

            doc = f.__doc__[:coln]
            if len(f.__doc__) &gt; coln: elip = ' ...'
        else:
            doc = ' no additional info '

        if not tw:
            st = formdoc(doc)
        else:
            t = tw.TextWrapper(
                     width= 42,
                    initial_indent=' ',
                   subsequent_indent= ' ',
                   expand_tabs= True,
                  replace_whitespace= True,
                 fix_sentence_endings= False,
                break_long_words= True )

            st = t.fill(doc)

        g.es('\n' + x + '.__doc__\n' + st + elip)

    #obj, name = resolve(x, 0)
    #desc = describe(obj)
    #g.es(text.docroutine(f, x))
    </t>
<t tx="ekr.20050421093045.128">def formdoc(doc, to= 50):
    r"""    
    &gt;&gt;&gt; formdoc('create a rough wraper to 40 charlines', 14)
    '\n  create a rough\n    wraper to 40 charlines\n'

    """
    sx = doc.expandtabs(2).splitlines()
    sl = []
    for i, x in enumerate(sx):
        if len(x) &lt; (to-8): sl.append('  ' + x.lstrip()); continue

        if len(x) &gt; to: ax = to
        else: ax = len(x) - 1

        dash = '-'
        while ax &gt; (to-8):
            if x[ax] in ' .,(){}[]?\n': dash = ''; break
            ax -= 1
        #if ax w/in few char of len(x) may as well be one line
        #check it isnt eating a char at ends
        sl.append('  ' + x.lstrip()[:ax] + dash)
        sl.append('   ' + x.lstrip()[ax:])

    return '\n'.join(sl)</t>
<t tx="ekr.20050421093045.129">def quietwarnings():
    '''quiet warnings from pychecker and tim1 about regex
    this should be part of init rather than module level'''
    
    import warnings
    
    warnings.filterwarnings("ignore",
             r'the regex module is deprecated; please use the re module$',
             DeprecationWarning, r'(&lt;string&gt;|%s)$' % __name__)
    warnings.filterwarnings("ignore",
             r' the regsub module is deprecated; please use re.sub\(\).$.$',
             DeprecationWarning, r'(&lt;string&gt;|%s)$' % __name__)
    
    if sys.version_info &gt;= (2, 3): #py2.2 no simple
        warnings.simplefilter("ignore", DeprecationWarning, append=0)
    </t>
<t tx="ekr.20050421093045.130">def dynaput(c, slst):
    """return the text selection or put it if slst is not None
    assumes slst is a list to be joined and print/paste as toggled
     add other option, paste w/o delete
    up to the caller to insert \n if required
    eventially pass in event so can get text from any widget
    for now, hardwired to use the Leo API to the Tk text widget   
    **slight problem, wont insert something wth nothing selected
 leoTkinterFrame

  add another menu toggle for print to clipboard 
    in addition to printing or instead of printing
     and replace or append to clipboard.
  bodyCtrl
  allowing fixbody to be called so added test for paste &amp; no selected 
  and selected or slst
  if nothing selected and slst then 3rd choice. must be a full body
  bad idea to past over the node because it wont follow nodes.
  
  problem since split into dynacommonm
  g.top().frame.dynaMvar no longer reliable doe some reason
  maybe that shouve always been based on c? isnt that already c? 
  still havent got a handle on why its failing.
  decide to spend another var. g. works but g.app better
    """
    cg = g.app.dynaMvar
    #print cg

    #this depends on the macro calling dynaput first as they mostly do now
    #bound to be some sideffects untill I put it in the right place
    #maybe the menu has to have a function caller instead of calling the function
    if 'doc' == cg.dynapasteFlag.get():

        #what about dynabutton
        #g.es(sys.modules[dyna_menu].keys())
        caller_globals, caller_locals = _caller_symbols()
        #g.es("this_caller", caller_globals)

        #in dynabutton they are all radio buttions 
        #and its easy to see which was called. unlike in plugin
        #dump all for now
        dynadoc(c, globs= caller_globals)
        return

    Tx = c.frame.body
    if Tx.hasTextSelection() or slst: #*
        
        #returns selection point if nothing selected
        Tst,  Ten = Tx.getTextSelection()

        if not slst: #**and Tx.hasTextSelection()
            return Tx.getTextRange(Tst, Ten)

        else:

            #ux = g.toUnicode(x[1:] )  ?? need to know the encodeing!
            # toUnicode(before,app.tkEncoding), hope Leo handles this
            ux = ''.join(slst)
    
            if 'print' == cg.dynapasteFlag.get():
                #print ux
                g.es(ux)

            elif 'paste' == cg.dynapasteFlag.get() and \
                    Tx.hasTextSelection():
                #g.es('overwrite\n', str(Tx.getTextRange(Tst, Ten)) )
        
                #btw, Tk insert doesnt disturb the selection.
                Tx.deleteTextSelection()
                Tx.setInsertionPoint(Tst)
                #print '%r', ux
                Tx.insertAtInsertPoint(ux)
                Tx.onBodyChanged("Typing")
        
                #selection may wander depending on the final size
                Tx.setTextSelection(Tst,  Ten)

            else:
                g.es('nothing selected',
                         cg.dynapasteFlag.get() )

    else: g.es("no text selected", color= 'orangered' )</t>
<t tx="ekr.20050421093045.131">#make part of a larger basic python sanity check
import leoGlobals as g

#indented def's problem in doctest &lt; py2.4b2?
def xt():
    """__ """
    pass

try:
    assert(1 == 0)
    g.es('assert disabled, use g.app._t.assert_()',
        color= 'tomato')

    if __debug__: g.es('__debug__ is',__debug__, color= 'tomato')
    #how to tell if also -OO? __debug__? prob only -O
    #if hasattr(x,"__doc__") and x.__doc__:
    #if not hasattr(dynaB_Clip_dtef, '__doc__'):  #
    #if not len(dynaB_Clip_dtef.__doc__):
        
    #print dynaplay.__doc__  
    #when printed is not None of -O, of not printed is None if -O!
    #x()
    print xt.__doc__, #will this fail on pyw?

    #doc apparently is always defined, even if empty? just None if -OO
    #further caviet, is None untill run regardless if -O due to late binding
    #even if run is None, has to be specifically accessed! weird...
    #if printed is totally unreliable the difference between -O and -OO
    #back to the drawing board.
    if xt.__doc__ is None:
        pyO = 'OO'
        g.es('YOU MAY HAVE RUN python -OO \ndoctest Will fail, @test ok',
            color= 'tomato')
    else:
        pyO = 'O'
        g.es('YOU HAVE RUN python -O',
            color= 'tomato')

except AssertionError: 
    pyO = 'I'  #used in du_test
    pass
del xt</t>
<t tx="ekr.20050421093045.132">#note, these changes are at the time the button or menu is created
#to effect these changes you have to 
#write the plugin and start a new python and leo. maybe reload
#execute script on the dynaclick node for the dynabutton
#they will take effect in dynatester imediatly
#preserve the space after to allow for parameters
#those that will be joined to pypath start with seperator \ or /
#any other scripts should have their own full path, 

#pypath = r'C:\c\py\Python233'         #nospace
pypath = g.os_path_split(sys.executable)[0]

#py =  pypath + '/python.exe -tOO '     #_space_
py =  g.os_path_join(pypath, 'python') + ' -tO '

#leosrc = r'c:\c\leo\leo4CVS233\src'
leosrc = g.app.loadDir

#reindent = g.os_path_join(pypath, '/Tools/Scripts/reindent.py ')  #space
reindent = pypath +  '/Tools/Scripts/reindent.py '  #space

#print pypath, py, leosrc

#classic pychecker
pycheck = pypath + '/Lib/site-packages/pychecker/checker.py '  #space
#pychecker2, doesnt import, is alot slower and less details.
# and leaves some temp files, I guess its still experimental.
pycheck2 = pypath + '/Lib/site-packages/pychecker2/main.py '


#
#classic pychecker I think does import regex which causes a warning when called from plugin. maybe they fixed that in the latest version.
#not sure why dont see it when run from dynabutton. output on stderr?
#DeprecationWarning: the regsub module is deprecated; please use re.sub()
# was caused by tim1crunch, I supress the warning now.

#pylint is its own macro now, could delete if you don't run it
#set to 1 to call pylint after pychecker ub makatemp
dopylint = 0  #this call too complicated to code in here


doreindent = 0 #to forgo reindent step in pylint &amp; makatemp macro


@
it might be preferable to generate a new tmpfile w/pid or something
 ok for singleuser no security multiuser issues for now.
YMMV, I set tmp and temp in autoexec,

it seems pylint has to be able to import from site-packages
look in makatemp trying to add tmp to syspath isnt easy from Leo
add leoID, and sanitize, leoID may not exist at this point.
why would it be None though?
that seems odd since plugins should be able to call on it at creation
should create an hname for htmlize also
or maybe the macro should add the extension

putting an html file in tmp could still be a huge secuity risk
maybe should be in user HOME instead?
also create in site-packages might not be enabled for everyone.
have to check better for write access

later generate the filenames inside a function
and add them to a Bunch allong with the colors
maybe a Bunch of Bunches class dynaMvar will overtake
@c

#print 'leoID=', g.app.leoID
Id = g.choose(g.app.leoID, g.app.leoID, 'Leo')
tname = sanitize_('tmptest' + Id )+ '.py'

#use lower if on *nix. 
#windos may set TEMP and TMP by default, case insensitive.
#tmpfile = g.os_path_join(os.environ['tmp'],'tmptest.py')

tmpfile = g.os_path_join(pypath, 'Lib/site-packages', tname)
#
tname = sanitize_('python' + Id )+ '.html'
htmlfile = g.os_path_join(
           os.getenv('tmp', default= g.os_path_abspath('./')), tname)


del Id, tname

#replace forwardslash to backslash if required
#frd slash usually ok except for cd and sometimes openfile
#with filename as parameter in windos frdslash might be taken as option
if sys.platform[:3] == 'win':
    #generally win doesn't care mixed slashes
    #but you might pass py, pypath et al thru here too
    tmpfile = g.os_path_abspath(tmpfile)  #.replace('/', '\\')
    htmlfile = g.os_path_abspath(htmlfile)

#enable the print if not sure its working to satisfaction.
#print tmpfile, htmlfile, py, pypath

#should check is valid and have access and create if doesn't exist...
#may have to defer the creat w/properties so is created on first use
#leoID doesnt exist when dyna imports common and shouldent import * either

#should calculate from @lineending,  does python handle conversion?
EOLN = '\n'  #have to try and use this everywhere, os.linesep()?
</t>
<t tx="ekr.20050421093045.133">;ini may be shortlived in favor of @settings when thats feasible
;leave nosent so it isn't updated on leo open and all comments lost
; but if you change something here, it will overwrite any previous ini on disk.
;
;current properties ini editor will not have enough room for all these.
;pick only about a dozzen of your favorites more if you have more screen size
; True==1 False==0 just like the old days works too, case insensitive
;case sensitive on section names, insensitive on item names
;untested with spaces or Unicode in filenames please report any problem. 


[main]
verbosity=0
;verbosity for du_test and @test
;tempfile used in makatemp and tim1crunch, not active yet, edit dynacommon
;tmpfile = site-packages

;no source print after checks
justPyChecker=1

bugImport=0
tabstrip=4


[htmlize]
;which external colorizer for @language other than python
;leave blank for none or comment out
;hilighter=silvercity
hilighter=source-highlight
;hilighter=

;codefold = False
stripcomments = False
stripsentinals = True
stripnodesents = False
stripdirectives = False
noNUMBER = False
noOP = False
noNAME = True

;filename = c:\temp\htmlize.html
timestring = default

;use leodefault if Leo has one or default for whats hardwired in dyna_menu
;non existant or commented out values use the default in dyna_menu

;have to invent a new node, a clone with languageformatconversion
;hate duplicating here the defaults hardwired in htmlize, but anyways
;colors
;token_NUMBER  =  #483D8B  ;black/darkslateblue
;token_OP      =  #000080  ;black/navy
;token_STRING  =  #00AA00  ;green 00cc66
;token_COMMENT =  #DD0000  ;red cc0033
;token_NAME     = #4B0082  ;black/indigo
;token_ERRORTOKEN= #FF8080  ;redred bare null does it
;token_KEYWORD    =  #0066ff  ;blue
;token_TEXT       =  #000000  ;black /is text fg color too
;token_LeoDir     =  #228B22  ;directive, forest comment
token_LeoSen     =  #BC8F8F  ;sentinal, tan fade comment
token_bg         =  #FFFAFA  ;snow

; comments can be after values but not spaces or commas?
;comments can be between values?
;configparser needs a complete testsuite to answer these questions
;maybe there is one already?


@language elisp
</t>
<t tx="ekr.20050421093045.134">@all
 you need
&lt; @home &gt;

rc, urls to pychecker and pylint,
    tags.j2h,
     css,
   rpdb,
   au3,

.astylerc for astyle reformater not included

HappyDoc3-r3_0_a1 from happydoc.sourceforge.net or pydoc (in stdlib).
need PYTHONDOCS env set and download the help from python.org
for print help(whatever) type answers. think pydoc imports the module.

happydoc doesn't import so is safe on untrusted code. but is proving
to be quite out of date so will try something from docutils sandbox
other apps like epydoc also possible. why does noone think of scriptability!
everything is input file and output file and no mention of anything else.


silvercity or source-highlight for syntax highlighted htmlize output


#u05417a10:51
@killcolor </t>
<t tx="ekr.20050421093045.135">python code and style checkers, pylint and makeatemp macro
to use you pylint need both.
http://www.logilab.org/projects/pylint
http://www.logilab.org/projects/common
%HOME% .pylintrc
see how to get the rc file below

for pychecker
http://pychecker.sourceforge.net/
%HOME% .pycheckrc
in test.leo I think there is a good rc file for pychecker

http://www.python.org/peps/pep-0008.html
http://www.python.org/doc/current/tut/tut.html


astyle macro, reformat c, java/javascript code
http://astyle.sourceforge.net/  
can use  ~/.astylerc not included


syntax highlight from htmlize
docutils
silvercity
source-highlight


for subprocess for python less than v2.4
replaces popen and used to call various externals
pychecker source-highlight and others
http://effbot.org/download

not sure it helps, might even slow things down
but if its installed a few macros can enable it.
http://psyco.sourceforge.net/ 




set HOME=c:\sve\mii or whatever in your .rc or autoexec.bat
or somehow set HOME or export in your env 
or use the os default for home if there is one.
many programs look in your home for .rc files

it may also be possible to set which config on the command line
for some of the chekers or source highlighters.

   few macros expect python 2.3 or python 2.4 modules.
   instruction how to get modules from cvs are on c.l.py
 cvs.sourceforge.net/cgi-bin/viewcvs.cgi/python/python/nondist/sandbox/csv

   some modules that have been left in compatible python source 
   on cvs will work in py2.2 or less.
   textwrap, csv, sets, iterators, datetime and the list is growing.

    you may need generators and enumerate for some operations.
    py2.2 you can uncomment from  __future__ import generators
    enumerate you have to search a little. dyna_menu has enumerate.
    or ask on IRC. (Internet Relay Chat)
     
type in: 
/server irc.freenode.net 
/join #Leo  
from an IRC client sometime! 
if you have Leo questions or answers. 
    #python too. ask good questions get good answers.
    and many open source projects have channels there.

   c.l.py is the usenet comp.lang.python gated mailing list
   source of all knowledge and misinformation about python.
   time marches on, Leo backward compatibility is not perfect either.

other dependencies are in the doc strings of the individual macro's 
many of them are just shells that produce some typical output 
to use as a template if the need arises. url's included
or use http://www.python.org/pypi/ 
or Vaults of Parnassus  http://www.vex.net/~x/parnassus/ 
 or the archive of google site:python.org
 help(module) 
 help needs to installed python docs and PYTHONDOC env variable set.
or run pydoc in gui mode 
or search the index in the chm a python install should setup
a shortcut for you and for other systems there are chm readers.

aspn recipes refer to numbers add the number after this url
http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/

don't forget the dead tree version of information exchange
for the python cookbook and many other titles.
and the many link sites for python have links to articles
or tutorials that should be read and tested more than once.

 Daily Python-URL [http://www.pythonware.com/daily/]

http://www.python.org/moin/PythonSpeed/PerformanceTips
http://www.awaretek.com/ output.html

http://www.speedygrl.com/p/44.html

Tom Loredo's page is one of the first I ever saw about python.
http://astrosun.tn.cornell.edu/staff/loredo/
</t>
<t tx="ekr.20050421093045.136">#howtto get the pylint rc file
#@url file:///C|/C/PY/PYTHON~1/SCRIPTS/PYLINT.bat%20c:\sve\mi\.pylintrt
#    os.startfile(url)
#WindowsError: [Errno 2] The system cannot find the file specified: 
#I thought maybe with %20 I could sneak in a parameter to pylint.bat
#actually the command would be
#C:\C\PY\PYTHON~1\SCRIPTS\PYLINT.bat &gt;c:\sve\mi\.pylintrc
#but that even wont work because they dopily put the output on stderr
#so I cameup with this script, run from a macro. I leave it up to you
#you could copy the runcmd function and import os and exscript from here too
#you need to edit the resultnant rc file because pylint is a style checker
#it complains about alot of stuff. no space after coma, single char names
#etc etc etc
#if you have msys shell or other shell rather than a dos window
#you can run pylint and redirect stderr or copy from the screen

#not recently tested, runit in dynacommon
it = r'C:\C\PY\PYTHON~1\SCRIPTS\PYLINT.bat'
para = r' --generate-rcfile'
outit = None  or r'c:\sve\mii\.pylintrc'
output, outerr = runcmd(it + para )
if outit:
    fo = file(outit, 'w')
    fo.writelines(output + "\n" + outerr )
    fo.close()
    print 'written to', outit



@language python
@color</t>
<t tx="ekr.20050421093045.137">#@path ~home

@  rc option files &amp; url's for pychecker and pylint

1&gt; executeScript on this node will insert 
the proper path to your home directory
as the first line of this node.
if it looks ok, remove the #comment to enable it.
of course, you can just setup the path however you want
no executescript is required, just another toy to play with.

2&gt; remove ignore from at least pylint and pycheckrc
check over details in the subnodes,
although they both may work ok w/o rc files or with these as defaults.
rc files are not one size fits all for every project and small script
in some cases may have to specify an rc file on the command line.
tags files is for source-highlite

3&gt; if you already have rc files,
before you save the leo do read @file first
or don't remove the ignore on those you don't want to generate.

4&gt;  write @file here to generate your
pchecker and pylint rc files
or save the leo as the case may be.
nothing could be simpler...

5&gt; this has not been tested on all systems.
worst case if no suitable home can be found
you must insert a proper path yourself.
worst case than that, please post a traceback
or some indication how it failed.

6. as to pychecker and pylint being able to find
the rc, if there are problems you may have to try
to run them from the commandline to see whats what.
you might try to set the env variable home=somewhere
on nix systems this would probably never be necessary.
although you cuold want to have the rc file accessable 
for all users, I have no idea how to make that happen.

7. with .name  files, there have been reports of some 
problems on older windows. I've never had a problem.

@c
&lt;&lt; @home &gt;&gt;
insertAhome(c)
@language python
@color
</t>
<t tx="ekr.20050421093045.138">@others
def insertAhome(c,wch= 'i'): #i/r
    """use to insertAt 1.0 #@path user.home
   
    incorperate fallbacks for win2k, XP, mac and nix 
    still to be determined if spaces in path is a problem
    not tested on a mac or nix or XP
    """
    import leoGlobals as g
    import os, sys

    home = None
    #         ,nt/w2k?   xp  ,xp,   ,nix/mac 
    l = 'USERPROFILE APPDATA home'.split()  #HOMEPATH HOMEDRIVE 
    x = l.pop()
    while x:
        print x 
        try:
            home = os.environ[x]
            if home.startswith('%') and home.endswith('%'):
                home = os.environ[x[1:-1]]
            break
        except KeyError:
            x = l.pop()
    
    if home is None:
        if sys.platform == "win32": 
            home = _APPDATA()
    
        elif sys.platform == "darwin": 
            home =  getPrefsDir() 
    
        else:
            home = os.path.expanduser("~")
            if home == "~":
                home = os.getenv("home", None)
        
    if home is None:
        home = './' #use curent dir

    home = g.os_path_normpath(g.os_path_abspath(home, encoding=None))

    if sys.platform == "win32": 
        home = GetLongPath(home)

    if not g.os_path_isdir(home):
        print 'give up', home; raise NameError

    if 'i' in wch:
        Tx = c.frame.body
        Tx.setInsertionPoint(1.0)
        Tx.insertAtInsertPoint('#@path %s\n'%(home,))
        Tx.onBodyChanged("Typing")  

    #return home
</t>
<t tx="ekr.20050421093045.139">
def GetLongPath(shortname):
    r"""
    &gt;&gt;&gt; GetLongPath('c:\\Program Files')
    'c:\\Program Files'
    &gt;&gt;&gt; GetLongPath('c:\\progra~1')
    'c:\\Program Files'
    """
    try:
        from win32api import GetLongPathName
        name = GetLongPathName(shortname)
    except ImportError:
        #not going to attempt to do this...
        name = shortname
    return name

#shortpath = win32api.GetShortPathName(path)


#maybe the Leo plugin dir belongs here? not sure on nix/mac
def _APPDATA():
    """
     same code as above by changing CSIDL_APPDATA to
CSIDL_LOCAL_APPDATA
However, Win98/Me/NT4 do not support CSIDL_LOCAL_APPDATA, so you'll need to
check for an error 
    """
    #check is win, if not there is major problem
    print 'try for CSIDL_APPDATA'  # '%windir%/application data'
    try:
        from win32com.shell import shell, shellcon
    except ImportError:
        return None
        
    return shell.SHGetPathFromIDList (
      shell.SHGetSpecialFolderLocation (0, shellcon.CSIDL_APPDATA)
    )
</t>
<t tx="ekr.20050421093045.140">@
from http://www.astro.washington.edu/rowen/ROPython.html

@c


def findFolder(domain, dirType, doCreate=False):
    """Return a path to the specified standard directory or None if not found.
    
    The path is in unix notation for MacOS X native python
    and Mac colon notation for Carbon python,
    i.e. the form expected by the os.path module.
    
    Inputs:
    - domain: one of the domain constants found in Carbon.Folders,
        such as kUserDomain, kLocalDomain or kSystemDomain.
    - dirType: one of the type constants found in Carbon.Folders,
        such as kPreferencesFolderType or kTrashFolderType.
    - doCreate: try to create the directory if it does not exist?
    """
    import Carbon.Folder, Carbon.Folders
    import MacOS
    try:
        fsref = Carbon.Folder.FSFindFolder(domain, dirType, doCreate)
        return fsref.as_pathname()
    except MacOS.Error:
        return None

def getPrefsDir(doCreate = False):
    """Return a path to the user's preferences folder.
    
    Inputs:
    - doCreate	try to create the dir if it does not exist?

    Returns None if the directory does not exist
    (and could not be created if doCreate True).
    """
    import Carbon.Folder, Carbon.Folders
    import MacOS
    return findFolder(
        domain = Carbon.Folders.kUserDomain,
        dirType = Carbon.Folders.kPreferencesFolderType,
        doCreate = doCreate,
    )

def getAppSuppDirs(doCreate = False):
    """Return a list of paths to the user's and local (shared) application support folder.
    
    Inputs:
    - doCreate	try to create each dir if it does not exist?
    
    If a folder does not exist (and could not be created if doCreate True),
    it is omitted; hence returns [] if nothing found.
    """
    import Carbon.Folder, Carbon.Folders
    import MacOS
    retDirs = []
    for domain in Carbon.Folders.kUserDomain, Carbon.Folders.kLocalDomain:
        path = findFolder(
            domain = domain,
            dirType = Carbon.Folders.kApplicationSupportFolderType,
            doCreate = doCreate,
        )
        if path != None:
            retDirs.append(path)
    return retDirs  
</t>
<t tx="ekr.20050421093045.141">#this should work even if python -O or -OO
#http://rclick.netfirms.com/commonerrors.html
if 1: #try:
    assert(1 == 1)

if 1: #finally:
    import unittest
    class t_(unittest.TestCase):
        def runTest(self):
            pass
    t = t_()
    t.assert_(1 == 1)
</t>
<t tx="ekr.20050421093045.142">urls to pychecker and pylint
</t>
<t tx="ekr.20050421093045.143">need common too
run python setup.py install on both of them
</t>
<t tx="ekr.20050421093045.144"></t>
<t tx="ekr.20050421093045.145">install pychecker python setup.py install
then copy pychecker2 to site-packages
and make mods mentioned in the pychecker2 macro if you want to try it.
experimental and so far provides a minimal value on hard to debug scripts
while pychecker is proven useful in more cases</t>
<t tx="ekr.20050421093045.146">@ignore
#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]
#Print instance variables in self
alias ps pi self

</t>
<t tx="ekr.20050421093045.147">@ignore
#import user
#sys.version 
</t>
<t tx="ekr.20050421093045.148">@ignore
# Sample defaults file for PyChecker 0.8.13
# This file should be called:  .pycheckrc
# It should be placed in your home directory (value of $HOME).
# If $HOME is not set, it will look in the current directory.

# file = c:/prog/leoCVS/leo/src/leo.py

# bool: warnings for Doc Strings
noDocModule = 0
noDocClass = 0
noDocFunc = 0

# bool: when checking if class data members (attributes) are set
#       check all members or __init__() only
onlyCheckInitForMembers = 0

# bool: warn when all module variables are not used (including private vars)
allVariablesUsed = 0

# bool: produce warnings for each occurrence of a warning for global (xxx)
reportAllGlobals = 0

# bool: warn when private module variables are not used (_var)
privateVariableUsed = 1

# bool: warn when imports are not used
importUsed = 1

# bool: warn when import and from ... import are used for same module
mixImport = 0 # EKR

# bool: warn when imports are not used in __init__.py
packageImportUsed = 1

# bool: warn when a module reimports another module (import &amp; from/import)
moduleImportErrors = 0 # EKR

# bool: warn when modules import themselves
reimportSelf = 0 # EKR

# bool: warn when local variables are not used
localVariablesUsed = 1

# bool:  assume a, b, and c are used in this case:  a, b, c = func()
unusedLocalTuple = 0

# bool:  warn when class attributes (data members) are unused
membersUsed = 0

# bool: warn when Subclass.__init__ is not called in a subclass
baseClassInitted = 1

# bool: warn when Subclass needs to override methods that only throw exceptions
abstractClasses = 1

# bool: warn when __init__ is defined in a subclass
initDefinedInSubclass = 0

# bool: warn when __init__ returns None
returnNoneFromInit = 1

# bool: warn when code is not reachable
unreachableCode = 0

# bool: warn when a constant is used in a conditional statement (if '':)
constantConditions = 1

# bool: warn when 1 is used in a conditional statement, (if 1: while 1: etc)
constant1 = 0

# bool: warn when iterating over a string in a for loop
stringIteration = 1

# bool: warn when setting a variable to different types
inconsistentTypes = 0

# bool: warn when setting a tuple of variables to a non-sequence (a, b = None)
unpackNonSequence = 1

# bool: warn when setting a tuple of variables to the wrong length (a, b = 1,)
unpackLength = 1

# bool: warn when using strings exceptions or 
#       other classes not derived from Exception to raise/catch exceptions
badExceptions = 1

# bool: warn when statements appear to have no effect
noEffect = 1

# bool: warn when using (expr % 1), it has no effect on integers and strings
modulo1 = 1

# bool: warn if using (expr is const-literal), 
# doesn't always work on integers and strings
isLiteral = 0 # EKR

# bool: warn when using a deprecated module or function
deprecated = 1

# bool: warn when the class attribute does not exist
classAttrExists = 1

# bool: warn when calling an attribute not a method
callingAttribute = 0

# bool: warn when using named arguments: func(a=1, b=2), where def func(a, b):
#       def func2(a, b, **kw): doesn't generate a warning
namedArgs = 0 # EKR

# str: name of 'self' parameter
methodArgName = 'self'

# list of str: names of first parameter to classmethods
## classmethodArgNames = ['cls', 'klass']

# bool: warn when method/function arguments are unused
argumentsUsed = 1

# bool: ignore if self is unused in methods
ignoreSelfUnused = 0

# bool: warn if functions/classes/methods names are redefined in same scope
redefiningFunction = 1

# bool:  check if an overriden method has the same signature
#	 as base class method (__init__() methods are not checked)
checkOverridenMethods = 1

# bool:  check if a special (reserved) method has the correct signature
#	 and is known (these are methods that begin and end with __
## checkSpecialMethods = 1

# int: warnings for code complexity, max value before generating a warning
maxLines = 2000
maxBranches = 500
maxReturns = 100
maxArgs = 100
maxLocals = 250
maxReferences = 500

# bool:  ignore all warnings from standard library components
#	 (this includes anything under the standard library, eg, site-packages)
ignoreStandardLibrary = 1 # EKR

# list of strings: ignore unused locals/arguments if name is one of
unusedNames = [
    '_', 'empty', 'unused', 'dummy', 'event', 'commander',
    'c', 'i', 'j', 'k', 's',
    'tag', 'args', 'keys', 'keywords']

# list of strings: ignore warnings generated from these modules
blacklist = [
    'leoGlobals',
    'leoConfig',
    'leoFrame', 'leoMenu', 'leoGui', # Base classes have lots of unused params.
    'Tkinter', 'wxPython', 'gtk', 'GTK', 'GDK', ]

# list of strings: ignore global variables not used if name is one of
variablesToIgnore = [ '__all__', '__version__', '__copyright__', ]

# bool: print the PyChecker parse of modules, classes, etc.
printParse = 0

# bool: turn debugging of PyChecker on
debug = 0

# bool: check that attributes of objects exist
checkObjectAttrs = 1

# bool: various warnings about incorrect usage of __slots__
slots = 1

# bool: check if __slots__ is empty
emptySlots = 1

# bool: check for using properties in classic classes
classicProperties = 1

# bool: check for integer division (may be problem between Python versions)
intDivide = 1

# bool: check if local variables shadow a global variable with same name
shadows = 0 # EKR

# bool: check if input() is used, which is a security problem, use raw_input()
usesInput = 1

# bool: check if using a constant string to getattr()/setattr()
# Doesn't exist.
## constAttr = 1

# bool: check for using +variable, since it is almost always has no effect
unaryPositive = 1

# bool: check for modifying a parameter with a default value
#       (value must be: list, dict, instance)
#       modifying the value may have undesirable/unexpected side-effects
modifyDefaultValue = 1

# bool: check if the exec statement is used (possible security problem)
usesExec = 0

# bool: check consistent return values
checkReturnValues = 1

# bool: check if using implict and explicit return values
checkImplicitReturns = 1

# dict: suppress warnings, key is module.class.method or module.function
#	value is a string of command line arguments (can omit -- for long args)
#       { 'module1': 'no-namedargs maxlines=0',
#	  'module2.my_func': 'argsused',
#	  'module3.my_class': 'no-initreturn', }
if 1:
    suppressions = {}
else: # Doesn't work
    suppressions = {
        'leoFrame' : 'argumentsUsed=0',
        'leoGui' : 'argumentsUsed=0' }

# dict: suppress warnings where keys can be regular expressions
suppressionRegexs = {}</t>
<t tx="ekr.20050421093045.149">@ignore
#t04413p12:07 lint Python modules using external checkers.
    
[MASTER]
# Add &lt;file&gt; (may be a directory) to the black list. It should be a base name,
# not a path. You may set this option multiple times.
ignore=CVS

# Pickle collected data for later comparisons.
persistent=yes

# Tells wether to display a full report or only the messages
reports=yes

# Python expression which should return a note less than 10 (10 is the highest
# note).You have access to the variables errors, warnings, statements which
# respectivly contain the number of errors / warnings messages and the total
# number of statements analyzed. This is used by the global evaluation report
# (R0004).
evaluation='10.0 - ((float(5 * errors + warnings) / statements) * 10)'

# Add a comment according to your evaluation note. This is used by the global
# evaluation report (R0004).
comment=no

# Include message's id in output
include-ids=no

# checks for                                                              
#    * external modules dependancies                                            
#    * relative / wildcard imports                                                         
#    * cyclic imports                                                           
#    * uses of deprecated modules
    
[IMPORTS]
# Enable / disable this checker
enable-imports=yes

# Deprecated modules which should not be used, separated by a comma
deprecated-modules=regsub,string,TERMIOS,Bastion,rexec


# checks for :                                                            
#    * doc strings                                                              
#    * modules / classes / functions / methods / arguments / variables name     
#    * number of arguments, local variables, branchs, returns and statements infunctions, methods                                                       
#    * required module attributes                                             
#    * dangerous default values as arguments                                    
#    * redefinition of function / method / class                                
#    * uses of the global statement                                             
    
[BASIC]
# Enable / disable this checker
enable-basic=yes

# Maximum number of arguments for function / method
max-args=5

# Maximum number of locals for function / method body
max-locals=15

# Maximum number of return / yield for function / method body
max-returns=6

# Maximum number of branch for function / method body
max-branchs=12

# Maximum number of statements in function / method body
max-statements=50

# Required attributes for module, separated by a comma
required-attributes=__revision__

# Regular expression which should only match functions which do not require a
# docstring
no-docstring-rgx=__.*__

# Minimal length for module / class / function / method / argument / variable
# names
min-name-length=3

# Regular expression which should only match correct module names
module-rgx=([a-z_][a-z1-9_]*)|([A-Z][a-zA-Z]+)

# Regular expression which should only match correct class names
class-rgx=[A-Z][a-zA-Z1-9]+

# Regular expression which should only match correct function names
function-rgx=[a-z_][a-z1-9_]*

# Regular expression which should only match correct argument names
argument-rgx=[a-z_][a-z1-9_]*

# Regular expression which should only match correct variable names
variable-rgx=[a-z_][a-z1-9_]*

# Good variable names which should always be accepted, separated by a comma
good-names=i,j,k,ex

# Bad variable names which should always be refused, separated by a comma
bad-names=foo,bar,baz,toto,tutu,tata

# List of builtins function names that should not be used, separated by a comma
bad-functions=map,filter,apply,input

# checks for                                                              
#    * unused variables / imports                                               
#    * undefined variables                                                      
#    * redefinition of variable from builtins or from an outer scope            
#    * use of variable before assigment                                         
    
[VARIABLES]
# Enable / disable this checker
enable-variables=yes

# Tells wether we should check for unused import in __init__ files.
init-import=no


# checks for :                                                            
#    * methods without self as first argument                                   
#    * overriden methods signature                                              
#    * access only to existant members via self                                 
#    * attributes not defined in the __init__ method                            
#    * supported interfaces implementation                                      
#    * unreachable code                                                         
    
[CLASSES]
# Enable / disable this checker
enable-classes=yes

# List of interface methods to ignore, separated by a comma. This is used for
# instance to not check methods defines in Zope's Interface base class.
ignore-iface-methods=isImplementedBy,deferred,extends,names,namesAndDescriptions,queryDescriptionFor,getBases,getDescriptionFor,getDoc,getName,getTaggedValue,getTaggedValueTags,isEqualOrExtendedBy,setTaggedValue,isImplementedByInstancesOf

# Tells wether missing members accessed in mixin class should be ignored. A
# mixin class is detected if its name ends with "mixin" (case insensitive).
ignore-mixin-members=yes



# checks for                                                              
#    * excepts without exception filter                                         
#    * string exceptions                                                        
    
[EXCEPTIONS]
# Enable / disable this checker
enable-exceptions=yes



# does not check anything but gives some raw metrics :                    
#    * total number of lines                                                    
#    * total number of code lines                                               
#    * total number of docstring lines                                          
#    * total number of comments lines                                           
#    * total number of empty lines                                              
    
[METRICS]
# Enable / disable this checker
enable-metrics=yes



# checks for:                                                             
#    * source code with non ascii characters but np encoding declaration ( 263)                                                                     
#    * warning notes in the code like FIXME, XXX
    
[MISCELLANEOUS]
# Enable / disable this checker
enable-miscellaneous=yes

# List of note tags to take in consideration, separated by a comma. Default to
# FIXME, XXX, TODO
notes=FIXME,XXX,TODO



# checks for :                                                            
#    * unauthorized constructions                                               
#    * strict indentation                                                       
#    * line length                                                              
#    * use of &lt;&gt;
    
[FORMAT]
# Enable / disable this checker
enable-format=yes

# Maximum number of characters on a single line.
max-line-length=80

# Maximum number of lines in a module
max-module-lines=1000

# String used as indentation unit. This is usually "    " (4 spaces) or "\t" (1# tab). leave a tab here '	'
indent-string='    '
#this is a tab indent-string='	' 


</t>
<t tx="ekr.20050421093045.150">@ignore
// generate to exist in your homeDir for source-highlite from htmlize
keyword blue b ;
type blue  ;
string green ;
comment red;
number purple ;
preproc darkblue b ;
symbol brown ;
function darkblue b;
cbracket gray;

// line numbers
linenum black;

// other elements for ChangeLog and Log files
date blue b ;
time darkblue b ;
ip darkgreen ;
file darkblue b ;
name darkgreen ; </t>
<t tx="ekr.20050421093045.151">@ignore 
# css files for the rst plugin and htmlize macro

#set @path to where the rst plugin and htmlize will output 
path c:/windows/temp
path c:/c/leo/HTML
@language css


fixed colors to be more Leo like
uped the fonts a little. looks ok in IE 
but firefox fonts are too small 
and the @import url in the default doesn't work in firefox
@color </t>
<t tx="ekr.20050421093045.152">/*alternate default style sheet for the HTML output of Docutils.
:Author: David Goodger, Ian Bicking 
Blue Bars with Boxed Admonitions
:version: $Revision$
:copyright: This stylesheet has been placed in the public domain.
 

preincluded leo and silvercity at the end, so firefox works better
is not fully compatible yet. not sure why but @import url() failed.

generate file rename to default.css where you will generate @rst nodes
I guess htmlize should use this file as well.
some kind of script to automatically change the font size and style
to suite individulat taste would probably not be much work.
some simplification is in order and some duplication is evident.


there is also the problem of adding Rest directives on the fly
and keeping the css up to date.
code-block is one
simple too small
*/
BODY {
	FONT-FAMILY: Arial, sans-serif
}
EM {
	FONT-FAMILY: Times New Roman, Times, serif
}
I {
	FONT-FAMILY: Times New Roman, Times, serif
}
LI {
	LIST-STYLE-TYPE: circle
}
A.target {
	COLOR: blue
}
A.toc-backref {
	COLOR: black; TEXT-DECORATION: none
}
A.toc-backref:hover {
	
}
A:hover {
	BACKGROUND-COLOR: #cccccc
}
CITE {
	FONT-WEIGHT: bold; FONT-STYLE: normal; FONT-FAMILY: monospace
}
DD {
	MARGIN-BOTTOM: 0.5em
}
DIV.abstract {
	MARGIN: 2em 5em
}
DIV.abstract P.topic-title {
	FONT-WEIGHT: bold; TEXT-ALIGN: center
}
DIV.attention {
	BORDER-RIGHT: outset; PADDING-RIGHT: 3px; BORDER-TOP: outset; PADDING-LEFT: 3px; FLOAT: right; PADDING-BOTTOM: 3px; BORDER-LEFT: outset; WIDTH: 40%; PADDING-TOP: 3px; BORDER-BOTTOM: outset; BACKGROUND-COLOR: #cccccc
}
DIV.caution {
	BORDER-RIGHT: outset; PADDING-RIGHT: 3px; BORDER-TOP: outset; PADDING-LEFT: 3px; FLOAT: right; PADDING-BOTTOM: 3px; BORDER-LEFT: outset; WIDTH: 40%; PADDING-TOP: 3px; BORDER-BOTTOM: outset; BACKGROUND-COLOR: #cccccc
}
DIV.danger {
	BORDER-RIGHT: outset; PADDING-RIGHT: 3px; BORDER-TOP: outset; PADDING-LEFT: 3px; FLOAT: right; PADDING-BOTTOM: 3px; BORDER-LEFT: outset; WIDTH: 40%; PADDING-TOP: 3px; BORDER-BOTTOM: outset; BACKGROUND-COLOR: #cccccc
}
DIV.error {
	BORDER-RIGHT: outset; PADDING-RIGHT: 3px; BORDER-TOP: outset; PADDING-LEFT: 3px; FLOAT: right; PADDING-BOTTOM: 3px; BORDER-LEFT: outset; WIDTH: 40%; PADDING-TOP: 3px; BORDER-BOTTOM: outset; BACKGROUND-COLOR: #cccccc
}
DIV.hint {
	BORDER-RIGHT: outset; PADDING-RIGHT: 3px; BORDER-TOP: outset; PADDING-LEFT: 3px; FLOAT: right; PADDING-BOTTOM: 3px; BORDER-LEFT: outset; WIDTH: 40%; PADDING-TOP: 3px; BORDER-BOTTOM: outset; BACKGROUND-COLOR: #cccccc
}
DIV.important {
	BORDER-RIGHT: outset; PADDING-RIGHT: 3px; BORDER-TOP: outset; PADDING-LEFT: 3px; FLOAT: right; PADDING-BOTTOM: 3px; BORDER-LEFT: outset; WIDTH: 40%; PADDING-TOP: 3px; BORDER-BOTTOM: outset; BACKGROUND-COLOR: #cccccc
}
DIV.note {
	BORDER-RIGHT: outset; PADDING-RIGHT: 3px; BORDER-TOP: outset; PADDING-LEFT: 3px; FLOAT: right; PADDING-BOTTOM: 3px; BORDER-LEFT: outset; WIDTH: 40%; PADDING-TOP: 3px; BORDER-BOTTOM: outset; BACKGROUND-COLOR: #cccccc
}
DIV.tip {
	BORDER-RIGHT: outset; PADDING-RIGHT: 3px; BORDER-TOP: outset; PADDING-LEFT: 3px; FLOAT: right; PADDING-BOTTOM: 3px; BORDER-LEFT: outset; WIDTH: 40%; PADDING-TOP: 3px; BORDER-BOTTOM: outset; BACKGROUND-COLOR: #cccccc
}
DIV.warning {
	BORDER-RIGHT: outset; PADDING-RIGHT: 3px; BORDER-TOP: outset; PADDING-LEFT: 3px; FLOAT: right; PADDING-BOTTOM: 3px; BORDER-LEFT: outset; WIDTH: 40%; PADDING-TOP: 3px; BORDER-BOTTOM: outset; BACKGROUND-COLOR: #cccccc
}
DIV.attention P.admonition-title {
	DISPLAY: block; FONT-WEIGHT: bold; MARGIN: 0px; COLOR: #cc0000; FONT-FAMILY: sans-serif; BACKGROUND-COLOR: #999999; TEXT-ALIGN: center
}
DIV.caution P.admonition-title {
	DISPLAY: block; FONT-WEIGHT: bold; MARGIN: 0px; COLOR: #cc0000; FONT-FAMILY: sans-serif; BACKGROUND-COLOR: #999999; TEXT-ALIGN: center
}
DIV.danger P.admonition-title {
	DISPLAY: block; FONT-WEIGHT: bold; MARGIN: 0px; COLOR: #cc0000; FONT-FAMILY: sans-serif; BACKGROUND-COLOR: #999999; TEXT-ALIGN: center
}
DIV.error P.admonition-title {
	DISPLAY: block; FONT-WEIGHT: bold; MARGIN: 0px; COLOR: #cc0000; FONT-FAMILY: sans-serif; BACKGROUND-COLOR: #999999; TEXT-ALIGN: center
}
DIV.warning P.admonition-title {
	DISPLAY: block; FONT-WEIGHT: bold; MARGIN: 0px; COLOR: #cc0000; FONT-FAMILY: sans-serif; BACKGROUND-COLOR: #999999; TEXT-ALIGN: center
}
DIV.hint P.admonition-title {
	DISPLAY: block; FONT-WEIGHT: bold; MARGIN: 0px; FONT-FAMILY: sans-serif; BACKGROUND-COLOR: #999999; TEXT-ALIGN: center
}
DIV.important P.admonition-title {
	DISPLAY: block; FONT-WEIGHT: bold; MARGIN: 0px; FONT-FAMILY: sans-serif; BACKGROUND-COLOR: #999999; TEXT-ALIGN: center
}
DIV.note P.admonition-title {
	DISPLAY: block; FONT-WEIGHT: bold; MARGIN: 0px; FONT-FAMILY: sans-serif; BACKGROUND-COLOR: #999999; TEXT-ALIGN: center
}
DIV.tip P.admonition-title {
	DISPLAY: block; FONT-WEIGHT: bold; MARGIN: 0px; FONT-FAMILY: sans-serif; BACKGROUND-COLOR: #999999; TEXT-ALIGN: center
}
DIV.dedication {
	MARGIN: 2em 5em; FONT-STYLE: italic; TEXT-ALIGN: center
}
DIV.dedication P.topic-title {
	FONT-WEIGHT: bold; FONT-STYLE: normal
}
DIV.figure {
	MARGIN-LEFT: 2em
}
DIV.footer {
	FONT-SIZE: smaller
}
DIV.header {
	FONT-SIZE: smaller
}
DIV.system-messages {
	MARGIN: 5em
}
DIV.system-messages H1 {
	COLOR: red
}
DIV.system-message {
	BORDER-RIGHT: outset; PADDING-RIGHT: 1em; BORDER-TOP: outset; PADDING-LEFT: 1em; PADDING-BOTTOM: 1em; BORDER-LEFT: outset; PADDING-TOP: 1em; BORDER-BOTTOM: outset
}
DIV.system-message P.system-message-title {
	FONT-WEIGHT: bold; COLOR: red
}
DIV.topic {
	MARGIN: 2em
}
H1 {
	BORDER-RIGHT: black thin solid; PADDING-RIGHT: 4px; BORDER-TOP: black thin solid; PADDING-LEFT: 4px; PADDING-BOTTOM: 4px; BORDER-LEFT: black thin solid; PADDING-TOP: 4px; BORDER-BOTTOM: black thin solid; FONT-FAMILY: Helvetica, Arial, sans-serif; moz-border-radius: 8px
}
H2 {
	BORDER-RIGHT: black thin solid; PADDING-RIGHT: 4px; BORDER-TOP: black thin solid; PADDING-LEFT: 4px; PADDING-BOTTOM: 4px; BORDER-LEFT: black thin solid; PADDING-TOP: 4px; BORDER-BOTTOM: black thin solid; FONT-FAMILY: Helvetica, Arial, sans-serif; moz-border-radius: 8px
}
H3 {
	BORDER-RIGHT: black thin solid; PADDING-RIGHT: 4px; BORDER-TOP: black thin solid; PADDING-LEFT: 4px; PADDING-BOTTOM: 4px; BORDER-LEFT: black thin solid; PADDING-TOP: 4px; BORDER-BOTTOM: black thin solid; FONT-FAMILY: Helvetica, Arial, sans-serif; moz-border-radius: 8px
}
H4 {
	BORDER-RIGHT: black thin solid; PADDING-RIGHT: 4px; BORDER-TOP: black thin solid; PADDING-LEFT: 4px; PADDING-BOTTOM: 4px; BORDER-LEFT: black thin solid; PADDING-TOP: 4px; BORDER-BOTTOM: black thin solid; FONT-FAMILY: Helvetica, Arial, sans-serif; moz-border-radius: 8px
}
H5 {
	BORDER-RIGHT: black thin solid; PADDING-RIGHT: 4px; BORDER-TOP: black thin solid; PADDING-LEFT: 4px; PADDING-BOTTOM: 4px; BORDER-LEFT: black thin solid; PADDING-TOP: 4px; BORDER-BOTTOM: black thin solid; FONT-FAMILY: Helvetica, Arial, sans-serif; moz-border-radius: 8px
}
H6 {
	BORDER-RIGHT: black thin solid; PADDING-RIGHT: 4px; BORDER-TOP: black thin solid; PADDING-LEFT: 4px; PADDING-BOTTOM: 4px; BORDER-LEFT: black thin solid; PADDING-TOP: 4px; BORDER-BOTTOM: black thin solid; FONT-FAMILY: Helvetica, Arial, sans-serif; moz-border-radius: 8px
}
H1 {
	BORDER-RIGHT: black solid; BORDER-TOP: black solid; BORDER-LEFT: black solid; COLOR: #ffffff; BORDER-BOTTOM: black solid; BACKGROUND-COLOR: #444499
}
H1 A.toc-backref {
	COLOR: #ffffff
}
H2 A.toc-backref {
	COLOR: #ffffff
}
H2 {
	BORDER-RIGHT: black solid; BORDER-TOP: black solid; BORDER-LEFT: black solid; COLOR: #ffffff; BORDER-BOTTOM: black solid; BACKGROUND-COLOR: #666666
}
H3 {
	COLOR: #000000; BACKGROUND-COLOR: #cccccc
}
H4 {
	COLOR: #000000; BACKGROUND-COLOR: #cccccc
}
H5 {
	COLOR: #000000; BACKGROUND-COLOR: #cccccc
}
H6 {
	COLOR: #000000; BACKGROUND-COLOR: #cccccc
}
H3 A.toc-backref {
	COLOR: #000000
}
H4 A.toc-backref {
	COLOR: #000000
}
H5 A.toc-backref {
	COLOR: #000000
}
H6 A.toc-backref {
	COLOR: #000000
}
H1.title {
	BORDER-RIGHT: black thick solid; BORDER-TOP: black thick solid; BORDER-LEFT: black thick solid; COLOR: #eeeeee; BORDER-BOTTOM: black thick solid; BACKGROUND-COLOR: #444499; TEXT-ALIGN: center; moz-border-radius: 20px
}
H2.subtitle {
	TEXT-ALIGN: center
}
HR {
	WIDTH: 75%
}
OL.simple {
	MARGIN-BOTTOM: 1em
}
UL.simple {
	MARGIN-BOTTOM: 1em
}
OL.arabic {
	LIST-STYLE-TYPE: decimal
}
OL.loweralpha {
	LIST-STYLE-TYPE: lower-alpha
}
OL.upperalpha {
	LIST-STYLE-TYPE: upper-alpha
}
OL.lowerroman {
	LIST-STYLE-TYPE: lower-roman
}
OL.upperroman {
	LIST-STYLE-TYPE: upper-roman
}
P.caption {
	FONT-STYLE: italic
}
P.credits {
	FONT-SIZE: smaller; FONT-STYLE: italic
}
P.first {
	MARGIN-TOP: 0px
}
P.label {
	WHITE-SPACE: nowrap
}
P.topic-title {
	FONT-WEIGHT: bold
}
PRE.address {
	MARGIN-TOP: 0px; FONT-SIZE: 100%; MARGIN-BOTTOM: 0px; FONT-FAMILY: serif
}
PRE.line-block {
	FONT-SIZE: 100%; FONT-FAMILY: serif
}
PRE.literal-block {
	BORDER-RIGHT: black thin solid; PADDING-RIGHT: 5px; BORDER-TOP: black thin solid; PADDING-LEFT: 5px; PADDING-BOTTOM: 5px; MARGIN-LEFT: 2em; BORDER-LEFT: black thin solid; MARGIN-RIGHT: 2em; PADDING-TOP: 5px; BORDER-BOTTOM: black thin solid; BACKGROUND-COLOR: #eeeeee
}
PRE.doctest-block {
	BORDER-RIGHT: black thin solid; PADDING-RIGHT: 5px; BORDER-TOP: black thin solid; PADDING-LEFT: 5px; PADDING-BOTTOM: 5px; MARGIN-LEFT: 2em; BORDER-LEFT: black thin solid; MARGIN-RIGHT: 2em; PADDING-TOP: 5px; BORDER-BOTTOM: black thin solid; BACKGROUND-COLOR: #eeeeee
}
SPAN.classifier {
	FONT-STYLE: oblique; FONT-FAMILY: sans-serif
}
SPAN.classifier-delimiter {
	FONT-WEIGHT: bold; FONT-FAMILY: sans-serif
}
SPAN.interpreted {
	FONT-FAMILY: sans-serif
}
SPAN.option-argument {
	FONT-STYLE: italic
}
SPAN.pre {
	WHITE-SPACE: pre
}
SPAN.problematic {
	COLOR: red
}
TABLE {
	MARGIN-TOP: 0.5em; MARGIN-BOTTOM: 0.5em
}
TABLE.citation {
	PADDING-LEFT: 0.5ex; BORDER-LEFT: gray thin solid
}
TABLE.docinfo {
	MARGIN: 2em 4em
}
TABLE.footnote {
	PADDING-LEFT: 0.5ex; BORDER-LEFT: black thin solid
}
TD {
	PADDING-RIGHT: 0.5em; PADDING-LEFT: 0.5em; VERTICAL-ALIGN: top
}
TH {
	PADDING-RIGHT: 0.5em; PADDING-LEFT: 0.5em; VERTICAL-ALIGN: top
}
UNKNOWN {
	MARGIN-TOP: 0em
}
TH.docinfo-name {
	FONT-WEIGHT: bold; WHITE-SPACE: nowrap; TEXT-ALIGN: left
}
TH.field-name {
	FONT-WEIGHT: bold; WHITE-SPACE: nowrap; TEXT-ALIGN: left
}
H1 TT {
	FONT-SIZE: 100%
}
H2 TT {
	FONT-SIZE: 100%
}
H3 TT {
	FONT-SIZE: 100%
}
H4 TT {
	FONT-SIZE: 100%
}
H5 TT {
	FONT-SIZE: 100%
}
H6 TT {
	FONT-SIZE: 100%
}
CODE {
	COLOR: #000066
}
TT {
	COLOR: #000066
}
UL.auto-toc {
	LIST-STYLE-TYPE: none
}

@others</t>
<t tx="ekr.20050421093045.153">/* Some of these styles taken from Gunnar Schwant's (g.schwant@gmx.de) DocFactory */

/* tt is the class of the inline literal
as 10pt
*/

tt { background-color: #ffffee } 

.first {
  font-size: 110% }

.last {
  font-size: 110% }

a {
  text-decoration: none }

a.reference {
  color: #00009F }

a:hover {
  background-color: #00009F ;
  color: white }

body {
  font-family: arial,helvetica,univers ;
  font-size: 110% ;
  padding-top: 0.6cm ;
  margin-left:0.5cm ;
  margin-right:0.5cm ;
  margin-bottom:0.5cm }

/* dd appears to be the text of the definitions  padding-top: 0.1cm */
dd {
  font-size: 110% }
  
 dt {
   font-style: italic }

/* dt appears to be the word in a definition list line-height: 110%

dt {
  font-size: 110% ;
  font-family: "Courier New", Courier;
  }
*/

div.abstract {
  font-size: 110% }

div.abstract p.topic-title {
  font-size: 110% }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning {
  font-size: 110% }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, div.hint p.admonition-title, 
div.important p.admonition-title, div.note p.admonition-title, 
div.tip p.admonition-title {
  margin-top: 0em ;
  font-size: 120% ;
  font-family: arial,helvetica,univers }

div.dedication {
  font-size: 110% }

div.dedication p.topic-title {
  font-size: 110% }

div.figure {
  font-size: 110% }

div.footer, div.header {
  font-size: 9pt }

div.system-messages {
  font-size: 110% }

div.system-messages h1 {
  font-size: 120% }

div.system-message {
  font-size: 110% }

div.system-message p.system-message-title {
  font-size: 110% }

div.topic {
  font-size: 110% }

h1, h2, h3, h4, h5, h6 {
  padding-top: 0.5cm ;
  page-break-after: avoid ;
  font-family: arial,helvetica,univers }

#content .subtitle {
	font-size: .9em;
}

#content .title {
	font-size: 1.6em;
	font-weight: normal;
}

#content ul {
    margin-left: 20px;
    margin-bottom: 10px;
}

p {
	margin-bottom: 10px;
}

h1, h2, h3, h4, h5, h6 {
	margin-top: 10px;
	margin-bottom: 5px;
}


h1 {
	font-size: 1.4em;
	border-bottom: .25pt solid #ccc;
}

h1.title {
         font-size: 1.6em;
         border-bottom:none}

h2 {
	font-size: 1.2em;
}

h3, h4, h5, h6 {
	font-size: 1.0em;}

hr {
  width: 100%;
  page-break-after: always }

/* the following was creating too much space in the table of contents*/
/*li {
  padding-top: 1mm ;
  padding-bottom: 1mm }*/
  
li {font-size: 10pt}

ol.simple, ul.simple {
  font-size: 110% }

ol.arabic {
  font-size: 110% }

ol.loweralpha {
  font-size: 110% }

ol.upperalpha {
  font-size: 110% }

ol.lowerroman {
  font-size: 110% }

ol.upperroman {
  font-size: 110% }

p.caption {
  font-size: 110% }

p.credits {
  font-style: italic ;
  font-size: 8pt }

p.label {
  font-size: 110% }

p.topic-title {
  font-size: 110% }

pre.address {
  font-family: arial,helvetica,univers ;
  font-size: 110% }

pre.line-block {
  background-color: #eeeeee ;
  border-color: #999999 ;
  border-width: 1pt ;
  font-size: 10pt;
  font-family: "Courier New", Courier }
  
  /*border: 1px dotted #999;*/

pre.literal-block, pre.doctest-block {
  border-width: 1pt ;
  border-style: solid ;
  border-color: #999999 ;
  background-color: #ffffee ;
  padding-left: 0.5ex ;
  margin-left:0.5cm ;
  font-size: 110% }
  
/*code class - this allows us to use literal-block for program code and make it gray with small text*/
  pre.code {
  background-color: #eeeeee ;
  font-size: 10pt }

span.classifier {
  font-size: 110% ;
  font-family: arial,helvetica,univers }

span.classifier-delimiter {
  font-size: 110% ;
  font-family: arial,helvetica,univers }

span.field-argument {
  font-size: 110% }

span.interpreted {
  font-size: 110% ;
  font-family: arial,helvetica,univers }

span.option-argument {
  font-size: 110% }

span.problematic {
  font-size: 110% }

table {
  font-size: 110% ;
  border-collapse: collapse ;
  border-width: 1.5pt ;
  border-color: #003366 }

table.citation {
  font-size: 110% }

table.docinfo {
  font-size: 110% }

table.footnote {
  font-size: 8pt ;
  text-align: left }

/*table.table {
  width: 100% } */

th {
  border-width: 1.5pt }

td {
  border-width: 1pt }

td, th {
  font-size: 9pt ;
  border-style: thin ;
  border-color: #003366 }

td.docinfo-name, th.field-name {
  font-size: 110% }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 110% }
  
  /* SZ CHANGES*/
  
  div.system-messages {
    margin: 5em }
  
  div.system-messages h1 {
    color: red }
  
  div.system-message {
    border: medium outset ;
    padding: 1em }
  
  div.system-message p.system-message-title {
    color: red ;
  font-weight: bold }
  
  div.hint p.admonition-title, div.important p.admonition-title,
  div.note p.admonition-title, div.tip p.admonition-title,
  div.admonition p.admonition-title {
  color: maroon }
  
  p.topic-title {
  font-weight: bold }
  
  p.rubric {
    text-align: left} ;
    
/* Following added for code-blocks if SilverCity is present*/
    
  div.code-block{
    margin-left: 2em ;
    margin-right: 2em ;
    background-color: #eeeeee;
    font-family: "Courier New", Courier, monospace;
    font-size: 10pt;
    white-space: nowrap;
    }
</t>
<t tx="ekr.20050421093045.154">
.code_default
{
    FONT-FAMILY: "Courier New", Courier, monospace;
    FONT-SIZE: 110%;
}

.c_character
{
	color: olive;
}

.c_comment
{
	color: firebrick;
	font-style: italic;
}

.c_commentdoc
{
	color: green;
	font-style: italic;
}

.c_commentdockeyword
{
	color: navy;
	font-weight: bold;
}

.c_commentdockeyworderror
{
	color: red;
	font-weight: bold;
}

.c_commentline
{
	color: green;
	font-style: italic;
}

.c_commentlinedoc
{
	color: firebrick;
	font-style: italic;
}

.c_default
{
}

.c_identifier
{
	color: black;
}

.c_number
{
    color: #009999;
}

.c_operator
{
	color: black;
}

.c_preprocessor
{
	color: navy;
	font-weight: bold;
}

.c_regex
{
	color: #00aa00;
}

.c_string
{
	color: #00aa00;
}

.c_stringeol
{
	color: #00aa00;
}

.c_uuid
{
	color: olive;
}

.c_verbatim
{
	color: olive;
}

.c_word
{
	color: navy;
	font-weight: bold;
}

.c_word2
{
	color: navy;
	font-weight: bold;
}

.h_asp
{
    color: #ffff00;
}

.h_aspat
{
    color: #ffdf00;
}

.h_attribute
{
    color: #008080;
}

.h_attributeunknown
{
    color: #ff0000;
}

.h_cdata
{
    color: #ffdf00;
}

.h_comment
{
    color: #808000;
}

.h_default
{
}

.h_doublestring
{
	color: olive;
}

.h_entity
{
    color: #800080;
}

.h_number
{
    color: #009999;
}

.h_other
{
    color: #800080;
}

.h_script
{
    color: #000080;
}

.h_singlestring
{
	color: olive;
}

.h_tag
{
    color: #000080;
}

.h_tagend
{
    color: #000080;
}

.h_tagunknown
{
    color: #ff0000;
}

.h_xmlend
{
    color: #0000ff;
}

.h_xmlstart
{
    color: #0000ff;
}

.pl_array
{
	color: black;
}

.pl_backticks
{
	color: olive;
}

.pl_character
{
	color: olive;
}

.pl_commentline
{
	color: green;
	font-style: italic;
}

.pl_datasection
{
	color: olive;
}

.pl_default
{
}

.pl_error
{
	color: red;
	font-style: bold;
}

.pl_hash
{
	color: black;
}

.pl_here_delim
{
	color: olive;
}

.pl_here_q
{
	color: olive;
}

.pl_here_qq
{
	color: olive;
}

.pl_here_qx
{
	color: olive;
}

.pl_identifier
{
	color: black;
}

.pl_longquote
{
	color: olive;
}

.pl_number
{
    color: #009999;
}

.pl_operator
{
	color: black;
}

.pl_pod
{
	color: black;
	font-style: italic;
}

.pl_preprocessor
{
	color: navy;
	font-weight: bold;
}

.pl_punctuation
{
	color: black;
}

.pl_regex
{
	color: olive;
}

.pl_regsubst
{
	color: olive;
}

.pl_scalar
{
	color: black;
}

.pl_string
{
	color: olive;
}

.pl_string_q
{
	color: olive;
}

.pl_string_qq
{
	color: olive;
}

.pl_string_qr
{
	color: olive;
}

.pl_string_qw
{
	color: olive;
}

.pl_string_qx
{
	color: olive;
}

.pl_symboltable
{
	color: black;
}

.pl_word
{
	color: navy;
	font-weight: bold;
}

.p_character
{
	color: 00aa00;
}

.p_classname
{
	color: blue;
	font-weight: bold;
}

.p_commentblock
{
	color: firebrick;
	font-style: italic;
}

.p_commentline
{
	color: firebrick;
	font-style: italic;
}

.p_default
{
}

.p_defname
{
    color: blue;
	font-weight: bold;
}

.p_identifier
{
	color: black;
}

.p_number
{
    color: black;
}

.p_operator
{
	color: olive;
}

.p_string
{
	color: #00aa00;
}

.p_stringeol
{
	color: #00aa00;
}

.p_triple
{
	color: #00aa00;
}

.p_tripledouble
{
	color: #00aa00;
}

.p_word
{
	color: navy;
	font-weight: bold;
}

.yaml_comment
{
    color: #008800;
	font-style: italic;
}

.yaml_default
{
}

.yaml_document
{
    color: #808080;
	font-style: italic;
}

.yaml_identifier
{
	color: navy;
	font-weight: bold;
}

.yaml_keyword
{
    color: #880088;
}

.yaml_number
{
    color: #880000;
}

.yaml_reference
{
    color: #008888;
}

</t>
<t tx="ekr.20050421093045.155">to debug a script that is run from an embedded interpreter,
add 'rpdb.set_active()' in the beginning of your script.</t>
<t tx="ekr.20050421093045.156">@path c:\bIn\bat\
@lineending crlf
set pydir=c:\c\py\Python233
set rpdb=%pydir%\Lib\site-packages\rpdb.py

%pydir%\python.exe %rpdb% --server %1 %2 %3 %4 %5 %6 %7 %8 %9


exit
#Started server on port 50009
rpdb.py [-h] [-c [-aN] | -s] [-pM] script-name [script-args...]

    Where the options above mean the following:
    -h, --help     print extended help
    -c, --client   start client side only (server will not spawn automatically)
    -s, --server   start server side only (will wait for clients to connect)
    -aN, --host=N  connect to server on host N
    -pM, --port=M  connect to port M
    
   If you want to debug a script that is run from an embedded interpreter,
        add 'rpdb.set_active()' in the beginning of your script. This will 
        make the calls to 'rpdb.set_trace()' break into the debugger (they
        will not be ignored). Don't forget to add an extra 'rpdb.set_trace()'
        for your main thread. You also need to manually start rpdb.py in 
        server mode before you run your script.

#run the bat first to start rpdb in server mode
#try debugging. at set trace control leo hangs and control is to rpdp
#q will exit the console and return control to leo
#probably there is a  continue
Documented commands (type help &lt;topic&gt;):
========================================
EOF    bn     clear      debug    exit    jump  next  quit    step    unalias
a      break  condition  disable  h       l     p     r       tbreak  up
alias  bt     cont       down     help    list  pdb   return  tc      w
args   c      continue   enable   ignore  load  pp    s       ts      whatis
b      cl     d          exec     j       n     q     save    u       where

* &gt; q
Connection MainThread is not responsive.It may be running, blocked on system call, or doing non Pythonish code.



import rpdb
rpdb.set_active()
try:
    a = a
except Exception:
    rpdb.set_trace()
    print 'caught a=a and set trace'


#print help
import os, sys
runcmd = sys.modules['dyna_menu'].runcmd

rpdb= r'c:\c\py\Python233\Lib\site-packages\rpdb.py'
output, errout = runcmd('python.exe %s --help'%rpdb)

print output, errout


#e</t>
<t tx="ekr.20050421093045.157">remote pdb. http://rpdb.digitalpeers.com/
c:\bIn\bat\rpdb.bat
</t>
<t tx="ekr.20050421093045.158">&lt;http://www.hiddensoft.com/AutoIt&gt; 
a way to automate open leo. 
AutoIt3, windows only though. 


http://www.autoitscript.com/autoit3/
 
regsvr32 AutoItX3.dll
</t>
<t tx="ekr.20050421093045.159">@path c:\c\chall\osix_Geek\
@language elisp
;
; AutoIt Version: 3.0
;
;   Opens Leo with no filename, then opens a new, closes it
;  preliminary will eventually programatically create
;    leoPlugins.txt and various leoSettings.leo
;   and run commands in all permutations looking for failures
; paths hardwired but later scripts will be created on the fly
; not sure about reading back the error returns and and stderr tracebacks
; maybe Leo can have a -trace mode to output to file a log of activities?

; exit when CTRL+ALT+x is pressed
HotKeySet("^!x", "MyExit")


@color 

Func MyExit()
    Exit 
EndFunc 

;===============================================================================
;
; Description:      Executes a DOS command in a hidden command window.
; Syntax:           _RunDOS( $sCommand )
; Parameter(s):     $sCommand - Command to execute
; Requirement(s):   None
; Return Value(s):  On Success - Returns the exit code of the command
;                   On Failure - Depends on RunErrorsFatal setting
; Author(s):        Jeremy Landes &lt;jlandes@landeserve.com&gt;
; Note(s):          None
;
;===============================================================================
Func _RunDOS( $sCommand )
  Return RunWait( @ComSpec &amp; " /C """ &amp; $sCommand &amp; """", "", @SW_HIDE )
EndFunc


Opt("SendKeyDelay", 1)
Opt("WinWaitDelay", 80)


; Send("cd \c\{ENTER}") ;need to cd somewhere?
Run("python c:\c\leo\V43leos\leo\src\leo.py")
Sleep(2700) 

WinWaitActive("untitled")   

Sleep(700) 
Send("!Fn")  ;how to tell if there are errors?
Sleep(2700) 


Send("!Fx")
Sleep(2700) 


Send("!Fx")

; Finished!</t>
<t tx="ekr.20050421093045.160">
c:/c/chall/osix_Geek/leoopen1.au3cd 



have to learn the sendkeys better
some of the output is to this node
exiting Leo exits the python command window too

x and %F went into the body of the untitled leo


will need to change HOME on demand so don't use my settings etc
rename leoSettings so test with builtin defaults and on and on


AutoItSetOption().
SendKeyDelay Alters the the length of the brief pause in between sent keystrokes.
Time in milliseconds to pause (default=5). Sometimes a value of 0 does not work; use 1 instead. 
WinWaitDelay Alters how long a script should briefly pause after a successful window-related operation.
Time in milliseconds to pause (default=250). 
Set oAutoIt = WScript.CreateObject("AutoItX3.Control")
oldvalue = oAutoIt.Opt("SendAttachMode", 0)



Run("c:\WINDOWS\Command.pif")
WinWaitActive("MS-DOS Prompt")   


</t>
<t tx="ekr.20050427102121"></t>
<t tx="ekr.20050513171201">'''usetemacs is a Leo plugin that patches the temacs modules Emacs emulation
into the standard Leo Tkinter Text editor.

Create a usetemacs.ini file to rebind shortcuts that conflict with those in your
leoSettings.leo file. There are many such conflicts. For example, Ctrl-s is
incremental search forward here but by default it is Save in Leo. 

See Help-&gt;Temacs Help for a complete listing of commands and keystrokes.
'''</t>
<t tx="ekr.20050523073009"></t>
<t tx="ekr.20050527084754">
#if self.uC:
#    self.previousStroke = stroke
#    return self.universalDispatch( event, stroke )

#if self.controlx:
#    self.previousStroke = stroke
#     return self.doControlX( event, stroke )


#if stroke in ('&lt;Control-s&gt;', '&lt;Control-r&gt;' ): 
#    self.previousStroke = stroke
#    return self.startIncremental( event, stroke )

#if self.isearch:
#   return self.iSearch( event )

#if stroke == '&lt;Alt-g&gt;':
#    self.previousStroke = stroke
#    return self.startGoto( event )
#if self.goto:
#    return self.Goto( event )

#if stroke == '&lt;Alt-z&gt;':
#    self.previousStroke = stroke
#    return self.startZap( event )

#if self.zap:
#    return self.zapTo( event )</t>
<t tx="ekr.20050527084754.1">
    #if self.howM:
    #    return self.howMany( event )
        
    #if self.abbrevMode:
    #    return self.abbrevCommand1( event )
        
    #if self.altx:
    #    return self.doAlt_X( event )

    #if stroke == '&lt;Alt-percent&gt;':
    #    self.previousStroke = stroke
    #    return self.masterQR( event )  
    #if self.qlisten:
    #    return self.masterQR( event )
        
    #if self.rString:
    #    return self.replaceString( event )
     
    #if self.negativeArg:
    #    return self.negativeArgument( event, stroke )
    
    #if stroke == '&lt;Control-Alt-w&gt;':
    #    self.previousStroke = '&lt;Control-Alt-w&gt;'   
    #    return 'break'</t>
<t tx="ekr.20050527111832"># EKR: This is a generator (it contains a yield).
# EKR: To make this work we must define a new generator for each call to regionalExpandAbbrev.
def searchXR( i1 , i2, ins, event ):
    tbuffer.tag_add( 'sXR', i1, i2 )
    while i1:
        tr = tbuffer.tag_ranges( 'sXR' )
        if not tr: break
        i1 = tbuffer.search( r'\w', i1, stopindex = tr[ 1 ] , regexp = True )
        if i1:
            word = tbuffer.get( '%s wordstart' % i1, '%s wordend' % i1 )
            tbuffer.tag_delete( 'found' )
            tbuffer.tag_add( 'found',  '%s wordstart' % i1, '%s wordend' % i1 )
            tbuffer.tag_config( 'found', background = 'yellow' )
            if self.abbrevs.has_key( word ):
                svar, label = self.getSvarLabel( event )
                svar.set( 'Replace %s with %s? y/n' % ( word, self.abbrevs[ word ] ) )
                yield None
                if self.regXKey == 'y':
                    ind = tbuffer.index( '%s wordstart' % i1 )
                    tbuffer.delete( '%s wordstart' % i1, '%s wordend' % i1 )
                    tbuffer.insert( ind, self.abbrevs[ word ] )
            i1 = '%s wordend' % i1
    tbuffer.mark_set( 'insert', ins )
    tbuffer.selection_clear()
    tbuffer.tag_delete( 'sXR' )
    tbuffer.tag_delete( 'found' )
    svar, label = self.getSvarLabel( event )
    svar.set( '' )
    self.setLabelGrey( label )
    self._setRAvars()</t>
<t tx="ekr.20050527112828">Emacs.lossage.reverse()
Emacs.lossage.append( event.char ) #Then we add the new char.  Hopefully this will keep Python from allocating a new array each time.
Emacs.lossage.reverse()

self.keysymhistory.reverse()
self.keysymhistory.append( event.keysym )
self.keysymhistory.reverse()</t>
<t tx="ekr.20050529143413.30">def colorize(self,p,incremental=False):
    
    '''The main colorizer entry point.'''
    
    # g.trace(incremental)

    if self.enabled:
        self.incremental=incremental 
        self.updateSyntaxColorer(p)
        return self.colorizeAnyLanguage(p)
    else:
        return "ok" # For unit testing.</t>
<t tx="ekr.20050529143413.31">def colorizeAnyLanguage (self,p,leading=None,trailing=None):
    
    '''Color the body pane.  All coloring starts here.'''
    
    self.init_mode(self.language)
    if self.killcolorFlag or not self.mode:
        self.removeAllTags() ; return
    try:
        c = self.c
        self.p = p
        self.redoColoring = False
        self.redoingColoring = False
        self.was_non_incremental = not self.incremental
        # g.trace('was_non_incremental',self.was_non_incremental)
        if not self.incremental:
            # g.trace('removing tags')
            if 0: # removing tags causes flash at idle time.
                self.removeAllTags()
                self.removeAllImages()
            self.colored_ranges = {}
        self.configure_tags()
        g.doHook("init-color-markup",colorer=self,p=self.p,v=self.p)
        s = self.body.getAllText()
        self.colorAll(s)
        if self.redoColoring: # Set only from plugins.
            self.recolor_all()
        return "ok" # for unit testing.
    except Exception:
        g.es_exception()
        return "error" # for unit testing.</t>
<t tx="ekr.20050529180421">@killcolor</t>
<t tx="ekr.20050529180421.1">You might encounter this very common pitfall when writing your own modes.

Since jEdit checks buffer text against parser rules in the order they appear in
the ruleset, more specific rules must be placed before generalized ones,
otherwise the generalized rules will catch everything.</t>
<t tx="ekr.20050529180421.2"></t>
<t tx="ekr.20050529180421.3"></t>
<t tx="ekr.20050529180421.4"></t>
<t tx="ekr.20050529180421.5">If set to TRUE, the sequence will only be highlighted if it occurs at the beginning of a line.</t>
<t tx="ekr.20050529180421.6">If set to TRUE, the sequence will only be highlighted if it is the first non-whitespace text in the line.</t>
<t tx="ekr.20050529180421.7">If set to TRUE, the sequence will only be highlighted if it occurs at the beginning of a word.</t>
<t tx="ekr.20050529180421.8"></t>
<t tx="ekr.20050529180421.9">If set to TRUE, the span will not cross word breaks.</t>
<t tx="ekr.20050529180421.10">If set to TRUE, the span will not cross line breaks.</t>
<t tx="ekr.20050529180421.11">If set to TRUE, the ruleset's escape character will have no effect before the span's end string. Otherwise, the presence of the escape character will cause that occurrence of the end string to be ignored.

</t>
<t tx="ekr.20050529180421.12">If set to TRUE, the match will not be highlighted, only the text before it will.</t>
<t tx="ekr.20050529180421.13"></t>
<t tx="ekr.20050529180421.14">The token type for text which doesn't match any specific rule. Default is NULL.
See the section called Token Types for a list of token types.</t>
<t tx="ekr.20050529180421.15">If the HIGHLIGHT_DIGITS attribute is set to TRUE, jEdit will attempt to highlight numbers in this ruleset.

Any word consisting entirely of digits (0-9) will be highlighted with the DIGIT token type.

A word that contains other letters in addition to digits will be highlighted with the DIGIT token type only if it matches the regular expression specified in the DIGIT_RE attribute. If this attribute is not specified, it will not be highlighted.

Here is an example DIGIT_RE regular expression that highlights Java-style numeric literals (normal numbers, hexadecimals prefixed with 0x, numbers suffixed with various type indicators, and floating point literals containing an exponent):

DIGIT_RE="(0x[[:xdigit:]]+|[[:digit:]]+(e[[:digit:]]*)?)[lLdDfF]?"</t>
<t tx="ekr.20050529180421.16">If set to FALSE, matches will be case sensitive.
Otherwise, case will not matter. Default is TRUE.</t>
<t tx="ekr.20050529180421.17">The name of this ruleset. All rulesets other than the first must have a name.</t>
<t tx="ekr.20050529180421.18">Any non-alphanumeric character not in this list is treated as a word separator for the purposes of syntax highlighting.
</t>
<t tx="ekr.20050529180421.19">The number of characters to terminate after.</t>
<t tx="ekr.20050529180421.20">Text inside the span will be highlighted with the specified ruleset. To delegate
to a ruleset defined in the current mode, just specify its name. To delegate to
a ruleset defined in another mode, specify a name of the form mode::ruleset.
Note that the first (unnamed) ruleset in a mode is called MAIN.

One quirk is that the definition of the imported ruleset is not copied to the
location of the IMPORT tag, but rather to the end of the containing ruleset.
This has implications with rule-ordering; see the section called Rule Ordering
Requirements.</t>
<t tx="ekr.20050529180421.21">Atribute            Elements used in
--------            ----------------
HASH_CHAR           EOL_SPAN_REGEXP,SPAN_REGEXP,SEQ_REGEXP

It must be set to the first character that the regular expression matches. This
rules out using regular expressions which can match more than one character at
the start position. The regular expression match cannot span more than one line,
either.</t>
<t tx="ekr.20050529180421.22">The token type to highlight the text with.

Parser rules can highlight tokens using any of the following token types:

NULL - no special highlighting
COMMENT1,COMMENT2,COMMENT3,COMMENT4
FUNCTION
KEYWORD1,KEYWORD2,KEYWORD3,KEYWORD4
LABEL
LITERAL1,LITERAL2,LITERAL3,LITERAL4
MARKUP
OPERATOR</t>
<t tx="ekr.20050529180421.23">Atribute            Elements used in
--------            ----------------
AT_LINE_START       BEGIN,END
AT_WHITESPACE_END   BEGIN,END
AT_WORD_START       BEGIN,END</t>
<t tx="ekr.20050529180421.24">The only required attribute DELEGATE must be set to the name of a ruleset. To
import a ruleset defined in the current mode, just specify its name. To import a
ruleset defined in another mode, specify a name of the form mode::ruleset. Note
that the first (unnamed) ruleset in a mode is called MAIN.

One quirk is that the definition of the imported ruleset is not copied to the
location of the IMPORT tag, but rather to the end of the containing ruleset.
This has implications with rule-ordering; see the section called Rule Ordering
Requirements.</t>
<t tx="ekr.20050529180421.25">Atribute            Elements used in
--------            ----------------
AT_LINE_START       MARK_FOLLOWING,MARK_PREVIOUS
AT_WHITESPACE_END   MARK_FOLLOWING,MARK_PREVIOUS
AT_WORD_START       MARK_FOLLOWING,MARK_PREVIOUS 
EXCLUDE_MATCH       MARK_FOLLOWING,MARK_PREVIOUS
TYPE                MARK_FOLLOWING,MARK_PREVIOUS</t>
<t tx="ekr.20050529180421.26">Atribute            Elements used in
--------            ----------------
NAME                PROPERTY
VALUE               PROPERTY</t>
<t tx="ekr.20050529180421.27">Atribute            Elements used in
--------            ----------------
DEFAULT             RULES
DIGIT_RE            RULES
HIGHLIGHT_DIGITS    RULES
IGNORE_CASE         RULES
SET                 RULES
NO_WORD_SEP         RULES

The RULES tag supports the following attributes, all of which are optional: 

SET the name of this ruleset. All rulesets other than the first must have a
name.

IGNORE_CASE if set to FALSE, matches will be case sensitive. Otherwise, case
will not matter. Default is TRUE.

NO_WORD_SEP Any non-alphanumeric character not in this list is treated as a word
separator for the purposes of syntax highlighting.

DEFAULT The token type for text which doesn't match any specific rule. Default
is NULL. See the section called Token Types for a list of token types.

HIGHLIGHT_DIGITS DIGIT_RE

If the HIGHLIGHT_DIGITS attribute is set to TRUE, jEdit will attempt to
highlight numbers in this ruleset.

Any word consisting entirely of digits (0-9) will be highlighted with the DIGIT
token type. A word that contains other letters in addition to digits will be
highlighted with the DIGIT token type only if it matches the regular expression
specified in the DIGIT_RE attribute. If this attribute is not specified, it will
not be highlighted.</t>
<t tx="ekr.20050529180421.28">all_spans   = EOL_SPAN,EOL_SPAN_REGEXP,SPAN,SPAN_REGEXP
plain_spans = SPAN,SPAN_REGEXP
regx_spans  = EOL_SPAN_REGEXP,SPAN_REGEXP

Atribute            Elements used in
--------            ----------------
AT_LINE_START       all_spans
AT_WHITESPACE_END   all_spans
AT_WORD_START       all_spans
DELEGATE            all_spans
EXCLUDE_MATCH       all_spans
HASH_CHAR           regx_spans  (must be specified)
NO_ESCAPE           plain_spans
NO_LINE_BREAK       plain_spans
NO_WORD_BREAK       plain_spans
TYPE                all_spans</t>
<t tx="ekr.20050529180421.29">Atribute            Elements used in
--------            ----------------
AT_LINE_START       SEQ,SEQ_REGEXP
AT_WHITESPACE_END   SEQ,SEQ_REGEXP
AT_WORD_START       SEQ,SEQ_REGEXP
DELEGATE            SEQ,SEQ_REGEXP
HASH_CHAR           SEQ_REGEXP (must be specified)
TYPE                SEQ,SEQ_REGEXP</t>
<t tx="ekr.20050529180421.30">@language html
@color</t>
<t tx="ekr.20050529180421.31">An EOL_SPAN is similar to a SPAN except that highlighting stops at the end of
the line, and no end sequence needs to be specified. The text to match is
specified between the opening and closing EOL_SPAN tags.

The following attributes are supported:

TYPE - The token type to highlight the span with. See the section called Token
Types for a list of token types.

AT_LINE_START - If set to TRUE, the span will only be highlighted if the start
sequence occurs at the beginning of a line.

AT_WHITESPACE_END - If set to TRUE, the span will only be highlighted if the
sequence is the first non-whitespace text in the line.

AT_WORD_START - If set to TRUE, the span will only be highlighted if the start
sequence occurs at the beginning of a word.

DELEGATE - text inside the span will be highlighted with the specified ruleset.
To delegate to a ruleset defined in the current mode, just specify its name. To
delegate to a ruleset defined in another mode, specify a name of the form
mode::ruleset. Note that the first (unnamed) ruleset in a mode is called
MAIN.

EXCLUDE_MATCH - If set to TRUE, the start and end sequences will not be
highlighted, only the text between them will.

Here is an EOL_SPAN that highlights C++ comments:

&lt;EOL_SPAN TYPE="COMMENT1"&gt;//&lt;/EOL_SPAN&gt;</t>
<t tx="ekr.20050529180421.32">The EOL_SPAN_REGEXP rule is similar to the EOL_SPAN rule except the match
sequence is taken to be a regular expression.

In addition to the attributes supported by the EOL_SPAN tag, the HASH_CHAR
attribute must be specified. It must be set to the first character that the
regular expression matches. This rules out using regular expressions which can
match more than one character at the start position. The regular expression
match cannot span more than one line, either.

Here is an EOL_SPAN_REGEXP that highlights MS-DOS batch file comments, which
start with REM, followed by any whitespace character, and extend until the end
of the line:

&lt;EOL_SPAN_REGEXP AT_WHITESPACE_END="TRUE" HASH_CHAR="R" TYPE="COMMENT1"&gt;REM\s&lt;/EOL_SPAN_REGEXP&gt;</t>
<t tx="ekr.20050529180421.33">The IMPORT tag, which must be placed inside a RULES tag, loads all rules defined
in a given ruleset into the current ruleset; in other words, it has the same
effect as copying and pasting the imported ruleset.

The only required attribute DELEGATE must be set to the name of a ruleset. To
import a ruleset defined in the current mode, just specify its name. To import a
ruleset defined in another mode, specify a name of the form mode::ruleset. Note
that the first (unnamed) ruleset in a mode is called MAIN.

One quirk is that the definition of the imported ruleset is not copied to the
location of the IMPORT tag, but rather to the end of the containing ruleset.
This has implications with rule-ordering; see the section called Rule Ordering
Requirements.

Here is an example from the PHP mode, which extends the inline JavaScript
highlighting to support embedded PHP:


   &lt;RULES SET="JAVASCRIPT+PHP"&gt;

   &lt;SPAN TYPE="MARKUP" DELEGATE="php::PHP"&gt;
       &lt;BEGIN&gt;&amp;lt;?php&lt;/BEGIN&gt;
       &lt;END&gt;?&amp;gt;&lt;/END&gt;
   &lt;/SPAN&gt;
   
   &lt;SPAN TYPE="MARKUP" DELEGATE="php::PHP"&gt;
       &lt;BEGIN&gt;&amp;lt;?&lt;/BEGIN&gt;
       &lt;END&gt;?&amp;gt;&lt;/END&gt;
   &lt;/SPAN&gt;
   
   &lt;SPAN TYPE="MARKUP" DELEGATE="php::PHP"&gt;
       &lt;BEGIN&gt;&amp;lt;%=&lt;/BEGIN&gt;
       &lt;END&gt;%&amp;gt;&lt;/END&gt;
   &lt;/SPAN&gt;

   &lt;IMPORT DELEGATE="javascript::MAIN"/&gt;
&lt;/RULES&gt;</t>
<t tx="ekr.20050529180421.34">The KEYWORDS tag, which must be placed inside a RULES tag and can only appear
once, specifies a list of keywords to highlight. Keywords are similar to SEQs,
except that SEQs match anywhere in the text, whereas keywords only match whole
words. Words are considered to be runs of text separated by non-alphanumeric
characters.

The KEYWORDS tag does not define any attributes.

Each child element of the KEYWORDS tag is an element whose name is a token type,
and whose content is the keyword to highlight.

&lt;KEYWORDS&gt;
  &lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
  &lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
  &lt;KEYWORD3&gt;int&lt;/KEYWORD3&gt;
  &lt;KEYWORD3&gt;void&lt;/KEYWORD3&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="ekr.20050529180421.35">The MARK_FOLLOWING rule, which must be placed inside a RULES tag, highlights
from the start of the match to the next syntax token. The text to match is
specified between opening and closing MARK_FOLLOWING tags.

The following attributes are supported:

TYPE - The token type to highlight the text with. See the section called Token
Types for a list of token types.

AT_LINE_START - If set to TRUE, the sequence will only be highlighted if it
occurs at the beginning of a line.

AT_WHITESPACE_END - If set to TRUE, the sequence will only be highlighted if it
is the first non-whitespace text in the line.

AT_WORD_START - If set to TRUE, the sequence will only be highlighted if it
occurs at the beginning of a word.

EXCLUDE_MATCH - If set to TRUE, the match will not be highlighted, only the text
after it will.

Here is a rule that highlights variables in Unix shell scripts ($CLASSPATH,$IFS, etc):

&lt;MARK_FOLLOWING TYPE="KEYWORD2"&gt;$&lt;/MARK_FOLLOWING&gt;</t>
<t tx="ekr.20050529180421.36">The MARK_PREVIOUS rule, which must be placed inside a RULES tag, highlights from
the end of the previous syntax token to the matched text. The text to match is
specified between opening and closing MARK_PREVIOUS tags. The following
attributes are supported:

TYPE - The token type to highlight the text with. See the section called Token
Types for a list of token types.

AT_LINE_START - If set to TRUE, the sequence will only be highlighted if it
occurs at the beginning of a line.

AT_WHITESPACE_END - If set to TRUE, the sequence will only be highlighted if it
is the first non-whitespace text in the line.

AT_WORD_START - If set to TRUE, the sequence will only be highlighted if it
occurs at the beginning of a word.

EXCLUDE_MATCH - If set to TRUE, the match will not be highlighted, only the text
before it will.

Here is a rule that highlights labels in Java mode (for example, XXX:):

&lt;MARK_PREVIOUS AT_WHITESPACE_END="TRUE" EXCLUDE_MATCH="TRUE"&gt;:&lt;/MARK_PREVIOUS&gt;</t>
<t tx="ekr.20050529180421.37">Each mode definition must begin with the following:

&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

Each mode definition must also contain exactly one MODE tag. All other tags (PROPS, RULES) must be placed inside the MODE tag. The MODE tag does not have any defined attributes. Here is an example:

&lt;MODE&gt;
    ... mode definition goes here ...
&lt;/MODE&gt;</t>
<t tx="ekr.20050529180421.38">The PROPS tag and the PROPERTY tags inside it are used to define mode-specific
properties. Each PROPERTY tag must have a NAME attribute set to the property's
name, and a VALUE attribute with the property's value.

All buffer-local properties listed in the section called Buffer-Local
Properties may be given values in edit modes.

The following mode properties specify commenting strings:

* commentEnd - the comment end string, used by the Range Comment command.
* commentStart - the comment start string, used by the Range Comment command.
* lineComment - the line comment string, used by the Line Comment command. 

When performing auto indent, a number of mode properties determine the resulting indent level:

* The line and the one before it are scanned for brackets listed in the
indentCloseBrackets and indentOpenBrackets properties. Opening brackets in the
previous line increase indent.

If lineUpClosingBracket is set to true, then closing brackets on the current
line will line up with the line containing the matching opening bracket. For
example, in Java mode lineUpClosingBracket is set to true, resulting in brackets
being indented like so:

{
    // Code
    {
        // More code
    }
}

If lineUpClosingBracket is set to false, the line after a closing bracket will
be lined up with the line containing the matching opening bracket. For example,
in Lisp mode lineUpClosingBracket is set to false, resulting in brackets being
indented like so:

(foo 'a-parameter
    (crazy-p)
    (bar baz ()))
(print "hello world")

* If the previous line contains no opening brackets, or if the
doubleBracketIndent property is set to true, the previous line is checked
against the regular expressions in the indentNextLine and indentNextLines
properties. If the previous line matches the former, the indent of the current
line is increased and the subsequent line is shifted back again. If the previous
line matches the latter, the indent of the current and subsequent lines is
increased.

In Java mode, for example, the indentNextLine property is set to match control
structures such as if, else, while, and so on.

The doubleBracketIndent property, if set to the default of false, results in code indented like so:

while(objects.hasNext())
{
    Object next = objects.hasNext();
    if(next instanceof Paintable)
        next.paint(g);
}

On the other hand, settings this property to true will give the following result:

while(objects.hasNext())
    {
        Object next = objects.hasNext();
        if(next instanceof Paintable)
            next.paint(g);
    }

Here is the complete &lt;PROPS&gt; tag for Java mode:

&lt;PROPS&gt;
    &lt;PROPERTY NAME="commentStart" VALUE="/*" /&gt;
    &lt;PROPERTY NAME="commentEnd" VALUE="*/" /&gt;
    &lt;PROPERTY NAME="lineComment" VALUE="//" /&gt;
    &lt;PROPERTY NAME="wordBreakChars" VALUE=",+-=&amp;lt;&amp;gt;/?^&amp;amp;*" /&gt;

    &lt;!-- Auto indent --&gt;
    &lt;PROPERTY NAME="indentOpenBrackets" VALUE="{" /&gt;
    &lt;PROPERTY NAME="indentCloseBrackets" VALUE="}" /&gt;
    &lt;PROPERTY NAME="indentNextLine"
    	VALUE="\s*(((if|while)\s*\(|else\s*|else\s+if\s*\(|for\s*\(.*\))[^{;]*)" /&gt;
    &lt;!-- set this to 'true' if you want to use GNU coding style --&gt;
    &lt;PROPERTY NAME="doubleBracketIndent" VALUE="false" /&gt;
    &lt;PROPERTY NAME="lineUpClosingBracket" VALUE="true" /&gt;
&lt;/PROPS&gt;</t>
<t tx="ekr.20050529180421.39">RULES tags must be placed inside the MODE tag. Each RULES tag defines a ruleset.
A ruleset consists of a number of parser rules, with each parser rule specifying
how to highlight a specific syntax token. There must be at least one ruleset in
each edit mode. There can also be more than one, with different rulesets being
used to highlight different parts of a buffer (for example, in HTML mode, one
rule set highlights HTML tags, and another highlights inline JavaScript). For
information about using more than one ruleset, see the section called The SPAN
Tag.

The RULES tag supports the following attributes, all of which are optional: 

SET the name of this ruleset. All rulesets other than the first must have a
name.

IGNORE_CASE if set to FALSE, matches will be case sensitive. Otherwise, case
will not matter. Default is TRUE.

NO_WORD_SEP Any non-alphanumeric character not in this list is treated as a word
separator for the purposes of syntax highlighting.

DEFAULT The token type for text which doesn't match any specific rule. Default
is NULL. See the section called Token Types for a list of token types.

HIGHLIGHT_DIGITS DIGIT_RE

If the HIGHLIGHT_DIGITS attribute is set to TRUE, jEdit will attempt to
highlight numbers in this ruleset.

Any word consisting entirely of digits (0-9) will be highlighted with the DIGIT
token type. A word that contains other letters in addition to digits will be
highlighted with the DIGIT token type only if it matches the regular expression
specified in the DIGIT_RE attribute. If this attribute is not specified, it will
not be highlighted.

Here is an example DIGIT_RE regular expression that highlights Java-style
numeric literals (normal numbers, hexadecimals prefixed with 0x, numbers
suffixed with various type indicators, and floating point literals containing an
exponent):

DIGIT_RE="(0x[[:xdigit:]]+|[[:digit:]]+(e[[:digit:]]*)?)[lLdDfF]?"

Here is an example RULES tag:

&lt;RULES IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
    ... parser rules go here ...
&lt;/RULES&gt;</t>
<t tx="ekr.20050529180421.40">The SEQ rule, which must be placed inside a RULES tag, highlights fixed
sequences of text. The text to highlight is specified between opening and
closing SEQ tags. The following attributes are supported:

TYPE - the token type to highlight the sequence with. See the section called
Token Types for a list of token types.

AT_LINE_START - If set to TRUE, the sequence will only be highlighted if it
occurs at the beginning of a line.

AT_WHITESPACE_END - If set to TRUE, the sequence will only be highlighted if it
is the first non-whitespace text in the line.

AT_WORD_START - If set to TRUE, the sequence will only be highlighted if it
occurs at the beginning of a word.

DELEGATE - if this attribute is specified, all text after the sequence will be
highlighted using this ruleset. To delegate to a ruleset defined in the current
mode, just specify its name. To delegate to a ruleset defined in another mode,
specify a name of the form mode::ruleset. Note that the first (unnamed) ruleset
in a mode is called MAIN.

The following rules highlight a few Java operators:

&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;</t>
<t tx="ekr.20050529180421.41">The SEQ_REGEXP rule is similar to the SEQ rule except the match sequence is
taken to be a regular expression.

In addition to the attributes supported by the SEQ tag, the HASH_CHAR attribute
must be specified. It must be set to the first character that the regular
expression matches. This rules out using regular expressions which can match
more than one character at the start position. The regular expression match
cannot span more than one line, either.

Here is an example of a SEQ_REGEXP rule that highlights Perl's matcher
constructions such as m/(.+):(\d+):(.+)/:

&lt;SEQ_REGEXP TYPE="MARKUP"
    HASH_CHAR="m"
    AT_WORD_START="TRUE"
&gt;m([[:punct:]])(?:.*?[^\\])*?\1[sgiexom]*&lt;/SEQ_REGEXP&gt;</t>
<t tx="ekr.20050529180421.42">The SPAN rule, which must be placed inside a RULES tag, highlights text between
a start and end string. The start and end strings are specified inside child
elements of the SPAN tag. The following attributes are supported:

TYPE - The token type to highlight the span with. See the section called Token
Types for a list of token types.

AT_LINE_START - If set to TRUE, the span will only be highlighted if the start
sequence occurs at the beginning of a line.

AT_WHITESPACE_END - If set to TRUE, the span will only be highlighted if the
start sequence is the first non-whitespace text in the line.

AT_WORD_START - If set to TRUE, the span will only be highlighted if the start
sequence occurs at the beginning of a word.

DELEGATE - text inside the span will be highlighted with the specified ruleset.
To delegate to a ruleset defined in the current mode, just specify its name. To
delegate to a ruleset defined in another mode, specify a name of the form
mode::ruleset. Note that the first (unnamed) ruleset in a mode is called
MAIN.

EXCLUDE_MATCH - If set to TRUE, the start and end sequences will not be
highlighted, only the text between them will.

NO_ESCAPE - If set to TRUE, the ruleset's escape character will have no effect
before the span's end string. Otherwise, the presence of the escape character
will cause that occurrence of the end string to be ignored.

NO_LINE_BREAK - If set to TRUE, the span will not cross line breaks.

NO_WORD_BREAK - If set to TRUE, the span will not cross word breaks.

Note that the AT_LINE_START, AT_WHITESPACE_END and AT_WORD_START attributes can
also be used on the BEGIN and END elements. Setting these attributes to the same
value on both elements has the same effect as setting them on the SPAN element.

Here is a SPAN that highlights Java string literals, which cannot include line breaks:

&lt;SPAN TYPE="LITERAL1" NO_LINE_BREAK="TRUE"&gt;
  &lt;BEGIN&gt;"&lt;/BEGIN&gt;
  &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

Here is a SPAN that highlights Java documentation comments by delegating to the JAVADOC ruleset defined elsewhere in the current mode:

&lt;SPAN TYPE="COMMENT2" DELEGATE="JAVADOC"&gt;
  &lt;BEGIN&gt;/**&lt;/BEGIN&gt;
  &lt;END&gt;*/&lt;/END&gt;
&lt;/SPAN&gt;

Here is a SPAN that highlights HTML cascading stylesheets inside &lt;STYLE&gt; tags by delegating to the main ruleset in the CSS edit mode:

&lt;SPAN TYPE="MARKUP" DELEGATE="css::MAIN"&gt;
  &lt;BEGIN&gt;&amp;lt;style&amp;gt;&lt;/BEGIN&gt;
  &lt;END&gt;&amp;lt;/style&amp;gt;&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="ekr.20050529180421.43">The SPAN_REGEXP rule is similar to the SPAN rule except the start sequence is
taken to be a regular expression.

In addition to the attributes supported by the SPAN tag, the HASH_CHAR attribute
must be specified. It must be set to the first character that the regular
expression matches. This rules out using regular expressions which can match
more than one character at the start position. The regular expression match
cannot span more than one line, either.

Any text matched by groups in the BEGIN regular expression is substituted in the
END string. See below for an example of where this is useful. 

Here is a SPAN_REGEXP rule that highlights read-ins in shell scripts:

&lt;SPAN_REGEXP HASH_CHAR="&lt;" TYPE="LITERAL1" DELEGATE="LITERAL"&gt;
    &lt;BEGIN&gt;&lt;![CDATA[&lt;&lt;[[:space:]'"]*([[:alnum:]_]+)[[:space:]'"]*]]&gt;&lt;/BEGIN&gt;
    &lt;END&gt;$1&lt;/END&gt;
&lt;/SPAN_REGEXP&gt;

Here is a SPAN_REGEXP rule that highlights constructs placed between &lt;#ftl and
&gt;, as long as the &lt;#ftl is followed by a word break:

&lt;SPAN_REGEXP TYPE="KEYWORD1" HASH_CHAR="&amp;lt;" DELEGATE="EXPRESSION"&gt;
    &lt;BEGIN&gt;&amp;lt;#ftl\&amp;gt;&lt;/BEGIN&gt;
    &lt;END&gt;&amp;gt;&lt;/END&gt;
&lt;/SPAN_REGEXP&gt;</t>
<t tx="ekr.20050529180421.44">The TERMINATE rule, which must be placed inside a RULES tag, specifies that
parsing should stop after the specified number of characters have been read from
a line.

The number of characters to terminate after should be specified with the AT_CHAR
attribute. Here is an example:

&lt;TERMINATE AT_CHAR="1" /&gt;

This rule is used in Patch mode, for example, because only the first character
of each line affects highlighting.</t>
<t tx="ekr.20050529220821"></t>
<t tx="ekr.20050529220821.1"></t>
<t tx="ekr.20050530065723"></t>
<t tx="ekr.20050530065723.47">def parse_jEdit_file(self,fileName,verbose=False):
    
    if not fileName:
        return None
    
    if not fileName.endswith('.xml'):
        fileName = fileName + '.xml'

    path = os.path.join(g.app.loadDir,'../','modes',fileName)
    path = os.path.normpath(path)
    
    try: f = open(path)
    except IOError:
        g.trace('can not open %s'%path)
        return None

    try:
        try:
            mode = None
            parser = xml.sax.make_parser()
            # Do not include external general entities.
            # The actual feature name is "http://xml.org/sax/features/external-general-entities"
            parser.setFeature(xml.sax.handler.feature_external_ges,0)
            handler = contentHandler(self.c,fileName,verbose=verbose)
            parser.setContentHandler(handler)
            parser.parse(f)
            # if verbose: handler.printSummary()
            mode = handler.getMode()
        except:
            g.es('unexpected exception parsing %s' % (fileName),color='red')
            g.es_exception()
    finally:
        f.close()
        return mode</t>
<t tx="ekr.20050601105358">def colorOneChunk(self,allowBreak=True):
    '''Colorize a fixed number of tokens.
    If not done, queue this method again to continue coloring later.'''
    s,i = self.chunk_s,self.chunk_i
    count = 0 ; self.chunk_count += 1
    # g.trace('%3d'%(self.chunk_count),self.incremental)
    if not self.incremental:
        self.incremental = True
        &lt;&lt; queue up this method the first time &gt;&gt;
        return
    while i &lt; len(s):
        count += 1
        # Exit only after finishing the row.  This reduces flash.
        if i == 0 or s[i-1] == '\n':
            if self.kill_chunk: return
            if self.incremental and allowBreak:
                if count &gt;= 50:
                    &lt;&lt; queue up this method &gt;&gt;
                    return
        for f,kind,token_type,delegate in self.rulesDict.get(s[i],self.defaultRulesList):
            n = f(self,s,i)
            if n &gt; 0:
                self.doRule(s,i,i+n,kind,token_type,delegate)
                i += n
                break
        else:
            if self.present_ruleset.defaultColor:
                self.colorRangeWithTag(s,i,i+1,self.present_ruleset.defaultColor.lower())
            # g.trace('no match')
            i += 1

    self.removeTagsFromRange(s,self.chunk_last_i,len(s))</t>
<t tx="ekr.20050601162452.1">self.chunk_s,self.chunk_i = s,i
self.c.frame.top.after_idle(self.colorOneChunk)</t>
<t tx="ekr.20050602150619">def init_mode (self,language):
    
    # bunch = self.modes.get(language)
    bunch = self.modes.get(language)
    if bunch:
        self.mode = bunch.mode
        self.defaultRulesList=bunch.defaultRulesList
        self.keywords = bunch.keywords
        self.rulesDict=bunch.rulesDict
        self.word_chars = bunch.word_chars
    else:
        self.mode = mode = self.parse_jEdit_file(language)
        if mode:
            g.trace(language)
            # Handle only the main rulese here.
            rulesets = mode.getRulesets()
            self.present_ruleset = ruleset = rulesets[0]
            # mode.printSummary (printStats=False)
            self.keywords,self.word_chars = self.init_keywords(mode,ruleset)
                # Sets self.word_chars: must be called before createRuleMatchers.
            self.createRuleMatchers(ruleset.rules)
                # Sets self.defaultRulesList &amp; self.rulesDict.
            bunch = g.bunch(mode=mode,
                defaultRulesList=self.defaultRulesList,
                keywords=self.keywords,
                rulesDict=self.rulesDict,
                word_chars=self.word_chars)
            self.modes[language] = bunch
        elif language:
            g.trace('No language description for %s' % language)</t>
<t tx="ekr.20050602152743">def init_keywords (self,mode,ruleset):
    
    '''Initialize the keywords for the present language.
    
     Set word_chars to all non-alpha characters appearing in any keyword'''

    # Add any new user keywords to leoKeywords.
    for d in g.globalDirectiveList:
        name = '@' + d
        if name not in leoKeywords:
            leoKeywords.append(name)
    # Create a single keywords dict.
    keywords = {}
    for key in leoKeywords:
        keywords[key] = 0

    for i in (1,2,3,4):
        keys = mode.getKeywords(i,ruleset)
        for key in keys:
            if keywords.get(key):
                print 'keyword %s defined in multiple places' % key
            keywords[key] = i
    # g.trace(len(keywords.keys()))
    # Create the word_chars list. 
    word_chars = {}
    for ch in string.letters:
        word_chars[ch] = None
    for keys in keywords.keys():
        for word in keys:
            for ch in word:
                word_chars[ch] = None
    if 0: # Testing.
        &lt;&lt; compute extra_word_chars &gt;&gt;
            
    return keywords,word_chars</t>
<t tx="ekr.20050602205810.4">def colorRangeWithTag (self,s,i,j,tag):

    if self.was_non_incremental:
        must_color = True
        self.removeOldTagsFromRange(s,self.chunk_last_i,j)
    elif self.rangeColoredWithTag(i,j,tag):
        must_color = False
        # Remove the old tags to i.
        self.removeTagsFromRange(s,self.chunk_last_i,i)
    else:
        must_color = True
        # Remove the old tags to j.
        self.removeTagsFromRange(s,self.chunk_last_i,j)

    if must_color:
        # Remember the new tags.
        for k in xrange(i,j):
            self.colored_ranges[k] = tag

        # Do the real coloring.
        row,col = g.convertPythonIndexToRowCol(s,i)
        x1 = '%d.%d' % (row+1,col)
        row,col = g.convertPythonIndexToRowCol(s,j)
        x2 = '%d.%d' % (row+1,col)
        self.body.tag_add(tag,x1,x2)

    self.chunk_last_i = j</t>
<t tx="ekr.20050605130806">self.chunk_s,self.chunk_i = s,i
self.c.frame.top.after(50,self.colorOneChunk)</t>
<t tx="ekr.20050606214954"></t>
<t tx="ekr.20050606221357"></t>
<t tx="ekr.20050607073917">extra_word_chars = {}
for ch in word_chars:
    if ch not in string.letters and ch not in extra_word_chars:
        extra_word_chars[ch] = None</t>
<t tx="ekr.20050607212958">def colorByDelegate(self,delegate,s,i,j,token_type):
    
    # g.trace(delegate,repr(s[i:j]))
    
    if -1 == delegate.find('::'):
        # Use the ruleset in the present mode.
        rulesetName = delegate
    else:
        # file::ruleset
        file,rulesetName = delegate.split('::')
        self.init_mode(file)
        
    ruleset = self.mode.getRuleset(name=rulesetName)
    if ruleset:
        # self.mode.printRuleset(ruleset,tag=delegate)
        # Save ivars
        ### Bug: this doesn't handle nested delegates.
        ### Fix: don't save here:  move the ivars to the ruleset class and keep a stack of rulesets.
        self.save_present_ruleset = self.present_ruleset
        self.save_keywords = self.keywords # A bunch.
        self.save_word_chars = self.word_chars.copy()
        self.save_defaultRulesList = self.defaultRulesList[:]
        self.save_rulesDict = self.rulesDict.copy()
        # Set ivars for the delegated string only.
        # Sart at the real zero so row/column numbers are computed properly.
        self.chunk_s = s[0:j+1]
        self.chunk_i = i # Required.
        self.present_ruleset = ruleset
        self.keywords,self.word_chars = self.init_keywords(self.mode,ruleset)
        self.createRuleMatchers(ruleset.rules) # Sets self.defaultRulesList &amp; self.rulesDict.
        # Do the coloring with no break.
        self.colorOneChunk(allowBreak=False) 
        # Restore ivars.
        self.chunk_s = s
        self.chunk_i = j+1
        self.present_ruleset = self.save_present_ruleset
        self.keywords = self.save_keywords
        self.word_chars = self.save_word_chars
        self.defaultRulesList = self.save_defaultRulesList
        self.rulesDict = self.save_rulesDict</t>
<t tx="ekr.20050607220512"># To do: honor default:comment3 attribute of ruleset.</t>
<t tx="ekr.20050612074047"></t>
<t tx="ekr.20050718142601"></t>
<t tx="ekr.20050718142601.1">@nocolor

- The find frame is no longer global, so g.app.findFrame no longer exists.

- Added gui arg in wxLeoFrame ctor.

- Changed trace to g.trace, es to g.es, etc.

- Changed calling sequence of setTopGeometry to (self,w,h,x,y,adjustSize=True):</t>
<t tx="ekr.20050718142601.3"># The find window is no longer global.

g.app.findFrame = wxFindFrame()
g.app.globalWindows.append(g.app.findFrame)</t>
<t tx="ekr.20050718151826"></t>
<t tx="ekr.20050722075812">for p in p.self_and_subtree_iter():
    s = p.bodyString()
    target = s.rstrip()
    if s != target:
        p.setBodyStringOrPane(target)
        g.es(p.headString())</t>
<t tx="ekr.20050724100334">c.prettyPrintPythonNode()</t>
<t tx="ekr.20050817115636.2">import sys
sys.path.append(r'c:\reportlab_1_20') 

if 1: # This dependency could easily be removed.
    # Used only for tracing and error reporting.
    import leoGlobals as g
    
try:
    # from reportlab.lib.enums import *
    # from reportlab.platypus import *
    
    # Formatting imports...
    import docutils
    import reportlab.platypus
    import reportlab.platypus.para
    import stylesheet # To do: get this a better way.
    
    # General imports...
    import StringIO
    import time
    import types
except ImportError:
    pass



</t>
<t tx="ekr.20050817115636.4">class Writer (docutils.writers.Writer):
	
	&lt;&lt; class Writer declarations &gt;&gt;

	@others</t>
<t tx="ekr.20050817115636.5">supported = ('pdf','rlpdf')
"""Formats this writer supports."""

settings_spec = (
    'PDF-Specific Options',
    None,
    (
        # EKR: added this entry.
    (   'Specify a stylesheet URL, used verbatim.  Overrides '
        '--stylesheet-path.  Either --stylesheet or --stylesheet-path '
        'must be specified.',
        ['--stylesheet'],
        {'metavar': '&lt;URL&gt;', 'overrides': 'stylesheet_path'}),
         
    (   'Specify a stylesheet file, relative to the current working '
        'directory.  The path is adjusted relative to the output HTML '
        'file.  Overrides --stylesheet.',
        ['--stylesheet-path'],
        {'metavar': '&lt;file&gt;', 'overrides': 'stylesheet'}),

    (   'Format for footnote references: one of "superscript" or '
        '"brackets".  Default is "brackets".',
        ['--footnote-references'],
        {'choices': ['superscript', 'brackets'], 'default': 'brackets',
        'metavar': '&lt;FORMAT&gt;'}),
    )
)

output = None
"""Final translated form of `document`."""</t>
<t tx="ekr.20050817115636.6">def __init__(self):

    docutils.writers.Writer.__init__(self)

    # self.translator_class = PDFTranslator</t>
<t tx="ekr.20050817115636.7">def translate(self):
    
    '''Do final translation of self.document into self.output.'''
    
    if 1: # Production code.
        visitor = PDFTranslator(self,self.document)
    else: # Use intermediate file, and dummy pdf translator.
        # We can modify the intermediate file by hand to test proposed code generation.
        try:
            filename = 'intermediateFile.txt'
            s = file(filename).read()
            # g.trace('creating .pdf file from %s...' % filename)
            visitor = dummyPDFTranslator(self,self.document,s)
        except IOError:
            # g.trace('can not open %s' % filename)
            return

    # Create a list of paragraphs using Platypus.
    self.document.walkabout(visitor)
    story = visitor.as_what()
    
    if 0: # Not useful: story is a list of reportlab.platypus.para.Para objects.
        # Use the trace in createParagraph instead.
        g.trace('story','*'*40)
        print story        
    
    # Generate self.output.  Gets sent to reportlab.
    self.output = self.createPDF_usingPlatypus(story)
    # Solve the newline problem by brute force.
    self.output = self.output.replace('\n\r','\n')
    self.output = self.output.replace('\r\n','\n')
    if 0: # This is the actual .pdf output returned from doc.build(story)
        # doc is a Platypus (and this reportlab) document.
        g.trace('output','*'*40)
        lines = g.splitLines(self.output)
        g.printList(lines)</t>
<t tx="ekr.20050817115636.8">def createPDF_usingPlatypus (self,story):

    out = StringIO.StringIO()

    doc = reportlab.platypus.SimpleDocTemplate(out,
        pagesize=reportlab.lib.pagesizes.A4)

    doc.build(story)

    return out.getvalue()</t>
<t tx="ekr.20050817115636.9">def lower(self):

    return 'pdf'</t>
<t tx="ekr.20050817120850.1">@first #! /usr/bin/env python

&lt;&lt; docstring &gt;&gt;

# Note: you must copy this file to the Python/Lib/site-packages/docutils/writers folder.

@language python
@tabwidth -4

&lt;&lt; about this code &gt;&gt;
&lt;&lt; copyright &gt;&gt;
&lt;&lt; version history &gt;&gt;
&lt;&lt; to do &gt;&gt;

__version__ = '0.4'
__docformat__ = 'reStructuredText'
&lt;&lt; imports &gt;&gt;

@others</t>
<t tx="ekr.20050817120850.10">class PDFTranslator (docutils.nodes.NodeVisitor):

	@others

    depart_comment = invisible_visit
    visit_substitution_definition = visit_comment
    depart_substitution_definition = depart_comment
    visit_figure = visit_comment
    depart_figure = depart_comment

    visit_sidebar = invisible_visit
    visit_warning = invisible_visit
    visit_tip = invisible_visit
    visit_tbody = invisible_visit
    visit_thead = invisible_visit
    visit_tgroup = invisible_visit
    visit_table = invisible_visit
    visit_title_reference = invisible_visit
    visit_transition = invisible_visit
    visit_pending = invisible_visit
    depart_pending = invisible_visit
    depart_transition = invisible_visit
    depart_title_reference = invisible_visit
    depart_table = invisible_visit
    depart_tgroup = invisible_visit
    depart_thead = invisible_visit
    depart_tbody = invisible_visit
    depart_tip = invisible_visit
    depart_warning = invisible_visit
    depart_sidebar = invisible_visit</t>
<t tx="ekr.20050817120850.11">def __init__(self, writer,doctree):

    self.writer = writer
    self.settings = settings = doctree.settings
    self.styleSheet = stylesheet.getStyleSheet()
    docutils.nodes.NodeVisitor.__init__(self, doctree) # Init the base class.
    self.language = docutils.languages.get_language(doctree.settings.language_code)
    
    self.in_docinfo = False
    self.head = [] # Set only by meta() method.  
    self.body = [] # The body text being accumulated.
    self.foot = []
    self.sectionlevel = 0
    self.context = []
    
    self.story = []
    self.bulletText = '\267'
        # maybe move this into stylesheet.
        # This looks like the wrong glyph.

    if 0: # no longer used.
        self.topic_class = ''
        self.bulletlevel = 0
</t>
<t tx="ekr.20050817120850.12">def as_what(self):

    return self.story
</t>
<t tx="ekr.20050817120850.13">def encode(self, text):

    """Encode special characters in `text` &amp; return."""
    if type(text) is types.UnicodeType:
        text = text.replace(u'\u2020', u' ')
        text = text.replace(u'\xa0', u' ')
        text = text.encode('utf-8')
    #text = text.replace("&amp;", "&amp;amp;")
    #text = text.replace("&lt;", '"')
    #text = text.replace('"', "(quot)")
    #text = text.replace("&gt;", '"')
    # footnotes have character values above 128 ?
    return text
</t>
<t tx="ekr.20050817120850.14">def createParagraph (self,text,style='Normal',bulletText=None):

    if type(text) in (types.ListType,types.TupleType):
        text = ''.join([self.encode(t) for t in text])

    if not style.strip(): ### EKR
        style = 'Normal'
        
    if 0:
        s = text.split('&gt;')
        s = '&gt;\n'.join(s)
        print
        if 1: # just print the text.
            print s
        else:
            g.trace('%8s\n\n%s' % (style,s))
        print

    style = self.styleSheet [style]
    
    try:
        self.story.append(
            reportlab.platypus.para.Paragraph (
                self.encode(text), style,
                bulletText = bulletText,
                context = self.styleSheet))
    except Exception:
        g.es_print('Exception in createParagraph')
        g.es_exception()
        self.dumpContext()
        raise</t>
<t tx="ekr.20050817120850.15"># The suffix is always '\n' except for a cant-happen situation.

def starttag (self,node,tagname,suffix='\n',caller='',**attributes):
    
    # g.trace(repr(attributes))
    atts = {}
    for (name,value) in attributes.items():
        atts [name.lower()] = value
    for att in ('class',): # append to node attribute
        if node.has_key(att):
            if atts.has_key(att):
                atts [att] = node [att] + ' ' + atts [att]
    for att in ('id',): # node attribute overrides
        if node.has_key(att):
            atts [att] = node [att]
    
    attlist = atts.items() ; attlist.sort()
    parts = [tagname]
    # Convert the attributes in attlist to a single string.
    for name, value in attlist:
        # g.trace('attlist element:',repr(name),repr(value))
        if value is None: # boolean attribute
            parts.append(name.lower().strip())
        elif isinstance(value,types.ListType):
            values = [str(v) for v in value]
            val = ' '.join(values).strip()
            parts.append('%s="%s"' % (
                name.lower(), self.encode(val)))
        else:
            parts.append('%s="%s"' % (
                name.lower(),self.encode(str(value).strip())))

    val = '&lt;%s&gt;%s' % (' '.join(parts),suffix)
    # g.trace('%-24s %s' % (caller,val))
    return val</t>
<t tx="ekr.20050817120850.18">def visit_admonition(self, node, name):
    pass

def depart_admonition(self):
    pass
</t>
<t tx="ekr.20050817120850.20">def visit_attention(self, node):

    self.visit_admonition(node, 'attention')

def depart_attention(self, node):

    self.depart_admonition()
</t>
<t tx="ekr.20050817120850.22">def visit_author(self, node):
    self.visit_docinfo_item(node, 'author')

def depart_author(self, node):
    self.depart_docinfo_item()
</t>
<t tx="ekr.20050817120850.24">def visit_address(self, node):
    self.visit_docinfo_item(node, 'address')

def depart_address(self, node):
    self.depart_docinfo_item()
</t>
<t tx="ekr.20050817120850.26">def visit_version(self, node):
    self.visit_docinfo_item(node, 'version')

def depart_version(self, node):
    self.depart_docinfo_item()
</t>
<t tx="ekr.20050817120850.28">def visit_system_message(self, node):
    pass

def depart_system_message(self, node):
    pass
</t>
<t tx="ekr.20050817120850.30">def visit_term (self,node):

    self.push(kind='dt')

    self.body.append(
        self.starttag(node,'dt',suffix='',caller='visit_term'))

def depart_term (self,node):

    self.pop('dt')</t>
<t tx="ekr.20050817120850.32">def visit_authors(self, node):
    pass

def depart_authors(self, node):
    pass
</t>
<t tx="ekr.20050817120850.34">def visit_block_quote(self, node):
    pass
    
def depart_block_quote(self, node):
    pass</t>
<t tx="ekr.20050817120850.36">def visit_bullet_list(self, node):
    
    self.push(kind='ul',start=len(self.body))

    # At present self.bulletText is a constant.
    self.body.append('&lt;ul bulletText="%s"&gt;' % self.bulletText)

def depart_bullet_list(self, node):
    
    b = self.pop('ul')

    self.body.append('&lt;/ul&gt;')
    
    if not self.inContext('ul'):
        self.putTail(b.start)</t>
<t tx="ekr.20050817120850.39">def visit_caption(self, node):
    pass

def depart_caption(self, node):
    pass
</t>
<t tx="ekr.20050817120850.40">def visit_caution(self, node):
    self.visit_admonition(node, 'caution')

def depart_caution(self, node):
    self.depart_admonition()
</t>
<t tx="ekr.20050817120850.42">def visit_citation(self, node):
    pass

def depart_citation(self, node):
    pass
</t>
<t tx="ekr.20050817120850.44">def visit_citation_reference(self, node):
    pass

def depart_citation_reference(self, node):
    pass
</t>
<t tx="ekr.20050817120850.46">def visit_classifier(self, node):
    pass

def depart_classifier(self, node):
    pass
</t>
<t tx="ekr.20050817120850.48">def visit_colspec(self, node):
    pass

def depart_colspec(self, node):
    pass
</t>
<t tx="ekr.20050817120850.50">def visit_contact(self, node):
    
    self.visit_docinfo_item(node, 'contact')

def depart_contact(self, node):

    self.depart_docinfo_item()
</t>
<t tx="ekr.20050817120850.52">def visit_copyright(self, node):
    
    self.visit_docinfo_item(node, 'copyright')

def depart_copyright(self, node):

    self.depart_docinfo_item()
</t>
<t tx="ekr.20050817120850.54">def visit_danger(self, node):
    
    self.visit_admonition(node, 'danger')

def depart_danger(self, node):

    self.depart_admonition()
</t>
<t tx="ekr.20050817120850.56">def visit_date(self, node):
    
    self.visit_docinfo_item(node, 'date')

def depart_date(self, node):
    
    self.depart_docinfo_item()

</t>
<t tx="ekr.20050817120850.58">def visit_definition(self, node):
    
    self.push(kind='dd')

    self.body.append('&lt;/dt&gt;')
    self.body.append(
        self.starttag(node,'dd',caller='visit_destination'))

def depart_definition(self, node):
    
    self.pop('dd')
    self.body.append('&lt;/dd&gt;')</t>
<t tx="ekr.20050817120850.60">def visit_definition_list(self, node):
    
    self.push(kind='dl',start=len(self.body))
    
    self.body.append(self.starttag(node, 'dl'))

def depart_definition_list(self, node):
    
    b = self.pop('dl')

    self.body.append('&lt;/dl&gt;')

    if not self.inContext('dl'):
        self.putTail(b.start)
</t>
<t tx="ekr.20050817120850.62">def visit_definition_list_item(self, node):
    pass

def depart_definition_list_item(self, node):
    pass</t>
<t tx="ekr.20050817120850.64">def visit_description(self, node):
    pass

def depart_description(self, node):
    pass
</t>
<t tx="ekr.20050817120850.66"></t>
<t tx="ekr.20050817120850.68">def visit_docinfo_item(self, node, name):
    
    self.body.append(
        '&lt;para style="DocInfo"&gt;&lt;b&gt;%s: &lt;/b&gt;' % (
            self.language.labels[name]))

def depart_docinfo_item(self):
    
    self.body.append('&lt;/para&gt;')
</t>
<t tx="ekr.20050817120850.70">def visit_doctest_block(self, node):
    
    self.visit_literal_block(node)

def depart_doctest_block(self, node):
    
    self.depart_literal_block(node)

</t>
<t tx="ekr.20050817120850.72">def visit_line_block(self, node):
    self.visit_literal_block(node)

def depart_line_block(self, node):
    self.depart_literal_block(node)
</t>
<t tx="ekr.20050817120850.74">def visit_document(self, node):
    pass
    
def depart_document(self, node):
    pass</t>
<t tx="ekr.20050817120850.76">def visit_emphasis(self, node):
    
    self.push(kind='i')
    
    self.body.append('&lt;i&gt;')

def depart_emphasis(self, node):
    
    self.pop('i')

    self.body.append('&lt;/i&gt;')
</t>
<t tx="ekr.20050817120850.78">def visit_entry(self, node):
    pass

def depart_entry(self, node):
    pass
</t>
<t tx="ekr.20050817120850.80">def visit_enumerated_list(self, node):
    
    self.push(kind='ol',start=len(self.body))

    self.body.append('&lt;ol&gt;')

def depart_enumerated_list(self, node):
    
    b = self.pop('ol')

    self.body.append('&lt;/ol&gt;')

    if not self.inContext('ol'):
        self.putTail(b.start)</t>
<t tx="ekr.20050817120850.82">def visit_error(self, node):
    self.visit_admonition(node, 'error')

def depart_error(self, node):
    self.depart_admonition()</t>
<t tx="ekr.20050817120850.84">def visit_field(self, node):
    
    self.body.append('&lt;para&gt;')

def depart_field(self, node):

    self.body.append('&lt;/para&gt;')
</t>
<t tx="ekr.20050817120850.86">def visit_field_argument(self, node):
    pass

def depart_field_argument(self, node):
    pass
</t>
<t tx="ekr.20050817120850.88">def visit_field_list(self, node):
    
    self.push(kind='&lt;para&gt;',start=len(self.body))

def depart_field_list(self, node):
    
    b = self.pop('&lt;para&gt;')
    
    self.body.append('&lt;/para&gt;')
    
    self.putTail(b.start)</t>
<t tx="ekr.20050817120850.90">def visit_field_name(self, node):

    self.body.append('&lt;b&gt;')

def depart_field_name(self, node):

    self.body.append(': &lt;/b&gt;')</t>
<t tx="ekr.20050817120850.92">def visit_field_body(self, node):
    pass

def depart_field_body(self, node):
    pass
</t>
<t tx="ekr.20050817120850.94">def visit_footnote(self, node):
    
    self.push(kind='footnotes',context=[])

    self.footnote_backrefs(node)

def depart_footnote(self, node):
    
    self.pop('footnotes')

    self.footnote_backrefs_depart(node)
</t>
<t tx="ekr.20050817120850.95">@ Bug fixes, EKR 8/22/05:
    - Get attributes from node.attributes, not node.
    - The proper key is 'ids', not 'id'
Warning: this does not work for auto-numbered footnotes.
@c

def footnote_backrefs (self,node):
    
    '''Create b.link and b.setLink for visit/depart_label.'''
    
    # self.dumpNode(node,tag='backrefs-node')
    
    b = self.peek('footnotes')
    a = node.attributes ; backrefs = a.get('backrefs',[]) # EKR.

    # Set b.setLink.
    b.setLink = self.starttag(
        {},'setLink','',destination=a['ids']) # EKR.

    # Set b.links.
    b.links = []
    if self.settings.footnote_backlinks:
        for backref in backrefs:
            b.links.append(
                self.starttag(
                    {},'link',suffix='',destination=backref))</t>
<t tx="ekr.20050817120850.96">def footnote_backrefs_depart(self, node):

    if not self.context and self.body:
        self.createParagraph(self.body)
        self.body = []
</t>
<t tx="ekr.20050817120850.98">@ Bug fixes, EKR 8/22/05:
    - Get attributes from node.attributes, not node.
    - The proper key is 'ids', not 'id'
@c

def visit_footnote_reference (self,node):
    
    '''Generate code for a footnote reference.'''
    
    # self.dumpNode(node,tag='footnote-ref-node')

    markup = [] # The terminating markup to be supplied by depart_footnote_reference.
    a = node.attributes # EKR.
    if self.settings.footnote_backlinks and a.get('ids'):
        self.body.append(
            self.starttag(node,'setLink','',destination=a['ids']))
        markup.append('&lt;/setLink&gt;')
    
    if   node.hasattr('refid'):   href = a ['refid']
    elif node.hasattr('refname'): href = self.document.nameids [a ['refname']]
    else:                         href = ''
    # g.trace('href:',href)

    format = self.settings.footnote_references
    if format == 'brackets':
        suffix = '[' ; markup.append(']')
    elif format == 'superscript':
        suffix = '&lt;super&gt;' ; markup.append('&lt;/super&gt;')
    else: # shouldn't happen
        suffix = None

    if suffix:
        self.body.append(
            self.starttag(node,'link',suffix,destination=href))
        markup.append('&lt;/link&gt;')

    markup.reverse()
    self.push(kind='footnote-ref',markup=markup)</t>
<t tx="ekr.20050817120850.99">def depart_footnote_reference(self, node):
    
    b = self.pop('footnote-ref')
    
    for z in b.markup:
        self.body.append(z)</t>
<t tx="ekr.20050817120850.100">def visit_hint(self, node):
    self.visit_admonition(node, 'hint')

def depart_hint(self, node):
    self.depart_admonition()
</t>
<t tx="ekr.20050817120850.102">def visit_image(self, node):
    pass

def depart_image(self, node):
    pass
</t>
<t tx="ekr.20050817120850.105">def visit_important(self, node):
    self.visit_admonition(node, 'important')

def depart_important(self, node):
    self.depart_admonition()
</t>
<t tx="ekr.20050817120850.106">def visit_interpreted(self, node):
    pass

def depart_interpreted(self, node):
    pass
</t>
<t tx="ekr.20050817120850.108">def visit_label(self, node):
    
    b = self.inContext('footnotes')
    if b:
        self.body.append(b.setLink)
        self.body.append('&lt;/setLink&gt;')
        # Start all links.
        for link in b.links:
            self.body.append(link)
        self.body.append('[')

def depart_label(self, node):
    
    b = self.inContext('footnotes')
    if b:
        self.body.append(']')
        # End all links.
        for link in b.links:
            self.body.append('&lt;/link&gt;')
        # Who knows why this is here...
        self.body.append('   ')</t>
<t tx="ekr.20050817120850.110">def visit_legend(self, node):
    pass

def depart_legend(self, node):
    pass
</t>
<t tx="ekr.20050817120850.112">def visit_list_item(self, node):
    
    self.push(kind='li')
    
    self.body.append('&lt;li&gt;')

def depart_list_item(self, node):
    
    self.pop('li')

    self.body.append('&lt;/li&gt;')
</t>
<t tx="ekr.20050817120850.114">def visit_literal(self, node):
    
    self.push(kind='literal')
    
def depart_literal(self, node):
    
    self.pop('literal')</t>
<t tx="ekr.20050817120850.116">def visit_literal_block(self, node):
    
    self.story.append(
        reportlab.platypus.Preformatted(
            node.astext(),self.styleSheet['Code']))

    raise docutils.nodes.SkipNode

def depart_literal_block(self, node):
    pass</t>
<t tx="ekr.20050817120850.118">def visit_meta(self, node):
    
    g.trace(**node.attributes)

    self.head.append(
        self.starttag(node, 'meta', **node.attributes))

def depart_meta(self, node):

    pass</t>
<t tx="ekr.20050817120850.120">def visit_note(self, node):
    
    self.visit_admonition(node, 'note')

def depart_note(self, node):

    self.depart_admonition()
</t>
<t tx="ekr.20050817120850.122">def visit_option(self, node):
    pass

def depart_option(self, node):
    pass
</t>
<t tx="ekr.20050817120850.124">def visit_option_argument(self, node):
    pass

def depart_option_argument(self, node):
    pass
</t>
<t tx="ekr.20050817120850.126">def visit_option_group(self, node):
    pass

def depart_option_group(self, node):
    pass
</t>
<t tx="ekr.20050817120850.128">def visit_option_list(self, node):
    
    self.push(kind='option-list',start=len(self.body))

def depart_option_list(self, node):
    
    b = self.pop('option-list')

    if not self.inContext('option_list'):
        self.putTail(b.start)
        </t>
<t tx="ekr.20050817120850.130">def visit_option_list_item(self, node):
    pass

def depart_option_list_item(self, node):
    pass
</t>
<t tx="ekr.20050817120850.132">def visit_option_string(self, node):
    pass

def depart_option_string(self, node):
    pass
</t>
<t tx="ekr.20050817120850.134">def visit_organization(self, node):
    
    self.visit_docinfo_item(node, 'organization')

def depart_organization(self, node):

    self.depart_docinfo_item()
</t>
<t tx="ekr.20050817120850.138">def visit_problematic(self, node):
    pass

def depart_problematic(self, node):
    pass
</t>
<t tx="ekr.20050817120850.140">def visit_raw(self, node):

    if node.has_key('format') and node['format'] == 'html':
        self.body.append(node.astext())

    raise docutils.nodes.SkipNode
</t>
<t tx="ekr.20050817120850.141">def visit_target (self,node):

    if not (
        node.has_key('refuri') or
        node.has_key('refid') or
        node.has_key('refname')
    ):
        href = ''
        if node.has_key('id'):
            href = node ['id']
        elif node.has_key('name'):
            href = node ['name']
        self.body.append("%s%s" % (
            self.starttag(node,'setLink',suffix='',
                destination=href,caller='visit_targtet'),
            '&lt;/setLink&gt;'))
    raise docutils.nodes.SkipNode

def depart_target (self,node):
    pass</t>
<t tx="ekr.20050817120850.143">def visit_reference (self,node):

    markup = [] ; caller = 'visit_reference'

    if node.has_key('refuri'):
        href = node ['refuri']
        self.body.append(
            self.starttag(node,'a',suffix='',href=href,caller=caller))
        markup.append('&lt;/a&gt;')
    else:
        if node.has_key('id'):
            self.body.append(
                self.starttag({},'setLink','',
                    destination=node['id'],caller=caller))
            markup.append('&lt;/setLink&gt;')
        if node.has_key('refid'):
            href = node ['refid']
        elif node.has_key('refname'):
            href = self.document.nameids [node ['refname']]
        self.body.append(
            self.starttag(node,'link','',destination=href,caller=caller))
        markup.append('&lt;/link&gt;')

    self.push(kind='a',markup=markup)
</t>
<t tx="ekr.20050817120850.144">def depart_reference(self, node):
    
    b = self.pop('a')

    for s in b.markup:
        self.body.append(s)</t>
<t tx="ekr.20050817120850.145">def visit_revision(self, node):

    self.visit_docinfo_item(node, 'revision')

def depart_revision(self, node):

    self.depart_docinfo_item()
</t>
<t tx="ekr.20050817120850.147">def visit_row(self, node):
    pass

def depart_row(self, node):
    pass
</t>
<t tx="ekr.20050817120850.149">def visit_section(self, node):
    
    self.sectionlevel += 1

def depart_section(self, node):

    self.sectionlevel -= 1
</t>
<t tx="ekr.20050817120850.151">def visit_status(self, node):
    
    self.visit_docinfo_item(node, 'status')

def depart_status(self, node):

    self.depart_docinfo_item()
</t>
<t tx="ekr.20050817120850.153">def visit_strong(self, node):
    
    self.push(kind='b')

    self.body.append('&lt;b&gt;')

def depart_strong(self, node):
    
    self.pop('b')

    self.body.append('&lt;/b&gt;')

</t>
<t tx="ekr.20050817120850.155">def visit_subtitle(self, node):
    
    self.push(kind='subtitle',start=len(self.body))

def depart_subtitle(self, node):
    
    b = self.pop('subtitle')

    self.putTail(b.start,b.style)
</t>
<t tx="ekr.20050817120850.157">def visit_title (self,node):

    caller='visit_title'
    start = len(self.body) ; markup = []
    isTopic = isinstance(node.parent,docutils.nodes.topic)
    isTitle = self.sectionlevel == 0
    
    # Set the style.
    if isTopic:   style = 'topic-title'
    elif isTitle: style = 'title'
    else:         style = "h%s" % self.sectionlevel

    ## The old code was equivalent to: if style != 'title'.
    if 0:
        self.dumpNode(node.parent,tag='node.parent')
        self.dumpNode(node,tag='node')
    # Bug fix: 8/21/05: changed 'id' to 'ids'.
    if node.parent.hasattr('ids'):
        self.body.append(
        self.starttag({},'setLink','',
            destination=node.parent['ids'],caller=caller))
        markup.append('&lt;/setLink&gt;')
    if node.hasattr('refid'):
        self.body.append(
        self.starttag({},'setLink','',
            destination=node['refid'],caller=caller))
        markup.append('&lt;/setLink&gt;')

    self.push(kind='title',markup=markup,start=start,style=style)</t>
<t tx="ekr.20050817120850.158">def depart_title (self,node):

    b = self.pop('title')

    for z in b.markup:
        self.body.append(z)
        
    self.putTail(b.start,style=b.style)</t>
<t tx="ekr.20050817120850.159">def unimplemented_visit(self, node):
    
    raise NotImplementedError(
        'visiting unimplemented node type: %s' % node.__class__.__name__)
</t>
<t tx="ekr.20050817120850.160">def visit_topic (self,node):

    if node.hasattr('id'):
        self.push(kind='topic-id',markup='&lt;/setLink&gt;')
        self.body.append(self.starttag({},'setLink',
            suffix='',destination=node['id'],caller='visit_topic'))

def depart_topic (self,node):

    if node.hasattr('id'):
        b = self.pop('topic-id')
        self.body.append(b.markup)

</t>
<t tx="ekr.20050817120850.162">def visit_generated(self, node):
    pass

def depart_generated(self, node):
    pass
</t>
<t tx="ekr.20050817120850.164">def invisible_visit(self, node):
    
    """Invisible nodes should be ignored."""
    pass</t>
<t tx="ekr.20050817120850.165">def visit_comment(self, node):

    raise docutils.nodes.SkipNode
</t>
<t tx="ekr.20050817122915">'''This NOT a Leo plugin: this is a docutils writer for .pdf files.  

That file uses the reportlab module to convert html markup to pdf.

The original code written by Engelbert Gruber.

Rewritten by Edward K. Ream for the Leo rst3 plugin.
'''
</t>
<t tx="ekr.20050817124859">#####################################################################################
#
#	Copyright (c) 2000-2001, ReportLab Inc.
#	All rights reserved.
#
#	Redistribution and use in source and binary forms, with or without modification,
#	are permitted provided that the following conditions are met:
#
#		*	Redistributions of source code must retain the above copyright notice,
#			this list of conditions and the following disclaimer. 
#		*	Redistributions in binary form must reproduce the above copyright notice,
#			this list of conditions and the following disclaimer in the documentation
#			and/or other materials provided with the distribution. 
#		*	Neither the name of the company nor the names of its contributors may be
#			used to endorse or promote products derived from this software without
#			specific prior written permission. 
#
#	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#	IN NO EVENT SHALL THE OFFICERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
#	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
#	TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
#	IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
#	IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#	SUCH DAMAGE.
#
#####################################################################################</t>
<t tx="ekr.20050817124859.1">@

- Added 'c:\reportlab_1_20' to sys.path.

- Obtained this file and stylesheet.py from
  http://docutils.sourceforge.net/sandbox/dreamcatcher/rlpdf/

- Put stylesheet.py in docutils/writers directory.
  This is a stylesheet class used by the file.

- Made minor mods to stop crashes.
    - Added support for the '--stylesheet' option.
        - This may be doing more harm than good.
    - Changed the following methods of the PDFTranslator class:
        - createParagraph
        - depart_title</t>
<t tx="ekr.20050817132814"></t>
<t tx="ekr.20050817135706">def visit_Text (self,node):

    self.push(kind='#text')

    self.body.append(node.astext())

def depart_Text (self,node):

    self.pop('#text')</t>
<t tx="ekr.20050817135706.1"></t>
<t tx="ekr.20050817142135">def visit_paragraph(self, node):
    
    self.push(kind='p',start=len(self.body))
    
def depart_paragraph(self, node):
    
    b = self.pop('p')
    
    if not self.context and self.body:
        self.putTail(b.start)</t>
<t tx="ekr.20050817142135.1"></t>
<t tx="ekr.20050817165745">@nocolor
@others</t>
<t tx="ekr.20050817165745.1">@

- Removed '\r' characters in Writer.translate.
- Created self.push and self.pop.
- Rewrote visit/depart_title.  The code now is clear and works properly.

To do:
    The code in several places uses x in self.context.
    This won't work when g.Bunches are on the context stack,
    so we shall need a method that searches the bunches on the stack.</t>
<t tx="ekr.20050818022030">def push (self,**keys):
    
    self.context.append(Bunch(**keys))
    
def pop (self,kind):
    
    bunch = self.context.pop()
    assert bunch.kind == kind,\
        'wrong bunch kind popped.  Expected: %s Got: %s' % (
            kind, bunch.kind)

    return bunch
    
def peek (self,kind):
    
    bunch = self.context[-1]
    assert bunch.kind == kind,\
        'peek at wrong bunch.  Expected: %s Got: %s' % (
            kind, bunch.kind)
    return bunch</t>
<t tx="ekr.20050818033610">@

- Fixed bug in visit_reference: added self.push(b).
- Added putHead, putTail utilities.
- Simplified most of the code.
- Reorganized node handlers so that it is clear what the important methods are.
- Almost all the grunt work is done.</t>
<t tx="ekr.20050818081715">def dumpContext (self):
    
    print ; print '-' * 40
    print 'Dump of context'
        
    i = 0
    for bunch in self.context:
        print '%2d %s' % (i,bunch)
        i += 1</t>
<t tx="ekr.20050818083045">def inContext (self,kind):
    
    '''Return the most recent bunch having the indicated kind, or None.'''
    
    i = len(self.context) - 1

    while i &gt;= 0:
        bunch = self.context[i]
        if bunch.kind == kind:
            return bunch
        i -= 1
        
    return None</t>
<t tx="ekr.20050818084920">def putHead (self,start,style='Normal',bulletText=None):
    
    self.createParagraph(self.body[:start],
        style=style,bulletText=bulletText)

    self.body = self.body[start:]


def putTail (self,start,style='Normal',bulletText=None):
    
    self.createParagraph(self.body[start:],
        style=style,bulletText=bulletText)

    self.body = self.body[:start]
</t>
<t tx="ekr.20050818090152"></t>
<t tx="ekr.20050818090152.1"></t>
<t tx="ekr.20050818090907"></t>
<t tx="ekr.20050818094118.1">def visit_docinfo(self, node):
    
    self.push(kind='docinfo',start=len(self.body))
    self.in_docinfo = True

def depart_docinfo(self, node):
    
    b = self.pop('docinfo')
    self.putHead(b.start)
    self.in_docinfo = False</t>
<t tx="ekr.20050818094118.2"></t>
<t tx="ekr.20050818094954"></t>
<t tx="ekr.20050818094954.1"></t>
<t tx="ekr.20050818095347">@

All grunt work completed:

- Moved Bunch class into this file (so no dependencies on leoGlobals.py).

- Simplified calls to self.push

- Finish all simple methods.

- Better dumps in createParagraph.</t>
<t tx="ekr.20050818103031">@nocolor

@others

@

- Bullets show up as a black 2 ball.

- More flexible handling of style sheets.

- Auto-footnote numbering does not work.

- Test rST raw: pdf feature.</t>
<t tx="ekr.20050818103441">@ From The Python Cookbook:  Often we want to just collect a bunch of stuff together, naming each item of the bunch; a dictionary's OK for that, but a small do-nothing class is even handier, and prettier to use.

Create a Bunch whenever you want to group a few variables:

    point = Bunch(datum=y, squared=y*y, coord=x)

You can read/write the named attributes you just created, add others, del some of them, etc:
    if point.squared &gt; threshold:
        point.isok = True
@c

class Bunch (object):
    
    """A class that represents a colection of things.
    
    Especially useful for representing a collection of related variables."""
    
    def __init__(self,**keywords):
        self.__dict__.update (keywords)
        
    def __repr__(self):
        return self.toString()

    def ivars(self):
        return self.__dict__.keys()
        
    def keys(self):
        return self.__dict__.keys()
        
    def toString(self):
        tag = self.__dict__.get('tag')
        entries = ["%s: %s" % (key,str(self.__dict__.get(key)))
            for key in self.ivars() if key != 'tag']
        if tag:
            return "Bunch(tag=%s)...\n%s\n" % (tag,'\n'.join(entries))
        else:
            return "Bunch...\n%s\n" % '\n'.join(entries)

    # Used by new undo code.
    def __setitem__ (self,key,value):
        '''Support aBunch[key] = val'''
        return operator.setitem(self.__dict__,key,value)
        
    def __getitem__ (self,key):
        '''Support aBunch[key]'''
        return operator.getitem(self.__dict__,key)
        
    def get (self,key,theDefault=None):
        return self.__dict__.get(key,theDefault)
        
bunch = Bunch</t>
<t tx="ekr.20050818105023"></t>
<t tx="ekr.20050818105023.1"></t>
<t tx="ekr.20050818130249"></t>
<t tx="ekr.20050819055746">c.save()</t>
<t tx="ekr.20050819055746.1">@

- Added dummyPDFTranslator class.

- Added support for this dummy class to Writer.translate.</t>
<t tx="ekr.20050819072001">def dumpNode (self,node,tag=''):
    
    &lt;&lt; define keys to be printed &gt;&gt;
    
    d = node.__dict__
    
    nkeys = d.keys() ; nkeys.sort()
    
    print ; print '-' * 30
    print 'dump of node %s\n' % (g.choose(tag,'(%s)' % tag,''))
    
    print 'class',node.__class__
    
    for nkey in nkeys:
        if nkey in keys:
            val = d.get(nkey)
            print nkey,':',g.toString(val,verbose=False,indent='\t')
            
    print ; print 'done', '-' * 25</t>
<t tx="ekr.20050819072001.1">keys = (
    #'anonymous_refs'
    #'anonymous_targets'
    'attributes'
    'autofootnote_refs'
    'autofootnote_start'
    'autofootnotes'
    #'children'
    #'citation_refs'
    #'citations'
    #'current_line'
    #'current_source'
    #'decoration'
    #'document'
    'footnote_refs'
    'footnotes'
    'id_start'
    'ids'  # keys are sectinon names, values are section objects or reference objects.
    'indirect_targets'
    'nameids' # This might be what we want: keys are section names, values are munged names.
    #'nametypes'
    #'parse_messages'
    #'rawsource'
    'refids'
    'refnames'
    #'reporter'
    #'settings'
    #'substitution_defs'
    #'substitution_names'
    #'substitution_refs'
    #'symbol_footnote_refs'
    #'symbol_footnote_start'
    #'symbol_footnotes'
    #'tagname'
    #'transform_messages'
    #'transformer',
)</t>
<t tx="ekr.20050820092312">def createParagraphsFromIntermediateFile (self,s,story,visitor):
    
    if 0: # Not needed now that putParaFromIntermediateFile is in the visitor.
        self.styleSheet = visitor.styleSheet
        self.encode = visitor.encode
    
    out = StringIO.StringIO()

    doc = reportlab.platypus.SimpleDocTemplate(out,
        pagesize=reportlab.lib.pagesizes.A4)

    # The 'real' code is doc.build(story)
    self.buildFromIntermediateFile(s,story,visitor)

    return out.getvalue()</t>
<t tx="ekr.20050820092312.1">def putParaFromIntermediateFile (self,lines,style):

    bulletText = None
    text = '\n'.join(lines)
    
    # g.trace(style,repr(text))
    
    style = self.styleSheet [style]

    self.story.append(
        reportlab.platypus.para.Paragraph (
            self.encode(text), style,
            bulletText = bulletText,
            context = self.styleSheet))</t>
<t tx="ekr.20050820094818">def buildFromIntermediateFile (self):
    
    'Synthesize calls to reportlab.platypus.para.Paragraph from an intermediate file.'
    
    lines = g.splitLines(self.contents)
    para = [] # The lines of the next paragraph.

    for line in lines:
        if line:
            if line.startswith('createParagraph:'):
                if para:
                    self.putParaFromIntermediateFile(para,style)
                    para = []
                style = line[len('createParagraph:'):].strip()
            elif line.startswith('starttag:') or line.startswith('..'):
                pass
            else:
                para.append(line)
    if para:
        self.putParaFromIntermediateFile(para,style)</t>
<t tx="ekr.20050820100547">class dummyPDFTranslator (docutils.nodes.NodeVisitor):

	@others</t>
<t tx="ekr.20050820101355">def __init__(self, writer,doctree,contents):

    self.writer = writer
    self.contents = contents
    self.story = []
    
    # Some of these may be needed, even though they are not referenced directly.
    self.settings = settings = doctree.settings
    self.styleSheet = stylesheet.getStyleSheet()
    docutils.nodes.NodeVisitor.__init__(self, doctree) # Init the base class.
    self.language = docutils.languages.get_language(doctree.settings.language_code)</t>
<t tx="ekr.20050820101355.1">def visit_document(self, node):

    self.buildFromIntermediateFile()
    
    raise docutils.nodes.SkipNode
    
def depart_document(self, node):
    
    pass</t>
<t tx="ekr.20050820101522">def encode(self, text):

    """Encode special characters in `text` &amp; return."""
    
    if type(text) is types.UnicodeType:
        text = text.replace(u'\u2020', u' ')
        text = text.replace(u'\xa0', u' ')
        text = text.encode('utf-8')

    return text

</t>
<t tx="ekr.20050820103029">def as_what(self):

    return self.story
</t>
<t tx="ekr.20050820112549">@

- First working version.

</t>
<t tx="ekr.20050821153838">def pdfMunge (self,s):
    
    '''Duplicate the munging done (somewhere in docutils) of section names.
    
    This allows us to use the nameids attribute in the document element.'''
    
    s = s.lower.replace('\t',' ')

    while s != s.replace('  ',' '):
        s = s.replace('  ',' ')
    
    return s.replace(' ','-')</t>
<t tx="ekr.20050822065754">@

- Completed the conversion to using Bunches on the context stack.
    - Added peek method.
    - In context now searches from top of context stack and returns a Bunch.
    - Rewrote the footnote logic to use bunches:
        - footnote_backrefs sets b.setLink and b.links.  Much clearer code.
        - visit/depart_label uses b.setLink and b.links to generate code.
- The code now passes a minimal test of footnote code.

- WARNING: auto-footnote numbering does not work.  I doubt it ever did.  I feel under no obligation to make it work.</t>
<t tx="ekr.20050822123348">@
I. Bugs and bug fixes

This file, leo_pdf.py, is derived from rlpdf.py. It is intended as a replacement
for it. The copyright below applies only to this file, and to no other part of
Leo.

This code fixes numerous bugs that must have existed in rlpdf.py. That code was
apparently out-of-date. For known bugs in the present code see the 'to do'
section.

II. New and improved code.

This code pushes only Bunch's on the context stack. The Bunch class is slightly
adapted from the Python Cookbook.

Pushing only Bunches greatly simplifies the code and makes it more robust: there
is no longer any need for one part of the code to pop as many entries as another
part pushed. Furthermore, Bunch's can have as much internal structure as needed
without affecting any other part of the code.

The following methods make using Bunch's trivial: push, pop, peek, inContext.
inContext searches the context stack for a Bunch of the indicated 'kind'
attribute, returning the Bunch if found.

The following 'code generator' methods were heavily rewritten:
visit/depart_title, visit/depart_visit_footnote_reference, footnote_backrefs
and visit/depart_label.

III. Passing intermediateFile.txt to reportlab.

You can use an 'intermediate' file as the input to reportlab. This can be highly
useful: you can see what output reportlab will accept before the code generators
can actually generate it.

The way this works is as follows:
1. Run this code as usual, with the trace in PDFTranslator.createParagraph
enabled. This trace will print the contents of each paragraph to be sent to
reportlab, along with the paragraph's style.

2. Take the resulting console output and put it in the file called
intermediateFile.txt, in the same folder as the original document.

3. At the start of Writer.translate, change the 'if 1:' to 'if: 0'. This causes
the code to use the dummyPDFTranslator class instead of the usual PDFTranslator
class.

4. *Rerun* this code. Because of step 3, the code will read
intermediateFile.txt and send it, paragraph by paragraph, to reportlab. The
actual work is done in buildFromIntermediateFile. This method assumes the output
was produced by the trace in PDFTranslator.createParagraph as discussed
in point 2 above.

IV. About tracing and debugging.

As mentioned in the imports section, it is not necessary to import leoGlobals.
This file is part of Leo, and contains debugging stuff such as g.trace and
g.toString. There are also g.splitLines, g.es_exception, etc. used by debugging
code.

The trace in PDFTranslator.createParagraph is extremely useful for figuring out
what happened. Various other calls to g.trace are commented out throughout the
code. These were the way I debugged this code.

Edward K. Ream:  Aug 22, 2005.</t>
<t tx="ekr.20050822125824">@

- Added 'about this code' section.</t>
<t tx="ekr.20050822172321"></t>
<t tx="ekr.20050822172321.1">@ Minor improvements to documentation.</t>
<t tx="ekr.20050825101321">def init ():
    
    '''This file may be distributed in Leo's plugin folder, but this file is NOT
    a Leo plugin!
    
    The init method returns None to tell Leo's plugin manager and unit tests to
    skip this file.'''
    
    return None</t>
<t tx="ekr.20050825101903">@

- Added warning to docstring that this is not a valid Leo plugin.

- Added init function that always returns False.  This helps Leo's unit tests.</t>
<t tx="ekr.20050830091910"></t>
<t tx="ekr.20051025144116">c.spellCommands.openSpellTab()</t>
<t tx="ekr.20051109021852">@ Not ready for prime time yet.</t>
<t tx="ekr.20060107100005"></t>
<t tx="ekr.20060109001152">@nocolor

I do not pretend to understand this code. I have simply done some mechanical
modifications to eliminate all call to g.top().

- All functions or methods that used to call g.top() now have a *required* c parameter.

- All calls to such functions now have that required c parameter.

**Warning**: The c paramter in those modified calls might not exist. The changes
are totally untested, except that I have made sure the dynaMenu plugin can load,
i.e., there are no syntax errors.</t>
<t tx="ekr.20060109063941">def init ():

    if Pmw and not g.app.unitTesting: # Not for unit testing:  modifies core classes.
        if g.app.gui is None: 
            g.app.createTkGui(__file__)
    
        if g.app.gui.guiName() == "tkinter":
            &lt;&lt; override various methods &gt;&gt;
            g.plugin_signon( __name__ )</t>
<t tx="ekr.20060109105601"></t>
<t tx="ekr.20060109114710">c.openLeoSettings()</t>
<t tx="ekr.20060110125615"></t>
<t tx="mork.20040926105355.1">&lt;&lt;docstring&gt;&gt;

# To do:  Find/Change does not appear to work.

@language python
@tabwidth -4

__version__ = "0.68"
&lt;&lt; version history &gt;&gt;
&lt;&lt; imports &gt;&gt;
&lt;&lt; globals &gt;&gt;

# Solve problems with string.atoi...
import string
string.atoi = int

@others
</t>
<t tx="mork.20040926105355.2">chapters = {}
notebooks = {}
frames = {}
iscStringIO = False
twidgets = {}
pbodies = {}

</t>
<t tx="mork.20040926105355.3">def viewIndex( c , nodes = None, tle = '' ):
    if nodes == None:
        nodes = [ x for x in walkChapters( c, chapname = True ) ]
    def aN( a ):
        n = a[ 0 ].headString()
        return n, a[ 0 ], a[ 1 ]
    nodes = map( aN, nodes )
    nodes.sort()
    tl = Tk.Toplevel()
    import time    
    title = "%s Index of %s created at %s" % ( tle, c.frame.shortFileName(), time.ctime())
    tl.title( title )
    f = Tk.Frame( tl )
    f.pack( side = 'bottom' )
    l = Tk.Label( f, text = 'ScrollTo:' )
    e = Tk.Entry( f , bg = 'white', fg = 'blue')
    l.pack( side = 'left' )
    e.pack( side ='left' )
    b = Tk.Button( f, text = 'Close' )
    b.pack( side = 'left' )
    def rm( tl = tl ):
        tl.withdraw()
        tl.destroy()
    b.configure( command = rm )
    sve = Tk.StringVar()
    e.configure( textvariable = sve )
    ms = tl.maxsize()
    tl.geometry( '%sx%s+0+0' % (ms[ 0 ], (ms[ 1 ]/4 )*3 ))
    sc = Pmw.ScrolledCanvas( tl , vscrollmode = 'static', hscrollmode = 'static', 
    usehullsize = 1, borderframe = 1, hull_width = ms[ 0 ], hull_height = (ms[ 1 ]/4 )*3 )
    sc.pack()
    can = sc.interior()
    can.configure( background = 'white' )
    bal = Pmw.Balloon( can )
    
    tags = {}
    #ltag = None
    buildIndex( nodes , c, can, tl, bal, tags)            
    sc.resizescrollregion()
    def scTo( event , nodes = nodes, sve = sve , can = can , tags = tags):
        t = sve.get()
        if event.keysym == 'BackSpace':
            t = t[ : -1 ]
        else:
            t = t + event.char
        if t == '': return
        for z in nodes:
            if z[ 0 ].startswith( t ) and tags.has_key( z[ 1 ] ):
                tg = tags[ z[ 1 ] ]
                eh = can.bbox( ltag )[ 1 ]
                eh = (eh *1.0)/100
                bh = can.bbox( tg )[ 1 ]
                ncor = (bh/ eh) * .01 
                can.yview( 'moveto' , ncor)
                return

    e.bind( '&lt;Key&gt;', scTo )
    e.focus_set()
</t>
<t tx="mork.20040926105355.4">def regexViewIndex (c):

    def regexWalk (result,entry,widget):
        txt = entry.get()
        widget.deactivate()
        widget.destroy()
        if result == 'Cancel': return None
        nodes = [x for x in walkChapters(c,chapname=True)]
        import re
        regex = re.compile(txt)
        def search (nd,regex=regex):
            return regex.search(nd[0].bodyString())
        nodes = filter(search,nodes)
        viewIndex(c,nodes,'Regex( %s )' % txt)
        return

    sd = Pmw.PromptDialog(c.frame.top,
        title = 'Regex Index',
        buttons = ('Search','Cancel'),
        command = regexWalk,
    )
    entry = sd.component('entry')
    sd.configure(command=
        lambda result, entry = entry, widget = sd:
            regexWalk(result,entry,widget))
    sd.activate(geometry='centerscreenalways')</t>
<t tx="mork.20040926105355.5">def renumber( notebook ):
    pagenames = notebook.pagenames()
    for i , z in enumerate(pagenames):
        i = i +1
        tab = notebook.tab( z )
        tab.configure( text = str( i ) )
</t>
<t tx="mork.20040926105355.6">def getGoodPage( event , body ):
    global focusing
    c = body.c 
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    body.frame.body = body
    body.frame.bodyCtrl = body.bodyCtrl
    if not hasattr( body, 'lastChapter' ):
        body.lastChapter = notebook.getcurselection()
    page = checkChapterValidity( body.lastChapter, c )
    if page != notebook.getcurselection():
        body.lastChapter = page
        notebook.selectpage( page )
    selectNodeForEditor( c, body )         
    activateEditor( body )</t>
<t tx="mork.20040926105355.7">def checkChapterValidity( name , c):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    try:
        notebook.index( name )
    except:
        return notebook.getcurselection()            
    return name
</t>
<t tx="mork.20040926105355.8">def insertChapters (chapters,frame,c):
     notebook = notebooks.get(c)
     if not notebook: return # For unit testing
     pagenames = notebook.pagenames()
     for num, tup in enumerate(chapters):
            x, y = tup
            if num &gt; 0:
                sv = addPage(c,x).sv
                notebook.nextpage()
                cselection = notebook.getcurselection()
            else:
                cselection = notebook.getcurselection()
                sv = getSV(c,cselection)
            sv.set(x)
            next = cselection
            setTree(c,next,notebook)
            frame.c.fileCommands.open(y,sv.get())
            if num == 0:
                flipto = cselection
     setTree(flipto,notebook,c)
     c.frame.canvas.update_idletasks()</t>
<t tx="mork.20040926105355.9">def openChaptersFile( fileName ):
    zf = zipfile.ZipFile( fileName )
    import cStringIO
    file = cStringIO.StringIO()
    name = zf.namelist()
    csfiles = [ [], [] ]
    for x in name :
        zi = zf.getinfo( x )
        csfiles[ 0 ].append( zi.comment )
        cs = cStringIO.StringIO()
        csfiles[ 1 ].append( cs )           
        cs.write( zf.read( x ) )
        cs.seek( 0 )          
    zf.close()
    csfiles = zip( csfiles[ 0 ], csfiles[ 1 ] )
    return csfiles
</t>
<t tx="mork.20040926105355.20">def getSV (c,name):

    '''return a Tk StrinVar that is a primary identifier.'''

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    index = notebook.index(name)
    page = notebook.page(index)
    return page.sv
</t>
<t tx="mork.20040926105355.21">cControl = leoTkinterFrame.leoTkinterBody.createControl

def newCreateControl( self, frame, parentFrame  ):
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    if c not in pbodies:
        parentFrame = createPanedWidget( parentFrame, c )
    pbody = pbodies[ c ]
    l, r =addHeading( parentFrame )
    ctrl = cControl( self, frame , parentFrame ) 
    ctrl.bind( "&lt;FocusIn&gt;", lambda event, body = frame.body : getGoodPage( event, body ), '+' )
    i = 1.0 / len( pbody.panes() )
    for z in pbody.panes():
        pbody.configurepane( z , size = i )
    pbody.updatelayout()
    frame.body.l =l
    frame.body.r =r 
    frame.body.editorName = editorNames[ parentFrame ]
    if frame not in twidgets:
        twidgets[ frame ] = []
    twidgets[ frame ].append( frame.body )
    l.configure( textvariable = getSV(c, notebook.getcurselection()) )
    return ctrl
</t>
<t tx="mork.20040926105355.22">editorNames = {}

def newEditorPane( c ):
    names = pbodies[ c ].panes()
    if names:
        name  = str( int(names[ -1 ]) + 1 )
    else:
        name = '1'
    zpane = pbodies[ c ].add( name )
    editorNames[ zpane ] = name
    return zpane
</t>
<t tx="mork.20040926105355.23">def newCreateCanvas( self, parentFrame, createCanvas = leoTkinterFrame.leoTkinterFrame.createCanvas ):
    c = self.c
    
    if c not in frames:
        frames[ c ] = self
        notebook = createNoteBook( c, parentFrame )
    else:
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        
    pname = notebook.nameMaker.next()
    page = notebook.add( pname )
    indx = notebook.index( pname )
    tab = notebook.tab( indx )
    if indx == 0:
        tab.configure( background = 'grey', foreground = 'white' )
    canvas = createCanvas( self, page )
    
    hull = notebook.component( 'hull' )
    tab.bind( '&lt;Button-3&gt;' , lambda event : hull.tmenu.post( event.x_root , event.y_root ) )
    sv = Tk.StringVar()
    page.sv = sv
    createBalloon( tab, sv )
    canvas.name = pname
    
    # g.trace(repr(canvas.name),canvas)

    return canvas</t>
<t tx="mork.20040926105355.24">def newTreeinit( self, c,frame,canvas, oinit = leoTkinterTree.leoTkinterTree.__init__ ):
    
    # g.trace(canvas)

    sv = getSV(c, canvas.name)
    oinit( self, c, frame, canvas )
    self.chapter = chapters[ sv ] = Chapter( c, self , frame, canvas )
</t>
<t tx="mork.20040926105355.25">def constructTree( frame , notebook, name ):
    
    canvas = treeBar = tree = None
    if frame.canvas:
        canvas = frame.canvas
        treeBar = frame.treeBar
        tree = frame.tree
    sv = Tk.StringVar()
    sv.set( name )
    canvas = frame.createCanvas( None )
    frame.canvas =  canvas
    frame.tree = leoTkinterTree.leoTkinterTree( frame.c ,frame, frame.canvas)
    frame.tree.setColorFromConfig()
    indx = notebook.index( notebook.pagenames()[ -1 ] )
    tab = notebook.tab( indx )
    tnum = str( len( notebook.pagenames() ) ) 
    tab.configure( text = tnum )
    hull = notebook.component( 'hull' )
    tab.bind( '&lt;Button-3&gt;' , lambda event ,hull = hull: hull.tmenu.post( event.x_root , event.y_root ) )
    return tree , notebook.page( notebook.pagenames()[ - 1 ] )
</t>
<t tx="mork.20040926105355.26">def addPage( c , name = None ):

    frame = frames[ c ]
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    if name == None : name = str( len( notebook.pagenames() ) + 1 )
    o_chapter = c.cChapter
    otree, page  = constructTree( frame, notebook, name )
    c.cChapter.makeCurrent()
    o_chapter.makeCurrent()
    return page
</t>
<t tx="mork.20040926105355.27">def setTree(c, name , notebook):
    
    if not c or not c.exists: return None
    pindex = notebook.index( name )
    page = notebook.page( pindex )
    if not hasattr( page, 'sv' ) : return None
    sv = page.sv
    chapter = chapters[ sv ]
    chapter.makeCurrent()
    frame = c.frame
    frame.body.lastChapter = name
    frame.body.lastNode = chapter.cp
    frame.body.l.configure( textvariable = sv )
    tab = notebook.tab( pindex )
    tab.configure( background = 'grey', foreground = 'white' )
    activateEditor( frame.body )
</t>
<t tx="mork.20040926105355.28">old_getLeoFile = leoFileCommands.fileCommands.getLeoFile

def newGetLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    global iscStringIO

    if iscStringIO:
        def dontSetReadOnly (self,name,value):
            if name not in ('read_only','tnodesDict'):
                self.__dict__ [name] = value
        self.read_only = False
        self.__class__.__setattr__ = dontSetReadOnly

    rt = old_getLeoFile(self,fileName,readAtFileNodesFlag,silent)
    if iscStringIO:
        del self.__class__.__setattr__

    return rt</t>
<t tx="mork.20040926105355.29">oldOpen = leoFileCommands.fileCommands.open

def newOpen( self,file,fileName,readAtFileNodesFlag=True,silent=False):

    global iscStringIO,stringIOCommander
    c = self.c
    
    if zipfile.is_zipfile( fileName ):
        iscStringIO = True
        stringIOCommander = c
        chapters = openChaptersFile( fileName )
        g.es( str( len( chapters ) ) + " Chapters To Read", color = 'blue' )
        insertChapters( chapters, c.frame, c )
        g.es( "Finished Reading Chapters", color = 'blue' )
        iscStringIO = False
        return True

    return oldOpen(self,file,fileName,readAtFileNodesFlag,silent)</t>
<t tx="mork.20040926105355.30">def newWrite_LEO_file( self,fileName,outlineOnlyFlag, singleChapter = False):
    
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    at = c.atFileCommands
    if len( pagenames ) &gt; 1 and not singleChapter:        
        chapList = []
        self.__class__.__setattr__ =  getMakeStringIO( chapList )
        rv = writeChapters( self, fileName, pagenames, c , outlineOnlyFlag )
        if rv:
            zipChapters( fileName, pagenames, c, chapList )
        del self.__class__.__setattr__         
    else:
        rv = olWrite_LEO_file( self, fileName, outlineOnlyFlag )

    return rv</t>
<t tx="mork.20040926105355.31">if hasattr( leoFileCommands.fileCommands, 'write_LEO_file' ):
    olWrite_LEO_file = leoFileCommands.fileCommands.write_LEO_file
else:
    olWrite_LEO_file = leoFileCommands.fileCommands.write_Leo_file
    

def cloneToChapter( c , name ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    c.beginUpdate()
    vnd = c.currentPosition()
    clo = vnd.clone( vnd )
    clChapter = chapters[ page.sv ]
    vndm = clChapter.cp
    clo.unlink()
    clo.linkAfter(vndm)
    c.endUpdate()
</t>
<t tx="mork.20040926105355.32">def moveToChapter( c, name ):
    
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    mvChapter = chapters[ page.sv ]
    c.beginUpdate()
    vnd = c.currentVnode()
    if  not vnd.parent() and not vnd.back() :
        c.endUpdate()
        return None
    vndm = mvChapter.cp
    vnd.unlink()
    vnd.linkAfter(vndm)
    c.endUpdate()
    c.selectVnode( c.rootVnode() )

</t>
<t tx="mork.20040926105355.33">def copyToChapter( c, name ):
    
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    cpChapter = chapters[ page.sv ]
    c.beginUpdate()
    s = c.fileCommands.putLeoOutline()
    v = c.fileCommands.getLeoOutline( s )
    cpChapter.setVariables()
    mvnd = cpChapter.cp
    v.moveAfter( mvnd )
    c.cChapter.setVariables()
    c.endUpdate()

</t>
<t tx="mork.20040926105355.34">old_os_pat_dirname = g.os_path_dirname

def new_os_path_dirname (path,encoding=None):
    
    global iscStringIO,stringIOCommander

    if iscStringIO:
        c = stringIOCommander
        return os.path.dirname(c.mFileName)
    else:
        return old_os_pat_dirname(path,encoding)</t>
<t tx="mork.20040926105355.35">def newEditor (c):

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    frame = frames [c]
    pbody = pbodies [c]
    zpane = newEditorPane(c)
    af = leoTkinterBody(frame,zpane)
    c.frame.bodyCtrl = af.bodyCtrl
    af.setFontFromConfig()
    af.createBindings(frame)
    af.bodyCtrl.focus_set()
    cname = notebook.getcurselection()
    af.l.configure(textvariable=getSV(c,cname))
    af.r.configure(text=c.currentVnode().headString())</t>
<t tx="mork.20040926105355.36">def removeEditor( c ):
    pbody = pbodies[ c ]
    if len( pbody.panes() ) == 1: return None
    body = c.frame.body
    pbody.delete( body.editorName )
    pbody.updatelayout()
    panes = pbody.panes()
    twidgets[ c.frame ].remove( body )
    nBody = twidgets[ c.frame ][ 0 ] 
    nBody.bodyCtrl.focus_set()
    nBody.bodyCtrl.update_idletasks()
</t>
<t tx="mork.20040926105355.37">def conversionToSimple( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    vnd = c.rootPosition()
    while 1:
        n = vnd.next()
        if n == None:
            break
        else:
            vnd = n
    pagenames = notebook.pagenames()
    current = notebook.getcurselection()
    pagenames.remove( current )
    c.beginUpdate()
    for z in pagenames:
        index = notebook.index( z )
        page = notebook.page( index )
        chapter = chapters[ page.sv ]
        rvNode = chapter.rp
        while 1:
            nxt = rvNode.next()
            rvNode.moveAfter( vnd )
            if nxt: rvNode = nxt
            else:
                vnd = rvNode 
                break
        notebook.delete( z )
    c.endUpdate()
    renumber( notebook )       
</t>
<t tx="mork.20040926105355.38">def conversionToChapters( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    vnd = c.rootPosition()
    while 1:
        nxt = vnd.next()
        if nxt:
            makeNodeIntoChapter(c , nxt )
        else:
            break
    setTree( notebook.pagenames()[ 0 ], notebook , c )     
</t>
<t tx="mork.20040926105355.39">def makeNodeIntoChapter( c, vnd = None ):
    renum = vnd
    if vnd == None:
        vnd = c.currentPosition()
    if vnd == c.rootPosition() and vnd.next() == None:
        return
    nxt = vnd.next()
    if nxt:
        vnd.doDelete( nxt )
        
    page = addPage( c )
    mnChapter = chapters[ page.sv ]
    c.beginUpdate()
    oChapter = c.cChapter
    mnChapter.makeCurrent()
    root = mnChapter.rp
    vnd.moveAfter( root )
    c.setRootPosition( vnd )
    oChapter.makeCurrent()
    c.endUpdate()
    if not renum:
        notebook = notebooks.get(c)
        if notebook: # For unit testing
            renumber(notebook)
    c.selectPosition( oChapter.rp )
</t>
<t tx="mork.20040926105355.40">def walkChapters( c , ignorelist = [], chapname = False):
    # a generator that allows one to walk the chapters as one big tree
    if not c or not c.exists: return
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    for z in pagenames:
        sv = getSV(c, z)
        chapter = chapters[ sv ]
        v = chapter.rp
        while v:
            if chapname:
                if v not in ignorelist: yield v, z
            else:
                if v not in ignorelist:  yield v
            v = v.threadNext()
</t>
<t tx="mork.20040926105355.41">def makeTabMenu( widget, notebook, c ):
    #creates the Menu that appears
    tmenu = Tk.Menu( widget, tearoff = 0 )
    widget.bind( '&lt;Button-3&gt;' , lambda event : tmenu.post( event.x_root , event.y_root ) )
    widget.tmenu = tmenu
    tmenu.add_command( command = tmenu.unpost )
    tmenu.add_separator()
    ac = getAddChapter( c, notebook )
    tmenu.add_command( label = 'Add Chapter', command = ac )
    rmenu = Tk.Menu( tmenu , tearoff = 0 )    
    remove = getRemove( notebook, c, rmenu )
    rmenu.configure( postcommand = remove )        
    tmenu.add_cascade( menu = rmenu, label = "Remove Chapter" )
    rename = getRename(c, notebook )
    tmenu.add_command( label = "Add/Change Title" , command = rename )
    opmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( menu = opmenu , label = 'Node-Chapter Ops' )
    cmenu = Tk.Menu( opmenu, tearoff = 0 )
    movmenu = Tk.Menu( opmenu, tearoff = 0 )
    copymenu = Tk.Menu( opmenu, tearoff = 0 )
    swapmenu = Tk.Menu( opmenu, tearoff = 0 )
    searchmenu = Tk.Menu( opmenu, tearoff = 0 )
    opmenu.add_cascade( menu = cmenu, label = 'Clone To Chapter' )
    opmenu.add_cascade( menu = movmenu, label = 'Move To Chapter' )
    opmenu.add_cascade( menu = copymenu, label = 'Copy To Chapter' )
    opmenu.add_cascade( menu = swapmenu, label = 'Swap With Chapter' )
    opmenu.add_cascade( menu = searchmenu, label = 'Search and Clone To' )
    opmenu.add_command( label ="Make Node Into Chapter", command = lambda c=c:  makeNodeIntoChapter( c ) )
    mkTrash = getMakeTrash( notebook )
    opmenu.add_command( label = "Add Trash Barrel", command =
    lambda c = c : mkTrash( c ))
    opmenu.add_command( label = 'Empty Trash Barrel', command =
    lambda notebook = notebooks.get(c), c = c: emptyTrash( notebook, c ) )
    setupMenu = getSetupMenu( c, notebook )
    cmenu.configure(
        postcommand = lambda menu = cmenu, command = cloneToChapter : setupMenu( menu, command ) )
    movmenu.configure(
        postcommand = lambda menu = movmenu, command = moveToChapter : setupMenu( menu, command ) )
    copymenu.configure(
        postcommand = lambda menu = copymenu, command = copyToChapter : setupMenu( menu, command ) ) 
    swapmenu.configure( postcommand = 
    lambda menu = swapmenu, command = swapChapters : setupMenu( menu, command ) )
    searchmenu.configure( postcommand = lambda menu = searchmenu,
    command = regexClone: setupMenu( menu, command, all = True ) )
    edmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( label = "Editor", menu = edmenu )
    edmenu.add_command( label = "Add Editor" , command = lambda c =c : newEditor( c ) ) 
    edmenu.add_command( label = "Remove Editor", command = lambda c = c : removeEditor( c ) )
    conmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( menu = conmenu, label = 'Conversion' )
    conmenu.add_command(
        label = "Convert To Simple Outline",
        command = lambda c =c : conversionToSimple( c ) )
    conmenu.add_command(
        label = "Convert Simple Outline into Chapters",
        command = lambda c= c : conversionToChapters( c ) )
    iemenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade(label = 'Import/Export', menu = iemenu )
    iemenu.add_command( label = "Import Leo File ", command = lambda c = c: importLeoFile(c ) )
    iemenu.add_command( label = "Export Chapter To Leo File", command = lambda c =c : exportLeoFile( c ) )
    indmen = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( label = 'Index', menu = indmen )
    indmen.add_command( label = 'Make Index', command = lambda c =c : viewIndex( c ) )
    indmen.add_command( label = 'Make Regex Index', command = lambda c =c : regexViewIndex( c ) ) 
    try:
        import reportlab
        tmenu.add_command( label = 'Convert To PDF', command = lambda c = c: doPDFConversion( c ) )
    except Exception: 
        g.es( "no reportlab" )</t>
<t tx="mork.20040926105355.42">def doPDFConversion( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    import cStringIO
    from reportlab.platypus import SimpleDocTemplate,  Paragraph , Spacer 
    from reportlab.lib.styles import getSampleStyleSheet 
    from reportlab.lib.units import inch
    from reportlab.rl_config import defaultPageSize
    PAGE_HEIGHT = defaultPageSize[ 1 ]
    PAGE_WIDTH = defaultPageSize[ 0 ]
    maxlen = 100
    styles = getSampleStyleSheet()
    pinfo = c.frame.shortFileName()
    pinfo1 = pinfo.rstrip( '.leo' )
    cs = cStringIO.StringIO()
    doc = SimpleDocTemplate( cs , showBoundary = 1)
    Story = [Spacer(1,2*inch)] 
    pagenames = notebook.pagenames()   
    cChapter = c.cChapter
    for n,z in enumerate( pagenames ):
        
        n = n + 1
        sv = getSV(c, z)
        chapter = chapters[ sv ]
        chapter.setVariables()
        p = chapter.rp
        if p:
            _changeTreeToPDF( sv.get(), n, p , c, Story, styles, maxlen)
    &lt;&lt; define otherPages callback &gt;&gt;
    cChapter.setVariables()# This sets the nodes back to the cChapter, if we didnt the makeCurrent would point to the wrong positions
    cChapter.makeCurrent()
    doc.build(Story,  onLaterPages = otherPages)
    f = open( '%s.pdf' % pinfo1, 'w' )
    cs.seek( 0 )
    f.write( cs.read() )
    f.close()
    cs.close()</t>
<t tx="mork.20040926105355.43">def _changeTreeToPDF( name, num, p, c, Story, styles , maxlen):
    
    import copy
    from reportlab.platypus import SimpleDocTemplate,  Paragraph , Spacer, PageBreak, XPreformatted
    from reportlab.lib.units import inch
    from reportlab.rl_config import defaultPageSize
    enc = c.importCommands.encoding
    hstyle = styles[ 'title' ]
    Story.append( Paragraph( 'Chapter %s: %s' % ( num, name), hstyle ) )
    style = styles[ 'Normal' ]
    g.trace(p)
    for v in p.allNodes_iter(): #self_and_subtree_iter doesn't seem to work here????  Switched to allNodes_iter
    # while v:
        head = v.moreHead( 0 )
        head = g.toEncodedString(head,enc,reportErrors=True) 
        s = head +'\n'
        body = v.moreBody() # Inserts escapes.
        if len(body) &gt; 0:
            body = g.toEncodedString(body,enc, reportErrors=True)
            s = s + body
            s = s.split( '\n' )
            s2 = []
            for z in s:
                if len( z ) &lt; maxlen:
                    s2.append( z )
                else:
                    while 1:
                        s2.append( z[ : maxlen ] )
                        if len( z[ maxlen: ] ) &gt; maxlen:
                            z = z[ maxlen: ]
                        else:
                            s2.append( z[ maxlen: ] )
                            break
            s = '\n'.join( s2 )
            s = s.replace( '&amp;' ,'&amp;amp;' )
            s = s.replace( '&lt;', '&amp;lt;' )
            s = s.replace( '&gt;', '&amp;gt;' )
            s = s.replace( '"', '&amp;quot;' )
            s = s.replace( "`", '&amp;apos;' )
            Story.append( XPreformatted( s, style ) )
            Story.append( Spacer( 1, 0.2 * inch ) )
        #v = v.threadNext() 
    Story.append( PageBreak() )</t>
<t tx="mork.20040926105355.44">def addHeading( pane ):
    f = Tk.Frame( pane )
    f.pack( side = 'top' )
    l = Tk.Label( f )
    l.pack( side = 'left' )
    r = Tk.Label( f )
    r.pack( side = 'right' )
    return l , r
</t>
<t tx="mork.20040926105355.45">old_editLabel = leoTkinterTree.leoTkinterTree.endEditLabel

def newendEditLabel (self):

    c = self.c
    rv = old_editLabel(self)
    v = c.currentPosition()
    if v and hasattr(c.frame.body,'r'):
        hS = v.headString()
        if hS:
            c.frame.body.r.configure(text=v.headString())
    return rv</t>
<t tx="mork.20040926105355.46">def swapChapters( c, name ):

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    cselection = notebook.getcurselection()
    tab1 = notebook.tab( cselection )
    tab2 = notebook.tab( name )
    tval1 = tab1.cget( 'text' )
    tval2 = tab2.cget( 'text' )
    tv1 = getSV(c, cselection)
    tv2 = getSV(c, name)
    chap1 = c.cChapter
    chap2 = chapters[ tv2 ]
    rp, tp, cp = chap2.rp, chap2.tp, chap2.cp
    chap2.rp, chap2.tp, chap2.cp = chap1.rp, chap1.tp, chap1.cp
    chap1.rp, chap1.tp, chap1.cp = rp, tp, cp
    chap1.setVariables()
    c.redraw()
    chap1.canvas.update_idletasks()
  
    val1 = tv1.get()
    val2 = tv2.get()
    if  val2.isdigit() :
        tv1.set( notebook.index( cselection ) + 1 ) 
    else: tv1.set( val2 )
    if val1.isdigit() :
        tv2.set( notebook.index( name ) + 1 )
    else: tv2.set( val1 )

</t>
<t tx="mork.20040926105355.47">def importLeoFile( c ):
    import tkFileDialog
    name = tkFileDialog.askopenfilename()
    if name:
        page = addPage( c , name )
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing       
        notebook.selectpage( notebook.pagenames()[ - 1 ] )
        c.fileCommands.open( file( name, 'r' ), name )
        c.cChapter.makeCurrent()
        renumber( notebook )
</t>
<t tx="mork.20040926105355.48">def exportLeoFile( c ):
    import tkFileDialog
    name = tkFileDialog.asksaveasfilename()
    if name:
        if not name.endswith('.leo' ):
            name += '.leo'
        c.fileCommands.write_LEO_file( name, False, singleChapter = True )
</t>
<t tx="mork.20040926105355.49">if hasattr(leoNodes.vnode,'doDelete'):
    olDelete = leoNodes.vnode.doDelete
else:
    olDelete = leoNodes.position.doDelete

def newTrashDelete (self,newVnode):
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    pagenames = [getSV(c,x).get().upper() for x in pagenames]
    nbnam = notebook.getcurselection()
    if nbnam != None:
        name = getSV(c,notebook.getcurselection()).get().upper()
    else: name = 'TRASH'
    tsh = 'TRASH'
    if name != tsh and tsh in pagenames:
        index = pagenames.index(tsh)
        trchapter = chapters [getSV(c,index)]
        trashnode = trchapter.rp
        trchapter.setVariables()
        self.moveAfter(trashnode)
        c.cChapter.setVariables()
        c.selectVnode(newVnode)
        return self
    olDelete(self,newVnode)</t>
<t tx="mork.20040926105355.50">def emptyTrash( notebook  , c):
    pagenames = notebook.pagenames()
    pagenames = [ getSV(c, x) for x in pagenames ]
    for z in pagenames:
        if z.get().upper() == 'TRASH':
            trChapter = chapters[ z ]
            rvND = trChapter.rp
            c.beginUpdate()
            trChapter.setVariables()
            nRt = rvND.insertAfter()
            nRt.moveToRoot()
            trChapter.rp = c.rootPosition()
            trChapter.cp = c.currentPosition()
            trChapter.tp = c.topPosition()
            c.cChapter.setVariables()
            c.endUpdate( False )
            if c.cChapter == trChapter:
                c.selectPosition( nRt )
                c.redraw()
                trChapter.canvas.update_idletasks()
            return
</t>
<t tx="mork.20040926105355.51">def regexClone (c,name):
    if not c or not c.exists: return
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    sv = getSV(c,name)
    chapter = chapters [sv]

    def cloneWalk (result,entry,widget,c=c):
        txt = entry.get()
        widget.deactivate()
        widget.destroy()
        if result == 'Cancel': return None
        import re
        regex = re.compile(txt)
        rt = chapter.cp
        chapter.setVariables()
        stnode = leoNodes.tnode('',txt)
        snode = leoNodes.vnode(c,stnode)
        snode = leoNodes.position(c,snode,[])
        snode.moveAfter(rt)
        ignorelist = [snode]
        it = walkChapters(c,ignorelist=ignorelist)
        for z in it:
            f = regex.search(z.bodyString())
            if f:
                clone = z.clone(z)
                i = snode.numberOfChildren()
                clone.moveToNthChildOf(snode,i)
                ignorelist.append(clone)

        c.cChapter.setVariables()
        notebook.selectpage(name)
        c.selectVnode(snode)
        snode.expand()
        c.beginUpdate()
        c.endUpdate()

    sd = Pmw.PromptDialog(c.frame.top,
        title = 'Search and Clone',
        buttons = ('Search','Cancel'),
        command = cloneWalk,
    )
    entry = sd.component('entry')
    sd.configure(command=
        lambda result, entry = entry, widget = sd:
            cloneWalk(result,entry,widget))
    sd.activate(geometry='centerscreenalways')</t>
<t tx="mork.20040926105355.52">old_select = leoTkinterTree.leoTkinterTree.select

def newselect (self,v,updateBeadList=True):

    self.frame.body.lastNode = v
    notebook = notebooks.get(v.c)
    if not notebook: return # For unit testing
    self.frame.body.lastChapter = notebook.getcurselection()
    rv = old_select(self,v,updateBeadList)
    if hasattr(v.c.frame.body,'r'):
        v.c.frame.body.r.configure(text=v.headString())
    return rv</t>
<t tx="mork.20040927092626">class Chapter:
    '''The fundamental abstraction in the Chapters plugin.
       It enables the tracking of Chapters tree information.'''
       
    @others</t>
<t tx="mork.20040928223221">def getRemove( notebook, c , rmenu ):
    #a function that makes a function to remove chapters
    def remove():
        rmenu.delete( 0 , Tk.END )
        pn = notebook.pagenames()
        for i, z in enumerate( pn ):
            i = i + 1
            def rmz( name = z):
                if len( notebook.pagenames() ) == 1: return
                sv = getSV(c, name )
                chapter = chapters[ sv ]
                tree = chapter.tree
                vnd = chapter.rp
                cvnd = c.cChapter.cp
                c.beginUpdate()
                otree = c.cChapter.tree
                c.frame.tree = tree
                if vnd:
                    v = vnd                    
                    nnd = vnd.next()
                    if nnd == None:
                        nnd = vnd.insertAfter()
                        vnd = None
                    v.doDelete( nnd )
                c.frame.tree = otree
                c.endUpdate()
                notebook.delete( name )
                if tree != otree:
                    c.selectPosition( cvnd )
                if tree == otree:
                    pnames = notebook.pagenames()
                    notebook.selectpage( pnames[ 0 ] )
                    c.selectPosition( c.currentPosition() )
                    c.beginUpdate()
                    c.endUpdate()
                renumber( notebook )
            rmenu.add_command( label = str( i ) , command = rmz )  
              
    return remove
</t>
<t tx="mork.20040928223738">def getRename(c, notebook ):
    #a function that makes a function to rename chapters
    def rename( rnframes = {} ):
        name = notebook.getcurselection()
        frame = notebook.page( notebook.index( name ) )
        fr = frames[c]
        if not rnframes.has_key( frame ):
            f = rnframes[ frame ] = Tk.Frame( frame )
            e = Tk.Entry( f , background = 'white', textvariable = frame.sv )
            b = Tk.Button( f , text = "Close" ) 
            e.pack( side = 'left' )
            b.pack( side = 'right' )
            def change():
                f.pack_forget()
            b.configure( command = change )
        else:
            f = rnframes[ frame ]
            if f.winfo_viewable() : return None
        fr.canvas.pack_forget()
        f.pack( side = 'bottom' )
        fr.canvas.pack( fill = 'both', expand = 1 )

    return rename</t>
<t tx="mork.20040928224049">def getMakeTrash (notebook):
    #a function that makes a function to add a trash chapters
    def mkTrash (c):
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        addPage(c,'Trash')
        pnames = notebook.pagenames()
        sv = getSV(c,pnames[-1])
        sv.set('Trash')
        renumber(notebook)

    return mkTrash
</t>
<t tx="mork.20040928224349">def getAddChapter( c , notebook ):
    #a function that makes a function to add chapters  
    def ac( c = c ):
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        cname = notebook.getcurselection()
        addPage( c )        
        renumber( notebook)
    
    return ac</t>
<t tx="mork.20040928224621">def getSetupMenu( c, notebook ):
    #a function that makes a function to populate a menu
    def setupMenu( menu , command , all = False):
        menu.delete( 0 , Tk.END )
        current = notebook.getcurselection()
        for i, z in  enumerate( notebook.pagenames() ):
            i = i + 1
            if z == current and not all: continue
            menu.add_command( label = str( i ) , command = lambda c = c , name = z : command( c, name ) )
            
    return setupMenu</t>
<t tx="mork.20040929084846">def lowerPage( name, notebook):
    # a function that sets a lowered tabs color
    pindex = notebook.index( name )
    tab = notebook.tab( pindex )
    tab.configure( background = 'lightgrey', foreground = 'black' )</t>
<t tx="mork.20040929090525">def writeChapters( self, fileName, pagenames, c , outlineOnlyFlag):
    #goes over Chapters and puts info in StringIO instances
    for z in pagenames:
        sv = getSV(c,z )
        chapter = chapters[ sv ]
        chapter.setVariables()
        rv = olWrite_LEO_file( self, fileName, outlineOnlyFlag )    
    c.cChapter.setVariables()
    return rv</t>
<t tx="mork.20040929090525.1">def zipChapters( fileName, pagenames, c, chapList ):
    #takes list of StringIO instances and zips them to a file
    zf = zipfile.ZipFile( fileName, 'w',  zipfile.ZIP_DEFLATED )
    for x ,fname in enumerate( pagenames ):
        sv = getSV(c, fname )
        zif = zipfile.ZipInfo( str( x ) )
        zif.comment = sv.get()
        zif.compress_type = zipfile.ZIP_DEFLATED
        chapList[ x ].seek( 0 )
        zf.writestr( zif ,chapList[ x ].read() )
    zf.close()</t>
<t tx="mork.20040929092231">def getMakeStringIO( chapList ):
    #insures data is put in a StringIO instance
    def makeStringIO( self, name, value , cList = chapList):
        if name == 'outputFile' and value != None:
            import StringIO
            cS = StringIO.StringIO()
            cS.close = lambda : None
            self.__dict__[ name ] = cS
            cList.append( cS )
        elif name == 'outputFile' and value == None:
            self.__dict__[ name ] = None
        else:
            self.__dict__[ name ] = value 
            
    return makeStringIO</t>
<t tx="mork.20040929093051">def getNameMaker( notebook ):
    #creates a numbering mechanism for tabs
    def nameMaker():
        i = 0
        while 1:
            if len( notebook.pagenames() ) == 0: i = 0
            i += 1
            yield str( i )
            
    return nameMaker()</t>
<t tx="mork.20040929102107">def createNoteBook (c,parentFrame):

    #constructs a NoteBook widget for a frame
    notebooks [c] = notebook = Pmw.NoteBook(parentFrame,borderwidth=1,pagemargin=0)
    hull = notebook.component('hull')
    makeTabMenu(hull,notebook,c)
    notebook.configure(raisecommand=lambda name,notebook=notebook: setTree(c,name,notebook))
    notebook.configure(lowercommand=lambda name,notebook=notebook: lowerPage(name,notebook))
    notebook.pack(fill='both',expand=1)
    notebook.nameMaker = getNameMaker(notebook)
    return notebook</t>
<t tx="mork.20040929104527">def selectNodeForEditor( c, body ):
    #sets the node for the new editor
    if not hasattr( body, 'lastNode' ):
        body.lastNode = c.currentPosition()

    if body.lastNode == c.currentPosition(): return    
    elif body.lastNode.exists( c ):
        c.selectPosition( body.lastNode )
    else:
        c.selectPosition( c.rootPosition() )

    body.lastNode = c.currentPosition()    </t>
<t tx="mork.20040929105638">def activateEditor( body ):
    #performs functions that brings editor on line
    body.r.configure( text = body.lastNode.headString() )
    ip = body.lastNode.t.insertSpot
    txt = body.lastNode.bodyString()
    body.deleteAllText()
    body.insertAtEnd( txt )
    if ip : body.setInsertionPoint( ip )
    body.colorizer.colorize( body.lastNode )
    body.bodyCtrl.update_idletasks()</t>
<t tx="mork.20040929110556">def createPanedWidget( parentFrame, c ):
    #constructs a new panedwidget for a frame
    pbody = Pmw.PanedWidget( parentFrame , orient = 'horizontal' )
    pbody.pack( expand = 1 , fill = 'both')
    pbodies[ c ] = pbody
    parentFrame = newEditorPane( c )
    return parentFrame</t>
<t tx="mork.20040929120442">def createBalloon( tab, sv ):
    #creates a balloon for a widget
    balloon = Pmw.Balloon( tab , initwait = 100 )
    balloon.bind( tab , '' )
    hull = balloon.component( 'hull' )
    def blockExpose( event ):
        if sv.get() == '':
             hull.withdraw()
    hull.bind( '&lt;Expose&gt;', blockExpose, '+' )
    balloon._label.configure( textvariable = sv )</t>
<t tx="mork.20040929121409">def buildIndex( nodes , c , can, tl, bal, tags):

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    import tkFont
    f = tkFont.Font()
    f.configure( size = -20 )
    ltag = None
    for i,z in enumerate(nodes):
        tg = 'abc' + str( i ) 
        parent = z[ 1 ].parent()
        if parent: parent = parent.headString()
        else:
            parent = 'No Parent'
        sv = getSV(c, z[ 2 ] )
        if sv.get(): sv = ' - ' + sv.get()
        else: sv = ''
        
        tab = notebook.tab( z[ 2 ] )
        tv = tab.cget( 'text' )
        isClone = z[ 1 ].isCloned()
        if isClone:
            clone = ' (Clone) '
        else:
            clone =''
        txt = '%s  , parent: %s , chapter: %s%s%s' %( z[ 0 ], parent, tv, sv, clone)
        ltag = tags[ z[1] ] = can.create_text( 20, i * 20 + 20, text = txt, fill = 'blue', font = f , anchor = Tk.W, tag = tg )
        bs = z[ 1 ].bodyString()
        if bs.strip() != '':
            bal.tagbind( can, tg, bs)
        def goto( event, z = z , c = c, tl = tl):
            notebook = notebooks.get(c)
            if not notebook: return # For unit testing
            notebook.selectpage( z[ 2 ] )
            c.selectVnode( z[ 1 ] )
            c.frame.outerFrame.update_idletasks()
            c.frame.outerFrame.event_generate( '&lt;Button-1&gt;' )
            c.frame.bringToFront()
            return 'break'
        def colorRd( event , tg = ltag , can = can ):
            can.itemconfig( tg, fill = 'red' )
        def colorBl( event , tg = ltag , can = can ):
            can.itemconfig( tg, fill = 'blue' )
        can.tag_bind( tg, '&lt;Button-1&gt;', goto )
        can.tag_bind( tg, '&lt;Enter&gt;', colorRd, '+' )
        can.tag_bind( tg, '&lt;Leave&gt;', colorBl, '+' )    
</t>
<t tx="mork.20040930090547">@
Indexing is complementary to find, it provides a gui Index of nodes.  In comparison to regular find which bounces you around the tree, you can preview the node before you go to it.
@c
@others
</t>
<t tx="mork.20040930090735">@
This category deals with creating widgets and any support functions for doing so.
@c
@others</t>
<t tx="mork.20040930091035">@
This category is for opening and closing of Leo files.  We need to decorate and be tricky here, since a Chapters leo file is a zip file.  These functions are easy to break in my experience. :)
@c
@others</t>
<t tx="mork.20040930091035.1">@others</t>
<t tx="mork.20040930091035.2">@others</t>
<t tx="mork.20040930091319">@
Tab menu and factory functions for the tab menu creation process.
@c
@others</t>
<t tx="mork.20040930091319.1">@others</t>
<t tx="mork.20040930091624">@
I prefer decorating Leo functions as opposed to patching them.  Patching them leads to long term incompatibilites with Leo and the plugin.  Though this happens anyway with code evolution/changes, this makes it worse.  Thats my experience with it. :)
@c
@others</t>
<t tx="mork.20040930091624.1"># Requires reportlab toolkit at http://www.reportlab.org

@others</t>
<t tx="mork.20040930091759">@others</t>
<t tx="mork.20040930092027">@others</t>
<t tx="mork.20040930092027.1">@
Import a Leo file as a Chapter(s).  Export a Chapter as a single Leo file.  Kinda handy.
@c
@others</t>
<t tx="mork.20040930092207">@
couldn't think of any parent node to group these under.
@c
@others</t>
<t tx="mork.20040930092346">@others</t>
<t tx="mork.20040930094729">@others</t>
<t tx="mork.20041013092542.1">&lt;&lt; docstring &gt;&gt;

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;
&lt;&lt; globals &gt;&gt;
__version__ = '.57'
&lt;&lt;version history&gt;&gt;
&lt;&lt; documentation &gt;&gt;

@others

&lt;&lt;exampleTemacsExtension.py&gt;&gt;
&lt;&lt;usetemacs.ini example&gt;&gt;</t>
<t tx="mork.20041013092542.2">

labels = weakref.WeakKeyDictionary()
editors = weakref.WeakKeyDictionary()
haveseen = weakref.WeakKeyDictionary()
extensions = []
new_keystrokes = {}
leocommandnames = None</t>
<t tx="mork.20041013092542.3">def utTailEnd( buffer , frame ):
    '''A method that Emacs will call with its _tailEnd method'''
    buffer.event_generate( '&lt;Key&gt;' )
    buffer.update_idletasks()
    return 'break'
</t>
<t tx="mork.20041013092542.5">def addMenu( tag, keywords ):
    '''Adds the Temacs Help option to Leo's Help menu'''
    
    c = keywords.get('c')
    if not c: return

    men = c.frame.menu.getMenu( 'Help' )
    men.add_separator()
    men.add_command( label = 'Temacs Help', command = seeHelp )</t>
<t tx="mork.20041013092542.6">def seeHelp():
    '''Opens a Help dialog that shows the Emac systems commands and keystrokes'''
    tl = Tk.Toplevel()
    ms = tl.maxsize()
    tl.geometry( '%sx%s+0+0' % ( ( ms[ 0 ]/3 ) *2 , ms[ 1 ]/2 )) #half the screen height, half the screen width
    tl.title( "Temacs Help" )
    #fixedFont = Pmw.logicalfont( 'Fixed' )
    fixedFont = tkFont.Font( family = 'Fixed', size = 14 )
    #t = Pmw.ScrolledText( tl , text_font = fixedFont , text_background = 'white', hscrollmode = 'static', text_wrap='none')
    tc = ScrolledText.ScrolledText( tl, font = fixedFont, background = 'white', wrap = 'word' )
    sbar = Tk.Scrollbar( tc.frame, orient = 'horizontal' )
    sbar.configure( command = tc.xview )
    tc.configure( xscrollcommand = sbar.set )
    sbar.pack( side = 'bottom', fill = 'x' )
    for z in tc.frame.children.values():
        sbar.pack_configure( before = z )
    #t.settext( temacs.Emacs.getHelpText() )
    tc.insert( '1.0', temacs.Emacs.getHelpText() )
    lc='''\n---------Leo Commands-----------\n'''
    tc.insert( 'end', lc )
    leocommandnames.sort()
    lstring = '\n'.join( leocommandnames )
    tc.insert( 'end', lstring )
    def clz( tl = tl ):
        tl.withdraw()
        tl.destroy()
    #g = Pmw.Group( tl )
    g = Tk.Frame( tl )
    g.pack( side = 'bottom' )
    tc.pack( side = 'top' ,expand = 1, fill = 'both')
    e = Tk.Label( g, text = 'Search:' )
    e.pack( side = 'left' )
    #ef = Pmw.EntryField( g.interior() , 
    #                     labelpos = 'w', 
    #                     label_text = 'Search:' ,
    #                     entry_background = 'white',
    #                     entry_foreground = 'blue')
    #ef.pack( side = 'left' )
    ef = Tk.Entry( g, background = 'white', foreground = 'blue' )
    ef.pack( side = 'left' )
    def search():
        
        #stext = ef.getvalue()
        stext = ef.get()
        #tc = t.component( 'text' )
        tc.tag_delete( 'found' )
        tc.tag_configure( 'found', background = 'red' )
        ins = tc.index( 'insert' )
        ind = tc.search( stext, 'insert', stopindex = 'end', nocase = True )
        if not ind:
            ind = tc.search( stext, '1.0', stopindex = 'end', nocase = True )
        if ind:
            tc.mark_set( 'insert', '%s +%sc' % ( ind , len( stext ) ) )
            tc.tag_add(  'found', 'insert -%sc' % len( stext ) , 'insert' )
            tc.see( ind )
        
    go = Tk.Button( g , text = 'Go', command = search )
    go.pack( side = 'left' )
    b = Tk.Button( g  , text = 'Close' , command = clz )
    b.pack( side = 'left' )
    def watch( event ):
        search()
        
    #ef.component( 'entry' ).bind( '&lt;Return&gt;', watch )
    ef.bind( '&lt;Return&gt;', watch )
    #fixedFont = Pmw.logicalfont( 'Fixed' )
    #t = Pmw.ScrolledText( tl , text_font = fixedFont , text_background = 'white', hscrollmode = 'static', text_wrap='none')
    #t.pack( expand = 1, fill = 'both')
    #t.settext( temacs.Emacs.getHelpText() )
</t>
<t tx="mork.20041030164547">'''temacs is a binding module for the Tkinter Text widget.

Using the setBufferStrokes def will bind callbacks to the widget.'''

@language python
@tabwidth -4

__version__ = ".55"
&lt;&lt; version history &gt;&gt;
&lt;&lt; documentation &gt;&gt;
&lt;&lt; imports &gt;&gt;

@others

if __name__ == '__main__':
    &lt;&lt; run standalone tests &gt;&gt;</t>
<t tx="mork.20041030164547.1"># pretty low level imports. These may be all the imports the module needs

import leoGlobals as g # ekr

import Tkinter
import string
import weakref
import new
import sys
import re
import os
</t>
<t tx="mork.20041030164547.2">def setLabelGrey( self, label ):
    label.configure( background = 'lightgrey' )
</t>
<t tx="mork.20041030164547.3">def setLabelBlue( self ,label ):
    label.configure( background = 'lightblue' ) 
</t>
<t tx="mork.20041030164547.4">def _tailEnd( self, tbuffer ):
    '''This returns the tailEnd function that has been configure for the tbuffer parameter.'''
    if self.tailEnds.has_key( tbuffer ):
        return self.tailEnds[ tbuffer ]( tbuffer )
    else:
        return 'break'
</t>
<t tx="mork.20041030164547.5">#self.tailEnds = {}
def setTailEnd( self, tbuffer , tailCall ):
    '''This method sets a ending call that is specific for a particular Text widget.
       Some environments require that specific end calls be made after a keystroke
       or command is executed.'''
    self.tailEnds[ tbuffer ] = tailCall
</t>
<t tx="mork.20041030164547.6">#self.undoers = {}
def setUndoer( self, tbuffer, undoer ):
    '''This method sets the undoer method for the Emacs instance.'''
    self.undoers[ tbuffer ] = undoer
</t>
<t tx="mork.20041030164547.7">def doUndo(  self, event, amount = 1 ):
    tbuffer = event.widget
    if self.undoers.has_key( tbuffer ):
        for z in xrange( amount ):
            self.undoers[ tbuffer ]()
    return 'break'
</t>
<t tx="mork.20041030164547.8">#self.lastMacro = None
#self.macs = []
#self.macro = []
#self.namedMacros = {}
#self.macroing = False
def startKBDMacro( self, event ):

    svar, label = self.getSvarLabel( event )
    svar.set( 'Recording Keyboard Macro' )
    label.configure( background = 'lightblue' )
    self.macroing = True
    return 'break'
</t>
<t tx="mork.20041030164547.9">def recordKBDMacro( self, event, stroke ):
    if stroke != '&lt;Key&gt;':
        self.macro.append( (stroke, event.keycode, event.keysym, event.char) )
    elif stroke == '&lt;Key&gt;':
        if event.keysym != '??':
            self.macro.append( ( event.keycode, event.keysym ) )
    return
</t>
<t tx="mork.20041030164547.10">def stopKBDMacro( self, event ):
    #global macro, lastMacro, macroing
    if self.macro:
        self.macro = self.macro[ : -4 ]
        self.macs.insert( 0, self.macro )
        self.lastMacro = self.macro
        self.macro = []

    self.macroing = False
    svar, label = self.getSvarLabel( event )
    svar.set( 'Keyboard macro defined' )
    label.configure( background = 'lightgrey' )
    return 'break' 
</t>
<t tx="mork.20041030164547.11">def _executeMacro( self, macro, tbuffer ):
    
    for z in macro:
        if len( z ) == 2:
            tbuffer.event_generate( '&lt;Key&gt;', keycode = z[ 0 ], keysym = z[ 1 ] ) 
        else:
            meth = z[ 0 ].lstrip( '&lt;' ).rstrip( '&gt;' )
            method = self.cbDict[ meth ]
            ev = Tkinter.Event()
            ev.widget = tbuffer
            ev.keycode = z[ 1 ]
            ev.keysym = z[ 2 ]
            ev.char = z[ 3 ]
            self.masterCommand( ev , method, '&lt;%s&gt;' % meth )
    return self._tailEnd( tbuffer )  

</t>
<t tx="mork.20041030164547.12">def executeLastMacro( self, event ):
    tbuffer = event.widget
    if self.lastMacro:
        return self._executeMacro( self.lastMacro, tbuffer )
    return 'break'
</t>
<t tx="mork.20041030164547.13">def nameLastMacro( self, event ):
    '''Names the last macro defined.'''
    #global macroing
    svar, label = self.getSvarLabel( event )    
    if not self.macroing :
        self.macroing = 2
        svar.set( '' )
        self.setLabelBlue( label )
        return 'break'
    if event.keysym == 'Return':
        name = svar.get()
        self._addToDoAltX( name, self.lastMacro )
        svar.set( '' )
        self.setLabelBlue( label )
        self.macroing = False
        self.stopControlX( event )
        return 'break'
    self.setSvar( event, svar )
    return 'break'
</t>
<t tx="mork.20041030164547.14">def _addToDoAltX( self, name, macro ):
    '''Adds macro to Alt-X commands.'''
    if not self.doAltX.has_key( name ):
        def exe( event, macro = macro ):
            self.stopControlX( event )
            return self._executeMacro( macro, event.widget )
        self.doAltX[ name ] = exe
        self.namedMacros[ name ] = macro
        return True
    else:
        return False
</t>
<t tx="mork.20041030164547.15">def loadMacros( self,event ):
    '''Asks for a macro file name to load.'''
    import tkFileDialog
    f = tkFileDialog.askopenfile()
    if f == None: return 'break'
    else:
        return self._loadMacros( f )       
</t>
<t tx="mork.20041030164547.16">def _loadMacros( self, f ):
    '''Loads a macro file into the macros dictionary.'''
    import cPickle
    macros = cPickle.load( f )
    for z in macros:
        self._addToDoAltX( z, macros[ z ] )
    return 'break'
</t>
<t tx="mork.20041030164547.17">def getMacroName( self, event ):
    '''A method to save your macros to file.'''
    #global macroing
    svar, label = self.getSvarLabel( event )
    if not self.macroing:
        self.macroing = 3
        svar.set('')
        self.setLabelBlue( label )
        return 'break'
    if event.keysym == 'Return':
        self.macroing = False
        self.saveMacros( event, svar.get() )
        return 'break'
    if event.keysym == 'Tab':
        svar.set( self._findMatch( svar, self.namedMacros ) )
        return 'break'        
    self.setSvar( event, svar )
    return 'break'    
</t>
<t tx="mork.20041030164547.18">def saveMacros( self, event, macname ):
    '''Asks for a file name and saves it.'''
    import tkFileDialog
    name = tkFileDialog.asksaveasfilename()
    if name:
        f = file( name, 'a+' )
        f.seek( 0 )
        if f:
            self._saveMacros( f, macname ) 
    return 'break'
</t>
<t tx="mork.20041030164547.19">def _saveMacros( self, f , name ):
    '''Saves the macros as a pickled dictionary'''
    import cPickle
    fname = f.name
    try:
        macs = cPickle.load( f )
    except:
        macs = {}
    f.close()
    if self.namedMacros.has_key( name ):
        macs[ name ] = self.namedMacros[ name ]
        f = file( fname, 'w' )
        cPickle.dump( macs, f )
        f.close()   
</t>
<t tx="mork.20041030164547.20">#self.ccolumn = '0'
def setCommentColumn( self, event ):
    #global ccolumn
    cc= event.widget.index( 'insert' )
    cc1, cc2 = cc.split( '.' )
    self.ccolumn = cc2
    return 'break'
</t>
<t tx="mork.20041030164547.21">def indentToCommentColumn( self, event ):
    tbuffer = event.widget
    i = tbuffer.index( 'insert lineend' )
    i1, i2 = i.split( '.' )
    i2 = int( i2 )
    c1 = int( self.ccolumn )
    if i2 &lt; c1:
        wsn = c1 - i2
        tbuffer.insert( 'insert lineend', ' '* wsn )
    if i2 &gt;= c1:
        tbuffer.insert( 'insert lineend', ' ')
    tbuffer.mark_set( 'insert', 'insert lineend' )
    return self._tailEnd( tbuffer ) 
</t>
<t tx="mork.20041030164547.22">def exchangePointMark( self, event ):
    if not self._chckSel( event ):
        return
    tbuffer = event.widget
    s1 = tbuffer.index( 'sel.first' )
    s2 = tbuffer.index( 'sel.last' )
    i = tbuffer.index( 'insert' )
    if i == s1:
        tbuffer.mark_set( 'insert', s2 )
    else:
        tbuffer.mark_set('insert', s1 )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.23">#self.howM = False
def howMany( self, event ):
    #global howM
    svar, label = self.getSvarLabel( event )
    if event.keysym == 'Return':
        tbuffer = event.widget
        txt = tbuffer.get( '1.0', 'end' )
        import re
        reg1 = svar.get()
        reg = re.compile( reg1 )
        i = reg.findall( txt )
        svar.set( '%s occurances found of %s' % (len(i), reg1 ) )
        self.setLabelGrey( label )
        #self.howM = False
        self.mcStateManager.setState( 'howM', False )
        return 'break'
    self.setSvar( event, svar )
    return 'break'
</t>
<t tx="mork.20041030164547.24">def startHowMany( self, event ):
    #global howM
    #self.howM = True
    self.mcStateManager.setState( 'howM', True )
    svar, label = self.getSvarLabel( event )
    svar.set( '' )
    self.setLabelBlue( label )
    return 'break'
</t>
<t tx="mork.20041030164547.25">def selectParagraph( self, event ):
    tbuffer = event.widget
    txt = tbuffer.get( 'insert linestart', 'insert lineend' )
    txt = txt.lstrip().rstrip()
    i = tbuffer.index( 'insert' )
    if not txt:
        while 1:
            i = tbuffer.index( '%s + 1 lines' % i )
            txt = tbuffer.get( '%s linestart' % i, '%s lineend' % i )
            txt = txt.lstrip().rstrip()
            if txt:
                self._selectParagraph( tbuffer, i )
                break
            if tbuffer.index( '%s lineend' % i ) == tbuffer.index( 'end' ):
                return 'break'
    if txt:
        while 1:
            i = tbuffer.index( '%s - 1 lines' % i )
            txt = tbuffer.get( '%s linestart' % i, '%s lineend' % i )
            txt = txt.lstrip().rstrip()
            if not txt or tbuffer.index( '%s linestart' % i ) == tbuffer.index( '1.0' ):
                if not txt:
                    i = tbuffer.index( '%s + 1 lines' % i )
                self._selectParagraph( tbuffer, i )
                break     
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.26">def _selectParagraph( self, tbuffer, start ):
    i2 = start
    while 1:
        txt = tbuffer.get( '%s linestart' % i2, '%s lineend' % i2 )
        if tbuffer.index( '%s lineend' % i2 )  == tbuffer.index( 'end' ):
            break
        txt = txt.lstrip().rstrip()
        if not txt: break
        else:
            i2 = tbuffer.index( '%s + 1 lines' % i2 )
    tbuffer.tag_add( 'sel', '%s linestart' % start, '%s lineend' % i2 )
    tbuffer.mark_set( 'insert', '%s lineend' % i2 )
</t>
<t tx="mork.20041030164547.27">def killParagraph( self, event ):   
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    txt = tbuffer.get( 'insert linestart', 'insert lineend' )
    if not txt.rstrip().lstrip():
        i = tbuffer.search( r'\w', i, regexp = True, stopindex = 'end' )
    self._selectParagraph( tbuffer, i )
    i2 = tbuffer.index( 'insert' )
    self.kill( event, i, i2 )
    tbuffer.mark_set( 'insert', i )
    tbuffer.selection_clear()
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.28">def backwardKillParagraph( self, event ):   
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    i2 = i
    txt = tbuffer.get( 'insert linestart', 'insert lineend' )
    if not txt.rstrip().lstrip():
        self.movingParagraphs( event, -1 )
        i2 = tbuffer.index( 'insert' )
    self.selectParagraph( event )
    i3 = tbuffer.index( 'sel.first' )
    self.kill( event, i3, i2 )
    tbuffer.mark_set( 'insert', i )
    tbuffer.selection_clear()
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.29">#self.reset = False
def iterateKillBuffer( self ):
    #global reset
    while 1:
        if self.killbuffer:
            self.last_clipboard = None
            for z in self.killbuffer:
                if self.reset:
                    self.reset = False
                    break        
                yield z
        
            
</t>
<t tx="mork.20041030164547.30">#mbuffers = {}
#svars = {}
def setBufferStrokes( self, tbuffer, label ):
        '''setBufferStrokes takes a Tk Text widget called 'tbuffer'. 'stext' is a function or method
        that when called will return the value of the search text. 'rtext' is a function or method
        that when called will return the value of the replace text.  It is this method and
        getHelpText that users of the temacs module should call.  The rest are callback functions
        that enable the Emacs emulation.'''
        
        g.trace(tbuffer,label)
    
        Emacs.Emacs_instances[ tbuffer ] = self
        def cb( evstring ):
            _cb = None
            if self.cbDict.has_key( evstring ):
                _cb = self.cbDict[ evstring ]
            evstring = '&lt;%s&gt;' % evstring
            if evstring != '&lt;Key&gt;':
                # g.trace(evstring)
                tbuffer.bind( evstring,  lambda event, meth = _cb: self.masterCommand( event, meth , evstring) )
            else:
                # g.trace('+',evstring)
                tbuffer.bind( evstring,  lambda event, meth = _cb: self.masterCommand( event, meth , evstring), '+' )

        # EKR: create one binding for each entry in cbDict.
        for z in self.cbDict:
            cb( z )
        
        self.mbuffers[ tbuffer ] = label
        self.svars[ tbuffer ] = Tkinter.StringVar()
        def setVar( event ):
            label = self.mbuffers[ event.widget ]
            svar = self.svars[ event.widget ]
            label.configure( textvariable = svar )
        tbuffer.bind( '&lt;FocusIn&gt;', setVar, '+' )
        def scrollTo( event ):
            event.widget.see( 'insert' )
        
        #tbuffer.bind( '&lt;Enter&gt;', scrollTo, '+' )
        
        # EKR: This _adds_ a binding for all &lt;Key&gt; events, so _all_ key events go through masterCommand.
        cb( 'Key' )
</t>
<t tx="mork.20041030164547.31">def moveTo( self, event, spot ):
    tbuffer = event.widget
    tbuffer.mark_set( Tkinter.INSERT, spot )
    tbuffer.see( spot )
    return 'break'
</t>
<t tx="mork.20041030164547.33">def moveword( self, event, way  ):
    '''This function moves the cursor to the next word, direction dependent on the way parameter'''
    
    tbuffer = event.widget
    #i = way
    
    ind = tbuffer.index( 'insert' )
    if way == 1:
         ind = tbuffer.search( '\w', 'insert', stopindex = 'end', regexp=True )
         if ind:
            nind = '%s wordend' % ind
         else:
            nind = 'end'
    else:
         ind = tbuffer.search( '\w', 'insert -1c', stopindex= '1.0', regexp = True, backwards = True )
         if ind:
            nind = '%s wordstart' % ind 
         else:
            nind = '1.0'
    tbuffer.mark_set( 'insert', nind )
    tbuffer.see( 'insert' )
    tbuffer.event_generate( '&lt;Key&gt;' )
    tbuffer.update_idletasks()
    return 'break'</t>
<t tx="mork.20041030164547.34">def kill( self, event, frm, to  ):
    tbuffer = event.widget
    text = tbuffer.get( frm, to )
    self.addToKillBuffer( text )
    tbuffer.clipboard_clear()
    tbuffer.clipboard_append( text )    
    if frm == 'insert' and to =='insert lineend' and tbuffer.index( frm ) == tbuffer.index( to ):
        tbuffer.delete( 'insert', 'insert lineend +1c' )
        self.addToKillBuffer( '\n' )
    else:
        tbuffer.delete( frm, to )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.35">def deletelastWord( self, event ):
    #tbuffer = event.widget
    #i = tbuffer.get( 'insert' )
    self.moveword( event, -1 )
    self.kill( event, 'insert', 'insert wordend')
    self.moveword( event ,1 )
    return 'break'
</t>
<t tx="mork.20041030164547.36">def walkKB( self, event, frm, which ):# kb = self.iterateKillBuffer() ):
        #if not kb1:
        #    kb1.append( self.iterateKillBuffer() )
        #kb = kb1[ 0 ]
        #global reset
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    t , t1 = i.split( '.' )
    clip_text = self.getClipboard( tbuffer )    
    if self.killbuffer or clip_text:
        if which == 'c':
            self.reset = True
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()
            tbuffer.tag_delete( 'kb' )
            tbuffer.insert( frm, txt, ('kb') )
            tbuffer.mark_set( 'insert', i )
        else:
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()
            t1 = str( int( t1 ) + len( txt ) )
            r = tbuffer.tag_ranges( 'kb' )
            if r and r[ 0 ] == i:
                tbuffer.delete( r[ 0 ], r[ -1 ] )
            tbuffer.tag_delete( 'kb' )
            tbuffer.insert( frm, txt, ('kb') )
            tbuffer.mark_set( 'insert', i )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.37">def killsentence( self, event, back = False ):
    tbuffer = event.widget
    i = tbuffer.search( '.' , 'insert', stopindex = 'end' )
    if back:
        i = tbuffer.search( '.' , 'insert', backwards = True, stopindex = '1.0' ) 
        if i == '':
            return 'break'
        i2 = tbuffer.search( '.' , i, backwards = True , stopindex = '1.0' )
        if i2 == '':
            i2 = '1.0'
        return self.kill( event, i2, '%s + 1c' % i )
        #return self.kill( event , '%s +1c' % i, 'insert' )
    else:
        i = tbuffer.search( '.' , 'insert', stopindex = 'end' )
        i2 = tbuffer.search( '.', 'insert', backwards = True, stopindex = '1.0' )
    if i2 == '':
       i2 = '1.0'
    else:
       i2 = i2 + ' + 1c '
    if i == '': return 'break'
    return self.kill( event, i2, '%s + 1c' % i )
</t>
<t tx="mork.20041030164547.38">def search( self, event, way , useregex=False):
    '''This method moves the insert spot to position that matches the pattern in the minibuffer'''
    tbuffer = event.widget
    svar, label = self.getSvarLabel( event )
    stext = svar.get()
    if stext == '': return 'break'
    try:
        if way == 'bak': #Means search backwards.
            i = tbuffer.search( stext, 'insert', backwards = True,  stopindex = '1.0' , regexp = useregex )
            if not i: #If we dont find one we start again at the bottom of the buffer. 
                i = tbuffer.search( stext, 'end', backwards = True, stopindex = 'insert', regexp = useregex)
        else: #Since its not 'bak' it means search forwards.
            i = tbuffer.search(  stext, "insert + 1c", stopindex = 'end', regexp = useregex ) 
            if not i: #If we dont find one we start at the top of the buffer. 
                i = tbuffer.search( stext, '1.0', stopindex = 'insert', regexp = useregex )
    except:
        return 'break'
    if not i or i.isspace(): return 'break'
    tbuffer.mark_set( 'insert', i )
    tbuffer.see( 'insert' )
</t>
<t tx="mork.20041030164547.39">def capitalize( self, event, which ):
    tbuffer = event.widget
    text = tbuffer.get( 'insert wordstart', 'insert wordend' )
    i = tbuffer.index( 'insert' )
    if text == ' ': return 'break'
    tbuffer.delete( 'insert wordstart', 'insert wordend' )
    if which == 'cap':
        text = text.capitalize() 
    if which == 'low':
        text = text.lower()
    if which == 'up':
        text = text.upper()
    tbuffer.insert( 'insert', text )
    tbuffer.mark_set( 'insert', i )    
    return 'break' 
</t>
<t tx="mork.20041030164547.40">def swapWords( self, event , swapspots ):
    tbuffer = event.widget
    txt = tbuffer.get( 'insert wordstart', 'insert wordend' )
    if txt == ' ' : return 'break'
    i = tbuffer.index( 'insert wordstart' )
    if len( swapspots ) != 0:
        def swp( find, ftext, lind, ltext ):
            tbuffer.delete( find, '%s wordend' % find )
            tbuffer.insert( find, ltext )
            tbuffer.delete( lind, '%s wordend' % lind )
            tbuffer.insert( lind, ftext )
            swapspots.pop()
            swapspots.pop()
            return 'break'
        if tbuffer.compare( i , '&gt;', swapspots[ 1 ] ):
            return swp( i, txt, swapspots[ 1 ], swapspots[ 0 ] )
        elif tbuffer.compare( i , '&lt;', swapspots[ 1 ] ):
            return swp( swapspots[ 1 ], swapspots[ 0 ], i, txt )
        else:
            return 'break'
    else:
        swapspots.append( txt )
        swapspots.append( i )
        return 'break'
</t>
<t tx="mork.20041030164547.41">def getHelpText():
    '''This returns a string that describes what all the
    keystrokes do with a bound Text widget.'''
    help_t = [ 'Buffer Keyboard Commands:',
    '----------------------------------------\n',
    '&lt;Control-p&gt;: move up one line',
    '&lt;Control-n&gt;: move down one line',
    '&lt;Control-f&gt;: move forward one char',
    '&lt;Conftol-b&gt;: move backward one char',
    '&lt;Control-o&gt;: insert newline',
    '&lt;Control-Alt-o&gt; : insert newline and indent',
    '&lt;Control-j&gt;: insert newline and tab',
    '&lt;Alt-&lt;&gt; : move to start of Buffer',
    '&lt;Alt- &gt;' +' &gt;: move to end of Buffer',
    '&lt;Control a&gt;: move to start of line',
    '&lt;Control e&gt; :move to end of line',
    '&lt;Alt-Up&gt;: move to start of line',
    '&lt;Alt-Down&gt;: move to end of line',
    '&lt;Alt b&gt;: move one word backward',
    '&lt;Alt f&gt; : move one word forward',
    '&lt;Control - Right Arrow&gt;: move one word forward',
    '&lt;Control - Left Arrow&gt;: move one word backwards',
    '&lt;Alt-m&gt; : move to beginning of indentation',
    '&lt;Alt-g&gt; : goto line number',
    '&lt;Control-v&gt;: scroll forward one screen',
    '&lt;Alt-v&gt;: scroll up one screen',
    '&lt;Alt-a&gt;: move back one sentence',
    '&lt;Alt-e&gt;: move forward one sentence',
    '&lt;Alt-}&gt;: move forward one paragraph',
    '&lt;Alt-{&gt;: move backwards one paragraph',
    '&lt;Alt-:&gt; evaluate a Python expression in the minibuffer and insert the value in the current buffer',
    'Esc Esc : evaluate a Python expression in the minibuffer and insert the value in the current buffer',
    '&lt;Control-x . &gt;: set fill prefix',
    '&lt;Alt-q&gt;: fill paragraph',
    '&lt;Alt-h&gt;: select current or next paragraph',
    '&lt;Control-x Control-@&gt;: pop global mark',
    '&lt;Control-u&gt;: universal command, repeats the next command n times.',
    '&lt;Alt -n &gt; : n is a number.  Processes the next command n times.',
    '&lt;Control-x (&gt;: start definition of kbd macro',
    '&lt;Control-x ) &gt; : stop definition of kbd macro',
    '&lt;Control-x e : execute last macro defined',
    '&lt;Control-u Control-x ( &gt;: execute last macro and edit',
    '&lt;Control-x Esc Esc &gt;: execute last complex command( last Alt-x command',
    '&lt;Control-x Control-c &gt;: save buffers kill Emacs',
    '''&lt;Control-x u &gt; : advertised undo.   This function utilizes the environments.
    If the buffer is not configure explicitly, there is no operation.''',
    '&lt;Control-_&gt;: advertised undo.  See above',
    '&lt;Control-z&gt;: iconfify frame',
    '----------------------------------------\n',
    '&lt;Delete&gt; : delete previous character',
    '&lt;Control d&gt;: delete next character',
    '&lt;Control k&gt; : delete from cursor to end of line. Text goes to kill buffer',
    '&lt;Alt d&gt;: delete word. Word goes to kill buffer',
    '&lt;Alt Delete&gt;: delete previous word. Word goes to kill buffer',
    '&lt;Alt k &gt;: delete current sentence. Sentence goes to kill buffer',
    '&lt;Control x Delete&gt;: delete previous sentence. Sentence goes to kill buffer',
    '&lt;Control y &gt;: yank last deleted text segment from\n kill buffer and inserts it.',
    '&lt;Alt y &gt;: cycle and yank through kill buffer.\n',
    '&lt;Alt z &gt;: zap to typed letter. Text goes to kill buffer',
    '&lt;Alt-^ &gt;: join this line to the previous one',
    '&lt;Alt-\ &gt;: delete surrounding spaces',
    '&lt;Alt-s&gt; &gt;: center line in current fill column',
    '&lt;Control-Alt-w&gt;: next kill is appended to kill buffer\n'
    
    '----------------------------------------\n',
    '&lt;Alt c&gt;: Capitalize the word the cursor is under.',
    '&lt;Alt u&gt;: Uppercase the characters in the word.',
    '&lt;Alt l&gt;: Lowercase the characters in the word.',
    '----------------------------------------\n',
    '&lt;Alt t&gt;: Mark word for word swapping.  Marking a second\n word will swap this word with the first',
    '&lt;Control-t&gt;: Swap characters',
    '&lt;Ctrl-@&gt;: Begin marking region.',
    '&lt;Ctrl-W&gt;: Kill marked region',
    '&lt;Alt-W&gt;: Copy marked region',
    '&lt;Ctrl-x Ctrl-u&gt;: uppercase a marked region',
    '&lt;Ctrl-x Ctrl-l&gt;: lowercase a marked region',
    '&lt;Ctrl-x h&gt;: mark entire buffer',
    '&lt;Alt-Ctrl-backslash&gt;: indent region to indentation of line 1 of the region.',
    '&lt;Ctrl-x tab&gt; : indent region by 1 tab',
    '&lt;Control-x Control-x&gt; : swap point and mark',
    '&lt;Control-x semicolon&gt;: set comment column',
    '&lt;Alt-semicolon&gt;: indent to comment column',
    '----------------------------------------\n',
    'M-! cmd -- Run the shell command line cmd and display the output',
    'M-| cmd -- Run the shell command line cmd with region contents as input',
    '----------------------------------------\n',
    '&lt;Control-x a e&gt;: Expand the abbrev before point (expand-abbrev). This is effective even when Abbrev mode is not enabled',
    '&lt;Control-x a g&gt;: Define an abbreviation for previous word',
    '&lt;Control-x a i g&gt;: Define a word as abbreviation for word before point, or in point',                        
    '----------------------------------------\n',
    '&lt;Control s&gt;: forward search, using pattern in Mini buffer.\n',
    '&lt;Control r&gt;: backward search, using pattern in Mini buffer.\n' ,
    '&lt;Control s Enter&gt;: search forward for a word, nonincremental\n',
    '&lt;Control r Enter&gt;: search backward for a word, nonincremental\n',
    '&lt;Control s Enter Control w&gt;: Search for words, ignoring details of punctuation',
    '&lt;Control r Enter Control w&gt;: Search backward for words, ignoring details of punctuation',
    '&lt;Control-Alt s&gt;: forward regular expression search, using pattern in Mini buffer\n',
    '&lt;Control-Alt r&gt;: backward regular expression search, using pattern in Mini buffer\n',
    '''&lt;Alt-%&gt;: begin query search/replace. n skips to next match. y changes current match.  
    q or Return exits. ! to replace all remaining matches with no more questions''',
    '''&lt;Control Alt %&gt; begin regex search replace, like Alt-%''',
    '&lt;Alt-=&gt;: count lines and characters in regions',
    '&lt;Alt-( &gt;: insert parentheses()',
    '&lt;Alt-) &gt;:  move past close',
    '&lt;Control-x Control-t&gt;: transpose lines.',
    '&lt;Control-x Control-o&gt;: delete blank lines' ,
    '&lt;Control-x r s&gt;: save region to register',
    '&lt;Control-x r i&gt;: insert to buffer from register',
    '&lt;Control-x r +&gt;: increment register',
    '&lt;Control-x r n&gt;: insert number 0 to register',
    '&lt;Control-x r space &gt; : point insert point to register',
    '&lt;Control-x r j &gt; : jump to register',
    '&lt;Control-x x&gt;: save region to register',
    '&lt;Control-x r r&gt; : save rectangle to register',
    '&lt;Control-x r o&gt;: open up rectangle',
    '&lt;Control-x r c&gt; : clear rectangle',
    '&lt;Control-x r d&gt; : delete rectangle',
    '&lt;Control-x r t&gt; : replace rectangle with string',
    '&lt;Control-x r k&gt; : kill rectangle',
    '&lt;Control-x r y&gt; : yank rectangle',
    '&lt;Control-g&gt; : keyboard quit\n',
    '&lt;Control-x = &gt; : position of cursor',
    '&lt;Control-x . &gt; : set fill prefix',
    '&lt;Control-x f &gt; : set the fill column',
    '&lt;Control-x Control-b &gt; : display the buffer list',
    '&lt;Control-x b &gt; : switch to buffer',
    '&lt;Control-x k &gt; : kill the specified buffer',
    '----------------------------------------\n',
    '&lt;Alt - - Alt-l &gt;: lowercase previous word',
    '&lt;Alt - - Alt-u&gt;: uppercase previous word',
    '&lt;Alt - - Alt-c&gt;: capitalise previous word',
    '----------------------------------------\n',
    '&lt;Alt-/ &gt;: dynamic expansion',
    '&lt;Control-Alt-/&gt;: dynamic expansion.  Expands to common prefix in buffer\n'
    '----------------------------------------\n',
    'Alt-x commands:\n',
    '(Pressing Tab will result in auto completion of the options if an appropriate match is found',
    'replace-string  -  replace string with string',
    'replace-regex - replace python regular expression with string',
    'append-to-register  - append region to register',
    'prepend-to-register - prepend region to register\n'
    'sort-lines - sort selected lines',
    'sort-columns - sort by selected columns',
    'reverse-region - reverse selected lines',
    'sort-fields  - sort by fields',
    'abbrev-mode - toggle abbrev mode on/off',
    'kill-all-abbrevs - kill current abbreviations',
    'expand-region-abbrevs - expand all abrevs in region',
    'read-abbrev-file - read abbreviations from file',
    'write-abbrev-file - write abbreviations to file',
    'list-abbrevs   - list abbrevs in minibuffer',
    'fill-region-as-paragraph - treat region as one paragraph and add fill prefix',
    'fill-region - fill paragraphs in region with fill prefix',
    'close-rectangle  - close whitespace rectangle',
    'how-many - counts occurances of python regular expression',
    'kill-paragraph - delete from cursor to end of paragraph',
    'backward-kill-paragraph - delete from cursor to start of paragraph',
    'backward-kill-sentence - delete from the cursor to the start of the sentence',
    'name-last-kbd-macro - give the last kbd-macro a name',
    'insert-keyboard-macro - save macros to file',
    'load-file - load a macro file',
    'kill-word - delete the word the cursor is on',
    'kill-line - delete form the cursor to end of the line', 
    'kill-sentence - delete the sentence the cursor is on',
    'kill-region - delete a marked region',
    'yank - restore what you have deleted',
    'backward-kill-word - delete previous word',
    'backward-delete-char - delete previous character',
    'delete-char - delete character under cursor' , 
    'isearch-forward - start forward incremental search',
    'isearch-backward - start backward incremental search',
    'isearch-forward-regexp - start forward regular expression incremental search',
    'isearch-backward-regexp - start backward return expression incremental search',
    'capitalize-word - capitalize the current word',
    'upcase-word - switch word to upper case',
    'downcase-word - switch word to lower case',
    'indent-region - indent region to first line in region',
    'indent-rigidly - indent region by a tab',
    'indent-relative - Indent from point to under an indentation point in the previous line',
    'set-mark-command - mark the beginning or end of a region',
     'kill-rectangle - kill the rectangle',
    'delete-rectangle - delete the rectangle',
    'yank-rectangle - yank the rectangle',
    'open-rectangle - open the rectangle',
    'clear-rectangle - clear the rectangle',
    'copy-to-register - copy selection to register',
    'insert-register - insert register into buffer',
    'copy-rectangle-to-register - copy buffer rectangle to register',
    'jump-to-register - jump to position in register',
    'point-to-register - insert point into register',
    'number-to-register - insert number into register',
    'increment-register - increment number in register',
    'view-register - view what register contains',
    'beginning-of-line - move to the beginning of the line',
    'end-of-line - move to the end of the line',
    'beginning-of-buffer - move to the beginning of the buffer',
    'end-of-buffer - move to the end of the buffer',
    'newline-and-indent - insert a newline and tab',
    'keyboard-quit - abort current command',
    'iconify-or-deiconify-frame - iconfiy current frame',
    'advertised-undo - undo the last operation',
    'back-to-indentation - move to first non-blank character of line',
    'delete-indentation - join this line to the previous one',
    'view-lossage - see the last 100 characters typed',
    'transpose-chars - transpose two letters',
    'transpose-words - transpose two words',
    'transpose-line - transpose two lines',
    'flush-lines - delete lines that match regex',
    'keep-lines - keep lines that only match regex',
    'insert-file - insert file at current position',
    'save-buffer - save file',
    'split-line - split line at cursor. indent to column of cursor',
    'upcase-region - Upper case region',
    'downcase-region - lower case region',
    'goto-line - goto a line in the buffer',
    'what-line - display what line the cursor is on',
    'goto-char - goto a char in the buffer',
    'set-fill-column - sets the fill column',
    'center-line - centers the current line within the fill column',
    'center-region - centers the current region within the fill column',   
    'forward-char - move the cursor forward one char',
    'backward-char - move the cursor backward one char',
    'previous-line - move the cursor up one line',
    'next-line - move the cursor down one line',
    'universal-argument - Repeat the next command "n" times',
    'digit-argument - Repeat the next command "n" times',
    'set-fill-prefix - Sets the prefix from the insert point to the start of the line',
    'scroll-up - scrolls up one screen',
    'scroll-down - scrolls down one screen',
    'append-to-buffer - Append region to a specified buffer',
    'prepend-to-buffer - Prepend region to a specified buffer',
    'copy-to-buffer - Copy region to a specified buffer, deleting the previous contents',
    'insert-buffer - Insert the contents of a specified buffer into current buffer at point',
    'list-buffers - Display the buffer list',
    'switch-to-buffer - switch to a different buffer, if it does not exits, it is created.',
    'kill-buffer - kill the specified buffer',
    'rename-buffer - rename the buffer',
    'query-replace - query buffer for pattern and replace it.  The user will be asked for a pattern, and for text to replace the pattern with.',
    'query-replace-regex - query buffer with regex and replace it.  The user will be asked for a pattern, and for text to replace the regex matches with.',
    'inverse-add-global-abbrev - add global abbreviation from previous word.  Will ask user for word to expand to',
    'expand-abbrev - Expand the abbrev before point. This is effective even when Abbrev mode is not enabled',
    're-search-forward - do a python regular expression search forward',
    're-search-backward - do a python regular expression search backward',
    'diff - compares two files, displaying the differences in an Emacs buffer named *diff*',
    'make-directory - create a new directory',
    'remove-directory - remove an existing directory if its empty',
    'delete-file - remove an existing file',
    'search-forward - search forward for a word',
    'search-backward - search backward for a word',
    'word-search-forward - Search for words, ignoring details of punctuation.', 
    'word-search-backward - Search backward for words, ignoring details of punctuation',
    'repeat-complex-command - repeat the last Alt-x command',
    'eval-expression - evaluate a Python expression and put the value in the current buffer',
    'tabify - turn the selected text\'s spaces into tabs',
    'untabify - turn the selected text\'s tabs into spaces',
    'shell-command -Run the shell command line cmd and display the output',
    'shell-command-on-region -Run the shell command line cmd with region contents as input',
    ]
    
    return '\n'.join( help_t )

getHelpText = staticmethod( getHelpText )











</t>
<t tx="mork.20041030164547.42">#self.killbuffer = []
def addToKillBuffer( self, text ):
    #global reset
    self.reset = True 
    if self.previousStroke in ( '&lt;Control-k&gt;', '&lt;Control-w&gt;' ,
     '&lt;Alt-d&gt;', '&lt;Alt-Delete', '&lt;Alt-z&gt;', '&lt;Delete&gt;',
     '&lt;Control-Alt-w&gt;' ) and len( self.killbuffer):
        self.killbuffer[ 0 ] = self.killbuffer[ 0 ] + text
        return
    self.killbuffer.insert( 0, text )
</t>
<t tx="mork.20041030164547.43">#self.controlx = False
#self.csr = { '&lt;Control-s&gt;': 'for', '&lt;Control-r&gt;':'bak' }
#self.pref = None
#self.zap = False
#self.goto = False
#self.previousStroke = ''
def masterCommand( self, event, method , stroke):
    '''The masterCommand is the central routing method of the Emacs method.
       All commands and keystrokes pass through here.'''
       
    special = event.keysym in ('Control_L','Control_R','Alt_L','Alt-R','Shift_L','Shift_R')
    inserted = not special or len(self.keysymhistory) == 0 or self.keysymhistory[0] != event.keysym

    # Don't add multiple special characters to history.
    if inserted:
        self.keysymhistory.insert(0,event.keysym)
        if len(event.char) &gt; 0:
            if len(Emacs.lossage) &gt; 99: Emacs.lossage.pop()
            Emacs.lossage.insert(0,event.char)
        
        if 1: # traces
            print event.keysym,stroke
            g.trace(self.keysymhistory)
            g.trace(Emacs.lossage)
        
    if 0:
        &lt;&lt; old insert code &gt;&gt;
    
            
    if self.macroing:
        if self.macroing == 2 and stroke != '&lt;Control-x&gt;':
            return self.nameLastMacro( event )
        elif self.macroing == 3 and stroke != '&lt;Control-x&gt;':
            return self.getMacroName( event )
        else:
           self.recordKBDMacro( event, stroke )
         
    if  stroke == '&lt;Control-g&gt;':
        self.previousStroke = stroke
        return self.keyboardQuit( event )
        
    if self.mcStateManager.hasState():
        self.previousStroke = stroke
        return self.mcStateManager( event, stroke ) # EKR: Invoke the __call__ method.
        
    if self.kstrokeManager.hasKeyStroke( stroke ):
        self.previousStroke = stroke
        return self.kstrokeManager( event, stroke ) # EKR: Invoke the __call__ method.

    &lt;&lt; old code &gt;&gt;
    if self.regXRpl: # EKR: a generator.
        try:
            self.regXKey = event.keysym
            self.regXRpl.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    &lt;&lt; old code 2 &gt;&gt;
    if self.abbrevOn:
        if self.expandAbbrev( event ) :
            return 'break'       

    if method:
        rt = method( event )
        self.previousStroke = stroke
        return rt</t>
<t tx="mork.20041030164547.44">#self.registers = {}

def copyToRegister( self, event ):

    if not self._chckSel( event ):
        return
    if event.keysym in string.letters:
        event.keysym = event.keysym.lower()
        tbuffer = event.widget
        txt = tbuffer.get( 'sel.first', 'sel.last' )
        self.registers[ event.keysym ] = txt
        return 
    self.stopControlX( event )
</t>
<t tx="mork.20041030164547.45">def copyRectangleToRegister( self, event ):
    if not self._chckSel( event ):
        return
    if event.keysym in string.letters:
        event.keysym = event.keysym.lower()
        tbuffer = event.widget
        r1, r2, r3, r4 = self.getRectanglePoints( event )
        rect = []
        while r1 &lt;= r3:
            txt = tbuffer.get( '%s.%s' %( r1, r2 ), '%s.%s' %( r1, r4 ) )
            rect.append( txt )
            r1 = r1 +1
        self.registers[ event.keysym ] = rect
    self.stopControlX( event )        
</t>
<t tx="mork.20041030164547.46">def prependToRegister( self, event ):
    #global regMeth, registermode, controlx, registermode
    event.keysym = 'p'
    self.setNextRegister( event )
    self.mcStateManager.setState( 'controlx', False )
    #self.controlx = True
</t>
<t tx="mork.20041030164547.47">def appendToRegister( self, event ):
    #global regMeth, registermode, controlx
    event.keysym = 'a'
    self.setNextRegister( event )
    self.mcStateManager.setState( 'controlx', True )
    #self.controlx = True
</t>
<t tx="mork.20041030164547.48">def _chckSel( self, event ):
     if not 'sel' in event.widget.tag_names():
        return False
     if not event.widget.tag_ranges( 'sel' ):
        return False  
     return True
</t>
<t tx="mork.20041030164547.49">def _ToReg( self, event , which):
    if not self._chckSel( event ):
        return
    if self._checkIfRectangle( event ):
        return
    if event.keysym in string.letters:
        event.keysym = event.keysym.lower()
        tbuffer = event.widget
        if not self.registers.has_key( event.keysym ):
            self.registers[ event.keysym ] = ''
        txt = tbuffer.get( 'sel.first', 'sel.last' )
        rtxt = self.registers[ event.keysym ]
        if self.which == 'p':
            txt = txt + rtxt
        else:
            txt = rtxt + txt
        self.registers[ event.keysym ] = txt
        return
</t>
<t tx="mork.20041030164547.50">def _checkIfRectangle( self, event ):
    if self.registers.has_key( event.keysym ):
        if isinstance( self.registers[ event.keysym ], list ):
            svar, label = self.getSvarLabel( event )
            self.stopControlX( event )
            svar.set( "Register contains Rectangle, not text" )
            return True
    return False           
</t>
<t tx="mork.20041030164547.51">def insertFromRegister( self, event ):
    tbuffer = event.widget
    if self.registers.has_key( event.keysym ):
        if isinstance( self.registers[ event.keysym ], list ):
            self.yankRectangle( event, self.registers[ event.keysym ] )
        else:
            tbuffer.insert( 'insert', self.registers[ event.keysym ] )
            tbuffer.event_generate( '&lt;Key&gt;' )
            tbuffer.update_idletasks()
    self.stopControlX( event )
</t>
<t tx="mork.20041030164547.52">def incrementRegister( self, event ):
    if self.registers.has_key( event.keysym ):
        if self._checkIfRectangle( event ):
            return
        if self.registers[ event.keysym ] in string.digits:
            i = self.registers[ event.keysym ]
            i = str( int( i ) + 1 )
            self.registers[ event.keysym ] = i
        else:
            self.invalidRegister( event, 'number' )
            return
    self.stopControlX( event )
</t>
<t tx="mork.20041030164547.53">def numberToRegister( self, event ):
    if event.keysym in string.letters:
        self.registers[ event.keysym.lower() ] = str( 0 )
    self.stopControlX( event )
</t>
<t tx="mork.20041030164547.54">def pointToRegister( self, event ):
    if event.keysym in string.letters:
        tbuffer = event.widget
        self.registers[ event.keysym.lower() ] = tbuffer.index( 'insert' )
    self.stopControlX( event )
</t>
<t tx="mork.20041030164547.55">def jumpToRegister( self, event ):
    if event.keysym in string.letters:
        if self._checkIfRectangle( event ):
            return
        tbuffer = event.widget
        i = self.registers[ event.keysym.lower() ]
        i2 = i.split( '.' )
        if len( i2 ) == 2:
            if i2[ 0 ].isdigit() and i2[ 1 ].isdigit():
                pass
            else:
                self.invalidRegister( event, 'index' )
                return
        else:
            self.invalidRegister( event, 'index' )
            return
        tbuffer.mark_set( 'insert', i )
        tbuffer.event_generate( '&lt;Key&gt;' )
        tbuffer.update_idletasks() 
    self.stopControlX( event ) 
</t>
<t tx="mork.20041030164547.56">def invalidRegister( self, event, what ):
    self.deactivateRegister( event )
    svar, label = self.getSvarLabel( event )
    svar.set( 'Register does not contain valid %s'  % what)
    return    
</t>
<t tx="mork.20041030164547.57">def setNextRegister( self, event ):
    #global regMeth, registermode
    if event.keysym == 'Shift':
        return
    if self.regMeths.has_key( event.keysym ):
        self.mcStateManager.setState( 'controlx', True )
        self.regMeth = self.regMeths[ event.keysym ]
        self.registermode = 2
        svar = self.svars[ event.widget ]
        svar.set( self.regText[ event.keysym ] )
        return
    self.stopControlX( event )
</t>
<t tx="mork.20041030164547.58">def executeRegister( self, event ):
    self.regMeth( event )
    if self.registermode: 
        self.stopControlX( event )
    return
</t>
<t tx="mork.20041030164547.59">def deactivateRegister( self, event ):
    #global registermode, regMeth
    svar, label = self.getSvarLabel( event )
    svar.set( '' )
    self.setLabelGrey( label )
    self.registermode = False
    self.regMeth = None
</t>
<t tx="mork.20041030164547.60">#self.abbrevMode = False
#self.abbrevOn = False
#self.abbrevs = {}
def abbreviationDispatch( self, event, which ):
    #global abbrevMode
    #if not self.abbrevMode:
    aM = self.mcStateManager.getState( 'abbrevMode' )
    if not aM:
        #self.abbrevMode = which
        self.mcStateManager.setState( 'abbrevMode', which )
        svar, label = self.getSvarLabel( event )
        svar.set( '' )
        self.setLabelBlue( label )
        return 'break'
    if aM:
        self.abbrevCommand1( event )
    return 'break'
</t>
<t tx="mork.20041030164547.61">def abbrevCommand1( self, event ):
    #global abbrevMode
    if event.keysym == 'Return':
        tbuffer = event.widget
        word = tbuffer.get( 'insert -1c wordstart', 'insert -1c wordend' )
        if word == ' ': return
        svar, label = self.getSvarLabel( event )
        aM = self.mcStateManager.getState( 'abbrevMode' )
        if aM == 1:
            self.abbrevs[ svar.get() ] = word
        elif aM == 2:
            self.abbrevs[ word ] = svar.get()
        #self.abbrevMode = False
        #self.mcStateManager.setState( 'abbrevMode', False )
        self.keyboardQuit( event )
        self.resetMiniBuffer( event )
        return 'break'
    svar, label = self.getSvarLabel( event )
    self.setSvar( event, svar )
    return 'break'
</t>
<t tx="mork.20041030164547.62">def expandAbbrev( self,event ):
    tbuffer = event.widget
    word = tbuffer.get( 'insert -1c wordstart', 'insert -1c wordend' )
    c = event.char.strip()
    if c: #We have to do this because this method is called from Alt-x and Control-x, we get two differnt types of data and tbuffer states.
        word = '%s%s' %( word, event.char )
    if self.abbrevs.has_key( word ):
        tbuffer.delete( 'insert -1c wordstart', 'insert -1c wordend' )
        tbuffer.insert( 'insert', self.abbrevs[ word ] ) 
        return self._tailEnd( tbuffer )
        #return True
    else: return False
</t>
<t tx="mork.20041030164547.63">#self.regXRpl = None
#self.regXKey = None
def regionalExpandAbbrev( self, event ):
    #global regXRpl
    if not self._chckSel( event ):
        return
    tbuffer = event.widget
    i1 = tbuffer.index( 'sel.first' )
    i2 = tbuffer.index( 'sel.last' ) 
    ins = tbuffer.index( 'insert' )
    &lt;&lt; define a new generator searchXR &gt;&gt;
    # EKR: the 'result' of calling searchXR is a generator object.
    self.regXRpl = searchXR( i1, i2, ins, event)
    self.regXRpl.next() # Call it the first time.
    return 'break' </t>
<t tx="mork.20041030164547.64">def _setRAvars( self ):
    #global regXRpl, regXKey
    self.regXRpl = self.regXKey = None 
</t>
<t tx="mork.20041030164547.65">def killAllAbbrevs( self, event ):
    #global abbrevs
    self.abbrevs = {}
    return self.keyboardQuit( event )
</t>
<t tx="mork.20041030164547.66">def toggleAbbrevMode( self, event ):
    #global abbrevOn
    #aO = self.mcStateManager.getState( 'abbrevOn' )
    svar, label = self.getSvarLabel( event )
    if self.abbrevOn:
        self.abbrevOn = False
        self.keyboardQuit( event )
        svar.set( "Abbreviations are Off" )  
        #self.mcStateManager.setState( 'abbrevOn', False ) #This doesnt work too well with the mcStateManager
    else:
        self.abbrevOn = True
        self.keyboardQuit( event )
        svar.set( "Abbreviations are On" )
        #self.mcStateManager.setState( 'abbrevOn', True )
</t>
<t tx="mork.20041030164547.67">def listAbbrevs( self, event ):
    svar, label = self.getSvarLabel( event )
    txt = ''
    for z in self.abbrevs:
        txt = '%s%s=%s\n' %( txt, z, self.abbrevs[ z ] )
    svar.set( '' )
    svar.set( txt )
    return 'break'
</t>
<t tx="mork.20041030164547.68">def readAbbreviations( self, event ):
    import tkFileDialog
    f = tkFileDialog.askopenfile()
    if f == None: return 'break'        
    return self._readAbbrevs( f )
</t>
<t tx="mork.20041030164547.69">def _readAbbrevs( self, f ):
    for x in f:
        a, b = x.split( '=' )
        b = b[ : -1 ]
        self.abbrevs[ a ] = b
    f.close()        
    return 'break'
</t>
<t tx="mork.20041030164547.70">def writeAbbreviations( self, event ):
    import tkFileDialog
    f = tkFileDialog.asksaveasfile() 
    if f == None: return 'break' 
    return self._writeAbbrevs( f )
</t>
<t tx="mork.20041030164547.71">def _writeAbbrevs( self, f ):
    for x in self.abbrevs:
        f.write( '%s=%s\n' %( x, self.abbrevs[ x ] ) )
    f.close()    
    return 'break'
</t>
<t tx="mork.20041030164547.72">def movingParagraphs( self, event, way ):
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    
    if way == 1:
        while 1:
            txt = tbuffer.get( '%s linestart' % i, '%s lineend' %i )
            txt = txt.rstrip().lstrip()
            if not txt:
                i = tbuffer.search( r'\w', i, regexp = True, stopindex = 'end' )
                i = '%s' %i
                break
            else:
                i = tbuffer.index( '%s + 1 lines' % i )
                if tbuffer.index( '%s linestart' % i ) == tbuffer.index( 'end' ):
                    i = tbuffer.search( r'\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                    i = '%s + 1c' % i
                    break
    else:
        while 1:
            txt = tbuffer.get( '%s linestart' % i, '%s lineend' %i )
            txt = txt.rstrip().lstrip()
            if not txt:
                i = tbuffer.search( r'\w', i, backwards = True, regexp = True, stopindex = '1.0' )
                i = '%s +1c' %i
                break
            else:
                i = tbuffer.index( '%s - 1 lines' % i )
                if tbuffer.index( '%s linestart' % i ) == '1.0':
                    i = tbuffer.search( r'\w', '1.0', regexp = True, stopindex = 'end' )
                    break
    if i : 
        tbuffer.mark_set( 'insert', i )
        tbuffer.see( 'insert' )
        return self._tailEnd( tbuffer )
    return 'break'
</t>
<t tx="mork.20041030164547.73">#self.fillPrefix = ''
def setFillPrefix( self, event ):
    #global fillPrefix
    tbuffer = event.widget
    txt = tbuffer.get( 'insert linestart', 'insert' )
    self.fillPrefix = txt
    return 'break'
</t>
<t tx="mork.20041030164547.74">def fillParagraph( self, event ):
    tbuffer = event.widget
    txt = tbuffer.get( 'insert linestart', 'insert lineend' )
    txt = txt.lstrip().rstrip()
    if txt:
        i = tbuffer.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = tbuffer.index( '%s - 1 lines' % i2)
            txt2 = tbuffer.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if tbuffer.index( '%s linestart' % pi2 ) == '1.0':
                i2 = tbuffer.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.lstrip().rstrip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = tbuffer.index( '%s + 1 lines' %i3 )
            txt3 = tbuffer.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if tbuffer.index( '%s lineend' % pi3 ) == tbuffer.index( 'end' ):
                i3 = tbuffer.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.lstrip().rstrip() == '': break
            i3 = pi3
        ntxt = tbuffer.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        tbuffer.delete( '%s linestart' %i2, '%s lineend' % i3 )
        tbuffer.insert( i2, ntxt )
        tbuffer.mark_set( 'insert', i )
        return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.75">def _addPrefix( self, ntxt ):
        ntxt = ntxt.split( '.' )
        ntxt = map( lambda a: self.fillPrefix+a, ntxt )
        ntxt = '.'.join( ntxt )               
        return ntxt
</t>
<t tx="mork.20041030164547.76">def fillRegionAsParagraph( self, event ):
    if not self._chckSel( event ):
        return
    tbuffer = event.widget
    i1 = tbuffer.index( 'sel.first linestart' )
    i2 = tbuffer.index( 'sel.last lineend' )
    txt = tbuffer.get(  i1,  i2 )
    txt = self._addPrefix( txt )
    tbuffer.delete( i1, i2 )
    tbuffer.insert( i1, txt )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.77">def fillRegion( self, event ):
    if not self._chckSel( event ):
        return
    tbuffer = event.widget
    #i = tbuffer.index( 'insert' ) 
    s1 = tbuffer.index( 'sel.first' )
    s2 = tbuffer.index( 'sel.last' )
    tbuffer.mark_set( 'insert', s1 )
    self.movingParagraphs( event, -1 )
    if tbuffer.index( 'insert linestart' ) == '1.0':
        self.fillParagraph( event )
    while 1:
        self.movingParagraphs( event, 1 )
        if tbuffer.compare( 'insert', '&gt;', s2 ):
            break
        self.fillParagraph( event )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.78">#self.registermode = False
def doControlX( self, event, stroke, previous = [] ):
    #global registermode
    """previous.insert( 0, event.keysym )
    if len( previous ) &gt; 10: previous.pop()
    if stroke == '&lt;Key&gt;':
        if event.keysym in ( 'Shift_L', 'Shift_R' ):
            return
        if event.keysym == 'period':
            self.stopControlX( event )
            return self.setFillPrefix( event )
        if event.keysym == 'parenleft':
            self.stopControlX( event )
            return self.startKBDMacro( event )
        if event.keysym == 'parenright':
            self.stopControlX( event )
            return self.stopKBDMacro( event )
        if event.keysym == 'semicolon':
            self.stopControlX( event )
            return self.setCommentColumn( event )
        if event.keysym == 'Tab':
            self.stopControlX( event )
            return self.tabIndentRegion( event )
        if self.sRect:
            self.stringRectangle( event )
            return 'break'
        if event.keysym in ( 'a', 'i' , 'e'):
            svar, label = self.getSvarLabel( event )
            if svar.get() != 'a' and event.keysym == 'a':
                svar.set( 'a' )
                return 'break'
            elif svar.get() == 'a':
                if event.char == 'i':
                    svar.set( 'a i' )
                elif event.char == 'e':
                    self.stopControlX( event )
                    event.char = ''
                    self.expandAbbrev( event )
                return 'break'
        if event.keysym == 'g':
            svar, label = self.getSvarLabel( event )
            l = svar.get()
            if l == 'a':
                self.stopControlX( event )
                return self.abbreviationDispatch( event, 1 )
            elif l == 'a i':
                self.stopControlX( event )
                return self.abbreviationDispatch( event, 2 )
        if event.keysym == 'e':
            self.stopControlX( event )
            return self.executeLastMacro( event )
        if event.keysym == 'x' and previous[ 1 ] not in ( 'Control_L', 'Control_R'):
            event.keysym = 's' 
            self.setNextRegister( event )
            return 'break'
        if event.keysym == 'o' and self.registermode == 1:
            self.openRectangle( event )
            return 'break'
        if event.keysym == 'c' and self.registermode == 1:
            self.clearRectangle( event )
            return 'break'
        if event.keysym == 't' and self.registermode == 1:
            self.stringRectangle( event )
            return 'break'
        if event.keysym == 'y' and self.registermode == 1:
            self.yankRectangle( event )
            return 'break'
        if event.keysym == 'd' and self.registermode == 1:
            self.deleteRectangle( event )
            return 'break'
        if event.keysym == 'k' and self.registermode == 1:
            self.killRectangle( event )
            return 'break'       
        if self.registermode == 1:
            self.setNextRegister( event )
            return 'break'
        elif self.registermode == 2:
            self.executeRegister( event )
            return 'break'
        if event.keysym == 'r':
            self.registermode = 1
            svar = self.svars[ event.widget ]
            svar.set( 'C - x r' )
            return 'break'
        if event.keysym== 'h':
           self.stopControlX( event )
           event.widget.tag_add( 'sel', '1.0', 'end' )
           return 'break' 
        if event.keysym == 'equal':
            self.lineNumber( event )
            return 'break'
        if event.keysym == 'u':
            self.stopControlX( event )
            return self.doUndo( event, 2 )
    if stroke in self.xcommands:
        self.xcommands[ stroke ]( event )
        self.stopControlX( event )
    return 'break' """
    return self.cxHandler( event, stroke )
</t>
<t tx="mork.20041030164547.79">def startIncremental( self, event, stroke, which='normal' ):
    #global isearch, pref
    #widget = event.widget
    #if self.isearch:
    isearch = self.mcStateManager.getState( 'isearch' )
    if isearch:
        self.search( event, way = self.csr[ stroke ], useregex = self.useRegex() )
        self.pref = self.csr[ stroke ]
        self.scolorizer( event )
        return 'break'
    else:
        svar, label = self.getSvarLabel( event )
        #self.isearch = True'
        self.mcStateManager.setState( 'isearch', which )
        self.pref = self.csr[ stroke ]
        label.configure( background = 'lightblue' )
        label.configure( textvariable = svar )
        return 'break'
</t>
<t tx="mork.20041030164547.80">def iSearch( self, event, stroke ):
    if len( event.char ) == 0: return
    
    if stroke in self.csr: return self.startIncremental( event, stroke )
    svar, label = self.getSvarLabel( event )
    if event.keysym == 'Return':
          if svar.get() == '':
              return self.startNonIncrSearch( event, self.pref )
          else:
            return self.stopControlX( event )
          #return self._tailEnd( event.widget )
    widget = event.widget
    label.configure( textvariable = svar )
    #if event.keysym == 'Return':
    #      return self.stopControlX( event )
    self.setSvar( event, svar )
    if event.char != '\b':
       stext = svar.get()
       z = widget.search( stext , 'insert' , stopindex = 'insert +%sc' % len( stext ) )
       if not z:
           self.search( event, self.pref, useregex= self.useRegex() )
    self.scolorizer( event )
    return 'break'
</t>
<t tx="mork.20041030164547.81">def startZap( self, event ):
    #global zap
    #self.zap = True
    self.mcStateManager.setState( 'zap', True )
    svar, label = self.getSvarLabel( event )
    label.configure( background = 'lightblue' )
    svar.set( 'Zap To Character' )
    return 'break'
</t>
<t tx="mork.20041030164547.82">def zapTo( self, event ):
        #global zap

        widget = event.widget
        s = string.ascii_letters + string.digits + string.punctuation
        if len( event.char ) != 0 and event.char in s:
            #self.zap = False
            self.mcStateManager.setState( 'zap', False )
            i = widget.search( event.char , 'insert',  stopindex = 'end' )
            self.resetMiniBuffer( event )
            if i:
                t = widget.get( 'insert', '%s+1c'% i )
                self.addToKillBuffer( t )
                widget.delete( 'insert', '%s+1c' % i)
                return 'break'
        else:
            return 'break'
</t>
<t tx="mork.20041030164547.83">def changecbDict( self, changes ):
    for z in changes:
        if self.cbDict.has_key( z ):
            self.cbDict[ z ] = self.changes[ z ]
</t>
<t tx="mork.20041030164547.84">def startControlX( self, event ):
    '''This method starts the Control-X command sequence.'''  
    #global controlx
    #self.controlx = True
    self.mcStateManager.setState( 'controlx', True )
    svar, label = self.getSvarLabel( event )
    svar.set( 'Control - X' )
    label.configure( background = 'lightblue' )
    return 'break'
</t>
<t tx="mork.20041030164547.85">def stopControlX( self, event ):  #This will all be migrated to keyboardQuit eventually.
    '''This method clears the state of the Emacs instance'''
    #global controlx, rstring, isearch, sRect,negativeArg, uC, howM, altx
    #self.altx = False
    #self.howM = False
    #self.controlx = False
    #self.isearch = False
    if self.shuttingdown: return
    self.sRect = False
    #self.uC = False
    #self.negativeArg = False
    self.mcStateManager.clear()
    event.widget.tag_delete( 'color' )
    event.widget.tag_delete( 'color1' )
    if self.registermode:
        self.deactivateRegister( event )
    self.rectanglemode = 0
    self.bufferMode = None
    #self.rString = False
    self.resetMiniBuffer( event )
    event.widget.update_idletasks()     
    return 'break'

</t>
<t tx="mork.20041030164547.86">def resetMiniBuffer( self, event ):
    svar, label = self.getSvarLabel( event )
    svar.set( '' )
    label.configure( background = 'lightgrey' )
</t>
<t tx="mork.20041030164547.87">def setRegion( self, event ):   
    mrk = 'sel'
    tbuffer = event.widget
    def extend( event ):
        widget = event.widget
        widget.mark_set( 'insert', 'insert + 1c' )
        if self.inRange( widget, mrk ):
            widget.tag_remove( mrk, 'insert -1c' )
        else:
            widget.tag_add( mrk, 'insert -1c' )
            widget.tag_configure( mrk, background = 'lightgrey' )
            self.testinrange( widget )
        return 'break'
        
    def truncate( event ):
        widget = event.widget
        widget.mark_set( 'insert', 'insert -1c' )
        if self.inRange( widget, mrk ):
            self.testinrange( widget )
            widget.tag_remove( mrk, 'insert' )
        else:
            widget.tag_add( mrk, 'insert' )
            widget.tag_configure( mrk, background = 'lightgrey' )
            self.testinrange( widget  )
        return 'break'
        
    def up( event ):
        widget = event.widget
        if not self.testinrange( widget ):
            return 'break'
        widget.tag_add( mrk, 'insert linestart', 'insert' )
        i = widget.index( 'insert' )
        i1, i2 = i.split( '.' )
        i1 = str( int( i1 ) - 1 )
        widget.mark_set( 'insert', i1+'.'+i2)
        widget.tag_add( mrk, 'insert', 'insert lineend + 1c' )
        if self.inRange( widget, mrk ,l = '-1c', r = '+1c') and widget.index( 'insert' ) != '1.0':
            widget.tag_remove( mrk, 'insert', 'end' )  
        return 'break'
        
    def down( event ):
        widget = event.widget
        if not self.testinrange( widget ):
            return 'break'
        widget.tag_add( mrk, 'insert', 'insert lineend' )
        i = widget.index( 'insert' )
        i1, i2 = i.split( '.' )
        i1 = str( int( i1 ) + 1 )
        widget.mark_set( 'insert', i1 +'.'+i2 )
        widget.tag_add( mrk, 'insert linestart -1c', 'insert' )
        if self.inRange( widget, mrk , l = '-1c', r = '+1c' ): 
            widget.tag_remove( mrk, '1.0', 'insert' )
        return 'break'
        
    extend( event )   
    tbuffer.bind( '&lt;Right&gt;', extend, '+' )
    tbuffer.bind( '&lt;Left&gt;', truncate, '+' )
    tbuffer.bind( '&lt;Up&gt;', up, '+' )
    tbuffer.bind( '&lt;Down&gt;', down, '+' )
    return 'break'
</t>
<t tx="mork.20041030164547.88">def inRange( self, widget, range, l = '', r = '' ):
    ranges = widget.tag_ranges( range )
    #i = widget.index( 'insert' )
    for z in xrange( 0,  len( ranges) , 2 ):
        z1 = z + 1
        l1 = 'insert%s' %l
        r1 = 'insert%s' % r
        if widget.compare( l1, '&gt;=', ranges[ z ]) and widget.compare( r1, '&lt;=', ranges[ z1] ):
            return True
    return False
</t>
<t tx="mork.20041030164547.89">def contRanges( self, widget, range ):
    ranges = widget.tag_ranges( range)
    t1 = widget.get( ranges[ 0 ], ranges[ -1 ] )
    t2 = []
    for z in xrange( 0,  len( ranges) , 2 ):
        z1 = z + 1
        t2.append( widget.get( ranges[ z ], ranges[ z1 ] ) )
    t2 = '\n'.join( t2 )
    return t1 == t2
</t>
<t tx="mork.20041030164547.90">def testinrange( self, widget ):
    mrk = 'sel'
    #ranges = widget.tag_ranges( mrk)
    if not self.inRange( widget , mrk) or not self.contRanges( widget, mrk ):
        self.removeRKeys( widget )
        return False
    return True
</t>
<t tx="mork.20041030164547.91">def killRegion( self, event, which ):
    mrk = 'sel'
    tbuffer = event.widget
    trange = tbuffer.tag_ranges( mrk )
    if len( trange ) != 0:
        txt = tbuffer.get( trange[ 0 ] , trange[ -1 ] )
        if which == 'd':
            tbuffer.delete( trange[ 0 ], trange[ -1 ] )   
        self.addToKillBuffer( txt )
        tbuffer.clipboard_clear()
        tbuffer.clipboard_append( txt )
    self.removeRKeys( tbuffer )
    return 'break'
</t>
<t tx="mork.20041030164547.92">def removeRKeys( self, widget ):
    mrk = 'sel'
    widget.tag_delete( mrk )
    widget.unbind( '&lt;Left&gt;' )
    widget.unbind( '&lt;Right&gt;' )
    widget.unbind( '&lt;Up&gt;' )
    widget.unbind( '&lt;Down&gt;' )
</t>
<t tx="mork.20041030164547.93">def indentRegion( self, event ):
    tbuffer = event.widget
    mrk = 'sel'
    trange = tbuffer.tag_ranges( mrk )
    if len( trange ) != 0:
        ind = tbuffer.search( '\w', '%s linestart' % trange[ 0 ], stopindex = 'end', regexp = True )
        if not ind : return
        text = tbuffer.get( '%s linestart' % ind ,  '%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring[ 0 ]
        ws = text.split( sstring )
        if len( ws ) &gt; 1:
            ws = ws[ 0 ]
        else:
            ws = ''
        s , s1 = trange[ 0 ].split( '.' )
        e , e1 = trange[ -1 ].split( '.' )
        s = int( s )
        s = s + 1
        e = int( e ) + 1
        for z in xrange( s , e ):
            t2 = tbuffer.get( '%s.0' %z ,  '%s.0 lineend'%z)
            t2 = t2.lstrip()
            t2 = ws + t2
            tbuffer.delete( '%s.0' % z ,  '%s.0 lineend' %z)
            tbuffer.insert( '%s.0' % z, t2 )
        tbuffer.event_generate( '&lt;Key&gt;' )
        tbuffer.update_idletasks()
    self.removeRKeys( tbuffer )
    return 'break'
</t>
<t tx="mork.20041030164547.94">def tabIndentRegion( self,event ):
    tbuffer = event.widget
    if not self._chckSel( event ):
        return
    i = tbuffer.index( 'sel.first' )
    i2 = tbuffer.index( 'sel.last' )
    i = tbuffer.index( '%s linestart' %i )
    i2 = tbuffer.index( '%s linestart' % i2)
    while 1:
        tbuffer.insert( i, '\t' )
        if i == i2: break
        i = tbuffer.index( '%s + 1 lines' % i )    
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.95">def manufactureKeyPress( self, event, which ):
    tbuffer = event.widget
    tbuffer.event_generate( '&lt;Key&gt;',  keysym = which  )
    tbuffer.update_idletasks()
    return 'break'</t>
<t tx="mork.20041030164547.96">def backToIndentation( self, event ):
    tbuffer = event.widget
    i = tbuffer.index( 'insert linestart' )
    i2 = tbuffer.search( r'\w', i, stopindex = '%s lineend' % i, regexp = True )
    tbuffer.mark_set( 'insert', i2 )
    tbuffer.update_idletasks()
    return 'break'
</t>
<t tx="mork.20041030164547.97">def deleteIndentation( self, event ):
    tbuffer = event.widget
    txt = tbuffer.get( 'insert linestart' , 'insert lineend' )
    txt = ' %s' % txt.lstrip()
    tbuffer.delete( 'insert linestart' , 'insert lineend +1c' )    
    i  = tbuffer.index( 'insert - 1c' )
    tbuffer.insert( 'insert -1c', txt )
    tbuffer.mark_set( 'insert', i )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.98">def deleteNextChar( self,event ):
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    tbuffer.delete( i, '%s +1c' % i )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.99">def deleteSpaces( self, event , insertspace = False):
    tbuffer = event.widget
    char = tbuffer.get( 'insert', 'insert + 1c ' )
    if char.isspace():
        i = tbuffer.index( 'insert' )
        wf = tbuffer.search( r'\w', i, stopindex = '%s lineend' % i, regexp = True )
        wb = tbuffer.search( r'\w', i, stopindex = '%s linestart' % i, regexp = True, backwards = True )
        if '' in ( wf, wb ):
            return 'break'
        tbuffer.delete( '%s +1c' %wb, wf )
        if insertspace:
            tbuffer.insert( 'insert', ' ' )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.100">def measure( self, tbuffer ):
    i = tbuffer.index( 'insert' )
    i1, i2 = i.split( '.' )
    start = int( i1 )
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart - 1
        if ustart &lt; 0:
            break
        ds = '%s.0' % ustart
        pone = tbuffer.dlineinfo( ds )
        if pone:
            top = ds
            watch = watch  + 1
    
    pone = 1
    ustart = start
    while pone:
        ustart = ustart +1
        ds = '%s.0' % ustart
        pone = tbuffer.dlineinfo( ds )
        if pone:
            bottom = ds
            watch = watch + 1
            
    return watch , top, bottom
</t>
<t tx="mork.20041030164547.101">def screenscroll( self, event, way = 'north' ):
    tbuffer = event.widget
    chng = self.measure( tbuffer )
    i = tbuffer.index( 'insert' )
    
    if way == 'north':
        #top = chng[ 1 ]
        i1, i2 = i.split( '.' )
        i1 = int( i1 ) - chng[ 0 ]
    else:
        #bottom = chng[ 2 ]
        i1, i2 = i.split( '.' )
        i1 = int( i1 ) + chng[ 0 ]
        
    tbuffer.mark_set( 'insert', '%s.%s' % ( i1, i2 ) )
    tbuffer.see( 'insert' )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.102">def countRegion( self, event ):
    tbuffer = event.widget
    txt = tbuffer.get( 'sel.first', 'sel.last')
    svar = self.svars[ tbuffer ]
    lines = 1
    chars = 0
    for z in txt:
        if z == '\n': lines = lines + 1
        else:
            chars = chars + 1       
    svar.set( 'Region has %s lines, %s characters' %( lines, chars ) )
    return 'break'
</t>
<t tx="mork.20041030164547.103">def insertParentheses( self, event ):
    tbuffer = event.widget
    tbuffer.insert( 'insert', '()' )
    tbuffer.mark_set( 'insert', 'insert -1c' )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.104">#self.qQ = None
#self.qR = None
#self.qlisten = False
#self.lqR = Tkinter.StringVar()
#self.lqR.set( 'Query with: ' )
def listenQR( self, event ):
    #global qgetQuery, qlisten
    #self.qlisten = True
    self.mcStateManager.setState( 'qlisten', 'replace-caption' )
    #tbuffer = event.widget
    svar, label = self.getSvarLabel( event )
    self.setLabelBlue( label )
    if self.querytype == 'regex':
        svar.set( "Regex Query with:" )
    else:
        svar.set( "Query with:" )
    #label.configure( background = 'lightblue' , textvariable = self.lqR)
    self.qgetQuery = True
</t>
<t tx="mork.20041030164547.105">def qsearch( self, event ):
    if self.qQ:
        tbuffer = event.widget
        tbuffer.tag_delete( 'qR' )
        svar, label = self.getSvarLabel( event )
        if self.querytype == 'regex':
            try:
                regex = re.compile( self.qQ )
            except:
                self.keyboardQuit( event )
                svar.set( "Illegal regular expression" )
                
            txt = tbuffer.get( 'insert', 'end' )
            match = regex.search( txt )
            if match:
                start = match.start()
                end = match.end()
                length = end - start
                tbuffer.mark_set( 'insert', 'insert +%sc' % start )
                tbuffer.update_idletasks()
                tbuffer.tag_add( 'qR', 'insert', 'insert +%sc' % length )
                tbuffer.tag_config( 'qR', background = 'lightblue' )
                txt = tbuffer.get( 'insert', 'insert +%sc' % length )
                svar.set( "Replace %s with %s? y/n(! for all )" % ( txt, self.qR ) )
                return True
        else:
            i = tbuffer.search( self.qQ, 'insert', stopindex = 'end' )
            if i:
                tbuffer.mark_set( 'insert', i )
                tbuffer.update_idletasks()
                tbuffer.tag_add( 'qR', 'insert', 'insert +%sc'% len( self.qQ ) )
                tbuffer.tag_config( 'qR', background = 'lightblue' )
                self._tailEnd( tbuffer )
                return True
        self.quitQSearch( event )
        return False

</t>
<t tx="mork.20041030164547.106">def quitQSearch( self,event ):
    #global qQ, qR, qlisten, qrexecute
    event.widget.tag_delete( 'qR' )
    self.qQ = None
    self.qR = None
    #self.qlisten = False
    self.mcStateManager.setState( 'qlisten', False )
    self.qrexecute = False
    svar, label = self.getSvarLabel( event )
    svar.set( '' )
    label.configure( background = 'lightgrey' )
    #self.keyboardQuit( event )
    self.querytype = 'normal'
    self._tailEnd( event.widget )
    #event.widget.event_generate( '&lt;Key&gt;' )
    #event.widget.update_idletasks()
</t>
<t tx="mork.20041030164547.107">def qreplace( self, event ):

    if event.keysym == 'y':
        self._qreplace( event )
        return
    elif event.keysym in ( 'q', 'Return' ):
        self.quitQSearch( event )
    elif event.keysym == 'exclam':
        while self.qrexecute:
            self._qreplace( event )
    elif event.keysym in ( 'n', 'Delete'):
        #i = event.widget.index( 'insert' )
        event.widget.mark_set( 'insert', 'insert +%sc' % len( self.qQ ) )
        self.qsearch( event )
    event.widget.see( 'insert' )
</t>
<t tx="mork.20041030164547.108">def _qreplace( self, event ):
    i = event.widget.tag_ranges( 'qR' )
    event.widget.delete( i[ 0 ], i[ 1 ] )
    event.widget.insert( 'insert', self.qR )
    self.qsearch( event )
</t>
<t tx="mork.20041030164547.109">#self.qgetQuery = False
#self.lqQ = Tkinter.StringVar()
#self.lqQ.set( 'Replace with:' )      
def getQuery( self, event ):
    #global qQ, qgetQuery, qgetReplace
    l = event.keysym
    svar, label = self.getSvarLabel( event )
    label.configure( textvariable = svar )
    if l == 'Return':
        self.qgetQuery = False
        self.qgetReplace = True
        self.qQ = svar.get()
        svar.set( "Replace with:" )
        self.mcStateManager.setState( 'qlisten', 'replace-caption' )
        #label.configure( textvariable = self.lqQ)
        return
    if self.mcStateManager.getState( 'qlisten' ) == 'replace-caption':
        svar.set( '' )
        self.mcStateManager.setState( 'qlisten', True )
    self.setSvar( event, svar )
</t>
<t tx="mork.20041030164547.110">#self.qgetReplace = False
def getReplace( self, event ):
    #global qR, qgetReplace, qrexecute
    l = event.keysym
    svar, label = self.getSvarLabel( event )
    label.configure( textvariable = svar )
    if l == 'Return':
        self.qgetReplace = False
        self.qR = svar.get()
        self.qrexecute = True
        ok = self.qsearch( event )
        if self.querytype == 'regex' and ok:
            tbuffer = event.widget
            range = tbuffer.tag_ranges( 'qR' )
            txt = tbuffer.get( range[ 0 ], range[ 1 ] )
            svar.set( 'Replace %s with %s y/n(! for all )' %( txt, self.qR ) )
        elif ok:
            svar.set( 'Replace %s with %s y/n(! for all )' %( self.qQ, self.qR ) )
        #self.qrexecute = True
        #ok = self.qsearch( event )
        return
    if self.mcStateManager.getState( 'qlisten' ) == 'replace-caption':
        svar.set( '' )
        self.mcStateManager.setState( 'qlisten', True )
    self.setSvar( event, svar )
</t>
<t tx="mork.20041030164547.111">#self.qrexecute = False   
def masterQR( self, event ):

    if self.qgetQuery:
        self.getQuery( event )
    elif self.qgetReplace:
        self.getReplace( event )
    elif self.qrexecute:
        self.qreplace( event )
    else:
        #svar, label = self.getSvarLabel( event )
        #svar.set( '' )
        self.listenQR( event )
    return 'break'
</t>
<t tx="mork.20041030164547.112">def getSvarLabel( self, event ):
    
    '''returns the StringVar and Label( minibuffer ) for a specific Text editor'''
    svar = self.svars[ event.widget ]
    label = self.mbuffers[ event.widget ]
    return svar, label

</t>
<t tx="mork.20041030164547.113">def setSvar( self, event, svar ):
    '''Alters the StringVar svar to represent the change in the event.
       It mimics what would happen with the keyboard and a Text editor
       instead of plain accumalation.''' 
    t = svar.get()  
    if event.char == '\b':
           if len( t ) == 1:
               t = ''
           else:
               t = t[ 0 : -1 ]
           svar.set( t )
    else:
            t = t + event.char
            svar.set( t )
</t>
<t tx="mork.20041030164547.114">def movePastClose( self, event ):
    tbuffer = event.widget
    i = tbuffer.search( '(', 'insert' , backwards = True ,stopindex = '1.0' )
    icheck = tbuffer.search( ')', 'insert',  backwards = True, stopindex = '1.0' )
    if ''  ==  i:
        return 'break'
    if icheck:
        ic = tbuffer.compare( i, '&lt;', icheck )
        if ic: 
            return 'break'
    i2 = tbuffer.search( ')', 'insert' ,stopindex = 'end' )
    i2check = tbuffer.search( '(', 'insert', stopindex = 'end' )
    if '' == i2:
        return 'break'
    if i2check:
        ic2 = tbuffer.compare( i2, '&gt;', i2check )
        if ic2:
            return 'break'
    ib = tbuffer.index( 'insert' )
    tbuffer.mark_set( 'insert', '%s lineend +1c' % i2 )
    if tbuffer.index( 'insert' ) == tbuffer.index( '%s lineend' % ib ):
        tbuffer.insert( 'insert' , '\n')
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.115">#self.rString = False
#self._sString = ''
#self._rpString = ''
def replaceString( self, event ):
    
    svar, label = self.getSvarLabel( event )
    if event.keysym in ( 'Control_L', 'Control_R' ):
        return
    rS = self.mcStateManager.getState( 'rString' )
    regex = self._useRegex
    if not rS:
        #self.rString = 1
        self.mcStateManager.setState( 'rString', 1 )
        self._sString = ''
        self._rpString = ''
        if regex:
            svar.set( 'Replace Regex' )
        else:
            svar.set( 'Replace String' )
        return
    if event.keysym == 'Return':
        #self.rString = self.rString + 1
        rS = rS + 1
        self.mcStateManager.setState( 'rString', rS  )
        #return 'break'
    if rS == 1:
        svar.set( '' )
        #self.rString = self.rString + 1
        rS = rS + 1
        self.mcStateManager.setState( 'rString', rS )
    if rS == 2:
        self.setSvar( event, svar )
        self._sString = svar.get()
        return 'break'
    if rS == 3:
        if regex:
            svar.set( 'Replace regex %s with:' % self._sString )
        else:
            svar.set( 'Replace string %s with:' % self._sString )
        self.mcStateManager.setState( 'rString',rS + 1 )
        #self.rString = self.rString + 1
        return 'break'
    if rS == 4:
        svar.set( '' )
        #self.rString = self.rString + 1
        rS = rS + 1
        self.mcStateManager.setState( 'rString', rS )
    if rS == 5:
        self.setSvar( event, svar )
        self._rpString = svar.get()
        return 'break'
    if rS == 6:
        tbuffer = event.widget
        i = 'insert'
        end = 'end'
        ct = 0
        if tbuffer.tag_ranges( 'sel' ):
            i = tbuffer.index( 'sel.first' )
            end = tbuffer.index( 'sel.last' )
        if regex:
            txt = tbuffer.get( i, end )
            try:
                pattern = re.compile( self._sString )
            except:
                self.keyboardQuit( event )
                svar.set( "Illegal regular expression" )
                return 'break'
            ct = len( pattern.findall( txt ) )
            if ct:
                ntxt = pattern.sub( self._rpString, txt )
                tbuffer.delete( i, end )
                tbuffer.insert( i, ntxt )
        else:
            txt = tbuffer.get( i, end )
            ct = txt.count( self._sString )
            if ct:
                ntxt = txt.replace( self._sString, self._rpString )
                tbuffer.delete( i, end )
                tbuffer.insert( i, ntxt )
                
        svar.set( 'Replaced %s occurances' % ct )
        #label.configure( background = 'lightgrey' )
        self.setLabelGrey( label ) 
        #self.rString = False
        self.mcStateManager.clear()
        self._useRegex = False
        #self.mcStateManager.setState( 'rString', False )
        return self._tailEnd( tbuffer )

</t>
<t tx="mork.20041030164547.116">def swapCharacters( self, event ):
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    c1 = tbuffer.get( 'insert', 'insert +1c' )
    c2 = tbuffer.get( 'insert -1c', 'insert' )
    tbuffer.delete( 'insert -1c', 'insert' )
    tbuffer.insert( 'insert', c1 )
    tbuffer.delete( 'insert', 'insert +1c' )
    tbuffer.insert( 'insert', c2 )
    tbuffer.mark_set( 'insert', i )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.117">def insertNewLine( self,event ):
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    tbuffer.insert( 'insert', '\n' )
    tbuffer.mark_set( 'insert', i )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.118">def lineNumber( self, event ):
    self.stopControlX( event )
    svar, label = self.getSvarLabel( event )
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    i1, i2 = i.split( '.' )
    c = tbuffer.get( 'insert', 'insert + 1c' )
    txt = tbuffer.get( '1.0', 'end' )
    txt2 = tbuffer.get( '1.0', 'insert' )
    perc = len( txt ) * .01
    perc = int( len( txt2 ) / perc )
    svar.set( 'Char: %s point %s of %s(%s%s)  Column %s' %( c, len( txt2), len( txt), perc,'%', i1 ) )
    return 'break'
</t>
<t tx="mork.20041030164547.119">def prevNexSentence( self, event , way ):
    tbuffer = event.widget
    if way == 'bak':
        i = tbuffer.search( '.', 'insert', backwards = True, stopindex = '1.0' )
        if i:
            i2 = tbuffer.search( '.', i, backwards = True, stopindex = '1.0' )
            if not i2:
                i2 = '1.0'
            if i2:
                i3 = tbuffer.search( '\w', i2, stopindex = i, regexp = True )
                if i3:
                    tbuffer.mark_set( 'insert', i3 )
        else:
            tbuffer.mark_set( 'insert', '1.0' )
    else:
        i = tbuffer.search( '.', 'insert', stopindex = 'end' )
        if i:
            tbuffer.mark_set( 'insert', '%s +1c' %i )
        else:
            tbuffer.mark_set( 'insert', 'end' )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.120">def openRectangle( self, event ):
    if not self._chckSel( event ):
        return
    tbuffer = event.widget
    r1, r2, r3, r4 = self.getRectanglePoints( event )
    lth = ' ' * ( r4 - r2 )
    self.stopControlX( event )
    while r1 &lt;= r3:
        tbuffer.insert( '%s.%s' % ( r1, r2 ) , lth)
        r1 = r1 + 1
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.121">def clearRectangle( self, event ):
    if not self._chckSel( event ):
        return
    tbuffer = event.widget
    r1, r2, r3, r4 = self.getRectanglePoints( event )
    lth = ' ' * ( r4 - r2 )
    self.stopControlX( event )
    while r1 &lt;= r3:
        tbuffer.delete( '%s.%s' % ( r1, r2 ) , '%s.%s' % ( r1, r4 )  )
        tbuffer.insert( '%s.%s' % ( r1, r2 ) , lth)
        r1 = r1 + 1
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.122">def deleteRectangle( self, event ):
    if not self._chckSel( event ):
        return
    tbuffer = event.widget
    r1, r2, r3, r4 = self.getRectanglePoints( event )
    #lth = ' ' * ( r4 - r2 )
    self.stopControlX( event )
    while r1 &lt;= r3:
        tbuffer.delete( '%s.%s' % ( r1, r2 ) , '%s.%s' % ( r1, r4 )  )
        r1 = r1 + 1
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.123">#self.sRect = False   
def stringRectangle( self, event ):
    #global sRect
    svar, label = self.getSvarLabel( event )
    if not self.sRect:
        self.sRect = 1
        svar.set( 'String rectangle :' )
        self.setLabelBlue( label )
        return 'break'
    if event.keysym == 'Return':
        self.sRect = 3
    if self.sRect == 1:
        svar.set( '' )
        self.sRect = 2
    if self.sRect == 2:
        self.setSvar( event, svar )
        return 'break'
    if self.sRect == 3:
        if not self._chckSel( event ):
            self.stopControlX( event )
            return
        tbuffer = event.widget
        r1, r2, r3, r4 = self.getRectanglePoints( event )
        lth = svar.get()
        #self.stopControlX( event )
        while r1 &lt;= r3:
            tbuffer.delete( '%s.%s' % ( r1, r2 ),  '%s.%s' % ( r1, r4 ) )
            tbuffer.insert( '%s.%s' % ( r1, r2 ) , lth )
            r1 = r1 + 1
        #i = tbuffer.index( 'insert' )
        #tbuffer.mark_set( 'insert', 'insert wordend' )
        #tbuffer.tag_remove( 'sel', '1.0', 'end' )
        #return self._tailEnd( tbuffer )
        self.stopControlX( event )
        return self._tailEnd( tbuffer )
        #return 'break'
        #return 'break'
        #tbuffer.mark_set( 'insert', i )
        #return 'break'
</t>
<t tx="mork.20041030164547.124">#self.krectangle = None       
def killRectangle( self, event ):
    #global krectangle
    if not self._chckSel( event ):
        return
    tbuffer = event.widget
    r1, r2, r3, r4 = self.getRectanglePoints( event )
    #lth = ' ' * ( r4 - r2 )
    self.stopControlX( event )
    self.krectangle = []
    while r1 &lt;= r3:
        txt = tbuffer.get( '%s.%s' % ( r1, r2 ) , '%s.%s' % ( r1, r4 )  )
        self.krectangle.append( txt )
        tbuffer.delete( '%s.%s' % ( r1, r2 ) , '%s.%s' % ( r1, r4 )  )
        r1 = r1 + 1
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.125">def closeRectangle( self, event ):
    if not self._chckSel( event ):
        return
    tbuffer = event.widget
    r1, r2, r3, r4 = self.getRectanglePoints( event ) 
    ar1 = r1
    txt = []
    while ar1 &lt;= r3:
        txt.append( tbuffer.get( '%s.%s' %( ar1, r2 ), '%s.%s' %( ar1, r4 ) ) )
        ar1 = ar1 + 1 
    for z in txt:
        if z.lstrip().rstrip():
            return
    while r1 &lt;= r3:
        tbuffer.delete( '%s.%s' %(r1, r2 ), '%s.%s' %( r1, r4 ) )
        r1 = r1 + 1
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.126">def yankRectangle( self, event , krec = None ):
    self.stopControlX( event )
    if not krec:
        krec = self.krectangle
    if not krec:
        return 'break'
    tbuffer = event.widget
    txt = tbuffer.get( 'insert linestart', 'insert' )
    txt = self.getWSString( txt )
    i = tbuffer.index( 'insert' )
    i1, i2 = i.split( '.' )
    i1 = int( i1 )
    for z in krec:        
        txt2 = tbuffer.get( '%s.0 linestart' % i1, '%s.%s' % ( i1, i2 ) )
        if len( txt2 ) != len( txt ):
            amount = len( txt ) - len( txt2 )
            z = txt[ -amount : ] + z
        tbuffer.insert( '%s.%s' %( i1, i2 ) , z )
        if tbuffer.index( '%s.0 lineend +1c' % i1 ) == tbuffer.index( 'end' ):
            tbuffer.insert( '%s.0 lineend' % i1, '\n' )
        i1 = i1 + 1
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.127">def getWSString( self, txt ):
    ntxt = []
    for z in txt:
        if z == '\t':
            ntxt.append( z )
        else:
            ntxt.append( ' ' )
    return ''.join( ntxt )
</t>
<t tx="mork.20041030164547.128">def getRectanglePoints( self, event ):
    tbuffer = event.widget
    i = tbuffer.index( 'sel.first' )
    i2 = tbuffer.index( 'sel.last' )
    r1, r2 = i.split( '.' )
    r3, r4 = i2.split( '.' )
    r1 = int( r1 )
    r2 = int( r2 )
    r3 = int( r3 )
    r4 = int( r4 )
    return r1, r2, r3, r4
</t>
<t tx="mork.20041030164547.129">#self.negativeArg = False
def negativeArgument( self, event, stroke = None ):
    #global negativeArg
    svar, label = self.getSvarLabel( event )
    svar.set( "Negative Argument" )
    label.configure( background = 'lightblue' )
    nA = self.mcStateManager.getState( 'negativeArg' )
    if not nA:
        self.mcStateManager.setState( 'negativeArg', True )
        #self.negativeArg = True
    if nA:
        if self.negArgs.has_key( stroke ):
            self.negArgs[ stroke ]( event , stroke)
    return 'break'
</t>
<t tx="mork.20041030164547.130">def changePreviousWord( self, event, stroke ):
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    self.moveword( event, -1  )
    if stroke == '&lt;Alt-c&gt;': 
        self.capitalize( event, 'cap' )
    elif stroke =='&lt;Alt-u&gt;':
         self.capitalize( event, 'up' )
    elif stroke == '&lt;Alt-l&gt;': 
        self.capitalize( event, 'low' )
    tbuffer.mark_set( 'insert', i )
    self.stopControlX( event )
    return self._tailEnd( tbuffer )    
</t>
<t tx="mork.20041030164547.131">#self.negArgs = { '&lt;Alt-c&gt;': changePreviousWord,
#'&lt;Alt-u&gt;' : changePreviousWord,
#'&lt;Alt-l&gt;': changePreviousWord }



def insertNewLineIndent( self, event ):
    tbuffer =  event.widget
    txt = tbuffer.get( 'insert linestart', 'insert lineend' )
    txt = self.getWSString( txt )
    i = tbuffer.index( 'insert' )
    tbuffer.insert( i, txt )
    tbuffer.mark_set( 'insert', i )    
    return self.insertNewLine( event )
</t>
<t tx="mork.20041030164547.132">def dynamicExpansion( self, event ):#, store = {'rlist': [], 'stext': ''} ):
    tbuffer = event.widget
    rlist = self.store[ 'rlist' ]
    stext = self.store[ 'stext' ]
    i = tbuffer.index( 'insert -1c wordstart' )
    i2 = tbuffer.index( 'insert -1c wordend' )
    txt = tbuffer.get( i, i2 )
    dA = tbuffer.tag_ranges( 'dA' )
    tbuffer.tag_delete( 'dA' )
    def doDa( txt, from_ = 'insert -1c wordstart', to_ = 'insert -1c wordend' ):

        tbuffer.delete( from_, to_ ) 
        tbuffer.insert( 'insert', txt, 'dA' )
        return self._tailEnd( tbuffer )
        
    if dA:
        dA1, dA2 = dA
        dtext = tbuffer.get( dA1, dA2 )
        if dtext.startswith( stext ) and i2 == dA2: #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                tbuffer.delete( dA1, dA2 )
                dA2 = dA1 #since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList( tbuffer, txt, rlist )
            return doDa( txt, dA1, dA2 )
        else:
            dA = None
            
    if not dA:
        self.store[ 'stext' ] = txt
        self.store[ 'rlist' ] = rlist = []
        self.getDynamicList( tbuffer, txt, rlist )
        if not rlist:
            return 'break'
        txt = rlist.pop()
        return doDa( txt )
</t>
<t tx="mork.20041030164547.133">def dynamicExpansion2( self, event ):
    tbuffer = event.widget
    i = tbuffer.index( 'insert -1c wordstart' )
    i2 = tbuffer.index( 'insert -1c wordend' )
    txt = tbuffer.get( i, i2 )   
    rlist = []
    self.getDynamicList( tbuffer, txt, rlist )
    dEstring = reduce( self.findPre, rlist )
    if dEstring:
        tbuffer.delete( i , i2 )
        tbuffer.insert( i, dEstring )    
        return self._tailEnd( tbuffer )          
</t>
<t tx="mork.20041030164547.134">def getDynamicList( self, tbuffer, txt , rlist ):

     ttext = tbuffer.get( '1.0', 'end' )
     items = self.dynaregex.findall( ttext ) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith( txt ) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append( word )
             else:
                 rlist.remove( word )
                 rlist.append( word )
                 
        


</t>
<t tx="mork.20041030164547.135">def findPre( self, a, b ):
    st = ''
    for z in a:
        st1 = st + z
        if b.startswith( st1 ):
            st = st1
        else:
            return st
    return st  
</t>
<t tx="mork.20041030164547.136">def sortLines( self, event , which = None ):
    tbuffer = event.widget  
    if not self._chckSel( event ):
        return self.keyboardQuit( event )

    i = tbuffer.index( 'sel.first' )
    i2 = tbuffer.index( 'sel.last' )
    is1 = i.split( '.' )
    is2 = i2.split( '.' )
    txt = tbuffer.get( '%s.0' % is1[ 0 ], '%s.0 lineend' % is2[ 0 ] )
    ins = tbuffer.index( 'insert' )
    txt = txt.split( '\n' )
    tbuffer.delete( '%s.0' % is1[ 0 ], '%s.0 lineend' % is2[ 0 ] )
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[ 0 ])
    for z in txt:
        tbuffer.insert( '%s.0' % inum, '%s\n' % z ) 
        inum = inum + 1
    tbuffer.mark_set( 'insert', ins )
    self.keyboardQuit( event )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.137">def sortColumns( self, event ):
    tbuffer = event.widget
    if not self._chckSel( event ):
        return self.keyboardQuit( event )
        
    ins = tbuffer.index( 'insert' )
    is1 = tbuffer.index( 'sel.first' )
    is2 = tbuffer.index( 'sel.last' )   
    sint1, sint2 = is1.split( '.' )
    sint2 = int( sint2 )
    sint3, sint4 = is2.split( '.' )
    sint4 = int( sint4 )
    txt = tbuffer.get( '%s.0' % sint1, '%s.0 lineend' % sint3 )
    tbuffer.delete( '%s.0' % sint1, '%s.0 lineend' % sint3 )
    columns = []
    i = int( sint1 )
    i2 = int( sint3 )
    while i &lt;= i2:
        t = tbuffer.get( '%s.%s' %( i, sint2 ), '%s.%s' % ( i, sint4 ) )
        columns.append( t )
        i = i + 1
    txt = txt.split( '\n' )
    zlist = zip( columns, txt )
    zlist.sort()
    i = int( sint1 )      
    for z in xrange( len( zlist ) ):
         tbuffer.insert( '%s.0' % i, '%s\n' % zlist[ z ][ 1 ] ) 
         i = i + 1
    tbuffer.mark_set( 'insert', ins )
    return self._tailEnd( tbuffer ) 

</t>
<t tx="mork.20041030164547.138">def reverseRegion( self, event ):
    tbuffer = event.widget
    if not self._chckSel( event ):
        return
    ins = tbuffer.index( 'insert' )
    is1 = tbuffer.index( 'sel.first' )
    is2 = tbuffer.index( 'sel.last' )    
    txt = tbuffer.get( '%s linestart' % is1, '%s lineend' %is2 )
    tbuffer.delete( '%s linestart' % is1, '%s lineend' %is2  )
    txt = txt.split( '\n' )
    txt.reverse()
    istart = is1.split( '.' )
    istart = int( istart[ 0 ] )
    for z in txt:
        tbuffer.insert( '%s.0' % istart, '%s\n' % z )
        istart = istart + 1
    tbuffer.mark_set( 'insert', ins )
    self.mcStateManager.clear()
    self.resetMiniBuffer( event )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.139">def sortFields( self, event, which = None ):
    tbuffer = event.widget
    if not self._chckSel( event ):
        return self.keyboardQuit( event )

    ins = tbuffer.index( 'insert' )
    is1 = tbuffer.index( 'sel.first' )
    is2 = tbuffer.index( 'sel.last' )
    
    txt = tbuffer.get( '%s linestart' % is1, '%s lineend' % is2 )
    txt = txt.split( '\n' )
    fields = []
    import re
    fn = r'\w+'
    frx = re.compile( fn )
    for z in txt:
        f = frx.findall( z )
        if not which:
            fields.append( f[ 0 ] )
        else:
            i =  int( which )
            if len( f ) &lt; i:
                return self._tailEnd( tbuffer )
            i = i - 1            
            fields.append( f[ i ] )
    nz = zip( fields, txt )
    nz.sort()
    tbuffer.delete( '%s linestart' % is1, '%s lineend' % is2 )
    i = is1.split( '.' )
    #i2 = is2.split( '.' )
    int1 = int( i[ 0 ] )
    for z in nz:
        tbuffer.insert( '%s.0' % int1, '%s\n'% z[1] )
        int1 = int1 + 1
    tbuffer.mark_set( 'insert' , ins )
    return self._tailEnd( tbuffer )

</t>
<t tx="mork.20041030164547.140">#self.altx = False
def alt_X( self, event , which = None):
    #global altx
    if which:
        self.mcStateManager.setState( 'altx', which )
    else:
        self.mcStateManager.setState( 'altx', 'True' )

    svar, label = self.getSvarLabel( event )
    if which:
        svar.set( '%s M-x:' % which )
    else:
        svar.set( 'M-x:' )
    self.setLabelBlue( label )
    return 'break'
</t>
<t tx="mork.20041030164547.141">def doAlt_X( self, event ):
    '''This method executes the correct Alt-X command'''
    svar, label = self.getSvarLabel( event )
    if svar.get().endswith( 'M-x:' ): 
        self.axTabList.clear() #clear the list, new Alt-x command is in effect
        svar.set( '' )
    if event.keysym == 'Return':
        txt = svar.get()
        if self.doAltX.has_key( txt ):
            if txt != 'repeat-complex-command':
                self.altx_history.reverse()
                self.altx_history.append( txt )
                self.altx_history.reverse()
            aX = self.mcStateManager.getState( 'altx' )
            if aX.isdigit() and txt in self.x_hasNumeric:
                self.doAltX[ txt]( event, aX )
            else:
                self.doAltX[ txt ]( event )
        else:
            self.keyboardQuit( event )
            svar.set('Command does not exist' )

        #self.altx = False
        #self.mcStateManager.setState( 'altx', False )
        return 'break'
    if event.keysym == 'Tab':
        
        stext = svar.get().strip()
        if self.axTabList.prefix and stext.startswith( self.axTabList.prefix ):
            svar.set( self.axTabList.next() ) #get next in iteration
        else:
            prefix = svar.get()
            pmatches = self._findMatch2( svar )
            self.axTabList.setTabList( prefix, pmatches )
            svar.set( self.axTabList.next() ) #begin iteration on new lsit
        return 'break'   
    else:
        self.axTabList.clear() #clear the list, any other character besides tab indicates that a new prefix is in effect.    
    self.setSvar( event, svar )
    return 'break'
</t>
<t tx="mork.20041030164547.142">def _findMatch2( self, svar, fdict = None ):#, fdict = self.doAltX ):
    '''This method returns a sorted list of matches.'''
    if not fdict:
        fdict = self.doAltX
    txt = svar.get()
    if not txt.isspace() and txt != '':
        txt = txt.strip()
        pmatches = filter( lambda a : a.startswith( txt ), fdict )
    else:
        pmatches = []
    pmatches.sort()
    return pmatches
    #if pmatches:
    #    #mstring = reduce( self.findPre, pmatches )
    #    #return mstring
    #return txt
</t>
<t tx="mork.20041030164547.143">#self.uC = False
def universalDispatch( self, event, stroke ):
    #global uC    
    uC = self.mcStateManager.getState( 'uC' )
    if not uC:
        #self.uC = 1
        self.mcStateManager.setState( 'uC', 1 )
        svar, label = self.getSvarLabel( event )
        svar.set( '' )
        self.setLabelBlue( label ) 
    elif uC == 1:
        self.universalCommand1( event, stroke )
    elif uC == 2:
        self.universalCommand3( event, stroke )
    return 'break'
</t>
<t tx="mork.20041030164547.144">#import string
#self.uCstring = string.digits + '\b'

def universalCommand1( self, event, stroke ):
    #global uC
    if event.char not in self.uCstring:
        return self.universalCommand2( event, stroke )
    svar, label = self.getSvarLabel( event )
    self.setSvar( event, svar )
    if event.char != '\b':
        svar.set( '%s ' %svar.get() )
</t>
<t tx="mork.20041030164547.145">def universalCommand2(  self, event , stroke ):
    #global uC
    #self.uC = False
    #self.mcStateManager.setState( 'uC', False )
    svar, label = self.getSvarLabel( event )
    txt = svar.get()
    self.keyboardQuit( event )
    txt = txt.replace( ' ', '' )
    self.resetMiniBuffer( event )
    if not txt.isdigit(): #This takes us to macro state.  For example Control-u Control-x (  will execute the last macro and begin editing of it.
        if stroke == '&lt;Control-x&gt;':
            #self.uC = 2
            self.mcStateManager.setState( 'uC', 2 )
            return self.universalCommand3( event, stroke )
        return self._tailEnd( event.widget )
    if self.uCdict.has_key( stroke ): #This executes the keystroke 'n' number of times.
            self.uCdict[ stroke ]( event , txt )
    else:
        tbuffer = event.widget
        i = int( txt )
        stroke = stroke.lstrip( '&lt;' ).rstrip( '&gt;' )
        if self.cbDict.has_key( stroke ):
            for z in xrange( i ):
                method = self.cbDict[ stroke ]
                ev = Tkinter.Event()
                ev.widget = event.widget
                ev.keysym = event.keysym
                ev.keycode = event.keycode
                ev.char = event.char
                self.masterCommand( ev , method, '&lt;%s&gt;' % stroke )
        else:
            for z in xrange( i ):
                tbuffer.event_generate( '&lt;Key&gt;', keycode = event.keycode, keysym = event.keysym )
                self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.146">#self.uCdict = { '&lt;Alt-x&gt;' : alt_X }
def universalCommand3( self, event, stroke ):
    svar, label = self.getSvarLabel( event )
    svar.set( 'Control-u %s' % stroke.lstrip( '&lt;' ).rstrip( '&gt;' ) )
    self.setLabelBlue( label )
    if event.keysym == 'parenleft':
        self.keyboardQuit( event )
        self.startKBDMacro( event )
        self.executeLastMacro( event )
        return 'break'
</t>
<t tx="mork.20041030164547.147">def numberCommand( self, event, stroke, number ):
    self.universalDispatch( event, stroke )
    tbuffer = event.widget
    tbuffer.event_generate( '&lt;Key&gt;', keysym = number )
    return 'break'       
</t>
<t tx="mork.20041030164547.148">def transposeLines( self, event ):
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    i1, i2 = i.split( '.' )
    i1 = str( int( i1 ) -1 )
    if i1 != '0':
        l2 = tbuffer.get( 'insert linestart', 'insert lineend' )
        tbuffer.delete( 'insert linestart-1c', 'insert lineend' )
        tbuffer.insert( i1+'.0', l2 +'\n')
    else:
        l2 = tbuffer.get( '2.0', '2.0 lineend' )
        tbuffer.delete( '2.0', '2.0 lineend' )
        tbuffer.insert( '1.0', l2 + '\n' )
    return self._tailEnd( tbuffer )         
</t>
<t tx="mork.20041030164547.149">def upperLowerRegion( self, event, way ):
    tbuffer = event.widget
    mrk = 'sel'
    trange = tbuffer.tag_ranges( mrk )
    if len( trange ) != 0:
        text = tbuffer.get( trange[ 0 ] , trange[ -1 ] )
        i = tbuffer.index( 'insert' )
        if text == ' ': return 'break'
        tbuffer.delete( trange[ 0 ], trange[ -1 ] )
        if way == 'low':
            text = text.lower()
        if way == 'up':
            text = text.upper()
        tbuffer.insert( 'insert', text )
        tbuffer.mark_set( 'insert', i ) 
    self.removeRKeys( tbuffer )
    return 'break'
</t>
<t tx="mork.20041030164547.150">def removeBlankLines (self,event):
    tbuffer = event.widget
    i = tbuffer.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1)
    dindex = []
    if tbuffer.get('insert linestart','insert lineend').strip() == '':
        while 1:
            if str(i1) + '.0' == '1.0':
                break
            i1 = i1-1
            txt = tbuffer.get('%s.0' % i1,'%s.0 lineend' % i1)
            txt = txt.strip()
            if len(txt) == 0:
                dindex.append('%s.0' % i1)
                dindex.append('%s.0 lineend' % i1)
            elif dindex:
                tbuffer.delete('%s-1c' % dindex[-2],dindex[1])
                tbuffer.event_generate('&lt;Key&gt;')
                tbuffer.update_idletasks()
                break
            else:
                break
    i = tbuffer.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1)
    dindex = []
    while 1:
        if tbuffer.index('%s.0 lineend' % i1) == tbuffer.index('end'):
            break
        i1 = i1 + 1
        txt = tbuffer.get('%s.0' % i1,'%s.0 lineend' % i1)
        txt = txt.strip()
        if len(txt) == 0:
            dindex.append('%s.0' % i1)
            dindex.append('%s.0 lineend' % i1)
        elif dindex:
            tbuffer.delete('%s-1c' % dindex[0],dindex[-1])
            tbuffer.event_generate('&lt;Key&gt;')
            tbuffer.update_idletasks()
            break
        else:
            break</t>
<t tx="mork.20041030164547.151">def insertFile( self, event ):
    tbuffer = event.widget
    f, name = self.getReadableTextFile()
    if not f: return None
    txt = f.read()
    f.close()
    tbuffer.insert( 'insert', txt )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041030164547.152">def saveFile( self, event ):
    tbuffer = event.widget
    import tkFileDialog
    txt = tbuffer.get( '1.0', 'end' )
    f = tkFileDialog.asksaveasfile()
    if f == None : return None
    f.write( txt )
    f.close()
</t>
<t tx="mork.20041030164547.153">def scolorizer( self, event ):

    tbuffer = event.widget
    svar, label = self.getSvarLabel( event )
    stext = svar.get()
    tbuffer.tag_delete( 'color' )
    tbuffer.tag_delete( 'color1' )
    if stext == '': return 'break'
    ind = '1.0'
    while ind:
        try:
            ind = tbuffer.search( stext, ind, stopindex = 'end', regexp = self.useRegex() )
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int( d ) + len( stext ))
            index = tbuffer.index( 'insert' )
            if ind == index:
                tbuffer.tag_add( 'color1', ind, '%s.%s' % (i,d) )
            tbuffer.tag_add( 'color', ind, '%s.%s' % (i, d) )
            ind = i +'.'+d
    tbuffer.tag_config( 'color', foreground = 'red' ) 
    tbuffer.tag_config( 'color1', background = 'lightblue' ) 
</t>
<t tx="mork.20041030164547.154">def startGoto( self, event , ch = False):
    #global goto
    #self.goto = True
    if not ch:
        self.mcStateManager.setState( 'goto', 1 )
    else:
        self.mcStateManager.setState( 'goto', 2 )
    #label = self.mbuffers[ event.widget ] 
    svar , label = self.getSvarLabel( event )
    svar.set( '' )
    label.configure( background = 'lightblue' )
    return 'break'
</t>
<t tx="mork.20041030164547.155">def Goto( self, event ):
    #global goto
    widget = event.widget
    svar, label = self.getSvarLabel( event )
    if event.keysym == 'Return':
          i = svar.get()
          self.resetMiniBuffer( event )
          #self.goto = False
          state = self.mcStateManager.getState( 'goto' )
          self.mcStateManager.setState( 'goto', False )
          if i.isdigit():
              
              if state == 1:
                widget.mark_set( 'insert', '%s.0' % i )
              elif state == 2:
                widget.mark_set( 'insert', '1.0 +%sc' % i )
              widget.event_generate( '&lt;Key&gt;' )
              widget.update_idletasks()
              widget.see( 'insert' )
          return 'break'
    t = svar.get()
    if event.char == '\b':
           if len( t ) == 1:
               t = ''
           else:
               t = t[ 0 : -1 ]
           svar.set( t )
    else:
            t = t + event.char
            svar.set( t )
    return 'break'
</t>
<t tx="mork.20041030165020">class Emacs:
    '''The Emacs class binds to a Tkinter Text widget and adds Emac derived keystrokes and commands
       to it.'''
    
    Emacs_instances = weakref.WeakKeyDictionary()
    global_killbuffer = []
    global_registers = {}
    lossage = [] ### EKR: list( ' ' * 100 )
    @others</t>
<t tx="mork.20041030165020.1">def __init__( self , tbuffer = None , minibuffer = None, useGlobalKillbuffer = False, useGlobalRegisters = False):
    '''Sets up Emacs instance.
    
    If a Tkinter Text widget and Tkinter Label are passed in
    via the tbuffer and minibuffer parameters, these are bound to.
    Otherwise an explicit call to setBufferStrokes must be done.
    useGlobalRegisters set to True indicates that the Emacs instance should use a class attribute that functions
    as a global register.
    useGlobalKillbuffer set to True indicates that the Emacs instances should use a class attribute that functions
    as a global killbuffer.'''
    
    self.mbuffers = {} 
    self.svars = {}
    
    
    #self.isearch = False
    self.tailEnds = {} #functions to execute at the end of many Emac methods.  Configurable by environment.
    self.undoers = {} #Emacs instance tracks undoers given to it.
    
    
    self.store = {'rlist': [], 'stext': ''} 
    
    #macros
    self.lastMacro = None 
    self.macs = []
    self.macro = []
    self.namedMacros = {}
    self.macroing = False
    self.dynaregex = re.compile( r'[%s%s\-_]+' %( string.ascii_letters, string.digits ) ) #for dynamic abbreviations
    self.altx_history = []
    self.keysymhistory = [] 
    
    #This section sets up the buffer data structures
    self.bufferListGetters = {}
    self.bufferSetters = {}
    self.bufferGotos = {}
    self.bufferDeletes = {}
    self.renameBuffers = {}
    self.bufferDict = None
    self.bufferTracker = Tracker()
    self.bufferCommands = {
    
    'append-to-buffer': self.appendToBuffer,
    'prepend-to-buffer': self.prependToBuffer,
    'copy-to-buffer': self.copyToBuffer,
    'insert-buffer': self.insertToBuffer,
    'switch-to-buffer': self.switchToBuffer,
     'kill-buffer': self.killBuffer,   
    }
    
    self.swapSpots = []
    self.ccolumn = '0'
    #self.howM = False
    self.reset = False
    if useGlobalKillbuffer:
        self.killbuffer = Emacs.global_killbuffer
    else:
        self.killbuffer = []
    self.kbiterator = self.iterateKillBuffer()
    
    #self.controlx = False
    self.csr = { '&lt;Control-s&gt;': 'for', '&lt;Control-r&gt;':'bak' }
    self.pref = None
    #self.zap = False
    #self.goto = False
    self.previousStroke = ''
    if useGlobalRegisters:
        self.registers = Emacs.global_registers
    else:
        self.registers = {}
    
    #registers
    self.regMeth = None
    self.regMeths, self.regText = self.addRegisterItems()

    #Abbreviations
    self.abbrevMode = False 
    self.abbrevOn = False # determines if abbreviations are on for masterCommand and toggle abbreviations
    self.abbrevs = {}
    
    self.regXRpl = None # EKR: a generator: calling self.regXRpl.next() get the next value.
    self.regXKey = None
    
    self.fillPrefix = '' #for fill prefix functions
    self.fillColumn = 70 #for line centering
    self.registermode = False #for rectangles and registers
    
    self.qQ = None
    self.qR = None
    #self.qlisten = False
    #self.lqR = Tkinter.StringVar()
    #self.lqR.set( 'Query with: ' ) # replaced with using the svar and self.mcStateManager
    self.qgetQuery = False
    #self.lqQ = Tkinter.StringVar()
    #self.lqQ.set( 'Replace with:' )# replaced with using the svar and self.mcStateManager
    self.qgetReplace = False
    self.qrexecute = False
    self.querytype = 'normal'
    
    #self.rString = False
    #These attributes are for replace-string and replace-regex
    self._sString = ''
    self._rpString = ''
    self._useRegex = False
    
    self.sRect = False  #State indicating string rectangle.  May be moved to MC_StateManager
    self.krectangle = None #The kill rectangle
    self.rectanglemode = 0 #Determines what state the rectangle system is in.
    
    self.last_clipboard = None #For interacting with system clipboard.
    
    self.negativeArg = False 
    self.negArgs = { '&lt;Alt-c&gt;': self.changePreviousWord,
    '&lt;Alt-u&gt;' : self.changePreviousWord,
    '&lt;Alt-l&gt;': self.changePreviousWord } #For negative argument functionality
    
    #self.altx = False
    #Alt-X commands.
    self.doAltX = self.addAltXCommands()
    self.axTabList = Tracker()
    self.x_hasNumeric = [ 'sort-lines' , 'sort-fields']
    
    #self.uC = False
    #These attributes are for the universal command functionality.
    self.uCstring = string.digits + '\b'
    self.uCdict = { '&lt;Alt-x&gt;' : self.alt_X }
    
    self.cbDict = self.addCallBackDict()# Creates callback dictionary, primarily used in the master command
    self.xcommands = self.addXCommands() # Creates the X commands dictionary
    self.cxHandler = ControlXHandler( self ) #Creates the handler for Control-x commands
    self.mcStateManager = MC_StateManager( self ) #Manages state for the master command
    self.kstrokeManager = MC_KeyStrokeManager( self ) #Manages some keystroke state for the master command.
    self.shutdownhook = None #If this is set via setShutdownHook, it is executed instead of sys.exit when Control-x Control-c is fired
    self.shuttingdown = False #indicates that the Emacs instance is shutting down and no work needs to be done.
    
    if tbuffer and minibuffer:
        self.setBufferStrokes( tbuffer, minibuffer )

</t>
<t tx="mork.20041030183331">def addCallBackDict( self ):
    '''This method adds a dictionary to the Emacs instance through which the masterCommand can
       call the specified method.'''
    cbDict = {
    'Alt-less' : lambda event, spot = '1.0' : self.moveTo( event, spot ),
    'Alt-greater': lambda event, spot = 'end' : self.moveTo( event, spot ),
    'Control-Right': lambda event, way = 1: self.moveword( event, way ),
    'Control-Left': lambda event, way = -1: self.moveword( event, way ),
    'Control-a': lambda event, spot = 'insert linestart': self.moveTo( event, spot ),
    'Control-e': lambda event, spot = 'insert lineend': self.moveTo( event, spot ),
    'Alt-Up': lambda event, spot = 'insert linestart': self.moveTo( event, spot ),
    'Alt-Down': lambda event, spot = 'insert lineend': self.moveTo( event, spot ),
    'Alt-f': lambda event, way = 1: self.moveword( event, way ),
    'Alt-b' : lambda event, way = -1: self.moveword( event, way ),
    'Control-o': self.insertNewLine,
    'Control-k': lambda event, frm = 'insert', to = 'insert lineend': self.kill( event, frm, to) ,
    'Alt-d': lambda event, frm = 'insert wordstart', to = 'insert wordend': self.kill( event,frm, to ),
    'Alt-Delete': lambda event: self.deletelastWord( event ),
    "Control-y": lambda event, frm = 'insert', which = 'c': self.walkKB( event, frm, which),
    "Alt-y": lambda event , frm = "insert", which = 'a': self.walkKB( event, frm, which ),
    "Alt-k": lambda event : self.killsentence( event ),
    'Control-s' : None,
    'Control-r' : None,
    'Alt-c': lambda event, which = 'cap' : self.capitalize( event, which ),
    'Alt-u': lambda event, which = 'up' : self.capitalize( event, which ),
    'Alt-l': lambda event, which = 'low' : self.capitalize( event, which ),
    'Alt-t': lambda event, sw = self.swapSpots: self.swapWords( event, sw ),
    'Alt-x': self.alt_X,
    'Control-x': self.startControlX,
    'Control-g': self.keyboardQuit,
    'Control-Shift-at': self.setRegion,
    'Control-w': lambda event, which = 'd' :self.killRegion( event, which ),
    'Alt-w': lambda event, which = 'c' : self.killRegion( event, which ),
    'Control-t': self.swapCharacters,
    'Control-u': None,
    'Control-l': None,
    'Alt-z': None,
    'Control-i': None,
    'Alt-Control-backslash': self.indentRegion,
    'Alt-m' : self.backToIndentation,
    'Alt-asciicircum' : self.deleteIndentation,
    'Control-d': self.deleteNextChar,
    'Alt-backslash': self.deleteSpaces, 
    'Alt-g': None,
    'Control-v' : lambda event, way = 'south': self.screenscroll( event, way ),
    'Alt-v' : lambda event, way = 'north' : self.screenscroll( event, way ),
    'Alt-equal': self.countRegion,
    'Alt-parenleft': self.insertParentheses,
    'Alt-parenright': self.movePastClose,
    'Alt-percent' : None,
    'Control-c': None,
    'Delete': lambda event, which = 'BackSpace': self.manufactureKeyPress( event, which ),
    'Control-p': lambda event, which = 'Up': self.manufactureKeyPress( event, which ),
    'Control-n': lambda event, which = 'Down': self.manufactureKeyPress( event, which ),
    'Control-f': lambda event, which = 'Right':self.manufactureKeyPress( event, which ),
    'Control-b': lambda event, which = 'Left': self.manufactureKeyPress( event, which ),
    'Control-Alt-w': None,
    'Alt-a': lambda event, which = 'bak': self.prevNexSentence( event, which ),
    'Alt-e': lambda event, which = 'for': self.prevNexSentence( event, which ),
    'Control-Alt-o': self.insertNewLineIndent,
    'Control-j': self.insertNewLineAndTab,
    'Alt-minus': self.negativeArgument,
    'Alt-slash': self.dynamicExpansion,
    'Control-Alt-slash': self.dynamicExpansion2,
    'Control-u': lambda event, keystroke = '&lt;Control-u&gt;': self.universalDispatch( event, keystroke ),
    'Alt-braceright': lambda event, which = 1: self.movingParagraphs( event, which ),
    'Alt-braceleft': lambda event , which = 0: self.movingParagraphs( event, which ),
    'Alt-q': self.fillParagraph,
    'Alt-h': self.selectParagraph,
    'Alt-semicolon': self.indentToCommentColumn,
    'Alt-0': lambda event, stroke = '&lt;Alt-0&gt;', number = 0: self.numberCommand( event, stroke, number ) ,
    'Alt-1': lambda event, stroke = '&lt;Alt-1&gt;', number = 1: self.numberCommand( event, stroke, number ) ,
    'Alt-2': lambda event, stroke = '&lt;Alt-2&gt;', number = 2: self.numberCommand( event, stroke, number ) ,
    'Alt-3': lambda event, stroke = '&lt;Alt-3&gt;', number = 3: self.numberCommand( event, stroke, number ) ,
    'Alt-4': lambda event, stroke = '&lt;Alt-4&gt;', number = 4: self.numberCommand( event, stroke, number ) ,
    'Alt-5': lambda event, stroke = '&lt;Alt-5&gt;', number = 5: self.numberCommand( event, stroke, number ) ,
    'Alt-6': lambda event, stroke = '&lt;Alt-6&gt;', number = 6: self.numberCommand( event, stroke, number ) ,
    'Alt-7': lambda event, stroke = '&lt;Alt-7&gt;', number = 7: self.numberCommand( event, stroke, number ) ,
    'Alt-8': lambda event, stroke = '&lt;Alt-8&gt;', number = 8: self.numberCommand( event, stroke, number ) ,
    'Alt-9': lambda event, stroke = '&lt;Alt-9&gt;', number = 9: self.numberCommand( event, stroke, number ) ,
    'Control-underscore': self.doUndo,
    'Alt-s': self.centerLine,
    'Control-z': self.suspend, 
    'Control-Alt-s': lambda event, stroke='&lt;Control-s&gt;': self.startIncremental( event, stroke, which='regexp' ),
    'Control-Alt-r': lambda event, stroke='&lt;Control-r&gt;': self.startIncremental( event, stroke, which='regexp' ),
    'Control-Alt-percent': lambda event: self.startRegexReplace() and self.masterQR( event ),
    'Escape': self.watchEscape,
    'Alt-colon': self.startEvaluate,
    'Alt-exclam': self.startSubprocess,
    'Alt-bar': lambda event: self.startSubprocess( event, which = 1 ),
    }
    
    return cbDict</t>
<t tx="mork.20041030183633">def addXCommands( self ):
    
    xcommands = {
    '&lt;Control-t&gt;': self.transposeLines, 
    '&lt;Control-u&gt;': lambda event , way ='up': self.upperLowerRegion( event, way ),
    '&lt;Control-l&gt;':  lambda event , way ='low': self.upperLowerRegion( event, way ),
    '&lt;Control-o&gt;': self.removeBlankLines,
    '&lt;Control-i&gt;': self.insertFile,
    '&lt;Control-s&gt;': self.saveFile,
    '&lt;Control-x&gt;': self.exchangePointMark,
    '&lt;Control-c&gt;': self.shutdown,
    '&lt;Control-b&gt;': self.listBuffers,
    '&lt;Control-Shift-at&gt;': lambda event: event.widget.selection_clear(),
    '&lt;Delete&gt;' : lambda event, back = True: self.killsentence( event, back ),
    }
    
    return xcommands</t>
<t tx="mork.20041030190729">def addRegisterItems( self ):
    
    regMeths = {
    's' : self.copyToRegister,
    'i' : self.insertFromRegister,
    'n': self.numberToRegister,
    'plus': self.incrementRegister,
    'space': self.pointToRegister,
    'j': self.jumpToRegister,
    'a': lambda event , which = 'a': self._ToReg( event, which ),
    'p': lambda event , which = 'p': self._ToReg( event, which ),
    'r': self.copyRectangleToRegister,
    'view' : self.viewRegister,
    }    
    
    regText = {
    's' : 'copy to register',
    'i' : 'insert from register',
    'plus': 'increment register',
    'n' : 'number to register',
    'p' : 'prepend to register',
    'a' : 'append to register',
    'space' : 'point to register',
    'j': 'jump to register',
    'r': 'rectangle to register',
    'view': 'view register',
    }
    
    return regMeths, regText</t>
<t tx="mork.20041030190903">def addAltXCommands( self ):
    
    #many of the simpler methods need self.keyboardQuit( event ) appended to the end to stop the Alt-x mode.
    doAltX= {
    'prepend-to-register': self.prependToRegister,
    'append-to-register': self.appendToRegister,
    'replace-string': self.replaceString,
    'replace-regex': lambda event:  self.activateReplaceRegex() and self.replaceString( event ),
    'sort-lines': self.sortLines,
    'sort-columns': self.sortColumns,
    'reverse-region': self.reverseRegion,
    'sort-fields': self.sortFields,
    'abbrev-mode': self.toggleAbbrevMode,
    'kill-all-abbrevs': self.killAllAbbrevs,
    'expand-region-abbrevs': self.regionalExpandAbbrev,
    'write-abbrev-file': self.writeAbbreviations,
    'read-abbrev-file': self.readAbbreviations,
    'fill-region-as-paragraph': self.fillRegionAsParagraph,
    'fill-region': self.fillRegion,
    'close-rectangle': self.closeRectangle,
    'how-many': self.startHowMany,
    'kill-paragraph': self.killParagraph,
    'backward-kill-paragraph': self.backwardKillParagraph,
    'backward-kill-sentence': lambda event: self.keyboardQuit( event ) and self.killsentence( event, back = True ),
    'name-last-kbd-macro': self.nameLastMacro,
    'load-file': self.loadMacros,
    'insert-keyboard-macro' : self.getMacroName,
    'list-abbrevs': self.listAbbrevs,
    'kill-word': lambda event, frm = 'insert wordstart', to = 'insert wordend': self.kill( event,frm, to ) and self.keyboardQuit( event ),
    'kill-line': lambda event, frm = 'insert', to = 'insert lineend': self.kill( event, frm, to) and self.keyboardQuit( event ), 
    'kill-sentence': lambda event : self.killsentence( event ) and self.keyboardQuit( event ),
    'kill-region': lambda event, which = 'd' :self.killRegion( event, which ) and self.keyboardQuit( event ),
    'yank': lambda event, frm = 'insert', which = 'c': self.walkKB( event, frm, which) and self.keyboardQuit( event ),
    'yank-pop' : lambda event , frm = "insert", which = 'a': self.walkKB( event, frm, which ) and self.keyboardQuit( event ),
    'backward-kill-word': lambda event: self.deletelastWord( event ) and self.keyboardQuit( event ),
    'backward-delete-char':lambda event, which = 'BackSpace': self.manufactureKeyPress( event, which ) and self.keyboardQuit( event ),
    'delete-char': lambda event: self.deleteNextChar( event ) and self.keyboardQuit( event ) , 
    'isearch-forward': lambda event: self.keyboardQuit( event ) and self.startIncremental( event, '&lt;Control-s&gt;' ),
    'isearch-backward': lambda event: self.keyboardQuit( event ) and self.startIncremental( event, '&lt;Control-r&gt;' ),
    'isearch-forward-regexp': lambda event: self.keyboardQuit( event ) and self.startIncremental( event, '&lt;Control-s&gt;', which = 'regexp' ),
    'isearch-backward-regexp': lambda event: self.keyboardQuit( event ) and self.startIncremental( event, '&lt;Control-r&gt;', which = 'regexp' ),
    'capitalize-word': lambda event, which = 'cap' : self.capitalize( event, which ) and self.keyboardQuit( event ),
    'upcase-word': lambda event, which = 'up' : self.capitalize( event, which ) and self.keyboardQuit( event ),
    'downcase-word': lambda event, which = 'low' : self.capitalize( event, which ) and self.keyboardQuit( event ),
    'indent-region': lambda event: self.indentRegion( event ) and self.keyboardQuit( event ),
    'indent-rigidly': lambda event: self.tabIndentRegion( event ) and self.keyboardQuit( event ),
    'indent-relative': self.indent_relative,
    'set-mark-command': lambda event: self.setRegion( event ) and self.keyboardQuit( event ),
    'kill-rectangle': lambda event: self.killRectangle( event ),
    'delete-rectangle': lambda event: self.deleteRectangle( event ),
    'yank-rectangle': lambda event: self.yankRectangle( event ),
    'open-rectangle': lambda event: self.openRectangle( event ),
    'clear-rectangle': lambda event: self.clearRectangle( event ),
    'copy-to-register': lambda event: self.setEvent( event, 's' ) and self.setNextRegister( event ),
    'insert-register': lambda event: self.setEvent( event, 'i' ) and self.setNextRegister( event ),
    'copy-rectangle-to-register': lambda event: self.setEvent( event, 'r' ) and self.setNextRegister( event ),
    'jump-to-register': lambda event: self.setEvent( event, 'j' ) and self.setNextRegister( event ),
    'point-to-register': lambda event: self.setEvent( event, 'space' ) and self.setNextRegister( event ),
    'number-to-register': lambda event: self.setEvent( event, 'n' ) and self.setNextRegister( event ),
    'increment-register': lambda event: self.setEvent( event, 'plus' ) and self.setNextRegister( event ),
    'view-register': lambda event: self.setEvent( event, 'view' ) and self.setNextRegister( event ),
    'beginning-of-line': lambda event, spot = 'insert linestart': self.moveTo( event, spot ) and self.keyboardQuit( event ),
    'end-of-line': lambda event, spot = 'insert lineend': self.moveTo( event, spot ) and self.keyboardQuit( event ),
    'keyboard-quit': lambda event: self.keyboardQuit( event ),
    'advertised-undo': lambda event: self.doUndo( event ) and self.keyboardQuit( event ),
    'back-to-indentation': lambda event: self.backToIndentation( event ) and self.keyboardQuit( event ),
    'delete-indentation': lambda event: self.deleteIndentation( event ) and self.keyboardQuit( event ),    
    'view-lossage': lambda event: self.viewLossage( event ),
     'transpose-chars': lambda event : self.swapCharacters( event ) and self.keyboardQuit( event ),
     'transpose-words': lambda event, sw = self.swapSpots: self.swapWords( event, sw ) and self.keyboardQuit( event ),
     'transpose-lines': lambda event: self.transposeLines( event ) and self.keyboardQuit( event ),
     'insert-file' : lambda event: self.insertFile( event ) and self.keyboardQuit( event ),
     'save-buffer' : lambda event: self.saveFile( event ) and self.keyboardQuit( event ),
     'split-line' : lambda event: self.insertNewLineIndent( event ) and self.keyboardQuit( event ),
     'upcase-region': lambda event: self.upperLowerRegion( event, 'up' ) and self.keyboardQuit( event ),
     'downcase-region': lambda event: self.upperLowerRegion( event , 'low' ) and self.keyboardQuit( event ),
     'dabbrev-expands': lambda event: self.dynamicExpansion( event ) and self.keyboardQuit( event ),
     'dabbrev-completion': lambda event: self.dynamicExpansion2( event ) and self.keyboardQuit( event ),
     'goto-line': lambda event: self.startGoto( event ),
     'goto-char': lambda event: self.startGoto( event, True ),
     'set-fill-prefix': lambda event: self.setFillPrefix( event ) and self.keyboardQuit( event ),
     'set-fill-column': lambda event: self.setFillColumn( event ),
     'center-line': lambda event: self.centerLine( event ) and self.keyboardQuit( event ),
     'center-region': lambda event: self.centerRegion( event ) and self.keyboardQuit( event ),
     'forward-char': lambda event, which = 'Right': self.keyboardQuit( event ) and self.manufactureKeyPress( event, which ),
     'backward-char': lambda event, which = 'Left': self.keyboardQuit( event ) and self.manufactureKeyPress( event, which ),
     'previous-line': lambda event, which = 'Up': self.keyboardQuit( event ) and self.manufactureKeyPress( event, which ),
     'next-line': lambda event, which = 'Down': self.keyboardQuit( event ) and self.manufactureKeyPress( event, which ),
     'digit-argument': lambda event: self.universalDispatch( event, '' ),
     'universal-argument': lambda event: self.universalDispatch( event, '' ),   
     'newline-and-indent': lambda event: self.insertNewLineAndTab( event ) and self.keyboardQuit( event ),
     'beginning-of-buffer': lambda event, spot = '1.0' : self.moveTo( event, spot ) and self.keyboardQuit( event ),
     'end-of-buffer': lambda event, spot = 'end' : self.moveTo( event, spot ) and self.keyboardQuit( event ),
     'scroll-up': lambda event, way = 'north' : self.screenscroll( event, way ) and self.keyboardQuit( event ),
     'scroll-down': lambda event, way = 'south': self.screenscroll( event, way ) and self.keyboardQuit( event ),
     'copy-to-buffer': lambda event, which = 'copy-to-buffer': self.setInBufferMode( event, which ),
     'insert-buffer': lambda event, which = 'insert-buffer': self.setInBufferMode( event, which ),
     'append-to-buffer': lambda event , which = 'append-to-buffer':  self.setInBufferMode( event, which ),
     'prepend-to-buffer': lambda event, which = 'prepend-to-buffer': self.setInBufferMode( event, which ),
     'switch-to-buffer': lambda event, which = 'switch-to-buffer': self.setInBufferMode( event, which ),
     'list-buffers' : lambda event: self.listBuffers( event ),
     'kill-buffer' : lambda event, which = 'kill-buffer': self.setInBufferMode( event, which ),
     'rename-buffer': lambda event: self.renameBuffer( event ),
     'query-replace': lambda event: self.masterQR( event ), 
     'query-replace-regex': lambda event: self.startRegexReplace() and self.masterQR( event ),
     'inverse-add-global-abbrev': lambda event: self.abbreviationDispatch( event, 2 ) ,  
     'expand-abbrev': lambda event : self.keyboardQuit( event ) and self.expandAbbrev( event ), 
     'iconfify-or-deiconify-frame': lambda event: self.suspend( event ) and self.keyboardQuit( event ),
     'save-buffers-kill-emacs': lambda event: self.keyboardQuit( event ) and self.shutdown( event ),
     're-search-forward': lambda event: self.reStart( event ),
     're-search-backward': lambda event: self.reStart( event, which = 'backward' ),
     'diff': self.diff, 
     'what-line': self.whatLine,
     'flush-lines': lambda event: self.startLines( event ),
     'keep-lines': lambda event: self.startLines( event, which = 'keep' ),
     'make-directory': lambda event: self.makeDirectory( event ),
     'remove-directory': lambda event: self.removeDirectory( event ),
     'delete-file': lambda event: self.deleteFile( event ),
     'search-forward': lambda event: self.startNonIncrSearch( event, 'for' ),
     'search-backward': lambda event: self.startNonIncrSearch( event, 'bak' ),
     'word-search-forward': lambda event : self.startWordSearch( event, 'for' ),
     'word-search-backward': lambda event: self.startWordSearch( event, 'bak' ),
     'repeat-complex-command': lambda event: self.repeatComplexCommand( event ),
     'eval-expression': self.startEvaluate,
     'tabify': self.tabify,
     'untabify': lambda event: self.tabify( event, which = 'untabify' ),
     'shell-command': self.startSubprocess,
     'shell-command-on-region': lambda event: self.startSubprocess( event, which=1 ),
    }    
    #Note: if we are reusing some of the cbDict lambdas we need to alter many by adding: self.keyboardQuit( event )
    #Otherwise the darn thing just sits in Alt-X land.  Putting the 'and self.keyboardQuit( event )' part in the killbuffer
    #and yanking it out for each new item, works well.  Adding it to a register might be good to.
    return doAltX






 </t>
<t tx="mork.20041031131847">class ControlXHandler:
    '''The ControlXHandler manages how the Control-X based commands operate on the
       Emacs instance.'''    
    
    @others

</t>
<t tx="mork.20041031132342">def __call__( self, event , stroke ):
    
    self.previous.insert( 0, event.keysym )
    emacs = self.emacs 
    if len( self.previous ) &gt; 10: self.previous.pop()
    if stroke in ('&lt;Key&gt;', '&lt;Escape&gt;' ):
        return self.processKey( event )
    if stroke in emacs.xcommands:
        emacs.xcommands[ stroke ]( event )
        if stroke != '&lt;Control-b&gt;': emacs.keyboardQuit( event )
    return 'break'</t>
<t tx="mork.20041031133146">def processKey( self, event ):
        
    emacs = self.emacs 
    previous = self.previous
    if event.keysym in ( 'Shift_L', 'Shift_R' ):
        return
        
    if emacs.sRect:
        return emacs.stringRectangle( event )
        
    if ( event.keysym == 'r' and emacs.rectanglemode == 0 ) and not emacs.registermode:
        return self.processRectangle( event )
    elif self.rect_commands.has_key( event.keysym ) and emacs.rectanglemode == 1:
        return self.processRectangle( event )
        
    if self.register_commands.has_key( emacs.registermode ):
        self.register_commands[ emacs.registermode ]( event )
        return 'break'
    
    if self.variety_commands.has_key( event.keysym ):
        emacs.stopControlX( event )
        return self.variety_commands[ event.keysym ]( event )
        
    
    #if emacs.sRect:
    #    return emacs.stringRectangle( event )
    #    #return 'break'
    if event.keysym in ( 'a', 'i' , 'e'):
        if self.processAbbreviation( event ): return 'break'

    if event.keysym == 'g':
        svar, label = emacs.getSvarLabel( event )
        l = svar.get()
        if self.abbreviationDispatch.has_key( l ):
            emacs.stopControlX( event )
            return self.abbreviationDispatch[ l ]( event )
        #if l == 'a':
        #    emacs.stopControlX( event )
        #    return emacs.abbreviationDispatch( event, 1 )
        #elif l == 'a i':
        #    emacs.stopControlX( event )
        #    return emacs.abbreviationDispatch( event, 2 )
    if event.keysym == 'e':
        emacs.stopControlX( event )
        return emacs.executeLastMacro( event )
    if event.keysym == 'x' and previous[ 1 ] not in ( 'Control_L', 'Control_R'):
        event.keysym = 's' 
        emacs.setNextRegister( event )
        return 'break'
    
    if event.keysym == 'Escape':
        if len( previous ) &gt; 1:
            if previous[ 1 ] == 'Escape':
                return emacs.repeatComplexCommand( event )
    #if event.keysym == 'r':
    #    return emacs.activateRectangleMethods( event )
    #if self.rect_commands.has_key( event.keysym ):# and emacs.registermode == 1:
    #    return self.processRectangle( event )
     
    #if emacs.registermode == 1:
    #    emacs.setNextRegister( event )
    #    return 'break'
    #elif emacs.registermode == 2:
    #    emacs.executeRegister( event )
    #    return 'break'
    #if self.register_commands.has_key( emacs.registermode ):
    #    print 'register commands'
    #    self.register_commands[ emacs.registermode ]( event )
    #    return 'break'
    #if event.keysym == 'r':
    #    return emacs.activateRectangleMethods( event )
    #    emacs.registermode = 1
    #    svar = emacs.svars[ event.widget ]
    #    svar.set( 'C - x r' )
    #    return 'break'
    #if event.keysym== 'h':
    #    emacs.stopControlX( event )
    #    event.widget.tag_add( 'sel', '1.0', 'end' )
    #tag_add( 'sel', '1.0', 'end' )    return 'break' 
    #if event.keysym == 'equal':
    #    emacs.lineNumber( event )
    #    return 'break'
    #if event.keysym == 'u':
    #    emacs.stopControlX( event )
    #    return emacs.doUndo( event, 2 )   
        
         



</t>
<t tx="mork.20041031134709">def processRectangle( self, event ):
    
    self.rect_commands[ event.keysym ]( event )
    return 'break'
    #if event.keysym == 'o':
    #    emacs.openRectangle( event )
    #    return 'break'
    #if event.keysym == 'c':
    #    emacs.clearRectangle( event )
    #    return 'break'
    #if event.keysym == 't':
    #    emacs.stringRectangle( event )
    #    return 'break'
    #if event.keysym == 'y':
    #    emacs.yankRectangle( event )
    #    return 'break'
    #if event.keysym == 'd':
    #    emacs.deleteRectangle( event )
    #    return 'break'
    #if event.keysym == 'k':
    #    emacs.killRectangle( event )
    #    return 'break'       
</t>
<t tx="mork.20041031135748">def processAbbreviation( self, event ):
    
    emacs = self.emacs
    svar, label = emacs.getSvarLabel( event )
    if svar.get() != 'a' and event.keysym == 'a':
        svar.set( 'a' )
        return 'break'
    elif svar.get() == 'a':
        if event.char == 'i':
            svar.set( 'a i' )
        elif event.char == 'e':
            emacs.stopControlX( event )
            event.char = ''
            emacs.expandAbbrev( event )
        return 'break'</t>
<t tx="mork.20041031145157">class MC_StateManager:
    
    '''MC_StateManager manages the state that the Emacs instance has entered and
       routes key events to the right method, dependent upon the state in the MC_StateManager'''
       
    @others



</t>
<t tx="mork.20041031150125"># EKR: used only below.
def eA( event ):
    if self.emacs.expandAbbrev( event ) :
        return 'break'

self.stateCommands = { #1 == one parameter, 2 == all
    'uC': ( 2, emacs.universalDispatch ),
    'controlx': ( 2, emacs.doControlX ),
    'isearch':( 2, emacs.iSearch ),
    'goto': ( 1, emacs.Goto ),
    'zap': ( 1, emacs.zapTo ),
    'howM': ( 1, emacs.howMany ),
    'abbrevMode': ( 1, emacs.abbrevCommand1 ),
    'altx': ( 1, emacs.doAlt_X ),
    'qlisten': ( 1, emacs.masterQR ),
    'rString': ( 1, emacs.replaceString ),
    'negativeArg':( 2, emacs.negativeArgument ),
    'abbrevOn': ( 1, eA ),
    'set-fill-column': ( 1, emacs.setFillColumn ),
    'chooseBuffer': ( 1, emacs.chooseBuffer ),
    'renameBuffer': ( 1, emacs.renameBuffer ),
    're_search': ( 1, emacs.re_search ),
    'alterlines': ( 1, emacs.processLines ),
    'make_directory': ( 1, emacs.makeDirectory ),
    'remove_directory': ( 1, emacs.removeDirectory ),
    'delete_file': ( 1, emacs.deleteFile ),
    'nonincr-search': ( 2, emacs.nonincrSearch ),
    'word-search':( 1, emacs.wordSearch ),
    'last-altx': ( 1, emacs.executeLastAltX ),
    'escape': ( 1, emacs.watchEscape ),
    'subprocess': ( 1, emacs.subprocesser ),
    }</t>
<t tx="mork.20041031155313">@others</t>
<t tx="mork.20041031155455">@others</t>
<t tx="mork.20041031155642">@
These methods add things to the registers( a-z )

@c

@others</t>
<t tx="mork.20041031155753">@
general macro methods.

@c


@others</t>
<t tx="mork.20041031155913">@others</t>
<t tx="mork.20041031160002">@
These methods take the user to a specific line or a specific character in the buffer


@c

@others</t>
<t tx="mork.20041031162857">def __init__( self, emacs ):
        
    self.emacs = emacs
    self.state = None
    self.states = {}
    &lt;&lt;statecommands&gt;&gt;</t>
<t tx="mork.20041031162857.1">def setState( self, state, value ):
        
    self.state = state
    self.states[ state ] = value</t>
<t tx="mork.20041031162857.2">def getState( self, state ):
    
    return self.states.get(state,False)</t>
<t tx="mork.20041031162857.3">def hasState( self ):

    if self.state:
        return self.states[ self.state ]
</t>
<t tx="mork.20041031162857.4">def __call__( self, *args ):
        
    if self.state:
        which = self.stateCommands[ self.state ]
        
        # EKR: which[0] is a flag: 1 == one parameter, 2 == all
        # EKR: which[1] is the function.
        
        if which[ 0 ] == 1:
            return which[ 1 ]( args[ 0 ] )
        else:
            return which[ 1 ]( *args )
</t>
<t tx="mork.20041031162857.5">def clear( self ):
        
    self.state = None

    for z in self.states.keys():
        self.states[ z ] = False</t>
<t tx="mork.20041031162953">def __init__( self, emacs ):
        
    self.emacs = emacs
    self.previous = []
    self.rect_commands = {
    'o': emacs.openRectangle,
    'c': emacs.clearRectangle,
    't': emacs.stringRectangle,
    'y': emacs.yankRectangle,
    'd': emacs.deleteRectangle,
    'k': emacs.killRectangle,
    'r': emacs.activateRectangleMethods,             
    }
    
    self.variety_commands = {
    'period': emacs.setFillPrefix,
    'parenleft': emacs.startKBDMacro,
    'parenright' : emacs.stopKBDMacro,
    'semicolon': emacs.setCommentColumn,
    'Tab': emacs.tabIndentRegion,
    'u': lambda event: emacs.doUndo( event, 2 ),
    'equal': emacs.lineNumber,
    'h': emacs.selectAll,
    'f': emacs.setFillColumn,
    'b': lambda event, which = 'switch-to-buffer': emacs.setInBufferMode( event, which ),
    'k': lambda event, which = 'kill-buffer': emacs.setInBufferMode( event, which ),
    }
    
    self.abbreviationDispatch = {    
    'a': lambda event: emacs.abbreviationDispatch( event, 1 ),
    'a i': lambda event: emacs.abbreviationDispatch( event, 2 ),    
    }
    
    self.register_commands ={    
    1: emacs.setNextRegister,
    2: emacs.executeRegister,        
    }
</t>
<t tx="mork.20041031181701">@

type some text, set its abbreviation with Control-x a i g, type the text for abbreviation expansion
type Control-x a e ( or Alt-x expand-abbrev ) to expand abbreviation
type Alt-x abbrev-on to turn on automatic abbreviation expansion
Alt-x abbrev-on to turn it off

an example:
type:
frogs
after typing 's' type Control-x a i g.  This will turn the minibuffer blue, type in your definition. For example: turtles.

Now in the buffer type:
frogs
after typing 's' type Control-x a e.  This will turn the 'frogs' into:
turtles



@c

@others</t>
<t tx="mork.20041031181701.1">@
These methods handle the query-replace and query-replace-regex commands.  They need to be fully migrated
to the self.mcStateManager mechanism, which should simplify things greatly, or at least the amount of variables its required
so far.

@c


@others</t>
<t tx="mork.20041031181701.2">@others</t>
<t tx="mork.20041031181740">@others</t>
<t tx="mork.20041031181929">@
These methods add text to the killbuffer.
@c

@others</t>
<t tx="mork.20041031181929.1">@
These methods control the Alt-x command functionality.

@c


@others</t>
<t tx="mork.20041031182137">@

untested as of yet for .5 conversion.

@c


@others</t>
<t tx="mork.20041031182215">@
Two closely related categories under this one heading.  Svars are the internals of the minibuffer
and the labels are the presentation of those internals

@c

@others</t>
<t tx="mork.20041031182258">@
These methods create the dispatch dictionarys that the
Emacs instance uses to execute specific keystrokes and commands.
Dont mess with it if you dont understand this section, without these dictionarys
the Emacs system cant work.

@c


@others</t>
<t tx="mork.20041031182332">@
These methods start and execute the Zap to functionality.
@c



@others</t>
<t tx="mork.20041031182402">@others</t>
<t tx="mork.20041031182449">@
These methods load files into buffers and save buffers to files

@c


@others</t>
<t tx="mork.20041031182643">@others</t>
<t tx="mork.20041031182643.1">@
Emacs requires an undo mechanism be added from the environment.
If there is no undo mechanism added, there will be no undo functionality in the instance.
@c



@others</t>
<t tx="mork.20041031182709">@others</t>
<t tx="mork.20041031182837">@
These methods enable the incremental search functionality.

@c

@others</t>
<t tx="mork.20041031182916">@others</t>
<t tx="mork.20041031182943">@
These methods get and alter the Svar variable which is a Tkinter
StringVar.  This StringVar contains what is displayed in the minibuffer.
@c


@others</t>
<t tx="mork.20041031183018">@others</t>
<t tx="mork.20041031183136">@others</t>
<t tx="mork.20041031183614">@
These methods currently do not have a specific class that they belong to.

@c


@others</t>
<t tx="mork.20041031183614.1">@others</t>
<t tx="mork.20041031194703">@others</t>
<t tx="mork.20041031194746">@
These methods contain methods by which an Emacs instance is extended, changed, added to , etc...

@c


@others</t>
<t tx="mork.20041031194858">@others</t>
<t tx="mork.20041031195549">@others</t>
<t tx="mork.20041031195908">@others</t>
<t tx="mork.20041031195908.1">@others</t>
<t tx="mork.20041031202438">def selectAll( event ):

    event.widget.tag_add( 'sel', '1.0', 'end' )
    return 'break'
    
</t>
<t tx="mork.20041031202908">def activateRectangleMethods( self, event ):
    
    self.rectanglemode = 1
    svar = self.svars[ event.widget ]
    svar.set( 'C - x r' )
    return 'break'
</t>
<t tx="mork.20041101083527">class MC_KeyStrokeManager:
    
    @others</t>
<t tx="mork.20041101083527.1">def __init__( self, emacs ):
    
    self.emacs = emacs

    &lt;&lt;keystrokes&gt;&gt;
</t>
<t tx="mork.20041101083527.2">self.keystrokes = {

    '&lt;Control-s&gt;': ( 2, emacs.startIncremental ), 
    '&lt;Control-r&gt;': ( 2, emacs.startIncremental ),
    '&lt;Alt-g&gt;': ( 1, emacs.startGoto ),
    '&lt;Alt-z&gt;': ( 1, emacs.startZap ),
    '&lt;Alt-percent&gt;': ( 1,  emacs.masterQR ) ,
    '&lt;Control-Alt-w&gt;': ( 1, lambda event: 'break' ),
}</t>
<t tx="mork.20041101084148">def hasKeyStroke( self, stroke ):
    
    return self.keystrokes.has_key( stroke )</t>
<t tx="mork.20041101084148.1">def __call__( self, event, stroke ):
    
    kstroke = self.keystrokes[ stroke ]
    
    if 0: # EKR: this would be better:
        numberOfArgs,func = self.keystrokes[ stroke ]
        if numberOfArgs == 1:
            return func(event)
        else:
            return func(event,stroke)
    
    # EKR: which[0] is the number of params.
    # EKR: which[1] is the function.

    if kstroke[ 0 ] == 1:
        return kstroke[ 1 ]( event )
    else:
        return kstroke[ 1 ]( event, stroke )
        
    </t>
<t tx="mork.20041101100635">@

.5
       This was a fairly major shift for temacs.
   -- Changed structure from pure functional to Object Oriented.  Emacs is the central class in the temacs package now.
      The changes wrought by this are quite extensive.
   -- worked on complicated control logic, turned some parts into Objects that are state Handlers and Managers
   -- fixed a bug in block indentation.  If the first line was blank it throw an Exception.  It now finds the first text line.
   -- added the ability to add extensions.  see 'how to write an Emacs extension' section.  Also look at exampleTemacsExtension.py
      for a simple example as to how this works.
   -- fixed control-left control-right up so they do what Emacs does.  This has ramifications for delete previous word as well,
      since that command relies on the control-left command to do its work.
   -- added the ability to change the keystrokes via the reconfigureKeyStroke method.  This method is largely untested.
   -- last count: at around 204 keystrokes and commands( note some commands and keystrokes are the same,
      just different ways of accesing the functionality.
   -- enhanced incremental search so that if the search doesnt find anything it will start again either at the top or bottom, depending
      on which direction it is going.  This is a nice little enhancement.
   -- enhanced Tabing with alt-x, so that the user can cycle through the matches. Added Tracker class to accomplish this.
      This will speed up the use of the Alt-x commands and expose functionality that is hard for a user to remember by keystroke.
   -- added Control-x and regular keystroke commands to Alt-x commands.  Ive focused on the ones Ive found most usefull.  This might be
      the best way to access rectangle functionality and registers.
   -- Created a better organized Outline.  There are several organizing nodes now.  Its easier to find things when looking for them.
   -- Added killing append to system clipboard.  The clipboard gets set with every kill.  Control - y will return the fresh clipboard kill as well as Alt-y.  This will be very nice to have.
   -- Added ability to test standalone.  Just type: python temacs.py and a simple Editor will appear.
   -- New commands and keystrokes:
       Control-j ( insert newline and tab )
       added goto-char
       added set-fill-column ( Control-x f )
       added center-line  ( Alt- s )
       added center-region ( see node 'fill column and centering' to see what these do )
       ( these buffer ops have to be configured so the Emacs instance knows what is a 'buffer' in the environment,
       see 'buffer recognition and alterers' node )
       append-to-buffer
       prepend-to-buffer
       copy-to-buffer
       insert-buffer
       list-buffer ( aka Control-x Control-b )
       switch-to-buffer ( aka Control-x b )
       kill-buffer ( aka Control-x k )
       rename-buffer


0.51 EKR:  Minor stylistic changes.

0.55:
    added:
    Control-z or 'iconify-or-deiconfify-frame'
    Control-x Esc Esc - executes last Alt-x command( repeat-complex-command )
    Control-x Control-c shutdown code, as well as a replacement hook if configured to do so.
    re-search-forward, re-search-backward - simple Alt-x regular expression commands
    Control-Alt-s, Control-Alt-r - regular expression cousins of incremental search( which makes me think that I need to change isearch to python based searches instead of the Tcl way..
    diff - does a diff on 2 files and adds it as a buffer
    what-line
    keep-lines and flush-lines, two fun new text manipulation commands!(see help text )
    make-directory and remove-directory, two commands that remove and add directories.
    delete-file - removes a file
    search-forward search-backward, searchs backward and forward for a word, non-incrementally.  Accessed by Conrtrol-s Enter and Control-r
    word-search-forward and word-search-backward, incredible!  You search for a group of words ignoring punctuation.  This is mighty stuff, dont know if Ill use it, but I like what I see.
    replace-regex - like replace-string but uses a python regular expression for the match.
    query-replace-regex( Control-Alt-% ) -like query-replace but with a python regular expression
    Esc Esc :, Alt-:, eval-expression  - these evaluate a Python expression in the minibuffer and puts the value in the current buffer.  This I think is different than what Emacs does, but I think it makes the value more accessible if its in the current buffer.  Nice little calculator too.
    tabify, untabify - turns spaces to tabs and tabs into spaces( current does it on 4 spaces to one tab ).
    indent-relative - a very nice command that indents from the insert point until it matches the indentation of a word in the above line.
    changed:
    replace-string command now will operate on a selection if there is one.  Also the function now uses string functionality to replace the
    strings instead of using the Tk Text widget to do the job.
    dynamic expansion now will expand with the '-' character, which helps greatly in some cases.  Alot of work for a what will hopefully be a long term gain.  Also will now use quoted strings as actual completion targets, thank goodness.
    fixed:
    sort-lines will now clear its state after sorting the lines.
    Alt-!(shell-command, Alt-|(shell-command-on-region) --now temacs allows one to execute shell commands.  I dont see a shell being added to temacs, so thats one area where it will probably not stray.
    total 26 new commands added
    fixed up: sort-lines and its cousins, if nothing is selected the command is deactivated.
</t>
<t tx="mork.20041101124927">def modifyOnBodyKey( self, event ):
    '''stops Return and Tab from being processed if the Emacs instance has state.'''
    if event.char.isspace(): 
        Emacs = temacs.Emacs.Emacs_instances[ event.widget ]   
        if Emacs.mcStateManager.hasState():
           return None
    return orig_OnBodyKey( self, event )
</t>
<t tx="mork.20041101132349">@ 

.5 -- fixed problem with spurious whitespace being added in some of the paste commands when Return was entered.  This was
      because Leo is programmed to indent after Enter is pressed.  We decorate the OnBodyKey with usetemacs modifyOnBodyKey.
   -- made transitions to temacs.Emacs class
   -- Help text can now be searched.  Search is initiated by either typing Return in the Entry or pressing the go button.
   -- Set it up so when the Text widget has all of its text deleted via a call to delete '1.0', 'end', this calls
      the StopControlX method of the Emacs object.  This is equivilant of pressing Control-G.
   -- Added ability to load temacs.Emacs extensions
   -- Added ability to change default key bindings( in alpha stage ).
   -- Created example Emacs extension.
   -- Added ability for user to see each node in the outline as a buffer.  There are methods in temacs such as
      append-to-buffer, copy-to-buffer, etc... that needs a name and some supplied functionality to do its work.
      usetemacs does this for the Emacs instance.  Note: if a group of nodes have the same name, then only one will be viewable
      by the Emacs instance.  This might be enhanced in the future to include all headlines.
      I would not recommend 'list-buffers' if you have a large outline.  This will have to be enhanced in the future as well.
   -- Removed all references to Pmw in code( still exists in comments ).  Reports of some weirdness with the string.atoi and how
      it was behaving in Pmw.  This helps lower the bar of entry to this.  I have replaced the megawidgets with items like
      ScrolledText and a minibuffer composed of a Frame, a Frame in this Frame, and 2 labels.
   -- folded in changes from .4 that could be detected

.51
.52 EKR: Minor style changes.
.53 EKR: Use __name__ in .plugin_signon
.55
    --added a def that adds all the Leo Commands to the Emacs instance, in command addLeoCommands.  I no longer need to
    remember how to summon the find panel, its done via Alt-x 'find panel'.  This was a very good use of the extension mechanism
    that was put into place in .5.  I should note that there are a couple I left out like Recent Files, and End Edit Headline,
    since they didnt seem to functional( i.e. no good way to use them within the Alt-x mechanism).
    --changed the location of where text appears in the minibuffer, it now always starts from the left instead of the center.
    This is what Emacs does, and its less disorienting.
    --added a dialog to show up if there are multiple nodes with the same name.  This gives the user the ability to select a node
    in its numerical position in the graph, from 1 to N.  Im still surprised that this works as quick as it does, more power to the
    graph!
    --added Leo Commands to Temacs Help, good to see which Leo commands you can execute.
.56 EKR:
    - Removed 'start2' hook and haveseen dict.
    - Added init function.
.57 EKR:
    - Added global orig_Bindings,orig_OnBodyKey to init().
    - Removed writeNewDerivedFiles writeOldDerivedFiles and 'apply settings' commands.
    - Changed c.findPanel to c.showFindPanel.
    - Changed leoConfig.txt to leoSettings.leo in docstring.
</t>
<t tx="mork.20041101190309">def extendAltX( self, name, function ):
    '''A simple method that extends the functions Alt-X offers.'''
    
    nfunction = new.instancemethod( function, self, Emacs ) #making it an instance method allows the function to be passed 'self'.
    self.doAltX[ name ] = nfunction
    

</t>
<t tx="mork.20041101191351">def loadConfig():
    '''Loads Emacs extensions and new keystrokes to be added to Emacs instances'''
    pth = os.path.split(g.app.loadDir)   
    aini = pth[0]+r"/plugins/usetemacs.ini"
    if os.path.exists( aini ):
        
        cp = ConfigParser.ConfigParser()
        cp.read( aini )
        section = None
        for z in cp.sections():
            if z.strip() == 'extensions':
                section = z
                break
        
        if section:
            for z in cp.options( section ):
                extension = cp.get( section, z )
                try:
                    ex = __import__( extension )
                    extensions.append( ex )
                except Exception, x:
                    g.es( "Could not load %s because of %s" % ( extension, x ), color = 'red' )
                
        kstroke_sec = None
        for z in cp.sections():
            if z.strip() == 'newkeystrokes':
                kstroke_sec = z
                break
        if kstroke_sec:
            for z in cp.options( kstroke_sec ):
                new_keystrokes[ z.capitalize() ] = cp.get( kstroke_sec, z )




</t>
<t tx="mork.20041101202945">def addTemacsExtensions( Emacs ):
    '''Adds extensions to Emacs parameter.'''
    for z in extensions:
            try:
                if hasattr( z, 'getExtensions' ):
                    ex_meths = z.getExtensions()
                    for x in ex_meths.keys():
                        Emacs.extendAltX( x, ex_meths[ x ] )
                else:
                    g.es( 'Module %s does not have a getExtensions function' % z , color = 'red' )
            except Exception, x:
                g.es( 'Could not add extension because of %s' % x, color = 'red' )
</t>
<t tx="mork.20041101203748">@
Emacs instances offer the user the ability to add functionality
to itself.  This is accomplished through the Emacs extendAltX method.  Functions passed in should not be methods
but just plain functions.

An example:
def burp( self, event ):
    print 'burp %s' % self     #This will print info about the Emacs instance
    self.stopControlX( event ) #every extension should call this or the function will be called for each keystroke.
                               #To be more precise, it should be called when the function has completely cycled through.
ei.extendAltX( 'burp', burp ) #burp has been added as an Alt-x command and the burp function has become
                              #a method of the Emacs instance.  self, will now reflect this.

accessing it through the Alt-X interface will be done like so
Alt-x
burp ( Hit return , alternatively the user could type b and hit the tab button )

Each function/method will be called with two parameters:
    self -- which is the Emacs instance
    event -- which is an Tkinter Event instance.
    self gives the extension writer the ability to access the Emacs intances functionality
    event gives the user the ability to access the Text widget that the Emacs instance is bound to.
    the preferred way to do so is like this:
    tbuffer = event.widget</t>
<t tx="mork.20041101204659">@

to begin to understand how to write an Emacs extension see temacs.py section 'how to write an Emacs extension'.

usetemacs will look for a file called usetemacs.ini

It will open this file and look for a sections called [ extensions ]

every option under this section will act as an indicator to import a module.

For example:
[ extensions ]
1=anExtension

The module anExtension.py must be importable by usetemacs.

-----
usetemacs will load anExtension as a module.  For each Emacs object created it will
call the modules getExtensions() method which should return a dictionary containing:
    a. keys that are strings.  These are the names that will be added to the Alt-x command in Emacs.
    b. functions.  These should not be methods, as they become methods when added to Emacs.
    for example:
        module test.py:
        def power( self, event ):
            print 'power'
        def getExtensions():
            return { 'power' : power }
    upon loading by usetemacs, every Emacs instance will have 'power' added as an Alt-x command which will call
    the power function( method after adding ).  The extension write should not worry about the name of the function,
    they should only worry about the name that they want to access the function-method by.  It is possible to overwrite
    a default Alt-x method if the same name is used.
-----

To test an Emacs extensions try out the exampleTemacsExtension.py with this mechanism.

</t>
<t tx="mork.20041101205414">def watchDelete(  i, j = None, Emacs = None , orig_del = None , Text = None ):
    '''Watches for complete text deletion.  If it occurs, turns off all state in the Emacs instance.'''
    if j:
        if i == '1.0' and j == 'end':
            event = Tk.Event()
            event.widget = Text
            Emacs.keyboardQuit( event )
    return orig_del( i, j )</t>
<t tx="mork.20041101210722">def addTemacsAbbreviations( Emacs ):
    '''Adds abbreviatios and kbd macros to an Emacs instance'''
    pth = os.path.split( g.app.loadDir ) 
    aini = pth[ 0 ] + os.sep + 'plugins' + os.sep
    if os.path.exists( aini + r'usetemacs.kbd' ):
        f = file( aini +  r'usetemacs.kbd', 'r' )
        Emacs._loadMacros( f )
    if os.path.exists( aini + r'usetemacs.abv' ):
        f = file( aini + r'usetemacs.abv', 'r' )
        Emacs._readAbbrevs( f )
        

</t>
<t tx="mork.20041102081834">@ 

tbuffer - a Tkinter Text widget.  Would be called buffer, but this shadows a Python builin.  This is the widget carried
by the events in the Emacs instancs.  Can be accessed like so 'event.widget'
svar - a Tkinter StringVar widget.  This should hold what the minibuffer is showing currently.  Can
be acquired by 'self.getSvarLabel'.



</t>
<t tx="mork.20041102082023">def keyboardQuit( self, event ):
    '''This method cleans the Emacs instance of state and ceases current operations.'''
    return self.stopControlX( event )#This method will eventually contain the stopControlX code.
    
</t>
<t tx="mork.20041102082911">@ 

.5

- control-u seems kinda flaky.  Will enhance in the next iteration and make less flaky. :)
- digit-arguments seem pretty flaky as well.
--- These are no longer flaky.  A simple change to calling self.keyboardQuit, has eliminated the flakiness Ive seen. :)
    This was centered on using a command that wasnt a commadn like typing 99a, made it burp!  You can also see the commands
    as they are done in the Editor.  For example 'Control-u 99 a'  will type 'a' 99 times in the editor.  Or
    'Control-u 99 Control-_'  will undo the last 99 changes, thats if the Emacs instance has been configure with an undoer.</t>
<t tx="mork.20041102091309">@

'''An example of a temacs Extension.  To test example:
    1. Create usetemacs.ini file.
    2. Make an [ extensions ] section.
    3. put:
       1=exampleTemacsExtension
    When Leo starts,
    select a set of lines
    type Alt-x
    the format-selection-as-list and hit Enter( or type format and hit tab, the autocompletion will work ).
    After typing Enter you should see you selection indented and each line prefixed with an ascending number.'''


def formatSelectionAsList( self, event ):
    '''This function indents and prepends a number to a selection of text'''
    try: #We guard against there not being anything selected, which throws an Exception in this block.
        tbuffer = event.widget # call the Text instance tbuffer as in Emacs class.
        self.indentRegion( event ) # use the Emacs instances indentRegion method to do initial formatting.
        start = tbuffer.index( 'sel.first linestart' )
        start = tbuffer.search( '\w', start, regexp = True, stopindex = '%s lineend' % 'sel.last' )
        if not start:
            return self.keyboardQuit( event )
        end = tbuffer.index( 'sel.last' )
    except Exception, x:
        return self.keyboardQuit( event )
    r1, c1 = start.split( '.' )
    r1, c1 = int( r1 ), int( c1 )
    r2, c2 = end.split( '.' )
    r2 = int( r2 )
    amount = r2 - r1
    for z in xrange( amount + 1 ):
        tbuffer.insert( '%s.%s' % ( r1, c1 ), '%s. ' % ( z + 1 ))
        r1 = r1 + 1
    self.keyboardQuit( event ) # this turns off the state and sets things to normal
    return self._tailEnd( tbuffer ) # this calls the _tailEnd method, which when used with usetemacs will ensure that the text sticks.

def getExtensions():

    return { 'format-selection-as-list': formatSelectionAsList } #We return the one function in this module.</t>
<t tx="mork.20041102092057">@

#An example usetemacs .ini file
[ extensions ]
1=exampleTemacsExtension

[ newkeystrokes ]
#Alt-q=Alt-f</t>
<t tx="mork.20041102094131">@ 

usetemacs depends on temacs and Leo like so:
temacs.py  &lt;------ usetemacs.py -------&gt; Leo

temacs can function by itself.
Leo can function by itself.

usetemacs brings the two together.

Its the glue between the temacs module and Leo.  Leo doesn't need usetemacs to function, temacs doesn't need usetemacs to be used.
But if temacs.py and Leo are to work together usetemacs.py must be employed as a plugin for Leo.

It performs several helpful functions for temacs and Leo:

1. Protects against bad whitespace being added because of a Return key press.
2. Does a keyboardQuit if a new node is selected.
3. Configures temacs with temacs extensions.
4. Adds abbreviations and macros to Emacs instances
5. Configures Emac instances with functions that allow it to treat nodes as buffers.</t>
<t tx="mork.20041102094341">@ 

temacs.py prior to the .4 version needed to be installed so that it could be loaded anywhere from a python instance.
Now all the user needs to do is have temacs.py in the same plugins directory of the usetemacs plugin.  The plugin should
be able to load the module if done in this way.</t>
<t tx="mork.20041102094716">def reconfigureKeyStroke( self, tbuffer, keystroke , set_to ):
    
    '''This method allows the user to reconfigure what a keystroke does.
       This feature is alpha at best, and untested.'''

    if self.cbDict.has_key( set_to ):
        
        command = self.cbDict[ set_to ]
        self.cbDict[ keystroke ] = command
        evstring = '&lt;%s&gt;' % keystroke
        tbuffer.bind( evstring,  lambda event, meth = command: self.masterCommand( event, meth , evstring)  )</t>
<t tx="mork.20041102094928">def changeKeyStrokes( Emacs, tbuffer ):
    
    for z in new_keystrokes.keys():
        Emacs.reconfigureKeyStroke( tbuffer, z, new_keystrokes[ z ] )
</t>
<t tx="mork.20041102102111">@

usetemacs allows the user to change keystrokes in the Emacs instances via the ustemacs.ini file.

the section should be called [ newkeystrokes ].

To reconfigure a keystroke or add a keystroke, under the section add for example:
Alt-q=Alt-f



this will rebind Alt-q to what Alt-f does.

------
note this feature is largely untested and will most likely need work.

</t>
<t tx="mork.20041102103822">@

1. Continue adding the keystroke command names to the Alt-x mechanism.  Much of this has already been done.
2. Maybe make it possible for the user to add state to the MC_StateManager instance.  This could allow the extension writer
to create specific state based extension functions.  They may already be able to do this.
3. When python 2.4 is official, look at subprocess module and decide if it can be used to run exterior commands.  Pythons current
cross platform process commands, dont seem too cross platform at this point.  subprocess hopefully will fix this.
4. Continue migrating statefull commands to the MC_StateManager class.
5. Add ability for a user to learn the keystroke for a command.  The Help Text should be considered a definitive source of
information, but it may be quicker for the user to just ask.  This will be accomplished by adding the 'where-is' command or
'Control-h w'.  Not essential at this point, and will be done when we are entering a polish iteration.
6. Maybe add the ability for the user to evaluate Python expressions.  Vanilla Emacs has the ability to do something with
Lisp expressions, so it may make sense to do this with Python since Python is what this is built out of.
7. Maybe add Emacs variables for the commands.  Ive noticed that you can set Emac variables to change some of the behavior
in subtle ways.  A dictionary should be used to implement this, adding 1000 attributes to the Emacs class doesnt seem like a good idea.
8 Maybe add local abbreviations 'Control-x a i l'</t>
<t tx="mork.20041102131352">class Tracker:
    '''A class designed to allow the user to cycle through a list
       and to change the list as deemed appropiate.'''

    @others</t>
<t tx="mork.20041102131352.1">def __init__( self ):
    
    self.tablist = []
    self.prefix = None
    self.ng = self._next()</t>
<t tx="mork.20041102131352.2">def setTabList( self, prefix, tlist ):
    
    self.prefix = prefix
    self.tablist = tlist
    

</t>
<t tx="mork.20041102131352.3">def _next( self ):
    
    while 1:
        
        tlist = self.tablist
        if not tlist: yield ''
        for z in self.tablist:
            if tlist != self.tablist:
                break
            yield z
</t>
<t tx="mork.20041102132710">def next( self ):
    
    return self.ng.next()
</t>
<t tx="mork.20041102133805">def _findMatch( self, svar, fdict = None ):#, fdict = self.doAltX ):
    '''This method finds the first match it can find in a sorted list'''
    if not fdict:
        fdict = self.doAltX
    txt = svar.get()
    pmatches = filter( lambda a : a.startswith( txt ), fdict )
    pmatches.sort()
    if pmatches:
        mstring = reduce( self.findPre, pmatches )
        return mstring
    return txt
</t>
<t tx="mork.20041102151545">def viewRegister( self, event ):
    
    self.stopControlX( event )
    if event.keysym in string.letters:
        text = self.registers[ event.keysym.lower() ]
        svar, label = self.getSvarLabel( event )
        svar.set( text )</t>
<t tx="mork.20041102151939">def setEvent( self, event, l ):
    event.keysym = l
    return event
    
</t>
<t tx="mork.20041102160313">def clear( self ):

    self.tablist = []
    self.prefix = None
</t>
<t tx="mork.20041102161859">def viewLossage( self, event ):
    
    svar, label = self.getSvarLabel( event )
    loss = ''.join( Emacs.lossage )
    self.keyboardQuit( event )
    svar.set( loss )</t>
<t tx="mork.20041102183901"></t>
<t tx="mork.20041103085329">@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap
after an center-region command via Alt-x.


@c


@others

</t>
<t tx="mork.20041103085329.1">def centerLine( self, event ):
    '''Centers line within current fillColumn'''
    
    tbuffer = event.widget
    ind = tbuffer.index( 'insert linestart' )
    txt = tbuffer.get( 'insert linestart', 'insert lineend' )
    txt = txt.strip()
    if len( txt ) &gt;= self.fillColumn: return self._tailEnd( tbuffer )
    amount = ( self.fillColumn - len( txt ) ) / 2
    ws = ' ' * amount
    col, nind = ind.split( '.' )
    ind = tbuffer.search( '\w', 'insert linestart', regexp = True, stopindex = 'insert lineend' )
    if not ind: return 'break'
    tbuffer.delete( 'insert linestart', '%s' % ind )
    tbuffer.insert( 'insert linestart', ws )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041103085329.2">def setFillColumn( self, event ):
    
    if self.mcStateManager.getState( 'set-fill-column' ):
        
        if event.keysym == 'Return':
            svar, label = self.getSvarLabel( event )
            value = svar.get()
            if value.isdigit():
                self.fillColumn = int( value )
            return self.keyboardQuit( event )
        elif event.char.isdigit() or event.char == '\b':
            svar, label = self.getSvarLabel( event )
            self.setSvar( event, svar )
            return 'break'
        return 'break'
        
        
        
    else:
        self.mcStateManager.setState( 'set-fill-column', 1 )
        svar, label = self.getSvarLabel( event )
        svar.set( '' )
        label.configure( background = 'lightblue' )
        return 'break'
</t>
<t tx="mork.20041103095628">def centerRegion( self, event ):
    '''This method centers the current region within the fill column'''
    tbuffer = event.widget
    start = tbuffer.index( 'sel.first linestart' )
    sindex , x = start.split( '.' )
    sindex = int( sindex )
    end = tbuffer.index( 'sel.last linestart' )
    eindex , x = end.split( '.' )
    eindex = int( eindex )
    while sindex &lt;= eindex:
        txt = tbuffer.get( '%s.0 linestart' % sindex , '%s.0 lineend' % sindex )
        txt = txt.strip()
        if len( txt ) &gt;= self.fillColumn:
            sindex = sindex + 1
            continue
        amount = ( self.fillColumn - len( txt ) ) / 2
        ws = ' ' * amount
        ind = tbuffer.search( '\w', '%s.0' % sindex, regexp = True, stopindex = '%s.0 lineend' % sindex )
        if not ind: 
            sindex = sindex + 1
            continue
        tbuffer.delete( '%s.0' % sindex , '%s' % ind )
        tbuffer.insert( '%s.0' % sindex , ws )
        sindex = sindex + 1
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041103120919">def getClipboard( self, tbuffer ):
    
    ctxt = None
    try:
        ctxt = tbuffer.selection_get( selection='CLIPBOARD' )
        if ctxt != self.last_clipboard or not self.killbuffer:
            self.last_clipboard = ctxt
            if self.killbuffer and self.killbuffer[ 0 ] == ctxt:
                return None
            return ctxt
        else:
            return None
        
    except:
        return None
        
    return None</t>
<t tx="mork.20041103135515">def insertNewLineAndTab( self, event ):
    '''Insert a newline and tab'''
    tbuffer = event.widget
    self.insertNewLine( event )
    i = tbuffer.index( 'insert +1c' )
    tbuffer.insert( i, '\t' )
    tbuffer.mark_set( 'insert', '%s lineend' % i )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041103155347">@
an Emacs instance does not have knowledge of what is considered a buffer in the environment.
It must be configured by the user so that it can operate on the other buffers.  Otherwise
these methods will be useless.

@c


@others</t>
<t tx="mork.20041103155347.1">def setBufferListGetter( self, buffer, method ):
    #Sets a method that returns a buffer name and its text, and its insert position.
    self.bufferListGetters[ buffer ] = method
</t>
<t tx="mork.20041103155347.2">def setBufferSetter( self, buffer, method ):
    #Sets a method that takes a buffer name and the new contents.
    self.bufferSetters[ buffer ] = method</t>
<t tx="mork.20041103155347.3">def getBufferDict( self, event ):
    
    tbuffer = event.widget
    meth = self.bufferListGetters[ tbuffer ]
    return meth()</t>
<t tx="mork.20041103155347.4">def appendToBuffer( self, event, name ):

    tbuffer = event.widget
    try:
        txt = tbuffer.get( 'sel.first', 'sel.last' )
        bdata = self.bufferDict[ name ]
        bdata = '%s%s' % ( bdata, txt )
        self.setBufferData( event, name, bdata )
    except Exception, x:
        pass
    return self.keyboardQuit( event )</t>
<t tx="mork.20041103155347.5">def prependToBuffer( self, event, name ):
    
    tbuffer = event.widget
    try:
        txt = tbuffer.get( 'sel.first', 'sel.last' )
        bdata = self.bufferDict[ name ]
        bdata = '%s%s' % ( txt, bdata )
        self.setBufferData( event, name, bdata )
    except Exception, x:
        pass
    return self.keyboardQuit( event )</t>
<t tx="mork.20041103155347.6">def insertToBuffer( self, event, name ):

    tbuffer = event.widget
    bdata = self.bufferDict[ name ]
    tbuffer.insert( 'insert', bdata )
    self._tailEnd( tbuffer )
    return self.keyboardQuit( event )
</t>
<t tx="mork.20041103155347.7">def copyToBuffer( self, event, name ):
    
    tbuffer = event.widget
    try:
        txt = tbuffer.get( 'sel.first', 'sel.last' )
        self.setBufferData( event, name, txt )
    except Exception, x:
        pass
    return self.keyboardQuit( event )
    
</t>
<t tx="mork.20041103160433">tnodes = {}
positions =  {}
def setBufferInteractionMethods( c, emacs, buffer ):
    '''This function configures the Emacs instance so that
       it can see all the nodes as buffers for its buffer commands.'''
    def buildBufferList(): #This builds a buffer list from what is in the outline.  Worked surprisingly fast on LeoPy.
        if not tnodes.has_key( c ): #I was worried that speed factors would make it unusable.
            tnodes[ c ] = {}
        tdict = tnodes[ c ]
        pos = c.rootPosition()
        utni = pos.allNodes_iter()
        bufferdict = {}
        tdict.clear()
        positions.clear()
        for z in utni:
        
           t = z.v.t
           if positions.has_key( t.headString ):
            positions[ t.headString ].append( z.copy() )
           else:
            positions[ t.headString ] = [ z.copy() ]#not using a copy seems to have bad results.
           #positions[ t.headString ] = z
        
           bS = ''
           if t.bodyString: bS = t.bodyString
 
           
           bufferdict[ t.headString ] = bS
           tdict[ t.headString ] = t 
        
        return bufferdict
        
    def setBufferData( name, data ):
        
        data = unicode( data )
        tdict = tnodes[ c ]
        if tdict.has_key( name ):
            tdict[ name ].bodyString = data
            
    def gotoNode( name ):
        
        c.beginUpdate()
        if positions.has_key( name ):
            posis = positions[ name ]
            if len( posis ) &gt; 1:
                tl = Tk.Toplevel()
                #tl.geometry( '%sx%s+0+0' % ( ( ms[ 0 ]/3 ) *2 , ms[ 1 ]/2 ))
                tl.title( "Select node by numeric position" )
                fr = Tk.Frame( tl )
                fr.pack()
                header = Tk.Label( fr, text='select position' )
                header.pack()
                lbox = Tk.Listbox( fr, background='white', foreground='blue' )
                lbox.pack()
                for z in xrange( len( posis ) ):
                    lbox.insert( z, z + 1 )
                lbox.selection_set( 0 )
                def setPos( event ):
                    cpos = int( lbox.nearest( event.y ) )
                    tl.withdraw()
                    tl.destroy()
                    if cpos != None:
                        gotoPosition( c, posis[ cpos ] )
                lbox.bind( '&lt;Button-1&gt;', setPos )
                geometry = tl.geometry()
                geometry = geometry.split( '+' )
                geometry = geometry[ 0 ]
                width = tl.winfo_screenwidth()/3
                height = tl.winfo_screenheight()/3
                geometry= '+%s+%s' %( width,height )
                tl.geometry( geometry )
            else:
                pos = posis[ 0 ]
                gotoPosition( c, pos )
        else:
            pos2 = c.currentPosition()
            tnd = leoNodes.tnode( '', name )
            pos = pos2.insertAfter( tnd )
            gotoPosition( c, pos )
        #c.frame.tree.expandAllAncestors( pos )
        #c.selectPosition( pos )
        #c.endUpdate()
    
    def deleteNode( name ):
        
        c.beginUpdate()
        if positions.has_key( name ):
            pos = positions[ name ]
            cpos = c.currentPosition()
            pos.doDelete( cpos )
        c.endUpdate()
    
    def renameNode( name ):
    
        c.beginUpdate()
        pos = c.currentPosition()
        pos.setHeadString( name )
        c.endUpdate()

        
    emacs.setBufferListGetter( buffer, buildBufferList ) #This gives the Emacs instance the ability to get a buffer list
    emacs.setBufferSetter( buffer, setBufferData )# This gives the Emacs instance the ability to set a tnodes bodyString
    emacs.setBufferGoto( buffer, gotoNode )# This gives the Emacs instance the ability to jump to a node
    emacs.setBufferDelete( buffer, deleteNode )# This gives the Emacs instance the ability to delete a node
    emacs.setBufferRename( buffer, renameNode )# This gives the Emacs instance the ability to rename the current node

</t>
<t tx="mork.20041103161202">def chooseBuffer( self, event ):
    
    svar, label = self.getSvarLabel( event )

    state = self.mcStateManager.getState( 'chooseBuffer' )
    if state.startswith( 'start' ):
        state = state[ 5: ]
        self.mcStateManager.setState( 'chooseBuffer', state )
        svar.set( '' )
    if event.keysym == 'Tab':
        
        stext = svar.get().strip()
        if self.bufferTracker.prefix and stext.startswith( self.bufferTracker.prefix ):
            svar.set( self.bufferTracker.next() ) #get next in iteration
        else:
            prefix = svar.get()
            pmatches = []
            for z in self.bufferDict.keys():
                if z.startswith( prefix ):
                    pmatches.append( z )
            self.bufferTracker.setTabList( prefix, pmatches )
            svar.set( self.bufferTracker.next() ) #begin iteration on new lsit
        return 'break'        

        
    elif event.keysym == 'Return':
       
       bMode = self.mcStateManager.getState( 'chooseBuffer' )
       return self.bufferCommands[ bMode ]( event, svar.get() )
        
        
    else:
        self.setSvar( event, svar )
        return 'break'

</t>
<t tx="mork.20041103161202.1">def setInBufferMode( self, event, which ):
    
    self.keyboardQuit( event )
    tbuffer = event.widget
    self.mcStateManager.setState( 'chooseBuffer', 'start%s' % which )
    svar, label = self.getSvarLabel( event )
    label.configure( background = 'lightblue' )
    svar.set( 'Choose Buffer Name:' )
    self.bufferDict = self.getBufferDict( event )
    return 'break'</t>
<t tx="mork.20041103162147">def setBufferData( self, event, name, data ):
    
    tbuffer = event.widget
    meth = self.bufferSetters[ tbuffer ]
    meth( name, data )</t>
<t tx="mork.20041103190332">def listBuffers( self, event ):
    
    bdict  = self.getBufferDict( event )
    list = bdict.keys()
    list.sort()
    svar, label = self.getSvarLabel( event )
    data = '\n'.join( list )
    self.keyboardQuit( event )
    svar.set( data )
    return 'break'
    </t>
<t tx="mork.20041103191311">def setBufferGoto( self, tbuffer, method ):
    self.bufferGotos[ tbuffer ] = method </t>
<t tx="mork.20041103191311.1">def switchToBuffer( self, event, name ):
    
    method = self.bufferGotos[ event.widget ]
    self.keyboardQuit( event )
    method( name )
    return 'break'
</t>
<t tx="mork.20041104090224">def setBufferDelete( self, tbuffer, method ):
    
    self.bufferDeletes[ tbuffer ] = method
    

</t>
<t tx="mork.20041104090224.1">def killBuffer( self, event, name ):
    
    method = self.bufferDeletes[ event.widget ]
    self.keyboardQuit( event )
    method( name )
    return 'break'
    

</t>
<t tx="mork.20041104092058">def renameBuffer( self, event ):
    
    svar, label = self.getSvarLabel( event )
    if not self.mcStateManager.getState( 'renameBuffer' ):
        self.mcStateManager.setState( 'renameBuffer', True )
        svar.set( '' )
        label.configure( background = 'lightblue' )
        return 'break'
    if event.keysym == 'Return':
       
       nname = svar.get()
       self.keyboardQuit( event )
       self.renameBuffers[ event.widget ]( nname )
        
        
    else:
        self.setSvar( event, svar )
        return 'break'</t>
<t tx="mork.20041104092349">def setBufferRename( self, buffer, method ):
    
    self.renameBuffers[ buffer ] = method</t>
<t tx="mork.20041104094826">@others</t>
<t tx="mork.20041104094826.1">@others</t>
<t tx="mork.20041104095745">@
Alt-x is the mechanism by which the user should be able to access any command in the Emacs instance.
The first steps in developing temacs was focused on the keystrokes.  Though in reality the keystrokes
are just ways to access the commands.

To initiate a command type Alt-x
Start typing the command name
Press Tab.  If the command does not come up, continue pressing Tab.
If you placed the correct prefix in the minibuffer, eventually the command will appear.


This will help a user to quickly cycle through commands and select the one they want, even if they can somewhat remember what
the spelling is.</t>
<t tx="mork.20041104100514">@

Hard to say at this point.  usetemacs is essentially the glue between Leo and temacs.py.  Anytime
temacs needs some machinery from the surrounding environment, usetemacs.py is supposed to supply it.
temacs development drives this development.
</t>
<t tx="mork.20041104100856">@
In the plugins directory there should be a subdirectory called: temacs_ext.
usetemacs will add that directory to the import list.


This keeps temacs extensions separate from regular plugins.

usetemacs creates this directory for the user if it doesn't alread exist upon startup.

</t>
<t tx="mork.20041104102456">@others
</t>
<t tx="mork.20041104145603">def initialise():
    '''This fuction sets up the module'''
    def createBindings (self,frame): 
     
        if not labels.has_key( frame ):
            #group = Pmw.Group( frame.split2Pane2, tag_text = 'mini buffer' )
            group = Tk.Frame( frame.split2Pane2 , 
                              relief = 'ridge', 
                              borderwidth = 3 )
            f2 = Tk.Frame( group )
            f2.pack( side = 'top', fill = 'x' )
            gtitle = Tk.Label( f2, 
                               text = 'mini-buffer' , 
                               justify = 'left' , 
                               anchor = 'nw',
                               foreground = 'blue',
                               background = 'white' )
            #gtitle.pack( side = 'top', fill ='x' )
            #gtitle.place( x = 5, y = 10 )
            group.pack( side = 'bottom', fill = 'x', expand = 1 )
            #gtitle.place( x = 0, y = 0 , relwidth = 1.0, relheight = 1.0 )
            #gtitle.grid( columnspan = 5 )
            for z in frame.split2Pane2.children.values():
                group.pack_configure( before = z )
            label = Tk.Label( group , 
                              relief = 'groove',
                              justify = 'left',
                              anchor='w',
                               )
            label.pack( side = 'bottom', fill = 'both', expand = 1, padx = 2, pady = 2 )   
            gtitle.pack( side = 'left' ) #, fill ='x' )
            #label.place( x = 10, y = 10 )
            #label.grid( column =2, columnspan = 15, rowspan = 3 )
            labels[ frame ] = label  
        else:
            label = labels[ frame ]
            
        orig_Bindings( self, frame )
        Emacs = temacs.Emacs( frame.bodyCtrl, label, useGlobalKillbuffer = True, useGlobalRegisters = True )
        Emacs.setUndoer( frame.bodyCtrl, self.c.undoer.undo ) 
        Emacs.setTailEnd( frame.bodyCtrl, lambda buffer, frame = frame: utTailEnd( buffer, frame ) )
        Emacs.setShutdownHook( self.c.close )
        addTemacsExtensions( Emacs )
        addTemacsAbbreviations( Emacs )
        addLeoCommands( self.c, Emacs )
        changeKeyStrokes( Emacs, frame.bodyCtrl )
        setBufferInteractionMethods( self.c, Emacs, frame.bodyCtrl )
                
        orig_del = frame.bodyCtrl.delete
        def wD( i, j = None, Emacs = Emacs, orig_del = orig_del, Text = frame.bodyCtrl ):
                return watchDelete( i,j, Emacs, orig_del, Text )
        frame.bodyCtrl.delete = wD

    return createBindings</t>
<t tx="mork.20041120195951">def suspend( self, event ):
    
    widget = event.widget
    widget.winfo_toplevel().iconify()
</t>
<t tx="mork.20041120222336">def shutdown( self, event ):
    
    self.shuttingdown = True
    if self.shutdownhook:
        self.shutdownhook()
    else:
        sys.exit( 0 )</t>
<t tx="mork.20041120223251">@others</t>
<t tx="mork.20041120223251.1">def setShutdownHook( self, hook ):
        
    self.shutdownhook = hook</t>
<t tx="mork.20041121103034">@
For the re-search-backward and re-search-forward Alt-x commands

@c



@others</t>
<t tx="mork.20041121103034.1">def reStart( self, event, which='forward' ):
    self.keyboardQuit( event )
    tbuffer = event.widget
    self.mcStateManager.setState( 're_search', 'start%s' % which )
    svar, label = self.getSvarLabel( event )
    label.configure( background = 'lightblue' )
    svar.set( 'RE Search:' )
    return 'break'
</t>
<t tx="mork.20041121103034.2">def re_search( self, event ):
    svar, label = self.getSvarLabel( event )

    state = self.mcStateManager.getState( 're_search' )
    if state.startswith( 'start' ):
        state = state[ 5: ]
        self.mcStateManager.setState( 're_search', state )
        svar.set( '' )
       

        
    if event.keysym == 'Return':
       
        tbuffer = event.widget
        pattern = svar.get()
        cpattern = re.compile( pattern )
        end = None
        if state == 'forward':
            
            txt = tbuffer.get( 'insert', 'end' )
            match = cpattern.search( txt )
            end = match.end()
        
        else:

            txt = tbuffer.get( '1.0', 'insert' ) #initially the reverse words formula for Python Cookbook was going to be used.
            a = re.split( pattern, txt )         #that didnt quite work right.  This one apparently does.   
            if len( a ) &gt; 1:
                b = re.findall( pattern, txt )
                end = len( a[ -1 ] ) + len( b[ -1 ] )
        
        if end:
            
            wdict ={ 'forward': 'insert +%sc', 'backward': 'insert -%sc' }
                
            tbuffer.mark_set( 'insert', wdict[ state ] % end )                                
            self._tailEnd( tbuffer )
            tbuffer.see( 'insert' )
            
        return self.keyboardQuit( event )    
        
        
    else:
        self.setSvar( event, svar )
        return 'break'

</t>
<t tx="mork.20041121125455">def useRegex( self ):

    isearch = self.mcStateManager.getState( 'isearch' )
    risearch = False
    if isearch != 'normal':
        risearch=True
    return risearch</t>
<t tx="mork.20041121140620">@
the diff command, accessed by Alt-x diff.  Creates a buffer and puts the diff between 2 files into it.

@c


@others</t>
<t tx="mork.20041121140620.1">def diff( self, event ):
    
    try:
        f, name = self.getReadableTextFile()
        txt1 = f.read()
        f.close()
        
        f2, name2 = self.getReadableTextFile()
        txt2 = f2.read()
        f2.close()
    except:
        return self.keyboardQuit( event )
    
    
    self.switchToBuffer( event, "*diff* of ( %s , %s )" %( name, name2 ) )
    import difflib
    data = difflib.ndiff( txt1, txt2 )
    idata = []
    for z in data:
        idata.append( z )
    tbuffer = event.widget
    tbuffer.delete( '1.0', 'end' )
    tbuffer.insert( '1.0', ''.join( idata ) )
    self._tailEnd( tbuffer )
    return self.keyboardQuit( event )
</t>
<t tx="mork.20041121140620.2">def getReadableTextFile( self ):
    
    import tkFileDialog
    fname = tkFileDialog.askopenfilename()
    if fname == None: return None, None
    f = open( fname, 'rt' )
    return f, fname
</t>
<t tx="mork.20041121195816">def whatLine( self, event ):
    
    tbuffer = event.widget
    svar, label = self.getSvarLabel( event )
    i = tbuffer.index( 'insert' )
    i1, i2 = i.split( '.' )
    self.keyboardQuit( event )
    svar.set( "Line %s" % i1 )
</t>
<t tx="mork.20041121201041">@

flush-lines
Delete each line that contains a match for regexp, operating on the text after point. In Transient Mark mode, if the region is active, the command operates on the region instead.


keep-lines
Delete each line that does not contain a match for regexp, operating on the text after point. In Transient Mark mode, if the region is active, the command operates on the region instead.

@c

@others</t>
<t tx="mork.20041121201041.1">def alterLines( self, event, which ):
    
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    end = 'end'
    if tbuffer.tag_ranges( 'sel' ):
        i = tbuffer.index( 'sel.first' )
        end = tbuffer.index( 'sel.last' )
        
    txt = tbuffer.get( i, end )
    tlines = txt.splitlines( True )
    if which == 'flush':
        keeplines = list( tlines )
    else:
        keeplines = []
    svar, label = self.getSvarLabel( event )
    pattern = svar.get()
    try:
        regex = re.compile( pattern )
        for n , z in enumerate( tlines ):
            f = regex.findall( z )
            if which == 'flush' and f:
                keeplines[ n ] = None
            elif f:
                keeplines.append( z )
    except Exception,x:
        return
    
    if which == 'flush':
        keeplines = [ x for x in keeplines if x != None ]
    tbuffer.delete( i, end )
    tbuffer.insert( i, ''.join( keeplines ) )
    tbuffer.mark_set( 'insert', i )
    self._tailEnd( tbuffer )
        
    



</t>
<t tx="mork.20041121201112">def startLines( self , event, which = 'flush' ):

    self.keyboardQuit( event )
    tbuffer = event.widget
    self.mcStateManager.setState( 'alterlines', 'start%s' % which )
    svar, label = self.getSvarLabel( event )
    label.configure( background = 'lightblue' )
    return 'break'
    
</t>
<t tx="mork.20041121210221">def processLines( self, event ):
    svar, label = self.getSvarLabel( event )

    state = self.mcStateManager.getState( 'alterlines' )
    if state.startswith( 'start' ):
        state = state[ 5: ]
        self.mcStateManager.setState( 'alterlines', state )
        svar.set( '' )
       

        
    if event.keysym == 'Return':
       
        self.alterLines( event, state )
            
        return self.keyboardQuit( event )    
        
        
    else:
        self.setSvar( event, svar )
        return 'break'</t>
<t tx="mork.20041122110739">@others</t>
<t tx="mork.20041122110739.1">def makeDirectory( self, event ):
    
    svar,label = self.getSvarLabel( event )
    state = self.mcStateManager.getState( 'make_directory' )
    if not state:
        self.mcStateManager.setState( 'make_directory', True )
        self.setLabelBlue( label )
        directory = os.getcwd()
        svar.set( '%s%s' %( directory, os.sep ) )
        return 'break'
    
    if event.keysym == 'Return':
        
        ndirectory = svar.get()
        self.keyboardQuit( event )
        try:
            os.mkdir( ndirectory )
        except:
            svar.set( "Could not make %s%" % ndirectory  )
        return 'break'
    else:
        self.setSvar( event, svar )
        return 'break'</t>
<t tx="mork.20041122111431">def removeDirectory( self, event ):
    
    svar,label = self.getSvarLabel( event )
    state = self.mcStateManager.getState( 'remove_directory' )
    if not state:
        self.mcStateManager.setState( 'remove_directory', True )
        self.setLabelBlue( label )
        directory = os.getcwd()
        svar.set( '%s%s' %( directory, os.sep ) )
        return 'break'
    
    if event.keysym == 'Return':
        
        ndirectory = svar.get()
        self.keyboardQuit( event )
        try:
            os.rmdir( ndirectory )
        except:
            svar.set( "Could not remove %s%" % ndirectory  )
        return 'break'
    else:
        self.setSvar( event, svar )
        return 'break'</t>
<t tx="mork.20041122112210">def deleteFile( self, event ):

    svar,label = self.getSvarLabel( event )
    state = self.mcStateManager.getState( 'delete_file' )
    if not state:
        self.mcStateManager.setState( 'delete_file', True )
        self.setLabelBlue( label )
        directory = os.getcwd()
        svar.set( '%s%s' %( directory, os.sep ) )
        return 'break'
    
    if event.keysym == 'Return':
        
        dfile = svar.get()
        self.keyboardQuit( event )
        try:
            os.remove( dfile )
        except:
            svar.set( "Could not delete %s%" % dfile  )
        return 'break'
    else:
        self.setSvar( event, svar )
        return 'break'
</t>
<t tx="mork.20041122151944">@
originally when this project started it was not envisioned that there would be that many emacs like commands and stuff implemented.
But then things changed, it grew.  At one point there were too many functions for the module to be flexible and understandable anymore.

The first reaction in the development was to decompose the pure module approach to an object approach.  This has helped immensely in
making temacs more manageable.  But, an Emacs instance now has over 200+ methods in it.  If it continues to grow, there may be
the need to decompose the families of methods into their own objects.  This could have two benefits:
1. More intellectually managable.
2. Swapable functionality.  Though its possible to do so now with python, this could be made much easier by having all
calls to a certain family be made through the __call__ operator.  Then swaping could be simply done by changing the object
the call is made to.


We will see if this approach may be taken.  At this point I can say for certain that the original pure functional design was a mistake, but one that was correctable by using Leo and pychecker.  Without these 2 tools, I think it may have been better to start over from scratch.
</t>
<t tx="mork.20041122152311">@
Ive noticed a general strategy that works for adding commands that need state to develop.

1. Create a start method.  This sets the mcStateManager into a specific state
2. Create a process method.  This watches events as they happen in the state
3. Create endpoint methods. These perform the final steps in processing the stateful command.


This general strategy works well so far.  A whole family of methods can be created in this manner.  Steps 1 and 2
could be combined but at a cost of more complexity, so Id recommend keeping them separate.
</t>
<t tx="mork.20041122154604">@
Accessed by Control-s Enter or Control-r Enter.  Alt-x forward-search or backward-search, just looks for words...


@c


@others</t>
<t tx="mork.20041122154604.1">def nonincrSearch( self, event, stroke ):
    
    if event.keysym in ('Control_L', 'Control_R' ): return
    state = self.mcStateManager.getState( 'nonincr-search' )
    svar, label = self.getSvarLabel( event )
    if state.startswith( 'start' ):
        state = state[ 5: ]
        self.mcStateManager.setState( 'nonincr-search', state )
        svar.set( '' )
        
    if svar.get() == '' and stroke=='&lt;Control-w&gt;':
        return self.startWordSearch( event, state )
    
    if event.keysym == 'Return':
        
        tbuffer = event.widget
        i = tbuffer.index( 'insert' )
        word = svar.get()
        if state == 'for':
            s = tbuffer.search( word, i , stopindex = 'end' )
            if s:
                s = tbuffer.index( '%s +%sc' %( s, len( word ) ) )
        else:            
            s = tbuffer.search( word,i, stopindex = '1.0', backwards = True )
            
        if s:
            tbuffer.mark_set( 'insert', s )    
        self.keyboardQuit( event )
        return self._tailEnd( tbuffer )        
            
    else:
        self.setSvar( event, svar )
        return 'break'


</t>
<t tx="mork.20041122155708">def startNonIncrSearch( self, event, which ):
    
    self.keyboardQuit( event )
    tbuffer = event.widget
    self.mcStateManager.setState( 'nonincr-search', 'start%s' % which )
    svar, label = self.getSvarLabel( event )
    self.setLabelBlue( label )
    svar.set( 'Search:' )
    return 'break'
</t>
<t tx="mork.20041122171601">@

Control-s(r) Enter Control-w words Enter, pattern entered is treated as a regular expression.

for example in the buffer we see:
    cats......................dogs
if we are after this and we enter the backwards look, search for 'cats dogs' if will take us to the match.

@c

@others</t>
<t tx="mork.20041122171601.1">def startWordSearch( self, event, which ):

    self.keyboardQuit( event )
    tbuffer = event.widget
    self.mcStateManager.setState( 'word-search', 'start%s' % which )
    svar, label = self.getSvarLabel( event )
    self.setLabelBlue( label )
    if which == 'bak':
        txt = 'Backward'
    else:
        txt = 'Forward'
    svar.set( 'Word Search %s:' % txt ) 
    return 'break'
</t>
<t tx="mork.20041122171601.2">def wordSearch( self, event ):

    state = self.mcStateManager.getState( 'word-search' )
    svar, label = self.getSvarLabel( event )
    if state.startswith( 'start' ):
        state = state[ 5: ]
        self.mcStateManager.setState( 'word-search', state )
        svar.set( '' )
        
    
    if event.keysym == 'Return':
        
        tbuffer = event.widget
        i = tbuffer.index( 'insert' )
        words = svar.get().split()
        sep = '[%s%s]+' %( string.punctuation, string.whitespace )
        pattern = sep.join( words )
        cpattern = re.compile( pattern )
        if state == 'for':
            
            txt = tbuffer.get( 'insert', 'end' )
            match = cpattern.search( txt )
            if not match: return self.keyboardQuit( event )
            end = match.end()
            
        else:            
            txt = tbuffer.get( '1.0', 'insert' ) #initially the reverse words formula for Python Cookbook was going to be used.
            a = re.split( pattern, txt )         #that didnt quite work right.  This one apparently does.   
            if len( a ) &gt; 1:
                b = re.findall( pattern, txt )
                end = len( a[ -1 ] ) + len( b[ -1 ] )
            else:
                return self.keyboardQuit( event )
            
        wdict ={ 'for': 'insert +%sc', 'bak': 'insert -%sc' }
        
        tbuffer.mark_set( 'insert', wdict[ state ] % end )                                
        tbuffer.see( 'insert' )    
        self.keyboardQuit( event )
        return self._tailEnd( tbuffer )        
            
    else:
        self.setSvar( event, svar )
        return 'break'</t>
<t tx="mork.20041122190403">@
A tremendous variety of searching methods are available.

@c


@others</t>
<t tx="mork.20041122223754">def executeLastAltX( self, event ):
    
    if event.keysym == 'Return' and self.altx_history:
        last = self.altx_history[ 0 ]
        self.doAltX[ last ]( event )
        return 'break'
    else:
        return self.keyboardQuit( event )
</t>
<t tx="mork.20041122225107">def repeatComplexCommand( self, event ):

    self.keyboardQuit( event )
    if self.altx_history:
        svar, label = self.getSvarLabel( event )
        self.setLabelBlue( label )
        svar.set( "Redo: %s" % self.altx_history[ 0 ] )
        self.mcStateManager.setState( 'last-altx', True )
    return 'break'
</t>
<t tx="mork.20041123093234">@others</t>
<t tx="mork.20041123095123">def activateReplaceRegex( self ):
    '''This method turns regex replace on for replaceString'''
    self._useRegex = True
    return True
    

</t>
<t tx="mork.20041123095436">@
both commands use the replaceString method, differentiated by a state variable

@c


@others</t>
<t tx="mork.20041123095507">@others</t>
<t tx="mork.20041123113640">def startRegexReplace( self ):
    
    self.querytype = 'regex'
    return True
</t>
<t tx="mork.20041123150144">@
Using python regular expressions and the Text widget may seem difficult but in reality it is very easy.
A simple formula:
1. get the text you are interested in from the Text widget.
2. Do a python regex on it, get the start value from the match object: match.start()
3. This gives you the position in the text widget where the regex matched.  Change the 'insert' point
in the Text like so:

tbuffer.mark_set( 'insert', 'insert +%sc' % match.start() )


this will change the insert point to where the match started.  Since you can move forward in the Text widget
by the character amount, bridging python regexes and Text is a simple operation.
  Need to go after the match, just use
match.end() instead of match.start().

I puzzled over this for awhile, so this note is a reminder that it is easy.  See the implementation for query-replace-regex for
an example.  Doing this with just plain string can follow a similar pattern.

@c</t>
<t tx="mork.20041123150836">@

just a short note to anyone, including myself, that is working on temacs.  Currently all( well all the ones that we have registered interest in ) key events get
routed through:

def masterCommand( self, event, method , stroke):


to understand the flow of the Emacs class, you need to understand this method.  Everything goes through it, there are no sidecuts or anything.  This offers the implementor complete control over what happens, and for the stateful commands it is essential to
keep states from being corrupted.


dont mess with this method lightly.
</t>
<t tx="mork.20041123192555">@others</t>
<t tx="mork.20041123192555.1">def watchEscape( self, event ):
    
    svar, label = self.getSvarLabel( event )
    if not self.mcStateManager.hasState():
        self.mcStateManager.setState( 'escape' , 'start' )
        self.setLabelBlue( label )
        svar.set( 'Esc' )
        return 'break'
    if self.mcStateManager.whichState() == 'escape':
        
        state = self.mcStateManager.getState( 'escape' )
        hi1 = self.keysymhistory[ 0 ]
        hi2 = self.keysymhistory[ 1 ]
        if state == 'esc esc' and event.keysym == 'colon':
            return self.startEvaluate( event )
        elif state == 'evaluate':
            return self.escEvaluate( event )    
        elif hi1 == hi2 == 'Escape':
            self.mcStateManager.setState( 'escape', 'esc esc' )
            svar.set( 'Esc Esc -' )
            return 'break'
        elif event.keysym in ( 'Shift_L', 'Shift_R' ):
            return
        else:
            return self.keyboardQuit( event )
    


</t>
<t tx="mork.20041124094511">def whichState( self ):
    
    return self.state
</t>
<t tx="mork.20041124095452">def escEvaluate( self, event ):
    
    svar, label = self.getSvarLabel( event )
    if svar.get() == 'Eval:':
        svar.set( '' )
    
    if event.keysym =='Return':
    
        expression = svar.get()
        try:
            ok = False
            tbuffer = event.widget
            result = eval( expression, {}, {} )
            result = str( result )
            tbuffer.insert( 'insert', result )
            ok = True
        finally:
            self.keyboardQuit( event )
            if not ok:
                svar.set( 'Error: Invalid Expression' )
            return self._tailEnd( tbuffer )
        
        
    else:
        
        self.setSvar( event, svar )
        return 'break'
    
</t>
<t tx="mork.20041124102729">def startEvaluate( self, event ):
    
    svar, label = self.getSvarLabel( event )
    self.setLabelBlue( label )
    svar.set( 'Eval:' )
    self.mcStateManager.setState( 'escape', 'evaluate' )
    return 'break'
</t>
<t tx="mork.20041124123825">@
For the tabify and untabify Alt-x commands.  Turns tabs to spaces and spaces to tabs in the selection

@c


@others</t>
<t tx="mork.20041124123825.1">def tabify( self, event, which='tabify' ):
    
    tbuffer = event.widget
    if tbuffer.tag_ranges( 'sel' ):
        i = tbuffer.index( 'sel.first' )
        end = tbuffer.index( 'sel.last' )
        txt = tbuffer.get( i, end )
        if which == 'tabify':
            
            pattern = re.compile( ' {4,4}' )
            ntxt = pattern.sub( '\t', txt )

        else:
            
            pattern = re.compile( '\t' )
            ntxt = pattern.sub( '    ', txt )
        tbuffer.delete( i, end )
        tbuffer.insert( i , ntxt )
        self.keyboardQuit( event )
        return self._tailEnd( tbuffer )
    self.keyboardQuit( event )

</t>
<t tx="mork.20041124130434">def indent_relative( self, event ):
    
    tbuffer = event.widget
    i = tbuffer.index( 'insert' )
    l,c = i.split( '.' )
    c2 = int( c )
    l2 = int( l ) - 1
    if l2 &lt; 1: return self.keyboardQuit( event )
    txt = tbuffer.get( '%s.%s' % (l2, c2 ), '%s.0 lineend' % l2 )
    if len( txt ) &lt;= len( tbuffer.get( 'insert', 'insert lineend' ) ):
        tbuffer.insert(  'insert', '\t' )
    else:
        reg = re.compile( '(\s+)' )
        ntxt = reg.split( txt )
        replace_word = re.compile( '\w' )
        for z in ntxt:
            if z.isspace():
                tbuffer.insert( 'insert', z )
                break
            else:
                z = replace_word.subn( ' ', z )
                tbuffer.insert( 'insert', z[ 0 ] )
                tbuffer.update_idletasks()
        
        
    self.keyboardQuit( event )
    return self._tailEnd( tbuffer )
</t>
<t tx="mork.20041126091717">@

I believe in .7 the transition from one big Emacs object to an Emacs object composed of many method-family objects
will begin.  This may be as a big as a transition as the change from the flat module structure to the Emacs class based
structure.  The .6 cycle Ill reserve for improving the functionality and documentation.  The current command crop may be
froze in that cycle.</t>
<t tx="mork.20041204141826">def addLeoCommands( c, emacs ):
    
    global leocommandnames
    f = c.frame
    
    commands = {
    'new': c.new,
    'open': c.open,
    'openWith': c.openWith,
    'close': c.close,
    'save': c.save,
    'saveAs': c.saveAs,
    'saveTo': c.saveTo,
    'revert': c.revert,
    'readOutlineOnly': c.readOutlineOnly,
    'readAtFileNodes': c.readAtFileNodes,
    'importDerivedFile': c.importDerivedFile,
    #'writeNewDerivedFiles': c.writeNewDerivedFiles,
    #'writeOldDerivedFiles': c.writeOldDerivedFiles,
    'tangle': c.tangle,
    'tangle all': c.tangleAll,
    'tangle marked': c.tangleMarked,
    'untangle': c.untangle,
    'untangle all': c.untangleAll,
    'untangle marked': c.untangleMarked,
    'export headlines': c.exportHeadlines,
    'flatten outline': c.flattenOutline,
    'import AtRoot': c.importAtRoot,
    'import AtFile': c.importAtFile,
    'import CWEB Files': c.importCWEBFiles,
    'import Flattened Outline': c.importFlattenedOutline,
    'import Noweb Files': c.importNowebFiles,
    'outline to Noweb': c.outlineToNoweb,
    'outline to CWEB': c.outlineToCWEB,
    'remove sentinels': c.removeSentinels,
    'weave': c.weave,
    'delete': c.delete,
    'execute script': c.executeScript,
    'go to line number': c.goToLineNumber,
    'set font': c.fontPanel,
    'set colors': c.colorPanel,
    'show invisibles': c.viewAllCharacters,
    'preferences': c.preferences,
    'convert all blanks': c.convertAllBlanks,
    'convert all tabs': c.convertAllTabs,
    'convert blanks': c.convertBlanks,
    'convert tabs': c.convertTabs,
    'indent': c.indentBody,
    'unindent': c.dedentBody,
    'reformat paragraph': c.reformatParagraph,
    'insert time': c.insertBodyTime,
    'extract section': c.extractSection,
    'extract names': c.extractSectionNames,
    'extract': c.extract,
    'match bracket': c.findMatchingBracket,
    'find panel': c.showFindPanel, ## c.findPanel,
    'find next': c.findNext,
    'find previous': c.findPrevious,
    'replace': c.replace,
    'replace then find': c.replaceThenFind,
    'edit headline': c.editHeadline,
    'toggle angle brackets': c.toggleAngleBrackets,
    'cut node': c.cutOutline,
    'copy node': c.copyOutline,
    'paste node': c.pasteOutline,
    'paste retaining clone': c.pasteOutlineRetainingClones,
    'hoist': c.hoist,
    'de-hoist': c.dehoist,
    'insert node': c.insertHeadline,
    'clone node': c.clone,
    'delete node': c.deleteOutline,
    'sort children': c.sortChildren,
    'sort siblings': c.sortSiblings,
    'demote': c.demote,
    'promote': c.promote,
    'move right': c.moveOutlineRight,
    'move left': c.moveOutlineLeft,
    'move up': c.moveOutlineUp,
    'move down': c.moveOutlineDown,
    'unmark all': c.unmarkAll,
    'mark clones': c.markClones,
    'mark': c.markHeadline,
    'mark subheads': c.markSubheads,
    'mark changed items': c.markChangedHeadlines,
    'mark changed roots': c.markChangedRoots,
    'contract all': c.contractAllHeadlines,
    'contract node': c.contractNode,
    'contract parent': c.contractParent,
    'expand to level 1': c.expandLevel1,
    'expand to level 2': c.expandLevel2,
    'expand to level 3': c.expandLevel3,
    'expand to level 4': c.expandLevel4,
    'expand to level 5': c.expandLevel5,
    'expand to level 6': c.expandLevel6,
    'expand to level 7': c.expandLevel7,
    'expand to level 8': c.expandLevel8,
    'expand to level 9': c.expandLevel9,
    'expand prev level': c.expandPrevLevel,
    'expand next level': c.expandNextLevel,
    'expand all': c.expandAllHeadlines,
    'expand node': c.expandNode,
    'check outline': c.checkOutline,
    'dump outline': c.dumpOutline,
    'check python code': c.checkPythonCode,
    'check all python code': c.checkAllPythonCode,
    'pretty print python code': c.prettyPrintPythonCode,
    'pretty print all python code': c.prettyPrintAllPythonCode,
    'goto parent': c.goToParent,
    'goto next sibling': c.goToNextSibling,
    'goto previous sibling': c.goToPrevSibling,
    'goto next clone': c.goToNextClone,
    'goto next marked': c.goToNextMarkedHeadline,
    'goto next changed': c.goToNextDirtyHeadline,
    'goto first': c.goToFirstNode,
    'goto last': c.goToLastNode,
    "go to prev visible":c.selectVisBack,
    "go to next visible" : c.selectVisNext,
    "go to prev node" : c.selectThreadBack,
    "go to next node" : c.selectThreadNext,
    'about leo...': c.about,
    #'apply settings': c.applyConfig,
    'open LeoConfig.leo': c.leoConfig,
    'open LeoDocs.leo': c.leoDocumentation,
    'open online home': c.leoHome,
    'open online tutorial': c.leoTutorial,
    'open compare window': c.openCompareWindow,
    'open Python window': c.openPythonWindow,
    "equal sized panes": f.equalSizedPanes,
    "toggle active pane": f.toggleActivePane,
    "toggle split direction": f.toggleSplitDirection,
    "resize to screen": f.resizeToScreen,
    "cascade": f.cascade,
    "minimize all": f.minimizeAll,
    }
    
    for z in commands.keys():
        #z2 = 'leo-%s' % z -- no need to do this, Leos command names dont clash with temacs so far
        def coverdef( self, event, command=commands[ z ] ):
            command()
            emacs.keyboardQuit( event )
            
        emacs.extendAltX( z, coverdef )
    leocommandnames = commands.keys()
    
    






























































</t>
<t tx="mork.20041208120232">@others</t>
<t tx="mork.20041208120232.1">def startSubprocess( self, event, which = 0 ):
    
    svar, label = self.getSvarLabel( event )
    statecontents = { 'state':'start', 'payload': None }
    self.mcStateManager.setState( 'subprocess', statecontents )
    if which:
        tbuffer = event.widget
        svar.set( "Shell command on region:" )
        is1 = is2 = None
        try:
            is1 = tbuffer.index( 'sel.first' )
            is2 = tbuffer.index( 'sel.last' )
        finally:
            if is1:
                statecontents[ 'payload' ] = tbuffer.get( is1, is2 )
            else:
                return self.keyboardQuit( event )
    else:
        svar.set( "Alt - !:" )
    self.setLabelBlue( label )
    return 'break'    
</t>
<t tx="mork.20041208120232.2">def subprocesser( self, event ):
    
    state = self.mcStateManager.getState( 'subprocess' )
    svar, label = self.getSvarLabel( event )
    if state[ 'state' ] == 'start':
        state[ 'state' ] = 'watching'
        svar.set( "" )
    
    if event.keysym == "Return":
        #cmdline = svar.get().split()
        cmdline = svar.get()
        return self.executeSubprocess( event, cmdline, input=state[ 'payload' ] )
       
    else:
        self.setSvar(  event, svar )
        return 'break'
</t>
<t tx="mork.20041208121502">def executeSubprocess( self, event, command  ,input = None ):
    import subprocess
    try:
        try:
            out ,err = os.tmpnam(), os.tmpnam()
            ofile = open( out, 'wt+' ) 
            efile = open( err, 'wt+' )
            process = subprocess.Popen( command, bufsize=-1, 
                                        stdout = ofile.fileno(), 
                                        stderr= ofile.fileno(), 
                                        stdin=subprocess.PIPE,
                                        shell=True )
            if input:
                process.communicate( input )
            process.wait()   
            tbuffer = event.widget
            efile.seek( 0 )
            errinfo = efile.read()
            if errinfo:
                tbuffer.insert( 'insert', errinfo )
            ofile.seek( 0 )
            okout = ofile.read()
            if okout:
                tbuffer.insert( 'insert', okout )
        except Exception, x:
            tbuffer = event.widget
            tbuffer.insert( 'insert', x )
    finally:
        os.remove( out )
        os.remove( err )
    self.keyboardQuit( event )
    return self._tailEnd( tbuffer )



</t>
<t tx="mork.20041213112640">def gotoPosition( c, pos ):
    c.frame.tree.expandAllAncestors( pos )
    c.selectPosition( pos )
    c.endUpdate()
    
</t>
</tnodes>
</leo_file>
