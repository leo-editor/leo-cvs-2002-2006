<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2102" clone_windows="0"/>
<globals body_outline_ratio="0.56894679696">
	<global_window_position top="12" left="258" height="921" width="951"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="edream.110203113231"><vh>@file-thin pluginsNotes.txt</vh></v>
<v t="edream.110203113231.618"><vh>Plugins</vh>
<v t="edream.110203113231.667"><vh>Commands</vh>
<v t="edream.110203113231.668"><vh> Importing Cisco configuration files</vh>
<v t="edream.110203113231.669"><vh>@file-thin import_cisco_config.py</vh></v>
<v t="edream.110203113231.677"><vh> Example of an imported config</vh>
<v t="edream.110203113231.678"><vh>plain configuration</vh></v>
<v t="edream.110203113231.679"><vh>cisco config: C:/Davide/Leo/CVS Version/example_conf.txt</vh>
<v t="edream.110203113231.680"><vh>&lt;&lt;access-list&gt;&gt;</vh></v>
<v t="edream.110203113231.681"><vh>&lt;&lt;boot&gt;&gt;</vh></v>
<v t="edream.110203113231.682"><vh>&lt;&lt;controller&gt;&gt;</vh>
<v t="edream.110203113231.683"><vh>controller E1 5/0/0</vh></v>
<v t="edream.110203113231.684"><vh>controller E1 5/0/1</vh></v>
<v t="edream.110203113231.685"><vh>controller SONET 1/0/0</vh></v>
</v>
<v t="edream.110203113231.686"><vh>&lt;&lt;interface&gt;&gt;</vh>
<v t="edream.110203113231.687"><vh>interface Async1</vh></v>
<v t="edream.110203113231.688"><vh>interface Dialer0</vh></v>
<v t="edream.110203113231.689"><vh>interface FastEthernet0/0/0</vh></v>
<v t="edream.110203113231.690"><vh>interface FastEthernet0/0/1</vh></v>
<v t="edream.110203113231.691"><vh>interface FastEthernet0/0/1.1</vh></v>
<v t="edream.110203113231.692"><vh>interface FastEthernet0/0/1.2</vh></v>
<v t="edream.110203113231.693"><vh>interface FastEthernet0/0/1.3</vh></v>
<v t="edream.110203113231.694"><vh>interface FastEthernet0/0/1.5</vh></v>
<v t="edream.110203113231.695"><vh>interface FastEthernet0/0/1.50</vh></v>
<v t="edream.110203113231.696"><vh>interface Loopback0</vh></v>
<v t="edream.110203113231.697"><vh>interface POS4/1/0</vh></v>
<v t="edream.110203113231.698"><vh>interface Serial5/0/0:1</vh></v>
<v t="edream.110203113231.699"><vh>interface Serial5/0/0:2</vh></v>
<v t="edream.110203113231.700"><vh>interface Serial5/0/1:0</vh></v>
<v t="edream.110203113231.701"><vh>interface Serial5/1/0</vh></v>
<v t="edream.110203113231.702"><vh>interface Serial5/1/1</vh></v>
</v>
<v t="edream.110203113231.703"><vh>&lt;&lt;ip community-list&gt;&gt;</vh></v>
<v t="edream.110203113231.704"><vh>&lt;&lt;ip route&gt;&gt;</vh></v>
<v t="edream.110203113231.705"><vh>&lt;&lt;line&gt;&gt;</vh>
<v t="edream.110203113231.706"><vh>line aux 0</vh></v>
<v t="edream.110203113231.707"><vh>line vty 0 4</vh></v>
</v>
<v t="edream.110203113231.708"><vh>&lt;&lt;logging&gt;&gt;</vh></v>
<v t="edream.110203113231.709"><vh>&lt;&lt;ntp&gt;&gt;</vh></v>
<v t="edream.110203113231.710"><vh>&lt;&lt;route-map&gt;&gt;</vh>
<v t="edream.110203113231.711"><vh>route-map only permit 2</vh></v>
<v t="edream.110203113231.712"><vh>route-map only1 permit 10</vh></v>
<v t="edream.110203113231.713"><vh>route-map only3 permit 10</vh></v>
<v t="edream.110203113231.714"><vh>route-map tag_com permit 10</vh></v>
<v t="edream.110203113231.715"><vh>route-map tag_com permit 20</vh></v>
</v>
<v t="edream.110203113231.716"><vh>&lt;&lt;router&gt;&gt;</vh>
<v t="edream.110203113231.717"><vh>router bgp 65001</vh></v>
<v t="edream.110203113231.718"><vh>router ospf 1</vh></v>
</v>
<v t="edream.110203113231.719"><vh>&lt;&lt;service&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="edream.110203113231.720"><vh>@file-thin outline_export.py</vh></v>
<v t="edream.110203113231.722"><vh>mod_autosave</vh>
<v t="edream.110203113231.723" tnodeList="edream.110203113231.723"><vh>@file-nosent mod_autosave.ini</vh></v>
<v t="edream.110203113231.724"><vh>@file-thin mod_autosave.py</vh></v>
</v>
<v t="edream.110203113231.727"><vh>@file-thin mod_timestamp.py</vh></v>
</v>
<v t="edream.110203113231.729"><vh>Debugging</vh>
<v t="edream.110203113231.730"><vh>@file-thin dump_globals.py</vh></v>
<v t="edream.110203113231.732"><vh>@file-thin enable_gc.py</vh></v>
<v t="edream.110203113231.734"><vh>@file-thin quit_leo.py</vh></v>
<v t="edream.110203113231.735"><vh>@file-thin trace_gc.py</vh></v>
<v t="edream.110203113231.736"><vh>@file-thin trace_keys.py</vh></v>
<v t="edream.110203113231.738"><vh>@file-thin trace_tags.py</vh></v>
</v>
<v t="edream.110203113231.740"><vh>Directives</vh>
<v t="edream.110203113231.741"><vh>@file-thin add_directives.py</vh></v>
</v>
<v t="edream.110203113231.744"><vh>Drawing, graphics &amp; styled text</vh>
<v t="edream.110403140857"><vh>Wiki plugin 1.4 (color_markup)(requires add-directives plugin)</vh>
<v t="edream.110403140857.1"><vh>Plugin documentation</vh>
<v t="edream.110403140857.2"><vh>Installation</vh></v>
<v t="edream.110403140857.3"><vh>Use</vh>
<v t="edream.110403140857.4"><vh>Supported markups</vh></v>
<v t="edream.110403140857.5"><vh>Example</vh>
<v t="edream.110403140857.6"><vh>a subnode</vh></v>
</v>
</v>
<v t="edream.110403140857.7"><vh>Release notes</vh></v>
</v>
<v t="edream.110403140857.8" a="M"><vh>@file-thin color_markup.py</vh></v>
</v>
<v t="edream.110203113231.753"><vh>@file-thin image.py</vh></v>
<v t="edream.110203113231.758"><vh>@file-thin nav_buttons.py</vh></v>
<v t="ekr.20040108095351"><vh>@file-thin rowcol.py</vh></v>
<v t="ekr.20040107092135.2"><vh>@file-thin searchbox.py</vh></v>
<v t="ekr.20040108062655"><vh>@file-thin nodenavigator.py</vh></v>
<v t="EKR.20040517075915" tnodeList="EKR.20040517075915,EKR.20040517075915.1,EKR.20040517075915.2,EKR.20040517075915.3,EKR.20040517075915.4,EKR.20040517075915.5,EKR.20040517075915.6,EKR.20040517075915.7,EKR.20040517075915.8,EKR.20040517075915.9,EKR.20040517075915.10,EKR.20040517075915.11,EKR.20040517075915.12,EKR.20040517075915.13"><vh>@file-noref newButtons.py</vh>
<v t="EKR.20040517075915.1"><vh>Helper classes</vh>
<v t="EKR.20040517075915.2"><vh>class FlatOptionMenu</vh></v>
<v t="EKR.20040517075915.3"><vh>class Node</vh></v>
<v t="EKR.20040517075915.4"><vh>class NodeAdder</vh></v>
<v t="EKR.20040517075915.5"><vh>class Helper</vh></v>
</v>
<v t="EKR.20040517075915.6"><vh>Modifiable classes to add buttons</vh>
<v t="EKR.20040517075915.7"><vh>body text used by AddTestModule &amp; AddTestClass</vh></v>
<v t="EKR.20040517075915.8"><vh>class AddTestModule</vh></v>
<v t="EKR.20040517075915.9"><vh>class AddTestClass</vh></v>
<v t="EKR.20040517075915.10"><vh>class AddTestMethod</vh></v>
<v t="EKR.20040517075915.11"><vh>class AddClass</vh></v>
<v t="EKR.20040517075915.12"><vh>class AddClassMethod</vh></v>
</v>
<v t="EKR.20040517075915.13"><vh>main code</vh></v>
</v>
<v t="ekr.20040205071616"><vh>mnplugins.py</vh>
<v t="ekr.20040205071616.1"><vh>mnstamp</vh></v>
<v t="ekr.20040205071616.2"><vh>mnOKstamp</vh></v>
<v t="ekr.20040205071616.3"><vh>onStart</vh></v>
<v t="ekr.20040205071616.4"><vh>setHeadOK</vh></v>
<v t="ekr.20040205071616.5"><vh>insertBodystamp</vh></v>
<v t="ekr.20040205071616.6"><vh>is_subnodesOK</vh></v>
<v t="ekr.20040205071616.7"><vh>onRclick</vh></v>
<v t="ekr.20040205071616.8"><vh>insertOKcmd</vh></v>
<v t="ekr.20040205071616.9"><vh>insertUser</vh></v>
<v t="ekr.20040205071616.10"><vh>create_UserMenu</vh></v>
</v>
</v>
<v t="EKR.20040517075715"><vh>External editors &amp; Open With</vh>
<v t="EKR.20040517075715.1"><vh>@file-thin mod_tempfname.py</vh></v>
<v t="EKR.20040517075715.4"><vh>@file-thin open_with.py</vh></v>
<v t="EKR.20040517075715.10"><vh>@file-thin vim.py</vh></v>
<v t="EKR.20040517075715.12"><vh>@file-thin xemacs.py</vh></v>
<v t="EKR.20040517075715.13"><vh>Word export</vh>
<v t="EKR.20040517075715.14"><vh>@file-thin word_export.py</vh></v>
<v t="EKR.20040517075715.20" tnodeList="EKR.20040517075715.20"><vh>@file-nosent word_export.ini</vh></v>
</v>
</v>
<v t="EKR.20040517080049"><vh>Files</vh>
<v t="EKR.20040517080049.1"><vh>@file-thin empty_leo_file.py</vh></v>
<v t="EKR.20040517080049.4"><vh>@file-thin open_shell.py</vh></v>
</v>
<v t="EKR.20040517074107"><vh>Gui</vh>
<v t="edream.110203113231.233"><vh>wxPython plugin (alpha quality)</vh>
<v t="edream.110203113231.234"><vh> Diary</vh>
<v t="edream.111503110300"><vh>11/15/03  Leo becomes usuable (!)</vh></v>
<v t="edream.111403093253"><vh>11/13 &amp; 11/14</vh></v>
<v t="edream.110203113231.235"><vh>10/26 Code works with reorganized core</vh></v>
<v t="edream.110203113231.236"><vh>10/13/03: Added icons (Windows only)</vh></v>
<v t="edream.110203113231.237"><vh>10/12/03: Houston, we have ignition</vh></v>
<v t="edream.110203113231.238"><vh>10/11/03: converted code using c2py, then hand converted code</vh></v>
</v>
<v t="edream.111403093253.1"><vh>Projects</vh>
<v t="edream.110203113231.243"><vh>invoke c2py</vh></v>
<v t="edream.111503111146"><vh>Finished or mostly finished</vh>
<v t="edream.111303205442"><vh>(colorizing) (demo only)</vh>
<v t="edream.111303204025"><vh>Indices</vh>
<v t="edream.111303204025.1"><vh>adjustIndex</vh></v>
<v t="edream.111303204025.2"><vh>compareIndices</vh></v>
<v t="edream.111303204025.3"><vh>convertRowColumnToIndex</vh></v>
<v t="edream.111303204025.4"><vh>convertIndexToRowColumn</vh></v>
<v t="edream.111303204025.5"><vh>getImageIndex</vh></v>
<v t="edream.111403080609"><vh>maxWxIndex (internal use)</vh></v>
</v>
<v t="edream.111303204517"><vh>Color tags (hacks for styles)</vh>
<v t="edream.111403082513"><vh>tkColorToWxColor (internal use)</vh></v>
<v t="edream.111303205611"><vh>tag_add</vh></v>
<v t="edream.111303205611.1"><vh>tag_bind</vh></v>
<v t="edream.111303205611.2"><vh>tag_configure (hack for wxStyles)</vh></v>
<v t="edream.111303205611.3"><vh>tag_delete</vh></v>
<v t="edream.111303205611.4"><vh>tag_remove</vh></v>
</v>
</v>
</v>
<v t="edream.111503111350"><vh>Unfinished</vh>
<v t="edream.111303184347"><vh>(delete_range) doesn't work</vh>
<v t="edream.111303103141.3"><vh>delete_range</vh></v>
</v>
<v t="edream.111303100039"><vh>Gui-dependent commands (to do)</vh>
<v t="edream.111303100039.1"><vh>Edit Menu...</vh>
<v t="edream.111303101257"><vh>abortEditLabelCommand</vh></v>
<v t="edream.111303101257.1"><vh>endEditLabelCommand</vh></v>
<v t="edream.111303100039.6"><vh>insertHeadlineTime</vh></v>
</v>
<v t="edream.111303100039.7"><vh>Window Menu</vh>
<v t="edream.111303100039.8"><vh>cascade</vh></v>
<v t="edream.111303100039.9"><vh>equalSizedPanes</vh></v>
<v t="edream.111303100039.10"><vh>hideLogWindow</vh></v>
<v t="edream.111303100039.11"><vh>minimizeAll</vh></v>
<v t="edream.111303101709"><vh>toggleActivePane</vh></v>
<v t="edream.111303100039.12"><vh>toggleSplitDirection</vh></v>
</v>
<v t="edream.111703103908"><vh>Help Menu...</vh>
<v t="edream.111703103908.2"><vh>leoHelp</vh>
<v t="edream.111703103908.3"><vh>showProgressBar</vh>
<v t="edream.111703103908.4"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="edream.110203113231.242"><vh>Unused code</vh>
<v t="edream.110203113231.257"><vh>updateJoinedHeadlines</vh></v>
<v t="edream.111303202917.1"><vh>Syntax coloring REMOVED: now in base body class</vh></v>
</v>
<v t="edream.110203113231.302"><vh>@file-thin __wx_gui.py</vh></v>
</v>
</v>
<v t="EKR.20040517080202"><vh>Foreign languages</vh>
<v t="EKR.20040517080202.3"><vh>@file-thin french_fm.py</vh></v>
</v>
<v t="EKR.20040517080250"><vh>http plugin</vh>
<v t="EKR.20040517080250.1"><vh>@file-thin mod_http.py</vh></v>
<v t="EKR.20040517080250.49"><vh>@file-thin mod_http.ini</vh></v>
</v>
<v t="EKR.20040517080517"><vh>Key bindings</vh>
<v t="EKR.20040517080517.1"><vh>@file-thin arrows.py</vh></v>
</v>
<v t="EKR.20040517080555"><vh>Menus</vh>
<v t="EKR.20040517080555.1"><vh> Plugins menu</vh>
<v t="EKR.20040517080555.2"><vh>@file-thin plugins_menu.py</vh></v>
<v t="EKR.20040517080555.25"><vh>@file-thin pluginsTest.py</vh></v>
<v t="EKR.20040517080555.32"><vh>Notes re plugins menu</vh>
<v t="EKR.20040517080555.33"><vh> Changes made by E.K.Ream</vh></v>
<v t="EKR.20040517080555.34"><vh> Design</vh></v>
<v t="EKR.20040517080555.35"><vh> Initial suggestion from Paul Paterson</vh></v>
</v>
</v>
<v t="EKR.20040517080555.36"><vh>@file-thin scripts_menu.py</vh></v>
</v>
<v t="edream.110203113231.872"><vh>New kinds of nodes</vh>
<v t="edream.110203113231.873"><vh>@file-thin at_folder.py</vh></v>
<v t="edream.110203113231.876"><vh>@file-thin read_only_nodes.py</vh></v>
<v t="edream.111803100242"><vh>@file-thin rst.py</vh></v>
</v>
<v t="edream.110203113231.915"><vh>Overriding functions, methods &amp; classes</vh>
<v t="edream.110203113231.916"><vh>@file-thin __overrideClasses.py</vh></v>
<v t="edream.110203113231.919"><vh>@file-thin override_commands.py</vh></v>
<v t="edream.110203113231.921"><vh>@file-thin redefine_put.py</vh></v>
<v t="edream.110203113231.924"><vh>@file-thin redirect_to_log.py</vh></v>
<v t="edream.110203113231.925"><vh>@file-thin script_io_to_body.py</vh></v>
</v>
<v t="edream.110203113231.982"><vh>Plugin manager (demo)</vh>
<v t="edream.110203113231.983"><vh>Notes by Paul Paterson</vh></v>
<v t="edream.110203113231.984" tnodeList="edream.110203113231.984,edream.110203113231.985,edream.110203113231.986,edream.110203113231.987,edream.110203113231.988,edream.110203113231.989,edream.110203113231.990,edream.110203113231.991,edream.110203113231.992,edream.110203113231.993"><vh>@file-thin leopm_client.py</vh></v>
<v t="edream.110203113231.994" tnodeList="edream.110203113231.994,edream.110203113231.995,edream.110203113231.995,edream.110203113231.996,edream.110203113231.997,edream.110203113231.998,edream.110203113231.999,edream.110203113231.1000,edream.110203113231.1001"><vh>@file-thin leopm_server.py</vh></v>
</v>
<v t="edream.110203113231.930"><vh>Spell Checking</vh>
<v t="edream.110203113231.931"><vh>@file-asis mod_spelling.txt</vh></v>
<v t="edream.110203113231.932" tnodeList="edream.110203113231.932"><vh>@file-asis mod_spelling.ini</vh></v>
<v t="edream.110203113231.933"><vh>@file-thin mod_spelling.py</vh></v>
</v>
</v>
<v t="ekr.20040330120121"><vh>New or improved in 4.2</vh>
<v t="ekr.20040331071919"><vh>Leo to AsciiDoc</vh>
<v t="ekr.20040331071919.1"><vh>Leo 2 AsciiDoc Developers Guide</vh>
<v t="ekr.20040331071919.2"><vh>About this document</vh>
<v t="ekr.20040331071919.3"><vh>License</vh>
<v t="ekr.20040331071919.4"><vh>License document</vh></v>
</v>
</v>
<v t="ekr.20040331071919.5"><vh>Version, Requirements</vh></v>
<v t="ekr.20040331071919.6"><vh>The General Approach</vh>
<v t="ekr.20040331071919.7"><vh>Markup Added</vh></v>
</v>
<v t="ekr.20040331071919.8"><vh>&lt;&lt; The Code &gt;&gt;</vh>
<v t="ekr.20040331071919.9"><vh>&lt;&lt; Key Functions &gt;&gt;</vh></v>
<v t="ekr.20040331071919.10"><vh>&lt;&lt; Declarations and Utilities &gt;&gt;</vh>
<v t="ekr.20040331071919.11"><vh>&lt;&lt; The Code -- Declarations and Utilities &gt;&gt;</vh></v>
</v>
<v t="ekr.20040331071919.12"><vh>&lt;&lt; Write the outline tree as AsciiDoc file &gt;&gt;</vh>
<v t="ekr.20040331071919.13"><vh>&lt;&lt; Write a node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040331071919.14"><vh>Other programs</vh></v>
<v t="ekr.20040331071919.15"><vh>&lt;&lt;Appendix: AsciiDoc &gt;&gt;</vh>
<v t="ekr.20040331071919.16"><vh>&lt;&lt; Configuration file &gt;&gt;</vh></v>
<v t="ekr.20040331071919.17"><vh>&lt;&lt; Patches &gt;&gt;</vh></v>
</v>
<v t="ekr.20040331071919.18"><vh>&lt;&lt;Appendix: DocBook&gt;&gt;</vh>
<v t="ekr.20040331071919.19"><vh>&lt;&lt; Tool Chain &gt;&gt;</vh></v>
<v t="ekr.20040331071919.20"><vh>&lt;&lt; Make File &gt;&gt;</vh></v>
<v t="ekr.20040331071919.21"><vh>&lt;&lt; Style Sheets &gt;&gt;</vh>
<v t="ekr.20040331071919.22"><vh>&lt;&lt; General &gt;&gt;</vh></v>
<v t="ekr.20040331071919.23"><vh>&lt;&lt; Customize &gt;&gt;</vh></v>
<v t="ekr.20040331071919.24"><vh>&lt;&lt; HTML: One File &gt;&gt;</vh></v>
<v t="ekr.20040331071919.25"><vh>&lt;&lt; HTML: Individual Pages &gt;&gt;</vh></v>
<v t="ekr.20040331071919.26"><vh>&lt;&lt; HTML: base css style sheet &gt;&gt;</vh></v>
<v t="ekr.20040331071919.27"><vh>&lt;&lt; HTML: css style sheet &gt;&gt;</vh></v>
<v t="ekr.20040331071919.28"><vh>&lt;&lt; HTML: common &gt;&gt;</vh></v>
<v t="ekr.20040331071919.29"><vh>&lt;&lt; PDF &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040331071919.30"><vh>&lt;&lt;Appendix: XEmacs Text Editor&gt;&gt;</vh>
<v t="ekr.20040331071919.31"><vh>&lt;&lt; Open_With Plugin &gt;&gt;</vh></v>
<v t="ekr.20040331071919.32"><vh>&lt;&lt; Open_Tree Plugin &gt;&gt;</vh></v>
<v t="ekr.20040331071919.33"><vh>&lt;&lt; Filename modification &gt;&gt;</vh></v>
<v t="ekr.20040331071919.34"><vh>&lt;&lt; Kill Temporary Buffers &gt;&gt;</vh></v>
<v t="ekr.20040331071919.35"><vh>&lt;&lt; MMM-mode &gt;&gt;</vh></v>
<v t="ekr.20040331071919.36"><vh>&lt;&lt; Insert indexterm &gt;&gt;</vh></v>
<v t="ekr.20040331071919.37"><vh>&lt;&lt; Indent Leo comments &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040331071919.38"><vh>Leo 2 AsciiDoc Users Guide</vh>
<v t="ekr.20040331071919.2"><vh>About this document</vh>
<v t="ekr.20040331071919.3"><vh>License</vh>
<v t="ekr.20040331071919.4"><vh>License document</vh></v>
</v>
</v>
<v t="ekr.20040331071919.39"><vh>Installation</vh></v>
<v t="ekr.20040331071919.40"><vh>Operation</vh>
<v t="ekr.20040331071919.41"><vh>Directives</vh>
<v t="ekr.20040331071919.42"><vh>Configuration</vh></v>
</v>
<v t="ekr.20040331071919.43"><vh>Markup</vh>
<v t="ekr.20040331071919.44"><vh>Standard AsciiDoc Markup</vh>
<v t="ekr.20040331071919.45"><vh>Headings</vh></v>
<v t="ekr.20040331071919.46"><vh>Lists</vh></v>
<v t="ekr.20040331071919.47"><vh>URLs</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040331072607" a="M"><vh>@file-thin hoist.py</vh></v>
<v t="ekr.20040331151007"><vh>@file-thin niceNosent.py</vh></v>
<v t="ekr.20040331153923"><vh>@file-thin scheduler.py</vh></v>
<v t="ekr.20040422072343"><vh>@file-thin rClick.py</vh></v>
<v t="EKR.20040422094618"><vh>@file-thin startfile.py</vh></v>
<v t="ekr.20040408161258"><vh>rst2 plugin</vh>
<v t="ekr.20040408192158"><vh>Documentation for the rST plugin using rst</vh>
<v t="ekr.20040408192158.1"><vh>@rst ../doc/rstplugin.html</vh>
<v t="ekr.20040408192158.2"><vh>Overview</vh>
<v t="ekr.20040408192158.3"><vh>@rst</vh></v>
</v>
<v t="ekr.20040408192158.4"><vh>Formatting</vh>
<v t="ekr.20040408192158.5"><vh>@rst</vh></v>
</v>
<v t="ekr.20040409051841"><vh>Embedding documentation in @file trees</vh>
<v t="ekr.20040409051841.1"><vh>@rst</vh></v>
</v>
<v t="ekr.20040408192158.6"><vh>The code-block directive</vh>
<v t="ekr.20040408192158.7"><vh>@rst</vh></v>
</v>
<v t="ekr.20040408192158.8"><vh>Cascading style sheets</vh>
<v t="ekr.20040408192158.9"><vh>@rst</vh></v>
</v>
</v>
</v>
<v t="ekr.20040331071319"><vh>@file-thin rst2.py</vh></v>
</v>
<v t="ekr.20040419105219"><vh>@file-thin lineNumbers.py</vh></v>
<v t="ekr.20040201060959"><vh>@file-thin status_line.py</vh></v>
</v>
<v t="EKR.20040517090508" a="E"><vh>Enable plugins by changing pluginsManager.txt</vh>
<v t="edream.120603093808"><vh>@file-thin pluginsManager.txt</vh></v>
</v>
<v t="EKR.20040612183736"><vh>Unfinished</vh>
<v t="EKR.20040608080921.1"><vh>@thin fastgotonode.py</vh></v>
<v t="EKR.20040609091913"><vh>Plugin generalizing marks (mulder)</vh>
<v t="EKR.20040609091913.1"><vh>@url http://home.pacbell.net/bwmulder/python/Leo/mod_label.leo</vh></v>
<v t="EKR.20040609091913.2"><vh>Crash</vh></v>
</v>
<v t="EKR.20040609213754" tnodeList="EKR.20040609213754,EKR.20040609213754.1"><vh>@file Configurator.py</vh>
<v t="EKR.20040609213754.1"><vh>&lt;&lt; create the top frame tl and its contents &gt;&gt;</vh></v>
</v>
<v t="EKR.20040611044600"><vh>Mulder undo</vh>
<v t="bwmulder.20040601212737"><vh>basic_undo.py</vh>
<v t="bwmulder.20040601212737.1"><vh>class passthrough</vh>
<v t="bwmulder.20040601212737.2"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.3"><vh>__set__</vh></v>
<v t="bwmulder.20040601212737.4"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040601212737.5"><vh>class scalar_monitor</vh>
<v t="bwmulder.20040601212737.6"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.7"><vh>__set__</vh></v>
<v t="bwmulder.20040601212737.8"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040601212737.9"><vh>class list_monitor</vh>
<v t="bwmulder.20040605231305"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.10"><vh>set_monitor_object</vh></v>
<v t="bwmulder.20040601212737.11"><vh>__setitem__</vh></v>
<v t="bwmulder.20040601212737.12"><vh>__delitem__</vh></v>
<v t="bwmulder.20040601212737.13"><vh>append</vh></v>
<v t="bwmulder.20040602152548"><vh>pop</vh></v>
</v>
<v t="bwmulder.20040601212737.14"><vh>class list_monitor_in_instance</vh>
<v t="bwmulder.20040601212737.15"><vh>__init__</vh></v>
<v t="bwmulder.20040601212737.16"><vh>__set__</vh></v>
<v t="bwmulder.20040601212737.17"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040602153618"><vh>class dict_monitor</vh>
<v t="bwmulder.20040605231401"><vh>__init__</vh></v>
<v t="bwmulder.20040602153642"><vh>set_monitor_object</vh></v>
<v t="bwmulder.20040602153723"><vh>__setitem__</vh></v>
<v t="bwmulder.20040602153835"><vh>__delitem__</vh></v>
</v>
<v t="bwmulder.20040602154259"><vh>class  dict_monitor_in_instance</vh>
<v t="bwmulder.20040602154259.1"><vh>__init__</vh></v>
<v t="bwmulder.20040602154259.2"><vh>__set__</vh></v>
<v t="bwmulder.20040602154259.3"><vh>__get__</vh></v>
</v>
<v t="bwmulder.20040601212737.18"><vh>class monitor</vh>
<v t="bwmulder.20040601212737.19"><vh>__init__</vh></v>
<v t="bwmulder.20040601214251"><vh>scalars</vh>
<v t="bwmulder.20040601212737.20"><vh>monitor_scalar</vh></v>
<v t="bwmulder.20040601212737.24"><vh>scalar_set</vh></v>
<v t="bwmulder.20040601212737.25"><vh>scalar_modify</vh></v>
</v>
<v t="bwmulder.20040601215339"><vh>lists</vh>
<v t="bwmulder.20040601212737.21"><vh>monitor_list_attribute_in_class</vh></v>
<v t="bwmulder.20040601212737.26"><vh>list_create</vh></v>
<v t="bwmulder.20040601212737.27"><vh>list_set</vh></v>
<v t="bwmulder.20040601212737.28"><vh>list_del</vh></v>
<v t="bwmulder.20040601212737.29"><vh>list_append</vh></v>
</v>
<v t="bwmulder.20040602165344"><vh>dicts</vh>
<v t="bwmulder.20040602165402"><vh>monitor_dict_attribute_in_class</vh></v>
<v t="bwmulder.20040602165506"><vh>dict_create</vh></v>
<v t="bwmulder.20040602165513"><vh>dict_set</vh></v>
<v t="bwmulder.20040602165553"><vh>dict_del</vh></v>
</v>
<v t="bwmulder.20040601215339.1"><vh>switching on and off</vh>
<v t="bwmulder.20040601212737.22"><vh>enable</vh></v>
<v t="bwmulder.20040602164627"><vh>enable_put_in_removed_functions</vh></v>
<v t="bwmulder.20040602154259.4"><vh>enable_category</vh></v>
<v t="bwmulder.20040602161525"><vh>disable_category</vh></v>
<v t="bwmulder.20040601212737.23"><vh>disable</vh></v>
<v t="bwmulder.20040603081718"><vh>remove_overrides_in_list_and_dict_monitor</vh></v>
</v>
</v>
<v t="bwmulder.20040601222230"><vh>class basic_undomechanism</vh>
<v t="bwmulder.20040601222230.1"><vh>__init__</vh></v>
<v t="bwmulder.20040602171606"><vh>reset</vh></v>
<v t="bwmulder.20040601222230.2"><vh>scalars</vh>
<v t="bwmulder.20040601222230.3"><vh>scalar_set</vh></v>
<v t="bwmulder.20040601222230.4"><vh>scalar_set_undo</vh></v>
<v t="bwmulder.20040601222230.5"><vh>scalar_set_redo</vh></v>
<v t="bwmulder.20040601222230.6"><vh>scalar_modify</vh></v>
<v t="bwmulder.20040601222431"><vh>scalar_modify_undo</vh></v>
</v>
<v t="bwmulder.20040602075341"><vh>lists</vh>
<v t="bwmulder.20040602084701.1"><vh>creation</vh>
<v t="bwmulder.20040602175523"><vh>list_assignment_replace</vh></v>
<v t="bwmulder.20040602175523.1"><vh>list_assignment_replace_undo</vh></v>
<v t="bwmulder.20040602175740"><vh>list_assignment_replace_redo</vh></v>
<v t="bwmulder.20040602183806"><vh>list_assignment_new</vh></v>
<v t="bwmulder.20040602183814"><vh>list_assignment_new_undo</vh></v>
<v t="bwmulder.20040602183911"><vh>list_assignment_new_redo</vh></v>
<v t="bwmulder.20040602075341.1"><vh>list_create</vh></v>
<v t="bwmulder.20040602084701.2"><vh>list_create_undo</vh></v>
<v t="bwmulder.20040602084701.3"><vh>list_create_redo</vh></v>
</v>
<v t="bwmulder.20040602084701.4"><vh>setting</vh>
<v t="bwmulder.20040602085955"><vh>list_set</vh></v>
<v t="bwmulder.20040602085955.1"><vh>list_set_undo</vh></v>
</v>
<v t="bwmulder.20040602085955.2"><vh>deletion</vh>
<v t="bwmulder.20040602085955.3"><vh>list_del</vh></v>
<v t="bwmulder.20040602085955.4"><vh>list_del_undo</vh></v>
<v t="bwmulder.20040602085955.5"><vh>list_del_redo</vh></v>
</v>
<v t="bwmulder.20040602151709"><vh>append</vh>
<v t="bwmulder.20040602152051"><vh>list_append</vh></v>
<v t="bwmulder.20040602152051.1"><vh>list_append_undo</vh></v>
<v t="bwmulder.20040602152051.2"><vh>list_append_redo</vh></v>
</v>
<v t="bwmulder.20040602152548.1"><vh>pop</vh>
<v t="bwmulder.20040602152548.2"><vh>list_pop</vh></v>
</v>
</v>
<v t="bwmulder.20040602171032"><vh>dictionaries</vh>
<v t="bwmulder.20040602171032.1"><vh>creation</vh>
<v t="bwmulder.20040602175801"><vh>dictionary creation</vh></v>
<v t="bwmulder.20040602171032.2"><vh>dict_create</vh></v>
<v t="bwmulder.20040602171032.3"><vh>dict_create_undo</vh></v>
<v t="bwmulder.20040602171032.4"><vh>dict_create_redo</vh></v>
</v>
<v t="bwmulder.20040602171032.5"><vh>setting</vh>
<v t="bwmulder.20040602171032.6"><vh>dict_set</vh></v>
<v t="bwmulder.20040602171032.7"><vh>dict_set_undo</vh></v>
</v>
<v t="bwmulder.20040602171032.8"><vh>deletion</vh>
<v t="bwmulder.20040602171032.9"><vh>dict_del</vh></v>
<v t="bwmulder.20040602171032.10"><vh>dict_del_undo</vh></v>
<v t="bwmulder.20040602171032.11"><vh>dict_del_redo</vh></v>
</v>
</v>
<v t="bwmulder.20040601224447"><vh>the undo machinery</vh>
<v t="bwmulder.20040603211921"><vh>queries</vh>
<v t="bwmulder.20040601224447.5"><vh>canUndo</vh></v>
<v t="bwmulder.20040601224447.6"><vh>canRedo</vh></v>
<v t="bwmulder.20040603212552"><vh>commands</vh></v>
<v t="bwmulder.20040603212612"><vh>commands_to_undo</vh></v>
<v t="bwmulder.20040603212713"><vh>commands_to_redo</vh></v>
<v t="bwmulder.20040604165011"><vh>steps_stored</vh></v>
<v t="bwmulder.20040605220919"><vh>print_commands</vh></v>
</v>
<v t="bwmulder.20040601224447.2"><vh>mark</vh></v>
<v t="bwmulder.20040601224447.3"><vh>undo</vh></v>
<v t="bwmulder.20040601224447.4"><vh>redo</vh></v>
<v t="bwmulder.20040603212934"><vh>rollback</vh></v>
<v t="bwmulder.20040601222649"><vh>run_commands</vh></v>
</v>
</v>
</v>
<v t="bwmulder.20040602221559"><vh>basic_undo_test.py</vh>
<v t="bwmulder.20040602232337"><vh>test_variables</vh></v>
<v t="bwmulder.20040602223236"><vh>imports</vh></v>
<v t="bwmulder.20040602223236.1"><vh>class tracer</vh>
<v t="bwmulder.20040602223236.2"><vh>__getattr__</vh></v>
<v t="bwmulder.20040602223906"><vh>catchall</vh></v>
</v>
<v t="bwmulder.20040602224231"><vh>class delegator</vh>
<v t="bwmulder.20040602224413"><vh>__init__</vh></v>
<v t="bwmulder.20040602224332"><vh>__getattr__</vh></v>
<v t="bwmulder.20040602231914"><vh>catchall</vh></v>
<v t="bwmulder.20040602231934"><vh>enable_category</vh></v>
</v>
<v t="bwmulder.20040602225640"><vh>class basic_scalar_test</vh>
<v t="bwmulder.20040602230124"><vh>test_scalar_basic</vh></v>
<v t="bwmulder.20040604184443"><vh>test_linked_list</vh></v>
</v>
<v t="bwmulder.20040605104941"><vh>class basic_list_test</vh>
<v t="bwmulder.20040605105746"><vh>test_lists_basic</vh></v>
<v t="bwmulder.20040605174728"><vh>test_lists_replace</vh></v>
</v>
<v t="bwmulder.20040605180204"><vh>class basic_dict_test</vh>
<v t="bwmulder.20040605180225"><vh>test_dicts_basic</vh></v>
<v t="bwmulder.20040605180245"><vh>test_dicts_replace</vh></v>
</v>
<v t="bwmulder.20040602230426"><vh>test_main</vh></v>
</v>
</v>
<v t="mark.20040522114528.1"><vh>@thin xemacs_a.py</vh></v>
<v t="EKR.20040609091717"><vh>dynabutton</vh>
<v t="EKR.20040609091717.1" a="E"><vh>Dynabutton docs, etc</vh>
<v t="EKR.20040609091717.2"><vh>Description</vh></v>
<v t="EKR.20040609091717.3"><vh>Description 2</vh></v>
<v t="EKR.20040609091717.4"><vh>@url http://rclick.netfirms.com/rCpython.htm</vh></v>
<v t="EKR.20040609091717.5"><vh>Install script</vh>
<v t="EKR.20040609091717.6"><vh>dosomething</vh></v>
<v t="EKR.20040609091717.7"><vh>dynaclick</vh></v>
<v t="EKR.20040609091717.8"><vh>deldyna</vh></v>
</v>
</v>
<v t="EKR.20040608165334"><vh>dyna0.032</vh>
<v t="EKR.20040612184408"><vh>Notes</vh></v>
<v t="EKR.20040608165334.1"><vh>useage</vh>
<v t="EKR.20040608165334.2"><vh>plugin or other</vh></v>
<v t="EKR.20040608165334.3"><vh>older comments</vh></v>
<v t="EKR.20040608165334.4"><vh>comments</vh></v>
<v t="EKR.20040608165334.5"><vh>Newcomments</vh></v>
<v t="EKR.20040608165334.6"><vh>u04523p01</vh></v>
</v>
<v t="EKR.20040608165334.7"><vh>you need</vh>
<v t="EKR.20040608165334.8"><vh>@url http://www.logilab.org/projects/pylint</vh></v>
<v t="EKR.20040608165334.9"><vh>@url http://www.logilab.org/projects/common</vh></v>
<v t="EKR.20040608165334.10"><vh>@url http://pychecker.sourceforge.net/</vh></v>
<v t="EKR.20040608165334.11"><vh>rc (@ignored)</vh>
<v t="EKR.20040608165334.12" tnodeList="EKR.20040608165334.12"><vh>@file-nosent .pycheckrc</vh></v>
<v t="EKR.20040608165334.13" tnodeList="EKR.20040608165334.13"><vh>@file-nosent .pdbrc </vh></v>
<v t="EKR.20040608165334.14" tnodeList="EKR.20040608165334.14"><vh>@file-nosent .pythonrc.py </vh></v>
<v t="EKR.20040608165334.15"><vh>@file-nosent .pylintrc</vh></v>
</v>
</v>
<v t="EKR.20040608165334.84"><vh>Dynaclick Script</vh>
<v t="EKR.20040612185017.1"><vh>&lt;&lt; about dynaclick &gt;&gt;</vh></v>
<v t="EKR.20040608165334.85"><vh>macros</vh>
<v t="EKR.20040608165334.22"><vh>geturls</vh></v>
<v t="EKR.20040608165334.86"><vh>call_dynaplay</vh></v>
<v t="EKR.20040608165334.24"><vh>+dynaHexdump</vh></v>
<v t="EKR.20040608165334.20"><vh>c2py</vh>
<v t="EKR.20040612191121"><vh>&lt;&lt; about dynaM_c2py &gt;&gt;</vh></v>
</v>
<v t="EKR.20040608165334.28"><vh>linenumber</vh></v>
<v t="EKR.20040608165334.83"><vh>call_fixbody</vh></v>
<v t="EKR.20040608165334.34"><vh>dyna_regexTk</vh></v>
<v t="EKR.20040608165334.87"><vh>+sortnumb</vh></v>
<v t="EKR.20040608165334.88"><vh>+rsortnumb</vh></v>
<v t="EKR.20040608165334.21"><vh>backslash</vh></v>
<v t="EKR.20040608165334.70"><vh>+call_evaluator</vh></v>
<v t="EKR.20040608165334.29"><vh>makatemp</vh></v>
<v t="EKR.20040608165334.30"><vh>pycheck2</vh></v>
<v t="EKR.20040608165334.31"><vh>tim_one_crunch</vh>
<v t="EKR.20040608165334.32"><vh>Bugfixcrunch</vh>
<v t="EKR.20040608165334.33"><vh>&lt;&lt; bfcrunch &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="EKR.20040608165334.89"><vh>dynabuttonmenu</vh>
<v t="EKR.20040612191928.2"><vh>&lt;&lt; about dynamenu &gt;&gt;</vh></v>
<v t="EKR.20040608165334.90"><vh>dyna_use</vh></v>
<v t="EKR.20040612191121.1"><vh>deldyna</vh></v>
<v t="EKR.20040612191121.2"><vh>dyna_getsubnodes</vh></v>
</v>
<v t="EKR.20040608165334.40"><vh>common</vh>
<v t="EKR.20040608165334.41"><vh>fixbody</vh></v>
<v t="EKR.20040608165334.42"><vh>dynastuff</vh>
<v t="EKR.20040608165334.43"><vh>dynaBunch</vh></v>
<v t="EKR.20040608165334.44"><vh>dynaerrout</vh></v>
<v t="EKR.20040608165334.45"><vh>captureStd</vh></v>
<v t="EKR.20040608165334.46"><vh>runcmd</vh></v>
<v t="EKR.20040608165334.47"><vh>dynadoc</vh></v>
</v>
<v t="EKR.20040608165334.48"><vh>dynaput</vh></v>
<v t="EKR.20040608165334.49"><vh>dynaplay</vh></v>
</v>
</v>
<v t="EKR.20040608165334.16"><vh>@thin dyna_menu.py</vh></v>
<v t="EKR.20040608165334.50" a="E"><vh>@thin dynatester.py</vh></v>
<v t="EKR.20040608165334.52"><vh>Macros: NOT part of Dyna menu</vh>
<v t="EKR.20040612224923.1"><vh>Ideas for other macros</vh></v>
<v t="EKR.20040609081035"><vh>dynaM_dupe</vh></v>
<v t="EKR.20040608165334.53"><vh>done ideas</vh>
<v t="EKR.20040608165334.54"><vh>commafy</vh></v>
<v t="EKR.20040608165334.55"><vh>del_comment</vh></v>
<v t="EKR.20040608165334.18"><vh>Clip_dtef</vh></v>
<v t="EKR.20040608165334.56"><vh>screenshot</vh></v>
</v>
<v t="EKR.20040608165334.57"><vh>inprocess</vh>
<v t="EKR.20040608165334.58"><vh>how to</vh>
<v t="EKR.20040608165334.59"><vh>&lt;&lt;somenode&gt;&gt;</vh>
<v t="EKR.20040608165334.60"><vh>2ndnode</vh></v>
</v>
</v>
<v t="EKR.20040608165334.36"><vh>restoreStd</vh></v>
<v t="EKR.20040608165334.61"><vh>Pic97</vh></v>
<v t="EKR.20040608165334.62"><vh>getdoc</vh></v>
<v t="EKR.20040608165334.63"><vh>profile</vh></v>
<v t="EKR.20040608165334.64"><vh>psyco_timeit</vh></v>
<v t="EKR.20040608165334.65"><vh>Graphvizoutline</vh>
<v t="EKR.20040608165334.66"><vh>&lt;&lt; code &gt;&gt;</vh>
<v t="EKR.20040608165334.67"><vh>addLeoNodesToGraph</vh></v>
<v t="EKR.20040608165334.68"><vh>tnode/vnodeLabel</vh></v>
<v t="EKR.20040608165334.69"><vh>tnode/vnodeRepr</vh></v>
</v>
</v>
<v t="EKR.20040608165334.70"><vh>+call_evaluator</vh></v>
</v>
<v t="EKR.20040608165334.71"><vh>template</vh></v>
<v t="EKR.20040608165334.72"><vh>parsing...</vh>
<v t="EKR.20040608165334.73"><vh>yaml</vh></v>
<v t="EKR.20040608165334.74" a="E"><vh>pullparser</vh>
<v t="EKR.20040608165334.75"><vh>&lt;&lt;readers&gt;&gt;</vh></v>
</v>
<v t="EKR.20040608165334.76"><vh>dateform</vh></v>
<v t="EKR.20040608165334.77"><vh>csv</vh></v>
<v t="EKR.20040608165334.78"><vh>fix_pack (changing Tk packing)</vh></v>
<v t="EKR.20040608165334.79"><vh>Tkpackpypar</vh></v>
<v t="EKR.20040608165334.80"><vh>pyparseTk</vh></v>
<v t="EKR.20040608165334.81"><vh>PlexTk</vh></v>
<v t="EKR.20040608165334.82"><vh>org_fix_pack</vh></v>
</v>
<v t="EKR.20040608165334.83"><vh>call_fixbody</vh></v>
</v>
</v>
</v>
<v t="EKR.20040605181725"><vh>Autocompleter</vh>
<v t="EKR.20040605181725.1"><vh>Docs for v125</vh>
<v t="EKR.20040608070256"><vh>autocompleter.ini</vh></v>
<v t="EKR.20040608070256.1"><vh>.ato files in the autocompleter folder</vh></v>
</v>
<v t="EKR.20040605181725.2"><vh>@thin autocompleter.py</vh></v>
</v>
</v>
<v t="EKR.20040613213623" a="TV"><vh>@thin mod_scripting.py</vh></v>
</vnodes>
<tnodes>
<t tx="EKR.20040517074107"></t>
<t tx="EKR.20040517075715"></t>
<t tx="EKR.20040517075715.13"></t>
<t tx="EKR.20040517075715.20">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading

</t>
<t tx="EKR.20040517075915">'''Automatically add nodes for common tasks'''

# We must use @file-noref because data below might look like section references,
# so ORDER IS IMPORTANT throughout this tree (we can't use @others).

#@language python
#@tabwidth -4

__name__ = "New Buttons"
__version__ = "0.2" # Converted to @file-noref by EKR.
 
import leoGlobals as g
import leoPlugins

import leoFind

try: import Tkinter as Tk
except ImportError: Tk = None</t>
<t tx="EKR.20040517075915.1">"""Classes to add helpers to the toolbar 
 
A helper is a class that adds a set of preconfigured nodes to the outline. This 
can be used to generate boiler plate code to quickly build an outline. The nodes 
and body text added can have an adjustable parameter, which is defined from 
the text entry box. 
 
"""

USE_FIXED_SIZES = 1</t>
<t tx="EKR.20040517075915.2">class FlatOptionMenu(Tk.OptionMenu):

    """Flat version of OptionMenu which allows the user to select a value from a menu."""

    def __init__(self, master, variable, value, *values, **kwargs):
        """Construct an optionmenu widget with the parent MASTER, with 
        the resource textvariable set to VARIABLE, the initially selected 
        value VALUE, the other menu values VALUES and an additional 
        keyword argument command.""" 
        kw = {
            "borderwidth": 2, "textvariable": variable,
            "indicatoron": 1, "relief": "flat", "anchor": "c",
            "highlightthickness": 2}
        Tk.Widget.__init__(self, master, "menubutton", kw)
        self.widgetName = 'tk_optionMenu' 
        menu = self.__menu = Tk.Menu(self, name="menu", tearoff=0)
        self.menuname = menu._w
        # 'command' is the only supported keyword 
        callback = kwargs.get('command')
        if kwargs.has_key('command'):
            del kwargs['command']
        if kwargs:
            raise TclError, 'unknown option -'+kwargs.keys()[0]
        menu.add_command(label=value,
            command=Tk._setit(variable, value, callback))
        for v in values:
            menu.add_command(label=v,
                command=Tk._setit(variable, v, callback))
        self["menu"] = menu</t>
<t tx="EKR.20040517075915.3">class Node: 
    """A node to add"""

    def __init__(self, name="", body="", inherit=0, subnodes=None):
        """Initialise the node"""
        self.name = name
        self.body = body
        self.subnodes = subnodes or []
        self.inherit = inherit # Set True to inherit the first line from our immediate sibling 

    def processText(self, text, name):
        """Process some boiler plate text"""
        if name: 
            text = text.replace("XXX", name)
            text = text.replace("xxx", name.lower())
        return text.strip()

    def addTo(self, c, text, parent=None): 
        """Add our nodes etc"""
        if self.inherit:
            header = c.currentVnode().bodyString().split("\n")[0] + "\n"
        else:
            header = ""
        # 
        c.insertHeadline()
        main = c.currentVnode()
        main.setHeadString(self.processText(self.name, text))
        # 
        main.setBodyStringOrPane(self.processText(header+self.body, text))
        if parent: 
            c.currentVnode().moveToNthChildOf(parent, 0) 
        # 
        parent = c.currentVnode()
        for node in self.subnodes:
            node.addTo(c, text, parent)
            parent = None # Only want first node to be moved, others will go automatically </t>
<t tx="EKR.20040517075915.4">class NodeAdder:

    """A Class to add a helper button to the toolbar which adds nodes to the outline""" 

    button_name = "Add"

    nodes = () # Should be set in the subclasses 

    def doIt(self, entry):
        """Create the nodes"""
        c = g.top()
        name = entry.get()
        for node in self.nodes:
            node.addTo(c, name)</t>
<t tx="EKR.20040517075915.5">class Helper:

    """A Class to aid in the creating and maintenance of unit test files"""

    def __init__(self, adders):

        """Initialise with a set of adders"""
    
        self.adders = adders

    def addWidgets(self, tags, keywords):

        """Add the widgets to Leo"""
        self.commander = keywords['c']
        toolbar = self.commander.frame.iconFrame
        # 
        self.frame = Tk.Frame(toolbar)
        self.frame.pack(side="right", padx=2)
        # 
        self.text = Tk.Entry(self._getSizer(self.frame, 24, 130))
        self.text.pack(side="left", padx=3, fill="both", expand=1)
        self.text.bind("&lt;Return&gt;", self.doCallback)
        # 
        self.pseudobutton = Tk.Frame(self._getSizer(self.frame, 24, 142), relief="raised", borderwidth=2) 
        self.pseudobutton.pack(side="right")
        # 
        self.doit = Tk.Button(self._getSizer(self.pseudobutton, 25, 32), text="New", relief="flat", command=self.doCallback)
        self.doit.pack(side="left")
        # 
        options = [adder.button_name for adder in self.adders]
        self.option_value = Tk.StringVar()
        self.options = FlatOptionMenu(self._getSizer(self.pseudobutton, 29, 110), self.option_value, *options)
        self.option_value.set(options[0])
        self.options.pack(side="right", fill="both", expand=1)
        
    def _getSizer(self, parent, height, width, pack="left"):
    
        """Return a sizer object to force a Tk widget to be the right size"""
    
        if USE_FIXED_SIZES:
            sizer = Tk.Frame(parent, height=height, width=width)
            sizer.pack_propagate(0) # don't shrink 
            sizer.pack(side=pack)
            return sizer
        else:
            return parent
            
    def doCallback(self, event=None):

        """Generate a callback to call the specific adder"""
        for adder in self.adders:
            if adder.button_name == self.option_value.get():
                adder.doIt(self.text)
                break
        else:
            raise ValueError("Button name not found: '%s'" % self.option_value.get())</t>
<t tx="EKR.20040517075915.6"># Modify these classes or data as you like to create templates that suit you.</t>
<t tx="EKR.20040517075915.7">TEST_NODE_BODY = '''
import unittest

@others

if __name__ == "__main__":
    unittest.main()
'''

TEST_CLASS_BODY = '''
class TestXXX(unittest.TestCase):

    """Tests for the XXX class"""

    @others
'''

TEST_SETUP_BODY = '''
def setUp(self):

    """Create the test fixture"""

'''</t>
<t tx="EKR.20040517075915.8">class AddTestModule(NodeAdder):

    """Add unit testing node"""

    button_name = "test module"

    nodes = [
        Node(
            name="testxxx.py",
            body=TEST_NODE_BODY,
            subnodes=[ 
                Node(
                    name="TestXXX",
                    body=TEST_CLASS_BODY,
                    subnodes=[ 
                        Node(name="setUp",
                        body=TEST_SETUP_BODY)])])]</t>
<t tx="EKR.20040517075915.9">class AddTestClass(NodeAdder):

    """Add unit testing class"""

    button_name = "test class"

    nodes = [
        Node(
            name="TestXXX",
            body=TEST_CLASS_BODY,
            subnodes=[
                Node(
                    name="setUp",
                    body=TEST_SETUP_BODY)])]</t>
<t tx="EKR.20040517075915.10">TEST_METHOD_BODY = '''
def testXXX(self):

    """testXXX: TestDescriptionGoesHere"""

'''

class AddTestMethod(NodeAdder):

    """Add unit testing method"""

    button_name = "test method"

    nodes = [
    Node(
        name="testXXX",
        body=TEST_METHOD_BODY,
        inherit=0)] # EKR: was 1.</t>
<t tx="EKR.20040517075915.11">NEW_CLASS_BODY = '''
class XXX:

    """DocStringGoesHere"""

    @others
'''

NEW_INIT_BODY = '''
def __init__(self):

    """Initialise the XXX instance"""

'''

class AddClass(NodeAdder):
    
    """Add new class"""

    button_name = "class"

    nodes = [
        Node(
            name="class XXX",
            body=NEW_CLASS_BODY,
            subnodes=[
                #Node(
                #	name="&lt;&lt; class XXX declarations &gt;&gt;",
                #	body="@c\npass"),
                Node(
                    name="__init__",
                    body=NEW_INIT_BODY)] )]
</t>
<t tx="EKR.20040517075915.12">CLASS_METHOD_BODY = '''
def XXX(self):

    """MethodDocstringGoesHere"""

'''

class AddClassMethod(NodeAdder):

    """Add class method"""

    button_name = "method"

    nodes = [
        Node(
            name="XXX",
            body=CLASS_METHOD_BODY,
            inherit=0)] # EKR: was 1.</t>
<t tx="EKR.20040517075915.13">if Tk:

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":
    
        g.es("Activating newButtons", color="orange")

        buttonList = [
            AddTestModule(),AddTestClass(),
            AddTestMethod(),AddClass(),AddClassMethod()]
    
        helper = Helper(buttonList)

        leoPlugins.registerHandler("after-create-leo-frame", helper.addWidgets)
        g.plugin_signon("newButtons")</t>
<t tx="EKR.20040517080049"></t>
<t tx="EKR.20040517080202">In Python 2.3 the source files should declare the encoding.

See http://www.python.org/peps/pep-0263.html for full details.</t>
<t tx="EKR.20040517080250"></t>
<t tx="EKR.20040517080517"></t>
<t tx="EKR.20040517080555"></t>
<t tx="EKR.20040517080555.1"></t>
<t tx="EKR.20040517080555.32">@nocolor</t>
<t tx="EKR.20040517080555.33">Reorganized the code so I can find various classes more easily.
Used @others to simply the outline.

Sorted all entries in dialogs.
Sorted all entries in Plugins menu, regardless of whether they are configurable.

For all dialogs:
    Added top ivar and removed root/master params and ivars.
    Added Leo icon and title.
    Centered dialogs.

Ctors now run all dialogs as modal dialogs: this could easily be undone.

Used a grid in the properties dialog to align widgets.</t>
<t tx="EKR.20040517080555.34">- We will use a new settings file called leoSettings.txt:
- Each setting will have its _own section_ in leoSettings.txt with the following items (most optional)
    val = present value of settings: Use parent setting if this does not exist.
    help = help string (displayed near setting if it exists)
    prompt = prompt string (defaults to setting name, i.e., the section name)
    group = name of group dialog containing this item (use general section if this does not exist)
    type = one of the following:
        value			meaning
        bool			followed by True/False prompts for radio buttons
        color			color picker
        font			font picker
        parent			name of parent config file (set/get setting in that file)
        entry			followed by arbitrary text in an entry widget
        text			followed by arbitrary text in a text widget
        number			any number, or followed by a range of valid values for an entry widget.
        numberlist  followed by a list valid values for a listbox.
        list			followed by a list of valid strings in a listbox.
Notes:
- We could use yaml or ConfigParser or Pickle.  yaml might be best.
- The options dialog will have a separate frame for each group or subgroup.
- We will want a Create Options file command (useful for converting old leoConfig.txt files)
- All options may have a use parent settings (for all widgets?)
- The separate "Groups" section may indicate which groups are subgroups of other groups for multi-level displays.</t>
<t tx="EKR.20040517080555.35">I wrote myself a plug-in which would automatically save the Leo file every so often and in doing so realized that it would be useful to be able to configure the interval between saves. Anyway, to cut a long story short, I generalized the idea and came up with the attached patch. 
 
All code resides under the "Plug in changes" node. The additions are all under the "create the plug-in menu" node with another couple of lines in "createMenuBar". Structurally this is ugly - but it helps keep all the changes in one place!
 
The basic idea is to allow plug-ins to be configured and also allow them to expose additional functions which can be accessed by a menu item. The advantage is that people don't have to mess with adding menus to Leo. Existing plug-ins don't need to be changed in any way to work with the new patch.
 
Ok, here's what it does	
 
1. A new "Plug-ins" menu item is added
 
2. Each plug-in gets an "About x	" entry.
 
    - clicking on "About x..." brings up an about box which shows name, version and documentation for the plug in
    - name comes from the module name
    - version is the module __version__ if present
    - documentation is the module docstring 
 
3. If the plug-in is configurable then a sub menu is created
 
    - configurable means that a corresponding ".ini" file is found with the same names as the plug-in (ie mod_image.py has mod_image.ini)
    - the sub menu contains
        - the "About x..." as before
        - a "Properties..." menu entry to edit the properties (*)
 
4. A further search is made for plug-in specific commands
 
    - we look for functions called "cmd_*" in the module
    - if found we add them to the plug-in menu
    - when you click on the menu item the function is called with a single parameter
 
(*) How does the property window work,
 
5. The property window reads the ini file which is assumed to be in standard ini file format (ie sections and parameters)
    - each section gets a frame in the window
    - each property gets an entry box
 
6. From the property window the user can "Cancel" or "OK", which saves changes
 
7. If the module contains an "applyConfiguration" function then there is also an "Apply" button on the form. The apply configuration function is called with the current configuration when the "Apply" button is pressed.
</t>
<t tx="EKR.20040517090508">@nocolor

Leo enables only those plugins whose filenames appear in PluginsManager.txt.

@color</t>
<t tx="EKR.20040605181725"></t>
<t tx="EKR.20040605181725.1">@nocolor

New in this version:

- Alt-Up, Alt-Down scroll the Autobox.
- Captialization and _ do not unsummon Autobox
- Ctrl now unsummons calltip box.GetSelection.</t>
<t tx="EKR.20040608070256">The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.</t>
<t tx="EKR.20040608070256.1">The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word( ....) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.</t>
<t tx="EKR.20040608165334">@language python
@tabwidth -4
@color</t>
<t tx="EKR.20040608165334.1">@language plain

Use dynabutton and dynatester to test and debug macros 
to later add to a dynamenu plugin, or for one time use.

See the sample macros for how to use selected text or the body 
text as data.  What's in the copy buffer can sometimes be used 
to alter how a macro works.

Note: in Leo after you select text, it often will stay selected
even if you perform some other editing task or copy something from
the log. it sometimes looses the visable select till the focus returns.
you can use this to advantage to copy or paste something in the log.
you can get bitten if you begin to Edit headline and hit selectall or 
hit delete both which act on the body text. which might not look selected.

select doc of the choices print/paste/doc in the menu, then hit DQ3
to see the doc strings of all the macros. later add pydoc for
specific macro. after you use them a few times it will be obvious
what they do. maybe. 
the rclick menu print/paste/doc is as you would expect. 
in the plugin you have to click them untill the right one shows up.

I've identified some tasks I commonly do a few times a day, week or month.
If there is a reasonable expectation that the task will be required again
that is the time to create some way of automating the task.
once the macro works, move it into the plugin macros node
now it will be available in all leo's

some of these were previously just plain scripts that I pasted data
into some triple quotes inside the script or used a subnode included.
there are ways to find a particular node directly and that also works.
but always requiring me to bring the data to the script somehow.
with dynabutton or dynamenu you can bring the script to the data!


one of the goals was to let the macro decide if there is selected text
use that otherwise get the body text and use that, the default now is
to follow @other and named section nodes as Leo's execute script works.
see fixbody in common, selected text gets @directives comented out.
if nothing is selected then @directives are striped out before processing.
another refinement might be to strip all comments before running the code.
if you just want the current node in one of the macros expecting code
then selectall. other macros that work on text will use the current node.

for the output, depending on a menu toggle, you might want 
to paste the results over the selected text or print the results to log.
I use the redirect to log config setting, YMMV
if a macro is included in the plugin, the print probably has to be 
changed to the g.es() output to log function.
later there will be a dynaprint type function that senses if its
run from the plugin to do the right thing. not a huge problem for now.


some of the functions like DQ3 and backslash might read the copy buffer
to get the char string to use for its replacement char string.
in other cases it senses from the selected text what it must do.
in all cases these are decisions that cover common (to me) use and in 
practice there is no problem beyond simply forgetting what you have to do.
for some people there will be extra work involved if they are totally
focused on the keyboard and don't want to stop to think how to utilize
these and other macros they might create. binding for keyboard
accelerators for menu choices will be easier to add in later versions.
maybe if it were easy to simply create macros by recording keystrokes
then playing them back the macros would be something easy to use.
there is a macro started to do the playback of scripted commands.
it wouldn't be that difficult to record keystrokes.
for me, creating a custom macro covers the majority use case.

there is some disconnect when you identify something that needs
a macro, you have to stop and create one. test and debug it.
so depending on how much time it could potentially save
for most few line modifications it will not be worth the trouble.
if you don't use it, it will never be easy. that is sure.

the idea for any macro or button is will it interupt the creative
process or simplify some refactor task. in the case of the flipper.
very often I notice I want to flip something while I have something
else Im in the middle of, often with a copy buffer that I am about
to go somewhere else and paste or use to search or add a doc.
do I stop, do I try and remember to return to flip or swap something
risking the forgetting and the cascade effect of loosing focus.
saveing a few keystrokes or few miliseconds isnt always the key benifit.
its what can happen or not happen in those few miliseconds.
it is also in these times I don't want to interupt my train of thought
to get involved in the infrastructure of macro creation. so I tend
to create and debug macros and processes between other operations.


as I've only been using dyna for a few weeks, theres some 
flux in the exact specifications to this idea, although
in the works for some time. I wasn't sure how best to implement parts of it.
I still don't! so there will be no guaranties of future compatibility etc.
undo is your friend. until your sure whatever modification or print
or paste wont harm your data. please be careful. if you overwrite
a file that isn't backed up, undo can't help you. test everything first.
use print first, that's why it is the default rather than paste.

on some of the more risky operations, it maybe wise to save the leo
you can later revert if there is a problem
backup to another directory or zipfile occasionally as well.


probably should come up with a unified naming scheme so don't clobber any varbs
currently preceding everything w/dyna. macros called dynaM_whatever(c)

class dynaBunch consolidates all the instance vars.
maybe use Leo ivar? except want to pretend this might somehow
be usable in other Tk or gui app for a custom menu

you can also paste just the dynaclick node into another leo and use 
the dynabutton directly to create and debug or use the macros there.

you can just run the macro from the dynatester node 
and never include it in either menu. in any case thinking ahead 
to the more general use while you tackle a particular task with 
a script or macro will make future reuse of the code more likely.

the plugin may have as one option recreate a dynanode like this one later.
 still up in the air about that idea for the moment.


each item could get a *default toggle to be the function under
the lclick. as is the first node with a def before common in
the dynabutton hirearchy is default. not sure this is better
than always haveing the first item be lclickable.
Alt-q will call the first macro in the dynabutton.
other macros could have their own accelerator keys.
this might be something to specify in the first line 
of the macro's doc string. checking for duplicates and overriding
Leo commad keys is something I don't want to have to check right now.

all or none of the above.
</t>
<t tx="EKR.20040608165334.2"> might just windup doubling all the relevant code to simplify my life.
 
u04516p11:08:50 first snag, the way dynabutton builds the menus wont work
I dont want to use a nameing convention to be able to tell the macros 
from other funxctions, but there must be a way to isolate them.
leaving it simple to clone or copy them into the macros node
maybe if it isnt a function call, but a table build as a result
of the write @file which must do some code compilation?
maybe some self registration code that has to be included? metaclass?
errors while loading the plugin are often not available in leo log window
it doesnt reprint the full scroll
also if fatal to leo and using pythonw leo wont start and there will be no indication
maybe a tkpopup would be nice for display, if people add macros that error.
added call to create exS button. cheaper then rclick or edit menu. ~= ^E
maybe macros should have a consistant first 4 chars so can find them in __dict__?
for now, yes. have to add the infrastructure for the toggle print/paste
still havent solved how to get the print/paste in a common way
need to pass in or use a global or add getprpa to class or put atttribute there
 for now chged dynabutton to use the same default global in connon as here
 final test will be if dynabutton and dynamenu can coexist w/o complete refactor
all the print stuff doesnt get redirected to log when run from the plugin
might need to common a little more any print output and test for __name___
seems the plugins have their own namespace? I must have forgotten that.
evaluator trapping prints isnt working so how to redirect that to log?
 maybe it will work from the plugin what doesnt work from exS?
 why in hell we need this dichotomy not sure...
 if I change everything to es, then I could loose being able to debug to console?
 and since print isnt a function I cant just reassign it?
chged to g.es in common and sofar so good, did a quick copy of dynaclick to new leo
still seems to work and works with the plugin enabled. and I assume disabled too.
should rename dynaclick to dynabutton to make the doc's consistant.
changed macro names. dumpbody. which also works on selected text
and probably should change name to dumphex or something.
names in rclick of dynabutton arent -6 and some of the first is leaking through.
the line between foolish consistincy and madness is getting blurry
print/paste toggle and status display isnt working in plugin

oh no, the tclerror no more menu just happened... am I not deallocating something?
I had the same leo open for many hours and overnight, opened and closed a test leo
many times testing the plugin and dynabutton interaction.
 probably in normal use this wouldent occur. the same thing did happen with rClick
 I had to remove a cascade submenu that listed the alphabit, numbers, punctuation
 and python keywords and Leo directives. I never see it now and I rClick alot.
moved initMdyna to part of __init__ in the Data class, why wasnt it before?
status update in the exS button works fine. 
status update and print/paste togle flip isnt working, isnt erroring
maybe I have to bind a command to the menu choice?
I dont know how to update the menu to show the current state of print/paste
I think I need to entryconfigure something
adding print/paste as a radio buttons. toto, we're not in simple anymore.
you have to click on the toggled item to switch to the other one?
 doesnt work like that in dynabutton. you click on the one you want &amp; it toggles
another anamoly for another days bug fixing. its beginning to look feasable.
t04518 one class cloned for the plugin or button instead of two seperate.


</t>
<t tx="EKR.20040608165334.3">#w04505p01:22:22 add a button works! 
maybe I can have a script that acts on selected text
usable from the button? 
how to get the button in an exact position?
toolbar is getting crowded.
why did noone think of this before? 
you could give it other commands once its up,
like soakup the current selected text as a script.

need an inline image instead of text though
would be nice to add to similar function to rClick.
its more natural to rclick after selecting something, 
than to hit a button. poor mans macro.
more than one active button easily possible.

use it wisely and test everything fully.


w04505p05:54:43 posted to sf forums dotted version.
might make a plugin to recreate this node, rather than start off
needing to copy it from another leo. it should idealy change the font &amp; size
of all the other buttons to make room for itself if needed.
Leo support button create should expand the icon bar as needed.
want to add its own rclick menu
maybe something to take selected text and create a regex to find it
r04506p05:33:42 adding a structure of this dynanode and dynamenu 
for macro store and clone into the dyna submenu and dynamic menu creation
snag, the list of def's found is a string, I need it to be function definitions
added a few more vars to cf and del them before initilizing the menu again
added better traceback to catch problems reading the function def's
globals()[x] sortof works, new anomaly, only the last defined item is called
maybe I need to get a refrence to them and pass a tuple name, inst back?
deeper than I want to have to know.
also I am now pypassing dynaclick which calls dosomething(c)
there is no more dosomething.and so lclick on the button errors.
maybe that should do the first function found?
then Im duplicating things in dynamenu as well. 
its starting to look like a plugin again
have the click to print or paste toggle infrastructire working.
just have to add the code to overwrite and update body.
need a quiet debug msg toggle next
and a help print of any __doc__ would be accessable from the menu somehow?
continuing on with the default action lclick, polishing up the delete first char
trying to reselect the area now so can keep hitting the button
usually only need to del 1-4 chars, and that only rarelym but iften enouugh
would be nice to have a select that wasnt line orientated too.
a few editors have conqured this with varying sucess
then could just select what you want and crop it.
wow, if you have a tearoff and then dissapear from the tearoff, 
the tearoff stays! and works. wish could make it always on top.
still have the bug about both item functions being the same as the last
found a base64 to image thing on aspn cookbook, it works from configure.
when passed to iconcreate it fails, imagefile fails, bg fails. wow
still the repaste reselect thing, a few good ideas.
have to make space on the toolbar if there isnt full width you cant still see.
the text is just as good and easier to modify
using pil to generate an image w/o file write then base64 might work
dont really want it that bad.
the ultimate will be when I can cut from one toolbar position and paste to another
or specify which open leo to put it on and where and remember it when it reopens.
even if I have to go to a config.leo with an improved automated updateing.
the idea of copying this whole node structure into another leo is a problem.
for debugging subroutines to paste into the testingmenu plugin is ok.
f04507a08:22:11 why do I rearange code for hours before realizing its an algrythmic mistake? was setting the whole selection inside the loop on the splitlines!
now have to abstract out the part that gets and sets over or prints the selection
used to cut the first n off of the new comafy and set that as the new working on function, that is the one that is activated when you lclick
any others get their names inserted as menu items for rclick.
except only the last one is active till I can learn why its working strange.
f04507a08:56:09 totally functional in just a few minutes including the abstract
this is fantastic! now additional macros on selected text should be very easy
just jot a;tr nymostale and leo printed done in blue, wtf? nothing in the undo
f04507p05:18:21 just solved the problem of how to present xml on netfirms, 
inside a form! copy &amp; paste into a new leo worked fine.
the question now is how can I easily create a html that wont mangle it?
and that the html inside wont be so screwedup it will crash the searchers bots.
parts of xml are already htmlized, if I redo that...
need a straignt xml to html translator better than the pastebins use.
I havent investigated how they screwup the copy but Leo knows it isnt a valid node
it messes up a little, although you can past the node.
may be I cant use view partial source?
the triple &gt;&gt;&gt; is htmlized but not unhtmlized when viewing the form
probably messes in the paste too? no, is ok
have to do a solid compare.
the tearoff still uses the body it was called from but the log of the current leo
try to get a refresh going, then to call init if there is no lst.
the output went back to the origional then disapeared.
hard to move around and it lost its title bar after refresh.
maybe it should be a full Tk widget.
the fastgoto guy has implimented a buffer read/write/copy/paste system
that looks usable for something.
there is recently a plugin for @run nodes, subnodes hold parameters
not sure if that is easier than writeing up a small function button
you can click the tearoff again after refresh to get titlebar back
if you click inthe new leo, click refresh, click tearoff, select something
it says nothing selected. but now the output goes to the newleo. select from old
how to get the select from the new? jow to just copy &amp; paste the  new button
how about a choice to migrate automatically at all new leo? a virtual plugin!
I can just do the plugin init, add itself to handler.
the toggle is updating now when tearoff, wasn't yesterday

    might use the url thing of grabbin the line if nothing is selected
    except that isnt how I usually doit
    need to save the selection points and reselect it fre maximum utilage
    problem is the selection is depending on the direction the user selected
    from bottomup, the insertpoint is at the top, otherwise is at bottom
    this makes it problematic to reselect the same points
    you cant tell from the index's returned where the insert point is either
    what happens when some is cit off a line and the insert is at the end
    will Tk balk or use the max on that line?
    need to set insertpoint to the top, hang the consequences
    little more predictablem but its still chipping the whole first line
    if skip the delete and reseletc it works fine, reselect hit button again
    if only select one line either direction, x1 -xmax or whole line, it works.
    otherwise the selection moves down each time and consumes the top line
    one of those things, I couldve finished quicker than all the time this 
    will save if its eventually working. OTOH, I might use it more if it worked.
  think have to get charbeforeselection, check it for 1.0 then set after that
  its really a pain to have to try and 2nd gueess everything that can go wrong.

</t>
<t tx="EKR.20040608165334.4">s04508p10:11:41 some more minor refactoring and cleaning up comments.
added a DQ3 paste over. need to make a cascade with ({[""" ' " ''' surrounds.
u04509p03:12:46 did the ul to netfirms &amp; post to forums, new dynabutton
hope people contribute some slick new scripts for doing some common tasks.
typically they will be one off or very user specific things. I hope some adventurous few realize the potential utility of this dynasystem.
there are many spell error and unintelligable typos, even I am seeeing them.
fixed a bug in deldyna that wasnt forceing try del of attributes.
have to convert to class so each leo gets one instance
or maybe what I need is to give the one borg instance to pre gui Leo
that way it will survive any deletion of any Leo. same w/rClick?
migrating to new Leo is still problematic w/o a plugin. 
that too is comming rsn (Tm).
back to work on evaluator, stacking winter wood, planting or other stuff.
another node structure needs to be designed
not good to need everything expanded to exscript dynaclick
and it maybe better to mark the nodes or tag the body somehow to include
as an item rather than requireing to clone.
still might be a little confusing to clone the scripts in macro node
oh well. good enough, for who its for, as they say.
im diggin it.
is there a way to have Leo execute something on load? 
whata can of worms that would be.
u04509p08:43:42  did a cut to oldcmt of some of the above comments.
have to solve the cascade choice problem for the enclosing DQ3
DQ3 should be able to select from one of the (),{},[], """, ''', ', "
and another new one the transform selected filename into 
forwardslash, backslash, url file:/// type, doublebackslash etc
optionally create a node w/@path or @url from it.
if it is already a url or close to it, add %20 if necessary over spaces
if path add quote around it. a series of checkmarks and cascades
in a general enough way so that the dynamenu can create what the def requires
the code is already done in python so just remains how to let dyna do it.
forgot I solved this yesterday. whats in the copybuffer does the choice!
so you copy the char you want to be the souround or the replace
then select something and its done with the matching pair or other side
copy ", then select and you get "select" simple enough to remember I hope.
you can always not toggle paste till its good
maybe the button should be whichever is the last operation?
starts off the first one on the list.
have to add a togle so you can see which is the default for the button too.
sounds like a plan.
fixed DQ3 &amp; clip to to the more compatible g.app.gui.*Clipboard()
worked like a dream. 
these little side trips to work on infrastrucure are getting shorter and shorter.
still need to classify the whole thing so can limit the name pollution
might ul this verion before many people get to see the msg and try it.
m04510a12:04:03 made the html, tested new improvements to sort
using a copybuffer char to  split on if not multiline
now need a way to select reverse sort. maybe what is in the previous undo?
would just have 2 choices and pass it other than only c? why not.
need a way to automate creting the html, little tedious as it is now.
usimg private var on sort function to determine direction. sneaky
there maybe oversights, the testing got shorter this itteration.
added reverse and either selected or body sort. need more tests.
should work wih it a few more days. publish or perish. release early &amp; often.
m04510a01:02:35 uled, up the version &amp; version stamp
not going to notify anyone. they can checkback if they have a problem
to get a new version and see if its already fixed. noone commented anywhere.
at the worst its a place to backup what I think is the most usefull work.
not that I dont backup a few times a week anyway. and after the last few hd crashes I should have had a more permanant backup off disk by now. ya think?
maybe tomorray Ill get right on that.
chg to 4 inline checkmarks on the menu
print paste doc test, maybe 3 checkmarks, they arent inline, each gets a line
they arent check they are radio. check is one item on/off
I dont know how to make one of them selected from the start.
m04510a10:03:17 switch to stringvar and use 'print' 'paste' directly
only now there are 3 lines instead of one toggle. ahh progress
debateing adding add char to delfirstchar using whats in the copy buffer
maybe if the rclick shows the first n chars in the copy buffer 
it would remind that something has to be copyed for some operations?
except now if tornoff nothing changes unless you click dynamenu
hardly ever use tearoff anyway.
should lable which of them defaults to body if nothing selected
that implys parsing the def to learn. in lisp its trivial to get
the body of a function definition. more difficult in python.
probably more than I want to have to debug right now.
instead of add char to delfirstchar,
better to take -Rich's idea of a series of commands to insert
and another macro to parse and execute commands to insert and move
seperating out the commands from the text is dificult, error prone
without a macro recorder and editor, something again not ready to debug.
m04510a11:18:31 did the first cut anyway as proof of concept. 1/2h

m04510p03:44:51 made a class to store and output varbs. no methods to speak of
dont want to force extension scripts to become members
although membership has its advantages.
ignoreing the good advice leave well enough alone. 
now its not destroying the menu
damm, shoulve made a backup before this refactor.
somethihng must be different from deleting attribute of cf to a class var &amp; class
m04510p05:04:05 its dissapearing again. thats a good thing.
print/paste is selected on start but I cant get one of the functions selected
till you click one for the first time
why when you lclick does nothing selected print twice? 
gave it a default of blank docstring if nothing selected.
another problem of this type of dev vrs plugin is on an endless your leo is hung
when I was testng and getting hung before and the dyna wouldent dissapear
I copied the whole node to a new leo. edited code there then copied back
when I realized that was just a test. it ruined all the clone connections.
that could be annoying when xfering to another leo. I keep forgetting about that.
how do they survive when copied from the html? maybe I can package it here too.
maybe b64 or uue the node, then copy and have a little bootstrap to unpack it.
m04510p11:56:57 added a choice submenu to get typical strings into the copy buffer
like ({[""" and a few others
t04511a03:12:41 avoiding the clone operation is becomeing problematic.
with good reason I wanted that node out of the execution path
now need another node for dont run macros and run macros.
and marking the headlines is a little superfluous
maybe use the hadline mark to specify if its a print/paste
if it expects something in the copybuffer
if its selected or nothing or if it will use the body if nothing selected
fixed all the str(dynaput) returning none
then checking if data == None, why it gets lowcases after print str(None)
that shoulve been is None, but wasnt either, was just if data:
doesnt when you run it directly. anyway they all now properly do the proper thing.

all talk of clones and macros and after the common node are defunct.
macro node has to come before dynamenu otherwise it cant find the functions
to add the command= instance, they refer to functions in the common node
which is way after in the hirearchy. could fix that with anglebrackets
but nothing is actually run till everything is loaded so its no problem.
t04511a06:34:06 maybe with the plugin the use of clones would work. haveing 
a similar way to build the menu. meoving finished ones to the plugin too.
they would get frozen anyway once the plugin was rendered.
maybe a plugin isnt required at all since I really want to rclick with these
I should be migrating all the good ideas to rClick and rclickclass
I should be subclassing rClickclass for plugin use to stop maintaining 4 versions
of basically the same codebase.
t04511p12:49:54 started dyna_menu.py and a csv approach to the pack thing
to avoid code duplication or not to avoid code duplication
possibly there will be expansion of the dynaData class clone to the plugin
then can check for existance of that and either one can use it
same with other leo's. thas the plan anyway.
methods of the class will be basically all the things in this subnode?
if exscript on this node all hell will break loose if the plugin is loaded.
-
if I save a timestamp when leo is opened with the instance then on exit
can match an attrinute to the time saved and pop that instance
so it doesnt get used again. why this isnt easier is beyond me.
-
r04513p02:53:47 tossed off flipper and swapper &amp; delcomments little toys.
starting pyparsing of the tkpack thing turned into general list/dict builder
redefine dynaput locally so can execute script on test data
f04514a11:22:06 tryed pyparsing &amp; plex on the packTK thing, no avail
im sure its just a simple correctable mistake givent the time to debug it.
fine tuned the local dynaput redef, including exceptions and multiple test runs
need to abstract that into its own node to be conditionally included
not sure Leo can do that w/o editing ATothers, editing which Im trying to avoid
the removeing anglebrackets and deleting the clone also would require editing.
duplicating the code in each node under test isnt too bad really
maybe have a special node that allows testing and menu inclusion when done
finishned converting sfdots to sense if there are dots remove them, 
if none add them. touch up some of the comments in the first few nodes.

have to have find the way of dynamically adding items to menus

need 2 positions on the menu for filein, fileout
to be selected either from copy buffer or browse
defaulting to something sensible on startup

override the es_traceback to show full?
what about other menu items that are always to print, like to show current sun position for the monitor user overworked metric plugin
using dyna as a debugger for parts of that code should be an improvement

u04516a02:45:28 added makeatemp to make a tempscript.py from selected or body
run it thru reindent, pychecker &amp; pylint. not haveing alot of sucess
with the checkers run externally especially on source calling leo* stuff
tryed to do this once before on plugin code with little sucess.
timone posted code to check for single use of varb found on google from 96?
maybe that would be a quick lint check usefull macro ?
its ment to run from stdin? would have to be modifyed alot. nothing is easy.
u04516a05:29:39  fixed pylint, it wants the module only, 
no .py extension and it seems only in site-packages. 
pychecker and reindent work too.
for the plugin, running deldyna from dynabutton will screw the dynamenu totally.
going to have to add whatever is really common to the Data class
seperate out deleting or reconfiguring the button
m04517a04:13:23 snag in dynamenu, not to mention on of the functions for dynabutton is called dynamenu
building the macro caller has to happen either while writeing the plugin or before writeing the plugin maybe with exscript on a buildmenu script
once the plugin is loaded in another leo, there may be no macros node.
why wasn't this immediatly obvious?
when you copy a node and it has clones within its node, they do stay clones
but if you then paste the node into another leo, they are only copies.
how when you copy the xml firstm then paste into a leo the clones stay clones?
cloned a few copied a few to plugins macros. and they appear to work ok.
plugins required a new class Data simplifyed table menu maker, cloned common
little disconcerting now that I realize rclicking to select in dynabutton
then lclicking to select item in dynamenu, not sure if that should be corrected,
maybe dynabuttton shouldent be a button at all,
except as a menu would be more tedius to update the labels.
generating a new menu on each rclick is alot closer to how it should happen.
need a debug/nodebug for print statements.
have to enable doc toggle for the plugin where it might not be easy
to look at the code to see what it does. realize -OO removes doc's
maybe a default usage=__doc__.splitlines(True)[:5] for each macro?
a metaclass to add a status display of a few words from __doc__ might be helpfull
something the writer of the macro doesnt have to work hard to remember to do.
will onmouseover/onmouseout work for menu items like it does in exS button?
m04517p09:18:03 alt-d bad for dyna menu. moved init to __init__
tighted up and cloned dynadoc under common. the clone mark doesnt show, but it is a clone, guess any sub nodes of a clone are a clone.
with 3 choices in dynamenu to toggle its completely weird which it will be
unlike in the button you click the one you want. better to index into the list?
should make they python and sitedir defaulted in class so can access from there
in common would be better so its not duplicated. several macros need it
  File "&lt;string&gt;", line 961, in dynamenu, TypeError: unsubscriptable object
wqs calling the old initM
chg to cStringIO if available, moved the import to common
have duplicated trailing test code in alot of the macros which is superceeded
in dynatester node. found out the class dynaData lifted from c.l.py
is really the Bunch class from a few years ago and which Leo has available
could have been setting varbs by passing in a dict much easier.
t04518p12:28:29 ^T enter to get dtef have to change to ^Y enter for first macro
abstracted the class and init to common, button &amp; plugin using the same
just had to change the plugin getmenu to return a lst same as button
moved the table building thing toload menu and few other cosmetic changes.
another level of indirection to get makatemp to work in plugin 
w/o remove the testing code at the end. 
which is kind of the point of it all anyway.
have to remember print doesnt redirect well from a plugin
and it might not always be wanted output to the log
have to go thru and setup a dynaprint or something = es or = print
in crunch &amp; makatemp
haveing reindent and pychecker is paying dividents I woulden't have suspected.
presiously I would tediously save a temp, grab the filename or just the filename
and or write the file then run reindent then pychecker.
now I can just run snipits. just have to solve stoping the body/selected read
if there is a valid filename just use that.
should chg to function to return tmpfile instead of global, ok for now.
another choice, if to include ATothers? maybe thats a menu toggle
the code to get body can be abstracted now, 
used in crunch &amp; makatemp and quite a few others if nothing selected
except that in makatemp &amp; crunch you want @-@c and all @~ commented out.
better see how other plugins handle this and what Leo already provides.
very pythonic that it was quicker to whipup the code to do it than to look
but commenting out the @commands wasnt really that complicated. @others is
fixbody(data) just does what crunch &amp; makatemp had each duplicated. 
sfdots, wouldent want the body commented out sections?
but if they were included, then the section &amp; @others would be wrong...
if the macros could sense how they were being called you  could modify behavior
like for clipdtef, if called from another macro you would not want the copybuffer
just the output returned. unhandled return isnt allowed in python? probably not.
although None is routinely ignored w/o problem. maybe orther values are too.
</t>
<t tx="EKR.20040608165334.5">u04516a02:45:28 -4h added an exScript button.

added dynatester node, you copy the macro under test into it
optionally add test data at the bottom using the suplied caller
there are a few caviets. maybe one too many

w04519a01:43:39 moved the dyna menu back before help, remove circular
refrence in load and caller. just init in either one if None.
tryed open, new, seems ok. no cross polination so far. no extranious prints.
coverage of print/paste isnt complete. 
unless you know what they do probably incomprehensable.
so glad am putting off uploading new version till work with it a few days.
so many fatal errors and oversights caught since the last major refactor.
cant really see how to autommate a go no test on everything.
even manually remembering what to try seems impossible.
really should get another system or two to try things on.
have to get rid of that regsub warning, 
is it in timone, pychecker or reindent or all 3?
looks like crunch. got rid of one of the two.
the other regex isnt matching so used simplefilter to turn off all depreciated
maybe on some of the macros it would be clearer to have an embeded listbox to popup with the choices if it wasnt clear what to do.
a macro to be a front end to many scripts would let you select in/out file
w04519a11:13:02 I guess I could have rClick check if there is a cf.dynaMvar
if so add a cascade of macro items available. usually its too distracting
to use buttons and toolbar menus, its too far to travel. 
rClick is right where the data is. 
I really dont want to reimplement all the toggles and menu items though.
w04519p01:47:15 upl new version, uped the versions here. unfortunatly 
I forgot to collapse some of the nodes and fine tune which macros were 
in which menu or button. ohwell. Im not expecting a huge outcry,
the fastgotonode guy implemented macros in the latest version.
Ive stuck w/version .2 I think, I might use the buffers &amp; macros though.
been too busy implimenting dyna to try any of the later versions.
I really have to test in 4.2 now that its out. 
couldent get to cvs the other night, ment to test it before releasing.
damm and damm again.
really should be using the sme function to create both menus.
especially since have to manually add items anyway.
the only difference is letting leo initilize from a table
it wouldent be hard to duplicate that for the button.
w04519p11:53:34 little more light refactoring and found a few latent bugs.
 explain more how to generate and get the .rc files for pychecker &amp; pylint
moved around a few of the docs and cut a word here and there.
started to add load/save to the class to get/save an ini
started macro to geturls,  c&amp;p would've worked as well.
had a usecase. best time to work, ready test data, motivation.
was a little off in fixbody about comment start and what stops it.
and my use, if there is no code, you dont need @c at body end
any directive can stop it?  chged a few things &amp; lightly tested
r04520p05:28:27  do another bugfix upload, uped the versions here
reenabled the prints from init and load menu in the plugin
ment to shut them off, but it is interesting when they fire.
load is called before init, assuming the output is realtime.
matches with previous experiance of before load had its own init.
on new and open, load gets called after init so the var is not None
does there need to be such confustation?
seems to do the right thing when close the origional, unlike rClickk
integration of the 2 menu creators more is next.
maybe I can change the button to fire on rclick, menu on lclick
f04521p02:10:14 \python233\lib\textwrap.py why reinvent when you can reuse
probably need to get a utl for those not in py3.4 but defaults to formdoc
which needs to be more featurefull and less obstanant about width =40
added call to a clip_dtef macro on every save operation in plugin.
used to timestamp the log on save. hook on save1 instead of command1
had to add code to clipdtef to choose if clip, print and or return dt
was trying to think of way to determine if another macro called it return dt, this is better. now can use to timestamp other operations.
added reverse dict to DQ3 to expand selection choices, yet same result.
also in flipper to simplify the dict creation to one pair.
f04521p05:06:34 wraper more generic than whats in dynadoc
wrap to the len of the first line in selected text
later extend to do like edit wrap paragraph, maybe replace it.
made a macro of my modifyed EKR get screenshot script
 maybe still has imsurmountable problems run from inside leo
 this was also the script where running a script from a button
 really started to become an obcession. even though I already have had
 menus with scripts in them since the first plugin for Leo was released.
 hexdumpbody and clipdtef.

its possible to have scripts that are helper scripts outside of the menu
that work as macros or helpers. clipdtef and wraper
still a little fuzzy on the details.
might be annoying to have to have a dependancy checker parse the node
amd complain if a required macro was not found.
OTOH would be the same problem if someone removed something from common.
a macro included in common wouldent have to be cloned into the menu too,
unless it works as those do.
except wraper might optionally replace the edit reformat paragraph
which never seems to leave me with usable results.
f04521p06:26:19 just found a fatal bug in Leo headline handling.
not sure if anyone reported an oversize string can crash python.
another long standing bug related to there being no onDeleteFromBody(),
selected text stays selected even after you copy or paste something
in the log. I often forget this when I edit headline. delete there
works on the body! so does selectall when you are editing headline.
you can selectall, not realize it because while your in headline
selected text in the body doesnt look selected. then hit delete,
selected text might not even be in visable section of the body.
it would be gone just the same.
having the macro spit out the copy choices its aware of to the log
might make sense. 
s04522p08:30:53 did try the automcompleter and the new fastgotonode.
autocompleter is a great first version. worked, think there were a few
sf induced syntax errors easily fixed. it works but full integration
with pasteing partial words from the mouse doesnt work. if you backspace
you may as well start typing the whole word over again then hit .
no offence to paul and his EKR supported autocompleter. looks great
but I didnt get it working and took too much to understand why.
I wasnt able to get the spell checkier working either and I suspect it will be too slow. I havent tryed either recently so probably shoulent comment.
the new v.8 of fastgotonode seems ok, Im not sure I would use buffers as much as I thought origionally. I always was annoyed in vi (decade ago) that you couldent see what was in the buffer. nice there is a little popup and rclick you can control that with. the macro idea there in its infancy to be sure, will take alot of work to duplicate what executing script in Leo already does. I like using a leo to store my macros, edit and test them.
s04522p10:24:38 few minor extractions to shorten up some nodes
some subnodes to better arrange things here and there. chged fixbody
for makatemp, tim1 evaluator to respect @language partially and
using that in lue of ad hock getbody in each. now consistantly you
check for selected and or just pass data, c  to fixbody it returns
 @directives commented and eventually follow @others and sections
I think I must clone a macros node of safe to export macros
 I dont want to upload some of the latest halfbaked ideas
 yet I may want to upload any bugfixes in the doc or common
not planning anything untill something major like follow @others happens.
</t>
<t tx="EKR.20040608165334.6">u04523p01:37:13 debuged the bugfix version of tim1crunch
explored getting line number. seems inside a module the linenumber
I know about is from the caller? need more info on how to do that
alot of asumptions in code from 96 are no longer 1
get it localized to a few sections that build an exclusion dict
using dict as a name, then del dict. commented out if it doesnt make sense
turned up problem in StringIO reuse, its eating blank lines by accident.
makeatemp doesnt.  add newline=False and splitlines(True)
need to port over the keyword list builder from evaluator
more words to flipper or swapper as they are needed
proably should clean up the half baked macro situation &amp; upload.
started macro pullparser to print html titles for later.
did an upload, but the version must change slightly.
u04523p11:53:06 you should never download anything  the same day
its uploaded. advice from a long time downloader, short time uploader.
did get 4.2 from cvs the other day and ment to try before upload.
dyna menu works fine, 
dyna menu should not and doesnt produce any messages on startup.
something kills the status message from another of my menu's
maybe on leo fully loaded its cleared. 
have to get tricky and put an idle in. its a status arms race.
the exS status msg is ok, for some reasone there is 
a purple script ended message now after every execute script.
that could get on your last nerve.
possibly security related. so you know when a script has run,
why no message if you give the script a name?
always a way around any security chicanery.

f = file('leoCommands.py','w+')
bg = c.frame.log.cget('bg')
s = f.read().replace('purple', bg)
f.seek(0)
f.write(s)

for some reason was using a complicated frame thing instead of
c.currentVnode() in getmenu
now the button works too.
4.2 does seem little quicker, not to mention the saveing in @file-thin
I like the thick files, though file size was getting to be a problem
on a few of them.
another upload, this hasnt been fully testing obviously
there are many things that can go wrong.
but, if it worked yesterday,
there is no logical reason it wont work tomorrow.
if use Leo API for body full that will require other code to nodewalk
 since for some macros you might want subnodes and follow @others
  without it necessarily being python source. or a coherent script.
and why involve another step if remove comments and docstrings for test
m04524a11:03:54 patched in some relevent code from executescript
to follow @others etc and write derived file to filelikeobject
have to if around if selected still have to do the same thing
appears to work. adding py+tempfile to macro callfixbody tester
then can run any script outside Leo 
and maybe later optionally rename/move it once its working well
maybe even create a shortcut
might changeexS button to a mode button
SexS could stands for save then execute script.
something tells me that isnt going to happen by that name.
m04524p12:34:14 added forklike to runcmd to spawn a script from fixbody
 should be minor to tweek it to work in *nix
now can run anything. still passing it thru reindent first to catch syntax errors rather than depend on the console
also forgot to add -i if Tk, that maybe should be a prerequisit anyway
strange, I forgot to notice, there was no console! even after -i added.
makes no sense. but ok. maybe because it was a Tk script.
noting is ever easy. the -i leaves a hanging python.
just the opposit problem it usually solves.
calling a console script leaves a hanging python and saw nothing
nothing in the taskbar noplace to get input from or show output...
how did the Tk script work?
I probably worked all this out in easyjump
and am making the same mistakes.
the output is to the console the leo started with.
that seems dangerous.
and what I was trying to avoid.
it does spawn python though, just reuses the console.
all the stacked up pythons exited when I closed the leo.
another half done one till I find out how to start a really new process.
last exS on dynaclick got a tk error ehen I rclicked on dynabutton
unscriptable object. maybe was not quite initilized yet?
was ok after the error.
command.com /k same process just a dosprompt, exit to exit

speak of the devil and they appear
A Pyrex wrapper for the aspell api.
http://prdownloads.sourceforge.net/uncpythontools/aspell-1.0.zip?download
http://sourceforge.net/project/showfiles.php?group_id=82407

You will also, of course, need Pyrex from
http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/.
 
http://aspell.net/win32/   
 http://ftp.gnu.org/gnu/aspell/w32/Aspell-0-50-3-3-Setup.exe 2m
http://ftp.gnu.org/gnu/aspell/w32/Aspell-en-0.50-2-3.exe    2.5m
http://wordlist.sourceforge.net/
http://ftp.gnu.org/gnu/aspell/w32/aspell-dev-0-50-3-3.zip
http://ftp.gnu.org/gnu/aspell/w32/
http://aspell.net/win32/files/
http://aspell.net

#Gary Bishop python-list@python.org
import aspell
sc = aspell.spell_checker()  #prefix="c:/UTIL/DLL/Aspell"
word = 'flarg'
if not sc.check(word):
  print word, 'is incorrect'
  print 'suggestions include:', sc.suggest(word)
 
insalled the aspell libs ok.
pyrex.9 failed had to get newer version, .91a
got the pyx build although system got weird and had to reboot
rebuild after reboot no problem. a few too many warnings.
the dirs now are a problem? import aspell doesnt work
ImportError: DLL load failed: The system cannot find the file specified.
filemon shows it is found and loaded, but it doesnt look for other dll?
dled the authors pyd for py2.3, copied Aspell to the default, still nfg.
aspell is evil.
its far easier to make mistakes that prevent progrms from working than the reverse. python does cut down the ratio quite a bit, its not near zero.
m04524p08:29:54 it has been awhile since I tried mod_spelling plugin
w/exception of it deciding which node to start on. but does the 2nd time,
and ignoreing selected text this is vastly improved in every way.
the focus shifting is a little weird. you have to get both onscreen.
the suggestions are really good for even unrecognizable stuff &amp; typos.
it doesnt focus the text when its near the bottom. think it misses headlines. not sure if its slowing me down more than 20%
and I hardly notice the 5minutes lost forgetting to save before it hung.
at least it didnt hang both leo's, win some loose some. maybe it recovers.
it is on another python and after a few minutes,
 I really dont care if it recovers, Im gone.
think will probably keep it off and create a button to toggle
pluginmanager.txt. why cant there be something like load xyz.py
then reopen the leo and it has spell check. ok I can work around it.
 and it sort of proves the Aspell install is actually working.
maybe I can just hook into what mod_spelling has to check selected text
I dont like the idea of it always updateing every time I select
a node and on any command that can change text. OTOH rebuilding
and index can be prohibitive on a large leo 
and IIR there was a huge startup time to concider. that seems nonexsistant.
maybe it is indexing in a thread. have to look at the source again.
many plugins are starting to use threads. maybe exS should thread.
need to get more lazy eval only register when first used for ex.
Graphviz macro using EKR demo which apparently 4.2 and not finished.
the other dot test work to create jpg.
think im going to seperate out pylint from pychecker
pychecker consistantly doesnt understand anything leo
maybe pylint will be more usefull esp now that full body
if you want just the node, then selectall is simpler than a toggle
still havent worked out node following while not programs
as might be the case for many other Leo useage you want full text.
now with the purple end of script thing looming I hate to mark the end.
the more nodes the smaller they get.
might be usefull for a few subnode description
I dont have a solid understanding of all the wys to travel in node land.
it doesnt help that there is a paralell uncompatable way in 4.2
t04525a01:34:29 tightened up the attribute access in exS button
calling the def with the name of the attribute now
this will allow multiple buttons. later add a dict with status msg
and command and all the other stuff a button would want to have.
including eventually some sense of where to put itself.
and it should push info on how to add itself back should it dissapear.
how can a macro be a button? or how to convey it wants to be a button?
t04525a09:44:10 did a quick run thru in py2.2 few things
you cant find a string in a string? if leopath in path
warnings has no simplefilter and a few of the try arounds still used print.
only the plugin, any macros in button or macrostore YOYO yer on yer own.
defensive programming and sticking to the API really pays off
only took anout 4 minutes to fix problems in both Leo4.2 and py2.2
other os probably will take more effort probably by someone else if ever.
not to start a flame war but getting a decent wm up in nux is no hour job.

</t>
<t tx="EKR.20040608165334.7">"""to use you pylint need both.
http://www.logilab.org/projects/pylint
http://www.logilab.org/projects/common
%HOME% .pylintrc
see how to get the rc file below

for pychecker
http://pychecker.sourceforge.net/
%HOME% .pycheckrc

in test.leo I think there is a good rc file for pychecker

set HOME=c:\sve\mii or whatever in your .rc or autoexec.bat
or somehow set HOME or export in your env

it may also be possible to set which config on the command line.


for call_evaluator get calc_util.py and its unit tests 
  and rClickclass 
   from http://rclick.netfirms.com/rCpython.htm
as of 6/04 ******* not yet available *********


   instruction how to get modules from cvs are on c.l.py
 cvs.sourceforge.net/cgi-bin/viewcvs.cgi/python/python/nondist/sandbox/csv

   some modules that have been left in compatable python source 
   on cvs will work in py2.2 or less.
   textwrap, csv, sets, iterators, datetime and the list is growing.

    you may need generators and enumerate for some operations.
    py2.2 you can uncomment from  __future__ import generators
    enumerate you have to search a little or ask on IRC in #python

   c.l.py is the usenet comp.lang.python gated mailing list
   source of all knowledge and misinformation about python.
   time marches on, Leo backward compatibility is not perfect either.

other depancies are in the doc strings of the individual macro's 
many of them are just shells that produce some typical output 
to use as a template if the need arises. url's included
or use http://www.python.org/pypi/ 
or Vaults of Parnassus  http://www.vex.net/~x/parnassus/ 
 help(module) or run pydoc or search the index 
 or the archive of google site:python.org



"""
import os

print os.path.expanduser("~")
print os.getenv("home")

#howtto get the pylint rc file
#@url file:///C|/C/PY/PYTHON~1/SCRIPTS/PYLINT.bat%20c:\sve\mi\.pylintrt
#    os.startfile(url)
#WindowsError: [Errno 2] The system cannot find the file specified: 
#I thought maybe wit
h %20 I could sneak in a parameter to pylint.bat
#actually the command would be
#C:\C\PY\PYTHON~1\SCRIPTS\PYLINT.bat &gt;c:\sve\mi\.pylintrc
#but that even wont work because they dopily put the output on stderr
#so I cameup with this script, run from a macro. I leave it up to you
#you could copy the runcmd function and import os and exscript from here too
#you need to edit the resultnant rc file because pylint is a style checker
#it complains about alot of stuff. no space after coma, single char names
#etc etc etc
#if you have msys shell or other shell rather than a dos window
#you can run pylint and redirect stderr or copy from the screen

#not recently tested
it = r'C:\C\PY\PYTHON~1\SCRIPTS\PYLINT.bat'
para = r' --generate-rcfile'
outit = None  or r'c:\sve\mii\.pylintrc'
output, outerr = runcmd(it + para )
if outit:
    fo = file(outit, 'w')
    fo.writelines(output + "\n" + outerr )
    fo.close()
    print 'written to', outit</t>
<t tx="EKR.20040608165334.8"></t>
<t tx="EKR.20040608165334.9"></t>
<t tx="EKR.20040608165334.10"></t>
<t tx="EKR.20040608165334.11">@ignore
@path c:\sve\mii\
</t>
<t tx="EKR.20040608165334.12"># Sample defaults file for PyChecker 0.8.13
# This file should be called:  .pycheckrc
# It should be placed in your home directory (value of $HOME).
# If $HOME is not set, it will look in the current directory.

# file = c:/prog/leoCVS/leo/src/leo.py

# bool: warnings for Doc Strings
noDocModule = 0
noDocClass = 0
noDocFunc = 0

# bool: when checking if class data members (attributes) are set
#       check all members or __init__() only
onlyCheckInitForMembers = 0

# bool: warn when all module variables are not used (including private vars)
allVariablesUsed = 0

# bool: produce warnings for each occurrence of a warning for global (xxx)
reportAllGlobals = 0

# bool: warn when private module variables are not used (_var)
privateVariableUsed = 1

# bool: warn when imports are not used
importUsed = 1

# bool: warn when import and from ... import are used for same module
mixImport = 0 # EKR

# bool: warn when imports are not used in __init__.py
packageImportUsed = 1

# bool: warn when a module reimports another module (import &amp; from/import)
moduleImportErrors = 0 # EKR

# bool: warn when modules import themselves
reimportSelf = 0 # EKR

# bool: warn when local variables are not used
localVariablesUsed = 1

# bool:  assume a, b, and c are used in this case:  a, b, c = func()
unusedLocalTuple = 0

# bool:  warn when class attributes (data members) are unused
membersUsed = 0

# bool: warn when Subclass.__init__ is not called in a subclass
baseClassInitted = 1

# bool: warn when Subclass needs to override methods that only throw exceptions
abstractClasses = 1

# bool: warn when __init__ is defined in a subclass
initDefinedInSubclass = 0

# bool: warn when __init__ returns None
returnNoneFromInit = 1

# bool: warn when code is not reachable
unreachableCode = 0

# bool: warn when a constant is used in a conditional statement (if '':)
constantConditions = 1

# bool: warn when 1 is used in a conditional statement, (if 1: while 1: etc)
constant1 = 0

# bool: warn when iterating over a string in a for loop
stringIteration = 1

# bool: warn when setting a variable to different types
inconsistentTypes = 0

# bool: warn when setting a tuple of variables to a non-sequence (a, b = None)
unpackNonSequence = 1

# bool: warn when setting a tuple of variables to the wrong length (a, b = 1,)
unpackLength = 1

# bool: warn when using strings exceptions or 
#       other classes not derived from Exception to raise/catch exceptions
badExceptions = 1

# bool: warn when statements appear to have no effect
noEffect = 1

# bool: warn when using (expr % 1), it has no effect on integers and strings
modulo1 = 1

# bool: warn if using (expr is const-literal), 
# doesn't always work on integers and strings
isLiteral = 0 # EKR

# bool: warn when using a deprecated module or function
deprecated = 1

# bool: warn when the class attribute does not exist
classAttrExists = 1

# bool: warn when calling an attribute not a method
callingAttribute = 0

# bool: warn when using named arguments: func(a=1, b=2), where def func(a, b):
#       def func2(a, b, **kw): doesn't generate a warning
namedArgs = 0 # EKR

# str: name of 'self' parameter
methodArgName = 'self'

# list of str: names of first parameter to classmethods
## classmethodArgNames = ['cls', 'klass']

# bool: warn when method/function arguments are unused
argumentsUsed = 1

# bool: ignore if self is unused in methods
ignoreSelfUnused = 0

# bool: warn if functions/classes/methods names are redefined in same scope
redefiningFunction = 1

# bool:  check if an overriden method has the same signature
#	 as base class method (__init__() methods are not checked)
checkOverridenMethods = 1

# bool:  check if a special (reserved) method has the correct signature
#	 and is known (these are methods that begin and end with __
## checkSpecialMethods = 1

# int: warnings for code complexity, max value before generating a warning
maxLines = 2000
maxBranches = 500
maxReturns = 100
maxArgs = 100
maxLocals = 250
maxReferences = 500

# bool:  ignore all warnings from standard library components
#	 (this includes anything under the standard library, eg, site-packages)
ignoreStandardLibrary = 1 # EKR

# list of strings: ignore unused locals/arguments if name is one of
unusedNames = [
    '_', 'empty', 'unused', 'dummy', 'event', 'commander',
    'c', 'i', 'j', 'k', 's',
    'tag', 'args', 'keys', 'keywords']

# list of strings: ignore warnings generated from these modules
blacklist = [
    'leoGlobals',
    'leoConfig',
    'leoFrame', 'leoMenu', 'leoGui', # Base classes have lots of unused params.
    'Tkinter', 'wxPython', 'gtk', 'GTK', 'GDK', ]

# list of strings: ignore global variables not used if name is one of
variablesToIgnore = [ '__all__', '__version__', '__copyright__', ]

# bool: print the PyChecker parse of modules, classes, etc.
printParse = 0

# bool: turn debugging of PyChecker on
debug = 0

# bool: check that attributes of objects exist
checkObjectAttrs = 1

# bool: various warnings about incorrect usage of __slots__
slots = 1

# bool: check if __slots__ is empty
emptySlots = 1

# bool: check for using properties in classic classes
classicProperties = 1

# bool: check for integer division (may be problem between Python versions)
intDivide = 1

# bool: check if local variables shadow a global variable with same name
shadows = 0 # EKR

# bool: check if input() is used, which is a security problem, use raw_input()
usesInput = 1

# bool: check if using a constant string to getattr()/setattr()
# Doesn't exist.
## constAttr = 1

# bool: check for using +variable, since it is almost always has no effect
unaryPositive = 1

# bool: check for modifying a parameter with a default value
#       (value must be: list, dict, instance)
#       modifying the value may have undesirable/unexpected side-effects
modifyDefaultValue = 1

# bool: check if the exec statement is used (possible security problem)
usesExec = 0

# bool: check consistent return values
checkReturnValues = 1

# bool: check if using implict and explicit return values
checkImplicitReturns = 1

# dict: suppress warnings, key is module.class.method or module.function
#	value is a string of command line arguments (can omit -- for long args)
#       { 'module1': 'no-namedargs maxlines=0',
#	  'module2.my_func': 'argsused',
#	  'module3.my_class': 'no-initreturn', }
if 1:
    suppressions = {}
else: # Doesn't work
    suppressions = {
        'leoFrame' : 'argumentsUsed=0',
        'leoGui' : 'argumentsUsed=0' }

# dict: suppress warnings where keys can be regular expressions
suppressionRegexs = {}</t>
<t tx="EKR.20040608165334.13">#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]
#Print instance variables in self
alias ps pi self

</t>
<t tx="EKR.20040608165334.14">#import user
#sys.version 
</t>
<t tx="EKR.20040608165334.15">#t04413p12:07 lint Python modules using external checkers.
    
[MASTER]
# Add &lt;file&gt; (may be a directory) to the black list. It should be a base name,
# not a path. You may set this option multiple times.
ignore=CVS

# Pickle collected data for later comparisons.
persistent=yes

# Tells wether to display a full report or only the messages
reports=yes

# Python expression which should return a note less than 10 (10 is the highest
# note).You have access to the variables errors, warnings, statements which
# respectivly contain the number of errors / warnings messages and the total
# number of statements analyzed. This is used by the global evaluation report
# (R0004).
evaluation='10.0 - ((float(5 * errors + warnings) / statements) * 10)'

# Add a comment according to your evaluation note. This is used by the global
# evaluation report (R0004).
comment=no

# Include message's id in output
include-ids=no

# checks for                                                              
#    * external modules dependancies                                            
#    * relative / wildcard imports                                                         
#    * cyclic imports                                                           
#    * uses of deprecated modules
    
[IMPORTS]
# Enable / disable this checker
enable-imports=yes

# Deprecated modules which should not be used, separated by a comma
deprecated-modules=regsub,string,TERMIOS,Bastion,rexec


# checks for :                                                            
#    * doc strings                                                              
#    * modules / classes / functions / methods / arguments / variables name     
#    * number of arguments, local variables, branchs, returns and statements infunctions, methods                                                       
#    * required module attributes                                             
#    * dangerous default values as arguments                                    
#    * redefinition of function / method / class                                
#    * uses of the global statement                                             
    
[BASIC]
# Enable / disable this checker
enable-basic=yes

# Maximum number of arguments for function / method
max-args=5

# Maximum number of locals for function / method body
max-locals=15

# Maximum number of return / yield for function / method body
max-returns=6

# Maximum number of branch for function / method body
max-branchs=12

# Maximum number of statements in function / method body
max-statements=50

# Required attributes for module, separated by a comma
required-attributes=__revision__

# Regular expression which should only match functions which do not require a
# docstring
no-docstring-rgx=__.*__

# Minimal length for module / class / function / method / argument / variable
# names
min-name-length=3

# Regular expression which should only match correct module names
module-rgx=([a-z_][a-z1-9_]*)|([A-Z][a-zA-Z]+)

# Regular expression which should only match correct class names
class-rgx=[A-Z][a-zA-Z1-9]+

# Regular expression which should only match correct function names
function-rgx=[a-z_][a-z1-9_]*

# Regular expression which should only match correct argument names
argument-rgx=[a-z_][a-z1-9_]*

# Regular expression which should only match correct variable names
variable-rgx=[a-z_][a-z1-9_]*

# Good variable names which should always be accepted, separated by a comma
good-names=i,j,k,ex

# Bad variable names which should always be refused, separated by a comma
bad-names=foo,bar,baz,toto,tutu,tata

# List of builtins function names that should not be used, separated by a comma
bad-functions=map,filter,apply,input

# checks for                                                              
#    * unused variables / imports                                               
#    * undefined variables                                                      
#    * redefinition of variable from builtins or from an outer scope            
#    * use of variable before assigment                                         
    
[VARIABLES]
# Enable / disable this checker
enable-variables=yes

# Tells wether we should check for unused import in __init__ files.
init-import=no


# checks for :                                                            
#    * methods without self as first argument                                   
#    * overriden methods signature                                              
#    * access only to existant members via self                                 
#    * attributes not defined in the __init__ method                            
#    * supported interfaces implementation                                      
#    * unreachable code                                                         
    
[CLASSES]
# Enable / disable this checker
enable-classes=yes

# List of interface methods to ignore, separated by a comma. This is used for
# instance to not check methods defines in Zope's Interface base class.
ignore-iface-methods=isImplementedBy,deferred,extends,names,namesAndDescriptions,queryDescriptionFor,getBases,getDescriptionFor,getDoc,getName,getTaggedValue,getTaggedValueTags,isEqualOrExtendedBy,setTaggedValue,isImplementedByInstancesOf

# Tells wether missing members accessed in mixin class should be ignored. A
# mixin class is detected if its name ends with "mixin" (case insensitive).
ignore-mixin-members=yes



# checks for                                                              
#    * excepts without exception filter                                         
#    * string exceptions                                                        
    
[EXCEPTIONS]
# Enable / disable this checker
enable-exceptions=yes



# does not check anything but gives some raw metrics :                    
#    * total number of lines                                                    
#    * total number of code lines                                               
#    * total number of docstring lines                                          
#    * total number of comments lines                                           
#    * total number of empty lines                                              
    
[METRICS]
# Enable / disable this checker
enable-metrics=yes



# checks for:                                                             
#    * source code with non ascii characters but np encoding declaration ( 263)                                                                     
#    * warning notes in the code like FIXME, XXX
    
[MISCELLANEOUS]
# Enable / disable this checker
enable-miscellaneous=yes

# List of note tags to take in consideration, separated by a comma. Default to
# FIXME, XXX, TODO
notes=FIXME,XXX,TODO



# checks for :                                                            
#    * unauthorized constructions                                               
#    * strict indentation                                                       
#    * line length                                                              
#    * use of &lt;&gt;
    
[FORMAT]
# Enable / disable this checker
enable-format=yes

# Maximum number of characters on a single line.
max-line-length=80

# Maximum number of lines in a module
max-module-lines=1000

# String used as indentation unit. This is usually "    " (4 spaces) or "\t" (1# tab). leave a tab here '	'
indent-string='    '
#this is a tab indent-string='	' 


</t>
<t tx="EKR.20040608165334.18">def dynaM_Clip_dtef(c, ret= 'cp'):

    """A general purpose timestamp utility.
    
    if 'p' in ret, print to the log pane.
    if 'c' in ret, replace clipboard with the time.
    """
    try:
        # Try to use custom timestamp format.
        import binaryfun
        dt = binaryfun.dtef()
    except ImportError:
        # Use Leo's default timestamp format.
        import time
        Leoconfigformat = '%m/%d/%Y %H:%M.%S'
        dt = time.strftime(Leoconfigformat) 

    if 'p' in ret: g.es('\n%s '% dt)
    if 'c' in ret: g.app.gui.replaceClipboardWith(dt)
    return dt # EKR: There is no reason not to return dt.</t>
<t tx="EKR.20040608165334.20">def dynaM_c2py(c):
    
    &lt;&lt; about dynaM_c2py &gt;&gt;
    import sys
    
    s = g.os_path_join(str(g.app.loadDir), '../scripts')

    #sc2py = g.os_path_join(s, 'c2py.py')
    if not s in sys.path:
        sys.path.append(s)

    import c2py
    mess = """\
    the current node &amp; subnodes will be changed
     and there is no undo
     """
    #g.alert(mess)  #g.app.gui
    ans = runAskYesNoCancelDialog("c2py", message= mess, yesMessage= 'ok')

    if 'ok' != ans: g.es('c2py cancled'); return

    #get selected or body... getbody language sensitive
    #write the temp

    #c2py.convertCurrentTree()  #reimports c2py but does work

    #this might fail, but want to try and set some things
    #if it reimports they might get lost...
    c2py.convertLeoTree(c.currentVnode(), c)
    
    #convertLeoTree just node walks, might pass from fixbody
    #then try and reimport to @file from that.
    
    #tmpfile should just be a basename you add extension to?
    #temp = tmpfile[:-3] + '.c'

    #c2py.convertCFileToPython(file) #another way to go

    #cmd = py + c2py + temp
    #out, err = runcmd(cmd)

#file leoTkinterGui.py
#import tkFont,Tkinter,tkFileDialog leoTkinterDialog
#class tkinterGui(leoGui.leoGui):
#when it works add some way to up the damm fonts!

def runAskYesNoCancelDialog(title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    import leoTkinterDialog
    d = leoTkinterDialog.tkinterAskYesNoCancel(
        title,message,yesMessage,noMessage,defaultButton)
    #d.configure(font=(("Lucida", "Console"), 12)) #nfg
#AttributeError: tkinterAskYesNoCancel instance has no attribute 'configure'
    #d.buttonsFrame.configure(font=(("Lucida", "Console"), 12)) #nfg
    #tryed buttonsFrame, frame, top, root...

    return d.run(modal=True)
</t>
<t tx="EKR.20040608165334.21">
def dynaM_backslash(c):
    """create a file monicur out of a path for IE or NS4
    @url file://some.bat will work, not sure with %20 can add params
    or chg forward or backslash to the other. add "'s or %20 for spaces
    dblclick on @url might not open IE for some reason
    r04212p7:05 whiped up out of my head in few mins
    editpad can't handle path with forwardslashes.
    u04509p08:56:53  cvrt to dyna, somehow need to select which...
    using copy buffer or just flip b\/f slashes
    should add 8.3 to longfilename and back
    dblbs isnt working, it want to flip bs/fs if they exist whatever else
    should probably just output the path in every way possible
    folowed by space delimited words make into valid get url
    """
    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)

    repchar = g.app.gui.getTextFromClipboard()
    if not repchar in ['/', '\\' '\\\\', ':', '|', ' ',]:
        #if nothing in copy buffer flip the back/forward slashes
        if newSel.find('/') != -1:
            repchar = '\\'
        elif newSel.find('\\') != -1:
            repchar = '/'
        elif newSel.find('~') != -1:  #could be 8.3 also
            repchar = ':'
        
    sx = []
    for x in newSel.splitlines(True):
    
        if x == '': continue
    
        #check is valid, starts with drive : and has no non printables
    
        if repchar == ':':
            s =  x.replace('\\\\','\\').replace('\\','/').replace(':','|') 
            s = s.replace(' ','%20')
            sx.append('file:///' + s)
        elif repchar == '|':
            s = x.replace('file:///','').replace('|',':').replace('/','\\') 
            s = s.replace('%20',' ')
            sx.append(s)
    
        elif repchar == '\\\\':
            sx.append(x.replace('/','\\').replace('\\','\\\\') )
    
        elif repchar == '\\':
            sx.append(x.replace('/','\\') )
    
        elif repchar == '/':
            sx.append(x.replace('\\\\','\\').replace('\\','/') )
    
        elif repchar == ' ':
            sx.append(x.replace(' ','%20') )

        else:
            #sx.append(' " ",/,\\,:, %s'%(x,) )
            g.es(' err', x)
        
        g.es(' repchar= %r x=%r'%(repchar,x) )
        dynaput(c, sx)


#
#by pass while in plugin,
# for testing while included in dynatester node
#
if __name__ != 'dyna_menu':
    try:
        __version__
    except NameError:  
        def testbs():
            #some test paths , better encapsulation
            lst= r"""
            L:\\c\\Python22\\Doc\\lib\\modindex.html
            L:\c\Python22\Doc\lib\modindex.html
            C:/TEMP/leo/leo4CVS/plugins/mod_rclick.py.txt
            L:\c\Progr\leo-3.7\info\doc\ASPN
            file://L|/c/Progr/leo-3.7/info/doc/ASPN
            """.splitlines(True)
            lst =  [x.lstrip() for x in lst]
            return lst

        #need to have a better way to run all the lines
        # (cbuf, input, expected output)
        #need way to get something into the copy buffer 
        genteststr.tstlst = testbs()
        testmacro = 'dynaM_backslash'
</t>
<t tx="EKR.20040608165334.22">
def dynaM_geturls(c):
    '''extract all urls from selected text. included som extra text.
    doesnt span line endings. misses any number of other mal formed urls.
    might use some ideas from the extend rclick post on sf.
    not 100% reliable and not intended to be the last word in re use.
    reconstruction of the found url is at this point just exploratory.

    testing in redemo, modifyed to include rClickclass 
    and multiline text for re's instead of single line entry.
    kodos works too, but always seeems a little less reliable

    some might want the ability to open the default browser with the url
    thats best let to another plugin or macro or could optionally
    add it to the clipboard which there isnt a clean way to do yet.
    '''
    newSel = dynaput(c, [])
    if not newSel: return
    data = str(newSel)

    import re

    #from leo
    # A valid url is (according to D.T.Hein):
    # 3 or more lowercase alphas, followed by,
    # one ':', followed by,
    # one or more of: (excludes !"#;&lt;&gt;[\]^`|)
    #   $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
    # followed by one of: (same as above, except no minus sign or 
    # comma).
    #   $%&amp;'()*+/0-9:=?@A-Z_a-z}~
    #thers problems with this, I forget what just now.
    #
    #http etc from rClick plugin extension idea posted to leo forum, works
    #scan_url_re="(http|https|ftp)://([^/?#\s]*)([^?#\s]*)(\\?([^#\s]*))?(#(.*))?"
    #re.sub(scan_url_re,new_url_caller,text)  #leaves out a few types
    #
    #r04422a05:03:35 mine still doesnt match everything, and doesnt submatch as well
    #w04519p05:58:10 make a try at verbose,
    #shold relax it from expecting perfect links
    

    #leaves out a few types
    # excluding all invalid chars is always for security &amp; sanity
    # worse than including all valid chars, there will be ommisions
    scan_url = r"""
   (http|https|ftp|ftps|gopher|link|file|ur[il])(://)
    ([_0-9a-z%]+?
    @?
    [_0-9a-z%]+?:?)  #takeing some liberties
    ([^/?#\s"']*)
   ([^?#\s"']*)
    (\?*[a-z0-9, %_.:+/-~=]*)
    (\#*[a-z0-9, %_.:+/-~=]*)  #lookup exact name ref link standard
     (&amp;*[a-z0-9, %_.:+/-~=]*)  #needs work
     ([^"&lt;'&gt;\n[\]]*)  #catch the rest till learn repeat
 #   (#|&amp;*[^&amp;?]*.*)
    """
    #(\?*[^&amp;#"'/&gt;\\]*[a-z0-9, %_-~]*?)
    #(\?([^#\s]*?))  #this is doubling the params
    #(&amp;(.*)*?)
    #(#(.*)*?)  
    #end game, this fails
    #urllib.unquote_plus( urllib.quote(

    scan_url_re = re.compile(scan_url, re.IGNORECASE | re.MULTILINE | re.VERBOSE)
    ndata = scan_url_re.findall(data)  #leaves out :// and /
    sx = []
    if ndata:
        g.es('just urls:')
        for x in ndata:
            if not x: continue
            sx.append( ''.join(list(x)) + '\n')
            #note, this can totally screw things up...
    else: g.es('no urls')  #, data

    dynaput(c, sx)


#
#by pass while in plugin,
# for testing while included in dynatester node
#
if __name__ != 'dyna_menu':
    try:
        __version__
    except NameError:  
    
        def testbs():
            lst = ["""\
http://uid@pw/adwords.google.com//http://www-106.ibm.com/""", """\
windows are.&lt;/SPAN&gt;&lt;BR&gt;&lt;BR&gt;[&lt;A target=_blank 
href="http://www.geoshell.com/plugins/zoom.asp?id=244"&gt;download&lt;/A&gt;] [&lt;A 
target=_blank href="http://docs.geoshell.com/R4/GeoXWM"&gt;documentation&lt;/A&gt;] 
&lt;/DIV&gt;""", """\ http://www-106.ibm.com/search/searchResults.jsp?searchType=1&amp;searchSite=dW&amp;query=python&amp;searchScope=dW&amp;Search.x=0&amp;Search.y=0
    https://adwords.google.com/support/bin/topic.py#topi
    https://adwords.google.com/support/bin/topic.py?topic=102
        href="http://www-106.ibm.com/developerworks/css/r1.css" type="text/css"/&gt;')
        else if ((navigator.userAgent.indexOf("X11"))!= -1) 
             """] 
            #print 'lst =', lst
            return lst
    

        genteststr.tstlst = testbs()
        testmacro = 'dynaM_geturls'
</t>
<t tx="EKR.20040608165334.24">def dynaM_dump_body(c, ret= 'p'):
    """yadayada call hexdump, on selected text or body
      if you need need an exact output, including any lineendings?
      Leo translates to unicode first so that might be relevant
      calls dynaHexdump(src, length=8)

UnicodeDecodeError: 'ascii' codec can't decode byte 0x9f in position 1: ordinal not in range(128)
since its not a char at a time, this is going to be hard to trap
maybe will have to filter first. 
need feedback from someone who cares about unicode.
    """

    data = dynaput(c, [])
    g.es("selected ")
    if not data:
        g.es("...skip, dump the body")
        v = c.currentVnode() # may chg in 4.2
        data = v.bodyString()

    if data and len(data) &gt; 0:
        #newdata = re.sub("\n", "\r\n", data)
        newdata = dynaHexdump(data)
        if newdata != data:
            #v.setBodyStringOrPane(newdata)
            if 'p' in ret: g.es(newdata)
            if 'r' in ret: return newdata

#had to unicode the FILTER for Leo plugin use
FILTER= u''.join([(len(repr(chr(x)))==3) and chr(x) or '.' for x in range(256)])

def dynaHexdump(src, length=8):
    """
    m02A14p6:31 ASPN Python Cookbook
    Title: Hexdumper.py  Submitter: S?stien Keim  2002/08/05 Version no: 1.0
    Hexadecimal display of a byte stream
    later, output to logwindow of selected text add as a menu option
    maybe can make it read from a file and output as hex
    #r04408ap11:16 chg += to append &amp; join,  not that its particularly slow
    &gt;&gt;&gt; Hexdump('ASPN Python Cook')
    &gt;&gt;&gt; #Hexdump('01')
    '0000   41 53 50 4E 20 50 79 74    ASPN Pyt\n0008   68 6F 6E 20 43 6F 6F 6B    hon Cook'
    """
    N = 0; result = []
    while src:
        s, src = src[:length], src[length:]
        hexa = ' '.join(["%02X"%ord(x) for x in s] )
        s = s.translate(FILTER)
        result.append("%04X   %-*s   %s  % 3dd" % (N, length * 3, hexa, s, N) )
        N += length
    return '\n'.join(result)</t>
<t tx="EKR.20040608165334.28">def dynaM_linenumber(c):
    """show selected text or body as leo sees it, 
    numbering lines or if there is an integer in copybuffer,
     show just +- a few lines around that number.
    syntax errors, indentation errors ,  missing closing paren
    missing colon ':'  in def, if, class
    the actual error can be ahead or behind of the reported error line.
    often at the top of the block contining the error.
    sometimes a symptom is an undefined identifyer that looks fine.
    you have to trust what you know, otherwise you will change
    10 things before you get to the point of the error. bad instinct
    at this point to change too many things. you still arent going
    to see the effect of the change untill the origional error is fixed.
    in the cut paste and retry programming that I often do, its
    best to change only very few things and make sure you will see 
    the effect of the change while you're looking for it.
    and that the change will be tested with some part of the test 
    or an assert if you don't run -OO as you shouldent do while testing.
    that -OO also limits the docstrings you get from help.
    watch the actual line endings. very often while pasteing
    you can inadvertantly have one line in a texteditor that wraps
    and lineup the indentation after the paste not realizing
    its a line continued from the previous paste. 
    blank lines can be suspect too as they might have an odd number
    of spaces. show invisables or run that section thru reindent.

    pass, often needed if you comment out the only live statemts
     in a try/except or if/else block

    these can eat up much time and cause frustration for simple mistakes.
    you have to debug from the top of the file to the bottom.
    python wont evaluate something till it gets there. but, there
    must be no syntax errors anywhere. sometimes it helps to break
    down step by step line by line what you think will happen.
    actually describing what will happen sometimes makes errors obvious.
    a voice synthisizer here might even work. many bugs are that simple.
    
    properly formated python (to your mind) helps to point out
    statements and expressions that might be in error.
    luckily most indentation errors are syntax errors 
    rather than logic errors which would be orders of magnitiute
    harder to catch and laying in wait as latent bugs to trouble you later.
    if you indeed ever did catch them. 
    this is why the focus on unittests, coverage tools pychecker etc.
    which only can help if the file can be imported.
    hence my focus on evaluator using some of the techniques in pychecker2.
    
    run the code thru reindent wont always fix the problem.
    but its a good first step and is why the macros that run pychecker
    run thru reindent first. you can paste over the copy of your program
    or those sections that are troubling. 
    dont mix tabs and spaces. Edit -&gt; Edit Body -&gt; convert all tabs.
    a hexdump of the offending section sometimes will turn up
    a control code or other line ending problem.
    personally I never use tabs and always use unix lineendings 0x0A,
    unless its a bat file which requires 0x0D0A.
    the other editor I use is EditPad which transparently writes
    in the same lineendings as the file has to begin with,
    you can move EditPad to notepad and windows will use it.
    

   seperate multiple statements/expressions on their own line.
   use temp variables to simplify and make readable complex expressions
   you can always reoptomixe it back to gibberish later.

    its misplaced brain power to force too many mental caviets while
   you are trying to debug a section of code. one of the things I
   most was surprized at when I began learning python comming from
   c and javascript as my first and 2nd language, was how much I
   was depending on the preprocesser for macros to simplify code.
   and optomizations like in javascript and still usefull 
   in python of making a temporary bind to localize globals.
   La = L.append  # sppeds up access inside a loop
   what you foget when you go overboard and code first in this way
   is that it is so often in parts of code that dont get excercized
   much where the errors are. all the premature optomization does
   is leave the code un readable for later maintance and debugging.
   I totally under estimated the amount of extra work it takes to
   lookup all these little code shortcuts later when you have to change
   something. there must be a more concice way to say that.


    turn on Leos Edit -&gt; show invisables command
    actually derive a file and look at it
    add @file whatever.py or whatever.ext 
    write @file and get an eye on it.

   extract section to further localize the error.
   turn a section of code into a function or method, this
   will often expose a depandance on a global that is wrecking havock.


   try to create something that will repeat the error, in 
   the smallest possible amount of text. then report it.
   the process of simplification will often provide the answer.


   finally, and as a very, very last resort, blame the tools.
   might be something in how Leo derives file 
   or even how python is parsing it.
   take a break, sleep on it. read a few cookbook recipies,
   ask someone else to look at the code with fresh eyes.

   its entirely possibly the current algorythm will be suuperceeded
   by firther reseach anyway, why wait. don't sweat the small stuff.
   rip out the offending code and substitute some black box data 
   returned by a stub and press on, 
   endless debugging can be its own reward. like sand castles.

    Leo's goto linenumber works from the derived @file
    fixbody uses similar calls to find its line numbers.
    note: in some cases 
    some forms of fixbody with nothing selected 
    will strip out Leo @directives rather than comment them out.
    this will become fully consistant in the the future.
    you know, the future where all the bugs are easy to describe.
    you should expect at least one anomaly per 100 lines of code.
    
    it maybe that Edit-&gt; gotolinenumber can never be correct because
    execute script strips the @directives. derived files comment them.
    
    further enhnacement, keep track of last section ref node
    last def last method of last class and output all the lines together
    rather than one a a time which can tie up Leo on long programs.
    should output current path and language and wrap to current wrap
    -n +n could be under/over the abs(int) in copy buffer

    could make it jump to linenumber based on env variable
    that way you wouldent have to remake the plugin to change behaviour
    several other macro also could use settable params at ex script time.

    might be a bit much for a docstring    
    """

    newSel = dynaput(c, [])
    data = fixbody(newSel, c)   
    datalines = data.splitlines()

    pln = g.app.gui.getTextFromClipboard()
    try:
        pln = int(pln)
        g.es('using line # %d'%(pln,), color= 'tomato')
    except Exception, err:
        g.es('invalid int(copy buffer)', color= 'tomato')
        pln = 0
        
    for i, x in enumerate(datalines):
        if pln and i &lt; (pln - 5): continue
        if pln and i &gt; (pln + 5): break

        #would rather not go thru this every time thru the loop
        if pln and i == pln:
            colr = 'gray'
        else: 
            colr = 'slategray'

        g.es('%- 3d '%(i,), newline= False, color= colr)

        g.es('%s'%(x,))

#</t>
<t tx="EKR.20040608165334.29">
def dynaM_makatemp(c):
    '''create a file and lightly test it.
     default to a tmp filename
     if copy buffer has a valid path like name, use that
     take the selected text or body (eventually @other &amp; section ref too)

     write out the file and run it thru reindent then pychecker
     or maybe what is wanted is to take from the copy buffer
     makeatemp and run it thru pychecker then create a subnode with it
     usecsae, posting from c.l.py or from other artical
     handling @directives, not @others nor section nodes yet.
     

  for some reason only the @ is getting thru from exS in dynatest
  the re isnt commenting them out either. I HATE re's
  doh, comedy of errors again. forgot the * after .
  was testing date instead of data, misnamed single use varb.
  generated new macro idea to scan for those mistakes.

  have to tell it to skip from @ to @c as well
  
  the name verifyer re isnt workring yet. not fully implimented
  
  
  external pychecker still has a problem resolveing from import leo*
  not sure how to resolve that. 
  maybe import pythecker.pychecker in the macro?
  wpp[s, this whole thing is breaking down. I forgot one other thing
  the import phase will cause the code to be run. this may or may not be a problem,
  adding a name == main if one doesnt exist might be better
  \nif __name__ == '__main__': pass
  which wont help unless all the indentation on executable lines are indented
  that is too much work I think.
  checking selected text or filenames of generated modules still usefull
  pylint still complaining it cant find the py in temp in sys modules
  may have to dig deeper into that as well
  adding tempdir where the file is doesnt seem to be enough for pylint

  tryed a bunch more things. pychecker works, nearly got pylint.
  pychecker still balks on leo* stuff 
  so checking plugins would have to add import pychecker; pychecker.pychecker()?
  
    have to abstract the get path thing out to return a tuple of 
    leo, python, scripts, site-packages
    so all macros can find and user only has to change one place
    

  using expandtabs(4)
  ***************
    warning, this makes asumptions about where python is, 
    what and where reindent and pychecker is
    at least you have to edit in your correct paths.
    I could guess more but still wouldent be totally sure.
    see the .rc file usefull for pychecker in leoPy.leo
    pylint the same thing.
    url's ...

    I have no idea if pychecker is safe to run on insecure code
    it will create a py and pyc or pyo and maybe a bak file in tmp
    hold me harmless or delete this now.
  ***************
  all paths below are woefully hardwired, you must edit them all.
  you may have to download pychecker and or pylint and install it too.
    '''
    #1no print, reindent to create tmp then pychecker on that tmp
    justPyChecker = 1


    newSel = dynaput(c, [])
    data = fixbody(newSel, c)

    if not data or len(data) == 0: 
        return

    tmpname = tmpfile #global or from copybuffer

    import re, os, sys
    import leoTkinterDialog as lTkD



    #you might not have to fix leo/src either
    #better to get basepath or something, look it up later
    #one run and its in sys.path, sys.path is global for all leo's?
    #another append will be twice in there
    #Leo prepends its src dir but pychecker isnt finding it.

    #this could be trouble on nix or mac. YOYO
    #might not even be necessary in the app, maybe some other
    if sys.platform[:3] == 'win':
        
        oldpPath = os.environ['PYTHONPATH']
        oldpSath = sys.path
        #these changes will be compounded at every run of the script

        if not leosrc in sys.path:
            sys.path.append(leosrc)

        if not os.path.split(tmpname)[0] in sys.path:
            sys.path.append(os.path.split(tmpname)[0] )
        
        #Leo may have already zero this out to just path of python.

        try:
            if not leosrc in os.environ['PYTHONPATH']:
                os.environ['PYTHONPATH'] = os.environ['PYTHONPATH'] + \
                    ';' + leosrc

        #[py2.2 :'in &lt;string&gt;' requires character as left operand
        except TypeError:
            pass

        #g.es(sys.path )
        #g.es(os.environ['PYTHONPATH'] )

    elif sys.platform[:5] == 'linux':
        pass
    
    #print lTkD.tkinterAskYesNoCancel(tmpname)

    #pylint has to be able to import the file on sys.path?
    #pychecker seems to be able to import from the filename arg
    #pychecker can find it now and does report ok if no leo* stuff in there
    #it can import the leo* ok just not resolve from what I can tell.


    #pylint = r'\Tools\scripts\pylint.bat ' 
    #have to create a py the win version ships with a bat
    #was Run(sys.argv[1:])
    #Exception: Unable to find module for C:\WINDOWS\TEMP\tmptest in C:\c\leo, 
    #Leo doenst send the sys we are hacking on above to the exec?
    #think I realized this once before and didnt know how to solve it.
    #think pylint can only handle modules, so dup filenames will be  problem
    #if its expecting sys.arg maybe a list?
    #F:  0: Unable to load module tmptest (No module named tmptest)
    #temp is in sys.path so why it refuses to load I have no idea




    #valid name consists of many more chars on win and nix
    #I may never use this, but will continue testing
    re_testname = re.compile(
    r"""
\s*
([a-zA-Z0-9]*?)
(:?)
(/|\\\\*[a-z]*?[a-zA-Z0-9_\s]*?)  #this needs to repeat however many times
(\.*?)
([a-zA-Z0-9_\.\s]*?)
\s*
""", re.VERBOSE )  

    #g.es('data is %r'%(data,) )

    #raise SystemExit  maybe dangerous inside Leo tho was ok.
    #e32 = r34   #works as an error to stop execution too

    name = g.app.gui.getTextFromClipboard()
    #if name:
    #    print re_testname.search(name).groups()

    g.es('writeing tmpname', tmpname )
    fo = file(tmpname,'w')
    fo.writelines(data + "\n#e\n")
    fo.close()
    
    g.es('running reindent', py + reindent + tmpname )
    out, err = runcmd(py + reindent + tmpname)
    for x in (out + err).splitlines():
        g.es(x)
        
    g.es('running pychecker', py + pycheck + tmpname )
    out, err = runcmd(py + pycheck + tmpname)
    for x in (out + err).splitlines():
        g.es(x)

    if dopylint:
        pylname = os.path.split(tmpname)[1][:-3] #cut off .py
        g.es('pylint module', pylname )
        pylint = \
        " -c \"import sys; from logilab.pylint import lint;\
                   lint.Run([r\'%s\',])\" "%(pylname,)

        g.es('running pylint', py + pylint )
        out, err = runcmd( py + pylint)
        for x in (out + err).splitlines():
            g.es(x)
    
    if not justPyChecker:
        g.es('#source for ', tmpname, color='blue' ) 
        TextFile = file(tmpname)
        Text = TextFile.read()
        TextFile.close()
        g.es(Text)
    
    #should be restored even if error. oh well
    if sys.platform[:3] == 'win':
        
        os.environ['PYTHONPATH'] = oldpPath
        sys.path = oldpSath  #Leo discards this?

    g.es('done ', color='blue' ) 

#
#by pass while in plugin,
#this for testing while included in dynatester node
#
if __name__ != 'dyna_menu':
    try:
        __version__
    except NameError:  
    
        lst = """\
        
@language python
@tabwidth -4

import leoGlobals as g

try: import Tkinter as Tk
except ImportError: Tk = None

import string

#@+others     C:/TEMP/leo/leo4CVS/plugins/mod_rclick.py
    L:\\c\\Python22\\Doc\\lib\\modindex.html
    L:\c\Python22\Doc\lib\modindex.html
    """  #.splitlines(True)
        #lst =  [x.lstrip() for x in lst]
        genteststr.tstlst = lst
        testmacro = 'dynaM_makatemp'</t>
<t tx="EKR.20040608165334.30">
def dynaM_pycheck2(c):
    '''this takes a long time 
    and leave a 2+meg file CACHE_FILE = '/temp/t'  in pychecker2/main.py
 have to modify the dump line chg 0 to -2, highest proto supported auto

    needs a progressbar, Leo will wait till its done, so will you.
    takes over 2 mins on pII300 on a simple Tk program of about 50k.
    pycheck2 doesnt import or compile the file first,
    so it is safer to use on untrusted code or code with sideeffects.
    it should also work regardless if the file is in sys.path .
    runs thru reindent first as a rough syntax error test.
    install pychecker from the source, move pychecker2 dir to site-packages
    and fix the path in common for pycheck2
    this is also self described IIR experimental so dont expect miricals
    it might even Traceback or crash. though it hasn't crashed for me, 
    has at least found unused vars. its no pychecker.
    not sure if it uses the same rc file as pychecker.
  seems not to be able to find leoglobals at all
  seems to check problems in modules not even related
  console, win32con pyreadline, ctypes. not sure whats going on there


ImportError: No module named IterableUserDict
 might have to get cvs version. first run a cpickle is left in /temp/t
 2nd run it will fail. didnt notice this before. could delete it
 could chg to text instead of binary which has failed for me before
 also could try pickle instead of cpickle

     checker = cPickle.load(open(CACHE_FILE, 'rb')) 
     chg dump protocall from 1 to 0 didnt help, douled size of file
import cPickler; print cPickle.__doc__
 have to modify the dump line chg 0 to -2, highest proto supported auto
 now cache file is only 50k 
 and doesnt error on 2nd run 
 and is quite a bit faster.
  but after a few runs it came back, going to have to del the t
    '''
    #1no print, reindent to create tmp then pychecker on that tmp
    justPyChecker = 1
    CACHE_FILE = '/temp/t'  #defined in pychecker2.main

    newSel = dynaput(c, [])
    data = fixbody(newSel, c)

    if not data or len(data) == 0: 
        return

    tmpname = tmpfile #global or from copybuffer later

    import os
    try:
        os.remove(CACHE_FILE)
        pass
    except Exception:
        pass

    g.es('writeing tmpname', tmpname )
    fo = file(tmpname,'w')
    fo.writelines(data + "\n#e\n")
    fo.close()
    
    g.es('running reindent', py + reindent + tmpname )
    out, err = runcmd(py + reindent + tmpname)
    for x in (out + err).splitlines():
        g.es(x)

    #see if this works, dyna_menu. didnt, maybe g.dyna_menu., lg.?
    #pristine enviorment?
    #g.dyna_menu.dynaM_Clip_dtef(c, ret= 'p')  #rough timestamp
    g.es(' be paitent,\n can take several minutes')
    g.es('running pychecker2', py + pycheck2 + tmpname )
    out, err = runcmd(py + pycheck2 + tmpname)
    for x in (out + err).splitlines():
        g.es(x.replace(tmpname, tmpname[-10:]))
    
    
    if not justPyChecker:
        g.es('#source for ', tmpname, color='blue' ) 
        TextFile = file(tmpname)
        Text = TextFile.read()
        TextFile.close()
        g.es(Text)
    

    g.es('done ', color='blue' ) 
</t>
<t tx="EKR.20040608165334.31">
def dynaM_tim_one_crunch(c):
    '''
    #t04504p10:05:08 bit of old code from tim peters gooogle, 
    had to un-htmlify it, then uu.decode it. quite a PITA.

    riped code from makatemp to preprocess the selected text or body
    hardwire write a file then see how many single use varbs there are
    it generates alot of false positives
   try the bugfix, slightly more complicated in a later post
   double check the name polution, uses regex and string too
   woh, was not going to work or needs some updateing.
   use the old crunch for now. better than nothing when trouble starts.
    need to finish the code to use a filename instead of writeing a new temp
    that will be usefull for pychecker &amp; pylint too.
    its alot faster than you would think too 
    parse &amp; create a tmpfile, crunch parse it and display the results.
    on few page bodys, I can barely get off the button and its done.
    might run the makatmp first to create the file and just parse it with this
    rather than pulling in the reindent call. few more lines, what the hell
    reindent doesnt fix to standard indentation. why do I keep thinking it does?
    have to wait till the last few bugs worked out of evaluator.
    could use to test against known methods and modules in use by the code
    could reduce the false positives.
    if you make the same mistake twice, its no longer unique. is that caught?

    try compile as a way to verify code will import? is it safe?
    why doesnt it just pass the data directly to StringIO unless it is a filename?
    OTOH, reindent proves the thing has correct syntax so may as well keep it
  using the bugfix version now, patched in import keyword
   added dir(list,dict from the older version
   commented out __modules__ __builtins__ for now
   building a more complete keyword list is the holy grail
   of autocomplete and debuggers and code evaluators of all kinds.



    Tim Peters tim_one@msn.com    Thu, 27 Feb 97 09:00:30 UT 
 ----
    Attached is a Python program that reports identifiers used only once in a .py (text) file, except for keywords, builtins, and methods on dicts &amp; lists (&amp; the way to expand that set should be obvious). 
    This is much dumber than the other approaches on the table, but has the clear advantage that it's written &lt;wink&gt;, and catches things like "bound but never used" (including-- and this is a mixed blessing! --functions &amp; classes defined but not referenced in their file). 
        '''
    #1no print, reindent to create tmp then checker on that tmp
    justPyChecker = 0


    newSel = dynaput(c, [])
    data = fixbody(newSel, c)

    if not data or len(data) == 0: 
        #here check copybutffer for valid filename

        return

    tmpname = tmpfile #global or from copybuffer

    g.es('writeing tmpname', tmpname )
    fo = file(tmpname,'w')
    fo.writelines(data + "\n#e\n")
    fo.close()
    
    g.es('running reindent', py + reindent + tmpname )
    out, err = runcmd(py + reindent + tmpname)
    for x in (out + err).splitlines():
        g.es(x)

    o = file(tmpname)
    so = StringIO.StringIO(o.read())
    o.close()

    #made a caller to hide some of the globals
    Bugfixcrunch(so.readline)
    
    if not justPyChecker:

        g.es('#source for ', tmpname, color='blue' ) 
        
        so.seek(0, 0)
        #.read() and .readlines() doubled up because of \n\r on win
        for x in so.getvalue().splitlines(True):
            g.es(x, newline= False)
    g.es('done ', color='blue' ) 


#</t>
<t tx="EKR.20040608165334.32">
def Bugfixcrunch(getline):
    """u04523p12:01:20  madifying use of globals with 
    calling functions bfcrunch embeded
    the origional crunch has alot of false positives
    
    &gt;Bugfix (RE: Patch to Tim Peters python lint)&lt;/H1&gt;
     &lt;B&gt;Tim Peters&lt;/B&gt; &lt;A HREF="mailto:tim_one@msn.com"
     TITLE="Bugfix (RE: Patch to Tim Peters python
     lint)"&gt;tim_one@msn.com&lt;/A&gt;&lt;BR&gt; &lt;I&gt;
     Wed, 5 Mar 97 05:14:38 UT
      I'll agree to fix errors in the hard-core parsing crap (&amp;
     there are at least  &lt;/I&gt;&lt;BR&gt;&lt;P&gt; &lt;BR&gt;&gt;&lt;i&gt; two more
     (small &amp; unlikely) holes that I know of ...
     &lt;/I&gt;&lt;BR&gt;&lt;P&gt; Ya, ya, ya.  One of them was this: &lt;P&gt;
     &lt;BR&gt;&gt;&lt;i&gt; [anonymous nagger &lt;wink&gt;] &lt;/I&gt;&lt;BR&gt;&gt;&lt;i&gt;
     &lt;/I&gt;&lt;BR&gt;&gt;&lt;i&gt; LABEL = "\ &lt;/I&gt;&lt;BR&gt;&gt;&lt;i&gt; &lt;/I&gt;&lt;BR&gt;&gt;&lt;i&gt;
     (that is, a quote followed by a backslash followed by
     a newline) &lt;/I&gt;&lt;BR&gt;&gt;&lt;i&gt; seems to cause an infinite
     loop... &lt;/I&gt;&lt;BR&gt;&lt;P&gt; More, *any* unclosed uni-quoted
     string fell into that loop -- continued  uni-quoted
     strings are a feature of Python I never used, so was
     blind to the  possibility at first; then conveniently
     convinced myself nobody else used that  misfeature
     &lt;wink&gt; either so I could ignore it.  I lose! &lt;P&gt;
     Attached version fixes that by treating uni-quoted
     and triple-quoted strings  pretty much the same
     (although the former have more-irksome rules to
     check, so  are messier). &lt;P&gt; Too busy to have
     incorporated other suggestions yet. &lt;P&gt; What else?
     Yup:  the current regex implementation is known to
     commit blunders  of various sorts when passed "very
     long" strings, &amp; I've already done all I  can to
     avoid that.  If you have Python source with multi-
     hundred character  lines, things may not work, and if
     so that won't get fixed soon.  Parsing a  character
     at a time would work, but would be so much slower the
     tool wouldn't  get used; while speed isn't crucial
     here, a gross slowdown is unacceptable. &lt;P&gt; 
    sez-me-anyway-ly y'rs  - tim &lt;P&gt; Tim Peters    &lt;A
     HREF="mailto:tim_one@msn.com"&gt;tim_one@msn.com&lt;/A&gt;, &lt;A
     HREF="mailto:tim@dragonsys.com"&gt;tim@dragonsys.com&lt;/A&gt;
     not speaking for Dragon Systems Inc."""

    [NOTE, CAUTION, WARNING, ERROR] = range(4)
    _level_msg = ['note', 'caution', 'warning', 'error']

    # The function bound to module vrbl "format_msg" defaults to the
    # following, and is used to generate all output; if you don't
    # like this one, you know what to do &lt;wink&gt;.
    
    def _format_msg(
          # the error msg, like "unique id"
          msg,
    
          # sequence of details, passed thru str &amp; joined with
          # space; if empty, not printed
          details = (),
    
          # name of source file
          filename = '???.py',
    
          # source file line number of offending line
          lineno = 0,
    
          # the offending line, w/ trailing newline;
          # or, if null string, not printed
          line = '',
    
          # severity (NOTE, CAUTION, WARNING, ERROR)
          level = CAUTION ):
        try:
            severity = _level_msg[level]
        except:
            raise ValueError, 'unknown error level ' + `level`

        g.es('%(filename)s:%(lineno)d:[%(severity)s]' % locals() )
        if details:
            from string import join
            g.es("%s:" % msg, join(map(str, details)) )
        else:
            g.es(msg)
        if line:
            g.es(line)
    
    format_msg = _format_msg
    
    # Create sets of 'safe' names.
    import sys

    _system_name = {}   # set of __xxx__ special names
    for name in """\
          abs add and
          bases builtins
          call class cmp coerce copy copyright
          deepcopy del delattr delitem delslice
              dict div divmod doc
          file float
          getattr getinitargs getitem getslice getstate
          hash hex
          init int invert
          len long lshift
          members methods mod mul
          name neg nonzero
          oct or
          pos pow
          radd rand rdiv rdivmod repr rlshift rmod rmul ror
              rpow rrshift rshift rsub rxor
          self setattr setitem setslice setstate str sub
          version
          xor""".strip().split():
        _system_name['__' + name + '__'] = 1
    _is_system_name = _system_name.has_key

    import keyword
    
    _keyword = {}   # set of Python keywords
    for name in keyword.kwlist + ['as', 'str'] + dir(__builtins__) + \
            dir(list) + dir(dict):
        _keyword[name] = 1

    #builtins isnt the same from exec as from script outside Leo
    #maybe import builtins? same with methods if it even exists

    _builtin = {}   # set of builtin names
    """for name in dir(__builtins__) + sys.builtin_module_names:
        _builtin[name] = 1
    """
    _methods = {}   # set of common method names
    """for name in [].__methods__ + {}.__methods__:
        _methods[name] = 1"""
    
    _lotsa_names = {}   # the union of the preceding
    for dct in (_system_name, _keyword, _builtin, _methods):
        for name in dct.keys():
            _lotsa_names[name] = 1
    
    #del sys, name  #, dct string,  dict


    
    # Compile helper regexps.
    import regex
    
    # regexps to find the end of a triple quote, given that
    # we know we're in one; use the "match" method; .regs[0][1]
    # will be the index of the character following the final
    # quote
    _dquote3_finder = regex.compile(
        '\([^\\\\"]\|'
        '\\\\.\|'
        '"[^\\\\"]\|'
        '"\\\\.\|'
        '""[^\\\\"]\|'
        '""\\\\.\)*"""' )
    _squote3_finder = regex.compile(
        "\([^\\\\']\|"
        "\\\\.\|"
        "'[^\\\\']\|"
        "'\\\\.\|"
        "''[^\\\\']\|"
        "''\\\\.\)*'''" )
    
    # regexps to find the end of a "uni"-quoted string, given that
    # we know we're in one; use the "match" method; .regs[0][1]
    # will be the index of the character following the final
    # quote
    _dquote1_finder = regex.compile( '\([^"\\\\]\|\\\\.\)*"' )
    _squote1_finder = regex.compile( "\([^'\\\\]\|\\\\.\)*'" )
    
    # _is_junk matches pure comment or blank line
    _is_junk = regex.compile( "^[ \t]*\(#\|$\)" ).match
    
    # find leftmost splat or quote
    _has_nightmare = regex.compile( """["'#]""" ).search
    
    # find Python identifier; .regs[2] bounds the id found;
    # &amp; it's a decent bet that the id is being used as an
    # attribute if and only if .group(1) == '.'
    _id_finder = regex.compile(
        "\(^\|[^_A-Za-z0-9]\)"  # bol or not id char
        "\([_A-Za-z][_A-Za-z0-9]*\)" ) # followed by id

    #del regex, keyword
    &lt;&lt; bfcrunch &gt;&gt;

    bfcrunch(getline, filename= 'exS')

</t>
<t tx="EKR.20040608165334.33">
def bfcrunch(getline, filename='???.py' ):
    # for speed, give local names to compiled regexps
    is_junk, has_nightmare, id_finder, is_system_name = \
        _is_junk, _has_nightmare, _id_finder, _is_system_name

    end_finder = { "'": { 1: _squote1_finder,
                          3: _squote3_finder },
                   '"': { 1: _dquote1_finder,
                          3: _dquote3_finder }
                 }

    multitudinous = {}  # 'safe' names + names seen more than once
    for name in _lotsa_names.keys():
        multitudinous[name] = 1

    trail = {}  # maps seen-once name to (lineno, line) pair
    in_quote = last_quote_lineno = lineno = 0
    while 1:
        # eat one line
        where = lineno, line = lineno + 1, getline()
        if not line:
            break
        if in_quote:
            if in_quote.match(line) &lt; 0:
                # not out of the quote yet, in which case a uni-
                # quoted string *must* end with a backslash
                if quote_length == 3 or (len(line) &gt; 1 and
                                         line[-2] == '\\'):
                    continue
                format_msg( "continued uni-quoted string must \
end with backslash",  # making this line its own test case &lt;wink&gt;
                            filename=filename,
                            lineno=lineno,
                            line=where[1],
                            level=ERROR )
                # the source code is so damaged that more
                # msgs would probably be spurious, so just
                # get out
                return
            # else the quote has ended; get rid of everything thru the
            # end of the string &amp; continue
            end = in_quote.regs[0][1]
            line = line[end:]
            in_quote = 0
        # get rid of junk early, for speed
        if is_junk(line) &gt;= 0:
            continue
        # awaken from the nightmares
        while 1:
            i = has_nightmare(line)
            if i &lt; 0:
                break
            ch = line[i]    # splat or quote
            if ch == '#':
                # chop off comment; and there are no quotes
                # remaining because splat was leftmost
                line = line[:i]
                break
            else:
                # a quote is leftmost
                last_quote_lineno = lineno
                quote_length = 1  # assume uni-quoted
                if ch*3 == line[i:i+3]:
                    quote_length = 3
                in_quote = end_finder[ch][quote_length]
                if in_quote.match(line, i + quote_length) &gt;= 0:
                    # remove the string &amp; continue
                    end = in_quote.regs[0][1]
                    line = line[:i] + line[end:]
                    in_quote = 0
                else:
                    # stuck in the quote, but anything
                    # to its left remains fair game
                    if quote_length == 1 and line[-2] != '\\':
                        format_msg( 'continued uni-quoted string \
must end with backslash',
                                    filename=filename,
                                    lineno=lineno,
                                    line=where[1],
                                    level=ERROR )
                        # the source code is so damaged that more
                        # msgs would probably be spurious, so just
                        # get out
                        return
                    line = line[:i]
                    break

        # find the identifiers &amp; remember 'em
        idi = 0     # index of identifier
        while 1:
            if id_finder.search(line, idi) &lt; 0:
                break
            start, idi = id_finder.regs[2]
            word = line[start:idi]
            if multitudinous.has_key(word):
                continue
            if trail.has_key(word):
                # saw it before; don't want to see it again
                del trail[word]
                multitudinous[word] = 1
            else:
                trail[word] = where
                if word[:2] == '__' == word[-2:] and \
                   not is_system_name(word):
                    format_msg( 'dubious reserved name',
                                details=[word],
                                filename=filename,
                                lineno=where[0],
                                line=where[1],
                                level=WARNING )

    if in_quote:
        format_msg( 'still in string at EOF',
                    details=['started on line', last_quote_lineno],
                    filename=filename,
                    lineno=lineno,
                    level=ERROR)

    inverted = {}
    for oddball, where in trail.items():
        if inverted.has_key(where):
            inverted[where].append(oddball)
        else:
            inverted[where] = [oddball]
    bad_lines = inverted.keys()
    bad_lines.sort()    # i.e., sorted by line number
    for where in bad_lines:
        words = inverted[where]
        format_msg( 'unique id' + 's'[:len(words)&gt;1],
                    details=words,
                    filename=filename,
                    lineno=where[0],
                    line=where[1],
                    level=CAUTION )

</t>
<t tx="EKR.20040608165334.34">
def dynaM_regexTk(c):
    '''changing Tk pack options to dict's using re
    match alphanumeric on either side of =: or space or coma delimited
    build a dict or list from it. properly quoted and verifyed numbers
    its only been 3 minutes and I have better results 
    than in plex or pyparsing in more time than I care to admidt
    maybe need re, space double in space delimited means cant ignore
    avoided re for now. probably woulve been easiest

    cuts after the decimal on floats. might want = as an option too

reWhitespace = re.compile( r'[,\s\n]+', re.MULTILINE )
fields = reWhitespace.split( line )
    
    '''
    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)

    g.es('text is', newSel)

    sx = []

    #premassage the data
    newSel = newSel.replace(' ', ',').replace(',,', ',').replace(',,', ',')
    #print 'newSel is %r'%(newSel,)

    for x in newSel: 

        if x in '\'"':
            continue

        if x in ' ,\n':
            sx.append('\n')
            continue

        if x in '=:':
            sx.append(':')
            continue
        
        sx.append(x)


    data = ''.join(sx)
    data = data.replace('\n\n', '\n').replace('\n\n', '\n')
    data = data.replace('\n,\n', ',').replace('\n:\n', ':').replace(',', '\n')
    data = data.replace('\n:', ':').replace(':\n', ':').replace('::', ':')
    #print 'data is %r'%(data,)

    sx = []
    sx.append('{')
    for x in data.splitlines():
        #print 'for x', x

        if not x: 
            continue

        if x in ' ,\n': 
            sx.append(", ")
            continue

        if x.find(':') != -1: 
            x1 = x.split(':') 
            for i, y in enumerate(x1):
                #print 'for y', y

                if i == 1: 
                    sx.append(":")

                try:
                    #sx.append("%d"%int(y) )
                    sx.append("%d"%float(y) )
        
                #maybe float and int will have different errors
                #maybe if int it isnt coerced to float? works for me.
                except Exception, e:
                    #print 'exception', e.args
        
                    s = y.replace('Tk.', "").replace('Tkinter.', "")
                    sx.append("'%s'"%(s.lower(),) )
                #else: sx.append(":") else is only if except tripped

        else: #no : seperator assume is a plain delimited list
                sx.append("'%s':1"%(x,)) 
        sx.append(", ")


    sx.append("}")
    dynaput(c, sx)

#
#by pass while in plugin,
# for testing while included in dynatester node
#
if __name__ != 'dyna_menu':
    try:
        __version__
    except NameError:  
    
        #test passing quoted strings, space before and after, 
        #either numeric and real is getting parsed as 2
        #and isnt continuing to the next pair. stops at the first one
        #whatever "side"=1,  (whatever side) 
        def testbs():
            lst = """"\
            one two three
            side= Tk.LEFT , expand =1, 'fill'=Tk.BOTH,
            side"=1, expand = 1 , fi_ll=Tk.BOTH
            (=), [=], whatever 
                    """.splitlines(True)
            #print 'lst =', lst
            return lst



        genteststr.tstlst = testbs()
        testmacro = 'dynaM_regexTk'


    
</t>
<t tx="EKR.20040608165334.36">def dynaM_restoreStd(c):
    import leoGlobals as g
    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()
    g.redirectStderr()
    g.redirectStdout()
    
    g.restoreStdout()
    g.restoreStderr()

if __name__ != 'dyna_menu':
    try:
        __version__
    except NameError:  
        dynaM_restoreStd(0)</t>
<t tx="EKR.20040608165334.40">#helper code your macro can call.

#is clone, is common to dynabutton, dynatester &amp; dynamenu
#some things common like the dynaBunch &amp; init you probably wont call

#the first section is filenames, you have to edit in your correct path.
#note, these changes are at the time the button or menu is created
#to effect these changes you have to 
#write the plugin and start a new python and leo.
#execute script on the dynaclick node for the dynabutton
#they will take effect in dynatester imediatly
#preserve the space after to allow for parameters
#those that will be joined to pypath start with seperator \ or /
#scripts should have their own full path, 

import sys, os
    
pypath = r'C:\c\py\Python233'         #nospace
py =  pypath + r'\python.exe -tOO '   #space
reindent = pypath + r'\Tools\scripts\reindent.py '  #space
leosrc = r'c:\c\leo\leo4CVS233\src'

#classic pychecker
pycheck = pypath + r'\Lib\site-packages\pychecker\checker.py '  #space
#pychecker2, doesnt import, is alot slower and less details.
# and leaves some temp files, I guess its still experimental.
pycheck2 = pypath + r'\Lib\site-packages\pychecker2\main.py '

#classic pychecker I think does import regex which causes a warning when called from plugin. maybe they fixed that in the latest version.
#not sure why dont see it when run from dynabutton. output on stderr?
#DeprecationWarning: the regsub module is deprecated; please use re.sub()
# was caused by tim1crunch, I supress the warning now.

#set to 1 to call pylint after pychecker or 0 for just pychecker
dopylint = 1  #this call in makatemp is too complicated to code in here

#it might be preferable to generate a new tmpfile w/pid or something 
# ok for singleuser no security multiuser issues for now.
#YMMV, I set tmp and temp in autoexec, 
#use lower if on *nix. 
#windos may set TEMP and TMP by default, case insensitive.
#
#tmpfile = os.path.join(os.environ['tmp'],'tmptest.py')

#it seems pylint has to be able to import from site-packages
#look in makatemp trying to add tmp to syspath isnt easy from Leo
tmpfile = os.path.join(pypath, r'lib\site-packages', 'tmptest.py')

#replace forwardslash to backslash if required
#frd slash usually ok except for cd and sometimes openfile
#with filename as parameter in windos frdslash might be taken as option
tmpfile = tmpfile.replace('/', '\\')

try:
    import cStringIO as StringIO
except ImportError:
    import StringIO</t>
<t tx="EKR.20040608165334.41">
def scriptbody(c, p):
    """AttributeError: vnode instance has no attribute 'copy'
    this removes all sentinals but might be switchable somehow

        """
    df = c.atFileCommands.new_df
    df.scanAllDirectives(p, scripting=True)
    # Force Python comment delims.
    df.startSentinelComment = "#"
    df.endSentinelComment = None
    # Write the "derived file" into fo.
    fo = StringIO.StringIO()  #g.fileLikeObject()
    #df.write(p.copy(), nosentinels= True, scriptFile= fo)
    df.write(p, nosentinels= True, scriptFile= fo)
    assert(p)  #why assert after the write?
    return fo.getvalue()  #get()


def selecbody(data, sdict):
    """ if selected starts after @ it should be commented anyway?
    
    backslash inside string literal, always skips the next char 
    \s might have to be \\s in raw?
        """
    cmtdelim = '#'
    if sdict['language'] != u'python':
        #obviously for other language have to check is valid
        # is more than one, then have to trail each line etc
        #was delims[0] not sure where that came from
        #coverage tool might have caught that so far untested
        cmtdelim = sdict.get('delims', ['#'])[0]
        
    import re
    datalines = data.splitlines(True)
    #print 'data is %r'%(datalines,)


    #not sure why &lt;\&lt; works
    #does \s work like s, apparently not. 
    #though \s was only for rawstring w/o it misses indented @|&lt;
    repATang = re.compile('\s*&lt;\&lt;.*?&gt;&gt;.*')  #^$ 
    repATc = re.compile('\s*@.*', re.MULTILINE )
    #could use it on the whole string, ok line by line too.


    sx = []
    inATc = False  #a comment, not @c. poor name choice here.
    for x in datalines:
        
        if inATc:  #chances are Leo already does this somewhere
            #what about the foolish @color inside already started comment?
            #any @ is end of comment directive, 
            if x.startswith('@c'): #@ but its not stopping till @x!
                inATc = False
            sx.append('%s%s'%(cmtdelim, x) )
            continue

        if repATc.match(x):  #is start of comment
            if x == '@\n' or x.startswith('@ ') or \
                x.startswith('@\t') or x.startswith('@doc'):
                inATc = True
            sx.append('%s%s'%(cmtdelim, x) )
            continue

        if repATang.match(x): #is sectionname
            #would need to get more fancy here
            sx.append('%s%s'%(cmtdelim, x) )
            continue
        
        #if x == '\n': continue  #delete blank lines?

        sx.append(x)

    return ''.join(sx)

def fixbody(data, c= g.top()):
    """ assumed leo body, forces str &amp; expandtabs
    @directives commented out
    from @ to @c commented out
    have to make sure doesnt expand \n \t etc literals in strings
    that is a problem when include section refrences as data
    eventually follow @others, and section refrences or use Leo API
    comments sectionnames
    commented out indented @others or sectionnames 
    add a strip comments mode to speedup the processing on larger data
   I was a little confused about directive use. forgot @c is code
  (@ followed by a space, tab or newline) or @doc
  Body text from an @c or @code directive to the
    next @&lt;space&gt; or @directive.  
    Leo itself doesnt stop the comment if @path after @space
    @doc isnt commented, not sure what that is.
   @color/@nocolor work @path doesnt stop comments
   any htmlize of the body should follow these very closely
   even if just rendering code

    1/2h looking thru leodoc leopy, 1/2h looking thru leo*file
    I have no idea how to do this using the Leo API
    maybe some other plugin does it? rst must have some of it
    obvious solution would be a recurxive one.
    it seems the plugins and scripts do alot of the node traversal
    I dont see where they are calling Leo
    nor do I see how they follow @others or sectionnames
    
    luckily it continues on to comment after any @directive till @c
    the goal here is not to mimic Leo. but to render all @ as comments

    should get directives so the proper comment are rendered
    in c for ex, might want to mark and output /* comments */
    or in style section of html or inside script = javascript
    name fixbody is a misnomer here, I assume we are in body
    and the c would be valid but who knonws.
    its only passed data so that has to change.
    chg to data, c if data is None then assume the worst
    still going to need what node selected text is in?
    otherwise how to use language &amp; delims
    

{'language': u'python', 'pagewidth': 80, 'encoding': None, 'delims': ('#', None, None), 'lineending': '\n', 'tabwidth': -4, 'wrap': 1, 'path': u'', 'pluginsList': []}
     just because I get the directives, doesn't mean I respect them all.
     
     
    the other piece is implimenting a toggle get @others or just node
    if if get @others, will the caller be responsible for knowing
    if the current node is the complete piece of the program? guess so.
    not ready to go recursive yet,   
    going to need a follow @other 
     but add dont comment mode &amp; strip docstrings also 
    
    executescript in leocommands has code to derive a file to an object
    it takes care of comments and I assume adds sentinals.
    it does the @ comments, 
    but removes all other sentinal as presently setup
    selectedtext passes thru my @directive commenter
      """

    if not c:
        g.es("in fixbody, empty c")
        return

    v = c.currentVnode() # may want to chg for 4.2
    sdict = g.scanDirectives(c, v) 
    #print sdict

    if not data:
        #g.es("in fixbody, empty data, using body")
        #data = v.bodyString()
        data = str(scriptbody(c, v).expandtabs(4))
    else:
        print  'data is %r'%(data,)

        data = str(selecbody(data, sdict).expandtabs(4))


    return data</t>
<t tx="EKR.20040608165334.42">@
#code for dyna

    - dynaBunch
    - dynaerrout
    - captureStd
    - runcmd
    - dynadoc

</t>
<t tx="EKR.20040608165334.43">
def init_dyna(c, *a, **k):
    """same for both button and menu
    """    
    
    dynainst = dynaBunch(
        dynadefaultFlag = Tk.IntVar(),
        dynapastelst = ['print', 'paste', 'doc'],
        dynapasteFlag = Tk.StringVar(),
        #getsubnodes different in button &amp; menu, lst is a list of macros
        dynadeflst = dyna_getsubnodes(c), 
        )
    
    #print to start, paste over selection later

    dynainst.dynapasteFlag.set(dynainst.dynapastelst[0] )
    dynainst.dynadefaultFlag.set(0)
    return dynainst


class dynaBunch(object):
    """tieing an instance of dynaBunch to c.frame is responsibility of caller
    Bunch aspn python cookbook 52308
    point = Bunch(datum=y, squared=y*y, coord=x)
    if point.squared &gt; threshold:
        point.isok = 1
    in Leo From The Python Cookbook. used setattr &amp; getattr
     not sure of the ivar stuff for now
    repr lifted from c.l.py
    clear might still use, need gc tests
     http://www.norvig.com/python-iaq.html  (Struct class)

    in the sprit of one obvious way to do it.
    the idom appears to be to change the name of the class
    and hype it as a way to turn a dict into a lot of instance vars
    alot are taking credit for this idea through the years,

        """
    import operator

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def __repr__(self):
        return '%s(%s)' % (self.__class__.__name__, '\n'.join(
            ['%s=%r' % keyval for keyval in self.__dict__.items()]))

    def __clear(self):
        g.es('attempting to clear')
        for key in self.__dict__.keys():
            g.es(';k=',key)
            del key
            g.es('deleted')
        g.es('\ndone clear')

    def set_ivars(self, c):
        """Set the ivars for the find, from searchbox
        might want to use this
        """
        # Modified from leoTkinterFind.set_ivars
        #for key in self.intKeys:
        #    setattr(c, key + "_flag", 0)  

    def ivars(self):
        return self.__dict__.keys()
        
    def __setitem__ (self,key,value):
        #allows access like dyna['dynalst']?
        return operator.setitem(self.__dict__,key,value)
        
    def __getitem__ (self,key):
        return operator.getitem(self.__dict__,key)

    """
    def load(infile):
        strng = infile.read()
        exec( 'bag = Bag(\n' + strng + ')' )
        return bag
    load = staticmethod(load)

    def save(self, outfile):"""</t>
<t tx="EKR.20040608165334.44">
#quiet warnings from pychecker and tim1 about regex

import warnings

warnings.filterwarnings("ignore",
         r'the regex module is deprecated; please use the re module$',
         DeprecationWarning, r'(&lt;string&gt;|%s)$' % __name__)
warnings.filterwarnings("ignore",
         r' the regsub module is deprecated; please use re.sub\(\).$.$',
         DeprecationWarning, r'(&lt;string&gt;|%s)$' % __name__)

if sys.version_info &gt;= (2, 3): #py2.2 no simple
    warnings.simplefilter("ignore", DeprecationWarning, append=0)

'''C:\c\leo\leo4CVS233\plugins\dyna_menu.py:774: DeprecationWarning: the regex module is deprecated; please use the re module
  import regex
C:\C\PY\PYTHON233\lib\regsub.py:15: DeprecationWarning: the regsub module is dep
recated; please use re.sub()
  DeprecationWarning)'''

#maybe can turn on full exception reporting 
#rather than rolling my own
# es_event_exception (eventName,full=False):
#excepthook() like displayhook?
# __displayhook__ = displayhook(...)
#        displayhook(object) -&gt; None
#   __excepthook__ = excepthook(...)
#        excepthook(exctype, value, traceback) -&gt; None

#    # dynaM_tim_one_crunch 909 1071
#    print 'co_name=', sys._getframe(1).f_code.co_name
#    print 'lineno=', sys._getframe(1).f_lineno  #
#sys._getframe().f_code.co_name returns ? while in exscript
#make a method of something so can use it to find the linenumber in macro
#possibly even jump directly to the source on error in dynatester
#lt = classmethod(doDefault) self = frame.f_locals['self'] 
#  import sys  g.es('lineno= ' + sys._getframe().f_lineno )


def dynaerrout(err, msg):
    """from fuzzy cmd
    Leo often masks the errors 
    making debuggin of this kind of script more painful than not
    """
    
    from traceback import print_exc

    g.es(msg, color= 'tomato')
    f = StringIO.StringIO()
    print_exc(file= f)
    a = f.getvalue().splitlines()
    for line in a:
        #g.app.goToLineNumber(int(newSel))
        g.es(line, color= 'tomato')</t>
<t tx="EKR.20040608165334.45">class captureStd(object):
    """the typical redirect stdout
    add stderr and stdin later
    borrowing the class from PH testsuite for redirect stdout

    leo also has filelike objects and its own redirect    
    there isa config option and a plugin to redirect to log
    and to append to body of captured output

    another way
    sys.displayhook = mydisplayhook

    &gt;&gt;&gt; def mydisplayhook(a):
    ...     if a is not None:
    ...             sys.stdout.write("%r\n" % (a,))
    ...
        """
    def captureStdout(self):
        sys.stdout = StringIO.StringIO()

    def releaseStdout(self):
        captured = sys.stdout.getvalue()
        sys.stdout = sys.__stdout__
        return captured</t>
<t tx="EKR.20040608165334.46">
#runcmd(cmds) &amp; forklike(*cmds)

def runcmd(cmds):
    """for win9x this works better than other popen for me.
    on *nix you can import commands or something else popen5 maybe
    this does wait and leo is inactive so if there is a chance
    the process will infinate loop, better use a spawner
    you get the return output outerr stdout stderr
    """
    import os
    child_stdin, child_stdout, child_stderr = os.popen3(cmds)
    
    output = child_stdout.read()
    outerr = child_stderr.read()
    
    return output, outerr
    
    
def forklike(*cmds):
    """still experimenting
     on *nix you can commands or fork or this 
    this does not wait and leo is active 
    but it appears to reuse the same console if there is one
    not sure what happens if use leo.pyw

    returns the pid I guess its meaningless on windows?

cmds
('C:\\c\\py\\Python233\\python.exe -tOO ', 'C:\\c\\py\\Python233\\lib\\site-packages\\tmptest.py')

params, para
['C:\\c\\py\\Python233\\python.exe', '-tOO'] ['-tOO', 'C:\\c\\py\\Python233\\lib\\site-packages\\tmptest.py']
says needs string only
startfile( os.path.normpath(path) ) 

times( ) Return a 5-tuple of floating point numbers indicating accumulated (processor or other) times, in seconds. The items are: user time, system time, children's user time, children's system time, and elapsed real time since a fixed point in the past, in that order. 
(2868845789.5628495, 0.0, 0.0, 0.0, 0.0)

tryed startfile
WindowsError: [Errno 2] The system cannot find the file specified: 'C:\\c\\py\\Python233\\python.exe -tOO C:\\c\\py\\Python233\\lib\\site-packages\\tmptest.py'
    """
    import os

    #all the good ones are *nix only
    # from spawnl got traceback return spawnv(mode, file, args)

    params = cmds[0].split()
    para = ''
    if len(params) &gt; 1:
        para = params[1:] + list(cmds[1:])
        # os.path.normpath(path) 

    #print os.times()
    print cmds
    print params, para


    cmd = params[0]
    #cmd = 'c:/Command.com' #c:/windows/system32/cmd.exe 

    #s = ' '.join(['%s'%x.replace('\\\\', '\\') for x in para])
    #print s
    #output = os.startfile(s)  #cant handle command w/params?

    output = os.spawnl(os.P_NOWAIT, cmd, *para )
    
    return output</t>
<t tx="EKR.20040608165334.47">
def dynadoc(c, sub= 'all' ):
    """read dynadeflst and createdoc for them
        was previously print, but that doesnt work well in plugin
        add a simple wrap, which isnt appending dash in midword like expected
        could set wrap on for the log. then off again, 
        would probably unwrap  though

    combined the call to all and removed else. works because
    a list is made from sub, will preclude docing a macro named all

    using now \python233\lib\textwrap.py, if available
    too many amonalies in fordoc too little time.
    made a wraper macro, dont really want another depency
    would have to extract the relevant code and have the 
    macro call it too. ok a little code duplication for now
    
    expand to show macro's internal __dict__
    getting doc for fliper for ex, might be nice to know
    
  """
    import leoGlobals as g

    try:
        import textwrap as tw
    except ImportError:
        tw = None  #or overwrite formdoc
        g.es('textwrap is going to produce better resiults.')
        g.es('get it from the python cvs archive\n')
        

    #from pydoc import resolve, describe, inspect, text, plain

    def formdoc(doc):
        """create a rough wraper to 40 charlines"""
        sx = doc.expandtabs(2).splitlines()
        sl = ['\n']
        for i, x in enumerate(sx):
            if i &gt; 6: break  #beyond that is implimentation details

            if len(x) &lt; 42: sl.append('  ' + x.lstrip()); continue

            if len(x) &gt; 50: ax = 50
            else: ax = len(x) - 1

            dash = '-'
            while ax &gt; 35:
                if x[ax] in ' .,(){}[]?\n': dash = ''; break
                ax -= 1
            #if ax w/in few char of len(x) may as well be one line
            #check it isnt eating a char at ends
            sl.append('  ' + x.lstrip()[:ax] + dash)
            sl.append('   ' + x.lstrip()[ax:])

        sl.append('\n')
        return '\n'.join(sl)

    lst = [sub ] 
    if sub == 'all':
        lst = dynaMvar.dynadeflst

    for x in lst:
        f = globals()[x]
        
        coln = 320
        if not tw:
            st = formdoc(f.__doc__)
        else:
            t = tw.TextWrapper(
                     width= 42,
                    initial_indent=' ',
                   subsequent_indent= ' ',
                   expand_tabs= True,
                  replace_whitespace= True,
                 fix_sentence_endings= False,
                break_long_words= True )

            st = t.fill(f.__doc__[:coln])

        if len(f.__doc__) &gt; coln: elip = ' ...'
        else: elip = ''

        g.es('\n' + x + '.__doc__\n' + st + elip)
        #g.es('\n' + str(f.__dict__))  #{}

    #obj, name = resolve(x, 0)
    #desc = describe(obj)
    #g.es(text.docroutine(f, x))
    
</t>
<t tx="EKR.20040608165334.48">@

dynaput is a dual use function. you call it with the current commander c, passed
to the macro and an empty list.
it returns the selected text or None.

depending on the macro you could return at that point or get the full body text
etc.

for ouput you call dynaput with a list of your text. it checks the state of
print/paste selected on the menu and either prints the text or pastes it over
the selected text as you choose.

@c
def dynaput(c, slst):
    """return the text selection or put it if slst is not None
    assumes slst is a list to be joined and print/paste as toggled
     add other option, paste w/o delete
    up to the caller to insert \n if required
    eventially pass in event so can get text from any widget
    for now, hardwired to use the Leo API to the Tk text widget   
    **slight problem, wont insert something wth nothing selected
 leoTkinterFrame

  add another menu toggle for print to clipboard 
    in addition to printing or instead of printing
     and replace or append to clipboard.
  
    """

    #this depends on the macro calling dynaput first as they mostly do now
    #bound to be some sideffects untill I put it in the right place
    #maybe the menu has to have a function caller instead of calling the function
    if 'doc' == dynaMvar.dynapasteFlag.get():
        #in dynabutton they are all radio buttions 
        #and its easy to see which was called. unlike in plugin
        #dump all for now
        dynadoc(c)
        return

    Tx = c.frame.body
    if Tx.hasTextSelection(): #**or slst
        
        #returns selection point if nothing selected
        Tst,  Ten = Tx.getTextSelection()

        if not slst: #**and Tx.hasTextSelection()
            return Tx.getTextRange(Tst, Ten)

        else:

            #ux = g.toUnicode(x[1:] )  ?? need to know the encodeing!
            # toUnicode(before,app.tkEncoding), hope Leo handles this
            ux = ''.join(slst)
    
            if 'print' == dynaMvar.dynapasteFlag.get():
                #print ux
                g.es(ux)

            elif 'paste' == dynaMvar.dynapasteFlag.get():
                g.es('overwrite\n', str(Tx.getTextRange(Tst, Ten)) )

                v = c.currentVnode() #should this be positions in 4.2?
        
                #btw, Tk insert doesnt disturb the selection.
                Tx.deleteTextSelection()
                #Tx.onBodyWillChange(v, "Delete")
        
                Tx.setInsertionPoint(Tst)
        
                #print '%r', ux
                Tx.insertAtInsertPoint(ux)
                Tx.onBodyWillChange(v, "Typing")
        
                #selection may wander depending on the final size
                Tx.setTextSelection(Tst,  Ten)

            else:
                g.es('third choice', dynaMvar.dynapasteFlag.get() )

    else:
        g.es("no text selected", color= 'orangered')
</t>
<t tx="EKR.20040608165334.49">def g_row(ip): return int(ip)

def g_col(ip): return int(ip - g_row(ip))

def dynaplay(c, splst):
    """playback commands from a list into the selected or body text
    inventing a new little language isnt a trivial endevor
    should do some research to find out if I can steal one
    didnt takevery long to get initial results
    need to preparse and push repeat n, and parse n for other commands
    preparsing is dificult, untill you act you dont know if it will raise an error
    this first cut wont allow repeat and n as easily
    repete means startover to the repete -= 1. 
    what if there is another repete, the previous repete needs to be reset

    need to set insert point so repete works, independant of paste mode?
    tricky, first time thru insert can be outside of selection
    and commands can try to insert outside of selection
    undo doesnt change insertpoint

    """
    if not splst: return

    nothingselected = False
    data = dynaput(c, [])
    g.es("selected ")
    if not data:
        nothingselected = True
        g.es("...skip, dump the body")
        v = c.currentVnode() # may chg in 4.2
        data = v.bodyString()

    ip = float(c.frame.body.getInsertionPoint())
    #this apparently does the right thing if nothing selected 
    Tst,  Ten = c.frame.body.getTextSelection()

    #on selection insert is at end or start
    #if repete play you want the insert if its midselection somewhere
    #print 'Tst%r &lt;= ip%r &lt;= Ten%r'%(Tst, ip, Ten)

    if c.frame.body.hasTextSelection():
        if float(Tst) &lt;= ip &lt; float(Ten):
            pass
        else: ip = float(Tst)
    

    sx = data.splitlines(True)
    sx[0:0] = ' ' #make it base1

    for x in splst:
        if x.startswith('%%C,'): #command
            comd = x[4:].lower()
            if comd == '[down]':
                ip += 1.0

            elif comd == '[up]':
                ip -= 1.0

            elif comd == '[home]':
                ip = float("%d.%d"%(g_row(ip), 0 ))

            elif comd == '[end]':
                ip = float("%d.%d"%(g_row(ip), len(sx[g_row(ip)]) ))

        else: #must be an insert something
            try:
                b = sx[g_row(ip)][:g_col(ip)]
                m = x
                a = sx[g_row(ip)][g_col(ip):]
    
                sx[g_row(ip)] = '%s%s%s'%(b,m,a)
                ip = "%d.%d"%(g_row(ip), len(x) + g_col(ip) )
                ip = float(ip)
                c.frame.body.setInsertionPoint(ip)
            except IndexError, err:
                g.es('command outside selection', err)

        g.es('ip=%r, x=%r'%(ip, x))

    dynaput(c, sx[1:])
    c.frame.body.setInsertionPoint(ip)

</t>
<t tx="EKR.20040608165334.52">@killcolor

This section holds additional macros that will not be put into the Dyna menu.

As always, macros should have names that start with "dynaM_"</t>
<t tx="EKR.20040608165334.53">@nocolor **********

done or very close to working ideas

*toggle button on rclick menu for dyna to paste or print
     or insert w/o paste
*delete first n chars, fixed reselect problem

*reimpliment hexdump body for dyna to work on selected text or body

*new comafy from c.l.py

flipper, toggle the boolean selected, if 1 make it 0, True becomes False , 

swaper, copy one section or word, then select, hit flipper they are switched

comment cutter, sentinal cutter expander

geturls start of a urlgrabber from text or body
 expand to grab emails. using verbose re's, alot of work to do yet.
 

sfdots, the sourceforge forum dot added, UPL, DNL 
  if it starts with dots, the dots are removed otherwise they are added
  combine with evaluator so indentation can be standardized at the same time.

sort if its a coma space, delimited single line
   present setup will add comaspace which you can then delete

tim-one crunch does a fair job, creates tmp file, could chg to StringIO
not sure macros will make it thru pychecker or pylint
something to simple xref and show single use varbs
will avlid problem I just had with think re was the problem
data = something; s = re.something(data)
date = s
#why is re not working!
print data
you get the jist.


datereformater, take various date formats and convert to one selectable type
 lots of room for errors and anomailies here


made a first cut on a solution for this
Playing back the buffer would be the same as you typing it in again. E.g., if I want to comment out some lines in Python, I would record 
"#" + " " + [Home] + [Dn-Arrow]
--Rich
if there was passed in some command or if there was a class to initilize
as pot and replaces were done it could refer to the commands to see what
should happen. being flexable w/o macro recording will be fificult
seeing something then modufying it is easier than producind it from thin air.
 

paste, then end of line paste something else. 
 DQ3 already does this, but in the plugin how to extend the dict it uses
 and if you do extend it, can it read it/save it to ini for next time
    playback can also do this with a little more dev time


graphviz nodewalker from EKR demo

parsers has some ideas about using parsers and regex's to parse
in various states of disrepair. still working out the dynatest node
feel free to point out the error of my ways.
im always a little surprized when parser or re's solve the problem.
 which is not often.
pullparser macro to print titles in all html in a directory

in the future
reindent selected code. even nievely would be improvement
prettyprint selected or body and subnodes using calc_util
not too dificult, 
needs some tightening up in calc_util 
though it fixes non standard indentation nice
the prettyprint messes some indentation after comments, before dedents.
and adds extra spaces in too many places.

made a first cut on this w/makatemp all the paths hardwired
pylint and pychecker, not ready to call the export hooks or whatever
export flattened might work, or copy to @file-nosent and write? then delete, meessy.
 would need to create a tmpfilem call them and collect output
 a display of the tmp file dir might be called for
 as well as checking free diskspace
 abilty to reindent necessary as expandtab
 and how to get in the location of all the utilities
 and provide dl info from pipi or elsewhere if nothing installed
 as well as py less than 2.3 compatibility


grabscreen with popup to start 5s countdown timer to arrange screen

have to do something with psyco to make sure that works
maybe something with timeit to run selected text or body
with and without psyco. compareing 2 functions or 2 lines


a wrap to len macro, probably should be something
that on loadm replaces leo's reformat paragraph w/more options
default it would wrap to the len of the first line.


some code is a bad idea to run inside Leo.
 some Tk probably alot of other GUI  raw_input and urllib 
 I've had problems with
 its not a problem in those cases to create a file and run it 
 from a shortcut or a doswindow or msys shell if theres alot of output.
 but, it would be useful to just run the tempfile in its own process.
 a slight  morph of makatemp would do this. something like the openwith
 plugin that doesnt wait for output that may never happen if hung.


macro to linenumber source as Leo sees it for executescript
        or print +- a few around linenumber


basestring apparently only works on Python  2.3.  used in dynodoc &amp; dynamenu

Leo bugreport
addIconButton(text=None,imagefile=None,image=None,command=None,bg=None)
    bg doesnt work, image &amp; imagefile errors
    using the output instance config works with the same parameters
    node navigatior does its own config.
@color
</t>
<t tx="EKR.20040608165334.54">'''&gt;&gt;&gt; s = 1234567.89
&gt;&gt;&gt; '$' + re.sub(r'(?&lt;=\d)(?=(\d\d\d)+(\.|$))', ',', str(s))
    '''

def dynaM_commafy(c):
    """f04507a08:27:05  from recent post on c.l.py
    """
    #import re
    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)
    try:
        val = float(newSel)
    except:
        print 'except: float(', newSel
        return

    dynaput(c, ['$ '+ commafy(val).replace(' ',',')] )
    #dynaput(c, ['$' + re.sub(r'(?&lt;=\d)(?=(\d\d\d)+(\.|$))', ',', str(val))] )

class Doit(dict):
    def __init__(self, d): dict.__init__(self, d)
    def __getitem__(self, name):
        if name.startswith('cfy_'):
            return commafy(self.get(name[4:],'??'))
        else: return self.get(name,'??')

def commafy(val):
    sign, val = '-'[:val&lt;0], str(abs(val))
    val, dec =  (val.split('.')+[''])[:2]
    if dec: dec = '.'+dec
    rest = ''
    while val: val, rest = val[:-3], '%s %s'%(val[-3:], rest)
    return '%s%s%s' %(sign, rest[:-1], dec)</t>
<t tx="EKR.20040608165334.55">def dynaM_del_comment(c):
    """del lines starting with #
    for no particular reason

    """
    nothingselected = False
    data = dynaput(c, [])
    g.es("selected ")
    if not data:
        nothingselected = True
        g.es("...skip, dump the body")
        v = c.currentVnode() # may chg in 4.2
        data = v.bodyString()

    data = fixbody(data)
    sx = []
    for x in data.splitlines(True):

        if x.lstrip().startswith('#'): continue
        sx.append(x)

    if nothingselected:
        print ''.join(sx)
    else: 
        dynaput(c, sx)
</t>
<t tx="EKR.20040608165334.56">
def dynaM_screenshot(c):
    """
    f04416p3:39 fine tuneing EKR script to work for screenshots
     screen grabber (windows only)?

    need to resample to make the gif fit in an app on the screen
    added timer and alert so can gauge when the snap will be taken,
    still problematic if in this leo then need to avoid the minimize
    also the img is a gif? why not png 
    and it doesnt zoom well in the IE rclick zoom img helpers,
     distorts, try another resampler

    f04521p04:57:57  the following comment from my modifyed 
    get screenshot script was actually one of the final straws 
    that forced me to develope dyna,
        
      this pointsup the problem with not having execute script
     be able to work from another node, the copy buffer or
     some other non visable mechinism. what do I do to get a
     screenshot from w/in leo about another node?     maybe a
     leo that has all these scripts then can work on another
     leo's current node? the problems with rClick may turn out
     to be an advantage under control.     you could also
     start a new leo and copy this node there and execute
     script from it 
     
    default is to minimize leo, if you want the screenshot of Leo
    then you have some editing to do
    gong to have to put this on an accelerator key
    otherwise if leo is in the screenshot a menu is partly vissable?
    the resize is a little fuzzier than I remember.
    there is still the problem of another leo started from the same
    python, that is frozen too so you have to get everything setup first
    probably the way to do this is from a python script outside of Leo.
    or start another python and another leo. 
    and put screenshot in dynamenu plugin
    in some cases the alert doesnt dissapear till after the screenshot
    well we are at another deadend for the moment.
    
    remove Leo depencies so can run as a standalone script

    http://www.pythonware.com/downloads/index.htm #pil
    """
    import leoGlobals as g
    
    import Image
    import ImageGrab
    import os # requires PIL 1.1.3 or later
    import time
 
    #2 from leotinker, should call them directly?
    def fminimizeAll(f):
        #what about plugin window or compare?
        f.minimize(g.app.findFrame)  
        f.minimize(g.app.pythonFrame)
        #how to know which is this leo? frame==top?
        for frame in g.app.windowList:  
            f.minimize(f)
        
    def fminimize(frame):
        if frame and frame.top.state() == "normal":
            frame.top.iconify()
    
    path = os.path.join(g.app().loadDir,"../","test","screenshot.gif")

    #ug   weird but works 
    #C:\c\leo\leo4CVS233\src\../test\screenshot.gif
    
    g.top().frame.minimize(g.top().frame) #
    #fminimize(g.top().frame) #this miimizes the current leo
    #if you want a pic of this, then thats a problem
    #youi could programatically select a node, or use the scheduler plugin
    
    g.alert('start counting  down 10 seconds')
    time.sleep(11)  #avoid the edit menu artifact still visable!
    #something to slightly reduce the image size would be nice
    # a full screen image viewed less than full screen isnt that useful
    
    #ImageGrab.grab().save(path)  this worked
    im=ImageGrab.grab()
    #grab(bbox=None) grabclipboard():@return An image, 
    #a list of filenames, or None
    
    #resample
    #the bounding box working, I dont need crop though, 
    
    box = (( 4), ( -4), (im.size[0]  ),(im.size[1] ) )
    
    #to_save = im.crop(box)
    
    #.resize((480, 360), resample= Image.ANTIALIAS) 
    #ok but still distorts a little
    to_save = im.resize((480, 360), 
        resample= Image.NEAREST)
    #all distorted fuzzy
    #NONE = 0 NEAREST = 0 
    #ANTIALIAS = 1 # 3-lobed lanczos
    #LINEAR = BILINEAR = 2
    #CUBIC = BICUBIC = 3

    to_save.save(path)
    
    #print path
    g.top().frame.top.deiconify()
        
#e</t>
<t tx="EKR.20040608165334.57"></t>
<t tx="EKR.20040608165334.58">@nocolor
is it feasable to use a filename from the copybuffer if toggle a switch?

how to hook into @others and subnode so getbody gets all body
does selected text include @others included? like a section name
inside triple quotes gets some conversion by leo
it also expands \n literals in strings, not good.
@color

#select this section and execute script to see what happens
s = """\
&lt;&lt;somenode&gt;&gt;
""".splitlines()
for x in s: print x
#it does included the @others and comments the @-@c section
@nocolor
might use this somehoww, see fixbody in common for other solutions
could I programatically create a string with a namedsection in it?


@color
#I do this often enough it should be a pick from one liners macro in dyna
#this would idealy use the base of the current dir however thats found
print file(r'c:\c\leo\flat.txt ').read()
print file(r'c:\c\leo\headlines.txt ').read() #headlines uses tabs

var = open("file", "r").read().replace("string1", "string2")
open("file", "w").write(var)

create_temp_name()
g.app.getBaseDirectory()
@nocolor

how to select something in the log after you insert or print it?
    self.output.insert(Tk.END, outstr + '\n', tag)  #
 mark current insert point, then get insertpoint if its at the end?
    self.output.see(Tk.END)
    could clear the whole thing first
@color
    t = c.frame.log.logCtrl
    print t
    t.delete("1.0","end")

@nocolor

 can I tell if there is redirection to node or append to body active?
g.isRedirected()
</t>
<t tx="EKR.20040608165334.59">
#test of idea to get Leo to do body filtering &amp; inclusion
@others</t>
<t tx="EKR.20040608165334.60">@
this is in comment section from the 2nd node

@c
for x in [1, '2\\n2\\n2', 3,]:
    print x,
print

</t>
<t tx="EKR.20040608165334.61">
def dynaM_Pic97(c):
    """not worrking yet, works from the commandline
    probably because its calling py2.2 from leo using py2.3
-n
-t

 -c 
    """

    py = r"c:\c\py\Python22\python.exe "
    src = r"c:\c\leo\lot\Pic97classifier_txt.py "
    per = r" -c "
    cmds = py + src #+ per

    for x in runcmd(cmds):  #now returns tuple out &amp; err
        print x



    

</t>
<t tx="EKR.20040608165334.62">
def dynaM_getdoc(c):
    """from recent post, 
    doesnt handle builtins or python keywords like help(txt) does
    """
    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)
    print getdoc(newSel)

def getdoc(thing, title='Help on %s', forceload=0):
    ''' 0.4: Maxim Krikun
        # - added context-dependent commands:
        #   open url, jump to reference, pydoc help
        # - replaced rc_help with context-dependent pydoc help; 
        #   rc_help was not working for me :(
     '''   
    #g.es('in getdoc: '+repr(thing))
        
    from pydoc import resolve, describe, inspect, text, plain
    
    obj, name = resolve(thing, forceload)
    desc = describe(obj)
    module = inspect.getmodule(obj)
    if name and '.' in name:
        desc += ' in ' + name[:name.rfind('.')]
    elif module and module is not obj:
        desc += ' in module ' + module.__name__
    doc = title % desc + '\n\n' + text.document(obj, name)
    
    #g.es('out getdoc: '+repr(doc)[:100])
    
    return plain(doc)
#print getdoc('tokenize.generate_tokens', title='Help on %s', forceload=0)</t>
<t tx="EKR.20040608165334.63">
def dynaM_profile(c):
    """Python Mailing List
    """
    import profile
    p = profile.profiler()
    def ver1():
       # put version 1 here
    
    def ver2():
       # put version 2 here
    
    p.run("ver1()").print_stats()
    p.run("ver2()").print_stats()</t>
<t tx="EKR.20040608165334.64">
def dynaM_psyco_timeit(c):
    """a very first draft. import of timeit like this
    might preclude anything helpfull from timeit
    bind also can only help in the local scope
    timeit compiles and runs what you pass to it.
    a good first approximation at something though
    timeit.reindent should be able to take multiline and make single line
    or at worst, will build a temp file and run it.
    getting selected text into startup and single line code is too dificult

timeit.py
http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/*checkout*/python/python/dist/src/Lib/timeit.py ?rev=1.9&amp;amp;content-type=text/plain

itertools.py
 http://members.rogers.com/mcfletch/
try:
    import itertools
except ImportError:
    # Must be an older Python version (see timeit() below)
    itertools = None

    python timeit.py [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement]

Options:
  -n/--number N: how many times to execute 'statement' (default: see below)
  -r/--repeat N: how many times to repeat the timer (default 3)
  -s/--setup S: statement to be executed once initially (default 'pass')
  -t/--time: use time.time() (default on Unix)
  -c/--clock: use time.clock() (default on Windows)
  -v/--verbose: print raw timing results; repeat for more digits precision
  -h/--help: print this usage message and exit
  statement: statement to be timed (default 'pass')


A multi-line statement may be given by specifying each line as a
separate argument; indented lines are possible by enclosing an
argument in quotes and using leading spaces.  Multiple -s options are
treated similarly.
    
    """

    arg = "-c -s'ags=range(1000)' 'x=ags[:]' "
    arg = "--help"
    timit = pypath + r"\Lib\timeit.py "
    runcmd(py + "-OO" + timit + arg)


      
    newSel = dynaput(c, [])
    data = fixbody(newSel, c)

    if not data or len(data) == 0: 
        return
    
    try:    
        import timeit
    except ImportError:
        import time
        ze = time.clock()
    
    import sys
    psyc = """
omize = ['none', 'psyco', 'bindc'][0]
try:    
    if omize == 'psyco':#01  or use commandline option
        #if present use psyco to accelerate the program
        import psyco
        #psyco.jit() #only py2.2?
        psyco.full()
        #psyco.log()?

        #psyco.profile( watermark=0.09, halflife=0.5, pollfreq=20, parentframe=0.25, memory=None, time=None, memorymax=None, timemax=None) 

    elif omize == 'bindc':
        #if present use b_c to optomize the bytecode
        #Raymond Hettinger's Cookbook recipe
        # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/277940
        import bind_constants as b_c
        
except ImportError: pass """

    data = psyc + data
        
    #s = """p = random.random()"""
    #sup = """import random; \
    #    t =random.randrange(500,1000)"""
    sup = ""
    s = timeit.reindent(data, 4)
    print s
    
    tim = timeit.Timer(stmt= s, setup= sup)   
    
    try:
        r = tim.timeit(10) # or t.repeat(...)
    except:
        tim.print_exc(file= sys.stdout)
    
    
    print r
    print "took: %2.5fm Optomize= %s"%(r, omize)</t>
<t tx="EKR.20040608165334.65">
def dynaM_Graphviz(c):
    """m04524p09:28:35 take the EKR Graphviz pydot demo
    see the 4.2+ test.leo for the origional and other info
    http://www.dkbza.org/pydot.html
    http://www.research.att.com/sw/tools/graphviz/download.html
    pydot, python setup.py install
    install the full Graphviz in a subdir somewhere on  the path
    pydot has a path walker that will find it.
    works on win.

    bring it back down to 4.1 standards and macroize it
    put in a switch for &gt;4.1 use the origional calls
    
    works on any node now. best if there are not too many subnodes
    the graph gets too dense and small
    
    the other demo graph node outline builder worked 4.1.
    also have to refocus. the demo was to visualize 4.2 t\/v nodes
    I dont need to see the numbers just the headlines
    some things are compatable some not. 
    need to dev a good list of what works
    list of cvs commits would help here maybe if the docs dont keep up.
    its not going to make a whole lot of sense in less than 4.2
    untill I find out about the diferences
    makes a nice looking graph though!

 a dependancy graph of which modules a program uses might be doable.
 more nodes for pieces in the module and other filesystem dependancies.
 
 
    numberOfChildren() nthChild(n) lastChild()
    """
    import leoGlobals as g
    import os
    import pydot
    import string  #why?

    fname = r'c:\temp\pydotOut.jpg'

    #maybe there is a way to know this for sure
    #you still might want to specify it
    Leo = 4.1   


    c = g.top()

    if Leo &gt; 4.1:
         p = c.currentPosition()
    else:
         p = c.currentVnode()

    &lt;&lt; code &gt;&gt;
        
    graph = pydot.Dot(simplify= True, ordering= "out")

    root = p  #g.findNodeInTree(p, "Root") #another 4.2ism or in leotest

    addLeoNodesToGraph(root, graph, top= True)
    graph.write_jpeg(fname, prog= 'dot')

    g.es('graph of outline written to \n' + fname)
</t>
<t tx="EKR.20040608165334.66">@others</t>
<t tx="EKR.20040608165334.67">
def addLeoNodesToGraph(p, graph, top= False):
    """
    p.v attribute is 4.2, this might be a dealbreaker for 4.1?
    butchering it up just to get some output
    the node ovals are too large
    
    """

    # Create p's vnode.
    if Leo &gt; 4.1:
        n = vnodeRepr(p.v)
        l = vnodeLabel(p.v)
    else:
        n = vnodeRepr(p)
        l = vnodeLabel(p)

    thisNode = pydot.Node(name= n, label= l)
    graph.add_node(thisNode)

    
    if p.hasChildren():
        child = p.firstChild()
        childNode = addLeoNodesToGraph(child, graph)
        graph.add_node(childNode)

        if Leo &gt; 4.1:
            e1 = tnodeRepr(p.v.t)
            e2 = vnodeRepr(child.v)
        else:
            e1 = tnodeRepr(p)
            e2 = vnodeRepr(child)

        edge2 = pydot.Edge(e1, e2)
        graph.add_edge(edge2)

        
        #     child.next() could error?  hasattr(child, 'next()')?
        while child.next():  #child.hasNext() 4.2
            next = child.next()
            
            if Leo &gt; 4.1:
                e1 = vnodeRepr(child.v)
                e2 = vnodeRepr(next.v)
            else:
                e1 = vnodeRepr(child)
                e2 = vnodeRepr(next)

            edge =  pydot.Edge(e1, e2, dir="both")

            nextNode = addLeoNodesToGraph(next, graph)
            graph.add_node(nextNode)
            graph.add_edge(edge)
            child = next
            
    if 1:
        if Leo &gt; 4.1:
            n = tnodeRepr(p.v.t)
            l = tnodeLabel(p.v.t)
        else:
            n = tnodeRepr(p)
            l = tnodeLabel(p)

        tnode = pydot.Node(name= n, shape="box", label= l)
        
        if Leo &gt; 4.1:
            e1 = vnodeRepr(p.v)
            e2 = tnodeRepr(p.v.t)
        else:
            e1 = vnodeRepr(p)
            e2 = tnodeRepr(p)

        edge1 = pydot.Edge(e1, e2, arrowhead= "none")
        graph.add_edge(edge1)
        graph.add_node(tnode)
    
    if 0: # Confusing.
        if not top and p.v._parent:
            edge = pydot.Edge(vnodeRepr(p.v),vnodeRepr(p.v._parent),
                style="dotted",arrowhead="onormal")
            graph.add_edge(edge)

    if 0: # Marginally useful.
        for v in p.v.t.vnodeList:
            edge = pydot.Edge(tnodeRepr(p.v.t),vnodeRepr(v),
                style="dotted",arrowhead="onormal")
            graph.add_edge(edge)

    return thisNode</t>
<t tx="EKR.20040608165334.68">
def tnodeLabel(t):

    if Leo &gt; 4.1:
        tl = len(t.vnodeList)
    else:
        tl = 0

    return "t %d [%d]" % (id(t), tl)
    
def vnodeLabel(v):
    
    return "v %d %s" % (id(v),v.t.headString)
</t>
<t tx="EKR.20040608165334.69">
def dotId(s):
    """Convert s to a C id"""

    s2 = [ch for ch in s if ch in (string.letters + string.digits + '_')]
    return string.join(s2,'')

def tnodeRepr(t):

    return "t_%d" % id(t)
    
def vnodeRepr(v):
    
    return "v_%d_%s" % (id(v),dotId(v.headString()))

</t>
<t tx="EKR.20040608165334.70">
def dynaM_evaluator(c):
    """calc_util.py and its unit tests and rClickclass 
   from http://rclick.netfirms.com/rCpython.htm

    ******* not available yet *********
    parsing python programs perfectly presumes perfect programming.
    its so close, I use it all the time to verify code.
    but I know its limitations and I cant realease it yet,


   does good job of reindenting, but still can make mistakes indenting after dedent or comment or before an indent
   compare to origional code carefully!
   
    forgot to tell evaluator to skip to @c if it finds @ alone
    output to log doesnt colorize so isnt immediatly obvious
    the html mode should be reparsed to change to es color output
    need to add an eval mode so can get expression outpt as well
    have to trap stdout so can use to paste if thats selected
    capture seems to be working now from plugin or button
    fixbody takes care of commenting out @directives now.

    if nothing selected, it seems to have nothing?
    weird, its now going to the console again from the button
    and from plugin nothing if nothing selected.
    this is easily the 3rd time it was then wasnt working.
    all the calls are same as pychecker2, it sometimes prints the data
    inside the if. something is erroring and getting masked.
    
    """
    try:
        import calc_util ;#reload(calc_util) #if working on calc_util
    except ImportError:
        g.es('you have to get the evaluator first')
        return

    newSel = dynaput(c, [])
    data = fixbody(newSel, c)
    #print repr(data)


    if data and len(data) &gt; 0:

        #ta = g.stdOutIsRedirected()
        #g.restoreStdout()
            

        #print repr(data)

        o = captureStd()
        o.captureStdout()

        try:
            #this has print on line by line as parsed
            newdata = calc_util.file_test(data, q= 1,
                 doEval= 0, formater= 'py2py',  #py2py raw html
                    onlyPrintFails= 0, printAny= 0 )

        except Exception, err:
            dynaerrout(err,'evaluator ')

        output = o.releaseStdout()
        #if ta:
        #    g.redirectStdout()
            

        dynaput(c, output.splitlines(True))

    #elif len(data) &lt; 80: maybe check for newlines better?
    #    eror, result, ppir = calc_util.evalcall(data)

#</t>
<t tx="EKR.20040608165334.71">

def dynaM_r(c):  #part of the dynabutton macro script
    """
    """
    newSel = dynaput(c, [])
    g.es("selected ")
    if not newSel:
        g.es("...skip, dump the body")
        v = c.currentVnode() # may chg in 4.2
        newSel = v.bodyString()

    #print 'newSel =', newSel
    if not newSel or len(newSel) == 0: return
    data = str(newSel)
        
    sx = []
    for x in data.splitlines():
        sx.append(x[1:] + '\n' )  #"'%s"%(s.lower(),)
        
    dynaput(c, sx)

#
#by pass while in plugin,
# for testing while included in dynatester node
#
if __name__ != 'dyna_menu':
    try:
        __version__
    except NameError:  
    
        def testbs():
            lst = """"\
            'This', 'can', 'also', 'be', 1, 
            'is', 'an', 'so', 'e', 0, 
            """.splitlines(True)
    
            lst =  [x.lstrip() for x in lst]
            print 'lst =', lst
            return lst

        genteststr.tstlst = testbs()
        testmacro = 'dynaM_r'</t>
<t tx="EKR.20040608165334.72">various attempt to use parsers and regex to make a dict
not including the one actually working

csv is a more general one which might be used on a file or to write to file

</t>
<t tx="EKR.20040608165334.73">def dynaM_yaml(c):
    """Python Mailing List
    """
    import yaml
    print yaml.load("""
    rub1:
        - one
        - two
    rub2:
        - three
        - four
    """).next()
    
    #{'rub1': ['one', 'two'], 'rub2': ['three', 'four']}
    
    #it can also work on the other side :
    
    print yaml.dump({'rub1': ['one', 'two'], 'rub2': ['three', 'four']})
    """---
    rub1:
        - one
        - two
    rub2:
        - three
        - four
    """</t>
<t tx="EKR.20040608165334.74">

#can execute script on this alone, no testing no dependancies

def dynaM_pullparse(c):
    """another day another parser. pullparser is great!
    I have a few things I do with it all the time.
    rclick saveas on aspn cookbook re title script
    I dont rename things to my later concernation when I saveas
    I allways download into the same directory and move things around later
    so using pullparser script to get the title on all htm*
    you can then rename to the cookbook title and move them.
    another script pulls data out of tables in an archive html.
    
    this macro just goes through the named directory mask prints titles
    you could have it give a better name to the file if it needs one.
    also might search for specific title or other text in all html's
    matching or similar to selected text.
    use it to reparse a file generated by @rst or @html node 
     while debugging to verify everything is correct
    
    
    pullparser
     http://wwwsearch.sf.net/bits/pullparser.py

    mx.Tidy
      #http://www.egenix.com /files/python

    there are other tidy and you can get the tidy source
    """
    
    from mx.Tidy import tidy  #* 
    import misc.pullparser as pull
    import glob, sys
    
    files = glob.glob(r'c:\html\*.htm*')
    print len(files), files
    
    #print [ x+'\n\r' for x in files]  #.split() no split? no \n
    #for x in files:print x+'\n'

    #occasionally will complain about some html or other
    #see the error message and move that html
        
    &lt;&lt;readers&gt;&gt;
    
    
    i=0
    for x in files:
        if i&gt;3:  #do only 3
            break; 
        else: 
            i+=1
            
        data = file(x).read()     

        (nerrors, nwarnings, outputdata, errordata) = \
           tidy(data,
                uppercase_tags= 1,
                #alt_text= "", 
                #raw, ascii, latin1, utf8 or iso2022 
                char_encoding= "ascii",  
                quiet= 1,
                wrap= 0,
                indent= "yes",  #no, yes or auto 
                clean= "yes",
                drop_font_tags= 1,
                # yes, Tidy will strip out all the surplus stuff 
                word_2000= "yes", 
                )
    
        # pullparser only takes file objects not just data...
        # a StringIO object here might be simpler
        
        #if nerrors:  print errordata

        mf = TextReaderdata(sys.stdin,  outputdata)
        
        try:
            p = pull.PullParser(mf)
        
            if p.get_tag("title"):
                title = p.get_compressed_text()
                print "\n---%s  %s---"% (title, x[-14:])

        except pull.NoMoreTokensError, err:
            print x, err

        continue  #process more later
    
        #pullparser only recognizes lower case tags in matches
        #either is fine in the html

        for token in p.tag_iter("span"):
            if token.type == "endtag": continue

            #works w/name w/class
            nam = dict(token.attrs).get("class", "-")  
    
            text = p.get_compressed_text(endat=("endtag", "span"))
    
            if not text: continue  #will pass empty instead of error
    
            
            if nam == 'profileheader':
                text = 'areas: '+ text
    
    
            if nam == 'profilenavbartext': continue
            
    
            print "%s" % ( text )

        mf.close()  #

#a similar switch could be inside the function
#to supply data if in test mode 
#or get data from selected text or body    

if __name__ != 'dyna_menu':
    try:
        __version__
    except NameError:  
        dynaM_pullparse(None)
#e</t>
<t tx="EKR.20040608165334.75">
#u04208ap09:16  you can clone this node to other pullparser scripts

#from __future__ import generators
import os, sys

"""

f=file('LEOpy.txt','w')
owrite= TextWriter(sys.stdout, self.text ) 
sys.stdout = owrite 

    data=TextReadernode(sys.stdin, "Bockstein" ,quiet=1).read(444444) #Lascurettes
    mf=TextReaderdata(sys.stdin,  outputdata)
    
    #mf=TextReaderdata(sys.stdin,  outputdata ,quiet=1)   #file(x).read()
    #mf=TextReaderfile(sys.stdin,  file(x)  ,quiet=0)


    data=TextReadernode(sys.stdin, node ,quiet=1).read() 
"""

def blocks(infile, size= 1024 ):
    while True:
        block = infile.read(size)
        if len(block) == 0:
            break
        yield block
 
class TextWriterfile:

    def __init__(self, stdout, ofile, quiet= 1 ):
        self.stdout = stdout
        #self.stdo = sys.__stdout__ 
        sys.__stdout__ = ofile
        self.ofile = ofile
        self.quiet = quiet

    def write(self, text):
        self.stdout.write(text)
        #if self.quiet == 0:
        #    self.stdo.write(text)

    def close(self):
        #sys.__stdout__ = self.stdo
        self.stdout.close()
        self.ofile.close()


class TextReaderfile:

    def __init__(self, stdin, infile, quiet= 1 ):
        #stdi = sys.__stdin__ 
        #sys.__stdin__ = stdin
        self.stdin = stdin
        self.infile = infile
        self.dline = 0
        self.quiet = quiet
    #little shaky ground here
    def read(self, buff, x= 0, y= 0 ):
        #can it be a generator yeild the next line?
        #print 'buf=',buff  ,      
        if not self.dline:
            self.dline+=buff
            blocks(self.infile, buff)
 
        if self.dline != buff:
            print buff ,'buf!=',self.dline 
 
        if not self.quiet:
            datas = blocks(self.infile, buff).next() 
            print buff ,'buf=',datas
            return datas
 
        return blocks(self.infile, buff).next() 
 
    def write(self, buff, rbuff):
        pass
 
    def close(self):
        #self.stdin.close()
        #del self.datas
        pass

class TextReaderdata:

    def __init__(self, stdin, datas, quiet= 1 ):
        #stdi = sys.__stdin__ 
        #sys.__stdin__ = stdin
        self.stdin = stdin
        self.datas = datas
        self.dline = 0
        self.quiet = quiet

    #little shaky ground here
    def read(self, buff,x=0,y=0):
        #buff=self.stdin.read()
        #print 'buf=',buff  ,      
        self.dline += buff
        if self.quiet == 0:
            print buff ,'buf=', self.datas[self.dline - buff:self.dline]
        return self.datas[self.dline-buff:self.dline]
 
 
    def write(self, buff, rbuff):
        pass
 
    def close(self):
        #self.stdin.close()
        #del self.datas
        pass
 
class TextReadernode(TextReaderdata):
    """needs a little work to be reliable
    another one of my earlyier attempts 
    to bring the data to the script
    """
    import leoGlobals as g
    import leoTest
 

    def __init__(self, stdin, node, quiet=1):
        #self.stdin = stdin
        c = g.top()
        #v=c.currentVnode() # get the current vnode.
        #print v
        #print "head:", v.headString()
        u = leoTest.testUtils()
        v = u.findNodeAnywhere(c,node)
        print "using data fro:",v
        TextReaderdata.__init__(self, stdin,v.bodyString(),quiet)
        
#e</t>
<t tx="EKR.20040608165334.76">
def dynaM_dateform(c):
    '''take a date in one of many recognized formats
    and translate into the selected degault format
    this is for a series of TV scheduling text and todo
    that accumulated various haphazzard ways of specifying time
    this might just cover a few of the more common ones 
    just for kicks.
    got it setup to start tweeking anyway
    for some reason, m is not None 
    because it has a bunch of empty tuples ?
    it always worked as a switch before. maybe should use group()

    parsers and re are not produceing the results they usually do in dyna
    I wonder if there is something extra in or missing from 
    locals or globals that is throwing them or me off our game
    @ file-nosent .py run from outside Leo, same error
    nothing to repeatm did get the source line that the error is on
    wonder why im not getting that now
    have to remove ? for nongreedy matches to avoid error. makes no sense
    
    alot of what is obvious comes from the context. there is some redundancy
    which the re or parser cant pick out. 
    might have to go char by char FSM

    '''
    newSel = dynaput(c, [])
    if not newSel: return
    data = str(newSel)
    #might want to do the whole body later after some debugging

    print 'text is', data
    import re
    
    #make a first try at adding consitant seperators between
    #let below handle rearranging the various parts

    #a/p can appear anywhere first problem
    #can be s, sa, sat same for other days of the week
    #are matches shifted down if one matches before it?
    #need to know more about conditional matching
    #wish I could use a parser on this

    #^    
    firstspliter = re.compile(
    r"""
\s*
([a-z]*?)
\s*
(a|p|am|pm)*?
\s*
([0-9:]*?)
(a|p|am|pm)*?
\s*
(.*)
""",
    re.VERBOSE | re.IGNORECASE
    )  
    #$ addeing ? for nongreedy gives nothing to repeat error

    """ (?i)(?P&lt;month&gt;january|jan|february|feb|march|mar|april|apr|may|june|jun|july|jul|august|aug|september|sep|october|oct|november|nov|december|dec)\s+(?P&lt;day&gt;3[01]|[0-2]{0,1}\d),\s*(?P&lt;year&gt;\d{4})\W*


   """
    

    sx = []
    m = firstspliter.findall(data)
    if m:
        print 'm is %r'%(m,)
        for i in range(1, len(m)):
            for mt in range(len(m[i])):
            
                if not m[i][mt]: continue
                sx.append('@' + m[i][mt])

    if sx: data = ' '.join(sx)

    print 'data is %r'%(data,)

    #raise SystemExit #need a way to exit w/o traceback

    sx = []
    for x in data.splitlines():
        #print 'for x', x

        if not x: 
            continue

        if x in ' ' :
            x1 = x.split() 
            for i, y in enumerate(x1):
                #print 'for y', y

                if i == 1: 
                    sx.append(":")

                sx.append("%s "%(y,))

        else: #no seperator 
                sx.append("%s"%(x,)) 
        sx.append(", ")


    dynaput(c, sx)


#
#by pass while in plugin,
# for testing while included in dynatester node
#
if __name__ != 'dyna_menu':
    try:
        __version__
    except NameError:  
        #a full index and sort required to tell how many
        #different formats there are
        def testbs():
            lst = """\
            SA1000 T6-24 
            SA  0100  T6-15  
            sa7 w1=24 
            SAT Midnight T5-09 
            """.splitlines(True)
    
            lst =  [x.lstrip() for x in lst]
            print 'lst =', lst
            return lst

        genteststr.tstlst = testbs()
        testmacro = 'dynaM_dateform'

        </t>
<t tx="EKR.20040608165334.77">def dynaM_csv(c):
    """attempt to get cvs input parsed from file or selected text
     filename assumed if no coma in the selected text or copy buffer
     parts of StringIO idea from some recent blog.

    """
    #ere = rewe
    newSel = dynaput(c, [])
    #print 'newSel =', newSel

    if not newSel: return
    data = str(newSel)

    try:
        import csv
    except ImportError:
        print 'no csv try http://www.object-craft.com.au/projects/csv/'
        #grab csv.py and _csv.c from the 2.3 distro 
        #http://www.python.org/peps/pep-0305.html
        #http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/python/
        # python/nondist/sandbox/csv/
        return

    #grabed from a wx csv demo posted
    #dirname = dlg.GetDirectory()
    #filename = os.path.join(self.dirname, dlg.GetFilename())
    #f = file(self.filename, 'r')
    #csvfile = csv.reader(self.file )

    sf = StringIO.StringIO()
    csvReader = csv.reader(sf)
    #data = '1,2,three,"four,five",6'
    sf.write(data)

    # We have to seek the StringIO pseudo-file back to its start.
    sf.seek(0,0)

    # Now read in the same data via the csv reader object.
    parsedData = csvReader.next()
    print parsedData


    """#grab a sample and see if there is a header
    sample = self.file.read(8192)
    self.file.seek(0)
    if csv.Sniffer().has_header(sample ):
        colnames = csvfile.next()
    else:
        row = csvfile.next()
        colnames = []
        for i in len(row ):
            colnames.append('col%d' % i )
        self.file.seek(0)"""

#
#by pass while in plugin,
# for testing while included in dynatester node
#
if __name__ != 'dyna_menu':
    try:
        print __version__
    except NameError:  
    
        def testbs():
            lst = """\
            'This', 'can', 'also', 'be', 1, 
            'is', 'an', 'so', 'e', 0, 
            """.splitlines(True)
            lst =  [x.lstrip() for x in lst]
            print 'lst =', lst
            return lst

        genteststr.tstlst = testbs()
        testmacro = 'dynaM_csv'</t>
<t tx="EKR.20040608165334.78">def dynaM_fix_pack(c):
    '''#w04505p06:45:43 used first for changing Tk pack options to dict's
    good for making any dic from (=), [=], ot=1, pairs
    #side=Tk.LEFT, expand=1, fill=Tk.BOTH
    #{'side':'left', 'expand':'1', 'fill':'both'}
    #this might have been ok as a find/change script as too...   
    taking the long way around using a re in the first place probably
    updateing to leave numbers unquoted, which might be bad if single hex digit
    left it in worse shape for now. meaning if not well formed it may error
    side=BOTTOM , fill=BOTH, expand=YES
    need to seperate words from punctuation then recombine in dict form
    continuing to work around individual bad cases is nuts
    copied out the orgfixpackm now free to change it around
    this is where a bunch of test casses would be helpfull in test mode
    '''

    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)
    import re
    #gnosis\util\XtoY.py
    pat_fl = r'[-+]?(((((\d+)?[.]\d+|\d+[.])|\d+)[eE][+-]?\d+)|((\d+)?[.]\d+|\d+[.]))'
    re_float = re.compile(pat_fl+'$')
    re_zero = '[+-]?0$'
    pat_int = r'[-+]?[1-9]\d*'
    re_int  = re.compile(pat_int+'$')
    pat_flint = '(%s|%s)' % (pat_fl, pat_int)    # float or int

    sx = []
    sx.append('{')  # + '\n' 
    print 'text is', newSel
    for x in newSel.split():
        s = x.replace('"', "'").replace("'", "")
        s = s.replace("=", "':'")
        s = s.replace('Tkinter.', "").replace('Tk.', "")
        s = s.replace(",", "', ").replace(" '", "'").lower()

        print 's', s
        if s == "', " or s == "'":
            #need to check for anynumber of wrong things
            sx.append(s)
            continue

        #idealy it wouldn't add SQ around plain numbers
        #split on , then is_a_number(ix) each and re SQ if False
        a = s.split(', ')
        print a
        nonumb = False
        if a:
            for x1 in a:
                if not x1: continue
                b = x1.replace("'","").split(':')
                if not b: 
                    #print 'nomatch b'; 
                    continue
                #print b
                bt = b[-1]
                if re.match(re_int, bt): 
                    ia = "%s"%int(bt)
                elif re.match(re_float, bt):
                    ia = "%s"%float(bt)
                else: 
                    nonumb = True
                    ia = b[1]

                #print b, ia 
                sx.append("'%s:%s"%(b[0],ia) )
                if x1 != a[-1]:
                    sx.append(", ")

        else: sx.append("'%s"%(s,) )

    if nonumb:
        sx.append("'")

    sx.append("}")
    dynaput(c, sx)

def is_a_number(x):
    """from cookbook poster idea"""
    try:
        int(x) #float(x) 
        return True
    except ValueError:
        return False</t>
<t tx="EKR.20040608165334.79">def dynaM_Tkpackpypars(c):
    '''Tkpackpyparsing changing Tk pack options to dict's
    good for making any dic from (=), [=], ot=1, pairs
    comas inside strings are ok. if no coma then split on space
    more pyparsing to handle = -&gt; : transparently
    
    I installed pyparsing in misc, check your own import
    http://pyparsing.sourceforge.net
    
    '''
    from misc.pyparsing import commaSeparatedList

    #allow quoted numbers?
    integer  = Word(nums )
    variable = Word(alphas )

    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)

    sx = []
    sx.append('{')
    print 'text is', newSel

    for x in newSel.splitlines(True):
        #this will wrongly count coma in string too
        if not x.count(','):
            #print 'comma not there.'
            ls = x.split()
        else:
            #print 'comma is there.'
            print commaSeparatedList.parseString(x)
            ls = commaSeparatedList.parseString(x)

        #may want to try a split again on =
        #or fix the parser to split on space,=, or coma

        for x1 in ls:

            s = x1.replace('"', "'").replace("'", "")
            s = s.replace("=", ":").replace(" =", ":").replace("= ", ":")
            s = s.replace('Tkinter.', "").replace('Tk.', "")
            s = s.replace("' ", "").replace(" '", "").lower()

            if s.count(':'):
                s1 = s.split(':')
                try:
                    int(s1[1])  #could be float too
                    sx.append("'%s':%s"%(s1[0],s1[1]) )
                except:
                    sx.append("'%s':'%s'"%(s1[0],s1[1]) )

            else: sx.append("'%s'"%(s,) )

            sx.append(", ")

        #sx.append(", ")  #hav to have a lastcoma flag
        
    sx.append("}")
    dynaput(c, sx)</t>
<t tx="EKR.20040608165334.80">
def dynaM_pyparseTk(c):
    '''dyna_pyparTk changing Tk pack options to dict's using pyparsing
    good for making any dic from (=), [=], ot=1, pairs
    comas inside strings are ok. if no coma then split on space
    might have already a dict using = or : between and already quoted
    may want a simpler varient that takes a list of words and adds :1
    may not want lower(). add an instance varb that can be easily changed
    limited identifter to alphanumeric or number for now
    changed so now it isnt recognizing dotted names as one name.
    not quite getting the feedback to what is happening well.

    was good but add more pyparsing to handle = -&gt; : transparently
    before would get confused if misc space on either side of some chars
    stealing from the examples or c.l.py or DK tutorial
    should be easily usefull in the dynaplayback thing
    first real use of pyparsing beyond running a few examples.
    earlier versions crashed and I think requires generators or py2.3

    its only matching the first pair, not sure this will be simpler
    looses it on doted names or real, makes 2 words.
    may have to shelve this as a viable idea in the time alloted
    
    I installed pyparsing in misc, check your own import location
    http://pyparsing.sourceforge.net
    '''
    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)

    from misc.pyparsing import ZeroOrMore, Word, Literal, quotedString, Group
    from misc.pyparsing import alphanums, nums, alphas, Forward, OneOrMore
    from misc.pyparsing import ParseException, RecursiveGrammarException
    import misc.pyparsing as prs

    lineDef = Forward()

    singleLineComment = "#" + prs.restOfLine

    quotedString.setParseAction(lambda s,l,t: t[0].strip("'\""))
    #SDq = Literal('"').suppress() ^ Literal("'").suppress()

    real = Word(nums + '.')
    integer = Word(nums)
    #.setParseAction( lambda ( s, loc, toks  [ int(toks[0]) ] )

    #this will? fully validate dotted names. its breaking it up, not greedy?
    partname = Word(alphas + alphanums + "_" )
    dotname = partname + ZeroOrMore('.' + partname)
    identifier = partname ^ dotname  #|^ the same? order no diff
    
    #Upcase why no Lowcase?
    #varb = ZeroOrMore(SDq) + (identifier ^ integer) + ZeroOrMore(SDq)

    varb = (quotedString | identifier | integer | real) # | singleLineComment 
    #ZeroOrMore("=" ^ ":")  fails
    fieldDef = Group(varb + ZeroOrMore("=") + ZeroOrMore(varb)  + ZeroOrMore("," ))
    lineDef &lt;&lt;  fieldDef | lineDef

    try:
        lineDef.validate() 
    except (ParseException, RecursiveGrammarException):
        print 'parser problem validate'
        raise

    print 'text is', newSel

    sx = []
    sx.append('{')

    for x in lineDef.parseString(newSel):
        print 'for x', x

        if x == ',':
            print 'is x coma'
            sx.append(", ")
            continue

        for x1 in x:
            print 'for x1', x1

            if x1 in '=:': 
                sx.append(":")
                continue
            elif x1 == ',':
                print 'is x1 coma'
                sx.append(", ")
                continue

            try:
                #sx.append("%d"%int(x1) )
                sx.append("%d"%float(x1) )

            #maybe float and int will have different errors
            #maybe if int it isnt coerced to float? works for me.
            except Exception, e:
                #print 'exception', e.args

                s = x1.replace('Tk.', "").replace('Tkinter.', "")
                sx.append("'%s'"%(s.lower(),) )


    sx.append("}")
    dynaput(c, sx)

#
#by pass while in plugin,
# for testing while included in dynatester node
#
if __name__ != 'dyna_menu':
    try:
        print __version__
    except NameError:  
        def testbs():
            lst = """\
            side"=1, expand = 1 , fi_ll=Tk.BOTH
        (=), [=], whatever 
        side= Tk.LEFT , expand =1, 'fill'=Tk.BOTH,
            """.splitlines(True)
            lst =  [x.lstrip() for x in lst]
            print 'lst =', lst
            return lst

        genteststr.tstlst = testbs()
        testmacro = 'dynaM_pyparseTk'
    </t>
<t tx="EKR.20040608165334.81">def dynaM_PlexTk(c):
    '''dyna_PlexTk changing Tk pack options to dict's using Plex
    match alphanumeric on either side of =: or space or coma delimited
    build a dict or list from it. properly quoted and verifyed numbers
    only getting the first word. scanner suposto return a tupple, isnt.
    made class from StringIO, scanner is requestion 4096 bytes as a str
    
    http://www.cosc.canterbury.ac.nz/~greg/python/Plex/
    '''
    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)

    import Plex

    letter = Plex.Range("AZaz")  #
    digit = Plex.Range("09") 
    name = letter + Plex.Rep(letter | digit | Plex.Any("_."))
    number = Plex.Any("-") + Plex.Rep1(digit) + Plex.Any(".") + Plex.Rep1(digit)
    varb = number | name
    space = Plex.Any(" \t\n")
    quot = Plex.Any("\"'")
    coma = Plex.Any(",")
    comment = Plex.Str("#") + Plex.Rep(Plex.AnyBut("\n"))
    
    lex = Plex.Lexicon([
        (varb,              Plex.TEXT),
        (Plex.Any("=:"),   Plex.TEXT),
        (coma,            Plex.TEXT),
        (space | quot,   Plex.IGNORE),
        (comment,      Plex.TEXT),
    ])

    class myio(StringIO.StringIO):

        def __init__(self, data):
            StringIO.StringIO.__init__(self, data)

        def read(self, *amt):
            print 'read amt', amt
            return self.getvalue()
        
    sio = myio(newSel)
    
    scanner = Plex.Scanner(lex, sio, 'PlexTk')

    print 'text is', newSel

    sx = []
    sx.append('{')

    #ValueError: too many values to unpack  #value, text
    for x in scanner.read():
        if x is None:
            break
        print 'for x', x

        if x == ',':
            print 'is x coma'
            sx.append(", ")
            continue

        if x in '=:': 
            sx.append(":")
            continue


        try:
            #sx.append("%d"%int(x) )
            sx.append("%d"%float(x) )

        #maybe float and int will have different errors
        #maybe if int it isnt coerced to float? works for me.
        except Exception, e:
            #print 'exception', e.args

            s = x.replace('Tk.', "").replace('Tkinter.', "")
            sx.append("'%s'"%(s.lower(),) )


    sx.append("}")
    dynaput(c, sx)

#
#by pass while in plugin,
# for testing while included in dynatester node
#
if __name__ != 'dyna_menu':
    try:
        print __version__
    except NameError:  
        def testbs():
            lst = """\
            side"=1, expand = 1 , fi_ll=Tk.BOTH
        (=), [=], whatever 
        side= Tk.LEFT , expand =1, 'fill'=Tk.BOTH,
            """.splitlines(True)
            lst =  [x.lstrip() for x in lst]
            print 'lst =', lst
            return lst

        genteststr.tstlst = testbs()
        testmacro = 'dynaM_PlexTk'

    </t>
<t tx="EKR.20040608165334.82">def dynaM_org_fix_pack(c):
    '''#w04505p06:45:43 used first for changing Tk pack options to dict's
    good for making any dic from (=), [=], ot=1, pairs
    #side=Tk.LEFT, expand=1, fill=Tk.BOTH
    #{'side':'left', 'expand':'1', 'fill':'both'}
    #this might have been ok as a find/change script as too...   

    '''

    newSel = dynaput(c, [])
    if not newSel: return
    newSel = str(newSel)

    sx = []
    sx.append('{')  # + '\n' 
    print 'text is', newSel
    for x in newSel.split():
        s = x.replace('"', "'").replace("'", "")
        s = s.replace("=", "':'")
        s = s.replace('Tkinter.', "").replace('Tk.', "")
        s = s.replace(",", "', ").replace(" '", "'").lower()

        sx.append("'%s"%(s,) )

    sx.append("'}")
    dynaput(c, sx)</t>
<t tx="EKR.20040608165334.83">def dynaM_call_fixbody(c):
    """test fixbody, need to be able to 
    roam around an see what data it produces.
    making test data is devils work.
    
    testing forklike, adding command.com gives me dosprompt
    and cant see how to get seperate process from leo
    it reuses the same console
    
    """
    #1/0 
    runFile = 1

    newSel = dynaput(c, [])  #is there anything selected
    #get body if nothing, 
    #in either case, parse and comment @directives
    data = fixbody(newSel, c)   
    
    print repr(data)  #dynaHexdump(data, length=8)

    if runFile:

        g.es('writeing tmpfile', tmpfile )
        fo = file(tmpfile,'w')
        fo.writelines(data + "\n#e\n")
        fo.close()
        
        if 0 or 0:
            g.es('running reindent', py + reindent + tmpfile )
            out, err = runcmd(py + reindent + tmpfile)
            for x in (out + err).splitlines():
                g.es(x)

        g.es('forking tmpfile', py + tmpfile )


        #out = forklike(r'c:\Command.com', '/k', py, tmpfile )  #'-i', 
        out = forklike(py, tmpfile )  #'-i', 

        #OSError, WindowsError and others possible:
        g.es(out)</t>
<t tx="EKR.20040608165334.84"># This is a script, _not_ a plugin.

from __future__ import generators
# from __future__ import enumerate

&lt;&lt; about dynaclick &gt;&gt;

import leoGlobals as g
import leoPlugins

try: import Tkinter as Tk
except ImportError: Tk = None

__version__ = '0.032 f04604p10:27:47 '[:5]

NDebug = True or False

@others

c = g.top()
cf = c.frame

deldyna()

#using both names here to avoid the same name for button and menu
#the menu name is used in common and plugin. this will shake out eventually
#the dynaBunch is in common and plugin and button call the same init
dynavar = dynaMvar = c.frame.dynavar = init_dyna(c)

#dynavar.dynaiconImage = Tk.PhotoImage(master=None, data=icon)
# imagefile= 'dyna.gif'

dynavar.dynacb = cf.addIconButton(text= "dyna",   #image= iconImage,
    bg= 'red', command= dynaclick )  #bg has no effect

#need expand= 1 so other buttons cant takeover dynaclick button space
#isnt a config option and addIconButton doesnt pass it on


#dynavar.dynacb = Tk.Button(cf.body, text= 'dyna', command= dynaclick,
#                       bg= 'gray20', fg= 'blanchedalmond' )
#dynavar.dynacb.pack({'side':'right', 'expand':0, 'padx':3, 'pady':3})
#dynavar.dynacb.configure({'image':cf.dynaiconImage, 'height':4, 'width':24, 'padx':3})

dynaconfig = {'font':('verdana', 7, 'bold'), 'bg':'AntiqueWhite1'}
dynavar.dynacb.configure(dynaconfig)
cf.statusText.configure(dynaconfig)

#expand1 didnt help, dyna still gets crunched if other buttons arent full size
#meaning on my 17" screen 1024x768? leo must be open to an inch of one side
#using node navigator searchbox hoist and newbuttons, 
#custom edited all of them to be smaller than default, need even smaller fonts!

dynavar.dynacb.pack({'anchor':'w', 'side':'left', 'expand':0, 'padx':2, "fill":"x",})

#print dynavar.dynacb.config()

#these also change the rclick and some of the menus
#isnt consistant, rclick gets real big on size 8, hardle affects the other buttons
#have to experiment w/optionDB for leo, 
#could radically change the config thing, at least for Tk Leo
#dynavar.dynacb.option_readfile('optionDB')
#dynavar.dynacb.option_add('*font', ('verdana', 8))
#dynavar.dynacb.option_add('*font', ('verdana', 8, 'bold'))

#bind double right click button3 to make dynaclick dissapear
#this isnt that good, does the something before disapearing
#dynavar.dynacb.bind('&lt;Double-3&gt;', dynaclick)

#should add unbind to deldyna which implys some automated bind dict.
#use rclick to select different functions
dynavar.dynacb.bind('&lt;3&gt;', dynamenu)

#bind Alt-F12 to dosomething, needs work, alt1 is already bound
#F11 L1, F12 L2  , didnt work either no, single or double brackets
#Alt-Q not bound to anything and it doesnt work, why not working?
#dynavar.dynacb.bind('&lt;'+'Alt-q&gt;', dynaclick)
#woops, once the button has focus, there would be no need for Alt-q
#better bind to something else
cf.bodyCtrl.bind('&lt;'+'Alt-q&gt;', dynaclick)

cf.clearStatusLine()
for msg, color in (('dyn',"red"),('a',"coral3"),('click',"blue")):
    cf.putStatusLine("%s"%(msg,), color= color )

#dynadoc(c)
#dynadoc(c, 'dynaM_wraper')
#print dynavar

print "dynaclick button installed"
#print g.getBaseDirectory(), g.app.loadDir
#c:\c\leo C:\c\leo\leo4CVS233\src
#if g.os_path_exists(dir): 
#print g.os_path_abspath('.')</t>
<t tx="EKR.20040608165334.85">@
clone or copy macro into this node
they get added to the rightclick of the dynabutton
the first function will be active on the leftbutton click
only the first macro in each node is added

unification of all the little scripts into one grand menu dyna_menu.py plugin

use the leo script version of dynabutton to debug the macros
with quicker turnaround than in a plugin.


in dynabuttonmenu
while child and number &lt; 12: #limits items in the rclick

#
@c
</t>
<t tx="EKR.20040608165334.86">def dynaM_dynaplay(c):
    """first cut attempt to get playback of commands into buffer
    """    
    #dynaplay(c, ['#', '%%C,[home]', '%%C,[down]', '%%C,[repeat]' )
    #dynaplay(c, ['#', '%%C,[home]', '%%C,[down]4', '%%C,[repeat]3'] )

    dynaplay(c, ['#', '%%C,[home]', '%%C,[down]',] )  #works
    
    #here it gets tricky changing print x, y, z or print x + y #
    #in find/change it would also be difficult
    #this one needs work, end not implimented
    #also not tested with single line selection
    #would need to go outside the selection to do this
    #dynaplay(c, ['g.es(', '%%C,[end]', ' )', '%%C,[home]', '%%C,[down]',] )
</t>
<t tx="EKR.20040608165334.87">
def dynaM_sortnumb(c):
    """do a numeric aware sort, add field selection later
    maybe even a regex selection or other field specifyer
    can sort a list by copying the seperator then selecting some words
    default seperator is space, \n for multilines
    I realize other options might sometimes be required
    for those times, copy DQ3 and make something specilized.
    checking for multiple lines could be less redundant, ok for now.
    now how do I do a reverse sort?
    have a little helper function to call this with d=1
    need to preserve lineending if selected multiline,
     splitlines(True) ok if body
     how. each choice gets me deeper into trying to guess everything

     keeping indented lines together would allow sorting headlines
     and possibly functions. using a script in the copy buffer?

    """    
    nothingselected = False
    data = dynaput(c, [])
    g.es("selected ")
    if not data:
        nothingselected = True
        g.es("...skip, dump the body")
        v = c.currentVnode() # may chg in 4.2
        data = v.bodyString()

    #maybe use DQ3 thing of the copybuffer to select the splitchar
    splitchar = g.app.gui.getTextFromClipboard()

    multiline = ''
    if not splitchar:
        splitchar = ' '

    
    if 1 == len(data.splitlines(True)):
        sx = [x + splitchar for x in data.split(splitchar)]
    else: 
        multiline = '\n'
        sx = data.splitlines() #True
        
        
    sx.sort(compnum)

    try:
        if dynaM_sortnumb.direction == 1:
            sx.reverse()
            dynaM_sortnumb.direction = 0

    except AttributeError:
        pass

    #deal with nothing selected, must be sort of whole body as lines
    if nothingselected:
        #nothing selected so cant be paste over
        for x in sx:
            print x #might this double line?
    else:
        if multiline:
            sx = [x + multiline for x in sx]
        dynaput(c, sx)

def compnum(x, y ):
    """214202 Pretty_sorting_.htm
    Submitter: Su'\xe9'bastien Keim
    Last Updated: 2003/08/05 
    Sorting strings whith embeded numbers.
    #  sample
    &gt;&gt;&gt; L1 = ["file~%d.txt"%i for i in range(1,5)]
    &gt;&gt;&gt; L2 = L1[:]

    &gt;&gt;&gt; L1.sort()
    &gt;&gt;&gt; L2.sort(compnum)
    
    &gt;&gt;&gt; for i,j in zip(L1, L2):
    ... print "%15s %15s" % (i,j)
     file~1.txt      file~1.txt  not the exact result
     file~2.txt      file~7.txt
     file~3.txt      file~3.txt
     file~4.txt      file~6.txt
     file~5.txt      file~5.txt
    """
    import re
    DIGITS = re.compile(r'[0-9]+')

    nx = ny = 0
    while True:
        a = DIGITS.search(x, nx )
        b = DIGITS.search(y, ny )
        if None in (a, b ):
            return cmp(x[nx:], y[ny:])
        r = (cmp(x[nx:a.start()], y[ny:b.start()])or
            cmp(int(x[a.start():a.end()]), int(y[b.start():b.end()])))
        if r:
            return r
        nx, ny = a.end(), b.end()

#</t>
<t tx="EKR.20040608165334.88">
def dynaM_rsortnumb(c):
    """caller to dyna_sortnumb(c, d= 1 )
    the reverse list will be called before output there
    """
    dynaM_sortnumb.direction = 1
    dynaM_sortnumb(c)

</t>
<t tx="EKR.20040608165334.89">#code for dynabutton, no user code

def dynamenu(*ae):

    &lt;&lt; about dynamenu &gt;&gt;
    global dynavar, dynaMvar

    import leoGlobals as g
    c = g.top()
    e = ae[0]

    #try to allow the tearoff to work from another leo after refresh
    #uses global c, seems to get it right somehow too.
    if not hasattr(c.frame, 'dynavar'): #dynadeflst
        dynavar = dynaMvar = c.frame.dynavar = init_dyna(c)

    #why isnt the name dyna when its torn off?
    #do I dare bother giveing this its own icon, stop the insanity.
    dynau = dynavar.dynau = Tk.Menu(None, tearoff= 1, takefocus= 1,
             name= 'dyna', disabledforeground= 'GhostWhite',
             )  #selectcolor= '' 

    #show whats in the clipboard, replace clipboard with left side of pair
    dynau.add_command(label= "Clip=%r"%(g.app.gui.getTextFromClipboard()[:6],),
           )
    dynai = Tk.Menu(None, tearoff= 0, takefocus= 0 )
    for x in  '\' Sq, " Dq, \'\'\' Sq3, """ Dq3, : file, | !file, \\\\ Dbs, ( ), { }, [  ] '.split(', '):
            dynai.add_command(label= x, 
              command= lambda x= x, f= g.app.gui.replaceClipboardWith: 
              f(x.split()[0]) ) 

    dynau.add_cascade(menu= dynai, label= 'choice' )

    dynau.add_separator()

    n = 3 #tearoff + the lable + seperator
        
    #dynau.add_command(label= 'del_first_char',
    #     command= lambda c= c: dyna_del_first_char(c) )

    #here is some possibly 4.1 dependant code changeing in 4.2
    #give your functions doc strings do can print them for refrence
    for x in dynavar.dynadeflst:
        #print 'adding menu item expects this form  x(c)', x
        #might want to pass them e as well?
        #need to turn this string into a function definition
        #I dont know how to do that... says string object not callable
        #if I leave the (c) in the string its nothing happens either
        # globals() .__dict__ im_func.__doc__  __name__ 
        if isinstance(x, basestring):

            #print x, 'globals()[x]'
            f = globals()[x]

            #but now, all the items are the same as the last function
            #only the item names changes! setting f first didnt help
            #was another lambda scope bug, defineing f=f fixed it.
            dynau.add_radiobutton(label= x[6:24], 
                variable= dynavar.dynadefaultFlag,
                 command= lambda c= c, f= f: f(c) ) 
            n += 1            

    dynau.add_separator(); n += 1
    
    #used in any output print by checking state of
    #if dynavar.dynapasteFlag.get(): lab = 'print'
    #else: lab = 'paste'
    
    d = dynavar.dynapastelst
    for i in d:
        dynau.add_radiobutton(label= i, #, value=3,accelerator='+'
            variable= dynavar.dynapasteFlag )
    
    #dynavar.dynadefaultFlag.set(5)
    #dynau.entryconfigure(4) #, 'select'  first function
    #dynau.entryconfigure(n) #, 'select'  choice 1 radiobutton
    
    #could have another togle, treat selected as filename
    #need to mind what function outputs and needs what input
    #maybe an IOclass that defaults I/O filename, manages output

    dynau.add_separator()
    dynau.add_command(label= 'dynamenu',
         command= lambda e= e: dynamenu(e) )
    dynau.add_command(label= 'dissapear', command= deldyna )
    dynau.add_command(label= 'exScript', command= c.executeScript )

    dynau.entryconfigure(1, state = 'disabled')  #

    dynau.tk_popup(e.x_root-3, e.y_root+3, entry= "1" ) 
</t>
<t tx="EKR.20040608165334.90">#no user code, specific to dynabutton setup

def dynaclick(*a, **k):
    #this import appears superfluous when used with executescript
    import leoGlobals as g
    c = g.top()
    c.frame.putStatusLine('.')
    
    try:
        #put the current work in progress here
        #this will be the default leftclick action of dynabutton
        #or invoke .bind("&lt;ButtonPress-1&gt;", hamana hamana)

        #need to syncronize with the list, last called is the default
        #seems like a good way if needed, may want to stick with first though
        #dynavar.dynadefaultFlag.get() is index
        #else is first time thru
        #first vnode with a def function, after 'common' node
        globals()[dynavar.dynadeflst[0]](c)

    except Exception, e:
        #dynaerrout camelsamecase
        dynaerrout(e, "function call failed ")

</t>
<t tx="EKR.20040609081035">def dynaM_dupe(c):
	'''very often I want to copy a line or 2, but I only realize
	after I already have something in the buffer to paste over part of the line.
	this will duplicate the selected lines after the selected lines.
	saveing you the trouble of doing the lines copy then recopying what was in the buffer
	'''
	newSel = dynaput(c, [])
	if not newSel: return

	sx = newSel.splitlines(True)
	sx += newSel.splitlines(True)

	dynaput(c, sx)</t>
<t tx="EKR.20040609091717"></t>
<t tx="EKR.20040609091717.1"></t>
<t tx="EKR.20040609091717.2">@killcolor
http://sourceforge.net/forum/message.php?msg_id=2556085

exec this script, then select some text and hit dynabuttton
its perfect! no plugin to bother with.

and re-editing the code is simple.
leverage Leo to keep a collection of macro scripts.
just switch in new dosomething nodes as needed.

#w04505p01:22:22 add a button works!
I can have a script that acts on selected text
usable from the button.
how to get the button in an exact position?
toolbar is getting crowded.
why did noone think of this before?
you could give it other commands once its up,
like soakup the current selected text as a script.
anything you like. a poor mans macro.
more than one active button easily possible.

use it wisely and test everything fully.
works at least on Leo 4.1final &amp; win9x

replace leading dots with spaces
enjoy
@c

</t>
<t tx="EKR.20040609091717.3">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2560787
By: nobody

I've uploaded a new version which includes a few sample "macro's" and a node
structure that lends itself to better work out the bugs in new scripts. and
a rightclick menu for the button to select from the script samples.
the menu is built from nodes cloned in the macro node which you drag into the
dynamenu node.
also a better way to copy the XML of the node off the html page so you can paste
it into a leo.
http://rclick.netfirms.com/rCpython.htm

you can now toggle a menu item to either print selected text transformed by
whichever item or to paste over the selected text.
there is a dump selected text or body in hex form, good for debugging char related
problems.
one to put a triple double quote around the selected text.
one that isnt quite ready to output python in txt or html prettyprint form.
one that deletes the first char of each line in selected text.
one to sort the selected text line by line.

of course, it is easy enough to add your own and be up and running with it in
under a minute.
I will post more examples as they are contributed here or in the comments page
there.</t>
<t tx="EKR.20040609091717.4"></t>
<t tx="EKR.20040609091717.5">import leoGlobals as g

c = g.top()
cf = c.frame
 
#used first for changing Tk pack options to dict's
#side=Tk.LEFT, expand=1, fill=Tk.BOTH
#{'side':'left', 'expand':'1', 'fill':'both'}
#this might have been ok as a find/change script as too...

@others

deldyna()

cf.dynacb = cf.addIconButton(text="dyna", command= dynaclick)

#later can add its own menu and options
#bind double right click button3 to make dynaclick dissapear
cf.dynacb.bind('&lt;Double-3&gt;', deldyna)
#more likely use, rclick to select different functions
cf.dynacb.bind('&lt;3&gt;', dynaclick)

#bind Alt+1 to dosomething, needs work
cf.dynacb.bind('&lt;'+'&lt;Key-Alt-1&gt;&gt;', dynaclick)

cf.clearStatusLine() 
for msg, color in (('dyn',"red"),('a',"orange"),('click',"blue")):
	cf.putStatusLine("%s"%(msg,),color= color)

print "dynaclick button installed"</t>
<t tx="EKR.20040609091717.6">def dosomething(c):

	if c.frame.body.hasTextSelection():
		newSel = str(c.frame.body.getSelectedText() )
		so = '{'
		print 'text is', newSel
		for x in newSel.split():
			s = x.replace('"', "'").replace("'", "")
			s = s.replace("=", "':'")
			s = s.replace('Tk.', "").replace(",", "', ")
			so += "'%s"%(s.lower(),)
			#idealy it wouldn't add SQ around plain numbers
			#split on , maybe or resplit later, 
			#good enough for now
		print so + "'}"

	else:
		g.es("no text selected", color= 'red' )


</t>
<t tx="EKR.20040609091717.7">def dynaclick(*a, **k):
	
	import leoGlobals as g

	c = g.top()
	c.frame.clearStatusLine()
	c.frame.putStatusLine('Dyna Click Active')
	dosomething(c)
	print 'add your own code here to dosomething'</t>
<t tx="EKR.20040609091717.8">def deldyna(*a, **k):

	try:
		cf.dynacb.destroy()
	except:
		print "no dyna button active"</t>
<t tx="EKR.20040609091913"></t>
<t tx="EKR.20040609091913.1"></t>
<t tx="EKR.20040609091913.2">@nocolor

getUnknownTag: labels &lt;long string&gt;

exceptions opening: C:\Documents and Settings\default\Desktop\mod_label.leo
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 670, in openWithFileName
    frame.c.fileCommands.open(file,fileName) # closes file.
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 1121, in open
    ok, ratio = self.getLeoFile(fileName,atFileNodesFlag=True)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 525, in getLeoFile
    self.getVnodes()
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 927, in getVnodes
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 864, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 833, in getVnode
    v,skip = self.createVnode(parent,back,tref,headline,attrDict)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 145, in createVnode
    p.v.unknownAttributes = attrDict
NameError: global name 'p' is not defined</t>
<t tx="EKR.20040609213754">try: import Tkinter as Tk
except ImportError: Tk = None

try: import Pmw as P
except ImportError: P = None

import sys
import ConfigParser as cp
import sets
import os

if 0: # Standalone doesn't work well
	fileName = r"c:\prog\leoCVS\leo\config\leoConfig.txt"
else:
	if len( sys.argv ) &lt; 2 or not os.path.exists( sys.argv[ 1 ] ):
		sys.exit( 0 )
	fileName = sys.argv[1]

if os.path.exists(fileName):
	
	&lt;&lt; create the top frame tl and its contents &gt;&gt;
			
	tl.geometry('%sx%s+0+0' % ( tl.winfo_screenwidth(), tl.winfo_screenheight()-100 ) )
	tl.deiconify()
	tl.title(fileName)
	tl.mainloop()</t>
<t tx="EKR.20040609213754.1">tl = Tk.Tk()
tlf = Tk.Frame( tl )
tlf.pack( side = 'bottom' )
b = Tk.Button( tlf, text = 'Save' )
b.pack( side = 'left' )
b2 = Tk.Button( tlf ,text = 'Quit' , command = sys.exit ) 
b2.pack( side = 'right' )
P.initialise( tl )
nb = P.NoteBook( tl )
nb.pack( fill = 'both', expand = 1 )
cfp = cp.ConfigParser()
cfp.read(fileName) # sys.argv[ 1 ] )
dirties = {}
def save():
	for d in dirties:
		s = dirties[ d ]
		for sd in s:
			l = sd.component( 'label' )
			lt = l.cget( 'text' )
			cfp.set( d, lt, sd.getvalue() )
	config = file(fileName,'w') # sys.argv[ 1 ], 'w' )
	cfp.write( config)
	config.close()
b.configure( command = save )

for z in cfp.sections():
	i = nb.add( z )
	sf = P.ScrolledFrame( i )
	sf.pack( fill = 'both', expand = 1 )
	c = sf.interior()
	dirties[ z ] = sets.Set()
	opts = cfp.options( z )
	opts.sort()
	for x in opts:
		val = cfp.get( z, x )
		ef = P.EntryField( c , labelpos = 'w', label_text = x, value = val )
		ef.component( 'entry' ).configure(background='white',foreground= 'blue')
		def markAsDirty( section = z, ef = ef):
			s = dirties[ section ]
			s.add( ef )
		ef.configure( modifiedcommand = markAsDirty )
		ef.pack( side = 'top', fill = 'x', expand = 1 )</t>
<t tx="EKR.20040611044600"></t>
<t tx="EKR.20040612183736"></t>
<t tx="EKR.20040612184408">@killcolor

fix the path and write @file for the dyna_menu.py plugin

 execute script on the dynaclick node to enable the dyna button

 you don't have to write @file on dynaclick.py node
   that is an @file node so that goto line number works.
   if you do need to use goto linenumber, you can write @file there too.

 you don't have to write @file on dynatester.py node, same reason.
 its not easy to know the exact line from Leo w/o a generated file
 apparently gotolinenumber doesnt work from @file-nosent and the ilk
 nevertheless, to track down an error, you need to know where it is.
 see the linenumber macro for another way to get the line number
 possibly add a jumptonode containing the linenumber while in tester node.

at the top of the common node, there are some paths you will have to
 change to use a few of the macros that call python and create temp files
 if you want to use makatemp to call pychecker and or pylint.

write some macro scripts using other similar macros as template.
post your creation for other people to learn from.


you can put a macro to test in dynatester node, then execute script
 the makatemp works there which creates a temp file
then calls reindent, pychecker and pylint on that temp file.
you would have to change the hardwired paths for this to work for you.
and possibly download and install pychecker and pylint. up to you.

Don't debug the comments, only the code. it works for me today.
your system might have to take into account other assumptions.


if you have problems or suggestions:
    please leave a comment on my page or sorceforge 


few notes on the nodes, you can find more details later on,

each macro get c as parameter to pass to dynaput
macros are added as item to rclick dynabutton or to dynamenu plugin.


    + @file dynatester.py
        a macro
        + common

    macrostore
     in process or don't want in any menu

    + @file dyna_menu.py
        + macros get included in the plugin created dyna menu

    + @file dynaclick.py
        + macros  ones included in the dynabutton rclick menu

either copy or clone macros into the node you want the item to appear in
for ex: you want DQ3 only in the dyna menu, put it in macros
you must have it in one of these to be in one of the menus.
you can append the testing code like in a few of the parse macros
 then they will run with execute script in tester mode node.
 or if included in the plugin or dynaclick macros nodes.
 you can leave the test code appended w/o problem, it's only a few lines.
you can also create custom functions your macro can call, just add them
to the node called common, they will be automatically cloned everywhere.

+ dyna0.032
    + useage
        - plugin or other
        - older comments
        - comments
        - Newcomments
        - u04523p01
    + you need
        - @url http://www.logilab.org/projects/pylint
        - @url http://www.logilab.org/projects/common
        - @url http://pychecker.sourceforge.net/
        + rc
            - @file-nosent .pycheckrc
            - @file-nosent .pdbrc 
            - @file-nosent .pythonrc.py 
            - @file-nosent .pylintrc
    + @file dyna_menu.py
        + macros
            -  Clip_dtef
            - +DQ3
            - c2py
            - +dyna_backslash
            - geturls
            - +del first n char
            - +dynaHexdump
            - swaper
            - flipper
            - _sfdots
            - linenumber
            - makatemp
            - +call_evaluator
            - pycheck2
            + tim_one_crunch
            - dyna_regexTk
            - wraper
            - restoreStd
        + dynaMData
            - load_menu
        - ExButton
        + common

    + @ file dynatester.py
        - getallurl
        + common

    + macrostore
        + done ideas
            - Bengtcommafy
            - +del pycomments
            -  Clip_dtef
            - screenshot
        + inprocess
            + how to

            - restoreStd
            - Pic97
            - getdoc
            - profile
            - psyco_timeit
            + Graphvizoutline

            - +call_evaluator
        - template
        + parse
            - NewHeadline
            + pullparser

            - dateform
            - dyna_csv
            - changing Tk pack
            - Tkpackpypar
            - dyna_pyparseTk
            - dyna_PlexTk
            - +org Tk pack
        - +call_fixbody
    + @ file dynaclick.py
        + macros
            - geturls
            - call_dynaplay
            - +dynaHexdump
            - c2py
            - linenumber
            - +call_fixbody
            - dyna_regexTk
            - +sortnumb
            - +rsortnumb
            - +dyna_backslash
            - +call_evaluator
            - makatemp
            - pycheck2
            + tim_one_crunch

        + dynabuttonmenu
            - dyna_use
        + common
            - fixbody
            + dynastuff
                - dynaBunch
                - dynaerrout
                - captureStd
                - runcmd
                - dynadoc
            - dynaput
            - dynaplay




        + dynabuttonmenu   &gt;&gt;reads which macros defined and adds them
            - dyna_use &gt;&gt;functions and classes to support the button
        - common     &gt;&gt;functions and classes to support the macros

common is clone in 3 spots
some of the macros are cloned, some copied, some not in either menu.
many of them will not work for you without special data or modules.
some are deadends that can never be smarter than putting in the keystrokes.
the ones included in the plugin should work ok. once you know what they do.

Don't rearrange the order of the macros node after dynaclick
w/o changing the code

assumptions are @language python in most cases or plain text data.

I wont be making any script available because without Leo it would be too 
confusing to explain and some of the code itself depends on Leo after all.
much of it is in flux so additionional docs and clarification of code
is an ongoing process.  look in the code or run dynadoc to see all of 
the doc strings for the macros.

if you have an idea for a macro, a change in how they should work, 
 or better yet, alternate code for one or a new one, please post it.

next release expect additional macro's. more playback commands supported.
cascade menu to fit more macros on the menu. 
any bugs not caught or not fixed this time around gone.
better choosing of filenames, maybe a display preview mode.
maybe an ini to read instead of hardwireing paths
and an interactive ini creator for first time use.
RSN at the earlist.

http://rclick.netfirms.com/rCpython.htm for latest version.</t>
<t tx="EKR.20040612185017.1">@killcolor
@

execute script, then select some text and hit dynabuttton
its perfect! no plugin to bother with.
and re-editing the code is simple.

leverage Leo to keep a collection of macro scripts.
just switch in new dosomething nodes as needed.

using @file here only to assist with goto line number.
see the linenumber macro for better way to get the line number

 --cut long comments to parent node --

t04525p10:39:34 still experimenting with forklike
it reuses the same process and console the Leo is in
but it doesnt wait like runcmd.
w04526p04:24:42 weird indentation error in my aspn re titler
script, macro linenumber to show how leo sees the lines
its subtly different than the derived file
and the reported error is at the head of the block with the error
you tend to forget that and the error messages arent that helpful.
thats an hour Ill maybe get back using linenumber macro eventually.
no combination of evaluator reindent helped, pychecker couldent import.
need to optionally enable pychecker2 or give each its own macro.
maybe wait till have the cascade menu's before
bloat the number of macros included in the plugin.
added wordcount to wrap. often use it to get a line &amp; word count.
w04526p04:24:42 did another upload &amp; version change. linenumber
is just too good, even though hasnt got full testing yet.
all the accumulated changes since trying in 4.2 and py2.2
getting sloppier and its getting too huge to be all in one node.
I dont notice any problems copying from the html or the node paste into leo.
there is a lag creating the html view partial source and paste into editpad.
found pyyaml, another parser to try. and ply
in linenumber it stoped outputting in the test,leo when not on typical
python source, didnt understand why, both button &amp; plugin
this node linenumbered is almost 3000 lines long. no comment?
would be good to get a metric using a custom rc with pylint.
all details to be worked out in the fullness of time. or not.
with the linenumber macro working,
might remove the @file from dynabutton &amp; tester.
or leave it in as a reminder that gotolinenumber should be overwritten
start psyco/bind/timeit macro and profile
why am I not importing reindent and using it directly to overwrite source?
timeit has a reindent, wonder if that is the same results?
another action to compare and wish could script such things easier.
r04527p01:20:28 dynaM_pycheck2, had to modify to chnage pickle
think cPickle is erroring, just deleting the pickle each time now
doesnt find nearly the same information as pychecker does.
but it doesnt import while still checking is it importable.
evaluator wont output body text. if selected ok.
tryed changeing around the redirection. cant see how its getting stuck.
need if sdict['language'] != u'python': in a few places
doesnt make sense sending java to pychecker
u04530a03:57:59 dynaM_c2py
pf DQ3 only checked the first char in copybuffer for match
then could let the dropdown insert both sides of pair for x = [] use
Hexdump = sys.modules['dyna_menu'].dynaHexdump
print Hexdump('help')
added an ok/cancle button before calling c2py since there is no undo.
f04604a08:59:00 tweeked the getmenu for the button, choked on dunadump.
had to fix the def extracter. dump is choking on some unicode.
using the plugin calls in other scripts quite sucessfully.
may create module out of some of them to further reuse it in other python.

installed geomenu the other day after a bad install left me without explorer
after changeing the shell=taskman.exe in system.ini for a few hours.
I finally realized someone has probably been down that road before.
http://www.geoshell.com install win9x or 2k Nt or xp
http://docs.geoshell.com/R4/WeLoveGeoShell
has plugins for dodads that live on floating toolbars,  is opensource
its a little too dependant on the registry for my taste but otherwise
amazing stuff. litestep too but that is too dependant on rc files.
the clip widget, taskbar the startmenu all work mostly as you would like.
much of explorer still is in the bacground anyway, you cant eliminate it.
fixed the explorer by upgrading IE from a CD rom backback drive.
quite disconcerting when you reboot and get gpf in explorer and then nothing.
have to trot out all the backup floppies and try and backup the dats
reboot try something else then slowlyremember how to restore things.
remembering how to function, where all the paths are.
I didnt even have a CD on this computer, some dell problem
where the CD's arent recognized because of a well known buss conflict.
no wonder the damm thing was only 100  bucks. battery dead in the laptop.
not been a great year sofar except for too busy witha number of scripts.
delved into building dictionaries for a custom anagram solver. some
code from c.l.py last year was able to replace some java and javascript
that took around a minute to some python that is nearly immediate.
more stuff that is too specialized and dependant to put on the web.
it may turn into a another spell checker. I already can lookup words.
there is no optimization, rudimentary pluralization. a word length 10
dictionary is about 4meg, once read into a python dictionary is fast.
solveing how to access it from other leos would be the problem.
I havent found out how to have a borg instance of a class for all leo's.
&lt;A HREF="http://www.cis.upenn.edu/proj/plclub/contest/"&gt;ICFP Programming Contest 2004&lt;/A&gt;
tweaked up the geturls macro. was getting including the links
which was the origional problem now that I think about it.
got sidetracked with so much bad html. need to check
if its a well formed link first, then extract
if its a bad formed link attempt to extract
extract url's or  if its a filename try to match that
its to big a problem for the times I need a real page scraper.
just ment to clean up random fragments of html.
split out getallurls to continue testing, geturls in the plugin
should make it able to scan the entire leo. as now fixbody does
follow @others using what is used to generate scripts or derived files
a general node walking would be another way to included more content.
using searching to find the next match of the start of a link/url
just realized should be upping the version just before I upload not after.
f04604p10:27:47  going to just chg the date this time
editpad all of a sudden wont display @ chars.
I think it been getting progressively weirder, maybe its a subtle nag to register? sometimes you cant insert or copy, workaround is to use the line number function.
lucky I tested the html copy to another leo. getting syntax error
at bfcrunch when exS on the dynaclick node. from the copy, &amp;#%!.
generated plugin and compared. this is very disturbing.
0000   09     it inserts a tab at that node defore the def!
and the first char on each line of that node, mixed with spaces!
how can this be...
has this happened before and just not been noticed?
or have I just not tested it well enough?
looks like a pause on the upload.
amd another warning for everyone to run -t and maybe even an error
and will everyone using tabs please get a grip and change to spaces.
something is triggering it, mabe the regex on the lines before?
compares fine ignoreing semtinals up to that point.
why is it only happening in the node copied to another leo?
its about 400bytes less too. Ill trade the last 10 minutes
of debugging for each leo being 10k longer any day of the week.
trading space for cpu cycles made sense when disks cost $1/meg maybe.
not when they are 10 cents a gig. comming from not haveing enough
memory cpu or hardisk. I fail to see why those that throw backward
compatibility out the window at any chance hold on to this anacronizm from the teletype days that saved punching extra holes in the tape,
my first input device wws an asr43 and im not making this up.
those few k could mean the difference between a long jump or a chort
being in the same memory segment or not. but thats the compilers job.
woops, my settings got fliped from -4 somehow! nevermind...
this is nastyier even still.
my config still is -4, the prefrences has a checkbox replace tabs with spaces.
when you open a new leo, that checkmark is unchecked!
how many errors is this responsible for?
isnt that strange. open another python and leo an the prefs are right!
and the paste of dynaclick then exS w/o error... I assume plugin too.
grrrr


insert macro soon
    method,         newnode named for copybuffer
    def,            newnode named for copybuffer
    class,          newnode named for copybuffer
    if/elif/else,  at insert point following same indent
    try/except  before/after selected text add Exception, err\ndynaerrout
    exe=r2r   #one line syntax error to halt script


cascade menu for plugin, dynaM_ something to specify in cascade
probably just put all programming related.
would be nice if could tag the menu as indev or inword
dev expose all the programming related stuff
word expose all the word manupulation stuff
switching either of several catagories to be the default
leaveing others in their own cascades still accessable
and haveing a few root always macros and features on the main menu.
jave to do more work on a floating dynamenu. why wasnt that tearoff?
because Leo doesnt expose that directly and previously was editing src.
probably have to see how to subclass and/or add a method.


another choice /clip instead of print copy to clip
instead of from selected or body or only body, only from clicp
need a clearly more defined from and to sometimes.


mod_tempfname.py


have to check doesnt screwup unicode on paste over

impliment the doc choice to spill the __doc__ when you click on an item.
make __doc__ on macros wrap so they look better in log for dynadoc
only print first 3 lines too and rearange so they are most relevant.
add 'macro', 'clones', 'all' to doc all of dynasystem the macro node
or just those included in the menu. expand to doc other called modules
add -q mode default to not printdoc
fix getdoc to respect @language and punt for other than python
make it find keywords and builtins like help(txt)


more Leo API functions to use.
attachLeoIcon(w)
setDefaultIcon()

funcToMethod(f,theClass,name=None)
    how is this an advantage w/o rewriteing to use self.*?
clearAllIvars(o)

there are dependancies in a few functions, dtef, calc_util are 2
try except around them somewhat
need to finish calc_util evaluator and upload it

on the far distant todo
steal buffers code from fastgotonode for ^Kr ^Kw
steal the record commands from the timer plugin
to paraphrase someone elses mixed metaphore
 code is never finished, it is abandoned to the fates.

in case you haddent noticed anything I put out there for code
is what I believe in and use at the time and all the time.
I mostly eat my own dog food as they say.
I dont get back to work unless I revert or fix it or do without.
not too difficult really since these are simple enhancements
to the real grand designs made possible with Python and Leo
if I could imagine anything more dynamic and plyable,
Im afraid my head would explode.

works at least on Py2.3.3, Tk 8.4.3, Leo 4.1final &amp; win9x
only lightly tested  Py2.2,  Leo4.2 from cvs
the purple execute script done msg has to go
thats not comming from dyna!</t>
<t tx="EKR.20040612191121">"""call the fantastic first cut c2py script
you still have to make it more pythonic but it does quite alot.
c2py doesnt generate an undo event so there is no turning back.

@language c

still some things to work out. if the c file is in one node
it might be better to import it first as c, then let c2py convert it
using convertCurrentTree it converts in place.
 that might be dangerous if it
fails or if you need to refer to it later
OTOH, from a tempfile you wouldent be able to import
as there may be logic problems left over from the conversion.

on selected text or body written to tempfile.
previously foundit easier to call c2py with a filename
then import the modifyed file. which did work well.
usually stick with what works. glad I didnt this time.
having dyna provide the currentvnode was the missing piece
and should allow the import as well without a filewrite.

might still make  a backup to another node or to a derived file.
it also might make sense to run the c thru indent first
you definatly want the origional to refer to.
need to run thru reindent or remove tabs maybe too before usage.
there are clues to give c2py which might help with some specific
conversions which I havent examined.
in the case of declarations I wouldve left comments on the type
int x, becomes just x. might have been char or double who knows.
# 
# c2py removes all type definitions correctly; it converts
# 	new aType(...)
# to
# 	aType(...)


classList = [
"vnode", "tnode", "Commands",
"wxString", "wxTreeCtrl", "wxTextCtrl", "wxSplitterWindow" ]

typeList = ["char", "void", "short", "long", "int", "double", "float"]

Please change ivarsDict so it represents the instance variables (ivars) used  by your program's classes.
ivarsDict is a dictionary used to translate ivar i of class c to self.i.  
It  also translates this-&gt;i to self.i.


ivarsDict = {
"atFile": [ "mCommands", "mErrors", "mStructureErrors",
    "mTargetFileName", "mOutputFileName", "mOutputStream",
    "mStartSentinelComment", "mEndSentinelComment", "mRoot"],

"vnode": ["mCommands", "mJoinList", "mIconVal", "mTreeID", "mT", "mStatusBits"],

"tnode": ["mBodyString", "mBodyRTF", "mJoinHead", "mStatusBits", "mFileIndex",
    "mSelectionStart", "mSelectionLength", "mCloneIndex"],
    
"LeoFrame": ["mNextFrame", "mPrevFrame", "mCommands"],

"Commands": [
    # public
    "mCurrentVnode", "mLeoFrame", "mInhibitOnTreeChanged", "mMaxTnodeIndex",
    "mTreeCtrl", "mBodyCtrl", "mFirstWindowAndNeverSaved",
    #private
    "mTabWidth", "mChanged", "mOutlineExpansionLevel", "mUsingClipboard",
    "mFileName", "mMemoryInputStream", "mMemoryOutputStream", "mFileInputStream",
    "mInputFile", "mFileOutputStream", "mFileSize", "mTopVnode", "mTagList",
    "mMaxVnodeTag",
    "mUndoType", "mUndoVnode", "mUndoParent", "mUndoBack", "mUndoN",
    "mUndoDVnodes", "mUndoLastChild", "mUndoablyDeletedVnode" ]}  

def convertCurrentTree():
import c2py
import leo
import leoGlobals
c=leoGlobals.top()
v = c.currentVnode()
c2py.convertLeoTree(v,c) 

wouldent this obviate any changes to ivars or other code?
might have to do the same setup w/o the fresh import
and where to get th custom info from if using M_c2py from plugin?


messages are going to console instead of log
converting: NewHeadline
end of c2py

x = {}  will have the {} removed. not sure why...
removeBlankLines 
"""</t>
<t tx="EKR.20040612191121.1">def deldyna(*a, **k):
    """there has to be a better way to do this.
    tweeking it  is very error prone
    """
    import random

    n = 1
    while n and n &lt; 8:
        try:
            if n == 1:
                print dynavar
                n += 1
            if n == 2:
                c.frame.dynavar.dynacb.destroy()
                n += 1
            if n == 3:
                c.frame.dynavar.dynau.destroy()   #tearoff survives destroy
                n += 1
            if n == 4:
                c.frame.dynavar.__clear()	#this finishes it
                n += 1
            if n == 5:
                del c.frame.dynavar
                n += 1
            if n == 6:
                del dynavar
                n += 1
        except:
            #print "del",n,
            n += 1
            continue
        print "dyna button removed "  #, n
        n = 0  #this alone wasnt having the effect of forcine all del

    print
    for x in '  gone':
        color = random.choice(['red','green','orange','black'])
        cf.putStatusLine(x, color)


</t>
<t tx="EKR.20040612191121.2">def dyna_getsubnodes(c):
    """
        read nodes in macro node get function def's
        where the headline starts with + maybe that takes body
        if +- then it paste or print, not anything solid yet.
        add to the lst for dynamenu to add when called
        #possibly this code will break ni 4.2+
    """
    import re
    lst = []

    #this will only make sense if you are looking at the nodes in Leo
    #should check if has child in case is rearranged by mistake.
    try:
        #child = c.frame.tree.currentVnode().firstChild()
        child = c.currentVnode().firstChild()
        
        hs = child.headString()  #; print hs
    
        if hs != 'macros': print 'cant find macros node'; return
    
        child = child.firstChild()

    except Exception, e:
        # d=rew  Leo caught syntax error, space
        #Leo caught TypeError: dynaerrout() takes exactly 1 argument (2 given)
        #d=rew might not have caught this
        dynaerrout(e, "Exception no active var ")

    
    number = 0
    fdef = re.compile(r'def\s+([a-zA-Z]+[a-zA-Z_0-9]*)\s*.')
    #fdef = re.compile(r'def\s+([a-zA-Z]+[a-zA-Z_0-9]*)\s*\((.)+\)') next
    while child and number &lt; 22:
        number += 1

        #here would actually parse the body for def's
        #and verufy they have a c arg
        #first one is the only one per node included
        hs = child.headString()
        if 1 or hs.startswith('+'):

            lines = str(child.bodyString()).splitlines()
            for s in lines:
                if s.startswith('def'):
                    #2nd item is the name(c) remove the :
                    #very hardwired at this first alpha stage
                    fnd = fdef.match(s)
                    if fnd:
                        #print 'found', hs, fnd.group(1)
                        lst.append(fnd.group(1))
                        break  #it always burns me, this time where will it go?
                    #else: print 'missed'
                    
        child = child.next()
    #print 'in get node', lst
    return lst

"""aspn\52264  code fragment will convert a GIF to python source code
import base64
print "icon='''\\\n" + base64.encodestring(open("icon.gif", "rb").read()) + "'''"
"""
# here's the result
icon='''\
R0lGODlhIABIAPcAAAQCBHyCnDxCXLzCzCQiNFxifJyitNzi5CwyTBQWJGxyjIySpExSbMzS3LSy
cut for brevity
5YgfsEACrWhAA2cxCn9VwsU8sCAjU8hDgik8kIhAZAYT5rCIR0zhgAAAOw==
'''
'''# to use this in Tkinter:
try: import Tkinter as Tk
except ImportError: Tk = None
root = Tk.Tk()
iconImage=Tk.PhotoImage(master=root, data=icon)
Tk.Button(image=iconImage).pack()'''</t>
<t tx="EKR.20040612191928.2">"""read dynadeflst and create menu items for them
 in addition to any already defined
 have to work out some means of exclusion, 
 maybe something in the def name
if isinstance(x, callable):?
postcommand callback If given, this callback is called whenever Tkinter is
about to display this menu. If you have dynamic
menus, use this callback to update their contents.

from Tkinter   Construct menu widget with the parent MASTER.
    Valid resource names: activebackground, activeborderwidth,
    activeforeground, background, bd, bg, borderwidth, cursor,
    disabledforeground, fg, font, foreground, postcommand, relief,
    selectcolor, takefocus, tearoff, tearoffcommand, title, type.
    some of these dont work in entryconfig, maybe all
    getting tired of seeing TclError: unknown option "-whatever"
    where is the valid options are messages I get in other TK use?
     bg= 'ivory1' errors, maybe only the menu itself can be one color
     not individual item lines
     a menu/button to cycle thru colors ever time clicked would be helpful
 probably its just my color scheme that makes it hard to see the disabled text

possibly creting cascade menus would be simpler if this function did
the node traversal. starting at macros, get all children
 if has subnodes then use the headline as a cascade name &amp; add those.
 dynaM_ now required in macros used in dynamenu plugin, may as well here too
 and change the code that build the lst to return a tuple
 maybe the macro wants to define keystroke accelerator, somehow get that too
 
"""</t>
<t tx="EKR.20040612224923.1">new macro ideas...

- start publishing macros like the cookbook

- shell processing.  Overides '|' ... so Python looks like bash commands...

- unhtmlify and htmlify selected text or body
 strip html tags, chg &gt;,&lt;,&amp;," to their htmlentities
 add html tags the way some simple txt2html things work

- MD5, crc of selected or body or body full or filename

- wordspell theasauras unscrambler wordcompletion macro

- print to printer of seleted text, file or node or subnodes headlines.

- create a sequential text file of subnodes not requireing @others

- nodesize, wordcount, indexbuilder linecount/per node like headline export

make a copy of a macro template below the current node
using copy buffer as name. pick from several styles w/w/o testing code
styles 
    only selected,  like for wraper can still selectall here
    selected/body  like for sorter  nothing selected use body
    s/b for code like for pychecker  comment out @directives
    each choice would additionally have use &amp;| change copybuffer
    use I &amp;| O filenames
    also pure execute script using none of the dyna but function wraped
     in case later you need to get or put selected text or body

a dump all config options macro, good first step for a config gui
 might be instructive to debug config problems in any case.

macro to walk node, like NiceNosent plugin, but do it in the leo
 add \n at start of each node , class, method &amp; def and end of each
 not sure that will help, may need 2 at the end. Leo inexplicitly
 decides to eat trailing newlines in a node. related to dreaded newline?
 in the derived of @file sentinals crowd class, method, def
 it would be nice to put some blank comment before each in addition
 anything that can help readability and consistancy

macro to extract the first function or class or method
 in the current node. popup a form with sample
parameters guessed from the args and guess their type
and show the return value. 
 or more likely, append such a test into that node so next time after edit it can perform the test. getting the imports right could be a problem. as hard as it is to node walk forward it must be harder to node walk backward collecting relevent imports and varb rebinding.

a macro to make selective changes in leoconfig.txt
create a batch
spawn a new leo and test.leo --batch
why a macro instead of a script? better debuging


bind a macro to a keypress, maybe the same thing as the accelerator key
 need a way for macro to have a decorator the menucreator can extract
 seems ive made this comment before somewhere else.


Tk can output ps, macro to create an image, call ghostscript
 which doesnt work on windows from Pil to generate a png from the ps.
 another way to get colorized output of other languages or
 a snapshot of a Leo window

try to get pdb active in Leo macro, would have to use popup window
 I dont think embedding into the log or body would work well.
 maybe could pass it a command on exception to dump all local vars?
 that would on occasion be too much data and trash Leo, better not.

for doctest, write out the node changeing the name doctest needs to load
or make a mock file out of StringIO and use it to call doctest on the current node.
    import doctest, sys
    doctest.testmod(sys.modules[__name__])

add doctests for more of the functions, even  if just as example
turn it into a dynamic module somehow to fool doctest into running

en/decrypt pass thru en/decode overwrite body using passkey
derived from a python expression and locally generated data of your choice.
or a way to compress nodes inside the same leo, zip then b64, 
then delete the node. a plugin could expand them on load.

backup to another directory or zipfile 

obfuscator, there is one for python.

macro to tell you where in leo something from selected text is
 what you might use to call it. sounds like, for ex:
      you select alert, it responds g.alert('message')
      you say dialog etc etc
        
a more complicated swaper would handle x and y to chg to y and x

macro to turn a macro into a standalone python script accepting stdin
 producing its results on stdout like a filter. or into -batch script
 or make a commandline python -C script out of it.

fix names of headlines to match macros , 
  more general the first function found.
  this would save a copy &amp; paste 
  after an insert node and paste of a function


a macro to setup and use Leo find and compare
  to setup the checkboxes and find/change scripts or filenames

a toggle or macro to copy each copy to the log. or to a file log.
 maybe thats a potential plugin with its own controlls.

difftool, call \Tools\Scripts\diff.py on nodes and files 

make tool running on selected or body a cascade read/save/update from ini


run coverage tool on selected or body, like for pychecker or pylint.


node/body creator macro, like the new button plugin but easier to edit.


appender, copy, select something hit appender, and its appended to copybuffer.


up/dn up/down the number selected, select a 1, hit up/dn its 2 etc


align, take  list of numbers
 lineup the list vertically and horizontally. fixed font non withstanding

dumpkeys, [keyboard shortcuts] and when you hit a key it shows what it is bound to
 there is something in leo src that tests keyhits on the status bar.
 maybe you have to trap focus there for it to work.


print selected in various case like rClick case does, 
 and CamelCase wide_name conversion to from

produce html from body or file. if silvercity than other lang ok

for rs2 plugin use, create a node named from the headline of current node
 make the current node a subnode of that node called @rst headline.html
 double click it, add custom rst commands to all doc strings or wherever.

html output for python colorized code. part of evaluator in another module



adding items to rClick would be interesting from outide rClick
g.rClicker.nclst.append(('whatever','whateeever'))
except its built dynamically depending on if its body or not.
might have to change it to body, log or other entry widget
giveing all buttons &amp; menus a dissapear would also be usefull 
  except there is no reappear w/o restarting Leo.
  it should be able to access the dynaMvar w/o problem
  not sure if the macro started running it would have access to common's


compare node1 w/node2. maybe a popup to select the nodes
maybe write tmp files or get compare to use StringIO mock file
scripting the compare isnt done yet, AFAIK.
compareFilesIgnoringLineEndings(f1, f2)
    return f1.read() == f2.read()

have to get a common buffer scheme with the fastgotonode guy
buffers would simplify the compare node and a few other ideas.
dont want to refactor the code nor duplicate it. what to do what to do.

try and impliment a ^Kr ^Kw
control K read/write function as some of the old IDe's used to have
and some editors have, the ability to read or write portions or all of the body
from or to extrnal file.
read c:\c\leo\flat.txt would be one typical often use

import to @file from node, textreadernode might be improved and used</t>
<t tx="bwmulder.20040601212737">"""
Define a general purpose monitor module.

Can be used for classes derived from "object" to intercept assignment to instance attributes.

For lists and dictionaries, it also offers drop-in replacements which monitor all changes to those list and mappings.

This module also includes a basic undo / redo mechanism.

For this undo / redo mechanism, it is important that the undo / redo steps do not trigger any monitoring calls. 
This module should fullfill that requirement.

For scalars, we put "scalar_monitor" into the attribute slot to intercept accesses to the attribute. The values
themselves live in a differnt, "private" attribute. These private attributes are accessed directly for the
undo / redo steps.

For dictionaries and lists, we extend the base types. The undo / redo mechanism 
uses the methods of the basic type.

If you assign a list or a dictionary to a monitored attribute, the list or mapping is automatically converted to
a monitored list or mapping (but only one level deep).

[Question: do we need a convenience function which does this recursively?]
"""

@language python
@tabwidth -4

@others
</t>
<t tx="bwmulder.20040601212737.1">class passthrough(object):
	"""
	Instances of this class are used to disable monitoring.
	The values are just passed through.
	"""
	@others

</t>
<t tx="bwmulder.20040601212737.2">def __init__(self, private_attributename):
   self.private_attributename = private_attributename
</t>
<t tx="bwmulder.20040601212737.3">def __set__( self, instance, value):
   setattr(instance, self.private_attributename, value)
</t>
<t tx="bwmulder.20040601212737.4">def __get__(self, instance, owner):
   return getattr(instance, self.private_attributename)
</t>
<t tx="bwmulder.20040601212737.5">   
class scalar_monitor(object):
	"""
   Monitor a scalar attribute.
   A scalar attribute is an attribute whose values do not have internal structure.
   Used for Integers and references.
	"""
	@others
</t>
<t tx="bwmulder.20040601212737.6">def __init__(self, external_attributename, monitor_object):
	self.external_attributename = external_attributename
	self.private_attributename = '__' + external_attributename
	self.monitor_object = monitor_object
</t>
<t tx="bwmulder.20040601212737.7">def __set__( self, instance, value):
	private_attributename = self.private_attributename
	external_attributename = self.external_attributename
	try:
		oldvalue = getattr(instance, private_attributename)
	except AttributeError:
		self.monitor_object.scalar_set(instance, private_attributename, external_attributename)
	else:
		if oldvalue != value:
			self.monitor_object.scalar_modify(instance, private_attributename, external_attributename, oldvalue)
	setattr(instance, private_attributename, value)

</t>
<t tx="bwmulder.20040601212737.8">def __get__(self, instance, owner):
   return getattr(instance, self.private_attributename)

</t>
<t tx="bwmulder.20040601212737.9">class list_monitor(list):
	"""
	Monitor changes to a list.
	
	Calls a "monitor_object" whenever changes are made to a list.
	
	You can use this class whenever you want to track changes to a list.
	"""
	@others
</t>
<t tx="bwmulder.20040601212737.10">def set_monitor_object(self, monitor_object):
	"""
	All changes to this list will trigger calls to monitor_object methods
	"""
	self.monitor_object = monitor_object

</t>
<t tx="bwmulder.20040601212737.11">def __setitem__( self, key, value):
	"""
	Intercept the l[key]=value operations.
	Also covers slice assignment.
	"""
	try:
		oldvalue = self.__getitem__(key)
	except KeyError:
		self.monitor_object.list_create(self, key)
	else:
		self.monitor_object.list_set(self, key, oldvalue)
	list.__setitem__(self, key, value)
</t>
<t tx="bwmulder.20040601212737.12">def __delitem__( self, key):
   oldvalue = list.__getitem__(self, key)
   self.monitor_object.list_del(self, key, oldvalue)
   list.__delitem__(self, key)
</t>
<t tx="bwmulder.20040601212737.13">def append(self, value):
   self.monitor_object.list_append(self)
   list.append(self, value)


</t>
<t tx="bwmulder.20040601212737.14">class list_monitor_in_instance(object):
	"""
	Monitor instance attributes which contain a list as a value.

	Assignments to this attributes, which must be lists, are replaced by instances of 'list_monitor'.
   """
	@others
</t>
<t tx="bwmulder.20040601212737.15">def __init__(self, external_attributename, monitor_object):
	self.external_attributename = external_attributename
	self.internal_attributename = '__' + external_attributename
	self.monitor_object = monitor_object
</t>
<t tx="bwmulder.20040601212737.16">def __set__(self, instance, value):
	"""Intercept assignments to the external attribute"""
	assert isinstance(value, type([]))
	if isinstance(value, list_monitor):
		newvalue = value
		# if the value is already a list monitor, assume that this value
		# is already monitored. Do not create a new value.
	else:
		newvalue = list_monitor(value, self.monitor_object)
	internal_attributename = self.internal_attributename
	try:
		oldvalue = getattr(instance, internal_attributename)
	except AttributeError:
		self.monitor_object.list_assignment_new(instance, internal_attributename)
	else:
		self.monitor_object.list_assignment_replace(instance, internal_attributename, oldvalue)
	setattr(instance, self.internal_attributename, newvalue)

</t>
<t tx="bwmulder.20040601212737.17">def __get__(self, instance, owner):
   try:
      return instance.__dict__[self.internal_attributename]
   except KeyError: 
      return instance.__dict__[self.external_attributename]

</t>
<t tx="bwmulder.20040601212737.18">class monitor:
	"""
   Monitor changes to (new style) classes.

   To use:
      1. 
			a) Call monitor_scalar(klass, external_attributename, internal_attributename)
         			for each scalar attribute you want to monitor.

				A scalar attribute is an attribute without internal structure (int and reference).

 				The normal Python comparison operation (=) is used to check if a new value is stored
				in an instance attribute.
				
			b) Call monitor_list(klass, external_attributename, internal_attributename) for each
			   list attribute you want to monitor.
				
		   c) Call monitor_dict(klass, external_attributename, internal_attributename) for each
			   dict attribute you want to monitor.
         
      2. 
		    Call enable / disable to enable / disable monitoring.

   This is an abstract class.
   
   Concrete subclasses are the classes "tracer" and "basic_undomechanism". The latter does most
   (almost all) of the work of a (fairly) general undo mechanism.

   Limitations:
   
      Assumes that instance attributes are used consistently with certain types.
      
   """
	@others
</t>
<t tx="bwmulder.20040601212737.19">def __init__(self):
   self.monitored_scalar_attributes = []
   self.monitored_list_attributes = []
   self.monitored_dict_attributes = []
   self.removed_functions = []
   
   self.monitor_object = self
   # See enable_category.
   
   # Overwriting this one attribute allows
   # Clients of this module to implemente tracing of all
   # calls to this module.
   
</t>
<t tx="bwmulder.20040601212737.20">def monitor_scalar(self, klass, external_attributename):
   """
   Put in a hook so that we can monitor modications to instances of classref'
   with respect to the attribute "attributename".

   It is assumed that the attribute only contains scalar objects. A scalar
   object is an object which is unstructured, and not shared.
   """
   self.monitored_scalar_attributes.append(
      (klass, external_attributename))
</t>
<t tx="bwmulder.20040601212737.21">def monitor_list_attribute_in_class(self, klass, external_attributename):
   self.monitored_list_attributes.append(
      (klass, external_attributename))
</t>
<t tx="bwmulder.20040601212737.22">def enable(self):
	for l, klass in ((self.monitored_scalar_attributes, scalar_monitor),
			 (self.monitored_list_attributes, list_monitor_in_instance),
			 (self.monitored_dict_attributes, dict_monitor_in_instance)):
		self.enable_category(l, klass)
		
	self.enable_put_in_removed_functions()
	

</t>
<t tx="bwmulder.20040601212737.23">def disable(self):
	"""
	Disable monitoring (temporarily).
	"""
	for l, klass in ((self.monitored_scalar_attributes, scalar_monitor),
					 (self.monitored_list_attributes, list_monitor_in_instance),
					 (self.monitored_dict_attributes, dict_monitor_in_instance)):
		self.disable_category(l, klass)
	
	self.remove_overrides_in_list_and_dict_monitor()
	
</t>
<t tx="bwmulder.20040601212737.24">def scalar_set(self, instance, private_attributename, external_attributename):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.25">def scalar_modify(self, instance, private_attributename, external_attributename, oldvalue):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.26">def list_create(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.27">def list_set(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.28">def list_del(self, array, key, oldvalue):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601212737.29">def list_append(self, array, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040601214251"></t>
<t tx="bwmulder.20040601215339"></t>
<t tx="bwmulder.20040601215339.1">@doc
Delayed activation of the monitor mechanism is probably useful.

Not clear of switching off and on is useful, though.</t>
<t tx="bwmulder.20040601222230">class basic_undomechanism(monitor):
	"""
	This class provides the basic operations for undoable operations.
	
	Records a list of changes which it will undone or redone one by one.
	
	The granularity of the undo / redo operations is determined by calls to
	the 'mark' procedure. Only immediately after the 'mark' call can undo be called.
	Redo can only be called after calling undo.
	
	'rollback' is a special case of undo: it is not redoable. The envisioned usage of
	this facility is in error recovery: if a command does not go through, you can call
	this command to undo all your changes (and leave the application in a consistent state).
	
	Use the monitor_scalar, monitor_list_attribute_in_class and monitor_dict_attribute_in_class
	methods to make assignment to instance variables undoable.
	
	Call 'enable' to activate the undo mechanism, 'disable' to temporarily
	stop the undo mechanism from collecting information about changes.
	
	The individual changes are bundled into "_commands'. The boundaries of
	these _commands are marked by a call to the procedure "mark".
	
	The procedure 'reset' can be called externally to erase all undo information.
	
	Individual lists and dictionaries can also be monitored for change with the
	list_monitor and dict_monitor classes.
	
	Possible optimizations later: special handling for string attributes.
	"""
	@others</t>
<t tx="bwmulder.20040601222230.1">def __init__(self):
	monitor.__init__(self)
	self.reset()
	</t>
<t tx="bwmulder.20040601222230.2"></t>
<t tx="bwmulder.20040601222230.3">def scalar_set(self, instance, private_attributename, external_attributename):
   self._steps.append((self.scalar_set_undo, (instance, private_attributename)))
	

</t>
<t tx="bwmulder.20040601222230.4">def scalar_set_undo(self, instance, private_attributename):
	"""Undo the changes done by the assignment of an instance"""
	newvalue = getattr(instance, private_attributename)
	delattr(instance, private_attributename)
	return self.scalar_set_redo, (instance, private_attributename, newvalue)
</t>
<t tx="bwmulder.20040601222230.5">def scalar_set_redo(self, instance, private_attributename, newvalue):
	setattr(instance, private_attributename, newvalue)
	return self.scalar_set_undo, (instance, private_attributename)
</t>
<t tx="bwmulder.20040601222230.6">def scalar_modify(self, instance, private_attributename, external_attributename, oldvalue):
  self._steps.append((self.scalar_modify_undo, (instance, private_attributename, oldvalue)))
</t>
<t tx="bwmulder.20040601222431">def scalar_modify_undo(self, instance, private_attributename, oldvalue):
	new_value = getattr(instance, private_attributename)
	setattr(instance, private_attributename, oldvalue)
	return self.scalar_modify_undo, (instance, private_attributename, new_value)</t>
<t tx="bwmulder.20040601222649">def run_commands(self, steps):
	"""
	Run the undo / redo _steps.
	Returns the list of steps to redo / undo the steps just made.
	"""
	steps.reverse()
	return [func(*args) for func, args in steps]
</t>
<t tx="bwmulder.20040601224447"></t>
<t tx="bwmulder.20040601224447.2">def mark(self):
	"""
	The current commmand ends.
	"""
	if self._steps:
		self._commands[self._index+1:] = [self._steps, None]
		self._index += 1
		self._steps = []</t>
<t tx="bwmulder.20040601224447.3">def undo(self):
	assert self.canUndo()
	self._commands[self._index] = self.run_commands(self._commands[self._index])
	self._index -= 1
	
</t>
<t tx="bwmulder.20040601224447.4">def redo(self):
	assert self.canRedo()
	self._commands[self._index+1] = self.run_commands(self._commands[self._index+1])
	self._index += 1</t>
<t tx="bwmulder.20040601224447.5">def canUndo(self):
	return self._commands[self._index] is not None and len(self._steps) == 0</t>
<t tx="bwmulder.20040601224447.6">def canRedo(self):
	return self._commands[self._index+1] is not None and len(self._steps) == 0</t>
<t tx="bwmulder.20040602075341"></t>
<t tx="bwmulder.20040602075341.1">def list_create(self, array, key):
	self._steps.append((self.list_create_undo, (array, key)))

</t>
<t tx="bwmulder.20040602084701.1"></t>
<t tx="bwmulder.20040602084701.2">def list_create_undo(self, array, key):
	value = list.__getitem__(array, key)
	list.__delitem__(array, key)
	return self.list_create_redo, (array, key, value)

</t>
<t tx="bwmulder.20040602084701.3">def list_create_redo(self, array, key, value):
	list.__setitem__(array, key, value)
	return self.list_create_undo, (array, key)</t>
<t tx="bwmulder.20040602084701.4"></t>
<t tx="bwmulder.20040602085955">def list_set(self, array, key, oldvalue):
	self._steps.append((self.list_set_undo, (array, key, oldvalue)))

</t>
<t tx="bwmulder.20040602085955.1">def list_set_undo(self, array, key, value):
	oldvalue = list.__getitem__(array, key)
	list.__setitem__(array, key, value)
	return self.list_set_undo, (array, key, oldvalue)
</t>
<t tx="bwmulder.20040602085955.2"></t>
<t tx="bwmulder.20040602085955.3">def list_del(self, array, key, oldvalue):
   self._steps.append((self.list_del_undo, (array, key, oldvalue)))
   
</t>
<t tx="bwmulder.20040602085955.4">def list_del_undo(self, array, key, oldvalue):
	if type(key) == type(1):
		list.__setitem__(array, slice(key, key), [oldvalue])
	else:
		list.__setitem__(array, key, oldvalue)
	return self.list_del_redo, (array, key, oldvalue)
</t>
<t tx="bwmulder.20040602085955.5">def list_del_redo(self, array, key, oldvalue):
	oldvalue = list.__getitem__(array, key)
	list.__delitem__(array, key)
	return self.list_del_undo, (array, key, oldvalue)
</t>
<t tx="bwmulder.20040602151709"></t>
<t tx="bwmulder.20040602152051">def list_append(self, array):
	self._steps.append((self.list_append_undo, (array,)))
	


</t>
<t tx="bwmulder.20040602152051.1">def list_append_undo(self, array):
	oldvalue = list.pop(array)
	return self.list_append_redo, (array, oldvalue)
</t>
<t tx="bwmulder.20040602152051.2">def list_append_redo(self, array, oldvalue):
	list.append(array, oldvalue)
	return self.list_append_undo, (array,)</t>
<t tx="bwmulder.20040602152548">def pop(self):
	oldvalue = list.pop(self)
	self.monitor_object.list_pop(self, oldvalue)
</t>
<t tx="bwmulder.20040602152548.1"></t>
<t tx="bwmulder.20040602152548.2">def list_pop(self, array, oldvalue):
	self._steps.append((self.list_append_redo, (array, oldvalue)))
</t>
<t tx="bwmulder.20040602153618">class dict_monitor(dict):
	"""
	Overwrite dictionaries so that we can monitor them.
	"""
	@others
</t>
<t tx="bwmulder.20040602153642">def set_monitor_object(self, monitor_object):
	"""
	All changes to this dictionary will trigger calls to monitor_object methods
	"""
	self.monitor_object = monitor_object

</t>
<t tx="bwmulder.20040602153723">def __setitem__( self, key, value):
	"""
	Intercept the l[key]=value operations.
	Also covers slice assignment.
	"""
	try:
		oldvalue = self.__getitem__(key)
	except KeyError:
		self.monitor_object.dict_create(self, key, value)
	else:
		self.monitor_object.dict_set(self, key, oldvalue)
	dict.__setitem__(self, key, value)
</t>
<t tx="bwmulder.20040602153835">def __delitem__( self, key):
   oldvalue = dict.__getitem__(self, key)
   self.monitor_object.dict_del(self, key, oldvalue)
   dict.__delitem__(self, key)
</t>
<t tx="bwmulder.20040602154259">class dict_monitor_in_instance(object):
	"""
	Monitor instance attributes which contain a list as a value.

	Assignments to this attributes, which must be lists, are replaced by instances of 'list_monitor'.
   """
	@others
</t>
<t tx="bwmulder.20040602154259.1">def __init__(self, external_attributename, monitor_object):
	self.external_attributename = external_attributename
	self.internal_attributename = '__' + external_attributename
	self.monitor_object = monitor_object
</t>
<t tx="bwmulder.20040602154259.2">def __set__(self, instance, value):
	"""Intercept assignments to the external attribute"""
	assert isinstance(value, type({}))
	if isinstance(value, dict_monitor):
		newvalue = value
		# if the value is already a dict_monitor,
		# assume that the value is already monitored.
	else:
		newvalue = dict_monitor(value, self.monitor_object)
	internal_attributename = self.internal_attributename
	try:
		oldvalue = getattr(instance, internal_attributename)
	except AttributeError:
		self.monitor_object.list_assignment_new(instance, internal_attributename)
	else:
		self.monitor_object.list_assignment_replace(instance, internal_attributename, oldvalue)
	setattr(instance, self.internal_attributename, newvalue)
</t>
<t tx="bwmulder.20040602154259.3">def __get__(self, instance, owner):
   try:
      return instance.__dict__[self.internal_attributename]
   except KeyError: 
      return instance.__dict__[self.external_attributename]

</t>
<t tx="bwmulder.20040602154259.4">def enable_category(self, l, monitor_class):
   for klass, external_attributename in l:
      setattr(klass, external_attributename, monitor_class(
         external_attributename, self.monitor_object))
	</t>
<t tx="bwmulder.20040602161525">def disable_category(self, l, monitor_class):
   for klass, external_attributename in l:
      setattr(klass, external_attributename, passthrough (internal_attributename))
	
</t>
<t tx="bwmulder.20040602164627">def enable_put_in_removed_functions(self):
	"""
	Reinstate the functions which were removed from list_monitor and dict_monitor.
	"""
	for klass, attribute, function in self.removed_functions:
		setattr(klass, attribute, function)
</t>
<t tx="bwmulder.20040602165344"></t>
<t tx="bwmulder.20040602165402">def monitor_dict_attribute_in_class(self, klass, external_attributename):
   self.monitored_dict_attributes.append(
      (klass, external_attributename))
</t>
<t tx="bwmulder.20040602165506">def dict_create(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040602165513">def dict_set(self, array, key, value):
   raise notImplementedError
</t>
<t tx="bwmulder.20040602165553">def dict_del(self, array, key, oldvalue):
   raise notImplementedError
</t>
<t tx="bwmulder.20040602171032"></t>
<t tx="bwmulder.20040602171032.1"></t>
<t tx="bwmulder.20040602171032.2">def dict_create(self, dictionary, key, value):
	self._steps.append((self.dict_create_undo, (dictionary, key)))

</t>
<t tx="bwmulder.20040602171032.3">def dict_create_undo(self, dictionary, key):
	value = dict.__getitem__(dictionary, key)
	dict.__delitem__(dictionary, key)
	return self.dict_create_redo, (dictionary, key, value)

</t>
<t tx="bwmulder.20040602171032.4">def dict_create_redo(self, dictionary, key, value):
	dict.__setitem__(dictionary, key, value)
	return self.dict_create_undo, (dictionary, key,)
</t>
<t tx="bwmulder.20040602171032.5"></t>
<t tx="bwmulder.20040602171032.6">def dict_set(self, dictionary, key, oldvalue):
	self._steps.append((self.dict_set_undo, (dictionary, key, oldvalue)))

</t>
<t tx="bwmulder.20040602171032.7">def dict_set_undo(self, dictionary, key, value):
	oldvalue = dict.__getitem__(dictionary, key)
	dict.__setitem__(dictionary, key, value)
	return self.dict_set_undo, (dictionary, key, oldvalue)
</t>
<t tx="bwmulder.20040602171032.8"></t>
<t tx="bwmulder.20040602171032.9">def dict_del(self, dictionary, key, oldvalue):
   self._steps.append((self.dict_del_undo, (dictionary, key, oldvalue)))
   
</t>
<t tx="bwmulder.20040602171032.10">def dict_del_undo(self, dictionary, key, oldvalue ):
	dict.__setitem__(dictionary, key, oldvalue)
	return self.dict_del_redo, (dictionary, key, oldvalue)
</t>
<t tx="bwmulder.20040602171032.11">def dict_del_redo(self, dictionary, key, oldvalue ):
	oldvalue = dict.__getitem__(dictionary, key)
	dict.__delitem__(dictionary, key)
	return self.dict_del_undo, (dictionary, key, oldvalue)
</t>
<t tx="bwmulder.20040602171606">def reset(self):
	self._steps = []
	self._commands = [None, None]
	self._index = 0
	


</t>
<t tx="bwmulder.20040602175523">def list_assignment_replace(self, instance, attributename, oldvalue):
	self._steps.append((self.list_assignment_replace_undo, (instance, attributename, oldvalue)))</t>
<t tx="bwmulder.20040602175523.1">def list_assignment_replace_undo(self, instance, attributename, oldvalue):
	newvalue = getattr(instance, attributename)
	setattr(instance, attributename, oldvalue)
	return self.list_assignment_replace_redo, (instance, attributename, newvalue)</t>
<t tx="bwmulder.20040602175740">def list_assignment_replace_redo(self, instance, attributename, newvalue):
	oldvalue = getattr(instance, attributename)
	setattr(instance, attributename, newvalue)
	return self.list_assignment_replace_undo, (instance, attributename, oldvalue)
</t>
<t tx="bwmulder.20040602175801"># Dictionary monitors are are really handled like
# list monitors.
# For now, just use the same methods.
dict_assignment_new = list_assignment_new
dict_assignment_new_undo = list_assignment_new_undo
dict_assignment_new_redo = list_assignment_new_redo

dict_assignment_replace      = list_assignment_replace
dict_assignment_replace_undo = list_assignment_replace_undo
dict_assignment_replace_redo = list_assignment_replace_redo</t>
<t tx="bwmulder.20040602183806">def list_assignment_new(self, instance, attributename):
	self._steps.append((self.list_assignment_new_undo, (instance, attributename)))</t>
<t tx="bwmulder.20040602183814">def list_assignment_new_undo(self, instance, attributename):
	newvalue = getattr(instance, attributename)
	delattr(instance, attributename)
	return self.list_assignment_new_redo, (instance, attributename, newvalue)</t>
<t tx="bwmulder.20040602183911">def list_assignment_new_redo(self, instance, attributename, newvalue):
	setattr(instance, attributename, newvalue)
	return self.list_assignment_new_undo, (instance, attributename)
</t>
<t tx="bwmulder.20040602221559">@others</t>
<t tx="bwmulder.20040602223236">from basic_undo import monitor, basic_undomechanism, list_monitor, dict_monitor
import unittest
from test import test_support
</t>
<t tx="bwmulder.20040602223236.1">class tracer(monitor):
	"""
	Simple class which can be used to trace all calls made from a monitor.
	
	The output format could be improved, but this is only for testing.
	"""
	@others

</t>
<t tx="bwmulder.20040602223236.2">def __getattr__(self, attributename):
	self.attributename = attributename
	return self.catchall</t>
<t tx="bwmulder.20040602223906">def catchall(self, *args, **kwrds):
	print "Tracer:", self.attributename, ":", args, kwds</t>
<t tx="bwmulder.20040602224231">class delegator(object):
	"""
	Simple class to print all arguments passed to a monitor.
	Allows you to watch the undoer in action...
	"""
	@others</t>
<t tx="bwmulder.20040602224332">def __getattr__(self, attributename):
	self.attributename = attributename
	return self.catchall</t>
<t tx="bwmulder.20040602224413">def __init__(self):
	self.undoer = basic_undomechanism()
	self.undoer.monitor_object = self
	
</t>
<t tx="bwmulder.20040602225640">class basic_scalar_test_class(object):
	"""Simple class for the basic_scalar_test"""
	pass

class basic_scalar_test(unittest.TestCase):
	@others</t>
<t tx="bwmulder.20040602230124">def test_scalar_basic(self):
	"""
	Some basic testing for the scalar undoer.
	"""
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()
	m.monitor_scalar(basic_scalar_test_class, "x")
	m.enable()
	# command 1
	c = basic_scalar_test_class()
	c.x = "First value"
	m.mark()
	# command 2	
	c.x = "second value"
	m.mark()
	# command 3
	c.x = "third value"
	m.mark()
	# command 4
	# Check that the second assignment can be undone
	assert c.x == "third value", c.x
	m.undo()
	# command 2
	assert c.x == "second value"
	m.undo()
	# command 1
	assert c.x == "First value", c.x
	m.undo()
	assert not hasattr(c, "x")
</t>
<t tx="bwmulder.20040602230426">def test_main():
    test_support.run_unittest(
		basic_scalar_test,
		basic_list_test,					
		basic_dict_test,	 
                  )

if __name__ == '__main__':
    test_main()
</t>
<t tx="bwmulder.20040602231914">def catchall(self, *args, **kwrds):
	print "delegator:", self.attributename, ":", args, kwrds
	getattr(self.undoer, self.attributename) (*args, **kwrds)
</t>
<t tx="bwmulder.20040602231934">def enable_category(self, l, monitor_class):
   for klass, external_attributename, internal_attributename in l:
      setattr(klass, external_attributename, monitor_class(
         external_attributename, internal_attributename, self))
	
</t>
<t tx="bwmulder.20040602232337">undo_tracing = False</t>
<t tx="bwmulder.20040603081718">def remove_overrides_in_list_and_dict_monitor(self):
	"""
	Deletes all function definitions in list_monitor and dict_monitor.
	The net effect of this is that instances of these classes should
	behave like regular lists and dictionaries.
	"""	
	import inspect
	for klass in (list_monitor, dict_monitor):
		for attribute in dir(klass):
			try:
				entity = getattr(klass, attribute)
			except AttributeError:
				pass
			else:
				if inspect.isfunction(entity):
					delattr(klass, attribute)
					self.removed_functions.append(klass, attribute, entity)</t>
<t tx="bwmulder.20040603211921"></t>
<t tx="bwmulder.20040603212552">def commands(self):
	return len(self._commands) - 2</t>
<t tx="bwmulder.20040603212612">def commands_to_undo(self):
	return self._index</t>
<t tx="bwmulder.20040603212713">def commands_to_redo(self):
	return self.commands() - self._index</t>
<t tx="bwmulder.20040603212934">def rollback(self):
	self.run_commands(self._steps)
</t>
<t tx="bwmulder.20040604165011">def steps_stored(self):
	"""
	Return the total number of steps stored in the undoer.
	"""
	result = 0
	for command in self._commands[1:-1]:
		result += len(command)
	return result</t>
<t tx="bwmulder.20040604184443">def test_linked_list(self):
	"""
	Shows that the basic undo mechanism can be used to undo the construction of a linked list.
	"""
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()

	# Create a linked list and check that the link operations can be undone.
	class root_class(object):
		pass
		
	class x(object):
		def __init__(self, name, next=None):
			self.name = name
			self.next = next
	
	def p(root):
		result = []
		r = root.root
		while r:
			result.append(r.name)
			r = r.next
		return result
			
	undoer = basic_undomechanism()
	
	m.monitor_scalar(root_class, "root")
	m.monitor_scalar(x, "name")
	m.monitor_scalar(x, "next")
	m.enable()
	
	root = root_class()
	root.root = x("first")
	root.root.next = x("second")
	m.mark()
	root.root.next.next = x("third")
	root.root.next.next.next = x("fourth")
	m.mark()
	assert p(root) == ["first", "second", "third", "fourth"]
	m.undo()
	assert  p(root) == ["first", "second"]
	m.redo()
	assert p(root) ==["first", "second", "third", "fourth"]
	
	# now try a few things with dictionaries.
	m.monitor_dict_attribute_in_class(root_class, "d")
	m.enable()
	root.d = {}
	m.mark()
	root.d = {'Some dict': 1}
	m.mark()
	root.d[1] = 2
	assert root.d == {'Some dict': 1, 1: 2}, root.d
	m.mark()
	m.undo()
	assert root.d == {'Some dict': 1}, root.d
	m.undo()
	assert root.d == {}, root.d
	
	
	</t>
<t tx="bwmulder.20040605104941">class basic_list_test_class(object):
	"""Simple class to test the list undoer"""
	pass

class basic_list_test(unittest.TestCase):
	"""
	Test the basic operations of the list class
	"""
	@others
		
</t>
<t tx="bwmulder.20040605105746">def test_lists_basic(self):
	"""
	Some basic testing for the list undoer.
	
	"""
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()
	m.monitor_list_attribute_in_class(basic_list_test_class, "a")
	m.enable()
	c = basic_list_test_class()
	c.a = [1, 2, 3]
	c.a = c.a
	m.mark()
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	c.a.append(5)
	m.mark()
	assert m.commands_to_undo() == 2, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	assert c.a == [1, 2, 3, 5], c.a
	m.undo()
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 1, m.commands_to_redo()
	assert c.a == [1, 2, 3], c.a
	m.redo()
	assert m.commands_to_undo() == 2, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	assert c.a == [1, 2, 3, 5], c.a
	m.undo()
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 1, m.commands_to_redo()
	m.undo()
	assert m.commands_to_undo() == 0, m.commands_to_undo()
	assert m.commands_to_redo() == 2, m.commands_to_redo()
	assert not hasattr(c, "a"), "A should not exist here"
	assert m.steps_stored() == 3, m.steps_stored()
	m.redo()
	m.redo()
	assert c.a == [1, 2, 3, 5], c.a
	del c.a[2]
	assert c.a == [1, 2, 5], c.a # 1
	m.mark()
	m.undo()
	assert c.a == [1, 2, 3, 5], c.a # 2
	m.redo()
	assert c.a == [1, 2, 5], c.a # 3
	x = c.a.pop()
	m.mark()
	assert c.a == [1, 2]
	m.undo()
	assert c.a == [1, 2, 5]

	

	


</t>
<t tx="bwmulder.20040605174728">def test_lists_replace(self):
	"""
	
	Test that list assignment works for an instance attribute that is put under the
	undo mechanism.
	
	"""
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()
	c = basic_list_test_class()
	m.monitor_list_attribute_in_class(basic_list_test_class, "a")
	m.enable()
	c.a = [1, 2, 3]
	m.mark()
	m.undo()
	assert not hasattr(c,"a")
	m.redo()
	c.a.append(4)
	c.a.append(5)
	assert c.a == [1, 2, 3, 4, 5]
	m.mark()
	m.undo()
	assert c.a == [1, 2, 3]
	m.redo()
	assert c.a == [1, 2, 3, 4, 5]
	b = list_monitor(('a', 'b', 'c'), m)
	m.enable()
	b.append('d')
	assert b == ['a', 'b', 'c', 'd']
	m.mark()
	m.undo()
	assert b == ['a', 'b', 'c']
	m.redo()
	assert b == ['a', 'b', 'c', 'd']
	
	
</t>
<t tx="bwmulder.20040605180204">class basic_dict_test_class(object):
	"""Simple class to test the list undoer"""
	pass

class basic_dict_test(unittest.TestCase):
	"""
	Test the basic operations of the list class
	"""
	@others
		

</t>
<t tx="bwmulder.20040605180225">def test_dicts_basic(self):
	"""
	Some basic testing for the dict undoer.
	
	"""
	trace_commands = False
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()
	m.monitor_dict_attribute_in_class(basic_dict_test_class, "a")
	m.enable()
	c = basic_dict_test_class()
	c.a = {1:1, 2:2, 3:3}
	c.a = c.a
	m.mark()
	if trace_commands:  print; m.print_commands(1)
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	c.a[5] = 5
	m.mark()
	if trace_commands: m.print_commands(2)
	assert m.commands_to_undo() == 2, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 1
	m.undo()
	if trace_commands: m.print_commands(3)
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 1, m.commands_to_redo()
	assert c.a == {1:1, 2:2, 3:3}, c.a # 2
	m.redo()
	if trace_commands: m.print_commands(4)
	assert m.commands_to_undo() == 2, m.commands_to_undo()
	assert m.commands_to_redo() == 0, m.commands_to_redo()
	assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 3
	m.undo()
	if trace_commands: m.print_commands(5)
	assert m.commands_to_undo() == 1, m.commands_to_undo()
	assert m.commands_to_redo() == 1, m.commands_to_redo()
	assert c.a == {1:1, 2:2, 3:3}, c.a # 4
	m.undo()
	if trace_commands: m.print_commands(6)
	assert m.commands_to_undo() == 0, m.commands_to_undo()
	assert m.commands_to_redo() == 2, m.commands_to_redo()
	assert not hasattr(c, "a"), "A should not exist here"
	assert m.steps_stored() == 3, m.steps_stored()
	m.redo()
	if trace_commands: m.print_commands(7)
	assert c.a == {1:1, 2:2, 3:3}, c.a # 5
	m.redo()
	if trace_commands: m.print_commands(8)
	assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 6
	del c.a[5]
	assert c.a == {1:1, 2:2, 3:3}, c.a # 7
	m.mark()
	if trace_commands: m.print_commands(9)
	m.undo()
	if trace_commands: m.print_commands(10)
	assert c.a == {1:1, 2:2, 3:3, 5:5}, c.a # 8
	m.redo()
	if trace_commands: m.print_commands(11)
	assert c.a == {1:1, 2:2, 3:3}, c.a # 9
	del c.a[2]
	m.mark()
	if trace_commands: m.print_commands(12)
	assert c.a == {1:1, 3:3}, c.a # 10
	m.undo()
	if trace_commands: m.print_commands(13)
	assert c.a == {1:1, 2:2, 3:3}, c.a # 11



	

</t>
<t tx="bwmulder.20040605180245">def test_dicts_replace(self):
	"""
	
	Test that dict assignment works for an instance attribute that is put under the
	undo mechanism.
	
	"""
	if undo_tracing:
		self.m = m = delegator()
	else:
		self.m = m = basic_undomechanism()
	c = basic_dict_test_class()
	m.monitor_dict_attribute_in_class(basic_dict_test_class, "a")
	m.enable()
	c.a = {1:1, 2:2, 3:3}
	m.mark()
	m.undo()
	assert not hasattr(c,"a")
	m.redo()
	c.a[4] = 4
	c.a[5] = 5
	assert c.a == {1:1, 2:2, 3:3, 4:4, 5:5}, c.a # 1
	m.mark()
	m.undo()
	assert c.a == {1:1, 2:2, 3:3}, c.a # 2
	m.redo()
	assert c.a ==  {1:1, 2:2, 3:3, 4:4, 5:5}, c.a # 3
	b = dict_monitor({'a':'a', 'b':'b', 'c':'c'}, m)
	m.enable()
	b['d'] = 'd'
	assert b == {'a':'a', 'b':'b', 'c':'c', 'd':'d'}, b # 4
	m.mark()
	m.undo()
	assert b == {'a':'a', 'b':'b', 'c':'c'}, b # 5
	m.redo()
	assert b == {'a':'a', 'b':'b', 'c':'c', 'd':'d'}, b # 6
	
	</t>
<t tx="bwmulder.20040605220919">def print_commands(self, comment):
	"""
	rint a readable list of all commands
	"""
	print "===== Commands: %s ========" % comment
	i = 0
	while i &lt; len(self._commands):
		print "Command", i
		steps = self._commands[i]
		if steps:
			for step in steps:
				function, args = step
				print "  ",function.__name__, args
		if i == self._index:
			print "---------------------"
		i += 1
	print "========================"
</t>
<t tx="bwmulder.20040605231305">def __init__(self, value, monitor):
	list.__init__(self, value)
	self.set_monitor_object(monitor)
</t>
<t tx="bwmulder.20040605231401">def __init__(self, value, monitor):
	dict.__init__(self, value)
	self.set_monitor_object(monitor)
</t>
<t tx="edream.110203113231.233">@ To do:
    
*** WARNING: problems with locking out event handlers could cause Leo to drop Text!
    - Do not trust this version of Leo with important data !!!
    
- The find logic doesn't properly show the found selection (or the correct body text).
    - Remove traces.

- Replace body widget with something better.

- Update joined headlines when any headline changes.

- Minor:
    - Finish all callbacks.
    - Finish dragging code.
    - Handle exception when starting by double-clicking LeoPy.leo.</t>
<t tx="edream.110203113231.234">@nocolor</t>
<t tx="edream.110203113231.235"></t>
<t tx="edream.110203113231.236">
</t>
<t tx="edream.110203113231.237">

- Almost all events connected properly.
- Code draws the screen (after the file has been read in!)
- Removed idle-time pollution: created onUpdateAllMenus.</t>
<t tx="edream.110203113231.238"></t>
<t tx="edream.110203113231.242"></t>
<t tx="edream.110203113231.243"># Used 10/11/03 to convert old wxLeo code 

if 0: # This script calls c2py on the current node and all nodes of its subtree.
    import c2py
    c2py.convertCurrentTree()</t>
<t tx="edream.110203113231.257"># This updates the text of joined _headlines_, not body text.

if 0: # no longer used

    def updateJoinedHeadlines(self,text,v):
        guard = 0
        if guard &gt; 0: return
        guard += 1
        v2 = v.joinList()
        while v2 and v2 != v:
            id = v2.treeID()
            assert(id)
            self.tree.SetItemText(id,text)
            v2 = v2.joinList()
        guard -= 1</t>
<t tx="edream.110203113231.618">@ It is usually best not to catch exceptions in plugins:
doHook catches all exceptions and disables further calls to plugins.
@c

@language python
@tabwidth -4</t>
<t tx="edream.110203113231.667"></t>
<t tx="edream.110203113231.668"></t>
<t tx="edream.110203113231.677">@ignore
@language plain
@comment !
@ This node has an example of a flat configuration file (i.e. just the output of a 
'show running' command on a cisco router), and of the same configuration file 
imported by the plugin.
</t>
<t tx="edream.110203113231.678">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable
!
hostname rpr1
!
boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3
logging buffered 100000 debugging
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
!
controller SONET 1/0/0
 framing sdh
!
controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2
!
controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
!
interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast
!
interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex
!
interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex
!
interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.2
 no ip directed-broadcast
!
interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode
!
interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast
!
interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal
!
interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010
!
interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010
!
interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address
!
interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable
!
router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0
!
router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary
!
ip classless
ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3
ip bgp-community new-format
ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
logging facility local6
logging 10.10.10.1
access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any
route-map only permit 2
 match community 65001:2
 set origin igp
!
route-map only1 permit 10
 match community 1 65001:1
 set origin igp
!
route-map only3 permit 10
 match community 100
!
route-map tag_com permit 10
 match tag 1
 set community 65001:1
!
route-map tag_com permit 20
 match tag 3
 set community 65001:3
!
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware
line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0
!
ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer
end

rpr1#
</t>
<t tx="edream.110203113231.679">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
&lt;&lt;service&gt;&gt;
!
hostname rpr1
!
&lt;&lt;boot&gt;&gt;
&lt;&lt;logging&gt;&gt;
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
&lt;&lt;controller&gt;&gt;
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
&lt;&lt;interface&gt;&gt;
!
&lt;&lt;router&gt;&gt;
!
ip classless
&lt;&lt;ip route&gt;&gt;
ip bgp-community new-format
&lt;&lt;ip community-list&gt;&gt;
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
&lt;&lt;access-list&gt;&gt;
&lt;&lt;route-map&gt;&gt;
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
&lt;&lt;line&gt;&gt;
!
&lt;&lt;ntp&gt;&gt;
end

rpr1#</t>
<t tx="edream.110203113231.680">access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any</t>
<t tx="edream.110203113231.681">boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3</t>
<t tx="edream.110203113231.682"></t>
<t tx="edream.110203113231.683">controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2</t>
<t tx="edream.110203113231.684">controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1</t>
<t tx="edream.110203113231.685">controller SONET 1/0/0
 framing sdh</t>
<t tx="edream.110203113231.686"></t>
<t tx="edream.110203113231.687">interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address</t>
<t tx="edream.110203113231.688">interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable</t>
<t tx="edream.110203113231.689">interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex</t>
<t tx="edream.110203113231.690">interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex</t>
<t tx="edream.110203113231.691">interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="edream.110203113231.692">interface FastEthernet0/0/1.2
 no ip directed-broadcast</t>
<t tx="edream.110203113231.693">interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode</t>
<t tx="edream.110203113231.694">interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="edream.110203113231.695">interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="edream.110203113231.696">interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast</t>
<t tx="edream.110203113231.697">interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal</t>
<t tx="edream.110203113231.698">interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="edream.110203113231.699">interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="edream.110203113231.700">interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="edream.110203113231.701">interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010</t>
<t tx="edream.110203113231.702">interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010</t>
<t tx="edream.110203113231.703">ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3</t>
<t tx="edream.110203113231.704">ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3</t>
<t tx="edream.110203113231.705"></t>
<t tx="edream.110203113231.706">line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware</t>
<t tx="edream.110203113231.707">line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0</t>
<t tx="edream.110203113231.708">logging buffered 100000 debugging
logging facility local6
logging 10.10.10.1</t>
<t tx="edream.110203113231.709">ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer</t>
<t tx="edream.110203113231.710"></t>
<t tx="edream.110203113231.711">route-map only permit 2
 match community 65001:2
 set origin igp</t>
<t tx="edream.110203113231.712">route-map only1 permit 10
 match community 1 65001:1
 set origin igp</t>
<t tx="edream.110203113231.713">route-map only3 permit 10
 match community 100</t>
<t tx="edream.110203113231.714">route-map tag_com permit 10
 match tag 1
 set community 65001:1</t>
<t tx="edream.110203113231.715">route-map tag_com permit 20
 match tag 3
 set community 65001:3</t>
<t tx="edream.110203113231.716"></t>
<t tx="edream.110203113231.717">router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary</t>
<t tx="edream.110203113231.718">router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0</t>
<t tx="edream.110203113231.719">no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable</t>
<t tx="edream.110203113231.722"></t>
<t tx="edream.110203113231.723">[Main]
active = Yes
interval = 20</t>
<t tx="edream.110203113231.729"></t>
<t tx="edream.110203113231.740"></t>
<t tx="edream.110203113231.744"></t>
<t tx="edream.110203113231.872"></t>
<t tx="edream.110203113231.915"></t>
<t tx="edream.110203113231.930"></t>
<t tx="edream.110203113231.931">colour
colourful
coloured
</t>
<t tx="edream.110203113231.932"># Configuration file for mod_spelling plugin.

[main]

aspell_dir=c:\aspell\bin\aspell.exe

local_leo_dictionary=c:\prog\leoCVS\leo\plugins\mod_spelling.txt

local_language_code=en</t>
<t tx="edream.110203113231.982">@ignore</t>
<t tx="edream.110203113231.983">@nocolor

Attached is some proof-of-concept code for a Leo Plugin manager.

To try it out ... (warning: it will write files to your c:\temp directory)

1. Start 'leopm_server.py' ... Should display a message saying "Listening on 8001"
2. Start 'leopm_client.py' ... Should bring up an ugly Tkinter window

How it works:

1. The client attaches to the remote server (via XMLRPC) 
2. Client asks for a list of plug-ins
3. Server responds
4. Client asks for details of files required + version for each plugin
5. Client checks local plugin directory to see if these files are there and if they are the right version.
6. Client displays list of available + installed plugins
7. User selects plugin and clicks 'Install'
8. Client requests files from server
9. Server sends back files
10. Client installs files in local directory (currently c:\temp)

In the current code, the client side is functional - the server side is
actually dummy methods just returning the right kind of data. There's no
point doing anything clever there until the client functionality is
fully fleshed out. Although it is all running locally in the demo there
aren't any code changes required to run remotely.

It is all pretty primitive, but I think the functionality maps quite
closely with jEdit. Tidying the Tkinter interface and fleshing out the
server side shouldn't take too long and then it could be wrapped as a
plugin itself.

Advantages of this (XMLRPC) approach,

- can go over HTTP port
- client and server are nicely decoupled (server needn't be in Python if the web host doesn't support it)
- client/server stuff is so transparent (look at the server implementation!) compared to other approaches.

Some kind of 'submit plugin' option would be interesting, but suddenly security issues start to loom!

Do you think this is worth pursuing?</t>
<t tx="edream.110403140857"></t>
<t tx="edream.110403140857.1"></t>
<t tx="edream.110403140857.2">@
--How to install the wiki markup plugin--

1) first make sure that the "add_directives" plugin is enabled. This plugin turns on support for @markup directives, and it can be found in leoPlugins.leo under the section "Plugins &amp; scripts" -&gt; Directives. In particular:
    a) check that the plugin code is enabled. You should have a line like (note the "if 1"):
        if 1: # Register the handlers...
    b) generate the plugin file. Right click with the mouse on the outline heading "@file add_directives.py" and select "Write @file nodes".

2) enable the "color_markup.py" plugin:
    a) check that the plugin code is enabled. You should have a line like:
        if Tkinter: # Register the handlers...
    b) generate the plugin file. Right click with the mouse on the outline heading "@file color_markup.py" and select "Write @file nodes".

</t>
<t tx="edream.110403140857.3">@
--How to use the wiki markup plugin--

Make sure first that both the add_directives and color_markup plugins are installed and enabled (see the Installation node for details). Make also sure that coloring is not disabled for your outline (i.e. you should not have @nocolor in an ancestor node).
    
Important: coloring via wiki markups is only supported in doc parts and Python triple-double-quoted strings (not in Python triple-single-quoted strings!).

To use the wiki markup, write

@markup wiki # turn on the wiki markup
@            # start a doc part
(here goes your marked-up text, see below)

To disable the wiki markup, write

@markup      # turn off the wiki markup

You can now use the markups either selecting the Wiki menu entries (or the corresponding keyboard shortcuts) found in the Edit-&gt;Edit Body-&gt;Wiki Tags menu, or manually inserting the tags yourself. 

If you use the menus, you can either select a word and choose the appropriate menu entry to appy styling to that word, or you can just choose a menu entry (e.g. "Bold") and start writing text with the correspongin style. Select the menu entry again to return to normal text.

See the "Supported markups" for the currently supported markups.

See also the "Example" subnode. If you have the add_directives and color_markup plugins enabled, you should see the text in that node displayed as styled text.</t>
<t tx="edream.110403140857.4">@
The currently supported markups are:

''text''                   # write text in italics
__text__                   # write text in bold
~~&lt;color&gt;:text~~           # write text in the color specified by &lt;color&gt; (e.g. blue, grey, etc)
{picture file=&lt;filename&gt;}  # load the picture indicated by &lt;filename&gt;
http://url                 # URL support: double clicking on the url will open it in the default browser.
https://url                # URL support: double clicking on the url will open it in the default browser.

Note 1: italics and bold markups can be nested, e.g.

''__text__''               # write text in italics and bold

Just remember to terminate the tags in the order they were opened.

Note 2: URLs must be terminated by a space.

By default, once the text has been markup up, the actual tags (e.g. __ for bold) are not displayed anymore. You can choose to display them selecting "Show Invisibles" from the Edit menu.
</t>
<t tx="edream.110403140857.5">@color
@markup wiki
@doc (this turns on a doc section; a '@ ' would do too)

This should be ''italic'' text
This should be __bold__ text
This text should be ~~pink:colored in pink~~, ~~blue:this one in blue~~.
This text should be ''__both bold and italic__''.
Leo's homepage is at http://webpages.charter.net/edreamleo/front.html 

You can also have wiki markups in python triple-double-quoted strings:

@c

def __dummy():
    """This is a __very important__ function."""
    return None
</t>
<t tx="edream.110403140857.6">@
Wiki markups are supported ''in subnodes too''.</t>
<t tx="edream.110403140857.7">@
Version 1.2.1, October 29, 2003.

Added documentation.
Added menu entries to tag selected text and to start/end wiki tagging.

Version 1.3, October 29, 2003.

Fixed bug in the creation of the wiki menu.
Added support for clickable http tags.

Version 1.4, November 4, 2003.
Put import tkinter in a try/except block.
Made changes for 4.1 g.app.gui architecture. (More work needed).</t>
<t tx="edream.111303100039"></t>
<t tx="edream.111303100039.1"></t>
<t tx="edream.111303100039.6">def insertHeadlineTime (self):
    
    es("insertHeadlineTime not ready yet")
    return

    frame = self ; c = frame.c ; v = c.currentVnode()
    h = v.headString() # Remember the old value.

    if v.edit_text():
        sel1,sel2 = g.app.gui.getTextSelection(v.edit_text())
        if sel1 and sel2 and sel1 != sel2: # 7/7/03
            v.edit_text().delete(sel1,sel2)
        v.edit_text().insert("insert",c.getTime(body=False))
        frame.idle_head_key(v)

    # A kludge to get around not knowing whether we are editing or not.
    if h.strip() == v.headString().strip():
        es("Edit headline to append date/time")</t>
<t tx="edream.111303100039.7"></t>
<t tx="edream.111303100039.8">def cascade(self):
    
    es("cascade not ready yet")
    return

    x,y,delta = 10,10,10
    for frame in g.app.windowList:
        top = frame.top
        # Compute w,h
        top.update_idletasks() # Required to get proper info.
        geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
        dim,junkx,junky = string.split(geom,'+')
        w,h = string.split(dim,'x')
        w,h = int(w),int(h)
        # Set new x,y and old w,h
        geom = "%dx%d%+d%+d" % (w,h,x,y)
        frame.setTopGeometry(geom) # frame.top.geometry("%dx%d%+d%+d" % (w,h,x,y))
        # Compute the new offsets.
        x += 30 ; y += 30
        if x &gt; 200:
            x = 10 + delta ; y = 40 + delta
            delta += 10
</t>
<t tx="edream.111303100039.9">def equalSizedPanes(self):
    
    es("equalSizedPanes not ready yet")
    return

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
</t>
<t tx="edream.111303100039.10">def hideLogWindow (self):
    
    es("hideLogWindow not ready yet")
    return
    
    frame = self
    frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)</t>
<t tx="edream.111303100039.11">def minimizeAll(self):
    
    es("minimizeAll not ready yet")
    return

    self.minimize(g.app.findFrame)
    self.minimize(g.app.pythonFrame)
    for frame in g.app.windowList:
        self.minimize(frame)
    
def minimize(self, frame):

    if frame:
        frame.Show(False)</t>
<t tx="edream.111303100039.12"># The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.
def toggleSplitDirection(self):
    
    es("toggleSplitDirection not ready yet")
    return

    # Abbreviations.
    frame = self
    bar1 = self.bar1 ; bar2 = self.bar2
    split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
    split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
    # Switch directions.
    verticalFlag = self.splitVerticalFlag = not self.splitVerticalFlag
    orientation = choose(verticalFlag,"vertical","horizontal")
    g.app.config.setWindowPref("initial_splitter_orientation",orientation)
    # Reconfigure the bars.
    bar1.place_forget()
    bar2.place_forget()
    self.configureBar(bar1,verticalFlag)
    self.configureBar(bar2,not verticalFlag)
    # Make the initial placements again.
    self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
    self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
    # Adjust the log and body panes to give more room around the bars.
    self.reconfigurePanes()
    # Redraw with an appropriate ratio.
    vflag,ratio,secondary_ratio = frame.initialRatios()
    self.resizePanesToRatio(ratio,secondary_ratio)</t>
<t tx="edream.111303101257">def abortEditLabelCommand (self):

    es("abortEditLabelCommand not ready yet")
    return
    
    c = self.c ; v = c.currentVnode ; tree = self.tree
    # trace(v)
    if self.revertHeadline and v.edit_text() and v == self.editVnode:
        
        # trace(`self.revertHeadline`)
        v.edit_text().delete("1.0","end")
        v.edit_text().insert("end",self.revertHeadline)
        tree.idle_head_key(v) # Must be done immediately.
        tree.revertHeadline = None
        tree.select(v)
        if v and len(v.t.joinList) &gt; 0:
            # 3/26/03: changed redraw_now to force_redraw.
            tree.force_redraw() # force a redraw of joined headlines.</t>
<t tx="edream.111303101257.1">def endEditLabelCommand (self):
    
    es("endEditLabelCommand not ready yet")
    return

    c = self.c ; tree = self.tree ; v = self.editVnode

    if v and v.edit_text():
        tree.select(v)

    if v: # Bug fix 10/9/02: also redraw ancestor headlines.
        # 3/26/03: changed redraw_now to force_redraw.
        tree.force_redraw() # force a redraw of joined headlines.

    gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02</t>
<t tx="edream.111303101709">def toggleActivePane(self):
    
    # This can't work from the menu...
    
    es("toggleActivePane not ready yet")
    return

    if self.FindFocus() == self.body.bodyCtrl:
        self.tree.SetFocus()
    else:
        self.body.bodyCtrl.SetFocus()</t>
<t tx="edream.111303103141.3">def delete_range (self,menu,n1,n2):
    
    if not menu:
        trace("no menu")
        return
        
    # trace(n1,n2,menu.GetTitle())
    
    items = menu.GetMenuItems()
    
    if 0: # debugging
        for item in items:
            id = item.GetId()
            item = menu.FindItemById(id)
            trace(item.GetText())
            
    ## Doesn't work:  a problem with wxPython.
    
    if len(items) &gt; n1 and len(items) &gt; n2:
        i = n1
        while i &lt;= n2:
            id = items[i].GetId()
            item = menu.FindItemById(id)
            trace("deleting:",item.GetText())
            menu.Delete(id)
            i += 1</t>
<t tx="edream.111303184347">@ The wxWindows menu code has problems:  changes do not take effect immediately.</t>
<t tx="edream.111303202917.1">def getColorizer(self):

    return self.colorizer

def recolor(self,v,incremental=False):

    if self.use_coloring:
        self.colorizer.colorize(v,incremental)

def recolor_now(self,v,incremental=False):

    if self.use_coloring:
        self.colorizer.colorize(v,incremental)
    
def recolor_range(self,v,leading,trailing):

    if self.use_coloring:
        self.colorizer.recolor_range(v,leading,trailing)
    
def updateSyntaxColorer (self,v):

    return self.colorizer.updateSyntaxColorer(v)</t>
<t tx="edream.111303204025"></t>
<t tx="edream.111303204025.1">def adjustIndex (self,index,offset):
    
    try:
        column, row = index
        return column, row + offset
    except:
        return index + offset</t>
<t tx="edream.111303204025.2">def compareIndices(self,i,rel,j):
    
    try:
        y1,x1 = i
        y2,x2 = j
        pos1 = self.bodyCtrl.XYToPosition(x1,y1)
        pos2 = self.bodyCtrl.XYToPosition(x2,y2)
    except:
        pos1 = i
        pos2 = j
    
    val = eval("%d %s %d" % (pos1,rel,pos2))
    trace(i,j,rel,val)
    return val</t>
<t tx="edream.111303204025.3">def convertRowColumnToIndex (self,row,column):
    
    index = self.bodyCtrl.XYToPosition(column,row-1)
    # trace(column,row,"-&gt;",index)
    return index</t>
<t tx="edream.111303204025.4">def convertIndexToRowColumn (self,index):
    
    x,y = self.bodyCtrl.PositionToXY(index)
    # trace(index,"-&gt;",y+1,x)
    return y+1,x</t>
<t tx="edream.111303204025.5">def getImageIndex (self,image):
    
    trace(image)</t>
<t tx="edream.111303204517"></t>
<t tx="edream.111303205442">@ The colorizer isn't ready for prime time:
    
    - It's too slow when selecting long text
    - The screen flashes too much
    - The tkColorToWxColor routine needs much more work.
    
wxLeo should use wxStc rather than wxText!</t>
<t tx="edream.111303205611">def tag_add (self,tagName,index1,index2):
    
    # trace(tagName,index1,index2)

    style = self.styles.get(tagName)
    if style:
        self.bodyCtrl.SetStyle(index1,index2,style)</t>
<t tx="edream.111303205611.1">def tag_bind (self,tagName,event,callback):
    
    # trace(tagName,event,callback)
    pass
</t>
<t tx="edream.111303205611.2">def tag_configure (self,colorName,**keys):
    
    foreground = keys.get("foreground")
    background = keys.get("background")

    if foreground:
        fcolor = self.tkColorToWxColor (foreground)
        bcolor = self.tkColorToWxColor (background)
        if fcolor and bcolor:
            # trace(colorName,foreground,keys)
            style = wx.wxTextAttr(fcolor,bcolor)
            self.styles[colorName] = style
        elif fcolor:
            style = wx.wxTextAttr(fcolor)
            self.styles[colorName] = style</t>
<t tx="edream.111303205611.3">def tag_delete(self,tagName):

    if tagName == "keyword": # A kludge.

        # trace(tagName)
        style = wx.wxTextAttr(wx.wxBLACK)
        last = self.maxWxIndex()
        
        if 1: # This may cause the screen flash.
            self.bodyCtrl.SetStyle(0,last,style)</t>
<t tx="edream.111303205611.4">def tag_remove (self,tagName,index1,index2):
    
    trace(tagName,index1,index2)
    pass
</t>
<t tx="edream.111403080609">def maxWxIndex (self):
    
    return self.bodyCtrl.GetLastPosition()</t>
<t tx="edream.111403082513">def tkColorToWxColor (self, color):
    
    d = {
        "red": wx.wxRED,
        "blue": wx.wxBLUE,
        "#00aa00": wx.wxGREEN,
        "firebrick3": wx.wxRED }
        
    return d.get(color)</t>
<t tx="edream.111403093253">The new code now works with the new reorg.  This means that wxLeo is using all the code in Leo's core.

In particular:

- wxLeo creates all menus using the base leoMenu class.
- wxLeo uses all commands in the Commands class.
- wxLeoFrame contains only gui-dependent commands.

The syntax colorer is working in demo mode.  Almost certainly wxLeo should use a better control than wxText.</t>
<t tx="edream.111403093253.1"></t>
<t tx="edream.111503110300">At this point, Leo is useable.

What I did:

- Added use_coloring ivar to the wxLeoFrame class.  The body text is syntax colored only if this is True.
    This is set to False at present because the default colors are very poor.
    Also, coloring causes the body pane to scroll for large text.  These are minor problems...

- Got find panel working.  This required creating dummy wxSearchWidget class.  Probably _all_ the search code should be in the base leoFind class, but that would making supporting regexp searches harder.

- Simplified the event handlers in the find panel.  We can use tables to _create_ the event handlers.

- Solved the problem with selecting new nodes: we must lock out further event handling once an event handler starts.  In particular, the syntax colorer generates a lot of other events.  This also prevents the outline from being marked dirty when a new node is selected.

- Added code to insject do-nothing callbacks into vnode class.  This is required by the syntax colorer.

Later:

- Completed Find panel.

- Made sure Leo prompts when closing a window.
    - The new code is very simple: it just calls g.app.closeLeoWindow.
        - Removed some gui dependencies from the g.app.finishQuit logic.
          (They are now in the g.app.tkinterGui.destroySelf routine.)

- Implemented the wx gui dialog code.
    - Only the number dialog remains...

Very little remains to be done, and nothing big.</t>
<t tx="edream.111503111146"></t>
<t tx="edream.111503111350"></t>
<t tx="edream.111703103908"></t>
<t tx="edream.111703103908.2">def leoHelp (self):
    
    es("leoHelp not ready yet")
    
    return ##
    
    file = os.path.join(g.app.loadDir,"..","doc","sbooks.chm")
    file = toUnicode(file,g.app.tkEncoding) # 10/20/03

    if os.path.exists(file):
        os.startfile(file)
    else:	
        answer = g.app.gui.runAskYesNoDialog(
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")

        if answer == "yes":
            try:
                if 0: # Download directly.  (showProgressBar needs a lot of work)
                    url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
                    import urllib
                    self.scale = None
                    urllib.urlretrieve(url,file,self.showProgressBar)
                    if self.scale:
                        self.scale.destroy()
                        self.scale = None
                else:
                    url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                    import webbrowser
                    os.chdir(g.app.loadDir)
                    webbrowser.open_new(url)
            except:
                es("exception dowloading sbooks.chm")
                es_exception()</t>
<t tx="edream.111703103908.3">def showProgressBar (self,count,size,total):

    # trace("count,size,total:" + `count` + "," + `size` + "," + `total`)
    if self.scale == None:
        &lt;&lt; create the scale widget &gt;&gt;
    self.scale.set(count*size)
    self.scale.update_idletasks()</t>
<t tx="edream.111703103908.4">top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()</t>
<t tx="ekr.20040205071616">"""
mnplugins.py

mnplugins shows how to :
define new Commands  "insertOK" + "insertUser"
create Usermenu with new Commands

new Commands:
insertOK: 
    insert 'OK' in headline and a stamp in the first bodyline
    are there childnodes without 'OK' verhindern OK in actual node
    (insertOK on iconrclick2 too)

insertUser : Shift-F6
    insert a &lt;user/date/time&gt; stamp at the current location in bodytext
    
"""

import leoGlobals as g
import leoPlugins

import leoCommands
import time

OKFLAG='OK '  # Space required.

@others

try: import Tkinter as Tk
except ImportError: Tk = None

if Tk: 

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":
        leoPlugins.registerHandler("start1", onStart)
        leoPlugins.registerHandler("create-optional-menus",create_UserMenu)
        leoPlugins.registerHandler("iconrclick2", onRclick)

        __version__ = "0.1"
        g.plugin_signon(__name__)
        g.es('mnplug OK+Commands+Menu aktiv',color='green')</t>
<t tx="ekr.20040205071616.1">def mnstamp():

    lt=time.localtime(time.time())
    mndatetime=time.strftime('%y%m%d %H:%M',(lt))
    return '### '+g.app.leoID+mndatetime


</t>
<t tx="ekr.20040205071616.2">def mnOKstamp():

    lt=time.localtime(time.time())
    mndatetime=time.strftime('%y%m%d %H:%M',(lt))
    return '###'+OKFLAG+g.app.leoID+mndatetime
</t>
<t tx="ekr.20040205071616.3">def onStart (tag,keywords):

    # insert function insertUser as method of class Commands at runtime
    g.funcToMethod(insertUser,leoCommands.Commands)
    g.funcToMethod(insertOKcmd,leoCommands.Commands)

</t>
<t tx="ekr.20040205071616.4">def setHeadOK(v):

    s = OKFLAG + v.headString()
    v.setHeadStringOrHeadline(s)

</t>
<t tx="ekr.20040205071616.5">def insertBodystamp(c,v):

    stamp=mnOKstamp()+'\n'

    # insertAtBegin - ??!! workaround ??!! 
    # insertPointFormat is  ('row.column')
    
    oldip=c.frame.body.getInsertionPoint()
    newip=str(int(string.split(oldip,'.')[0])+1)+'.'+string.split(oldip,'.')[1]

    c.frame.body.setInsertionPoint('0.0')
    c.frame.body.insertAtInsertPoint(stamp)
    c.frame.body.setInsertionPoint(newip)
    c.frame.body.onBodyChanged(v,"Typing")</t>
<t tx="ekr.20040205071616.6">def is_subnodesOK(v):

    if not v.hasChildren():
        return True
    else:
        ok = False
        child=v.firstChild()
        while child:
            s=child.headString()
            ok=s[0:len(OKFLAG)]==OKFLAG
            if not ok:break
            child=child.next()
    return ok

</t>
<t tx="ekr.20040205071616.7">def onRclick(tag,keywords):
    
    """Handle right click in body pane."""

    c=keywords.get('c')
    insertOKcmd(c)</t>
<t tx="ekr.20040205071616.8">def insertOKcmd(self,event=None):

    c=self; v=c.currentVnode()  
    
    if is_subnodesOK(v) :
        setHeadOK(v)
        insertBodystamp(c,v)
    else: 
        g.es('OK in child missing')</t>
<t tx="ekr.20040205071616.9">def insertUser (self,event=None):
    
    """Handle the Insert User command."""

    c = self ; v = c.currentVnode()
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    
    s = mnstamp()
    
    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(v,"Typing",oldSel=oldSel)</t>
<t tx="ekr.20040205071616.10">def create_UserMenu (tag,keywords):

    c = keywords.get("c")
    
    c.pluginsMenu = c.frame.menu.createNewMenu("UserMenu")

    table = [
        ("insUser", 'Shift+F6', c.insertUser),
        ("insOK",'Ctrl+Shift+O',c.insertOKcmd)]

    c.frame.menu.createMenuEntries(c.pluginMenu,table)</t>
<t tx="ekr.20040330120121">@nocolor

None of these plugins is guaranteed to be ready for prime time.  I am including these here now so that we shall all have a common base from which to work.

I believe all these new plugins follow the 4.2 conventions (see next node).  I may, however, have introduced bugs in making the conversion to the 4.2 code style.  I apologize for any such problems.

@color</t>
<t tx="ekr.20040331071919"></t>
<t tx="ekr.20040331071919.1">@language plain
@ascfile "doc/mod_asc_dev.asc"
@doc                
@ascskip # Time-stamp: "Mon, Jan 19 15:30 CST 2004  michael@redpriest Leo_AsciiDoc_Developers_Guide_141612300.txt"
Preface
-------

Leo2AsciiDoc is a small Python program which has been built to be used as
a plugin module for the Leo outlining editor.

This is the Developer Documentation and source code listing of
Leo2AsciiDoc.

Leo2AsciiDoc enables the contents of Leo outlines to be published to
HTML or PDF via the DocBook XML set of publishing tools.  Plain text
from the Leo outline is transformed into a final result that has:

    - typeset body text, in which bulleted and numbered lists,
      variable lists, page numbers, URLs, index terms,and bold and
      italic text are automatically recognized.
    - typeset Headings
    - a Table of Contents
    - an Index containing any items marked by the user, and any
      Python classes or functions.

indexterm:[Literate Programming]
For programmers, Leo2AsciiDoc enables a simplified version of
Literate Programming: all the documentation and code for a program
can be written in a Leo outline, and published with just a few
keystrokes.  As is normal for a Leo outline, Leo can also extract
the source code from the outline and package it into text files,
ready to be run or compiled.

Specifically, what the Leo2AsciiDoc program does is:

    - wait to be called by the Leo menu (File; Export; Export to
      AsciiDoc), and then
    - read a part of a Leo outline, and
    - write the contents to a text file that can be understood by
      the AsciiDoc program.

From there:

    - the xref:AsciiDoc[] program can then convert that text file to
      another text file that is in the DocBook XML format.
    - the standard collection of xref:DocBook[] tools can then format the
      text in HTML (web page) files or as a typeset PDF file.
    - Once set up, the whole process happens quickly and
      automatically, usually with a simple "make" command.

Here are some web locations for the items I've referenced above:

Leo::    
    http://webpages.charter.net/edreamleo/front.html[]
Python::
    http://www.python.org[]
Docbook::    
    http://docbook.org/[]
Literate Programming::
    http://www.literateprogramming.com/[]
AsciiDoc::
    http://www.methods.co.nz/asciidoc/[]
PDF::
    Adobe provides a free program, Adobe Acrobat Reader (Windows &amp;
    Linux), that is used to read and print documents produced in the
    Adobe Portable Document Format.
    http://www.adobe.com/products/acrobat/readermain.html[]

---
Michael Dawson
Marshall Research
michael_dawson at marshallresearch dot com
---
@code</t>
<t tx="ekr.20040331071919.2">@doc
@ascskip # Time-stamp: "Fri, Jan  9 15:19 CST 2004  michael@redpriest About_this_document_140583820.txt"

If you are reading this document in HTML (in a web browser) or as a
PDF file (usually in Adobe Acrobat Reader), it may interest you to
know that this document was generated from a Leo outline.

The Leo outline (in the file mod_leo2ascd.leo) contained the
Leo2AsciiDoc Users Guide, the Leo2AsciiDoc Developers Guide, and all
the Leo2AsciiDoc source code.  All of them were created by simply
typing plain text.

The working source code was exported by Leo using the "File; Tangle;
Tangle" menu selection, which created the Python program file
"mod_leo2ascd.py".

The Users Guide and the Developers Guide were created by exporting
the text from Leo, using the menu selection "File; Export; Export
All to AsciiDoc".  This created the plain text files
"mod_asc_user.asc" and "mod_asc_dev.asc" (which are the file names I
told Leo to use.)

I then typed "make all" at the console in the directory, and the
make program:

    - ran the AsciiDoc program to produce the DocBook XML files.
    - ran the xsltproc program to produce the HTML files from the
      XML files.
    - ran the xsltproc program to produce "fo" files, and ran the
      fop program to produce PDF files from the fo files.

Everything was generated automatically without any further work on
my part.

@code</t>
<t tx="ekr.20040331071919.3">@doc
@ascskip # Time-stamp: "Mon, Jan 19 15:28 CST 2004  michael@redpriest License_141615068.txt"

This is part of the Leo2AsciiDoc software package, which is released
as open source.  

The license is the most "open" I know of, and is sometimes referred
to as the "X11" or "MIT" license.  Boiled down, in non-legal terms:

    - the software is yours for free -- to run, modify and
      distribute as you will
    - I have no legal liability for any of it
    - you may not use my name.

Michael Dawson
Marshall Research
michael_dawson at marshallresearch dot com

NOTE: The following license is often referred to as the "MIT/X
Consortium License", as the "MIT license" and as the "X11" license.
My source for the exact wording is the copy at the Open Source
Initiative:  http://opensource.org/licenses/mit-license.html[]


@code
</t>
<t tx="ekr.20040331071919.4">@doc
@ascskip # Time-stamp: "Fri, Jan  9 09:18 CST 2004  michael@redpriest License_document_140581532.txt"
---
Terms and Conditions
 
COPYRIGHT AND PERMISSION NOTICE

Copyright (c) 1999,2000,2001,2002,2003,2004 Michael W. Dawson

All rights reserved.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, provided
that the above copyright notice(s) and this permission notice appear
in all copies of the Software and that both the above copyright
notice(s) and this permission notice appear in supporting
documentation.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE
COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR
ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY
DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
OF THIS SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale,
use or other dealings in this Software without prior written
authorization of the copyright holder.
---
@code</t>
<t tx="ekr.20040331071919.5">@doc
@ascskip # Time-stamp: "Fri, Jan  9 16:13 CST 2004  michael@redpriest Version_Requirements_140584132.txt"

This is version 0.4 of Leo2AsciiDoc.  The major version of zero
indicates that it is an in-house version, not suitable for
production use elsewhere.

It was created and tested using:

    - Leo version 4.1 (release candidate 3).  Leo2AsciiDoc was
      upgraded to use the new features in 4.1 and is no longer
      compatible with previous versions.
    - AsciiDoc version 5.0.2.  Leo2AsciiDoc was upgraded to use the
      new features in 5.0.2, and is no longer compatible with older
      versions of AsciiDoc.
    - DocBook XML DTD version 4.2 and DocBook XSL stylesheets 1.60.1
    - xsltproc 1.0.30
    - fop 0.20.5

The last three items are the DocBook tool chain I'm currently using.
Any working DocBook XML tool chain you may have is likely to work,
since the major Leo2AsciiDoc effort is in producing the XML files
the tool chain uses as input.

@code</t>
<t tx="ekr.20040331071919.6">@language plain
@doc
@ascskip # Time-stamp: "Fri, Jan  9 16:00 CST 2004  michael@redpriest The_General_Approach_140588436.txt"

Leo2AsciiDoc simply copies the text from a portion of a Leo outline
to a text file.  That text file can then be processed by other
programs to produce HTML, PDF's, etc.

The text will be copied from each outline item, in outline order,
though you can skip individual nodes or sub-trees.

The idea is that you write the outline as a book, or series of
books.

If your book contains source code, you can break it up into pieces
that make it convenient to review with the reader.  Additionally,
you can discuss the pieces in any order that you like.  Using the
"tangle" command, Leo will be able to assemble and reorder the
pieces in the order required for a file of compilable source code.

As the text is copied from the outline, Leo2AsciiDoc adds minimal markup,
generally:

    - It marks up node headlines as Titles and Section Headings
      in the AsciiDoc format.
    - Program listings have AsciiDoc section markers inserted before
      and after.

A specific list follows.

@code</t>
<t tx="ekr.20040331071919.7">@language plain
@doc
@ascskip # Time-stamp: "Fri, Jan  9 16:05 CST 2004  michael@redpriest Markup_Added_140589620.txt"

    - headings:
        * By default, all outline node headings are underlined with
          the appropriate section underline character, which
          AsciiDoc will use to transform the headings into titles:
          chapter, section1, section2, etc.
        * code extracts are given an "example" heading.
    - source code sections are marked with delimiters, so that they
      can be assigned to the DocBook "programlisting" element.
    - source code sections are line-wrapped in the document output,
      for convenient html display.
    - wherever source code is exported to a source code file, the
      document with note this with an automatically generated "note"
      element.

@code
</t>
<t tx="ekr.20040331071919.8">@language python
@tabwidth -4

@doc
@ascskip on
 @silent
NB: remove leading space from above silent directive for final clean
code.

@ascskip off
@ascskip # Time-stamp: "Thu, Dec  4 11:58 CST 2003  michael@redpriest _The_Code__140751676.py"

This chapter contains all the source code for the Leo2AsciiDoc program.
The code is arranged in an order that is convenient for discussion.

On its way from the Leo outline to this document, the code has been
reformatted for printing.  Please note that:

    - code lines that are longer than the current publishing limit
      are wrapped.  Wrapped lines end in a "\" character and have
      the remainder of the text on the next line, preceeded by 4
      spaces. The real working code is not changed in this way when
      exported for actual use.
    - Some code has been extracted as Examples, and has a title
      saying something like "Example: Interesting Code".  Rather
      than repeat that code in the main code body, there is simply a
      reference to the name, enclosed in double angle brackets:
      \&lt;&lt;Interesting Code&gt;&gt;. All extracts are indexed, see "Python
      code, extracts used" in the Index at the end of the document.

@ascskip on
@root "mod_leo2ascd.py"
&lt;&lt; Declarations and Utilities &gt;&gt;
&lt;&lt; Write the outline tree as AsciiDoc file &gt;&gt;
&lt;&lt; Write a node &gt;&gt;
&lt;&lt; Key Functions &gt;&gt;
@code</t>
<t tx="ekr.20040331071919.9">@doc
@ascskip # Time-stamp: "Thu, Dec  4 16:05 CST 2003  michael@redpriest _Key_Functions__141128028.py"

These are the top-level functions that can be called from the Leo menu.

The next function writes the Leo outline tree of the current node to
a text file.  It first checks to see that there is an ascfile
directive in the current node, or above it, and then calls the
WriteTreeAsAsc function to write the tree starting at the ascfile
node.

If you have several documents in one Leo outline, this function will
write out the current one.

@code

def WriteTreeOfCurrentNode():
    c = g.top() ; f = c.frame
    vnode = c.currentVnode() # get the current vnode.
    while vnode:
        ascFileN = GetAscFilename(vnode)
        if ascFileN == None:
            vnode = vnode.parent()
        else:
            break

    if ascFileN == None:
        g.es("Sorry, there was no @ascfile directive in this outline tree.")
    else:
        WriteTreeAsAsc(vnode, ascFileN)

@doc

The next function exports all Leo2AsciiDoc documents in the entire Leo
outline, starting at the top and working through all nodes.

@code
def WriteAll():
    c = g.top() ; f = c.frame
    v = c.rootVnode()
    while v:
        ascFileN = GetAscFilename(v)
        if ascFileN != None:
            WriteTreeAsAsc(v, ascFileN)
            v = v.nodeAfterTree()
        else:
            v = v.threadNext()
@doc

This function is handy to see all the Leo2AsciiDoc sub-trees and source
code sub-trees in a Leo outline.  It prints the results in the log pane.

@code

def WriteAllRoots():
    "Writes @root directive and/or @ascfile directive to log pane."

    patternAscDirectiveFile = re.compile(r'^@ascfile')
    patternRoot = re.compile(r'^@root')

    g.es('Looking for @root or @ascfile.')
    c = g.top() ; f = c.frame
    vnode = c.rootVnode()
    while vnode:
        bodyString = vnode.bodyString()
        lines = bodyString.splitlines()
        printedHeading = False
        for line in lines:
            printLine = False
            containsAscFileDirective = patternAscDirectiveFile.match(line)
            if containsAscFileDirective:
                printLine = True
            containsRootDirective = patternRoot.match(line)
            if containsRootDirective:
                printLine = True
            if printLine:
                if not printedHeading:
                    g.es(vnode.headString())
                    printedHeading = True
                g.es('  ' + line)
        vnode = vnode.threadNext()

@doc

Next, we simply create Leo menu items for the above functions,
assuming Leo is loading this code as a module (i.e. the Python
source has been placed in the Leo plugins directory.)  As a module,
the phrase "if 0:" must be changed to "if 1:" to activate the
module.

But while the "if 0:" is left, this code can be used as a script
from the Leo scripts menu (assuming a copy of the code has been
placed in the Leo scripts directory), implementing the WriteAll
function above. This is useful in testing.

@code
def CreateAscMenu(tag,keywords):

    """Create the Outline to AsciiDoc menu item in the Export menu."""


    if  (tag=="open2" or
        (tag=="start2") or
        (tag=="command2" and keywords.get("label")=="new")):

        c = g.top()
        exportMenu = c.frame.menu.getMenu('export')
        newEntries = (
            ("-", None, None),
            ("Export all to &amp;AsciiDoc","Alt+Shift+A",WriteAll),
            ("Export current tree to AsciiDoc","Alt+Shift+T",WriteTreeOfCurrentNode),
            ("Log all root and ascfile to log pane","Alt+Shift+L",WriteAllRoots)
            )

        c.frame.menu.createMenuEntries(exportMenu, newEntries)
    

if 1:
    leoPlugins.registerHandler(("start2","open2","command2"), CreateAscMenu)

    __version__ = ".4" # Set version for the plugin handler.
    g.plugin_signon(__name__)
else:
    WriteTreeOfCurrentNode()

@doc

</t>
<t tx="ekr.20040331071919.10">@doc
@ascskip # Time-stamp: "Tue, Nov 25 11:25 CST 2003  michael@redpriest _Declarations_and_Utilities__140958380.py"

Next, we define new directives to control the way we export the Leo
text, as seen in this extract from the main code.  Directives start
with an "@" character as the first character in the line.

@code
&lt;&lt;New Leo2AsciiDoc directives&gt;&gt;=
patternAscDirectiveConfig = re.compile(r'^@ascconfig\W+(\w+)\s+(\S+)')
patternAscDirectiveFile = re.compile(r'^@ascfile *"*([\w\\/\.]*)"*')
patternAscDirectiveExit = re.compile(r"^@ascexit")
patternAscDirectiveIgnore = re.compile(r"^@ascignore")
patternAscDirectiveSkip = re.compile(r"^@ascskip")
patternAscDirectiveSkipToggle = re.compile(r"^@ascskip\s*(\w+)+.*")
@doc

Next, a class to simulate constants, and make it easy to use
them. We create a class whose variables can be assigned, but not
reassigned inadvertently. As well, the "Next" function gives us an
easy way to acquire a variable of unique value when we don't care
what that value actually is, just that it is unique.

@code
&lt;&lt;Simulate Python constants&gt;&gt;=
class   _AssignUniqueConstantValue:
    """ Provide unique value to be used as a constant """
    def __init__(self):
        self.UniqueInternalValue = 0
        self.Assign_at_start()

    class ConstError(TypeError): pass
    def __setattr__(self,name,value):
        if self.__dict__.has_key(name):
            if name != "UniqueInternalValue":
                raise self.ConstError, "Can't rebind const(%s)"%name
        self.__dict__[name]=value

    def Assign_at_start(self):
        self.END_PROGRAM = self.Next()   # signal abort
        self.LINE_WAS_NONE = self.Next() # describe last line printed
        self.LINE_WAS_CODE = self.Next()
        self.LINE_WAS_DOC  = self.Next()
        self.LINE_WAS_HEAD = self.Next()
        self.LINE_PENDING_NONE  = self.Next() # describe next line to be printed
        self.LINE_PENDING_CODE  = self.Next()
        self.LINE_PENDING_DOC   = self.Next()

    def Next(self):
        self.UniqueInternalValue += 1
        return(self.UniqueInternalValue)
@doc
@ascexit
@code
&lt;&lt;The Code -- Declarations and Utilities&gt;&gt;</t>
<t tx="ekr.20040331071919.11">@
@ascskip # Time-stamp: "Fri, Dec 19 10:42 CST 2003  michael@redpriest _The_Code_Declarations_and_Utilities__140568852.py"

Here we begin the Python program, importing the modules we need, and
signing on as the Leo2AsciiDoc module in the Leo log window.
@c

import leoGlobals as g
import leoPlugins

import re
import os

g.es("---mod_leo2asc 0.4-------")

@
Next, a class to hold our configuration data. Users can change the
Leo2AsciiDoc configuration by including an "@ascconfig" directive in the
body text of a Leo outline, either in the root node or in the same
node as an "@ascfile" directive.  User directives in the root node
override the Leo2AsciiDoc defaults. Further, directives in an ascfile
node not only override the Leo2AsciiDoc defaults, but also any user
directives in the root node.
@c

&lt;&lt;Simulate Python constants&gt;&gt;

class _ConfigOptions:
    """Hold current configuration options."""
    def __init__(self):
        self.current = {}
        self.default = {}
        self.default["maxCodeLineLength"] = '76'
        self.default["delimiterForCodeStart"] = '~-~--- code starts --------'
        self.default["delimiterForCodeEnd"]   = '~-~--- code ends ----------'
        self.default["delimiterForCodeSectionDefinition"] = '*example*'
        self.default["headingUnderlines"] = '=-~^+'
        self.default["asciiDocSectionLevels"] = '5'
        self.default["PrintHeadings"] = "on"

    def __GetNodeOptions(self, vnode):
        bodyString = vnode.bodyString()
        lines = bodyString.splitlines()
        for line in lines:
            containsAscConfigDirective = patternAscDirectiveConfig.match(line)
            if containsAscConfigDirective:
                # Leo uses unicode, convert to plain ascii
                name = str(containsAscConfigDirective.group(1))
                value = str(containsAscConfigDirective.group(2))
                if self.current.has_key(name):
                    self.current[name] = value
                else:
                    g.es(vnode.headString())
                    g.es("  No such config option: %s" % name)

    def GetCurrentOptions(self, vnode):
        self.current.clear()
        self.current = self.default.copy()
        c = g.top()
        v = c.rootVnode()
        self.__GetNodeOptions(v)             # root node
        self.__GetNodeOptions(vnode)         # current node

# ----- assign constants ---------------------------------------------------
CV = _AssignUniqueConstantValue()
CV.NODE_IGNORE = CV.Next()              # demo of adding in code
Conf = _ConfigOptions()

# ----- globals ------------------------------------------------------------
#   compile the patterns we'll be searching for frequently
patternSectionName = re.compile("\&lt;\&lt; *(.+?) *\&gt;\&gt;")
patternSectionDefinition = re.compile("(\&lt;\&lt; *)(.+?)( *\&gt;\&gt;)(=)")
patternDirective = re.compile(r"^@")
patternCodeDirective = re.compile(r"^(@c *$)|(@code)")
patternDocDirective = re.compile(r"^(@ |@doc)(.*)")
patternRootDirective = re.compile(r"^@root\s+(.+)")
patternAscDirective = re.compile(r"^@asc")
&lt;&lt;New Leo2AsciiDoc directives&gt;&gt;
@doc

AsciiDoc recognizes titles and section headings by the underlining (a
line of characters on the next line after the text) with a line
of flag characters.  This function calculates the section level
(considering the ascfile node to be the top or "book" level) and
creates the appropriate string of flag characters.

@code
def SectionUnderline(h,level,v):
    'Return a section underline string.'
    asciiDocSectionLevels = int(Conf.current["asciiDocSectionLevels"])
    if level &lt; 0:
        g.es("Section level is less than 1:\n  %s" % v.headString())
        level = 1
    elif level &gt; asciiDocSectionLevels - 1:
        g.es("Section level is more than maximum Section Levels: %d\n  %s" \
           % (asciiDocSectionLevels, v.headString()))
        level = asciiDocSectionLevels - 1
    str = Conf.current["headingUnderlines"][level]  #'
    return str*max(len(h),1)
@doc

GetAscFilename is a frequently used function that checks a node for
the presence of an "@ascfile" directive, which specifies the name
and location of the Leo2AsciiDoc output file.

Leo2AsciiDoc will not export text without finding a file name. If no path
is given, the file will be created in the same directory as the Leo
outline.

@code
def GetAscFilename(vnode):
    'Checks a node for a filename directive.'
    # f is the Leo outline
    c = g.top()
    ascFileName = None
    bodyString = vnode.bodyString()
    lines = bodyString.splitlines()
    for line in lines:
        containsAscFileDirective = patternAscDirectiveFile.match(line)
        if containsAscFileDirective:
            ascFileName = containsAscFileDirective.group(1)
            if (ascFileName != None):
                base = os.path.split(c.mFileName)[0]  # linux or windows
                if (((base[0]=="/") and (ascFileName[0] != "/")) or 
                   ((base[1]==":") and (ascFileName[1] != ":"))): 
                    # no full pathname specified
                    ascFileName = os.path.join(base, ascFileName)
                Conf.GetCurrentOptions(vnode)
    return ascFileName
        
@doc

CodeChunk splits a line of text into chunks of a maximum length.
This is used in exporting source code sections of the Leo outline
for publication.

@code
def CodeChunk(text, width=72):
    """Split a line of text into a list of chunks not longer
    than width."""
    chunkList = []
    chunkStart = 0
    chunkEnd = 0
    lastSpacePosition = 0
    shortWidth = width - 4
    prefix = ''
    suffix = ' \\'
    textLen = len(text)
    if width &gt; textLen:
        chunkList.append(text)
    else:
        while chunkEnd &lt; textLen:
            if len(chunkList) &gt; 0:
                prefix = '  '
            chunkEnd = chunkStart + shortWidth
            if chunkEnd &gt; textLen:
                chunkList.append(prefix + text[chunkStart:])
                chunkEnd = textLen          # get out of jail
            else:
                lastSpacePosition = text.rfind(' ',chunkStart, chunkEnd +1)
                if lastSpacePosition != -1:  # success
                    chunkList.append(prefix + text[chunkStart:lastSpacePosition] + ' \\')
                    chunkStart = lastSpacePosition + 1
                else:
                    chunkEnd = chunkStart + shortWidth
                    chunkList.append(prefix + text[chunkStart:chunkEnd] + ' \\')
                    chunkStart = chunkEnd
    return chunkList</t>
<t tx="ekr.20040331071919.12">@doc
@ascskip # Time-stamp: "Thu, Dec  4 15:28 CST 2003  michael@redpriest _Write_the_outline_tree_as_AsciiDoc_file__141131100.py"

This function opens the output file and walks the tree of outline
nodes under the node that is passed as the first parameter.  At each
node, it calls our workhorse "WriteNode".


@code
def WriteTreeAsAsc(vnode, ascFileN):
    'Writes the tree under vnode to the file ascFile'
    def CleanUp():
        'Cleanup on exit'
        ascFile.close()

    writeNodeReturnValue = None
    startinglevel = vnode.level()
    try:
        ascFile = file(ascFileN,'w')
    except IOError:
        g.es("Could not open output file: %s" % ascFileN)
        return
    stopHere = vnode.nodeAfterTree()
    v = vnode
    while v != stopHere:
        writeNodeReturnValue = WriteNode(v, startinglevel, ascFile)
        if  writeNodeReturnValue == CV.END_PROGRAM:
            CleanUp()
            return
        elif  writeNodeReturnValue == CV.NODE_IGNORE:
            v = v.nodeAfterTree()       # ran into an @ascignore
        else:
            v = v.threadNext()

    CleanUp()
    g.es('Wrote: '+`ascFileN`)





</t>
<t tx="ekr.20040331071919.13">@doc
@ascskip # Time-stamp: "Fri, Jan  9 13:58 CST 2004  michael@redpriest _Write_a_node__140596620.py"

This is the workhorse of the program, exporting the text in a node
to the output file in a way that the AsciiDoc program will
recognize.

The basic activity is:
    - output the node headline as a DocBook section heading (Book,
      Chapter, Section1, Section2, etc.)
    - scan each line of the body text for directives, and take the
      appropriate action.  Regular expressions do the heavy lifting.
    - mark the code sections and documentation sections, so that
      DocBook can print them in the correct styles.
    - ensure that code lines do not exceed a maximum length.



@code
def WriteNode(v,startinglevel, ascFile):

    'Writes the contents of the node v to the ascFile.'

    containsAscIignore = None          # initialize
    skippingDocLines = False
    startingCodeExtract = False
    inCodeExtract = False
    statusOfWriteOutputLine = None

    def WriteOutputLine(lineString):

        'Writes a line of text to the output file.'
        try:
            ascFile.write("%s\n" % lineString)
        except IOError:
            g.es("Could not write to output file: %s" % ascFile.name)
            statusOfWriteOutputLine = CV.END_PROGRAM


    # ----- get the headline text ------------------------------------------
    h = v.headString()
    markedupAsSection = patternSectionName.match(h)
    if markedupAsSection:
        h = markedupAsSection.group(1) # dump the angle brackets

    # ----- put the body text into a list of lines -------------------------
    bodyString = v.bodyString()
    lines = bodyString.splitlines()

    lastLinePrintedType = CV.LINE_WAS_NONE
    # ----- by default, nodes start with a code section --------------------
    pendinglineType = CV.LINE_PENDING_CODE

    for line in lines:
        containsRootDirective = None

@doc

If this line starts a code extract, called a Section Definition
here, then extract the text to use as the title and set the
"startingCodeExtract" flag to guide further processing.

@code
        containsSectionDefinition = patternSectionDefinition.match(line)
        if containsSectionDefinition:
            # dump the angle brackets, etc.
#             line = containsSectionDefinition.group(2)  + '\n' + \
#                    (SectionUnderline(containsSectionDefinition.group(2),2,v))
            line = '.' + containsSectionDefinition.group(2)
            pendinglineType = CV.LINE_PENDING_CODE
            startingCodeExtract = True
@doc

Check if this line starts a @doc or @code section.

@code
        containsCodeDirective = patternCodeDirective.match(line)
        if containsCodeDirective:
            pendinglineType = CV.LINE_PENDING_CODE
            skippingDocLines = False
            continue                    # don't print this line

        containsDocDirective = patternDocDirective.match(line)
        if containsDocDirective:
            pendinglineType = CV.LINE_PENDING_DOC
            if containsDocDirective.group(2):
                # it is legal to have text on the same line
                # as a doc directive.
                line = containsDocDirective.group(2)
            else:
                continue
@doc

Check line for a Leo2AsciiDoc directive, and if so, act on it.

@code
        containsAscDirective = patternAscDirective.match(line)
        if containsAscDirective:
            containsAscIignore = patternAscDirectiveIgnore.match(line)
            if containsAscIignore:
                break

            containsAscExit = patternAscDirectiveExit.match(line)
            if containsAscExit:
                break

            containsAscSkip = patternAscDirectiveSkip.match(line)
            if containsAscSkip:
                containsAscSkipDirectiveToggle = patternAscDirectiveSkipToggle.match(line)
                if containsAscSkipDirectiveToggle:
                    if containsAscSkipDirectiveToggle.group(1).lower() == "on":
                        skippingDocLines = True
                    elif containsAscSkipDirectiveToggle.group(1).lower() == "off":
                        skippingDocLines = False
                continue

        containsOtherDirective = patternDirective.match(line)
        if containsOtherDirective:
            containsRootDirective = patternRootDirective.match(line)
            if containsRootDirective:
                line = "*note*\nThe code sections that follow, when extracted from a " + \
                       "Leo outline, will be located in: %s\n*note*" % \
                       containsRootDirective.group(1)
            else:
                continue

        # ----- we have something to print, so print heading ---------------
        if lastLinePrintedType == CV.LINE_WAS_NONE:
            if (len(h) &gt; 0) and (Conf.current["PrintHeadings"] == "on"):
                WriteOutputLine("\n\n%s" % h)
                WriteOutputLine(SectionUnderline(h,v.level()-startinglevel,v))
                lastLinePrintedType = CV.LINE_WAS_HEAD
@doc

Here we manage the transitions between code and doc sections.

@code
        if pendinglineType == CV.LINE_PENDING_DOC:
            if lastLinePrintedType != CV.LINE_WAS_DOC and \
               lastLinePrintedType != CV.LINE_WAS_HEAD:
                WriteOutputLine("%s" % Conf.current["delimiterForCodeEnd"])
                if inCodeExtract:
                    WriteOutputLine("\n%s" % Conf.current["delimiterForCodeSectionDefinition"])
                    inCodeExtract = False
                lastLinePrintedType = CV.LINE_WAS_DOC
            if skippingDocLines:
                if not containsRootDirective: # always document a root directive
                    continue

        if pendinglineType == CV.LINE_PENDING_CODE:
            if lastLinePrintedType != CV.LINE_WAS_CODE:
                if startingCodeExtract:
                    WriteOutputLine("\n%s" % line)
                    WriteOutputLine("%s" % Conf.current["delimiterForCodeSectionDefinition"])
                    inCodeExtract = True
                    line = ''
                WriteOutputLine("%s" % Conf.current["delimiterForCodeStart"])
                lastLinePrintedType = CV.LINE_WAS_CODE
                if startingCodeExtract:
                    startingCodeExtract = False
                    continue
@doc

Check for maximum code line length.  Finally, output the text to the
export file.

@code
            maxCodeLineLength = int(Conf.current["maxCodeLineLength"])
            if len(line) &lt;= maxCodeLineLength:
                WriteOutputLine("%s" % line)
            elif len(line.rstrip()) &lt;= maxCodeLineLength:
                WriteOutputLine("%s" % line.rstrip())
            else:
                lineList = CodeChunk(line, maxCodeLineLength)
                for ln in lineList:
                    WriteOutputLine("%s" % ln)
            lastLinePrintedType = CV.LINE_WAS_CODE
        else:
            WriteOutputLine("%s" % line)

        if statusOfWriteOutputLine != None:
            return statusOfWriteOutputLine

@doc

Before we leave, make sure that any ending code section is marked as
ended.

@code
    if lastLinePrintedType == CV.LINE_WAS_CODE:
        WriteOutputLine("%s" % Conf.current["delimiterForCodeEnd"])
        if inCodeExtract:
            WriteOutputLine("\n%s" % Conf.current["delimiterForCodeSectionDefinition"])
            inCodeExtract = False

    if containsAscIignore != None:
        return CV.NODE_IGNORE                        # flag ignore tree to caller

@doc

</t>
<t tx="ekr.20040331071919.14">@doc
@ascskip # Time-stamp: "Tue, Jan 13 11:09 CST 2004  michael@redpriest Other_programs_140636444.txt"

The appendices are about other programs that are used with Leo.
I'm including them because they are examples of how my setup works,
for those who may be interested in setting up something similar.

    - AsciiDoc is the program that processes the output from Leo2AsciiDoc
      into a DocBook-ready XML file.
    - Setting up DocBook is a topic that is far too large for this
      little manual, but the DocBook section which follows contains
      documentation of exactly how my working system is configured.
    - The XEmacs text editor is the one I prefer, but it is not
      necessary for the use of Leo2AsciiDoc.  Others who also use XEmacs
      might find the documentation of my Leo integration and
      multi-mode support to be useful.
@code</t>
<t tx="ekr.20040331071919.15">@language plain
@ascskip Time-stamp: "Thu, Oct 30 10:58 CST 2003  michael@redpriest Appendix_AsciiDoc__140954356.txt"
@doc
anchor:AsciiDoc[AsciiDoc]

The AsciiDoc program is written by Stuart Rackham and has its own
web site at http://www.methods.co.nz/asciidoc/[], with full
documentation.

AsciiDoc is a small program, written in Python, that reads text
which is in the AsciiDoc text format. Generally speaking, ordinary
text (such as you would write in an email message) is already in the
AsciiDoc format.  The AsciiDoc program produces (among other
choices) output in the DocBook XML format.

Text exported from a Leo outline by Leo2AsciiDoc is ready to be processed
by AsciiDoc, once AsciiDoc has been configured to recognize it.

Leo2AsciiDoc comes with an AsciiDoc configuration file that will enable
AsciiDoc to process all Leo2AsciiDoc features.  The following section
describes that configuration file.

Of course, you don't need to read or understand the configuration
file to use it.  Simply put it (leo-docbook.conf) in the same
directory as AsciiDoc's "docbook.conf" file.  When you invoke
AsciiDoc (see the xref:Makefile[] section in the DocBook appendix for
examples), give the "leo-docbook.conf" file as the configuration
parameter ("-f leo-docbook.conf".)

@ascskip on
&lt;&lt; Appendix: AsciiDoc &gt;&gt;
@code
</t>
<t tx="ekr.20040331071919.16">@language python
@tabwidth -4

@doc
@ascskip # Time-stamp: "Tue, Jan 13 11:58 CST 2004  michael@redpriest _Configuration_file__140640380.py"

AsciiDoc is customized through the use of configuration files, which
cascade, so that you can include other configuration files and
then proceed to add your changes.

The main elements of the configuration file below:

    - adds chapter and web site document types
    - switches code listings to use the DocBook "programlisting"
      element 

    *note*

    If you choose to export this configuration file from the Leo
    outline, you will have to remove escape charactersfrom some
    lines after you have exported it.

    Specifically, some lines begin with the character "\".  That
    character should be removed.

    *note*

@ascskip on
@root "other/asciidoc/leo-docbook.conf"
&lt;&lt; Configuration File &gt;&gt;
@code
# Start with the standard docbook back end configuration.
# ensure the next line is uncommented before installing
\include::docbook.conf[]

@doc

I want tabs interpreted as 4 spaces.

@code
[options]
tabsize=4
@doc

Interpret an indented paragraph as a simple paragraph.

@code
[indentedparagraph]
&lt;simpara&gt;|&lt;/simpara&gt;


@doc

For our code listings we invent a new markup that will use the
DocBook programlisting element.

@code
[blockdef-leocode]
delimiter=^\~\-~--- code(.*?)$
section=programlistingblock
presubs=specialcharacters, replacements

[programlistingblock]
&lt;programlisting&gt;
|
&lt;/programlisting&gt;

@doc

We add new markup to signify the DocBook "note" element.  This
predates AsciiDoc 5.0, and is still useful.

@code
[blockdef-note]
delimiter=^ *\*note\*$
section=noteblock
presubs=specialcharacters,quotes,specialwords,replacements,macros,glossary

# Block macro
[noteblock]
&lt;note&gt;
|
&lt;/note&gt;

[blockdef-example]
delimiter=^ *\*example\*$
options=section
section=exampleblock
presubs=replacements

# Block macro
[exampleblock]
&lt;example&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/example&gt;


@doc

The following replacements ensure basic Python code indexing.

@code
[replacements]
#----- indexing markup -----------------------------------------------------
# using regular expressions because I don't want to introduce a filter, which
# would slow things down.
#
# index python classes and defs
^(def +)(.+?)(\(.+:)=\1\2\3&lt;indexterm&gt;&lt;primary&gt;Python code, functions&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 
^(class +)(.+?)(:)=\1\2\3&lt;indexterm&gt;&lt;primary&gt;Python code, classes&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 
^( +def +)(.+?)(\(.+:)=\1\2\3&lt;indexterm&gt;&lt;primary&gt;Python code, methods and nested functions&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 

# index code extracts
(\&amp;lt\;\&amp;lt\;)(.+?)(\&amp;gt\;\&amp;gt\;\=)=\2&lt;indexterm&gt;&lt;primary&gt;Python code, extracts explained&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt;
(\&amp;lt\;\&amp;lt\;)(.+?)(\&amp;gt\;\&amp;gt\;)(\s*$)=\1\2\3\4&lt;indexterm&gt;&lt;primary&gt;Python code, extracts used&lt;/primary&gt;&lt;secondary&gt;\2&lt;/secondary&gt;&lt;/indexterm&gt; 

@doc

Change the standard AsciiDoc article, book and manpage definition to
use the DocBook 4.2 DTD.  Add an empty index element to the end of
the book definition so that DocBook will automatically generate an
index.

@code
#---------------------------------------------------------------------------
#----- article -------------------------------------------------------------
#---------------------------------------------------------------------------

# changing to our version of the docbook dtd
\ifdef::doctype-article[]

[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE article
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;

&lt;article lang="en"&gt;
&lt;articleinfo&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
    &lt;date&gt;{date}&lt;/date&gt;
    &lt;author&gt;
        &lt;firstname&gt;{firstname}&lt;/firstname&gt;
        &lt;othername&gt;{middlename}&lt;/othername&gt;
        &lt;surname&gt;{lastname}&lt;/surname&gt;
        &lt;affiliation&gt;
            &lt;address&gt;
                &lt;email&gt;{email}&lt;/email&gt;
            &lt;/address&gt;
        &lt;/affiliation&gt;
    &lt;/author&gt;
    &lt;authorinitials&gt;{authorinitials}&lt;/authorinitials&gt;
    &lt;revhistory&gt;&lt;revision&gt;&lt;revnumber&gt;{revision}&lt;/revnumber&gt;&lt;date&gt;{date}&lt;/date&gt;&lt;/revision&gt;&lt;/revhistory&gt;
    &lt;corpname&gt;{companyname}&lt;/corpname&gt;
&lt;/articleinfo&gt;

\endif::doctype-article[]


#---------------------------------------------------------------------------
#----- book ----------------------------------------------------------------
#---------------------------------------------------------------------------
# change to our version of docbook dtd

\ifdef::doctype-book[]

[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE book
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;

&lt;book lang="en"&gt;
&lt;bookinfo&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
    &lt;date&gt;{date}&lt;/date&gt;
    &lt;author&gt;
        &lt;firstname&gt;{firstname}&lt;/firstname&gt;
        &lt;othername&gt;{middlename}&lt;/othername&gt;
        &lt;surname&gt;{lastname}&lt;/surname&gt;
        &lt;affiliation&gt;
            &lt;address&gt;
                &lt;email&gt;{email}&lt;/email&gt;
            &lt;/address&gt;
        &lt;/affiliation&gt;
    &lt;/author&gt;
    &lt;authorinitials&gt;{authorinitials}&lt;/authorinitials&gt;
    &lt;revhistory&gt;&lt;revision&gt;&lt;revnumber&gt;{revision}&lt;/revnumber&gt;&lt;date&gt;{date}&lt;/date&gt;&lt;/revision&gt;&lt;/revhistory&gt;
    &lt;corpname&gt;{companyname}&lt;/corpname&gt;
&lt;/bookinfo&gt;


[footer]
&lt;index/&gt;
&lt;/book&gt;

\endif::doctype-book[]

#---------------------------------------------------------------------------
#----- manpage -------------------------------------------------------------
#---------------------------------------------------------------------------
\ifdef::doctype-manpage[]

[header]
&lt;!DOCTYPE refentry
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;
&lt;refentry&gt;
# The refentryinfo element is legal and should not normally be printed.
# Unfortunately some docbook processors do print it.
&lt;refentryinfo&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
    &lt;date&gt;{date}&lt;/date&gt;
    &lt;author&gt;
        &lt;firstname&gt;{firstname}&lt;/firstname&gt;
        &lt;othername&gt;{middlename}&lt;/othername&gt;
        &lt;surname&gt;{lastname}&lt;/surname&gt;
        &lt;affiliation&gt;
            &lt;address&gt;
                &lt;email&gt;{email}&lt;/email&gt;
            &lt;/address&gt;
        &lt;/affiliation&gt;
    &lt;/author&gt;
    &lt;authorinitials&gt;{authorinitials}&lt;/authorinitials&gt;
    &lt;revhistory&gt;&lt;revision&gt;&lt;revnumber&gt;{revision}&lt;/revnumber&gt;&lt;date&gt;{date}&lt;/date&gt;&lt;/revision&gt;&lt;/revhistory&gt;
    &lt;corpname&gt;{companyname}&lt;/corpname&gt;
&lt;/refentryinfo&gt;
&lt;refmeta&gt;
&lt;refentrytitle&gt;{mantitle}&lt;/refentrytitle&gt;
&lt;manvolnum&gt;{manvolnum}&lt;/manvolnum&gt;
&lt;/refmeta&gt;
&lt;refnamediv&gt;
    &lt;refname&gt;{manname}&lt;/refname&gt;
    &lt;refpurpose&gt;{manpurpose}&lt;/refpurpose&gt;
&lt;/refnamediv&gt;

\endif::doctype-manpage[]



@doc

Add chapter and website document types.

@code
#---------------------------------------------------------------------------
#----- new: chapter --------------------------------------------------------
#---------------------------------------------------------------------------
\ifdef::doctype-chapter[]

[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE chapter
        PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
        "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"&gt;
&lt;chapter&gt;
&lt;title&gt;{doctitle}&lt;/title&gt;

[footer]
&lt;/chapter&gt;


# Section macros
# Using &lt;abstract&gt; semantics restricts preface to &lt;simpara&gt; elements.
[preface]
|

[sect1]
&lt;sect1&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/sect1&gt;

[sect2]
&lt;sect2&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/sect2&gt;

[sect3]
&lt;sect3&gt;
&lt;title&gt;{title}&lt;/title&gt;
|
&lt;/sect3&gt;

[options]
outfilesuffix=.xml

\endif::doctype-chapter[]

@doc

Website requires a unique id for each page.  I've changed AsciiDoc
to provide the HTML filename as the id, and we use it here. We'll
use the date the XML file was created as the update date.

@code
#---------------------------------------------------------------------------
#----- new: website --------------------------------------------------------
#---------------------------------------------------------------------------
\ifdef::doctype-website[]
[header]
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE webpage SYSTEM "website-full.dtd"&gt;
&lt;webpage id="{infilebase}"&gt;
  &lt;head&gt;
    &lt;title&gt;{doctitle}&lt;/title&gt;
  &lt;/head&gt;
  &lt;config param="rcsdate" value="Updated: {localdate}  {localtime}"/&gt;
[footer]
&lt;/webpage&gt;

[options]
outfilesuffix=.xml

\endif::doctype-website[]

</t>
<t tx="ekr.20040331071919.17">@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 14:11 CST 2004  michael@redpriest _Patches__140641532.txt"

I've patched the source code for AsciiDoc (asciidoc.py) with a few
small changes to allow AsciiDoc to process chapters and DocBook
web site documents as well as the DocBook book format.  Since I use
Linux, I also changed the default line-ending code to the Linux
default.

For the exact changes I made, the following output at the end of
this section was created by GNU diff (version 2.8.4) with the
command

---
LC_ALL=C TZ=UTC0 diff -Naur 5.0.2-original 5.0.2-mrc-patched \
    &gt;mrc-asciidoc-5.0.2-patch-diff
---

I include this mainly so that you can see the exact changes I made.
However, you may want to patch a copy of the original in exactly the
same way. 

To patch a copy of the original asciidoc.py (version 5.0.2), one
would use the patch command as follows (when in the same directory
as the copy of asciidoc.py and mrc-asciidoc-5.0.2-patch-diff)

---
patch -Np1 &lt;mrc2-asciidoc-5.0.2-patch-diff
---

@ascskip on
@root "other/asciidoc/mrc-asciidoc-5.0.2-patch-diff"
&lt;&lt; Patches &gt;&gt;
@code
diff -Naur 5.0.2-original/asciidoc.py 5.0.2-mrc-patched/asciidoc.py
--- 5.0.2-original/asciidoc.py	2003-12-16 00:16:28.000000000 +0000
+++ 5.0.2-mrc-patched/asciidoc.py	2004-01-08 17:45:37.000000000 +0000
@@ -838,12 +838,15 @@
         '''Set predefined glossary entries that follow configuration file
         loading.'''
         self.glossary['infile'] = reader.fname
+        # mwd Monday, June 23, 2003 for use in website
+        self.glossary['infilebase'] = os.path.splitext(os.path.split(reader.fname)[1]) [0]
         self.glossary['outfile'] = reader.fname
         s = os.path.splitext(writer.fname)[1][1:]   # Output file extension.
         self.glossary['filetype'] = s
         self.glossary['filetype-'+s] = ''
     def translate(self):
-        assert self.doctype in ('article','manpage','book'), \
+        # mwd 2003-Jun-23 assert self.doctype in ('article','manpage','book'), \
+        assert self.doctype in ('article','chapter','website','manpage', 'book'), \
             'illegal document type'
         assert self.level == 0
         reader.tabsize = config.tabsize
@@ -864,7 +867,8 @@
             if not config.suppress_headers:
                 hdr = config.subs_section('header',{})
                 writer.write(hdr)
-            if self.doctype in ('article','book'):
+            # mwd 2003-Jun-23 if self.doctype in ('article','book'):
+            if self.doctype in ('article','book','chapter','website'):
                 # Translate 'preamble' (untitled elements between header
                 # and first section title).
                 if Lex.next() is not Title:
@@ -952,7 +956,7 @@
                 # Parse revision line.
                 s = reader.read()
                 s = subs_glossary([s])[0]
-                # Match RCS/CVS $Id$ marker format.
+                # Match RCS/CVS $Id$ marker format.
                 mo = re.match(r'^\$Id: \S+ (?P&lt;revision&gt;\S+)' \
                     ' (?P&lt;date&gt;\S+) \S+ \S+ \S+ \$$',s)
                 if not mo:
@@ -2573,7 +2577,8 @@
 
 class Writer:
     '''Writes lines to output file.'''
-    EOL = '\r\n'    # End of line terminator.
+    # mwd 2003-Jun-23 EOL = '\r\n'    # End of line terminator.
+    EOL = '\n'    # End of line terminator.
     f = None        # Output file object.
     fname= None     # Output file name.
     lines_out = 0   # Number of lines written.
@@ -3068,7 +3073,8 @@
     The AsciiDoc document is read from file object src the translated
     DocBook file written to file object dst.'''
     try:
-        if doctype not in ('article','manpage','book'):
+        # mwd-2004-Jan-05 if doctype not in ('article','manpage','book'):
+        if doctype not in ('article','chapter','website','manpage', 'book'):
             raise EAsciiDoc,'illegal document type'
         if backend == 'linuxdoc' and doctype != 'article':
             raise EAsciiDoc,'%s %s documents are not supported' \
</t>
<t tx="ekr.20040331071919.18">@language plain
@ascskip Time-stamp: "Fri, Dec 19 11:48 CST 2003  michael@redpriest Appendix_DocBook_140578660.txt"
@doc

anchor:DocBook[DocBook]
DocBook is a project that provides:

    - a specification for the text markup (DTD) of DocBook XML
      documents, and
    - a set of XSLT stylesheets that can be used by an XSLT engine
      to transform those XML documents to HTML, PDF, etc.
      
If you create your text documents using the rules in the DocBook
DTD, you can use the DocBook XSLT stylesheets to produce various
output formats, such as HTML and PDF.

The DocBook project is designed for the production of computer
documentation, but is actually used for a wide variety of documents.

Some web resources:

    - the official home page for DocBook: The Definitive Guide:
        http://docbook.org/[]
    - DocBook Basics:
        http://www.dpawson.co.uk/docbook/reference.html[]
    - DocBook Open Repository:
        http://sourceforge.net/projects/docbook/[]
    - DocBook XSL: The Complete Guide:
        http://www.sagehill.net/docbookxsl/index.html[]

I include this section as documentation of one setup that works --
it translates Leo2AsciiDoc output to HTML and PDF.

This is not a guide to the installation, setup and operation of
DocBook, just an example of a working system.

@ascskip on
&lt;&lt; Appendix: DocBook &gt;&gt;
@code
</t>
<t tx="ekr.20040331071919.19">@doc
@ascskip # Time-stamp: "Thu, Jan  8 13:57 CST 2004  michael@redpriest _Tool_Chain__140810780.txt"

Documents go through a number of stages in their creation.  Each
stage may involve one or more tools or programs, which form a tool
chain: each performing some processing and handing off to the next.

As a simple example, for this document:


    - text creation was handled by XEmacs, a text
      editor (which functioned as a Leo plugin.)
      indexterm:[XEmacs]
      indexterm:[GNU Make]
      indexterm:[AsciiDoc]
      indexterm:[xsltproc]
      indexterm:[FOP]
    - text storage and organization was handled by Leo, an outlining
      editor.
    - text was exported from Leo to a plain-text file, using the
      Leo2AsciiDoc program.
    - from there, all transformations are automated by the
      GNU Make program.
    - the DocBook XML document was created by the
      AsciiDoc program, which transformed the
      plain-text file to XML.
    - The HTML pages were created by the
      xsltproc program. xsltproc read the XML
      document, and the DocBook XSLT stylesheets, and then created
      each HTML page.
    - To make the PDF file, the xsltproc program used the same
      process as for the HTML pages, except that it created a
      Formatting Objects (FO) file instead.  Then the
      FOP program processed the FO file, producing
      the final PDF file.  This process was also automated.

All I did was type in text for each section, arranging it much as I
usually do for email.  The rest was handled automatically by
clicking on a Leo menu, or entering a short command at the console.
For example: "make all".

There are many, many choices of tools to put in your DocBook tool
chain.  You can even purchase complete packages, from text editing
to PDF generation.

@code</t>
<t tx="ekr.20040331071919.20">@language plain
@tabwidth 4
@doc
@ascskip # Time-stamp: "Thu, Jan 15 15:39 CST 2004  michael@redpriest _Make_File__140651828.txt"

anchor:Makefile[Makefile]
In my case, I use a standard unix-style "make" setup for processing
the text exported from a Leo outline.  It simply automates the
commands which I would otherwise have to type at the command line.

After Leo2AsciiDoc exports the text from the Leo outline to a disk file,
the Make program takes over.  It reads rules in a file named
"Makefile" and calls the necessary programs to make the
requested output.

This Makefile takes over where Leo2AsciiDoc leaves off.  It directs the
AsciiDoc conversion of the Leo2AsciiDoc text file to XML, and then the
DocBook conversion of the XML file to HTML pages or a PDF document.

indexterm:[GNU Make]
I use GNU Make.  For example, assuming I am in xterm and located in
the same directory as the Makefile, I just enter the command

---
make pdf-dev
---
and the make program guides the creation of the PDF version of The
Developers Guide, using the instructions in this Makefile.  The PDF
is available within seconds.

The Makefile instructions, in brief:

    - the AsciiDoc program is called to make an XML file.
    - the xsltproc program is called to process the XML file to
      either HTML or a Formatting Objects file for further
      translation to PDF
        * various XSLT style sheets (html.xsl, man.xsl, etc.) are
          used by xsltproc to guide the transformation of the XML
          file.  Typically, they call the DocBook stylesheets for
          the heavy lifting, and set a few simple options.
    - the FOP program is used to process the intermediate fo file to
      the final PDF file.

This is by no means a model Makefile.  It is included because it
works for me in my office, and may thus be useful as an example for
other people who want to set up Make for this purpose.

@ascskip xemacs-makefile-mode-on
@ascskip on
@root "doc/Makefile"
&lt;&lt; Make File &gt;&gt;
@code
#----- global variables -----------------------------------------
DEVGUIDE=mod_asc_dev
USERGUIDE=mod_asc_user
CSS=dbstyle.css

MAN=${DOC}.1
STYLESHEET_MAN=man.xsl
# default docbook, located by /etc/xml/catalog
STYLESHEET_MAN_HTML=docbook.xsl
MAN_OUTPUT_DIR=man

STYLESHEET_HTML=html.xsl
HTML_DEV_OUTPUT_DIR=html-dev
HTML_USER_OUTPUT_DIR=html-user
STYLESHEET_CHUNK=chunkit.xsl
CHUNK_DEV_OUTPUT_DIR=chunk-dev
CHUNK_USER_OUTPUT_DIR=chunk-user

STYLESHEET_FO_FOP=fo-fop.xsl
PDF_DEV_OUTPUT_DIR=pdf-dev
PDF_USER_OUTPUT_DIR=pdf-user

ASCIIDOC_COMMAND=python asciidoc/asciidoc.py -v -b docbook -d book
ASCIIDOC_CONFIG=asciidoc/leo-docbook.conf

#   $@ target file name
#   $&lt; name of the first prerequisite
#   $* stem that rule matched

#----- pattern rules -------------------------------------------------------
%.xml	:	%.asc
#	asciidoc -b docbook -d book -f ${ASCIIDOC_CONFIG} -o $@ $&lt;
    ${ASCIIDOC_COMMAND}  -f ${ASCIIDOC_CONFIG} -o $@ $&lt;
    xsltproc --output $*.final.xml customize.xsl $@


%.html	:	%.xml css
    xsltproc --xinclude --output ${OUTPUT} ${STYLESHEET}  $*.final.xml
    touch $*.xml

%.pdf	:	%.xml
    xsltproc --xinclude  --output ${OUTPUT}/$*.fo $(STYLESHEET) $*.final.xml
    fop -fo  ${OUTPUT}/$*.fo  -pdf ${OUTPUT}/$*.pdf 
    -$(RM) ${OUTPUT}/$*.fo

#----- usage ---------------------------------------------------------------
usage	:
    @echo; echo "primary make modules: html-dev chunk-dev pdf-dev"
    @echo       "                      html-user chunk-user pdf-user"
    @echo



#---------------------------------------------------------------------------
#----- modules -------------------------------------------------------------
#---------------------------------------------------------------------------

# docbook
#---------------------------------------------------------------------------

all	:	css pdf-dev html-dev sub-chunk-dev html-user sub-chunk-user pdf-user

#----- DocBook html stylesheet ---------------------------------------------
css:
    cat base.css   &gt;  $(CSS)
    cat docstyle.css &gt;&gt; $(CSS)

#----- Developers Guide ----------------------------------------------------
#   #----- one page -----------------------------------------------------
html-dev	:	STYLESHEET=$(STYLESHEET_HTML)
html-dev	:	OUTPUT=${HTML_DEV_OUTPUT_DIR}/$*.html
html-dev	:	mkdirhtmldev ${DEVGUIDE}.html
    cp ${CSS} ${HTML_DEV_OUTPUT_DIR}

mkdirhtmldev	:	cleanhtmldev
    mkdir ${HTML_DEV_OUTPUT_DIR}

#   #----- individual pages ------------------------------------------------
chunk-dev	:	STYLESHEET=$(STYLESHEET_CHUNK)
chunk-dev	:	OUTPUT=$(CHUNK_DEV_OUTPUT_DIR)/
chunk-dev	:	mkdirchunkdev ${DEVGUIDE}.html
    cp chunk-dev-frame*.html ${CHUNK_DEV_OUTPUT_DIR}
    cp ${CSS} ${CHUNK_DEV_OUTPUT_DIR}
    cp frametoc.css ${CHUNK_DEV_OUTPUT_DIR}
    cp -r ../graphics ${CHUNK_DEV_OUTPUT_DIR}
# put in frame target line
    sed -f sed-dev-frame ${CHUNK_DEV_OUTPUT_DIR}/index.html &gt;${CHUNK_DEV_OUTPUT_DIR}/chunk-dev-frame-toc.html

mkdirchunkdev	:	cleanchunkdev
    mkdir ${CHUNK_DEV_OUTPUT_DIR}

sub-chunk-dev	:
    ${MAKE} chunk-dev

#----- Users Guide ---------------------------------------------------------
#   #----- one page -----------------------------------------------------
html-user	:	STYLESHEET=$(STYLESHEET_HTML)
html-user:	OUTPUT=${HTML_USER_OUTPUT_DIR}/$*.html
html-user:	mkdirhtmluser ${USERGUIDE}.html
    cp ${CSS} ${HTML_USER_OUTPUT_DIR}

mkdirhtmluser	:	cleanhtmluser
    mkdir ${HTML_USER_OUTPUT_DIR}

#   #----- individual pages ------------------------------------------------
chunk-user	:	STYLESHEET=$(STYLESHEET_CHUNK)
chunk-user	:	OUTPUT=$(CHUNK_USER_OUTPUT_DIR)/
chunk-user	:	cleanchunkuser ${USERGUIDE}.html
    cp chunk-user-frame*.html ${CHUNK_USER_OUTPUT_DIR}
    cp ${CSS} ${CHUNK_USER_OUTPUT_DIR}
    cp frametoc.css ${CHUNK_USER_OUTPUT_DIR}
    cp -r ../graphics ${CHUNK_USER_OUTPUT_DIR}
# put in frame target line
    sed -f sed-user-frame ${CHUNK_USER_OUTPUT_DIR}/index.html &gt;${CHUNK_USER_OUTPUT_DIR}/chunk-user-frame-toc.html

mkdirchunkuser	:	cleanchunkuser
    mkdir ${CHUNK_USER_OUTPUT_DIR}

sub-chunk-user	:
    ${MAKE} chunk-user

#   #----- pdf -------------------------------------------------------------
pdf-dev		:	STYLESHEET=$(STYLESHEET_FO_FOP)
pdf-dev		:	OUTPUT=$(PDF_DEV_OUTPUT_DIR)
pdf-dev		:	mkdirpdf ${DEVGUIDE}.pdf

pdf-user		:	STYLESHEET=$(STYLESHEET_FO_FOP)
pdf-user		:	OUTPUT=$(PDF_USER_OUTPUT_DIR)
pdf-user		:	mkdirpdf ${USERGUIDE}.pdf

#   mkdirpdf exists only to make an empty directory for the pdf working files
mkdirpdf	:
    -mkdir $(PDF_DEV_OUTPUT_DIR)
    -mkdir $(PDF_USER_OUTPUT_DIR)




#----- clean ---------------------------------------------------------------
clean	: cleanhtml cleanchunk cleanpdf cleanman cleanclutter 

cleanhtml	:	cleanhtmluser cleanhtmldev

cleanhtmluser	:
    -$(RM) -r $(HTML_USER_OUTPUT_DIR)

cleanhtmldev	:
    -$(RM) -r $(HTML_DEV_OUTPUT_DIR)

cleanchunk	:	cleanchunkuser cleanchunkdev

cleanchunkuser	:
    -$(RM) -r $(CHUNK_USER_OUTPUT_DIR)

cleanchunkdev	:
    -$(RM) -r $(CHUNK_DEV_OUTPUT_DIR)

cleanpdf	:
    -$(RM) -r $(PDF_OUTPUT_DIR)

cleanman	:
    -$(RM) -r $(MAN_OUTPUT_DIR)

cleanclutter: 
    -$(RM) -r *.xml

.PRECIOUS	:	%.xml
@doc
@ascskip xemacs-makefile-mode-off
@code
</t>
<t tx="ekr.20040331071919.21">@silent
@doc
@ascskip # Time-stamp: "Wed, Oct  1 15:33 CST 2003  michael@redpriest _Style_Sheets__140741140.txt"

When the Makefile calls the xsltproc program, it gives it the name
of an XSLT stylesheet to guide the production of the result.

Following are simple XSLT stylesheets that are used to:
    - set formatting options, and
    - call the main DocBook XSLT stylesheets.

The stylesheets cascade (each adding its options to the total), with
the original stylesheet including others as needed, and always
calling the main DocBook stylesheets at some point.

@code
</t>
<t tx="ekr.20040331071919.22">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:01 CST 2004  michael@redpriest _General__139758588.txt"

indexterm:[Stylesheets, common-links.xsl]
This is the entire common-links style sheet ("common-links.xsl"),
which sets basic Table of Contents and chapter cross-reference
preferences.

This stylesheet is called by both HTML and PDF stylesheets.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/common-links.xsl"
&lt;&lt; General &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 

&lt;!--===== 
    This changes a chapter cross-reference to include the chapter
    title text. 
--&gt;
&lt;xsl:param name="local.l10n.xml" select="document('')"/&gt; 
&lt;l:i18n xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0"&gt; 
  &lt;l:l10n language="en"&gt; 
    &lt;l:context name="xref"&gt; 
      &lt;l:template name="chapter" text="Chapter %n: &amp;#8220;%t&amp;#8221;"/&gt; 
    &lt;/l:context&gt;   
  &lt;/l:l10n&gt;
&lt;/l:i18n&gt;

&lt;xsl:param name="generate.toc"&gt;
book      toc,title,figure,table,example,equation
chapter   title
&lt;/xsl:param&gt;

&lt;!-- only 1 toc in the doc --&gt;
&lt;xsl:param name="generate.section.toc.level" select="1"/&gt;

&lt;!-- toc shows 3 levels of sections --&gt;
&lt;xsl:param name="toc.section.depth"&gt;3&lt;/xsl:param&gt;

&lt;xsl:param name="generate.index" select="1"&gt;&lt;/xsl:param&gt;

&lt;!--===== omit the title for notes, tips ================================--&gt;
&lt;xsl:param name="admon.textlabel" select="0"&gt;&lt;/xsl:param&gt;

&lt;/xsl:stylesheet&gt;
@doc
@ascskip xemacs-xsl-mode-off


</t>
<t tx="ekr.20040331071919.23">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 20 11:42 CST 2004  michael@redpriest _Customize__141637044.txt"


indexterm:[customize.xsl]
This is the entire customize style sheet ("customize.xsl", which is
used by the Makefile to make changes to the standard xml file
produced from the AsciiDoc output.  It results in a file suffixed
".final.xml" which is used by both the HTML and PDF stylesheets.

Currently, the stylesheet copies the xml file:

    - changing any chapter elements that have a title beginning
      with "Appendix: " to DocBook appendix elements.  This is from
      AsciiDoc 3.2 days, when AsciiDoc didn't know about appendix
      elements. I haven't yet modified Leo2AsciiDoc to take
      advantage of the automatic appendix elements in AsciiDoc 5.0.
    - adding custom bookinfo elements

I've used XSLT for this, but it could have been done with python,
AWK, sed, or other tools.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/customize.xsl"
&lt;&lt; Customize &gt;&gt;
@code
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="1.0"&gt;

&lt;xsl:variable name="AppendBegin"&gt;Appendix: &lt;/xsl:variable&gt;

&lt;!--~~~~~~ copy everything ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--&gt;
&lt;xsl:template match="@*|node()"&gt;
   &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
   &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;!--~~~~~~ delete the appendix string from the title ~~~~~~~~~~~~~~~~~~~~--&gt;
&lt;xsl:template match="/book/chapter/title[starts-with(text(),$AppendBegin)]"&gt;
  &lt;title&gt;
  &lt;xsl:value-of select="substring-after(text(),$AppendBegin)"/&gt;
  &lt;/title&gt;
  &lt;xsl:apply-templates select="*" /&gt; 
&lt;/xsl:template&gt;

&lt;!--~~~~~~ change appendix chapter element to appendix element ~~~~~~~~~~--&gt;
&lt;xsl:template match="/book/chapter[starts-with(title,$AppendBegin)]"&gt;
  &lt;appendix&gt;
    &lt;xsl:apply-templates select="*" /&gt; 
  &lt;/appendix&gt;
&lt;/xsl:template&gt;

&lt;!--~~~~~~ bookinfo ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--&gt;
&lt;!--
From Leo2AsciiDoc, only the bookinfo title is filled in, with a
blank author.  Here, we replace the author element with any and all
bookinfo elements we please.
--&gt;
  
&lt;xsl:template match="/book/bookinfo/author"&gt;
  &lt;author&gt;
    &lt;firstname&gt;Michael&lt;/firstname&gt;&lt;surname&gt;Dawson&lt;/surname&gt;
    &lt;affiliation&gt;
      &lt;address&gt;
        &lt;otheraddr&gt;
          &lt;ulink url="http://www.marshallresearch.com/contact.html"&gt;
            at Marshall Research
          &lt;/ulink&gt;
        &lt;/otheraddr&gt;
      &lt;/address&gt;
    &lt;/affiliation&gt;
  &lt;/author&gt;
  &lt;revhistory&gt;
    &lt;revision&gt;
      &lt;revnumber&gt;0.4a&lt;/revnumber&gt;
      &lt;date&gt;Jan 21 2004&lt;/date&gt;
      &lt;authorinitials&gt;mwd&lt;/authorinitials&gt;
      &lt;revremark&gt;Formatting enhancements&lt;/revremark&gt;
    &lt;/revision&gt;
    &lt;revision&gt;
      &lt;revnumber&gt;0.4&lt;/revnumber&gt;
      &lt;date&gt;Jan 19 2004&lt;/date&gt;
      &lt;authorinitials&gt;mwd&lt;/authorinitials&gt;
      &lt;revremark&gt;First release&lt;/revremark&gt;
    &lt;/revision&gt;
  &lt;/revhistory&gt;
&lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;

@doc
@ascskip xemacs-xsl-mode-off

</t>
<t tx="ekr.20040331071919.24">@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:02 CST 2004  michael@redpriest _HTML_One_File__139289780.txt"

indexterm:[Stylesheets,html.xsl]
For one long page of HTML, we simply import the DocBook stylesheets
and our small custom stylesheets that set our standard options.
This is the "html.xsl" stylesheet.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/html.xsl"
&lt;&lt; HTML: One File &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 

&lt;!--===== the catalog (/etx/xml/catalog) will convert this to the local pathname --&gt;
&lt;xsl:import href="docbook.xsl"/&gt;

&lt;xsl:import href="common-links.xsl"/&gt;
&lt;xsl:import href="common-html.xsl"/&gt;

&lt;/xsl:stylesheet&gt; 
@doc
@ascskip xemacs-xsl-mode-off


</t>
<t tx="ekr.20040331071919.25">@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:40 CST 2004  michael@redpriest _HTML_Individual_Pages__141001292.txt"

For individual section pages of HTML, we import the DocBook stylesheets
and our small custom stylesheets that set our standard options.

Then we set our chunking options, and tell the web pages where to
find the header and footer graphics.

indexterm:[Stylesheets,chunkit.xsl]
The following code is the entire chunkit style sheet
("chunkit.xsl").

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/chunkit.xsl"
&lt;&lt; HTML: Individual Pages &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 

&lt;xsl:import href="chunk.xsl"/&gt;

&lt;xsl:import href="common-links.xsl"/&gt;
&lt;xsl:import href="common-html.xsl"/&gt;

&lt;xsl:param name="navig.graphics" select="1"/&gt;
&lt;xsl:param name=
  "navig.graphics.path"&gt;graphics/&lt;/xsl:param&gt;
    &lt;!--  "navig.graphics.path"&gt;/usr/share/xml/docbook/docbook-xsl-1.59.1/images/&lt;/xsl:param&gt;--&gt;
    &lt;!--&lt;xsl:param name="navig.graphics.path"&gt;graphics/dbook/navicons/&lt;/xsl:param&gt;--&gt;
&lt;xsl:param name="navig.graphics.extension"&gt;.png&lt;/xsl:param&gt;
&lt;xsl:param name="navig.showtitles"&gt;1&lt;/xsl:param&gt;

&lt;xsl:param name="chunk.first.sections" select="1"&gt;&lt;/xsl:param&gt;
&lt;xsl:param name="chunk.section.depth" select="2"&gt;&lt;/xsl:param&gt;
&lt;xsl:param name="section.autolabel" select="0"&gt;&lt;/xsl:param&gt;

&lt;xsl:param name="css.decoration"&gt;1&lt;/xsl:param&gt;

&lt;/xsl:stylesheet&gt;

@doc
@ascskip xemacs-xsl-mode-off
</t>
<t tx="ekr.20040331071919.26">@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:58 CST 2004  michael@redpriest _HTML_base_css_style_sheet__141160708.txt"

css style sheet

@ascskip on
@ascskip xemacs-css-mode-on
@root "doc/base.css"
&lt;&lt; HTML: base css style sheet &gt;&gt;
@code
/* base from http://www.w3.org/TR/CSS21/sample.html */

address,
blockquote,
body, dd, div,
dl, dt, fieldset, form,
frame, frameset,
h1, h2, h3, h4,
h5, h6, noframes,
ol, p, ul, center,
dir, hr, menu, pre   { display: block }
li              { display: list-item }
head            { display: none }
table           { display: table }
tr              { display: table-row }
thead           { display: table-header-group }
tbody           { display: table-row-group }
tfoot           { display: table-footer-group }
col             { display: table-column }
colgroup        { display: table-column-group }
td, th          { display: table-cell; }
caption         { display: table-caption }
th              { font-weight: bolder; text-align: center }
caption         { text-align: center }
body            { padding: 8px; line-height: 1.12em }
h1              { font-size: 2em; margin: .67em 0 }
h2              { font-size: 1.5em; margin: .75em 0 }
h3              { font-size: 1.17em; margin: .83em 0 }
h4, p,
blockquote, ul,
fieldset, form,
ol, dl, dir,
menu            { margin: 1.12em 0 }
h5              { font-size: .83em; margin: 1.5em 0 }
h6              { font-size: .75em; margin: 1.67em 0 }
h1, h2, h3, h4,
h5, h6, b,
strong          { font-weight: bolder }
blockquote      { margin-left: 40px; margin-right: 40px }
i, cite, em,
var, address    { font-style: italic }
pre, tt, code,
kbd, samp       { font-family: monospace }
pre             { white-space: pre }

/********** comment **********/
/* http://www.w3.org/TR/CSS21/visuren.html#propdef-display lists inline-block */
button, textarea,
input, object, 
select, img { display:inline-block; }

big             { font-size: 1.17em }
small, sub, sup { font-size: .83em }
sub             { vertical-align: sub }
sup             { vertical-align: super }
s, strike, del  { text-decoration: line-through }
hr              { border: 1px inset }
ol, ul, dir,
menu, dd        { margin-left: 40px }
ol              { list-style-type: decimal }
ol ul, ul ol,
ul ul, ol ol    { margin-top: 0; margin-bottom: 0 }
u, ins          { text-decoration: underline }
/*br:before       { content: "\A" }*/
center          { text-align: center }

/********** changed **********/
/*
abbr, acronym   { font-variant: small-caps; letter-spacing: 0.1em }
*/

:link, :visited { text-decoration: underline }
:focus          { outline: thin dotted invert }

/* Begin bidirectionality settings (do not change) */
BDO[DIR="ltr"]  { direction: ltr; unicode-bidi: bidi-override }
BDO[DIR="rtl"]  { direction: rtl; unicode-bidi: bidi-override }

*[DIR="ltr"]    { direction: ltr; unicode-bidi: embed }
*[DIR="rtl"]    { direction: rtl; unicode-bidi: embed }

@media print {
  h1            { page-break-before: always }
  h1, h2, h3,
  h4, h5, h6    { page-break-after: avoid }
  ul, ol, dl    { page-break-before: avoid }
}



@doc
@ascskip xemacs-css-mode-off
</t>
<t tx="ekr.20040331071919.27">@silent
@doc
@ascskip # Time-stamp: "Wed, Jan 21 09:13 CST 2004  michael@redpriest _HTML_css_style_sheet__140659188.txt"

css style sheet

@ascskip on
@ascskip xemacs-css-mode-on
@root "doc/docstyle.css"
&lt;&lt; HTML: css style sheet &gt;&gt;
@code

html, body {
  background-color: #CCCCCC;
  font-family: "Verdana", arial;
}

body {
  font-size: 9pt;
  line-height: 125%;
/*   margin: 1em; */
  padding: 2em;
  margin-top: 1em;
  margin-left: 3em;
/*   width: 39em; */
  min-height: 60em;
/*   margin-right: 0.5em; */
  background-color: white;
  border-top: 1px solid black;
  border-left: 1px solid black;
/*   border-right: 2px solid black; */
/*   border-bottom: 2px solid black; */
}

.strong {
  font-weight: bold;
}

h1, h2, h3, h4, h5, h6,
p
{
  margin-bottom: 0.5em;
  margin-top: 0.5em;
  line-height: 125%;
}

h1 { font-size: 2em;}
h2 { font-size: 1.4em; }
h3 { font-size: 1.2em; }
h4 { font-size: 1.0em; }
h5 { font-size: 1.0em; }
h6 { font-size: 1.0em; }

h1, h2, h3, h4, h5, h6 {
  color: #660000;
  margin-right: 20%;
}

* &gt; h1 {
  padding-top: 0.5em;
}

/* h2, h3 */
/* { */
/*   margin-right: 10em; */
/* } */

h1.title 
{
  margin-top: 3em;
  border-top: 3px solid #660000;
  border-bottom: 3px solid #660000;
  border-color: #660000;
  padding: .4em;
  text-align: center;
}

h2.title 
{
  margin-top: 3em;
  border-top: 3px solid #660000;
  border-bottom: 3px solid #660000;
  border-color: #660000;
  padding: .4em;
}

div.toc {
    line-height: 100%;
}

div.list-of-examples {
    margin-top: 3em;
}

div.sect1 h2 {
  font-size: 1.5em;
  margin-top: 4em;
  margin-left: 0em;
  margin-right: 25%;
  margin-bottom: 1em;
  /* border-color: #660000; */
  border-top: 0em;
  border-bottom: 1px solid;
  padding: 0em;
}

div.sect2 h3 {
  font-size: 1em;
  margin-top: 4em;
  margin-bottom: 1em;
  margin-right: 25%;
  /* border-color: #660000; */
  border-top: 0em;
  border-bottom: 1px solid;
}

div.sect3 h4 {
  font-size: small;
  color: black;
  margin-top: 4em;
  margin-bottom: 1em;
  margin-right: 25%;
  /* border-color: #660000; */
  border-top: 0em;
  border-bottom: 1px solid;
}

div.note
{
  margin-top: 1em;
  margin-bottom: 1em;
}
div.note .title
{
  color: black;
  font-size: x-small;
  margin-top: 0em;
  margin-bottom: 0em;
}
/* ----- links ---------------------------------------------------------- */
:link {
  color: #660000;
  text-decoration: none;
  font-weight: bold;
}

:visited {
  color: #333333;
  text-decoration: none;
  font-weight: bold;
}


div.toc :link, :visited {
  font-weight: normal;
 }

div.list-of-examples :link, :visited {
  font-weight: normal;
 }


a:link img {border-style: none;}
a:visited img {border-style: none;}

div.toc dd, dl
{
  margin-top: 0em;
  margin-bottom: 0em;
}
div.toc dt
{
  margin-top: 0.2em;
}

ul, ol
{
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

.para {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

.sect1,
.toplevel.section
{
  padding-bottom: 0.25em;
}


tt,pre {
    font-family: Courier New,Courier,monospace;
    font-size: smaller;
}

.programlisting {
    margin-top: 8pt;
    margin-bottom: 8pt;
    margin-left: 1em;
    background-color: #FFFFCC;
    white-space: pre;
    border-style: solid;
    border-width: 1pt;
    border-color: #999999;
    padding-left: 6pt;
    padding-top: 2pt;
    padding-bottom: 2pt;
    width: 100%;
    line-height: 100%;
}

table{
    background-color: #FFFFFF;
    width: 99.6%;
}

div.example {
    margin-top: 0pt;
    margin-bottom: 0pt;
    padding-top: 0pt;
    padding-bottom: 0pt;
}

div.example .title {
    color: black;
    margin-top: 0pt;
    margin-bottom: 0pt;
    padding-top: 8pt;
    padding-bottom: 0pt;
}

div.sidebar .title {
  font-weight: bold;
  color: black;
}

div.sidebar  {
  font-size: x-small;
  margin-top: 2em;
  margin-bottom: 0.5em;
  /* margin-left: 1em; */
  margin-right: 33%; 
  padding: 4pt;
  border-top: 1px solid black;
  border-bottom: 1px solid black;
  border-left: 1px solid black;
  border-right: 1px solid black;
}


h1 &gt; a,
h2 &gt; a {
  padding-top: 0.5em;
}

ol.vert, ol.inline {
  list-style-type: none;
  padding-left: 0;
  margin-left: 0;
}

hr, .toc, .title
{ color: #660000 
}


.navfooter
{
  margin-top: 2em;
}
.navheader
{
  margin-bottom: 1em;

}

/* ------ title page ---------------------------------------------------- */
h3.author
{
  padding: 0em;
  margin-top: 0em;
  margin-bottom: -1em;
}

.affiliation
{
  padding: 0em;
  margin-top: 0em;
  margin-bottom: 0em;
  font-size: smaller;
}


div.revhistory table, tr, td
{
  border-collapse: collapse;
  border: hidden;
  font-size: x-small;
 }

div.revhistory table
{
  width: auto;
  }

div.revhistory td[colspan="3"]
{
  padding-left: 2em;  
 }


/* div.draft { */
/*   background-image: url('pics/draft.png'); */
/* } */


@doc
@ascskip xemacs-css-mode-off

</t>
<t tx="ekr.20040331071919.28">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:03 CST 2004  michael@redpriest _HTML_common__140982180.txt"
@ascskip xemacs-xsl-mode-off

indexterm:[Stylesheets,common-html.xsl]
The following section is the entire common-html style sheet
("common-html.xsl"), which sets basic HTML options.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/common-html.xsl"
&lt;&lt; HTML: common&gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 
&lt;!--===== ==========================================================--&gt;
&lt;xsl:param name="default.table.width" select="'100%'"&gt;&lt;/xsl:param&gt;
&lt;xsl:param name="html.stylesheet" select="'dbstyle.css'"/&gt;
&lt;xsl:param name="shade.verbatim" select="1"/&gt;
&lt;xsl:attribute-set name="shade.verbatim.style"&gt;
  &lt;xsl:attribute name="border"&gt;0&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="bgcolor"&gt;#F3F3F3&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;


&lt;/xsl:stylesheet&gt;
@doc
@ascskip xemacs-xsl-mode-off
</t>
<t tx="ekr.20040331071919.29">@comment &lt;!-- --&gt;
@silent
@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:03 CST 2004  michael@redpriest _PDF__139549436.txt"

indexterm:[Stylesheets, fo-fop.xsl]
This is the Formatting Objects style sheet ("fo-fop.xsl", which sets
the options for all printed output.

The actual output is a file with the ".fo" extension, which will be
used by a Formatting Object processor to produce a PDF file.

@ascskip on
@ascskip xemacs-xsl-mode-on
@root "doc/fo-fop.xsl"
&lt;&lt; PDF &gt;&gt;
@code
&lt;?xml version='1.0'?&gt; 
&lt;xsl:stylesheet  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"  version="1.0"&gt; 
&lt;!--===== ==========================================================--&gt;

&lt;!--===== catalog will convert the url to our file location =========--&gt;
&lt;xsl:import href="fo-docbook.xsl"/&gt;
&lt;xsl:import href="common-links.xsl"/&gt;

&lt;!--===== using the fop pdf processor ===================================--&gt;
&lt;xsl:param name="fop.extensions" select="1"/&gt;

&lt;!--===== single sided pages ============================================--&gt;
&lt;xsl:param name="double.sided" select="0"&gt;&lt;/xsl:param&gt;

&lt;!--===== body print ====================================================--&gt;
&lt;xsl:param name="body.font.master"&gt;12&lt;/xsl:param&gt;
&lt;xsl:param name="alignment"&gt;left&lt;/xsl:param&gt;
&lt;xsl:param name="hyphenate"&gt;true&lt;/xsl:param&gt;

&lt;!--===== set page margins ==============================================--&gt;
&lt;xsl:param name="page.margin.inner"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="$double.sided != 0"&gt;1.25in&lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;1.5in&lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:param&gt;

&lt;xsl:param name="body.margin.top" select="'.75in'"&gt;&lt;/xsl:param&gt;

&lt;!--===== set title fonts ===============================================
     Title fonts require replacing the standard
     titlepage.templates.xsl with a custom version.  This is done
     here by copying the fo/titlepage.templates.xml to
     mrc.titlepage.templates.xsl, editing it, and then processing it
     with
      xsltproc -output mrc.titlepage.templates.xsl \
         /usr/share/xml/docbook/docbook-xsl-1.60.1/template/titlepage.xsl  \
         mrc.titlepage.templates.xml
     Now we replace the old titlepage.templates.xsl with our new
     mrc.titlepage.templates.xsl
--&gt;
&lt;xsl:include href="mrc.titlepage.templates.xsl"/&gt;

&lt;!--===== blank verso titlepage =========================================--&gt;
&lt;xsl:template name="book.titlepage.verso"/&gt;

&lt;!--===== outdent titles ================================================--&gt;
&lt;xsl:param name="title.margin.left" select="'-2pc'"/&gt;

&lt;!--===== set section font, break ======================================--&gt;
&lt;xsl:attribute-set name="section.title.level1.properties"&gt;
  &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="break-before"&gt;page&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-bottom"&gt;1pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-bottom-style"&gt;solid&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-bottom-color"&gt;black&lt;/xsl:attribute&gt;  
  &lt;xsl:attribute name="margin-right"&gt;6em&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;xsl:attribute-set name="section.title.level2.properties"&gt;
  &lt;xsl:attribute name="break-before"&gt;page&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;xsl:attribute-set name="section.title.level3.properties"&gt;
  &lt;xsl:attribute name="break-before"&gt;page&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;!--===== Code extract titles are sidebars ==============================--&gt;
&lt;xsl:attribute-set name="sidebar.properties" use-attribute-sets="formal.object.properties"&gt;
  &lt;xsl:attribute name="border-style"&gt;solid&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-width"&gt;1pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="border-color"&gt;black&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="background-color"&gt;#EDEDED&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-left"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-right"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-top"&gt;2pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="padding-bottom"&gt;4pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-left"&gt;0pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-right"&gt;4em&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-top"&gt;2pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="margin-bottom"&gt;2pt&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;!--===== code (verbatim) font and spacing ==============================--&gt;
&lt;xsl:attribute-set name="verbatim.properties"&gt;
  &lt;xsl:attribute name="space-before.minimum"&gt;0.1pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-before.optimum"&gt;2pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-before.maximum"&gt;3pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-after.minimum"&gt;0.4em&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-after.optimum"&gt;.5em&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="space-after.maximum"&gt;1.2em&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
&lt;xsl:attribute-set name="monospace.verbatim.properties"
    use-attribute-sets="verbatim.properties monospace.properties"&gt;
  &lt;xsl:attribute name="text-align"&gt;start&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;9pt&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
    &lt;!--===== 2003-Oct-01 FOP does not appear to support shade.verbatim yet =--&gt;
&lt;xsl:param name="shade.verbatim" select="1"/&gt;
&lt;xsl:attribute-set name="shade.verbatim.style"&gt;
  &lt;xsl:attribute name="border"&gt;1&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="bgcolor"&gt;#E0E0E0&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

    &lt;!--===== FOP did not like this =========================================--&gt;
&lt;!--&lt;xsl:attribute-set name="xref.properties"&gt;--&gt;
&lt;!--  &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;--&gt;
&lt;!--  &lt;xsl:attribute name="font-style"&gt;bold&lt;/xsl:attribute&gt;--&gt;
&lt;!--&lt;/xsl:attribute-set&gt;--&gt;

&lt;/xsl:stylesheet&gt;

@doc
@ascskip xemacs-xsl-mode-off




</t>
<t tx="ekr.20040331071919.30">@language plain
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:21 CST 2004  michael@redpriest Appendix_XEmacs_Text_Editor_140657924.txt"

You can use Leo to enter all the text in an outline, but Leo also
allows you to use your familiar editing environment.  In my case,
that is XEmacs.  Fortunately, Leo integrates with XEmacs quite well.

The following items are code I use, some Leo Python plugins and some
XEmacs elisp functions.  You may find them useful.

@ascskip on
&lt;&lt; Appendix: XEmacs Text Editor &gt;&gt;
@code</t>
<t tx="ekr.20040331071919.31">@language python
@tabwidth -4

@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:10 CST 2004  michael@redpriest _OpenWith_Plugin__140659092.py"

Leo's Open_With plugin can be modified so that the body text of any
outline node can be edited in XEmacs by choosing "File; OpenWith;
XEmacs" or "File; OpenWith; XEmacs - noshow"  from the menu.

What actually happens is that Leo places the text in a temporary
file, and calls XEmacs with the address of that temporary file.  Leo
then watches for changes in the temporary file.  When and if the
temporary file changes, Leo copies the contents to the body text of
the Leo node.
      
Below is the standard open_with.py plugin that came with Leo 4.1-rc3
The only modification I've made is to insert
@code
&lt;&lt;call XEmacs&gt;&gt;=
table = (
    ("X&amp;Emacs", "Alt+Shift+O", ("os.system","/usr/bin/gnuclient -q ", None)),
    ("X&amp;Emacs - noshow", "Ctrl+Shift+O", ("os.system","/mrc2/linux-bin/gnuclient-noshow ", None))
    )
@doc
as noted below.  A similar alteration should work for future
versions.

Note: this alteration is for XEmacs running under Linux, but a
similar command should work in the Windows environment.

I use the "gnuclient-noshow" selection to load the temporary open_with file in
the background.  It is a small bash shell script:
---
#!/bin/bash
gnuclient -eval "(find-file-noselect \"${1}\")"
---

To implement this, edit a copy of the open_with.py file that comes
with your version of Leo.  Move the original copy to a safe place,
and put your edited copy in the Leo plugins directory.  Check to see
it is included in "pluginsManager.txt" in that directory.
@ascskip on
@root "other/xemacs/open_with.py"
&lt;&lt; Open_With Plugin&gt;&gt;
@code
"""Create menu for Open With command and handle the resulting commands"""

import leoGlobals as g
import leoPlugins

try:    import Tkinter as Tk
except: Tk = None

import os

if Tk: # Register the handlers...

    def on_idle (tag,keywords):
        a = g.app
        if g.app.killed: return
        for dict in a.openWithFiles:
            path = dict.get("path")
            c = dict.get("c")
            encoding = dict.get("encoding",None)
            v = dict.get("v")
            old_body = dict.get("body")
            if path and os.path.exists(path):
                try:
                    time = os.path.getmtime(path)
                    if time and time != dict.get("time"):
                        dict["time"] = time # inhibit endless dialog loop.
                        # The file has changed.
                        try:
                            # Update v from the changed temp file.
                            f=open(path)
                            s=f.read()
                            f.close()
                        except:
                            g.es("can not open " + g.shortFileName(path))
                            break
                        
                        # Convert body and s to whatever encoding is in effect.
                        body = v.bodyString()
                        body = g.toEncodedString(body,encoding,reportErrors=True)
                        s = g.toEncodedString(s,encoding,reportErrors=True) # 10/13/03
                        
                        conflict = body != old_body and body != s
                        
                        # Set update if we should update the outline from the file.
                        if conflict:
                            # See how the user wants to resolve the conflict.
                            g.es("conflict in " + g.shortFileName(path),color="red")
                            message = "Replace changed outline with external changes?"
                            result = g.app.gui.runAskYesNoDialog("Conflict!",message)
                            update = result.lower() == "yes"
                        else:
                            update = s != body
                        
                        if update:
                            g.es("updated from: " + g.shortFileName(path),color="blue")
                            v.setBodyStringOrPane(s,encoding) # 10/16/03
                            c.selectVnode(v)
                            dict["body"] = s
                        elif conflict:
                            g.es("not updated from: " + g.shortFileName(path),color="blue")
                except:
                    g.es_exception() ## testing
                    pass
    def create_open_with_menu (tag,keywords):
    
        if  (tag in ("start2","open2") or
            (tag=="command2" and keywords.get("label")=="new")):
    
            # Entries in the following table are the tuple 
            # (commandName,shortcut,data).
            # 
            # - data is the tuple (command,arg,ext).
            # - command is one of "os.system", "os.startfile", "os.spawnl", 
            # "os.spawnv" or "exec".
            # 
            # Leo executes command(arg+path) where path is the full path to 
            # the temp file.
            # If ext is not None, the temp file has the extension ext,
            # Otherwise, Leo computes an extension based on what @language 
            # directive is in effect.
            
            idle_arg = "c:/python22/tools/idle/idle.py -e "
            
@doc
Here is where we insert the &lt; Call XEmacs &gt; code fragment defined above:
@code
            if 1: # Default table.


&lt;&lt; Call XEmacs &gt;&gt;
#               table = (
#                   # Opening idle this way doesn't work so well.
#                   # ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
#                   ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
#                   ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
#           elif 1: # Test table.
#               table = ("&amp;Word","Alt+Shift+W",("os.startfile",None,".doc")),
#           else: # David McNab's table.
#               table = ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)),
            
            g.top().frame.menu.createOpenWithMenuFromTable(table)

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":

        g.app.hasOpenWithMenu = True
        leoPlugins.registerHandler("idle", on_idle)
        leoPlugins.registerHandler(("start2","open2","command2"), create_open_with_menu)
    
        __version__ = "1.4" # Set version for the plugin handler.
        g.plugin_signon(__name__)

</t>
<t tx="ekr.20040331071919.32">@language python
@tabwidth -4
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:14 CST 2004  michael@redpriest _OpenTree_Plugin__140660268.py"

This is a module that creates an "Open With" menu item that opens
Leo outline nodes in the tree below the current Leo node in the
XEmacs editor.  I frequently have a small tree of Leo nodes which
contain code that is usually edited in the same session.

NOTE: I use the "gnuclient-noshow" selection to load the temporary
open_with file in the background.  Leo calls a command with the
temporary file name at the end of the command, but the gnuclient
command needs to receive it enclosed in quotes and parentheses.  The
solution is a small intermediary bash shell script called
"gnuclient-noshow":

---
#!/bin/bash
gnuclient -eval "(find-file-noselect \"${1}\")"
---

I would rather have this operate in the background, but Leo's
openWith always operates on the current node, and openWith has much
good error checking that I want to use. So the fast solution was to
have OpenTreeInXEmacs visibly traverse the tree.

@ascskip on
@root "other/xemacs/mod_xemacsopentree.py"
&lt;&lt; Open_Tree Plugin &gt;&gt;
@code

import leoPlugins

def OpenTreeInXEmacs():
    import leoCommands
    #XEmacsCommand = "/usr/bin/gnuclient -q "
    XEmacsCommand = "/mrc2/linux-bin/gnuclient-noshow "
    c = g.top()
    vnode = c.currentVnode() # get the current vnode.
    stopHere = vnode.nodeAfterTree()
    v = vnode
    while v != stopHere:
        c.openWith(data=("os.system", XEmacsCommand, None))
        v = v.threadNext()
        if (not v) or (v == stopHere):
            break
        c.selectVnode(v)
    c.selectVnode(vnode)


def CreateOpenTreeMenu(tag,keywords):

    """Create the 'Xemacs: Open Tree' menu item in the Open With menu."""


    if  (tag=="open2" or
        (tag=="start2") or
        (tag=="command2" and keywords.get("label")=="new")):

        c = g.top()
        exportMenu = c.frame.menu.getMenu('Open With')
        newEntries = (
            ("-", None, None),
            ("XEmacs: Open nodes in sub-tree","None",OpenTreeInXEmacs),
            )

        c.frame.menu.createMenuEntries(exportMenu, newEntries)

if 1:
    leoPlugins.registerHandler(("start2","open2","command2"), CreateOpenTreeMenu)

    __version__ = ".4" # Set version for the plugin handler.
    g.plugin_signon(__name__)
@doc


@code
</t>
<t tx="ekr.20040331071919.33">@language python
@tabwidth -4
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:15 CST 2004  michael@redpriest _Filename_modification__140661308.py"

This is a small modification to Leo (via a Python plugin module) so
that Leo will open the temporary files with a name that can be
easily recognized in an XEmacs buffer listing.

On Linux, Leo opens files in the temporary files directory, all
prefixed with "LeoTemp_", which makes the names difficult to tell
apart when you have many different nodes loaded in XEmacs.

This code replaces the openWithTempFilePath method of the LeoFrame
class with code that opens temporary files in a subdirectory of the
temporary files directory, called "username_Leo", and omits the
"LeoTemp" prefix.

For example, I'm now editing this Leo node in XEmacs as
    "/tmp/michael_Leo/_Filename_modification__138976348.py"
In the XEmacs buffer list, the filename is shown as
    "_Filename_modification__138976348.py"
and all the Leo buffer names start with a leading underscore, so
they are grouped together.

For general use, this code should be considerably more robust about
creating the Leo subdirectory and signaling errors, but it is just a
quick hack that works for me on my machines.

This is distributed with Leo version 4.1rc3, so I've updated it with
Ed Ream's modifications to match that distribution.

@ascskip on
@root "other/xemacs/mod_tempfname.py"
&lt;&lt; Filename modification &gt;&gt;
@code

"""Replace Commands.openWithTempFilePath so Leo opens temporary
files with a filename that begins with the headline text, and
located in a 'username_Leo' subdirectory of the temporary
directory. The 'LeoTemp' prefix is omitted.  This makes it easier to
see which temporary file is related to which outline node.""" #'

import leoGlobals as g
import leoPlugins

import leoCommands
import getpass
import os
import tempfile

def onStart (tag,keywords):

    # g.trace("replacing openWithTempFilePath")

    g.funcToMethod(openWithTempFilePath,leoCommands.Commands,"openWithTempFilePath")

def openWithTempFilePath (self,v,ext):

    """Return the path to the temp file corresponding to v and ext.

    Replaces the Commands method."""    

    try:
        leoTempDir = getpass.getuser() + "_" + "Leo"
    except:
        leoTempDir = "LeoTemp"
        g.es("Could not retrieve your user name.")
        g.es("Temporary files will be stored in: %s" % leoTempDir)

    td = os.path.join(os.path.abspath(tempfile.gettempdir()), leoTempDir)
    if not os.path.exists(td):
        os.mkdir(td)

    name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
    path = os.path.join(td,name)
    return path

# Register the handlers...
leoPlugins.registerHandler("start2", onStart)

__version__ = "1.3"
g.plugin_signon(__name__)
</t>
<t tx="ekr.20040331071919.34">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 09:58 CST 2004  michael@redpriest _Kill_Temporary_Buffers__140661388.txt"

If you've opened a number of Leo temporary buffers in XEmacs, this
XEmacs function will kill them for you.  Just set the tempdir
variable to whatever matches your local value.

XEmacs will prompt you about any buffers that have unsaved changes.

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/kill-temporary-buffers.el"
&lt;&lt; Kill Temporary Buffers &gt;&gt;
@code
;;
;;-     mwd-leo-kill-buffers
(defun mwd-leo-kill-buffers ()
  "Kill any buffers for files in my Leo temporary directory."
  (interactive)
  (let ((bl (buffer-list))
        (tempdir "/tmp/michael_Leo" )  ;; change this to your temporary directory.
        )
    (while bl
      (setq test-buffer (car bl))
      (setq bname (buffer-file-name test-buffer))
      (if (and bname (string-match tempdir bname))
          (kill-buffer test-buffer)
        )
      (setq bl (cdr bl))
      )
    )
  )



@doc
@ascskip xemacs-lisp-mode-off
</t>
<t tx="ekr.20040331071919.35">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:18 CST 2004  michael@redpriest _MMMmode__140663340.txt"

There is an editing mode for XEmacs called Multiple Major Modes,
which allows us to edit the temporary text conveniently: with all
the syntax highlighting, special keymaps, etc. available, even
though Leo nodes may contain both plain text and program code.

When the XEmacs cursor is in a section of plain text, all the plain
text facilities are available, and there is no syntax
highlighting. When the XEmacs cursor is in a section of code
(Python, XSL, whatever) XEmacs invokes the syntax highlighting,
special keymaps, etc. appropriate for that code.

indexterm:[Multiple Major Modes]
indexterm:[Multiple Major Modes,mmm-mode.el]
If you have XEmacs installed, and you have also installed the
Multiple Major Modes mmm-mode.el package, the following code will
customize mmm-mode for use while editing Leo temporary files.

NOTE: mmm-mode is already installed by default in most
distributions.

Installation: Load mmm-leo-config.el from your .init.el file, or
just load it manually to try it out.

I won't go through it all, but for example, when editing a temporary
Leo file that is in XEmacs Python mode, and/or has a ".py" suffix:

    - when your cursor is any text between the @doc and @code
      directives XEmacs will enter text-mode.  Otherwise (e.g. with
      the cursor after the @code directive), XEmacs will be in
      Python mode.
    - when your cursor is between text that says
      "xemacs -makefile-mode-on" and text that says
      "xemacs -makefile-mode-off", XEmacs will enter makefile-mode.
      (You key in those text markers to mark out the area you want
      as makefile-mode.  See the Leo2AsciiDoc.leo outline for examples,
      e.g the "Make File" section in the Leo2AsciiDoc Users Guide.)

      Otherwise, XEmacs will be in Python mode in that buffer.

Similarly, makefile-mode, xsl-mode and emacs-lisp-mode are added to
temporary Leo files that created with a ".txt" extension.      

A future project may be to create a Leo module to use in the
Leo "openWith" function that examines each node for these mmm-mode
markers and creates the temporary file with the proper extension.

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/mmm-leo-config.el"
&lt;&lt; MMM-mode &gt;&gt;
@code
;;-     mmm-mode                multiple modes
(require 'mmm-auto)
(require 'mmm-vars)

;   mmm-mode-on and mmm-mode-off turn it on and off in a buffer.
;   \c-c % \c-b re-parses the whole buffer

;   set mode to activate on mode or extension
(setq mmm-global-mode 'maybe)

; turn off gray background
(setq mmm-submode-decoration-level 0)

;   add embedded modes in python
(mmm-add-group
 'py-embedded-text
 '(
   (py-leo
    :submode text-mode
    :face mmm-code-submode-face
    :front "^@doc.*"
    :back "^@code"
    :insert ((?l py-leo-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   (py-doc
    :submode text-mode
    :face mmm-code-submode-face
    :front "^\"\"\".*"
    :back "^.+\"\"\""
    )
   (py-makefile
    :submode makefile-mode
    :face mmm-code-submode-face
    :front "xemacs-makefile-mode-on"
    :back "xemacs-makefile-mode-off"
    )
   )
 )
;   add embedded modes in text
(mmm-add-group
 'text-embedded
 '(
   (txt-makefile-mode
    :submode makefile-mode
    :face mmm-code-submode-face
    :front "xemacs-makefile-mode-on"
    :back "xemacs-makefile-mode-off"
    :insert ((?l text-embedded-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   (txt-xsl-mode
    :submode xsl-mode
    :face mmm-code-submode-face
    :front "xemacs-xsl-mode-on"
    :back "xemacs-xsl-mode-off"
    :insert ((?l text-embedded-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   (txt-lisp-mode
    :submode emacs-lisp-mode
    :face mmm-code-submode-face
    :front "xemacs-lisp-mode-on"
    :back "xemacs-lisp-mode-off"
    :insert ((?l text-embedded-tag nil @ "@doc"
                 @ "\n\n" _ "\n\n" @ "@code" @))
    ; \c % l will insert the doc-code pair at point.
    )
   )
 )
(mmm-add-mode-ext-class 'python-mode "\\.py\\'" 'py-embedded-text)
(mmm-add-mode-ext-class 'text-mode "\\.txt\\'" 'text-embedded)

@doc
@ascskip xemacs-lisp-mode-off
</t>
<t tx="ekr.20040331071919.36">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:20 CST 2004  michael@redpriest _Insert_indexterm__140664580.txt"

indexterm:[XEmacs, Indexing]
Indexing is tedious work, and it interferes with the readability of
the ascii text as well.  However, used sparingly, it helps the
reader.

When editing a Leo node (in an XEmacs buffer), this function copies
a highlighted word or phrase and inserts an AsciiDoc index code on a
new line immediately before the paragraph.  I try to keep markup out
of the way of the reader.  In this case, AsciiDoc requires that the
index code be part of the same block of text, and the first line of
the block is the least annoying place I can find.

For example, if I wanted to index the words "XEmacs buffer" above, I
would highlight them (usually by pressing M-@ a couple of times) and
then call this function (I have it bound to C-k C-h C-i).  At the
beginning of the paragraph, my text would say "\indexterm:[XEmacs
buffer]".

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/index-leo-region.el"
&lt;&lt; Insert indexterm &gt;&gt;
@code
(defun mwd-index-leo-region (start end)
  "preface paragraph with AsciiDoc index macro of region."
  (interactive "r")
  (save-excursion
    (copy-region-as-kill start end)
    (backward-paragraph)
    (insert "\nindexterm:[")
    (yank)
    (insert "]")
    )
  )

@doc
@ascskip xemacs-lisp-mode-off

</t>
<t tx="ekr.20040331071919.37">@language plain
@silent
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:56 CST 2004  michael@redpriest _Indent_Leo_comments__141202716.txt"

Leo derived files are sprinkled with comments, which Leo uses as
markers to be able to "untangle" files, i.e. import changes made to
a derived file back into the Leo outline.

Useful as they may be, the comments are an ugly distraction when
reading the source code.  One could have XEmacs flush them from the
file, but then the untangle feature is gone for that file.

This pair of XEmacs elisp functions moves them to the right, where
they aren't so distracting, and moves them back again if you should
want to untangle the file.

@ascskip on
@ascskip xemacs-lisp-mode-on
@root "other/xemacs/indent-leo-comments.el"
&lt;&lt; Indent Leo comments &gt;&gt;
@code
(defun mwd-leo-comments-indent ()
  "Indent Leo comments to make them less distracting."
  (interactive)
  (save-excursion
    (let* (
          (leading-spaces 40)
          (start-string (concat (make-string leading-spaces ? ) "\\1" ))
          (end-string (concat (make-string leading-spaces ? ) "\\1" ))
          )
      (goto-char (point-min))
      (while (search-forward-regexp "\\(^# &lt;&lt;\\)" nil t) (replace-match start-string))
      (goto-char (point-min))
      (while (search-forward-regexp "\\(^# -- end\\)" nil t) (replace-match end-string))
      )
    )
  )

(defun mwd-leo-comments-unindent ()
  "Reverse the effect of mwd-leo-comments-indent."
  (interactive)
  (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp "^\\(\\s-\\)+\\(# &lt;&lt;\\)" nil t) (replace-match "\\2" ))
      (goto-char (point-min))
      (while (search-forward-regexp "^\\(\\s-\\)+\\(# -- end\\)" nil t) (replace-match "\\2" ))
    )
  )
@doc
@ascskip xemacs-lisp-mode-off
</t>
<t tx="ekr.20040331071919.38">@language plain
@ascfile "doc/mod_asc_user.asc"
@ascconfig maxCodeLineLength 80
@doc
@ascskip # Time-stamp: "Mon, Jan 19 15:29 CST 2004  michael@redpriest Leo_AsciiDoc_Users_Guide_141652036.txt"

Preface
-------

Leo2AsciiDoc is a small Python program which has been
built to be used as a plugin module for the Leo outlining editor.

Leo2AsciiDoc enables the contents of Leo outlines to be published to HTML
or PDF via the DocBook set of publishing tools.  Plain text from the
Leo outline is transformed into a final result that has:

    - typeset body text, in which bulleted and numbered lists,
      variable lists, page numbers, URLs, index terms,and bold and
      italic text are automatically recognized.
    - typeset Headings
    - a Table of Contents
    - an Index containing any items marked by the user, and any
      Python classes or functions.

As you will see, there's not a lot involved in using the
Leo2AsciiDoc module.  It simply copies text from a Leo outline (or a
portion of a Leo outline) to a text file.  In turn that text file can
be automatically converted by the AsciiDoc program and a DocBook
system to properly typeset DocBook HTML, PDF or other formats.

If you keep your text plain, and use a few simple formatting
conventions, the final output can have typeset headings, bulleted
lists, indexing and cross-referencing, as well as many other
features.

---
Michael Dawson
Marshall Research
michael_dawson at marshallresearch dot com
---

*note*

Leo2AsciiDoc is suited for general text documents, most programming
documentation and most business documents.  Leo2AsciiDoc (being based on
DocBook) is not the choice for anyone needing detailed typographic
control of individual words or characters -- for example, typeset
equations.  In general, DocBook typesets blocks of text.

*note*

@code
</t>
<t tx="ekr.20040331071919.39">@doc
@ascskip # Time-stamp: "Mon, Jan 19 11:48 CST 2004  michael@redpriest Installation_140689076.txt"
Installation of this plugin is very straightforward, using Leo
version 4.1:

    - copy the python source code (mod_leo2ascd.py) to your Leo
      plugin directory (a subdirectory called "plugins" under your
      main Leo directory).
    - in that directory should be a text file called
      pluginsManager.txt, containing a list of all plugins that are
      to be loaded when Leo starts.  Add mod_leo2ascd.py to the
      list.
    - start or re-start Leo.
    - in the Leo Log Window you should see the Leo2AsciiDoc sign-on
      message "---mod_leo2asc 0.4-------".
    - in the Leo main menu "File; Export", there should be two menu
      items called something like "Export to AsciiDoc".

@code</t>
<t tx="ekr.20040331071919.40">@language plain
@doc
@ascskip # Time-stamp: "Thu, Oct 16 13:46 CST 2003  michael@redpriest Operation_140791428.txt"

Using Leo2AsciiDoc is as simple as choosing the Leo menu item: "File;
Export; Export All to AsciiDoc".  From there, you have the AsciiDoc
program and the DocBook system automatically convert your outline to
HTML or PDF (or to a manpage or a DocBook website.)

Step by step:

    - You need a Leo outline containing some plain text, or plain
      text and code.
    - You ensure that the top node in the outline (or part of the
      outline tree which you want to be a separate document) must
      have an @ascfile directive in the body text. The @ascfile
      directive is used to specify the filename in which the output
      text will be put.
    - You then use Leo's menu: "File; Export; Export All to
      AsciiDoc" (or one of the other Leo2AsciiDoc menu items) to
      have Leo2AsciiDoc automatically export the outline to a text file.
    - After that, you run the AsciiDoc program on the exported text
      file, and process it as a DocBook document.  Most often,
      people have a Make file set up to do this automatically.

In practice, people often want to use special features:

    - plain text formatting, sometimes referred to as "structured
      text" or "minimal markup"
    - Leo2AsciiDoc configuration options

The following sections cover this.  If you've downloaded the Leo2AsciiDoc
package, the mod_leo2asc.leo outline is available, and illustrates
all the features.  It is the outline from which all the Leo2AsciiDoc HTML
and PDF documentation and code were derived.

@code
</t>
<t tx="ekr.20040331071919.41">@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:19 CST 2004  michael@redpriest Directives_140672364.txt"

The following are non-printing directives that you can insert into
your outline text to control Leo2AsciiDoc behaviour.  All must be at the
beginning of the line.

{amp}commat;ascfile::
    e.g: `@ascfile "doc/mod_asc_user.asc" `

    Ascfile is the equivalent of a Leo @root directive. Ascfile
    signals the start of a document and specifies the file name to
    receive the text.

    The default directory is the directory containing the Leo
    outline.  If you were editing an outline that resided in
    /home/me then the above ascfile directive would create the file
    mod_asc/user.asc in the directory /home/me/doc.

{amp}commat;ascignore::
    Ascignore causes Leo2AsciiDoc to ignore the outline node, and any
    sub-nodes. It must be placed before any line in the node which
    will print.

{amp}commat;ascskip::
    Causes Leo2AsciiDoc to skip the line.  If followed by the word "on",
    causes Leo2AsciiDoc to skip all succeeding document lines until an
    "{amp}commat;ascskip off" directive is read, or a code section is reached.

{amp}commat;ascexit::
    Causes Leo2AsciiDoc to exit the outline node without processing any
    further lines.  Sub-nodes will be processed.

{amp}commat;ascconfig::
    e.g. `{amp}commat;ascconfig maxCodeLineLength 70` -- see
    Configuration below. 
    

@code
</t>
<t tx="ekr.20040331071919.42">@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:20 CST 2004  michael@redpriest Configuration_140673612.txt"

There are a few configuration settings which may be set in an
outline.  To take effect, they must be placed:

    - in the top node of the outline, or
    - the same node as an @ascfile directive.
    
Configuration settings in the top node of the outline are effective
for the whole outline, unless overridden by settings in sub-nodes.

maxCodeLineLength::
    e.g. `{amp}commat;ascconfig maxCodeLineLength 70` -- 
    sets the maximum length of code printout lines to 70 characters.
    Longer lines will be wrapped and a line continuation character
    displayed.

PrintHeadings::    
    e.g. `{amp}commat;ascconfig PrintHeadings off` -- turns off the
    export of outline node headings as section titles.  In that
    case, you must have correctly entered AsciiDoc section titles in
    the body text of your outline.

Readers of the code will note that there are other configuration
settings in the code. These will be used in future, and so I won't
document them yet.


@code</t>
<t tx="ekr.20040331071919.43">@language plain
@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:22 CST 2004  michael@redpriest Markup_140672220.txt"

The point of using a system like AsciiDoc is to get a document that
is properly typeset, while writing only plain text with as little
embedded formatting instruction as possible.

For the most part, you simply write chunks of text, which become
typeset paragraphs.

I've tried to use most commonly used markup in the Leo outline that
contains all the Leo2AsciiDoc source and documentation, so that you
can see exactly how markup may be used.

@code</t>
<t tx="ekr.20040331071919.44">@doc
@ascskip # Time-stamp: "Mon, Jan 19 13:20 CST 2004  michael@redpriest Standard_AsciiDoc_Markup_140676540.txt"

This section illustrates a very small part of the standard AsciiDoc
markup.  However, AsciiDoc comes with extensive documentation of its
own, which any Leo2AsciiDoc user should read.


@code</t>
<t tx="ekr.20040331071919.45">@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:06 CST 2004  michael@redpriest Headings_141020668.txt"

indexterm:[Markup, Headings]
Leo2AsciiDoc will automatically create Headings from the headings of
your Leo outline.  You can turn this off (see Configuration), and
create your own headings in the body text of an outline node.  For
example, a Chapter heading is text at the left margin that has a
following line of dashes.  For example,

@code
 Operation
 ---------

@doc
is the heading of this chapter.  Chapter sub-sections have a
following line of tildes.  For example,

@code

 Markup
 ~~~~~~

@doc

is the heading of Section One of this chapter.  Section Two markup
is a following line of "^".  For example, 

@code

Standard AsciiDoc Markup
^^^^^^^^^^^^^^^^^^^^^^^^
@doc

is the heading of the section, which is a Section Two.

As I say, you normally don't need to do this, since Leo2AsciiDoc does all
this itself from the outline headings.


@code
</t>
<t tx="ekr.20040331071919.46">@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:06 CST 2004  michael@redpriest Lists_141018612.txt"

indexterm:[Markup, lists]
Bulleted lists start with a dash (or asterisk) followed by a space
or tab character.  I've extended this to allow leading spaces.  For
example,
    
@code
    - this is a list item
        * this is a sub-item
    - this is another list item
@doc

produces:

    - this is a list item
        * this is a sub-item
    - this is another list item


@code</t>
<t tx="ekr.20040331071919.47">@doc
@ascskip # Time-stamp: "Thu, Jan  8 14:07 CST 2004  michael@redpriest URLs_140994492.txt"

indexterm:[Markup, URL]
The URL address of a web page will be "hot" in the HTML or PDF
document, when terminated with square brackets:

@code

http://www.docbook.org[The official home page for DocBook: The Definitive  Guide.]

@doc

results in:

http://www.docbook.org[The official home page for DocBook: The Definitive Guide.]


@code</t>
<t tx="ekr.20040408161258"></t>
<t tx="ekr.20040408192158">@nocolor</t>
<t tx="ekr.20040408192158.1">###########################
|leo| Using the rst2 plugin
###########################

This page documents a nifty new plugin created by Josef Dalcolmo, Timo Honkasalo, Steve Zatz, Paul Paterson and Edward Ream.  This page was created using the rst2 plugin.  You can find the source code in LeoPlugins.leo (on cvs).

.. contents::

.. Here are the links used in this document.

.. _LaTeX:                http://www.latex-project.org/
.. _reStructuredText:     http://docutils.sourceforge.net/rst.html
.. _docutils:             http://docutils.sourceforge.net
.. _ListManagerDocs.html: http://webpages.charter.net/edreamleo/ListManagerDocs.html
.. _wxListManager.leo:    http://webpages.charter.net/edreamleo/wxListManager.leo
.. _SilverCity:           http://silvercity.sourceforge.net
.. _front:                http://webpages.charter.net/edreamleo/front.html
.. _home:                 http://webpages.charter.net/edreamleo/front.html

.. |blank| image:: blank.gif
.. |leo|   image:: leo.gif
    :target: front_</t>
<t tx="ekr.20040408192158.2"></t>
<t tx="ekr.20040408192158.3">@ignore
@nocolor
@wrap

This plugin creates output files from Leo outlines containing reStructuredText_
(rST) The combination of Leo outlines and rST creates a simple, flexible and
powerful way of generating HTML, LaTeX_ and other text documents.
ReStructuredText is a simple and powerful text formatting markup language.

The file ListManagerDocs.html_ is an impressive example of the kind of output
that is possible to generate relatively easily using this plugin. The source
file for this example is wxListManager.leo_.

To use this plugin, you must have installed Python's docutils_ module. This
module will also use the SilverCity_ syntax coloring package if you have
installed it.

This plugin assumes that a node whose headline is @rst &lt;filename&gt; contains a
tree of nodes containing reStructuredText. Let us call such a node an **rst root**
node. The plugin passes the headline and body text of the rst root and all the
nodes of its subtree to Python's docutils module, which parses the
reStructuredText and creates the output file.

Double-clicking on an rst root node generates an output file from the
reStructured Text input contained in the rst root node and all the nodes of its
subtree. The output file will be HTML, LaTex or plain text depending on the
extension of the filename specified in the rst root node. If the filename ends
in .html or .htm the docutils module will create an HTML file. If the filename
ends in .tex the docutils module will create a LaTex file. Otherwise, a plain
.txt file is generated.

If the output file is a .html or .htm file, it will use three .css (cascading
style sheet) files provided they exist in the same directory as the output file.
You can control the formatting of the HTML file by altering these .css files.
See the node called "cascading style sheets" for more details.

See the tree called "Scripting chapter using the rst plugin" in LeoDocs.leo for
many examples of how to use this plugin.</t>
<t tx="ekr.20040408192158.4"></t>
<t tx="ekr.20040408192158.5">@ignore
@nocolor
@wrap

If an outline node contains @rst &lt;filename&gt;, that node is the root of a tree of
nodes that will create the named output file. Let's call such a node the **rst
root**.

Subnodes of the rst root nodes may have headlines that contain just @rst. Such
node should contain rst markup, possibly including the code-block directive
defined by this plugin to format blocks of code.

**Important:** All @rst nodes should start with the @ignore directive. This allows @rst to be embedded in @file-nosent trees: see the next section for details. This plugin strips leading @ignore, @nocolor and @wrap directives.  Such directives do not appear in the output.

The root node may contain any rST directives.  In particular, to create a table of contents put::

    .. contents:: Table of Contents

on its own line in the rst root node.

All other subnodes of the rst root, i.e., nodes whose headline is something
other than @rst, are **code nodes**. This plugin converts the headline text of
code nodes into an rST section headline whose level depends on the level of the
node in the Leo outline. Higher-level headlines in the outline correspond to
higher-level section headings; lower-level headlines in the outline correspond
to lower-level section headings. Any text in a code node is formatted as if it
were enclosed in a code-block directive.

The plugin reserves the '#' character for your own use so that you can
specify an rST headline explicitly. For example,::

    #####
    Title
    #####

You would typically put such a title in the rst root node.
Otherwise, section underlining is discouraged, since the plugin automaticaly
generates sections from headlines.</t>
<t tx="ekr.20040408192158.6"></t>
<t tx="ekr.20040408192158.7">@ignore
@nocolor
@wrap

This plugin defines a code-block rST directive if the SilverCity syntax coloring module has been installed. This directive takes one argument, a language name.  For example::

    .. code-block:: Python
    
        import leoGlobals as g

This directive syntax colors the code in the indented code block that follows the directive.  The result looks like this:

.. code-block:: Python
    
    import leoGlobals as g

See the tree called "Scripting chapter using the rst plugin" in LeoDocs.leo for many examples of how to use this directive.
</t>
<t tx="ekr.20040408192158.8"></t>
<t tx="ekr.20040408192158.9">@ignore
@nocolor
@wrap

When this plugin generates HTML files, this plugin assumes that three .css
(cascading style sheet) files exist in the directory containing the output file.
For the HTML output to look good the following .css files should exist in the
directory containing the generatated HTML file: default.css, leo_rst.css and
silver_city.css.

- default.css is the default style sheet that docutils expects to exist.
- leo_rst.css contains some style improvements based on Gunnar Schwant's DocFactory.
- silver_city.css is the style sheet that controls the syntax highlighting generated by SilverCity.

The latter two style sheets are imported at the end of the default.css.

**N.B.** You can use cascading style sheets to do things that otherwise wouldn't be possible with "plain" rST.  For instance, the background color of this page was specified in a body style.

-------------

|leo|</t>
<t tx="ekr.20040409051841"></t>
<t tx="ekr.20040409051841.1">As stated earlier, you must put an @ignore directive in any @rst node (except the root @rst node) whose rST text you want to contribute to the output.  This strange-looking convention allows you to embed documentation in @file-nosent trees *without* that documentation being included in the file derived from the @file-nosent tree.

For example, consider the following outline, in which all the @rst nodes (except the root @rst node) contain @others directives::

    @rst spamDocs.html
        @file-nosent spam.py
            code node 1
                @rst
            code node 2
                @rst
            code node 3
                @rst

The rst2 plugin will ouput all the reStructuredText contained in the three @rst nodes to spamDocs.html, but the contents of those @rst nodes will not become part of spam.py.  *Note:* The @ignore directive is valid only in @file-nosent trees, which is why we must use @file-noset to generate spam.py.

It would be also be possible to use cloned nodes to embed code nodes in .html files.  This would allow you to use regular @file trees to generate derived files.  For example, suppose all similarly named code nodes are clones of each other::

    @rst spamDocs.html
        code node 1
            @rst
        code node 2
            @rst
        code node 3
            @rst

    @file-nosent spam.py
        code node 1
        code node 2
        code node 3

The disadvantage of this organization is that you must update spamDocs.html by hand to keep it up-to-date with spam.py.
</t>
</tnodes>
</leo_file>
