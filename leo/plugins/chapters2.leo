<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="248" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="152" left="376" height="660" width="800"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20060228085204"><vh>Buttons</vh>
<v t="ekr.20060228085204.1"><vh>@button Save</vh></v>
</v>
<v t="ekr.20060228081537"><vh>Original code</vh>
<v t="ekr.20060213023732.1"><vh>chapters.py ORIGINAL</vh>
<v t="ekr.20060213023732.2"><vh>&lt;&lt;docstring&gt;&gt;</vh></v>
<v t="ekr.20060213023732.3"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20060213023732.4"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060213023732.5"><vh>&lt;&lt; globals &gt;&gt;</vh></v>
<v t="ekr.20060213023732.6"><vh>init</vh>
<v t="ekr.20060213023732.7"><vh>&lt;&lt; override various methods &gt;&gt;</vh></v>
</v>
<v t="ekr.20060213023732.8"><vh>class Chapter</vh>
<v t="ekr.20060213023732.9"><vh>__init__</vh></v>
<v t="ekr.20060213023732.10"><vh>_saveInfo</vh></v>
<v t="ekr.20060213023732.11"><vh>setVariables</vh></v>
<v t="ekr.20060213023732.12"><vh>makeCurrent</vh></v>
</v>
<v t="ekr.20060213023732.13"><vh>Creating widgets...</vh>
<v t="ekr.20060213023732.14"><vh>newCreateControl</vh></v>
<v t="ekr.20060213023732.15"><vh>createPanedWidget</vh></v>
<v t="ekr.20060213023732.16"><vh>newEditorPane</vh></v>
<v t="ekr.20060213023732.17"><vh>newCreateCanvas</vh></v>
<v t="ekr.20060213023732.18"><vh>createBalloon</vh></v>
<v t="ekr.20060213023732.19"><vh>createNoteBook</vh></v>
<v t="ekr.20060213023732.20"><vh>getNameMaker</vh></v>
<v t="ekr.20060213023732.21"><vh>newTreeinit</vh></v>
<v t="ekr.20060213023732.22"><vh>constructTree</vh></v>
<v t="ekr.20060213023732.23"><vh>addPage</vh></v>
<v t="ekr.20060213023732.24"><vh>newEditor</vh></v>
</v>
<v t="ekr.20060213023732.25"><vh>tab menu stuff</vh>
<v t="ekr.20060213023732.26"><vh>makeTabMenu</vh></v>
<v t="ekr.20060213023732.27"><vh>function factories</vh>
<v t="ekr.20060213023732.28"><vh>getAddChapter</vh></v>
<v t="ekr.20060213023732.29"><vh>getRemove</vh></v>
<v t="ekr.20060213023732.30"><vh>getRename</vh></v>
<v t="ekr.20060213023732.31"><vh>getMakeTrash</vh></v>
<v t="ekr.20060213023732.32"><vh>getSetupMenu</vh></v>
</v>
</v>
<v t="ekr.20060213023732.33"><vh>Multi-Editor stuff</vh>
<v t="ekr.20060213023732.34"><vh>selectNodeForEditor</vh></v>
<v t="ekr.20060213023732.35"><vh>activateEditor</vh></v>
<v t="ekr.20060213023732.36"><vh>removeEditor</vh></v>
<v t="ekr.20060213023732.37"><vh>addHeading</vh></v>
</v>
<v t="ekr.20060213023732.38"><vh>Indexing</vh>
<v t="ekr.20060213023732.39"><vh>viewIndex</vh></v>
<v t="ekr.20060213023732.40"><vh>buildIndex</vh></v>
<v t="ekr.20060213023732.41"><vh>regexViewIndex</vh></v>
</v>
<v t="ekr.20060213023732.42"><vh>Chapter-Notebook ops</vh>
<v t="ekr.20060213023732.43"><vh>renumber</vh></v>
<v t="ekr.20060213023732.44"><vh>getGoodPage</vh></v>
<v t="ekr.20060213023732.45"><vh>checkChapterValidity</vh></v>
<v t="ekr.20060213023732.46"><vh>getSV</vh></v>
<v t="ekr.20060213023732.47"><vh>setTree</vh></v>
<v t="ekr.20060213023732.48"><vh>lowerPage</vh></v>
<v t="ekr.20060213023732.49"><vh>walkChapters</vh></v>
</v>
<v t="ekr.20060213023732.50"><vh>opening and closing (to be moved into Leo's core?)</vh>
<v t="ekr.20060213023732.51"><vh>opening</vh>
<v t="ekr.20060213023732.52"><vh>newGetLeoFile</vh></v>
<v t="ekr.20060213023732.53"><vh>newOpen</vh></v>
<v t="ekr.20060213023732.54"><vh>openChaptersFile</vh></v>
<v t="ekr.20060213023732.55" a="M"><vh>insertChapters</vh></v>
</v>
<v t="ekr.20060213023732.56"><vh>closing</vh>
<v t="ekr.20060213023732.57"><vh>newWrite_LEO_file</vh></v>
<v t="ekr.20060213023732.58"><vh>getMakeStringIO</vh></v>
<v t="ekr.20060213023732.59"><vh>writeChapters</vh></v>
<v t="ekr.20060213023732.60"><vh>zipChapters</vh></v>
</v>
</v>
<v t="ekr.20060213023732.61"><vh>decorated Leo functions</vh>
<v t="ekr.20060213023732.62"><vh>new_os_path_dirname</vh></v>
<v t="ekr.20060213023732.63"><vh>newendEditLabel</vh></v>
<v t="ekr.20060213023732.64"><vh>newselect</vh></v>
<v t="ekr.20060213023732.65"><vh>newTrashDelete</vh></v>
</v>
<v t="ekr.20060213023732.66"><vh>operation( node ) to Chapter</vh>
<v t="ekr.20060213023732.67"><vh>cloneToChapter</vh></v>
<v t="ekr.20060213023732.68"><vh>moveToChapter</vh></v>
<v t="ekr.20060213023732.69"><vh>copyToChapter</vh></v>
<v t="ekr.20060213023732.70"><vh>makeNodeIntoChapter</vh></v>
</v>
<v t="ekr.20060213023732.71"><vh>conversions</vh>
<v t="ekr.20060213023732.72"><vh>conversionToSimple</vh></v>
<v t="ekr.20060213023732.73"><vh>conversionToChapters</vh></v>
</v>
<v t="ekr.20060213023732.74"><vh>import/export</vh>
<v t="ekr.20060213023732.75"><vh>importLeoFile</vh></v>
<v t="ekr.20060213023732.76"><vh>exportLeoFile</vh></v>
</v>
<v t="ekr.20060213023732.77"><vh>functions without classification</vh>
<v t="ekr.20060213023732.78"><vh>swapChapters</vh></v>
<v t="ekr.20060213023732.79"><vh>emptyTrash</vh></v>
<v t="ekr.20060213023732.80"><vh>regexClone</vh></v>
</v>
<v t="ekr.20060213023732.81"><vh>PDF</vh>
<v t="ekr.20060213023732.82"><vh>doPDFConversion</vh>
<v t="ekr.20060213023732.83"><vh>&lt;&lt; define otherPages callback &gt;&gt;</vh></v>
</v>
<v t="ekr.20060213023732.84"><vh>_changeTreeToPDF</vh></v>
</v>
</v>
<v t="ekr.20060228072530"><vh>Chapters (jyLeo)</vh>
<v t="ekr.20060228072530.1"><vh>What are Chapters?</vh></v>
<v t="ekr.20060228072530.2"><vh>Things A Developer should know about Chapters</vh></v>
<v t="ekr.20060228072530.3"><vh>A Note about Chapters and Commanders</vh></v>
<v t="ekr.20060228072530.4"><vh>commander delegates</vh></v>
<v t="ekr.20060228072530.5"><vh>stateChanged</vh></v>
<v t="ekr.20060228072530.6"><vh>getChaptersIterator</vh></v>
<v t="ekr.20060228072530.7"><vh>markNodesForChapterization</vh></v>
<v t="ekr.20060228072530.8"><vh>utility</vh>
<v t="ekr.20060228072530.9"><vh>changeChaptersName</vh></v>
<v t="ekr.20060228072530.10"><vh>moveNodeToChapter</vh></v>
<v t="ekr.20060228072530.11"><vh>copyNodeToChapter</vh></v>
<v t="ekr.20060228072530.12"><vh>cloneNodeToChapter</vh></v>
<v t="ekr.20060228072530.13"><vh>testNode</vh></v>
<v t="ekr.20060228072530.14"><vh>swapChapters</vh></v>
<v t="ekr.20060228072530.15"><vh>mergeChapters</vh></v>
<v t="ekr.20060228072530.16"><vh>selectChapter</vh></v>
<v t="ekr.20060228072530.17"><vh>insertChapter</vh></v>
<v t="ekr.20060228072530.18"><vh>findChapterForNode</vh></v>
<v t="ekr.20060228072530.19"><vh>turnNodeIntoChapter</vh></v>
</v>
<v t="ekr.20060228072530.20"><vh>import and export</vh>
<v t="ekr.20060228072530.21"><vh>import outline</vh></v>
<v t="ekr.20060228072530.22"><vh>export outline</vh></v>
</v>
<v t="ekr.20060228072530.23"><vh>adding and removing chapters</vh>
<v t="ekr.20060228072530.24"><vh>addChapter</vh></v>
<v t="ekr.20060228072530.25"><vh>addChapterForSettingsTree</vh></v>
<v t="ekr.20060228072530.26"><vh>freshChapter</vh></v>
<v t="ekr.20060228072530.27"><vh>removeChapter</vh></v>
<v t="ekr.20060228072530.28"><vh>quietRemoveChapter</vh></v>
</v>
<v t="ekr.20060228072530.29"><vh>transforming an Outline into Chapers components</vh>
<v t="ekr.20060228072530.30"><vh>deferedChaperization</vh></v>
<v t="ekr.20060228072530.31"><vh>breakOutlineIntoChapters</vh></v>
</v>
<v t="ekr.20060228072530.32"><vh>class ChaptersPopup</vh>
<v t="ekr.20060228072530.33"><vh>mousePressed</vh></v>
<v t="ekr.20060228072530.34"><vh>class CopyNodeToChapter</vh></v>
<v t="ekr.20060228072530.35"><vh>class CloneNodeToChapter</vh></v>
<v t="ekr.20060228072530.36"><vh>class SwapChapters</vh></v>
<v t="ekr.20060228072530.37"><vh>class MergeChapters</vh></v>
</v>
<v t="ekr.20060228072530.38"><vh>Action Classes</vh>
<v t="ekr.20060228072530.39"><vh>DefAction</vh></v>
</v>
<v t="ekr.20060228072530.40"><vh>class ChapterModel</vh></v>
<v t="ekr.20060228072530.41"><vh>class Chapter</vh></v>
<v t="ekr.20060228072530.42"><vh>class SliderMessageButtons</vh></v>
<v t="ekr.20060228072530.43"><vh>IconCloser</vh></v>
<v t="ekr.20060228072530.44"><vh>iterators</vh>
<v t="ekr.20060228072530.45"><vh>chaptersIterator</vh></v>
<v t="ekr.20060228072530.46"><vh>topLevelSiblingsIterator</vh></v>
<v t="ekr.20060228072530.47"><vh>cycleThroughChapters</vh></v>
</v>
<v t="ekr.20060228072530.48"><vh>Undo</vh>
<v t="ekr.20060228072530.49"><vh>UndoRemoveChapter</vh></v>
<v t="ekr.20060228072530.50"><vh>UndoChangeChapterName</vh></v>
<v t="ekr.20060228072530.51"><vh>UndoAddChapter</vh></v>
<v t="ekr.20060228072530.52"><vh>UndoImport</vh></v>
<v t="ekr.20060228072530.53"><vh>UndoSwapChapters</vh></v>
</v>
<v t="ekr.20060228072530.54"><vh>(Important)</vh>
<v t="ekr.20060228072530.7"><vh>markNodesForChapterization</vh></v>
<v t="ekr.20060228072530.29"><vh>transforming an Outline into Chapers components</vh>
<v t="ekr.20060228072530.30"><vh>deferedChaperization</vh></v>
<v t="ekr.20060228072530.31"><vh>breakOutlineIntoChapters</vh></v>
</v>
</v>
</v>
<v t="ekr.20060228082602"><vh>No longer used</vh>
<v t="ekr.20060213023839.22"><vh>&lt;&lt; globals &gt;&gt;</vh></v>
<v t="ekr.20060213023839.36"><vh>makeNameMaker</vh></v>
</v>
</v>
<v t="ekr.20060228081628"><vh>To do</vh></v>
<v t="ekr.20060213023839.3"><vh>chapters2bad.py</vh>
<v t="ekr.20060213023839.8"><vh>Module level</vh>
<v t="ekr.20060213023839.4"><vh>&lt;&lt;docstring&gt;&gt;</vh></v>
<v t="ekr.20060213023839.5"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20060213023839.7"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060213023839.1"><vh>&lt;&lt; remember the originals for decorated methods &gt;&gt;</vh></v>
<v t="ekr.20060213023839.9"><vh>init</vh>
<v t="ekr.20060213023839.10"><vh>&lt;&lt; override various methods &gt;&gt;</vh></v>
</v>
<v t="ekr.20060228113912"><vh>afterCreate</vh></v>
<v t="ekr.20060213023839.11"><vh>decorated Leo functions</vh>
<v t="ekr.20060213023839.12"><vh>new_createCanvas (leoTkinterFrame)  (creates chapterControllers)</vh></v>
<v t="ekr.20060213023839.13"><vh>new_os_path_dirname (leoGlobals) (ok)</vh></v>
<v t="ekr.20060213023839.14"><vh>new_createControl (leoTkinterBody)</vh></v>
<v t="ekr.20060213023839.15"><vh>new_doDelete (position)</vh></v>
<v t="ekr.20060213023839.16"><vh>new_endEditLabel (leoTkinterTree)</vh></v>
<v t="ekr.20060213023839.17"><vh>new_getLeoFile (fileCommands)</vh></v>
<v t="ekr.20060213023839.18"><vh>new_open (fileCommands)</vh></v>
<v t="ekr.20060213023839.19"><vh>new_select (leoTkinterTree)</vh></v>
<v t="ekr.20060213023839.20"><vh>new_tree_init (leoTkinterTree</vh></v>
<v t="ekr.20060213023839.21"><vh>new_write_Leo_file</vh></v>
</v>
</v>
<v t="ekr.20060213023839.23"><vh>class Chapter</vh>
<v t="ekr.20060213023839.24"><vh>__init__ (Chapter)</vh></v>
<v t="ekr.20060213023839.25"><vh>_saveInfo</vh></v>
<v t="ekr.20060213023839.26"><vh>setVariables</vh></v>
<v t="ekr.20060213023839.27"><vh>makeCurrent</vh></v>
</v>
<v t="ekr.20060213023839.28"><vh>class chapterController</vh>
<v t="ekr.20060213023839.29"><vh>Birth...</vh>
<v t="ekr.20060213023839.30"><vh> ctor chapterController</vh></v>
<v t="ekr.20060213023839.31"><vh>addPage</vh></v>
<v t="ekr.20060213023839.32"><vh>constructTree</vh></v>
<v t="ekr.20060213023839.33"><vh>createBalloon</vh></v>
<v t="ekr.20060213023839.34"><vh>createNoteBook</vh></v>
<v t="ekr.20060213023839.35"><vh>createPanedWidget</vh></v>
<v t="ekr.20060213023839.37"><vh>newEditor</vh></v>
<v t="ekr.20060213023839.38"><vh>newEditorPane</vh></v>
<v t="ekr.20060228113912.1"><vh>finishCreate</vh></v>
</v>
<v t="ekr.20060228094838"><vh>Getters...</vh>
<v t="ekr.20060228094838.1"><vh>getChapter</vh></v>
<v t="ekr.20060213023839.79"><vh>getStringVar</vh></v>
<v t="ekr.20060228092227"><vh>nextPageNumber</vh></v>
</v>
<v t="ekr.20060213023839.39"><vh>Called from decorated functions</vh>
<v t="ekr.20060213023839.40"><vh>createCanvas</vh></v>
<v t="ekr.20060213023839.41"><vh>createControl</vh></v>
<v t="ekr.20060213023839.42"><vh>doDelete</vh></v>
<v t="ekr.20060213023839.43"><vh>endEditLabel</vh></v>
<v t="ekr.20060213023839.44"><vh>getLeoFile</vh></v>
<v t="ekr.20060213023839.45"><vh>select</vh></v>
<v t="ekr.20060213023839.46"><vh>open</vh></v>
<v t="ekr.20060213023839.47"><vh>treeInit</vh></v>
<v t="ekr.20060213023839.48"><vh>write_Leo_file &amp; helper</vh>
<v t="ekr.20060213023839.49"><vh>writeChapters</vh></v>
</v>
</v>
<v t="ekr.20060213023839.50"><vh>tab menu stuff</vh>
<v t="ekr.20060213023839.51"><vh>makeTabMenu</vh></v>
<v t="ekr.20060213023839.52"><vh>tab callbacks</vh>
<v t="ekr.20060213023839.53"><vh>addChapter</vh></v>
<v t="ekr.20060213023839.54"><vh>removeChapter &amp; helper</vh>
<v t="ekr.20060213023839.55"><vh>removeOneChapter</vh></v>
</v>
<v t="ekr.20060213023839.56"><vh>renameChapter</vh></v>
<v t="ekr.20060213023839.57"><vh>addTrashBarrel</vh></v>
<v t="ekr.20060213023839.58"><vh>setupMenu</vh></v>
<v t="ekr.20060213023839.59"><vh>importLeoFile</vh></v>
<v t="ekr.20060213023839.60"><vh>exportLeoFile</vh></v>
<v t="ekr.20060213023839.61"><vh>doPDFConversion &amp; helper</vh>
<v t="ekr.20060213023839.62"><vh>&lt;&lt; define otherPages callback &gt;&gt;</vh></v>
<v t="ekr.20060213023839.63"><vh>_changeTreeToPDF</vh></v>
</v>
</v>
</v>
<v t="ekr.20060213023839.64"><vh>Multi-Editor stuff</vh>
<v t="ekr.20060213023839.65"><vh>selectNodeForEditor</vh></v>
<v t="ekr.20060213023839.66"><vh>activateEditor</vh></v>
<v t="ekr.20060213023839.67"><vh>removeEditor</vh></v>
<v t="ekr.20060213023839.68"><vh>addHeading</vh></v>
</v>
<v t="ekr.20060213023839.69"><vh>Indexing</vh>
<v t="ekr.20060213023839.70"><vh>viewIndex</vh>
<v t="ekr.20060213023839.71"><vh>&lt;&lt; define scTo callback &gt;&gt;</vh></v>
</v>
<v t="ekr.20060213023839.72"><vh>buildIndex</vh>
<v t="ekr.20060213023839.73"><vh>&lt;&lt; def callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20060213023839.74"><vh>regexViewIndex</vh></v>
</v>
<v t="ekr.20060213023839.75"><vh>Chapter-Notebook ops</vh>
<v t="ekr.20060213023839.76"><vh>renumber</vh></v>
<v t="ekr.20060213023839.77"><vh>getGoodPage &amp; helper</vh>
<v t="ekr.20060213023839.78"><vh>checkChapterValidity</vh></v>
</v>
<v t="ekr.20060213023839.2"><vh>setTree</vh></v>
<v t="ekr.20060213023839.80"><vh>lowerPage</vh></v>
<v t="ekr.20060213023839.81"><vh>walkChapters</vh></v>
</v>
<v t="ekr.20060213023839.82"><vh>opening and closing</vh>
<v t="ekr.20060213023839.83"><vh>opening</vh>
<v t="ekr.20060213023839.84"><vh>openChaptersFile</vh></v>
<v t="ekr.20060213023839.85"><vh>insertChapters</vh></v>
</v>
<v t="ekr.20060213023839.86"><vh>closing</vh>
<v t="ekr.20060213023839.87"><vh>getMakeStringIO</vh></v>
<v t="ekr.20060213023839.88"><vh>zipChapters</vh></v>
</v>
</v>
<v t="ekr.20060213023839.89"><vh>operation( node ) to Chapter</vh>
<v t="ekr.20060213023839.90"><vh>cloneToChapter</vh></v>
<v t="ekr.20060213023839.91"><vh>moveToChapter</vh></v>
<v t="ekr.20060213023839.92"><vh>copyToChapter</vh></v>
<v t="ekr.20060213023839.93"><vh>makeNodeIntoChapter</vh></v>
</v>
<v t="ekr.20060213023839.94"><vh>Conversions</vh>
<v t="ekr.20060213023839.95"><vh>conversionToSimple</vh></v>
<v t="ekr.20060213023839.96"><vh>conversionToChapters</vh></v>
</v>
<v t="ekr.20060213023839.97"><vh>Misc</vh>
<v t="ekr.20060213023839.98"><vh>swapChapters</vh></v>
<v t="ekr.20060213023839.99"><vh>emptyTrash</vh></v>
<v t="ekr.20060213023839.100"><vh>regexClone</vh>
<v t="ekr.20060213023839.101"><vh>&lt;&lt; define cloneWalk callback &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060213023839.3" a="V"><vh>@thin chapters2.py</vh></v>
<v t="ekr.20060228123606"><vh>Recent</vh>
<v t="ekr.20060213023839.30"><vh> ctor chapterController</vh></v>
<v t="ekr.20060213023839.31"><vh>addPage</vh></v>
<v t="ekr.20060213023839.2"><vh>setTree</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20060213023732.1">&lt;&lt;docstring&gt;&gt;

# To do:  Find/Change does not appear to work.

@language python
@tabwidth -4

__version__ = "0.68"
&lt;&lt; version history &gt;&gt;
&lt;&lt; imports &gt;&gt;
&lt;&lt; globals &gt;&gt;

# Solve problems with string.atoi...
import string
string.atoi = int

@others
</t>
<t tx="ekr.20060213023732.2">'''This plugin creates separate outlines called "chapters" within a single .leo file.  Clones work between Chapters.

**Warning**: This plugin must be considered **buggy** and **unsafe**.  Use with extreme caution.

Requires Python Mega Widgets and Leo 4.2 or above.

Numbered tabs at the top of the body pane represent each chapter.  Right clicking the tab will show a popup menu containing commands.  These commands allow you to:
    
- insert and delete chapters.
- add names to chapters.
- split the body pane to create multiple "editors".
- create a "trash barrel that hold all deleted nodes.
- import and export outlines and chapters.
- create a pdf file from your chapters (requires reportlab toolkit at http://www.reportlab.org).
- and more...
 
Warnings:
    
- This plugin makes substantial changes to Leo's core.
- Outlines containing multiple chapters are stored as a zipped file that can only be read when this plugin has been enabled.
'''</t>
<t tx="ekr.20060213023732.3">@killcolor
@

v .2

1. Trash. If there is a Chapter in the Leo project called 'Trash' all deleted nodes are deposited there. Then when deleted in the 'Trash' chapter it is finally removed. There is an option to quickly add a Trash barrel in the menu.
2. Menu moved from Outline to being summoned by right clicking on a chapter tab or in the area of the tabs.
3. Swapping Chapters. Swap one Chapter for another one.
4. Conversion ops. Take one Outline and turn each node into a Chapter. The convers operation is also there, take each top level node in each Chapter and add it to one Chapter.
5. Import/Export. You are now able to load leo files as Chapters. This means, for example, that if you have 5 Outlines that you would like to bind together as one Leo file but keep their separateness you can now import those 5 Outlines into there own Chapters. You can also Export a single Chapter into it's own separate Leo file.
6. Search and Clone. This functionality is very similar to the Filtered Hoist concept. You decide which Chapter you want your search results to appear in and a dialog will pop up. You can enter simple text or a more complex regular expression and the function will search all the outlines and create a node with the results as children.
7. Editors now have headlines indicating what Chapters and what node are being worked on.

v .6 EKR: Based on version .5 by Leo User.

- Added g. before all functions in leoGlobals.py.
- Right clicking on Chapter tab crashes.

.61 fixed up a couple of spots.

.62 EKR: Restored conditional call to g.app.createTkGui(__file__) in startup code.

.63 EKR: Added long docstring.

.64 fixed cloneWalk and PDF Convertor.

.65 EKR: added new keyword args to newGetLeoFile and newOpen.
    - This is needed because of changes to the corresponding method's in Leo's core.

.66 EKR: use notebooks.get(c) throughout.
    - c may not exist during unit testing.  Not a complete fix, not tested!

.67 EKR:
    - Added 'silent' keywords to newGetLeoFile and newOpen.
.68 EKR:
    - Use 'c._xPosition. or c.nullPosition()' to init so that c._xPosition is never None.</t>
<t tx="ekr.20060213023732.4">import leoGlobals as g

import leoColor
import leoCommands
import leoFileCommands
import leoFrame
import leoNodes
import leoPlugins
import leoTkinterFrame
import leoTkinterMenu
import leoTkinterTree

Tk  = g.importExtension('Tkinter',pluginName=__name__,verbose=True)
Pmw = g.importExtension("Pmw",    pluginName=__name__,verbose=True)
   
from leoTkinterFrame import leoTkinterLog
from leoTkinterFrame import leoTkinterBody

import os
import string
import sys
import time
import zipfile</t>
<t tx="ekr.20060213023732.5">chapters = {}
notebooks = {}
frames = {}
iscStringIO = False
twidgets = {}
pbodies = {}

</t>
<t tx="ekr.20060213023732.6">def init ():

    if Pmw and not g.app.unitTesting: # Not for unit testing:  modifies core classes.
        if g.app.gui is None: 
            g.app.createTkGui(__file__)
    
        if g.app.gui.guiName() == "tkinter":
            &lt;&lt; override various methods &gt;&gt;
            g.plugin_signon( __name__ )</t>
<t tx="ekr.20060213023732.7">leoTkinterFrame.leoTkinterFrame.createCanvas = newCreateCanvas
leoTkinterFrame.leoTkinterBody.createControl = newCreateControl

leoTkinterTree.leoTkinterTree.select = newselect
leoTkinterTree.leoTkinterTree.endEditLabel = newendEditLabel
leoTkinterTree.leoTkinterTree.__init__ = newTreeinit

g.os_path_dirname = new_os_path_dirname

leoFileCommands.fileCommands.write_LEO_file = newWrite_LEO_file
leoFileCommands.fileCommands.write_Leo_file = newWrite_LEO_file
leoFileCommands.fileCommands.getLeoFile = newGetLeoFile
leoFileCommands.fileCommands.open = newOpen

if hasattr( leoNodes.vnode, 'doDelete' ):
    leoNodes.vnode.doDelete = newTrashDelete
else:
    leoNodes.position.doDelete = newTrashDelete</t>
<t tx="ekr.20060213023732.8">class Chapter:
    '''The fundamental abstraction in the Chapters plugin.
       It enables the tracking of Chapters tree information.'''
       
    @others</t>
<t tx="ekr.20060213023732.9">def __init__( self, c, tree, frame, canvas ):
        
    self.c = c
    self.tree = tree
    self.frame = frame
    self.canvas = canvas
    self.treeBar = frame.treeBar

    if hasattr( c, 'cChapter' ):
        tn = leoNodes.tnode( '', 'New Headline' )
        vn = leoNodes.vnode( c, tn )
        pos = leoNodes.position(c, vn, [] )
        self.cp = pos.copy()
        self.rp = pos.copy()
        self.tp = pos.copy()
    else:
        c.cChapter = self
        self.cp = c._currentPosition or c.nullPosition()
        self.tp = c._topPosition or c.nullPosition()
        self.rp = c._rootPosition or c.nullPosition()</t>
<t tx="ekr.20060213023732.10">def _saveInfo( self ):
    
    c = self.c

    self.cp = c._currentPosition or c.nullPosition()
    self.rp = c._rootPosition or c.nullPosition()
    self.tp = c._topPosition or c.nullPosition()</t>
<t tx="ekr.20060213023732.11">def setVariables( self ):
    
    c = self.c
    frame = self.frame
    frame.tree = self.tree
    frame.canvas = self.canvas
    frame.treeBar = self.treeBar
    c._currentPosition = self.cp
    c._rootPosition = self.rp
    c._topPosition = self.tp</t>
<t tx="ekr.20060213023732.12">def makeCurrent( self ):
    
    c = self.c
    c.cChapter._saveInfo()
    c.cChapter = self
    self.setVariables()
    c.redraw()
    self.canvas.update_idletasks()</t>
<t tx="ekr.20060213023732.13">@
This category deals with creating widgets and any support functions for doing so.
@c
@others</t>
<t tx="ekr.20060213023732.14">cControl = leoTkinterFrame.leoTkinterBody.createControl

def newCreateControl( self, frame, parentFrame  ):
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    if c not in pbodies:
        parentFrame = createPanedWidget( parentFrame, c )
    pbody = pbodies[ c ]
    l, r =addHeading( parentFrame )
    ctrl = cControl( self, frame , parentFrame ) 
    ctrl.bind( "&lt;FocusIn&gt;", lambda event, body = frame.body : getGoodPage( event, body ), '+' )
    i = 1.0 / len( pbody.panes() )
    for z in pbody.panes():
        pbody.configurepane( z , size = i )
    pbody.updatelayout()
    frame.body.l =l
    frame.body.r =r 
    frame.body.editorName = editorNames[ parentFrame ]
    if frame not in twidgets:
        twidgets[ frame ] = []
    twidgets[ frame ].append( frame.body )
    l.configure( textvariable = getSV(c, notebook.getcurselection()) )
    return ctrl
</t>
<t tx="ekr.20060213023732.15">def createPanedWidget( parentFrame, c ):
    #constructs a new panedwidget for a frame
    pbody = Pmw.PanedWidget( parentFrame , orient = 'horizontal' )
    pbody.pack( expand = 1 , fill = 'both')
    pbodies[ c ] = pbody
    parentFrame = newEditorPane( c )
    return parentFrame</t>
<t tx="ekr.20060213023732.16">editorNames = {}

def newEditorPane( c ):
    names = pbodies[ c ].panes()
    if names:
        name  = str( int(names[ -1 ]) + 1 )
    else:
        name = '1'
    zpane = pbodies[ c ].add( name )
    editorNames[ zpane ] = name
    return zpane
</t>
<t tx="ekr.20060213023732.17">def newCreateCanvas( self, parentFrame, createCanvas = leoTkinterFrame.leoTkinterFrame.createCanvas ):
    c = self.c
    
    if c not in frames:
        frames[ c ] = self
        notebook = createNoteBook( c, parentFrame )
    else:
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        
    pname = notebook.nameMaker.next()
    page = notebook.add( pname )
    indx = notebook.index( pname )
    tab = notebook.tab( indx )
    if indx == 0:
        tab.configure( background = 'grey', foreground = 'white' )
    canvas = createCanvas( self, page )
    
    hull = notebook.component( 'hull' )
    tab.bind( '&lt;Button-3&gt;' , lambda event : hull.tmenu.post( event.x_root , event.y_root ) )
    sv = Tk.StringVar()
    page.sv = sv
    createBalloon( tab, sv )
    canvas.name = pname
    
    # g.trace(repr(canvas.name),canvas)

    return canvas</t>
<t tx="ekr.20060213023732.18">def createBalloon( tab, sv ):
    #creates a balloon for a widget
    balloon = Pmw.Balloon( tab , initwait = 100 )
    balloon.bind( tab , '' )
    hull = balloon.component( 'hull' )
    def blockExpose( event ):
        if sv.get() == '':
             hull.withdraw()
    hull.bind( '&lt;Expose&gt;', blockExpose, '+' )
    balloon._label.configure( textvariable = sv )</t>
<t tx="ekr.20060213023732.19">def createNoteBook (c,parentFrame):

    #constructs a NoteBook widget for a frame
    notebooks [c] = notebook = Pmw.NoteBook(parentFrame,borderwidth=1,pagemargin=0)
    hull = notebook.component('hull')
    makeTabMenu(hull,notebook,c)
    notebook.configure(raisecommand=lambda name,notebook=notebook: setTree(c,name,notebook))
    notebook.configure(lowercommand=lambda name,notebook=notebook: lowerPage(name,notebook))
    notebook.pack(fill='both',expand=1)
    notebook.nameMaker = getNameMaker(notebook)
    return notebook</t>
<t tx="ekr.20060213023732.20">def getNameMaker( notebook ):
    #creates a numbering mechanism for tabs
    def nameMaker():
        i = 0
        while 1:
            if len( notebook.pagenames() ) == 0: i = 0
            i += 1
            yield str( i )
            
    return nameMaker()</t>
<t tx="ekr.20060213023732.21">def newTreeinit( self, c,frame,canvas, oinit = leoTkinterTree.leoTkinterTree.__init__ ):
    
    # g.trace(canvas)

    sv = getSV(c, canvas.name)
    oinit( self, c, frame, canvas )
    self.chapter = chapters[ sv ] = Chapter( c, self , frame, canvas )
</t>
<t tx="ekr.20060213023732.22">def constructTree( frame , notebook, name ):
    
    canvas = treeBar = tree = None
    if frame.canvas:
        canvas = frame.canvas
        treeBar = frame.treeBar
        tree = frame.tree
    sv = Tk.StringVar()
    sv.set( name )
    canvas = frame.createCanvas( None )
    frame.canvas =  canvas
    frame.tree = leoTkinterTree.leoTkinterTree( frame.c ,frame, frame.canvas)
    frame.tree.setColorFromConfig()
    indx = notebook.index( notebook.pagenames()[ -1 ] )
    tab = notebook.tab( indx )
    tnum = str( len( notebook.pagenames() ) ) 
    tab.configure( text = tnum )
    hull = notebook.component( 'hull' )
    tab.bind( '&lt;Button-3&gt;' , lambda event ,hull = hull: hull.tmenu.post( event.x_root , event.y_root ) )
    return tree , notebook.page( notebook.pagenames()[ - 1 ] )
</t>
<t tx="ekr.20060213023732.23">def addPage( c , name = None ):

    frame = frames[ c ]
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    if name == None : name = str( len( notebook.pagenames() ) + 1 )
    o_chapter = c.cChapter
    otree, page  = constructTree( frame, notebook, name )
    c.cChapter.makeCurrent()
    o_chapter.makeCurrent()
    return page
</t>
<t tx="ekr.20060213023732.24">def newEditor (c):

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    frame = frames [c]
    pbody = pbodies [c]
    zpane = newEditorPane(c)
    af = leoTkinterBody(frame,zpane)
    c.frame.bodyCtrl = af.bodyCtrl
    af.setFontFromConfig()
    af.createBindings(frame)
    af.bodyCtrl.focus_set()
    cname = notebook.getcurselection()
    af.l.configure(textvariable=getSV(c,cname))
    af.r.configure(text=c.currentVnode().headString())</t>
<t tx="ekr.20060213023732.25">@
Tab menu and factory functions for the tab menu creation process.
@c
@others</t>
<t tx="ekr.20060213023732.26">def makeTabMenu( widget, notebook, c ):
    #creates the Menu that appears
    tmenu = Tk.Menu( widget, tearoff = 0 )
    widget.bind( '&lt;Button-3&gt;' , lambda event : tmenu.post( event.x_root , event.y_root ) )
    widget.tmenu = tmenu
    tmenu.add_command( command = tmenu.unpost )
    tmenu.add_separator()
    ac = getAddChapter( c, notebook )
    tmenu.add_command( label = 'Add Chapter', command = ac )
    rmenu = Tk.Menu( tmenu , tearoff = 0 )    
    remove = getRemove( notebook, c, rmenu )
    rmenu.configure( postcommand = remove )        
    tmenu.add_cascade( menu = rmenu, label = "Remove Chapter" )
    rename = getRename(c, notebook )
    tmenu.add_command( label = "Add/Change Title" , command = rename )
    opmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( menu = opmenu , label = 'Node-Chapter Ops' )
    cmenu = Tk.Menu( opmenu, tearoff = 0 )
    movmenu = Tk.Menu( opmenu, tearoff = 0 )
    copymenu = Tk.Menu( opmenu, tearoff = 0 )
    swapmenu = Tk.Menu( opmenu, tearoff = 0 )
    searchmenu = Tk.Menu( opmenu, tearoff = 0 )
    opmenu.add_cascade( menu = cmenu, label = 'Clone To Chapter' )
    opmenu.add_cascade( menu = movmenu, label = 'Move To Chapter' )
    opmenu.add_cascade( menu = copymenu, label = 'Copy To Chapter' )
    opmenu.add_cascade( menu = swapmenu, label = 'Swap With Chapter' )
    opmenu.add_cascade( menu = searchmenu, label = 'Search and Clone To' )
    opmenu.add_command( label ="Make Node Into Chapter", command = lambda c=c:  makeNodeIntoChapter( c ) )
    mkTrash = getMakeTrash( notebook )
    opmenu.add_command( label = "Add Trash Barrel", command =
    lambda c = c : mkTrash( c ))
    opmenu.add_command( label = 'Empty Trash Barrel', command =
    lambda notebook = notebooks.get(c), c = c: emptyTrash( notebook, c ) )
    setupMenu = getSetupMenu( c, notebook )
    cmenu.configure(
        postcommand = lambda menu = cmenu, command = cloneToChapter : setupMenu( menu, command ) )
    movmenu.configure(
        postcommand = lambda menu = movmenu, command = moveToChapter : setupMenu( menu, command ) )
    copymenu.configure(
        postcommand = lambda menu = copymenu, command = copyToChapter : setupMenu( menu, command ) ) 
    swapmenu.configure( postcommand = 
    lambda menu = swapmenu, command = swapChapters : setupMenu( menu, command ) )
    searchmenu.configure( postcommand = lambda menu = searchmenu,
    command = regexClone: setupMenu( menu, command, all = True ) )
    edmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( label = "Editor", menu = edmenu )
    edmenu.add_command( label = "Add Editor" , command = lambda c =c : newEditor( c ) ) 
    edmenu.add_command( label = "Remove Editor", command = lambda c = c : removeEditor( c ) )
    conmenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( menu = conmenu, label = 'Conversion' )
    conmenu.add_command(
        label = "Convert To Simple Outline",
        command = lambda c =c : conversionToSimple( c ) )
    conmenu.add_command(
        label = "Convert Simple Outline into Chapters",
        command = lambda c= c : conversionToChapters( c ) )
    iemenu = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade(label = 'Import/Export', menu = iemenu )
    iemenu.add_command( label = "Import Leo File ", command = lambda c = c: importLeoFile(c ) )
    iemenu.add_command( label = "Export Chapter To Leo File", command = lambda c =c : exportLeoFile( c ) )
    indmen = Tk.Menu( tmenu, tearoff = 0 )
    tmenu.add_cascade( label = 'Index', menu = indmen )
    indmen.add_command( label = 'Make Index', command = lambda c =c : viewIndex( c ) )
    indmen.add_command( label = 'Make Regex Index', command = lambda c =c : regexViewIndex( c ) ) 
    try:
        import reportlab
        tmenu.add_command( label = 'Convert To PDF', command = lambda c = c: doPDFConversion( c ) )
    except Exception: 
        g.es( "no reportlab" )</t>
<t tx="ekr.20060213023732.27">@others</t>
<t tx="ekr.20060213023732.28">def getAddChapter( c , notebook ):
    #a function that makes a function to add chapters  
    def ac( c = c ):
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        cname = notebook.getcurselection()
        addPage( c )        
        renumber( notebook)
    
    return ac</t>
<t tx="ekr.20060213023732.29">def getRemove( notebook, c , rmenu ):
    #a function that makes a function to remove chapters
    def remove():
        rmenu.delete( 0 , Tk.END )
        pn = notebook.pagenames()
        for i, z in enumerate( pn ):
            i = i + 1
            def rmz( name = z):
                if len( notebook.pagenames() ) == 1: return
                sv = getSV(c, name )
                chapter = chapters[ sv ]
                tree = chapter.tree
                vnd = chapter.rp
                cvnd = c.cChapter.cp
                c.beginUpdate()
                otree = c.cChapter.tree
                c.frame.tree = tree
                if vnd:
                    v = vnd                    
                    nnd = vnd.next()
                    if nnd == None:
                        nnd = vnd.insertAfter()
                        vnd = None
                    v.doDelete( nnd )
                c.frame.tree = otree
                c.endUpdate()
                notebook.delete( name )
                if tree != otree:
                    c.selectPosition( cvnd )
                if tree == otree:
                    pnames = notebook.pagenames()
                    notebook.selectpage( pnames[ 0 ] )
                    c.selectPosition( c.currentPosition() )
                    c.beginUpdate()
                    c.endUpdate()
                renumber( notebook )
            rmenu.add_command( label = str( i ) , command = rmz )  
              
    return remove
</t>
<t tx="ekr.20060213023732.30">def getRename(c, notebook ):
    #a function that makes a function to rename chapters
    def rename( rnframes = {} ):
        name = notebook.getcurselection()
        frame = notebook.page( notebook.index( name ) )
        fr = frames[c]
        if not rnframes.has_key( frame ):
            f = rnframes[ frame ] = Tk.Frame( frame )
            e = Tk.Entry( f , background = 'white', textvariable = frame.sv )
            b = Tk.Button( f , text = "Close" ) 
            e.pack( side = 'left' )
            b.pack( side = 'right' )
            def change():
                f.pack_forget()
            b.configure( command = change )
        else:
            f = rnframes[ frame ]
            if f.winfo_viewable() : return None
        fr.canvas.pack_forget()
        f.pack( side = 'bottom' )
        fr.canvas.pack( fill = 'both', expand = 1 )

    return rename</t>
<t tx="ekr.20060213023732.31">def getMakeTrash (notebook):
    #a function that makes a function to add a trash chapters
    def mkTrash (c):
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing
        addPage(c,'Trash')
        pnames = notebook.pagenames()
        sv = getSV(c,pnames[-1])
        sv.set('Trash')
        renumber(notebook)

    return mkTrash
</t>
<t tx="ekr.20060213023732.32">def getSetupMenu( c, notebook ):
    #a function that makes a function to populate a menu
    def setupMenu( menu , command , all = False):
        menu.delete( 0 , Tk.END )
        current = notebook.getcurselection()
        for i, z in  enumerate( notebook.pagenames() ):
            i = i + 1
            if z == current and not all: continue
            menu.add_command( label = str( i ) , command = lambda c = c , name = z : command( c, name ) )
            
    return setupMenu</t>
<t tx="ekr.20060213023732.33">@others</t>
<t tx="ekr.20060213023732.34">def selectNodeForEditor( c, body ):
    #sets the node for the new editor
    if not hasattr( body, 'lastNode' ):
        body.lastNode = c.currentPosition()

    if body.lastNode == c.currentPosition(): return    
    elif body.lastNode.exists( c ):
        c.selectPosition( body.lastNode )
    else:
        c.selectPosition( c.rootPosition() )

    body.lastNode = c.currentPosition()    </t>
<t tx="ekr.20060213023732.35">def activateEditor( body ):
    #performs functions that brings editor on line
    body.r.configure( text = body.lastNode.headString() )
    ip = body.lastNode.t.insertSpot
    txt = body.lastNode.bodyString()
    body.deleteAllText()
    body.insertAtEnd( txt )
    if ip : body.setInsertionPoint( ip )
    body.colorizer.colorize( body.lastNode )
    body.bodyCtrl.update_idletasks()</t>
<t tx="ekr.20060213023732.36">def removeEditor( c ):
    pbody = pbodies[ c ]
    if len( pbody.panes() ) == 1: return None
    body = c.frame.body
    pbody.delete( body.editorName )
    pbody.updatelayout()
    panes = pbody.panes()
    twidgets[ c.frame ].remove( body )
    nBody = twidgets[ c.frame ][ 0 ] 
    nBody.bodyCtrl.focus_set()
    nBody.bodyCtrl.update_idletasks()
</t>
<t tx="ekr.20060213023732.37">def addHeading( pane ):
    f = Tk.Frame( pane )
    f.pack( side = 'top' )
    l = Tk.Label( f )
    l.pack( side = 'left' )
    r = Tk.Label( f )
    r.pack( side = 'right' )
    return l , r
</t>
<t tx="ekr.20060213023732.38">@
Indexing is complementary to find, it provides a gui Index of nodes.  In comparison to regular find which bounces you around the tree, you can preview the node before you go to it.
@c
@others
</t>
<t tx="ekr.20060213023732.39">def viewIndex( c , nodes = None, tle = '' ):
    if nodes == None:
        nodes = [ x for x in walkChapters( c, chapname = True ) ]
    def aN( a ):
        n = a[ 0 ].headString()
        return n, a[ 0 ], a[ 1 ]
    nodes = map( aN, nodes )
    nodes.sort()
    tl = Tk.Toplevel()
    import time    
    title = "%s Index of %s created at %s" % ( tle, c.frame.shortFileName(), time.ctime())
    tl.title( title )
    f = Tk.Frame( tl )
    f.pack( side = 'bottom' )
    l = Tk.Label( f, text = 'ScrollTo:' )
    e = Tk.Entry( f , bg = 'white', fg = 'blue')
    l.pack( side = 'left' )
    e.pack( side ='left' )
    b = Tk.Button( f, text = 'Close' )
    b.pack( side = 'left' )
    def rm( tl = tl ):
        tl.withdraw()
        tl.destroy()
    b.configure( command = rm )
    sve = Tk.StringVar()
    e.configure( textvariable = sve )
    ms = tl.maxsize()
    tl.geometry( '%sx%s+0+0' % (ms[ 0 ], (ms[ 1 ]/4 )*3 ))
    sc = Pmw.ScrolledCanvas( tl , vscrollmode = 'static', hscrollmode = 'static', 
    usehullsize = 1, borderframe = 1, hull_width = ms[ 0 ], hull_height = (ms[ 1 ]/4 )*3 )
    sc.pack()
    can = sc.interior()
    can.configure( background = 'white' )
    bal = Pmw.Balloon( can )
    
    tags = {}
    #ltag = None
    buildIndex( nodes , c, can, tl, bal, tags)            
    sc.resizescrollregion()
    def scTo( event , nodes = nodes, sve = sve , can = can , tags = tags):
        t = sve.get()
        if event.keysym == 'BackSpace':
            t = t[ : -1 ]
        else:
            t = t + event.char
        if t == '': return
        for z in nodes:
            if z[ 0 ].startswith( t ) and tags.has_key( z[ 1 ] ):
                tg = tags[ z[ 1 ] ]
                eh = can.bbox( ltag )[ 1 ]
                eh = (eh *1.0)/100
                bh = can.bbox( tg )[ 1 ]
                ncor = (bh/ eh) * .01 
                can.yview( 'moveto' , ncor)
                return

    e.bind( '&lt;Key&gt;', scTo )
    e.focus_set()
</t>
<t tx="ekr.20060213023732.40">def buildIndex( nodes , c , can, tl, bal, tags):

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    import tkFont
    f = tkFont.Font()
    f.configure( size = -20 )
    ltag = None
    for i,z in enumerate(nodes):
        tg = 'abc' + str( i ) 
        parent = z[ 1 ].parent()
        if parent: parent = parent.headString()
        else:
            parent = 'No Parent'
        sv = getSV(c, z[ 2 ] )
        if sv.get(): sv = ' - ' + sv.get()
        else: sv = ''
        
        tab = notebook.tab( z[ 2 ] )
        tv = tab.cget( 'text' )
        isClone = z[ 1 ].isCloned()
        if isClone:
            clone = ' (Clone) '
        else:
            clone =''
        txt = '%s  , parent: %s , chapter: %s%s%s' %( z[ 0 ], parent, tv, sv, clone)
        ltag = tags[ z[1] ] = can.create_text( 20, i * 20 + 20, text = txt, fill = 'blue', font = f , anchor = Tk.W, tag = tg )
        bs = z[ 1 ].bodyString()
        if bs.strip() != '':
            bal.tagbind( can, tg, bs)
        def goto( event, z = z , c = c, tl = tl):
            notebook = notebooks.get(c)
            if not notebook: return # For unit testing
            notebook.selectpage( z[ 2 ] )
            c.selectVnode( z[ 1 ] )
            c.frame.outerFrame.update_idletasks()
            c.frame.outerFrame.event_generate( '&lt;Button-1&gt;' )
            c.frame.bringToFront()
            return 'break'
        def colorRd( event , tg = ltag , can = can ):
            can.itemconfig( tg, fill = 'red' )
        def colorBl( event , tg = ltag , can = can ):
            can.itemconfig( tg, fill = 'blue' )
        can.tag_bind( tg, '&lt;Button-1&gt;', goto )
        can.tag_bind( tg, '&lt;Enter&gt;', colorRd, '+' )
        can.tag_bind( tg, '&lt;Leave&gt;', colorBl, '+' )    
</t>
<t tx="ekr.20060213023732.41">def regexViewIndex (c):

    def regexWalk (result,entry,widget):
        txt = entry.get()
        widget.deactivate()
        widget.destroy()
        if result == 'Cancel': return None
        nodes = [x for x in walkChapters(c,chapname=True)]
        import re
        regex = re.compile(txt)
        def search (nd,regex=regex):
            return regex.search(nd[0].bodyString())
        nodes = filter(search,nodes)
        viewIndex(c,nodes,'Regex( %s )' % txt)
        return

    sd = Pmw.PromptDialog(c.frame.top,
        title = 'Regex Index',
        buttons = ('Search','Cancel'),
        command = regexWalk,
    )
    entry = sd.component('entry')
    sd.configure(command=
        lambda result, entry = entry, widget = sd:
            regexWalk(result,entry,widget))
    sd.activate(geometry='centerscreenalways')</t>
<t tx="ekr.20060213023732.42">@others</t>
<t tx="ekr.20060213023732.43">def renumber( notebook ):
    pagenames = notebook.pagenames()
    for i , z in enumerate(pagenames):
        i = i +1
        tab = notebook.tab( z )
        tab.configure( text = str( i ) )
</t>
<t tx="ekr.20060213023732.44">def getGoodPage( event , body ):
    global focusing
    c = body.c 
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    body.frame.body = body
    body.frame.bodyCtrl = body.bodyCtrl
    if not hasattr( body, 'lastChapter' ):
        body.lastChapter = notebook.getcurselection()
    page = checkChapterValidity( body.lastChapter, c )
    if page != notebook.getcurselection():
        body.lastChapter = page
        notebook.selectpage( page )
    selectNodeForEditor( c, body )         
    activateEditor( body )</t>
<t tx="ekr.20060213023732.45">def checkChapterValidity( name , c):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    try:
        notebook.index( name )
    except:
        return notebook.getcurselection()            
    return name
</t>
<t tx="ekr.20060213023732.46">def getSV (c,name):

    '''return a Tk StrinVar that is a primary identifier.'''

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    index = notebook.index(name)
    page = notebook.page(index)
    return page.sv
</t>
<t tx="ekr.20060213023732.47">def setTree(c, name , notebook):
    
    if not c or not c.exists: return None
    pindex = notebook.index( name )
    page = notebook.page( pindex )
    if not hasattr( page, 'sv' ) : return None
    sv = page.sv
    chapter = chapters[ sv ]
    chapter.makeCurrent()
    frame = c.frame
    frame.body.lastChapter = name
    frame.body.lastNode = chapter.cp
    frame.body.l.configure( textvariable = sv )
    tab = notebook.tab( pindex )
    tab.configure( background = 'grey', foreground = 'white' )
    activateEditor( frame.body )
</t>
<t tx="ekr.20060213023732.48">def lowerPage( name, notebook):
    # a function that sets a lowered tabs color
    pindex = notebook.index( name )
    tab = notebook.tab( pindex )
    tab.configure( background = 'lightgrey', foreground = 'black' )</t>
<t tx="ekr.20060213023732.49">def walkChapters( c , ignorelist = [], chapname = False):
    # a generator that allows one to walk the chapters as one big tree
    if not c or not c.exists: return
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    for z in pagenames:
        sv = getSV(c, z)
        chapter = chapters[ sv ]
        v = chapter.rp
        while v:
            if chapname:
                if v not in ignorelist: yield v, z
            else:
                if v not in ignorelist:  yield v
            v = v.threadNext()
</t>
<t tx="ekr.20060213023732.50">@
This category is for opening and closing of Leo files.  We need to decorate and be tricky here, since a Chapters leo file is a zip file.  These functions are easy to break in my experience. :)
@c
@others</t>
<t tx="ekr.20060213023732.51">@others</t>
<t tx="ekr.20060213023732.52">old_getLeoFile = leoFileCommands.fileCommands.getLeoFile

def newGetLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    global iscStringIO

    if iscStringIO:
        def dontSetReadOnly (self,name,value):
            if name not in ('read_only','tnodesDict'):
                self.__dict__ [name] = value
        self.read_only = False
        self.__class__.__setattr__ = dontSetReadOnly

    rt = old_getLeoFile(self,fileName,readAtFileNodesFlag,silent)
    if iscStringIO:
        del self.__class__.__setattr__

    return rt</t>
<t tx="ekr.20060213023732.53">oldOpen = leoFileCommands.fileCommands.open

def newOpen( self,file,fileName,readAtFileNodesFlag=True,silent=False):

    global iscStringIO,stringIOCommander
    c = self.c
    
    if zipfile.is_zipfile( fileName ):
        iscStringIO = True
        stringIOCommander = c
        chapters = openChaptersFile( fileName )
        g.es( str( len( chapters ) ) + " Chapters To Read", color = 'blue' )
        insertChapters( chapters, c.frame, c )
        g.es( "Finished Reading Chapters", color = 'blue' )
        iscStringIO = False
        return True

    return oldOpen(self,file,fileName,readAtFileNodesFlag,silent)</t>
<t tx="ekr.20060213023732.54">def openChaptersFile( fileName ):
    zf = zipfile.ZipFile( fileName )
    import cStringIO
    file = cStringIO.StringIO()
    name = zf.namelist()
    csfiles = [ [], [] ]
    for x in name :
        zi = zf.getinfo( x )
        csfiles[ 0 ].append( zi.comment )
        cs = cStringIO.StringIO()
        csfiles[ 1 ].append( cs )           
        cs.write( zf.read( x ) )
        cs.seek( 0 )          
    zf.close()
    csfiles = zip( csfiles[ 0 ], csfiles[ 1 ] )
    return csfiles
</t>
<t tx="ekr.20060213023732.55">def insertChapters (chapters,frame,c):
     notebook = notebooks.get(c)
     if not notebook: return # For unit testing
     pagenames = notebook.pagenames()
     for num, tup in enumerate(chapters):
            x, y = tup
            if num &gt; 0:
                sv = addPage(c,x).sv
                notebook.nextpage()
                cselection = notebook.getcurselection()
            else:
                cselection = notebook.getcurselection()
                sv = getSV(c,cselection)
            sv.set(x)
            next = cselection
            setTree(c,next,notebook)
            frame.c.fileCommands.open(y,sv.get())
            if num == 0:
                flipto = cselection
     setTree(flipto,notebook,c)
     c.frame.canvas.update_idletasks()</t>
<t tx="ekr.20060213023732.56">@others</t>
<t tx="ekr.20060213023732.57">def newWrite_LEO_file( self,fileName,outlineOnlyFlag, singleChapter = False):
    
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    at = c.atFileCommands
    if len( pagenames ) &gt; 1 and not singleChapter:        
        chapList = []
        self.__class__.__setattr__ =  getMakeStringIO( chapList )
        rv = writeChapters( self, fileName, pagenames, c , outlineOnlyFlag )
        if rv:
            zipChapters( fileName, pagenames, c, chapList )
        del self.__class__.__setattr__         
    else:
        rv = olWrite_LEO_file( self, fileName, outlineOnlyFlag )

    return rv</t>
<t tx="ekr.20060213023732.58">def getMakeStringIO( chapList ):
    #insures data is put in a StringIO instance
    def makeStringIO( self, name, value , cList = chapList):
        if name == 'outputFile' and value != None:
            import StringIO
            cS = StringIO.StringIO()
            cS.close = lambda : None
            self.__dict__[ name ] = cS
            cList.append( cS )
        elif name == 'outputFile' and value == None:
            self.__dict__[ name ] = None
        else:
            self.__dict__[ name ] = value 
            
    return makeStringIO</t>
<t tx="ekr.20060213023732.59">def writeChapters( self, fileName, pagenames, c , outlineOnlyFlag):
    #goes over Chapters and puts info in StringIO instances
    for z in pagenames:
        sv = getSV(c,z )
        chapter = chapters[ sv ]
        chapter.setVariables()
        rv = olWrite_LEO_file( self, fileName, outlineOnlyFlag )    
    c.cChapter.setVariables()
    return rv</t>
<t tx="ekr.20060213023732.60">def zipChapters( fileName, pagenames, c, chapList ):
    #takes list of StringIO instances and zips them to a file
    zf = zipfile.ZipFile( fileName, 'w',  zipfile.ZIP_DEFLATED )
    for x ,fname in enumerate( pagenames ):
        sv = getSV(c, fname )
        zif = zipfile.ZipInfo( str( x ) )
        zif.comment = sv.get()
        zif.compress_type = zipfile.ZIP_DEFLATED
        chapList[ x ].seek( 0 )
        zf.writestr( zif ,chapList[ x ].read() )
    zf.close()</t>
<t tx="ekr.20060213023732.61">@
I prefer decorating Leo functions as opposed to patching them.  Patching them leads to long term incompatibilites with Leo and the plugin.  Though this happens anyway with code evolution/changes, this makes it worse.  Thats my experience with it. :)
@c
@others</t>
<t tx="ekr.20060213023732.62">old_os_pat_dirname = g.os_path_dirname

def new_os_path_dirname (path,encoding=None):
    
    global iscStringIO,stringIOCommander

    if iscStringIO:
        c = stringIOCommander
        return os.path.dirname(c.mFileName)
    else:
        return old_os_pat_dirname(path,encoding)</t>
<t tx="ekr.20060213023732.63">old_editLabel = leoTkinterTree.leoTkinterTree.endEditLabel

def newendEditLabel (self):

    c = self.c
    rv = old_editLabel(self)
    v = c.currentPosition()
    if v and hasattr(c.frame.body,'r'):
        hS = v.headString()
        if hS:
            c.frame.body.r.configure(text=v.headString())
    return rv</t>
<t tx="ekr.20060213023732.64">old_select = leoTkinterTree.leoTkinterTree.select

def newselect (self,v,updateBeadList=True):

    self.frame.body.lastNode = v
    notebook = notebooks.get(v.c)
    if not notebook: return # For unit testing
    self.frame.body.lastChapter = notebook.getcurselection()
    rv = old_select(self,v,updateBeadList)
    if hasattr(v.c.frame.body,'r'):
        v.c.frame.body.r.configure(text=v.headString())
    return rv</t>
<t tx="ekr.20060213023732.65">if hasattr(leoNodes.vnode,'doDelete'):
    olDelete = leoNodes.vnode.doDelete
else:
    olDelete = leoNodes.position.doDelete

def newTrashDelete (self,newVnode):
    c = self.c
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    pagenames = notebook.pagenames()
    pagenames = [getSV(c,x).get().upper() for x in pagenames]
    nbnam = notebook.getcurselection()
    if nbnam != None:
        name = getSV(c,notebook.getcurselection()).get().upper()
    else: name = 'TRASH'
    tsh = 'TRASH'
    if name != tsh and tsh in pagenames:
        index = pagenames.index(tsh)
        trchapter = chapters [getSV(c,index)]
        trashnode = trchapter.rp
        trchapter.setVariables()
        self.moveAfter(trashnode)
        c.cChapter.setVariables()
        c.selectVnode(newVnode)
        return self
    olDelete(self,newVnode)</t>
<t tx="ekr.20060213023732.66">@others</t>
<t tx="ekr.20060213023732.67">if hasattr( leoFileCommands.fileCommands, 'write_LEO_file' ):
    olWrite_LEO_file = leoFileCommands.fileCommands.write_LEO_file
else:
    olWrite_LEO_file = leoFileCommands.fileCommands.write_Leo_file
    

def cloneToChapter( c , name ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    c.beginUpdate()
    vnd = c.currentPosition()
    clo = vnd.clone( vnd )
    clChapter = chapters[ page.sv ]
    vndm = clChapter.cp
    clo.unlink()
    clo.linkAfter(vndm)
    c.endUpdate()
</t>
<t tx="ekr.20060213023732.68">def moveToChapter( c, name ):
    
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    mvChapter = chapters[ page.sv ]
    c.beginUpdate()
    vnd = c.currentVnode()
    if  not vnd.parent() and not vnd.back() :
        c.endUpdate()
        return None
    vndm = mvChapter.cp
    vnd.unlink()
    vnd.linkAfter(vndm)
    c.endUpdate()
    c.selectVnode( c.rootVnode() )

</t>
<t tx="ekr.20060213023732.69">def copyToChapter( c, name ):
    
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    page = notebook.page( notebook.index( name ) )
    cpChapter = chapters[ page.sv ]
    c.beginUpdate()
    s = c.fileCommands.putLeoOutline()
    v = c.fileCommands.getLeoOutline( s )
    cpChapter.setVariables()
    mvnd = cpChapter.cp
    v.moveAfter( mvnd )
    c.cChapter.setVariables()
    c.endUpdate()

</t>
<t tx="ekr.20060213023732.70">def makeNodeIntoChapter( c, vnd = None ):
    renum = vnd
    if vnd == None:
        vnd = c.currentPosition()
    if vnd == c.rootPosition() and vnd.next() == None:
        return
    nxt = vnd.next()
    if nxt:
        vnd.doDelete( nxt )
        
    page = addPage( c )
    mnChapter = chapters[ page.sv ]
    c.beginUpdate()
    oChapter = c.cChapter
    mnChapter.makeCurrent()
    root = mnChapter.rp
    vnd.moveAfter( root )
    c.setRootPosition( vnd )
    oChapter.makeCurrent()
    c.endUpdate()
    if not renum:
        notebook = notebooks.get(c)
        if notebook: # For unit testing
            renumber(notebook)
    c.selectPosition( oChapter.rp )
</t>
<t tx="ekr.20060213023732.71">@others</t>
<t tx="ekr.20060213023732.72">def conversionToSimple( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    vnd = c.rootPosition()
    while 1:
        n = vnd.next()
        if n == None:
            break
        else:
            vnd = n
    pagenames = notebook.pagenames()
    current = notebook.getcurselection()
    pagenames.remove( current )
    c.beginUpdate()
    for z in pagenames:
        index = notebook.index( z )
        page = notebook.page( index )
        chapter = chapters[ page.sv ]
        rvNode = chapter.rp
        while 1:
            nxt = rvNode.next()
            rvNode.moveAfter( vnd )
            if nxt: rvNode = nxt
            else:
                vnd = rvNode 
                break
        notebook.delete( z )
    c.endUpdate()
    renumber( notebook )       
</t>
<t tx="ekr.20060213023732.73">def conversionToChapters( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    vnd = c.rootPosition()
    while 1:
        nxt = vnd.next()
        if nxt:
            makeNodeIntoChapter(c , nxt )
        else:
            break
    setTree( notebook.pagenames()[ 0 ], notebook , c )     
</t>
<t tx="ekr.20060213023732.74">@
Import a Leo file as a Chapter(s).  Export a Chapter as a single Leo file.  Kinda handy.
@c
@others</t>
<t tx="ekr.20060213023732.75">def importLeoFile( c ):
    import tkFileDialog
    name = tkFileDialog.askopenfilename()
    if name:
        page = addPage( c , name )
        notebook = notebooks.get(c)
        if not notebook: return # For unit testing       
        notebook.selectpage( notebook.pagenames()[ - 1 ] )
        c.fileCommands.open( file( name, 'r' ), name )
        c.cChapter.makeCurrent()
        renumber( notebook )
</t>
<t tx="ekr.20060213023732.76">def exportLeoFile( c ):
    import tkFileDialog
    name = tkFileDialog.asksaveasfilename()
    if name:
        if not name.endswith('.leo' ):
            name += '.leo'
        c.fileCommands.write_LEO_file( name, False, singleChapter = True )
</t>
<t tx="ekr.20060213023732.77">@
couldn't think of any parent node to group these under.
@c
@others</t>
<t tx="ekr.20060213023732.78">def swapChapters( c, name ):

    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    cselection = notebook.getcurselection()
    tab1 = notebook.tab( cselection )
    tab2 = notebook.tab( name )
    tval1 = tab1.cget( 'text' )
    tval2 = tab2.cget( 'text' )
    tv1 = getSV(c, cselection)
    tv2 = getSV(c, name)
    chap1 = c.cChapter
    chap2 = chapters[ tv2 ]
    rp, tp, cp = chap2.rp, chap2.tp, chap2.cp
    chap2.rp, chap2.tp, chap2.cp = chap1.rp, chap1.tp, chap1.cp
    chap1.rp, chap1.tp, chap1.cp = rp, tp, cp
    chap1.setVariables()
    c.redraw()
    chap1.canvas.update_idletasks()
  
    val1 = tv1.get()
    val2 = tv2.get()
    if  val2.isdigit() :
        tv1.set( notebook.index( cselection ) + 1 ) 
    else: tv1.set( val2 )
    if val1.isdigit() :
        tv2.set( notebook.index( name ) + 1 )
    else: tv2.set( val1 )

</t>
<t tx="ekr.20060213023732.79">def emptyTrash( notebook  , c):
    pagenames = notebook.pagenames()
    pagenames = [ getSV(c, x) for x in pagenames ]
    for z in pagenames:
        if z.get().upper() == 'TRASH':
            trChapter = chapters[ z ]
            rvND = trChapter.rp
            c.beginUpdate()
            trChapter.setVariables()
            nRt = rvND.insertAfter()
            nRt.moveToRoot()
            trChapter.rp = c.rootPosition()
            trChapter.cp = c.currentPosition()
            trChapter.tp = c.topPosition()
            c.cChapter.setVariables()
            c.endUpdate( False )
            if c.cChapter == trChapter:
                c.selectPosition( nRt )
                c.redraw()
                trChapter.canvas.update_idletasks()
            return
</t>
<t tx="ekr.20060213023732.80">def regexClone (c,name):
    if not c or not c.exists: return
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    sv = getSV(c,name)
    chapter = chapters [sv]

    def cloneWalk (result,entry,widget,c=c):
        txt = entry.get()
        widget.deactivate()
        widget.destroy()
        if result == 'Cancel': return None
        import re
        regex = re.compile(txt)
        rt = chapter.cp
        chapter.setVariables()
        stnode = leoNodes.tnode('',txt)
        snode = leoNodes.vnode(c,stnode)
        snode = leoNodes.position(c,snode,[])
        snode.moveAfter(rt)
        ignorelist = [snode]
        it = walkChapters(c,ignorelist=ignorelist)
        for z in it:
            f = regex.search(z.bodyString())
            if f:
                clone = z.clone(z)
                i = snode.numberOfChildren()
                clone.moveToNthChildOf(snode,i)
                ignorelist.append(clone)

        c.cChapter.setVariables()
        notebook.selectpage(name)
        c.selectVnode(snode)
        snode.expand()
        c.beginUpdate()
        c.endUpdate()

    sd = Pmw.PromptDialog(c.frame.top,
        title = 'Search and Clone',
        buttons = ('Search','Cancel'),
        command = cloneWalk,
    )
    entry = sd.component('entry')
    sd.configure(command=
        lambda result, entry = entry, widget = sd:
            cloneWalk(result,entry,widget))
    sd.activate(geometry='centerscreenalways')</t>
<t tx="ekr.20060213023732.81"># Requires reportlab toolkit at http://www.reportlab.org

@others</t>
<t tx="ekr.20060213023732.82">def doPDFConversion( c ):
    notebook = notebooks.get(c)
    if not notebook: return # For unit testing
    import cStringIO
    from reportlab.platypus import SimpleDocTemplate,  Paragraph , Spacer 
    from reportlab.lib.styles import getSampleStyleSheet 
    from reportlab.lib.units import inch
    from reportlab.rl_config import defaultPageSize
    PAGE_HEIGHT = defaultPageSize[ 1 ]
    PAGE_WIDTH = defaultPageSize[ 0 ]
    maxlen = 100
    styles = getSampleStyleSheet()
    pinfo = c.frame.shortFileName()
    pinfo1 = pinfo.rstrip( '.leo' )
    cs = cStringIO.StringIO()
    doc = SimpleDocTemplate( cs , showBoundary = 1)
    Story = [Spacer(1,2*inch)] 
    pagenames = notebook.pagenames()   
    cChapter = c.cChapter
    for n,z in enumerate( pagenames ):
        
        n = n + 1
        sv = getSV(c, z)
        chapter = chapters[ sv ]
        chapter.setVariables()
        p = chapter.rp
        if p:
            _changeTreeToPDF( sv.get(), n, p , c, Story, styles, maxlen)
    &lt;&lt; define otherPages callback &gt;&gt;
    cChapter.setVariables()# This sets the nodes back to the cChapter, if we didnt the makeCurrent would point to the wrong positions
    cChapter.makeCurrent()
    doc.build(Story,  onLaterPages = otherPages)
    f = open( '%s.pdf' % pinfo1, 'w' )
    cs.seek( 0 )
    f.write( cs.read() )
    f.close()
    cs.close()</t>
<t tx="ekr.20060213023732.83">def otherPages( canvas, doc , pageinfo = pinfo):

    canvas.saveState()
    canvas.setFont('Times-Roman',9) 
    canvas.drawString(inch, 0.75 * inch, "Page %d %s" % (doc.page, pageinfo)) 
    canvas.restoreState()</t>
<t tx="ekr.20060213023732.84">def _changeTreeToPDF( name, num, p, c, Story, styles , maxlen):
    
    import copy
    from reportlab.platypus import SimpleDocTemplate,  Paragraph , Spacer, PageBreak, XPreformatted
    from reportlab.lib.units import inch
    from reportlab.rl_config import defaultPageSize
    enc = c.importCommands.encoding
    hstyle = styles[ 'title' ]
    Story.append( Paragraph( 'Chapter %s: %s' % ( num, name), hstyle ) )
    style = styles[ 'Normal' ]
    g.trace(p)
    for v in p.allNodes_iter(): #self_and_subtree_iter doesn't seem to work here????  Switched to allNodes_iter
    # while v:
        head = v.moreHead( 0 )
        head = g.toEncodedString(head,enc,reportErrors=True) 
        s = head +'\n'
        body = v.moreBody() # Inserts escapes.
        if len(body) &gt; 0:
            body = g.toEncodedString(body,enc, reportErrors=True)
            s = s + body
            s = s.split( '\n' )
            s2 = []
            for z in s:
                if len( z ) &lt; maxlen:
                    s2.append( z )
                else:
                    while 1:
                        s2.append( z[ : maxlen ] )
                        if len( z[ maxlen: ] ) &gt; maxlen:
                            z = z[ maxlen: ]
                        else:
                            s2.append( z[ maxlen: ] )
                            break
            s = '\n'.join( s2 )
            s = s.replace( '&amp;' ,'&amp;amp;' )
            s = s.replace( '&lt;', '&amp;lt;' )
            s = s.replace( '&gt;', '&amp;gt;' )
            s = s.replace( '"', '&amp;quot;' )
            s = s.replace( "`", '&amp;apos;' )
            Story.append( XPreformatted( s, style ) )
            Story.append( Spacer( 1, 0.2 * inch ) )
        #v = v.threadNext() 
    Story.append( PageBreak() )</t>
<t tx="ekr.20060213023839.2">def setTree (self,name):

    c = self.c ; nb = self.nb
    pindex = nb.index(name)
    page = nb.page(pindex)
    if not hasattr(page,'sv'):
        # The page hasn't been fully created yet.
        g.trace('******* no sv attr for page',g.callers(),color='red')
        return None
    ###sv = page.sv
    ###chapter = self.chapters [sv]
    chapter = self.getChapter(name)
    chapter.makeCurrent()
    frame = c.frame
    frame.body.lastChapter = name
    frame.body.lastPosition = chapter.cp
    frame.body.l.configure(textvariable=sv)
    tab = nb.tab(pindex)
    tab.configure(background='grey',foreground='white')
    self.activateEditor(frame.body)</t>
<t tx="ekr.20060213023839.22">chapters = {}
editorNames = {}
frames = {}
iscStringIO = False
notebooks = {}
pbodies = {}
twidgets = {}</t>
<t tx="ekr.20060213023839.30">def __init__ (self,c,frame,parentFrame):
    
    self.c = c
    self.frame = frame
    self.parentFrame = parentFrame

    self.chapters = {} # Keys are tab names, (no longer stringVars.)
    self.editorNames = {}
    
    self.pbodies = {}
    self.rnframes = {}
    self.twidgets = {}
    

    self.createNoteBook(parentFrame) # sets self.nb</t>
<t tx="ekr.20060213023839.31">def addPage (self,pageName=None):

    c = self.c ### ; frame = self.frame ; nb = self.nb

    ###name = name or str(len(nb.pagenames())+1)
    if not pageName: pageName = self.nextPageName()
    self.nb.add(pageName)
    ####tab = nb.tab(pageName)
    o_chapter = c.cChapter
    g.trace(pageName)
    otree, page = self.constructTree(self.frame,pageName)
    c.cChapter.makeCurrent()
    o_chapter.makeCurrent()
    return page,pageName
</t>
<t tx="ekr.20060213023839.36">def makeNameMaker (self):

    '''Create a numbering mechanism for tabs.'''

    def nameMaker ():
        i = 0
        while 1:
            if len(self.nb.pagenames())== 0: i = 0
            i += 1
            yield str(i)

    return nameMaker()</t>
<t tx="ekr.20060228072530">@ignore

from __future__ import generators
import java
import java.awt as awt
import java.awt.event as aevent
import javax.swing as swing
import javax.swing.event as sevent
import javax.swing.tree as stree
import java.util.concurrent.locks as locks
import leoNodes
import leoGlobals as g
import leoSwingUndo
import javax.swing.undo as undo
from utilities.DefCallable import DefCallable
from utilities.Phaser import Phaser
from utilities.Slider import Slider
from leoSwingFrame import leoSwingTree


class Chapters( sevent.ChangeListener ):
    
    def __init__( self, c ):
        
        self.c = c
        self.book = None
        path = g.os_path_join( g.app.loadDir,"..","Icons", "x.png" )
        self.icon = swing.ImageIcon( path )
        self.popup = self.ChaptersPopup( self )
        self.chapters = {}
        self.trees_chapters = {}
        self.current_chapter = self.Chapter()
        self.chapterlist = []
        #let's skip adding the first chapter
        #self.chapterlist.append( self.current_chapter )
        self.current_chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
        self.updateLock = locks.ReentrantLock() #this increase by 1 for each lock call. -1 for each unlock.  If it becomes 0, the lock is released
        self.chaptersIterationBlocked = 0
        self.chaptersundoer = undo.UndoManager()
        self.chaptersPromptingForRemove = False
        
    
    def getChapter( self ):
        return self.current_chapter
    
    def startPromptingForRemove( self ):
        self.chaptersPromptingForRemove = True
        
    def stopPromptingForRemove( self ):
        self.chaptersPromptingForRemove = False
    
    def isPromptingForRemove( self ):
        return self.chaptersPromptingForRemove
    
    
    
    def disablePopup( self ):
        self.popup.disable()
        
    def enablePopup( self ):
        self.popup.enable()
    
    def beginUpdate( self ):
        self.updateLock.lock()
        
    def endUpdate( self ):
        self.updateLock.unlock()
    
    def getWidget( self ):
        if self.book is None:
            # We defer creating until here because otherwise the book variable might miss a L&amp;amp;F change
            self.book = swing.JTabbedPane()
            self.book.addMouseListener( self.popup )
            ssm = self.book.getModel()
            ssm.addChangeListener( self )
        return self.book
        
    def getSelectedChapter( self ):
        return self.current_chapter
    
    def getSelectedChapterWidget( self ):
        
        return self.book.getSelectedComponent()
    
    @others
    

</t>
<t tx="ekr.20060228072530.1">@
Chapters simply put are multiple Outlines within the Leo instance.  The definition doesn't stop there though since having more than one Outline defines an interaction model between these Outlines.  It is better to think of it like so:
    An Outline is composed of at least 1 Chapter.
    A writen Outline with multiple Chapters should be indistinguishable from an Outline with one Chapter.  The only mark is that the roots will have a uA marking them as belonging to a specific Chapter.
    So at read time, the Outline is read in then broken into its separate Chapters.
    At write time, the Outline is reconstituted as one Outline during output.  The reunification is only realised on disk.  Internally we use magic unfication iterators that give the write process a sense that it is writing one outline.  These special iterators mean that there is a low impact upon the write code.  Much of it has stayed the same except that it now uses a different iterator.
</t>
<t tx="ekr.20060228072530.2">@
Observation 1: Do not start a beginUpdate in one chapter and finish it with a endUpdate in another chapter.  You will lose your ability to work with the outline/chapter where the beginUpdate started.  I have seen this happen, so let this be a warning to you.  I guess a protective fix against this would be to keep track of which chapter an endUpdate belongs to.  Hence doing a beginUpdate in one chapter followed by and endUpdate in another chapter would target the first chapter.  Im unsure if this would work, but it is a thought that may make the implementation more robust.

Observation 2: root positions should not become stale.  Since we aggresively copy everytime the root or current position is asked for from the chapter, the main copy should never change unless it is explicitly set.

Observation 3: Sliders and Phasers work better than dialogs with Chapters.  Ive found it disruptive when working with Chapters to suddenly have a dialog pop up grabbing my attention away from the Chapter Im working on.  Hence Ive moved informational and querying of the user primarily to Sliders.  Not only does it attach a question or notification to a Chapter better it also is very nice animation to observe.  Keeping our focus on the Chapter in question is essential!

Observation 4: We use the doHook mechanism to notify listeners that the current chapter has changed.  This makes it easy to monitor the changing of chapters, but the devloper must ensure that the chapter belongs to the chapters instance he is interested in.  Hence the commander is passed in as well.  If you are interested in the a specific Chapters instance the Commander should be enough to discern which chapters the chapter belongs to.  See the Node "A Note about Chapters and Commanders".

</t>
<t tx="ekr.20060228072530.3">@

Chapters Swing takes the lessons learned from past Chapters plugins and simplifies the implementation by making the Chapters instance the provider of the root, current and top positions.  The Command is no longer in charge of this and will delegate the:
    getCurrentPosition() # or is it c.currentPosition()? :D
    getTopPosition()
    getRootPosition()

to the Chapters instance.  Each Commander now has a Chapters instance upon instantiation.

Also setting the variables will be delegated to the Chapters instance, which in turn delegates to a Chapter instance.

Hence we can keep the Commander interface and just restructure the internals and Chapters are now available.</t>
<t tx="ekr.20060228072530.4">def setRootPosition( self, p ):
    
    #if self.loading: return
    if p:
        p = p.copy()
    if self.current_chapter:
        self.current_chapter.setRootPosition( p )
    #self.roots[ self.current_chapter ] = p


def getRootPosition( self ):
    
    #if self.loading: return
    if self.current_chapter:
        return self.current_chapter.getRootPosition()
    return None   
    #return self.roots[ self.current_chapter ].copy()
    #rv = self.roots.get( self.current_chapter, None )
    #if rv: rv = rv.copy()
    #return rv
    
    
def setCurrentPosition( self, p ):
    
    #if self.loading: return    
    if p:
        p = p.copy()
    if self.current_chapter:
        self.current_chapter.setCurrentPosition( p )   
    #self.currentPositions[ self.current_chapter ] = p
        
    
def getCurrentPosition( self ):
    
    #if self.loading: return
    if self.current_chapter:
        return self.current_chapter.getCurrentPosition()
    return None
        
    #return self.currentPositions[ self.current_chapter ].copy()
    #rv = self.currentPositions.get( self.current_chapter, None )
    #if rv: rv = rv.copy()
    #return rv</t>
<t tx="ekr.20060228072530.5">def stateChanged( self, event ):
    
    c = self.c
    try:
        self.beginUpdate()
        index = self.book.getSelectedIndex()
        component = self.book.getComponentAt( index )
        chapter = self.chapters[ component ]
        c.frame.tree = chapter.tree
        self.current_chapter = chapter
        #chapter.tree.jtree.treeDidChange()
        c.beginUpdate()
        c.endUpdate()
        #c.selectPosition( chapter.getCurrentPosition() )
        self.current_chapter.undoer.setMenu( forceupdate = 1 )
        g.doHook( "chapter-changed", c = self.c, chapter = chapter )
    finally:
        self.endUpdate()
        
    #if chapter.root:
    #    chapter.root.linkAsRoot( None )

@   
    oldchapter = self.current_chapter
    index = self.book.getSelectedIndex()
    title = self.book.getTitleAt( index )
    self.current_chapter = title
    nwroot = self.chapters[ title ]
    oldroot = self.c.rootPosition().copy()
    self.chapters[ oldchapter ] = oldroot
    c.beginUpdate()
    c.setRootPosition( nwroot.copy() )
    c.endUpdate()


</t>
<t tx="ekr.20060228072530.6">def iterateOverChapters( self ):
    
    for x in self.chaptersIterator():
        print x
        
    

</t>
<t tx="ekr.20060228072530.7">def markNodesForChapterization( self ):

    if not self.chaptersIterationBlocked:    
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for n in xrange( len(self.chapterlist)):
            chapter = self.chapterlist[ n ]
            rp = chapter.getRootPosition()
            rp_base = rp.copy()
            for z in rp.self_and_siblings_iter( copy = True ):
                v = z.v
                if not hasattr( v, "unknownAttributes" ):
                    v.unknownAttributes = {}
                v.unknownAttributes[ 'chapter' ] = n
                if z == rp_base:
                    v.unknownAttributes[ 'chapter_name' ] = chapter.name
    else:
        rp = self.getRootPosition()
        rp_base = rp.copy()
        for z in rp.self_and_siblings_iter( copy = True ):
            v = z.v
            if not hasattr( v, "unknownAttributs" ):
                v.unknownAttributes = {}
            v.unknownAttributes[ 'chapter' ] = 0
            if z == rp_base:
                v.unknownAttributes[ 'chapter_name' ] = self.current_chapter.name</t>
<t tx="ekr.20060228072530.8" />
<t tx="551a7a6f7263616e6461212e32303035303932353136303131382e3171002e">def changeChaptersName( self ):
       
    chapter = self.current_chapter
    if chapter.isMessaging(): return
    chapter.startMessaging()
    jp = swing.JPanel( java.awt.BorderLayout() )
    slider = Slider( jp, direction = Slider.down )
    #phaser = Phaser( jp )
    nlabel = swing.JLabel( "Chapter Name:" )
    jp.add( nlabel, java.awt.BorderLayout.NORTH )
    jtf = swing.JTextField()
    slider.setComponentToFocus( jtf )
    #phaser.setComponentToFocus( jtf )
    jtf.setText( str( chapter.name ) )
    jp.add( jtf )
    top = self.c.frame.top
    def closeAndChange():
        chapter.doneMessaging()
        nw_name = jtf.getText()
        book = self.book
        index = book.getSelectedIndex()
        old_name= book.getTitleAt( index ) 
        book.setTitleAt( index, nw_name )
        self.chaptersundoer.addEdit( self.UndoChangeChapterName( self, chapter, old_name, nw_name ) )
        chapter.name = nw_name
        slider.startRemoving()
        #phaser.phaseRemove()
    
    class aa( swing.AbstractAction ):
        def __init__( self, *args ):
            swing.AbstractAction.__init__( self, *args )
        
        def actionPerformed( self, ae ):
            closeAndChange()
    ks = swing.KeyStroke.getKeyStroke( "ENTER" )
    if ks:
        am = jtf.getActionMap()
        im = jtf.getInputMap()
        im.put( ks, "enter" )
        am.put( "enter", aa() )
    jp2 = swing.JPanel() 
    jb = swing.JButton( "Ok" )
    jb.actionPerformed = lambda event : closeAndChange()
    jp2.add( jb )
    jp.add( jp2, java.awt.BorderLayout.SOUTH )
    tree = self.c.frame.tree
    jtree = tree.jtree
    bg = jtree.getBackground()
    fg = jtree.getForeground()
    jp.setBackground( bg )
    jp.setForeground( fg )
    nlabel.setForeground( fg )
    jp2.setBackground( bg )
    jp2.setForeground( fg )
    lb = swing.border.LineBorder( fg )
    jp.setBorder( lb )
    main_widget = tree.getWidget()
    vrect = tree.jspane.getViewportBorderBounds()
    height = slider.getPreferredSize().height
    #height = phaser.getPreferredSize().height
    vrect.height = height
    slider.setBounds( vrect )
    #phaser.setBounds( vrect )
    gp = main_widget.getGlassPane()
    gp.setVisible( True )
    gp.add( slider )
    #gp.add( phaser )



</t>
<t tx="ekr.20060228072530.9"></t>
<t tx="ekr.20060228072530.10">def moveNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
        
    if cpos.isRoot():
        testroot = cpos.copy()
        testroot.moveToNext()
        if not testroot:
            return
    
    parent = cpos.getParent()    
    if parent:
        ok =  c.checkMoveWithParentWithWarning( pos.copy(), parent, True )
    else:
        ok = 1
        
    if not ok:
        return
    
    try:    
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        pos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        pos.linkAfter( cpos )
        c.endUpdate()
    

        self.current_chapter = current
        c.frame.tree = current.tree
    finally:
        self.endUpdate()

</t>
<t tx="ekr.20060228072530.11">def copyNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
    
    nwpos = pos.copyTreeAfter()    
    #if cpos.isRoot():
    #    testroot = cpos.copy()
    #    testroot.moveToNext()
    #    if not testroot:
    #        return
    
    #parent = cpos.getParent()    
    #if parent:
    #    ok =  c.checkMoveWithParentWithWarning( pos.copy(), parent, True )
    #else:
    #    ok = 1
        
    #if not ok:
    #    return
    try:
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        nwpos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        nwpos.linkAfter( cpos )
        undo = leoSwingUndo.UndoableInsertNode( self.c, [ "Insert Node", nwpos.copy(), ], {} )
        chapter.undoer.addUndo( undo )
        c.endUpdate()
        self.current_chapter = current
        c.frame.tree = current.tree
        current.undoer.setMenu( forceupdate = 1 )
    finally:
        self.endUpdate()
</t>
<t tx="ekr.20060228072530.12">def cloneNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
    
    nwpos = pos.clone( pos.copy() )
        
    #if cpos.isRoot():
    #    testroot = cpos.copy()
    #    testroot.moveToNext()
    #    if not testroot:
    #        return
    
    parent = cpos.getParent()    
    if parent:
        ok =  c.checkMoveWithParentWithWarning( nwpos.copy(), parent, True )
    else:
        ok = 1
        
    if not ok:
        nwpos.unlink()
        c.beginUpdate()
        c.endUpdate()
        return
    
    try:
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        nwpos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        nwpos.linkAfter( cpos )
        undo = leoSwingUndo.UndoableInsertNode( self.c, [ "Insert Node", nwpos.copy(), ], {} )
        chapter.undoer.addUndo( undo )
    finally:
        c.endUpdate()
    

    self.current_chapter = current
    c.frame.tree = current.tree
    self.endUpdate()
    current.undoer.setMenu( forceupdate = 1 )</t>
<t tx="ekr.20060228072530.13">def testNode( self ):
    
    chapter = self.current_chapter
    pos = chapter.getCurrentPosition()
    
    print pos
    for ancestor in pos.self_and_parents_iter(): #copy = 1):
        print ancestor, ancestor.isCloned()</t>
<t tx="ekr.20060228072530.14">def swapChapters( self, chapter1, chapter2, undo = True ):

    try:    
        self.beginUpdate()
        widget1 = chapter1.tree.getWidget()
        widget2 = chapter2.tree.getWidget()
        index1 = self.book.indexOfComponent( widget1 )
        index2 = self.book.indexOfComponent( widget2 )
        jp = swing.JPanel() #place holder, keeps order
        self.book.setComponentAt( index1, jp )
        self.book.setComponentAt( index2, widget1 )
        self.book.setComponentAt( index1, widget2 )
        self.book.setTitleAt( index1, chapter2.name )
        self.book.setTitleAt( index2, chapter1.name )
        i1 = self.chapterlist.index( chapter1 )
        i2 = self.chapterlist.index( chapter2 )
        self.chapterlist[ i1 ] = chapter2
        self.chapterlist[ i2 ] = chapter1
        self.current_chapter = chapter2
        self.c.frame.tree = chapter2.tree
        self.c.beginUpdate()
        self.c.endUpdate()
        if undo:
            self.chaptersundoer.addEdit( self.UndoSwapChapters( self, chapter1, chapter2 )) 
    finally:
        self.endUpdate()
    
    </t>
<t tx="ekr.20060228072530.15">def mergeChapters( self, chapter1, chapter2 ):

	try:    
        self.beginUpdate()
    
        rp = chapter2.getRootPosition()
        nodes = []
        for z in rp.self_and_siblings_iter( copy = True ):
            nodes.append( z )
    
        for z in nodes:
            z.unlink()
        
        rp2 = chapter1.getRootPosition()
        for z in rp2.self_and_siblings_iter( copy = True ):
            pass   
        base = z.copy()

    
        self.c.beginUpdate()
    
        for z in nodes:
            z.linkAfter( base )
            base = z.copy()
        
        self.quietRemoveChapter( chapter2 )
        self.c.endUpdate()    
    finally:
        self.endUpdate()</t>
<t tx="ekr.20060228072530.16">def selectChapter( self, chapter ):
    
    widget = chapter.tree.getWidget()
    index = self.book.indexOfComponent( widget )
    if index != -1:
        self.book.setSelectedComponent( widget )
    </t>
<t tx="ekr.20060228072530.17">def insertChapter( self, chapter ):
    
    self.chapterlist.append( chapter )
    tree = chapter.tree 
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()   
    self.chapters[ widget ] = chapter
    ic = self.IconCloser( self.icon, self.removeChapter )
    self.book.addTab( chapter.name, ic, widget )

</t>
<t tx="ekr.20060228072530.18">def findChapterForNode( self, p ):
    
    for n in xrange( self.book.getTabCount() ):
        widget = self.book.getComponentAt( n )
        chapter = self.chapters[ widget ]
        rp = chapter.getRootPosition()
        for z in rp.fromSelfAllNodes_iter( copy = True ):
            if z == p: return chapter
        
    return None</t>
<t tx="ekr.20060228072530.19">def turnNodeIntoChapter( self ):
    
    cp = self.current_chapter.getCurrentPosition()
    if cp.isRoot():
        testroot = cp.copy()
        testroot.moveToNext()
        if not testroot:
            return
    self.c.beginUpdate()
    cp.unlink()
    rp = self.current_chapter.getRootPosition()
    self.current_chapter.setCurrentPosition( rp )
    self.c.endUpdate()
    self.freshChapter( p = cp )</t>
<t tx="ekr.20060228072530.20">@others
</t>
<t tx="ekr.20060228072530.21">def importOutline( self ):
    
    fc = swing.JFileChooser()
    fc.showOpenDialog( None )
    sfile = fc.getSelectedFile()
    if sfile:
        self.loadFileAsChapter( sfile.getAbsolutePath() )
    
def loadFileAsChapter( self, fname ):
    
    c = self.c
    targetfile = java.io.File( fname )
    if not targetfile.exists() or targetfile.isDirectory():
        return
    
    mungedname = targetfile.getName()
    if mungedname.endswith( ".leo") : mungedname = mungedname[ : -4 ]
    def run():
        self.freshChapter( name = mungedname, edit = False, undo = False )
        
    dc = DefCallable( run )
    ft = dc.wrappedAsFutureTask()
    if java.awt.EventQueue.isDispatchThread():
        ft.run()
    else:
        swing.SwingUtilities.invokeAndWait( ft )
    
    edit = sel.UndoImport( self, self.current_chapter )
    self.chaptersundoer.addEdit( edit )
    c.frame.disableResizing()
    p = c.fileCommands.getLeoFileAsOutline( fname )
    c.frame.enableResizing()
    oldir = c.frame.openDirectory
    parent = targetfile.getParentFile()
    c.frame.openDirectory = parent.getAbsolutePath()
    c.atFileCommands.readAll( c.rootPosition().copy() ,partialFlag=False)
    c.frame.openDirectory= oldir
    self.deferedChapterization( c.rootPosition(), selectchapter = self.getSelectedChapterWidget(), edit = edit )

</t>
<t tx="ekr.20060228072530.22">def exportOutline( self ):
    
    self.chaptersIterationBlocked = 1
    self.beginUpdate()
    fc = swing.JFileChooser()
    fc.showSaveDialog( None )
    sfile = fc.getSelectedFile()
    if not sfile:
        g.es( "No file name entered." )
        return
    fileName = fc.getName( sfile )
    if not fileName.endswith( ".leo" ):
        fileName = "%s.leo" % fileName
    self.c.fileCommands.write_Leo_file( fileName, True )
    self.chaptersIterationBlocked = 0
    self.endUpdate()
    g.es( "Done Exporting %s as %s" % ( self.current_chapter.name, fileName ) )</t>
<t tx="ekr.20060228072530.23">@others
</t>
<t tx="ekr.20060228072530.24">def addChapter( self, name, p = None ):
    

    c = self.c
    chapter = self.Chapter()
    self.chapterlist.append( chapter )
    chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
    chapter.setRootPosition( p )
    chapter.setCurrentPosition( p )
    #self.current_chapter = current
    cm = self.ChapterModel( c , chapter) #, p )
    tree = leoSwingTree( frame = c.frame, model = cm, chapter= chapter )
    tree.createAuxilaryWidgets()
    #self.c.frame.tree = tree
    chapter.setTree( tree )
    chapter.name = name
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()
    
    self.chapters[ widget ] = chapter
    ic = self.IconCloser( self.icon, self.removeChapter )
    self.book.addTab( name, ic, widget )

    if not self.current_chapter:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        self.endUpdate()

    return tree



</t>
<t tx="ekr.20060228072530.25">def addChapterForSettingsTree( self, name, p = None , controller = None):
    
    c = self.c
    chapter = self.current_chapter
    #chapter = self.Chapter()
    #chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
    chapter.setRootPosition( p )
    chapter.setCurrentPosition( p )
    #c.chapters.current_chapter = chapter
    #chapter = self.current_chapter
    cm = self.ChapterModel( c , chapter)
    import leoConfig
    tree = leoConfig.settingsTree( frame = c.frame, model = cm, chapter = chapter, controller = controller )
    chapter.setTree( tree )
    chapter.name = name
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()
    
    self.chapters[ widget ] = chapter
    self.book = self.getWidget()
    self.book.addTab( name, widget )
    if not self.current_chapter:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        self.endUpdate()

    return tree




</t>
<t tx="ekr.20060228072530.26">def freshChapter( self, p = None, name = None, edit = True, undo = True ):
    
    c = self.c
    if not p:
        t = leoNodes.tnode( headString = "NewHeadline" )
        v = leoNodes.vnode( c, t )
        p = leoNodes.position( v, [] )
    if not name:
        name = "New Chapter"
    tree = self.addChapter( name, p = p )                    
    chapter = self.trees_chapters[ tree ]
    if undo:
        self.chaptersundoer.addEdit( self.UndoAddChapter( self, chapter ) ) 
    try:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        p.linkAsRoot( None )
        #self.current_chapter = current 
        widget = tree.getWidget()
        self.book.setSelectedComponent( widget )   
    finally:
        self.endUpdate()
    tree.loaded = 1
    if edit:
        self.c.editPosition( p.copy() )</t>
<t tx="ekr.20060228072530.27">def removeChapter( self, chapter = None, undo = True ):

    tree = self.c.frame.tree
    vrect = tree.jspane.getViewportBorderBounds()
    main_widget = tree.getWidget()
    gp = main_widget.getGlassPane()
    bgc = tree.jtree.getBackground()
    fgc = tree.jtree.getForeground() 
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    fg = self.book.getForegroundAt( index )
    bg = self.book.getBackgroundAt( index )
    if chapter.isMessaging() or self.isPromptingForRemove(): return
    chapter.startMessaging()
    self.startPromptingForRemove()
    self.book.setForegroundAt( index, bg )
    self.book.setBackgroundAt( index, fg )
    if self.book.getTabCount() == 1:
        def ok( chapter = chapter ):
            self.stopPromptingForRemove()
            chapter.doneMessaging()
            self.book.setForegroundAt( index, fg )
            self.book.setBackgroundAt( index, bg )
        buttons = ( ( "Ok", ok ), )
        sa = self.SliderMessageButtons( "Can't remove the only Chapter", buttons = buttons, bgc = bgc, fgc = fgc )
        gp.setVisible( True )
        swidget = sa.getSlider()
        height = swidget.getPreferredSize().height
        vrect.height = height
        swidget.setBounds( vrect )
        gp.add( swidget )
        return
    else:
        message = "Do you want to remove Chapter: %s ?" % chapter.name
        def yes( component = component, chapter = chapter ):
            self.book.remove( component )
            chapter.doneMessaging()
            self.chapterlist.remove( chapter )
            tree = chapter.tree 
            del self.trees_chapters[ tree ]
            del self.chapters[ component ]
            self.chaptersundoer.addEdit( self.UndoRemoveChapter( self, chapter ) )
            try:
                index = self.book.getSelectedIndex()
                component = self.book.getComponentAt( index )
                #self.chapters[ widget ] = chapter
                chapter = self.chapters[ component ]
                self.beginUpdate()
                self.current_chapter = chapter
                self.c.frame.tree = chapter.tree
            finally:
                self.endUpdate()
            self.stopPromptingForRemove()            
            g.doHook( "chapter-removed", c = self.c, chapter = chapter )
            
        def no( chapter = chapter ):
            self.stopPromptingForRemove()
            chapter.doneMessaging()
            self.book.setForegroundAt( index, fg )
            self.book.setBackgroundAt( index, bg )
            
        buttons = ( ( "Yes", yes ), ( "No", no ) )
        sa = self.SliderMessageButtons( message, buttons = buttons, bgc = bgc, fgc = fgc )
        gp.setVisible( True )
        swidget = sa.getSlider()
        height = swidget.getPreferredSize().height
        vrect.height = height
        swidget.setBounds( vrect )
        gp.add( swidget )            
           
@    
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    rv = swing.JOptionPane.showConfirmDialog( None,
                                             "Do you want to remove Chapter: %s" % chapter.name,
                                             "Remove a Chapter?",
swing.JOptionPane.YES_NO_OPTION )
    if rv == swing.JOptionPane.NO_OPTION: return


    self.book.removeTabAt( index ) #removing does not fire a change event
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    self.chapterlist.remove( chapter )
    try:
        self.beginUpdate()
        self.current_chapter = chapter
        self.c.frame.tree = chapter.tree
    finally:
        self.endUpdate()
    g.doHook( "chapter-removed", c = self.c, chapter = chapter )
</t>
<t tx="ekr.20060228072530.28">def quietRemoveChapter( self, chapter ):
    
    tree = chapter.tree
    component = tree.getWidget()
    self.book.remove( component )
    self.chapterlist.remove( chapter )
    del self.trees_chapters[ tree ]
    del self.chapters[ component ]    
</t>
<t tx="ekr.20060228072530.29">@others
</t>
<t tx="ekr.20060228072530.30">def deferedChapterization (self,pos,selectchapter=None,edit=None):

    x = lambda: self.breakOutlineIntoChapters(pos,selectchapter,edit)
    dc = DefCallable(x)
    ft = dc.wrappedAsFutureTask()
    swing.SwingUtilities.invokeLater(ft)</t>
<t tx="ekr.20060228072530.31">def breakOutlineIntoChapters( self, p, selectchapter = None, edit = None ):
    
    #self.loading = 1
    self.beginUpdate()
    #self.updateLock.unlock()
    n = 0 
    last_z = None
    p2 = p.copy()
    level_0 = []
    for z in p.self_and_siblings_iter( copy = True ):
        level_0.append( z )

    if level_0:
        p1 = level_0[ 0 ]
        v1 = p1.v
        if hasattr( v1, "unknownAttributes" ):
            uA = v1.unknownAttributes
            if uA.has_key( "chapter_name" ):
                name = uA[ 'chapter_name' ]
                i = self.book.getSelectedIndex()
                self.book.setTitleAt( i, name )
                if self.current_chapter: #This needs to be set here or its lost in the next save
                    self.current_chapter.name = name

    for z in level_0:
        v = z.v
        name = "New Chapter"
        if hasattr( v, "unknownAttributes" ):
            if v.unknownAttributes.has_key( "chapter" ):
                a_n = v.unknownAttributes[ "chapter" ]
            else:
                a_n = n
            if v.unknownAttributes.has_key( "chapter_name" ):
                name = v.unknownAttributes[ "chapter_name" ]
        else:
            a_n = n
   
        if a_n != n:
            #self.c.endUpdate()
            n = a_n
            #z.doDelete( p2 )
            z.unlink()
            tree = self.c.chapters.addChapter( name, z.copy() )
            widget = tree.getWidget()
            chapter = self.chapters[ widget ]
            self.c.frame.tree = chapter.tree
            self.current_chapter = chapter
            if edit and hasattr( edit, "addChapter" ):
                edit.addChapter( chapter )
            ic = self.IconCloser( self.icon, self.removeChapter )
            self.book.addTab( name, ic, widget )
            #self.book.addTab( name, widget )
            self.book.setSelectedComponent( widget )
            #self.c.beginUpdate()
            last_z = z
            z.linkAsRoot( None )
            tree.loaded = 1
            continue
        
        if last_z:
            #z.moveAfter( last_z )
            z.unlink() 
            z.linkAfter( last_z )
        last_z = z           
    
    if not selectchapter:
        selectchapter = self.book.getComponentAt( 0 )       
    self.book.setSelectedComponent( selectchapter )
    self.c.beginUpdate()
    self.c.endUpdate()       
    self.endUpdate()</t>
<t tx="ekr.20060228072530.32">class ChaptersPopup( aevent.MouseAdapter ):
    
    def __init__( self, chapters ):
        aevent.MouseAdapter.__init__( self )
        self.chapters = chapters
        self.copyNodeToChapter = self.CopyNodeToChapter( chapters )
        self.cloneNodeToChapter = self.CloneNodeToChapter( chapters )
        self.swapChapters = self.SwapChapters( chapters )
        self.mergeChapters = self.MergeChapters( chapters )
        self.enabled = True
        
    def disable( self ):
        self.enabled = False
        
    def enable( self ):
        self.enabled = True
        
    @others</t>
<t tx="ekr.20060228072530.33">def mousePressed( self, mE ):
                
    if mE.getClickCount() == 1 and self.enabled:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()
            DefAction = self.chapters.DefAction        
            popup = swing.JPopupMenu()            
            popup.add( DefAction( "Add Chapter", self.chapters.freshChapter ) ) 
            #popup.add( DefAction( "Remove Chapter", self.chapters.removeChapter ) )
            #popup.add( DefAction( "ITERATE!", self.chapters.iterateOverChapters ) ) 
            popup.add( DefAction( "Edit Chapters Name", self.chapters.changeChaptersName ) )
            popup.addSeparator()
            popup.add( self.copyNodeToChapter.getWidget() )
            popup.add( self.cloneNodeToChapter.getWidget() )
            popup.add( self.swapChapters.getWidget() )
            popup.add( self.mergeChapters.getWidget() )
            popup.add( DefAction( "Copy Node Into Chapter", self.chapters.turnNodeIntoChapter ) )
            #popup.add( DefAction( "Test NODE", self.chapters.testNode ) )
            popup.addSeparator()
            menu = swing.JMenu( "Import/Export" )
            popup.add( menu )
            menu.add( DefAction( "Import Outline", self.chapters.importOutline ) )
            menu.add( DefAction( "Export Chapter as Outline", self.chapters.exportOutline ) )
            popup.addSeparator()
            undoer = self.chapters.chaptersundoer
            utext = undoer.getUndoPresentationName()
            item = popup.add( DefAction( utext, undoer.undo ) )
            if not undoer.canUndo():
                item.setEnabled( False )
                
            rtext = undoer.getRedoPresentationName()
            item = popup.add( DefAction( rtext, undoer.redo ) )
            if not undoer.canRedo():
                item.setEnabled( False )    
                              
            source = mE.getSource()                
            popup.show( source, x, y )
</t>
<t tx="ekr.20060228072530.34">class CopyNodeToChapter( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Copy Node To Chapter" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        cpos = current.getCurrentPosition()
        root = current.getRootPosition()
        #if cpos == root:
        #    roottest = cpos.copy()
        #    roottest.moveToNext()
        #    if not roottest:
        #        return
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mvnd = lambda event, cpos = cpos.copy(), chapter = z: self.chapters.copyNodeToChapter( cpos, chapter )
            jmi.actionPerformed = mvnd
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
</t>
<t tx="ekr.20060228072530.35">class CloneNodeToChapter( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Clone Node To Chapter" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        cpos = current.getCurrentPosition()
        root = current.getRootPosition()
        #if cpos == root:
        #    roottest = cpos.copy()
        #    roottest.moveToNext()
        #    if not roottest:
        #        return
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mvnd = lambda event, cpos = cpos.copy(), chapter = z: self.chapters.cloneNodeToChapter( cpos, chapter )
            jmi.actionPerformed = mvnd
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
</t>
<t tx="ekr.20060228072530.36">class SwapChapters( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Swap Chapters" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            swapchap = lambda event,  chapter = z: self.chapters.swapChapters( current, chapter )
            jmi.actionPerformed = swapchap
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
</t>
<t tx="ekr.20060228072530.37">class MergeChapters( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Merge Chapters" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mergechapters = lambda event,  chapter = z: self.chapters.mergeChapters( current, chapter )
            jmi.actionPerformed = mergechapters
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
</t>
<t tx="ekr.20060228072530.38">@others
</t>
<t tx="ekr.20060228072530.39">class DefAction( swing.AbstractAction ):
    
    def __init__( self, name, function ):
        swing.AbstractAction.__init__( self, name )
        self.function = function
    
    def actionPerformed( self, event ):
        self.function()</t>
<t tx="ekr.20060228072530.40">class ChapterModel( stree.TreeModel, java.lang.Runnable ):
    
    
    
    def __init__( self, c , chapter ):#, proot ):

        self.c = c
        self.tmlisteners = java.util.ArrayList();
        self._root = self._rootN( c, chapter ) # , proot )
        self._rTreePath = stree.TreePath( self._root ) 
        self.chapter = chapter
        self.drunning = 0

        
    def getChapter( self ):
        return self.chapter

    def getRoot( self ):
        return self._root

    def reload( self, full_reload = False ):
        
        
        if full_reload:
            t_r = self.c.frame.tree.tree_reloader
            #for z in self.c.rootPosition().allNodes_iter( copy = True ):
            for z in self._root.getRootPosition().allNodes_iter( copy = True ):
                if z.isExpanded():
                    t_r.expand( z )
        
        import jarray
        a = jarray.zeros( 1, stree.TreeNode )
        a[ 0 ] = self._root
        e = sevent.TreeModelEvent( self._root, a )
        for z in list( self.tmlisteners ):
            z.treeStructureChanged( e )

            
    def dRun( self ):
        self.drunning = 1
        swing.SwingUtilities.invokeLater( self )
            
    def run( self ):
        
        try:
            import jarray
            a = jarray.zeros( 1, stree.TreeNode )
            a[ 0 ] = self._root
            e = sevent.TreeModelEvent( self._root, a )
            for z in list( self.tmlisteners ):
                z.treeStructureChanged( e )
            if self.chapter.tree.jtree:
                self.chapter.tree.jtree.fireTreeExpanded( self._rTreePath )
                cp = self.chapter.getCurrentPosition()
                cpp = self.getPathToRoot( cp )
                self.chapter.tree.jtree.setSelectionPath( cpp )
        finally:
            self.drunning = 0
    
    def addTreeModelListener( self, listener ):
        self.tmlisteners.add( listener )
        
    def removeTreeModelListener( self, listener ):
        self.tmlisteners.remove( listener )
    
    def getChild( self, parent, ind ):
        if parent is self._root:
            return parent.getChildAt( ind ).copy()
        return parent.getNthChild( ind ).copy()
        
    def getChildCount( self, parent ):
        
        if parent is self._root:
            return parent.getChildCount()
        if parent:
            return parent.numberOfChildren()
        else:
            return 0
        
    def getIndexOfChild( self, parent, child ):
        if parent is self._root:
            return self._root.getIndex( child )
        else:
            return child.childIndex()


    
    def valueForPathChanged( self, path, value ):

        pos = path.getLastPathComponent()
        pos.setHeadString( value )
        
    def isLeaf( self, node ):
        if node is self._root: return False
        if node:
            if node.numberOfChildren(): return False
            else: return True
        else:
            return True
            
            
    def getPathToRoot( self, node, masterlist = None ):
        
        path = []
        #if not node:
        #    node = self.c.rootPosition()
        stopat = None
        if self.chapter.hoistStack:
            bunch = self.chapter.hoistStack[ -1 ]
            stopat = bunch.p.copy()
            
        while node and node.level() != 0:
            path.append( node.copy() )
            if node == stopat: break
            node = node.getParent()
            if masterlist:
                if node in masterlist:
                    masterlist.remove( node )
        else:
            path.append( node.copy() )
        
        path.append( self._root )  
        path.reverse()
        tp = stree.TreePath( path )
        return tp
            
    class _rootN( stree.TreeNode ):
        
        def __init__( self, c, chapter ):#, proot ):
            self.c = c
            self.chapter = chapter
            self.v = None # These are for comparisons with positions, we must pretend to be a position
            self.stack = None
            
            #self.chapters = c.chapters
            #self.proot = proot
        def expand( self ): pass
        def contract( self ): pass
        
        def getChildIndex( self ):
            return -1
        
        def getRootPosition( self ):
            rp = self.chapter.getRootPosition()
            return rp

        
        def getChildAt(self, childIndex):
            rp = self.getRootPosition() #self.c.rootPosition()                
            #if len( self.c.hoistStack ) != 0: #Hoist Code
            if len( self.chapter.hoistStack ) != 0:
                #rp = self.c.hoistStack[ -1 ].p.copy()
                rp = self.chapter.hoistStack[ -1 ].p.copy()
                def getParent( root = self ): #This slight modification to a copy allows the Tree to keep its expanded state
                    return root
                rp.getParent = getParent
                return rp #End of Hoist Code
            if not rp: return None
            i = 0
            for z in rp.siblings_iter():
                if i == childIndex:
                    return z
                i = i + 1
            return None       
        
        def getChildCount( self ):
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            if len( self.chapter.hoistStack ) != 0:
                return 1
            #if len( self.c.hoistStack ) != 0:
            #    return 1
            i = 0
            for z in rp.siblings_iter():
                i = i + 1
            return i
        
        def getParent( self ):
            return None
            
        def getIndex( self, node):
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            if len( self.chapter.hoistStack ) != 0:
                return 0
            i = 0
            for z in rp.siblings_iter():
                if z == node: return i
                i = i + 1
            return -1
            
        def getAllowsChildren( self ):
            return True
            
        def isLeaf( self ):
            return False
            
        def equal( self, x ):
            if self is x: return True
            else: return False
            
        def equals( self, x ):
            if self is x: return True
            else:
                return False
            
        def copy( self ):
            return self
            
        def bodyString( self ):
            return ""
            
        def headString( self ):
            return ""
            
        def children( self ):
            
            class _enum( util.Enumeration ):
                
                def __init__( self, iter ):
                    self.iter = iter
                    try:
                        self.next = iter.next()
                    except:
                        self.next = None
                
                def hasMoreElements( self ):
                    if self.next: return True
                    else: return False
                    
                def nextElement( self ):
                    
                    try:
                        rt = self.next
                        self.next = iter.next()
                    finally:
                        return rt
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            return _enum( rp.siblings_iter( copy = True ) )
            #return _enum( self.c.rootPosition.siblings_iter( copy = True ) )


</t>
<t tx="ekr.20060228072530.41">class Chapter:
    
    def __init__( self ):
        
        self.root = None
        self.currentPosition = None
        self.tree = None
        self.name = None
        self.hoistStack = []
        self.undoer = None
        self.messaging = False
        
    def startMessaging( self ):
        self.messaging = True
    
    def isMessaging( self ):
        return self.messaging
        
    def doneMessaging( self ):
        self.messaging = False
        
    def isValid( self ):
        widget = self.tree.getWidget()
        if widget.getParent(): return True
        else:
            return False    
        
    def setUndoer( self, undoer ):
        self.undoer = undoer
        
    def getUndoer( self ):
        return self.undoer
        
    def getName( self ):
        return self.name
        
    def setName( self, name ):
        self.name = name
        
    
    def getTree( self ):
        return self.tree
        
    def setTree( self, tree ):
        self.tree = tree
    
    def setRootPosition( self, p ):
        if p:
            p = p.copy()
        self.root = p

    def getRootPosition( self ):
        p = self.root
        if p:
            p = p.copy()
        return p
    
    def setCurrentPosition( self, p ):
        if p:
            p = p.copy()        
        self.currentPosition = p
        
    
    def getCurrentPosition( self ):
        p = self.currentPosition
        if p:
            p = p.copy()
        return p</t>
<t tx="ekr.20060228072530.42">class SliderMessageButtons( sevent.AncestorListener ):
    '''A class that manages creates a message with 0 to N buttons for
       the user to select.  After selecting the button, the slider is removed.
       After removal the function corresponding to the button is fired'''
       
    def __init__( self, message, buttons = (), direction = Slider.down, bgc = None, fgc = None ):
        
        self.backingpanel = swing.JPanel( awt.BorderLayout() )
        self.slider = Slider( self.backingpanel, direction )
        if fgc:
            lb = swing.border.LineBorder( fgc )
            self.backingpanel.setBorder( lb )
        else:
            lb = swing.border.LineBorder( self.backingpanel.getForeground() )
            self.backingpanel.setBorder( lb )
        jl = swing.JLabel( message )
        jl.setHorizontalAlignment( swing.SwingConstants.CENTER )
        self.backingpanel.add( jl )
        jp2 = swing.JPanel()
        self.func = None
        for z in buttons:
            label = z[ 0 ]
            func = z[ 1 ]
            b = swing.JButton( label )
            b.actionPerformed = lambda event, func = func: self.__removeCall( func )
            jp2.add( b )

        self.backingpanel.add( jp2, awt.BorderLayout.SOUTH )
        self.slider.setSize( self.slider.getPreferredSize() )
        if not fgc is None:
            self.backingpanel.setForeground( fgc )
            jp2.setForeground( fgc )
            jl.setForeground( fgc )
        if not bgc is None:
            self.backingpanel.setBackground( bgc )
            jp2.setBackground( bgc )
            jl.setBackground( bgc )
        
    def __removeCall( self, func ):
        self.slider.addAncestorListener( self )
        self.slider.startRemoving()
        self.func = func
        
    def ancestorAdded( self, event):
        pass
        
    def ancestorMoved( self, event ):
        pass
        
    def ancestorRemoved( self, event ):
        if not self.func is None:
            self.func()
        
    def getSlider( self ):
        return self.slider

</t>
<t tx="ekr.20060228072530.43">class IconCloser( swing.Icon, aevent.MouseAdapter ):
    
    def __init__( self, iicon, callback ):
        
        aevent.MouseAdapter.__init__( self )
        self.iicon = iicon
        self.component = None
        self.x = None
        self.y = None
        self.callback = callback
        
    def mousePressed( self, event ):
        
        if event.getButton() == event.BUTTON1:
            x = event.getX(); y = event.getY()
            rec = awt.Rectangle( self.x, self.y, self.iicon.getIconWidth(), self.iicon.getIconHeight() )
            if rec.contains( x,y ):
                self.component.removeMouseListener( self )
                self.component = None
                dc = DefCallable(self.callback)
                swing.SwingUtilities.invokeLater(dc.wrappedAsFutureTask())
        
    def getIconHeight( self ):
        
        return self.iicon.getIconHeight()
        
    def getIconWidth( self ):
        
        return self.iicon.getIconWidth()
        
    def paintIcon( self, jc, g, x, y ):
        
        if self.component == None:
            self.component = jc
            jc.addMouseListener( self )
        self.x = x
        self.y = y
        self.iicon.paintIcon( jc, g, x ,y )
        </t>
<t tx="ekr.20060228072530.44">@others
</t>
<t tx="ekr.20060228072530.45">def chaptersIterator( self ):

    if not self.chaptersIterationBlocked:
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            rp = chapter.getRootPosition()
            for z in rp.fromSelfAllNodes_iter( copy = True ):
                yield z
    else:
        
        for z in self.c.allNodes_iter( copy = 1 ):
            yield z            

                
</t>
<t tx="ekr.20060228072530.46">def topLevelSiblingsIterator( self, ):

    if not self.chaptersIterationBlocked:
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            rp = chapter.getRootPosition()
            for z in rp.self_and_siblings_iter( copy = True ):
                yield z
    else:
        rp = self.c.rootPosition()
        for z in rp.self_and_siblings_iter( copy = True ):
            yield z
            
</t>
<t tx="ekr.20060228072530.47">def cycleThroughChapters( self, swap = 1 ):

    if not self.chaptersIterationBlocked:
        current = self.current_chapter
        if swap: self.beginUpdate()
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            if swap:    
                self.current_chapter = chapter
            yield chapter
    
        self.current_chapter = current
        if swap: self.endUpdate()
    else:
        yield self.current_chapter
    
</t>
<t tx="ekr.20060228072530.48">@others</t>
<t tx="ekr.20060228072530.49">class UndoRemoveChapter( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter = chapter
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Remove Chapter %s" % self.chapter.name
    def getRedoPresentationName( self ): return "Redo Removing %s" % self.chapter.name
    def getUndoPresentationName( self ): return "Undo Removing %s" % self.chapter.name
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.quietRemoveChapter( self.chapter )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.insertChapter( self.chapter )
        self.undone = True
    
</t>
<t tx="ekr.20060228072530.50">class UndoChangeChapterName( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter, name1, name2 ):
        self.chapters = chapters
        self.chapter = chapter
        self.name1 = name1
        self.name2 = name2
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Changing Chapter Name From %s to %s" % ( self.name1, self.name2 )
    def getRedoPresentationName( self ): return "Redo Changing Name From %s to %s" %  ( self.name1, self.name2 )
    def getUndoPresentationName( self ): return "Undo Changing Name From %s to %s" % ( self.name1, self.name2 )
    def isSignificant( self ): return True
    def redo( self ):
        
        book = self.chapters.book
        index = book.indexOfComponent( self.chapter.tree.getWidget() )
        book.setTitleAt( index, self.name2 )
        self.chapter.name = self.name2
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        book = self.chapters.book
        index = book.indexOfComponent( self.chapter.tree.getWidget() )
        book.setTitleAt( index, self.name1 )
        self.chapter.name = self.name1
        self.undone = True
</t>
<t tx="ekr.20060228072530.51">class UndoAddChapter( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter = chapter
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Add Chapter"
    def getRedoPresentationName( self ): return "Redo Add Chapter"
    def getUndoPresentationName( self ): return "Undo Add Chapter"
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.insertChapter( self.chapter )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.quietRemoveChapter( self.chapter )
        self.undone = True
    
</t>
<t tx="ekr.20060228072530.52">class UndoImport( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter_list = []
        self.chapter_list.append( chapter )
        self.undone = False
    
    def addChapter( self, chapter ):
        self.chapter_list.append( chapter )
           
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Import Outline"
    def getRedoPresentationName( self ): return "Redo Import Outline"
    def getUndoPresentationName( self ): return "Undo Import Outline"
    def isSignificant( self ): return True
    def redo( self ):
        
        for z in self.chapter_list:
            self.chapters.insertChapter( z )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        for z in self.chapter_list:
            self.chapters.quietRemoveChapter( z )
        self.undone = True
    
</t>
<t tx="ekr.20060228072530.53">class UndoSwapChapters( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter1, chapter2 ):
        self.chapters = chapters
        self.chapter1 = chapter1
        self.chapter2 = chapter2
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Swap Chapters %s , %s" % ( self.chapter1.name, self.chapter2.name )
    def getRedoPresentationName( self ): return "Redo Swap Chapters %s, %s" % ( self.chapter1.name , self.chapter2.name )
    def getUndoPresentationName( self ): return "Undo Swap Chapters %s, %s" % ( self.chapter1.name , self.chapter2.name )
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.swapChapters( self.chapter1, self.chapter2, undo = False )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.swapChapters( self.chapter1, self.chapter2, undo = False )
        self.undone = True
    
</t>
<t tx="ekr.20060228072530.54"></t>
<t tx="ekr.20060228081537"></t>
<t tx="ekr.20060228081628">@nocolor

* Remove most (all?) calls to getStringVar.

- What should the type of lastNode be? v or p??  See newSelect.

- Replace all v refs by p refs.  vnd

- Find/Change does not appear to work.

- Close box in window crashes the plugin.</t>
<t tx="ekr.20060228082602"></t>
<t tx="ekr.20060228085204"></t>
<t tx="ekr.20060228085204.1">c.save()
c.redraw_now() # Must be done here.</t>
<t tx="ekr.20060228092227">def nextPageName (self):
    
    n = str(len(self.nb.pagenames()) + 1)
    g.trace(n)
    return n</t>
<t tx="ekr.20060228094838"></t>
<t tx="ekr.20060228094838.1">def getChapter (self,pageName):
    
    return self.chapters.get(pageName)</t>
<t tx="ekr.20060228113912">def afterCreate (tag, keys):
    
    c = keys.get('c')
    
    g.trace(c)
    
    cc = controllers.get(c)
    cc.finishCreate()</t>
<t tx="ekr.20060228113912.1">def finishCreate (self):
    
    c = self.c
    
    pageName = '1'
    g.trace()
    self.stringVars[pageName] = Tk.StringVar()
    self.chapters [pageName] = Chapter(c,c.frame.tree,c.frame,c.frame.tree.canvas)
    self.inited = True
    self.setTree(pageName)</t>
<t tx="ekr.20060228123606"></t>
</tnodes>
</leo_file>
