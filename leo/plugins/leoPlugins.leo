<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="918" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="16" left="363" height="828" width="876"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0">
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1"><vh>Documentation and security warnings</vh>
<v t="T2"><vh>Overview of plugins and hooks</vh></v>
<v t="T3"><vh>Intro to scripts</vh></v>
<v t="T4"><vh>About hooks</vh></v>
<v t="T5"><vh>Hooks should never blindly Python scripts</vh></v>
<v t="T6"><vh>NEVER use this kind of code in a hook!!</vh></v>
</v>
<v t="T7"><vh>Unfinished projects</vh>
<v t="T8"><vh>(Settings menu)</vh>
<v t="T9"><vh>To do</vh></v>
<v t="T10"><vh>Design of Settings menu</vh></v>
<v t="T11"><vh>@file settings_menu.py</vh>
<v t="T12"><vh>createSettingsMenu</vh></v>
</v>
</v>
<v t="T13"><vh>Study code for EKR</vh>
<v t="T14"><vh>pymacs</vh>
<v t="T15"><vh>@file pymacs.el</vh>
<v t="T16"><vh>Intro</vh>
<v t="T17"><vh>&lt;&lt; free software stuff &gt;&gt;</vh></v>
</v>
<v t="T18"><vh>Published functions...</vh>
<v t="T19"><vh>vars...</vh>
<v t="T20"><vh>var pymacs-load-path</vh></v>
<v t="T21"><vh>var pymacs-trace-transit</vh></v>
<v t="T22"><vh>var pymacs-forget-mutability</vh></v>
<v t="T23"><vh>var pymacs-mutable-strings</vh></v>
<v t="T24"><vh>var pymacs-timeout-at-start</vh></v>
<v t="T25"><vh>var pymacs-timeout-at-reply</vh></v>
<v t="T26"><vh>var pymacs-timeout-at-line</vh></v>
</v>
<v t="T27"><vh>pymacs-load</vh></v>
<v t="T28"><vh>pymacs-eval</vh></v>
<v t="T29"><vh>pymacs-exec</vh></v>
<v t="T30"><vh>pymacs-call</vh></v>
<v t="T31"><vh>pymacs-apply</vh></v>
</v>
<v t="T32"><vh>Integration details...</vh>
<v t="T33"><vh>defadvice</vh></v>
<v t="T34"><vh>pymacs-python-reference</vh></v>
</v>
<v t="T35"><vh>experimental...</vh>
<v t="T36"><vh>pymacs-file-handler</vh></v>
<v t="T37"><vh>pymacs-file-force</vh></v>
</v>
<v t="T38"><vh>Gargabe collection of Python IDs...</vh>
<v t="T39"><vh>vars...</vh>
<v t="T40"><vh>var pymacs-use-hash-tables</vh></v>
<v t="T41"><vh>var pymacs-used-ids</vh></v>
<v t="T42"><vh>var pymacs-weak-hash</vh></v>
<v t="T43"><vh>var pymacs-gc-wanted</vh></v>
<v t="T44"><vh>var pymacs-gc-running</vh></v>
<v t="T45"><vh>var pymacs-gc-timer</vh></v>
</v>
<v t="T46"><vh>pymacs-schedule-gc</vh></v>
<v t="T47"><vh>pymacs-garbage-collect</vh></v>
<v t="T48"><vh>pymacs-defuns</vh></v>
<v t="T49"><vh>pymacs-defun</vh></v>
<v t="T50"><vh>pymacs-python</vh></v>
</v>
<v t="T51"><vh>Generating Python code...</vh>
<v t="T52"><vh>var pymacs-lisp</vh></v>
<v t="T53"><vh>var pymacs-freed-list</vh></v>
<v t="T54"><vh>pymacs-allocate-lisp</vh></v>
<v t="T55"><vh>pymacs-free-lisp</vh></v>
<v t="T56"><vh>pymacs-print-for-apply-expanded</vh></v>
<v t="T57"><vh>pymacs-print-for-apply</vh></v>
<v t="T58"><vh>pymacs-print-for-eval</vh></v>
</v>
<v t="T59"><vh>Communication protocol...</vh>
<v t="T60"><vh>pymacs-start-services</vh></v>
<v t="T61"><vh>pymacs-terminate-services</vh></v>
<v t="T62"><vh>pymacs-reply</vh></v>
<v t="T63"><vh>pymacs-error</vh></v>
<v t="T64"><vh>pymacs-expand</vh></v>
<v t="T65"><vh>pymacs-serve-until-reply</vh></v>
<v t="T66"><vh>pymacs-round-trip</vh></v>
<v t="T67"><vh>pymacs-proper-list-p</vh></v>
</v>
</v>
</v>
<v t="T68"><vh>wxPython stuff</vh>
<v t="T69"><vh>wxPython demo...</vh>
<v t="T70"><vh>@file Main.py</vh>
<v t="T71"><vh>&lt;&lt; version &gt;&gt;</vh></v>
<v t="T72"><vh>&lt;&lt; define the tree of demo elements &gt;&gt;</vh></v>
<v t="T73"><vh>class MyLog</vh>
<v t="T74"><vh>__init__</vh></v>
<v t="T75"><vh>DoLogString</vh></v>
</v>
<v t="T76"><vh>class MyTP (Tooltips)</vh>
<v t="T77"><vh>GetTip</vh></v>
</v>
<v t="T78"><vh>opj</vh></v>
<v t="T79"><vh>class wxPythonDemo  (tree, notebook, log, text...)</vh>
<v t="T80" a="M"><vh>__init__</vh>
<v t="T81"><vh>&lt;&lt; create menus &gt;&gt;</vh></v>
<v t="T82"><vh>&lt;&lt; Create a TreeCtrl &gt;&gt;</vh></v>
<v t="T83"><vh>&lt;&lt; Create a Notebook &gt;&gt; (HtmlWindow for over page)</vh></v>
<v t="T84"><vh>&lt;&lt; Set up a TextCtrl on the Demo Code Notebook page &gt;&gt;</vh></v>
<v t="T85"><vh>&lt;&lt; Set up a log on the View Log Notebook page &gt;&gt;</vh></v>
<v t="T86"><vh>&lt;&lt; add the windows to the splitter and split it &gt;&gt;</vh></v>
<v t="T87"><vh>&lt;&lt; create accelerators &gt;&gt;</vh></v>
<v t="T88"><vh>&lt;&lt; setup a taskbar icon, and catch some events from it &gt;&gt;</vh></v>
<v t="T89"><vh>&lt;&lt; handle sys.argv args &gt;&gt;</vh></v>
</v>
<v t="T90"><vh>WriteText</vh></v>
<v t="T91"><vh>write</vh></v>
<v t="T92"><vh>Tree event handlers</vh>
<v t="T93"><vh>OnItemExpanded</vh></v>
<v t="T94"><vh>OnItemCollapsed</vh></v>
<v t="T95"><vh>OnTreeLeftDown</vh></v>
<v t="T96"><vh>OnSelChanged</vh></v>
</v>
<v t="T97"><vh>RunDemo</vh></v>
<v t="T98"><vh>GetDemoFile</vh></v>
<v t="T99"><vh>SetOverview</vh></v>
<v t="T100"><vh>OnFileExit</vh></v>
<v t="T101"><vh>OnHelpAbout</vh></v>
<v t="T102"><vh>OnHelpFind</vh></v>
<v t="T103"><vh>OnFind</vh></v>
<v t="T104"><vh>OnFindNext</vh></v>
<v t="T105"><vh>OnFindClose</vh></v>
<v t="T106"><vh>OnCloseWindow</vh></v>
<v t="T107"><vh>OnIdle</vh></v>
<v t="T108"><vh>ShowTip</vh></v>
<v t="T109"><vh>OnDemoMenu</vh></v>
<v t="T110"><vh>OnTaskBarActivate</vh></v>
<v t="T111"><vh>OnTaskBarMenu</vh></v>
<v t="T112"><vh>OnTaskBarClose</vh></v>
<v t="T113"><vh>OnIconfiy</vh></v>
<v t="T114"><vh>OnMaximize</vh></v>
</v>
<v t="T115"><vh>class MySplashScreen</vh>
<v t="T116"><vh>__init__</vh></v>
<v t="T117"><vh>OnClose</vh></v>
</v>
<v t="T118"><vh>class MyApp</vh>
<v t="T119"><vh>OnInit (Create splash screen)</vh></v>
</v>
<v t="T120"><vh>main</vh></v>
<v t="T121"><vh>&lt;&lt; overview of demo &gt;&gt;</vh></v>
</v>
</v>
<v t="T122"><vh>Tree...</vh>
<v t="T123"><vh>@file wxTreeListCtrl.py</vh>
<v t="T124"><vh>class TestPanel</vh>
<v t="T125"><vh>__init__</vh></v>
<v t="T126"><vh>OnSize</vh></v>
</v>
<v t="T127"><vh>runTest</vh></v>
</v>
<v t="T128"><vh>@file wxTreeCtrl.py</vh>
<v t="T129"><vh>class MyTreeCtrl</vh>
<v t="T130"><vh>__init__</vh></v>
<v t="T131"><vh>OnCompareItems</vh></v>
</v>
<v t="T132"><vh>class TestTreeCtrlPanel</vh>
<v t="T133"><vh>__init__</vh></v>
<v t="T134"><vh>OnRightClick</vh></v>
<v t="T135"><vh>OnRightUp</vh></v>
<v t="T136"><vh>OnBeginEdit</vh></v>
<v t="T137"><vh>OnEndEdit</vh></v>
<v t="T138"><vh>OnLeftDClick</vh></v>
<v t="T139"><vh>OnSize</vh></v>
<v t="T140"><vh>OnItemExpanded</vh></v>
<v t="T141"><vh>OnItemCollapsed</vh></v>
<v t="T142"><vh>OnSelChanged</vh></v>
<v t="T143"><vh>OnActivate</vh></v>
</v>
<v t="T144"><vh>runTest</vh></v>
</v>
</v>
<v t="T145"><vh>Text...</vh>
<v t="T146"><vh>@file wxStyledTextCtrl_1.py</vh>
<v t="T147"><vh>&lt;&lt; wxStyledTextCtrl_1 declarations &gt;&gt;</vh></v>
<v t="T148"><vh>class MySTC</vh>
<v t="T149"><vh>__init__</vh></v>
<v t="T150"><vh>OnDestroy</vh></v>
<v t="T151"><vh>OnStartDrag</vh></v>
<v t="T152"><vh>OnDragOver</vh></v>
<v t="T153"><vh>OnDoDrop</vh></v>
<v t="T154"><vh>OnModified</vh></v>
<v t="T155"><vh>transModType</vh></v>
</v>
<v t="T156"><vh>runTest</vh></v>
</v>
<v t="T157"><vh>@file wxStyledTextCtrl_2.py</vh>
<v t="T158"><vh>&lt;&lt; wxStyledTextCtrl_2 declarations &gt;&gt;</vh></v>
<v t="T159"><vh>class PythonSTC</vh>
<v t="T160"><vh>__init__</vh></v>
<v t="T161"><vh>OnKeyPressed</vh></v>
<v t="T162"><vh>OnUpdateUI</vh></v>
<v t="T163"><vh>OnMarginClick</vh></v>
<v t="T164"><vh>FoldAll</vh></v>
<v t="T165"><vh>Expand</vh></v>
</v>
<v t="T166"><vh>runTest</vh></v>
</v>
<v t="T167"><vh>@file wxTextCtrl.py</vh>
<v t="T168"><vh>&lt;&lt; wxTextCtrl declarations &gt;&gt;</vh></v>
<v t="T169"><vh>class TestPanel</vh>
<v t="T170"><vh>OnSetFocus</vh></v>
<v t="T171"><vh>OnKillFocus</vh></v>
<v t="T172"><vh>OnWindowDestroy</vh></v>
<v t="T173"><vh>__init__</vh></v>
<v t="T174"><vh>EvtText</vh></v>
<v t="T175"><vh>EvtChar</vh></v>
<v t="T176"><vh>OnTestReplace</vh></v>
<v t="T177"><vh>OnTestWriteText</vh></v>
<v t="T178"><vh>OnTestGetSelection</vh></v>
<v t="T179"><vh>OnT5LeftDown</vh></v>
<v t="T180"><vh>LogT5Position</vh></v>
<v t="T181"><vh>OnTestEvent</vh></v>
</v>
<v t="T182"><vh>runTest</vh></v>
</v>
</v>
<v t="T183"><vh>HTML</vh>
<v t="T184"><vh>@file wxHtmlWindow.py</vh>
<v t="T185"><vh>class MyHtmlWindow</vh>
<v t="T186"><vh>__init__</vh></v>
<v t="T187"><vh>OnScroll</vh></v>
<v t="T188"><vh>OnLinkClicked</vh></v>
<v t="T189"><vh>OnSetTitle</vh></v>
<v t="T190"><vh>OnCellMouseHover</vh></v>
<v t="T191"><vh>OnCellClicked</vh></v>
</v>
<v t="T192"><vh>class MyHtmlFilter</vh>
<v t="T193"><vh>__init__</vh></v>
<v t="T194"><vh>CanRead</vh></v>
<v t="T195"><vh>ReadFile</vh></v>
</v>
<v t="T196"><vh>class TestHtmlPanel</vh>
<v t="T197"><vh>__init__</vh></v>
<v t="T198"><vh>ShutdownDemo</vh></v>
<v t="T199"><vh>OnShowDefault</vh></v>
<v t="T200"><vh>OnLoadFile</vh></v>
<v t="T201"><vh>OnLoadURL</vh></v>
<v t="T202"><vh>OnWithWidgets</vh></v>
<v t="T203"><vh>OnOk</vh></v>
<v t="T204"><vh>OnBack</vh></v>
<v t="T205"><vh>OnForward</vh></v>
<v t="T206"><vh>OnViewSource</vh></v>
<v t="T207"><vh>OnPrint</vh></v>
</v>
<v t="T208"><vh>runTest</vh></v>
</v>
<v t="T209"><vh>@file wxIEHtmlWin.py</vh>
<v t="T210"><vh>class TestPanel</vh>
<v t="T211"><vh>__init__</vh></v>
<v t="T212"><vh>ShutdownDemo</vh></v>
<v t="T213"><vh>OnSize</vh></v>
<v t="T214"><vh>OnLocationSelect</vh></v>
<v t="T215"><vh>OnLocationKey</vh></v>
<v t="T216"><vh>IgnoreReturn</vh></v>
<v t="T217"><vh>OnOpenButton</vh></v>
<v t="T218"><vh>OnHomeButton</vh></v>
<v t="T219"><vh>OnPrevPageButton</vh></v>
<v t="T220"><vh>OnNextPageButton</vh></v>
<v t="T221"><vh>OnStopButton</vh></v>
<v t="T222"><vh>OnSearchPageButton</vh></v>
<v t="T223"><vh>OnRefreshPageButton</vh></v>
<v t="T224"><vh>logEvt</vh></v>
<v t="T225"><vh>OnBeforeNavigate2</vh></v>
<v t="T226"><vh>OnNewWindow2</vh></v>
<v t="T227"><vh>OnDocumentComplete</vh></v>
<v t="T228"><vh>OnTitleChange</vh></v>
<v t="T229"><vh>OnStatusTextChange</vh></v>
</v>
<v t="T230"><vh>runTest</vh></v>
</v>
</v>
</v>
</v>
<v t="T231"><vh>wxPython plugin (not ready yet)</vh>
<v t="T232"><vh> Diary</vh></v>
<v t="T233"><vh> To do</vh>
<v t="T234"><vh>Design changes</vh></v>
</v>
<v t="T235"><vh> Unused code</vh>
<v t="T236"><vh>invoke c2py</vh></v>
<v t="T237"><vh>LeoFrame.__init__</vh>
<v t="T238"><vh>&lt;&lt; Initialize the private vars &gt;&gt;</vh></v>
<v t="T239"><vh>&lt;&lt; Initialize the argument settings &gt;&gt;</vh></v>
<v t="T240"><vh>&lt;&lt; Create the splitter windows &gt;&gt;</vh>
<v t="T241"><vh>&lt;&lt; Set the image list &gt;&gt;</vh></v>
</v>
<v t="T242"><vh>&lt;&lt; Create the accelerator table &gt;&gt;</vh></v>
<v t="T243"><vh>&lt;&lt; Create the status bar &gt;&gt;</vh></v>
<v t="T244"><vh>&lt;&lt; Set the window Icon &gt;&gt;</vh></v>
<v t="T245"><vh>&lt;&lt; Set the caret blink rate &gt;&gt;</vh></v>
<v t="T246"><vh>&lt;&lt; Add root node to the tree view &gt;&gt;</vh></v>
</v>
<v t="T247"><vh>OpenWithFileName</vh>
<v t="T248"><vh>&lt;&lt; Set closeEmptyFrameFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T249"><vh>&lt;&lt; LeoPrefs private constants &gt;&gt;</vh></v>
<v t="T250"><vh>updateJoinedHeadlines</vh></v>
</v>
<v t="T251"><vh>(Events)</vh>
<v t="T252" a="C"><vh>&lt;&lt; constants for wx plugin &gt;&gt;</vh></v>
<v t="T253" a="C"><vh>finishCreate</vh></v>
<v t="T254" a="C"><vh>__init__</vh>
<v t="T255"><vh>&lt;&lt; create the splitters &gt;&gt;</vh></v>
<v t="T256"><vh>&lt;&lt; create the tree &gt;&gt;</vh></v>
<v t="T257"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T258"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
<v t="T259"><vh>&lt;&lt; set the window icon &gt;&gt;</vh></v>
<v t="T260"><vh>&lt;&lt; declare event handlers for frame &gt;&gt;</vh></v>
<v t="T261"><vh>&lt;&lt; declare event handlers for body &amp; tree &gt;&gt;</vh></v>
</v>
<v t="T262" a="C"><vh>event handlers</vh>
<v t="T263"><vh>Frame events</vh>
<v t="T264"><vh>onActivate &amp; OnSetFocus</vh></v>
<v t="T265"><vh>onCloseLeoFrame</vh>
<v t="T266"><vh>&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;</vh></v>
<v t="T267"><vh>&lt;&lt; Close the permanent frames &gt;&gt;</vh></v>
</v>
<v t="T268"><vh>onResize</vh></v>
</v>
<v t="T269"><vh>Body events</vh>
<v t="T270"><vh>onBodyTextUpdated</vh>
<v t="T271"><vh>&lt;&lt; Set the dirty bit and/or the file-changed mark if the text has changed &gt;&gt;</vh></v>
<v t="T272"><vh>&lt;&lt; Update icons &gt;&gt;</vh></v>
</v>
</v>
<v t="T273"><vh>Tree events</vh>
<v t="T274"><vh>Expand/contract</vh>
<v t="T275"><vh>onTreeCollapsed &amp; onTreeExpanded</vh></v>
<v t="T276"><vh>onTreeCollapsing &amp; onTreeExpanding</vh></v>
</v>
<v t="T277"><vh>Selecting</vh>
<v t="T278"><vh>onTreeChanged</vh></v>
<v t="T279"><vh>onTreeChanging</vh></v>
</v>
<v t="T280"><vh>Editing labels</vh>
<v t="T281"><vh>onTreeBeginLabelEdit</vh></v>
<v t="T282"><vh>onTreeEndLabelEdit</vh></v>
<v t="T283"><vh>onTreeKeyDown</vh></v>
</v>
<v t="T284"><vh>onTreeBeginDrag</vh></v>
<v t="T285"><vh>onTreeEndDrag</vh>
<v t="T286"><vh>&lt;&lt; Define onTreeEndDrag vars &gt;&gt;</vh></v>
<v t="T287"><vh>&lt;&lt; Insert src as the first child of dst &gt;&gt;</vh></v>
<v t="T288"><vh>&lt;&lt; Insert src after dst &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T289" a="C"><vh>Interface with the tree class</vh>
<v t="T290"><vh>beginUpdate</vh></v>
<v t="T291"><vh>endUpdate</vh></v>
<v t="T292"><vh>Getters</vh></v>
<v t="T293"><vh>redraw &amp; redraw_now</vh></v>
<v t="T294"><vh>redraw_node</vh></v>
<v t="T295"><vh>redraw_subtree</vh></v>
<v t="T296"><vh>Setters</vh></v>
</v>
</v>
<v t="T297" a="M" tnodeList="297,298,252,300,302,303,304,305,306,307,308,309,310,311,312,314,315,317,318,319,320,322,323,324,326,327,328,329,330,331,332,333,334,335,254,255,256,257,258,259,260,261,337,253,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,264,265,266,267,268,270,271,272,275,276,278,279,281,282,283,284,285,286,287,288,362,363,365,366,367,368,369,289,290,291,292,293,294,295,296,371,373,375,376,377,378,379,380,381,382,383,384,385,386,387,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,469,470,471,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,490,491,492,494,495,496,497,498,499,500,501,502,503,504,505,506,508,509,510,511,512,513,515,517,518,519,520,521,522,523,525,527,528,529,530,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,571,572,573,574,575,576,577,578,579,580,581,582,583,299"><vh>@file __wx_gui.py</vh>
<v t="T298"><vh>&lt;&lt; imports for wx plugin &gt;&gt;</vh></v>
<v t="T252" a="C"><vh>&lt;&lt; constants for wx plugin &gt;&gt;</vh></v>
<v t="T299"><vh>&lt;&lt; set app.gui &gt;&gt;</vh></v>
<v t="T300"><vh>wxGui class</vh>
<v t="T301"><vh>Birth &amp; death</vh>
<v t="T302"><vh>wxGui.__init__</vh></v>
<v t="T303" a="M"><vh>createRootWindow &amp; allies</vh>
<v t="T304"><vh>setDefaultIcon</vh></v>
<v t="T305"><vh>setEncoding</vh></v>
<v t="T306"><vh>getDefaultConfigFont</vh></v>
<v t="T307"><vh>createGlobalWindows</vh></v>
</v>
<v t="T308"><vh>destroy</vh></v>
<v t="T309"><vh>finishCreate</vh></v>
<v t="T310"><vh>killGui (not used)</vh></v>
<v t="T311"><vh>recreateRootWindow (not used)</vh></v>
<v t="T312"><vh>runMainLoop</vh></v>
</v>
<v t="T313"><vh>Called by leoConfig</vh>
<v t="T314"><vh>getFontFromParams</vh></v>
</v>
<v t="T315"><vh>Dialogs</vh></v>
<v t="T316"><vh>Frames</vh>
<v t="T317"><vh>newLeoFrame</vh></v>
<v t="T318"><vh>other frames...</vh></v>
<v t="T319"><vh>destroyLeoFrame</vh></v>
<v t="T320"><vh>destroy</vh></v>
</v>
<v t="T321" a="M"><vh>Focus</vh>
<v t="T322"><vh>get_focus</vh></v>
<v t="T323"><vh>set_focus</vh></v>
<v t="T324"><vh>force_focus</vh></v>
</v>
<v t="T325" a="M"><vh>Dialog &amp; Icon utils</vh>
<v t="T326"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="T327"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="T328"><vh>createLeoIcon</vh></v>
</v>
<v t="T329"><vh>get_window_info</vh></v>
<v t="T330"><vh>center_dialog</vh></v>
<v t="T331"><vh>create_labeled_frame</vh></v>
</v>
</v>
<v t="T332"><vh>wxLeoApp class</vh>
<v t="T333"><vh>OnInit</vh></v>
<v t="T334"><vh>OnExit</vh></v>
</v>
<v t="T335"><vh>wxLeoFrame class</vh>
<v t="T336"><vh>Birth &amp; death</vh>
<v t="T254" a="C"><vh>__init__</vh>
<v t="T255"><vh>&lt;&lt; create the splitters &gt;&gt;</vh></v>
<v t="T256"><vh>&lt;&lt; create the tree &gt;&gt;</vh></v>
<v t="T257"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T258"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
<v t="T259"><vh>&lt;&lt; set the window icon &gt;&gt;</vh></v>
<v t="T260"><vh>&lt;&lt; declare event handlers for frame &gt;&gt;</vh></v>
<v t="T261"><vh>&lt;&lt; declare event handlers for body &amp; tree &gt;&gt;</vh></v>
</v>
<v t="T337"><vh>__repr__</vh></v>
<v t="T253" a="C"><vh>finishCreate</vh></v>
<v t="T338"><vh>createMenuBar</vh>
<v t="T339"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T340"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T341"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="T342"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T343"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T344"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T345"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="T346"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="T347"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T348"><vh>&lt;&lt; create the first top-level edit entries &gt;&gt;</vh></v>
<v t="T349"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T350"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="T351"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
<v t="T352"><vh>&lt;&lt; create the last top-level edit entries &gt;&gt;</vh></v>
</v>
<v t="T353"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T354"><vh>&lt;&lt; create top-level outline menu &gt;&gt;</vh></v>
<v t="T355"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="T356"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="T357"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="T358"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="T359"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T360"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T361"><vh>createMenuEntries</vh></v>
</v>
<v t="T262" a="C"><vh>event handlers</vh>
<v t="T263"><vh>Frame events</vh>
<v t="T264"><vh>onActivate &amp; OnSetFocus</vh></v>
<v t="T265"><vh>onCloseLeoFrame</vh>
<v t="T266"><vh>&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;</vh></v>
<v t="T267"><vh>&lt;&lt; Close the permanent frames &gt;&gt;</vh></v>
</v>
<v t="T268"><vh>onResize</vh></v>
</v>
<v t="T269"><vh>Body events</vh>
<v t="T270"><vh>onBodyTextUpdated</vh>
<v t="T271"><vh>&lt;&lt; Set the dirty bit and/or the file-changed mark if the text has changed &gt;&gt;</vh></v>
<v t="T272"><vh>&lt;&lt; Update icons &gt;&gt;</vh></v>
</v>
</v>
<v t="T273"><vh>Tree events</vh>
<v t="T274"><vh>Expand/contract</vh>
<v t="T275"><vh>onTreeCollapsed &amp; onTreeExpanded</vh></v>
<v t="T276"><vh>onTreeCollapsing &amp; onTreeExpanding</vh></v>
</v>
<v t="T277"><vh>Selecting</vh>
<v t="T278"><vh>onTreeChanged</vh></v>
<v t="T279"><vh>onTreeChanging</vh></v>
</v>
<v t="T280"><vh>Editing labels</vh>
<v t="T281"><vh>onTreeBeginLabelEdit</vh></v>
<v t="T282"><vh>onTreeEndLabelEdit</vh></v>
<v t="T283"><vh>onTreeKeyDown</vh></v>
</v>
<v t="T284"><vh>onTreeBeginDrag</vh></v>
<v t="T285"><vh>onTreeEndDrag</vh>
<v t="T286"><vh>&lt;&lt; Define onTreeEndDrag vars &gt;&gt;</vh></v>
<v t="T287"><vh>&lt;&lt; Insert src as the first child of dst &gt;&gt;</vh></v>
<v t="T288"><vh>&lt;&lt; Insert src after dst &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T362"><vh>Notifications: probably will never be called</vh></v>
<v t="T363"><vh>Vnode callbacks: probably will never be called</vh></v>
<v t="T364"><vh>Externally visible routines...</vh>
<v t="T365"><vh> dummy routines: not ready yet</vh></v>
<v t="T366"><vh>deiconify</vh></v>
<v t="T367"><vh>getTitle</vh></v>
<v t="T368"><vh>put &amp; putnl</vh></v>
<v t="T369"><vh>select</vh></v>
</v>
<v t="T289" a="CM"><vh>Interface with the tree class</vh>
<v t="T290"><vh>beginUpdate</vh></v>
<v t="T291"><vh>endUpdate</vh></v>
<v t="T292"><vh>Getters</vh></v>
<v t="T293"><vh>redraw &amp; redraw_now</vh></v>
<v t="T294"><vh>redraw_node</vh></v>
<v t="T295"><vh>redraw_subtree</vh></v>
<v t="T296"><vh>Setters</vh></v>
</v>
<v t="T370"><vh>Menu updaters</vh>
<v t="T371"><vh>updateAllMenus</vh></v>
<v t="T372"><vh>File menu...</vh>
<v t="T373"><vh>OnUpdateRevert</vh></v>
</v>
<v t="T374"><vh>Edit menu...</vh>
<v t="T375"><vh>OnUpdateCopy</vh></v>
<v t="T376"><vh>OnUpdateCut</vh></v>
<v t="T377"><vh>OnUpdateDelete</vh></v>
<v t="T378"><vh>OnUpdateExtract</vh></v>
<v t="T379"><vh>OnUpdateExtractNames</vh></v>
<v t="T380"><vh>OnUpdateExtractSection</vh></v>
<v t="T381"><vh>OnUpdateFind</vh></v>
<v t="T382"><vh>OnUpdatePaste</vh></v>
<v t="T383"><vh>OnUpdateRedo</vh></v>
<v t="T384"><vh>OnUpdateReplace</vh></v>
<v t="T385"><vh>OnUpdateSelectAll</vh></v>
<v t="T386"><vh>OnUpdateUndo</vh></v>
<v t="T387"><vh>hasSelection</vh></v>
</v>
<v t="T388"><vh>Outline menu...</vh>
<v t="T389"><vh>OnUpdateContractAll</vh></v>
<v t="T390"><vh>OnUpdateContractAllChildren</vh></v>
<v t="T391"><vh>OnUpdateContractChildren</vh></v>
<v t="T392"><vh>OnUpdateCutNode</vh></v>
<v t="T393"><vh>OnUpdateDeleteNode</vh></v>
<v t="T394"><vh>OnUpdateDemote</vh></v>
<v t="T395"><vh>OnUpdateExpandAll</vh></v>
<v t="T396"><vh>OnUpdateExpandAllChildren</vh></v>
<v t="T397"><vh>OnUpdateExpandChildren</vh></v>
<v t="T398"><vh>OnUpdateGoBack</vh></v>
<v t="T399"><vh>OnUpdateGoNext</vh></v>
<v t="T400"><vh>OnUpdateGoNextVisible</vh></v>
<v t="T401"><vh>OnUpdateGoPrevVisible</vh></v>
<v t="T402"><vh>OnUpdateGoToNextChanged</vh></v>
<v t="T403"><vh>OnUpdateGoToNextMarked</vh></v>
<v t="T404"><vh>OnUpdateMark</vh></v>
<v t="T405"><vh>OnUpdateMarkChangedItems</vh></v>
<v t="T406"><vh>OnUpdateMarkChangedRoots</vh></v>
<v t="T407"><vh>OnUpdateMarkSubheads</vh></v>
<v t="T408"><vh>OnUpdateMoveDown</vh></v>
<v t="T409"><vh>OnUpdateMoveLeft</vh></v>
<v t="T410"><vh>OnUpdateMoveRight</vh></v>
<v t="T411"><vh>OnUpdateMoveUp</vh></v>
<v t="T412"><vh>OnUpdatePasteNode</vh></v>
<v t="T413"><vh>OnUpdatePromote</vh></v>
<v t="T414"><vh>OnUpdateSortNode</vh></v>
</v>
</v>
<v t="T415"><vh>Menu command handlers...</vh>
<v t="T416"><vh>File Menu...</vh>
<v t="T417"><vh>OnNew</vh></v>
<v t="T418"><vh>OnOpen</vh></v>
<v t="T419"><vh>OnClose</vh></v>
<v t="T420"><vh>OnSave</vh></v>
<v t="T421"><vh>OnSaveAs</vh></v>
<v t="T422"><vh>OnSaveTo</vh></v>
<v t="T423"><vh>OnRevert</vh></v>
<v t="T424"><vh>OnPageSetup</vh></v>
<v t="T425"><vh>OnPrint</vh></v>
<v t="T426"><vh>OnTangleSubmenu</vh></v>
<v t="T427"><vh>OnUntangleSubmenu</vh></v>
<v t="T428"><vh>OnImportExportSubmenu</vh></v>
<v t="T429"><vh>OnQuit</vh></v>
<v t="T430"><vh>OnReadOutlineOnly</vh></v>
<v t="T431"><vh>readOutlineOnly</vh></v>
<v t="T432"><vh>OnReadAtFileNodes</vh></v>
<v t="T433"><vh>OnWriteOutlineOnly</vh></v>
<v t="T434"><vh>OnWriteAtFileNodes</vh></v>
<v t="T435"><vh>OnTangleAll</vh></v>
<v t="T436"><vh>OnTangleMarked</vh></v>
<v t="T437"><vh>OnTangle</vh></v>
<v t="T438"><vh>OnUntangleAll</vh></v>
<v t="T439"><vh>OnUntangleMarked</vh></v>
<v t="T440"><vh>OnUntangle</vh></v>
<v t="T441"><vh>OnImportFiles</vh></v>
<v t="T442"><vh>OnImportCWEBFiles</vh></v>
<v t="T443"><vh>OnImportNowebFiles</vh></v>
<v t="T444"><vh>OnImportMoreText</vh></v>
<v t="T445"><vh>OnFlattenOutline</vh></v>
</v>
<v t="T446"><vh>Edit menu...</vh>
<v t="T447"><vh>OnUndo</vh></v>
<v t="T448"><vh>OnRedo</vh></v>
<v t="T449"><vh>OnCut</vh></v>
<v t="T450"><vh>OnCopy</vh></v>
<v t="T451"><vh>OnPaste</vh></v>
<v t="T452"><vh>OnDelete</vh></v>
<v t="T453"><vh>OnSelectAll</vh></v>
<v t="T454"><vh>OnEditHeadline</vh></v>
<v t="T455"><vh>OnFontPanel</vh></v>
<v t="T456"><vh>OnSyntaxColoring</vh></v>
<v t="T457"><vh>OnPreferences</vh></v>
<v t="T458"><vh>OnConvertBlanks</vh></v>
<v t="T459"><vh>OnExtractSection</vh></v>
<v t="T460"><vh>OnExtractNames</vh></v>
<v t="T461"><vh>OnExtract</vh></v>
<v t="T462"><vh>OnFindPanel</vh></v>
<v t="T463"><vh>OnFindNext</vh></v>
<v t="T464"><vh>OnFindPrevious</vh></v>
<v t="T465"><vh>OnReplace</vh></v>
<v t="T466"><vh>OnReplaceThenFind</vh></v>
</v>
<v t="T467"><vh>Outline menu...</vh>
<v t="T468"><vh>Cut/Paste/Copy/Delete</vh>
<v t="T469"><vh>OnCutNode</vh></v>
<v t="T470"><vh>OnCopyNode</vh></v>
<v t="T471"><vh>OnPasteNode</vh></v>
</v>
<v t="T472"><vh>Expand/Contract</vh>
<v t="T473"><vh>OnExpandAll</vh></v>
<v t="T474"><vh>OnExpandAllChildren</vh></v>
<v t="T475"><vh>OnExpandChildren</vh></v>
<v t="T476"><vh>OnContractAll</vh></v>
<v t="T477"><vh>OnContractAllChildren</vh></v>
<v t="T478"><vh>OnContractChildren</vh></v>
<v t="T479"><vh>OnExpandNextLevel</vh></v>
<v t="T480"><vh>OnExpandToLevel1</vh></v>
<v t="T481"><vh>OnExpandToLevel2</vh></v>
<v t="T482"><vh>OnExpandToLevel3</vh></v>
<v t="T483"><vh>OnExpandToLevel4</vh></v>
<v t="T484"><vh>OnExpandToLevel5</vh></v>
<v t="T485"><vh>OnExpandToLevel6</vh></v>
<v t="T486"><vh>OnExpandToLevel7</vh></v>
<v t="T487"><vh>OnExpandToLevel8</vh></v>
<v t="T488"><vh>OnExpandToLevel9</vh></v>
</v>
<v t="T489"><vh>Insert/Delete/Clone</vh>
<v t="T490"><vh>OnDeleteNode</vh></v>
<v t="T491"><vh>OnInsertNode</vh></v>
<v t="T492"><vh>OnCloneNode</vh></v>
</v>
<v t="T493"><vh>Mark/Goto</vh>
<v t="T494"><vh>OnGoPrevVisible</vh></v>
<v t="T495"><vh>OnGoNextVisible</vh></v>
<v t="T496"><vh>OnGoBack</vh></v>
<v t="T497"><vh>OnGoNext</vh></v>
<v t="T498"><vh>OnMark</vh></v>
<v t="T499"><vh>OnMarkSubheads</vh></v>
<v t="T500"><vh>OnMarkChangedItems</vh></v>
<v t="T501"><vh>OnMarkChangedRoots</vh></v>
<v t="T502"><vh>OnMarkAllAtFileNodesDirty</vh></v>
<v t="T503"><vh>OnMarkAtFileNodesDirty</vh></v>
<v t="T504"><vh>OnUnmarkAll</vh></v>
<v t="T505"><vh>OnGoToNextMarked</vh></v>
<v t="T506"><vh>OnGoToNextChanged</vh></v>
</v>
<v t="T507"><vh>Move/Promote/Demote</vh>
<v t="T508"><vh>OnMoveDown</vh></v>
<v t="T509"><vh>OnMoveLeft</vh></v>
<v t="T510"><vh>OnMoveRight</vh></v>
<v t="T511"><vh>OnMoveUp</vh></v>
<v t="T512"><vh>OnPromote</vh></v>
<v t="T513"><vh>OnDemote</vh></v>
</v>
<v t="T514"><vh>Sort</vh>
<v t="T515"><vh>OnSortNode</vh></v>
</v>
</v>
<v t="T516"><vh>Window menu...</vh>
<v t="T517"><vh>OnEqualSizedPanes</vh></v>
<v t="T518"><vh>OnToggleActivePane</vh></v>
<v t="T519"><vh>OnChangeDirection</vh></v>
<v t="T520"><vh>OnCascade</vh></v>
<v t="T521"><vh>OnMinimizeAll</vh></v>
<v t="T522"><vh>OnOpenPythonWindow</vh></v>
<v t="T523"><vh>OnRecentWindows</vh></v>
</v>
<v t="T524"><vh>Help menu...</vh>
<v t="T525"><vh>OnAbout</vh></v>
</v>
</v>
</v>
<v t="T526"><vh>Find...</vh>
<v t="T527"><vh>wxFindFrame class</vh>
<v t="T528"><vh>&lt;&lt; FindPanel public globals &gt;&gt; (to be moved to Leo's core)</vh></v>
<v t="T529"><vh>FindFrame.__init__</vh>
<v t="T530"><vh>&lt;&lt; declare event handlers &gt;&gt;</vh></v>
</v>
<v t="T531"><vh>Event handlers</vh>
<v t="T532"><vh>OnActivateFindFrame &amp; OnSetFocus</vh></v>
<v t="T533"><vh>OnCloseFindFrame</vh></v>
<v t="T534"><vh>OnChangeButton</vh></v>
<v t="T535"><vh>OnChangeAllButton</vh></v>
<v t="T536"><vh>OnChangeThenFindButton</vh></v>
<v t="T537"><vh>OnFindButton</vh></v>
<v t="T538"><vh>OnFindAllButton</vh></v>
<v t="T539"><vh>OnBatchCheckBox</vh></v>
<v t="T540"><vh>OnIgnoreCaseCheckBox</vh></v>
<v t="T541"><vh>OnMarkChangesCheckBox</vh></v>
<v t="T542"><vh>OnMarkFindsCheckBox</vh></v>
<v t="T543"><vh>OnPatternMatchCheckBox</vh></v>
<v t="T544"><vh>OnReverseCheckBox</vh></v>
<v t="T545"><vh>OnSearchBodyTextCheckBox</vh></v>
<v t="T546"><vh>OnSearchHeadlineCheckBox</vh></v>
<v t="T547"><vh>OnSuboutlineOnlyCheckBox</vh></v>
<v t="T548"><vh>OnWrapAroundCheckBox</vh></v>
<v t="T549"><vh>OnWholeWordCheckBox</vh></v>
<v t="T550"><vh>OnChangeText</vh></v>
<v t="T551"><vh>OnFindText</vh></v>
</v>
<v t="T552"><vh>Interface with commander</vh></v>
<v t="T553"><vh>set_check_boxes</vh></v>
</v>
<v t="T554"><vh>wxFindPanel class</vh>
<v t="T555"><vh>FindPanel.__init__</vh>
<v t="T556"><vh>&lt;&lt; Create the find text box &gt;&gt;</vh></v>
<v t="T557"><vh>&lt;&lt; Create the change text box &gt;&gt;</vh></v>
<v t="T558"><vh>&lt;&lt; Create all the find check boxes &gt;&gt;</vh>
<v t="T559"><vh>&lt;&lt; Create the first column of check boxes &gt;&gt;</vh></v>
<v t="T560"><vh>&lt;&lt; Create the second column of check boxes &gt;&gt;</vh></v>
</v>
<v t="T561"><vh>&lt;&lt; Create all the find buttons &gt;&gt;</vh>
<v t="T562"><vh>&lt;&lt; Create the first row of buttons &gt;&gt;</vh></v>
<v t="T563"><vh>&lt;&lt; Create the second row of buttons &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T564"><vh>wxLeoPrefs class</vh>
<v t="T565"><vh>wxLeoPrefs.__init__</vh>
<v t="T566"><vh>&lt;&lt; define event handlers for wxLeoPrefsFrame &gt;&gt;</vh></v>
</v>
<v t="T567"><vh>initialize</vh></v>
<v t="T568"><vh>targetToLanguage (should be in Leo's core)</vh></v>
<v t="T569"><vh>languageToTarget (should be in Leo's core)</vh></v>
<v t="T570"><vh>Event handlers</vh>
<v t="T571"><vh>OnActivatePrefsFrame</vh></v>
<v t="T572"><vh>OnClosePrefsFrame</vh></v>
<v t="T573"><vh>OnPageWidthText</vh></v>
<v t="T574"><vh>OnDoneBatCheckBox</vh></v>
<v t="T575"><vh>OnUnBatCheckBox</vh></v>
<v t="T576"><vh>OnTangleDirectoryText</vh></v>
<v t="T577"><vh>OnHeaderCheckBox</vh></v>
<v t="T578"><vh>OnDocChunksCheckBox</vh></v>
<v t="T579"><vh>OnTargetLanguageRadioBox</vh></v>
</v>
<v t="T580"><vh>PrefsPanel.__init__</vh>
<v t="T581"><vh>&lt;&lt; Create the Global Options static box &gt;&gt;</vh></v>
<v t="T582"><vh>&lt;&lt; Create the Default Tangle Options static box &gt;&gt;</vh></v>
<v t="T583"><vh>&lt;&lt; Create the Default Target Language radio buttons &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="T584" a="EV"><vh>Plugins</vh>
<v t="T585"><vh>Commands</vh>
<v t="T586"><vh> Importing Cisco configuration files</vh>
<v t="T587" tnodeList="587,588,589,590,591,592,593,594"><vh>@file import_cisco_config.py</vh>
<v t="T588"><vh>&lt;&lt; about this plugin &gt;&gt;</vh></v>
<v t="T589"><vh>create_import_cisco_menu</vh></v>
<v t="T590"><vh>importCiscoConfig</vh>
<v t="T591"><vh>&lt;&lt; open file &gt;&gt;</vh></v>
<v t="T592"><vh>&lt;&lt; process custom line &gt;&gt;</vh></v>
<v t="T593"><vh>&lt;&lt; process indented block &gt;&gt;</vh></v>
<v t="T594"><vh>&lt;&lt; complete outline &gt;&gt;</vh></v>
</v>
</v>
<v t="T595"><vh> Example of an imported config</vh>
<v t="T596"><vh>plain configuration</vh></v>
<v t="T597"><vh>cisco config: C:/Davide/Leo/CVS Version/example_conf.txt</vh>
<v t="T598"><vh>&lt;&lt;access-list&gt;&gt;</vh></v>
<v t="T599"><vh>&lt;&lt;boot&gt;&gt;</vh></v>
<v t="T600"><vh>&lt;&lt;controller&gt;&gt;</vh>
<v t="T601"><vh>controller E1 5/0/0</vh></v>
<v t="T602"><vh>controller E1 5/0/1</vh></v>
<v t="T603"><vh>controller SONET 1/0/0</vh></v>
</v>
<v t="T604"><vh>&lt;&lt;interface&gt;&gt;</vh>
<v t="T605"><vh>interface Async1</vh></v>
<v t="T606"><vh>interface Dialer0</vh></v>
<v t="T607"><vh>interface FastEthernet0/0/0</vh></v>
<v t="T608"><vh>interface FastEthernet0/0/1</vh></v>
<v t="T609"><vh>interface FastEthernet0/0/1.1</vh></v>
<v t="T610"><vh>interface FastEthernet0/0/1.2</vh></v>
<v t="T611"><vh>interface FastEthernet0/0/1.3</vh></v>
<v t="T612"><vh>interface FastEthernet0/0/1.5</vh></v>
<v t="T613"><vh>interface FastEthernet0/0/1.50</vh></v>
<v t="T614"><vh>interface Loopback0</vh></v>
<v t="T615"><vh>interface POS4/1/0</vh></v>
<v t="T616"><vh>interface Serial5/0/0:1</vh></v>
<v t="T617"><vh>interface Serial5/0/0:2</vh></v>
<v t="T618"><vh>interface Serial5/0/1:0</vh></v>
<v t="T619"><vh>interface Serial5/1/0</vh></v>
<v t="T620"><vh>interface Serial5/1/1</vh></v>
</v>
<v t="T621"><vh>&lt;&lt;ip community-list&gt;&gt;</vh></v>
<v t="T622"><vh>&lt;&lt;ip route&gt;&gt;</vh></v>
<v t="T623"><vh>&lt;&lt;line&gt;&gt;</vh>
<v t="T624"><vh>line aux 0</vh></v>
<v t="T625"><vh>line vty 0 4</vh></v>
</v>
<v t="T626"><vh>&lt;&lt;logging&gt;&gt;</vh></v>
<v t="T627"><vh>&lt;&lt;ntp&gt;&gt;</vh></v>
<v t="T628"><vh>&lt;&lt;route-map&gt;&gt;</vh>
<v t="T629"><vh>route-map only permit 2</vh></v>
<v t="T630"><vh>route-map only1 permit 10</vh></v>
<v t="T631"><vh>route-map only3 permit 10</vh></v>
<v t="T632"><vh>route-map tag_com permit 10</vh></v>
<v t="T633"><vh>route-map tag_com permit 20</vh></v>
</v>
<v t="T634"><vh>&lt;&lt;router&gt;&gt;</vh>
<v t="T635"><vh>router bgp 65001</vh></v>
<v t="T636"><vh>router ospf 1</vh></v>
</v>
<v t="T637"><vh>&lt;&lt;service&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T638" tnodeList="638,639"><vh>@file outline_export.py</vh>
<v t="T639"><vh>newMoreHead</vh></v>
</v>
<v t="T640"><vh>mod_autosave</vh>
<v t="T641" tnodeList="641"><vh>@file mod_autosave.ini</vh></v>
<v t="T642" tnodeList="642,643,644"><vh>@file mod_autosave.py</vh>
<v t="T643"><vh>applyConfiguration</vh></v>
<v t="T644"><vh>autosave</vh></v>
</v>
</v>
<v t="T645" tnodeList="645,646"><vh>@file mod_timestamp.py</vh>
<v t="T646"><vh>timestamp</vh></v>
</v>
</v>
<v t="T647"><vh>Debugging</vh>
<v t="T648" tnodeList="648,649"><vh>@file dump_globals.py</vh>
<v t="T649"><vh>onStart</vh></v>
</v>
<v t="T650" tnodeList="650,651"><vh>@file enable_gc.py</vh>
<v t="T651"><vh>onStart</vh></v>
</v>
<v t="T652" tnodeList="652"><vh>@file trace_gc.py</vh></v>
<v t="T653" tnodeList="653,654"><vh>@file trace_keys.py</vh>
<v t="T654"><vh>onKey</vh></v>
</v>
<v t="T655" tnodeList="655,656"><vh>@file trace_tags.py</vh>
<v t="T656"><vh>trace_tags</vh></v>
</v>
</v>
<v t="T657"><vh>Directives</vh>
<v t="T658" tnodeList="658,659,660"><vh>@file add_directives.py</vh>
<v t="T659"><vh>addPluginDirectives</vh></v>
<v t="T660"><vh>scanPluginDirectives</vh></v>
</v>
</v>
<v t="T661"><vh>Drawing, graphics &amp; styled text</vh>
<v t="T662" tnodeList="662,663,664,665,666,667,668,669"><vh>@file color_markup.py</vh>
<v t="T663"><vh>initAnyMarkup</vh></v>
<v t="T664"><vh>colorWikiMarkup</vh></v>
<v t="T665"><vh>doWikiText</vh>
<v t="T666"><vh>&lt;&lt; set first to a tuple describing the first tag to be handled &gt;&gt;</vh></v>
<v t="T667"><vh>&lt;&lt; handle the tag using n1,n2,delim1,delim2 &gt;&gt;</vh>
<v t="T668"><vh>&lt;&lt; parse and handle color field &gt;&gt;</vh></v>
</v>
</v>
<v t="T669"><vh>insertWikiPicture</vh></v>
</v>
<v t="T670" tnodeList="670,671,672,673,674"><vh>@file image.py</vh>
<v t="T671"><vh>onSelect</vh>
<v t="T672"><vh>&lt;&lt; Select Image &gt;&gt;</vh></v>
</v>
<v t="T673"><vh>onUnselect</vh>
<v t="T674"><vh>&lt;&lt; Unselect Image &gt;&gt;</vh></v>
</v>
</v>
<v t="T675" tnodeList="675,676,677,678,679,680,681,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706"><vh>@file nav_buttons.py</vh>
<v t="T676"><vh>class commanderInfoClass</vh>
<v t="T677"><vh>__init__ (commanderInfoClass)</vh></v>
<v t="T678"><vh>addWidgets</vh>
<v t="T679"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
<v t="T680"><vh>createImage</vh></v>
<v t="T681"><vh>updateNavButtons (nav_buttons.py)</vh></v>
<v t="T682"><vh>Callbacks</vh>
<v t="T683"><vh>marksButtonCallback</vh></v>
<v t="T684"><vh>recentButtonCallback</vh></v>
</v>
</v>
<v t="T685"><vh>class globalInfoClass</vh>
<v t="T686"><vh>__init__ ( globalInfoClass)</vh></v>
<v t="T687"><vh>addNavWidgets</vh></v>
<v t="T688"><vh>destroyFrame, destroyAllFrames, destroyOneFrame</vh></v>
<v t="T689"><vh>updateRecentSections</vh></v>
<v t="T690"><vh>updateMarks &amp; updateMarksAfterCommand</vh></v>
<v t="T691"><vh>updateNavButtons</vh></v>
</v>
<v t="T692"><vh>class marksDialog (listBoxDialog)</vh>
<v t="T693"><vh>marksDialog.__init__</vh></v>
<v t="T694"><vh>createFrame</vh></v>
<v t="T695"><vh>addbuttons</vh></v>
<v t="T696"><vh>fillbox</vh></v>
</v>
<v t="T697"><vh>class recentSectionsDialog (listBoxDialog)</vh>
<v t="T698"><vh>__init__  recentSectionsDialog</vh></v>
<v t="T699"><vh>addButtons</vh></v>
<v t="T700"><vh>clearAll</vh></v>
<v t="T701"><vh>createFrame</vh></v>
<v t="T702"><vh>deleteEntry</vh></v>
<v t="T703"><vh>destroy</vh></v>
<v t="T704"><vh>fillbox (recent sections)</vh>
<v t="T705"><vh>&lt;&lt; reconstruct the contents of self.box &gt;&gt;&gt;</vh></v>
</v>
<v t="T706"><vh>synchNavButtons</vh></v>
</v>
</v>
</v>
<v t="T707"><vh>External editors &amp; Open With</vh>
<v t="T708" tnodeList="708,709,710,711,712,713"><vh>@file open_with.py</vh>
<v t="T709"><vh>on_idle</vh>
<v t="T710"><vh>&lt;&lt; update v's body text &gt;&gt;</vh>
<v t="T711"><vh>&lt;&lt; set s to the file text &gt;&gt;</vh></v>
</v>
</v>
<v t="T712"><vh>create_open_with_menu</vh>
<v t="T713"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
</v>
</v>
<v t="T714" tnodeList="714"><vh>@file xemacs.py</vh></v>
<v t="T715"><vh>Vim</vh>
<v t="T716" a="M" tnodeList="716,717"><vh>@file vim.py</vh>
<v t="T717"><vh>open_in_vim</vh></v>
</v>
<v t="T718" tnodeList="718,719"><vh>vim.py (previous version)</vh>
<v t="T719"><vh>open_in_vim</vh></v>
</v>
</v>
<v t="T720"><vh>Word export</vh>
<v t="T721" tnodeList="721,722,723,724,725,726"><vh>@file word_export.py</vh>
<v t="T722"><vh>getConfiguration</vh></v>
<v t="T723"><vh>getWordConnection</vh></v>
<v t="T724"><vh>doPara</vh></v>
<v t="T725"><vh>writeNodeAndTree</vh></v>
<v t="T726"><vh>cmd_Export</vh></v>
</v>
<v t="T727" tnodeList="727"><vh>@file word_export.ini</vh></v>
</v>
</v>
<v t="T728"><vh>Files</vh>
<v t="T729" tnodeList="729,730,731"><vh>@file empty_leo_file.py</vh>
<v t="T730"><vh>&lt;&lt; define minimal .leo file &gt;&gt;</vh></v>
<v t="T731"><vh>onOpen</vh></v>
</v>
<v t="T732" tnodeList="732,733,734,735,736,737,738,739"><vh>@file open_shell.py</vh>
<v t="T733"><vh>&lt;&lt; about the open shell plugin &gt;&gt;</vh></v>
<v t="T734"><vh>load_menu</vh></v>
<v t="T735"><vh>_getpath</vh></v>
<v t="T736"><vh>_getcurrentnodepath</vh></v>
<v t="T737"><vh>launchCmd</vh></v>
<v t="T738"><vh>launchExplorer</vh></v>
<v t="T739"><vh>launchxTerm</vh></v>
</v>
</v>
<v t="T740"><vh>Foreign languages</vh>
<v t="T741" tnodeList="741,742"><vh>@file french.py</vh>
<v t="T742"><vh>onMenu</vh></v>
</v>
<v t="T743" tnodeList="743,744"><vh>@file french_fm.py</vh>
<v t="T744"><vh>onMenu</vh></v>
</v>
</v>
<v t="T745"><vh>Key bindings</vh>
<v t="T746" tnodeList="746,747"><vh>@file arrows.py</vh>
<v t="T747"><vh>onOpen</vh></v>
</v>
</v>
<v t="T748"><vh>Menus</vh>
<v t="T749"><vh> Plugins menu</vh>
<v t="T750" tnodeList="750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772"><vh>@file plugins_menu.py</vh>
<v t="T751"><vh>class Plugin</vh>
<v t="T752"><vh>__init__</vh>
<v t="T753"><vh>&lt;&lt; Check if this can be configured &gt;&gt;</vh></v>
<v t="T754"><vh>&lt;&lt; Check if this has an apply &gt;&gt;</vh></v>
<v t="T755"><vh>&lt;&lt; Look for additional commands &gt;&gt;</vh></v>
</v>
<v t="T756"><vh>about</vh></v>
<v t="T757"><vh>properties</vh></v>
</v>
<v t="T758"><vh>class PropertiesWindow</vh>
<v t="T759"><vh>__init__</vh>
<v t="T760"><vh>&lt;&lt; initialize all ivars &gt;&gt;</vh></v>
<v t="T761"><vh>&lt;&lt; create the frame from the configuration data &gt;&gt;</vh>
<v t="T762"><vh>&lt;&lt; Create the top level and the main frame &gt;&gt;</vh></v>
<v t="T763"><vh>&lt;&lt; Create widgets for each section and option &gt;&gt;</vh></v>
<v t="T764"><vh>&lt;&lt; Create Ok, Cancel and Apply buttons &gt;&gt;</vh></v>
</v>
</v>
<v t="T765"><vh>Event Handlers</vh></v>
<v t="T766"><vh>writeConfiguration</vh></v>
</v>
<v t="T767"><vh>class PluginAbout</vh>
<v t="T768"><vh>__init__</vh>
<v t="T769"><vh>&lt;&lt; Create the contents of the about box &gt;&gt;</vh></v>
<v t="T770"><vh>&lt;&lt; Create the close button &gt;&gt;</vh></v>
</v>
</v>
<v t="T771"><vh>createPluginsMenu</vh>
<v t="T772"><vh>&lt;&lt; add items to the plugins menu &gt;&gt;</vh></v>
</v>
</v>
<v t="T773"><vh>@file test.py</vh>
<v t="T774"><vh>applyConfiguration</vh></v>
<v t="T775"><vh>cmd_fn1/2/3</vh></v>
<v t="T776"><vh>onSelect</vh>
<v t="T777"><vh>&lt;&lt; Select Image &gt;&gt;</vh></v>
</v>
<v t="T778"><vh>onUnselect</vh>
<v t="T779"><vh>&lt;&lt; Unselect Image &gt;&gt;</vh></v>
</v>
</v>
<v t="T780"><vh>Notes re plugins menu</vh>
<v t="T781"><vh> Changes made by E.K.Ream</vh></v>
<v t="T782"><vh> Design</vh></v>
<v t="T783"><vh> Initial suggestion from Paul Paterson</vh></v>
</v>
</v>
<v t="T784" tnodeList="784,785,786,787,788"><vh>@file scripts_menu.py</vh>
<v t="T785"><vh>createScriptsMenu</vh>
<v t="T786"><vh>&lt;&lt; Return if no scripts exist anywhere &gt;&gt;</vh></v>
<v t="T787"><vh>&lt;&lt; Create top-level entries for every script in top_scripts &gt;&gt;</vh></v>
<v t="T788"><vh>&lt;&lt; Create a submenu for dir containing each file in files &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T789"><vh>New kinds of nodes</vh>
<v t="T790" tnodeList="790,791,792"><vh>@file at_folder.py</vh>
<v t="T791"><vh>&lt;&lt; about this plugin &gt;&gt;</vh></v>
<v t="T792"><vh>sync_node_to_folder</vh></v>
</v>
<v t="T793" tnodeList="793,794,795,796,797,799,800,802,804,805,806,807,808,809,810,811,812,813,814,815,816,817"><vh>@file read_only_nodes.py</vh>
<v t="T794"><vh>documentation for @read-only nodes</vh>
<v t="T795"><vh>ftp/http access</vh></v>
</v>
<v t="T796"><vh>class FTPurl</vh>
<v t="T797"><vh>__init__</vh></v>
<v t="T798"><vh>Getters</vh>
<v t="T799"><vh>read</vh></v>
<v t="T800"><vh>readline</vh></v>
</v>
<v t="T801"><vh>Setters</vh>
<v t="T802"><vh>write</vh></v>
</v>
<v t="T803"><vh>Utilities</vh>
<v t="T804"><vh>seek</vh></v>
<v t="T805"><vh>flush</vh></v>
<v t="T806"><vh>dir</vh></v>
<v t="T807"><vh>exists</vh></v>
<v t="T808"><vh>checkParams</vh></v>
</v>
<v t="T809"><vh>close</vh></v>
</v>
<v t="T810"><vh>enable/disable_body</vh></v>
<v t="T811"><vh>insert_read_only_node (FTP version)</vh>
<v t="T812"><vh>&lt;&lt; convert HTML to text &gt;&gt;</vh></v>
</v>
<v t="T813"><vh>on_open2</vh></v>
<v t="T814"><vh>on_bodykey1</vh></v>
<v t="T815"><vh>on_headkey2</vh></v>
<v t="T816"><vh>on_select1</vh></v>
<v t="T817"><vh>on_select2</vh></v>
</v>
<v t="T818" tnodeList="818,819,820,821,822,823,824,825,826"><vh>@file rst.py</vh>
<v t="T819"><vh>&lt;&lt;about this plugin &gt;&gt;</vh></v>
<v t="T820"><vh>&lt;&lt; change log &gt;&gt;</vh></v>
<v t="T821"><vh>onIconDoubleClick</vh>
<v t="T822"><vh>&lt;&lt; write rST as HTML &gt;&gt;</vh>
<v t="T823"><vh>&lt;&lt; convert rST to HTML &gt;&gt;</vh></v>
</v>
<v t="T824"><vh>&lt;&lt; write rST file &gt;&gt;</vh></v>
</v>
<v t="T825"><vh>writeTreeAsRst</vh></v>
<v t="T826"><vh>underline</vh></v>
</v>
<v t="T827" tnodeList="827,828,829,830,831"><vh>@file startfile.py</vh>
<v t="T828"><vh>&lt;&lt;about this plugin &gt;&gt;</vh></v>
<v t="T829"><vh>&lt;&lt; change log &gt;&gt;</vh></v>
<v t="T830"><vh>onIconDoubleClick</vh>
<v t="T831"><vh>&lt;&lt; find path and start file &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T832"><vh>Overriding functions, methods &amp; classes</vh>
<v t="T833" tnodeList="833,834,835"><vh>@file __overrideClasses.py</vh>
<v t="T834"><vh>&lt;&lt; override the LeoFrame class &gt;&gt;</vh></v>
<v t="T835"><vh>&lt;&lt; override methods of the LeoApp class &gt;&gt;</vh></v>
</v>
<v t="T836" tnodeList="836,837"><vh>@file override_commands.py</vh>
<v t="T837"><vh>onCommand</vh></v>
</v>
<v t="T838" tnodeList="838,839,840"><vh>@file redefine_put.py</vh>
<v t="T839"><vh>onStart</vh></v>
<v t="T840"><vh>newPut and newPutNl</vh></v>
</v>
<v t="T841" tnodeList="841"><vh>@file redirect_to_log.py</vh></v>
<v t="T842" tnodeList="842,843,844,845,846"><vh>@file script_io_to_body.py</vh>
<v t="T843"><vh>onStart</vh></v>
<v t="T844"><vh>newExecuteScript</vh></v>
<v t="T845"><vh>newPut and newPutNl</vh></v>
<v t="T846"><vh>newEs, etc.</vh></v>
</v>
</v>
<v t="T847"><vh>Spell Checking</vh>
<v t="T848"><vh>@silentfile mod_spelling.txt</vh></v>
<v t="T849" tnodeList="849"><vh>@file mod_spelling.ini</vh></v>
<v t="T850" tnodeList="850,852,853,854,855,857,858,859,860,861,862,863,864,865,867,868,869,870,871,872,873,874,876,877,878,879,880,881,883,884,885,886,887,889,890,891,892,893,894,895,896,897,898"><vh>@file mod_spelling.py</vh>
<v t="T851"><vh>Functions</vh>
<v t="T852"><vh>createSpellMenu</vh></v>
<v t="T853"><vh>onSelect</vh></v>
<v t="T854"><vh>onCommand</vh></v>
</v>
<v t="T855"><vh>class Aspell</vh>
<v t="T856"><vh>Birth &amp; death</vh>
<v t="T857"><vh>__init__</vh></v>
<v t="T858"><vh>getAspellDirectory</vh></v>
</v>
<v t="T859"><vh>openPipes</vh>
<v t="T860"><vh>&lt;&lt; Ensure local dictionary is present &gt;&gt;</vh></v>
</v>
<v t="T861"><vh>closePipes</vh></v>
<v t="T862"><vh>listAlternates</vh></v>
<v t="T863"><vh>processWord</vh></v>
<v t="T864"><vh>updateDictionary</vh></v>
</v>
<v t="T865"><vh>class spellDialog</vh>
<v t="T866"><vh>Birth &amp; death</vh>
<v t="T867"><vh>spell.__init__</vh>
<v t="T868"><vh>&lt;&lt; set self.dictionary &gt;&gt;</vh></v>
</v>
<v t="T869"><vh>getLocalDictionary</vh></v>
<v t="T870"><vh>getLocalLanguageCode</vh></v>
<v t="T871"><vh>readLocalDictionary</vh></v>
</v>
<v t="T872"><vh>createFrame</vh>
<v t="T873"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="T874"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="T875"><vh>Buttons</vh>
<v t="T876"><vh>onAddButton</vh></v>
<v t="T877"><vh>onIgnoreButton</vh></v>
<v t="T878"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="T879"><vh>onFindButton</vh></v>
<v t="T880"><vh>onHideButton</vh></v>
<v t="T881"><vh>onRedoButton &amp; onUndoButton</vh></v>
</v>
<v t="T882"><vh>Commands</vh>
<v t="T883"><vh>add</vh></v>
<v t="T884"><vh>change</vh></v>
<v t="T885"><vh>checkSpelling</vh></v>
<v t="T886"><vh>find</vh></v>
<v t="T887"><vh>ignore</vh></v>
</v>
<v t="T888"><vh>Helpers</vh>
<v t="T889"><vh>closePipes</vh></v>
<v t="T890"><vh>fillbox</vh></v>
<v t="T891"><vh>findNextMisspelledWord</vh>
<v t="T892"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="T893"><vh>findNextWord</vh></v>
<v t="T894"><vh>getSuggestion</vh></v>
<v t="T895"><vh>onMap</vh></v>
<v t="T896"><vh>onSelectListBox</vh></v>
<v t="T897"><vh>update</vh></v>
<v t="T898"><vh>updateButtons</vh></v>
</v>
</v>
</v>
</v>
<v t="T899"><vh>Plugin manager (demo)</vh>
<v t="T900"><vh>Notes by Paul Paterson</vh></v>
<v t="T901" tnodeList="901,902,903,904,905,906,907,908,909,910"><vh>@file leopm_client.py</vh>
<v t="T902"><vh>class LeoPMClient</vh>
<v t="T903"><vh>__init__</vh></v>
<v t="T904"><vh>poll</vh></v>
<v t="T905"><vh>_getSelectedPluginName</vh></v>
<v t="T906"><vh>updateDetail</vh></v>
<v t="T907"><vh>downloadPlugin</vh></v>
<v t="T908"><vh>getPluginList</vh></v>
<v t="T909"><vh>initListbox</vh></v>
<v t="T910"><vh>getVersionOfFile</vh></v>
</v>
</v>
<v t="T911" tnodeList="911,912,912,913,914,915,916,917,918"><vh>@file leopm_server.py</vh>
<v t="T912"><vh>class LeoPM</vh>
<v t="T913"><vh>__init__</vh></v>
<v t="T914"><vh>getPluginNames</vh></v>
<v t="T915"><vh>getPluginDescription</vh></v>
<v t="T916"><vh>getPlugin</vh></v>
<v t="T917"><vh>getPluginVersion</vh></v>
<v t="T918"><vh>getPluginFilenames</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@nocolor

This file contains code for all plugins distributed with Leo.</t>
<t tx="T2">@nocolor

What is a plugin?

A plugin is a .py file that appears in Leo's plugin subdirectory. Leo tries to
import all such files while starting up. This is done at "start1" time, that
is, in the call to doHook("start1") in the run function in leo.py. Plugins
exist to define "hook code".

What is hook code?

Leo automatically calls hook code at various times during Leo's execution.
Typical hooks are:

- "start2", called at the end of Leo's startup process,
- "command1", called before executing any of Leo's commands
- "idle", called at Tk's idle time, when nothing else is happening,

See the documentation for hooks in this file for full details.

N.B. Plugins can use "start2" hooks to override any of Leo's classes. See
"Overriding functions, methods &amp; classes" in leoPlugins.leo for several
examples of how to do this.

How do plugins work?

Plugins register themselves when Leo imports them using the following code,
which should appear as the outer level of the .py file:

@color

"""A description of this plugin"""

if 1: # 1 to enable the plugin, 0 to disable the plugin:
	registerHandler("xxx", onXXX)
	__version__ = "1.2"
	plugin_signon(__name__)
	
@nocolor

Line by line:

1) """A description of this plugin"""

This is a Python doc string describing the plugin. This string becomes the
value of the __name__ attribute for the module (.py file).

2) if 1: # 1 to enable the plugin, 0 to disable the plugin:

This line enables or disables the code that registers the plugin. Plugins do
nothing unless they are actually registered when Leo first imports them.

3) registerHandler("xxx", onXXX)

This line registers a handler called onXXX for the hook called "xxx". See the
documentation for hooks for a complete list of hook names that you can use
instead of "xxx". onXXX is the name of a function or method, presumably defined
in the plugin file, that Leo will call at "xxx" time. For example:

registerHandler("idle",onIdle)

will cause Leo to call the onIdle function at "idle" time.

You can pass a list of hook names as the first argument to registerHandler. For
example:

registerHandler(("bodykey1","bodykey2","headkey1","headkey2"), onKey)

4) __version__ = "1.2"

This assigns a version attribute to module. At present this attribute is used
by the plugin code that creates Leo's Plugins menu.

5) plugin_signon(__name__)

This line increases the count of loaded modules. The present code for
plugin_signon does not actually print separate signons--it seems to verbose.

About hook handlers

See the "About hooks" section of leoPlugins.leo for full documentation about
how to write hook handler routines, like onXXX or onKey in the examples above.
Basically, each hook should have this pattern:
	
@color

def onXXX (tag,keywords):
	c = keywords.get("c")
	otherKeyword = keywords.get("otherKeyword")
	&lt;&lt; do something with c and otherKeyword, etc. &gt;&gt;
	
@nocolor

In other words, keywords is a Python dictionary containing the keyword
arguments passed to the hook handler. See the See the "About hooks" section of
leoPlugins.leo for a list of the keywords passed to each hook handler.

The tag is the name of the hook. For example, tag would one of
"bodykey1","bodykey2","headkey1","headkey2", for the onKey hook handler in the
example above.

What's next?

It's one thing to know how to create a plugin. It's another to know how to
actually change Leo. Obviously, some study is needed. The place to start your
study is LeoPy.leo. In particular, study very carefully the section called
"Overview of code". Leo is a highly modular program, and Python is ideally
suited to this style of programming.</t>
<t tx="T3">@nocolor

Scripting is fully documented in Leo's Users Guide, and the following should be enough to get you started:

@color

top() # The commander of the top (current) windows.
top().rootVnode() # The root vnode of the outline.
top().currentVnode() # The presently selected vnode.

@nocolor

If v is any vnode:
	
@color

v.headString() # is the headline of v.
v.bodyString() # is the body of v.
v.threadNext() # is node after v in outline order.

@nocolor

For example, this prints every headline of an outline:
	
@color

v = top().rootVnode()
while v:
	print v.headString()
	v = v.threadNext()
</t>
<t tx="T4">At startup time Leo looks all files of the form mod_*.py in the plugins
directory. Leo assumes that these files are "plugins" containing Python modules
that customizes Leo's operation. Leo attempts to import each file.

Each module should register routines that are called at various times during
execution. Such times are identified by strings known as "tags". The code in in
one or more plugins corresponding to each tag are known as the "hook" routines
for that tag. Leo catches exceptions (including syntax errors) in hook
routines, so it is safe to hack away on this code.

Leo passes two argument to all hook routines: the tag and a keywords dictionary
containing additional information. For example, keywords["label"] indicates the
kind of command for "command1" and "command2" hooks.

For some hooks, returning anything other than None "overrides" Leo's default
action. Hooks have full access to all of Leo's source code. Just import the
relevant file. For example, top() returns the commander for the topmost Leo
window.

The following table summarizes the arguments passed to hooks: ( Overrides is
"yes" if returning anything other than None overrides Leo's normal command or
event processing.)

tag argument                                              keys in keywords
(hook name)  overrides       when called                  dictionary argument
---------    ---------       -----------                  -------------------
"bodyclick1"   yes      before normal click in body       c,v,event 
"bodyclick2"            after  normal click in body       c,v,event 
"bodydclick1"  yes      before double click in body       c,v,event 
"bodydclick2"           after  double click in body       c,v,event 
"bodykey1"     yes      before body keystrokes            c,v,ch,oldSel,undoType
"bodykey2"              after  body keystrokes            c,v,ch,oldSel,undoType
"bodyrclick1"  yes      before right click in body        c,v,event 
"bodyrclick2"           after  right click in body        c,v,event 
"boxclick1"    yes      before click in +- box            c,v,event 
"boxclick2"             after  click in +- box            c,v,event 
"command1"     yes      before each command               c,v,label (note 2)
"command2"              after  each command               c,v,label (note 2)
"drag1"        yes      before start of drag              c,v,event 
"drag2"                 after  start of drag              c,v,event 
"dragging1"    yes      before continuing to drag         c,v,event 
"dragging2"             after  continuing to drag         c,v,event 
"end1"                  start of app.quit()
"enddrag1"     yes      before end of drag                c,v,event 
"enddrag2"              after  end of drag                c,v,event 
"headkey1"     yes      before headline keystrokes        c,v,ch
"headkey2"              after  headline keystrokes        c,v,ch
"headclick1"   yes      before normal click in headline   c,v,event 
"headclick2"            after  normal click in headline   c,v,event 
"headrclick1"  yes      before right click in headline    c,v,event 
"headrclick2"           after  right click in headline    c,v,event 
"hypercclick1" yes      before control click in hyperlink c,v,event 
"hypercclick2"          after  control click in hyperlink c,v,event 
"hyperenter1"  yes      before entering hyperlink         c,v,event 
"hyperenter2"           after  entering hyperlink         c,v,event 
"hyperleave1"  yes      before leaving  hyperlink         c,v,event 
"hyperleave2"           after  leaving  hyperlink         c,v,event 
"iconclick1"   yes      before single click in icon box   c,v,event 
"iconclick2"            after  single click in icon box   c,v,event 
"iconrclick1"  yes      before right click in icon box    c,v,event 
"iconrclick2"           after  right click in icon box    c,v,event 
"icondclick1"  yes      before double click in icon box   c,v,event 
"icondclick2"           after  double click in icon box   c,v,event 
"idle"                  periodically (at idle time)       c,v
"menu1"        yes      before creating menus             c,v (note 3)
"menu2"        yes      before updating menus             c,v
"new"          no       during New command                old_c,new_c
"open1"        yes      before opening any file           old_c,new_c,fileName (note 4)
"open2"                 after  opening any file           old_c,new_c,fileName (note 4)
"openwith1"    yes      before Open With command          c,v,openType,arg,ext
"openwith2"             after  Open With command          c,v,openType,arg,ext
"recentfiles1" yes      before Recent Files command       c,v,fileName,closeFlag
"recentfiles2"          after  Recent Files command       c,v,fileName,closeFlag
"save1"        yes      before any Save command           c,v,fileName
"save2"                 after  any Save command           c,v,fileName
"select1"      yes      before selecting a vnode          c,new_v,old_v
"select2"               after  selecting a vnode          c,new_v,old_v
"start1"       no       after app.finishCreate()
"start2"                after opening first Leo window    c,v,fileName
"unselect1"    yes      before unselecting a vnode        c,new_v,old_v 
"unselect2"             after  unselecting a vnode        c,old_v,old_v 
"@url1"        yes      before double-click @url node     c,v (note 5)
"@url2"                 after  double-click @url node     c,v (note 5)

The following hooks are a new breed of hook, called "stub hooks". Conceptually,
these hooks are like calls to stub routines that can be filled in by code in
plugins.

tag argument                                                   keys in keywords
(hook name)             overrides    when called               dictionary argument
---------               ---------    -----------               -------------------

"create-optional-menus"  no          (note 8)                  (note 8)

"draw-outine-box"        yes         start of drawBox          tree,v,x,y (note 6)
"draw-outline-icon"      yes         start of tree.drawIcon    tree,v,x,y (note 6)
"draw-outline-node"      yes         start of tree.drawNode    tree,v,x,y (note 6)
"draw-outline-text-box"  yes         start of tree.drawText    tree,v,x,y (note 6)
"draw-sub-outline"       yes         start of tree.drawTree    tree,v,x,y,h,level (note 6)
"redraw-entire-outline"  yes         start of tree.redraw      c (note 6)

"color-optional-markup"  yes *       (note 7)                  colorer,v (note 7)
"init-color-markup"      no          (note 7)                  colorer,v,s,i,j,colortag (note 7)

"new"                    no          start of New command      old_c,new_c (note 9)

"scan-directives"        no          in scanDirectives         c,v,s,old_dict,dict,pluginsList (note 10)

Notes:

(1) "activate" and "deactivate" hooks: These have been removed because they do
not work as expected.

(2) "commands" hooks: The label entry in the keywords dict contains the
"canonicalized" form of the command, that is, the lowercase name of the command
with all non-alphabetic characters removed.

Commands hooks now set the label for undo and redo commands "undo" and "redo"
rather than "cantundo" and "cantredo".

(3) "menu1" hook: Setting app().realMenuNameDict in this hook is an easy way of
translating menu names to other languages. Note: the "new" names created this
way affect only the actual spelling of the menu items, they do _not_ affect how
you specify shortcuts in leoConfig.txt, nor do they affect the "official"
command names passed in app().commandName. For example, suppose you set
app().realMenuNameDict["Open..."] = "Ouvre".

(4) "open1" and "open2" hooks: These are called with a keywords dict containing
the following entries:

old_c: The commander of the previously open window.
new_c: The commander of the newly opened window.
fileName: The name of the file being opened.

You can use old_c.currentVnode() and new_c.currentVnode() to get the current
vnode in the old and new windows.

Leo calls the "open1" and "open2" hooks only if the file is already open.
Leo will also call the "open1" and "open2" hooks if:
a) a file is opened using the Recent Files menu and
b) the file is not already open.

(5) "@url1" and "@url2" hooks are only executed if "icondclick1" hook returns
None.

(6) These stub hooks allow plugins to revise or completely replace how Leo
draws outlines. For example, you could change tree.drawIcon to add additional
icons. These stub hooks are really methods of the leoTree class, with the
"tree" keyword corresponding to the "self" parameter. These stub hooks are
called at the beginning of the indicated method. See the method themselves for
a description of the paramters.

(7) These stub hooks allow plugins to parse and handle markup withing doc
parts, comments and Python """ strings. Note that these hooks are _not_ called
in Python ''' strings. See the color_markup plugin for a complete example of
how to use these hooks.

(8) The "create-optional-menus" stub hook is called when Leo is creating menus,
at the place at which creating new menus is appropriate. Therefore, this hook
need only create new menus in the correct order, without worrying about the
placement of the menus in the menu bar. See the plugins_menu and scripts_menu
plugins for examples of how to use this hook. Leo now executes hooks in
alphabetical order, so that the Plugins menu will be created before the Scripts
menu.

(9) The "new" stub hook is called at the beginning of the code that implements
the New command. This provides a much easier way of recognizing when Leo is
about to create a new Leo window.

(10) The "scan-directives" stub hooks is called inside the scanDirectives
global function. The dictionary returned by scanDirectives now contains an item
whose key is "pluginsList". The value of this item is a list of tuples
(d,v,s,k) where:

- d is the spelling of the @directive, without the leading @.
- v is the vnode containing the directive, _not_ the original vnode.
- s[k:] is a string containing whatever follows the @directive. k has already
been moved past any whitespace that follows the @directive.

See the add_directives plugins directive for a complete example of how to use
the "scan-directives" stub hook.</t>
<t tx="T5">Naively using hooks can expose you and your .leo files to malicious attacks.

** Hooks should never blindly execute Python scripts in .leo files.

It is safe to import and execute code from Leo itself, provided that you got Leo from Leo's SourceForge site.</t>
<t tx="T6">@color
@ WARNING ***** Using the following routine exposes you malicious code in .leo files! *****

Do not EVER use code that blindly executes code in .leo files!
Someone could send you malicious code embedded in the .leo file.

WARNING 1: Changing "@onloadpythonscript" to something else will NOT protect
           you if you EVER share either your files with anyone else.

WARNING 2: Replacing exec by rexec below provides NO additional protection!
           A malicious rexec script could trash your .leo file in subtle ways.
@c
if 0: # WRONG: This blindly execute scripts found in an .leo file! NEVER DO THIS!
	def onLoadFile():
		v = top().rootVnode()
		while v:
			h = v.headString().lower()
			if match_word(h,0,"@onloadpythonscript"):
				s = v.bodyString()
				if s and len(s) &gt; 0:
					try: # SECURITY BREACH: s may be malicious!
						exec s + '\n' in {}
					except:
						es_exception()
			v = v.threadNext()</t>
<t tx="T7"></t>
<t tx="T8"></t>
<t tx="T9">@nocolor

Allow different default types for each section.
Create _all_ menus from settings ?

[plugins]

pluginName = 1/0 # enables or disables plugin

# option = type (overrides defaults)

	[types]

__default_type = bool
page_width = int
tab_width = int
default_tangle_directory = string

	use type name in option?
	
	_color: color
	
	_font: font
	_key: keystroke
	_flag: bool
	everything else: bool
	
	bool: checkmark
	color: picker (or use dialog)

[menus]
child = parent</t>
<t tx="T10"></t>
<t tx="T11">"""Create a settings menu to replace LeoConfig.leo"""

from leoPlugins import *
from leoGlobals import *

import leoApp,leoAtFile,leoDialog,leoFileCommands,leoFrame,leoNodes

if 0: # Register the handlers...

	settingsMenu = None

	@others
	
	# registerHandler("start1",onAfterFinishCreate)
	registerHandler("create-optional-menus",createSettingsMenu)

	__version__ = "0.1"
	plugin_signon(__name__)</t>
<t tx="T12">def createSettingsMenu (tag,keywords):

	c = keywords.get("c")
	
	global settingsMenu
	settingsMenu = c.frame.createNewMenu("&amp;Settings")</t>
<t tx="T13">@ignore
@nocolor

This contains code that I am studying for later use.

@color</t>
<t tx="T14"></t>
<t tx="T15">@ignore
@language elisp

@others

(provide 'pymacs)</t>
<t tx="T16">;;; Interface between Emacs Lisp and Python - Lisp part.    -*- emacs-lisp -*-
;;; Copyright  2001, 2002, 2003 Progiciels Bourbeau-Pinard inc.
;;; Franois Pinard &lt;pinard@iro.umontreal.ca&gt;, 2001.

&lt;&lt; free software stuff &gt;&gt;

;;; See the Pymacs documentation (in `README') for more information.</t>
<t tx="T17">
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2, or (at your option)
;;; any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software Foundation,
;;; Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</t>
<t tx="T18">;;; Published functions.</t>
<t tx="T19"></t>
<t tx="T20">(defvar pymacs-load-path nil
  "List of additional directories to search for Python modules.
The directories listed will be searched first, in the order given.")</t>
<t tx="T21">(defvar pymacs-trace-transit '(5000 . 30000)

"Keep the communication buffer growing, for debugging.
When this variable is nil, the `*Pymacs*' communication buffer gets erased
before each communication round-trip.  Setting it to `t' guarantees that
the full communication is saved, which is useful for debugging.
It could also be given as (KEEP . LIMIT): whenever the buffer exceeds LIMIT
bytes, it is reduced to approximately KEEP bytes.")</t>
<t tx="T22">(defvar pymacs-forget-mutability nil
  "Transmit copies to Python instead of Lisp handles, as much as possible.
When this variable is nil, most mutable objects are transmitted as handles.
This variable is meant to be temporarily rebound to force copies.")</t>
<t tx="T23">(defvar pymacs-mutable-strings nil
  "Prefer transmitting Lisp strings to Python as handles.
When this variable is nil, strings are transmitted as copies, and the
Python side thus has no way for modifying the original Lisp strings.
This variable is ignored whenever `forget-mutability' is set.")</t>
<t tx="T24">(defvar pymacs-timeout-at-start 30
  "Maximum reasonable time, in seconds, for starting `pymacs-services'.
A machine should be pretty loaded before one needs to increment this.")</t>
<t tx="T25">(defvar pymacs-timeout-at-reply 5
  "Expected maximum time, in seconds, to get the first line of a reply.
The status of `pymacs-services' is checked at every such timeout.")</t>
<t tx="T26">(defvar pymacs-timeout-at-line 2
  "Expected maximum time, in seconds, to get another line of a reply.
The status of 'pymacs-services' is checked at every such timeout.")</t>
<t tx="T27">(defun pymacs-load (module &amp;optional prefix noerror)

  "Import the Python module named MODULE into Emacs.
Each function in the Python module is made available as an Emacs function.
The Lisp name of each function is the concatenation of PREFIX with
the Python name, in which underlines are replaced by dashes.  If PREFIX is
not given, it defaults to MODULE followed by a dash.
If NOERROR is not nil, do not raise error when the module is not found."

  (interactive
   (let* ((module (read-string "Python module? "))
	  (default (concat (car (last (split-string module "\\."))) "-"))
	  (prefix (read-string (format "Prefix? [%s] " default)
			       nil nil default)))
     (list module prefix)))
  (message "Pymacs loading %s..." module)
  (let ((lisp-code (pymacs-call "pymacs_load_helper" module prefix)))
    (cond (lisp-code (let ((result (eval lisp-code)))
		       (message "Pymacs loading %s...done" module)
		       result))
	  (noerror (message "Pymacs loading %s...failed" module) nil)
	  (t (error "Pymacs loading %s...failed" module)))))</t>
<t tx="T28">(defun pymacs-eval (text)

  "Compile TEXT as a Python expression, and return its value."
 
  (interactive "sPython expression? ")
  (let ((value (pymacs-call "eval" text)))
    (when (interactive-p)
      (message "%S" value))
    value))</t>
<t tx="T29">(defun pymacs-exec (text)

"Compile and execute TEXT as a sequence of Python statements.
This functionality is experimental, and does not appear to be useful."

  (interactive "sPython statements? ")
  (let ((value (pymacs-serve-until-reply
		`(progn (princ "exec ") (prin1 ,text)))))
    (when (interactive-p)
      (message "%S" value))
    value))</t>
<t tx="T30">(defun pymacs-call (function &amp;rest arguments)

"Return the result of calling a Python function FUNCTION over ARGUMENTS.
FUNCTION is a string denoting the Python function, ARGUMENTS are separate
Lisp expressions, one per argument.  Immutable Lisp constants are converted
to Python equivalents, other structures are converted into Lisp handles."

  (pymacs-serve-until-reply `(pymacs-print-for-apply ',function ',arguments)))</t>
<t tx="T31">(defun pymacs-apply (function arguments)

"Return the result of calling a Python function FUNCTION over ARGUMENTS.
FUNCTION is a string denoting the Python function, ARGUMENTS is a list of
Lisp expressions.  Immutable Lisp constants are converted to Python
equivalents, other structures are converted into Lisp handles."

  (pymacs-serve-until-reply `(pymacs-print-for-apply ',function ',arguments)))</t>
<t tx="T32">;;; Integration details.</t>
<t tx="T33">;; Python functions and modules should ideally look like Lisp functions and
;; modules.  This page tries to increase the integration seamlessness.

(defadvice documentation (around pymacs-ad-documentation activate)
  ;; Integration of doc-strings.
  (let* ((reference (pymacs-python-reference function))
	 (python-doc (when reference
		       (pymacs-eval (format "doc_string(%s)" reference)))))
    (if (or reference python-doc)
	(setq ad-return-value
	      (concat
	       "It interfaces to a Python function.\n\n"
	       (when python-doc
		 (if raw python-doc (substitute-command-keys python-doc)))))
      ad-do-it)))
</t>
<t tx="T34">(defun pymacs-python-reference (object)
  ;; Return the text reference of a Python object if possible, else nil.
  (when (functionp object)
    (let* ((definition (indirect-function object))
	   (body (and (pymacs-proper-list-p definition)
		      (&gt; (length definition) 2)
		      (eq (car definition) 'lambda)
		      (cddr definition))))
      (when (and body (listp (car body)) (eq (caar body) 'interactive))
	;; Skip the interactive specification of a function.
	(setq body (cdr body)))
      (when (and body
		 ;; Advised functions start with a string.
		 (not (stringp (car body)))
		 ;; Python trampolines hold exactly one expression.
		 (= (length body) 1))
	(let ((expression (car body)))
	  ;; EXPRESSION might now hold something like:
	  ;;    (pymacs-apply (quote (pymacs-python . N)) ARGUMENT-LIST)
	  (when (and (pymacs-proper-list-p expression)
		     (= (length expression) 3)
		     (eq (car expression) 'pymacs-apply)
		     (eq (car (cadr expression)) 'quote))
	    (setq object (cadr (cadr expression))))))))
  (when (eq (car-safe object) 'pymacs-python)
    (format "python[%d]" (cdr object))))</t>
<t tx="T35">;; The following functions are experimental -- they are not satisfactory yet.

</t>
<t tx="T36">(defun pymacs-file-handler (operation &amp;rest arguments)
  ;; Integration of load-file, autoload, etc.
  ;; Emacs might want the contents of some `MODULE.el' which does not exist,
  ;; while there is a `MODULE.py' or `MODULE.pyc' file in the same directory.
  ;; The goal is to generate a virtual contents for this `MODULE.el' file, as
  ;; a set of Lisp trampoline functions to the Python module functions.
  ;; Python modules can then be loaded or autoloaded as if they were Lisp.
  ;(message "** %S %S" operation arguments)
  (cond ((and (eq operation 'file-readable-p)
	      (let ((module (substring (car arguments) 0 -3)))
		(or (pymacs-file-force operation arguments)
		    (file-readable-p (concat module ".py"))
		    (file-readable-p (concat module ".pyc"))))))
	((and (eq operation 'load)
	      (not (pymacs-file-force
		    'file-readable-p (list (car arguments))))
	      (file-readable-p (car arguments)))
	 (let ((lisp-code (pymacs-call "pymacs_load_helper"
				       (substring (car arguments) 0 -3)
				       nil)))
	   (unless lisp-code
	     (error "Python import error"))
	   (eval lisp-code)))
	((and (eq operation 'insert-file-contents)
	      (not (pymacs-file-force
		    'file-readable-p (list (car arguments))))
	      (file-readable-p (car arguments)))
	 (let ((lisp-code (pymacs-call "pymacs_load_helper"
				       (substring (car arguments) 0 -3)
				       nil)))
	   (unless lisp-code
	     (error "Python import error"))
	   (insert (prin1-to-string lisp-code))))
	(t (pymacs-file-force operation arguments))))</t>
<t tx="T37">(defun pymacs-file-force (operation arguments)
  ;; Bypass the file handler.
  (let ((inhibit-file-name-handlers
	 (cons 'pymacs-file-handler
	       (and (eq inhibit-file-name-operation operation)
		    inhibit-file-name-handlers)))
	(inhibit-file-name-operation operation))
    (apply operation arguments)))
	
;(add-to-list 'file-name-handler-alist '("\\.el\\'" . pymacs-file-handler))</t>
<t tx="T38">;;; Gargabe collection of Python IDs.

;; Python objects which have no Lisp representation are allocated on the
;; Python side as `python[INDEX]', and INDEX is transmitted to Emacs, with
;; the value to use on the Lisp side for it.  Whenever Lisp does not need a
;; Python object anymore, it should be freed on the Python side.  The
;; following variables and functions are meant to fill this duty.

</t>
<t tx="T39"></t>
<t tx="T40">(defvar pymacs-use-hash-tables nil
  "Automatically set to t if hash tables are available.")</t>
<t tx="T41">(defvar pymacs-used-ids nil
  "List of received IDs, currently allocated on the Python side.")</t>
<t tx="T42">(defvar pymacs-weak-hash nil
  "Weak hash table, meant to find out which IDs are still needed.")</t>
<t tx="T43">(defvar pymacs-gc-wanted nil
  "Flag if it is time to clean up unused IDs on the Python side.")</t>
<t tx="T44">(defvar pymacs-gc-running nil
  "Flag telling that a Pymacs garbage collection is in progress.")</t>
<t tx="T45">(defvar pymacs-gc-timer nil
  "Timer to trigger Pymacs garbage collection at regular time intervals.
The timer is used only if `post-gc-hook' is not available.")</t>
<t tx="T46">(defun pymacs-schedule-gc ()
  (unless pymacs-gc-running
    (setq pymacs-gc-wanted t)))</t>
<t tx="T47">(defun pymacs-garbage-collect ()
  ;; Clean up unused IDs on the Python side.
  (when pymacs-use-hash-tables
    (let ((pymacs-gc-running t)
	  (pymacs-forget-mutability t)
	  (ids pymacs-used-ids)
	  used-ids unused-ids)
      (while ids
	(let ((id (car ids)))
	  (setq ids (cdr ids))
	  (if (gethash id pymacs-weak-hash)
	      (setq used-ids (cons id used-ids))
	    (setq unused-ids (cons id unused-ids)))))
      ;;(message "** pymacs-garbage-collect %d %d"
      ;;         (length used-ids) (length unused-ids))
      (setq pymacs-used-ids used-ids
	    pymacs-gc-wanted nil)
      (when unused-ids
	(pymacs-apply "free_python" unused-ids)))))</t>
<t tx="T48">(defun pymacs-defuns (arguments)
  ;; Take one argument, a list holding a number of items divisible by 3.  The
  ;; first argument is an INDEX, the second is a NAME, the third is the
  ;; INTERACTION specification, and so forth.  Register Python INDEX with a
  ;; function with that NAME and INTERACTION on the Lisp side.  The strange
  ;; calling convention is to minimise quoting at call time.
  (while (&gt;= (length arguments) 3)
    (let ((index (nth 0 arguments))
	  (name (nth 1 arguments))
	  (interaction (nth 2 arguments)))
      (fset name (pymacs-defun index interaction))
      (setq arguments (nthcdr 3 arguments)))))</t>
<t tx="T49">(defun pymacs-defun (index interaction)
  ;; Register INDEX on the Lisp side with a Python object that is a function,
  ;; and return a lambda form calling that function.  If the INTERACTION
  ;; specification is nil, the function is not interactive.  Otherwise, the
  ;; function is interactive, INTERACTION is then either a string, or the
  ;; index of an argument-less Python function returning the argument list.
  (let ((object (pymacs-python index)))
    (cond ((null interaction)
	   `(lambda (&amp;rest arguments)
	      (pymacs-apply ',object arguments)))
	  ((stringp interaction)
	   `(lambda (&amp;rest arguments)
	      (interactive ,interaction)
	      (pymacs-apply ',object arguments)))
	  (t `(lambda (&amp;rest arguments)
		(interactive (pymacs-call ',(pymacs-python interaction)))
		(pymacs-apply ',object arguments))))))</t>
<t tx="T50">(defun pymacs-python (index)
  ;; Register on the Lisp side a Python object having INDEX, and return it.
  ;; The result is meant to be recognised specially by `print-for-eval', and
  ;; in the function position by `print-for-apply'.
  (let ((object (cons 'pymacs-python index)))
    (when pymacs-use-hash-tables
      (puthash index object pymacs-weak-hash)
      (setq pymacs-used-ids (cons index pymacs-used-ids)))
    object))</t>
<t tx="T51">;;; Generating Python code.

;; Many Lisp expressions cannot fully be represented in Python, at least
;; because the object is mutable on the Lisp side.  Such objects are allocated
;; somewhere into a vector of handles, and the handle index is used for
;; communication instead of the expression itself.


</t>
<t tx="T52">(defvar pymacs-lisp nil
  "Vector of handles to hold transmitted expressions.")</t>
<t tx="T53">(defvar pymacs-freed-list nil
  "List of unallocated indices in Lisp.")</t>
<t tx="T54">;; When the Python CG is done with a Lisp object, a communication occurs so to
;; free the object on the Lisp side as well.

(defun pymacs-allocate-lisp (expression)
  ;; This function allocates some handle for an EXPRESSION, and return its
  ;; index.
  (unless pymacs-freed-list
    (let* ((previous pymacs-lisp)
	   (old-size (length previous))
	   (new-size (if (zerop old-size) 100 (+ old-size (/ old-size 2))))
	   (counter new-size))
      (setq pymacs-lisp (make-vector new-size nil))
      (while (&gt; counter 0)
	(setq counter (1- counter))
	(if (&lt; counter old-size)
	    (aset pymacs-lisp counter (aref previous counter))
	  (setq pymacs-freed-list (cons counter pymacs-freed-list))))))
  (let ((index (car pymacs-freed-list)))
    (setq pymacs-freed-list (cdr pymacs-freed-list))
    (aset pymacs-lisp index expression)
    index))</t>
<t tx="T55">(defun pymacs-free-lisp (&amp;rest indices)
  ;; This function is triggered from Python side for Lisp handles which lost
  ;; their last reference.  These references should be cut on the Lisp side as
  ;; well, or else, the objects will never be garbage-collected.
  (while indices
    (let ((index (car indices)))
      (aset pymacs-lisp index nil)
      (setq pymacs-freed-list (cons index pymacs-freed-list)
	    indices (cdr indices)))))</t>
<t tx="T56">(defun pymacs-print-for-apply-expanded (function arguments)
  ;; This function acts like `print-for-apply', but produce arguments which
  ;; are expanded copies whenever possible, instead of handles.  Proper lists
  ;; are turned into Python lists, vectors are turned into Python tuples.
  (let ((pymacs-forget-mutability t))
    (pymacs-print-for-apply function arguments)))</t>
<t tx="T57">(defun pymacs-print-for-apply (function arguments)
  ;; This function prints a Python expression calling FUNCTION, which is a
  ;; string naming a Python function, or a Python reference, over all its
  ;; ARGUMENTS, which are Lisp expressions.
  (let ((separator "")
	argument)
    (if (eq (car-safe function) 'pymacs-python)
	(princ (format "python[%d]" (cdr function)))
      (princ function))
    (princ "(")
    (while arguments
      (setq argument (car arguments)
	    arguments (cdr arguments))
      (princ separator)
      (setq separator ", ")
      (pymacs-print-for-eval argument))
    (princ ")")))</t>
<t tx="T58">(defun pymacs-print-for-eval (expression)
  ;; This function prints a Python expression out of a Lisp EXPRESSION.
  (let (done)
    (cond ((not expression)
	   (princ "None")
	   (setq done t))
	  ((numberp expression)
	   (princ expression)
	   (setq done t))
	  ((stringp expression)
	   (when (or pymacs-forget-mutability
		     (not pymacs-mutable-strings))
	     (let ((text (copy-sequence expression)))
	       (set-text-properties 0 (length text) nil text)
	       (princ (mapconcat 'identity
				 (split-string (prin1-to-string text) "\n")
				 "\\n")))
	     (setq done t)))
	  ((symbolp expression)
	   (let ((name (symbol-name expression)))
	     ;; The symbol can only be transmitted when in the main oblist.
	     (when (eq expression (intern-soft name))
	       (cond
		((save-match-data
		   (string-match "^[A-Za-z][-A-Za-z0-9]*$" name))
		 (princ "lisp.")
		 (princ (mapconcat 'identity (split-string name "-") "_")))
		(t (princ "lisp[")
		   (prin1 name)
		   (princ "]")))
	       (setq done t))))
	  ((vectorp expression)
	   (when pymacs-forget-mutability
	     (let ((limit (length expression))
		   (counter 0))
	       (princ "(")
	       (while (&lt; counter limit)
		 (unless (zerop counter)
		   (princ ", "))
		 (pymacs-print-for-eval (aref expression counter))
		 (setq counter (1+ counter)))
	       (when (= limit 1)
		 (princ ","))
	       (princ ")")
	       (setq done t))))
	  ((eq (car-safe expression) 'pymacs-python)
	   (princ "python[")
	   (princ (cdr expression))
	   (princ "]")
	   (setq done t))
	  ((pymacs-proper-list-p expression)
	   (when pymacs-forget-mutability
	     (princ "[")
	     (pymacs-print-for-eval (car expression))
	     (while (setq expression (cdr expression))
	       (princ ", ")
	       (pymacs-print-for-eval (car expression)))
	     (princ "]")
	     (setq done t))))
    (unless done
      (let ((class (cond ((vectorp expression) "Vector")
			 ((and pymacs-use-hash-tables
			       (hash-table-p expression))
			  "Table")
			 ((bufferp expression) "Buffer")
			 ((pymacs-proper-list-p expression) "List")
			 (t "Lisp"))))
	(princ class)
	(princ "(")
	(princ (pymacs-allocate-lisp expression))
	(princ ")")))))</t>
<t tx="T59">;;; Communication protocol.

(defvar pymacs-transit-buffer nil
  "Communication buffer between Emacs and Python.")
  
;; The principle behind the communication protocol is that it is easier to
;; generate than parse, and that each language already has its own parser.

;; So, the Emacs side generates Python text for the Python side to interpret,
;; while the Python side generates Lisp text for the Lisp side to interpret.
;; About nothing but expressions are transmitted, which are evaluated on
;; arrival.  The pseudo `reply' function is meant to signal the final result
;; of a series of exchanges following a request, while the pseudo `error'
;; function is meant to explain why an exchange could not have been completed.

;; The protocol itself is rather simple, and contains human readable text
;; only.  A message starts at the beginning of a line in the communication
;; buffer, either with `&gt;' for the Lisp to Python direction, or `&lt;' for the
;; Python to Lisp direction.  This is followed by a decimal number giving the
;; length of the message text, a TAB character, and the message text itself.
;; Message direction alternates systematically between messages, it never
;; occurs that two successive messages are sent in the same direction.  The
;; first message is received from the Python side, it is `(version VERSION)'.
</t>
<t tx="T60">(defun pymacs-start-services ()
  ;; This function gets called automatically, as needed.
  (let ((buffer (get-buffer-create "*Pymacs*")))
    (with-current-buffer buffer
      (buffer-disable-undo)
      (save-match-data
	;; Launch the Python helper.
	(let ((process (apply 'start-process "pymacs" buffer "pymacs-services"
			      (mapcar 'expand-file-name pymacs-load-path))))
	  (process-kill-without-query process)
	  ;; Receive the synchronising reply.
	  (while (progn
		   (goto-char (point-min))
		   (not (re-search-forward "&lt;\\([0-9]+\\)\t" nil t)))
	    (unless (accept-process-output process pymacs-timeout-at-start)
	      (error "Pymacs helper did not start within %d seconds."
		     pymacs-timeout-at-start)))
	  (let ((marker (process-mark process))
		(limit-position (+ (match-end 0)
				   (string-to-number (match-string 1)))))
	    (while (&lt; (marker-position marker) limit-position)
	      (unless (accept-process-output process pymacs-timeout-at-start)
		(error "Pymacs helper probably was interrupted at start.")))))
	;; Check that synchronisation occurred.
	(goto-char (match-end 0))
	(let ((reply (read (current-buffer))))
	  (if (and (pymacs-proper-list-p reply)
		   (= (length reply) 2)
		   (eq (car reply) 'pymacs-version))
	      (unless (string-equal (cadr reply) "0.22")
		(error "Pymacs Lisp version is 0.22, Python is %s."
		       (cadr reply)))
	    (error "Pymacs got an invalid initial reply.")))))
    (setq pymacs-use-hash-tables (and (fboundp 'make-hash-table)
				      (fboundp 'gethash)
				      (fboundp 'puthash)))
    (when pymacs-use-hash-tables
      (if pymacs-weak-hash
	  ;; A previous Pymacs session occurred in *this* Emacs session.  Some
	  ;; IDs may hang around, which do not correspond to anything on the
	  ;; Python side.  Python should not recycle such IDs for new objects.
	  (when pymacs-used-ids
	    (let ((pymacs-transit-buffer buffer)
		  (pymacs-forget-mutability t))
	      (pymacs-apply "zombie_python" pymacs-used-ids)))
	(setq pymacs-weak-hash (make-hash-table :weakness 'value)))
      (if (boundp 'post-gc-hook)
	  (add-hook 'post-gc-hook 'pymacs-schedule-gc)
	(setq pymacs-gc-timer (run-at-time 20 20 'pymacs-schedule-gc))))
    ;; If nothing failed, only then declare that Pymacs has started!
    (setq pymacs-transit-buffer buffer)))</t>
<t tx="T61">(defun pymacs-terminate-services ()
  ;; This function is mainly provided for documentation purposes.
  (interactive)
  (garbage-collect)
  (pymacs-garbage-collect)
  (when (or (not pymacs-used-ids)
	    (yes-or-no-p "\
Killing the helper might create zombie objects.  Kill? "))
    (cond ((boundp 'post-gc-hook)
	   (remove-hook 'post-gc-hook 'pymacs-schedule-gc))
	  ((timerp pymacs-gc-timer)
	   (cancel-timer pymacs-gc-timer)))
    (when pymacs-transit-buffer
      (kill-buffer pymacs-transit-buffer))
    (setq pymacs-gc-running nil
	  pymacs-gc-timer nil
	  pymacs-transit-buffer nil
	  pymacs-lisp nil
	  pymacs-freed-list nil)))</t>
<t tx="T62">(defun pymacs-reply (expression)
  ;; This pseudo-function returns `(pymacs-reply . EXPRESSION)'.
  ;; It is only used from within the `loop' function on the Python side.
  ;; `serve-until-reply' later recognises this form.
  (cons 'pymacs-reply expression))</t>
<t tx="T63">(defun pymacs-error (expression)
  ;; This pseudo-function returns `(pymacs-error . EXPRESSION)'.
  ;; It is only used from within the `loop' function on the Python side.
  ;; `serve-until-reply' later recognises this form.
  (cons 'pymacs-error expression))</t>
<t tx="T64">(defun pymacs-expand (expression)
  ;; This pseudo-function returns `(pymacs-expand . EXPRESSION)'.  It is
  ;; only called from the `loop' function within `Pymacs/pymacs.py'.
  ;; `serve-until-reply' later recognises this form.
  (cons 'pymacs-expand expression))</t>
<t tx="T65">(defun pymacs-serve-until-reply (inserter)
  ;; This function evals INSERTER to print a Python request.  It sends it to
  ;; the Python helper, and serves all sub-requests coming from the
  ;; Python side, until either a reply or an error is finally received.
  (unless (and pymacs-transit-buffer
	       (buffer-name pymacs-transit-buffer)
	       (get-buffer-process pymacs-transit-buffer))
    (pymacs-start-services))
  (when pymacs-gc-wanted
    (pymacs-garbage-collect))
  (let (done value)
    (while (not done)
      (let* ((text (pymacs-round-trip inserter))
	     (reply (condition-case info
			(eval text)
		      (error (cons 'pymacs-oops (prin1-to-string info))))))
	(cond ((not (consp reply))
	       (setq inserter `(pymacs-print-for-apply 'reply '(,reply))))
	      ((eq 'pymacs-reply (car reply))
	       (setq done t value (cdr reply)))
	      ((eq 'pymacs-error (car reply))
	       (error "Python: %s" (cdr reply)))
	      ((eq 'pymacs-expand (car reply))
	       (setq inserter `(pymacs-print-for-apply-expanded
				'reply '(,(cdr reply)))))
	      ((eq 'pymacs-oops (car reply))
	       (setq inserter `(pymacs-print-for-apply
				'error '(,(cdr reply)))))
	      (t (setq inserter `(pymacs-print-for-apply 'reply '(,reply)))))))
    value))</t>
<t tx="T66">(defun pymacs-round-trip (inserter)
  ;; This function evals INSERTER to print a Python request.  It sends it to
  ;; the Python helper, awaits for any kind of reply, and returns it.
  (with-current-buffer pymacs-transit-buffer
    ;; Possibly trim the beginning of the transit buffer.
    (cond ((not pymacs-trace-transit)
	   (erase-buffer))
	  ((consp pymacs-trace-transit)
	   (when (&gt; (buffer-size) (cdr pymacs-trace-transit))
	     (let ((cut (- (buffer-size) (car pymacs-trace-transit))))
	       (when (&gt; cut 0)
		 (save-excursion
		   (goto-char cut)
		   (unless (memq (preceding-char) '(0 ?\n))
		     (forward-line 1))
		   (delete-region (point-min) (point))))))))
    ;; Send the request, wait for a reply, and process it.
    (let* ((process (get-buffer-process pymacs-transit-buffer))
	   (status (process-status process))
	   (marker (process-mark process))
	   (moving (= (point) marker))
	   send-position reply-position reply)
      (save-excursion
	(save-match-data
	  ;; Encode request.
	  (setq send-position (marker-position marker))
	  (let ((standard-output marker))
	    (eval inserter))
	  (goto-char marker)
	  (unless (= (preceding-char) ?\n)
	    (princ "\n" marker))
	  ;; Send request text.
	  (goto-char send-position)
	  (insert (format "&gt;%d\t" (- marker send-position)))
	  (setq reply-position (marker-position marker))
	  (process-send-region process send-position marker)
	  ;; Receive reply text.
	  (while (and (eq status 'run)
		      (progn
			(goto-char reply-position)
			(not (re-search-forward "&lt;\\([0-9]+\\)\t" nil t))))
	    (unless (accept-process-output process pymacs-timeout-at-reply)
	      (setq status (process-status process))))
	  (when (eq status 'run)
	    (let ((limit-position (+ (match-end 0)
				     (string-to-number (match-string 1)))))
	      (while (and (eq status 'run)
			  (&lt; (marker-position marker) limit-position))
		(unless (accept-process-output process pymacs-timeout-at-line)
		  (setq status (process-status process))))))
	  ;; Decode reply.
	  (if (not (eq status 'run))
	      (error "Pymacs helper status is `%S'." status)
	    (goto-char (match-end 0))
	    (setq reply (read (current-buffer))))))
      (when (and moving (not pymacs-trace-transit))
	(goto-char marker))
      reply)))</t>
<t tx="T67">(defun pymacs-proper-list-p (expression)
  ;; Tell if a list is proper, id est, that it is `nil' or ends with `nil'.
  (cond ((not expression))
	((consp expression) (not (cdr (last expression))))))</t>
<t tx="T68"></t>
<t tx="T69"></t>
<t tx="T70">@ignore
@language python

&lt;&lt; version &gt;&gt;

import sys, os, time
import wx    # This module uses the new wx namespace
import wx.html
import images

&lt;&lt; define the tree of demo elements &gt;&gt;

@others

&lt;&lt; overview of demo &gt;&gt;

if __name__ == '__main__':
    main()</t>
<t tx="T71">#!/bin/env python

#----------------------------------------------------------------------------
# Name:         Main.py
# Purpose:      Testing lots of stuff, controls, window types, etc.
#
# Author:       Robin Dunn
#
# Created:      A long time ago, in a galaxy far, far away...
# RCS-ID:       $Id$
# Copyright:    (c) 1999 by Total Control Software
# Licence:      wxWindows license
#----------------------------------------------------------------------------
</t>
<t tx="T72">_treeList = [
    # new stuff
    ('Recent Additions', [
        'wxScrolledPanel',
        'ShapedWindow',
        'NewNamespace',
        'PopupMenu',
        'AnalogClockWindow',
        'MaskedEditControls',
        'wxTreeListCtrl',
        'wxGrid_MegaExample',
        ]),

    # managed windows == things with a (optional) caption you can close
    ('Base Frames and Dialogs', [
        'wxDialog',
        'wxFrame',
        'wxMDIWindows',
        'wxMiniFrame',
        'wxWizard',
        ]),

    # the common dialogs
    ('Common Dialogs', [
        'wxColourDialog',
        'wxDirDialog',
        'wxFileDialog',
        'wxFindReplaceDialog',
        'wxFontDialog',
        'wxMessageDialog',
        'wxPageSetupDialog',
        'wxPrintDialog',
        'wxProgressDialog',
        'wxSingleChoiceDialog',
        'wxTextEntryDialog',
        ]),

    # dialogs from libraries
    ('More Dialogs', [
        'ErrorDialogs',
        'ImageBrowser',
        'wxMultipleChoiceDialog',
        'wxScrolledMessageDialog',
        ]),

    # core controls
    ('Core Windows/Controls', [
        'PopupMenu',
        'wxButton',
        'wxCheckBox',
        'wxCheckListBox',
        'wxChoice',
        'wxComboBox',
        'wxGauge',
        'wxGenericDirCtrl',
        'wxGrid',
        'wxGrid_MegaExample',
        'wxListBox',
        'wxListCtrl',
        'wxListCtrl_virtual',
        'wxMenu',
        'wxNotebook',
        'wxPopupWindow',
        'wxRadioBox',
        'wxRadioButton',
        'wxSashWindow',
        'wxScrolledWindow',
        'wxSlider',
        'wxSpinButton',
        'wxSpinCtrl',
        'wxSplitterWindow',
        'wxStaticBitmap',
        'wxStaticText',
        'wxStatusBar',
        'wxTextCtrl',
        'wxToggleButton',
        'wxToolBar',
        'wxTreeCtrl',
        'wxValidator',
        ]),

    # controls coming from other librairies
    ('More Windows/Controls', [
        #'wxFloatBar',          deprecated
        #'wxMVCTree',           deprecated
        #'wxRightTextCtrl',     deprecated as we have wxTE_RIGHT now.
        'AnalogClockWindow',
        'ColourSelect',
        'ContextHelp',
        'FancyText',
        'FileBrowseButton',
        'GenericButtons',
        'MaskedEditControls',
        'PyShell',
        'PyCrust',
        'SplitTree',
        'TablePrint',
        'Throbber',
        'wxCalendar',
        'wxCalendarCtrl',
        'wxPyColourChooser',
        'wxDynamicSashWindow',
        'wxEditableListBox',
        'wxEditor',
        'wxHtmlWindow',
        'wxIEHtmlWin',
        'wxIntCtrl',
        'wxLEDNumberCtrl',
        'wxMimeTypesManager',
        'wxMultiSash',
        'wxPopupControl',
        'wxStyledTextCtrl_1',
        'wxStyledTextCtrl_2',
        'wxTimeCtrl',
        'wxTreeListCtrl',
        ]),

    # How to lay out the controls in a frame/dialog
    ('Window Layout', [
        'LayoutAnchors',
        'Layoutf',
        'RowColSizer',
        'Sizers',
        'wxLayoutConstraints',
        'wxScrolledPanel',
        'wxXmlResource',
        'wxXmlResourceHandler',
        ]),

    # ditto
    ('Process and Events', [
        'EventManager',
        'infoframe',
        'OOR',
        'PythonEvents',
        'Threads',
        'wxKeyEvents',
        'wxProcess',
        'wxTimer',
        ]),

    # Clipboard and DnD
    ('Clipboard and DnD', [
        'CustomDragAndDrop',
        'DragAndDrop',
        'URLDragAndDrop',
        ]),

    # Images
    ('Using Images', [
        'Throbber',
        'wxArtProvider',
        'wxDragImage',
        'wxImage',
        'wxImageFromStream',
        'wxMask',
        ]),

    # Other stuff
    ('Miscellaneous', [
        'ColourDB',
        'DialogUnits',
        'DrawXXXList',
        'FontEnumerator',
        'PrintFramework',
        'Throbber',
        'Unicode',
        'wxFileHistory',
        'wxJoystick',
        'wxOGL',
        'wxWave',
        ]),

    # need libs not coming with the demo
    ('Objects using an external library', [
        'ActiveXWrapper_Acrobat',
        'ActiveXWrapper_IE',
        'wxGLCanvas',
        'wxPlotCanvas',
        ]),


    ('Check out the samples dir too', [
        ]),
]</t>
<t tx="T73">class MyLog(wx.PyLog):
	@others
</t>
<t tx="T74">def __init__(self, textCtrl, logTime=0):
    wx.PyLog.__init__(self)
    self.tc = textCtrl
    self.logTime = logTime
</t>
<t tx="T75">def DoLogString(self, message, timeStamp):
    if self.logTime:
        message = time.strftime("%X", time.localtime(timeStamp)) + \
                  ": " + message
    if self.tc:
        self.tc.AppendText(message + '\n')
</t>
<t tx="T76">class MyTP(wx.PyTipProvider):
	@others
</t>
<t tx="T77">def GetTip(self):
    return "This is my tip"
</t>
<t tx="T78">def opj(path):
    """Convert paths to the platform-specific separator"""
    return apply(os.path.join, tuple(path.split('/')))
</t>
<t tx="T79">class wxPythonDemo(wx.Frame):
	overviewText = "wxPython Overview"
	@others
</t>
<t tx="T80">def __init__(self, parent, id, title):

    wx.Frame.__init__(self, parent, -1, title, size = (800, 600),
		style=wx.DEFAULT_FRAME_STYLE|wx.NO_FULL_REPAINT_ON_RESIZE)

    self.cwd = os.getcwd()
    self.curOverview = ""
    self.window = None

    icon = images.getMondrianIcon()
    self.SetIcon(icon)

    if wx.Platform == '__WXMSW__':
        &lt;&lt; setup a taskbar icon, and catch some events from it &gt;&gt;

    wx.CallAfter(self.ShowTip)
    self.otherWin = None
    wx.EVT_IDLE(self, self.OnIdle)
    wx.EVT_CLOSE(self, self.OnCloseWindow)
    wx.EVT_ICONIZE(self, self.OnIconfiy)
    wx.EVT_MAXIMIZE(self, self.OnMaximize)

    self.Centre(wx.BOTH)
    self.CreateStatusBar(1, wx.ST_SIZEGRIP)

    splitter  = wx.SplitterWindow(self,     -1, style=wx.NO_3D|wx.SP_3D)
    splitter2 = wx.SplitterWindow(splitter, -1, style=wx.NO_3D|wx.SP_3D)

    def EmptyHandler(evt): pass
    wx.EVT_ERASE_BACKGROUND(splitter, EmptyHandler)
    wx.EVT_ERASE_BACKGROUND(splitter2, EmptyHandler)

    # Prevent TreeCtrl from displaying all items after destruction when True
    self.dying = False

	&lt;&lt; create menus &gt;&gt;
    self.finddata = wx.FindReplaceData()
    if 0:
		&lt;&lt; create accelerators &gt;&gt;
    &lt;&lt; Create a TreeCtrl &gt;&gt;
    &lt;&lt; Create a Notebook &gt;&gt;
    &lt;&lt; Set up a TextCtrl on the Demo Code Notebook page &gt;&gt;
    &lt;&lt; Set up a log on the View Log Notebook page &gt;&gt;
    self.Show(True)
    &lt;&lt; add the windows to the splitter and split it &gt;&gt;
    # select initial items
    self.nb.SetSelection(0)
    self.tree.SelectItem(root)
	&lt;&lt; handle sys.argv args &gt;&gt;
    wx.LogMessage('window handle: %s' % self.GetHandle())</t>
<t tx="T81"># Make a File menu
self.mainmenu = wx.MenuBar()
menu = wx.Menu()
exitID = wx.NewId()
menu.Append(exitID, 'E&amp;xit\tAlt-X', 'Get the heck outta here!')
wx.EVT_MENU(self, exitID, self.OnFileExit)
wx.App_SetMacExitMenuItemId(exitID)
self.mainmenu.Append(menu, '&amp;File')

# Make a Demo menu
menu = wx.Menu()
for item in _treeList:
    submenu = wx.Menu()
    for childItem in item[1]:
        mID = wx.NewId()
        submenu.Append(mID, childItem)
        wx.EVT_MENU(self, mID, self.OnDemoMenu)
    menu.AppendMenu(wx.NewId(), item[0], submenu)
self.mainmenu.Append(menu, '&amp;Demo')


# Make a Help menu
helpID = wx.NewId()
findID = wx.NewId()
findnextID = wx.NewId()
menu = wx.Menu()
menu.Append(findID, '&amp;Find\tCtrl-F', 'Find in the Demo Code')
menu.Append(findnextID, 'Find &amp;Next\tF3', 'Find Next')
menu.AppendSeparator()
menu.Append(helpID, '&amp;About\tCtrl-H', 'wxPython RULES!!!')
wx.App_SetMacAboutMenuItemId(helpID)
wx.EVT_MENU(self, helpID, self.OnHelpAbout)
wx.EVT_MENU(self, findID, self.OnHelpFind)
wx.EVT_MENU(self, findnextID, self.OnFindNext)
wx.EVT_COMMAND_FIND(self, -1, self.OnFind)
wx.EVT_COMMAND_FIND_NEXT(self, -1, self.OnFind)
wx.EVT_COMMAND_FIND_CLOSE(self, -1 , self.OnFindClose)
self.mainmenu.Append(menu, '&amp;Help')
self.SetMenuBar(self.mainmenu)</t>
<t tx="T82">tID = wx.NewId()
self.treeMap = {}
self.tree = wx.TreeCtrl(splitter, tID,
	style=wx.TR_HAS_BUTTONS | wx.TR_HAS_VARIABLE_ROW_HEIGHT)

root = self.tree.AddRoot("wxPython Overview")
firstChild = None
for item in _treeList:
    child = self.tree.AppendItem(root, item[0])
    if not firstChild: firstChild = child
    for childItem in item[1]:
        theDemo = self.tree.AppendItem(child, childItem)
        self.treeMap[childItem] = theDemo

self.tree.Expand(root)
self.tree.Expand(firstChild)

wx.EVT_TREE_ITEM_EXPANDED   (self.tree, tID, self.OnItemExpanded)
wx.EVT_TREE_ITEM_COLLAPSED  (self.tree, tID, self.OnItemCollapsed)
wx.EVT_TREE_SEL_CHANGED     (self.tree, tID, self.OnSelChanged)
wx.EVT_LEFT_DOWN            (self.tree,      self.OnTreeLeftDown)</t>
<t tx="T83">self.nb = wx.Notebook(splitter2, -1, style=wx.CLIP_CHILDREN)

# Set up a wx.html.HtmlWindow on the Overview Notebook page
# we put it in a panel first because there seems to be a
# refresh bug of some sort (wxGTK) when it is directly in
# the notebook...

if 0:  # the old way
    self.ovr = wx.html.HtmlWindow(self.nb, -1, size=(400, 400))
    self.nb.AddPage(self.ovr, self.overviewText)

else:  # hopefully I can remove this hacky code soon, see SF bug #216861
    panel = wx.Panel(self.nb, -1, style=wx.CLIP_CHILDREN)
    self.ovr = wx.html.HtmlWindow(panel, -1, size=(400, 400))
    self.nb.AddPage(panel, self.overviewText)

    def OnOvrSize(evt, ovr=self.ovr):
        ovr.SetSize(evt.GetSize())

    wx.EVT_SIZE(panel, OnOvrSize)
    wx.EVT_ERASE_BACKGROUND(panel, EmptyHandler)

self.SetOverview(self.overviewText, overview)</t>
<t tx="T84">self.txt = wx.TextCtrl(self.nb, -1,
	style = wx.TE_MULTILINE|
	wx.TE_READONLY|
	wx.HSCROLL|
	wx.TE_RICH2|
	wx.TE_NOHIDESEL)
	
self.nb.AddPage(self.txt, "Demo Code")
</t>
<t tx="T85">self.log = wx.TextCtrl(splitter2, -1,
	style = wx.TE_MULTILINE|wx.TE_READONLY|wx.HSCROLL)

# Set the wxWindows log target to be this textctrl
#wx.Log_SetActiveTarget(wx.LogTextCtrl(self.log))

# But instead of the above we want to show how to use our own wx.Log class
wx.Log_SetActiveTarget(MyLog(self.log))

# for serious debugging
#wx.Log_SetActiveTarget(wx.LogStderr())
#wx.Log_SetTraceMask(wx.TraceMessages)</t>
<t tx="T86">splitter2.SplitHorizontally(self.nb, self.log, 450)
splitter.SplitVertically(self.tree, splitter2, 180)

splitter.SetMinimumPaneSize(20)
splitter2.SetMinimumPaneSize(20)</t>
<t tx="T87"># This is another way to set Accelerators, in addition to
# using the '\t&lt;key&gt;' syntax in the menu items.
aTable = wx.AcceleratorTable(
	[(wx.ACCEL_ALT,  ord('X'), exitID),
	(wx.ACCEL_CTRL, ord('H'), helpID),
	(wx.ACCEL_CTRL, ord('F'), findID),
	(wx.ACCEL_NORMAL, WXK_F3, findnextID)
	])
	
self.SetAcceleratorTable(aTable)
</t>
<t tx="T88">self.tbicon = wx.TaskBarIcon()
self.tbicon.SetIcon(icon, "wxPython Demo")

wx.EVT_TASKBAR_LEFT_DCLICK(self.tbicon, self.OnTaskBarActivate)
wx.EVT_TASKBAR_RIGHT_UP(self.tbicon, self.OnTaskBarMenu)
wx.EVT_MENU(self.tbicon, self.TBMENU_RESTORE, self.OnTaskBarActivate)
wx.EVT_MENU(self.tbicon, self.TBMENU_CLOSE, self.OnTaskBarClose)</t>
<t tx="T89">if len(sys.argv) == 2:
    try:
        selectedDemo = self.treeMap[sys.argv[1]]
    except:
        selectedDemo = None
    if selectedDemo:
        self.tree.SelectItem(selectedDemo)
        self.tree.EnsureVisible(selectedDemo)</t>
<t tx="T90">def WriteText(self, text):
    if text[-1:] == '\n':
        text = text[:-1]
    wx.LogMessage(text)
</t>
<t tx="T91">def write(self, txt):
    self.WriteText(txt)
</t>
<t tx="T92"></t>
<t tx="T93">def OnItemExpanded(self, event):
	
    item = event.GetItem()
    wx.LogMessage("OnItemExpanded: %s" % self.tree.GetItemText(item))
    event.Skip()

</t>
<t tx="T94">def OnItemCollapsed(self, event):

    item = event.GetItem()
    wx.LogMessage("OnItemCollapsed: %s" % self.tree.GetItemText(item))
    event.Skip()
</t>
<t tx="T95">def OnTreeLeftDown(self, event):
	
    pt = event.GetPosition();
    item, flags = self.tree.HitTest(pt)
    if item == self.tree.GetSelection():
        self.SetOverview(self.tree.GetItemText(item)+" Overview", self.curOverview)
    event.Skip()

</t>
<t tx="T96">def OnSelChanged(self, event):

    if self.dying:
        return

    item = event.GetItem()
    itemText = self.tree.GetItemText(item)
    self.RunDemo(itemText)</t>
<t tx="T97">def RunDemo(self, itemText):
    os.chdir(self.cwd)
    if self.nb.GetPageCount() == 3:
        if self.nb.GetSelection() == 2:
            self.nb.SetSelection(0)
        # inform the window that it's time to quit if it cares
        if self.window is not None:
            if hasattr(self.window, "ShutdownDemo"):
                self.window.ShutdownDemo()
        wx.SafeYield() # in case the page has pending events
        self.nb.DeletePage(2)

    if itemText == self.overviewText:
        self.GetDemoFile('Main.py')
        self.SetOverview(self.overviewText, overview)
        self.nb.Refresh();
        self.window = None

    else:
        if os.path.exists(itemText + '.py'):
            wx.BeginBusyCursor()
            wx.LogMessage("Running demo %s.py..." % itemText)
            try:
                self.GetDemoFile(itemText + '.py')
                module = __import__(itemText, globals())
                self.SetOverview(itemText + " Overview", module.overview)
            finally:
                wx.EndBusyCursor()
            self.tree.Refresh()

            # in case runTest is modal, make sure things look right...
            self.nb.Refresh();
            wx.SafeYield()

            self.window = module.runTest(self, self.nb, self) ###
            if self.window is not None:
                self.nb.AddPage(self.window, 'Demo')
                self.nb.SetSelection(2)
                self.nb.Refresh()  # without this wxMac has troubles showing the just added page

        else:
            self.ovr.SetPage("")
            self.txt.Clear()
            self.window = None
</t>
<t tx="T98">#---------------------------------------------
# Get the Demo files
def GetDemoFile(self, filename):
    self.txt.Clear()
    try:
        self.txt.SetValue(open(filename).read())
    except IOError:
        self.txt.WriteText("Cannot open %s file." % filename)

    self.txt.SetInsertionPoint(0)
    self.txt.ShowPosition(0)
</t>
<t tx="T99">#---------------------------------------------
def SetOverview(self, name, text):
    self.curOverview = text
    lead = text[:6]
    if lead != '&lt;html&gt;' and lead != '&lt;HTML&gt;':
        text = '&lt;br&gt;'.join(text.split('\n'))
    self.ovr.SetPage(text)
    self.nb.SetPageText(0, name)
</t>
<t tx="T100">#---------------------------------------------
# Menu methods
def OnFileExit(self, *event):
    self.Close()
</t>
<t tx="T101">def OnHelpAbout(self, event):
    from About import MyAboutBox
    about = MyAboutBox(self)
    about.ShowModal()
    about.Destroy()
</t>
<t tx="T102">def OnHelpFind(self, event):
    self.nb.SetSelection(1)
    self.finddlg = wx.FindReplaceDialog(self, self.finddata, "Find",
                    wx.FR_NOUPDOWN |
                    wx.FR_NOMATCHCASE |
                    wx.FR_NOWHOLEWORD)
    self.finddlg.Show(True)
</t>
<t tx="T103">def OnFind(self, event):
    self.nb.SetSelection(1)
    end = self.txt.GetLastPosition()
    textstring = self.txt.GetRange(0, end).lower()
    start = self.txt.GetSelection()[1]
    findstring = self.finddata.GetFindString().lower()
    loc = textstring.find(findstring, start)
    if loc == -1 and start != 0:
        # string not found, start at beginning
        start = 0
        loc = textstring.find(findstring, start)
    if loc == -1:
        dlg = wx.MessageDialog(self, 'Find String Not Found',
                      'Find String Not Found in Demo File',
                      wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()
    if self.finddlg:
        if loc == -1:
            self.finddlg.SetFocus()
            return
        else:
            self.finddlg.Destroy()
    self.txt.SetSelection(loc, loc + len(findstring))
    self.txt.ShowPosition(loc)
</t>
<t tx="T104">def OnFindNext(self, event):
    if self.finddata.GetFindString():
        self.OnFind(event)
    else:
        self.OnHelpFind(event)
</t>
<t tx="T105">def OnFindClose(self, event):
    event.GetDialog().Destroy()
</t>
<t tx="T106">#---------------------------------------------
def OnCloseWindow(self, event):
    self.dying = True
    self.window = None
    self.mainmenu = None
    if hasattr(self, "tbicon"):
        del self.tbicon
    self.Destroy()
</t>
<t tx="T107">#---------------------------------------------
def OnIdle(self, event):
    if self.otherWin:
        self.otherWin.Raise()
        self.window = self.otherWin
        self.otherWin = None
</t>
<t tx="T108">#---------------------------------------------
def ShowTip(self):
    try:
        showTipText = open(opj("data/showTips")).read()
        showTip, index = eval(showTipText)
    except IOError:
        showTip, index = (1, 0)
    if showTip:
        tp = wx.CreateFileTipProvider(opj("data/tips.txt"), index)
        ##tp = MyTP(0)
        showTip = wx.ShowTip(self, tp)
        index = tp.GetCurrentTip()
        open(opj("data/showTips"), "w").write(str( (showTip, index) ))
</t>
<t tx="T109">#---------------------------------------------
def OnDemoMenu(self, event):
    try:
        selectedDemo = self.treeMap[self.mainmenu.GetLabel(event.GetId())]
    except:
        selectedDemo = None
    if selectedDemo:
        self.tree.SelectItem(selectedDemo)
        self.tree.EnsureVisible(selectedDemo)
</t>
<t tx="T110">#---------------------------------------------
def OnTaskBarActivate(self, evt):
    if self.IsIconized():
        self.Iconize(False)
    if not self.IsShown():
        self.Show(True)
    self.Raise()
</t>
<t tx="T111">#---------------------------------------------

TBMENU_RESTORE = 1000
TBMENU_CLOSE   = 1001

def OnTaskBarMenu(self, evt):
    menu = wx.Menu()
    menu.Append(self.TBMENU_RESTORE, "Restore wxPython Demo")
    menu.Append(self.TBMENU_CLOSE,   "Close")
    self.tbicon.PopupMenu(menu)
    menu.Destroy()
</t>
<t tx="T112">#---------------------------------------------
def OnTaskBarClose(self, evt):
    self.Close()

    # because of the way wx.TaskBarIcon.PopupMenu is implemented we have to
    # prod the main idle handler a bit to get the window to actually close
    wx.GetApp().ProcessIdle()
</t>
<t tx="T113">#---------------------------------------------
def OnIconfiy(self, evt):
    wx.LogMessage("OnIconfiy")
    evt.Skip()
</t>
<t tx="T114">#---------------------------------------------
def OnMaximize(self, evt):
    wx.LogMessage("OnMaximize")
    evt.Skip()
</t>
<t tx="T115">class MySplashScreen(wx.SplashScreen):
	@others
</t>
<t tx="T116">def __init__(self):

    bmp = wx.Image(opj("bitmaps/splash.gif")).ConvertToBitmap()

    wx.SplashScreen.__init__(self, bmp,
		wx.SPLASH_CENTRE_ON_SCREEN|wx.SPLASH_TIMEOUT,
		4000, None, -1,
		style = wx.SIMPLE_BORDER|wx.FRAME_NO_TASKBAR|wx.STAY_ON_TOP)

    wx.EVT_CLOSE(self, self.OnClose)</t>
<t tx="T117">def OnClose(self, evt):
    frame = wxPythonDemo(None, -1, "wxPython: (A Demonstration)")
    frame.Show()
    evt.Skip()  # Make sure the default handler runs too...
</t>
<t tx="T118">class MyApp(wx.App):
	@others
</t>
<t tx="T119">def OnInit(self):
    """
    Create and show the splash screen.  It will then create and show
    the main frame when it is time to do so.
    """

    #import locale
    #self.locale = wx.Locale(wx.LANGUAGE_FRENCH)
    #locale.setlocale(locale.LC_ALL, 'fr')

    wx.InitAllImageHandlers()
    splash = MySplashScreen()
    splash.Show()
    return True
</t>
<t tx="T120">def main():
    try:
        demoPath = os.path.dirname(__file__)
        os.chdir(demoPath)
    except:
        pass

    app = MyApp(wx.Platform == "__WXMAC__")
    app.MainLoop()</t>
<t tx="T121">overview = """&lt;html&gt;&lt;body&gt;
&lt;h2&gt;wxPython&lt;/h2&gt;

&lt;p&gt; wxPython is a &lt;b&gt;GUI toolkit&lt;/b&gt; for the &lt;a
href="http://www.python.org/"&gt;Python&lt;/a&gt; programming language.  It
allows Python programmers to create programs with a robust, highly
functional graphical user interface, simply and easily.  It is
implemented as a Python extension module (native code) that wraps the
popular &lt;a href="http://wxwindows.org/front.htm"&gt;wxWindows&lt;/a&gt; cross
platform GUI library, which is written in C++.

&lt;p&gt; Like Python and wxWindows, wxPython is &lt;b&gt;Open Source&lt;/b&gt; which
means that it is free for anyone to use and the source code is
available for anyone to look at and modify.  Or anyone can contribute
fixes or enhnacments to the project.

&lt;p&gt; wxPython is a &lt;b&gt;cross-platform&lt;/b&gt; toolkit.  This means that the
same program will run on multiple platforms without modification.
Currently supported platforms are 32-bit Microsoft Windows, most Unix
or unix-like systems, and Macintosh OS X. Since the language is
Python, wxPython programs are &lt;b&gt;simple, easy&lt;/b&gt; to write and easy to
understand.

&lt;p&gt; &lt;b&gt;This demo&lt;/b&gt; is not only a collection of test cases for
wxPython, but is also designed to help you learn about and how to use
wxPython.  Each sample is listed in the tree control on the left.
When a sample is selected in the tree then a module is loaded and run
(usually in a tab of this notebook,) and the source code of the module
is loaded in another tab for you to browse and learn from.

"""</t>
<t tx="T122"></t>
<t tx="T123">@ignore
@language python

from wxPython.wx import *
from wxPython.gizmos import wxTreeListCtrl

import images

@others

overview = """&lt;html&gt;&lt;body&gt;
&lt;h2&gt;&lt;center&gt;wxTreeListCtrl&lt;/center&gt;&lt;/h2&gt;

The wxTreeListCtrl is essentially a wxTreeCtrl with extra columns,
such that the look is similar to a wxListCtrl.

&lt;/body&gt;&lt;/html&gt;
"""

if __name__ == '__main__':
    #raw_input("Press enter...")
    import sys,os,run
    run.main(['', os.path.basename(sys.argv[0])])</t>
<t tx="T124">class TestPanel(wxPanel):
	@others
</t>
<t tx="T125">def __init__(self, parent, log):
    self.log = log
    wxPanel.__init__(self, parent, -1)
    EVT_SIZE(self, self.OnSize)

    self.tree = wxTreeListCtrl(self, -1, style = wxTR_DEFAULT_STYLE
                               #| wxTR_ROW_LINES
                               #| wxTR_NO_LINES | wxTR_TWIST_BUTTONS
                               )
    isz = (16,16)
    il = wxImageList(isz[0], isz[1])
    fldridx     = il.Add(wxArtProvider_GetBitmap(wxART_FOLDER,      wxART_OTHER, isz))
    fldropenidx = il.Add(wxArtProvider_GetBitmap(wxART_FILE_OPEN,   wxART_OTHER, isz))
    fileidx     = il.Add(wxArtProvider_GetBitmap(wxART_REPORT_VIEW, wxART_OTHER, isz))
    smileidx    = il.Add(images.getSmilesBitmap())

    self.tree.SetImageList(il)
    self.il = il

    # create some columns
    self.tree.AddColumn("Main column")
    self.tree.AddColumn("Column 1")
    self.tree.AddColumn("Column 2")
    self.tree.SetMainColumn(0) # the one with the tree in it...
    self.tree.SetColumnWidth(0, 175)


    self.root = self.tree.AddRoot("The Root Item")
    self.tree.SetItemText(self.root, "col 1 root", 1)
    self.tree.SetItemText(self.root, "col 2 root", 2)
    self.tree.SetItemImage(self.root, fldridx, which = wxTreeItemIcon_Normal)
    self.tree.SetItemImage(self.root, fldropenidx, which = wxTreeItemIcon_Expanded)


    for x in range(15):
        txt = "Item %d" % x
        child = self.tree.AppendItem(self.root, txt)
        self.tree.SetItemText(child, txt + "(c1)", 1)
        self.tree.SetItemText(child, txt + "(c2)", 2)
        self.tree.SetItemImage(child, fldridx, which = wxTreeItemIcon_Normal)
        self.tree.SetItemImage(child, fldropenidx, which = wxTreeItemIcon_Expanded)

        for y in range(5):
            txt = "item %d-%s" % (x, chr(ord("a")+y))
            last = self.tree.AppendItem(child, txt)
            self.tree.SetItemText(last, txt + "(c1)", 1)
            self.tree.SetItemText(last, txt + "(c2)", 2)
            self.tree.SetItemImage(last, fldridx, which = wxTreeItemIcon_Normal)
            self.tree.SetItemImage(last, fldropenidx, which = wxTreeItemIcon_Expanded)

            for z in range(5):
                txt = "item %d-%s-%d" % (x, chr(ord("a")+y), z)
                item = self.tree.AppendItem(last,  txt)
                self.tree.SetItemText(item, txt + "(c1)", 1)
                self.tree.SetItemText(item, txt + "(c2)", 2)
                self.tree.SetItemImage(item, fileidx, which = wxTreeItemIcon_Normal)
                self.tree.SetItemImage(item, smileidx, which = wxTreeItemIcon_Selected)


    self.tree.Expand(self.root)
</t>
<t tx="T126">def OnSize(self, evt):
    self.tree.SetSize(self.GetSize())
</t>
<t tx="T127">def runTest(frame, nb, log):
    win = TestPanel(nb, log)
    return win
</t>
<t tx="T128">@ignore
@language python

from wxPython.wx import *
import images,string

@others

overview = """\
A tree control presents information as a hierarchy, with items that may be expanded to show further items. Items in a tree control are referenced by wxTreeItemId handles.

"""

if __name__ == '__main__':
    import sys,os,run
    run.main(['', os.path.basename(sys.argv[0])])

</t>
<t tx="T129">class MyTreeCtrl(wxTreeCtrl):
	@others
</t>
<t tx="T130">def __init__(self, parent, id, pos, size, style, log):

    wxTreeCtrl.__init__(self, parent, id, pos, size, style)
    self.log = log
</t>
<t tx="T131">def OnCompareItems(self, item1, item2):

    t1 = self.GetItemText(item1)
    t2 = self.GetItemText(item2)
    self.log.WriteText('compare: ' + t1 + ' &lt;&gt; ' + t2 + '\n')
    if t1 &lt; t2: return -1
    if t1 == t2: return 0
    return 1
</t>
<t tx="T132">class TestTreeCtrlPanel(wxPanel):
	@others
</t>
<t tx="T133">def __init__(self, parent, log):

    # Use the WANTS_CHARS style so the panel doesn't eat the Return key.
    wxPanel.__init__(self, parent, -1, style=wxWANTS_CHARS)
    EVT_SIZE(self,self.OnSize)

    self.log = log
    tID = wxNewId()

    self.tree = MyTreeCtrl(self, tID, wxDefaultPosition, wxDefaultSize,
                          wxTR_HAS_BUTTONS
                           | wxTR_EDIT_LABELS
                           #| wxTR_MULTIPLE
                           #| wxTR_HIDE_ROOT
                           , self.log)

    isz = (16,16)
    il = wxImageList(isz[0], isz[1])
    fldridx     = il.Add(wxArtProvider_GetBitmap(wxART_FOLDER,      wxART_OTHER, isz))
    fldropenidx = il.Add(wxArtProvider_GetBitmap(wxART_FILE_OPEN,   wxART_OTHER, isz))
    fileidx     = il.Add(wxArtProvider_GetBitmap(wxART_REPORT_VIEW, wxART_OTHER, isz))
    smileidx    = il.Add(images.getSmilesBitmap())

    self.tree.SetImageList(il)
    self.il = il

    # NOTE:  For some reason tree items have to have a data object in
    #        order to be sorted.  Since our compare just uses the labels
    #        we don't need any real data, so we'll just use None below for
    #        the item data.

    self.root = self.tree.AddRoot("The Root Item")
    self.tree.SetPyData(self.root, None)
    self.tree.SetItemImage(self.root, fldridx, wxTreeItemIcon_Normal)
    self.tree.SetItemImage(self.root, fldropenidx, wxTreeItemIcon_Expanded)


    for x in range(15):
        child = self.tree.AppendItem(self.root, "Item %d" % x)
        self.tree.SetPyData(child, None)
        self.tree.SetItemImage(child, fldridx, wxTreeItemIcon_Normal)
        self.tree.SetItemImage(child, fldropenidx, wxTreeItemIcon_Expanded)
        for y in range(5):
            last = self.tree.AppendItem(child, "item %d-%s" % (x, chr(ord("a")+y)))
            self.tree.SetPyData(last, None)
            self.tree.SetItemImage(last, fldridx, wxTreeItemIcon_Normal)
            self.tree.SetItemImage(last, fldropenidx, wxTreeItemIcon_Expanded)
            for z in range(5):
                item = self.tree.AppendItem(last,  "item %d-%s-%d" % (x, chr(ord("a")+y), z))
                self.tree.SetPyData(item, None)
                self.tree.SetItemImage(item, fileidx, wxTreeItemIcon_Normal)
                self.tree.SetItemImage(item, smileidx, wxTreeItemIcon_Selected)

    self.tree.Expand(self.root)
    EVT_TREE_ITEM_EXPANDED  (self, tID, self.OnItemExpanded)
    EVT_TREE_ITEM_COLLAPSED (self, tID, self.OnItemCollapsed)
    EVT_TREE_SEL_CHANGED    (self, tID, self.OnSelChanged)
    EVT_TREE_BEGIN_LABEL_EDIT(self, tID, self.OnBeginEdit)
    EVT_TREE_END_LABEL_EDIT (self, tID, self.OnEndEdit)
    EVT_TREE_ITEM_ACTIVATED (self, tID, self.OnActivate)

    EVT_LEFT_DCLICK(self.tree, self.OnLeftDClick)
    EVT_RIGHT_DOWN(self.tree, self.OnRightClick)
    EVT_RIGHT_UP(self.tree, self.OnRightUp)
</t>
<t tx="T134">def OnRightClick(self, event):

    pt = event.GetPosition();
    item, flags = self.tree.HitTest(pt)
    self.log.WriteText("OnRightClick: %s, %s, %s\n" %
                       (self.tree.GetItemText(item), type(item), item.__class__))
    self.tree.SelectItem(item)
</t>
<t tx="T135">def OnRightUp(self, event):

    pt = event.GetPosition();
    item, flags = self.tree.HitTest(pt)
    self.log.WriteText("OnRightUp: %s (manually starting label edit)\n"
                       % self.tree.GetItemText(item))
    self.tree.EditLabel(item)
</t>
<t tx="T136">def OnBeginEdit(self, event):
    self.log.WriteText("OnBeginEdit\n")
    # show how to prevent edit...
    if self.tree.GetItemText(event.GetItem()) == "The Root Item":
        wxBell()
        self.log.WriteText("You can't edit this one...\n")

        # Lets just see what's visible of its children
        cookie = 0
        root = event.GetItem()
        (child, cookie) = self.tree.GetFirstChild(root, cookie)
        while child.IsOk():
            self.log.WriteText("Child [%s] visible = %d" %
                               (self.tree.GetItemText(child),
                                self.tree.IsVisible(child)))
            (child, cookie) = self.tree.GetNextChild(root, cookie)

        event.Veto()
</t>
<t tx="T137">def OnEndEdit(self, event):
    self.log.WriteText("OnEndEdit\n")
    # show how to reject edit, we'll not allow any digits
    for x in event.GetLabel():
        if x in string.digits:
            self.log.WriteText("You can't enter digits...\n")
            event.Veto()
            return
</t>
<t tx="T138">def OnLeftDClick(self, event):
    pt = event.GetPosition();
    item, flags = self.tree.HitTest(pt)
    self.log.WriteText("OnLeftDClick: %s\n" % self.tree.GetItemText(item))
    parent = self.tree.GetItemParent(item)
    self.tree.SortChildren(parent)
    event.Skip()
</t>
<t tx="T139">def OnSize(self, event):
    w,h = self.GetClientSizeTuple()
    self.tree.SetDimensions(0, 0, w, h)
</t>
<t tx="T140">def OnItemExpanded(self, event):
    item = event.GetItem()
    self.log.WriteText("OnItemExpanded: %s\n" % self.tree.GetItemText(item))
</t>
<t tx="T141">def OnItemCollapsed(self, event):
    item = event.GetItem()
    self.log.WriteText("OnItemCollapsed: %s\n" % self.tree.GetItemText(item))
</t>
<t tx="T142">def OnSelChanged(self, event):
    self.item = event.GetItem()
    self.log.WriteText("OnSelChanged: %s\n" % self.tree.GetItemText(self.item))
    if wxPlatform == '__WXMSW__':
        self.log.WriteText("BoundingRect: %s\n" %
                           self.tree.GetBoundingRect(self.item, True))
    #items = self.tree.GetSelections()
    #print map(self.tree.GetItemText, items)
    event.Skip()
</t>
<t tx="T143">def OnActivate(self, event):
    self.log.WriteText("OnActivate: %s\n" % self.tree.GetItemText(self.item))
</t>
<t tx="T144">def runTest(frame, nb, log):
    win = TestTreeCtrlPanel(nb, log)
    return win
</t>
<t tx="T145"></t>
<t tx="T146">@ignore
@language python
&lt;&lt; wxStyledTextCtrl_1 declarations &gt;&gt;
@others



#----------------------------------------------------------------------


overview = """\
&lt;html&gt;&lt;body&gt;
Once again, no docs yet.  &lt;b&gt;Sorry.&lt;/b&gt;  But &lt;a href="data/stc.h.html"&gt;this&lt;/a&gt;
and &lt;a href="http://www.scintilla.org/ScintillaDoc.html"&gt;this&lt;/a&gt; should
be helpful.
&lt;/body&gt;&lt;html&gt;
"""


if __name__ == '__main__':
    import sys,os
    import run
    run.main(['', os.path.basename(sys.argv[0])])

</t>
<t tx="T147">from wxPython.wx import *
from wxPython.stc import *

import images

#----------------------------------------------------------------------

debug = 1


demoText = """\

This editor is provided by a class named wxStyledTextCtrl.  As
the name suggests, you can define styles that can be applied to
sections of text.  This will typically be used for things like
syntax highlighting code editors, but I'm sure that there are other
applications as well.  A style is a combination of font, point size,
forground and background colours.  The editor can handle
proportional fonts just as easily as monospaced fonts, and various
styles can use different sized fonts.

There are a few canned language lexers and colourizers included,
(see the next demo) or you can handle the colourization yourself.
If you do you can simply register an event handler and the editor
will let you know when the visible portion of the text needs
styling.

wxStyledTextEditor also supports setting markers in the margin...




...and indicators within the text.  You can use these for whatever
you want in your application.  Cut, Copy, Paste, Drag and Drop of
text works, as well as virtually unlimited Undo and Redo
capabilities, (right click to try it out.)
"""

if wxPlatform == '__WXMSW__':
    face1 = 'Arial'
    face2 = 'Times New Roman'
    face3 = 'Courier New'
    pb = 10
else:
    face1 = 'Helvetica'
    face2 = 'Times'
    face3 = 'Courier'
    pb = 10


#----------------------------------------------------------------------
# This shows how to catch the Modified event from the wxStyledTextCtrl

</t>
<t tx="T148">class MySTC(wxStyledTextCtrl):
	@others
</t>
<t tx="T149">def __init__(self, parent, ID, log):
    wxStyledTextCtrl.__init__(self, parent, ID)
    self.log = log

    EVT_STC_DO_DROP(self, ID, self.OnDoDrop)
    EVT_STC_DRAG_OVER(self, ID, self.OnDragOver)
    EVT_STC_START_DRAG(self, ID, self.OnStartDrag)
    EVT_STC_MODIFIED(self, ID, self.OnModified)

    EVT_WINDOW_DESTROY(self, self.OnDestroy)
</t>
<t tx="T150">def OnDestroy(self, evt):
    # This is how the clipboard contents can be preserved after
    # the app has exited.
    wxTheClipboard.Flush()
    evt.Skip()
</t>
<t tx="T151">def OnStartDrag(self, evt):
    self.log.write("OnStartDrag: %d, %s\n"
                   % (evt.GetDragAllowMove(), evt.GetDragText()))

    if debug and evt.GetPosition() &lt; 250:
        evt.SetDragAllowMove(False)     # you can prevent moving of text (only copy)
        evt.SetDragText("DRAGGED TEXT") # you can change what is dragged
</t>
<t tx="T152">        #evt.SetDragText("")             # or prevent the drag with empty text


def OnDragOver(self, evt):
    self.log.write("OnDragOver: x,y=(%d, %d)  pos: %d  DragResult: %d\n"
                   % (evt.GetX(), evt.GetY(), evt.GetPosition(), evt.GetDragResult()))

    if debug and evt.GetPosition() &lt; 250:
        evt.SetDragResult(wxDragNone)   # prevent dropping at the begining of the buffer
</t>
<t tx="T153">def OnDoDrop(self, evt):
    self.log.write("OnDoDrop: x,y=(%d, %d)  pos: %d  DragResult: %d\n"
                   "\ttext: %s\n"
                   % (evt.GetX(), evt.GetY(), evt.GetPosition(), evt.GetDragResult(),
                      evt.GetDragText()))

    if debug and evt.GetPosition() &lt; 500:
        evt.SetDragText("DROPPED TEXT")  # Can change text if needed
</t>
<t tx="T154">        ##evt.SetDragResult(wxDragNone)  # Can also change the drag operation, but it
                                         # is probably better to do it in OnDragOver so
                                         # there is visual feedback

        ##evt.SetPosition(25)            # Can also change position, but I'm not sure why
                                         # you would want to...




def OnModified(self, evt):
    self.log.write("""OnModified
    Mod type:     %s
    At position:  %d
    Lines added:  %d
    Text Length:  %d
    Text:         %s\n""" % ( self.transModType(evt.GetModificationType()),
                              evt.GetPosition(),
                              evt.GetLinesAdded(),
                              evt.GetLength(),
                              repr(evt.GetText()) ))
</t>
<t tx="T155">def transModType(self, modType):
    st = ""
    table = [(wxSTC_MOD_INSERTTEXT, "InsertText"),
             (wxSTC_MOD_DELETETEXT, "DeleteText"),
             (wxSTC_MOD_CHANGESTYLE, "ChangeStyle"),
             (wxSTC_MOD_CHANGEFOLD, "ChangeFold"),
             (wxSTC_PERFORMED_USER, "UserFlag"),
             (wxSTC_PERFORMED_UNDO, "Undo"),
             (wxSTC_PERFORMED_REDO, "Redo"),
             (wxSTC_LASTSTEPINUNDOREDO, "Last-Undo/Redo"),
             (wxSTC_MOD_CHANGEMARKER, "ChangeMarker"),
             (wxSTC_MOD_BEFOREINSERT, "B4-Insert"),
             (wxSTC_MOD_BEFOREDELETE, "B4-Delete")
             ]

    for flag,text in table:
        if flag &amp; modType:
            st = st + text + " "

    if not st:
        st = 'UNKNOWN'

    return st
</t>
<t tx="T156">#----------------------------------------------------------------------

_USE_PANEL = 1

def runTest(frame, nb, log):
    if not _USE_PANEL:
        ed = p = MySTC(nb, -1, log)

    else:
        p = wxPanel(nb, -1, style=wxNO_FULL_REPAINT_ON_RESIZE)
        ed = MySTC(p, -1, log)
        s = wxBoxSizer(wxHORIZONTAL)
        s.Add(ed, 1, wxEXPAND)
        p.SetSizer(s)
        p.SetAutoLayout(True)


    #ed.SetBufferedDraw(False)
    #ed.StyleClearAll()
    #ed.SetScrollWidth(800)
    #ed.SetWrapMode(True)

    ed.SetText(demoText)
    if wxUSE_UNICODE:
        import codecs
        decode = codecs.lookup("utf-8")[1]

        ed.GotoPos(ed.GetLength())
        ed.AddText("\n\nwxStyledTextCtrl can also do Unicode:\n")
        unitext, l = decode('\xd0\x9f\xd0\xb8\xd1\x82\xd0\xbe\xd0\xbd - '
                            '\xd0\xbb\xd1\x83\xd1\x87\xd1\x88\xd0\xb8\xd0\xb9 '
                            '\xd1\x8f\xd0\xb7\xd1\x8b\xd0\xba \xd0\xbf\xd1\x80\xd0\xbe\xd0\xb3\xd1\x80\xd0\xb0\xd0\xbc\xd0\xbc\xd0\xb8\xd1\x80\xd0\xbe\xd0\xb2\xd0\xb0\xd0\xbd\xd0\xb8\xd1\x8f!\n\n')
        ed.AddText('\tRussian: ')
        ed.AddText(unitext)
        ed.GotoPos(0)

    ed.EmptyUndoBuffer()

    # make some styles
    ed.StyleSetSpec(wxSTC_STYLE_DEFAULT, "size:%d,face:%s" % (pb, face3))
    ed.StyleSetSpec(1, "size:%d,bold,face:%s,fore:#0000FF" % (pb+2, face1))
    ed.StyleSetSpec(2, "face:%s,italic,fore:#FF0000,size:%d" % (face2, pb))
    ed.StyleSetSpec(3, "face:%s,bold,size:%d" % (face2, pb+2))
    ed.StyleSetSpec(4, "face:%s,size:%d" % (face1, pb-1))

    # Now set some text to those styles...  Normally this would be
    # done in an event handler that happens when text needs displayed.
    ed.StartStyling(98, 0xff)
    ed.SetStyling(6, 1)  # set style for 6 characters using style 1

    ed.StartStyling(190, 0xff)
    ed.SetStyling(20, 2)

    ed.StartStyling(310, 0xff)
    ed.SetStyling(4, 3)
    ed.SetStyling(2, 0)
    ed.SetStyling(10, 4)


    # line numbers in the margin
    ed.SetMarginType(0, wxSTC_MARGIN_NUMBER)
    ed.SetMarginWidth(0, 22)
    ed.StyleSetSpec(wxSTC_STYLE_LINENUMBER, "size:%d,face:%s" % (pb, face1))

    # setup some markers
    ed.SetMarginType(1, wxSTC_MARGIN_SYMBOL)
    ed.MarkerDefine(0, wxSTC_MARK_ROUNDRECT, "#CCFF00", "RED")
    #ed.MarkerDefine(1, wxSTC_MARK_CIRCLE, "FOREST GREEN", "SIENNA")
    ed.MarkerDefineBitmap(1, images.getFolder1Bitmap())
    ed.MarkerDefine(2, wxSTC_MARK_SHORTARROW, "blue", "blue")
    ed.MarkerDefine(3, wxSTC_MARK_ARROW, "#00FF00", "#00FF00")

    # put some markers on some lines
    ed.MarkerAdd(17, 0)
    ed.MarkerAdd(18, 1)
    ed.MarkerAdd(19, 2)
    ed.MarkerAdd(20, 3)
    ed.MarkerAdd(20, 0)


    # and finally, an indicator or two
    ed.IndicatorSetStyle(0, wxSTC_INDIC_SQUIGGLE)
    ed.IndicatorSetForeground(0, wxRED)
    ed.IndicatorSetStyle(1, wxSTC_INDIC_DIAGONAL)
    ed.IndicatorSetForeground(1, wxBLUE)
    ed.IndicatorSetStyle(2, wxSTC_INDIC_STRIKE)
    ed.IndicatorSetForeground(2, wxRED)

    ed.StartStyling(836, wxSTC_INDICS_MASK)
    ed.SetStyling(10, wxSTC_INDIC0_MASK)
    ed.SetStyling(10, wxSTC_INDIC1_MASK)
    ed.SetStyling(10, wxSTC_INDIC2_MASK | wxSTC_INDIC1_MASK)


    # some test stuff...
    if debug:
        print "GetTextLength(): ", ed.GetTextLength(), len(ed.GetText())
        print "GetText(): ", repr(ed.GetText())
        print
        print "GetStyledText(98, 104): ", repr(ed.GetStyledText(98, 104)), len(ed.GetStyledText(98, 104))
        print
        print "GetCurLine(): ", repr(ed.GetCurLine())
        ed.GotoPos(5)
        print "GetCurLine(): ", repr(ed.GetCurLine())
        print
        print "GetLine(1): ", repr(ed.GetLine(1))
        print
        ed.SetSelection(25, 35)
        print "GetSelectedText(): ", repr(ed.GetSelectedText())
        print "GetTextRange(25, 35): ", repr(ed.GetTextRange(25, 35))
        print "FindText(0, max, 'indicators'): ",
        print ed.FindText(0, ed.GetTextLength(), "indicators")

        ed.GotoPos(0)


    return p
</t>
<t tx="T157">@ignore
@language python
&lt;&lt; wxStyledTextCtrl_2 declarations &gt;&gt;
@others



#----------------------------------------------------------------------


overview = """\
&lt;html&gt;&lt;body&gt;
Once again, no docs yet.  &lt;b&gt;Sorry.&lt;/b&gt;  But &lt;a href="data/stc.h.html"&gt;this&lt;/a&gt;
and &lt;a href="http://www.scintilla.org/ScintillaDoc.html"&gt;this&lt;/a&gt; should
be helpful.
&lt;/body&gt;&lt;html&gt;
"""


if __name__ == '__main__':
    import sys,os
    import run
    run.main(['', os.path.basename(sys.argv[0])])





#----------------------------------------------------------------------
#----------------------------------------------------------------------

</t>
<t tx="T158">from wxPython.wx import *
from wxPython.stc import *
import images
import keyword

demoText = """\
## This version of the editor has been set up to edit Python source
## code.  Here is a copy of wxPython/demo/Main.py to play with.


"""

if wxPlatform == '__WXMSW__':
    faces = { 'times': 'Times New Roman',
              'mono' : 'Courier New',
              'helv' : 'Arial',
              'other': 'Comic Sans MS',
              'size' : 10,
              'size2': 8,
             }
else:
    faces = { 'times': 'Times',
              'mono' : 'Courier',
              'helv' : 'Helvetica',
              'other': 'new century schoolbook',
              'size' : 12,
              'size2': 10,
             }


#----------------------------------------------------------------------

</t>
<t tx="T159">class PythonSTC(wxStyledTextCtrl):
	@others
</t>
<t tx="T160">def __init__(self, parent, ID):
    wxStyledTextCtrl.__init__(self, parent, ID,
                              style = wxNO_FULL_REPAINT_ON_RESIZE)

    self.CmdKeyAssign(ord('B'), wxSTC_SCMOD_CTRL, wxSTC_CMD_ZOOMIN)
    self.CmdKeyAssign(ord('N'), wxSTC_SCMOD_CTRL, wxSTC_CMD_ZOOMOUT)

    self.SetLexer(wxSTC_LEX_PYTHON)
    self.SetKeyWords(0, " ".join(keyword.kwlist))

    self.SetProperty("fold", "1")
    self.SetProperty("tab.timmy.whinge.level", "1")
    self.SetMargins(0,0)

    self.SetViewWhiteSpace(False)
    #self.SetBufferedDraw(False)
    #self.SetViewEOL(True)

    self.SetEdgeMode(wxSTC_EDGE_BACKGROUND)
    self.SetEdgeColumn(78)

    # Setup a margin to hold fold markers
    #self.SetFoldFlags(16)  ###  WHAT IS THIS VALUE?  WHAT ARE THE OTHER FLAGS?  DOES IT MATTER?
    self.SetMarginType(2, wxSTC_MARGIN_SYMBOL)
    self.SetMarginMask(2, wxSTC_MASK_FOLDERS)
    self.SetMarginSensitive(2, True)
    self.SetMarginWidth(2, 12)

    if 0: # simple folder marks, like the old version
        self.MarkerDefine(wxSTC_MARKNUM_FOLDER, wxSTC_MARK_ARROW, "navy", "navy")
        self.MarkerDefine(wxSTC_MARKNUM_FOLDEROPEN, wxSTC_MARK_ARROWDOWN, "navy", "navy")
        # Set these to an invisible mark
        self.MarkerDefine(wxSTC_MARKNUM_FOLDEROPENMID, wxSTC_MARK_BACKGROUND, "white", "black")
        self.MarkerDefine(wxSTC_MARKNUM_FOLDERMIDTAIL, wxSTC_MARK_BACKGROUND, "white", "black")
        self.MarkerDefine(wxSTC_MARKNUM_FOLDERSUB, wxSTC_MARK_BACKGROUND, "white", "black")
        self.MarkerDefine(wxSTC_MARKNUM_FOLDERTAIL, wxSTC_MARK_BACKGROUND, "white", "black")

    else: # more involved "outlining" folder marks
        self.MarkerDefine(wxSTC_MARKNUM_FOLDEREND,     wxSTC_MARK_BOXPLUSCONNECTED,  "white", "black")
        self.MarkerDefine(wxSTC_MARKNUM_FOLDEROPENMID, wxSTC_MARK_BOXMINUSCONNECTED, "white", "black")
        self.MarkerDefine(wxSTC_MARKNUM_FOLDERMIDTAIL, wxSTC_MARK_TCORNER,  "white", "black")
        self.MarkerDefine(wxSTC_MARKNUM_FOLDERTAIL,    wxSTC_MARK_LCORNER,  "white", "black")
        self.MarkerDefine(wxSTC_MARKNUM_FOLDERSUB,     wxSTC_MARK_VLINE,    "white", "black")
        self.MarkerDefine(wxSTC_MARKNUM_FOLDER,        wxSTC_MARK_BOXPLUS,  "white", "black")
        self.MarkerDefine(wxSTC_MARKNUM_FOLDEROPEN,    wxSTC_MARK_BOXMINUS, "white", "black")


    EVT_STC_UPDATEUI(self,    ID, self.OnUpdateUI)
    EVT_STC_MARGINCLICK(self, ID, self.OnMarginClick)
    EVT_KEY_DOWN(self, self.OnKeyPressed)


    # Make some styles,  The lexer defines what each style is used for, we
    # just have to define what each style looks like.  This set is adapted from
    # Scintilla sample property files.

    self.StyleClearAll()

    # Global default styles for all languages
    self.StyleSetSpec(wxSTC_STYLE_DEFAULT,     "face:%(helv)s,size:%(size)d" % faces)
    self.StyleSetSpec(wxSTC_STYLE_LINENUMBER,  "back:#C0C0C0,face:%(helv)s,size:%(size2)d" % faces)
    self.StyleSetSpec(wxSTC_STYLE_CONTROLCHAR, "face:%(other)s" % faces)
    self.StyleSetSpec(wxSTC_STYLE_BRACELIGHT,  "fore:#FFFFFF,back:#0000FF,bold")
    self.StyleSetSpec(wxSTC_STYLE_BRACEBAD,    "fore:#000000,back:#FF0000,bold")

    # Python styles
    # White space
    self.StyleSetSpec(wxSTC_P_DEFAULT, "fore:#808080,face:%(helv)s,size:%(size)d" % faces)
    # Comment
    self.StyleSetSpec(wxSTC_P_COMMENTLINE, "fore:#007F00,face:%(other)s,size:%(size)d" % faces)
    # Number
    self.StyleSetSpec(wxSTC_P_NUMBER, "fore:#007F7F,size:%(size)d" % faces)
    # String
    self.StyleSetSpec(wxSTC_P_STRING, "fore:#7F007F,italic,face:%(times)s,size:%(size)d" % faces)
    # Single quoted string
    self.StyleSetSpec(wxSTC_P_CHARACTER, "fore:#7F007F,italic,face:%(times)s,size:%(size)d" % faces)
    # Keyword
    self.StyleSetSpec(wxSTC_P_WORD, "fore:#00007F,bold,size:%(size)d" % faces)
    # Triple quotes
    self.StyleSetSpec(wxSTC_P_TRIPLE, "fore:#7F0000,size:%(size)d" % faces)
    # Triple double quotes
    self.StyleSetSpec(wxSTC_P_TRIPLEDOUBLE, "fore:#7F0000,size:%(size)d" % faces)
    # Class name definition
    self.StyleSetSpec(wxSTC_P_CLASSNAME, "fore:#0000FF,bold,underline,size:%(size)d" % faces)
    # Function or method name definition
    self.StyleSetSpec(wxSTC_P_DEFNAME, "fore:#007F7F,bold,size:%(size)d" % faces)
    # Operators
    self.StyleSetSpec(wxSTC_P_OPERATOR, "bold,size:%(size)d" % faces)
    # Identifiers
    self.StyleSetSpec(wxSTC_P_IDENTIFIER, "fore:#808080,face:%(helv)s,size:%(size)d" % faces)
    # Comment-blocks
    self.StyleSetSpec(wxSTC_P_COMMENTBLOCK, "fore:#7F7F7F,size:%(size)d" % faces)
    # End of line where string is not closed
    self.StyleSetSpec(wxSTC_P_STRINGEOL, "fore:#000000,face:%(mono)s,back:#E0C0E0,eol,size:%(size)d" % faces)

    self.SetCaretForeground("BLUE")


    # register some images for use in the AutoComplete box.
    self.RegisterImage(1, images.getSmilesBitmap())
    self.RegisterImage(2, images.getFile1Bitmap())
    self.RegisterImage(3, images.getCopyBitmap())
</t>
<t tx="T161">def OnKeyPressed(self, event):
    if self.CallTipActive():
        self.CallTipCancel()
    key = event.KeyCode()
    if key == 32 and event.ControlDown():
        pos = self.GetCurrentPos()
        # Tips
        if event.ShiftDown():
            self.CallTipSetBackground("yellow")
            self.CallTipShow(pos, 'lots of of text: blah, blah, blah\n\n'
                             'show some suff, maybe parameters..\n\n'
                             'fubar(param1, param2)')
        # Code completion
        else:
            #lst = []
            #for x in range(50000):
            #    lst.append('%05d' % x)
            #st = " ".join(lst)
            #print len(st)
            #self.AutoCompShow(0, st)

            kw = keyword.kwlist[:]
            kw.append("zzzzzz?2")
            kw.append("aaaaa?2")
            kw.append("__init__?3")
            kw.append("zzaaaaa?2")
            kw.append("zzbaaaa?2")
            kw.append("this_is_a_longer_value")
            #kw.append("this_is_a_much_much_much_much_much_much_much_longer_value")

            kw.sort()  # Python sorts are case sensitive
            self.AutoCompSetIgnoreCase(False)  # so this needs to match

            # Images are specified with a appended "?type"
            for i in range(len(kw)):
                if kw[i] in keyword.kwlist:
                    kw[i] = kw[i] + "?1"

            self.AutoCompShow(0, " ".join(kw))
    else:
        event.Skip()
</t>
<t tx="T162">def OnUpdateUI(self, evt):
    # check for matching braces
    braceAtCaret = -1
    braceOpposite = -1
    charBefore = None
    caretPos = self.GetCurrentPos()
    if caretPos &gt; 0:
        charBefore = self.GetCharAt(caretPos - 1)
        styleBefore = self.GetStyleAt(caretPos - 1)

    # check before
    if charBefore and chr(charBefore) in "[]{}()" and styleBefore == wxSTC_P_OPERATOR:
        braceAtCaret = caretPos - 1

    # check after
    if braceAtCaret &lt; 0:
        charAfter = self.GetCharAt(caretPos)
        styleAfter = self.GetStyleAt(caretPos)
        if charAfter and chr(charAfter) in "[]{}()" and styleAfter == wxSTC_P_OPERATOR:
            braceAtCaret = caretPos

    if braceAtCaret &gt;= 0:
        braceOpposite = self.BraceMatch(braceAtCaret)

    if braceAtCaret != -1  and braceOpposite == -1:
        self.BraceBadLight(braceAtCaret)
    else:
        self.BraceHighlight(braceAtCaret, braceOpposite)
</t>
<t tx="T163">        #pt = self.PointFromPosition(braceOpposite)
        #self.Refresh(True, wxRect(pt.x, pt.y, 5,5))
        #print pt
        #self.Refresh(False)


def OnMarginClick(self, evt):
    # fold and unfold as needed
    if evt.GetMargin() == 2:
        if evt.GetShift() and evt.GetControl():
            self.FoldAll()
        else:
            lineClicked = self.LineFromPosition(evt.GetPosition())
            if self.GetFoldLevel(lineClicked) &amp; wxSTC_FOLDLEVELHEADERFLAG:
                if evt.GetShift():
                    self.SetFoldExpanded(lineClicked, True)
                    self.Expand(lineClicked, True, True, 1)
                elif evt.GetControl():
                    if self.GetFoldExpanded(lineClicked):
                        self.SetFoldExpanded(lineClicked, False)
                        self.Expand(lineClicked, False, True, 0)
                    else:
                        self.SetFoldExpanded(lineClicked, True)
                        self.Expand(lineClicked, True, True, 100)
                else:
                    self.ToggleFold(lineClicked)
</t>
<t tx="T164">def FoldAll(self):
    lineCount = self.GetLineCount()
    expanding = True

    # find out if we are folding or unfolding
    for lineNum in range(lineCount):
        if self.GetFoldLevel(lineNum) &amp; wxSTC_FOLDLEVELHEADERFLAG:
            expanding = not self.GetFoldExpanded(lineNum)
            break;

    lineNum = 0
    while lineNum &lt; lineCount:
        level = self.GetFoldLevel(lineNum)
        if level &amp; wxSTC_FOLDLEVELHEADERFLAG and \
           (level &amp; wxSTC_FOLDLEVELNUMBERMASK) == wxSTC_FOLDLEVELBASE:

            if expanding:
                self.SetFoldExpanded(lineNum, True)
                lineNum = self.Expand(lineNum, True)
                lineNum = lineNum - 1
            else:
                lastChild = self.GetLastChild(lineNum, -1)
                self.SetFoldExpanded(lineNum, False)
                if lastChild &gt; lineNum:
                    self.HideLines(lineNum+1, lastChild)

        lineNum = lineNum + 1
</t>
<t tx="T165">def Expand(self, line, doExpand, force=False, visLevels=0, level=-1):
    lastChild = self.GetLastChild(line, level)
    line = line + 1
    while line &lt;= lastChild:
        if force:
            if visLevels &gt; 0:
                self.ShowLines(line, line)
            else:
                self.HideLines(line, line)
        else:
            if doExpand:
                self.ShowLines(line, line)

        if level == -1:
            level = self.GetFoldLevel(line)

        if level &amp; wxSTC_FOLDLEVELHEADERFLAG:
            if force:
                if visLevels &gt; 1:
                    self.SetFoldExpanded(line, True)
                else:
                    self.SetFoldExpanded(line, False)
                line = self.Expand(line, doExpand, force, visLevels-1)

            else:
                if doExpand and self.GetFoldExpanded(line):
                    line = self.Expand(line, True, force, visLevels-1)
                else:
                    line = self.Expand(line, False, force, visLevels-1)
        else:
            line = line + 1;

    return line
</t>
<t tx="T166">#----------------------------------------------------------------------

_USE_PANEL = 1

def runTest(frame, nb, log):
    if not _USE_PANEL:
        ed = p = PythonSTC(nb, -1)
    else:
        p = wxPanel(nb, -1, style = wxNO_FULL_REPAINT_ON_RESIZE)
        ed = PythonSTC(p, -1)
        s = wxBoxSizer(wxHORIZONTAL)
        s.Add(ed, 1, wxEXPAND)
        p.SetSizer(s)
        p.SetAutoLayout(True)


    ed.SetText(demoText + open('Main.py').read())
    ed.EmptyUndoBuffer()
    ed.Colourise(0, -1)

    # line numbers in the margin
    ed.SetMarginType(1, wxSTC_MARGIN_NUMBER)
    ed.SetMarginWidth(1, 25)

    return p
</t>
<t tx="T167">@ignore
@language python
&lt;&lt; wxTextCtrl declarations &gt;&gt;
@others

#---------------------------------------------------------------------------




overview = """\
"""




if __name__ == '__main__':
    import sys,os
    import run
    run.main(['', os.path.basename(sys.argv[0])])

</t>
<t tx="T168">import sys
from wxPython.wx import *

#---------------------------------------------------------------------------

</t>
<t tx="T169">class TestPanel(wxPanel):
	@others
</t>
<t tx="T170">def OnSetFocus(self, evt):
    print "OnSetFocus"
    evt.Skip()
</t>
<t tx="T171">def OnKillFocus(self, evt):
    print "OnKillFocus"
    evt.Skip()
</t>
<t tx="T172">def OnWindowDestroy(self, evt):
    print "OnWindowDestroy"
    evt.Skip()
</t>
<t tx="T173">def __init__(self, parent, log):
    wxPanel.__init__(self, parent, -1)
    self.log = log

    l1 = wxStaticText(self, -1, "wxTextCtrl")
    t1 = wxTextCtrl(self, -1, "Test it out and see", size=(125, -1))
    t1.SetInsertionPoint(0)
    self.tc1 = t1
    EVT_TEXT(self, t1.GetId(), self.EvtText)
    EVT_CHAR(t1, self.EvtChar)
    EVT_SET_FOCUS(t1, self.OnSetFocus)
    EVT_KILL_FOCUS(t1, self.OnKillFocus)
    EVT_WINDOW_DESTROY(t1, self.OnWindowDestroy)

    l2 = wxStaticText(self, -1, "Passsword")
    t2 = wxTextCtrl(self, -1, "", size=(125, -1), style=wxTE_PASSWORD)
    EVT_TEXT(self, t2.GetId(), self.EvtText)

    l3 = wxStaticText(self, -1, "Multi-line")
    t3 = wxTextCtrl(self, -1,
                    "Here is a looooooooooooooong line of text set in the control.\n\n"
                    "The quick brown fox jumped over the lazy dog...",
                   size=(200, 100), style=wxTE_MULTILINE)
    t3.SetInsertionPoint(0)
    EVT_TEXT(self, t3.GetId(), self.EvtText)
    b = wxButton(self, -1, "Test Replace")
    EVT_BUTTON(self, b.GetId(), self.OnTestReplace)
    b2 = wxButton(self, -1, "Test GetSelection")
    EVT_BUTTON(self, b2.GetId(), self.OnTestGetSelection)
    b3 = wxButton(self, -1, "Test WriteText")
    EVT_BUTTON(self, b3.GetId(), self.OnTestWriteText)
    self.tc = t3
    b4 = wxButton(self, -1, "Test Simulated Event")
    EVT_BUTTON(self, b4.GetId(), self.OnTestEvent)


    l4 = wxStaticText(self, -1, "Rich Text")
    t4 = wxTextCtrl(self, -1, "If supported by the native control, this is red, and this is a different font.",
                    size=(200, 100), style=wxTE_MULTILINE|wxTE_RICH2)
    t4.SetInsertionPoint(0)
    t4.SetStyle(44, 47, wxTextAttr("RED", "YELLOW"))
    points = t4.GetFont().GetPointSize()  # get the current size
    f = wxFont(points+3, wxROMAN, wxITALIC, wxBOLD, True)
    t4.SetStyle(63, 77, wxTextAttr("BLUE", wxNullColour, f))

    l5 = wxStaticText(self, -1, "Test Positions")
    t5 = wxTextCtrl(self, -1, "0123456789\n" * 5, size=(200, 100),
                    style = wxTE_MULTILINE
                    #| wxTE_RICH
                    | wxTE_RICH2
                    )
    EVT_LEFT_DOWN(t5, self.OnT5LeftDown)
    self.t5 = t5


    bsizer = wxBoxSizer(wxVERTICAL)
    bsizer.Add(b, 0, wxGROW|wxALL, 4)
    bsizer.Add(b2, 0, wxGROW|wxALL, 4)
    bsizer.Add(b3, 0, wxGROW|wxALL, 4)
    bsizer.Add(b4, 0, wxGROW|wxALL, 4)

    sizer = wxFlexGridSizer(cols=3, hgap=6, vgap=6)
    sizer.AddMany([ l1, t1, (0,0),
                    l2, t2, (0,0),
                    l3, t3, bsizer,
                    l4, t4, (0,0),
                    l5, t5, (0,0),
                    ])
    border = wxBoxSizer(wxVERTICAL)
    border.Add(sizer, 0, wxALL, 25)
    self.SetSizer(border)
    self.SetAutoLayout(True)
</t>
<t tx="T174">def EvtText(self, event):
    self.log.WriteText('EvtText: %s\n' % event.GetString())
</t>
<t tx="T175">def EvtChar(self, event):
    self.log.WriteText('EvtChar: %d\n' % event.GetKeyCode())
    event.Skip()
</t>
<t tx="T176">def OnTestReplace(self, evt):
    self.tc.Replace(5, 9, "IS A")
</t>
<t tx="T177">    #self.tc.Remove(5, 9)

def OnTestWriteText(self, evt):
    self.tc.WriteText("TEXT")
</t>
<t tx="T178">def OnTestGetSelection(self, evt):
    start, end = self.tc.GetSelection()
    text = self.tc.GetValue()
    if wxPlatform == "__WXMSW__":  # This is why GetStringSelection was added
        text = text.replace('\n', '\r\n')
    self.log.write("GetSelection(): (%d, %d)\n"
                   "\tGetStringSelection(): %s\n"
                   "\tSelectedText: %s\n" %
                   (start, end,
                    self.tc.GetStringSelection(),
                    repr(text[start:end])))
</t>
<t tx="T179">def OnT5LeftDown(self, evt):
    evt.Skip()
    wxCallAfter(self.LogT5Position, evt)
</t>
<t tx="T180">def LogT5Position(self, evt):
    text = self.t5.GetValue()
    ip = self.t5.GetInsertionPoint()
    lp = self.t5.GetLastPosition()
    self.log.write("LogT5Position:\n"
                   "\tGetInsertionPoint:\t%d\n"
                   "\ttext[insertionpoint]:\t%s\n"
                   "\tGetLastPosition:\t%d\n"
                   "\tlen(text):\t\t%d\n"
                   % (ip, text[ip], lp, len(text)))
</t>
<t tx="T181">def OnTestEvent(self, evt):
    ke = wxKeyEvent(wxEVT_CHAR)
    ke.SetEventObject(self.tc1)
    ke.SetId(self.tc1.GetId())
    ke.m_keyCode = ord('A')
    self.tc1.GetEventHandler().ProcessEvent(ke)
</t>
<t tx="T182">#---------------------------------------------------------------------------

def runTest(frame, nb, log):
    win = TestPanel(nb, log)
    return win
</t>
<t tx="T183"></t>
<t tx="T184">@ignore
@language python

import sys, os
from   wxPython.wx         import *
from   wxPython.html       import *
import wxPython.lib.wxpTag
from Main import opj

@others

overview = """&lt;html&gt;&lt;body&gt;
&lt;h2&gt;wxHtmlWindow&lt;/h2&gt;

&lt;p&gt;wxHtmlWindow is capable of parsing and rendering most
simple HTML tags.

&lt;p&gt;It is not intended to be a high-end HTML browser.  If you're
looking for something like that try http://www.mozilla.org - there's a
chance you'll be able to make their widget wxWindows-compatible. I'm
sure everyone will enjoy your work in that case...

&lt;/body&gt;&lt;/html&gt;
"""

if __name__ == '__main__':
    import sys,os,run
    run.main(['', os.path.basename(sys.argv[0])])
</t>
<t tx="T185"># This shows how to catch the OnLinkClicked non-event.  (It's a virtual
# method in the C++ code...)

class MyHtmlWindow(wxHtmlWindow):
	@others
</t>
<t tx="T186">def __init__(self, parent, id, log):
    wxHtmlWindow.__init__(self, parent, id, style=wxNO_FULL_REPAINT_ON_RESIZE)
    self.log = log
    EVT_SCROLLWIN( self, self.OnScroll )
</t>
<t tx="T187">def OnScroll( self, event ):
    #print 'event.GetOrientation()',event.GetOrientation()
    #print 'event.GetPosition()',event.GetPosition()
    event.Skip()
</t>
<t tx="T188">def OnLinkClicked(self, linkinfo):
    self.log.WriteText('OnLinkClicked: %s\n' % linkinfo.GetHref())

    # Virtuals in the base class have been renamed with base_ on the front.
    self.base_OnLinkClicked(linkinfo)
</t>
<t tx="T189">def OnSetTitle(self, title):
    self.log.WriteText('OnSetTitle: %s\n' % title)
    self.base_OnSetTitle(title)
</t>
<t tx="T190">def OnCellMouseHover(self, cell, x, y):
    self.log.WriteText('OnCellMouseHover: %s, (%d %d)\n' % (cell, x, y))
    self.base_OnCellMouseHover(cell, x, y)
</t>
<t tx="T191">def OnCellClicked(self, cell, x, y, evt):
    self.log.WriteText('OnCellClicked: %s, (%d %d)\n' % (cell, x, y))
    self.base_OnCellClicked(cell, x, y, evt)
</t>
<t tx="T192"># This filter doesn't really do anything but show how to use filters
class MyHtmlFilter(wxHtmlFilter):
	@others
</t>
<t tx="T193">def __init__(self, log):
    wxHtmlFilter.__init__(self)
    self.log = log
</t>
<t tx="T194"># This method decides if this filter is able to read the file
def CanRead(self, fsfile):
    self.log.write("CanRead: %s\n" % fsfile.GetMimeType())
    return False
</t>
<t tx="T195"># If CanRead returns True then this method is called to actually
# read the file and return the contents.
def ReadFile(self, fsfile):
    return ""
</t>
<t tx="T196">class TestHtmlPanel(wxPanel):
	@others
</t>
<t tx="T197">def __init__(self, parent, frame, log):
    wxPanel.__init__(self, parent, -1, style=wxNO_FULL_REPAINT_ON_RESIZE)
    self.log = log
    self.frame = frame
    self.cwd = os.path.split(sys.argv[0])[0]
    if not self.cwd:
        self.cwd = os.getcwd()
    if frame:
        self.titleBase = frame.GetTitle()

    wxHtmlWindow_AddFilter(MyHtmlFilter(log))

    self.html = MyHtmlWindow(self, -1, log)
    self.html.SetRelatedFrame(frame, self.titleBase + " -- %s")
    self.html.SetRelatedStatusBar(0)

    self.printer = wxHtmlEasyPrinting()

    self.box = wxBoxSizer(wxVERTICAL)
    self.box.Add(self.html, 1, wxGROW)

    subbox = wxBoxSizer(wxHORIZONTAL)

    btn = wxButton(self, -1, "Load File")
    EVT_BUTTON(self, btn.GetId(), self.OnLoadFile)
    subbox.Add(btn, 1, wxGROW | wxALL, 2)

    btn = wxButton(self, -1, "Load URL")
    EVT_BUTTON(self, btn.GetId(), self.OnLoadURL)
    subbox.Add(btn, 1, wxGROW | wxALL, 2)

    btn = wxButton(self, -1, "With Widgets")
    EVT_BUTTON(self, btn.GetId(), self.OnWithWidgets)
    subbox.Add(btn, 1, wxGROW | wxALL, 2)

    btn = wxButton(self, -1, "Back")
    EVT_BUTTON(self, btn.GetId(), self.OnBack)
    subbox.Add(btn, 1, wxGROW | wxALL, 2)

    btn = wxButton(self, -1, "Forward")
    EVT_BUTTON(self, btn.GetId(), self.OnForward)
    subbox.Add(btn, 1, wxGROW | wxALL, 2)

    btn = wxButton(self, -1, "Print")
    EVT_BUTTON(self, btn.GetId(), self.OnPrint)
    subbox.Add(btn, 1, wxGROW | wxALL, 2)

    btn = wxButton(self, -1, "View Source")
    EVT_BUTTON(self, btn.GetId(), self.OnViewSource)
    subbox.Add(btn, 1, wxGROW | wxALL, 2)

    self.box.Add(subbox, 0, wxGROW)
    self.SetSizer(self.box)
    self.SetAutoLayout(True)

    # A button with this ID is created on the widget test page.
    EVT_BUTTON(self, wxID_OK, self.OnOk)

    self.OnShowDefault(None)
</t>
<t tx="T198">def ShutdownDemo(self):
    # put the frame title back
    if self.frame:
        self.frame.SetTitle(self.titleBase)
</t>
<t tx="T199">def OnShowDefault(self, event):
    name = os.path.join(self.cwd, opj('data/test.htm'))
    self.html.LoadPage(name)
</t>
<t tx="T200">def OnLoadFile(self, event):
    dlg = wxFileDialog(self, wildcard = '*.htm*', style=wxOPEN)
    if dlg.ShowModal():
        path = dlg.GetPath()
        self.html.LoadPage(path)
    dlg.Destroy()
</t>
<t tx="T201">def OnLoadURL(self, event):
    dlg = wxTextEntryDialog(self, "Enter a URL")
    if dlg.ShowModal():
        url = dlg.GetValue()
        self.html.LoadPage(url)
    dlg.Destroy()
</t>
<t tx="T202">def OnWithWidgets(self, event):
    os.chdir(self.cwd)
    name = os.path.join(self.cwd, opj('data/widgetTest.htm'))
    self.html.LoadPage(name)
</t>
<t tx="T203">def OnOk(self, event):
    self.log.WriteText("It works!\n")
</t>
<t tx="T204">def OnBack(self, event):
    if not self.html.HistoryBack():
        wxMessageBox("No more items in history!")
</t>
<t tx="T205">def OnForward(self, event):
    if not self.html.HistoryForward():
        wxMessageBox("No more items in history!")
</t>
<t tx="T206">def OnViewSource(self, event):
    from wxPython.lib.dialogs import wxScrolledMessageDialog
    source = self.html.GetParser().GetSource()
    dlg = wxScrolledMessageDialog(self, source, 'HTML Source')
    dlg.ShowModal()
    dlg.Destroy()
</t>
<t tx="T207">def OnPrint(self, event):
    ##self.printer.GetPageSetupData().SetMarginTopLeft((100,100))
    self.printer.PrintFile(self.html.GetOpenedPage())
</t>
<t tx="T208">def runTest(frame, nb, log):
    win = TestHtmlPanel(nb, frame, log)
    print wxWindow_FindFocus()
    return win
</t>
<t tx="T209">@ignore
@language python

from wxPython.wx import *
if wxPlatform == '__WXMSW__':
    from wxPython.iewin import *

@others



overview = """\
&lt;html&gt;&lt;body&gt;
&lt;h2&gt;wxIEHtmlWin&lt;/h2&gt;

The wxIEHtmlWin class is the first example of using a contributed
wxActiveX class in wxWindows C++.  It is still experimental, but
I think it is useful.

&lt;p&gt; Using this class is simpler than ActiveXWrapper, doesn't rely on
the win32all extensions, and is more "wx\'ish", meaning that it uses
events and etc. as would be expected from any other wx window.

&lt;/body&gt;&lt;/html&gt;
"""



if __name__ == '__main__':
    import sys,os
    import run
    run.main(['', os.path.basename(sys.argv[0])])


#----------------------------------------------------------------------

</t>
<t tx="T210">class TestPanel(wxWindow):
	@others
</t>
<t tx="T211">def __init__(self, parent, log, frame=None):
    wxWindow.__init__(self, parent, -1,
                      style=wxTAB_TRAVERSAL|wxCLIP_CHILDREN|wxNO_FULL_REPAINT_ON_RESIZE)
    self.log = log
    self.current = "http://wxWindows.org/"
    self.frame = frame
    if frame:
        self.titleBase = frame.GetTitle()


    sizer = wxBoxSizer(wxVERTICAL)
    btnSizer = wxBoxSizer(wxHORIZONTAL)

    self.ie = wxIEHtmlWin(self, -1, style = wxNO_FULL_REPAINT_ON_RESIZE)


    btn = wxButton(self, wxNewId(), "Open", style=wxBU_EXACTFIT)
    EVT_BUTTON(self, btn.GetId(), self.OnOpenButton)
    btnSizer.Add(btn, 0, wxEXPAND|wxALL, 2)

    btn = wxButton(self, wxNewId(), "Home", style=wxBU_EXACTFIT)
    EVT_BUTTON(self, btn.GetId(), self.OnHomeButton)
    btnSizer.Add(btn, 0, wxEXPAND|wxALL, 2)

    btn = wxButton(self, wxNewId(), "&lt;--", style=wxBU_EXACTFIT)
    EVT_BUTTON(self, btn.GetId(), self.OnPrevPageButton)
    btnSizer.Add(btn, 0, wxEXPAND|wxALL, 2)

    btn = wxButton(self, wxNewId(), "--&gt;", style=wxBU_EXACTFIT)
    EVT_BUTTON(self, btn.GetId(), self.OnNextPageButton)
    btnSizer.Add(btn, 0, wxEXPAND|wxALL, 2)

    btn = wxButton(self, wxNewId(), "Stop", style=wxBU_EXACTFIT)
    EVT_BUTTON(self, btn.GetId(), self.OnStopButton)
    btnSizer.Add(btn, 0, wxEXPAND|wxALL, 2)

    btn = wxButton(self, wxNewId(), "Search", style=wxBU_EXACTFIT)
    EVT_BUTTON(self, btn.GetId(), self.OnSearchPageButton)
    btnSizer.Add(btn, 0, wxEXPAND|wxALL, 2)

    btn = wxButton(self, wxNewId(), "Refresh", style=wxBU_EXACTFIT)
    EVT_BUTTON(self, btn.GetId(), self.OnRefreshPageButton)
    btnSizer.Add(btn, 0, wxEXPAND|wxALL, 2)

    txt = wxStaticText(self, -1, "Location:")
    btnSizer.Add(txt, 0, wxCENTER|wxALL, 2)

    self.location = wxComboBox(self, wxNewId(), "", style=wxCB_DROPDOWN|wxPROCESS_ENTER)
    EVT_COMBOBOX(self, self.location.GetId(), self.OnLocationSelect)
    EVT_KEY_UP(self.location, self.OnLocationKey)
    EVT_CHAR(self.location, self.IgnoreReturn)
    btnSizer.Add(self.location, 1, wxEXPAND|wxALL, 2)


    sizer.Add(btnSizer, 0, wxEXPAND)
    sizer.Add(self.ie, 1, wxEXPAND)

    self.ie.Navigate(self.current)
    self.location.Append(self.current)

    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    EVT_SIZE(self, self.OnSize)

    # Hook up the event handlers for the IE window
    EVT_MSHTML_BEFORENAVIGATE2(self, -1, self.OnBeforeNavigate2)
    EVT_MSHTML_NEWWINDOW2(self, -1, self.OnNewWindow2)
    EVT_MSHTML_DOCUMENTCOMPLETE(self, -1, self.OnDocumentComplete)
    #EVT_MSHTML_PROGRESSCHANGE(self, -1, self.OnProgressChange)
    EVT_MSHTML_STATUSTEXTCHANGE(self, -1, self.OnStatusTextChange)
    EVT_MSHTML_TITLECHANGE(self, -1, self.OnTitleChange)
</t>
<t tx="T212">def ShutdownDemo(self):
    # put the frame title back
    if self.frame:
        self.frame.SetTitle(self.titleBase)
</t>
<t tx="T213">def OnSize(self, evt):
    self.Layout()
</t>
<t tx="T214">def OnLocationSelect(self, evt):
    url = self.location.GetStringSelection()
    self.log.write('OnLocationSelect: %s\n' % url)
    self.ie.Navigate(url)
</t>
<t tx="T215">def OnLocationKey(self, evt):
    if evt.KeyCode() == WXK_RETURN:
        URL = self.location.GetValue()
        self.location.Append(URL)
        self.ie.Navigate(URL)
    else:
        evt.Skip()
</t>
<t tx="T216">def IgnoreReturn(self, evt):
    if evt.GetKeyCode() != WXK_RETURN:
        evt.Skip()
</t>
<t tx="T217">def OnOpenButton(self, event):
    dlg = wxTextEntryDialog(self, "Open Location",
                            "Enter a full URL or local path",
                            self.current, wxOK|wxCANCEL)
    dlg.CentreOnParent()
    if dlg.ShowModal() == wxID_OK:
        self.current = dlg.GetValue()
        self.ie.Navigate(self.current)
    dlg.Destroy()
</t>
<t tx="T218">def OnHomeButton(self, event):
    self.ie.GoHome()    ## ET Phone Home!
</t>
<t tx="T219">def OnPrevPageButton(self, event):
    self.ie.GoBack()
</t>
<t tx="T220">def OnNextPageButton(self, event):
    self.ie.GoForward()
</t>
<t tx="T221">def OnStopButton(self, evt):
    self.ie.Stop()
</t>
<t tx="T222">def OnSearchPageButton(self, evt):
    self.ie.GoSearch()
</t>
<t tx="T223">def OnRefreshPageButton(self, evt):
    self.ie.Refresh(wxIEHTML_REFRESH_COMPLETELY)
</t>
<t tx="T224">def logEvt(self, name, event):
    self.log.write('%s: %s\n' %
                   (name, (event.GetLong1(), event.GetLong2(), event.GetText1())))
</t>
<t tx="T225">def OnBeforeNavigate2(self, evt):
    self.logEvt('OnBeforeNavigate2', evt)
</t>
<t tx="T226">def OnNewWindow2(self, evt):
    self.logEvt('OnNewWindow2', evt)
    evt.Veto() # don't allow it
</t>
<t tx="T227">def OnDocumentComplete(self, evt):
    self.logEvt('OnDocumentComplete', evt)
    self.current = evt.GetText1()
    self.location.SetValue(self.current)
</t>
<t tx="T228">def OnTitleChange(self, evt):
    self.logEvt('OnTitleChange', evt)
    if self.frame:
        self.frame.SetTitle(self.titleBase + ' -- ' + evt.GetText1())
</t>
<t tx="T229">def OnStatusTextChange(self, evt):
    self.logEvt('OnStatusTextChange', evt)
    if self.frame:
        self.frame.SetStatusText(evt.GetText1())
</t>
<t tx="T230"># for the demo framework...

def runTest(frame, nb, log):
    if wxPlatform == '__WXMSW__':
        win = TestPanel(nb, log, frame)
        return win
    else:
        dlg = wxMessageDialog(frame, 'This demo only works on MSW.',
                          'Sorry', wxOK | wxICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()</t>
<t tx="T231"></t>
<t tx="T232">@nocolor

10/13/03
	- Added icons (Windows only).

10/12/03:
	- Houston, we have ignition.  Almost all events connected properly.
	- Code draws the screen (after the file has been read in!)
	- Removed idle-time pollution: created onUpdateAllMenus.

10/11/03: converted code using c2py, then hand converted code.</t>
<t tx="T233">@nocolor

- Replace most updater routines with corresponding commander routines.
- Not all startup messages make it to the log pane...

After 4.0 final:

** Debug all commands.
- Move most frame routines into commander class.
	- Make the code view-independent by calling app.gui routines as needed.
- Complete bodyChanged/headlineChanged handlers.
- Remove references to c.top and Tk routines from Leo's core (except leoFrame.py)
- Rewrite bodyChanged handler using Tk handler as a guide.</t>
<t tx="T234">1. Most commands should be commander routines, not frame routines.  The window commands are exceptions: they are almost completely gui-related.

Example: The only part of the Save commands that are gui/view related are the dialogs, and the dialog code can easily be separated out.

</t>
<t tx="T235"></t>
<t tx="T236"># Used 10/11/03 to convert old wxLeo code 

if 0: # This script calls c2py on the current node and all nodes of its subtree.
	import c2py
	c2py.convertCurrentTree()</t>
<t tx="T237">def __init__ (self):
	wxFrame.__init__(None,-1,"Leo",wxDefaultPosition,wxSize(550,600)),
	mFileName(""),
	mDefaultDirectory(""),
	mOpenDirectory("")
	# Link the new frame into the list of frames.
	mIniting = true  # Lock out resize events.
	long width = 600  # initial size
	if  gLeoFrameList:  gLeoFrameList.mPrevFrame = self
	self.mNextFrame = gLeoFrameList
	self.mPrevFrame = None
	gLeoFrameList = self
	&lt;&lt; Initialize the private vars &gt;&gt;
	&lt;&lt; Initialize the argument settings &gt;&gt;
	self.createMenus()
	&lt;&lt; Create the splitter windows &gt;&gt;
	&lt;&lt; Create the accelerator table &gt;&gt;
	&lt;&lt; Create the status bar &gt;&gt;
	&lt;&lt; Set the window Icon &gt;&gt;
	&lt;&lt; Set the caret blink rate &gt;&gt;
	mCommands = Commands(self,mTreeCtrl,mBodyCtrl)
	&lt;&lt; Add root node to the tree view &gt;&gt;
	gActiveFrame = self
	mIniting = false # allow resize events.
	es("Leo Log Window...\n\n")
</t>
<t tx="T238">self.textChanging = 0

mCopying = 0
mDraggedItem = 0L
mReverting = false</t>
<t tx="T239">mOutputDocFlag = true
mTangleBatchFlag = false
mUntangleBatchFlag = false
mUseHeaderFlag = true
mPageWidth = 132
mTabWidth = 4
mPresentLanguage = c_language
mTargetLanguage = c_language</t>
<t tx="T240">mSplitter1 = wxSplitterWindow(self,cSplitterWindow,
	wxDefaultPosition,wxDefaultSize,
	wxSP_BORDER | wxSP_3D,
	"splitterWindow")
	
mSplitter2 = wxSplitterWindow(mSplitter1,-1,
	wxDefaultPosition,wxDefaultSize,
	wxSP_BORDER | wxSP_3D,"splitterWindow")

mSplitter1.SetMinimumPaneSize(4)
mSplitter2.SetMinimumPaneSize(4)
mTreeCtrl = wxTreeCtrl(mSplitter2,cTreeCtrl,
	wxDefaultPosition,wxDefaultSize,
	wxTR_HAS_BUTTONS | wxTR_EDIT_LABELS,wxDefaultValidator,"treeCtrl")

&lt;&lt; Set the image list &gt;&gt;
mBodyCtrl = wxTextCtrl(mSplitter1,cBodyCtrl,"",
	wxDefaultPosition,wxDefaultSize,wxTE_MULTILINE)
mLogCtrl = wxTextCtrl(mSplitter2,cLogCtrl,"",
	wxDefaultPosition,wxDefaultSize,wxTE_MULTILINE)
# &lt;&lt; Set the body font &gt;&gt;
if wx.wxPlatform == "__WXMSW__":  # This is a fixed-width font and works well.
	# size,family,style,weight.
	wxFont font(9,wxMODERN,wxNORMAL,wxNORMAL)
else:
	# size,family,style,weight.
	# wxFont font(9,wxMODERN,wxNORMAL,wxNORMAL);
	# Try to use lucidatypewriter.
	wxFont font(12,wxFONTFAMILY_DEFAULT,wxFONTSTYLE_NORMAL,wxFONTWEIGHT_NORMAL,false,
		"lucidatypewriter",wxFONTENCODING_ISO8859_1)
	if 0 # none of these work
		wxFont font(14,74,90,90,false,
		"terminal",
		# "-bitstream-terminal-medium-r-normal-*-*-140-*-*-c-*-iso8859-1",
		# "-Bitstream-Terminal-Medium-R-Normal--18-140-100-100-C-*-ISO8859-1",
		wxFONTENCODING_ISO8859_1)
TRACEP("font_info",
	es("face: "); es(font.GetFaceName().c_str()); ecs()
	es("family: "); es(font.GetFamilyString().c_str()); enl()
	es("size: "); eint(font.GetPointSize()); ecs()
	es("style: "); es(font. GetStyleString().c_str()); ecs()
	es("weight: "); es(font.GetWeightString().c_str()); enl()
)
mBodyCtrl.SetFont(font)
# -- end -- &lt;&lt; Set the body font &gt;&gt;
# Attach the controls to the splitter.
mSplitter1.SplitHorizontally(mSplitter2,mBodyCtrl,0)
mSplitter2.SplitVertically(mTreeCtrl,mLogCtrl,width/2)</t>
<t tx="T241"># Warning: the width and height must match the underlying .bmp files.

# width: 20,height: 11,mask:TRUE,count:16

if defined(__WXMSW__)or defined(__WXGTK__)
	im = wxImageList(20,11,true,16)
	wxBitmap box(20,11)
	# Add 16 bitmaps to the image list.
	for  int i = 0 ; i &lt; 16 ; ++ i:
		if defined(__WXMSW__)
			wxString s("box")
			s &lt;&lt; i
			box.LoadFile(s,wxBITMAP_TYPE_BMP_RESOURCE)
		#elif defined(__WXGTK__)
			wxString s("./Icons/box") # Assume we are launched from ./ directory.
			if  gAppDirectory.Length()&gt; 0:
				s = gAppDirectory + "/Icons/box"
			if i &lt; 10: s &lt;&lt; "0"
			s &lt;&lt; i
			s &lt;&lt; ".bmp"
			box.LoadFile(s,wxBITMAP_TYPE_BMP)
		im.Add(box)
	mTreeCtrl.SetImageList(im)</t>
<t tx="T242">if wx.wxPlatform == "__WXGTK__": # Windows version handles shortcuts properly
	enum
		# &lt;&lt; accelerator constants &gt;&gt;
		alt = wxACCEL_ALT,
		normal = wxACCEL_NORMAL,
		ctrl = wxACCEL_CTRL,
		shift = wxACCEL_SHIFT,
		shift_alt =(wxACCEL_ALT | wxACCEL_SHIFT),
		shift_ctrl =(wxACCEL_CTRL | wxACCEL_SHIFT),
		# -- end -- &lt;&lt; accelerator constants &gt;&gt;
		cFirstEntry: = -1,# So first real index starts at 0.
		# &lt;&lt; accelerator indices &gt;&gt;(1 of 12)
		cQuit,
		# &lt;&lt; accelerator indices &gt;&gt;(2 of 12)
		cNew,
		# cOpen,cClose,cSave,cSaveAs,
		# &lt;&lt; accelerator indices &gt;&gt;(3 of 12)
		cTangleAll,cTangleMarked,cTangle,
		# &lt;&lt; accelerator indices &gt;&gt;(4 of 12)
		cUntangle,
		# &lt;&lt; accelerator indices &gt;&gt;(5 of 12)
		cImportFiles,
		# &lt;&lt; accelerator indices &gt;&gt;(6 of 12)
		cEditHeadline,
		# &lt;&lt; accelerator indices &gt;&gt;(7 of 12)
		cExtractSection,cExtractNames,cExtract,cConvertBlanks,
		# &lt;&lt; accelerator indices &gt;&gt;(8 of 12)
		cFindPanel,cFindNext,cFindPrev,cReplace,cReplaceThenFind,
		# &lt;&lt; accelerator indices &gt;&gt;(9 of 12)
		# cFontPanel,cSyntaxColoring,cPreferences,
		# &lt;&lt; accelerator indices &gt;&gt;(10 of 12)
		# cInsertNode,cCloneNode,
		# &lt;&lt; accelerator indices &gt;&gt;(11 of 12)
		if wx.wxPlatform == "__WXMSW__":
			cGoPrevVisibleMenuItem,cGoNextVisibleMenuItem,
		# &lt;&lt; accelerator indices &gt;&gt;(12 of 12)
		# Conflicts with Extract command.
		# cEqualSizedPanes,
		cToggleActivePane,
		# -- end -- &lt;&lt; accelerator indices &gt;&gt;
		cAcceleratorEntries # one more than the largest index.
assert(cQuit==0)
wxAcceleratorEntry: entries [cAcceleratorEntries]
# &lt;&lt; accelerator entries &gt;&gt;(1 of 12)
entries[cQuit].	Set(ctrl,(int)'Q',cQuitMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(2 of 12)
entries[cNew].   Set(ctrl,(int)'N',cNewMenuItem)
if 0 # Not needed,and might conflict with Outline menu
entries[cOpen].  Set(ctrl,(int)'O',cOpenMenuItem)
entries[cClose]. Set(ctrl,(int)'W',cCloseMenuItem)
entries[cSave]. Set(ctrl,(int)'S',cSaveMenuItem)
if 0 # Conflicts with Outline menu.
entries[cSaveAs].Set(shift-ctrl,(int)'S',cSaveAsMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(3 of 12)
entries[cTangleAll].	Set(shift_ctrl,(int)'A',cTangleAllMenuItem)
entries[cTangleMarked]. Set(shift_ctrl,(int)'M',cTangleMarkedMenuItem)
entries[cTangle]. Set(shift_ctrl,(int)'T',cTangleMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(4 of 12)
entries[cUntangle].Set(shift_ctrl,(int)'U',cUntangleMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(5 of 12)
entries[cImportFiles].Set(shift_ctrl,(int)'F',cImportFilesMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(6 of 12)
entries[cEditHeadline].	Set(shift-ctrl,(int)'H',cEditHeadlineMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(7 of 12)
entries[cExtractSection].	Set(shift-ctrl,(int)'E',cExtractSectionMenuItem)
entries[cExtractNames]. Set(shift-ctrl,(int)'N',cExtractNamesMenuItem)
entries[cExtract]. Set(shift-ctrl,(int)'D',cExtractMenuItem)
entries[cConvertBlanks]. Set(shift-ctrl,(int)'B',cConvertBlanksMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(8 of 12)
entries[cFindPanel].Set(ctrl, (int)'F',cFindPanelMenuItem)
if 1 # shift F-keys don't seem to work on Linux
	entries[cFindNext].	Set(normal,(int)WXK_F3,cFindNextMenuItem)
	entries[cFindPrev]. Set(shift,(int)WXK_F4,cFindPreviousMenuItem)
	entries[cReplace]. Set(normal,(int)WXK_F5,cReplaceMenuItem)
  entries[cReplaceThenFind].Set(normal,(int)WXK_F6,cReplaceThenFindMenuItem)
else:
	entries[cFindNext]. Set(normal,(int)WXK_F3,cFindNextMenuItem)
	entries[cFindPrev]. Set(shift,(int)WXK_F3,cFindPreviousMenuItem)
	entries[cReplace]. Set(normal,(int)WXK_F4,cReplaceMenuItem)
  entries[cReplaceThenFind].Set(shift,(int)WXK_F4,cReplaceThenFindMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(9 of 12)
if 0 # works now,and would conflict with other settings.
	entries[cFontPanel].     Set(shift-alt,(int)'T',cFontPanelMenuItem)
	entries[cSyntaxColoring].Set(shift-alt,(int)'S',cSyntaxColoringMenuItem)
	entries[cPreferences]. Set(ctrl,(int)'Y',cPreferencesMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(10 of 12)
if 0 # Conflicts with Outline pane.
entries[cInsertNode].Set(ctrl,     (int)'I',cInsertNodeMenuItem)
entries[cCloneNode] .Set(shift_ctrl,(int)'I',cCloneNodeMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(11 of 12)
if wx.wxPlatform == "__WXMSW__":
	# Without these wxTreeCtrl handles the up/down keys itself,wrongly.
	entries[cGoPrevVisibleMenuItem].Set(normal,WXK_UP,  cGoPrevVisibleMenuItem)
	entries[cGoNextVisibleMenuItem].Set(normal,WXK_DOWN,cGoNextVisibleMenuItem)
# &lt;&lt; accelerator entries &gt;&gt;(12 of 12)
# Show log works without accel
# Conflicts with Extract command.
# entries[cEqualSizedPanes].Set(ctrl,(int)'E',cEqualSizedPanesMenuItem);
entries[cToggleActivePane].Set(ctrl,(int)'T',cToggleActivePaneMenuItem)
# -- end -- &lt;&lt; accelerator entries &gt;&gt;
wxAcceleratorTable accel(cAcceleratorEntries,entries)
self.SetAcceleratorTable(accel)
mBodyCtrl.SetAcceleratorTable(accel)
mTreeCtrl.SetAcceleratorTable(accel)
mSplitter1.SetAcceleratorTable(accel)
</t>
<t tx="T243">CreateStatusBar(2)
SetStatusText("")</t>
<t tx="T244">if wx.wxPlatform == "__WXMSW__":
  self .SetIcon(wxIcon("LeoIcon"))
</t>
<t tx="T245"># Blinking happens on Windows without a problem.  Furthermore,setting the rate here affects _all_ windows.

if wx.wxPlatform == "__WXGTK__": # Doesn't seem to work.
	caret = mBodyCtrl.GetCaret()
	caret.SetBlinkTime(500)
</t>
<t tx="T246">root = mTreeCtrl.AddRoot("untitled")
t = tnode()
v = vnode(mCommands,t)
v.setTreeID(root)
mCommands.mCurrentVnode = v
mTreeCtrl.SetItemData(root,(wxTreeItemData *)v)

# Set icons: it appears to be necessary to set all here.
# Otherwise,we might take an exception...
v.setIconVal(0)
if defined(__WXMSW__)
	# Workaround bug in wxTreectrl.
	mTreeCtrl.SetItemImage(root,0,wxTreeItemIcon_Normal)
	mTreeCtrl.SetItemImage(root,0,wxTreeItemIcon_Selected)
#elif defined(__WXGTK__)
	mTreeCtrl.SetItemImage(root,0,wxTreeItemIcon_Normal)
	mTreeCtrl.SetItemImage(root,0,wxTreeItemIcon_Selected)
	mTreeCtrl.SetItemImage(root,0,wxTreeItemIcon_Expanded)
	mTreeCtrl.SetItemImage(root,0,wxTreeItemIcon_SelectedExpanded)
</t>
<t tx="T247">def OpenWithFileName(self,fileName):
	# If the file is already open just bring its window to the front.
	frame = gLeoFrameList
	while frame:
		if frame.mFileName == fileName:
			frame.Show()
			gActiveFrame = frame
			return frame
		frame = frame.self.mNextFrame
	# Don't take an exception if the file doesn't exist.
	if not wx.wxFileExists(fileName):
		alert("Can not open: " + fileName)
		return None
	try:
		&lt;&lt; Set closeEmptyFrameFlag if the only open window is empty &gt;&gt;
		frame = LeoFrame()
		if 0 # Don't show frame until it has been fully opened.
			frame.Show(true)
		frame.self.mCommands.open(fileName)
		frame.mFileName = fileName
		# Automatically close an empty frame that was created on entry.
		if 0 #// There is still something wrong here!
		if  closeEmptyFrameFlag and closeFrame:
			closeFrame.Close()
		gActiveFrame = frame
		return frame
	except:(...)
		alert("Error opening: " + fileName)
		return None</t>
<t tx="T248">if 0: # not used at present.
	closeFrame = gLeoFrameList
	closeEmptyFrameFlag = (
		# There is only one window open at present.
		gNumberOfUntitledWindows == 1 and
		# The window was opened on startup and has never been saved.
		closeFrame and
		closeFrame.self.mCommands.mFirstWindowAndNeverSaved and
		# The window is empty.
		not (closeFrame.self.mCommands. isChanged())</t>
<t tx="T249"># 	These must match the order of items in the wxRadioBox.
# 	These are _not_ the same as vars in args.h.

enum
	c_target = 0,
	cweb_target,
	html_target,
	java_target,
	pascal_target,
	perl_target,
	perlpod_target,
	plain_text_target,
	python_target,
	bad_last_target
</t>
<t tx="T250"># This updates the text of joined _headlines_, not body text.

if 0: # no longer used

	def updateJoinedHeadlines(self,text,v):
		guard = 0
		if guard &gt; 0: return
		guard += 1
		v2 = v.joinList()
		while v2 and v2 != v:
			id = v2.treeID()
			assert(id)
			self.tree.SetItemText(id,text)
			v2 = v2.joinList()
		guard -= 1</t>
<t tx="T251"></t>
<t tx="T252">cSplitterWidth = 600

const_dict = {}
const_lastVal = 100 # Starting wx id.

def const(name):
	
	"""Return the wx id associated with name"""
	
	# Should this canonicalize the label?  Just remove '&amp;' ??
	
	id = const_dict.get(name)
	if id != None:
		return id
	else:
		global const_lastVal
		const_lastVal += 1
		const_dict[name] = const_lastVal
		# trace(name,const_lastVal)
		return const_lastVal</t>
<t tx="T253">def finishCreate (self,commander):
	
	self.c = self.commands = commander
	trace(commander)
	
	# Kludge.
	self.c.body = self.body
	self.c.frame = self
	
	# Add the frame to the global window list.
	app.windowList.append(self)
	self.redraw()</t>
<t tx="T254">def __init__ (self,title):
	
	# trace("wxLeoFrame",title)
	self.title = title
	self.ratio = None
	self.secondary_ratio = None
	self.activeFrame = None
	self.c = None # set in finishCreate.
	self.quitting = false
	self.updateCount = 0
	self.treeIniting = false
	self.drawing = false # Lockout recursive draws.
	self.root_id = None
	self.menuIdDict = {}
	self.menuBar = None
	
	# These vars have corresponding getters/setters.
	self.mDragging = false
	self.mRootVnode = None
	self.mTopVnode = None
	self.mCurrentVnode = None

	wx.wxFrame.__init__(self, None, -1, title) # wx.wxNO_3D # hangs.
	
	#self.outerPanel = wx.wxPanel(self,-1)
	#self.iconPanel = wx.wxPanel(self.outerPanel, -1, "iconPanel")
	
	self.CreateStatusBar()
	self.createMenuBar()
	
	&lt;&lt; create the splitters &gt;&gt;
	&lt;&lt; create the tree &gt;&gt;
	&lt;&lt; create the body pane &gt;&gt;
	&lt;&lt; create the log pane &gt;&gt;
	&lt;&lt; set the window icon &gt;&gt;
	&lt;&lt; declare event handlers for frame &gt;&gt;
	&lt;&lt; declare event handlers for body &amp; tree &gt;&gt;
	
	# Attach the controls to the splitter.
	self.splitter1.SplitHorizontally(self.splitter2, self.body, 0)
	self.splitter2.SplitVertically(self.tree, self.log, cSplitterWidth/2)
	</t>
<t tx="T255">self.splitter1 = wx.wxSplitterWindow(self,
	const("cSplitterWindow"),
	wx.wxDefaultPosition, wx.wxDefaultSize,
	wx.wxSP_NOBORDER)

# No effect, except to create a red flash.
if 0:
	self.splitter1.SetForegroundColour(wx.wxRED)
	self.splitter1.SetBackgroundColour(wx.wxRED)

self.splitter2 = wx.wxSplitterWindow(self.splitter1, -1,
	wx.wxDefaultPosition, wx.wxDefaultSize,
	wx.wxSP_NOBORDER)
	# wx.wxSP_BORDER | wx.wxSP_3D, "splitterWindow");

self.splitter1.SetMinimumPaneSize(4)
self.splitter2.SetMinimumPaneSize(4)</t>
<t tx="T256">self.tree = wx.wxTreeCtrl(self.splitter2,
	const("cTreeCtrl"),
	wx.wxDefaultPosition, wx.wxDefaultSize,
	wx.wxTR_HAS_BUTTONS | wx.wxTR_EDIT_LABELS, wx.wxDefaultValidator,
	"treeCtrl")
	
trace(const("cTreeCtrl"))</t>
<t tx="T257">self.body = wx.wxTextCtrl(self.splitter1,
	const("cBodyCtrl"), "",
	wx.wxDefaultPosition, wx.wxDefaultSize,
	wx.wxTE_MULTILINE)
</t>
<t tx="T258">self.log = wx.wxTextCtrl(self.splitter2,
	const("cLogCtrl"), "",
	wx.wxDefaultPosition, wx.wxDefaultSize,
	wx.wxTE_MULTILINE )
</t>
<t tx="T259">if wx.wxPlatform == "__WXMSW__":

	path = os.path.join(app.loadDir,"..","Icons","LeoApp16.ico")
	icon = wx.wxIcon(path,wx.wxBITMAP_TYPE_ICO,16,16)
	self.SetIcon(icon)
</t>
<t tx="T260">if wx.wxPlatform == "__WXMSW__": # Activate events exist only on Windows.
	wx.EVT_ACTIVATE(self,self.onActivate)
else:
	wx.EVT_SET_FOCUS(self,self.OnSetFocus)

wx.EVT_CLOSE(self,self.onCloseLeoFrame)

wx.EVT_MENU_OPEN(self,self.updateAllMenus) 

if 0: # Causes problems at present.  The screen isn't drawn properly.
	wx.EVT_SIZE(self,self.onResize)</t>
<t tx="T261"># in self.body
wx.EVT_TEXT(self,const("cBodyCtrl"),self.onBodyTextUpdated) # Fires whenever text changes.

# in self.tree
id = const("cTreeCtrl")
trace(id,self.tree)

wx.EVT_TREE_KEY_DOWN        (self,id,self.onTreeKeyDown) # Control keys do not fire this event.
wx.EVT_TREE_SEL_CHANGED     (self,id,self.onTreeChanged)
wx.EVT_TREE_SEL_CHANGING    (self,id,self.onTreeChanging)
wx.EVT_TREE_BEGIN_DRAG      (self,id,self.onTreeBeginDrag)
wx.EVT_TREE_END_DRAG        (self,id,self.onTreeEndDrag)
wx.EVT_TREE_BEGIN_LABEL_EDIT(self,id,self.onTreeBeginLabelEdit)
wx.EVT_TREE_END_LABEL_EDIT  (self,id,self.onTreeEndLabelEdit)

 
wx.EVT_TREE_ITEM_COLLAPSED  (self,id,self.onTreeCollapsed)
wx.EVT_TREE_ITEM_EXPANDED   (self,id,self.onTreeExpanded)

wx.EVT_TREE_ITEM_COLLAPSING (self,id,self.onTreeCollapsing)
wx.EVT_TREE_ITEM_EXPANDING  (self,id,self.onTreeExpanding)</t>
<t tx="T262"></t>
<t tx="T263"></t>
<t tx="T264">if wx.wxPlatform == '__WXMSW__':
	
	def onActivate(self,event):
		if event.GetActive():
			self.activeFrame = self
			if self.c:
				pass ## self.c.checkAllFileDates()
else:
	
	def OnSetFocus(self,event):
		self.activeFrame = self
		if self.c:
			self.c.checkAllFileDates()
</t>
<t tx="T265">def destroyAllPanels (self):
	trace() # Not used yet.  Later, this might be called from the app class.
	self.Destroy()

def onCloseLeoFrame(self,event):

	frame = self

	if 1: # works.  It should be improved later...

		# To do: use app.closeLeoWindow so we can use app's logic.
		# We can't do this now because app.destroyWindow stupidly references frame.top.
		# And there are subtle problems that must be resolved in app.destroyWindow.
		app.windowList.remove(frame)
		if not app.windowList:
			if app.findFrame:
				app.findFrame.Destroy()
				app.findFrame = None
		
		if 0: # app should probably call a new frame.destroySelfAndIvars routine.

			# Can't do this before self.Destroy because the menu updaters need the ivars.
			# Can't do this after  self.Destroy because frame.clearAllIvars is gone.
			# We need to disable window updaters before destroying ivars.
			app.destroyAllWindowObjects(frame)
			
		self.Destroy() # Should be very last statement!

	return ## not finished yet.

	# Veto the close if the Frame has been changed and the user cancels.
	if  self.c.isChanged():
		veto = false
		if not mReverting:
			&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;
		if veto and event.CanVeto():
			event.Veto()# veto the close.
			return

	app.windowList.remove(self)
	if not app.windowList:
		&lt;&lt; Close the permanent frames &gt;&gt;
	# Clear the active form.  It will be set on the next activate event.
	self.activeFrame = None
	gCommands = None
	# Set all vnodes to NULL so they are not destroyed.
	if 0: #/// why shouldn't they be destroyed ??
		tree = self.tree
		v = self.c.rootVnode()
		while v:
			next = v.threadNext()
			id = v.treeID()
			assert(id)
			tree.SetItemData(id,None)
			v = next
	self.Destroy()</t>
<t tx="T266"># Use the window title:  mFileName may not exist.
title = self.GetTitle()
if title and title[0] == '*':
	title = title.Mid(1)
	
quitType = choose(self.quitting,"quitting","closing")
message = 'Save changes to "%s" before %s?' % (title,quitType)
dialog = wxMessageDialog(self,message,"LeoWX",wxYES_NO|wxCANCEL)
answer = dialog.ShowModal()
if answer == wx.wxID_YES:
	# The user want's to save the file before closing.
	if mFileName == "":
		d = wxFileDialog(
			None,"Save",
			"",# default directory
			title + ".leo",# default file
			"*.leo",# wildcard
			wxSAVE | wxOVERWRITE_PROMPT, # style of dialog.
			wxDefaultPosition)

		if d.ShowModal()== wxID_OK:
			paths = d.GetPaths()
			if paths.Count()== 1:
				path = paths.Item(0)
				mFileName = path
				self.SetTitle(path)
				self.c.save(path)
			else: veto = true
		else: veto = true
	else: self.c.save(mFileName)
elif answer == wx.wxID_NO:
	pass # The user does not want to save the frame.
elif answer == wx.wxID_CANCEL:
	pass # The user want's to cancel the close.
else:
	veto = true</t>
<t tx="T267">if  gPrefsFrame:
	gPrefsFrame.Destroy()
	gPrefsFrame = None

if app.findFrame:
	app.findFrame.Destroy()
	app.findFrame = None
	
if wx.wxPlatform == "__WXMSW__":
	wxPythonFrame.destroy()</t>
<t tx="T268">def onResize(self,event):

	if mIniting:
		return # Can be called during initialization.

	# Resize splitter1 with equal sized panes.
	size = self.splitter1.GetClientSize()
	self.splitter1.SetClientSize(size)
	w = size.GetWidth() ; h = size.GetHeight()
	if self.splitter1.GetSplitMode()== wx.wxSPLIT_VERTICAL:
		self.splitter1.SetSashPosition(w/2,true)
	else:
		self.splitter1.SetSashPosition(h/2,true)

	# Resize splitter2 with equal sized panes.
	size = self.splitter2.GetClientSize()
	w = size.GetWidth() ; h = size.GetHeight()
	if self.splitter2.GetSplitMode()== wx.wxSPLIT_VERTICAL:
		self.splitter2.SetSashPosition((3*w)/5,true)
	else:
		self.splitter2.SetSashPosition((3*h)/5,true)
</t>
<t tx="T269"></t>
<t tx="T270">def onBodyTextUpdated(self,event):

	if self.c == None:  return
	v = self.c.currentVnode()
	if v == None: return
	
	s = self.body.GetValue()
	trace(s)

	return ## Not yet: sevaral calls below use tkinter or frame.top.
	
	# not yet: c.setChanged uses frame.top
	&lt;&lt; Set the dirty bit and/or the file-changed mark if the text has changed &gt;&gt;
	# not yet: ses tkinter...
	v.setBodyStringOrPane(self,s)
	v.setAncestorAtFileNodeDirty()
	# Update the syntax colorer if needed.
	self.c.updateSyntaxColorer(v)
	&lt;&lt; Update icons &gt;&gt;</t>
<t tx="T271">if not v.isDirty() and s != v.bodyString():

	v.initDirtyBit()# Avoid calling setIcon.
	if not self.c.isChanged():
		self.c.setChanged(true)</t>
<t tx="T272"># It is very important to eliminate flicker here.
val = v.computeIcon()
repaint = false

if not self.c.isChanged():
	self.c.setChanged(true)
	repaint = true

if val &gt;= 0 and val != v.iconVal():
	repaint = true
	v.setIconWithVal(val)
	# Update all joined nodes.
	v2 = v.joinList()
	while v2 and v2 != v:
		v2.setIconWithVal(val)
		v2 = v2.joinList()

if repaint:
	self.tree.Refresh()</t>
<t tx="T273"></t>
<t tx="T274"></t>
<t tx="T275">def onTreeCollapsed(self,event):
	
	"""Prepare to collapse the tree."""
	
	# trace()
	pass # No need to redraw the tree.

def onTreeExpanded (self,event):
	
	"""Redraw the tree when a tree collapses."""

	if not self.drawing:
		# trace()
		self.redraw()</t>
<t tx="T276">def onTreeCollapsing(self,event):
	
	"""Call v.contract for a later redraw."""

	tree = self.tree
	id = event.GetItem()
	if id.IsOk:
		v = tree.GetItemData(id).GetData()
		if v:
			#trace(v)
			v.contract()
	
def onTreeExpanding (self,event):
	
	"""Call v.expand for a later redraw."""
	
	tree = self.tree
	id = event.GetItem()
	if id.IsOk:
		v = tree.GetItemData(id).GetData()
		if v:
			#trace(v)
			v.expand()</t>
<t tx="T277"></t>
<t tx="T278">def onTreeChanged(self,event):

	c = self.c ; tree = self.tree
 	new_id = event.GetItem()
	if new_id.IsOk():
		v = tree.GetItemData(new_id).GetData()
		# trace(v) ; es(v)
		c.selectVnode(v)
	return
	
	if self.c.mInhibitOnTreeChanged: return
	
	# N.B. Either new_id or old_id might be 0, depending on circumstances.
	new_id = event.GetItem()
	trace("new item: ", new_id)
	if not new_id.IsOk(): return
	new_v =(self.tree.GetItemData(new_id))
	if new_v == None: return
	if 0: # no longer used
		# old_id may not exist if we are activating the first node.
		old_id = event.GetOldItem()
		trace("old item: ", old_id)
		old_v = None
		if old_id.IsOk():
			old_v =(self.tree.GetItemData(old_id))
			if wx.wxPlatform == "__WXMSW__":
				assert(old_v)

	# Apparently in wxWindows this does _not_ fire the text changed event! But in wxGTK it does.
	# We must prevent the update event handler from messing with the old text!
	sDisableTextUpdates += 1
	if 1:
		# Clear the old text.
		self.body.Clear()
		# Put the text of the new node into the body pane.
		new_v.t().loadBodyPaneFromTnode(self.body)
		# Clear the undo stack.
		self.body.DiscardEdits()
	sDisableTextUpdates -= 1
	# Update the Commander's idea of the current node.
	self.c.mCurrentVnode = new_v
	# Update the syntax colorer if needed.
	self.c.updateSyntaxColorer(new_v)

</t>
<t tx="T279">def onTreeChanging(self,event):
	
	"""Event handler gets called whenever a new node gets selected"""

	# trace()
	pass</t>
<t tx="T280"></t>
<t tx="T281"># Editing is allowed only if this routine exists.

def onTreeBeginLabelEdit(self,event):

	# Disallow editing of the dummy root node.
	id = event.GetItem()
	if id == self.root_id:
		event.Veto()</t>
<t tx="T282"># Editing will be allowed only if this routine exists.

def onTreeEndLabelEdit(self,event):

	tree = self.tree
	s = event.GetLabel()
	id = event.GetItem()
	v = tree.GetItemData(id).GetData()
	trace(id,s)

	return # Not yet: c.setChanged uses frame.top.

	# Set the dirty bit and the file-changed mark if the headline has changed.
	if not v.isDirty()and s != v.headString():
		v.setDirty()
		if not self.c.isChanged():
			self.c.setChanged(true)

	# Update all joined headlines.
	j = v.joinList()
	while j != v:
		j.setHeadString(s)
		j = j.joinList()</t>
<t tx="T283">def onTreeKeyDown(self,event):
	
	trace()
	pass # Probably we don't need to do anything until the end-edit event.</t>
<t tx="T284">def onTreeBeginDrag(self,event):

	trace() ; return

	if event.GetItem()!= self.tree.GetRootItem():
		mDraggedItem = event.GetItem()
		event.Allow()
</t>
<t tx="T285">def onTreeEndDrag(self,event):
	
	trace() ; return

	&lt;&lt; Define onTreeEndDrag vars &gt;&gt;
	if  src == 0 or dst == 0:  return
	cookie = None
	if (
		# dst is the root
		not parent.IsOk()or
		# dst has visible children and dst isn't the first child.
		self.tree.ItemHasChildren(dst)and self.tree.IsExpanded(dst)and
		self.tree.GetFirstChild(dst,cookie) != src or
		# back(src)== dst(would otherwise be a do-nothing)
		self.tree.GetPrevSibling(src) == dst):
		&lt;&lt; Insert src as the first child of dst &gt;&gt;
	else:
		# Not the root and no visible children.
		&lt;&lt; Insert src after dst &gt;&gt;
	self.c.selectVnode(src_v)
	self.c.setChanged(true)
</t>
<t tx="T286">assert(self.tree)
assert(self.c)

dst = event.GetItem()
src = mDraggedItem
mDraggedItem = 0

if not dst.IsOk() or not src.IsOk():
	return

src_v = self.tree.GetItemData(src)
if src_v == None:
	return

dst_v =self.tree.GetItemData(dst)
if dst_v == None:
	return

parent = self.tree.GetParent(dst)
parent_v = None</t>
<t tx="T287"># Make sure the drag will be valid.
parent_v = self.tree.GetItemData(dst)

if not self.c.checkMoveWithParentWithWarning(src_v,parent_v,true):
	return

src_v.moveToNthChildOf(dst_v,0)</t>
<t tx="T288"># Do nothing if dst is a child of src.
p = parent
while p.IsOk():
	if p == src:
		return
	p = self.tree.GetParent(p)

# Do nothing if dst is joined to src.
if dst_v.isJoinedTo(src_v):
	return

# Make sure the drag will be valid.
parent_v = self.tree.GetItemData(parent)
if not self.c.checkMoveWithParentWithWarning(src_v,parent_v,true):
	return

src_v.moveAfter(dst_v)</t>
<t tx="T289">if 1: # Most important...

	def drawIcon(self,v,x,y): trace(v) #  return self.tree.drawIcon(v,x,y)
	
	def setTreeIniting(self,flag):
		self.treeIniting = flag

	# Scrolling... 
	def scrollTo(self,v):  trace() #  return self.tree.scrollTo(v)
	def idle_scrollTo(self,v):  trace(v) #  return self.tree.idle_scrollTo(v)

# Coloring...
def getColorizer(self):           trace() # return self.tree.colorizer
def recolor_now(self,v):          trace() # return self.tree.recolor_now(v)
def recolor_range(self,v,leading,trailing):  trace() #  return self.tree.recolor_range(v,leading,trailing)
def recolor(self,v):              trace() #  return self.tree.recolor(v)
def updateSyntaxColorer(self,v):  trace() #  return self.tree.colorizer.updateSyntaxColorer(v)

# Focus...
def focus_get(self): trace() #  return self.tree.canvas.focus_get()

# Fonts...
def getFont(self):      return self.tree.getFont()
def setFont(self,font): return self.tree.setFont(font)

# OnHeadlineClick
# OnHeadlineRightClick
def OnActivateHeadline(self,v): trace() #  return self.tree.OnActivate(v)

# Others...
def expandAllAncestors(self,v): trace() #  return self.tree.expandAllAncestors(v)
def getEditTextDict(self,v):    trace() #  return self.tree.edit_text_dict.get(v)</t>
<t tx="T290">def beginUpdate (self):

	self.updateCount += 1</t>
<t tx="T291">def endUpdate (self,flag=true):

	assert(self.updateCount &gt; 0)

	self.updateCount -= 1
	if flag and self.updateCount == 0:
		self.redraw()</t>
<t tx="T292">def currentVnode(self):
	return self.mCurrentVnode

def dragging(self):
	return self.mDragging
	
def rootVnode(self):
	return self.mRootVnode

def topVnode(self):
	return self.mTopVnode</t>
<t tx="T293">def redraw (self):

	# trace(self.drawing)
	self.drawing = true # Tell event handlers not to call us.

	c = self.c ; tree = self.tree
	if c is None: return
	v = c.rootVnode()
	if v is None: return

	tree.DeleteAllItems()
	self.root_id = root_id = tree.AddRoot("Leo Outline Pane")
	while v:
		self.redraw_subtree(root_id,v)
		v = v.next()
	tree.Expand(root_id)
	
	self.drawing = false
		
def redraw_now(self):
	trace()
	self.redraw()</t>
<t tx="T294">def redraw_node(self,parent_id,v):
	
	# trace(v)
	tree = self.tree
	data = wx.wxTreeItemData(v)
	id = tree.AppendItem(parent_id,v.headString(),data=data)
	v.wxTreeId = id # Inject the ivar into the vnode.
	assert (v == tree.GetItemData(id).GetData())
	return id
	</t>
<t tx="T295">def redraw_subtree(self,parent_id,v):
	
	# trace(v)
	tree = self.tree
	id = self.redraw_node(parent_id,v)
	child = v.firstChild()
	
	if v.isExpanded():
		while child:
			self.redraw_subtree(id,child)
			child = child.next()
		tree.Expand(id)
	else:
		if 1: # tree.SetItemHasChildren changes the event handler logic.  So this is good enough.
			while child:
				self.redraw_node(id,child)
				child = child.next()
		else:
			if child:
				tree.SetItemHasChildren(id)
		tree.Collapse(id)</t>
<t tx="T296">def setRootVnode(self,v):
	
	# trace(v)
	if v:
		self.mRootVnode = v
	
def setCurrentVnode(self,v):
	
	# trace(v)
	if v:
		self.mCurrentVnode = v</t>
<t tx="T297">@first # -*- coding: utf-8 -*-

"""A plugin to use wxPython as Leo's gui."""

from leoPlugins import *
from leoGlobals import *

&lt;&lt; imports for wx plugin &gt;&gt;
&lt;&lt; constants for wx plugin &gt;&gt;

@others

if 0: # Enable the plugin...

	if app.gui is None:
		print "Installing wxPython gui"
		&lt;&lt; Set app.gui &gt;&gt;
		__version__ = "0.1" # Set version for the plugin handler.
		plugin_signon(__name__)
	else:
		s = "Can't install wxPython gui: previous gui installed"
		print s ; es(s,color="red")</t>
<t tx="T298">import leoCommands,leoFind,leoFrame,leoGui,leoNodes,leoTree
import os,sys,traceback

from wxPython import wx</t>
<t tx="T299">app.gui = wxGui()
app.root = app.gui.createRootWindow()
app.gui.finishCreate()
</t>
<t tx="T300">class wxGui(leoGui.leoGui):
	
	@others</t>
<t tx="T301"></t>
<t tx="T302">def __init__ (self):
	
	trace("wxGui")
	
	# Initialize the base class.
	if 1: # in plugin
		leoGui.leoGui.__init__(self,"wxPython")
	else:
		leoGui.__init__(self,"wxPython")
		
	self.bitmap_name = None
	self.bitmap = None</t>
<t tx="T303">def createRootWindow(self):

	trace("wxGui")
	self.wxApp = wxLeoApp(None) # This redirects stdout &amp; stderr to stupid console.
	self.wxFrame = None
	
	if 0: # Not ready yet.
		self.setDefaultIcon()
		self.getDefaultConfigFont(app.config)
		self.setEncoding()
		self.createGlobalWindows()

	return self.wxFrame</t>
<t tx="T304">def setDefaultIcon(self):
	
	"""Set the icon to be used in all Leo windows.
	
	This code does nothing for Tk versions before 8.4.3."""
	
	gui = self

	try:
		version = gui.root.getvar("tk_patchLevel")
		if CheckVersion(version,"8.4.3"):
			# tk 8.4.3 or greater: load a 16 by 16 icon.
			path = os.path.join(app.loadDir,"..","Icons")
			if os.path.exists(path):
				file = os.path.join(path,"LeoApp16.ico")
				if os.path.exists(path):
					self.bitmap = Tkinter.BitmapImage(file)
				else:
					es("LeoApp16.ico not in Icons directory", color="red")
			else:
				es("Icons directory not found: "+path, color="red")
	except:
		print "exception setting bitmap"
		traceback.print_exc()</t>
<t tx="T305">@ According to Martin v. Lwis, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

def setEncoding (self):

	for (encoding,src) in (
		(app.config.tkEncoding,"config"),
		#(locale.getdefaultlocale()[1],"locale"),
		(getpreferredencoding(),"locale"),
		(sys.getdefaultencoding(),"sys"),
		("utf-8","default")):
	
		if isValidEncoding (encoding): # 3/22/03
			app.tkEncoding = encoding
			# trace(app.tkEncoding,src)
			break
		elif encoding and len(encoding) &gt; 0:
			trace("ignoring invalid " + src + " encoding: " + `encoding`)
			
	# trace(app.tkEncoding)</t>
<t tx="T306">def getDefaultConfigFont(self,config):
	
	"""Get the default font from a new text widget."""

	t = Tkinter.Text()
	fn = t.cget("font")
	font = tkFont.Font(font=fn)
	config.defaultFont = font
	config.defaultFontFamily = font.cget("family")</t>
<t tx="T307">def createGlobalWindows (self):
	
	"""Create the global windows for the application."""
	
	app.findFrame = leoFind.leoFind()
	app.findFrame.top.withdraw()
	app.globalWindows.append(app.findFrame)</t>
<t tx="T308">def destroy(self,widget):
	
	pass # wx code not ready yet.</t>
<t tx="T309">def finishCreate (self):

	pass
	
</t>
<t tx="T310">def killGui(self,exitFlag=true):
	
	"""Destroy a gui and terminate Leo if exitFlag is true."""

	pass # Not ready yet.

</t>
<t tx="T311">def recreateRootWindow(self):
	"""A do-nothing base class to create the hidden root window of a gui

	after a previous gui has terminated with killGui(false)."""
	pass

</t>
<t tx="T312">def runMainLoop(self):

	"""Run tkinter's main loop."""
	
	trace("wxGui")
	self.wxApp.MainLoop()
	trace("done")</t>
<t tx="T313"></t>
<t tx="T314">def getFontFromParams(self,family,size,slant,weight):
	
	trace(app.config.defaultFont)
	
	return app.config.defaultFont ##
	
	family_name = family
	
	try:
		font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
		#print family_name,family,size,slant,weight
		#print "actual_name:",font.cget("family")
		return font
	except:
		es("exception setting font from " + `family_name`)
		es("family,size,slant,weight:"+
			`family`+':'+`size`+':'+`slant`+':'+`weight`)
		es_exception()
		return app.config.defaultFont</t>
<t tx="T315">def newAboutLeoDialog(self,commander):
	"""A do-nothing base class to create an About Leo dialog."""
	pass

def newAskOkDialog(self,commander):
	"""A do-nothing base class to create an askOK dialog ."""
	pass

def newAskOkCancelDialog(self,commander):
	"""A do-nothing base class to create an askOkCancel dialog."""
	pass

def newAskOkCancelNumberDialog(self,commander):
	"""A do-nothing base class to create an askOkCancelNumber dialog ."""
	pass

def newAskYesNoDialog(self,commander):
	"""A do-nothing base class to create an askYesNo dialog."""
	pass

def newAskYesNoCancelDialg(self,commander):
	"""A do-nothing base class to create an askYesNoCancel dialog ."""
	pass</t>
<t tx="T316"></t>
<t tx="T317">def newLeoFrame(self,title):
	
	"""Create a view frame for the Leo main window."""
	
	trace()
	self.wxFrame = wxLeoFrame(title)
	self.wxApp.SetTopWindow(self.wxFrame)
	self.wxFrame.Show(true)
	if not app.root:
		app.root = self.wxFrame
	return self.wxFrame</t>
<t tx="T318">def newColorFrame(self,commander):
	"""Create a colorFrame."""
	pass # To do

def newColorNameFrame(self,commander):
	"""Create a colorNameFrame."""
	pass # To do

def newCompareFrame(self,commander):
	"""Create a compareFrame."""
	pass # To do

def newFindFrame(self,commander):
	"""Create a findFrame."""
	pass # To do

def newFontFrame(self,commander):
	"""Create a fontFrame."""
	pass # To do

def newPrefsFrame(self,commander):
	"""Create a prefsFrame."""
	pass # To do</t>
<t tx="T319">def destroyLeoFrame (self,frame):

	trace(frame.title)
	frame.Close()</t>
<t tx="T320">def destroy (self,widget):
	
	trace()</t>
<t tx="T321"></t>
<t tx="T322">def get_focus(self,top):
	
	"""Returns the widget that has focus, or body if None."""

	pass # wx code not ready yet.</t>
<t tx="T323">def set_focus(self,commands,widget):
	
	"""Set the focus of the widget in the given commander if it needs to be changed."""
	
	pass # wx code not ready yet.</t>
<t tx="T324">def force_focus(self,commands,widget):
	
	"""Set the focus of the widget in the given commander if it needs to be changed."""
	
	pass # wx code not ready yet.</t>
<t tx="T325"></t>
<t tx="T326">def attachLeoIcon (self,w):
	
	"""Try to attach a Leo icon to the Leo Window.
	
	Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
	Otherwise, try to use the Python Imaging Library and the tkIcon package."""

	if self.bitmap != None:
		# We don't need PIL or tkicon: this is tk 8.3.4 or greater.
		try:
			w.wm_iconbitmap(self.bitmap)
		except:
			self.bitmap = None
	
	if self.bitmap == None:
		try:
			&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
		except:
			# traceback.print_exc()
			self.leoIcon = None</t>
<t tx="T327">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image,tkIcon,_tkicon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
	try: self.leoIcon.attach(w.winfo_id())
	except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)
if not self.leoIcon:
	# Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
	icon_file_name = os.path.join(app.loadDir,'..','Icons','LeoWin.gif')
	icon_file_name = os.path.normpath(icon_file_name)
	icon_image = Image.open(icon_file_name)
	if 1: # Doesn't resize.
		self.leoIcon = self.createLeoIcon(icon_image)
	else: # Assumes 64x64
		self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="T328"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
	
	try:
		import Image,tkIcon,_tkicon
		
		i = icon ; m = None
		# create transparency mask
		if i.mode == "P":
			try:
				t = i.info["transparency"]
				m = i.point(lambda i, t=t: i==t, "1")
			except KeyError: pass
		elif i.mode == "RGBA":
			# get transparency layer
			m = i.split()[3].point(lambda i: i == 0, "1")
		if not m:
			m = Image.new("1", i.size, 0) # opaque
		# clear unused parts of the original image
		i = i.convert("RGB")
		i.paste((0, 0, 0), (0, 0), m)
		# create icon
		m = m.tostring("raw", ("1", 0, 1))
		c = i.tostring("raw", ("BGRX", 0, -1))
		return _tkicon.new(i.size, c, m)
	except:
		return None</t>
<t tx="T329"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
	
	top.update_idletasks() # Required to get proper info.

	# Get the information about top and the screen.
	geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
	dim,x,y = string.split(geom,'+')
	w,h = string.split(dim,'x')
	w,h,x,y = int(w),int(h),int(x),int(y)
	
	return w,h,x,y</t>
<t tx="T330"># Center the dialog on the screen.
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def center_dialog(self,top):

	sw = top.winfo_screenwidth()
	sh = top.winfo_screenheight()
	w,h,x,y = get_window_info(top)
	
	# Set the new window coordinates, leaving w and h unchanged.
	x = (sw - w)/2
	y = (sh - h)/2
	top.geometry("%dx%d%+d%+d" % (w,h,x,y))
	
	return w,h,x,y</t>
<t tx="T331"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
	caption=None,relief="groove",bd=2,padx=0,pady=0):
	
	Tk = Tkinter
	# Create w, the master frame.
	w = Tk.Frame(parent)
	w.grid(sticky="news")
	
	# Configure w as a grid with 5 rows and columns.
	# The middle of this grid will contain f, the expandable content area.
	w.columnconfigure(1,minsize=bd)
	w.columnconfigure(2,minsize=padx)
	w.columnconfigure(3,weight=1)
	w.columnconfigure(4,minsize=padx)
	w.columnconfigure(5,minsize=bd)
	
	w.rowconfigure(1,minsize=bd)
	w.rowconfigure(2,minsize=pady)
	w.rowconfigure(3,weight=1)
	w.rowconfigure(4,minsize=pady)
	w.rowconfigure(5,minsize=bd)

	# Create the border spanning all rows and columns.
	border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
	border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
	
	# Create the content frame, f, in the center of the grid.
	f = Tk.Frame(w,bd=bd)
	f.grid(row=3,column=3,sticky="news")
	
	# Add the caption.
	if caption and len(caption) &gt; 0:
		caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
		caption.tkraise(w)
		caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

	return w,f</t>
<t tx="T332">class wxLeoApp (wx.wxApp):
	
	@others
</t>
<t tx="T333">def OnInit(self):
	
	self.SetAppName("Leo")
	trace("wx.wxPlatform",wx.wxPlatform)
	app.findFrame = wxFindFrame()
	app.globalWindows.append(app.findFrame)
	return true</t>
<t tx="T334">def OnExit(self):
	
	trace()
	return true
</t>
<t tx="T335">class wxLeoFrame(wx.wxFrame):
	@others</t>
<t tx="T336"></t>
<t tx="T337">def __repr__ (self):
	
	return "wxLeoFrame: " + self.title</t>
<t tx="T338">def createMenuBar(self):
	
	self.menuBar = menuBar = wx.wxMenuBar()
	self.menuShortcuts = []
	
	&lt;&lt; create the file menu &gt;&gt;
	&lt;&lt; create the edit menu &gt;&gt;
	&lt;&lt; create the outline menu &gt;&gt;
	if 0: # c not created yet.
		doHook("create-optional-menus",c=c)
	&lt;&lt; create the window menu &gt;&gt;
	&lt;&lt; create the help menu &gt;&gt;
	
	for menu,name in (
		(fileMenu, "&amp;File"),
		(editMenu, "&amp;Edit"),
		(outlineMenu, "&amp;Outline"),
		(windowMenu, "&amp;Window"),
		(helpMenu, "&amp;Help")):
	
		menuBar.Append(menu,name)
		
	self.SetMenuBar(menuBar)  # attach the menu bar to the frame
	
	# app().menuWarningsGiven = true</t>
<t tx="T339">fileMenu = wx.wxMenu()

&lt;&lt; create the top-level file entries &gt;&gt;
&lt;&lt; create the recent files submenu &gt;&gt;
fileMenu.AppendSeparator()
&lt;&lt; create the read/write submenu &gt;&gt;
&lt;&lt; create the tangle submenu &gt;&gt;
&lt;&lt; create the untangle submenu &gt;&gt;
&lt;&lt; create the import submenu &gt;&gt;
&lt;&lt; create the export submenu &gt;&gt;
fileMenu.AppendSeparator()

# Create the last entries.
exitTable = (("E&amp;xit","Ctrl-Q",self.OnQuit),)
self.createMenuEntries(fileMenu,exitTable)</t>
<t tx="T340">@ leo.py will probably never have a Print command.  Instead, export text files that may be formatted and printed as desired.
@c

table = (
	("&amp;New","Ctrl+N",self.OnNew),
	("&amp;Open...","Ctrl+O",self.OnOpen))
self.createMenuEntries(fileMenu,table)

# Create a new menu rather than call OnOpenWith.
openWithMenu = wx.wxMenu()

table = (
	("-",None,None),
	("&amp;Close","Ctrl+W",self.OnClose),
	("&amp;Save","Ctrl+S",self.OnSave),
	("Save &amp;As","Shift+Ctrl+S",self.OnSaveAs),
	("Save To",None,self.OnSaveTo),
	("Re&amp;vert To Saved",None,self.OnRevert,self.OnUpdateRevert))

self.createMenuEntries(fileMenu,table)</t>
<t tx="T341">recentFilesMenu = wx.wxMenu()

self.recentFiles = app().config.getRecentFiles()

if 0: # Not ready yet.
	self.createRecentFilesMenuItems()
	
lab = "Recent &amp;Files..."
fileMenu.AppendMenu(const(lab),lab,recentFilesMenu)</t>
<t tx="T342">readWriteMenu = wx.wxMenu()

table = [
		("&amp;Read Outline Only","Shift+Ctrl+R",self.OnReadOutlineOnly),
		("Read @file &amp;Nodes",None,self.OnReadAtFileNodes),
		("-",None,None),
		#("Write &amp;Dirty @file Nodes","Shift+Ctrl+Q",self.OnWriteDirtyAtFileNodes),
		#("Write &amp;Missing @file Nodes",None,self.OnWriteMissingAtFileNodes),
		("Write &amp;Outline Only",None,self.OnWriteOutlineOnly),
		("&amp;Write @file Nodes","Shift+Ctrl+W",self.OnWriteAtFileNodes)]

self.createMenuEntries(readWriteMenu,table)

lab = "&amp;Read/Write..."
fileMenu.AppendMenu(const(lab),lab,readWriteMenu)</t>
<t tx="T343">tangleMenu = wx.wxMenu()

table = (
	("Tangle &amp;All","Shift+Ctrl+A",self.OnTangleAll),
	("Tangle &amp;Marked","Shift+Ctrl+M",self.OnTangleMarked),
	("&amp;Tangle","Shift+Ctrl+T",self.OnTangle))

self.createMenuEntries(tangleMenu,table)

lab = "&amp;Tangle..."
fileMenu.AppendMenu(const(lab),lab,tangleMenu)</t>
<t tx="T344">untangleMenu = wx.wxMenu()

table = (
	("Untangle &amp;All",None,self.OnUntangleAll),
	("Untangle &amp;Marked",None,self.OnUntangleMarked),
	("&amp;Untangle","Shift+Ctrl+U",self.OnUntangle))
	
self.createMenuEntries(untangleMenu,table)

lab = "&amp;Untangle..."
fileMenu.AppendMenu(const(lab),lab,untangleMenu)</t>
<t tx="T345">importMenu = wx.wxMenu()

table = (
	#("Import To @&amp;file","Shift+Ctrl+F",self.OnImportAtFile),
	#("Import To @&amp;root",None,self.OnImportAtRoot),
	("Import &amp;CWEB Files",None,self.OnImportCWEBFiles),
	("Import &amp;noweb Files",None,self.OnImportNowebFiles))
	#("Import Flattened &amp;Outline",None,self.OnImportFlattenedOutline))

self.createMenuEntries(importMenu,table)

lab = "&amp;Import..."
fileMenu.AppendMenu(const(lab),lab,importMenu)</t>
<t tx="T346">exportMenu = wx.wxMenu()

table = (
	#("Export &amp;Headlines",None,self.OnExportHeadlines),
	#("Outline To &amp;CWEB",None,self.OnOutlineToCWEB),
	#("Outline To &amp;Noweb",None,self.OnOutlineToNoweb),
	("&amp;Flatten Outline",None,self.OnFlattenOutline),)
	#("&amp;Remove Sentinels",None,self.OnRemoveSentinels),
	#("&amp;Weave",None,self.OnWeave)]

self.createMenuEntries(exportMenu,table)

lab = "&amp;Export..."
fileMenu.AppendMenu(const(lab),lab,exportMenu)</t>
<t tx="T347">editMenu = wx.wxMenu()

&lt;&lt; create the first top-level edit entries &gt;&gt;
&lt;&lt; create the edit body submenu &gt;&gt;
&lt;&lt; create the edit headline submenu &gt;&gt;
&lt;&lt; create the find submenu &gt;&gt;
&lt;&lt; create the last top-level edit entries &gt;&gt;</t>
<t tx="T348">table = (
	("Can't Undo","Ctrl+Z",self.OnUndo,self.OnUpdateUndo), # &amp;U reserved for Undo
	("Can't Redo","Shift+Ctrl+Z",self.OnRedo,self.OnUpdateRedo), # &amp;R reserved for Redo
	("-",None,None),
	#("Cu&amp;t","Ctrl+X",self.OnCutFromMenu,self.OnUpdateCut), 
	#("Cop&amp;y","Ctrl+C",self.OnCopyFromMenu,self.OnUpdateCopy),
	#("&amp;Paste","Ctrl+V",self.OnPasteFromMenu,self.OnUpdatePaste),
	#("&amp;Delete",None,self.OnDelete,self.OnUpdateDelete),
	("Select &amp;All","Ctrl+A",self.OnSelectAll,self.OnUpdateSelectAll),
	("-",None,None))

self.createMenuEntries(editMenu,table)</t>
<t tx="T349">editBodyMenu = wx.wxMenu()

table = (
	("Extract &amp;Section","Shift+Ctrl+E",self.OnExtractSection,self.OnUpdateExtractSection),
	("Extract &amp;Names","Shift+Ctrl+N",self.OnExtractNames,self.OnUpdateExtractNames),
	("&amp;Extract","Shift+Ctrl+D",self.OnExtract,self.OnUpdateExtract))

	#("-",None,None),
	#("Convert All B&amp;lanks",None,self.OnConvertAllBlanks),
	#("Convert All T&amp;abs",None,self.OnConvertAllTabs),
	#("Convert &amp;Blanks","Shift+Ctrl+B",self.OnConvertBlanks),
	#("Convert &amp;Tabs","Shift+Ctrl+J",self.OnConvertTabs),
	#("Insert Body Time/&amp;Date","Shift+Ctrl+G",self.OnInsertBodyTime),
	#("&amp;Reformat Paragraph","Shift+Ctrl+P",self.OnReformatParagraph),
	#("-",None,None),
	#("&amp;Indent","Ctrl+]",self.OnIndent),
	#("&amp;Unindent","Ctrl+[",self.OnDedent),
	#("&amp;Match Brackets","Ctrl+K",self.OnFindMatchingBracket))
	
self.createMenuEntries(editBodyMenu,table)

lab = "Edit &amp;Body..."
editMenu.AppendMenu(const(lab),lab,editBodyMenu)</t>
<t tx="T350">editHeadlineMenu = wx.wxMenu()

table = (
	("Edit &amp;Headline","Ctrl+H",self.OnEditHeadline),)

	#("&amp;End Edit Headline","Escape",self.OnEndEditHeadline),
	#("&amp;Abort Edit Headline","Shift-Escape",self.OnAbortEditHeadline),
	#("Insert Headline Time/&amp;Date","Shift+Ctrl+H",self.OnInsertHeadlineTime))
	
	# 5/16/03 EKR: I dislike this command.
	#("Toggle Angle Brackets","Ctrl+B",self.OnToggleAngleBrackets)
	
self.createMenuEntries(editHeadlineMenu,table)

lab = "Edit &amp;Headline..."
editMenu.AppendMenu(const(lab),lab,editHeadlineMenu)


</t>
<t tx="T351">findMenu = wx.wxMenu()

table = (
	("&amp;Find Panel","Ctrl+F",self.OnFindPanel),
	("-",None,None),
	("Find &amp;Next","F3",self.OnFindNext,self.OnUpdateFind),
	("Find &amp;Previous","F4",self.OnFindPrevious,self.OnUpdateFind),
	("&amp;Replace","Ctrl+=",self.OnReplace,self.OnUpdateReplace),
	("Replace, &amp;Then Find","Ctrl+-",self.OnReplaceThenFind,self.OnUpdateReplace))

self.createMenuEntries(findMenu,table)

lab = "&amp;Find..."
editMenu.AppendMenu(const(lab),lab,findMenu)</t>
<t tx="T352">if 1:
	label = "Toggle Invisibles"
else:
	label = choose(c.tree.colorizer.showInvisibles,"Hide In&amp;visibles","Show In&amp;visibles")

table = (
	#("&amp;Go To Line Number","Alt+G",self.OnGoToLineNumber),
	#("&amp;Execute Script","Alt+Shift+E",self.OnExecuteScript),
	("Set Fon&amp;t...","Shift+Alt+T",self.OnFontPanel),
	#("Set &amp;Colors...","Shift+Alt+C",self.OnColorPanel),
	#(label,"Alt+V",self.OnViewAllCharacters),
	#("-",None,None),
	("Prefere&amp;nces","Ctrl+Y",self.OnPreferences))

self.createMenuEntries(editMenu,table)</t>
<t tx="T353">outlineMenu = wx.wxMenu()

&lt;&lt; create top-level outline menu &gt;&gt;
&lt;&lt; create expand/contract submenu &gt;&gt;
&lt;&lt; create move submenu &gt;&gt;
&lt;&lt; create mark submenu &gt;&gt;
&lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="T354">table = (
	("C&amp;ut Node","Shift+Ctrl+X",self.OnCutNode,self.OnUpdateCutNode),
	("C&amp;opy Node","Shift+Ctrl+C",self.OnCopyNode),
	("&amp;Paste Node","Shift+Ctrl+V",self.OnPasteNode,self.OnUpdatePasteNode),
	("&amp;Delete Node","Shift+Ctrl+BkSp",self.OnDeleteNode,self.OnUpdateDeleteNode),
	("-",None,None),
	("&amp;Insert Node","Ctrl+I",self.OnInsertNode),
	("&amp;Clone Node","Ctrl+`",self.OnCloneNode))

	# ("Sort Node",None,self.OnSortChildren,self.OnUpdateSortNode)
	# ("Sort C&amp;hildren",None,self.OnSortChildren),
	#("&amp;Sort Siblings","Alt-A",self.OnSortSiblings),
	#("-",None,None))

self.createMenuEntries(outlineMenu,table)</t>
<t tx="T355">expandMenu = wx.wxMenu()

table = (
	("&amp;Contract All","Alt+-",self.OnContractAll,self.OnUpdateContractAll),
	# ("Contract &amp;Node","Alt+[",self.OnContractNode),
	# ("Contract &amp;Parent","Alt+0",self.OnContractParent),
	("-",None,None),
	# ("Expand P&amp;rev Level","Alt+.",self.OnExpandPrevLevel),
	# ("Expand N&amp;ext Level","Alt+=",self.OnExpandNextLevel),
	# ("-",None,None),
	("Expand To Level &amp;1","Alt+1",self.OnExpandToLevel1),
	("Expand To Level &amp;2","Alt+2",self.OnExpandToLevel2),
	("Expand To Level &amp;3","Alt+3",self.OnExpandToLevel3),
	("Expand To Level &amp;4","Alt+4",self.OnExpandToLevel4),
	("Expand To Level &amp;5","Alt+5",self.OnExpandToLevel5),
	("Expand To Level &amp;6","Alt+6",self.OnExpandToLevel6),
	("Expand To Level &amp;7","Alt+7",self.OnExpandToLevel7),
	("Expand To Level &amp;8","Alt+8",self.OnExpandToLevel8),
	# ("Expand To Level &amp;9","Alt+9",self.OnExpandToLevel9),
	("-",None,None),
	("Expand &amp;All","Alt+9",self.OnExpandAll,self.OnUpdateExpandAll))
	#("Expand N&amp;ode","Alt+]",self.OnExpandNode))

self.createMenuEntries(expandMenu,table)

lab = "&amp;Expand/Contract..."
outlineMenu.AppendMenu(const(lab),lab,expandMenu)

if 0: # not used yet.  Maybe never.
	wx.EVT_UPDATE_UI(cExpandAllChildrenMenuItem,self.OnUpdateExpandAllChildren)
	wx.EVT_UPDATE_UI(cExpandChilrenMenuItem,self.OnUpdateExpandChildren)
	wx.EVT_UPDATE_UI(cContractAllChildrenMenuItem,self.OnUpdateContractAllChildren)
	wx.EVT_UPDATE_UI(cContractChilrenMenuItem,self.OnUpdateContractChildren)</t>
<t tx="T356">moveSelectMenu = wx.wxMenu()

table = (
	("Move &amp;Down", "Ctrl+D",self.OnMoveDown,self.OnUpdateMoveDown),
	("Move &amp;Left", "Ctrl+L",self.OnMoveLeft,self.OnUpdateMoveLeft),
	("Move &amp;Right","Ctrl+R",self.OnMoveRight,self.OnUpdateMoveRight),
	("Move &amp;Up",   "Ctrl+U",self.OnMoveUp,self.OnUpdateMoveUp),
	("-",None,None),
	("&amp;Promote","Ctrl+{",self.OnPromote,self.OnUpdatePromote),
	("&amp;Demote", "Ctrl+}",self.OnDemote,self.OnUpdateDemote))
	
self.createMenuEntries(moveSelectMenu,table)

lab = "&amp;Move..."
outlineMenu.AppendMenu(const(lab),lab,moveSelectMenu)</t>
<t tx="T357">markMenu = wx.wxMenu()

table = (
	("&amp;Mark","Ctrl-M",self.OnMark,self.OnUpdateMark),
	("Mark &amp;Subheads","Alt+S",self.OnMarkSubheads,self.OnUpdateMarkSubheads),
	("Mark Changed &amp;Items","Alt+C",self.OnMarkChangedItems,self.OnUpdateMarkChangedItems),
	("Mark Changed &amp;Roots","Alt+R",self.OnMarkChangedRoots,self.OnUpdateMarkChangedRoots),
	# ("Mark &amp;Clones","Alt+K",self.OnMarkClones),
	("&amp;Unmark All","Alt+U",self.OnUnmarkAll))
	
self.createMenuEntries(markMenu,table)

lab = "M&amp;ark/Unmark..."
outlineMenu.AppendMenu(const(lab),lab,markMenu)</t>
<t tx="T358">gotoMenu = wx.wxMenu()

table = (
	#("Go Back",None,self.OnGoPrevVisitedNode), # Usually use buttons for this.
	#("Go Forward",None,self.OnGoNextVisitedNode),
	#("-",None,None),
	("Go To Next &amp;Marked","Alt+M",self.OnGoToNextMarked,self.OnUpdateGoToNextMarked),
	("Go To Next C&amp;hanged","Alt+D",self.OnGoToNextChanged,self.OnUpdateGoToNextChanged),
	# ("Go To Next &amp;Clone","Alt+N",self.OnGoToNextClone),
	("-",None,None),
	#("Go To &amp;First Node","Alt+Shift+G",self.OnGoToFirstNode),
	#("Go To &amp;Last Node","Alt+Shift+H",self.OnGoToLastNode),
	#("Go To &amp;Parent","Alt+Shift+P",self.OnGoToParent),
	#("Go To P&amp;rev Sibling","Alt+Shift+R",self.OnGoToPrevSibling),
	#("Go To Next &amp;Sibling","Alt+Shift+S",self.OnGoToNextSibling),
	#("-",None,None),
	("Go To Prev V&amp;isible","Alt-UpArrow",self.OnGoPrevVisible,self.OnUpdateGoPrevVisible),
	("Go To Next &amp;Visible","Alt-DnArrow",self.OnGoNextVisible,self.OnUpdateGoNextVisible),
	("Go To Prev Node","Alt-Shift+UpArrow",self.OnGoBack,self.OnUpdateGoBack),
	("Go To Next Node","Alt-Shift-DnArrow",self.OnGoNext,self.OnUpdateGoNext))
	
self.createMenuEntries(gotoMenu,table)

lab = "&amp;Go To..."
outlineMenu.AppendMenu(const(lab),lab,gotoMenu)</t>
<t tx="T359">windowMenu = wx.wxMenu()

table = (
	("&amp;Equal Sized Panes","Ctrl-E",self.OnEqualSizedPanes),
	("Toggle &amp;Active Pane","Ctrl-T",self.OnToggleActivePane),
	# ("Toggle &amp;Split Direction",None,self.OnToggleSplitDirection),
	("-",None,None),
	("Casca&amp;de",None,self.OnCascade),
	("&amp;Minimize All",None,self.OnMinimizeAll))
	
	#("-",None,None),
	#("Open &amp;Compare Window",None,self.OnOpenCompareWindow))

self.createMenuEntries(windowMenu,table)</t>
<t tx="T360">helpMenu = wx.wxMenu()

table = (
	("&amp;About Leo...",None,self.OnAbout),)
	#("Online &amp;Home Page",None,self.OnLeoHome),
	#("-",None,None),
	#("Open Online &amp;Tutorial",None,self.OnLeoTutorial))

self.createMenuEntries(helpMenu,table)

if 0: # not ready yet.

	if wx.wxPlatform == '__WXMSW__':
		table = (("Open &amp;Offline Tutorial",None,self.OnLeoHelp),)
		self.createMenuEntries(helpMenu,table)
	
	table = (
		("Open Leo&amp;Docs.leo",None,self.OnLeoDocumentation),
		("-",None,None),
		("Open Leo&amp;Config.leo",None,self.OnLeoConfig),
		("Apply &amp;Settings",None,self.OnApplyConfig))

	self.createMenuEntries(helpMenu,table)</t>
<t tx="T361">@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=0):
	
	for data in table:
		if len(data) == 3:
			label,accel,command = data ; update_command = None
		else:
			label,accel,command,update_command = data

		if label == '-':
			menu.AppendSeparator()
		else:
			def callback(event,command=command):
				try: command(event)
				except: print traceback.print_exc()
	
			id = const(label)
			menu.Append(id,label,label)
			wx.EVT_MENU(self,id,callback)
			if update_command:
				self.menuIdDict[label] = id,label,update_command
				# We no longer pollute idle-time with this garbage
				# wx.EVT_UPDATE_UI(self,id,update_command)</t>
<t tx="T362">if 0:# Notifications... We probably will never see these.
	def onBodyChanged(self,*args,**keys): trace() #  return self.tree.onBodyChanged(*args,**keys)
	def onHeadChanged(self,*args,**keys): trace() #  return self.tree.onHeadChanged(*args,**keys)
	def OnHeadlineKey(self,v,event):      trace(v) #  return self.tree.OnHeadlineKey(v,event)
	def idle_head_key(self,v):            trace(v) #  return self.tree.idle_head_key(v)
	
# Editing... These can remain do-nothings.
def editLabel(self,v):           pass
def editVnode(self):             pass
def endEditLabel(self):          pass
def setEditVnode(self,v):        trace() #  self.tree.editVnode = v
def setNormalLabelState(self,v): pass</t>
<t tx="T363"># vnode callbacks: to be removed.
if 0: # These will never be called, because the events are never generated.
	def OnBoxClick(self,v):              trace() #  return self.tree.OnBoxClick(v)
	def OnIconClick(self,v,event):       trace() #  return self.tree.OnIconClick(v,event)
	def OnIconDoubleClick(self,v,event): trace() #  return self.tree.OnIconDoubleClick(v,event)
	def OnIconRightClick(self,v,event):  trace() #  return self.tree.OnIconRightClick(v,event)
	def OnDrag(self,v,event):            trace() #  return self.tree.OnDrag(v,event)
	def OnEndDrag(self,v,event):         trace() #  return self.tree.OnEndDrag(v,event)
	def OnPopup(self,v,event):           trace() #  return self.tree.OnPopup(v,event)</t>
<t tx="T364"></t>
<t tx="T365">def after_idle(*args): trace()

def createOpenWithMenuFromTable (self,table): trace()
def getMenu (self,name): trace(name)
def resizePanesToRatio(self,ratio1,ratio2): trace(ratio1,ratio2)
def setInitialWindowGeometry (self): trace()
def setTopGeometry(self,geom): trace(geom)
def updateRecentFiles(self,fileName): trace(fileName)

# Wrappers for tk calls...

def lift (self):   trace()
def update (self): trace()

def FindFocus(self): return self.body # Kludge.</t>
<t tx="T366">def deiconify (self):
	self.Iconize(false)</t>
<t tx="T367">def getTitle (self):
	
	return self.title
</t>
<t tx="T368">def put (self,s,color=None):
	if self.log:
		self.log.AppendText(s)
	print s

def putnl (self):
	print
	if self.log:
		self.log.AppendText('\n')</t>
<t tx="T369">def select(self,v,updateBeadList=true):
	
	if v:
		self.mCurrentVnode = v
		#### What to do about updateBeadList ????
		trace("wxLeoFrame",v) #  return self.tree.select(v,updateBeadList)
</t>
<t tx="T370"></t>
<t tx="T371">def updateAllMenus(self,event):
	
	"""Called whenever any menu is pulled down."""
	
	for id,label,update_command in self.menuIdDict.values():

		item = self.menuBar.FindItemById(id)
		try:
			self.updateMenuItem = item # optional param
			val = update_command()
			val = choose(val,1,0)
			item.Enable(val)
			# trace(id,bool(val),item.GetLabel())
		except:
			traceback.print_exc()
			val = true</t>
<t tx="T372"></t>
<t tx="T373">def OnUpdateRevert(self):
	
	return self.c.canRevert()
</t>
<t tx="T374"></t>
<t tx="T375">def OnUpdateCopy(self):

	w = self.FindFocus()
	if w and w == self.body:
		return self.body.CanCopy()
	elif w and w == self.log:
		return self.log.CanCopy()
	else:
		return false</t>
<t tx="T376">def OnUpdateCut(self):

	w = self.FindFocus()
	if w and w == self.body:
		return self.body.CanCut()
	elif w and w == mLogCtrl:
		return self.log.CanCut()
	else:
		return false
</t>
<t tx="T377">def OnUpdateDelete(self):
	
	return self.body.CanCut()</t>
<t tx="T378">def OnUpdateExtract(self):
	
	return true
	
	# c.canExtract calls tk routines.
	# return self.c.canExtract()
</t>
<t tx="T379">def OnUpdateExtractNames(self):
	
	return true
	
	# c.canExtractSectionNames calls tk routines.
	# return self.c.canExtractSectionNames()</t>
<t tx="T380">def OnUpdateExtractSection(self):
	
	return true
	
	# c.canExtractSection calls tk routines.
	# return self.c.canExtractSection()

</t>
<t tx="T381">def OnUpdateFind(self):

	return true

	# return find_text.Length()&gt; 0
</t>
<t tx="T382">def OnUpdatePaste(self):

	if wx.wxPlatform == "__WXMSW__": # apparent bug.
		return true
	else:
		w = self.FindFocus()
		if w and w == self.body:
			return self.body.CanPaste()
		elif w and w == mLogCtrl:
			return self.log.CanPaste()
		else:
			return false</t>
<t tx="T383">def OnUpdateRedo(self):

	# The Tree view does not support redo.
	if wx.wxPlatform == "__WXGTK__": # text control does not support undo/redo on wxGTK
		return false
	else:
		return self.body.CanRedo()
	
</t>
<t tx="T384">def OnUpdateReplace(self):
	
	return true

	# event.Enable(self.c.changeIsEnabled()</t>
<t tx="T385">def OnUpdateSelectAll(self):
	
	w = self.FindFocus()
	return w and (w == self.body or w == self.log)
</t>
<t tx="T386">def OnUpdateUndo(self):
	
	w = self.FindFocus()
	enabled = true
	
	if 0: # not ready yet.
		enabled = false
		
		# FindFocus seems to be a bit flakey,so use it only when absolutely needed.
		if  w == self.tree:
			enabled = self.c.canUndo()
		else:
			# Don't use FindFocus.
			if wx.wxPlatform == "__WXGTK__": # text control does not support undo/redo on wxGTK
				enabled = false
			else:
				enabled = self.body.CanUndo()

	return enabled</t>
<t tx="T387">def hasSelection(self,void):

	if self.body:
		start,end = self.body.GetSelection()
		return start != end
	else:
		return false</t>
<t tx="T388"></t>
<t tx="T389">def OnUpdateContractAll(self):

	return self.c.canContractAllHeadlines()
</t>
<t tx="T390">def OnUpdateContractAllChildren(self):
	
	return self.c.canContractAllSubheads()

</t>
<t tx="T391">def OnUpdateContractChildren(self):
	
	return self.c.canContractSubheads()
</t>
<t tx="T392">def OnUpdateCutNode(self):
	
	return self.c.canCutOutline()
</t>
<t tx="T393">def OnUpdateDeleteNode(self):
	
	return self.c.canDeleteHeadline()
</t>
<t tx="T394">def OnUpdateDemote(self):
	
	return self.c.canDemote()
</t>
<t tx="T395">def OnUpdateExpandAll(self):
	
	return self.c.canExpandAllHeadlines()

</t>
<t tx="T396">def OnUpdateExpandAllChildren(self):

	return self.c.canExpandAllSubheads()
</t>
<t tx="T397">def OnUpdateExpandChildren(self):

	return self.c.canExpandAllSubheads()
</t>
<t tx="T398">def OnUpdateGoBack(self):

	return self.c.canSelectThreadBack()
</t>
<t tx="T399">def OnUpdateGoNext(self):

	return self.c.canSelectThreadNext()
</t>
<t tx="T400">def OnUpdateGoNextVisible(self):

	return self.c.canSelectVisNext()
</t>
<t tx="T401">def OnUpdateGoPrevVisible(self):

	return self.c.canSelectVisBack()
</t>
<t tx="T402">def OnUpdateGoToNextChanged(self):

	return self.c.canGoToNextDirtyHeadline()
</t>
<t tx="T403">def OnUpdateGoToNextMarked(self):

	return self.c.canGoToNextMarkedHeadline()
</t>
<t tx="T404">def OnUpdateMark(self):
	
	v = self.c.currentVnode()
	s = choose(v and v.isMarked(),"Unmark","Mark")
	self.updateMenuItem.SetText(s)</t>
<t tx="T405">def OnUpdateMarkChangedItems(self):

	return self.c.canMarkChangedHeadlines()
</t>
<t tx="T406">def OnUpdateMarkChangedRoots(self):

	return self.c.canMarkChangedRoots()
</t>
<t tx="T407">def OnUpdateMarkSubheads(self):

	v = self.c.currentVnode()
	return v and v.hasChildren()
</t>
<t tx="T408">def OnUpdateMoveDown(self):

	return self.c.canMoveOutlineDown()
</t>
<t tx="T409">def OnUpdateMoveLeft(self):

	return self.c.canMoveOutlineLeft()
</t>
<t tx="T410">def OnUpdateMoveRight(self):

	return self.c.canMoveOutlineRight()
</t>
<t tx="T411">def OnUpdateMoveUp(self):

	return self.c.canMoveOutlineUp()
</t>
<t tx="T412">def OnUpdatePasteNode(self):

	return self.c.canPasteOutline()
</t>
<t tx="T413">def OnUpdatePromote(self):

	return self.c.canPromote()
</t>
<t tx="T414">def OnUpdateSortNode(self):

	return self.c.canSort()
</t>
<t tx="T415"></t>
<t tx="T416"></t>
<t tx="T417">def OnNew(self,event):
	
	c,frame = app.gui.newLeoCommanderAndFrame(fileName=None)
	doHook("new",old_c=self,new_c=c)

	frame.setInitialWindowGeometry()
	frame.deiconify()
	frame.lift()
	frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
	
	c.beginUpdate()
	t = leoNodes.tnode()
	v = leoNodes.vnode(c,t)
	v.initHeadString("NewHeadline")
	v.moveToRoot()
	c.editVnode(v)
	c.endUpdate()
	
	set_focus(c,frame.body)</t>
<t tx="T418">def OnOpen(self,event):

	# Create the Open dialog.
	d = wx.wxFileDialog(
		None,"Choose a Leo file",
		"",# default directory
		"",# default file
		"*.leo",# wildcard
		wx.wxOPEN | wx.wxMULTIPLE, # style of dialog.
		wx.wxDefaultPosition)

	if d.ShowModal()== wx.wxID_OK:
		for path in d.GetPaths():
			openWithFileName(path)</t>
<t tx="T419">def OnClose(self,event):

	# Close the frame,giving the close handler a chance to veto.
	self.Close()
</t>
<t tx="T420"># Most of this code is common code.  Only the dialog stuff is unique to wx.

def OnSave(self,event):
	
	c = self.commands

	if c.mFileName:
		c.fileCommands.save(c.mFileName)
		c.setChanged(false)
		return
	else:
		c.mFileName = ""

	d = wx.wxFileDialog(None,"Save",
		(""),        # default directory
		c.mFileName, # default file
		("*.leo"),   # wildcard
		wx.wxSAVE | wx.wxOVERWRITE_PROMPT,
		wx.wxDefaultPosition)
		
	# Tk allows the following params...
		# filetypes=[("Leo files", "*.leo")],
		# defaultextension=".leo")

	if d.ShowModal()== wxID_OK:
		fileName = d.GetPath()
		if fileName &gt; 0:
			c.mFileName = ensure_extension(fileName, ".leo")
			self.title = c.mFileName
			self.SetLabel(computeWindowTitle(c.mFileName))
			c.fileCommands.save(c.mFileName)
			self.updateRecentFiles(c.mFileName)</t>
<t tx="T421">def OnSaveAs(self,event):
		
	c = self.commands

	# Make sure we never pass None to the ctor.
	if not c.mFileName:
		c.mFileName = ""
		
	d = wx.wxFileDialog(None,"Save As",
		(""),      # default directory
		c.mFileName, # default file
		("*.leo"), # wildcard
		wx.wxSAVE | wx.wxOVERWRITE_PROMPT,
		wx.wxDefaultPosition)

	if d.ShowModal()== wx.wxID_OK:
		fileName = d.GetPath()
		if fileName:
			c.mFileName = ensure_extension(fileName, ".leo")
			self.title = c.mFileName
			self.SetLabel(computeWindowTitle(c.mFileName))
			self.commands.fileCommands.saveAs(c.mFileName)
			self.updateRecentFiles(c.mFileName)</t>
<t tx="T422">def OnSaveTo(self,event):

	c = self.commands

	# Make sure we never pass None to the ctor.
	if not c.mFileName:
		c.mFileName = ""
		
	d = wx.wxFileDialog(None,"Save To",
		(""),        # default directory
		c.mFileName, # default file
		("*.leo"),   # wildcard
		wx.wxSAVE | wx.wxOVERWRITE_PROMPT,
		wx.wxDefaultPosition)

	if d.ShowModal()== wx.wxID_OK:
		fileName = d.GetPath()
		if fileName:
			fileName = ensure_extension(fileName, ".leo")
			self.commands.fileCommands.saveTo(fileName)
			self.updateRecentFiles(c.mFileName)</t>
<t tx="T423">def OnRevert(self,event):
	
	c = self.c ; fileName = c.mFileName

	# Make sure the user wants to Revert.
	prompt = "Revert to previous version of %s?" % fileName
	answer = wx.wxMessageBox(prompt,"Revert to saved?", wx.wxYES_NO)
	if answer == wx.wxNO: return
	
	# Kludge: rename this frame so OpenWithFileName won't think it is open.
	c.mFileName = ""

	# Create a new frame before deleting this frame.
	frame = openWithFileName(fileName)

	# Delete the form.
	self.reverting = true  # Indicate that no prompt is needed.
	self.Close()
	self.reverting = false

	# Bring the already-opened frame to the front.
	frame.Show(false)
	frame.Show(true)
</t>
<t tx="T424">def OnPageSetup(self,event):
	pass
</t>
<t tx="T425">def OnPrint(self,event):
	pass
</t>
<t tx="T426">def OnTangleSubmenu(self,event):
	pass</t>
<t tx="T427">def OnUntangleSubmenu(self,event):
	pass</t>
<t tx="T428">def OnImportExportSubmenu(self,event):
	pass</t>
<t tx="T429">def OnQuit(self,event):

	self.quitting = true

	# Closing all windows terminates Leo.  Stop if the user aborts.
	while app.windowList:
		w = app.windowList[0]
		if not w.Close():
			break # User cancelled a close.

	self.quitting = false</t>
<t tx="T430">def OnReadOutlineOnly(self,event):

	d = wxFileDialog(
		None,"Choose a Leo file",
		"",# default directory
		"",# default file
		"*.leo",# wildcard
		wxOPEN | wxMULTIPLE, # style of dialog.
		wxDefaultPosition)

	if d.ShowModal()== wxID_OK:
		paths = d.GetPaths(paths)
		count = paths.Count()
		for i in xrange(count):
			self.readOutlineOnly(paths.Item(i))
</t>
<t tx="T431">def readOutlineOnly(self,fileName):

	# Don't take an exception if the file doesn't exist.
	if not os.path.exists(fileName):
		es("Can not open: " + fileName)
		return
	try:
		frame = LeoFrame()
		frame.self.c.readOutlineOnly(fileName)
		frame.Show(true)
		frame.c.fileName = fileName
		self.activeFrame = frame
	except:
		es("Error opening: " + fileName)
</t>
<t tx="T432">def OnReadAtFileNodes(self,event):
	self.c.readAtFileNodes()
</t>
<t tx="T433">def OnWriteOutlineOnly(self,event):
	self.c.writeOutlineOnly()
</t>
<t tx="T434">def OnWriteAtFileNodes(self,event):
	self.c.writeAtFileNodes()
</t>
<t tx="T435">def OnTangleAll(self,event):
	self.c.tangleAll()
</t>
<t tx="T436">def OnTangleMarked(self,event):
	self.c.tangleMarked()
</t>
<t tx="T437">def OnTangle(self,event):
	self.c.tangle()
</t>
<t tx="T438">def OnUntangleAll(self,event):
	self.c.untangleAll()
</t>
<t tx="T439">def OnUntangleMarked(self,event):
	self.c.untangleMarked()
</t>
<t tx="T440">def OnUntangle(self,event):
	self.c.untangle()
</t>
<t tx="T441">def OnImportFiles(self,event):

	d = wxFileDialog(
		None,"Import Files",
		"",# default directory
		"",# default file
		"*.*",# wildcard
		wxOPEN | wxMULTIPLE | wxFILE_MUST_EXIST, # style of dialog.
		wxDefaultPosition)

	if d.ShowModal()== wxID_OK:
		paths = d.GetPaths(paths)
		self.c.ImportFilesCommand(paths)
</t>
<t tx="T442">def OnImportCWEBFiles(self,event):
	
	d = wxFileDialog(
		None,"Import CWEB Files",
		"",# default directory
		"",# default file
		"*.*",# wildcard
		wxOPEN | wxMULTIPLE | wxFILE_MUST_EXIST, # style of dialog.
		wxDefaultPosition)

	if d.ShowModal()== wxID_OK:
		paths = d.GetPaths(paths)
		self.c.CWEBToOutlineCommand(paths)
</t>
<t tx="T443">def OnImportNowebFiles(self,event):
	pass
</t>
<t tx="T444">def OnImportMoreText(self,event):

	d = wxFileDialog(
		None,"Import MORE Text",
		"",# default directory
		"",# default file
		"*.*",# wildcard
		wxOPEN | wxFILE_MUST_EXIST, # style of dialog.
		wxDefaultPosition)

	if d.ShowModal()== wxID_OK:
		paths = d.GetPaths(paths)
		self.c.importMoreText(paths)
</t>
<t tx="T445">def OnFlattenOutline(self,event):

	d = wxFileDialog(
		None,"Flatten Outline",
		"",# default directory
		"flat.txt",# default file
		"*.*",# wildcard
		wxSAVE | wxOVERWRITE_PROMPT, # style of dialog.
		wxDefaultPosition)

	if d.ShowModal()== wxID_OK:
		paths = d.GetPaths(paths)
		self.c.flattenOutline(paths)
</t>
<t tx="T446"></t>
<t tx="T447">def OnUndo(self,event):
	
	w = self.FindFocus()
	# FindFocus seems to be a bit flakey,so use it only when absolutely needed.
	if w == self.tree:
		self.c.undo()
	elif wx.wxPlatform != "__WXGTK__": # text control does not support undo/redo on wxGTK
		if self.body and self.body.CanUndo():
			self.body.Undo()
</t>
<t tx="T448">def OnRedo(self,event):
	
	# The tree control does not support redo.
	if wx.wxPlatform != "__WXGTK__": # text control does not support undo/redo on wxGTK
		if  self.body and self.body.CanRedo():
			self.body.Redo()</t>
<t tx="T449">def OnCut(self,event):
	w = self.FindFocus()
	if w and w == self.body:
		self.body. Cut()
	elif w and w == mLogCtrl:
		mLogCtrl. Cut()
</t>
<t tx="T450">def OnCopy(self,event):
	w = self.FindFocus()
	if w and w == self.body:
		self.body. Copy()
	elif w and w == mLogCtrl:
		mLogCtrl. Copy()
</t>
<t tx="T451">def OnPaste(self,event):
	w = self.FindFocus()
	if w and w == self.body:
		self.body. Paste()
	elif w and w == mLogCtrl:
		mLogCtrl. Paste()
</t>
<t tx="T452">def OnDelete(self,event):

	if self.body:
		start,end = self.body.GetSelection()
		if start &lt; end:
			self.body.Remove(start,end)
		else:
			self.body.Remove(end,start)
</t>
<t tx="T453">def OnSelectAll(self,event):
	w = self.FindFocus()
	if w == self.body:
		to = self.body.GetLastPosition()
		self.body.SetSelection(0,to)
	elif w == mLogCtrl:
		to = mLogCtrl.GetLastPosition()
		mLogCtrl.SetSelection(0,to)
</t>
<t tx="T454">def OnEditHeadline(self,event):

	if wx.wxPlatform != "__WXMSW__": # EditLabel is buggy.  Hitting a control key or tab will crash.
		item = self.tree.GetSelection()
		if item:
			self.tree.EditLabel(item)</t>
<t tx="T455">def OnFontPanel(self,event):

	data = None
	data.SetInitialFont(self.body.GetFont())
	data.SetColour(self.body.GetForegroundColour())
	dialog = wxFontDialog(self,data)
	if wx.wxPlatform != "__WXGTK__": # Causes problems on GTK+ version of wxWindows.
		dialog.CentreOnScreen()
	if dialog.ShowModal()!= wxID_OK: return
	retData = dialog.GetFontData()
	font = retData.GetChosenFont()
	color = retData.GetColour()
	# On Linux, SetFont apparently clears the text control's text string!
	if wx.wxPlatform == "__WXGTK__":
		contents = self.body.GetValue()
		self.body.SetFont(font)
		self.body.SetForegroundColour(color)
		self.body.SetValue(contents)
	else:
		self.body.SetFont(font)
		self.body.SetForegroundColour(color)
	self.Refresh()
	trace("font_info:face: %s, family: %s\nsize: %d, style: %s, weight: %s" %
		(font.GetFaceName(), font.GetFamilyString(),
		font.GetPointSize(), font.GetStyleString(), font.GetWeightString()))</t>
<t tx="T456">def OnSyntaxColoring(self,event):
	pass
</t>
<t tx="T457">def OnPreferences(self,event):

	if gPrefsFrame == None:
		gPrefsFrame = PrefsFrame()
		gPrefsFrame.initialize()
	gPrefsFrame.CenterOnScreen()
	gPrefsFrame.Show(true)
	gPrefsFrame.Raise()
</t>
<t tx="T458">def OnConvertBlanks(self,event):
	self.c.convertBlanks()
</t>
<t tx="T459">def OnExtractSection(self,event):
	self.c.extractSection()
</t>
<t tx="T460">def OnExtractNames(self,event):
	self.c.extractSectionNames()
</t>
<t tx="T461">def OnExtract(self,event):
	self.c.extract()
</t>
<t tx="T462">def OnFindPanel(self,event):

	# On windows,this activates the frame.
	app.findFrame.Show()
	app.findFrame.Raise()
</t>
<t tx="T463">def OnFindNext(self,event):
	self.c.doFindNextCommand()
</t>
<t tx="T464">def OnFindPrevious(self,event):
	self.c.doFindPreviousCommand()
</t>
<t tx="T465">def OnReplace(self,event):
	self.c.doChangeCommand()
</t>
<t tx="T466">def OnReplaceThenFind(self,event):
	self.c.doChangeThenFindCommand()
</t>
<t tx="T467"></t>
<t tx="T468"></t>
<t tx="T469">def OnCutNode(self,event):
	self.c.cutOutline()
</t>
<t tx="T470">def OnCopyNode(self,event):
	self.c.copyOutline()
</t>
<t tx="T471">def OnPasteNode(self,event):
	self.c.pasteOutline()
</t>
<t tx="T472"></t>
<t tx="T473">def OnExpandAll(self,event):
	self.c.expandAllHeadlines()
</t>
<t tx="T474">def OnExpandAllChildren(self,event):
	self.c.expandAllSubheads()
</t>
<t tx="T475">def OnExpandChildren(self,event):
	self.c.expandSubheads()
</t>
<t tx="T476">def OnContractAll(self,event):
	self.c.contractAllHeadlines()
</t>
<t tx="T477">def OnContractAllChildren(self,event):
	self.c.contractAllSubheads()
</t>
<t tx="T478">def OnContractChildren(self,event):
	self.c.contractSubheads()
</t>
<t tx="T479">def OnExpandNextLevel(self,event):
	self.c.expandNextLevel()
</t>
<t tx="T480">def OnExpandToLevel1(self,event):
	self.c.expandLevel1()
</t>
<t tx="T481">def OnExpandToLevel2(self,event):
	self.c.expandLevel2()
</t>
<t tx="T482">def OnExpandToLevel3(self,event):
	self.c.expandLevel3()
</t>
<t tx="T483">def OnExpandToLevel4(self,event):
	self.c.expandLevel4()
</t>
<t tx="T484">def OnExpandToLevel5(self,event):
	self.c.expandLevel5()
</t>
<t tx="T485">def OnExpandToLevel6(self,event):
	self.c.expandLevel6()
</t>
<t tx="T486">def OnExpandToLevel7(self,event):
	self.c.expandLevel7()
</t>
<t tx="T487">def OnExpandToLevel8(self,event):
	self.c.expandLevel8()
</t>
<t tx="T488">def OnExpandToLevel9(self,event):
	self.c.expandLevel9()
</t>
<t tx="T489"></t>
<t tx="T490">def OnDeleteNode(self,event):
	self.c.deleteHeadline()
</t>
<t tx="T491">def OnInsertNode(self,event):
	self.c.insertHeadline()
</t>
<t tx="T492">def OnCloneNode(self,event):
	self.c.clone()
</t>
<t tx="T493"></t>
<t tx="T494">def OnGoPrevVisible(self,event):
	self.c.moveOutlineUp()
</t>
<t tx="T495">def OnGoNextVisible(self,event):
	self.c.selectVisNext()
</t>
<t tx="T496">def OnGoBack(self,event):
	self.c.selectThreadBack()
</t>
<t tx="T497">def OnGoNext(self,event):
	self.c.selectThreadNext()
</t>
<t tx="T498">def OnMark(self,event):
	self.c.markHeadline()
</t>
<t tx="T499">def OnMarkSubheads(self,event):
	self.c.markSubheads()
</t>
<t tx="T500">def OnMarkChangedItems(self,event):
	self.c.markChangedHeadlines()
</t>
<t tx="T501">def OnMarkChangedRoots(self,event):
	self.c.markChangedRoots()
</t>
<t tx="T502">def OnMarkAllAtFileNodesDirty(self,event):
	self.c.markAllAtFileNodesDirty()
</t>
<t tx="T503">def OnMarkAtFileNodesDirty(self,event):
	self.c.markAtFileNodesDirty()
</t>
<t tx="T504">def OnUnmarkAll(self,event):
	self.c.unmarkAll()
</t>
<t tx="T505">def OnGoToNextMarked(self,event):
	self.c.goToNextMarkedHeadline()
</t>
<t tx="T506">def OnGoToNextChanged(self,event):
	self.c.goToNextDirtyHeadline()
</t>
<t tx="T507"></t>
<t tx="T508">def OnMoveDown(self,event):
	self.c.moveOutlineDown()
</t>
<t tx="T509">def OnMoveLeft(self,event):
	self.c.moveOutlineLeft()
</t>
<t tx="T510">def OnMoveRight(self,event):
	self.c.moveOutlineRight()
</t>
<t tx="T511">def OnMoveUp(self,event):
	self.c.moveOutlineUp()
</t>
<t tx="T512">def OnPromote(self,event):
	self.c.promote()
</t>
<t tx="T513">def OnDemote(self,event):
	self.c.demote()
</t>
<t tx="T514"></t>
<t tx="T515">def OnSortNode(self,event):
	self.c.sort()
</t>
<t tx="T516"></t>
<t tx="T517">def OnEqualSizedPanes(self,event):
	self.c.equalSizedPanes()
</t>
<t tx="T518">def OnToggleActivePane(self,event):
	w = self.FindFocus()
	if w == None or w == self.tree:
		self.body.SetFocus()
	else:
		self.tree.SetFocus()
</t>
<t tx="T519">def OnChangeDirection(self,event):

	mode = self.splitter1.GetSplitMode()
	self.splitter1.Unsplit()# Hides the text control.
	if  mode == wxSPLIT_VERTICAL:
		self.splitter1.SplitHorizontally(self.tree,self.body,0)
	else:
		self.splitter1.SplitVertically(self.tree,self.body,0)
	self.body.Show()
	self.body.SetFocus()
</t>
<t tx="T520">def OnCascade(self,event):
	
	p = wx.wxPoint(10,10)
	for f in app.windowList:
		f.Move(p)
		p.x += 30
		p.y += 30
		if p.x &gt; 200:
			p.x = 10
			p.y = 40</t>
<t tx="T521">def OnMinimizeAll(self,event):

	# trace(app.windowList)
	for w in app.windowList:
		w.Iconize(true)
		
	if app.findFrame:
		app.findFrame.Iconize()
	
	if 0: # old code
		if gPrefsFrame:
			gPrefsFrame.Iconize()
		if app.findFrame:
			app.findFrame.Iconize()
		if gPythonFrame:
			gPythonFrame.Iconize()</t>
<t tx="T522">if wx.wxPlatform == "__WXMSW__":
	
	pass

	#void LeoFrame::OnOpenPythonWindow(wxCommandEvent&amp; WXUNUSED(event))
	#gPythonFrame = wxPythonFrame::create((char *)"leoc",(char *)"leo",(void(*)())initleoc)
	#gPythonFrame.Show(true)</t>
<t tx="T523">def OnRecentWindows(self,event):
	pass
</t>
<t tx="T524"></t>
<t tx="T525">def OnAbout(self,event=None):
	
	message = u"\n\
Leo Version 4.0, October 11, 2003\n\
\n\
Copyright  2001 by Edward K. Ream\n\
All Rights Reserved \n\
Leo is distributed under the Python License"

	wx.wxMessageBox(message,"About Leo",wx.wxCenter,self)</t>
<t tx="T526"></t>
<t tx="T527">class wxFindFrame (wx.wxFrame):

	&lt;&lt; FindPanel public globals &gt;&gt;

	@others</t>
<t tx="T528">reset_search_flag = None
batch_flag = None
wrap_flag = None
whole_word_flag = None
ignore_case_flag = None
pattern_match_flag = None
search_headline_flag = None
search_body_flag = None
suboutline_only_flag = None
mark_changes_flag = None
mark_finds_flag = None
reverse_flag = None
find_text = ""
change_text = ""
</t>
<t tx="T529">def __init__ (self):

	# Init the base class
	wx.wxFrame.__init__(self,None,-1,"Leo Find/Change",
		wx.wxPoint(50,50), wx.wxDefaultSize,
		wx.wxMINIMIZE_BOX | wx.wxTHICK_FRAME | wx.wxSYSTEM_MENU | wx.wxCAPTION)

	self.findPanel = wxFindPanel(self)

	# Resize to fit the panel.
	sizer = wx.wxBoxSizer(wx.wxVERTICAL)
	sizer.Add(self.findPanel)
	self.SetAutoLayout(true)# tell dialog to use sizer
	self.SetSizer(sizer) # actually set the sizer
	sizer.Fit(self)# set size to minimum size as calculated by the sizer
	sizer.SetSizeHints(self)# set size hints to honour mininum size

	# Set the window icon.
	if wx.wxPlatform == '__WXMSW__':
		pass ## self.SetIcon(wx.wxIcon("LeoIcon"))

	# Set the focus.
	self.findPanel.findText.SetFocus()
		
	&lt;&lt; declare event handlers &gt;&gt;
</t>
<t tx="T530">if wx.wxPlatform == "__WXMSW__": # Activate events exist only on windows.
	pass ## wx.EVT_ACTIVATE(self.OnActivateFindFrame)
else:
	wx.EVT_SET_FOCUS(self.OnSetFocus)

## wx.EVT_CLOSE(self.OnCloseFindFrame)

for name,command in (
	("cChangeButton",self.OnChangeButton),
	("cChangeAllButton",self.OnChangeAllButton),
	("cChangeThenFindButton",self.OnChangeThenFindButton),
	("cFindButton",self.OnFindButton),
	("cFindAllButton",self.OnFindAllButton)):
	
	wx.EVT_BUTTON(self,const(name),command)
	
for name,command in (
	("cBatchCheckBox",self.OnBatchCheckBox),
	("cIgnoreCaseCheckBox",self.OnIgnoreCaseCheckBox),
	("cMarkChangesCheckBox",self.OnMarkChangesCheckBox),
	("cMarkFindsCheckBox",self.OnMarkFindsCheckBox),
	("cPatternMatchCheckBox",self.OnPatternMatchCheckBox),
	("cReverseCheckBox",self.OnReverseCheckBox),
	("cSearchHeadlineCheckBox",self.OnSearchHeadlineCheckBox),
	("cSearchBodyTextCheckBox",self.OnSearchBodyTextCheckBox),
	("cSuboutlineOnlyCheckBox",self.OnSuboutlineOnlyCheckBox),
	("cWrapAroundCheckBox",self.OnWrapAroundCheckBox),
	("cWholeWordCheckBox",self.OnWholeWordCheckBox)):
	
	wx.EVT_CHECKBOX(self,const(name),command)
	
for name,command in (
	("cFindTextCtrl",self.OnFindText),
	("cChangeTextCtrl",self.OnChangeText)):
	
	wx.EVT_TEXT(self,const(name),command)

if 0:
	wx.EVT_BUTTON(self,cChangeButton,self.OnChangeButton)
	wx.EVT_BUTTON(self,cChangeAllButton,self.OnChangeAllButton)
	wx.EVT_BUTTON(self,cChangeThenFindButton,self.OnChangeThenFindButton)
	wx.EVT_BUTTON(self,cFindButton,self.OnFindButton)
	wx.EVT_BUTTON(self,cFindAllButton,self.OnFindAllButton)
	
	wx.EVT_CHECKBOX(self,cBatchCheckBox,self.OnBatchCheckBox)
	wx.EVT_CHECKBOX(self,cIgnoreCaseCheckBox,self.OnIgnoreCaseCheckBox)
	wx.EVT_CHECKBOX(self,cMarkChangesCheckBox,self.OnMarkChangesCheckBox)
	wx.EVT_CHECKBOX(cMarkFindsCheckBox,self.OnMarkFindsCheckBox)
	wx.EVT_CHECKBOX(cPatternMatchCheckBox,self.OnPatternMatchCheckBox)
	wx.EVT_CHECKBOX(cReverseCheckBox,self.OnReverseCheckBox)
	wx.EVT_CHECKBOX(cSearchHeadlineCheckBox,self.OnSearchHeadlineCheckBox)
	wx.EVT_CHECKBOX(cSearchBodyTextCheckBox,self.OnSearchBodyTextCheckBox)
	wx.EVT_CHECKBOX(cSuboutlineOnlyCheckBox,self.OnSuboutlineOnlyCheckBox)
	wx.EVT_CHECKBOX(cWrapAroundCheckBox,self.OnWrapAroundCheckBox)
	wx.EVT_CHECKBOX(cWholeWordCheckBox,self.OnWholeWordCheckBox)
	wx.EVT_TEXT(cFindTextCtrl,self.OnFindText)
	wx.EVT_TEXT(cChangeTextCtrl,self.OnChangeText)</t>
<t tx="T531"></t>
<t tx="T532">if wx.wxPlatform == "__WXMSW__": # This event exists only on Windows.

	def OnActivateFindFrame(self,event):
		if event.GetActive():
			self.set_check_boxes()
			c = self.findPanel.self.findText
			s = c.GetValue()
			c.SetFocus()
			c.SetSelection(0,s.Length())
else:
	def OnSetFocus(self,event):
		self.set_check_boxes()
		c = self.findPanel.self.findText
		s = c.GetValue()
		c.SetFocus()
		c.SetSelection(0,s.Length())</t>
<t tx="T533">@ This is an event handler function called when the user has tried to close a frame or dialog box.

It is called via the wxWindow::Close function,so that the application can also invoke the handler programmatically.
You should check whether the application is forcing the deletion of the window using CanVeto.

If CanVeto returns FALSE,it is not possible to skip window deletion; destroy the window using wxWindow::Destroy.
If not,it is up to you whether you respond by destroying the window.

If you don't destroy the window,you should call wxCloseEvent::Veto to let the calling code know that you did not destroy the window. This allows the wxWindow::Close function to return TRUE or FALSE depending on whether the close instruction was honoured or not.
@c

def OnCloseFindFrame(self,event):
	
	if event.CanVeto():
		event.Veto()     # Did not destroy the window.
		self.Show(false) # Just hide the window.
	else:
		self.Destroy()
		app.findFrame = None
</t>
<t tx="T534">def OnChangeButton(self,event):

	if self.activeFrame:
		self.activeFrame.c.doChangeButton()
</t>
<t tx="T535">def OnChangeAllButton(self,event):
	if self.activeFrame:
		self.activeFrame.c.doChangeAllButton()
</t>
<t tx="T536">def OnChangeThenFindButton(self,event):
	if self.activeFrame:
		self.activeFrame.c.doChangeThenFindButton()
</t>
<t tx="T537">def OnFindButton(self,event):
	# This is the default button,so make sure there is find text.
	if  self.activeFrame and find_text.Length()&gt; 0:
		self.activeFrame.c.doFindButton()
</t>
<t tx="T538">def OnFindAllButton(self,event):
	if self.activeFrame:
		self.activeFrame.c.doFindAllButton()
</t>
<t tx="T539">def OnBatchCheckBox(self,event):
	box = event.GetEventObject()
	batch_flag = box.GetValue()
</t>
<t tx="T540">def OnIgnoreCaseCheckBox(self,event):
	box = event.GetEventObject()
	ignore_case_flag = box.GetValue()
	if self.activeFrame:
		self.activeFrame.c.setup(true)# reset the search.
</t>
<t tx="T541">def OnMarkChangesCheckBox(self,event):
	box = event.GetEventObject()
	mark_changes_flag = box.GetValue()
</t>
<t tx="T542">def OnMarkFindsCheckBox(self,event):
	box = event.GetEventObject()
	mark_finds_flag = box.GetValue()
</t>
<t tx="T543">def OnPatternMatchCheckBox(self,event):
	box = event.GetEventObject()
	pattern_match_flag = box.GetValue()
	if self.activeFrame:
		self.activeFrame.c.setup(true)# reset the search.
</t>
<t tx="T544">def OnReverseCheckBox(self,event):
	box = event.GetEventObject()
	reverse_flag = box.GetValue()
</t>
<t tx="T545">def OnSearchBodyTextCheckBox(self,event):
	box = event.GetEventObject()
	search_body_flag = box.GetValue()
	if self.activeFrame:
		self.activeFrame.c.setup(true)# reset the search.
</t>
<t tx="T546">def OnSearchHeadlineCheckBox(self,event):
	box = event.GetEventObject()
	search_headline_flag = box.GetValue()
</t>
<t tx="T547">def OnSuboutlineOnlyCheckBox(self,event):
	box = event.GetEventObject()
	suboutline_only_flag = box.GetValue()
</t>
<t tx="T548">def OnWrapAroundCheckBox(self,event):
	box = event.GetEventObject()
	wrap_flag = box.GetValue()
</t>
<t tx="T549">def OnWholeWordCheckBox(self,event):
	
	box = event.GetEventObject()
	whole_word_flag = box.GetValue()
	if self.activeFrame:
		self.activeFrame.c.setup(true)# reset the search.

</t>
<t tx="T550">def OnChangeText(self,event):
	text = event.GetEventObject()
	change_text = text.GetValue()
	if self.activeFrame:
		self.activeFrame.c.setup(true)# reset the search.
</t>
<t tx="T551">def OnFindText(self,event):
	text = event.GetEventObject()
	find_text = text.GetValue()
	if self.activeFrame:
		self.activeFrame.c.setup(true)# reset the search.
</t>
<t tx="T552">def set_ivars (self, *args, **keys):
	
	trace(*args,**keys)</t>
<t tx="T553">def set_check_boxes(self,void):

	self.findPanel.mBatchCheckBox.SetValue(batch_flag)
	self.findPanel.mWrapAroundCheckBox.SetValue(wrap_flag)
	self.findPanel.mWholeWordCheckBox.SetValue(whole_word_flag)
	self.findPanel.mIgnoreCaseCheckBox.SetValue(ignore_case_flag)
	self.findPanel.mPatternMatchCheckBox.SetValue(pattern_match_flag)
	self.findPanel.mSearchHeadlineCheckBox.SetValue(search_headline_flag)
	self.findPanel.mSearchBodyTextCheckBox.SetValue(search_body_flag)
	self.findPanel.mSuboutlineOnlyCheckBox.SetValue(suboutline_only_flag)
	self.findPanel.mMarkChangesCheckBox.SetValue(mark_changes_flag)
	self.findPanel.mMarkFindsCheckBox.SetValue(mark_finds_flag)
	self.findPanel.mReverseCheckBox.SetValue(reverse_flag)
	self.findPanel.findText.SetValue(find_text)
	self.findPanel.changeText.SetValue(change_text)</t>
<t tx="T554">class wxFindPanel (wx.wxPanel):

	@others</t>
<t tx="T555">def __init__(self,frame):
	 
	# Init the base class.
	wx.wxPanel.__init__(self,frame,-1)

	topSizer = wx.wxBoxSizer(wx.wxVERTICAL)
	topSizer.Add(0,10)

	&lt;&lt; Create the find text box &gt;&gt;
	&lt;&lt; Create the change text box &gt;&gt;
	&lt;&lt; Create all the find check boxes &gt;&gt;
	&lt;&lt; Create all the find buttons &gt;&gt;

	self.SetAutoLayout(true) # tell dialog to use sizer
	self.SetSizer(topSizer) # actually set the sizer
	topSizer.Fit(self)# set size to minimum size as calculated by the sizer
	topSizer.SetSizeHints(self)# set size hints to honour mininum size</t>
<t tx="T556">findSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
findSizer.Add(5,5)# Extra space.

# Label.
findSizer.Add(
	wx.wxStaticText(self,-1,"Find:",
		wx.wxPoint(-1,10), wx.wxSize(50,25),0,""),
	0, wx.wxBORDER | wx.wxTOP,15) # Vertical offset.

findSizer.Add(10,0) # Width.

# Text.
self.findText = wx.wxTextCtrl(self,
	const("cFindTextCtrl"),"",
	wx.wxDefaultPosition, wx.wxSize(300,60),
	wx.wxTE_PROCESS_TAB | wx.wxTE_MULTILINE,
	wx.wxDefaultValidator,"")

findSizer.Add(self.findText)
findSizer.Add(5,0)# Width.
topSizer.Add(findSizer)
topSizer.Add(0,10)</t>
<t tx="T557">changeSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
changeSizer.Add(5,5)# Extra space.

# Label.
changeSizer.Add(
	wx.wxStaticText(self,-1,"Change:",
		wx.wxPoint(-1,10),wx.wxSize(50,25),0,""),
	0, wx.wxBORDER | wx.wxTOP,15)# Vertical offset.

changeSizer.Add(10,0) # Width.

# Text.
self.changeText = wx.wxTextCtrl(self,
	const("cChangeTextCtrl"),"",
	wx.wxDefaultPosition, wx.wxSize(300,60),
	wx.wxTE_PROCESS_TAB | wx.wxTE_MULTILINE,
	wx.wxDefaultValidator,"")

changeSizer.Add(self.changeText)
changeSizer.Add(5,0)# Width.
topSizer.Add(changeSizer)
topSizer.Add(0,10)</t>
<t tx="T558">col1Sizer = wx.wxBoxSizer(wx.wxVERTICAL)
&lt;&lt; Create the first column of check boxes &gt;&gt;

col2Sizer = wx.wxBoxSizer(wx.wxVERTICAL)
&lt;&lt; Create the second column of check boxes &gt;&gt;

# Pack the two columns
checkBoxSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
checkBoxSizer.Add(col1Sizer)
checkBoxSizer.Add(col2Sizer)
topSizer.Add(checkBoxSizer)
topSizer.Add(0,10)</t>
<t tx="T559">for ivar,cname,label in (
	("batchCheckBox","cBatchCheckBox","Batch"),
	("wrapAroundCheckBox","cWrapAroundCheckBox","Wrap Around"),
	("wholeWordCheckBox","cWholeWordCheckBox","Whole Word"),
	("ignoreCaseCheckBox","cIgnoreCaseCheckBox","Ignore Case"),
	("patternMatchCheckBox","cPatternMatchCheckBox","Pattern Match")
	):
	
	box = wx.wxCheckBox(
		self,const(cname),label,
		wx.wxDefaultPosition,(150,25),
		0,wx.wxDefaultValidator,"")
		
	setattr(self,ivar,box)
	col1Sizer.Add(box,0,wx.wxBORDER | wx.wxLEFT,50)</t>
<t tx="T560">for ivar,cname,label in (
	("searchHeadlineCheckBox","cSearchHeadlineCheckBox","Search Headline Text"),
	("searchBodyTextCheckBox","cSearchBodyTextCheckBox","Search Body Text"),
	("suboutlineOnlyCheckBox","cSuboutlineOnlyCheckBox","Suboutline Only"),
	("markChangesCheckBox","cMarkChangesCheckBox","Mark Changes"),
	("markFindsCheckBox","cMarkFindsCheckBox","Mark Finds")
	):
	
	box = wx.wxCheckBox(
		self,const(cname),label,
		wx.wxDefaultPosition,(150,25),
		0,wx.wxDefaultValidator,"")

	setattr(self,ivar,box)
	col2Sizer.Add(box)</t>
<t tx="T561"># The row sizers are a bit dim:  they should distribute the buttons automatically.

row1Sizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
&lt;&lt; Create the first row of buttons &gt;&gt;

row2Sizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
&lt;&lt; Create the second row of buttons &gt;&gt;

# Pack the two rows
buttonSizer = wx.wxBoxSizer(wx.wxVERTICAL)
buttonSizer.Add(row1Sizer)
buttonSizer.Add(0,10)
buttonSizer.Add(row2Sizer)
topSizer.Add(buttonSizer)
topSizer.Add(0,10)</t>
<t tx="T562">row1Sizer.Add(20,0)

for ivar,cname,label,size,adj in (
	("findButton","cFindButton","Find",(80,25),None),
	("reverseCheckBox","cReverseCheckBox","Reverse",(100,25),(24,0)),
	("findAllButton","cFindAllButton","Find All",(80,25),None)):
	
	button = wx.wxButton(
		self,const(cname),label,
		wx.wxDefaultPosition,size,
		0,wx.wxDefaultValidator,"")
		
	setattr(self,ivar,button)
	row1Sizer.Add(button)
	if adj:
		row1Sizer.Add(adj)</t>
<t tx="T563">row2Sizer.Add(20,0)

for ivar,cname,label,size,adj in (
	("changeButton","cChangeButton","Change",(80,25),(24,0)),
	("changeThenFindButton","cChangeThenFindButton","Change,Then Find",(122,25),(24,0)),
	("changeAllButton","cChangeAllButton","Change All",(80,25),None)):
	
	button = wx.wxButton(
		self,const(cname),label,
		wx.wxDefaultPosition,size,
		0,wx.wxDefaultValidator,"")
		
	setattr(self,ivar,button)
	row2Sizer.Add(button)
	if adj:
		row2Sizer.Add(adj)</t>
<t tx="T564">class wxLeoPrefs (wx.wxFrame):
	@others
</t>
<t tx="T565">def __init__():
	
	# Init the base frame.
	wxFrame.__init__(None,-1,"Leo Preferences",
		wx.wxPoint(50,50),wxDefaultSize,
		wxMINIMIZE_BOX | wxTHICK_FRAME | wxSYSTEM_MENU | wxCAPTION)

	mPrefsPanel = PrefsPanel(self)

	# Resize to fit the panel.
	sizer = wxBoxSizer(wxVERTICAL)
	sizer.Add(mPrefsPanel)
	SetAutoLayout(true)# tell dialog to use sizer
	SetSizer(sizer) # actually set the sizer
	sizer.Fit(self)# set size to minimum size as calculated by the sizer
	sizer.SetSizeHints(self)# set size hints to honour mininum size

	# Set the window icon.
	if wx.wxPlatform == '__WXMSW__':
		self.SetIcon(wxIcon("LeoIcon"))
		
	&lt;&lt; define event handlers for wxLeoPrefsFrame &gt;&gt;</t>
<t tx="T566">wx.EVT_ACTIVATE(self,self.OnActivatePrefsFrame)
wx.EVT_CLOSE(self,self.OnClosePrefsFrame)

# Global options panel...
wx.EVT_TEXT(self,cPrefsPageWidthText,self.OnPageWidthText)
wx.EVT_CHECKBOX(self,cPrefsDoneBatCheckBox,self.OnDoneBatCheckBox)
wx.EVT_CHECKBOX(self,cPrefsUnBatCheckBox,self.OnUnBatCheckBox)

# Tangle options panel...
wx.EVT_TEXT(self,cPrefsTangleDirectoryText,self.OnTangleDirectoryText)
wx.EVT_CHECKBOX(self,cPrefsHeaderCheckBox,self.OnHeaderCheckBox)
wx.EVT_CHECKBOX(self,cPrefsDocChunksCheckBox,self.OnDocChunksCheckBox)

# Target language panel...
wx.EVT_RADIOBOX(self,cPrefsTargetLanguageRadioBox,self.OnTargetLanguageRadioBox)</t>
<t tx="T567">def initialize (self,void):
	
	# This may be called during construction.
	if not gPrefsFrame:  return
	s = ""
	if self.activeFrame:
		s += "%d" % self.activeFrame.mPageWidth
		mPrefsPanel.mPrefsPageWidthText.SetValue(s)
		mPrefsPanel.mPrefsDoneBatCheckBox.SetValue(self.activeFrame.mTangleBatchFlag)
		mPrefsPanel.mPrefsUnBatCheckBox.SetValue(self.activeFrame.mUntangleBatchFlag)
		mPrefsPanel.mPrefsTangleDirectoryText.SetValue(self.activeFrame.mDefaultDirectory)
		mPrefsPanel.mPrefsHeaderCheckBox.SetValue(self.activeFrame.mUseHeaderFlag)
		mPrefsPanel.mPrefsDocChunksCheckBox.SetValue(self.activeFrame.mOutputDocFlag)
		mPrefsPanel.mTargetLanguageRadioBox.SetSelection(languageToTarget(self.activeFrame.mTargetLanguage))
	else:
		s += "%d" % arg_page_width
		mPrefsPanel.mPrefsPageWidthText.SetValue(s)
		mPrefsPanel.mPrefsDoneBatCheckBox.SetValue(arg_tangle_batch)
		mPrefsPanel.mPrefsUnBatCheckBox.SetValue(arg_untangle_batch)
		# No global setting for director.
		mPrefsPanel.mPrefsHeaderCheckBox.SetValue(arg_use_header_flag)
		mPrefsPanel.mPrefsDocChunksCheckBox.SetValue(arg_output_doc_flag)
		mPrefsPanel.mTargetLanguageRadioBox.SetSelection(languageToTarget(arg_target_language))</t>
<t tx="T568">if 0:
	def targetToLanguage(self,target):
		
		pass

		# switch(target)
		# case c_target: return c_language
		# case cweb_target: return cweb_language
		# case html_target: return html_language
		# case java_target: return java_language
		# case perl_target: return perl_language
		# case perlpod_target: return perlpod_language
		# case pascal_target: return pascal_language
		# case plain_text_target: return plain_text_language
		# case python_target: return python_language
		# default: return plain_text_language
</t>
<t tx="T569">def languageToTarget(self,language):
	
	pass

	# switch(language)
	# case c_language: return c_target
	# case cweb_language: return cweb_target
	# case html_language: return html_target
	# case java_language: return java_target
	# case pascal_language: return pascal_target
	# case perl_language: return perl_target
	# case perlpod_language: return perlpod_target
	# case plain_text_language: return plain_text_target
	# case python_language: return python_target
	# default: return plain_text_target</t>
<t tx="T570"></t>
<t tx="T571">def OnActivatePrefsFrame(self,event):

	if gPrefsFrame and event.GetActive():
		gPrefsFrame.initialize()
</t>
<t tx="T572">@ This is an event handler function called when the user has tried to close a frame or dialog box.

It is called via the  wxWindow::Close function, so that the application can also invoke the handler programmatically.  You should check whether the application is forcing the deletion of the window using CanVeto. If CanVeto returns FALSE, it is  not possible to skip window deletion; destroy the window using wxWindow::Destroy. If not, it is up to you whether you respond  by destroying the window.  If you don't destroy the window, you should call wxCloseEvent::Veto to let the calling code know that you did not destroy the  window. This allows the wxWindow::Close function to return TRUE or FALSE depending on whether the close instruction was  honoured or not.
@c

def OnClosePrefsFrame(self,event):

	if event.CanVeto():
		event.Veto()# Did not destroy the window.
		self.Show(false) # Just hide the window.
	else:
		self.Destroy()
		gPrefsFrame = None
</t>
<t tx="T573">def OnPageWidthText(self,event):
	
	text = event.GetEventObject()
	s = text.GetValue()

	try:
		n = int(s)
		arg_page_width = default_page_width = n
		if self.activeFrame:
			self.activeFrame.mPageWidth = arg_page_width
	except: pass

</t>
<t tx="T574">def OnDoneBatCheckBox(self,event):
	
	box =event.GetEventObject()
	arg_tangle_batch = default_tangle_batch = box.GetValue()
	if self.activeFrame:
		self.activeFrame.mTangleBatchFlag = arg_tangle_batch

</t>
<t tx="T575">def OnUnBatCheckBox(self,event):
	
	box = event.GetEventObject()
	arg_untangle_batch = default_untangle_batch = box.GetValue()
	if self.activeFrame:
		self.activeFrame.mUntangleBatchFlag = arg_untangle_batch

</t>
<t tx="T576">def OnTangleDirectoryText(self,event):

	text = event.GetEventObject()
	s = text.GetValue()
	if self.activeFrame:
		self.activeFrame.mDefaultDirectory = s
		if self.activeFrame.mDefaultDirectory.Length()&gt; 0:
			wxSetWorkingDirectory(self.activeFrame.mDefaultDirectory)
		elif self.activeFrame.mOpenDirectory.Length()&gt; 0:
			wxSetWorkingDirectory(self.activeFrame.mOpenDirectory)</t>
<t tx="T577">def OnHeaderCheckBox(self,event):
	
	box = event.GetEventObject()
	arg_use_header_flag = default_use_header_flag = box.GetValue()
	if self.activeFrame:
		self.activeFrame.mUseHeaderFlag = arg_use_header_flag

</t>
<t tx="T578">def OnDocChunksCheckBox(self,event):
	
	box = event.GetEventObject()
	arg_output_doc_flag = default_output_doc_flag = box.GetValue()
	if self.activeFrame:
		self.activeFrame.mOutputDocFlag = arg_output_doc_flag

</t>
<t tx="T579">def OnTargetLanguageRadioBox(self,event):
	
	box = event.GetEventObject()
	targetIndex = box.GetSelection()
	default_target_language = arg_target_language = targetToLanguage(targetIndex)

	# Careful:  The @language or @nocolor will override this.
	if self.activeFrame:
		self.activeFrame.mTargetLanguage = arg_target_language
		c = self.activeFrame.c
		v = c.currentVnode()
		self.activeFrame.c.scanAllDirectives(v,cDontRequirePath,cDontIssueErrors)</t>
<t tx="T580">def __init__(frame):
	
	# Init the base class.
	wxPanel.__init__(frame,-1)
	
	topSizer = wxBoxSizer(wxVERTICAL)
	&lt;&lt; Create the Global Options static box &gt;&gt;
	topSizer.Add(sizer)
	topSizer.Add(0,10)
	&lt;&lt; Create the Default Tangle Options static box &gt;&gt;
	topSizer.Add(sizer2)
	topSizer.Add(0,10)
	&lt;&lt; Create the Default Target Language radio buttons &gt;&gt;
	topSizer.Add(mTargetLanguageRadioBox)
	SetAutoLayout(true)# tell dialog to use sizer
	SetSizer(topSizer) # actually set the sizer
	topSizer.Fit(self)# set size to minimum size as calculated by the sizer
	topSizer.SetSizeHints(self)# set size hints to honour mininum size</t>
<t tx="T581">globalOptionsBox = wxStaticBox(self,-1,
	"Global Options",(10,10),(250,110),0,"")
sizer = wxStaticBoxSizer(globalOptionsBox,wxVERTICAL)
lineSizer = wxBoxSizer(wxHORIZONTAL)
sizer.Add(0,5)# Extra vertical space.

# Text control.
mPrefsPageWidthText = wxTextCtrl(self,
	cPrefsPageWidthText,"132",
	wxDefaultPosition,wx.wxSize(50,25),0,wxDefaultValidator,"")

lineSizer.Add(mPrefsPageWidthText)
lineSizer.Add(20,0)# Width.

# Label for text control.
lineSizer.Add(
	wxStaticText(self,-1,"Page Width",
		(-1,10),(100,25),0,""),
	0,wxBORDER | wxTOP,5)# Vertical offset 5.
sizer.Add(lineSizer)

mPrefsDoneBatCheckBox = wxCheckBox(self,
	cPrefsDoneBatCheckBox,
	"Execute Leo_done.bat after Tangle",
	wxDefaultPosition,(235,25),0,wxDefaultValidator,"")
sizer.Add(mPrefsDoneBatCheckBox)

mPrefsUnBatCheckBox = wxCheckBox(self,
	cPrefsUnBatCheckBox,
	"Execute Leo_un.bat after Untangle",
	wxDefaultPosition,(235,25),0,wxDefaultValidator,"")
sizer.Add(mPrefsUnBatCheckBox)</t>
<t tx="T582">optionsBox = wxStaticBox(self,-1,
	"Default Tangle Options",
	wxDefaultPosition,wx.wxSize(250,210),
	0,"zzzz")

sizer2 = wxStaticBoxSizer(optionsBox,wxVERTICAL)
sizer2.Add(0,10)# Vertical space.
# Label.
sizer2.Add(
	wxStaticText(self,-1,
		"Default Tangle directory",
		wxDefaultPosition,wx.wxSize(165,25),0,""),
	0,wxBORDER | wxLEFT,30)# Indent 30.

mPrefsTangleDirectoryText = wxTextCtrl(self,
	cPrefsTangleDirectoryText,"",
	wxDefaultPosition,wx.wxSize(230,25),0,
	wxDefaultValidator,"")
sizer2.Add(mPrefsTangleDirectoryText)

mPrefsHeaderCheckBox = wxCheckBox(self,
	cPrefsHeaderCheckBox,
	"Tangle outputs header line",
	wxDefaultPosition,wx.wxSize(235,25),0,
	wxDefaultValidator,"")
sizer2.Add(mPrefsHeaderCheckBox)

mPrefsDocChunksCheckBox = wxCheckBox(self,
	cPrefsDocChunksCheckBox,
	"Tangle outputs document chunks",
	wxDefaultPosition,wx.wxSize(235,25),0,
	wxDefaultValidator,"")
sizer2.Add(mPrefsDocChunksCheckBox)</t>
<t tx="T583">targetLanguageChoices= [
	"C/C++","CWEB","HTML","Java",
	"Pascal","Perl","Perl + POD","Plain text","Python"]
	
# We specify rows so that items will be sorted down the columns.
mTargetLanguageRadioBox = wxRadioBox(self,
	cPrefsTargetLanguageRadioBox,
	"Default Target Language",
	wxDefaultPosition,wx.wxSize(245,145),
	WXSIZEOF(targetLanguageChoices),
	targetLanguageChoices,
	5,wxRA_SPECIFY_ROWS)</t>
<t tx="T584">@ It is usually best not to catch exceptions in plugins.  doHook catches all exceptions and disables further calls to plugins.
@c</t>
<t tx="T585"></t>
<t tx="T586"></t>
<t tx="T587">"""Import cisco configuration files"""

from leoPlugins import *
from leoGlobals import *
import tkFileDialog

&lt;&lt; about this plugin &gt;&gt;
@others

if 0:
	
	if app.gui is None:
		app.createTkGui(__file__)

	if app.gui.guiName() == "tkinter":

		registerHandler(("start2","open2","command2"), create_import_cisco_menu)

		__version__ = "1.3" # Set version for the plugin handler.
		plugin_signon(__name__)</t>
<t tx="T588">@ This plugin adds a menu item under the File-&gt;Import menu to import
Cisco configuration files.

The plugin will:

1) create a new node, under the current node, where the configuration will be
written. This node will typically have references to several sections (see below).

2) create sections (child nodes) for the indented blocks present in the original
config file. These child nodes will have sub-nodes grouping similar blocks (e.g.
there will be an 'interface' child node, with as many sub-nodes as there are real
interfaces in the configuration file).

3) create sections for the custom keywords specified in the customBlocks[] list in
importCiscoConfig(). You can modify this list to specify different keywords. DO
NOT put keywords that are followed by indented blocks (these are taken care of by
point 2 above). The negated form of the keywords (for example, if the keyword is
'service', the negated form is 'no service') is also included in the sections.

4) not display consecutive empty comment lines (lines with only a '!').

All created sections are alphabetically ordered.

Feedback on this plugin can be sent to Davide Salomoni (dsalomoni@yahoo.com).
</t>
<t tx="T589">def create_import_cisco_menu(tag, keywords):
	if	(tag=="open2" or
		(tag=="start2" and not keywords.has_key('c')) or
		(tag=="command2" and keywords.get("label")=="new")):

		c = top()
		importMenu = c.frame.getMenu('import')
		newEntries = (
			("-", None, None),
			("Import C&amp;isco Configuration", "Shift+Ctrl+I", importCiscoConfig))
		
		c.frame.createMenuEntries(importMenu, newEntries)</t>
<t tx="T590">def importCiscoConfig(event=None):
	c = top(); current = c.currentVnode()
	if current == None: return
	&lt;&lt; open file &gt;&gt;

	# define which additional child nodes will be created
	# these keywords must NOT be followed by indented blocks
	customBlocks = ['aaa','ip as-path','ip prefix-list','ip route',
					'ip community-list','access-list','snmp-server','ntp',
					'boot','service','logging']
	out = []
	blocks = {}
	children = []
	lines = len(linelist)
	i = 0
	skipToNextLine = 0
	# create level-0 and level-1 children
	while i&lt;(lines-1):
		for customLine in customBlocks:
			if (linelist[i].startswith(customLine) or
				linelist[i].startswith('no %s' % customLine)):
				&lt;&lt; process custom line &gt;&gt;
				skipToNextLine = 1
				break
		if skipToNextLine:
			skipToNextLine = 0
		else:
			if linelist[i+1].startswith(' '):
				&lt;&lt; process indented block &gt;&gt;
			else:
				out.append(linelist[i])
		i=i+1
	# process last line
	out.append(linelist[i])
	
	&lt;&lt; complete outline &gt;&gt;</t>
<t tx="T591">name = tkFileDialog.askopenfilename(
	title="Import Cisco Configuration File",
	filetypes=[("All files", "*")]
	)
if name == "":	return

v = current.insertAsNthChild(0)
c.beginUpdate()
v.setHeadString("cisco config: %s" % name)
c.endUpdate()

try:
	fh = open(name)
	es("importing: %s" % name)
	linelist = fh.read().splitlines()
	fh.close()
except IOError,msg:
	es("error reading %s: %s" % (name, msg))
	return</t>
<t tx="T592">if not blocks.has_key(customLine):
	blocks[customLine] = []
	out.append(angleBrackets(customLine))
	# create first-level child
	child = v.insertAsNthChild(0)
	child.setHeadStringOrHeadline(angleBrackets(customLine))
	children.append(child)

blocks[customLine].append(linelist[i])</t>
<t tx="T593">space = linelist[i].find(' ')
if space == -1:
	space = len(linelist[i])
key = linelist[i][:space]
if not blocks.has_key(key):
	blocks[key] = []
	out.append(angleBrackets(key))
	# create first-level child
	child = v.insertAsNthChild(0)
	child.setHeadStringOrHeadline(angleBrackets(key))
	children.append(child)

value = [linelist[i]]
# loop through the indented lines
i = i+1
try:
	while linelist[i].startswith(' '):
		value.append(linelist[i])
		i = i+1
except:
	# EOF
	pass
i = i-1 # restore index
# now add the value to the dictionary
blocks[key].append(value)</t>
<t tx="T594"># first print the level-0 text
outClean = []
prev = ''
for line in out:
	if line=='!' and prev=='!':
		pass # skip repeated comment lines
	else:
		outClean.append(line)
	prev = line
v.setBodyStringOrPane('\n'.join(outClean))

# scan through the created outline and add children
for child in children:
	# extract the key from the headline. Uhm... :)
	key = child.headString().split('&lt;&lt;'
		)[1].split('&gt;&gt;')[0].strip()
	if blocks.has_key(key):
		if type(blocks[key][0]) == type(''):
			# it's a string, no sub-children, so just print the text
			child.setBodyStringOrPane('\n'.join(blocks[key]))
		else:
			# it's a multi-level node
			for value in blocks[key]:
				# each value is a list containing the headline and then the text
				subchild = child.insertAsNthChild(0)
				subchild.setHeadStringOrHeadline(value[0])
				subchild.setBodyStringOrPane('\n'.join(value))
		child.sortChildren()
	else:
		# this should never happen
		es("Unknown key: %s" % key)
v.sortChildren()</t>
<t tx="T595">@ignore
@language plain
@comment !
@ This node has an example of a flat configuration file (i.e. just the output of a 
'show running' command on a cisco router), and of the same configuration file 
imported by the plugin.
</t>
<t tx="T596">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable
!
hostname rpr1
!
boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3
logging buffered 100000 debugging
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
!
controller SONET 1/0/0
 framing sdh
!
controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2
!
controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
!
interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast
!
interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex
!
interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex
!
interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.2
 no ip directed-broadcast
!
interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode
!
interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast
!
interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal
!
interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010
!
interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010
!
interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address
!
interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable
!
router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0
!
router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary
!
ip classless
ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3
ip bgp-community new-format
ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
logging facility local6
logging 10.10.10.1
access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any
route-map only permit 2
 match community 65001:2
 set origin igp
!
route-map only1 permit 10
 match community 1 65001:1
 set origin igp
!
route-map only3 permit 10
 match community 100
!
route-map tag_com permit 10
 match tag 1
 set community 65001:1
!
route-map tag_com permit 20
 match tag 3
 set community 65001:3
!
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware
line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0
!
ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer
end

rpr1#
</t>
<t tx="T597">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
&lt;&lt;service&gt;&gt;
!
hostname rpr1
!
&lt;&lt;boot&gt;&gt;
&lt;&lt;logging&gt;&gt;
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
&lt;&lt;controller&gt;&gt;
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
&lt;&lt;interface&gt;&gt;
!
&lt;&lt;router&gt;&gt;
!
ip classless
&lt;&lt;ip route&gt;&gt;
ip bgp-community new-format
&lt;&lt;ip community-list&gt;&gt;
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
&lt;&lt;access-list&gt;&gt;
&lt;&lt;route-map&gt;&gt;
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
&lt;&lt;line&gt;&gt;
!
&lt;&lt;ntp&gt;&gt;
end

rpr1#</t>
<t tx="T598">access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any</t>
<t tx="T599">boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3</t>
<t tx="T600"></t>
<t tx="T601">controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2</t>
<t tx="T602">controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1</t>
<t tx="T603">controller SONET 1/0/0
 framing sdh</t>
<t tx="T604"></t>
<t tx="T605">interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address</t>
<t tx="T606">interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable</t>
<t tx="T607">interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex</t>
<t tx="T608">interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex</t>
<t tx="T609">interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="T610">interface FastEthernet0/0/1.2
 no ip directed-broadcast</t>
<t tx="T611">interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode</t>
<t tx="T612">interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="T613">interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="T614">interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast</t>
<t tx="T615">interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal</t>
<t tx="T616">interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="T617">interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="T618">interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="T619">interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010</t>
<t tx="T620">interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010</t>
<t tx="T621">ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3</t>
<t tx="T622">ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3</t>
<t tx="T623"></t>
<t tx="T624">line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware</t>
<t tx="T625">line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0</t>
<t tx="T626">logging buffered 100000 debugging
logging facility local6
logging 10.10.10.1</t>
<t tx="T627">ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer</t>
<t tx="T628"></t>
<t tx="T629">route-map only permit 2
 match community 65001:2
 set origin igp</t>
<t tx="T630">route-map only1 permit 10
 match community 1 65001:1
 set origin igp</t>
<t tx="T631">route-map only3 permit 10
 match community 100</t>
<t tx="T632">route-map tag_com permit 10
 match tag 1
 set community 65001:1</t>
<t tx="T633">route-map tag_com permit 20
 match tag 3
 set community 65001:3</t>
<t tx="T634"></t>
<t tx="T635">router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary</t>
<t tx="T636">router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0</t>
<t tx="T637">no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable</t>
<t tx="T638">"""Modify the way exported outlines are displayed"""

from leoPlugins import *
from leoGlobals import *

def onStart (tag,keywords):
	import leoNodes
	funcToMethod(newMoreHead,leoNodes.vnode,"moreHead")

@others

if 0: # Register the handlers...
	registerHandler("start2", onStart)
	
	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T639"># Returns the headline string in MORE format.

def newMoreHead (self,firstLevel,useVerticalBar=true):

	useVerticalBar = true # Force the vertical bar

	v = self
	level = self.level() - firstLevel
	if level &gt; 0:
		if useVerticalBar:
			s = " |\t" * level
		else:
			s = "\t"
	else:
		s = ""
	s += choose(v.hasChildren(), "+ ", "- ")
	s += v.headString()
	return s
</t>
<t tx="T640"></t>
<t tx="T641">[Main]
active = Yes
interval = 600

</t>
<t tx="T642">"""Autosave the Leo document every so often"""

# By Paul Paterson.

from leoPlugins import *
from leoGlobals import *

import ConfigParser
import time, os

@others

if 0: # Register the handlers...

	AUTOSAVE_INTERVAL = 600
	ACTIVE = "Yes"
	LAST_AUTOSAVE = time.time()
	applyConfiguration()

	__version__ = "0.1"
	registerHandler("idle", autosave)
	es("auto save")
</t>
<t tx="T643">def applyConfiguration(config=None):
	
	"""Called when the user presses the "Apply" button on the Properties form"""

	global LAST_AUTOSAVE, ACTIVE, AUTOSAVE_INTERVAL

	if config is None:
		fileName = os.path.join(app().loadDir,"../","plugins","mod_autosave.ini")
		config = ConfigParser.ConfigParser()
		config.read(fileName)

	ACTIVE = config.get("Main", "Active")
	AUTOSAVE_INTERVAL = int(config.get("Main", "Interval"))</t>
<t tx="T644">def autosave(tag, keywords):
	
	"""Save the current document if it has a name"""

	global LAST_AUTOSAVE

	if ACTIVE == "Yes":
		if time.time() - LAST_AUTOSAVE &gt; AUTOSAVE_INTERVAL:
			f = top().frame
			if f.mFileName and f.commands.changed:
				es("Autosave: %s" % time.ctime())
				f.commands.fileCommands.save(f.mFileName)
			LAST_AUTOSAVE = time.time()</t>
<t tx="T645">"""Timestamp all save operations to show when they occur"""

# By Paul Paterson.

from leoPlugins import *
from leoGlobals import *

import time
	
@others

if 0: # Register the handlers...

	registerHandler("command1", timestamp)

	__version__ = "0.1" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T646">def timestamp(tag=None, keywords=None):
	
	cmd = keywords.get('label', 'save')

	if cmd.startswith("save") or cmd.startswith("tangle"):
		es("%s: %s" % (cmd, time.ctime()))
</t>
<t tx="T647"></t>
<t tx="T648">"""Dump globals at startup"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("start2", onStart)

	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T649">def onStart (tag,keywords):

	print "\nglobals..."
	for s in globals():
		if s not in __builtins__:
			print s
	
	print "\nlocals..."
	for s in locals():
		if s not in __builtins__:
			print s
</t>
<t tx="T650">"""Enable debugging for garbage collector"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("start2", onStart)
	
	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T651">def onStart (tag,keywords):

	try:
		import gc
		gc.set_debug(gc.DEBUG_LEAK)
	except: pass</t>
<t tx="T652">"""Trace changes to objects at idle time"""

from leoPlugins import *
from leoGlobals import *

def printIdleRefs(tag,keywords):
	printGcRefs(verbose=false)

def printIdleGC(tag,keywords):
	
	# Calling printGc is too expensive to do on every idle call.
	# Note: printGc only works if debugGc is true in leoGlobals.py.
	# At present, this code does _not_ set that constant.
	if tag == "idle":
		global count ; count += 1
		if (count % 20) == 0:
			# collectGarbage() # Has no effect.
			printGc(tag,onlyPrintChanges=true)
	else:
		printGc(tag,onlyPrintChanges=false)
		
if 0:
	registerHandler("command2", printIdleRefs)

if 0: # Register the handlers...

	count = 0 # For Pychecker: don't define this unless we are using this module.

	if 1: # Very effective.
		registerHandler("idle", printIdleGC)
	else: # Very precise.
		registerHandler("all", printIdleGC)
	
	__version__ = "1.2"
	plugin_signon(__name__)
</t>
<t tx="T653">"""Trace keystrokes in the outline and body panes"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler(("bodykey1","bodykey2","headkey1","headkey2"), onKey)
	
	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T654">def onKey (tag,keywords):

	ch = keywords.get("ch")
	if ch and len(ch) &gt; 0:
		es("key",`ch`)</t>
<t tx="T655">"""Trace most comment events, but not key, drag or idle events"""

from leoPlugins import *
from leoGlobals import *

tagCount = 0

@others

if 0: # Register the handlers...
	registerHandler("all", trace_tags)

	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T656">def trace_tags (tag,keywords):
	
	global tagCount # 8/28/03

	# Almost all tags have both c and v keys in the keywords dict.
	if tag not in ("start1","end1","open1","open2"):
		c = keywords.get("c")
		v = keywords.get("v")
		if not c:
			print tagCount,tag, "c = None"
		if not v:
			if tag not in ("select1","select2","unselect1","unselect2"):
				print tagCount,tag, "v = None"
	
	if tag not in (
		"bodykey1","bodykey2","dragging1","dragging2",
		"headkey1","headkey2","idle"):
	
		tagCount += 1 # Count all other hooks.
	
		if tag in ("command1","command2"):
			print tagCount,tag,keywords.get("label")
		elif tag in ("open1","open2"):
			print tagCount,tag,keywords.get("fileName")
		else:
			if 1: # Brief
				print tagCount,tag
			else: # Verbose
				keys = keywords.items()
				keys.sort()
				for key,value in keys:
					print tagCount,tag,key,value
				print</t>
<t tx="T657"></t>
<t tx="T658">"""Support new @direcives"""

from leoPlugins import *
from leoGlobals import *

if 1:
	directives = "markup", # A tuple with one string.
else:
	directives = ("markup","markup2")
	
@others

if 0: # Register the handlers...

	registerHandler("start1",addPluginDirectives)
	registerHandler("scan-directives",scanPluginDirectives)
	
	__version__ = "1.1"
	plugin_signon(__name__)</t>
<t tx="T659">def addPluginDirectives (tag,keywords):
	
	"""Add all new directives to globalDirectivesList"""
	
	global directives

	if 0:
		s = ""
		for d in directives:
			s += '@' + d + ' '
		es(s,color="blue")

	for d in directives:
		if d not in globalDirectiveList:
			globalDirectiveList.append(d)</t>
<t tx="T660">def scanPluginDirectives (tag, keywords):
	
	"""Add a tuple (d,v,s,k) to list for every directive d found"""
	
	global directives

	keys = ("c","v","s","old_dict","dict","pluginsList")
	c,v,s,old_dict,dict,pluginsList = [keywords.get(key) for key in keys]

	for d in directives:
		if not old_dict.has_key(d) and dict.has_key(d):
			# Point k at whatever follows the directive.
			k = dict[d]
			k += 1 + len(d) # Skip @directive
			k = skip_ws(s,k) # Skip whitespace
			# trace(`d`,`k`)
			pluginsList.append((d,v,s,k),)
</t>
<t tx="T661"></t>
<t tx="T662">"""Handle coloring for markup in doc parts and Python triple-double-quoted strings"""

from leoPlugins import *
from leoGlobals import *
import string  # zfill does not exist in Python 2.2.1

@others

if 0: # Register the handlers...

	if app.gui is None:
		app.createTkGui(__file__)

	if app.gui.guiName() == "tkinter":

		registerHandler("color-optional-markup", colorWikiMarkup)
		registerHandler("init-color-markup", initAnyMarkup)
	
		__version__ = "1.1"
		plugin_signon(__name__)</t>
<t tx="T663">def initAnyMarkup (tag,keywords):
	
	"""initialize colorer.markup_string
	
	The colorer completely recolors the body pane when this changes"""
	
	keys = ("colorer","v")
	colorer,v = [keywords.get(key) for key in keys]

	c = colorer.commands
	if not c or not v or not top(): return

	# trace()
	dict = scanDirectives(c,v=v) # v arg is essential.
	pluginsList = dict.get("pluginsList")
	
	if pluginsList:
		for d,v,s,k in pluginsList:
			if d == "markup":
				kind = s[k:]
				if kind:
					colorer.markup_string = kind
					return
					
	colorer.markup_string = "unknown" # default</t>
<t tx="T664">colorCount = 0

def colorWikiMarkup (tag,keywords):

	keys = ("colorer","v","s","i","j","colortag")
	colorer,v,s,i,j,colortag = [keywords.get(key) for key in keys]

	global colorCount ; colorCount += 1
	
	c = colorer.commands
	dict = scanDirectives(c,v=v) # v arg is essential.
	pluginsList = dict.get("pluginsList")
	
	if pluginsList:
		for d,v,s2,k in pluginsList:
			if d == "markup":
				# trace(`colorCount`,`d`)
				if match_word(s2,k,"wiki"):
					doWikiText(colorer,v,s,i,j,colortag)
					return true # We have colored the text.
			
	# trace(`colorCount`,"no markup")
	return None # We have not colored the text.</t>
<t tx="T665">def doWikiText (colorer,v,s,i,end,colortag):

	firsti = i ; inserted = 0

	while i &lt; end:
		&lt;&lt; set first to a tuple describing the first tag to be handled &gt;&gt;
		if first:
			tag,n1,n2,delim1,delim2 = first
			i = n2 + len(delim2)
			&lt;&lt; handle the tag using n1,n2,delim1,delim2 &gt;&gt;
		else: i = end
		
	colorer.tag(colortag,firsti,end+inserted)</t>
<t tx="T666">first = None

for tag,delim1,delim2 in (
	("bold","__","__"),
	("italic","''","''"),
	("picture","{picture file=","}"),
	("color","~~","~~")):
	n1 = s.find(delim1,i,end)
	if n1 &gt; -1:
		n2 = s.find(delim2,n1+len(delim1),end)
		if n2 &gt; -1:
			if not first or (first and n1 &lt; first[1]):
				first = tag,n1,n2,delim1,delim2
</t>
<t tx="T667">if tag =="picture":
	colorer.tag("elide",n1,n2+len(delim2)) # Elide everything.
	filename = s[n1+len(delim1):n2]
	filename = os.path.join(app().loadDir,filename)
	filename = os.path.normpath(filename)
	inserted += insertWikiPicture(colorer,filename,n2+len(delim2))
elif tag == "color":
	&lt;&lt; parse and handle color field &gt;&gt;
else:
	# look for nested bold or italic.
	if tag == "bold":
		delim3,delim4 = "''","''" # Look for nested italic.
	else:
		delim3,delim4 = "__","__" # Look for nested bold.
	n3 = s.find(delim3,n1+len(delim1),n2) ; n4 = -1
	if n3 &gt; -1:
		n4 = s.find(delim4,n3+len(delim3),n2+len(delim2))
	if n3 &gt; -1 and n4 &gt; -1:
		colorer.tag("elide",n1,n1+len(delim1))
		colorer.tag("elide",n2,n2+len(delim2))
		colorer.tag("elide",n3,n3+len(delim3))
		colorer.tag("elide",n4,n4+len(delim4))
		colorer.tag(tag,n1+len(delim1),n3)
		colorer.tag("bolditalic",n3+len(delim3),n4)
		colorer.tag(tag,n4+len(delim4),n2)
	else:
		# No nested tag.
		colorer.tag("elide",n1,n1+len(delim1))
		colorer.tag("elide",n2,n2+len(delim2))
		colorer.tag(tag,n1+len(delim1),n2)</t>
<t tx="T668"># Parse the color value.
j = n1+len(delim1)
n = s.find(":",j,n2)
if n2 &gt; n &gt; j &gt; -1:
	name = s[j:n]
	if name[0] == '#' and len(name) &gt; 1:
		name = '#' + string.zfill(name[1:],6)
	if name in colorer.color_tags_list:
		colorer.tag("elide",n1,n+1)
		colorer.tag(name,n+1,n2)
		colorer.tag("elide",n2,n2+len(delim2))
	else:
		try:
			# print "entering", name
			colorer.body.tag_configure(name,foreground=name)
			colorer.color_tags_list.append(name)
			colorer.tag("elide",n1,n+1)
			colorer.tag(name,n+1,n2)
			colorer.tag("elide",n2,n2+len(delim2))
		except: # an invalid color name: elide nothing.
			pass # es_exception()</t>
<t tx="T669">def insertWikiPicture (colorer,filename,i):
	
	"""Try to insert a picture with the give filename.
	
	Returns the number of characters actually inserted"""
	
	# trace(`colorer.color_pass`)
	if colorer.color_pass == 0:
		colorer.redoColoring = true # schedule a two-pass recoloring.
		return 0
		
	if colorer.color_pass == 2:
		return 0 # The second redo pass.
		
	# trace(`filename`,`v`)
	if not os.path.exists(filename):
		return 0

	try:
		# Create the image
		photo = Tkinter.PhotoImage(master=app().root, file=filename)
		image = colorer.body.image_create(colorer.index(i),image=photo,padx=0)
		
		# Keep references so images stay on the canvas.
		colorer.image_references.append((photo,image,colorer.line_index,i),)
		return 1
	except:
		es_exception()
		return 0</t>
<t tx="T670">"""Handle images in body text"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...

	if app.gui is None:
		app.createTkGui(__file__)

	if app.gui.guiName() == "tkinter":
		
		registerHandler("select2", onSelect)
		registerHandler("unselect1", onUnselect)
		
		__version__ = "1.2" # Set version for the plugin handler.
		plugin_signon(__name__)
</t>
<t tx="T671">def onSelect (tag,keywords):

	import Tkinter,os

	new_v = keywords.get("new_v")
	h = new_v.headString()
	if h[:7] == "@image ":
		filename = h[7:]
		&lt;&lt; Select Image &gt;&gt;</t>
<t tx="T672"># Display the image file in the text pane, if you can find the file
a = app()
c = keywords.get("c")
body = c.frame.body

if os.path.isfile(filename):
	try:
		# Note that Tkinter only understands GIF
		photo = Tkinter.PhotoImage(master=a.root, file=filename)
	except:
		es("error: cannot load image")
		return
	# Nicely display the image at the center top and push the text below.
	a.gsphoto = photo # This is soooo important.
	photoWidth = photo.width()
	bodyWidth = body.winfo_width()
	padding = int((bodyWidth - photoWidth - 16) / 2)
	padding = max(0,padding)
	a.gsimage = body.image_create("1.0",image=photo,padx=padding)
else:
	es("warning: missing image file")</t>
<t tx="T673">def onUnselect (tag,keywords):

	import Tkinter, os.path

	a = app()
	old_v = keywords.get("old_v")
	if old_v:
		h = old_v.headString()
		if h[:7] == "@image ":
			&lt;&lt; Unselect Image &gt;&gt;
	else: # Leo is initializing.
		a.gsphoto = None # Holds our photo file
		a.gsimage = None # Holds our image instance within the text pane</t>
<t tx="T674"># Erase image if it was previously displayed
a = app() ; c = keywords.get("c")

if a.gsimage:
	try:
		 c.frame.body.delete(a.gsimage)
	except:
		es("info: no image to erase")

# And forget about it
a.gsimage = None
a.gsphoto = None
</t>
<t tx="T675">"""Adds navigation buttons to icon bar"""

from leoPlugins import *
from leoGlobals import *
from leoDialog import listBoxDialog
import os, Tkinter

@others
	
globalInfo = globalInfoClass()

Tk = Tkinter

if 1: # Register the handlers...

	if app.gui is None:
		app.createTkGui(__file__)

	if app.gui.guiName() == "tkinter":

		registerHandler("after-create-leo-frame", globalInfo.addNavWidgets)
		registerHandler("select2",globalInfo.updateRecentSections)
		registerHandler("command2",globalInfo.updateMarksAfterCommand)
		registerHandler(("set-mark","clear-mark"),globalInfo.updateMarks)
		registerHandler("close-frame",globalInfo.destroyFrame)
		registerHandler("destroy-all-global-windows",globalInfo.destroyAllFrames)
	
		# 7/12/03: Moved marksDialog and recentSectionsDialog into this plugin.
		# 7/12/03: Handled "set-mark" and "clear-mark" hooks.
		__version__ = "1.2"
		plugin_signon(__name__)</t>
<t tx="T676">class commanderInfoClass:
	@others</t>
<t tx="T677">def __init__ (self,c,globalInfo):
	
	self.c = c
	self.globalInfo = globalInfo
	
	# The icon frame in c.
	self.iconFrame = c.frame.iconFrame
	
	# Dialogs.
	self.marksDialog = None
	self.recentSectionsDialog = None

	# Images for arrow buttons.
	self.lt_nav_disabled_image = self.lt_nav_enabled_image = None
	self.rt_nav_disabled_image = self.rt_nav_enabled_image = None
	
	# The arrow and text buttons.
	self.lt_nav_button = self.rt_nav_button = None
	sections_button = self.marks_button = None
	
	self.nav_buttons = None
</t>
<t tx="T678">def addWidgets (self):
	
	c = self.c ; d = self
	
	d.lt_nav_disabled_image = self.createImage("../Icons/lt_arrow_disabled.gif")
	d.lt_nav_enabled_image  = self.createImage("../Icons/lt_arrow_enabled.gif")
	
	d.rt_nav_disabled_image = self.createImage("../Icons/rt_arrow_disabled.gif")
	d.rt_nav_enabled_image  = self.createImage("../Icons/rt_arrow_enabled.gif")
	
	for image in (
		self.lt_nav_disabled_image, self.lt_nav_enabled_image,
		self.rt_nav_disabled_image, self.rt_nav_enabled_image):
		if not image:
			return
	
	# It's so nice to be able to add ivars to classes at any time!
	self.lt_nav_button = c.frame.addIconButton(
		image=self.lt_nav_disabled_image,
		command=c.frame.OnGoPrevVisitedNode)
		
	&lt;&lt; define callbacks &gt;&gt;

	self.sections_button = c.frame.addIconButton(
		text="Recent",command=onRecentButton)
		
	self.marks_button = c.frame.addIconButton(
		text="Marks",command=onMarksButton)
	
	self.rt_nav_button = c.frame.addIconButton(
		image=self.rt_nav_disabled_image,
		command=c.frame.OnGoNextVisitedNode)
		
	# Don't dim the button when it is inactive.
	for b in (self.lt_nav_button,self.rt_nav_button):
		fg = b.cget("foreground")
		b.configure(disabledforeground=fg)
		
	# Package these buttons for the recentSectionsDialog class in leoDialog.py
	self.nav_buttons = (self.lt_nav_button, self.rt_nav_button)</t>
<t tx="T679"># These are functions, not methods, so we must bind self at definition time.

def onMarksButton(self=self):

	self.marksButtonCallback()
	
def onRecentButton(self=self):

	self.recentButtonCallback()</t>
<t tx="T680">def createImage (self,path):
	
	path = os.path.join(app().loadDir,path)
	path = os.path.normpath(path)
	
	try:
		image = Tkinter.PhotoImage(master=app().root,file=path)
	except:
		es("can not load icon: " + shortFileName(path))
		image = None
	return image

</t>
<t tx="T681">def updateNavButtons (self):	

	d = self ; c = self.c
	
	# Make sure we have initialized properly.
	if not hasattr(d,"lt_nav_button") or not hasattr(d,"rt_nav_button"):
		return
		
	if not d.lt_nav_button or not d.rt_nav_button: # 6/30/03
		return
	
	b = d.lt_nav_button
	if c.beadPointer &gt; 0:
		image = self.lt_nav_enabled_image
		state = "normal"
	else:
		image = d.lt_nav_disabled_image
		state = "normal" # "disabled" makes the icon look bad.
	b.configure(image=image,state=state)
	
	b = d.rt_nav_button
	if c.beadPointer + 1 &lt; len(c.beadList):
		image =self.rt_nav_enabled_image
		state = "normal"
	else:
		image = self.rt_nav_disabled_image
		state = "normal" # "disabled" makes the icon look bad.
	b.configure(image=image,state=state)
</t>
<t tx="T682"></t>
<t tx="T683">def marksButtonCallback(self,event=None):
	
	c = self.c ; d = self.marksDialog

	if d:
		d.top.deiconify()
	else:
		# Create and run the dialog.
		title = "Marks"
		label = "Marks: " + shortFileName(c.mFileName)
		d = marksDialog(c,title,label)
		self.marksDialog = d
		d.root.wait_window(d.top)
</t>
<t tx="T684">def recentButtonCallback(self,event=None):
	
	c = self.c ; d = self.recentSectionsDialog
	
	if d:
		d.top.deiconify()
		d.fillbox()
	else:
		# Create and run the dialog.]
		title = "Recent Nodes"
		label = "Recent nodes: " + shortFileName(c.mFileName)
		d = recentSectionsDialog(c,self.nav_buttons,title,label)
		self.recentSectionsDialog = d
		d.root.wait_window(d.top)
</t>
<t tx="T685">class globalInfoClass:
	@others</t>
<t tx="T686">def __init__ (self):
	
	self.commanderInfo = {} # keys are commanders, values are navCommanderInfo objects
</t>
<t tx="T687">def addNavWidgets(self,tag,keywords):
	
	c = keywords.get("c")
	
	# Create the commanderInfo object.
	d = commanderInfoClass(c,self)
	self.commanderInfo[c] = d
	
	# Add the widgets.
	d.addWidgets()
	
</t>
<t tx="T688">def destroyAllFrames(self,tag,keywords):
	
	for d in self.commanderInfo.values():
		self.destroyOneFrame(d)
		
def destroyFrame(self,tag,keywords):

	c = keywords.get("c")
	d = self.commanderInfo.get(c)
	if d:
		self.destroyOneFrame(d)
		
def destroyOneFrame(self,d):

	if d.marksDialog:
		d.marksDialog.top.destroy()
	if d.recentSectionsDialog:
		d.recentSectionsDialog.top.destroy()
	del self.commanderInfo[d.c]</t>
<t tx="T689">def updateRecentSections (self,tag,keywords):
	
	c = keywords.get("c")
	info = self.commanderInfo.get(c)

	if info:
		info.updateNavButtons()
		d = info.recentSectionsDialog
		if d:
			d.fillbox()
</t>
<t tx="T690">def updateMarksAfterCommand (self,tag,keywords):
	
	"""Update the marks dialog when a new window is opened."""
	
	name = keywords.get("label")
	
	if name and name.lower() in ("open","new"):
		self.updateMarks(tag,keywords)
	
def updateMarks (self,tag,keywords):
	
	"""Update the marks dialog."""
	
	c = keywords.get("c")
	# trace()
	info = self.commanderInfo.get(c)
	if info and info.marksDialog:
		info.marksDialog.fillbox()</t>
<t tx="T691">def updateNavButtons (self,tag,keywords):

	"""Update the colors of c's nav buttons"""
	
	c = keywords.get("c")
	info = self.commanderInfo.get(c)
	
	if info:
		info.updateNavButtons()
</t>
<t tx="T692">class marksDialog (listBoxDialog):
	
	"""A class to create the marks dialog"""

	@others</t>
<t tx="T693">def __init__ (self,c,title,label):
	
	"""Create a Marks listbox dialog."""

	listBoxDialog.__init__(self,c,title,label)
</t>
<t tx="T694">def createFrame(self):
	
	"""Create the frame for a Marks listbox dialog."""

	listBoxDialog.createFrame(self)
	self.addButtons()</t>
<t tx="T695">def addButtons (self):
	
	"""Add buttons to a Marks listbox dialog."""
	
	f = Tk.Frame(self.outerFrame)
	f.pack()
	self.addStdButtons(f)</t>
<t tx="T696">def fillbox(self,event=None):

	"""Update a Marks listbox dialog and update the listbox and update vnodeList &amp; tnodeList ivars"""

	self.box.delete(0,"end")
	self.vnodeList = []
	self.tnodeList = []

	# Make sure the node still exists.
	# Insert only the last cloned node.
	c = self.c ; v = c.rootVnode()
	i = 0
	while v:
		if v.isMarked() and v.t not in self.tnodeList:
			self.box.insert(i,v.headString().strip())
			self.tnodeList.append(v.t)
			self.vnodeList.append(v)
			i += 1
		v = v.threadNext()</t>
<t tx="T697">class recentSectionsDialog (listBoxDialog):
	
	"""A class to create the recent sections dialog"""

	@others</t>
<t tx="T698">def __init__ (self,c,buttons,title,label):
	
	"""Create a Recent Sections listbox dialog."""
	
	self.lt_nav_iconFrame_button, self.rt_nav_iconFrame_button = buttons

	listBoxDialog.__init__(self,c,title,label)

</t>
<t tx="T699">def addButtons (self):
	
	"""Add buttons for a Recent Sections listbox dialog."""

	self.buttonFrame = f = Tk.Frame(self.outerFrame)
	f.pack()
	
	row1 = Tk.Frame(f)
	row1.pack()
	
	# Create the back and forward buttons, cloning the images &amp; commands of the already existing buttons.
	image   = self.lt_nav_iconFrame_button.cget("image")
	command = self.lt_nav_iconFrame_button.cget("command")

	self.lt_nav_button = b = Tk.Button(row1,image=image,command=command)
	b.pack(side="left",pady=2,padx=5)
	
	image   = self.rt_nav_iconFrame_button.cget("image")
	command = self.rt_nav_iconFrame_button.cget("command")

	self.rt_nav_button = b = Tk.Button(row1,image=image,command=command)
	b.pack(side="left",pady=2,padx=5)
	
	row2 = Tk.Frame(f)
	row2.pack()
	self.addStdButtons(row2)
	
	row3 = Tk.Frame(f)
	row3.pack()
	
	self.clear_button = b =  Tk.Button(row3,text="Clear All",
		width=6,command=self.clearAll)
	b.pack(side="left",pady=2,padx=5)
	
	self.delete_button = b =  Tk.Button(row3,text="Delete",
		width=6,command=self.deleteEntry)
	b.pack(side="left",pady=2,padx=5)
</t>
<t tx="T700">def clearAll (self,event=None):

	"""Handle clicks in the "Delete" button of the Recent Sections listbox dialog."""

	self.c.visitedList = []
	self.vnodeList = []
	self.fillbox()
</t>
<t tx="T701">def createFrame(self):
	
	"""Create the frame of a Recent Sections listbox dialog."""
	
	listBoxDialog.createFrame(self)	
	self.addButtons()
</t>
<t tx="T702">def deleteEntry (self,event=None):

	"""Handle clicks in the "Delete" button of a Recent Sections listbox dialog."""
	
	c = self.c ; box = self.box
	
	# Work around an old Python bug.  Convert strings to ints.
	items = box.curselection()
	try:
		items = map(int, items)
	except ValueError: pass

	if items:
		n = items[0]
		v = self.vnodeList[n]
		del self.vnodeList[n]
		if v in c.visitedList:
			c.visitedList.remove(v)
		self.fillbox()
</t>
<t tx="T703">def destroy (self,event=None):
	
	"""Hide a Recent Sections listbox dialog and mark it inactive.
	
	This is an escape from possible performace penalties"""
		
	# This is enough to disable fillbox.
	self.top.withdraw()
</t>
<t tx="T704">def fillbox(self,event=None):

	"""Update a Recent Sections listbox dialog and update vnodeList &amp; tnodeList ivars"""

	# Only fill the box if the dialog is visible.
	# This is an important protection against bad performance.

	if self.top.state() == "normal":
		&lt;&lt; reconstruct the contents of self.box &gt;&gt;
		self.synchButtons()</t>
<t tx="T705">c = self.c

self.box.delete(0,"end")
self.vnodeList = []
self.tnodeList = []

# Make sure the node still exists.
# Insert only the last cloned node.
i = 0
for v in c.visitedList:
	if v.exists(self.c) and v.t not in self.tnodeList:
		self.box.insert(i,v.headString().strip())
		self.tnodeList.append(v.t)
		self.vnodeList.append(v)
		i += 1
</t>
<t tx="T706">def synchButtons (self):
	
	"""Synchronize the arrow boxes of a Recent Sections listbox dialog."""

	image = self.lt_nav_iconFrame_button.cget("image")
	self.lt_nav_button.configure(image=image)
	
	image = self.rt_nav_iconFrame_button.cget("image")
	self.rt_nav_button.configure(image=image)</t>
<t tx="T707"></t>
<t tx="T708">"""Create menu for Open With command and handle the resulting commands"""

from leoPlugins import *
from leoGlobals import *

@others

if 1: # Register the handlers...

	app().hasOpenWithMenu = true
	registerHandler("idle", on_idle)
	registerHandler(("start2","open2","command2"), create_open_with_menu)

	__version__ = "1.4" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T709"># frame.OnOpenWith creates the dict with the following entries:
# "body", "c", "encoding", "f", "path", "time" and "v".

def on_idle (tag,keywords):

	import os
	a = app()
	for dict in a.openWithFiles:
		path = dict.get("path")
		c = dict.get("c")
		encoding = dict.get("encoding",None)
		v = dict.get("v")
		old_body = dict.get("body")
		if path and os.path.exists(path):
			try:
				time = os.path.getmtime(path)
				if time and time != dict.get("time"):
					dict["time"] = time # inhibit endless dialog loop.
					# The file has changed.
					&lt;&lt; update v's body text &gt;&gt;
			except:
				es_exception() ## testing
				pass</t>
<t tx="T710">&lt;&lt; set s to the file text &gt;&gt;

# Convert body and s to whatever encoding is in effect.
body = v.bodyString()
body = toEncodedString(body,encoding,reportErrors=true)
s = toEncodedString(s,encoding,reportErrors=true) # 10/13/03

conflict = body != old_body and body != s

# Set update if we should update the outline from the file.
if conflict:
	# See how the user wants to resolve the conflict.
	import leoDialog
	es("conflict in " + shortFileName(path),color="red")
	message = "Replace changed outline with external changes?"
	result = leoDialog.askYesNo("Conflict!",message).run(modal=true)
	update = result.lower() == "yes"
else:
	update = s != body

if update:
	es("updated from: " + shortFileName(path),color="blue")
	v.setBodyStringOrPane(s)
	c.selectVnode(v)
	dict["body"] = s
elif conflict:
	es("not updated from: " + shortFileName(path),color="blue")</t>
<t tx="T711">try:
	# Update v from the changed temp file.
	f=open(path)
	s=f.read()
	f.close()
except:
	es("can not open " + shortFileName(path))
	break
</t>
<t tx="T712">def create_open_with_menu (tag,keywords):

	if  (tag in ("start2","open2") or
		(tag=="command2" and keywords.get("label")=="new")):

		&lt;&lt; create the Open With menu &gt;&gt;
		# Enable the idle-time hook so we can check temp files created by Open With.
		from leoGlobals import enableIdleTimeHook
		enableIdleTimeHook(idleTimeDelay=500)
</t>
<t tx="T713">@ Entries in the following table are the tuple (commandName,shortcut,data).

- data is the tuple (command,arg,ext).
- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the extension ext,
Otherwise, Leo computes an extension based on what @language directive is in effect.
@c

idle_arg = "c:/python22/tools/idle/idle.py -e "

if 1: # Default table.
	table = (
		# Opening idle this way doesn't work so well.
		# ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
		("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
		("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
elif 1: # Test table.
	table = ("&amp;Word","Alt+Shift+W",("os.startfile",None,".doc")),
else: # David McNab's table.
	table = ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)),

top().frame.createOpenWithMenuFromTable(table)</t>
<t tx="T714">"""emacs handler"""

from leoPlugins import *
from leoGlobals import *

# path = "/usr/bin/gnuclient"
path = r"c:\Program Files\XEmacs\XEmacs-21.4.13\i586-pc-win32\xemacs.exe"

def open_in_emacs (tag,keywords):
	if top():
		top().frame.OnOpenWith(("os.spawnl", path , None),) # 6/27/03: add comma.

if 0: # Register the handlers...
	registerHandler("iconclick2", open_in_emacs)
	if 0: # This edits _everything_ in xemacs.  That's a bit much for my taste.
		registerHandler("select2", open_in_emacs)
	
	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T715"></t>
<t tx="T716">"""vim handler"""

# Contributed by Andrea Galimberti.
# Edited by Felix Breuer.

#  To use this plugin do the following:
#
# - Start VIM as server: vim --servername "LEO"
#   The name of the server *must* be "LEO".
#   If you wish to use a different server with LEO, change the
#   variable _vim_cmd below. If you want Leo to start the VIM server
#   uncomment the corresponding line below.
#
# - Single-click on a node's icon to open that node in VIM.
#
# - Leo will update the node in the outline when you save the file in VIM.

from leoPlugins import *
from leoGlobals import *

# This command is used to communicate with the vim server. If you use gvim
# you can leave the command as is, you do not need to change it to "gvim ..."
# Note: _vim_cmd must end with a space.
_vim_cmd = "vim --servername LEO "

@others

if 0: # Register the handlers...
	registerHandler("iconclick2", open_in_vim)
	
	# if you want to start a (g)vim server when leo is started
	# uncomment this line:
	# os.system("gvim --servername LEO")
	
	__version__ = "1.3" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T717">def open_in_vim (tag,keywords):
	if not top():
		return

	v=keywords['v']
	# Find dictionary with infos about this node
	this=filter(lambda x: id(x['v'])==id(v), app().openWithFiles)
	
	# Retrieve the name of the temporary file (if any).
	if this != []:
		path=this[0]['path']
	else:
		path=''

	old=''
	if os.path.exists(path) and hasattr(v,'OpenWithOldBody'):
		old=v.OpenWithOldBody
	
	# if the body has changed we need to open a new temp file
	# containing the new body in vim
	if v.bodyString() != old:
		# if there is an old temp file we need to delete it,
		# remove it from the dictionary and delete the old
		# buffer from vim
		if path != '':
			os.remove(path)
			app().openWithFiles=filter(lambda x: x['path']!=path,app().openWithFiles)
			os.system(_vim_cmd+"--remote-send '&lt;C-\\&gt;&lt;C-N&gt;:bd! "+path+"&lt;CR&gt;'")
		# update old body with new contents
		v.OpenWithOldBody=v.bodyString()
		# open the node in vim (note the space after --remote)
		top().frame.OnOpenWith(("os.system", _vim_cmd+"--remote ", None),) # 6/27/03: add comma.
	# else, display the old temp file in vim because other files may have
	# been opened in the meantime
	else:
		# We reopen the file. if it is still open, the buffer is raised
		# if the changes to the current buffer were not saved, vim will
		# notify the user of that fact at this point
		os.system(_vim_cmd+"--remote-send '&lt;C-\\&gt;&lt;C-N&gt;:e "+path+"&lt;CR&gt;'")
</t>
<t tx="T718">"""vim handler"""

# Contributed by Andrea Galimberti.

#  To use this plugin do the following:
#
# - Start VIM as server: vim --servername "VIM"
#   The name of the server *must* be "VIM".
#
# - Single-click on a node's icon to open that node in VIM.
#
# - Leo will update the node in the outline when you save the file in VIM.

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("iconclick2", open_in_vim)
	
	__version__ = "1.3" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T719">def open_in_vim (tag,keywords):
	if not top():
		return

	v=keywords['v']
	# Find dictionary with infos about this node
	this=filter(lambda x: id(x['v'])==id(v), app().openWithFiles)
	
	# Retrieve the name of the temporary file (if any).
	if this != []:
		path=this[0]['path']
	else:
		path=''

	if os.path.exists(path):
		# Get previous node contents.
		try:
			old=v.OpenWithOldBody
		except AttributeError:
			old=''

	if v.bodyString() != old:
		# delete old temp file
		os.remove(path)
		# remove old temp file from list
		app().openWithFiles=filter(lambda x: x['path']!=path,app().openWithFiles)
		# update old body with new contents
		v.OpenWithOldBody=v.bodyString()
		# open the node in vim (note the space after --remote)
		top().frame.OnOpenWith(("os.system", "vim --remote ", None),) # 6/27/03: add comma.</t>
<t tx="T720"></t>
<t tx="T721">"""Exports an outline to a word document.

Make sure word is running with an open (empty) document.

Click "plugins ... word export ... export"
to export the selected outline to Word."""

@language python

from leoPlugins import *
from leoGlobals import *

import win32com.client # From win32 extensions: http://www.python.org/windows/win32/
import ConfigParser

@others

if 0: # Register the handlers...

	# No hooks, we just use the cmd_Export to trigger an export
	__version__ = "0.1"
	__name__ = "Word Export"

	plugin_signon("word_export")</t>
<t tx="T722">def getConfiguration():
	
	"""Called when the user presses the "Apply" button on the Properties form"""

	fileName = os.path.join(app().loadDir,"../","plugins","word_export.ini")
	config = ConfigParser.ConfigParser()
	config.read(fileName)
	return config
</t>
<t tx="T723">def getWordConnection():
	
	"""Get a connection to Word"""

	es("Trying to connect to Word")
	try:
		word = win32com.client.Dispatch("Word.Application")
		return word
	except Exception, err:
		# es("Failed to connect to Word: %s", err)
		es("Failed to connect to Word",color="blue")
		es("Please make sure word is running with an open (empty) document.")
		return None</t>
<t tx="T724">def doPara(word, text, style=None):
	
	"""Write a paragraph to word"""
	
	doc = word.Documents(word.ActiveDocument)
	sel = word.Selection
	if style:
		try:
			sel.Style = doc.Styles(style)
		except:
			es("Unknown style: '%s'" % style)
	sel.TypeText(text)
	sel.TypeParagraph()</t>
<t tx="T725">def writeNodeAndTree(word, header_style, level, maxlevel=3, usesections=1, sectionhead="", vnode=None):
	
	"""Write a node and its children to Word"""

	commands = top().frame.commands
	if vnode is None:
		vnode = top().currentVnode()
	#
	dict = scanDirectives(commands,v=vnode)
	encoding = dict.get("encoding",None)
	if encoding == None:
		encoding = app().config.default_derived_file_encoding
	# 
	s = vnode.bodyString()
	s = toEncodedString(s,encoding,reportErrors=true)
	doPara(word, s)
	#
	for i in range(vnode.numberOfChildren()):
		if usesections:
			thishead = "%s%d." % (sectionhead, i+1)
		else:
			thishead = ""
		child = vnode.nthChild(i)
		h = child.headString()
		h = toEncodedString(h, encoding, reportErrors=true)
		doPara(word, "%s %s" % (thishead, h), "%s %d" % (header_style, min(level, maxlevel)))
		writeNodeAndTree(word, header_style, level+1, maxlevel, usesections, thishead, child)
</t>
<t tx="T726">def cmd_Export(event):
	
	"""Export the current node to Word"""

	try:
		word = getWordConnection()
		if word:
			header_style = getConfiguration().get("Main", "Header_Style")
			# Based on the rst plugin
			es("Writing tree to Word",color="blue")
			config = getConfiguration()
			writeNodeAndTree(word,
				config.get("Main", "header_style").strip(),
				1,
				int(config.get("Main", "max_headings")),
				config.get("Main", "use_section_numbers") == "Yes",
				"")						 
			es("Done!")
	except Exception,err:
		es("Failed to connect to Word",color="blue")
		es("Please make sure an empty word document is open.")</t>
<t tx="T727">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading

</t>
<t tx="T728"></t>
<t tx="T729">"""Open any empty file as a minimal .leo file"""

from leoPlugins import *
from leoGlobals import *

&lt;&lt; define minimal .leo file &gt;&gt;
@others

if 0: # Register the handlers...
	registerHandler("open1", onOpen)
	
	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T730">empty_leo_file = """&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/&gt;
&lt;globals body_outline_ratio="0.5"&gt;
	&lt;global_window_position top="145" left="110" height="24" width="80"/&gt;
	&lt;global_log_window_position top="0" left="0" height="0" width="0"/&gt;
&lt;/globals&gt;
&lt;preferences allow_rich_text="0"&gt;
&lt;/preferences&gt;
&lt;find_panel_settings&gt;
	&lt;find_string&gt;&lt;/find_string&gt;
	&lt;change_string&gt;&lt;/change_string&gt;
&lt;/find_panel_settings&gt;
&lt;vnodes&gt;
&lt;v a="V"&gt;&lt;vh&gt;NewHeadline&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;"""</t>
<t tx="T731">def onOpen (tag,keywords):

	import os
	file_name = keywords.get('fileName')

	if file_name and os.path.getsize(file_name)==0:
		# Rewrite the file before really opening it.
		es("rewriting empty .leo file: %s" % (file_name))
		file = open(file_name,'w')
		file.write(empty_leo_file)
		file.flush()
		file.close()

</t>
<t tx="T732">@language python

"""Opens up cmd and explorer window to same directory 
as @file nodes or children ..."""

&lt;&lt; about the open shell plugin &gt;&gt;

import leo,os,os.path,sys
from leoPlugins import *
from leoGlobals import *

pathToExplorer = 'c:/windows/explorer.exe'
pathToCmd = 'c:/windows/system32/cmd.exe'

@others

if 0: # Register the plugin

	registerHandler("after-create-leo-frame", load_menu)
	__version__ = "1.3"
	plugin_signon(__name__)</t>
<t tx="T733">@ Written by Ed Taekema.  Modified by E.K.Ream

Please submit bugs / feature requests to etaekema@earthlink.net"""

This is a simple plugin for leo 3.12 that allows the user to open either an xterm on linux or a cmd windows/explorer window on win32 in the directory of the current @file.  This allows quick navigation to facilitate testing and navigating large systems with complex direcgtories.

Current limitations ...

1. Not tested on Mac OS X ...
2. On win32, the cmd window will not open in the right directory if the @file location is on a different drive than the .leo file that is being edited.
3. On linux, xterm must be in your path.
</t>
<t tx="T734">def load_menu(tag,keywords):
	
	if sys.platform=="win32":
		table = (
			("&amp;Open Console Window",None,launchCmd),
			("Open &amp;Explorer",None,launchExplorer)) 
	else:
		table = ( ("Open &amp;xterm",None,launchxTerm), ) 
	
	top().frame.createNewMenu("E&amp;xtensions","top")
	top().frame.createMenuItemsFromTable("Extensions",table)
</t>
<t tx="T735">def _getpath(c,v):
	dict = scanDirectives(c,v)
	d = dict.get("path")

	if d == None:

		if v.isAtFileNode():
			filename = v.atFileNodeName()
		if v.isAtNoSentinelsFileNode():
			filename = v.atNoSentinelsFileNodeName()
		if v.isAtRawFileNode():
			filename = v.atRawFileNodeName()
		if v.isAtSilentFileNode():
			filename = v.atSilentFileNodeName()

		d = os.path.dirname(filename)

	d = os.path.normpath(d)
	return d
</t>
<t tx="T736">def _getCurrentNodePath():
	c = leo.top()
	v = c.currentVnode()
	f = v.atFileNodeName()
	d = _getpath(c,v)
	return d
</t>
<t tx="T737">def launchCmd(not_used):
	
	global pathToCmd

	d = _getCurrentNodePath()
	myCmd = 'cd ' + d
	os.spawnl(os.P_NOWAIT, pathToCmd, '/k ', myCmd)</t>
<t tx="T738">def launchExplorer(not_used):
	
	global pathToExplorer

	d = _getCurrentNodePath()
	os.spawnl(os.P_NOWAIT,pathToExplorer, ' ', d)

</t>
<t tx="T739">def launchxTerm(not_used):

	d = _getCurrentNodePath()
	curdir = os.getcwd()
	os.chdir(d)
	os.spawnlp(os.P_NOWAIT, 'xterm', '-title Leo')
	os.chdir(curdir)</t>
<t tx="T740">In Python 2.3 the source files should declare the encoding.

See http://www.python.org/peps/pep-0263.html for full details.</t>
<t tx="T741">@first # -*- coding: utf-8 -*-

"""Translate a few menu items into French"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler(("start1","menu1"), onMenu)
	
	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T742">@ The translation table used by setRealMenuNamesFromTable has entries of the form:

	("official name","translated name"),

Ampersands in the translated name indicate that the following character is to be underlined.

The official name can be any name equivalent to the standard English menu names.  Leo "canonicalizes" the official name by converting to lower case and removing any non-letters.  Thus, the following are  equivalent:
	("Open...","&amp;Ouvre"),
	("open",   "&amp;Ouvre"),
	("&amp;Open",  "&amp;Ouvre"),
@c
def onMenu (tag,keywords):
	table = (
		("Open...","&amp;Ouvre"),
		("OpenWith","O&amp;uvre Avec..."),
		("close","&amp;Ferme"),
		("Undo Typing","French &amp;Undo Typing"), # Shows you how much French I know ;-)
		("Redo Typing","French &amp;Redo Typing"),
		("Can't Undo", "French Can't Undo"),
		("Can't Redo", "French Can't Redo"))
	# Call the convenience routine to do the work.
	app().setRealMenuNamesFromTable(table)
</t>
<t tx="T743">@first # -*- coding: utf-8 -*-
@language python

"""traduit les menus en Franais"""

# French translation completed by Frdric Mommja, Spring 2003

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler(("start1","menu1"), onMenu)
	
	__version__ = "1.4" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T744">def onMenu (tag,keywords):
	table = (
		("File","&amp;Fichier"),
			("New","&amp;Nouveau"),
			("Open...","&amp;Ouvrir"),
			("OpenWith","Ouvrir Ave&amp;c..."),
			("Close","&amp;Fermer"),
			("Save","Enregi&amp;strer"),
			("Save As","Enre&amp;gistrer sous..."),
			("Save To","Enregistrer une co&amp;pie..."),
			("Revert To Saved","&amp;Version Enregistre"),
			("Recent Files...","&amp;Fichiers rcents..."),
			("Read/Write...", "&amp;Lire/crire..."),
				("Read Outline Only", "Relire &amp;Arborescence seule"),
				("Read @file Nodes", "Relire Structure @&amp;file seule"),
				("Write missing @file Nodes", "crire @file &amp;manquants sur Disque"),
				("Write Outline Only", "crire Arborescence &amp;seule"),
				("Write @file Nodes", "crire &amp;Noeuds @file seuls"),
			("Tangle...", "&amp;Transfrer (Tangle)..."),
				("Tangle All", "&amp;Tout"),
				("Tangle Marked", "Noeuds &amp;Marqus"),
				("Tangle", "&amp;Slection"),
			("Untangle...", "&amp;Ramener (Untangle)..."),
				("Untangle All", "&amp;Tout"),
				("Untangle Marked", "Noeuds &amp;Marqus"),
				("Untangle", "&amp;Slection"),
			("Import...", "&amp;Importer..."),
				("Import To @file", "Dans Structure @&amp;file"),
				("Import To @root", "Dans Structure @&amp;root"),
				("Import CWEB Files", "Fichier &amp;CWEB"),
				("Import noweb Files", "Fichier &amp;Noweb"),
				("Import Flattened Outline", "Fichier &amp;MORE"),
			("Export...", "&amp;Exporter..."),
				("Export Headlines", "&amp;Enttes Noeuds descendants vers .txt"),
				("Outline To CWEB", "Arborescence vers &amp;CWEB"),
				("Outline To Noweb", "Arborescence vers &amp;Noweb"),
				("Flatten Outline", "Arborescence vers &amp;MORE"),
				("Remove Sentinels", "En supprimant &amp;Sentinelles"),
				("Weave", "&amp;Arborescence descendante vers .txt"),
			("Exit","&amp;Quitter"),
		("Edit","&amp;Edition"),
			("Undo Typing","Ann&amp;uler saisie"),
			("Redo Typing","&amp;Rpter saisie"),
			("Can't Undo", "Impossible d'annuler"),
			("Can't Redo", "Impossible de rpter"),
			("Cut", "C&amp;ouper"),
			("Copy", "Co&amp;pier"),
			("Paste", "Co&amp;ller"),
			("Delete", "&amp;Supprimer"),
			("Select All", "&amp;Tout Slectionner"),
			("Edit Body...", "diter &amp;Contenu..."),
				("Extract Section", "E&amp;xtraire Section"),
				("Extract Names", "Extraire &amp;Noms de Sections"),
				("Extract", "&amp;Extraire Slection"),
				("Convert All Blanks", "Convertir Espaces &amp;Arborescence"),
				("Convert All Tabs", "Convertir Tabulations Ar&amp;borescence"),
				("Convert Blanks", "Convertir &amp;Espaces"),
				("Convert Tabs", "Convertir &amp;Tabulations"),
				("Insert Body Time/Date", "Insrer la &amp;Date/Heure"),
				("Reformat Paragraph", "Reformater &amp;Paragraphe"),
				("Indent", "&amp;Indenter"),
				("Unindent", "D&amp;sindenter"),
				("Match Brackets", "&amp;Vrifier Parit des Signes"), #  &lt;({["), #EKR
			("Edit Headline...", "diter &amp;Entte..."),
				("Edit Headline", "&amp;Modifier l'Entte"),
				("End Edit Headline", "Modification &amp;Termine"),
				("Abort Edit Headline", "&amp;Annuler Modification"),
				("Insert Headline Time/Date", "Insrer la &amp;Date/Heure"),
				("Toggle Angle Brackets", "Ajouter/supprimer Marques de &amp;Section"),
			("Find...", "C&amp;hercher..."),
				("Find Panel", "Dialogue de Re&amp;cherche"),
				("Find Next", "Chercher &amp;Suivant"),
				("Find Previous", "Chercher &amp;Prcdent"),
				("Replace", "&amp;Remplacer"),
				("Replace, Then Find", "Remplacer Chercher  &amp;Nouveau"),
			("Go To Line Number", "&amp;Atteindre Ligne No..."),
			("Execute Script", "E&amp;xcuter un Script Python"),
			("Set Font...", "&amp;Dfinir les Polices..."),
			("Set Colors...", "D&amp;finir les Couleurs..."),
			("Show Invisibles", "Afficher Caractres &amp;invisibles"),
			("Hide Invisibles", "Masquer Caractres &amp;invisibles"),
			("Preferences", "Prfre&amp;nces"),
		("Outline", "Arb&amp;orescence"),
			("Cut Node", "Co&amp;uper le Noeud"),
			("Copy Node", "C&amp;opier le Noeud"),
			("Paste Node", "Co&amp;ller le Noeud"),
			("Delete Node", "&amp;Supprimer le Noeud"),
			("Insert Node", "Ins&amp;rer un Noeud"),
			("Clone Node", "Clo&amp;ner le Noeud"),
			("Sort Children", "&amp;Trier les Noeuds Enfants"),
			("Sort Siblings", "Trier le Ni&amp;veau"),
			("Expand/Contract...", "&amp;Dployer/Refermer"),
				("Contract All", "&amp;Tout Refermer"),
				("Contract Node", "&amp;Refermer Noeud"),
				("Contract Parent", "Refermer Noeud &amp;Parent"),
				("Expand Prev Level", "Dployer Niveau pr&amp;cdent"),
				("Expand Next Level", "Dployer Niveau &amp;suivant"),
				("Expand To Level 1", "Dployer &amp;1 Niveau"),
				("Expand To Level 2", "Dployer &amp;2 Niveaux"),
				("Expand To Level 3", "Dployer &amp;3 Niveaux"),
				("Expand To Level 4", "Dployer &amp;4 Niveaux"),
				("Expand To Level 5", "Dployer &amp;5 Niveaux"),
				("Expand To Level 6", "Dployer &amp;6 Niveaux"),
				("Expand To Level 7", "Dployer &amp;7 Niveaux"),
				("Expand To Level 8", "Dployer &amp;8 Niveaux"),
				("Expand All", "Tout &amp;Dployer"),
				("Expand Node", "Dplo&amp;yer Noeud"),
			("Move...", "D&amp;placer..."),
				("Move Down", "Vers le &amp;Bas"),
				("Move Left", "Vers la &amp;Gauche"),
				("Move Right", "Vers la &amp;Droite"),
				("Move Up", "Vers le &amp;Haut"),
				("Promote", "&amp;Enfants vers la Gauche"),
				("Demote", "&amp;Noeuds suivants vers la Droite"),
			("Mark/Unmark...", "Mar&amp;quage..."),
				("Mark", "&amp;Marquer/Effacer Marque"),
				("Mark Subheads", "Marquer En&amp;fants"),
				("Mark Changed Items", "Marquer &amp;Noeuds modifis"),
				("Mark Changed Roots", "Marquer @&amp;root modifis"),
				("Mark Clones", "Marquer &amp;Clones"),
				("Unmark All", "&amp;Effacer toutes les Marques"),
			("Go To...", "Se Dpla&amp;cer vers..."),
				("Go To Next Marked", "&amp;Marque suivante"),
				("Go To Next Changed", "M&amp;odification suivante"),
				("Go To Next Clone", "&amp;Clone suivant"),
				("Go To First Node", "&amp;Premier Noeud"),
				("Go To Last Node", "&amp;Dernier Noeud"),
				("Go To Parent", "&amp;Noeud Parent"),
				("Go To Prev Sibling", "Noe&amp;ud prcdent"),
				("Go To Next Sibling", "Noeud &amp;suivant"),
				("Go To Prev Visible", "Noeud &amp;Visible prcdent"),
				("Go To Next Visible", "Noeud V&amp;isible suivant"),
				("Go Back", "De&amp;rnire Position"),
				("Go Next", "Posi&amp;tion suivante"),
		("Window", "Fen&amp;tre"),
			("Equal Sized Panes", "Panneaux de &amp;mme taille"),
			("Toggle Active Pane", "&amp;Bascule Panneau actif"),
			("Toggle Split Direction", "Bascule &amp;Horiz/Vert"),
			("Cascade", "Fentres Leo en &amp;Cascade"),
			("Minimize All", "&amp;Rduit toutes les Fentres"),
			("Open Compare Window", "Ouvrir Fentre de Com&amp;paraison..."),
			("Open Python Window", "Ouvrir Fentre Python (IDLE)..."),
		("Help", "&amp;Aide"),
			("About Leo...", "Au &amp;sujet de Leo..."),
			("Online Home Page", "&amp;Page d'Accueil en ligne"),
			("Open Online Tutorial", "Ouvrir &amp;Tutoriel en ligne"),
			("Open LeoDocs.leo", "Ouvrir Leo&amp;Docs.leo"),
			("Open LeoConfig.leo", "Ouvrir Leo&amp;Config.leo"),
			("Apply Settings", "Appliquer les &amp;Rglages"))
	# Call the convenience routine to do the work.
	app().setRealMenuNamesFromTable(table)
</t>
<t tx="T745"></t>
<t tx="T746">"""Rebind up/down arrow keys"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("open2", onOpen)
	
	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T747"># Warning: the bindings created this way conflict with shift-arrow keys.

def onOpen (tag,keywords):

	c = keywords.get("new_c")
	body = c.frame.body
	tree = c.frame.tree

	# Add "hard" bindings to have up/down arrows move by visual lines.
	old_binding = body.bind("&lt;Up&gt;")
	if len(old_binding) == 0:
		body.bind("&lt;Up&gt;",tree.OnUpKey)

	old_binding = body.bind("&lt;Down&gt;")
	if len(old_binding) == 0:
		body.bind("&lt;Down&gt;",tree.OnDownKey)
</t>
<t tx="T748"></t>
<t tx="T749"></t>
<t tx="T750">"""Create a Plugins menu"""

# Written by Paul A. Paterson.  Revised by Edward K. Ream.

## To do: confine the imports to the plugins directory.
## This does _not_ happen now!  import test gets a module from the Python directory!

## To do: add Revert button to each dialog.

from leoPlugins import *
from leoGlobals import *
import ConfigParser,glob,os,sys,Tkinter

Tk = Tkinter

@others

if 1: # Register the handlers...

	if app.gui is None:
		app.createTkGui(__file__)

	if app.gui.guiName() == "tkinter":
		registerHandler("create-optional-menus",createPluginsMenu)
		
		__version__ = "1.2"
		plugin_signon(__name__)</t>
<t tx="T751">class PlugIn:

	"""A class to hold information about one plugin"""

	@others
	
</t>
<t tx="T752">def __init__(self, filename):

	"""Initialize the plug-in"""

	# Import the file to find out some interesting stuff
	# Do not use the imp module: we only want to import these files once!
	self.mod = self.doc = self.version = None
	try:
		self.mod = __import__(os.path.splitext(os.path.basename(filename))[0])
		if not self.mod:
			return
		self.name = self.mod.__name__
		self.doc = self.mod.__doc__
		self.version = self.mod.__dict__.get("__version__") # "&lt;unknown&gt;")
		# if self.version: print self.version,shortFileName(filename)
	except: return

	&lt;&lt; Check if this can be configured &gt;&gt;
	&lt;&lt; Check if this has an apply &gt;&gt;
	&lt;&lt; Look for additional commands &gt;&gt;</t>
<t tx="T753"># Look for a configuration file
self.configfilename = "%s.ini" % os.path.splitext(filename)[0]
self.hasconfig = os.path.isfile(self.configfilename)
</t>
<t tx="T754">@ Look for an apply function ("applyConfiguration") in the module.

This is used to apply changes in configuration from the properties window
@c

self.hasapply = hasattr(self.mod, "applyConfiguration")
</t>
<t tx="T755">@ Additional commands can be added to the plugin menu by having functions in the module called "cmd_whatever". These are added to the main menu and will be called when clicked
@c

self.othercmds = {}

for item in self.mod.__dict__.keys():
	if item.startswith("cmd_"):
		self.othercmds[item[4:]] = self.mod.__dict__[item]
</t>
<t tx="T756">def about(self, arg):
	
	"""Put up an "about" dialog for this plugin"""

	PluginAbout(self.name, self.version, self.doc)</t>
<t tx="T757">def properties(self, arg):
	
	"""Create a modal properties dialog for this plugin"""

	PropertiesWindow(self.configfilename, self)
</t>
<t tx="T758">class PropertiesWindow:

	"""A class to create and run a Properties dialog for a plugin"""

	@others</t>
<t tx="T759">def __init__(self, filename, plugin):

	"""Initialize the property window"""
	
	&lt;&lt; initialize all ivars &gt;&gt;
	&lt;&lt; create the frame from the configuration data &gt;&gt;</t>
<t tx="T760"># config stuff.
config = ConfigParser.ConfigParser()
config.read(filename)
self.filename = filename
self.config = config
self.plugin = plugin

# self.entries is a list of tuples (section, option, e),
# where section and options are strings and e is a Tk.Entry widget.
# This list is used by writeConfiguration to write all settings.
self.entries = []
</t>
<t tx="T761">root = app().root

&lt;&lt; Create the top level and the main frame &gt;&gt;
&lt;&lt; Create widgets for each section and option &gt;&gt;
&lt;&lt; Create Ok, Cancel and Apply buttons &gt;&gt;

center_dialog(top) # Do this after packing.
top.grab_set() # Make the dialog a modal dialog.
top.focus_force() # Get all keystrokes.
root.wait_window(top)</t>
<t tx="T762">self.top = top = Tk.Toplevel(root)
attachLeoIcon(self.top)
top.title("Properties of "+ plugin.name)
top.resizable(0,0) # neither height or width is resizable.
	
self.frame = frame = Tk.Frame(top)
frame.pack(side="top")</t>
<t tx="T763"># Create all the entry boxes on the screen to allow the user to edit the properties
sections = config.sections()
sections.sort()
for section in sections:
	# Create a frame for the section.
	f = Tk.Frame(top, relief="groove",bd=2)
	f.pack(side="top",padx=5,pady=5)
	Tk.Label(f, text=section.capitalize()).pack(side="top")
	# Create an inner frame for the options.
	b = Tk.Frame(f)
	b.pack(side="top",padx=2,pady=2)
	# Create a Tk.Label and Tk.Entry for each option.
	options = config.options(section)
	options.sort()
	row = 0
	for option in options:
		e = Tk.Entry(b)
		e.insert(0, config.get(section, option))
		Tk.Label(b, text=option).grid(row=row, col=0, sticky="e", pady=4)
		e.grid(row=row, col=1, sticky="ew", pady = 4)
		row += 1
		self.entries.append((section, option, e))</t>
<t tx="T764">box = Tk.Frame(top, borderwidth=5)
box.pack(side="bottom")

list = [("OK",self.onOk),("Cancel",top.destroy)]
if plugin.hasapply:
	list.append(("Apply",self.onApply),)

for text,f in list:
	Tk.Button(box,text=text,width=6,command=f).pack(side="left",padx=5)</t>
<t tx="T765">def onApply(self):
	
	"""Event handler for Apply button"""
	self.writeConfiguration()
	self.plugin.mod.applyConfiguration(self.config)

def onOk(self):

	"""Event handler for Ok button"""
	self.writeConfiguration()
	self.top.destroy()</t>
<t tx="T766">def writeConfiguration(self):
	
	"""Write the configuration to disk"""

	# Set values back into the config item.
	for section, option, entry in self.entries:
		self.config.set(section, option, entry.get())

	# Write out to the file.
	f = open(self.filename, "w")
	self.config.write(f)
	f.close()
</t>
<t tx="T767">class PluginAbout:
	
	"""A class to create and run an About Plugin dialog"""
	
	@others
</t>
<t tx="T768">def __init__(self, name, version, about):
	
	"""# Create and run a modal dialog giving the name,
	version and description of a plugin.
	"""

	root = app().root
	self.top = top = Tk.Toplevel(root)
	attachLeoIcon(self.top)
	top.title("About " + name)
	top.resizable(0,0) # neither height or width is resizable.
	
	frame = Tk.Frame(top)
	frame.pack(side="top")
	&lt;&lt; Create the contents of the about box &gt;&gt;
	&lt;&lt; Create the close button &gt;&gt;
	
	center_dialog(top) # Do this after packing.
	top.grab_set() # Make the dialog a modal dialog.
	top.focus_force() # Get all keystrokes.
	root.wait_window(top)</t>
<t tx="T769">if 0: # The name is now in the window's title.
	Tk.Label(frame, text="Name:").grid(row=0, col=0, sticky="E")
	Tk.Label(frame, text=name).grid(row=0, col=1, sticky="W")
	Tk.Label(frame, text="Version").grid(row=1, col=0, sticky="E")
	Tk.Label(frame, text=version).grid(row=1, col=1, sticky="W")
	Tk.Label(frame, text=about, borderwidth=10, justify="left").grid(columnspan=2)
else:
	Tk.Label(frame, text="Version " + version).pack()
	Tk.Label(frame, text=about, borderwidth=10).pack()</t>
<t tx="T770">buttonbox = Tk.Frame(top, borderwidth=5)
buttonbox.pack(side="bottom")

self.button = Tk.Button(buttonbox, text="Close", command=top.destroy)
self.button.pack(side="bottom")</t>
<t tx="T771">def createPluginsMenu (tag,keywords):

	c = keywords.get("c")
	old_path = sys.path[:] # Make a _copy_ of the path.

	path = os.path.join(app().loadDir,"..","plugins")
	sys.path = path
	
	if os.path.exists(path):
		# Create a list of all active plugins.
		files = glob.glob(os.path.join(path,"*.py"))
		files.sort()
		plugins = [PlugIn(file) for file in files]
		items = [(p.name,p) for p in plugins if p.version]
		if items:
			items.sort()
			c.pluginsMenu = pluginMenu = c.frame.createNewMenu("&amp;Plugins")
			&lt;&lt; add items to the plugins menu &gt;&gt;
			
	sys.path = old_path


</t>
<t tx="T772">for name,p in items:
	if p.hasconfig:
		m = c.frame.createNewMenu(p.name, "&amp;Plugins")
		table = [("About...", None, p.about),
				 ("Properties...", None, p.properties)]
		if p.othercmds:
			table.append(("-", None, None))
			items = [(cmd,None,fn) for cmd,fn in p.othercmds.iteritems()]
			items.sort()
			table.extend(items)
		c.frame.createMenuEntries(m, table)
	else:
		table = ((p.name, None, p.about),)
		c.frame.createMenuEntries(pluginMenu, table)</t>
<t tx="T773">@ignore
@language python

"""Test file for Plugins menu protocols"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...

	if app.gui is None:
		app.createTkGui(__file__)

	if app.gui.guiName() == "tkinter":

		registerHandler("select2", onSelect)
		registerHandler("unselect1", onUnselect)
		
		__version__ = "1.1"
		plugin_signon(__name__)</t>
<t tx="T774">def applyConfiguration(config):
	
	sections = config.sections()
	sections.sort()

	for section in sections:
		options = config.options(section)
		options.sort()
		for option in options:
			print section, option, config.get(section, option)
</t>
<t tx="T775">def cmd_fn1(x):
	es("Fn1",color="blue")

def cmd_fn2(x):
	es("Fn2",color="blue")

def cmd_fn3(x):
	es("Fn3",color="blue")
</t>
<t tx="T776">def onSelect (tag,keywords):

	import Tkinter,os

	new_v = keywords.get("new_v")
	h = new_v.headString()
	if h[:7] == "@image ":
		filename = h[7:]
		&lt;&lt; Select Image &gt;&gt;</t>
<t tx="T777"># Display the image file in the text pane, if you can find the file
a = app()
c = keywords.get("c")
body = c.frame.body

if os.path.isfile(filename):
	try:
		# Note that Tkinter only understands GIF
		photo = Tkinter.PhotoImage(master=a.root, file=filename)
	except:
		es("error: cannot load image")
		return
	# Nicely display the image at the center top and push the text below.
	a.gsphoto = photo # This is soooo important.
	photoWidth = photo.width()
	bodyWidth = body.winfo_width()
	padding = int((bodyWidth - photoWidth - 16) / 2)
	padding = max(0,padding)
	a.gsimage = body.image_create("1.0",image=photo,padx=padding)
else:
	es("warning: missing image file")</t>
<t tx="T778">def onUnselect (tag,keywords):

	import Tkinter, os.path
	a = app()
	c = keywords.get("c")
	old_v = keywords.get("old_v")

	if old_v:
		h = old_v.headString()
		if h[:7] == "@image ":
			&lt;&lt; Unselect Image &gt;&gt;
	else: # Leo is initializing.
		a.gsphoto = None # Holds our photo file
		a.gsimage = None # Holds our image instance within the text pane</t>
<t tx="T779"># Erase image if it was previously displayed
if a.gsimage:
	try:
		 c.frame.body.delete(a.gsimage)
	except:
		es("info: no image to erase")

# And forget about it
a.gsimage = None
a.gsphoto = None
</t>
<t tx="T780">@nocolor</t>
<t tx="T781">Reorganized the code so I can find various classes more easily.
Used @others to simply the outline.

Sorted all entries in dialogs.
Sorted all entries in Plugins menu, regardless of whether they are configurable.

For all dialogs:
	Added top ivar and removed root/master params and ivars.
	Added Leo icon and title.
	Centered dialogs.

Ctors now run all dialogs as modal dialogs: this could easily be undone.

Used a grid in the properties dialog to align widgets.</t>
<t tx="T782">- We will use a new settings file called leoSettings.txt:
- Each setting will have its _own section_ in leoSettings.txt with the following items (most optional)
	val = present value of settings: Use parent setting if this does not exist.
	help = help string (displayed near setting if it exists)
	prompt = prompt string (defaults to setting name, i.e., the section name)
	group = name of group dialog containing this item (use general section if this does not exist)
	type = one of the following:
		value			meaning
		bool			followed by true/false prompts for radio buttons
		color			color picker
		font			font picker
		parent			name of parent config file (set/get setting in that file)
		entry			followed by arbitrary text in an entry widget
		text			followed by arbitrary text in a text widget
		number			any number, or followed by a range of valid values for an entry widget.
		numberlist  followed by a list valid values for a listbox.
		list			followed by a list of valid strings in a listbox.
Notes:
- We could use yaml or ConfigParser or Pickle.  yaml might be best.
- The options dialog will have a separate frame for each group or subgroup.
- We will want a Create Options file command (useful for converting old leoConfig.txt files)
- All options may have a use parent settings (for all widgets?)
- The separate "Groups" section may indicate which groups are subgroups of other groups for multi-level displays.</t>
<t tx="T783">I wrote myself a plug-in which would automatically save the Leo file every so often and in doing so realized that it would be useful to be able to configure the interval between saves. Anyway, to cut a long story short, I generalized the idea and came up with the attached patch. 
 
All code resides under the "Plug in changes" node. The additions are all under the "create the plug-in menu" node with another couple of lines in "createMenuBar". Structurally this is ugly - but it helps keep all the changes in one place!
 
The basic idea is to allow plug-ins to be configured and also allow them to expose additional functions which can be accessed by a menu item. The advantage is that people don't have to mess with adding menus to Leo. Existing plug-ins don't need to be changed in any way to work with the new patch.
 
Ok, here's what it does....
 
1. A new "Plug-ins" menu item is added
 
2. Each plug-in gets an "About x...." entry.
 
    - clicking on "About x..." brings up an about box which shows name, version and documentation for the plug in
    - name comes from the module name
    - version is the module __version__ if present
    - documentation is the module docstring 
 
3. If the plug-in is configurable then a sub menu is created
 
    - configurable means that a corresponding ".ini" file is found with the same names as the plug-in (ie mod_image.py has mod_image.ini)
    - the sub menu contains
        - the "About x..." as before
        - a "Properties..." menu entry to edit the properties (*)
 
4. A further search is made for plug-in specific commands
 
    - we look for functions called "cmd_*" in the module
    - if found we add them to the plug-in menu
    - when you click on the menu item the function is called with a single parameter
 
(*) How does the property window work,
 
5. The property window reads the ini file which is assumed to be in standard ini file format (ie sections and parameters)
    - each section gets a frame in the window
    - each property gets an entry box
 
6. From the property window the user can "Cancel" or "OK", which saves changes
 
7. If the module contains an "applyConfiguration" function then there is also an "Apply" button on the form. The apply configuration function is called with the current configuration when the "Apply" button is pressed.
</t>
<t tx="T784">"""Create a Scripts menu for LeoPy.leo"""

from leoPlugins import *
from leoGlobals import *
import glob,os

@others

if 1: # Register the handlers...
	registerHandler("create-optional-menus",createScriptsMenu)
	
	__version__ = "1.4"
	plugin_signon(__name__)</t>
<t tx="T785">def createScriptsMenu (tag,keywords):

	c = keywords.get("c")
	path = os.path.join(app().loadDir,"..","scripts")
	
	if os.path.exists(path):

		# Create lists of scripts and subdirectories.
		entries = glob.glob(os.path.join(path,"*"))
		top_scripts = glob.glob(os.path.join(path,"*.py"))
		dirs = [f for f in entries if os.path.isdir(f)]
		&lt;&lt; Return if no scripts exist anywhere &gt;&gt;
	
		scriptsMenu = c.frame.createNewMenu("&amp;Scripts")
		table = []
		&lt;&lt; Create top-level entries for every script in top_scripts &gt;&gt;
		for dir in dirs:
			files = glob.glob(os.path.join(dir,"*.py"))
			if files:
				&lt;&lt; Create a submenu for dir containing each file in files &gt;&gt;</t>
<t tx="T786">if not top_scripts:
	found = false
	for dir in dirs:
		scripts = glob.glob(os.path.join(dir,"*.py"))
		if scripts:
			found = true ; break
	if not found:
		return
</t>
<t tx="T787">table = []
top_scripts.sort()
for script in top_scripts:
	name = shortFileName(script)
	def doScript(event=None,name=name):
		executeScript(name)
	table.append((name,None,doScript),)
	
c.frame.createMenuEntries(scriptsMenu, table)
</t>
<t tx="T788"># Create the submenu.
name = os.path.join("scripts",shortFileName(dir))
menu = c.frame.createNewMenu(name,"&amp;Scripts")

# Populate the submenu.
table = []
for file in files:
	name = shortFileName(file)
	def doScript(event=None,name=name):
		from leoGlobals import executeScript
		executeScript(name)
	table.append((name,None,doScript),)

c.frame.createMenuEntries(menu, table)</t>
<t tx="T789"></t>
<t tx="T790">"""Synchronize @folder nodes with folders"""

from leoPlugins import *
from leoGlobals import *

&lt;&lt; about this plugin &gt;&gt;
@others

def onSelect (tag,keywords):
	v = keywords.get("new_v")
	h = v.headString()
	if match_word(h,0,"@folder"):
		sync_node_to_folder(v,h[8:])

if 0: # Register the handlers...
	registerHandler("select1", onSelect)

	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T791">@ If a node is named '@folder path_to_folder', the content (filenames) of the
folder and the children of that node will be sync. Whenever a new file is put
there, a new node will appear on top of the children list (with mark). So that
I can put my description (ie. annotation) as the content of that node. In this
way, I can find any files much easier from leo.

Moreover, I add another feature to allow you to group files(in leo) into
children of another group. This will help when there are many files in that
folder. You can logically group it in leo (or even clone it to many groups),
while keep every files in a flat/single directory on your computer.
</t>
<t tx="T792">def sync_node_to_folder(parent,d):

	oldlist = {}
	newlist = []
	#get children info
	v = parent
	after_v = parent.nodeAfterTree()
	while v != after_v:
		if not v.hasChildren():
			oldlist[v.headString()] = v.bodyString()
		v = v.threadNext()
	#compare folder content to children
	for name in os.listdir(d):
		if name in oldlist:
			del oldlist[name]
		else:
			newlist.append(name)
	#insert newlist
	newlist.sort()
	newlist.reverse()
	for name in newlist:
		v = parent.insertAsNthChild(0)
		v.setHeadStringOrHeadline(name)
		v.setMarked()
	#warn for orphan oldlist
	if len(oldlist)&gt;0:
		es('missing: '+','.join(oldlist.keys()))
</t>
<t tx="T793">"""Inhibit changes to @read-only nodes"""

# Contributed by Davide Salomoni &lt;dsalomoni@yahoo.com&gt;

from leoPlugins import *
from leoGlobals import *
import ftplib, urllib, urlparse, os, cStringIO, tkFileDialog
from formatter import AbstractFormatter, DumbWriter
from htmllib import HTMLParser

@others

if 0: # Register the handlers...

	if app.gui is None:
		app().createTkGui(__file__)

	if app.gui.guiName() == "tkinter":

		registerHandler(("start2","open2"), on_open2)
		registerHandler("bodykey1", on_bodykey1)
		registerHandler("headkey2", on_headkey2)
		if 0: # doesn't work: the cursor stops blinking.
			registerHandler("select1", on_select1)
			registerHandler("select2", on_select2)
	
		__version__ = "1.5" # Set version for the plugin handler.
		plugin_signon(__name__)
</t>
<t tx="T794">@ Dear Leo users,

Here's my first attempt at customizing leo. I wanted to have the ability to
import files in "read-only" mode, that is, in a mode where files could only
be read by leo (not tangled), and also kept in sync with the content on the
drive.

The reason for this is for example that I have external programs that generate
resource files. I want these files to be part of a leo outline, but I don't
want leo to tangle or in any way modify them. At the same time, I want them
to be up-to-date in the leo outline.

So I coded the directive plugin. It has the following characteristics:

- It reads the specified file and puts it into the node content.

- If the @read-only directive was in the leo outline already, and the file content
on disk has changed from what is stored in the outline, it marks the node as
changed and prints a "changed" message to the log window; if, on the other hand,
the file content has _not_ changed, the file is simply read and the node is
not marked as changed.

- When you write a @read-only directive, the file content is added to the node
immediately, i.e. as soon as you press Enter (no need to call a menu
entry to import the content).

- If you want to refresh/update the content of the file, just edit the headline
and press Enter. The file is reloaded, and if in the meantime it has changed,
a "change" message is sent to the log window.

- The body text of a @read-only file cannot be modified in leo.

Davide Salomoni
</t>
<t tx="T795">@ The syntax to access files in @read-only via ftp/http is the following:

@read-only http://www.ietf.org/rfc/rfc0791.txt
@read-only ftp://ftp.someserver.org/filepath

If FTP authentication (username/password) is required, it can be specified as follows:

@read-only ftp://username:password@ftp.someserver.org/filepath

For more details, see the doc string for the class FTPurl.
</t>
<t tx="T796">class FTPurl:
	"""An FTP wrapper class to store/retrieve files using an FTP URL.

    To create a connection, call the class with the constructor:

        FTPurl(url[, mode])

    The url should have the following syntax:
    
        ftp://[username:password@]remotehost/filename
    
    If username and password are left out, the connection is made using
    username=anonymous and password=realuser@host (for more information,
    see the documentation of module ftplib).
    
    The mode can be '' (default, for ASCII mode) or 'b' (for binary mode).
	This class raises an IOError exception if something goes wrong.
	"""
	
	@others
</t>
<t tx="T797">def __init__(self, ftpURL, mode=''):
	parse = urlparse.urlparse(ftpURL)
	if parse[0] != 'ftp':
		raise IOError, "error reading %s: malformed ftp URL" % ftpURL

	# ftp URL; syntax: ftp://[username:password@]hostname/filename
	self.mode = mode
	authIndex = parse[1].find('@')
	if authIndex == -1:
		auth = None
		ftphost = parse[1]
	else:
		auth = parse[1][:authIndex]
		ftphost = parse[1][authIndex+1:]
	self.ftp = ftplib.FTP(ftphost)
	if auth == None:
		self.ftp.login()
	else:
		# the URL has username/password
		pwdIndex = auth.find(':')
		if pwdIndex == -1:
			raise IOError, "error reading %s: malformed ftp URL" % ftpURL
		user = auth[:pwdIndex]
		password = auth[pwdIndex+1:]
		self.ftp.login(user, password)
	self.path = parse[2][1:]
	self.filename = os.path.basename(self.path)
	self.dirname = os.path.dirname(self.path)
	self.isConnectionOpen = 1
	self.currentLine = 0
</t>
<t tx="T798"></t>
<t tx="T799">def read(self):
	"""Read the filename specified in the constructor and return it as a string.
    If the constructor specifies no filename, or if the URL ends with '/',
    return the list of files in the URL directory.
	"""
	self.checkParams()
	if self.filename=='' or self.path[-1]=='/':
		return self.dir()

	try:
		if self.mode == '':  # mode='': ASCII mode
			slist = []
			self.ftp.retrlines('RETR %s' % self.path, slist.append)
			s = '\n'.join(slist)
		else: # mode='b': binary mode
			file = cStringIO.StringIO()
			self.ftp.retrbinary('RETR %s' % self.path, file.write)
			s = file.getvalue()
			file.close()
		return s
	except:
		exception, msg, tb = sys.exc_info()
		raise IOError, msg

</t>
<t tx="T800">def readline(self):
	"""Read one entire line from the remote file."""
	try:
		self.lst
	except AttributeError:
		self.lst = self.read().splitlines(1)
	
	if self.currentLine &lt; len(self.lst):
		s = self.lst[self.currentLine]
		self.currentLine = self.currentLine + 1
		return s
	else:
		return ''
</t>
<t tx="T801"></t>
<t tx="T802">def write(self, s):
	"""write(s) stores the string s to the filename specified in the
    constructor."""
	self.checkParams()
	if self.filename == '':
		raise IOError, 'filename not specified'
	
	try:
		file = cStringIO.StringIO(s)
		if self.mode == '':  # mode='': ASCII mode
			self.ftp.storlines('STOR %s' % self.path, file)
		else: # mode='b': binary mode
			self.ftp.storbinary('STOR %s' % self.path, file)
		file.close()
	except:
		exception, msg, tb = sys.exc_info()
		raise IOError, msg
</t>
<t tx="T803"></t>
<t tx="T804">def seek(offset=0):
	self.currentLine = 0  # we don't support fancy seeking via FTP
</t>
<t tx="T805">def flush():
	pass # no fancy stuff here.</t>
<t tx="T806">def dir(self, path=None):
	"""Issue a LIST command passing the specified argument and return output as a string."""
	s = []

	if path == None:
		path = self.dirname
	try:
		listcmd = 'LIST %s' % path
		self.ftp.retrlines(listcmd.rstrip(), s.append)
		return '\n'.join(s)
	except:
		exception, msg, tb = sys.exc_info()
		raise IOError, msg
</t>
<t tx="T807">def exists(self, path=None):
	"""Return 1 if the specified path exists. If path is omitted, the current file name is tried."""
	if path == None:
		path = self.filename

	s = self.dir(path)
	if s.lower().find('no such file') == -1:
		return 1
	else:
		return 0
</t>
<t tx="T808">def checkParams(self):
	if self.mode not in ('','b'):
		raise IOError, 'invalid mode: %s' % self.mode
	if not self.isConnectionOpen:
		raise IOError, 'ftp connection closed'
</t>
<t tx="T809">def close(self):
	"""Close an existing FTPurl connection."""
	try:
		self.ftp.quit()
	except:
		self.ftp.close()
	del self.ftp
	self.isConnectionOpen = 0</t>
<t tx="T810"># Alas, these do not seem to work on XP:
# disabling the body text _permanently_ stops the cursor from blinking.

def enable_body(body):
	global insertOnTime,insertOffTime
	if body.cget("state") == "disabled":
		try:
			es("enable")
			print insertOffTime,insertOnTime
			body.configure(state="normal")
			body.configure(insertontime=insertOnTime,insertofftime=insertOffTime)
		except: es_exception()
			
def disable_body(body):
	global insertOnTime,insertOffTime
	if body.cget("state") == "normal":
		try:
			es("disable")
			insertOnTime = body.cget("insertontime")
			insertOffTime = body.cget("insertofftime")
			print insertOffTime,insertOnTime
			body.configure(state="disabled")
		except: es_exception()
</t>
<t tx="T811"># Sets v's body text from the file with the given name.
# Returns true if the body text changed.
def insert_read_only_node (c,v,name):
	if name=="":
		name = tkFileDialog.askopenfilename(
			title="Open",
			filetypes=[("All files", "*")]
			)
		c.beginUpdate()
		v.setHeadString("@read-only %s" % name)
		c.endUpdate()
	parse = urlparse.urlparse(name)
	try:
		if parse[0] == 'ftp':
			file = FTPurl(name)  # FTP URL
		elif parse[0] == 'http':
			file = urllib.urlopen(name)  # HTTP URL
		else:
			file = open(name,"r")  # local file
		# es("..." + name)
		new = file.read()
		file.close()
	except IOError,msg:
		# es("error reading %s: %s" % (name, msg))
		# es("...not found: " + name)
		v.setBodyStringOrPane("") # Clear the body text.
		return true # Mark the node as changed.
	else:
		ext = os.path.splitext(parse[2])[1]
		if ext.lower() in ['.htm', '.html']:
			&lt;&lt; convert HTML to text &gt;&gt;
		previous = v.t.bodyString
		v.setBodyStringOrPane(new)
		changed = (toUnicode(new,'ascii') != toUnicode(previous,'ascii'))
		if changed and previous != "":
			es("changed: %s" % name) # A real change.
		return changed</t>
<t tx="T812">fh = cStringIO.StringIO()
fmt = AbstractFormatter(DumbWriter(fh))
# the parser stores parsed data into fh (file-like handle)
parser = HTMLParser(fmt)

# send the HTML text to the parser
parser.feed(new)
parser.close()

# now replace the old string with the parsed text
new = fh.getvalue()
fh.close()

# finally, get the list of hyperlinks and append to the end of the text
hyperlinks = parser.anchorlist
numlinks = len(hyperlinks)
if numlinks &gt; 0:
	hyperlist = ['\n\n--Hyperlink list follows--']
	for i in xrange(numlinks):
		hyperlist.append("\n[%d]: %s" % (i+1,hyperlinks[i])) # 3/26/03: was i.
	new = new + ''.join(hyperlist)</t>
<t tx="T813">#  scan the outline and process @read-only nodes.
def on_open2 (tag,keywords):
	
	
	if tag == "start2":
		c = top()
	else:
		c = keywords.get("new_c")

	v = c.rootVnode()
	es("scanning for @read-only nodes...",color="blue")
	c.beginUpdate()
	while v:
		h = v.headString()
		if match_word(h,0,"@read-only"):
			changed = insert_read_only_node(c,v,h[11:])
			if changed:
				if not v.isDirty():
					v.setDirty()
				if not c.isChanged():
					c.setChanged(changed)
		v = v.threadNext()
	c.endUpdate()
</t>
<t tx="T814"># override the body key handler if we are in an @read-only node.

def on_bodykey1 (tag,keywords):

	c = keywords.get("c")
	v = keywords.get("v")
	h = v.headString()
	if match_word(h,0,"@read-only"):
		# The following code causes problems with scrolling and syntax coloring.
		# Its advantage is that it makes clear that the text can't be changed,
		# but perhaps that is obvious anyway...
		if 0: # Davide Salomoni requests that this code be eliminated.
			# An @read-only node: do not change its text.
			body = c.frame.body
			body.delete("1.0","end")
			body.insert("1.0",v.bodyString())
		return 1 # Override the body key event handler.</t>
<t tx="T815"># update the body text when we press enter

def on_headkey2 (tag,keywords):

	c = keywords.get("c")
	v = keywords.get("v")
	h = v.headString()
	ch = keywords.get("ch")
	if ch == '\r' and match_word(h,0,"@read-only"):
		# on-the-fly update of @read-only directives
		changed = insert_read_only_node(c,v,h[11:])
		c.setChanged(changed)</t>
<t tx="T816">def on_select1 (tag,keywords):

	# Doesn't work: the cursor doesn't start blinking.
	# Enable the body text so select will work properly.
	c = keywords.get("c")
	enable_body(c.frame.body)
</t>
<t tx="T817">def on_select2 (tag,keywords):

	c = keywords.get("c")
	v = c.currentVnode()
	h = v.headString()
	if match_word(h,0,"@read-only"):
		disable_body(c.frame.body)
	else:
		enable_body(c.frame.body)
</t>
<t tx="T818">"""If a headline starts with @rst &lt;filename&gt;, double-clicking on it will 
write a file in outline order, with the headlines converted to reStructuredText 
section headings.
If the name of the &lt;filename&gt; has the extension .html or .htm, and if you have
docutils installed, it will generate HTML."""

# By Josef Dalcolmo: contributed under the same licensed as Leo.py itself.

# EKR: The code now lets other plugins handle @folder and @url nodes.

from leoPlugins import *
from leoGlobals import *

&lt;&lt; about this plugin &gt;&gt;
&lt;&lt; change log &gt;&gt;

@others

if 0: # Register the handlers...
	registerHandler("icondclick1",onIconDoubleClick)
	
	__version__ = "1.5" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T819">@ This plugin writes out @rst nodes as a reStructuredText file.

If the filename ends in .html or .htm and if you have docutils_ (a Python
module) installed, then it will be written as HTML. The HTML converter is far
from bug-free, but remember, docutils is alpha software. (Perhaps a future
version will allow automatic translation to other formats, like OpenOffice.org
as well).

Headlines are translated into reStructuredText headlines, e.g. underlined
depending on the level and empty line separated from body text otherwise, text
is written as it is. The "#" character is not used for underlining, so it may
be used for a title as in::

	#####
	Title
	#####

Otherwise, section underlining is discouraged, since it is automatically generated.

.. _docutils: http://docutils.sourceforge.net
</t>
<t tx="T820">@ Change log:

- New tree types: @rst has been added.

- EKR: The code now lets other plugins handle @folder and @url nodes.

- HTML generation: @rst nodes can now generate HTML, if Python docutils_ are
  installed. Simply give the filename an extension .htm or .html. You can try
  this out by renaming the filename in this @rst tree.

- underlines: I changed the order of the underline characters again. The "&gt;" is
  doesn't really look good as an underline in my opinion, so I moved it to a very
  low level.

- JD 2003-03-10 (rev 1.3): some more corrections to the unicode-&gt; encoding translation.
  No only check for missing docutils (doesn't mask other errors any more).

- JD 2003-03-11 (rev 1.4): separated out the file launching code to a different pluging.



</t>
<t tx="T821"># by Josef Dalcolmo 2003-01-13
#
# this does not check for proper filename syntax.
# path is the current dir, or the place @folder points to
# this should probably be changed to @path or so.

def onIconDoubleClick(tag,keywords):

	import os
	v = keywords.get("v")
	commands = keywords.get("c")
	h = v.headString().strip()
	if match_word(h,0,"@rst"):
		fname = h[5:]
		ext = os.path.splitext(fname)[1].lower()
		if ext in ('.htm','.html'):
			&lt;&lt; write rST as HTML &gt;&gt;
		else:
			&lt;&lt; write rST file &gt;&gt;
</t>
<t tx="T822">try:
	import docutils
except:
	docutils = None
	es('HTML generation requires docutils')
if docutils:
	import StringIO
	rstFile = StringIO.StringIO()
	writeTreeAsRst(rstFile, fname, v, commands)
	rstText = rstFile.getvalue()
	&lt;&lt; convert rST to HTML &gt;&gt;
	htmlFile = file(fname,'w')
	htmlFile.write(output)
	htmlFile.close()
	rstFile.close()
	es('written: '+`fname`)</t>
<t tx="T823"># this code snipped has been taken from code contributed by Paul Paterson 2002-12-05
from docutils.core import Publisher
from docutils.io import StringOutput, StringInput

pub = Publisher()
# Initialize the publisher
pub.source = StringInput(pub.settings, source=rstText)
pub.destination = StringOutput(pub.settings, encoding="utf-8")
pub.set_reader('standalone', None, 'restructuredtext')
pub.set_writer('html')
output = pub.publish()</t>
<t tx="T824">rstFile = file(fname,'w')
writeTreeAsRst(rstFile, fname, v, commands)
rstFile.close()
es('written: '+`fname`)</t>
<t tx="T825">def writeTreeAsRst(rstFile, fname, vnode, commands):
	'Writes the tree under vnode to the file rstFile (fname is the filename)'
	# we don't write a title, so the titlepage can be customized
	# use '#' for title under/overline
	# 3/7/03
	dict = scanDirectives(commands,v=vnode)
	encoding = dict.get("encoding",None)
	if encoding == None:
		encoding = app().config.default_derived_file_encoding
	# 3/7/03
	s = toEncodedString(fname,encoding,reportErrors=true)
	rstFile.write('.. filename: '+s+'\n')
	rstFile.write('\n')
	# 3/7/03
	s = vnode.bodyString()
	s = toEncodedString(s,encoding,reportErrors=true)
	rstFile.write(s+'\n')		# write body of titlepage
	rstFile.write('\n')
	
	toplevel = vnode.level()
	stopHere = vnode.nodeAfterTree()
	v = vnode.threadNext()
	# repeat for all nodes in this tree
	while v != stopHere:
		# 3/7/03
		h = v.headString()
		h = toEncodedString(h,encoding,reportErrors=true)
		rstFile.write(h+'\n')
		rstFile.write(underline(h,v.level()-toplevel))
		rstFile.write('\n')
		# 3/7/03
		s = v.bodyString()
		s = toEncodedString(s,encoding,reportErrors=true)
		rstFile.write(s+'\n')
		rstFile.write('\n')
		v = v.threadNext()</t>
<t tx="T826"># note the first character is intentionally unused, to serve as the underline
# character in a title (in the body of the @rst node)
def underline(h,level):
	str = """#=+*^~"'`-:&gt;&lt;_"""[level]
	return str*max(len(h),4)+'\n'</t>
<t tx="T827">"""Lauches (starts) a file with the name of the headline on double-clicking it.
Uses the @folder path if the headline is under an @folder headline.
Otherwise the path is relative to the Leo file.
Headlines starting with an '@' are ignored.
This does not work on Linux (yet)."""

# By Josef Dalcolmo: contributed under the same license as Leo.py itself.

from leoPlugins import *
from leoGlobals import *

&lt;&lt; about this plugin &gt;&gt;
&lt;&lt; change log &gt;&gt;

@others

if 0: # Register the handlers...
	registerHandler("icondclick1",onIconDoubleClick)
	
	__version__ = "1.1" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T828">@ This plugin starts a file with the name of a headline.


</t>
<t tx="T829">@ Change log

- JD: 2003-03-11 separated out from rst plugin



</t>
<t tx="T830"># @folder behavior after an idea and sample code by:
# korakot ( Korakot Chaovavanich ) @folder for files annotation 2002-11-27 02:39
# 
# open file (double-click = startfile) behavior added 
# nodes with @url, @folder, @rst are treated special
#
# by Josef Dalcolmo 2003-01-13
#
# this does not check for proper filename syntax.
# path is the current dir, or the place @folder points to
# this should probably be changed to @path or so.

def onIconDoubleClick(tag,keywords):

	import os
	v = keywords.get("v")
	commands = keywords.get("c")
	h = v.headString().strip()
	if len(h)==0 or h[0]=='@':
		return # Let other plugins handle these
	else:
		# open file with associated application
		&lt;&lt; find path and start file &gt;&gt;</t>
<t tx="T831"># Set the base directory by searching for @folder directives in ancestors.
try:
	basedir = os.curdir	# use current dir as default.
	parv = v.parent()	# start with parent
	while parv:	# stop when no more parent found
		p = parv.headString().strip()
		if match_word(p,0,'@folder'):
			basedir = p[8:]	# take rest of headline as pathname
			break	# we found the closest @folder
		else:
			parv = parv.parent()	# try the parent of the parent
	fname = os.path.join(basedir,h) # join path and filename
	os.startfile(fname)	# Try to open the file; it may not work for all file types.
except:
	es(os.path.join(os.getcwd(),fname)+' - file or application not found')
	es_exception()
</t>
<t tx="T832"></t>
<t tx="T833">from leoPlugins import *
from leoGlobals import *

@others

if 0: # Override classes &amp; methods...

	if 0:
		&lt;&lt; override the LeoFrame class &gt;&gt;

	if 0:
		&lt;&lt; override methods of the LeoApp class &gt;&gt;

	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T834"># print "overriding LeoFrame class"

import leoFrame

assert(leoFrame.leoCoreFrame.instances==0)

class myLeoFrame(leoFrame.leoCoreFrame):
	
	pass
	
	if 0:
		def __init__(self,title=None):
			print "myLeoFrame ctor",title
			leoFrame.leoCoreFrame.__init__(self,title)

leoFrame.LeoFrame = myLeoFrame</t>
<t tx="T835">import leoApp

# print "overriding app.closeLeoWindow"

oldAppCloseLeoWindow = app().closeLeoWindow

def myAppCloseLeoWindow(self,frame):
	
	global oldAppCloseLeoWindow

	oldAppCloseLeoWindow(frame)
	print "after closeLeoWindow"

funcToMethod(myAppCloseLeoWindow,leoApp.LeoApp,"closeLeoWindow")</t>
<t tx="T836">"""Override the Equal Sized Pane command"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("command1", onCommand)
	
	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T837">def onCommand (tag,keywords):

	if keywords.get("label")=="equalsizedpanes":
		es("over-riding Equal Sized Panes")
		return "override" # Anything other than None overrides.</t>
<t tx="T838">"""Redefine the "put" and "put_nl" methods"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("start2", onStart)
	
	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T839">@ This code illustrates how to redefine _any_ method of Leo.
Python makes this is almost too easy :-)
@c

def onStart (tag,keywords):

	import leoFrame
	
	# Replace frame.put with newPut.
	funcToMethod(newPut,leoFrame.LeoFrame,"put")
	
	# Replace frame.putnl with newPutNl.
	funcToMethod(newPutNl,leoFrame.LeoFrame,"putnl")
</t>
<t tx="T840"># Contrived examples of how to redefine frame.put and frame.putnl

# Same as frame.put except converts everything to upper case.
def newPut (self,s,color="black"):
	# print "newPut",s,
	if app().quitting &gt; 0: return
	s = s.upper()
	if self.log:
			self.log.insert("end",s)
			self.log.see("end")
			self.log.update_idletasks()
	else: print s,

# Same as frame.putnl except writes two newlines.
def newPutNl (self):
	# print "newPutNl"
	if app().quitting &gt; 0: return
	if self.log:
		self.log.insert("end","\n\n")
		self.log.see("end")
		self.log.update_idletasks()
	else: print</t>
<t tx="T841">"""Send all output to the log pane"""

from leoPlugins import *
from leoGlobals import *

def onStart (tag,keywords):
	from leoGlobals import redirectStdout,redirectStderr
	redirectStdout() # Redirect stdout
	redirectStderr() # Redirect stderr

if 0: # Register the handlers...
	registerHandler("start2", onStart)

	__version__ = "1.3" # Set version for the plugin handler.
	plugin_signon(__name__)

</t>
<t tx="T842">"""Send output from the Execute Script command to the end of the body pane"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("start1", onStart)

	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T843">def onStart (tag,keywords):
	
	import leoFrame
	
	# Replace frame.put with newPut.
	funcToMethod(newExecuteScript,leoFrame.LeoFrame,"OnExecuteScript")
</t>
<t tx="T844"># Execute the _selected_ body text as a Python script and sends the output to the end of the body pane.

def newExecuteScript(self,event=None,v=None):
	
	c = self.commands ; body = self.body ; s = None
	if v == None:
		v = c.currentVnode() 

	# Assume any selected body text is a script.
	start,end = getTextSelection(body)
	if start and end and start != end: # 7/7/03
		s = body.get(start,end)
	else:
		s = ""
	s = s.strip()
	if s and len(s) &gt; 0:
		s += '\n' # Make sure we end the script properly.
		try:
			# Switch output.
			import leoFrame,leoGlobals
			oldput = leoFrame.LeoFrame.put
			oldputnl = leoFrame.LeoFrame.putnl
			oldes = leoGlobals.es
			oldenl = leoGlobals.enl
			oldecnl = leoGlobals.ecnl
			oldecnls = leoGlobals.ecnls
			leoGlobals.es = newEs
			leoGlobals.enl = newEnl
			leoGlobals.ecnl = newEcnl
			leoGlobals.ecnls = newEcnls
			funcToMethod(newPut,leoFrame.LeoFrame,"put")
			funcToMethod(newPutNl,leoFrame.LeoFrame,"putNl")
			redirectStderr()
			redirectStdout()
			exec s in {} # Use {} to get a pristine environment!
			# Restore output.
			funcToMethod(oldput,leoFrame.LeoFrame,"put")
			funcToMethod(oldputnl,leoFrame.LeoFrame,"putNl")
			leoGlobals.es = oldes
			leoGlobals.enl = oldenl
			leoGlobals.ecnl = oldecnl
			leoGlobals.ecnls = oldecnls
			restoreStderr()
			restoreStdout()
		except:
			es("exception executing script")
			es_exception(full=false)
	else:
		es("no script selected")
</t>
<t tx="T845"># Same as frame.put except sends output to the end of the body text.
def newPut (self,s):
	if self.body:
			self.body.insert("end",s)
			# self.body.see("end")
			c = self.commands ; v = c.currentVnode()
			self.tree.onBodyChanged(v,"Typing")
	else: print s,

# Same as frame.putnl exceptsends output to the end of the body text.
def newPutNl (self):
	newPut (self,'\n')</t>
<t tx="T846">def newEnl():
	print
	
def newEcnl():
	print
	
def newEcnls(n):
	while n &gt; 0:
		n -= 1
		print

def newEs(s,*args,**keys):
	newline = keys.get("newline",true)
	if type(s) != type("") and type(s) != type(u""):
		s = repr(s)
	for arg in args:
		if type(arg) != type("") and type(arg) != type(u""):
			arg = repr(arg)
		s = s + ", " + arg
	if newline:
		print s
	else:
		print s,
</t>
<t tx="T847"></t>
<t tx="T848">colour
colourful
coloured
</t>
<t tx="T849"># Configuration file for mod_spelling plugin.

[main]

aspell_dir=c:\aspell\bin\aspell.exe

local_leo_dictionary=c:\prog\leoCVS\leo\plugins\mod_spelling.txt

local_language_code=en</t>
<t tx="T850">"""Spell Checker Plugin

- Perfoms spell checking on nodes within a Leo document.
- Uses aspell.exe to do the checking and suggest alternatives."""

import leoFind,os,popen2,re,sys,Tkinter,traceback
from leoPlugins import *
from leoGlobals import *

Tk = Tkinter

@others

if 0: # Register the handlers...

	if app.gui is None:
		app.createTkGui(__file__)

	if app.gui.guiName() == "tkinter":

		spellFrame = spellDialog()
		spellFrame.top.withdraw()
		app().globalWindows.append(spellFrame)
		
		registerHandler("create-optional-menus",createSpellMenu)
		registerHandler("select2",onSelect)
		registerHandler("command2",onCommand) # For any command that might change the text.
		registerHandler("bodykey2",onSelect) # For updating buttons.
		registerHandler(("bodyclick2","bodydclick2","bodyrclick2"),onSelect) # These affect selection.
		
		__version__ = "0.2.0"
		plugin_signon(__name__)</t>
<t tx="T851"></t>
<t tx="T852">def createSpellMenu(tag,keywords):
	
	"""Create the Check Spelling menu item in the Edit menu."""
	
	c = keywords.get("c")

	table = (
		("-",None,None),
		("Check Spelling","Alt+Shift+A",spellFrame.checkSpelling))

	c.frame.createMenuItemsFromTable("Edit",table)</t>
<t tx="T853">def onSelect (tag,keywords):
	
	"""A new vnode has just been selected.  Update the Spell Check window."""

	c = keywords.get("c")
	v = keywords.get("new_v")
	global spellFrame
	
	if top() and c and c.currentVnode():
		if c.currentVnode() != spellFrame.v:
			# print "onSelect",tag,`c.currentVnode()`,`spellFrame.v`
			spellFrame.update(show=false,fill=true)
		else:
			spellFrame.updateButtons()</t>
<t tx="T854">def onCommand (tag,keywords):
	
	"""Update the Spell Check window after any command that might change text."""

	global spellFrame
	
	if top() and top().currentVnode():
		
		# print "onCommand",tag
		spellFrame.update(show=false,fill=false)</t>
<t tx="T855">class Aspell:
	
	"""A wrapper class for Aspell spell checker"""
	
	@others
</t>
<t tx="T856"></t>
<t tx="T857">def __init__(self,local_dictionary_file,local_language_code):
	
	"""Ctor for the Aspell class."""
	
	self.altre = re.compile(".\s(.+)\s(\d+)\s(\d+):(.*)")
	self.attached = None
	self.input,self.output = None,None
	self.signonGiven = false
	
	self.aspell_exe_loc = self.getAspellDirectory()
	self.local_language_code = local_language_code
	
	if local_dictionary_file:
		self.local_dictionary_file = local_dictionary_file
		self.local_dictionary = "%s.wl" % os.path.splitext(local_dictionary_file)[0]
	else:
		print "failed to set aspell.local_dictionary"
		self.local.dictionary_file = None
		self.local_dictionary = None</t>
<t tx="T858">def getAspellDirectory(self):
	
	"""Get the directory containing aspell.exe from mod_spelling.ini"""

	import ConfigParser

	try:
		fileName = os.path.join(app().loadDir,"../","plugins","mod_spelling.ini")
		config = ConfigParser.ConfigParser()
		config.read(fileName)
		return config.get("main","aspell_dir")
	except:
		es_exception()
		return None</t>
<t tx="T859">def openPipes (self):
	
	"""Open the pipes to aspell.exe"""
	
	if self.input or self.output:
		print "pipes already open!"
		self.closePipes()
	
	&lt;&lt; Ensure local dictionary is present &gt;&gt;
	cmd = "%s pipe %s" % (self.aspell_exe_loc, add_dicts)
	if not self.local_dictionary:
		print "openPipes: command = " + cmd
	
	try:
		self.input, self.output = popen2.popen2(cmd)
	except:
		print "exception opening pipe"
		self.input = self.output = None
	
	if self.input:
		self.attached = self.input.readline()
	else:
		self.attached = None
		
	if not self.signonGiven:
		self.signonGiven = true
		if self.attached:
			print self.attached
			es(self.attached,color="blue")
		else:
			print "can not open aspell"
			es("can not open aspell",color="red")</t>
<t tx="T860">add_dicts = ""

if self.local_dictionary:
	if self.updateDictionary():
		add_dicts = "--add-extra-dicts %s" % self.local_dictionary


</t>
<t tx="T861">def closePipes (self):
	
	"""Close the pipes to aspell.exe"""
	
	# if self.input or self.output: print "closePipes"
	
	if self.input:
		self.input.close()
		self.input = None

	if self.output:
		self.output.close()
		self.output = None</t>
<t tx="T862">def listAlternates(self, aspell_return):
	
	"""Return a list of alternates from aspell."""
	
	match = self.altre.match(aspell_return)

	if match:
		return [item.strip() for item in match.groups()[3].split(",")]
	else:
		return []</t>
<t tx="T863">def processWord(self, word):

	"""Pass a word to aspell and return the list of alternatives."""
	
	if not self.attached:
		return None

	# print "processWord",`word`,`self.output`
	
	self.output.write("%s\n" % word)
	
	ret,junk = self.input.readline(),self.input.readline()

	if ret == "*\n":
		return None
	else:
		return self.listAlternates(ret)</t>
<t tx="T864">def updateDictionary(self):
	
	"""Update the aspell dictionary from a list of words.
	
	Return true if the dictionary was update correctly."""

	try:
		# Create master list
		basename = os.path.splitext(self.local_dictionary)[0]
		cmd = (
			"%s --lang=%s create master %s.wl &lt; %s.txt" %
			(self.aspell_exe_loc,self.local_language_code,basename,basename))
		os.popen(cmd)
		return true

	except Exception, err:
		es("Unable to update local aspell dictionary: %s" % err)
		print err
		add_dicts = ""
		return false</t>
<t tx="T865">class spellDialog (leoFind.leoFindBase):
	
	"""A class to create and manage Leo's Spell Check dialog."""
	
	@others</t>
<t tx="T866"></t>
<t tx="T867">def __init__ (self):
	
	"""Ctor for the Leo Spelling dialog."""
	
	# Call the base ctor to create the dialog.
	leoFind.leoFindBase.__init__(self,"Leo Spell Checking",resizeable=false)
	
	self.local_dictionary_file = self.getLocalDictionary()
	self.local_language_code = self.getLocalLanguageCode("en")
	self.aspell = Aspell(self.local_dictionary_file,self.local_language_code)
	&lt;&lt; set self.dictionary &gt;&gt;
	
	self.createFrame()
	self.fillbox([])
	
	# State variables.
	self.currentWord = None
	self.suggestions = []
	self.c = None
	self.v = None
	self.body = None
	self.work = Tk.Text(None) # A text widget for scanning.

	self.listBox.bind("&lt;Double-Button-1&gt;",self.onChangeThenFindButton)
	self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
	self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="T868">if self.local_dictionary_file:

	self.dictionary = self.readLocalDictionary(self.local_dictionary_file)
	if self.dictionary:
		# print "Local dictionary:", self.local_dictionary_file
		es("Local dictionary: %s" % shortFileName(self.local_dictionary_file),color="blue")
		if 0:
			keys = self.dictionary.keys()
			keys.sort()
			print "local dict:", keys
	else:
		self.dictionary = {}
		self.local_dictionary_file = None
else:
	self.dictionary = {}</t>
<t tx="T869">def getLocalDictionary(self):
	
	"""Get the dictionaries containing words not in the standard dictionary from mod_spelling.ini"""

	import ConfigParser

	try:
		fileName = os.path.join(app().loadDir,"../","plugins","mod_spelling.ini")
		config = ConfigParser.ConfigParser()
		config.read(fileName)
		return config.get("main","local_leo_dictionary",None)
	except:
		es_exception()
		return None</t>
<t tx="T870">def getLocalLanguageCode(self,defaultLanguageCode):
	
	"""Get the dictionaries containing words not in the standard dictionary from mod_spelling.ini"""

	import ConfigParser

	try:
		fileName = os.path.join(app().loadDir,"../","plugins","mod_spelling.ini")
		config = ConfigParser.ConfigParser()
		config.read(fileName)
		return config.get("main","local_language_code",defaultLanguageCode)
	except:
		es_exception()
		return defaultLanguageCode</t>
<t tx="T871">def readLocalDictionary (self,local_dictionary):
	
	"""Read the dictionary of words which we use as a local dictionary
	
	Although Aspell itself has the functionality to handle this kind of things
	we duplicate it here so that we can also use it for the "ignore" functionality
	and so that in future a Python only solution could be developed."""

	try:
		f = open(local_dictionary,"r")
	except IOError:
		es("Unable to open local dictionary '%s' - using a blank one instead" % local_dictionary)
		return None
	
	try:
		# Create the dictionary - there are better ways to do this
		# in later Python's but we stick with this method for compatibility
		dct = {}
		for word in f.readlines():
			dct[word.strip().lower()] = 0
	finally:
		f.close()

	return dct</t>
<t tx="T872">def createFrame (self):
	
	"""Create the Spelling dialog."""
	
	# Create the find panel...
	outer = Tk.Frame(self.frame,relief="groove",bd=2)
	outer.pack(padx=2,pady=2,expand=1,fill="both")

	&lt;&lt; Create the text and suggestion panes &gt;&gt;
	&lt;&lt; Create the spelling buttons &gt;&gt;
</t>
<t tx="T873">f = outer

f2 = Tk.Frame(f)
f2.pack(expand=1,fill="x")
self.wordLabel = Tk.Label(f2, text="Suggestions for:")
self.wordLabel.pack(side="left")

fpane = Tk.Frame(f,bd=2)
fpane.pack(side="top", expand=1, fill="x")

self.listBox = Tk.Listbox(fpane,height=30,selectmode="single")
self.listBox.pack(side="left", expand=1, fill="both")

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

for bar,txt in ((listBoxBar,self.listBox),):
	txt['yscrollcommand'] = bar.set
	bar['command'] = txt.yview
	bar.pack(side="right", fill="y")
</t>
<t tx="T874"># Create the button panes
buttons1  = Tk.Frame(outer,bd=1)
buttons1.pack (anchor="n",expand=1,fill="x")

buttons2  = Tk.Frame(outer,bd=1)
buttons2.pack (anchor="n",expand=1,fill="none")

buttonList = []
for text,command in (
	("Find",self.onFindButton),
	("Change",self.onChangeButton),
	("Change, Find",self.onChangeThenFindButton),
	("Add",self.onAddButton)):
	width = max(6,len(text))
	b=Tk.Button(buttons1,width=width,text=text,command=command)
	b.pack(side="left",fill="none",expand=1)
	buttonList.append(b)
		
for text,command in (
	("Undo",self.onUndoButton),
	("Redo",self.onRedoButton),
	("Ignore",self.onIgnoreButton),
	("Hide",self.onHideButton)):
	width = max(6,len(text))
	b=Tk.Button(buttons2,width=width,text=text,command=command)
	b.pack(side="left",fill="none",expand=0)
	buttonList.append(b)

# We need these to enable or disable buttons.
(self.findButton, self.changeButton,
 self.changeFindButton, self.addButton, 
 self.undoButton, self.redoButton,
 self.ignoreButton, self.hideButton) = buttonList</t>
<t tx="T875"></t>
<t tx="T876">def onAddButton (self):
	
	"""Handle a click in the Add button in the Check Spelling dialog."""

	self.add()
	self.closePipes()

</t>
<t tx="T877">def onIgnoreButton (self):

	"""Handle a click in the Ignore button in the Check Spelling dialog."""

	self.ignore()
	self.closePipes()</t>
<t tx="T878">def onChangeButton (self):
	
	"""Handle a click in the Change button in the Check Spelling dialog."""

	self.change()
	self.closePipes()
	self.updateButtons()
	
# Event needed for double-click event.
def onChangeThenFindButton (self,event=None): 
		
	"""Handle a click in the "Change, Find" button in the Check Spelling dialog."""

	if self.change():
		self.find()
	self.closePipes()
	self.updateButtons()</t>
<t tx="T879">def onFindButton (self):
	
	"""Handle a click in the Find button in the Check Spelling dialog."""

	self.find()
	self.updateButtons()
	self.closePipes()</t>
<t tx="T880">def onHideButton (self):
	
	"""Handle a click in the Hide button in the Check Spelling dialog."""

	self.closePipes()
	self.top.withdraw()
</t>
<t tx="T881">def onRedoButton (self):
	
	"""Handle a click in the Redo button in the Check Spelling dialog."""

	self.c.undoer.redo() # Not a command, so command hook doesn't fire.
	self.update(show=false,fill=false)
	self.c.frame.body.focus_force()
	
def onUndoButton (self):
	
	"""Handle a click in the Undo button in the Check Spelling dialog."""

	self.c.undoer.undo() # Not a command, so command hook doesn't fire.
	self.update(show=false,fill=false)
	self.c.frame.body.focus_force()</t>
<t tx="T882"></t>
<t tx="T883">def add (self):

	"""Add the selected suggestion to the dictionary."""
	
	if not self.local_dictionary_file:
		return
	
	try:
		f = None
		try:
			# Rewrite the dictionary in alphabetical order.
			f = open(self.local_dictionary_file,"r")
			words = f.readlines()
			f.close()
			words = [word.strip() for word in words]
			words.append(self.currentWord)
			words.sort()
			f = open(self.local_dictionary_file,"w")
			for word in words:
				f.write("%s\n" % word)
			f.flush()
			f.close()
			es("Adding ",color="blue",newline=false) ; es('%s' % self.currentWord)
		except IOError:
			es("Can not add %s to dictionary" % self.currentWord,color="red")
	finally:
		if f: f.close()
		
	self.dictionary[self.currentWord.lower()] = 0
	
	# Restart aspell so that it re-reads its dictionary.
	self.aspell.closePipes()
	self.aspell.openPipes()
	
	self.onFindButton()</t>
<t tx="T884">def change(self):
	
	"""Make the selected change to the text"""

	c = self.c ; v = self.v ; t = self.body
	
	selection = self.getSuggestion()
	if selection:
		start,end = oldSel = getTextSelection(t)
		if start:
			if t.compare(start, "&gt;", end):
				start,end = end,start
			t.delete(start,end)
			t.insert(start,selection)
			setTextSelection(t,start,start + "+%dc" % (len(selection)))
			newSel = getTextSelection(t)

			# update node, undo status, dirty flag, changed mark &amp; recolor
			c.beginUpdate()
			c.tree.onBodyChanged(v,"Change",oldSel=oldSel,newSel=newSel)
			c.endUpdate(true)
			t.focus_set()
			return true

	# The focus must never leave the body pane.
	t.focus_set()
	return false</t>
<t tx="T885">def checkSpelling (self,event=None):
	
	"""Open the Check Spelling dialog."""

	self.top.deiconify()
	self.top.lift()
	self.update(show=true,fill=false)</t>
<t tx="T886">def find(self):
	
	"""Find the next unknown word."""
	
	# Reload the work pane from the present node.
	s = self.body.get("1.0","end").rstrip()
	self.work.delete("1.0","end")
	self.work.insert("end",s)
	
	# Reset the insertion point of the work widget.
	ins = self.body.index("insert")
	self.work.mark_set("insert",ins)

	alts,word = self.findNextMisspelledWord()
	self.currentWord = word # Need to remember this for 'add' and 'ignore'
	
	if alts:
		self.fillbox(alts,word)
		self.body.focus_set()
					
		# Copy the working selection range to the body pane
		start,end = getTextSelection (self.work)
		setTextSelection (self.body,start,end)
	else:
		es("no more misspellings")
		self.fillbox([])</t>
<t tx="T887">def ignore (self):
	
	"""Ignore the incorrect word for the duration of this spell check session."""
	
	es("Ignoring ",color="blue",newline=false) ; es('%s' % self.currentWord)
	self.dictionary[self.currentWord.lower()] = 0
	self.onFindButton()</t>
<t tx="T888"></t>
<t tx="T889">def closePipes(self):
	
	self.aspell.closePipes()</t>
<t tx="T890">def fillbox(self,alts,word=None):

	"""Update the suggestions listbox in the Check Spelling dialog."""
	
	self.suggestions = alts
	
	if not word:
		word = ""

	self.wordLabel.configure(text = "Suggestions for: " + word)
	self.listBox.delete(0,"end")

	for i in xrange(len(self.suggestions)):
		self.listBox.insert(i,self.suggestions[i])
	
	if len(self.suggestions):
		self.listBox.select_set(1) # This doesn't show up because we don't have focus.</t>
<t tx="T891">def findNextMisspelledWord(self):
	
	"""Find the next unknown word."""
	
	aspell = self.aspell ; alts = None ; word = None
	c = self.c ; v = self.v
	try:
		aspell.openPipes()
		try:
			while 1:
				v,word = self.findNextWord(v) 
				if not v or not word:
					alts = None
					break
				&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
				alts = aspell.processWord(word)
				if alts:
					self.v = v
					c.beginUpdate()
					c.tree.expandAllAncestors(v)
					c.selectVnode(v)
					c.endUpdate()
					break
		except:
			es_exception()
	finally:
		aspell.closePipes()
		return alts, word</t>
<t tx="T892">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not true and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
	
	# print "Ignored", word
	continue
	
# print "Didn't ignore '%s'" % word</t>
<t tx="T893">def findNextWord (self,v):
	
	"""Scan for the next word, leaving the result in the work widget"""

	t = self.work
	word_start = string.letters + '_'
	t.mark_set("insert","insert wordend + 1c")
	while 1:
		# print `t.index("insert")`,`t.index("end-1c")`
		if t.compare("insert","&gt;=","end - 1c"):
			v = v.threadNext()
			if not v: return None,None
			t.delete("1.0","end")
			t.insert("end",v.bodyString())
			t.mark_set("insert","1.0")
		elif t.compare("insert","&gt;=","insert lineend - 1c"):
			t.mark_set("insert","insert lineend + 1line")
		else:
			ch = t.get("insert")
			if ch in word_start:
				word = t.get("insert wordstart","insert wordend")
				setTextSelection(t,"insert wordstart","insert wordend")
				# print "findNextWord:",`word`
				return v,word
			elif ch:
				t.mark_set("insert","insert + 1c")</t>
<t tx="T894">def getSuggestion (self):
	
	"""Return the selected suggestion from the listBox."""
	
	# Work around an old Python bug.  Convert strings to ints.
	items = self.listBox.curselection()
	try:
		items = map(int, items)
	except ValueError: pass

	if items:
		n = items[0]
		suggestion = self.suggestions[n]
		return suggestion
	else:
		return None</t>
<t tx="T895">def onMap (self,event=None):
	
	"""Respond to a Tk &lt;Map&gt; event."""
	
	self.update(show=false,fill=false)</t>
<t tx="T896">def onSelectListBox (self,event=None):
	
	"""Respond to a click in the selection listBox."""
	
	self.updateButtons()
	self.body.focus_set()
</t>
<t tx="T897">def update (self,show=true,fill=false):
	
	"""Update the Spell Check dialog."""
	
	# print "update(show=%d,fill=%d)" % (show,fill)
	
	# Always assume that the user has changed text.
	self.c = c = top()
	self.v = c.currentVnode()
	self.body = c.frame.body
	if fill:
		self.fillbox([])
	self.updateButtons()
	if show:
		self.top.deiconify()
		# Don't interfere with Edit Headline commands.
		self.body.focus_set()
		
	# Give the signon if it hasn't been given yet.
	if not self.aspell.signonGiven:
		self.aspell.openPipes()
		self.aspell.closePipes()</t>
<t tx="T898">def updateButtons (self):
	
	"""Enable or disable buttons in the Check Spelling dialog."""
	
	start,end = getTextSelection(self.body)
	state = choose(self.suggestions and start,"normal","disabled")
	
	self.changeButton.configure(state=state)
	self.changeFindButton.configure(state=state)

	state = choose(self.c.undoer.canRedo(),"normal","disabled")
	self.redoButton.configure(state=state)
	
	state = choose(self.c.undoer.canUndo(),"normal","disabled")
	self.undoButton.configure(state=state)
	
	state = choose(self.local_dictionary_file,"normal","disabled")
	self.addButton.configure(state=state)

	self.ignoreButton.configure(state="normal")</t>
<t tx="T899">@ignore</t>
<t tx="T900">@nocolor

Attached is some proof-of-concept code for a Leo Plugin manager.

To try it out ... (warning: it will write files to your c:\temp directory)

1. Start 'leopm_server.py' ... Should display a message saying "Listening on 8001"
2. Start 'leopm_client.py' ... Should bring up an ugly Tkinter window

How it works:

1. The client attaches to the remote server (via XMLRPC) 
2. Client asks for a list of plug-ins
3. Server responds
4. Client asks for details of files required + version for each plugin
5. Client checks local plugin directory to see if these files are there and if they are the right version.
6. Client displays list of available + installed plugins
7. User selects plugin and clicks 'Install'
8. Client requests files from server
9. Server sends back files
10. Client installs files in local directory (currently c:\temp)

In the current code, the client side is functional - the server side is
actually dummy methods just returning the right kind of data. There's no
point doing anything clever there until the client functionality is
fully fleshed out. Although it is all running locally in the demo there
aren't any code changes required to run remotely.

It is all pretty primitive, but I think the functionality maps quite
closely with jEdit. Tidying the Tkinter interface and fleshing out the
server side shouldn't take too long and then it could be wrapped as a
plugin itself.

Advantages of this (XMLRPC) approach,

- can go over HTTP port
- client and server are nicely decoupled (server needn't be in Python if the web host doesn't support it)
- client/server stuff is so transparent (look at the server implementation!) compared to other approaches.

Some kind of 'submit plugin' option would be interesting, but suddenly security issues start to loom!

Do you think this is worth pursuing?</t>
<t tx="T901">@first #!/usr/bin/env python

"""A client implementing a plug-in manager for Leo

The client is based on an XML server architecture. Methods exist
to query the plug-ins on the server, find version numbers, help information and
to download the actual source. In the future it might be possible to upload
plug-ins as well."""

from Tkinter import *
import os,re,xmlrpclib

__version__ = "0.1"

PORT = 8001 # The port the server is listening on
HOST = "http://localhost:%d" % PORT
ROOTDIR = r"c:\temp" # Where the plugins will end up

@others

if __name__ == "__main__":
    server = xmlrpclib.ServerProxy(HOST)
    root = Tk()
    client = LeoPMClient(root, server, ROOTDIR)
    root.mainloop()
</t>
<t tx="T902">class LeoPMClient:
	
	"""The client to talk to the LeoPM server"""

	@others
</t>
<t tx="T903">def __init__(self, master, server, rootdir):
    """Initialize the client"""
    self.server = server
    self.master = master
    self.rootdir = rootdir
    #
    frame = Frame(master)
    frame.pack()
    #
    l = Label(frame, text="Leo Plugin Manager")
    l.pack(side=TOP)
    # Get the list of plugins
    listbox = Listbox(frame)
    listbox.pack(side=TOP)
    self.listbox = listbox
    self.initListbox()
    # Detail box for additional information
    text = Text(frame)
    text.pack(side=TOP)
    self.text = text
    #
    buttonframe = Frame(frame)
    buttonframe.pack(side=BOTTOM)
    #
    quit = Button(buttonframe, text="QUIT", fg="red", command=master.quit)
    quit.pack(side=RIGHT)
    #
    download = Button(buttonframe, text="Download", command=self.downloadPlugin)
    download.pack(side=LEFT)
    # Start polling for changes in selection
    self.lastselection = None
    self.poll() </t>
<t tx="T904">def poll(self):
    """Poll and update the detail view if appropriate"""
    now = self._getSelectedPluginName()
    if now is not None and now != self.lastselection:
        self.updateDetail(now)
        self.lastselection = now
    self.master.after(250, self.poll)
</t>
<t tx="T905">def _getSelectedPluginName(self):
    """Return the currently selected plugin name"""
    sel = self.listbox.curselection()
    if sel:
        return self.plugins[int(sel[0])]
    else:
        return None
</t>
<t tx="T906">def updateDetail(self, name):
    """Update the detail view of a plugin"""
    self.text.delete(1.0, END)
    self.text.insert(END, self.server.getPluginDescription(name))
</t>
<t tx="T907">def downloadPlugin(self):
    """Download the selected plugin"""
    self.text.insert(END, "\n\nInstalling\n")
    data = self.server.getPlugin(self._getSelectedPluginName())
    self.text.insert(END, "Got plugin data\n")
    for filename, text in data:
        self.text.insert(END, "Copying file '%s' ..." % filename)
        f = file(os.path.join(self.rootdir, filename), "w")
        f.write(text)
        f.close()
        self.text.insert(END, "Done!\n")
    self.text.insert(END, "\n\nPlugin installed\n")
    self.initListbox()
</t>
<t tx="T908">def getPluginList(self):
    """Return a list of plugins on the server
    
    We markup the list to show which plugins are installed etc
    
    """
    ret = []
    self.plugins = server.getPluginNames()
    for name in self.plugins:
        version = server.getPluginVersion(name)
        files = server.getPluginFilenames(name)
        #
        found = 0
        version = None
        #
        for fname in files:
            # Is file already installed?
            filename = os.path.join(self.rootdir, fname)
            if os.path.isfile(filename):
                found += 1
                # Check version
                version = version or self.getVersionOfFile(filename)
        #
        if found == len(files):
            version = version or "Unknown"
            ret.append("%s - installed (v%s)" % (name, version))
        elif found:
            ret.append("%s - partially installed" % name)
        else:
            ret.append(name)
    #
    return ret
</t>
<t tx="T909">def initListbox(self):
    """Initialize the listbox"""
    plugin_list = self.getPluginList()
    self.listbox.delete(0, END)
    for item in plugin_list:
        self.listbox.insert(END, item)
</t>
<t tx="T910">def getVersionOfFile(self, filename):
    """Check the version of a plugin file"""
    ver = re.compile('.*__version__\s*=\s"(.*?)".*', re.DOTALL+re.MULTILINE)
    f = file(filename, "r")
    text = f.read()
    f.close()
    match = ver.match(text)
    if match:
        return match.groups()[0]
    else:
        return None
</t>
<t tx="T911">@first #!/usr/bin/env python

"""A server implementing a plug-in manager for Leo

The server is based on an XML server architecture. Methods exist
to query the plug-ins on the server, find version numbers, help information and to
download the actual source. In the future it might be possible to upload
plug-ins as well."""

import SimpleXMLRPCServer

__version__ = "0.1"

PORT = 8001

@others
        
if __name__ == "__main__":
    # Create the server
    leoPluginManager = LeoPM()
    server = SimpleXMLRPCServer.SimpleXMLRPCServer(("localhost", PORT))
    server.register_instance(leoPluginManager)
    # Go into the main listener loop
    print "LeoPM (v%s) Started\nListening on port %s" % (__version__, PORT)
    server.serve_forever()</t>
<t tx="T912">class LeoPM:
	"""The Leo Plugin manager XMLRPC server"""
	@others
</t>
<t tx="T913">def __init__(self, plugin_dir="."):
    """Start the server with plugins located in the specified directory"""
</t>
<t tx="T914">    #self._locatePlugins()
    
def getPluginNames(self):
    """Return a list of the plug-ins by name"""
    return ["one", "two", "three"]
</t>
<t tx="T915">def getPluginDescription(self, name):
	
    """Return the description of the plugin"""

    return "%s - v%s\n\n%s" % (name, len(name), "Some important details about it")
</t>
<t tx="T916">def getPlugin(self, name):

    """Get the source files for a plugin
    
    Files are returned as a list of tuples (filename, text)"""

    return [("%s1.py" % name, 'this is #1\n__version__ = "%d"' % len(name)),
            ("%s2.py" % name, 'this is #2\n__version__ = "%d"' % len(name))]
</t>
<t tx="T917">def getPluginVersion(self, name):
	
    """Return the plugin version"""

    return len(name)
</t>
<t tx="T918">def getPluginFilenames(self, name):
	
    """Return a list of the files needed by a plugin"""
    return ("%s1.py" % name, "%s2.py" % name)</t>
</tnodes>
</leo_file>
