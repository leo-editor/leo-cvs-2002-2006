<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="668" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="25" left="318" height="828" width="873"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0">
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1"><vh>Diary</vh>
<v t="T2"><vh>7/7 Created leoPlugins.leo</vh></v>
</v>
<v t="T3"><vh>Documentation and security warnings</vh>
<v t="T4"><vh>Overview of plugins and hooks</vh></v>
<v t="T5"><vh>Intro to scripts</vh></v>
<v t="T6"><vh>About hooks</vh></v>
<v t="T7"><vh>Hooks should never blindly Python scripts</vh></v>
<v t="T8"><vh>NEVER use this kind of code in a hook!!</vh></v>
</v>
<v t="T9"><vh>Unfinished projects</vh>
<v t="T10"><vh>(Settings menu)</vh>
<v t="T11"><vh>To do</vh></v>
<v t="T12"><vh>Design of Settings menu</vh></v>
<v t="T13"><vh>@file settings_menu.py</vh>
<v t="T14"><vh>createSettingsMenu</vh></v>
</v>
</v>
<v t="T15"><vh>(wxStuff: not a plugin yet)</vh>
<v t="T16"><vh>wxTests</vh>
<v t="T17"><vh>@file c:\prog\test\wxTest.py</vh></v>
</v>
<v t="T18"><vh>old wxLeo code (imported C++ code)</vh>
<v t="T19"><vh>alert.cpp</vh>
<v t="T20"><vh>alert</vh></v>
<v t="T21"><vh>assertFailedDialog</vh></v>
</v>
<v t="T22"><vh>FindPanel.cpp</vh>
<v t="T23"><vh>&lt;&lt; FindPanel declarations &gt;&gt;</vh></v>
<v t="T24"><vh>BEGIN_EVENT_TABLE</vh></v>
<v t="T25"><vh>ctor</vh></v>
<v t="T26"><vh>OnActivateFindFrame</vh></v>
<v t="T27"><vh>OnSetFocus</vh></v>
<v t="T28"><vh>OnCloseFindFrame</vh></v>
<v t="T29"><vh>OnChangeButton</vh></v>
<v t="T30"><vh>OnChangeAllButton</vh></v>
<v t="T31"><vh>OnChangeThenFindButton</vh></v>
<v t="T32"><vh>OnFindButton</vh></v>
<v t="T33"><vh>OnFindAllButton</vh></v>
<v t="T34"><vh>OnBatchCheckBox</vh></v>
<v t="T35"><vh>OnIgnoreCaseCheckBox</vh></v>
<v t="T36"><vh>OnMarkChangesCheckBox</vh></v>
<v t="T37"><vh>OnMarkFindsCheckBox</vh></v>
<v t="T38"><vh>OnPatternMatchCheckBox</vh></v>
<v t="T39"><vh>OnReverseCheckBox</vh></v>
<v t="T40"><vh>OnSearchBodyTextCheckBox</vh></v>
<v t="T41"><vh>OnSearchHeadlineCheckBox</vh></v>
<v t="T42"><vh>OnSuboutlineOnlyCheckBox</vh></v>
<v t="T43"><vh>OnWrapAroundCheckBox</vh></v>
<v t="T44"><vh>OnWholeWordCheckBox</vh></v>
<v t="T45"><vh>OnChangeText</vh></v>
<v t="T46"><vh>OnFindText</vh></v>
<v t="T47"><vh>set_check_boxes</vh></v>
<v t="T48"><vh>FindPanel</vh></v>
</v>
<v t="T49"><vh>LeoApp.cpp</vh>
<v t="T50"><vh>Event table</vh></v>
<v t="T51"><vh>OnInit</vh>
<v t="T52"><vh>&lt;&lt; Switch to the other running copy of Leo if one is already open &gt;&gt;</vh></v>
<v t="T53"><vh>&lt;&lt; Set gAppDirectory &gt;&gt;</vh></v>
<v t="T54"><vh>&lt;&lt; Open a file when double-clicking an icon &gt;&gt;</vh></v>
<v t="T55"><vh>&lt;&lt; Create a frame and link it into the global frame list &gt;&gt;</vh></v>
<v t="T56"><vh>&lt;&lt; Initialize Sherlock &gt;&gt;</vh></v>
<v t="T57"><vh>&lt;&lt; Dump the command line &gt;&gt;</vh></v>
</v>
<v t="T58"><vh>OnExit</vh></v>
<v t="T59"><vh>init_args</vh></v>
<v t="T60"><vh>wxFindAppPath</vh></v>
<v t="T61"><vh>log_open</vh></v>
<v t="T62"><vh>put_cstring_to_log_window</vh></v>
</v>
<v t="T63"><vh>LeoFrame.cpp</vh>
<v t="T64"><vh>BEGIN_EVENT_TABLE</vh>
<v t="T65"><vh>&lt;&lt; Declare menu events &gt;&gt;</vh></v>
</v>
<v t="T66"><vh>ctor</vh>
<v t="T67"><vh>&lt;&lt; Initialize the private vars &gt;&gt;</vh></v>
<v t="T68"><vh>&lt;&lt; Initialize the argument settings &gt;&gt;</vh></v>
<v t="T69"><vh>&lt;&lt; Create the splitter windows &gt;&gt;</vh></v>
<v t="T70"><vh>&lt;&lt; Create the accelerator table &gt;&gt;</vh></v>
<v t="T71"><vh>&lt;&lt; Create the status bar &gt;&gt;</vh></v>
<v t="T72"><vh>&lt;&lt; Set the window Icon &gt;&gt;</vh></v>
<v t="T73"><vh>&lt;&lt; Set the caret blink rate &gt;&gt;</vh></v>
<v t="T74"><vh>&lt;&lt; Add root node to the tree view &gt;&gt;</vh></v>
</v>
<v t="T75"><vh>createMenus</vh></v>
<v t="T76"><vh>SetUntitledNumber</vh></v>
<v t="T77"><vh>putToLog</vh></v>
<v t="T78"><vh>getLogText</vh></v>
<v t="T79"><vh>event handlers</vh>
<v t="T80"><vh>onActivate</vh></v>
<v t="T81"><vh>OnSetFocus</vh></v>
<v t="T82"><vh>onResize</vh></v>
<v t="T83"><vh>onBodyTextUpdated</vh></v>
<v t="T84"><vh>onCloseLeoFrame</vh></v>
<v t="T85"><vh>onTreeChanged</vh></v>
<v t="T86"><vh>onTreeChanging</vh></v>
<v t="T87"><vh>onTreeKeyDown</vh></v>
<v t="T88"><vh>onTreeBeginDrag</vh></v>
<v t="T89"><vh>onTreeEndDrag</vh></v>
<v t="T90"><vh>onTreeBeginLabelEdit</vh></v>
<v t="T91"><vh>onTreeEndLabelEdit</vh></v>
<v t="T92"><vh>updateJoinedHeadlines</vh></v>
<v t="T93"><vh>OnUpdateRevert</vh></v>
<v t="T94"><vh>OnNew</vh></v>
<v t="T95"><vh>OnOpen</vh></v>
<v t="T96"><vh>OpenWithFileName</vh></v>
<v t="T97"><vh>OnClose</vh></v>
<v t="T98"><vh>OnSave</vh></v>
<v t="T99"><vh>OnSaveAs</vh></v>
<v t="T100"><vh>OnSaveTo</vh></v>
<v t="T101"><vh>OnRevert</vh></v>
<v t="T102"><vh>OnPageSetup</vh></v>
<v t="T103"><vh>OnPrint</vh></v>
<v t="T104"><vh>OnTangleSubmenu</vh></v>
<v t="T105"><vh>OnUntangleSubmenu</vh></v>
<v t="T106"><vh>OnImportExportSubmenu</vh></v>
<v t="T107"><vh>OnQuit</vh></v>
<v t="T108"><vh>OnReadOutlineOnly</vh></v>
<v t="T109"><vh>readOutlineOnly</vh></v>
<v t="T110"><vh>OnReadAtFileNodes</vh></v>
<v t="T111"><vh>OnWriteOutlineOnly</vh></v>
<v t="T112"><vh>OnWriteAtFileNodes</vh></v>
<v t="T113"><vh>OnTangleAll</vh></v>
<v t="T114"><vh>OnTangleMarked</vh></v>
<v t="T115"><vh>OnTangle</vh></v>
<v t="T116"><vh>OnUntangleAll</vh></v>
<v t="T117"><vh>OnUntangleMarked</vh></v>
<v t="T118"><vh>OnUntangle</vh></v>
<v t="T119"><vh>OnImportFiles</vh></v>
<v t="T120"><vh>OnImportCWEBFiles</vh></v>
<v t="T121"><vh>OnImportNowebFiles</vh></v>
<v t="T122"><vh>OnImportMoreText</vh></v>
<v t="T123"><vh>OnFlattenOutline</vh></v>
<v t="T124"><vh>OnUpdateCopy</vh></v>
<v t="T125"><vh>OnUpdateCut</vh></v>
<v t="T126"><vh>OnUpdateDelete</vh></v>
<v t="T127"><vh>OnUpdateExtract</vh></v>
<v t="T128"><vh>OnUpdateExtractNames</vh></v>
<v t="T129"><vh>OnUpdateExtractSection</vh></v>
<v t="T130"><vh>OnUpdateFind</vh></v>
<v t="T131"><vh>OnUpdatePaste</vh></v>
<v t="T132"><vh>OnUpdateRedo</vh></v>
<v t="T133"><vh>OnUpdateReplace</vh></v>
<v t="T134"><vh>OnUpdateSelectAll</vh></v>
<v t="T135"><vh>OnUpdateUndo</vh></v>
<v t="T136"><vh>hasSelection</vh></v>
<v t="T137"><vh>OnUndo</vh></v>
<v t="T138"><vh>OnRedo</vh></v>
<v t="T139"><vh>OnCut</vh></v>
<v t="T140"><vh>OnCopy</vh></v>
<v t="T141"><vh>OnPaste</vh></v>
<v t="T142"><vh>OnDelete</vh></v>
<v t="T143"><vh>OnSelectAll</vh></v>
<v t="T144"><vh>OnEditHeadline</vh></v>
<v t="T145"><vh>OnFontPanel</vh></v>
<v t="T146"><vh>OnSyntaxColoring</vh></v>
<v t="T147"><vh>OnPreferences</vh></v>
<v t="T148"><vh>OnConvertBlanks</vh></v>
<v t="T149"><vh>OnExtractSection</vh></v>
<v t="T150"><vh>OnExtractNames</vh></v>
<v t="T151"><vh>OnExtract</vh></v>
<v t="T152"><vh>OnFindPanel</vh></v>
<v t="T153"><vh>OnFindNext</vh></v>
<v t="T154"><vh>OnFindPrevious</vh></v>
<v t="T155"><vh>OnReplace</vh></v>
<v t="T156"><vh>OnReplaceThenFind</vh></v>
<v t="T157"><vh>OnUpdateCutNode</vh></v>
<v t="T158"><vh>OnUpdateDeleteNode</vh></v>
<v t="T159"><vh>OnUpdatePasteNode</vh></v>
<v t="T160"><vh>OnUpdateSortNode</vh></v>
<v t="T161"><vh>OnUpdateExpandAll</vh></v>
<v t="T162"><vh>OnUpdateExpandAllChildren</vh></v>
<v t="T163"><vh>OnUpdateExpandChildren</vh></v>
<v t="T164"><vh>OnUpdateContractAll</vh></v>
<v t="T165"><vh>OnUpdateContractAllChildren</vh></v>
<v t="T166"><vh>OnUpdateContractChildren</vh></v>
<v t="T167"><vh>OnUpdateMoveDown</vh></v>
<v t="T168"><vh>OnUpdateMoveLeft</vh></v>
<v t="T169"><vh>OnUpdateMoveRight</vh></v>
<v t="T170"><vh>OnUpdateMoveUp</vh></v>
<v t="T171"><vh>OnUpdatePromote</vh></v>
<v t="T172"><vh>OnUpdateDemote</vh></v>
<v t="T173"><vh>OnUpdateGoPrevVisible</vh></v>
<v t="T174"><vh>OnUpdateGoNextVisible</vh></v>
<v t="T175"><vh>OnUpdateGoBack</vh></v>
<v t="T176"><vh>OnUpdateGoNext</vh></v>
<v t="T177"><vh>OnUpdateMark</vh></v>
<v t="T178"><vh>OnUpdateMarkSubheads</vh></v>
<v t="T179"><vh>OnUpdateMarkChangedItems</vh></v>
<v t="T180"><vh>OnUpdateMarkChangedRoots</vh></v>
<v t="T181"><vh>OnUpdateGoToNextMarked</vh></v>
<v t="T182"><vh>OnUpdateGoToNextChanged</vh></v>
<v t="T183"><vh>OnCutNode</vh></v>
<v t="T184"><vh>OnCopyNode</vh></v>
<v t="T185"><vh>OnPasteNode</vh></v>
<v t="T186"><vh>OnDeleteNode</vh></v>
<v t="T187"><vh>OnInsertNode</vh></v>
<v t="T188"><vh>OnCloneNode</vh></v>
<v t="T189"><vh>OnSortNode</vh></v>
<v t="T190"><vh>OnExpandAll</vh></v>
<v t="T191"><vh>OnExpandAllChildren</vh></v>
<v t="T192"><vh>OnExpandChildren</vh></v>
<v t="T193"><vh>OnContractAll</vh></v>
<v t="T194"><vh>OnContractAllChildren</vh></v>
<v t="T195"><vh>OnContractChildren</vh></v>
<v t="T196"><vh>OnExpandNextLevel</vh></v>
<v t="T197"><vh>OnExpandToLevel1</vh></v>
<v t="T198"><vh>OnExpandToLevel2</vh></v>
<v t="T199"><vh>OnExpandToLevel3</vh></v>
<v t="T200"><vh>OnExpandToLevel4</vh></v>
<v t="T201"><vh>OnExpandToLevel5</vh></v>
<v t="T202"><vh>OnExpandToLevel6</vh></v>
<v t="T203"><vh>OnExpandToLevel7</vh></v>
<v t="T204"><vh>OnExpandToLevel8</vh></v>
<v t="T205"><vh>OnExpandToLevel9</vh></v>
<v t="T206"><vh>OnMoveDown</vh></v>
<v t="T207"><vh>OnMoveLeft</vh></v>
<v t="T208"><vh>OnMoveRight</vh></v>
<v t="T209"><vh>OnMoveUp</vh></v>
<v t="T210"><vh>OnPromote</vh></v>
<v t="T211"><vh>OnDemote</vh></v>
<v t="T212"><vh>OnGoPrevVisible</vh></v>
<v t="T213"><vh>OnGoNextVisible</vh></v>
<v t="T214"><vh>OnGoBack</vh></v>
<v t="T215"><vh>OnGoNext</vh></v>
<v t="T216"><vh>OnMark</vh></v>
<v t="T217"><vh>OnMarkSubheads</vh></v>
<v t="T218"><vh>OnMarkChangedItems</vh></v>
<v t="T219"><vh>OnMarkChangedRoots</vh></v>
<v t="T220"><vh>OnMarkAllAtFileNodesDirty</vh></v>
<v t="T221"><vh>OnMarkAtFileNodesDirty</vh></v>
<v t="T222"><vh>OnUnmarkAll</vh></v>
<v t="T223"><vh>OnGoToNextMarked</vh></v>
<v t="T224"><vh>OnGoToNextChanged</vh></v>
<v t="T225"><vh>OnEqualSizedPanes</vh></v>
<v t="T226"><vh>OnToggleActivePane</vh></v>
<v t="T227"><vh>OnChangeDirection</vh></v>
<v t="T228"><vh>OnCascade</vh></v>
<v t="T229"><vh>OnMinimizeAll</vh></v>
<v t="T230"><vh>OnOpenPythonWindow</vh></v>
<v t="T231"><vh>OnRecentWindows</vh></v>
<v t="T232"><vh>OnAbout</vh></v>
</v>
</v>
<v t="T233"><vh>LeoPrefs.cpp</vh>
<v t="T234"><vh>&lt;&lt; LeoPrefs declarations &gt;&gt;</vh></v>
<v t="T235"><vh>BEGIN_EVENT_TABLE</vh></v>
<v t="T236"><vh>ctor</vh></v>
<v t="T237"><vh>initialize</vh></v>
<v t="T238"><vh>targetToLanguage</vh></v>
<v t="T239"><vh>languageToTarget</vh></v>
<v t="T240"><vh>OnActivatePrefsFrame</vh></v>
<v t="T241"><vh>OnClosePrefsFrame</vh></v>
<v t="T242"><vh>OnPageWidthText</vh></v>
<v t="T243"><vh>OnDoneBatCheckBox</vh></v>
<v t="T244"><vh>OnUnBatCheckBox</vh></v>
<v t="T245"><vh>OnTangleDirectoryText</vh></v>
<v t="T246"><vh>OnHeaderCheckBox</vh></v>
<v t="T247"><vh>OnDocChunksCheckBox</vh></v>
<v t="T248"><vh>OnTargetLanguageRadioBox</vh></v>
<v t="T249"><vh>PrefsPanel</vh></v>
</v>
</v>
<v t="T250"><vh>wxPython docs: local @urls</vh>
<v t="T251"><vh>@url file:///C:/prog/wxDocs/wx26.htm#classref</vh></v>
<v t="T252"><vh>@url file:c:\prog\wxDocs\index.htm</vh></v>
<v t="T253"><vh>@url file:///C:\Python22\Lib\site-packages\wxPython\docs\wxPythonManual.html</vh></v>
<v t="T254"><vh>app, color, icon, sizer, xmlresource</vh>
<v t="T255"><vh>@url file:///C:/prog/wxDocs/wx30.htm#wxapp</vh></v>
<v t="T256"><vh>@url file:///C:/prog/wxDocs/wx63.htm#wxcolour</vh></v>
<v t="T257"><vh>@url file:///C:/prog/wxDocs/wx216.htm#wxicon</vh></v>
<v t="T258"><vh>@url file:///C:/prog/wxDocs/wx343.htm#wxsizer</vh></v>
<v t="T259"><vh>@url file:///C:/prog/wxDocs/wx418.htm#wxxmlresource</vh></v>
</v>
<v t="T260"><vh>dialog, frame, panel, splitter,window</vh>
<v t="T261"><vh>@url file:///C:/prog/wxDocs/wx109.htm#wxdialog</vh></v>
<v t="T262"><vh>@url file:///C:/prog/wxDocs/wx163.htm#wxframe</vh></v>
<v t="T263"><vh>@url file:///C:/prog/wxDocs/wx291.htm#wxpanel</vh></v>
<v t="T264"><vh>@url file:///C:/prog/wxDocs/wx357.htm#wxsplitterwindow</vh></v>
<v t="T265"><vh>@url file:///C:/prog/wxDocs/wx411.htm#wxwindow</vh></v>
</v>
<v t="T266"><vh>events</vh>
<v t="T267"><vh>@url file:///C:/prog/wxDocs/wx130.htm#wxevent</vh></v>
<v t="T268"><vh>@url file:///C:/prog/wxDocs/wx264.htm#wxmenuevent</vh></v>
<v t="T269"><vh>@url file:///C:/prog/wxDocs/wx356.htm#wxsplitterevent</vh></v>
<v t="T270"><vh>@url file:///C:/prog/wxDocs/wx400.htm#wxtreeevent</vh></v>
</v>
<v t="T271"><vh>menu</vh>
<v t="T272"><vh>@url file:///C:/prog/wxDocs/wx262.htm#wxmenu</vh></v>
<v t="T273"><vh>@url file:///C:/prog/wxDocs/wx263.htm#wxmenubar</vh></v>
<v t="T274"><vh>@url file:///C:/prog/wxDocs/wx265.htm#wxmenuitem</vh></v>
</v>
<v t="T275"><vh>tree</vh>
<v t="T276"><vh>@url file:///C:/prog/wxDocs/wx399.htm#wxtreectrl</vh></v>
<v t="T277"><vh>@url file:///C:/prog/wxDocs/wx401.htm#wxtreeitemdata</vh></v>
</v>
<v t="T278"><vh>widgets</vh>
<v t="T279"><vh>@url file:///C:/prog/wxDocs/wx46.htm#wxbutton</vh></v>
<v t="T280"><vh>@url file:///C:/prog/wxDocs/wx52.htm#wxcheckbox</vh></v>
<v t="T281"><vh>@url file:///C:/prog/wxDocs/wx212.htm#wxhtmlwindow</vh></v>
<v t="T282"><vh>@url file:///C:/prog/wxDocs/wx357.htm#wxsplitterwindow</vh></v>
<v t="T283"><vh>@url file:///C:/prog/wxDocs/wx381.htm#wxtextctrl</vh></v>
</v>
<v t="T284"><vh>wx Questions</vh></v>
</v>
<v t="T285"><vh>Leo wx prototype</vh>
<v t="T286"><vh>@file c:\prog\test\wxLeo.py</vh>
<v t="T287"><vh>app</vh>
<v t="T288"><vh>OnInit</vh></v>
</v>
<v t="T289"><vh>frame</vh>
<v t="T290"><vh>__init__</vh></v>
<v t="T291"><vh>createMenus (old code: explicit id's)</vh>
<v t="T292"><vh>&lt;&lt; Create the File menu &gt;&gt;</vh>
<v t="T293"><vh>&lt;&lt; Create the initial items of the file menu &gt;&gt;</vh></v>
<v t="T294"><vh>&lt;&lt; Create the Read/Write submenu &gt;&gt;</vh></v>
<v t="T295"><vh>&lt;&lt; Create the Tangle submenu &gt;&gt;</vh></v>
<v t="T296"><vh>&lt;&lt; Create the Untangle submenu &gt;&gt;</vh></v>
<v t="T297"><vh>&lt;&lt; Create the Import Files submenu &gt;&gt;</vh></v>
</v>
<v t="T298"><vh>&lt;&lt; Create the Edit menu &gt;&gt;</vh>
<v t="T299"><vh>&lt;&lt; Create the initial items of the Edit menu &gt;&gt;</vh></v>
<v t="T300"><vh>&lt;&lt; Create the Find submenu &gt;&gt;</vh></v>
<v t="T301"><vh>&lt;&lt; Create the final items of the Edit menu &gt;&gt;</vh></v>
<v t="T302"><vh>&lt;&lt; Create the Edit Body submenu &gt;&gt;</vh></v>
</v>
<v t="T303"><vh>&lt;&lt; Create the Outline menu &gt;&gt;</vh>
<v t="T304"><vh>&lt;&lt; Create the initial items of the Outline menu &gt;&gt;</vh></v>
<v t="T305"><vh>&lt;&lt; Create the Expand/Contract submenu &gt;&gt;</vh></v>
<v t="T306"><vh>&lt;&lt; Create the Move/Select submenu &gt;&gt;</vh></v>
<v t="T307"><vh>&lt;&lt; Create the Mark/Go To submenu &gt;&gt;</vh></v>
</v>
<v t="T308"><vh>&lt;&lt; Create the Window menu &gt;&gt;</vh></v>
<v t="T309"><vh>&lt;&lt; Create the Help menu &gt;&gt;</vh></v>
</v>
<v t="T310"><vh>createMenuBar</vh>
<v t="T311"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T312"><vh>&lt;&lt; create the first top-level edit entries &gt;&gt;</vh></v>
<v t="T313"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T314"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="T315"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
<v t="T316"><vh>&lt;&lt; create the last top-level edit entries &gt;&gt;</vh></v>
</v>
<v t="T317"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T318"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T319"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="T320"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T321"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T322"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T323"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="T324"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="T325"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T326"><vh>&lt;&lt; create top-level outline menu &gt;&gt;</vh></v>
<v t="T327"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="T328"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="T329"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="T330"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="T331"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T332"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T333"><vh>createNewMenu</vh></v>
<v t="T334"><vh>createMenuEntries</vh></v>
<v t="T335"><vh>OnAbout</vh></v>
</v>
<v t="T336"><vh>const</vh></v>
</v>
</v>
</v>
</v>
<v t="T337" a="V"><vh>Plugins</vh>
<v t="T338"><vh>Commands</vh>
<v t="T339"><vh> Importing Cisco configuration files</vh>
<v t="T340" a="M" tnodeList="340,341,342,343,344,345,346,347"><vh>@file import_cisco_config.py</vh>
<v t="T341"><vh>&lt;&lt; about this plugin &gt;&gt;</vh></v>
<v t="T342"><vh>create_import_cisco_menu</vh></v>
<v t="T343"><vh>importCiscoConfig</vh>
<v t="T344"><vh>&lt;&lt; open file &gt;&gt;</vh></v>
<v t="T345"><vh>&lt;&lt; process custom line &gt;&gt;</vh></v>
<v t="T346"><vh>&lt;&lt; process indented block &gt;&gt;</vh></v>
<v t="T347"><vh>&lt;&lt; complete outline &gt;&gt;</vh></v>
</v>
</v>
<v t="T348"><vh> Example of an imported config</vh>
<v t="T349"><vh>plain configuration</vh></v>
<v t="T350"><vh>cisco config: C:/Davide/Leo/CVS Version/example_conf.txt</vh>
<v t="T351"><vh>&lt;&lt;access-list&gt;&gt;</vh></v>
<v t="T352"><vh>&lt;&lt;boot&gt;&gt;</vh></v>
<v t="T353"><vh>&lt;&lt;controller&gt;&gt;</vh>
<v t="T354"><vh>controller E1 5/0/0</vh></v>
<v t="T355"><vh>controller E1 5/0/1</vh></v>
<v t="T356"><vh>controller SONET 1/0/0</vh></v>
</v>
<v t="T357"><vh>&lt;&lt;interface&gt;&gt;</vh>
<v t="T358"><vh>interface Async1</vh></v>
<v t="T359"><vh>interface Dialer0</vh></v>
<v t="T360"><vh>interface FastEthernet0/0/0</vh></v>
<v t="T361"><vh>interface FastEthernet0/0/1</vh></v>
<v t="T362"><vh>interface FastEthernet0/0/1.1</vh></v>
<v t="T363"><vh>interface FastEthernet0/0/1.2</vh></v>
<v t="T364"><vh>interface FastEthernet0/0/1.3</vh></v>
<v t="T365"><vh>interface FastEthernet0/0/1.5</vh></v>
<v t="T366"><vh>interface FastEthernet0/0/1.50</vh></v>
<v t="T367"><vh>interface Loopback0</vh></v>
<v t="T368"><vh>interface POS4/1/0</vh></v>
<v t="T369"><vh>interface Serial5/0/0:1</vh></v>
<v t="T370"><vh>interface Serial5/0/0:2</vh></v>
<v t="T371"><vh>interface Serial5/0/1:0</vh></v>
<v t="T372"><vh>interface Serial5/1/0</vh></v>
<v t="T373"><vh>interface Serial5/1/1</vh></v>
</v>
<v t="T374"><vh>&lt;&lt;ip community-list&gt;&gt;</vh></v>
<v t="T375"><vh>&lt;&lt;ip route&gt;&gt;</vh></v>
<v t="T376"><vh>&lt;&lt;line&gt;&gt;</vh>
<v t="T377"><vh>line aux 0</vh></v>
<v t="T378"><vh>line vty 0 4</vh></v>
</v>
<v t="T379"><vh>&lt;&lt;logging&gt;&gt;</vh></v>
<v t="T380"><vh>&lt;&lt;ntp&gt;&gt;</vh></v>
<v t="T381"><vh>&lt;&lt;route-map&gt;&gt;</vh>
<v t="T382"><vh>route-map only permit 2</vh></v>
<v t="T383"><vh>route-map only1 permit 10</vh></v>
<v t="T384"><vh>route-map only3 permit 10</vh></v>
<v t="T385"><vh>route-map tag_com permit 10</vh></v>
<v t="T386"><vh>route-map tag_com permit 20</vh></v>
</v>
<v t="T387"><vh>&lt;&lt;router&gt;&gt;</vh>
<v t="T388"><vh>router bgp 65001</vh></v>
<v t="T389"><vh>router ospf 1</vh></v>
</v>
<v t="T390"><vh>&lt;&lt;service&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T391" tnodeList="391,392"><vh>@file outline_export.py</vh>
<v t="T392"><vh>newMoreHead</vh></v>
</v>
<v t="T393"><vh>mod_autosave</vh>
<v t="T394" tnodeList="394"><vh>@file mod_autosave.ini</vh></v>
<v t="T395" tnodeList="395,396,397"><vh>@file mod_autosave.py</vh>
<v t="T396"><vh>applyConfiguration</vh></v>
<v t="T397"><vh>autosave</vh></v>
</v>
</v>
<v t="T398" tnodeList="398,399"><vh>@file mod_timestamp.py</vh>
<v t="T399"><vh>timestamp</vh></v>
</v>
</v>
<v t="T400"><vh>Debugging</vh>
<v t="T401" tnodeList="401,402"><vh>@file dump_globals.py</vh>
<v t="T402"><vh>onStart</vh></v>
</v>
<v t="T403" tnodeList="403,404"><vh>@file enable_gc.py</vh>
<v t="T404"><vh>onStart</vh></v>
</v>
<v t="T405" tnodeList="405"><vh>@file trace_gc.py</vh></v>
<v t="T406" tnodeList="406,407"><vh>@file trace_keys.py</vh>
<v t="T407"><vh>onKey</vh></v>
</v>
<v t="T408" tnodeList="408,409"><vh>@file trace_tags.py</vh>
<v t="T409"><vh>trace_tags</vh></v>
</v>
</v>
<v t="T410"><vh>Directives</vh>
<v t="T411" tnodeList="411,412,413"><vh>@file add_directives.py</vh>
<v t="T412"><vh>addPluginDirectives</vh></v>
<v t="T413"><vh>scanPluginDirectives</vh></v>
</v>
</v>
<v t="T414"><vh>Drawing, graphics &amp; styled text</vh>
<v t="T415" a="M" tnodeList="415,416,417,418,419,420,421,422"><vh>@file color_markup.py</vh>
<v t="T416"><vh>initAnyMarkup</vh></v>
<v t="T417"><vh>colorWikiMarkup</vh></v>
<v t="T418"><vh>doWikiText</vh>
<v t="T419"><vh>&lt;&lt; set first to a tuple describing the first tag to be handled &gt;&gt;</vh></v>
<v t="T420"><vh>&lt;&lt; handle the tag using n1,n2,delim1,delim2 &gt;&gt;</vh>
<v t="T421"><vh>&lt;&lt; parse and handle color field &gt;&gt;</vh></v>
</v>
</v>
<v t="T422"><vh>insertWikiPicture</vh></v>
</v>
<v t="T423" a="M" tnodeList="423,424,425,426,427"><vh>@file image.py</vh>
<v t="T424"><vh>onSelect</vh>
<v t="T425"><vh>&lt;&lt; Select Image &gt;&gt;</vh></v>
</v>
<v t="T426"><vh>onUnselect</vh>
<v t="T427"><vh>&lt;&lt; Unselect Image &gt;&gt;</vh></v>
</v>
</v>
<v t="T428" a="M" tnodeList="428,429,430,431,432,433,434,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459"><vh>@file nav_buttons.py</vh>
<v t="T429"><vh>class commanderInfoClass</vh>
<v t="T430"><vh>__init__ (commanderInfoClass)</vh></v>
<v t="T431"><vh>addWidgets</vh>
<v t="T432"><vh>&lt;&lt; define callbacks &gt;&gt;</vh></v>
</v>
<v t="T433"><vh>createImage</vh></v>
<v t="T434"><vh>updateNavButtons (nav_buttons.py)</vh></v>
<v t="T435"><vh>Callbacks</vh>
<v t="T436"><vh>marksButtonCallback</vh></v>
<v t="T437"><vh>recentButtonCallback</vh></v>
</v>
</v>
<v t="T438"><vh>class globalInfoClass</vh>
<v t="T439"><vh>__init__ ( globalInfoClass)</vh></v>
<v t="T440"><vh>addNavWidgets</vh></v>
<v t="T441"><vh>destroyFrame, destroyAllFrames, destroyOneFrame</vh></v>
<v t="T442"><vh>updateRecentSections</vh></v>
<v t="T443"><vh>updateMarks &amp; updateMarksAfterCommand</vh></v>
<v t="T444"><vh>updateNavButtons</vh></v>
</v>
<v t="T445"><vh>class marksDialog (listBoxDialog)</vh>
<v t="T446"><vh>marksDialog.__init__</vh></v>
<v t="T447"><vh>createFrame</vh></v>
<v t="T448"><vh>addbuttons</vh></v>
<v t="T449"><vh>fillbox</vh></v>
</v>
<v t="T450"><vh>class recentSectionsDialog (listBoxDialog)</vh>
<v t="T451"><vh>__init__  recentSectionsDialog</vh></v>
<v t="T452"><vh>addButtons</vh></v>
<v t="T453"><vh>clearAll</vh></v>
<v t="T454"><vh>createFrame</vh></v>
<v t="T455"><vh>deleteEntry</vh></v>
<v t="T456"><vh>destroy</vh></v>
<v t="T457"><vh>fillbox (recent sections)</vh>
<v t="T458"><vh>&lt;&lt; reconstruct the contents of self.box &gt;&gt;&gt;</vh></v>
</v>
<v t="T459"><vh>synchNavButtons</vh></v>
</v>
</v>
</v>
<v t="T460"><vh>External editors &amp; Open With</vh>
<v t="T461" tnodeList="461,462,463,464,465,466"><vh>@file open_with.py</vh>
<v t="T462"><vh>on_idle</vh>
<v t="T463"><vh>&lt;&lt; update v's body text &gt;&gt;</vh>
<v t="T464"><vh>&lt;&lt; set s to the file text &gt;&gt;</vh></v>
</v>
</v>
<v t="T465"><vh>create_open_with_menu</vh>
<v t="T466"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
</v>
</v>
<v t="T467" tnodeList="467,468"><vh>@file vim.py</vh>
<v t="T468"><vh>open_in_vim</vh></v>
</v>
<v t="T469" tnodeList="469"><vh>@file xemacs.py</vh></v>
<v t="T470" a="E"><vh>word export</vh>
<v t="T471" tnodeList="471,472,473,474,475,476"><vh>@file word_export.py</vh>
<v t="T472"><vh>getConfiguration</vh></v>
<v t="T473"><vh>getWordConnection</vh></v>
<v t="T474"><vh>doPara</vh></v>
<v t="T475"><vh>writeNodeAndTree</vh></v>
<v t="T476"><vh>cmd_Export</vh></v>
</v>
<v t="T477" tnodeList="477"><vh>@file word_export.ini</vh></v>
</v>
</v>
<v t="T478"><vh>Files</vh>
<v t="T479" tnodeList="479,480,481"><vh>@file empty_leo_file.py</vh>
<v t="T480"><vh>&lt;&lt; define minimal .leo file &gt;&gt;</vh></v>
<v t="T481"><vh>onOpen</vh></v>
</v>
<v t="T482" tnodeList="482,483,484,485,486,487,488,489"><vh>@file open_shell.py</vh>
<v t="T483"><vh>&lt;&lt; about the open shell plugin &gt;&gt;</vh></v>
<v t="T484"><vh>load_menu</vh></v>
<v t="T485"><vh>_getpath</vh></v>
<v t="T486"><vh>_getcurrentnodepath</vh></v>
<v t="T487"><vh>launchCmd</vh></v>
<v t="T488"><vh>launchExplorer</vh></v>
<v t="T489"><vh>launchxTerm</vh></v>
</v>
</v>
<v t="T490"><vh>Foreign languages</vh>
<v t="T491" tnodeList="491,492"><vh>@file french.py</vh>
<v t="T492"><vh>onMenu</vh></v>
</v>
<v t="T493" tnodeList="493,494"><vh>@file french_fm.py</vh>
<v t="T494"><vh>onMenu</vh></v>
</v>
</v>
<v t="T495"><vh>Key bindings</vh>
<v t="T496" tnodeList="496,497"><vh>@file arrows.py</vh>
<v t="T497"><vh>onOpen</vh></v>
</v>
</v>
<v t="T498"><vh>Menus</vh>
<v t="T499"><vh> Plugins menu</vh>
<v t="T500" a="M" tnodeList="500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522"><vh>@file plugins_menu.py</vh>
<v t="T501"><vh>class Plugin</vh>
<v t="T502"><vh>__init__</vh>
<v t="T503"><vh>&lt;&lt; Check if this can be configured &gt;&gt;</vh></v>
<v t="T504"><vh>&lt;&lt; Check if this has an apply &gt;&gt;</vh></v>
<v t="T505"><vh>&lt;&lt; Look for additional commands &gt;&gt;</vh></v>
</v>
<v t="T506"><vh>about</vh></v>
<v t="T507"><vh>properties</vh></v>
</v>
<v t="T508"><vh>class PropertiesWindow</vh>
<v t="T509"><vh>__init__</vh>
<v t="T510"><vh>&lt;&lt; initialize all ivars &gt;&gt;</vh></v>
<v t="T511"><vh>&lt;&lt; create the frame from the configuration data &gt;&gt;</vh>
<v t="T512"><vh>&lt;&lt; Create the top level and the main frame &gt;&gt;</vh></v>
<v t="T513"><vh>&lt;&lt; Create widgets for each section and option &gt;&gt;</vh></v>
<v t="T514"><vh>&lt;&lt; Create Ok, Cancel and Apply buttons &gt;&gt;</vh></v>
</v>
</v>
<v t="T515"><vh>Event Handlers</vh></v>
<v t="T516"><vh>writeConfiguration</vh></v>
</v>
<v t="T517"><vh>class PluginAbout</vh>
<v t="T518"><vh>__init__</vh>
<v t="T519"><vh>&lt;&lt; Create the contents of the about box &gt;&gt;</vh></v>
<v t="T520"><vh>&lt;&lt; Create the close button &gt;&gt;</vh></v>
</v>
</v>
<v t="T521"><vh>createPluginsMenu</vh>
<v t="T522"><vh>&lt;&lt; add items to the plugins menu &gt;&gt;</vh></v>
</v>
</v>
<v t="T523" a="M"><vh>@file test.py</vh>
<v t="T524"><vh>applyConfiguration</vh></v>
<v t="T525"><vh>cmd_fn1/2/3</vh></v>
<v t="T526"><vh>onSelect</vh>
<v t="T527"><vh>&lt;&lt; Select Image &gt;&gt;</vh></v>
</v>
<v t="T528"><vh>onUnselect</vh>
<v t="T529"><vh>&lt;&lt; Unselect Image &gt;&gt;</vh></v>
</v>
</v>
<v t="T530"><vh>Notes re plugins menu</vh>
<v t="T531"><vh> Changes made by E.K.Ream</vh></v>
<v t="T532"><vh> Design</vh></v>
<v t="T533"><vh> Initial suggestion from Paul Paterson</vh></v>
</v>
</v>
<v t="T534" tnodeList="534,535,536,537,538"><vh>@file scripts_menu.py</vh>
<v t="T535"><vh>createScriptsMenu</vh>
<v t="T536"><vh>&lt;&lt; Return if no scripts exist anywhere &gt;&gt;</vh></v>
<v t="T537"><vh>&lt;&lt; Create top-level entries for every script in top_scripts &gt;&gt;</vh></v>
<v t="T538"><vh>&lt;&lt; Create a submenu for dir containing each file in files &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T539"><vh>New kinds of nodes</vh>
<v t="T540" tnodeList="540,541,542"><vh>@file at_folder.py</vh>
<v t="T541"><vh>&lt;&lt; about this plugin &gt;&gt;</vh></v>
<v t="T542"><vh>sync_node_to_folder</vh></v>
</v>
<v t="T543" tnodeList="543,544,545,546,547,549,550,552,554,555,556,557,558,559,560,561,562,563,564,565,566,567"><vh>@file read_only_nodes.py</vh>
<v t="T544"><vh>documentation for @read-only nodes</vh>
<v t="T545"><vh>ftp/http access</vh></v>
</v>
<v t="T546"><vh>class FTPurl</vh>
<v t="T547"><vh>__init__</vh></v>
<v t="T548"><vh>Getters</vh>
<v t="T549"><vh>read</vh></v>
<v t="T550"><vh>readline</vh></v>
</v>
<v t="T551"><vh>Setters</vh>
<v t="T552"><vh>write</vh></v>
</v>
<v t="T553"><vh>Utilities</vh>
<v t="T554"><vh>seek</vh></v>
<v t="T555"><vh>flush</vh></v>
<v t="T556"><vh>dir</vh></v>
<v t="T557"><vh>exists</vh></v>
<v t="T558"><vh>checkParams</vh></v>
</v>
<v t="T559"><vh>close</vh></v>
</v>
<v t="T560"><vh>enable/disable_body</vh></v>
<v t="T561"><vh>insert_read_only_node (FTP version)</vh>
<v t="T562"><vh>&lt;&lt; convert HTML to text &gt;&gt;</vh></v>
</v>
<v t="T563"><vh>on_open2</vh></v>
<v t="T564"><vh>on_bodykey1</vh></v>
<v t="T565"><vh>on_headkey2</vh></v>
<v t="T566"><vh>on_select1</vh></v>
<v t="T567"><vh>on_select2</vh></v>
</v>
<v t="T568" tnodeList="568,569,570,571,572,573,574,575,576"><vh>@file rst.py</vh>
<v t="T569"><vh>&lt;&lt;about this plugin &gt;&gt;</vh></v>
<v t="T570"><vh>&lt;&lt; change log &gt;&gt;</vh></v>
<v t="T571"><vh>onIconDoubleClick</vh>
<v t="T572"><vh>&lt;&lt; write rST as HTML &gt;&gt;</vh>
<v t="T573"><vh>&lt;&lt; convert rST to HTML &gt;&gt;</vh></v>
</v>
<v t="T574"><vh>&lt;&lt; write rST file &gt;&gt;</vh></v>
</v>
<v t="T575"><vh>writeTreeAsRst</vh></v>
<v t="T576"><vh>underline</vh></v>
</v>
<v t="T577" tnodeList="577,578,579,580,581"><vh>@file startfile.py</vh>
<v t="T578"><vh>&lt;&lt;about this plugin &gt;&gt;</vh></v>
<v t="T579"><vh>&lt;&lt; change log &gt;&gt;</vh></v>
<v t="T580"><vh>onIconDoubleClick</vh>
<v t="T581"><vh>&lt;&lt; find path and start file &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T582"><vh>Overriding functions, methods &amp; classes</vh>
<v t="T583" tnodeList="583,584,585"><vh>@file __overrideClasses.py</vh>
<v t="T584"><vh>&lt;&lt; override the LeoFrame class &gt;&gt;</vh></v>
<v t="T585"><vh>&lt;&lt; override methods of the LeoApp class &gt;&gt;</vh></v>
</v>
<v t="T586" tnodeList="586,587"><vh>@file override_commands.py</vh>
<v t="T587"><vh>onCommand</vh></v>
</v>
<v t="T588" tnodeList="588,589,590"><vh>@file redefine_put.py</vh>
<v t="T589"><vh>onStart</vh></v>
<v t="T590"><vh>newPut and newPutNl</vh></v>
</v>
<v t="T591" tnodeList="591"><vh>@file redirect_to_log.py</vh></v>
<v t="T592" tnodeList="592,593,594,595,596"><vh>@file script_io_to_body.py</vh>
<v t="T593"><vh>onStart</vh></v>
<v t="T594"><vh>newExecuteScript</vh></v>
<v t="T595"><vh>newPut and newPutNl</vh></v>
<v t="T596"><vh>newEs, etc.</vh></v>
</v>
</v>
<v t="T597"><vh>Spell Checking</vh>
<v t="T598"><vh>@silentfile mod_spelling.txt</vh></v>
<v t="T599" tnodeList="599"><vh>@file mod_spelling.ini</vh></v>
<v t="T600" a="M" tnodeList="600,602,603,604,605,607,608,609,610,611,612,613,614,615,617,618,619,620,621,622,623,624,626,627,628,629,630,631,633,634,635,636,637,639,640,641,642,643,644,645,646,647,648"><vh>@file mod_spelling.py</vh>
<v t="T601"><vh>Functions</vh>
<v t="T602"><vh>createSpellMenu</vh></v>
<v t="T603"><vh>onSelect</vh></v>
<v t="T604"><vh>onCommand</vh></v>
</v>
<v t="T605"><vh>class Aspell</vh>
<v t="T606"><vh>Birth &amp; death</vh>
<v t="T607"><vh>__init__</vh></v>
<v t="T608"><vh>getAspellDirectory</vh></v>
</v>
<v t="T609"><vh>openPipes</vh>
<v t="T610"><vh>&lt;&lt; Ensure local dictionary is present &gt;&gt;</vh></v>
</v>
<v t="T611"><vh>closePipes</vh></v>
<v t="T612"><vh>listAlternates</vh></v>
<v t="T613"><vh>processWord</vh></v>
<v t="T614"><vh>updateDictionary</vh></v>
</v>
<v t="T615"><vh>class spellDialog</vh>
<v t="T616"><vh>Birth &amp; death</vh>
<v t="T617"><vh>spell.__init__</vh>
<v t="T618"><vh>&lt;&lt; set self.dictionary &gt;&gt;</vh></v>
</v>
<v t="T619"><vh>getLocalDictionary</vh></v>
<v t="T620"><vh>getLocalLanguageCode</vh></v>
<v t="T621"><vh>readLocalDictionary</vh></v>
</v>
<v t="T622"><vh>createFrame</vh>
<v t="T623"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="T624"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="T625"><vh>Buttons</vh>
<v t="T626"><vh>onAddButton</vh></v>
<v t="T627"><vh>onIgnoreButton</vh></v>
<v t="T628"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="T629"><vh>onFindButton</vh></v>
<v t="T630"><vh>onHideButton</vh></v>
<v t="T631"><vh>onRedoButton &amp; onUndoButton</vh></v>
</v>
<v t="T632"><vh>Commands</vh>
<v t="T633"><vh>add</vh></v>
<v t="T634"><vh>change</vh></v>
<v t="T635"><vh>checkSpelling</vh></v>
<v t="T636"><vh>find</vh></v>
<v t="T637"><vh>ignore</vh></v>
</v>
<v t="T638"><vh>Helpers</vh>
<v t="T639"><vh>closePipes</vh></v>
<v t="T640"><vh>fillbox</vh></v>
<v t="T641"><vh>findNextMisspelledWord</vh>
<v t="T642"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="T643"><vh>findNextWord</vh></v>
<v t="T644"><vh>getSuggestion</vh></v>
<v t="T645"><vh>onMap</vh></v>
<v t="T646"><vh>onSelectListBox</vh></v>
<v t="T647"><vh>update</vh></v>
<v t="T648"><vh>updateButtons</vh></v>
</v>
</v>
</v>
</v>
<v t="T649"><vh>Plugin manager (demo)</vh>
<v t="T650"><vh>Notes by Paul Paterson</vh></v>
<v t="T651" tnodeList="651,652,653,654,655,656,657,658,659,660"><vh>@file leopm_client.py</vh>
<v t="T652"><vh>class LeoPMClient</vh>
<v t="T653"><vh>__init__</vh></v>
<v t="T654"><vh>poll</vh></v>
<v t="T655"><vh>_getSelectedPluginName</vh></v>
<v t="T656"><vh>updateDetail</vh></v>
<v t="T657"><vh>downloadPlugin</vh></v>
<v t="T658"><vh>getPluginList</vh></v>
<v t="T659"><vh>initListbox</vh></v>
<v t="T660"><vh>getVersionOfFile</vh></v>
</v>
</v>
<v t="T661" tnodeList="661,662,662,663,664,665,666,667,668"><vh>@file leopm_server.py</vh>
<v t="T662"><vh>class LeoPM</vh>
<v t="T663"><vh>__init__</vh></v>
<v t="T664"><vh>getPluginNames</vh></v>
<v t="T665"><vh>getPluginDescription</vh></v>
<v t="T666"><vh>getPlugin</vh></v>
<v t="T667"><vh>getPluginVersion</vh></v>
<v t="T668"><vh>getPluginFilenames</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@nocolor</t>
<t tx="T2"></t>
<t tx="T3">@nocolor

This file contains code for all plugins distributed with Leo.</t>
<t tx="T4">@nocolor

What is a plugin?

A plugin is a .py file that appears in Leo's plugin subdirectory. Leo tries to
import all such files while starting up. This is done at "start1" time, that
is, in the call to doHook("start1") in the run function in leo.py. Plugins
exist to define "hook code".

What is hook code?

Leo automatically calls hook code at various times during Leo's execution.
Typical hooks are:

- "start2", called at the end of Leo's startup process,
- "command1", called before executing any of Leo's commands
- "idle", called at Tk's idle time, when nothing else is happening,

See the documentation for hooks in this file for full details.

N.B. Plugins can use "start2" hooks to override any of Leo's classes. See
"Overriding functions, methods &amp; classes" in leoPlugins.leo for several
examples of how to do this.

How do plugins work?

Plugins register themselves when Leo imports them using the following code,
which should appear as the outer level of the .py file:

@color

"""A description of this plugin"""

if 1: # 1 to enable the plugin, 0 to disable the plugin:
	registerHandler("xxx", onXXX)
	__version__ = "1.2"
	plugin_signon(__name__)
	
@nocolor

Line by line:

1) """A description of this plugin"""

This is a Python doc string describing the plugin. This string becomes the
value of the __name__ attribute for the module (.py file).

2) if 1: # 1 to enable the plugin, 0 to disable the plugin:

This line enables or disables the code that registers the plugin. Plugins do
nothing unless they are actually registered when Leo first imports them.

3) registerHandler("xxx", onXXX)

This line registers a handler called onXXX for the hook called "xxx". See the
documentation for hooks for a complete list of hook names that you can use
instead of "xxx". onXXX is the name of a function or method, presumably defined
in the plugin file, that Leo will call at "xxx" time. For example:

registerHandler("idle",onIdle)

will cause Leo to call the onIdle function at "idle" time.

You can pass a list of hook names as the first argument to registerHandler. For
example:

registerHandler(("bodykey1","bodykey2","headkey1","headkey2"), onKey)

4) __version__ = "1.2"

This assigns a version attribute to module. At present this attribute is used
by the plugin code that creates Leo's Plugins menu.

5) plugin_signon(__name__)

This line increases the count of loaded modules. The present code for
plugin_signon does not actually print separate signons--it seems to verbose.

About hook handlers

See the "About hooks" section of leoPlugins.leo for full documentation about
how to write hook handler routines, like onXXX or onKey in the examples above.
Basically, each hook should have this pattern:
	
@color

def onXXX (tag,keywords):
	c = keywords.get("c")
	otherKeyword = keywords.get("otherKeyword")
	&lt;&lt; do something with c and otherKeyword, etc. &gt;&gt;
	
@nocolor

In other words, keywords is a Python dictionary containing the keyword
arguments passed to the hook handler. See the See the "About hooks" section of
leoPlugins.leo for a list of the keywords passed to each hook handler.

The tag is the name of the hook. For example, tag would one of
"bodykey1","bodykey2","headkey1","headkey2", for the onKey hook handler in the
example above.

What's next?

It's one thing to know how to create a plugin. It's another to know how to
actually change Leo. Obviously, some study is needed. The place to start your
study is LeoPy.leo. In particular, study very carefully the section called
"Overview of code". Leo is a highly modular program, and Python is ideally
suited to this style of programming.</t>
<t tx="T5">@nocolor

Scripting is fully documented in Leo's Users Guide, and the following should be enough to get you started:

@color

top() # The commander of the top (current) windows.
top().rootVnode() # The root vnode of the outline.
top().currentVnode() # The presently selected vnode.

@nocolor

If v is any vnode:
	
@color

v.headString() # is the headline of v.
v.bodyString() # is the body of v.
v.threadNext() # is node after v in outline order.

@nocolor

For example, this prints every headline of an outline:
	
@color

v = top().rootVnode()
while v:
	print v.headString()
	v = v.threadNext()
</t>
<t tx="T6">At startup time Leo looks all files of the form mod_*.py in the plugins
directory. Leo assumes that these files are "plugins" containing Python modules
that customizes Leo's operation. Leo attempts to import each file.

Each module should register routines that are called at various times during
execution. Such times are identified by strings known as "tags". The code in in
one or more plugins corresponding to each tag are known as the "hook" routines
for that tag. Leo catches exceptions (including syntax errors) in hook
routines, so it is safe to hack away on this code.

Leo passes two argument to all hook routines: the tag and a keywords dictionary
containing additional information. For example, keywords["label"] indicates the
kind of command for "command1" and "command2" hooks.

For some hooks, returning anything other than None "overrides" Leo's default
action. Hooks have full access to all of Leo's source code. Just import the
relevant file. For example, top() returns the commander for the topmost Leo
window.

The following table summarizes the arguments passed to hooks: ( Overrides is
"yes" if returning anything other than None overrides Leo's normal command or
event processing.)

tag argument                                              keys in keywords
(hook name)  overrides       when called                  dictionary argument
---------    ---------       -----------                  -------------------
"bodyclick1"   yes      before normal click in body       c,v,event 
"bodyclick2"            after  normal click in body       c,v,event 
"bodydclick1"  yes      before double click in body       c,v,event 
"bodydclick2"           after  double click in body       c,v,event 
"bodykey1"     yes      before body keystrokes            c,v,ch,oldSel,undoType
"bodykey2"              after  body keystrokes            c,v,ch,oldSel,undoType
"bodyrclick1"  yes      before right click in body        c,v,event 
"bodyrclick2"           after  right click in body        c,v,event 
"boxclick1"    yes      before click in +- box            c,v,event 
"boxclick2"             after  click in +- box            c,v,event 
"command1"     yes      before each command               c,v,label (note 2)
"command2"              after  each command               c,v,label (note 2)
"drag1"        yes      before start of drag              c,v,event 
"drag2"                 after  start of drag              c,v,event 
"dragging1"    yes      before continuing to drag         c,v,event 
"dragging2"             after  continuing to drag         c,v,event 
"end1"                  start of app.quit()
"enddrag1"     yes      before end of drag                c,v,event 
"enddrag2"              after  end of drag                c,v,event 
"headkey1"     yes      before headline keystrokes        c,v,ch
"headkey2"              after  headline keystrokes        c,v,ch
"headclick1"   yes      before normal click in headline   c,v,event 
"headclick2"            after  normal click in headline   c,v,event 
"headrclick1"  yes      before right click in headline    c,v,event 
"headrclick2"           after  right click in headline    c,v,event 
"hypercclick1" yes      before control click in hyperlink c,v,event 
"hypercclick2"          after  control click in hyperlink c,v,event 
"hyperenter1"  yes      before entering hyperlink         c,v,event 
"hyperenter2"           after  entering hyperlink         c,v,event 
"hyperleave1"  yes      before leaving  hyperlink         c,v,event 
"hyperleave2"           after  leaving  hyperlink         c,v,event 
"iconclick1"   yes      before single click in icon box   c,v,event 
"iconclick2"            after  single click in icon box   c,v,event 
"iconrclick1"  yes      before right click in icon box    c,v,event 
"iconrclick2"           after  right click in icon box    c,v,event 
"icondclick1"  yes      before double click in icon box   c,v,event 
"icondclick2"           after  double click in icon box   c,v,event 
"idle"                  periodically (at idle time)       c,v
"menu1"        yes      before creating menus             c,v (note 3)
"menu2"        yes      before updating menus             c,v
"new"          no       during New command                old_c,new_c
"open1"        yes      before opening any file           old_c,new_c,fileName (note 4)
"open2"                 after  opening any file           old_c,new_c,fileName (note 4)
"openwith1"    yes      before Open With command          c,v,openType,arg,ext
"openwith2"             after  Open With command          c,v,openType,arg,ext
"recentfiles1" yes      before Recent Files command       c,v,fileName,closeFlag
"recentfiles2"          after  Recent Files command       c,v,fileName,closeFlag
"save1"        yes      before any Save command           c,v,fileName
"save2"                 after  any Save command           c,v,fileName
"select1"      yes      before selecting a vnode          c,new_v,old_v
"select2"               after  selecting a vnode          c,new_v,old_v
"start1"       no       after app.finishCreate()
"start2"                after opening first Leo window    c,v,fileName
"unselect1"    yes      before unselecting a vnode        c,new_v,old_v 
"unselect2"             after  unselecting a vnode        c,old_v,old_v 
"@url1"        yes      before double-click @url node     c,v (note 5)
"@url2"                 after  double-click @url node     c,v (note 5)

The following hooks are a new breed of hook, called "stub hooks". Conceptually,
these hooks are like calls to stub routines that can be filled in by code in
plugins.

tag argument                                                   keys in keywords
(hook name)             overrides    when called               dictionary argument
---------               ---------    -----------               -------------------

"create-optional-menus"  no          (note 8)                  (note 8)

"draw-outine-box"        yes         start of drawBox          tree,v,x,y (note 6)
"draw-outline-icon"      yes         start of tree.drawIcon    tree,v,x,y (note 6)
"draw-outline-node"      yes         start of tree.drawNode    tree,v,x,y (note 6)
"draw-outline-text-box"  yes         start of tree.drawText    tree,v,x,y (note 6)
"draw-sub-outline"       yes         start of tree.drawTree    tree,v,x,y,h,level (note 6)
"redraw-entire-outline"  yes         start of tree.redraw      c (note 6)

"color-optional-markup"  yes *       (note 7)                  colorer,v (note 7)
"init-color-markup"      no          (note 7)                  colorer,v,s,i,j,colortag (note 7)

"new"                    no          start of New command      old_c,new_c (note 9)

"scan-directives"        no          in scanDirectives         c,v,s,old_dict,dict,pluginsList (note 10)

Notes:

(1) "activate" and "deactivate" hooks: These have been removed because they do
not work as expected.

(2) "commands" hooks: The label entry in the keywords dict contains the
"canonicalized" form of the command, that is, the lowercase name of the command
with all non-alphabetic characters removed.

Commands hooks now set the label for undo and redo commands "undo" and "redo"
rather than "cantundo" and "cantredo".

(3) "menu1" hook: Setting app().realMenuNameDict in this hook is an easy way of
translating menu names to other languages. Note: the "new" names created this
way affect only the actual spelling of the menu items, they do _not_ affect how
you specify shortcuts in leoConfig.txt, nor do they affect the "official"
command names passed in app().commandName. For example, suppose you set
app().realMenuNameDict["Open..."] = "Ouvre".

(4) "open1" and "open2" hooks: These are called with a keywords dict containing
the following entries:

old_c: The commander of the previously open window.
new_c: The commander of the newly opened window.
fileName: The name of the file being opened.

You can use old_c.currentVnode() and new_c.currentVnode() to get the current
vnode in the old and new windows.

Leo calls the "open1" and "open2" hooks only if the file is already open.
Leo will also call the "open1" and "open2" hooks if:
a) a file is opened using the Recent Files menu and
b) the file is not already open.

(5) "@url1" and "@url2" hooks are only executed if "icondclick1" hook returns
None.

(6) These stub hooks allow plugins to revise or completely replace how Leo
draws outlines. For example, you could change tree.drawIcon to add additional
icons. These stub hooks are really methods of the leoTree class, with the
"tree" keyword corresponding to the "self" parameter. These stub hooks are
called at the beginning of the indicated method. See the method themselves for
a description of the paramters.

(7) These stub hooks allow plugins to parse and handle markup withing doc
parts, comments and Python """ strings. Note that these hooks are _not_ called
in Python ''' strings. See the color_markup plugin for a complete example of
how to use these hooks.

(8) The "create-optional-menus" stub hook is called when Leo is creating menus,
at the place at which creating new menus is appropriate. Therefore, this hook
need only create new menus in the correct order, without worrying about the
placement of the menus in the menu bar. See the plugins_menu and scripts_menu
plugins for examples of how to use this hook. Leo now executes hooks in
alphabetical order, so that the Plugins menu will be created before the Scripts
menu.

(9) The "new" stub hook is called at the beginning of the code that implements
the New command. This provides a much easier way of recognizing when Leo is
about to create a new Leo window.

(10) The "scan-directives" stub hooks is called inside the scanDirectives
global function. The dictionary returned by scanDirectives now contains an item
whose key is "pluginsList". The value of this item is a list of tuples
(d,v,s,k) where:

- d is the spelling of the @directive, without the leading @.
- v is the vnode containing the directive, _not_ the original vnode.
- s[k:] is a string containing whatever follows the @directive. k has already
been moved past any whitespace that follows the @directive.

See the add_directives plugins directive for a complete example of how to use
the "scan-directives" stub hook.</t>
<t tx="T7">Naively using hooks can expose you and your .leo files to malicious attacks.

** Hooks should never blindly execute Python scripts in .leo files.

It is safe to import and execute code from Leo itself, provided that you got Leo from Leo's SourceForge site.</t>
<t tx="T8">@color
@ WARNING ***** Using the following routine exposes you malicious code in .leo files! *****

Do not EVER use code that blindly executes code in .leo files!
Someone could send you malicious code embedded in the .leo file.

WARNING 1: Changing "@onloadpythonscript" to something else will NOT protect
           you if you EVER share either your files with anyone else.

WARNING 2: Replacing exec by rexec below provides NO additional protection!
           A malicious rexec script could trash your .leo file in subtle ways.
@c
if 0: # WRONG: This blindly execute scripts found in an .leo file! NEVER DO THIS!
	def onLoadFile():
		v = top().rootVnode()
		while v:
			h = v.headString().lower()
			if match_word(h,0,"@onloadpythonscript"):
				s = v.bodyString()
				if s and len(s) &gt; 0:
					try: # SECURITY BREACH: s may be malicious!
						exec s + '\n' in {}
					except:
						es_exception()
			v = v.threadNext()</t>
<t tx="T9"></t>
<t tx="T10"></t>
<t tx="T11">@nocolor

Allow different default types for each section.
Create _all_ menus from settings ?

[plugins]

pluginName = 1/0 # enables or disables plugin

# option = type (overrides defaults)

	[types]

__default_type = bool
page_width = int
tab_width = int
default_tangle_directory = string

	use type name in option?
	
	_color: color
	
	_font: font
	_key: keystroke
	_flag: bool
	everything else: bool
	
	bool: checkmark
	color: picker (or use dialog)

[menus]
child = parent</t>
<t tx="T12"></t>
<t tx="T13">"""Create a settings menu to replace LeoConfig.leo"""

from leoPlugins import *
from leoGlobals import *

import leoApp,leoAtFile,leoDialog,leoFileCommands,leoFrame,leoNodes

if 0: # Register the handlers...

	settingsMenu = None

	@others
	
	# registerHandler("start1",onAfterFinishCreate)
	registerHandler("create-optional-menus",createSettingsMenu)

	__version__ = "0.1"
	plugin_signon(__name__)</t>
<t tx="T14">def createSettingsMenu (tag,keywords):

	c = keywords.get("c")
	
	global settingsMenu
	settingsMenu = c.frame.createNewMenu("&amp;Settings")</t>
<t tx="T15">@ignore

@ This code will soon become a plugin replaces Tk widgets with wxPython widgets.

To do:
	
- Convert the code in wxLeo.py to a plugin that overrides Leo's actual code.

- Override all of Leo's classes that contain Tk code, replacing Tk code with equivalent wxWindows code.

This will include the LeoDialog, LeoFrame and leoTree classes, and many others.  In particular, the colorizer will have to be rewritten.</t>
<t tx="T16"># Executing the following script executes some example wxWindows code.
# Just do the Execute Script command from here.
# For this to work the path to wxTest.py must be in sys.path.

# The first time you do this the window is created twice: once for the import and once for the reload.
# Thereafter only the reload takes effect, so only one window gets created.
# The purpose of reload is so you can change the code without restarting Leo.

import wxTest
reload(wxTest)</t>
<t tx="T17">from wxPython.wx import *

class Form1(wxPanel):
    def __init__(self, parent, id):
        wxPanel.__init__(self, parent, -1)
        self.quote = wxStaticText(self, -1, "Your quote :",wxPoint(20, 30))

        # A multiline TextCtrl
        self.logger = wxTextCtrl(self,5, "",wxPoint(300,20), wxSize(200,300),wxTE_MULTILINE | wxTE_READONLY)

        # A button
        self.button =wxButton(self, 10, "Save", wxPoint(200, 300))
        EVT_BUTTON(self, 10, self.OnClick)

        # the edit control - one line version.
        self.lblname = wxStaticText(self, -1, "Your name :",wxPoint(20,60))
        self.editname = wxTextCtrl(self, 20, "Enter here your name", wxPoint(150, 60), wxSize(150, -1))
        EVT_TEXT(self, 20, self.EvtText)
        EVT_CHAR(self.editname, self.EvtChar)

        # the combobox Control
        self.sampleList = ['friends', 'advetising', 'Websearch', 'yellowpages']
        self.lblhear = wxStaticText(self,-1,"How did you hear from us ?",wxPoint(20, 90))
        self.edithear=wxComboBox(self, 30, "", wxPoint(150, 90), wxSize(95, -1),
                   self.sampleList, wxCB_DROPDOWN)
        EVT_COMBOBOX(self, 30, self.EvtComboBox)
        EVT_TEXT(self, 30, self.EvtText)
        # Checkbox
        self.insure = wxCheckBox(self, 40, "Do you want Insured Shipment ?",wxPoint(20,180))
        EVT_CHECKBOX(self, 40,   self.EvtCheckBox)
        # Radio Boxes
        self.radioList = ['blue', 'red', 'yellow', 'orange', 'green', 'purple',
                      'navy blue', 'black', 'gray']

        rb = wxRadioBox(self, 50, "What color would you like ?", wxPoint(20, 210), wxDefaultSize,
                        self.radioList, 3, wxRA_SPECIFY_COLS)
        EVT_RADIOBOX(self, 50, self.EvtRadioBox)
    def EvtRadioBox(self, event):
        self.logger.AppendText('EvtRadioBox: %d\n' % event.GetInt())
    def EvtComboBox(self, event):
        self.logger.AppendText('EvtComboBox: %s\n' % event.GetString())
    def OnClick(self,event):
        self.logger.AppendText(" Click on object with Id %d\n" %event.GetId())
    def EvtText(self, event):
        self.logger.AppendText('EvtText: %s\n' % event.GetString())
    def EvtChar(self, event):
        self.logger.AppendText('EvtChar: %d\n' % event.GetKeyCode())
        event.Skip()
    def EvtCheckBox(self, event):
        self.logger.AppendText('EvtCheckBox: %d\n' % event.Checked())

class Form2(wxPanel):
    def __init__(self, parent, id):
        wxPanel.__init__(self, parent, -1)
        self.sampleList = ['friends', 'advetising', 'Websearch', 'yellowpages']
        self.radioList = ['blue', 'red', 'yellow', 'orange', 'green', 'purple',
                      'navy blue', 'black', 'gray']
        gs = wxFlexGridSizer(5,2,5,5)
        gs.Add(wxStaticText(self, -1, "Your name :"),0,wxEXPAND)
        self.editname=wxTextCtrl(self, 20, "Enter here your name")
        gs.Add(self.editname,0,wxEXPAND)
        EVT_TEXT(self, 20, self.EvtText)
        EVT_CHAR(self.editname, self.EvtChar)
        gs.Add(wxStaticText(self,-1,"How did you hear from us ?"),0,wxEXPAND)
        gs.Add(wxComboBox(self, 30, "", wxPoint(-1,-1),wxSize(-1,-1), self.sampleList, wxCB_DROPDOWN),0,wxEXPAND)
        EVT_COMBOBOX(self, 30, self.EvtComboBox)
        EVT_TEXT(self, 30, self.EvtText)
        gs.Add(60, 20, 0, wxEXPAND)
        gs.Add(wxCheckBox(self, 40, "Do you want Insured Shipment ?"),0,wxEXPAND)
        EVT_CHECKBOX(self, 40,   self.EvtCheckBox)
        gs.Add(60, 20, 0, wxEXPAND)
        gs.Add(wxRadioBox(self, 50, "What color would you like ?", wxPoint(-1,-1),wxDefaultSize,
                        self.radioList, 3, wxRA_SPECIFY_COLS),0,wxEXPAND)
        EVT_RADIOBOX(self, 50, self.EvtRadioBox)
        gs.Add(60, 20, 0, wxEXPAND)
        gs.Add(wxButton(self, 10, "Save"),0,wxALIGN_CENTER)
        EVT_BUTTON(self, 10, self.OnClick)
        # gs.AddGrowableRow(0)
        boxh = wxBoxSizer(wxHORIZONTAL)
        boxh.Add(gs,0,wxEXPAND)

        self.logger=wxTextCtrl(self,5, "",wxPoint(-1,-1),wxSize(-1,-1),wxTE_MULTILINE | wxTE_READONLY)
        boxh.Add( self.logger
                  ,1,wxEXPAND)

        self.sizer = boxh
        self.sizer.Fit(self)
        self.SetAutoLayout(true)
        self.SetSizer(self.sizer)
    def EvtRadioBox(self, event):
        self.logger.AppendText('EvtRadioBox: %d\n' % event.GetInt())
    def EvtComboBox(self, event):
        self.logger.AppendText('EvtComboBox: %s\n' % event.GetString())
    def OnClick(self,event):
        self.logger.AppendText(" Click on object with Id %d\n" %event.GetId())
    def EvtText(self, event):
        self.logger.AppendText('EvtText: %s\n' % event.GetString())
    def EvtChar(self, event):
        self.logger.AppendText('EvtChar: %d\n' % event.GetKeyCode())
        event.Skip()
    def EvtCheckBox(self, event):
        self.logger.AppendText('EvtCheckBox: %d\n' % event.Checked())


app = wxPySimpleApp()
frame = wxFrame(None,-1," Demo with Notebook")
nb = wxNotebook(frame,-1)
form1=Form1(nb, -1)
form2=Form2(nb,-1)
nb.AddPage(form1, "Absolute Positionning")
nb.AddPage(form2, "Sizers")
frame.Show(True)
app.MainLoop()</t>
<t tx="T18">@language c

@ For reference only: I have deleted the C++ cruft such as importing .h files.

To do:
- convert wxWindows code to wxPython code.
- move the wxPython code to the wx plugin that doesn't exist yet.</t>
<t tx="T19">@others</t>
<t tx="T20">void alert ( const char * message )
{
	wxMessageDialog * d = new wxMessageDialog( (wxWindow*) NULL,
		message,
		"Alert",
		wxOK |wxCENTRE,
		wxDefaultPosition);

	d -&gt; ShowModal();
	delete d;
}
</t>
<t tx="T21">void assertFailedDialog ( const char * message )
{
	wxMessageDialog * d = new wxMessageDialog( (wxWindow*) NULL,
		message,
		"Leo assert failed",
		wxOK |wxCENTRE,
		wxDefaultPosition);

	d -&gt; ShowModal();
	delete d;
}
</t>
<t tx="T22">&lt;&lt; FindPanel declarations &gt;&gt;

@others
</t>
<t tx="T23">// &lt;&lt; FindPanel public globals &gt;&gt;
bool reset_search_flag ;
bool batch_flag ;
bool wrap_flag ;
bool whole_word_flag ;
bool ignore_case_flag ;
bool pattern_match_flag ;
bool search_headline_flag ;
bool search_body_flag ;
bool suboutline_only_flag ;
bool mark_changes_flag ;
bool mark_finds_flag ;
bool reverse_flag ;
wxString find_text ("")  ;
wxString change_text ("") ;
</t>
<t tx="T24">BEGIN_EVENT_TABLE(FindFrame, wxFrame)

	#ifdef __WXMSW__ // Activate events exist only on windows.
		EVT_ACTIVATE( FindFrame::OnActivateFindFrame )
	#else
		EVT_SET_FOCUS( FindFrame::OnSetFocus )
	#endif

	EVT_CLOSE( FindFrame::OnCloseFindFrame)

	EVT_BUTTON( cChangeButton,			FindFrame::OnChangeButton )
	EVT_BUTTON( cChangeAllButton,		FindFrame::OnChangeAllButton )
	EVT_BUTTON( cChangeThenFindButton,	FindFrame::OnChangeThenFindButton )
	EVT_BUTTON( cFindButton,			FindFrame::OnFindButton )
	EVT_BUTTON( cFindAllButton,			FindFrame::OnFindAllButton )

	EVT_CHECKBOX ( cBatchCheckBox,		FindFrame::OnBatchCheckBox )
	EVT_CHECKBOX ( cIgnoreCaseCheckBox, FindFrame::OnIgnoreCaseCheckBox )
	EVT_CHECKBOX ( cMarkChangesCheckBox,FindFrame::OnMarkChangesCheckBox )
	EVT_CHECKBOX ( cMarkFindsCheckBox, 	FindFrame::OnMarkFindsCheckBox )
	EVT_CHECKBOX ( cPatternMatchCheckBox, FindFrame::OnPatternMatchCheckBox )
	EVT_CHECKBOX ( cReverseCheckBox, 	FindFrame::OnReverseCheckBox )
	EVT_CHECKBOX ( cSearchHeadlineCheckBox,	FindFrame::OnSearchHeadlineCheckBox )
	EVT_CHECKBOX ( cSearchBodyTextCheckBox, FindFrame::OnSearchBodyTextCheckBox )
	EVT_CHECKBOX ( cSuboutlineOnlyCheckBox, FindFrame::OnSuboutlineOnlyCheckBox )
	EVT_CHECKBOX ( cWrapAroundCheckBox,	FindFrame::OnWrapAroundCheckBox )
	EVT_CHECKBOX ( cWholeWordCheckBox,	FindFrame::OnWholeWordCheckBox )

	EVT_TEXT ( cFindTextCtrl,	FindFrame::OnFindText )
	EVT_TEXT ( cChangeTextCtrl, FindFrame::OnChangeText )

END_EVENT_TABLE()</t>
<t tx="T25">FindFrame::FindFrame()

	: wxFrame((wxFrame *)NULL, -1, "Leo Find/Change",
		wxPoint(50, 50), wxDefaultSize,
		wxMINIMIZE_BOX | wxTHICK_FRAME | wxSYSTEM_MENU | wxCAPTION)
{
	mFindPanel = new FindPanel(this);

	// Resize to fit the panel.
	wxBoxSizer * sizer = new wxBoxSizer(wxVERTICAL);
	sizer -&gt; Add ( mFindPanel );
	SetAutoLayout( TRUE );  // tell dialog to use sizer
	SetSizer( sizer );  // actually set the sizer
	sizer -&gt; Fit( this ); // set size to minimum size as calculated by the sizer
	sizer -&gt; SetSizeHints( this ); // set size hints to honour mininum size

	// Set the window icon.
	#ifdef __WXMSW__
	  this -&gt;SetIcon(wxIcon("LeoIcon"));
	#endif

	// Set the focus.
	if (mFindPanel &amp;&amp; mFindPanel -&gt; mFindText )
		mFindPanel -&gt; mFindText -&gt; SetFocus();
}
</t>
<t tx="T26">@ &lt;&lt; FindPanel methods &gt;&gt; (2 of 23)
@c

#ifdef __WXMSW__ // This event exists only on Windows.

void FindFrame::OnActivateFindFrame(wxActivateEvent&amp; event)
{
	if ( event . GetActive() ) {
		this -&gt; set_check_boxes();
		assert(mFindPanel &amp;&amp; mFindPanel -&gt; mFindText);
		wxTextCtrl *c = mFindPanel -&gt; mFindText ;
		wxString s = c -&gt; GetValue() ;
			c -&gt; SetFocus();
		c -&gt; SetSelection ( 0, s.Length() ) ;
	}
}
</t>
<t tx="T27">
#else

void FindFrame::OnSetFocus (wxFocusEvent&amp; WXUNUSED(event))
{
	this -&gt; set_check_boxes();
	assert(mFindPanel &amp;&amp; mFindPanel -&gt; mFindText);
	wxTextCtrl *c = mFindPanel -&gt; mFindText ;
	wxString s = c -&gt; GetValue() ;
		c -&gt; SetFocus();
	c -&gt; SetSelection ( 0, s.Length() ) ;
}
</t>
<t tx="T28">
#endif
// &lt;&lt; FindPanel methods &gt;&gt; (3 of 23)
/*
	This is an event handler function called when the user has tried to close a frame or dialog box. It is called via the 
	wxWindow::Close function, so that the application can also invoke the handler programmatically.
	
	You should check whether the application is forcing the deletion of the window using CanVeto. If CanVeto returns FALSE, it is 
	not possible to skip window deletion; destroy the window using wxWindow::Destroy. If not, it is up to you whether you respond 
	by destroying the window.
	
	If you don't destroy the window, you should call wxCloseEvent::Veto to let the calling code know that you did not destroy the 
	window. This allows the wxWindow::Close function to return TRUE or FALSE depending on whether the close instruction was 
	honoured or not.
*/
void FindFrame::OnCloseFindFrame(wxCloseEvent&amp; event)
{
	if ( event.CanVeto() ) {
		event.Veto();  // Did not destroy the window.
		this -&gt; Show(FALSE);  // Just hide the window.
	}
	else {
		this -&gt; Destroy();
		gFindFrame = NULL ;
	}
}
</t>
<t tx="T29">@ &lt;&lt; FindPanel methods &gt;&gt; (4 of 23)
@c

void FindFrame::OnChangeButton (wxCommandEvent&amp; WXUNUSED(event))
{
	if ( gActiveFrame )
		gActiveFrame -&gt; mCommands -&gt; doChangeButton() ;
}
</t>
<t tx="T30">@ &lt;&lt; FindPanel methods &gt;&gt; (5 of 23)
@c

void FindFrame::OnChangeAllButton (wxCommandEvent&amp; WXUNUSED(event))
{
	if ( gActiveFrame )
		gActiveFrame -&gt; mCommands -&gt; doChangeAllButton() ;
}
</t>
<t tx="T31">@ &lt;&lt; FindPanel methods &gt;&gt; (6 of 23)
@c

void FindFrame::OnChangeThenFindButton (wxCommandEvent&amp; WXUNUSED(event))
{
	if ( gActiveFrame )
		gActiveFrame -&gt; mCommands -&gt; doChangeThenFindButton() ;
}
</t>
<t tx="T32">@ &lt;&lt; FindPanel methods &gt;&gt; (7 of 23)
@c

void FindFrame::OnFindButton (wxCommandEvent&amp; WXUNUSED(event))
{
	// This is the default button, so make sure there is find text.
	if ( gActiveFrame &amp;&amp; find_text.Length() &gt; 0 )
		gActiveFrame -&gt; mCommands -&gt; doFindButton() ;
}
</t>
<t tx="T33">@ &lt;&lt; FindPanel methods &gt;&gt; (8 of 23)
@c

void FindFrame::OnFindAllButton (wxCommandEvent&amp; WXUNUSED(event))
{
	if ( gActiveFrame )
		gActiveFrame -&gt; mCommands -&gt; doFindAllButton() ;
}
</t>
<t tx="T34">@ &lt;&lt; FindPanel methods &gt;&gt; (9 of 23)
@c

void FindFrame::OnBatchCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	batch_flag = box -&gt; GetValue();
}
</t>
<t tx="T35">@ &lt;&lt; FindPanel methods &gt;&gt; (10 of 23)
@c

void FindFrame::OnIgnoreCaseCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	ignore_case_flag = box -&gt; GetValue();
	if ( gActiveFrame )
		gActiveFrame -&gt; mCommands -&gt; setup (TRUE) ; // reset the search.
}
</t>
<t tx="T36">@ &lt;&lt; FindPanel methods &gt;&gt; (11 of 23)
@c

void FindFrame::OnMarkChangesCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	mark_changes_flag = box -&gt; GetValue();
}
</t>
<t tx="T37">@ &lt;&lt; FindPanel methods &gt;&gt; (12 of 23)
@c

void FindFrame::OnMarkFindsCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	mark_finds_flag = box -&gt; GetValue();
}
</t>
<t tx="T38">@ &lt;&lt; FindPanel methods &gt;&gt; (13 of 23)
@c

void FindFrame::OnPatternMatchCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	pattern_match_flag = box -&gt; GetValue();
	if ( gActiveFrame )
		gActiveFrame -&gt; mCommands -&gt; setup (TRUE) ; // reset the search.
}
</t>
<t tx="T39">@ &lt;&lt; FindPanel methods &gt;&gt; (14 of 23)
@c

void FindFrame::OnReverseCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	reverse_flag = box -&gt; GetValue();
}
</t>
<t tx="T40">@ &lt;&lt; FindPanel methods &gt;&gt; (15 of 23)
@c

void FindFrame::OnSearchBodyTextCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	search_body_flag = box -&gt; GetValue();
	if ( gActiveFrame )
		gActiveFrame -&gt; mCommands -&gt; setup (TRUE) ; // reset the search.
}
</t>
<t tx="T41">@ &lt;&lt; FindPanel methods &gt;&gt; (16 of 23)
@c

void FindFrame::OnSearchHeadlineCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	search_headline_flag = box -&gt; GetValue();
}
</t>
<t tx="T42">@ &lt;&lt; FindPanel methods &gt;&gt; (17 of 23)
@c

void FindFrame::OnSuboutlineOnlyCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	suboutline_only_flag = box -&gt; GetValue();
}
</t>
<t tx="T43">@ &lt;&lt; FindPanel methods &gt;&gt; (18 of 23)
@c

void FindFrame::OnWrapAroundCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	wrap_flag = box -&gt; GetValue();
}
</t>
<t tx="T44">@ &lt;&lt; FindPanel methods &gt;&gt; (19 of 23)
@c

void FindFrame::OnWholeWordCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	whole_word_flag = box -&gt; GetValue();
	if ( gActiveFrame )
		gActiveFrame -&gt; mCommands -&gt; setup (TRUE) ; // reset the search.
}
</t>
<t tx="T45">@ &lt;&lt; FindPanel methods &gt;&gt; (20 of 23)
@c

void FindFrame::OnChangeText (wxCommandEvent&amp; event)
{
	wxTextCtrl * text = (wxTextCtrl *) event.GetEventObject() ;
	change_text = text -&gt; GetValue();
	if ( gActiveFrame )
		gActiveFrame -&gt; mCommands -&gt; setup (TRUE) ; // reset the search.
}
</t>
<t tx="T46">@ &lt;&lt; FindPanel methods &gt;&gt; (21 of 23)
@c

void FindFrame::OnFindText (wxCommandEvent&amp; event)
{
	wxTextCtrl * text = (wxTextCtrl *) event.GetEventObject() ;
	find_text = text -&gt; GetValue();
	if ( gActiveFrame )
		gActiveFrame -&gt; mCommands -&gt; setup (TRUE) ; // reset the search.
}
</t>
<t tx="T47">@ &lt;&lt; FindPanel methods &gt;&gt; (22 of 23)
@c

void FindFrame::set_check_boxes ( void )
{
	assert(mFindPanel);
	mFindPanel -&gt; mBatchCheckBox -&gt; SetValue(batch_flag);
	mFindPanel -&gt; mWrapAroundCheckBox -&gt; SetValue(wrap_flag);
	mFindPanel -&gt; mWholeWordCheckBox -&gt; SetValue(whole_word_flag);
	mFindPanel -&gt; mIgnoreCaseCheckBox -&gt; SetValue(ignore_case_flag);
	mFindPanel -&gt; mPatternMatchCheckBox -&gt; SetValue(pattern_match_flag);
	mFindPanel -&gt; mSearchHeadlineCheckBox -&gt; SetValue(search_headline_flag);
	mFindPanel -&gt; mSearchBodyTextCheckBox -&gt; SetValue(search_body_flag);
	mFindPanel -&gt; mSuboutlineOnlyCheckBox -&gt; SetValue(suboutline_only_flag);
	mFindPanel -&gt; mMarkChangesCheckBox -&gt; SetValue(mark_changes_flag);
	mFindPanel -&gt; mMarkFindsCheckBox -&gt; SetValue(mark_finds_flag);
	mFindPanel -&gt; mReverseCheckBox -&gt; SetValue(reverse_flag);
	mFindPanel -&gt; mFindText -&gt; SetValue(find_text);
	mFindPanel -&gt; mChangeText -&gt; SetValue(change_text);
}
</t>
<t tx="T48">@ &lt;&lt; FindPanel methods &gt;&gt; (23 of 23)
@c

FindPanel::FindPanel(wxFrame *frame)
	   : wxPanel(frame, -1)
{
	// &lt;&lt; Create the find controls &gt;&gt;
	wxBoxSizer * topSizer = new wxBoxSizer(wxVERTICAL);

	topSizer -&gt; Add ( 0, 10 ) ;
	// &lt;&lt; Create the find text box &gt;&gt;
	wxBoxSizer * findSizer = new wxBoxSizer(wxHORIZONTAL);

	findSizer -&gt; Add ( 5, 5 ) ; // Extra space.

	// Label.
	findSizer -&gt; Add (
		new wxStaticText(this, -1, "Find:",
			wxPoint(-1,10), wxSize(50,25), 0, ""),
		0, wxBORDER | wxTOP, 15);  // Vertical offset.

	findSizer -&gt; Add ( 10, 0 ) ; // Width.

	// Text.
	mFindText = new wxTextCtrl(this,
		cFindTextCtrl, "",
		wxDefaultPosition, wxSize(300,60),
		wxTE_PROCESS_TAB | wxTE_MULTILINE,
		wxDefaultValidator, "") ;
	findSizer -&gt; Add ( mFindText );
	findSizer -&gt; Add ( 5, 0 ) ; // Width.

	topSizer -&gt; Add ( findSizer );
	topSizer -&gt; Add ( 0, 10 );
	// -- end -- &lt;&lt; Create the find text box &gt;&gt;
	// &lt;&lt; Create the change text box &gt;&gt;
	wxBoxSizer * changeSizer = new wxBoxSizer(wxHORIZONTAL);

	changeSizer -&gt; Add ( 5, 5 ) ; // Extra space.

	// Label.
	changeSizer -&gt; Add (
		new wxStaticText(this, -1, "Change:",
			wxPoint(-1,10), wxSize(50,25), 0, ""),
		0, wxBORDER | wxTOP, 15);  // Vertical offset.
	changeSizer -&gt; Add ( 10, 0 ) ; // Width.

	// Text.
	mChangeText = new wxTextCtrl(this,
		cChangeTextCtrl, "",
		wxDefaultPosition, wxSize(300,60),
		wxTE_PROCESS_TAB | wxTE_MULTILINE,
		wxDefaultValidator, "") ;
	changeSizer -&gt; Add ( mChangeText ) ;
	changeSizer -&gt; Add ( 5, 0 ) ; // Width.

	topSizer -&gt; Add ( changeSizer );
	topSizer -&gt; Add ( 0, 10 );
	// -- end -- &lt;&lt; Create the change text box &gt;&gt;
	// &lt;&lt; Create all the find check boxes &gt;&gt;
	wxBoxSizer * col1Sizer = new wxBoxSizer(wxVERTICAL);
	// &lt;&lt; Create the first column of check boxes &gt;&gt;
	mBatchCheckBox = new wxCheckBox(this,
		cBatchCheckBox,
		"Batch",
		wxDefaultPosition, wxSize(150,25), 0,
		wxDefaultValidator, "") ;
	col1Sizer -&gt; Add ( mBatchCheckBox,
		0, wxBORDER | wxLEFT, 50);

	mWrapAroundCheckBox = new wxCheckBox(this,
		cWrapAroundCheckBox,
		"Wrap Around",
		wxDefaultPosition, wxSize(150,25), 0,
		wxDefaultValidator, "") ;
	col1Sizer -&gt; Add ( mWrapAroundCheckBox,
		0, wxBORDER | wxLEFT, 50);

	mWholeWordCheckBox = new wxCheckBox(this,
		cWholeWordCheckBox,
		"Whole Word",
		wxDefaultPosition, wxSize(150,25), 0,
		wxDefaultValidator, "") ;
	col1Sizer -&gt; Add ( mWholeWordCheckBox,
		0, wxBORDER | wxLEFT, 50);

	mIgnoreCaseCheckBox = new wxCheckBox(this,
		cIgnoreCaseCheckBox,
		"Ignore Case",
		wxDefaultPosition, wxSize(150,25), 0,
		wxDefaultValidator, "") ;
	col1Sizer -&gt; Add ( mIgnoreCaseCheckBox,
		0, wxBORDER | wxLEFT, 50);

	mPatternMatchCheckBox = new wxCheckBox(this,
		cPatternMatchCheckBox,
		"Pattern Match",
		wxDefaultPosition, wxSize(150,25), 0,
		wxDefaultValidator, "") ;
	col1Sizer -&gt; Add ( mPatternMatchCheckBox,
		0, wxBORDER | wxLEFT, 50);
	// -- end -- &lt;&lt; Create the first column of check boxes &gt;&gt;
	wxBoxSizer * col2Sizer = new wxBoxSizer(wxVERTICAL);
	// &lt;&lt; Create the second column of check boxes &gt;&gt;
	mSearchHeadlineCheckBox = new wxCheckBox(this,
		cSearchHeadlineCheckBox,
		"Search Headline Text",
		wxDefaultPosition, wxSize(150,25),
		0, wxDefaultValidator, "") ;
	col2Sizer -&gt; Add ( mSearchHeadlineCheckBox ) ;

	mSearchBodyTextCheckBox = new wxCheckBox(this,
		cSearchBodyTextCheckBox,
		"Search Body Text",
		wxDefaultPosition, wxSize(150,25), 0,
		wxDefaultValidator, "") ;
	col2Sizer -&gt; Add ( mSearchBodyTextCheckBox );

	mSuboutlineOnlyCheckBox = new wxCheckBox(this,
		cSuboutlineOnlyCheckBox,
		"Suboutline Only",
		wxDefaultPosition, wxSize(150,25), 0,
		wxDefaultValidator, "") ;
	col2Sizer -&gt; Add ( mSuboutlineOnlyCheckBox );

	mMarkChangesCheckBox = new wxCheckBox(this,
		cMarkChangesCheckBox,
		"Mark Changes",
		wxDefaultPosition, wxSize(150,25), 0,
		wxDefaultValidator, "") ;
	col2Sizer -&gt; Add ( mMarkChangesCheckBox );

	mMarkFindsCheckBox = new wxCheckBox(this,
		cMarkFindsCheckBox,
		"Mark Finds",
		wxDefaultPosition, wxSize(150,25), 0,
		wxDefaultValidator, "") ;
	col2Sizer -&gt; Add ( mMarkFindsCheckBox );
	// -- end -- &lt;&lt; Create the second column of check boxes &gt;&gt;

	// Pack the two columns
	wxBoxSizer * checkBoxSizer = new wxBoxSizer(wxHORIZONTAL);

	checkBoxSizer -&gt; Add (col1Sizer);
	checkBoxSizer -&gt; Add (col2Sizer);
	topSizer -&gt; Add(checkBoxSizer);
	topSizer -&gt; Add ( 0, 10 );
	// -- end -- &lt;&lt; Create all the find check boxes &gt;&gt;
	// &lt;&lt; Create all the find buttons &gt;&gt;
	/*
		The row sizers are a bit dim:  they should distribute the buttons automatically.
	*/
	wxBoxSizer * row1Sizer = new wxBoxSizer(wxHORIZONTAL);
	// &lt;&lt; Create the first row of buttons &gt;&gt;
	row1Sizer -&gt; Add (20,0);

	mFindButton = new wxButton(this,
		cFindButton, "Find",
		wxDefaultPosition, wxSize(80,25), 0,
		wxDefaultValidator, "") ;
	row1Sizer -&gt; Add ( mFindButton );
	row1Sizer -&gt; Add (24 + 22 ,0);

	mReverseCheckBox = new wxCheckBox(this,
		cReverseCheckBox, "Reverse",
		wxDefaultPosition, wxSize(100,25), 0,
		wxDefaultValidator, "") ;
	row1Sizer -&gt; Add ( mReverseCheckBox );
	row1Sizer -&gt; Add (24,0);

	mFindAllButton = new wxButton(this,
		cFindAllButton, "Find All",
		wxDefaultPosition, wxSize(80,25), 0,
		wxDefaultValidator, "") ;
	row1Sizer -&gt; Add ( mFindAllButton );
	// -- end -- &lt;&lt; Create the first row of buttons &gt;&gt;
	wxBoxSizer * row2Sizer = new wxBoxSizer(wxHORIZONTAL);
	// &lt;&lt; Create the second row of buttons &gt;&gt;
	row2Sizer -&gt; Add (20,0);

	mChangeButton = new wxButton(this,
		cChangeButton, "Change",
		wxDefaultPosition, wxSize(80,25), 0,
		wxDefaultValidator, "") ;
	row2Sizer -&gt; Add ( mChangeButton );
	row2Sizer -&gt; Add (24,0);

	mChangeThenFindButton = new wxButton(this,
		cChangeThenFindButton, "Change, Then Find",
		wxDefaultPosition, wxSize(122,25), 0,
		wxDefaultValidator, "") ;
	row2Sizer -&gt; Add ( mChangeThenFindButton );
	row2Sizer -&gt; Add (24,0);

	mChangeAllButton = new wxButton(this,
		cChangeAllButton, "Change All",
		wxDefaultPosition, wxSize(80,25), 0,
		wxDefaultValidator, "") ;
	row2Sizer -&gt; Add ( mChangeAllButton );
	// -- end -- &lt;&lt; Create the second row of buttons &gt;&gt;

	// Pack the two rows
	wxBoxSizer * buttonSizer = new wxBoxSizer(wxVERTICAL);

	buttonSizer -&gt; Add (row1Sizer);
	buttonSizer -&gt; Add (0, 10);
	buttonSizer -&gt; Add (row2Sizer);
	topSizer -&gt; Add(buttonSizer);
	topSizer -&gt; Add ( 0, 10 );
	// -- end -- &lt;&lt; Create all the find buttons &gt;&gt;

	SetAutoLayout( TRUE );  // tell dialog to use sizer
	SetSizer( topSizer );  // actually set the sizer
	topSizer -&gt; Fit( this ); // set size to minimum size as calculated by the sizer
	topSizer -&gt; SetSizeHints( this ); // set size hints to honour mininum size
	// -- end -- &lt;&lt; Create the find controls &gt;&gt;
}
</t>
<t tx="T49">@others
</t>
<t tx="T50">BEGIN_EVENT_TABLE( LeoApp, wxApp)

// EVT_EXIT ( LeoApp::OnExit )

END_EVENT_TABLE()</t>
<t tx="T51">bool LeoApp::OnInit()
{
	long argc = wxTheApp -&gt; argc ;
	long filesLoaded = 0 ;

	this -&gt; SetAppName("LeoWx");
	&lt;&lt; Set gAppDirectory &gt;&gt;
	&lt;&lt; Switch to the other running copy of Leo if one is already open &gt;&gt;
	&lt;&lt; Open a file when double-clicking an icon &gt;&gt;
	if ( filesLoaded == 0 ) {
		&lt;&lt; Create a frame and link it into the global frame list &gt;&gt;
	}
	# Create the find panel, but do not show it &gt;&gt;
	gFindFrame = new FindFrame ();
	&lt;&lt; Initialize Sherlock &gt;&gt;
	&lt;&lt; Dump the command line &gt;&gt;
	TRACEP("assert_test", assert(0));
	return TRUE;
}</t>
<t tx="T52">#if 0 //// Not yet: compiles, but lpCmdLine is a dummy !!!!

	LPSTR lpCmdLine = NULL ;  //// Was param to main routine...

	// Try to open the mutex.
	HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, 0, "LeoWxApp");

	// If hMutex is 0 then the mutex doesn't exist. Create it.
	if (!hMutex)
		hMutex = CreateMutex(0, 0, "LeoWxApp");
	else {
		// This is a second instance. Bring the original
		// instance to the top.
		HWND hWnd = FindWindow(0, "LeoWx");
		if (hWnd == 0 ) return 0 ;  ////

		SetForegroundWindow(hWnd);

		// Send the command line in a WM_COPYDATA message.
		if (strlen(lpCmdLine) != 0) {
			COPYDATASTRUCT cds;
			cds.cbData = strlen(lpCmdLine) + 1;
			cds.lpData = lpCmdLine;
			SendMessage(hWnd, WM_COPYDATA, 0, (LPARAM)&amp;cds);
		}
		return 0; ////
	}
#endif //// not yet</t>
<t tx="T53">wxString cwd = ::wxGetCwd();
gAppDirectory = wxFindAppPath( cwd ) ;

// Make sure the directory does not end with a directory separator.
size_t len = gAppDirectory.Length() ;
if ( len &gt; 0 &amp;&amp; gAppDirectory.Last() == wxFILE_SEP_PATH)
	gAppDirectory = gAppDirectory.Truncate(len - 1);</t>
<t tx="T54">gIniting = TRUE ; // Disable error message if file not found.

for ( int i = 1 ; i &lt; argc ; ++ i ) {
	wxString arg = wxTheApp -&gt; argv[i] ;
	LeoFrame *frame = LeoFrame::OpenWithFileName( arg );
	if (frame) ++filesLoaded;
}

gIniting = FALSE ;</t>
<t tx="T55">LeoFrame *frame = new LeoFrame();

++gNumberOfUntitledWindows ;
frame -&gt; SetTitle("untitled");
frame -&gt; Show(TRUE);
SetTopWindow(frame);
gCommands = frame -&gt; mCommands ;
gActiveFrame = frame ; // Allow writes to log pane.

// Set the current node in the _new_ form!.
vnode *v = frame -&gt; mCommands -&gt; rootVnode();
assert(v);
frame -&gt; mCommands -&gt; setCurrentVnode ( v ) ;
frame -&gt; mCommands -&gt; editVnode( v ) ;
frame -&gt; mCommands -&gt; mFirstWindowAndNeverSaved = TRUE ;</t>
<t tx="T56">#ifdef SHERLOCK
	gIniting = TRUE ; // Disable auto open of window during signon.
		SL_INIT () ;
		wxString path("./LeoArgs");
		if ( gAppDirectory.Length() &gt; 0 )
			path = gAppDirectory + "/LeoArgs" ;
		init_args ( &amp;sArgc, &amp;sArgv, (char *) path.c_str() ) ;

		// argv will still be NULL if LeoArgs can not be found.
		if ( sArgv ) {
			SL_PARSE ( sArgc, (char **) sArgv , "++" , "--" ) ;
		}
	gIniting = FALSE ;
#endif</t>
<t tx="T57">TRACEP("dump_argv", 
	ecnl(); es("argc: "); elong(argc); enl();
	for ( int i = 0 ; i &lt;= argc ; ++ i ) {
		wxString arg = wxTheApp -&gt; argv[i] ;
		es("argv["); elong(i); es("]: "); es(arg.c_str()); enl();
	}
);</t>
<t tx="T58">@ &lt;&lt; LeoApp methods &gt;&gt; (2 of 2)
@c

int LeoApp::OnExit()
{
	return TRUE ;
}
</t>
<t tx="T59">@ Initialize the argv vector from a file. This routine is declared in sl.h. init_arg_parse is defined in sl.c.
@c

void init_args ( int *argc, char ***argvp, char *file_name )
{
	// Open the file.  The ctor may throw an exception if it fails, so we test first.
	if ( ! wxFileExists ( file_name ) ) return ;
	wxFile file ( file_name, wxFile::read ) ;
	if ( ! file . IsOpened() ) return ;

	// Allocate the buffer.
	long file_size = file . Length() ;
	char * file_buf = ( char * ) calloc ( 1, file_size + 2 ) ;
	if (file_buf == NULL) return ;

	// Read the open file into file_buf.
	long count = file . Read ( file_buf, file_size ) ;
	if ( count != file_size ) return ;

	// End the buffer with a zero byte.
	file_buf [ file_size ] = '\0';

	// Create and return the arguments in a made-up argv vector.
	init_massage ( file_buf ) ;
	*argc = init_arg_parse ( argvp, file_buf ) ;
}
</t>
<t tx="T60">@ &lt;&lt; LeoApp functions &gt;&gt; (2 of 2)
Returns the absolute path containing this app, or an empty string if the path can not be determined.  cwd should be the current working directory at startup, _not_ the present current working directory.
@c

wxString wxFindAppPath(wxString&amp; cwd)
{
	// 1. Try the environment variable.
	wxString s = wxGetenv("Leo");
	if (!s.IsEmpty()) return s ;

	// 2. Try the path in argv0.
	wxString argv0 = wxTheApp -&gt; argv[0] ;
	if ( argv0.IsEmpty() ) return wxEmptyString ;

	if (wxIsAbsolutePath(argv0))
		return wxPathOnly(argv0);
	else {
		// Resolve the relative path.
		if (cwd.Last() != wxFILE_SEP_PATH)
			cwd += wxFILE_SEP_PATH;
		cwd += argv0;
		if (wxFileExists(cwd)) return wxPathOnly(cwd);
	}

	// 3. Search the PATH  var for the path in argv0.
	wxPathList pathList;
	pathList.AddEnvList(wxT("PATH"));
	s = pathList.FindAbsoluteValidPath(argv0);
	if ( s.IsEmpty() )
			return wxEmptyString ;
	else
			return wxPathOnly(s) ;
}
</t>
<t tx="T61">@ -- end -- &lt;&lt; LeoApp functions &gt;&gt;
@c

#include "LIBes.h"
// &lt;&lt; log bridge functions &gt;&gt; (1 of 2)
void log_open ( const char * filename )
{
	// Carefull: the Log window may not exist during startup or shutdown.
	#if 0 // no longer needed.
	if ( gLogFrame )
		gLogFrame -&gt; open(filename);
	#endif
}
</t>
<t tx="T62">@ &lt;&lt; log bridge functions &gt;&gt; (2 of 2)
@c

void put_cstring_to_log_window ( const char * s )
{
	if ( gActiveFrame )
		gActiveFrame -&gt; putToLog(s);
	//// else this -&gt; bufferLogMessage(s) ;
}
</t>
<t tx="T63">@others</t>
<t tx="T64">BEGIN_EVENT_TABLE(LeoFrame, wxFrame)

@ The following commands are processed by default event handlers in wxTextCtrl:
wxID_CUT, wxID_COPY, wxID_PASTE, wxID_UNDO, wxID_REDO.
The associated UI update events are also processed automatically, when the control has the focus.
@c

// General window events...
#ifdef __WXMSW__ // Activate events exist only on Windows.
	EVT_ACTIVATE( LeoFrame::onActivate )
#else
	EVT_SET_FOCUS ( LeoFrame::OnSetFocus )
#endif

EVT_CLOSE( LeoFrame::onCloseLeoFrame)
EVT_SIZE( LeoFrame::onResize)

// Events in the text control...
EVT_TEXT( cBodyCtrl, LeoFrame::onBodyTextUpdated)
	// Fires whenever text changes.

// Events in the tree control...
EVT_TREE_KEY_DOWN(cTreeCtrl, LeoFrame::onTreeKeyDown)
	// Control keys do not fire this event.

EVT_TREE_SEL_CHANGED(cTreeCtrl, LeoFrame::onTreeChanged) 
EVT_TREE_SEL_CHANGING(cTreeCtrl, LeoFrame::onTreeChanging)

EVT_TREE_BEGIN_DRAG(cTreeCtrl, LeoFrame::onTreeBeginDrag)
EVT_TREE_END_DRAG(cTreeCtrl, LeoFrame::onTreeEndDrag)

EVT_TREE_BEGIN_LABEL_EDIT(cTreeCtrl, LeoFrame::onTreeBeginLabelEdit)
EVT_TREE_END_LABEL_EDIT(cTreeCtrl, LeoFrame::onTreeEndLabelEdit)
&lt;&lt; Declare menu events &gt;&gt;

END_EVENT_TABLE()</t>
<t tx="T65">// Menu enablers...
EVT_UPDATE_UI(cRevertMenuItem, LeoFrame::OnUpdateRevert )

// Command handlers...
EVT_MENU(cNewMenuItem,		LeoFrame::OnNew)
EVT_MENU(cOpenMenuItem,		LeoFrame::OnOpen)
EVT_MENU(cCloseMenuItem,	LeoFrame::OnClose)
EVT_MENU(cSaveMenuItem,		LeoFrame::OnSave)
EVT_MENU(cSaveAsMenuItem,	LeoFrame::OnSaveAs)
EVT_MENU(cSaveToMenuItem,	LeoFrame::OnSaveTo)
EVT_MENU(cRevertMenuItem,	LeoFrame::OnRevert)

EVT_MENU(cPageSetupMenuItem,LeoFrame::OnPageSetup)
EVT_MENU(cPrintMenuItem,  	LeoFrame::OnPrint)

// Read/Write submenu

	EVT_MENU(cReadOutlineOnlyMenuItem,		LeoFrame::OnReadOutlineOnly)
	EVT_MENU(cReadAtFileNodesMenuItem,		LeoFrame::OnReadAtFileNodes)
	EVT_MENU(cWriteOutlineOnlyMenuItem,		LeoFrame::OnWriteOutlineOnly)
	EVT_MENU(cWriteAtFileNodesMenuItem,		LeoFrame::OnWriteAtFileNodes)

// EVT_MENU(cTangleSubmenuItem,	LeoFrame::OnTangleSubmenu)

	EVT_MENU(cTangleAllMenuItem,		LeoFrame::OnTangleAll)
	EVT_MENU(cTangleMarkedMenuItem,		LeoFrame::OnTangleMarked)
	EVT_MENU(cTangleMenuItem,			LeoFrame::OnTangle)

// EVT_MENU(cUntangleSubmenuItem,  LeoFrame::OnUntangleSubmenu)

	EVT_MENU(cUntangleAllMenuItem,		LeoFrame::OnUntangleAll)
	EVT_MENU(cUntangleMarkedMenuItem,	LeoFrame::OnUntangleMarked)
	EVT_MENU(cUntangleMenuItem,			LeoFrame::OnUntangle)

// EVT_MENU(cImportExportSubmenuItem,  LeoFrame::OnImportExportSubmenu)

	EVT_MENU(cImportFilesMenuItem,		LeoFrame::OnImportFiles)
	EVT_MENU(cImportCWEBFilesMenuItem,	LeoFrame::OnImportCWEBFiles)
	EVT_MENU(cImportNowebFilesMenuItem,	LeoFrame::OnImportNowebFiles)
	EVT_MENU(cImportMORETextMenuItem,	LeoFrame::OnImportMoreText)
	EVT_MENU(cFlattenOutlineMenuItem,	LeoFrame::OnFlattenOutline)

EVT_MENU(cQuitMenuItem,  LeoFrame::OnQuit)

// Menu enablers...
EVT_UPDATE_UI(cUndoMenuItem,	LeoFrame::OnUpdateUndo )

#ifndef __WXGTK__ // For now, neither tree nor text controls support Redo.
EVT_UPDATE_UI(cRedoMenuItem,	LeoFrame::OnUpdateRedo )
#endif

EVT_UPDATE_UI(cCutMenuItem,		LeoFrame::OnUpdateCut )
EVT_UPDATE_UI(cCopyMenuItem,	LeoFrame::OnUpdateCopy )
EVT_UPDATE_UI(cPasteMenuItem,	LeoFrame::OnUpdatePaste )
EVT_UPDATE_UI(cDeleteMenuItem,	LeoFrame::OnUpdateDelete )
EVT_UPDATE_UI(cDeleteMenuItem,	LeoFrame::OnUpdateSelectAll )

EVT_UPDATE_UI(cExtractMenuItem,	LeoFrame::OnUpdateExtract )
EVT_UPDATE_UI(cExtractSectionMenuItem,	LeoFrame::OnUpdateExtractSection )
EVT_UPDATE_UI(cExtractNamesMenuItem,	LeoFrame::OnUpdateExtractNames )

EVT_UPDATE_UI(cFindNextMenuItem,		LeoFrame::OnUpdateFind) 
EVT_UPDATE_UI(cFindNextMenuItem2,		LeoFrame::OnUpdateFind)
EVT_UPDATE_UI(cFindPreviousMenuItem,	LeoFrame::OnUpdateFind)
EVT_UPDATE_UI(cReplaceMenuItem,			LeoFrame::OnUpdateReplace) 
EVT_UPDATE_UI(cReplaceThenFindMenuItem,	LeoFrame::OnUpdateReplace) 

// Command handlers...

// Top level
EVT_MENU(cUndoMenuItem,			LeoFrame::OnUndo)
EVT_MENU(cRedoMenuItem,			LeoFrame::OnRedo)
EVT_MENU(cCutMenuItem,			LeoFrame::OnCut)
EVT_MENU(cCopyMenuItem,			LeoFrame::OnCopy)
EVT_MENU(cPasteMenuItem,		LeoFrame::OnPaste)
EVT_MENU(cDeleteMenuItem,		LeoFrame::OnDelete)
EVT_MENU(cSelectAllMenuItem,	LeoFrame::OnSelectAll)
EVT_MENU(cEditHeadlineMenuItem,	LeoFrame::OnEditHeadline)
EVT_MENU(cFontPanelMenuItem,		LeoFrame::OnFontPanel)
EVT_MENU(cSyntaxColoringMenuItem,	LeoFrame::OnSyntaxColoring)
EVT_MENU(cPreferencesMenuItem,		LeoFrame::OnPreferences)

// Edit Body submenu
EVT_MENU(cExtractSectionMenuItem,	LeoFrame::OnExtractSection)
EVT_MENU(cExtractNamesMenuItem,		LeoFrame::OnExtractNames)
EVT_MENU(cExtractMenuItem,			LeoFrame::OnExtract)
EVT_MENU(cConvertBlanksMenuItem,	LeoFrame::OnConvertBlanks)

// Find submenu
EVT_MENU(cFindPanelMenuItem,		LeoFrame::OnFindPanel)
EVT_MENU(cFindNextMenuItem,			LeoFrame::OnFindNext)
EVT_MENU(cFindNextMenuItem2,		LeoFrame::OnFindNext)
EVT_MENU(cFindPreviousMenuItem,		LeoFrame::OnFindPrevious)
EVT_MENU(cReplaceMenuItem,			LeoFrame::OnReplace)
EVT_MENU(cReplaceThenFindMenuItem,	LeoFrame::OnReplaceThenFind)

// Menu enablers...
// Top level
EVT_UPDATE_UI(cCutNodeMenuItem,		LeoFrame::OnUpdateCutNode)
EVT_UPDATE_UI(cDeleteNodeMenuItem,	LeoFrame::OnUpdateDeleteNode)
EVT_UPDATE_UI(cPasteNodeMenuItem,	LeoFrame::OnUpdatePasteNode)
EVT_UPDATE_UI(cSortNodeMenuItem,	LeoFrame::OnUpdateSortNode)

// Expand/Contract submenu
EVT_UPDATE_UI(cExpandAllMenuItem,			LeoFrame::OnUpdateExpandAll)
EVT_UPDATE_UI(cExpandAllChildrenMenuItem,	LeoFrame::OnUpdateExpandAllChildren)
EVT_UPDATE_UI(cExpandChilrenMenuItem,		LeoFrame::OnUpdateExpandChildren)
EVT_UPDATE_UI(cContractAllMenuItem,			LeoFrame::OnUpdateContractAll)
EVT_UPDATE_UI(cContractAllChildrenMenuItem,	LeoFrame::OnUpdateContractAllChildren)
EVT_UPDATE_UI(cContractChilrenMenuItem,		LeoFrame::OnUpdateContractChildren)

// Move/Select submenu
EVT_UPDATE_UI(cMoveDownMenuItem,	LeoFrame::OnUpdateMoveDown)
EVT_UPDATE_UI(cMoveLeftMenuItem,	LeoFrame::OnUpdateMoveLeft)
EVT_UPDATE_UI(cMoveRightMenuItem,	LeoFrame::OnUpdateMoveRight)
EVT_UPDATE_UI(cMoveUpMenuItem,		LeoFrame::OnUpdateMoveUp)
EVT_UPDATE_UI(cPromoteMenuItem,		LeoFrame::OnUpdatePromote)
EVT_UPDATE_UI(cDemoteMenuItem,		LeoFrame::OnUpdateDemote)
EVT_UPDATE_UI(cGoPrevVisibleMenuItem,LeoFrame::OnUpdateGoPrevVisible)
EVT_UPDATE_UI(cGoNextVisibleMenuItem,LeoFrame::OnUpdateGoNextVisible)
EVT_UPDATE_UI(cGoBackMenuItem,		LeoFrame::OnUpdateGoBack)
EVT_UPDATE_UI(cGoNextMenuItem,		LeoFrame::OnUpdateGoNext)

// Mark/Go To submenu
EVT_UPDATE_UI(cMarkMenuItem,			LeoFrame::OnUpdateMark)
EVT_UPDATE_UI(cMarkSubheadsMenuItem,	LeoFrame::OnUpdateMarkSubheads)
EVT_UPDATE_UI(cMarkChangedItemsMenuItem,LeoFrame::OnUpdateMarkChangedItems)
EVT_UPDATE_UI(cMarkChangedRootsMenuItem,LeoFrame::OnUpdateMarkChangedRoots)
EVT_UPDATE_UI(cGoToNextMarkedMenuItem,	LeoFrame::OnUpdateGoToNextMarked)
EVT_UPDATE_UI(cGoToNextChangedMenuItem,	LeoFrame::OnUpdateGoToNextChanged)

// Command handlers...
EVT_MENU(cCutNodeMenuItem,		LeoFrame::OnCutNode)
EVT_MENU(cCopyNodeMenuItem,		LeoFrame::OnCopyNode)
EVT_MENU(cPasteNodeMenuItem,	LeoFrame::OnPasteNode)
EVT_MENU(cDeleteNodeMenuItem,	LeoFrame::OnDeleteNode)

EVT_MENU(cInsertNodeMenuItem,	LeoFrame::OnInsertNode)
EVT_MENU(cCloneNodeMenuItem,	LeoFrame::OnCloneNode)
EVT_MENU(cSortNodeMenuItem,		LeoFrame::OnSortNode)

// Expand/Contract submenu
EVT_MENU(cExpandAllMenuItem,			LeoFrame::OnExpandAll)
EVT_MENU(cExpandAllChildrenMenuItem,	LeoFrame::OnExpandAllChildren)
EVT_MENU(cExpandChilrenMenuItem,		LeoFrame::OnExpandChildren)
EVT_MENU(cContractAllMenuItem,			LeoFrame::OnContractAll)
EVT_MENU(cContractAllChildrenMenuItem,	LeoFrame::OnContractAllChildren)
EVT_MENU(cContractChilrenMenuItem,		LeoFrame::OnContractChildren)

EVT_MENU(cExpandNextLevelMenuItem,	LeoFrame::OnExpandNextLevel)
EVT_MENU(cExpandToLevel1MenuItem,	LeoFrame::OnExpandToLevel1)
EVT_MENU(cExpandToLevel2MenuItem,	LeoFrame::OnExpandToLevel2)
EVT_MENU(cExpandToLevel3MenuItem,	LeoFrame::OnExpandToLevel3)
EVT_MENU(cExpandToLevel4MenuItem,	LeoFrame::OnExpandToLevel4)
EVT_MENU(cExpandToLevel5MenuItem,	LeoFrame::OnExpandToLevel5)
EVT_MENU(cExpandToLevel6MenuItem,	LeoFrame::OnExpandToLevel6)
EVT_MENU(cExpandToLevel7MenuItem,	LeoFrame::OnExpandToLevel7)
EVT_MENU(cExpandToLevel8MenuItem,	LeoFrame::OnExpandToLevel8)
EVT_MENU(cExpandToLevel9MenuItem,	LeoFrame::OnExpandToLevel9)

// Move/Select submenu
EVT_MENU(cMoveDownMenuItem,		LeoFrame::OnMoveDown)
EVT_MENU(cMoveLeftMenuItem,		LeoFrame::OnMoveLeft)
EVT_MENU(cMoveRightMenuItem,	LeoFrame::OnMoveRight)
EVT_MENU(cMoveUpMenuItem,		LeoFrame::OnMoveUp)
EVT_MENU(cPromoteMenuItem,		LeoFrame::OnPromote)
EVT_MENU(cDemoteMenuItem,		LeoFrame::OnDemote)
EVT_MENU(cGoPrevVisibleMenuItem,	LeoFrame::OnGoPrevVisible)
EVT_MENU(cGoNextVisibleMenuItem,	LeoFrame::OnGoNextVisible)
EVT_MENU(cGoBackMenuItem,	LeoFrame::OnGoBack)
EVT_MENU(cGoNextMenuItem,	LeoFrame::OnGoNext)

// Mark/Go To submenu
EVT_MENU(cMarkMenuItem,				LeoFrame::OnMark)
EVT_MENU(cMarkSubheadsMenuItem,		LeoFrame::OnMarkSubheads)
EVT_MENU(cMarkChangedItemsMenuItem,	LeoFrame::OnMarkChangedItems)
EVT_MENU(cMarkChangedRootsMenuItem,	LeoFrame::OnMarkChangedRoots)

EVT_MENU(cMarkAllAtFileNodesDirtyMenuItem,	LeoFrame::OnMarkAllAtFileNodesDirty)
EVT_MENU(cMarkAtFileNodesDirtyMenuItem,	LeoFrame::OnMarkAtFileNodesDirty)

EVT_MENU(cUnmarkAllMenuItem,		LeoFrame::OnUnmarkAll)
EVT_MENU(cGoToNextMarkedMenuItem,	LeoFrame::OnGoToNextMarked)
EVT_MENU(cGoToNextChangedMenuItem,	LeoFrame::OnGoToNextChanged)

// Command handlers...
EVT_MENU(cEqualSizedPanesMenuItem,	LeoFrame::OnEqualSizedPanes)
EVT_MENU(cToggleActivePaneMenuItem,	LeoFrame::OnToggleActivePane)
EVT_MENU(cSplitPaneDirectionMenuItem, LeoFrame::OnChangeDirection)

EVT_MENU(cCascadeMenuItem, 		LeoFrame::OnCascade)
EVT_MENU(cMinimizeAllMenuItem,	LeoFrame::OnMinimizeAll)

#ifdef __WXMSW__
EVT_MENU(cOpenPythonWindowMenuItem,LeoFrame::OnOpenPythonWindow)
#endif

EVT_MENU(cRecentWindowsMenuItem,LeoFrame::OnRecentWindows)

EVT_MENU(cAboutLeoMenuItem, LeoFrame::OnAbout)</t>
<t tx="T66">LeoFrame::LeoFrame()
	: wxFrame((wxFrame *)NULL, -1, "LeoWX", wxDefaultPosition, wxSize(550, 600)),
	mFileName ( "" ),
	mDefaultDirectory ( "" ),
	mOpenDirectory ( "" )
{
	// Link the new frame into the list of frames.
	mIniting = TRUE ; // Lock out resize events.
	long width = 600 ; // initial size
	if ( gLeoFrameList ) gLeoFrameList -&gt; mPrevFrame = this ;
	this -&gt; mNextFrame = gLeoFrameList ;
	this -&gt; mPrevFrame = NULL ;
	gLeoFrameList = this ;
	&lt;&lt; Initialize the private vars &gt;&gt;
	&lt;&lt; Initialize the argument settings &gt;&gt;
	this -&gt; createMenus() ;
	&lt;&lt; Create the splitter windows &gt;&gt;
	&lt;&lt; Create the accelerator table &gt;&gt;
	&lt;&lt; Create the status bar &gt;&gt;
	&lt;&lt; Set the window Icon &gt;&gt;
	&lt;&lt; Set the caret blink rate &gt;&gt;

	mCommands = new Commands(this, mTreeCtrl, mBodyCtrl) ;
	&lt;&lt; Add root node to the tree view &gt;&gt;
	gActiveFrame = this ;
	mIniting = FALSE ; // allow resize events.
	es("Leo Log Window...\n\n");
}</t>
<t tx="T67">mTextChanging = 0 ;
mCopying = 0 ;
mDraggedItem =  0L ;
mReverting = FALSE ;</t>
<t tx="T68">mOutputDocFlag = TRUE ;
mTangleBatchFlag = FALSE ;
mUntangleBatchFlag = FALSE ;
mUseHeaderFlag = TRUE ;
mPageWidth = 132 ;
mTabWidth = 4;
mPresentLanguage = c_language ;
mTargetLanguage = c_language ;</t>
<t tx="T69">mSplitter1 = new wxSplitterWindow(this, cSplitterWindow,
	wxDefaultPosition,  wxDefaultSize,
	wxSP_BORDER | wxSP_3D, 
	"splitterWindow");

mSplitter2 = new wxSplitterWindow( mSplitter1, -1,
	wxDefaultPosition,  wxDefaultSize,
	wxSP_BORDER | wxSP_3D, "splitterWindow");

mSplitter1 -&gt; SetMinimumPaneSize(4);
mSplitter2 -&gt; SetMinimumPaneSize(4);

mTreeCtrl = new wxTreeCtrl (mSplitter2, cTreeCtrl,
	wxDefaultPosition,  wxDefaultSize,
	wxTR_HAS_BUTTONS | wxTR_EDIT_LABELS, wxDefaultValidator, "treeCtrl");

// &lt;&lt; Set the image list &gt;&gt;
/*
	Warning: the width and height must match the underlying .bmp files.
*/
// width: 20, height: 11, mask:TRUE, count:16
#if defined(__WXMSW__) || defined(__WXGTK__)
	wxImageList * im = new wxImageList(20, 11, TRUE, 16);
	wxBitmap box(20,11);

	// Add 16 bitmaps to the image list.
	for ( int i = 0 ; i &lt; 16 ; ++ i ) {

		#if  defined(__WXMSW__)
			wxString s("box");
			s &lt;&lt; i;
			box.LoadFile(s, wxBITMAP_TYPE_BMP_RESOURCE);
		#elif defined(__WXGTK__)
			wxString s("./Icons/box");  // Assume we are launched from ./ directory.
			if ( gAppDirectory.Length() &gt; 0 )
				s = gAppDirectory + "/Icons/box" ;
			if ( i &lt; 10 ) s &lt;&lt; "0" ;
			s &lt;&lt; i;
			s &lt;&lt; ".bmp" ;
			box.LoadFile(s, wxBITMAP_TYPE_BMP);
		#endif
		im -&gt; Add ( box );
	}
	mTreeCtrl -&gt; SetImageList(im);
#endif
// -- end -- &lt;&lt; Set the image list &gt;&gt;

mBodyCtrl = new wxTextCtrl( mSplitter1, cBodyCtrl, "",
	wxDefaultPosition,  wxDefaultSize, wxTE_MULTILINE );

mLogCtrl = new wxTextCtrl( mSplitter2, cLogCtrl, "",
	wxDefaultPosition,  wxDefaultSize, wxTE_MULTILINE );

// &lt;&lt; Set the body font &gt;&gt;
#ifdef __WXMSW__  // This is a fixed-width font and works well.

	// size, family, style, weight.
	wxFont font (9, wxMODERN, wxNORMAL, wxNORMAL) ; 

#else

	// size, family, style, weight.
	// wxFont font (9, wxMODERN, wxNORMAL, wxNORMAL) ; 

	// Try to use lucidatypewriter.
	wxFont font (12, wxFONTFAMILY_DEFAULT, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL, FALSE,
		"lucidatypewriter", wxFONTENCODING_ISO8859_1);

	#if 0 // none of these work
		wxFont font(14, 74, 90, 90, FALSE,
		"terminal",
		// "-bitstream-terminal-medium-r-normal-*-*-140-*-*-c-*-iso8859-1",
		// "-Bitstream-Terminal-Medium-R-Normal--18-140-100-100-C-*-ISO8859-1",
		wxFONTENCODING_ISO8859_1);
	#endif
#endif

TRACEP("font_info",
	es("face: "); es( font . GetFaceName() . c_str() ) ; ecs();
	es("family: "); es( font . GetFamilyString() . c_str() ) ; enl();
	es("size: "); eint( font . GetPointSize() ) ; ecs();
	es("style: "); es( font. GetStyleString() . c_str() ) ; ecs();
	es("weight: "); es( font . GetWeightString() . c_str() ) ; enl();
);

mBodyCtrl -&gt; SetFont ( font ) ;
// -- end -- &lt;&lt; Set the body font &gt;&gt;

// Attach the controls to the splitter.
mSplitter1 -&gt; SplitHorizontally(mSplitter2, mBodyCtrl, 0);
mSplitter2 -&gt; SplitVertically(mTreeCtrl, mLogCtrl, width/2);</t>
<t tx="T70">#ifdef __WXGTK__ // Windows version handles shortcuts properly

enum {
	// &lt;&lt; accelerator constants &gt;&gt;
	alt = wxACCEL_ALT,
	normal = wxACCEL_NORMAL,
	ctrl = wxACCEL_CTRL,
	shift = wxACCEL_SHIFT,
	shift_alt = (wxACCEL_ALT | wxACCEL_SHIFT),
	shift_ctrl = (wxACCEL_CTRL | wxACCEL_SHIFT),
	// -- end -- &lt;&lt; accelerator constants &gt;&gt;
	cFirstEntry = -1, // So first real index starts at 0.
	// &lt;&lt; accelerator indices &gt;&gt; (1 of 12)
	cQuit,
	// &lt;&lt; accelerator indices &gt;&gt; (2 of 12)
	cNew,

	// cOpen, cClose, cSave, cSaveAs,
	// &lt;&lt; accelerator indices &gt;&gt; (3 of 12)
	cTangleAll, cTangleMarked, cTangle,
	// &lt;&lt; accelerator indices &gt;&gt; (4 of 12)
	cUntangle,
	// &lt;&lt; accelerator indices &gt;&gt; (5 of 12)
	cImportFiles,
	// &lt;&lt; accelerator indices &gt;&gt; (6 of 12)
	cEditHeadline,
	// &lt;&lt; accelerator indices &gt;&gt; (7 of 12)
	cExtractSection, cExtractNames, cExtract, cConvertBlanks,
	// &lt;&lt; accelerator indices &gt;&gt; (8 of 12)
	cFindPanel, cFindNext, cFindPrev, cReplace, cReplaceThenFind,
	// &lt;&lt; accelerator indices &gt;&gt; (9 of 12)
	// cFontPanel, cSyntaxColoring, cPreferences,
	// &lt;&lt; accelerator indices &gt;&gt; (10 of 12)
	// cInsertNode, cCloneNode,
	// &lt;&lt; accelerator indices &gt;&gt; (11 of 12)
	#ifdef __WXMSW__
		cGoPrevVisibleMenuItem, cGoNextVisibleMenuItem,
	#endif
	// &lt;&lt; accelerator indices &gt;&gt; (12 of 12)
	// Conflicts with Extract command.
	// cEqualSizedPanes,

	cToggleActivePane,
	// -- end -- &lt;&lt; accelerator indices &gt;&gt;
	cAcceleratorEntries // one more than the largest index.
};

assert(cQuit==0);

wxAcceleratorEntry entries [cAcceleratorEntries];

// &lt;&lt; accelerator entries &gt;&gt; (1 of 12)
entries[cQuit].	Set( ctrl, (int)'Q', cQuitMenuItem );
// &lt;&lt; accelerator entries &gt;&gt; (2 of 12)
entries[cNew].   Set( ctrl, (int)'N', cNewMenuItem);

#if 0 // Not needed, and might conflict with Outline menu
entries[cOpen].  Set( ctrl, (int)'O', cOpenMenuItem );
entries[cClose]. Set( ctrl, (int)'W', cCloseMenuItem );
entries[cSave].	 Set( ctrl, (int)'S', cSaveMenuItem );
#endif

#if 0 // Conflicts with Outline menu.
entries[cSaveAs].Set( shift-ctrl, (int)'S', cSaveAsMenuItem );
#endif
// &lt;&lt; accelerator entries &gt;&gt; (3 of 12)
entries[cTangleAll].	Set( shift_ctrl, (int)'A', cTangleAllMenuItem );
entries[cTangleMarked].	Set( shift_ctrl, (int)'M', cTangleMarkedMenuItem );
entries[cTangle].		Set( shift_ctrl, (int)'T', cTangleMenuItem );
// &lt;&lt; accelerator entries &gt;&gt; (4 of 12)
entries[cUntangle].Set( shift_ctrl, (int)'U', cUntangleMenuItem );
// &lt;&lt; accelerator entries &gt;&gt; (5 of 12)
entries[cImportFiles].Set( shift_ctrl, (int)'F', cImportFilesMenuItem );
// &lt;&lt; accelerator entries &gt;&gt; (6 of 12)
entries[cEditHeadline].	Set( shift-ctrl, (int)'H', cEditHeadlineMenuItem );
// &lt;&lt; accelerator entries &gt;&gt; (7 of 12)
entries[cExtractSection].	Set( shift-ctrl, (int)'E', cExtractSectionMenuItem );
entries[cExtractNames].	Set( shift-ctrl, (int)'N', cExtractNamesMenuItem );
entries[cExtract].	Set( shift-ctrl, (int)'D', cExtractMenuItem );
entries[cConvertBlanks].	Set( shift-ctrl, (int)'B', cConvertBlanksMenuItem );
// &lt;&lt; accelerator entries &gt;&gt; (8 of 12)
entries[cFindPanel].Set( ctrl,   (int) 'F', cFindPanelMenuItem );

#if 1 // shift F-keys don't seem to work on Linux
	entries[cFindNext].	Set( normal, (int) WXK_F3, cFindNextMenuItem );
	entries[cFindPrev].	Set( shift,  (int) WXK_F4, cFindPreviousMenuItem );
	entries[cReplace].	Set( normal, (int) WXK_F5, cReplaceMenuItem );
  entries[cReplaceThenFind].Set( normal, (int) WXK_F6, cReplaceThenFindMenuItem );
#else
	entries[cFindNext].	Set( normal, (int) WXK_F3, cFindNextMenuItem );
	entries[cFindPrev].	Set( shift,  (int) WXK_F3, cFindPreviousMenuItem );
	entries[cReplace].	Set( normal, (int) WXK_F4, cReplaceMenuItem );
  entries[cReplaceThenFind].Set( shift,  (int) WXK_F4, cReplaceThenFindMenuItem );
#endif
// &lt;&lt; accelerator entries &gt;&gt; (9 of 12)
#if 0 // works now, and would conflict with other settings.
	entries[cFontPanel].     Set( shift-alt, (int)'T', cFontPanelMenuItem );
	entries[cSyntaxColoring].Set( shift-alt, (int)'S', cSyntaxColoringMenuItem );
	entries[cPreferences].	 Set(      ctrl, (int)'Y', cPreferencesMenuItem );
#endif
// &lt;&lt; accelerator entries &gt;&gt; (10 of 12)
#if 0 // Conflicts with Outline pane.
entries[cInsertNode].Set( ctrl,       (int) 'I', cInsertNodeMenuItem );
entries[cCloneNode] .Set( shift_ctrl, (int) 'I', cCloneNodeMenuItem );
#endif
// &lt;&lt; accelerator entries &gt;&gt; (11 of 12)
#ifdef __WXMSW__
	// Without these wxTreeCtrl handles the up/down keys itself, wrongly.
	entries[cGoPrevVisibleMenuItem].Set( normal, WXK_UP,   cGoPrevVisibleMenuItem );
	entries[cGoNextVisibleMenuItem].Set( normal, WXK_DOWN, cGoNextVisibleMenuItem );
#endif
// &lt;&lt; accelerator entries &gt;&gt; (12 of 12)
// Show log works without accel
// Conflicts with Extract command.
// entries[cEqualSizedPanes].Set( ctrl, (int) 'E', cEqualSizedPanesMenuItem );
entries[cToggleActivePane].Set( ctrl, (int) 'T', cToggleActivePaneMenuItem );
// -- end -- &lt;&lt; accelerator entries &gt;&gt;

wxAcceleratorTable accel(cAcceleratorEntries, entries);

this -&gt; SetAcceleratorTable(accel);
mBodyCtrl -&gt; SetAcceleratorTable(accel);
mTreeCtrl -&gt; SetAcceleratorTable(accel);
mSplitter1 -&gt; SetAcceleratorTable(accel);

#endif</t>
<t tx="T71">CreateStatusBar(2);
SetStatusText("");</t>
<t tx="T72">#ifdef __WXMSW__
  this -&gt;SetIcon(wxIcon("LeoIcon"));
#endif</t>
<t tx="T73">/*
	Blinking happens on Windows without a problem.  Furthermore, setting the rate here affects _all_ windows.
*/
#ifdef __WXGTK__ // Doesn't seem to work.
	wxCaret * caret = mBodyCtrl -&gt; GetCaret();
	caret -&gt; SetBlinkTime (500) ;
#endif</t>
<t tx="T74">wxTreeItemId root = mTreeCtrl -&gt; AddRoot( "untitled" ) ;
tnode *t = new tnode() ;
vnode *v = new vnode( mCommands, t );
v -&gt; setTreeID ( root ) ;
mCommands -&gt; mCurrentVnode = v ;
mTreeCtrl -&gt; SetItemData(root, (wxTreeItemData *) v);

// Set icons: it appears to be necessary to set all here.
// Otherwise, we might take an exception...
v -&gt; setIconVal(0);

#if defined(__WXMSW__)
	// Workaround bug in wxTreectrl.
	mTreeCtrl -&gt; SetItemImage(root, 0, wxTreeItemIcon_Normal);
	mTreeCtrl -&gt; SetItemImage(root, 0, wxTreeItemIcon_Selected);
#elif defined(__WXGTK__)
	mTreeCtrl -&gt; SetItemImage(root, 0, wxTreeItemIcon_Normal);
	mTreeCtrl -&gt; SetItemImage(root, 0, wxTreeItemIcon_Selected);
	mTreeCtrl -&gt; SetItemImage(root, 0, wxTreeItemIcon_Expanded);
	mTreeCtrl -&gt; SetItemImage(root, 0, wxTreeItemIcon_SelectedExpanded);
#endif</t>
<t tx="T75">@ &lt;&lt; LeoFrame methods &gt;&gt; (2 of 157)
@c

void LeoFrame::createMenus ( void )
{
	wxMenuBar *menuBar = new wxMenuBar;
	// &lt;&lt; Create the File menu &gt;&gt;
	wxMenu *fileMenu = new wxMenu;

	// &lt;&lt; Create the initial items of the file menu &gt;&gt;
	fileMenu -&gt; Append ( cNewMenuItem, "&amp;New\tCtrl-N",
		"Open new Leo window" );
	fileMenu -&gt; Append ( cOpenMenuItem,
		"&amp;Open\tCtrl-O", "Open Leo file");

	fileMenu -&gt; AppendSeparator();

	fileMenu -&gt; Append ( cCloseMenuItem,
		"&amp;Close\tCtrl-W", "Close window" );
	fileMenu -&gt; Append ( cSaveMenuItem,
		"&amp;Save\tCtrl-S", "Save window" );
	fileMenu -&gt; Append ( cSaveAsMenuItem,
		"Save &amp;As\tShift-Ctrl-S", "Save window as" );
	fileMenu -&gt; Append ( cSaveToMenuItem,
		"Save &amp;To", "Save window to" );
	fileMenu -&gt; Append ( cRevertMenuItem,
		"&amp;Revert", "Revert window to saved" );

	fileMenu -&gt; AppendSeparator();

	fileMenu -&gt; Append ( cPageSetupMenuItem,
		"Page S&amp;etup\tShift-Ctrl-P", "Specify printer settings" );
	fileMenu -&gt; Append ( cPrintMenuItem,
		"&amp;Print\tCtrl-P", "Print (Weave) window" );

	// Disabled unused items
	fileMenu -&gt; Enable(cPrintMenuItem, FALSE);
	fileMenu -&gt; Enable(cPageSetupMenuItem, FALSE);

	fileMenu -&gt; AppendSeparator();
	// -- end -- &lt;&lt; Create the initial items of the file menu &gt;&gt;
	// &lt;&lt; Create the Read/Write submenu &gt;&gt;
	wxMenu *readWriteMenu = new wxMenu;

	readWriteMenu -&gt; Append (cReadOutlineOnlyMenuItem,
		"Read Outline Only", "Read outline only");
	readWriteMenu -&gt; Append (cReadAtFileNodesMenuItem,
		"Read @file Nodes", "Read @file nodes");
	readWriteMenu -&gt; Append (cWriteOutlineOnlyMenuItem,
		"Write Outline Only", "Write outline only");
	readWriteMenu -&gt; Append (cWriteAtFileNodesMenuItem,
		"Write @file Nodes", "Write @file nodes");

	fileMenu -&gt; Append(cReadWriteSubmenuItem, "Read/Write...", readWriteMenu, "");
	// -- end -- &lt;&lt; Create the Read/Write submenu &gt;&gt;
	// &lt;&lt; Create the Tangle submenu &gt;&gt;
	wxMenu *tangleMenu = new wxMenu;

	tangleMenu -&gt; Append (cTangleAllMenuItem,
		"Tangle &amp;All\tShift-Ctrl-A", "Tangle all roots");
	tangleMenu -&gt; Append (cTangleMarkedMenuItem,
		"Tangle &amp;Marked\tShift-Ctrl-M", "Tangle all marked roots");
	tangleMenu -&gt; Append (cTangleMenuItem,
		"&amp;Tangle\tShift-Ctrl-T", "Tangle selected headline");

	fileMenu -&gt; Append(cTangleSubmenuItem, "&amp;Tangle...", tangleMenu, "");

	// Doesn't work either.
	fileMenu -&gt; SetHelpString(cTangleSubmenuItem, "Tangle commands...");
	// -- end -- &lt;&lt; Create the Tangle submenu &gt;&gt;
	// &lt;&lt; Create the Untangle submenu &gt;&gt;
	wxMenu *untangleMenu = new wxMenu;

	untangleMenu -&gt; Append (cUntangleAllMenuItem,
		"Untangle &amp;All", "Tangle all roots");
	untangleMenu -&gt; Append (cUntangleMarkedMenuItem,
		"Untangle &amp;Marked", "Tangle all marked roots");
	untangleMenu -&gt; Append (cUntangleMenuItem,
		"&amp;Untangle\tShift-Ctrl-U", "Tangle selected headline");

	fileMenu -&gt; Append(cUntangleSubmenuItem, "&amp;Untangle...", untangleMenu, "");
	// -- end -- &lt;&lt; Create the Untangle submenu &gt;&gt;
	// &lt;&lt; Create the Import Files submenu &gt;&gt;
	wxMenu *importMenu = new wxMenu;

	importMenu -&gt; Append (cImportFilesMenuItem,
		"Import Files\tShift-Ctrl-F", "Convert source files to outline" );
	importMenu -&gt; Append (cImportCWEBFilesMenuItem,
		"Import CWEB Files", "Convert CWEB file to outline");
	importMenu -&gt; Append (cImportNowebFilesMenuItem,
		"Import noweb Files", "Convert noweb file to outline");

	importMenu -&gt; Enable(cImportNowebFilesMenuItem, FALSE);

	importMenu -&gt; Append (cImportMORETextMenuItem,
		"Import MORE Text", "Convert MORE file to outline");
	importMenu -&gt; Append (cFlattenOutlineMenuItem,
		"Flatten Outline", "Write Leo outline to text file");

	fileMenu -&gt; Append(cImportExportSubmenuItem,
		"&amp;Import Files...", importMenu, "Import commands");
	// -- end -- &lt;&lt; Create the Import Files submenu &gt;&gt;
	fileMenu -&gt; AppendSeparator();

	fileMenu -&gt; Append(cQuitMenuItem, "E&amp;xit\tCtrl-Q", "Quit Leo");
	// -- end -- &lt;&lt; Create the File menu &gt;&gt;
	// &lt;&lt; Create the Edit menu &gt;&gt;
	wxMenu *editMenu = new wxMenu;

	// &lt;&lt; Create the initial items of the Edit menu &gt;&gt;
	editMenu -&gt; Append ( cUndoMenuItem, "&amp;Undo\tCtrl-Z", "Undo last operation" );

	#ifndef __WXGTK__ // For now, neither tree nor text controls support Redo.
		editMenu -&gt; Append ( cRedoMenuItem,
			"&amp;Redo\tShift-Ctrl-Z", "Redo previous operation" );
	#endif

	editMenu -&gt; AppendSeparator();

	editMenu -&gt; Append ( cCutMenuItem,
		"Cu&amp;t\tCtrl-X", "Cut text" );
	editMenu -&gt; Append ( cCopyMenuItem,
		"&amp;Copy\tCtrl-C", "Copy text" );
	editMenu -&gt; Append ( cPasteMenuItem,
		"&amp;Paste\tCtrl-V", "Paste text" );
	editMenu -&gt; Append ( cDeleteMenuItem,
		"&amp;Delete", "Delete text" );
	editMenu -&gt; Append ( cSelectAllMenuItem,
		"Select A&amp;ll\tCtrl-A", "Select all" );

	editMenu -&gt; AppendSeparator();

	editMenu -&gt; Append ( cEditHeadlineMenuItem,
		"Edit &amp;Headline\tShift-Ctrl-H", "Edit headline text" );
	// -- end -- &lt;&lt; Create the initial items of the Edit menu &gt;&gt;
	// &lt;&lt; Create the Edit Body submenu &gt;&gt;
	wxMenu *editBodyMenu = new wxMenu;

	editBodyMenu -&gt; Append ( cExtractSectionMenuItem,
		"&amp;Extract Section\tShift-Ctrl-E",
		"Extract section to child" );
	editBodyMenu -&gt; Append ( cExtractNamesMenuItem,
		"Extract Section &amp;Names\tShift-Ctrl-N",
		"Extract section names to children" );
	editBodyMenu -&gt; Append ( cExtractMenuItem,
		"Extract\tShift-Ctrl-D",
		"Extract section text to child" );
	editBodyMenu -&gt; Append ( cConvertBlanksMenuItem,
		"&amp;Convert Blanks\tShift-Ctrl-B", "Convert blanks" );

	editMenu -&gt; Append(cEditBodySubmenuItem, "&amp;Edit Body...", editBodyMenu, "");
	// -- end -- &lt;&lt; Create the Edit Body submenu &gt;&gt;
	// &lt;&lt; Create the Find submenu &gt;&gt;
	wxMenu *findMenu = new wxMenu;

	findMenu -&gt; Append ( cFindPanelMenuItem,
		"&amp;Find Panel\tCtrl-F", "Open Find panel" );

	findMenu -&gt; AppendSeparator();

	#ifdef __WXGTK__  // bugs: can't recognize shift-F keys
		findMenu -&gt; Append ( cFindNextMenuItem,
			"Find &amp;Next\tF3", "Find next" );
		findMenu -&gt; Append ( cFindPreviousMenuItem,
			"Find &amp;Prev\tF4", "Find previous" );
		findMenu -&gt; Append ( cReplaceMenuItem,
			"&amp;Replace\tF5", "Replace" );
		findMenu -&gt; Append ( cReplaceThenFindMenuItem,
			"Replace &amp;Then Find\tF6", "Replace, then find again" );
	#else
		findMenu -&gt; Append ( cFindNextMenuItem,
			"Find &amp;Next\tF3", "Find next" );
		findMenu -&gt; Append ( cFindPreviousMenuItem,
			"Find &amp;Prev\tShift-F3", "Find previous" );
		findMenu -&gt; Append ( cReplaceMenuItem,
			"&amp;Replace\tF4", "Replace" );
		findMenu -&gt; Append ( cReplaceThenFindMenuItem,
			"Replace &amp;Then Find\tShift-F4", "Replace, then find again" );
	#endif

	editMenu -&gt; Append( cFindSubmenuItem,
		"&amp;Find...", findMenu, "");
	// -- end -- &lt;&lt; Create the Find submenu &gt;&gt;
	// &lt;&lt; Create the final items of the Edit menu &gt;&gt;
	editMenu -&gt; Append ( cFontPanelMenuItem,
		"&amp;Font Panel\tAlt-Shift-T", "Open Font panel" );

	editMenu -&gt; Append ( cSyntaxColoringMenuItem,
		"&amp;Syntax Coloring...\tAlt-Shift-S", "Set syntax coloring options" );

	editMenu -&gt; Enable(cSyntaxColoringMenuItem, FALSE);

	editMenu -&gt; AppendSeparator();

	editMenu -&gt; Append ( cPreferencesMenuItem,
		"Preferences\tCtrl-Y", "Open Preferences panel" );
	// -- end -- &lt;&lt; Create the final items of the Edit menu &gt;&gt;
	// -- end -- &lt;&lt; Create the Edit menu &gt;&gt;
	// &lt;&lt; Create the Outline menu &gt;&gt;
	wxMenu *outlineMenu = new wxMenu;

	// &lt;&lt; Create the initial items of the Outline menu &gt;&gt;
	outlineMenu -&gt; Append ( cCutNodeMenuItem,
		"Cu&amp;t Node\tShift-Ctrl-X", "Cut node");
	outlineMenu -&gt; Append ( cCopyNodeMenuItem,
		"&amp;Copy Node\tShift-Ctrl-C", "Copy node" );
	outlineMenu -&gt; Append ( cPasteNodeMenuItem,
		"&amp;Paste Node\tShift-Ctrl-V", "Paste node" );
	outlineMenu -&gt; Append ( cDeleteNodeMenuItem,
		// Shift-Ctrl-BkSp not validcPreferencesMenuItem
		"&amp;Delete Node", "Delete node" );

	outlineMenu -&gt; AppendSeparator();

	outlineMenu -&gt; Append ( cInsertNodeMenuItem,
		"&amp;Insert Node\tCtrl-I", "Insert new node" );

	outlineMenu -&gt; Append ( cCloneNodeMenuItem,
		"&amp;Clone Node\tShift-Ctrl-I", "Clone node" );

	outlineMenu -&gt; Append ( cSortNodeMenuItem,
		"&amp;Sort Node", "Sort node's childdren" );

	outlineMenu -&gt; AppendSeparator();
	// -- end -- &lt;&lt; Create the initial items of the Outline menu &gt;&gt;
	// &lt;&lt; Create the Expand/Contract submenu &gt;&gt;
	wxMenu *expandContractMenu = new wxMenu;

	expandContractMenu -&gt; Append ( cExpandAllChildrenMenuItem,
		"Expand All Children", "Expand node fully" );
	expandContractMenu -&gt; Append ( cExpandChilrenMenuItem,
		"Expand Children", "Expand node" );

	expandContractMenu -&gt; AppendSeparator();

	expandContractMenu -&gt; Append ( cContractAllChildrenMenuItem,
		"Contract All Children", "Contract node fully" );
	expandContractMenu -&gt; Append ( cContractChilrenMenuItem,
		"Contract Children", "Contract node" );

	expandContractMenu -&gt; AppendSeparator();

	expandContractMenu -&gt; Append ( cExpandNextLevelMenuItem,
		"Expand &amp;Next Level\tAlt-N", "Expand outline another level" );
	expandContractMenu -&gt; Append ( cExpandToLevel1MenuItem,  // better than contract all
		"Contract All\tAlt-1", "Contract all" );
	expandContractMenu -&gt; Append ( cExpandToLevel2MenuItem,
		"Expand To Level 2\tAlt-2", "Expand to level 2" );
	expandContractMenu -&gt; Append ( cExpandToLevel3MenuItem,
		"Expand To Level 3\tAlt-3", "Expand to level 3" );
	expandContractMenu -&gt; Append ( cExpandToLevel4MenuItem,
		"Expand To Level 4\tAlt-4", "Expand to level 4" );
	expandContractMenu -&gt; Append ( cExpandToLevel5MenuItem,
		"Expand To Level 5\tAlt-5", "Expand to level 5" );
	expandContractMenu -&gt; Append ( cExpandToLevel6MenuItem,
		"Expand To Level 6\tAlt-6", "Expand to level 6" );
	expandContractMenu -&gt; Append ( cExpandToLevel7MenuItem,
		"Expand To Level 7\tAlt-7", "Expand to level 7" );
	expandContractMenu -&gt; Append ( cExpandToLevel8MenuItem,
		"Expand To Level 8\tAlt-8", "Expand to level 8" );
	expandContractMenu -&gt; Append ( cExpandAllMenuItem,
		"Expand All\tAlt-9", "Expand all" );

	outlineMenu -&gt; Append(cExpandContractSubmenuItem,
		"Expand/Contract...", expandContractMenu, "");
	// -- end -- &lt;&lt; Create the Expand/Contract submenu &gt;&gt;
	// &lt;&lt; Create the Move/Select submenu &gt;&gt;
	wxMenu *moveSelectMenu = new wxMenu;

	moveSelectMenu -&gt; Append ( cMoveDownMenuItem,
		"Move &amp;Down\tCtrl-D", "Move node down" );
	moveSelectMenu -&gt; Append ( cMoveLeftMenuItem,
		"Move &amp;Left\tCtrl-L", "Move node left" );
	moveSelectMenu -&gt; Append ( cMoveRightMenuItem,
		"Move &amp;Right\tCtrl-R", "Move node right" );
	moveSelectMenu -&gt; Append ( cMoveUpMenuItem,
		"Move &amp;Up\tCtrl-U", "Move node up" );

	moveSelectMenu -&gt; AppendSeparator();

	// Can't use control-] and control-[ anywhere.
	moveSelectMenu -&gt; Append ( cPromoteMenuItem,
		"&amp;Promote", "Promote children" );

	moveSelectMenu -&gt; Append ( cDemoteMenuItem,
		"&amp;Demote", "Demote following siblings" );

	moveSelectMenu -&gt; AppendSeparator();

	#ifdef __WXMSW__  // Up and down keys handled by tree &amp; text control
		moveSelectMenu -&gt; Append ( cGoPrevVisibleMenuItem,
			"Go Prev Visible\tUp", "Select previous visible node" );
		moveSelectMenu -&gt; Append ( cGoNextVisibleMenuItem,
			"Go Next Visible\tDown", "Select next visible node" );
	#else
	 	moveSelectMenu -&gt; Append ( cGoPrevVisibleMenuItem,
			"Go Prev Visible", "Select previous visible node" );
		moveSelectMenu -&gt; Append ( cGoNextVisibleMenuItem,
			"Go Next Visible", "Select next visible node" );
	#endif

	moveSelectMenu -&gt; AppendSeparator();

	moveSelectMenu -&gt; Append ( cGoBackMenuItem,
		"Go Prev", "Select previous node" );
	moveSelectMenu -&gt; Append ( cGoNextMenuItem,
		"Go Next", "Select next node" );

	outlineMenu -&gt; Append(cMoveSelectSubmenuItem,
		"Move/&amp;Select...", moveSelectMenu, "");
	// -- end -- &lt;&lt; Create the Move/Select submenu &gt;&gt;
	// &lt;&lt; Create the Mark/Go To submenu &gt;&gt;
	wxMenu *markGoToMenu = new wxMenu;

	markGoToMenu -&gt; Append ( cMarkMenuItem,
		"&amp;Mark\tCtrl-M", "Mark node" );
	markGoToMenu -&gt; Append ( cMarkSubheadsMenuItem,
		"Mark &amp;Subheads\tAlt-S", "Mark children of node" );
	markGoToMenu -&gt; Append ( cMarkChangedItemsMenuItem,
		"Mark &amp;Changed Items\tAlt-C", "Mark all changed nodes" );
	markGoToMenu -&gt; Append ( cMarkChangedRootsMenuItem,
		"Mark Changed &amp;Roots\tAlt-R", "Mark all changed root nodes" );
	markGoToMenu -&gt; Append ( cMarkAllAtFileNodesDirtyMenuItem,
		"Mark All @file Nodes Dirty", "Mark all @file nodes" );
	markGoToMenu -&gt; Append ( cMarkAtFileNodesDirtyMenuItem,
		"Mark @file Nodes Dirty", "Mark @file nodes" );

	markGoToMenu -&gt; AppendSeparator();

	markGoToMenu -&gt; Append ( cUnmarkAllMenuItem,
		"&amp;Unmark All\tAlt-U", "Unmark all nodes" );
	markGoToMenu -&gt; Append ( cGoToNextMarkedMenuItem,
		"&amp;Go To Next Marked\tAlt-M", "Select next marked node" );
	markGoToMenu -&gt; Append ( cGoToNextChangedMenuItem,
		"Go To Next Changed\tAlt-D", "Select next changed node" );

	outlineMenu -&gt; Append(cMarkGotoSubmenuItem,
		"&amp;Mark/Go To...", markGoToMenu, "");
	// -- end -- &lt;&lt; Create the Mark/Go To submenu &gt;&gt;
	// -- end -- &lt;&lt; Create the Outline menu &gt;&gt;
	// &lt;&lt; Create the Window menu &gt;&gt;
	wxMenu *windowMenu = new wxMenu;

	windowMenu -&gt; Append ( cEqualSizedPanesMenuItem,
		#ifdef __WXGTK__  // Control-E conflicts with shift-control-E
			"&amp;Equal Sized Panes", "Make each pane the same size");
		#else
			"&amp;Equal Sized Panes\tCtrl-E", "Make each pane the same size");
		#endif

	windowMenu -&gt; Append ( cToggleActivePaneMenuItem,
		"&amp;Toggle Active Pane\tCtrl-T", "Switch the active pane");

	#ifdef __WXGTK__
		windowMenu -&gt; Enable(cToggleActivePaneMenuItem, FALSE);
	#endif

	windowMenu -&gt; Append ( cSplitPaneDirectionMenuItem,
		"&amp;Split Pane Vertically", "Change orientation of pane");

	windowMenu -&gt; AppendSeparator();

	windowMenu -&gt; Append ( cCascadeMenuItem,
		"&amp;Cascade Windows", "Cascade all open windows");

	windowMenu -&gt; Append ( cMinimizeAllMenuItem,
		"Minimize &amp;All Windows", "Minimize all open windows");

	windowMenu -&gt; AppendSeparator();

	#ifdef __WXMSW__
	windowMenu -&gt; Append ( cOpenPythonWindowMenuItem,
		"Open &amp;Python Window\tAlt-P", "Open the Python window");
	#endif

	#if 0 // Not ready yet: use wxFileHistory
		windowMenu -&gt; AppendSeparator();

		windowMenu -&gt; Append ( cRecentWindowsMenuItem,
			"Recent Windows", "List of recent windows");
	#endif
	// -- end -- &lt;&lt; Create the Window menu &gt;&gt;
	// &lt;&lt; Create the Help menu &gt;&gt;
	wxMenu *helpMenu = new wxMenu;

	helpMenu -&gt; Append(cAboutLeoMenuItem,
		"&amp;About Leo...",
		"Show about dialog");
	// -- end -- &lt;&lt; Create the Help menu &gt;&gt;
	menuBar-&gt;Append(fileMenu, "&amp;File");
	menuBar-&gt;Append(editMenu, "&amp;Edit");
	menuBar-&gt;Append(outlineMenu, "&amp;Outline");
	menuBar-&gt;Append(windowMenu, "&amp;Window");
	menuBar-&gt;Append(helpMenu, "&amp;Help");
	SetMenuBar(menuBar);  // attach the menu bar to the frame
}
</t>
<t tx="T76">@ &lt;&lt; LeoFrame methods &gt;&gt; (3 of 157)
@c

void LeoFrame::SetUntitledNumber ( long n )
{
	wxString s ( "untitled") ;
	if ( n &gt; 0 )
		s += wxString::Format("%d",n);
	this -&gt; SetTitle(s) ;
}
</t>
<t tx="T77">@ &lt;&lt; LeoFrame methods &gt;&gt; (4 of 157)
@c

void LeoFrame::putToLog ( const char * s )
{
	mLogCtrl -&gt; AppendText(s);
}
</t>
<t tx="T78">@ &lt;&lt; LeoFrame methods &gt;&gt; (5 of 157)
@c

wxString LeoFrame::getLogText ( void )
{
	return mLogCtrl -&gt; GetValue();
}
</t>
<t tx="T79"></t>
<t tx="T80">@ &lt;&lt; LeoFrame methods &gt;&gt; (6 of 157)
@c

#ifdef __WXMSW__

void LeoFrame::onActivate(wxActivateEvent &amp;event)
{
	if ( event . GetActive() ) {
		gActiveFrame = this ;
		if ( this -&gt; mCommands )
			this -&gt; mCommands -&gt; checkAllFileDates();
	}
}
</t>
<t tx="T81">
#else

void LeoFrame::OnSetFocus(wxFocusEvent&amp; WXUNUSED(event))
{
	gActiveFrame = this ;
	if ( this -&gt; mCommands )
		this -&gt; mCommands -&gt; checkAllFileDates();
}
</t>
<t tx="T82">
#endif
// &lt;&lt; LeoFrame methods &gt;&gt; (7 of 157)
void LeoFrame::onResize(wxSizeEvent&amp; WXUNUSED(event))
{
	if ( mIniting )
		return ; // Can be called during initialization.

	// Resize splitter1 with equal sized panes.
	wxSize size = this -&gt; GetClientSize();
	mSplitter1 -&gt; SetClientSize(size);
	long w = size.GetWidth();
	long h = size.GetHeight();
	if ( mSplitter1 -&gt; GetSplitMode() == wxSPLIT_VERTICAL )
		mSplitter1 -&gt; SetSashPosition(w/2, TRUE);
	else
		mSplitter1 -&gt; SetSashPosition(h/2, TRUE);

	// Resize splitter2 with equal sized panes.
	size = mSplitter2 -&gt; GetClientSize();
	w = size.GetWidth();
	h = size.GetHeight();
	if ( mSplitter2 -&gt; GetSplitMode() == wxSPLIT_VERTICAL )
		mSplitter2 -&gt; SetSashPosition((3*w)/5, TRUE);
	else
		mSplitter2 -&gt; SetSashPosition((3*h)/5, TRUE);
}
</t>
<t tx="T83">@ &lt;&lt; LeoFrame methods &gt;&gt; (8 of 157)
@c

static long sDisableTextUpdates = 0 ;

void LeoFrame::onBodyTextUpdated(wxCommandEvent&amp; WXUNUSED(event))
{
	// Changing text should never cause a recursive entry.
	assert(mTextChanging == 0);
	assert(mCopying == 0);

	if ( sDisableTextUpdates &gt; 0 ) return ; // 3/19/01
	if ( mCommands == NULL ) return ;
	vnode * v = mCommands -&gt; currentVnode();
	if ( v == NULL ) return ;

	TRACEP("events", es("OnBodyTextUpdated"); enl());
	++ mTextChanging ;

	// &lt;&lt; Set the dirty bit and/or the file-changed mark if the text has changed &gt;&gt;
	if (
		! v -&gt; isDirty() &amp;&amp;
		mBodyCtrl -&gt; GetValue() != v -&gt; bodyString()
	) {
		v -&gt; initDirtyBit () ;  // Avoid calling setIcon.
		if ( ! mCommands -&gt; isChanged() )
			mCommands -&gt; setChanged (TRUE) ;
	}
	// -- end -- &lt;&lt; Set the dirty bit and/or the file-changed mark if the text has changed &gt;&gt;

	// Update the tnode so nodes are always synched.
	v -&gt; t() -&gt; saveBodyPaneToTnode ( mBodyCtrl ) ;
	v -&gt; setAncestorAtFileNodeDirty();

	// Update the syntax colorer if needed.
	mCommands -&gt; updateSyntaxColorer ( v );

	// &lt;&lt; Update icons &gt;&gt;
	/*
		It is very important to eliminate flicker here.
	*/
	long val = v -&gt; computeIcon();
	bool repaint = FALSE ;

	if ( ! mCommands -&gt; isChanged() ) {
		mCommands -&gt; setChanged (TRUE);
		repaint = TRUE ;
	}

	if ( val &gt;= 0 &amp;&amp; val != v -&gt; iconVal() ) {
		repaint = TRUE ;

		v -&gt; setIconWithVal(val);

		// Update all joined nodes.
		for (
			vnode * v2 = v -&gt; joinList();
			v2 &amp;&amp; v2 != v ;
			v2 = v2 -&gt; joinList()
		)
			v2 -&gt; setIconWithVal(val);
	}

	if (repaint)
		mTreeCtrl -&gt; Refresh();
	// -- end -- &lt;&lt; Update icons &gt;&gt;
	-- mTextChanging ;
}
</t>
<t tx="T84">@ &lt;&lt; LeoFrame methods &gt;&gt; (9 of 157)
@c

void LeoFrame::onCloseLeoFrame(wxCloseEvent&amp; event)
{
	// Veto the close if the Frame has been changed and the user cancels.

	if ( mCommands -&gt; isChanged() ) {
		bool veto = FALSE ;
		if ( ! mReverting ) {
			// &lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;
			// Use the window title:  mFileName may not exist.
			wxString title = this -&gt; GetTitle();
			if ( title.Length() &gt; 0 &amp;&amp; title[0UL] == '*')
				title = title.Mid(1);

			wxString message("Save changes to \"");
			message += title ;

			if ( gQuitting )
				message += "\" before quitting?" ;
			else
				message += "\" before closing?"  ;

			wxMessageDialog * dialog = new wxMessageDialog(
				this, message, "LeoWX", wxYES_NO|wxCANCEL);
			int answer = dialog-&gt;ShowModal();
			dialog-&gt;Destroy();

			switch (answer)
			{
			case wxID_YES:
				// The user want's to save the file before closing.
				if ( mFileName == wxString("") ) {
					// Put up the save dialog.
					wxFileDialog d (
						NULL, "Save",
						"", // default directory
						title + ".leo", // default file
						"*.leo", // wildcard
						wxSAVE | wxOVERWRITE_PROMPT,  // style of dialog.
						wxDefaultPosition);

					if ( d.ShowModal() == wxID_OK ) {
						wxArrayString paths;
						d.GetPaths(paths);
						if ( paths.Count() == 1 ) {
							wxString path = paths.Item(0);
							mFileName = path ;
							this -&gt; SetTitle(path);
							mCommands -&gt; save (path);
						}
						else veto = TRUE ;
					}
					else veto = TRUE ;
				}
				else mCommands -&gt; save( mFileName ) ;
				break;

			case wxID_NO:
				// The user does not want to save the frame.
				break;

				// The user want's to cancel the close.
			case wxID_CANCEL:
			default:
				veto = TRUE ;
				break;
			}
			// -- end -- &lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;
		}
		if ( veto &amp;&amp; event.CanVeto() ) {
				event.Veto();  // veto the close.
				return ;
			}
	}

	// Unlink this frame from the list of frames.
	if ( mNextFrame )
		mNextFrame -&gt; mPrevFrame = mPrevFrame ;
	if ( mPrevFrame )
		mPrevFrame -&gt; mNextFrame = mNextFrame ;
	else
		gLeoFrameList = mNextFrame ;

	if ( gLeoFrameList == NULL ) {
		// &lt;&lt; Close the permanent frames &gt;&gt;
		if ( gPrefsFrame ) {
			gPrefsFrame -&gt; Destroy();
			gPrefsFrame = NULL ;
		}

		if ( gFindFrame ) {
			gFindFrame -&gt; Destroy();
			gFindFrame = NULL ;
		}

		#ifdef __WXMSW__
		wxPythonFrame::destroy();
		#endif
		// -- end -- &lt;&lt; Close the permanent frames &gt;&gt;
	}

	// Clear the active form.  It will be set on the next activate event.
	gActiveFrame = NULL ;
	gCommands = NULL ;

	// Set all vnodes to NULL so they are not destroyed.
	#if 0 ///// why shouldn't they be destroyed ?????
	  wxTreeCtrl * tree = mTreeCtrl;
	  vnode * v = mCommands -&gt; rootVnode();
	  while ( v ) {
		  vnode * next = v -&gt; threadNext();
		  wxTreeItemId id = v -&gt; treeID();
		  assert(id);
		  tree -&gt; SetItemData(id, NULL);
		  v = next ;
	  }
	#endif

	this -&gt; Destroy();
}
</t>
<t tx="T85">@ &lt;&lt; LeoFrame methods &gt;&gt; (10 of 157)
@c

void LeoFrame::onTreeChanged(wxTreeEvent&amp; event)
{
 	TRACEP("events", es("onTreeChanged"); enl());
	assert(mTreeCtrl);
	assert(mCommands);
	if (mCommands -&gt; mInhibitOnTreeChanged) return ;
	// &lt;&lt; Define old_id, new_id, old_v, new_v &gt;&gt;
	/*
		I used to think that new_id and old_id had to exist, but that is not so: either might be 0 depending on circumstances.
	*/
	wxTreeItemId new_id = event.GetItem();
	TRACEP("events", es("new item: "); elong( long(new_id) ) ; enl() ) ;

	if ( ! new_id.IsOk() ) return ;
	vnode * new_v = (vnode *)( mTreeCtrl -&gt; GetItemData(new_id) ) ;
	if ( new_v == NULL ) return ;

	#if 0 // no longer used

		// old_id may not exist if we are activating the first node.
		wxTreeItemId old_id = event.GetOldItem();
		TRACEP("events", es("old item: "); elong( long(old_id) ) ; enl() ) ;
		vnode * old_v = NULL ;

		if ( old_id.IsOk() ) {
			old_v = (vnode *) ( mTreeCtrl -&gt; GetItemData(old_id) ) ;
			#ifdef __WXMSW__
				assert(old_v);
			#endif
		}

	#endif
	// -- end -- &lt;&lt; Define old_id, new_id, old_v, new_v &gt;&gt;
	// &lt;&lt; Put the new text into the body pane &gt;&gt;
	/*
		Apparently in wxWindows this does _not_ fire the text changed event! But in wxGTK it does.  We must prevent the update 
		event handler from messing with the old text!
	*/
	++ sDisableTextUpdates ;
		// Clear the old text.
		mBodyCtrl -&gt; Clear();

		// Put the text of the new node into the body pane.
		new_v -&gt; t() -&gt; loadBodyPaneFromTnode ( mBodyCtrl ) ;

		// Clear the undo stack.
		mBodyCtrl -&gt; DiscardEdits();
	-- sDisableTextUpdates ;

	// Update the Commander's idea of the current node.
	mCommands -&gt; mCurrentVnode = new_v ;

	// Update the syntax colorer if needed.
	mCommands -&gt; updateSyntaxColorer ( new_v ) ;
	// -- end -- &lt;&lt; Put the new text into the body pane &gt;&gt;
}
</t>
<t tx="T86">@ &lt;&lt; LeoFrame methods &gt;&gt; (11 of 157)
@c

void LeoFrame::onTreeChanging(wxTreeEvent&amp; WXUNUSED(event))
{
	// No recursion should be possible here.
	assert(mTextChanging == 0);
	assert(mCopying == 0);
}
</t>
<t tx="T87">@ &lt;&lt; LeoFrame methods &gt;&gt; (12 of 157)
@c

void LeoFrame::onTreeKeyDown(wxTreeEvent&amp; WXUNUSED(event))
{

}
</t>
<t tx="T88">@ &lt;&lt; LeoFrame methods &gt;&gt; (13 of 157)
@c

void LeoFrame::onTreeBeginDrag(wxTreeEvent&amp; event)
{
	assert(mTreeCtrl);
	if ( event.GetItem() != mTreeCtrl -&gt; GetRootItem() ) {
		mDraggedItem = event.GetItem();
		event.Allow();
	}
}
</t>
<t tx="T89">@ &lt;&lt; LeoFrame methods &gt;&gt; (14 of 157)
@c

void LeoFrame::onTreeEndDrag(wxTreeEvent&amp; event)
{
	// &lt;&lt; Define onTreeEndDrag vars &gt;&gt;
	assert(mTreeCtrl);
	assert(mCommands);

	wxTreeItemId dst = event.GetItem();
	wxTreeItemId src = mDraggedItem;
	mDraggedItem = 0L;
	if ( ! dst.IsOk() || ! src.IsOk() ) return ;

	vnode * src_v = (vnode *) ( mTreeCtrl -&gt; GetItemData(src) );
	if (src_v == NULL) return ;

	vnode * dst_v = (vnode *) ( mTreeCtrl -&gt; GetItemData(dst) );
	if (dst_v == NULL) return ;

	wxTreeItemId parent = mTreeCtrl -&gt; GetParent(dst);
	vnode * parent_v = NULL ;
	// -- end -- &lt;&lt; Define onTreeEndDrag vars &gt;&gt;
	if ( src == 0 || dst == 0 ) return ;
	long cookie;
	if (
		// dst is the root
		!parent.IsOk() ||
		// dst has visible children and dst isn't the first child.
		mTreeCtrl -&gt; ItemHasChildren(dst) &amp;&amp; mTreeCtrl -&gt; IsExpanded(dst) &amp;&amp;
		mTreeCtrl -&gt; GetFirstChild(dst, cookie) != src ||
		// back(src) == dst (would otherwise be a do-nothing)
		mTreeCtrl -&gt; GetPrevSibling(src) == dst
	) {
		// &lt;&lt; Insert src as the first child of dst &gt;&gt;
		// Make sure the drag will be valid.
		parent_v = (vnode *) ( mTreeCtrl -&gt; GetItemData(dst) );
		if ( ! mCommands -&gt; checkMoveWithParentWithWarning ( src_v, parent_v, TRUE ) ) return ;

		src_v -&gt; moveToNthChildOf( dst_v, 0);
		// -- end -- &lt;&lt; Insert src as the first child of dst &gt;&gt;
	}
	else {
		// Not the root and no visible children.
		// &lt;&lt; Insert src after dst &gt;&gt;
		// Do nothing if dst is a child of src.
		for (wxTreeItemId p = parent; p.IsOk(); p = mTreeCtrl -&gt; GetParent(p) )
			if ( p == src )
				return ;

		// Do nothing if dst is joined to src.
		if ( dst_v -&gt; isJoinedTo(src_v) )
			return ;

		// Make sure the drag will be valid.
		parent_v = (vnode *) ( mTreeCtrl -&gt; GetItemData(parent) );
		if ( ! mCommands -&gt; checkMoveWithParentWithWarning ( src_v, parent_v, TRUE ) ) return ;

		src_v -&gt; moveAfter(dst_v);
		// -- end -- &lt;&lt; Insert src after dst &gt;&gt;
	}

	mCommands -&gt; selectVnode(src_v);
	mCommands -&gt; setChanged(TRUE);
}
</t>
<t tx="T90">@ &lt;&lt; LeoFrame methods &gt;&gt; (15 of 157)
Editing will not be allowed if this routine does not exist.
@c

void LeoFrame::onTreeBeginLabelEdit(wxTreeEvent&amp; WXUNUSED(event))
{
	// Doing nothing is is enough to enable the edit.
}
</t>
<t tx="T91">@ &lt;&lt; LeoFrame methods &gt;&gt; (16 of 157)
Editing will not be allowed if this routine does not exist.
@c

void LeoFrame::onTreeEndLabelEdit(wxTreeEvent&amp; event)
{
	// Doing nothing is enough to enable the edit.

	wxString s = event.GetLabel();
	wxTreeItemId item = event.GetItem();
	vnode * v = (vnode *) ( mTreeCtrl -&gt; GetItemData(item) );

	// Set the dirty bit and the file-changed mark if the headline has changed.
	if ( ! v -&gt; isDirty() &amp;&amp; s != v -&gt; headString() ) {
		v -&gt; setDirty () ;
		if ( ! mCommands -&gt; isChanged() )
			mCommands -&gt; setChanged (TRUE) ;
	}

	// Update all joined headlines.
	for ( vnode * j = v -&gt; joinList(); j &amp;&amp; j != v; j = j -&gt; joinList() )
		j -&gt; setHeadString(s);
}
</t>
<t tx="T92">@ &lt;&lt; LeoFrame methods &gt;&gt; (17 of 157)
This updates the text of joined _headlines_, not body text.
@c

#if 0 // no longer used

void LeoFrame::updateJoinedHeadlines ( wxString text, vnode * v )
{
	static long guard = 0 ;
	if ( guard &gt; 0 ) return ;
	++ guard ;
		for (
			vnode * v2 = v -&gt; joinList() ;
			v2 &amp;&amp; v2 != v ;
			v2 = v2 -&gt; joinList()
		)  {
			wxTreeItemId id = v2 -&gt; treeID();
			assert(id);
			mTreeCtrl -&gt; SetItemText(id, text) ;
		}
	-- guard ;
}
</t>
<t tx="T93">
#endif
// &lt;&lt; LeoFrame methods &gt;&gt; (18 of 157)
void LeoFrame::OnUpdateRevert( wxUpdateUIEvent &amp;event )
{
	event.Enable(mCommands -&gt; canRevert()) ;
}
</t>
<t tx="T94">@ &lt;&lt; LeoFrame methods &gt;&gt; (19 of 157)
@c

void LeoFrame::OnNew(wxCommandEvent&amp; WXUNUSED(event))
{
	// Create a frame and link it into the global frame list.
	LeoFrame *frame = new LeoFrame();
	wxString s("untitled");
	if ( ++gNumberOfUntitledWindows &gt; 1 )
		s += wxString::Format("%d", gNumberOfUntitledWindows);
	frame -&gt; SetTitle(s);
	frame -&gt; mFileName = wxString("") ;  // No real file associated with this window.
	frame -&gt; Show(TRUE);

	// Set the current node in the _new_ form!.
	vnode *v = frame -&gt; mCommands -&gt; rootVnode();
	assert(v);
	frame -&gt; mCommands -&gt; setCurrentVnode ( v ) ;
	frame -&gt; mCommands -&gt; editVnode( v ) ;
}
</t>
<t tx="T95">@ &lt;&lt; LeoFrame methods &gt;&gt; (20 of 157)
@c

void LeoFrame::OnOpen(wxCommandEvent&amp; WXUNUSED(event))
{
	// Create the Open dialog.
	wxFileDialog d (
		NULL, "Choose a Leo file",
		"", // default directory
		"", // default file
		"*.leo", // wildcard
		wxOPEN | wxMULTIPLE ,  // style of dialog.
		wxDefaultPosition);

	if ( d.ShowModal() == wxID_OK ) {
		wxArrayString paths;
		d.GetPaths(paths);
		long count = paths.Count();
		for ( long i = 0 ; i &lt; count ; ++ i )
			LeoFrame::OpenWithFileName ( paths.Item(i) ) ;
	}
}
</t>
<t tx="T96">@ &lt;&lt; LeoFrame methods &gt;&gt; (21 of 157)
@c

LeoFrame * LeoFrame::OpenWithFileName( wxString fileName )
{
	// If the file is already open just bring its window to the front.
	LeoFrame * frame = gLeoFrameList ;
	while ( frame ) {
		if ( frame -&gt; mFileName == fileName ) {
			frame -&gt; Show();
			gActiveFrame = frame ;
			return frame ;
		}
		frame = frame -&gt; mNextFrame ;
	}

	// Don't take an exception if the file doesn't exist.
	if ( ! ::wxFileExists ( fileName ) ) {
		wxString m("Can not open: ") ;
		m += fileName ;
		alert ( m.c_str() ) ;
		return NULL ;
	}

	try {
		// &lt;&lt; Set closeEmptyFrameFlag if the only open window is empty &gt;&gt;
		#if 0 // not used at present.
		LeoFrame * closeFrame = gLeoFrameList ;

		bool closeEmptyFrameFlag =
			// There is only one window open at present.
			gNumberOfUntitledWindows == 1 &amp;&amp;

			// The window was opened on startup and has never been saved.
			closeFrame &amp;&amp;
			closeFrame -&gt; mCommands -&gt; mFirstWindowAndNeverSaved &amp;&amp;

			// The window is empty.
			! ( closeFrame -&gt; mCommands-&gt; isChanged() ) ;
		#endif
		// -- end -- &lt;&lt; Set closeEmptyFrameFlag if the only open window is empty &gt;&gt;
		LeoFrame * frame = new LeoFrame ();
		#if 0 // Don't show frame until it has been fully opened.
			frame -&gt; Show(TRUE);
		#endif
		frame -&gt; mCommands -&gt; open( fileName ) ;
		frame -&gt; mFileName = fileName ;
		// Automatically close an empty frame that was created on entry.
		#if 0 //// There is still something wrong here!
		if ( closeEmptyFrameFlag &amp;&amp; closeFrame )
			closeFrame -&gt; Close ( ) ;
		#endif
		gActiveFrame = frame ;
		return frame ;
	}
	catch ( ... )
	{
		wxString m("Error opening: ") ;
		m += fileName ;
		alert ( m.c_str() ) ;
		return NULL ;
	}
}
</t>
<t tx="T97">@ &lt;&lt; LeoFrame methods &gt;&gt; (22 of 157)
@c

void LeoFrame::OnClose(wxCommandEvent&amp; WXUNUSED(event))
{
	// Close the frame, giving the close handler a chance to veto.
	this -&gt; Close();
}
</t>
<t tx="T98">@ &lt;&lt; LeoFrame methods &gt;&gt; (23 of 157)
@c

void LeoFrame::OnSave(wxCommandEvent&amp; WXUNUSED(event))
{
	if ( mFileName == wxString("") ) {
		// Create the Save dialog.
		wxFileDialog d (
			NULL, "Save",
			wxString(""), // default directory
			mFileName, // default file
			wxString("*.leo"), // wildcard
			wxSAVE | wxOVERWRITE_PROMPT,  // style of dialog.
			wxDefaultPosition);

		if ( d.ShowModal() == wxID_OK ) {
			wxString path = d.GetPath();
			mFileName = path ;
			this -&gt; SetLabel(path);
			mCommands -&gt; save (path);
		}
	}
	else mCommands -&gt; save ( mFileName ) ;
}
</t>
<t tx="T99">@ &lt;&lt; LeoFrame methods &gt;&gt; (24 of 157)
@c

void LeoFrame::OnSaveAs(wxCommandEvent&amp; WXUNUSED(event))
{
	// Create the Save dialog.
	wxFileDialog d (
		NULL, "Save As",
		wxString(""), // default directory
		mFileName, // default file
		wxString("*.leo"), // wildcard
		wxSAVE | wxOVERWRITE_PROMPT,  // style of dialog.
		wxDefaultPosition);

	if ( d.ShowModal() == wxID_OK ) {
		wxString path = d.GetPath();
		mFileName = path ;
		this -&gt; SetLabel(path);
		mCommands -&gt; saveAs (path);
	}
}
</t>
<t tx="T100">@ &lt;&lt; LeoFrame methods &gt;&gt; (25 of 157)
@c

void LeoFrame::OnSaveTo(wxCommandEvent&amp; WXUNUSED(event))
{
	// Create the Save dialog.
	wxFileDialog d (
		NULL, "Save To",
		wxString(""), // default directory
		mFileName, // default file
		wxString("*.leo"), // wildcard
		wxSAVE | wxOVERWRITE_PROMPT,  // style of dialog.
		wxDefaultPosition);

	if ( d.ShowModal() == wxID_OK ) {
		wxString fileName = d.GetPath();
		mCommands -&gt; saveACopyAs(fileName);
	}
}
</t>
<t tx="T101">@ &lt;&lt; LeoFrame methods &gt;&gt; (26 of 157)
@c

void LeoFrame::OnRevert(wxCommandEvent&amp; WXUNUSED(event))
{
   // Make sure the user wants to Revert.
	wxString prompt ("Revert to previous version of ");
	prompt += mFileName + "?" ;
	int answer = wxMessageBox( prompt, "Revert to saved?", wxYES_NO ) ;
	if (answer == wxNO) return ;

	// Kludge: rename this frame so OpenWithFileName won't think it is open.
	wxString fileName = mFileName ;
	mFileName = wxString("") ;

	// Create a new frame before deleting this frame.
	LeoFrame * frame = LeoFrame::OpenWithFileName( fileName );

	// Delete the form.
	mReverting = TRUE ; // Indicate that no prompt is needed.
	this -&gt; Close();
	mReverting = FALSE ;

	// Bring the already-opened frame to the front.
	frame -&gt; Show(FALSE);
	frame -&gt; Show(TRUE);
}
</t>
<t tx="T102">@ &lt;&lt; LeoFrame methods &gt;&gt; (27 of 157)
@c

void LeoFrame::OnPageSetup(wxCommandEvent&amp; WXUNUSED(event))
{
	////
}
</t>
<t tx="T103">@ &lt;&lt; LeoFrame methods &gt;&gt; (28 of 157)
@c

void LeoFrame::OnPrint(wxCommandEvent&amp; WXUNUSED(event))
{
	////
}
</t>
<t tx="T104">@ &lt;&lt; LeoFrame methods &gt;&gt; (29 of 157)
@c

void LeoFrame::OnTangleSubmenu(wxCommandEvent&amp; WXUNUSED(event))
{

}
</t>
<t tx="T105">@ &lt;&lt; LeoFrame methods &gt;&gt; (30 of 157)
@c

void LeoFrame::OnUntangleSubmenu(wxCommandEvent&amp; WXUNUSED(event))
{

}
</t>
<t tx="T106">@ &lt;&lt; LeoFrame methods &gt;&gt; (31 of 157)
@c

void LeoFrame::OnImportExportSubmenu(wxCommandEvent&amp; WXUNUSED(event))
{

}
</t>
<t tx="T107">@ &lt;&lt; LeoFrame methods &gt;&gt; (32 of 157)
@c

void LeoFrame::OnQuit(wxCommandEvent&amp; WXUNUSED(event))
{
	gQuitting = TRUE ;

		// Closing all windows terminates Leo.  Stop if the user aborts.
		while ( gLeoFrameList )
			if ( ! gLeoFrameList -&gt; Close() )
				break ; // User cancelled a close.

	gQuitting = FALSE ;
}
</t>
<t tx="T108">@ &lt;&lt; LeoFrame methods &gt;&gt; (33 of 157)
@c

void LeoFrame::OnReadOutlineOnly(wxCommandEvent&amp; WXUNUSED(event))
{
	// Create the Open dialog.
	wxFileDialog d (
		NULL, "Choose a Leo file",
		"", // default directory
		"", // default file
		"*.leo", // wildcard
		wxOPEN | wxMULTIPLE ,  // style of dialog.
		wxDefaultPosition);

	if ( d.ShowModal() == wxID_OK ) {
		wxArrayString paths;
		d.GetPaths(paths);
		long count = paths.Count();
		for ( long i = 0 ; i &lt; count ; ++ i )
			this -&gt; readOutlineOnly ( paths.Item(i) ) ;
	}
}
</t>
<t tx="T109">@ &lt;&lt; LeoFrame methods &gt;&gt; (34 of 157)
@c

void LeoFrame::readOutlineOnly ( wxString fileName )
{
	// If the file is already open just bring its window to the front.
	LeoFrame * frame = gLeoFrameList ;
	while ( frame ) {
		if ( frame -&gt; mFileName == fileName ) {
			frame -&gt; Show();
			gActiveFrame = frame ;
		}
		frame = frame -&gt; mNextFrame ;
	}

	// Don't take an exception if the file doesn't exist.
	if ( ! ::wxFileExists ( fileName ) ) {
		wxString m("Can not open: ") ;
		m += fileName ;
		alert ( m.c_str() ) ;
		return ;
	}

	try {
		LeoFrame * frame = new LeoFrame ();
		frame -&gt; mCommands -&gt; readOutlineOnly( fileName ) ;
		frame -&gt; Show(TRUE);
		frame -&gt; mFileName = fileName ;
		gActiveFrame = frame ;
	}
	catch ( ... )
	{
		wxString m("Error opening: ") ;
		m += fileName ;
		alert ( m.c_str() ) ;
	}
}
</t>
<t tx="T110">@ &lt;&lt; LeoFrame methods &gt;&gt; (35 of 157)
@c

void LeoFrame::OnReadAtFileNodes(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; readAtFileNodes();
}
</t>
<t tx="T111">@ &lt;&lt; LeoFrame methods &gt;&gt; (36 of 157)
@c

void LeoFrame::OnWriteOutlineOnly(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; writeOutlineOnly();
}
</t>
<t tx="T112">@ &lt;&lt; LeoFrame methods &gt;&gt; (37 of 157)
@c

void LeoFrame::OnWriteAtFileNodes(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; writeAtFileNodes();
}
</t>
<t tx="T113">@ &lt;&lt; LeoFrame methods &gt;&gt; (38 of 157)
@c

void LeoFrame::OnTangleAll(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; tangleAll();
}
</t>
<t tx="T114">@ &lt;&lt; LeoFrame methods &gt;&gt; (39 of 157)
@c

void LeoFrame::OnTangleMarked(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; tangleMarked();
}
</t>
<t tx="T115">@ &lt;&lt; LeoFrame methods &gt;&gt; (40 of 157)
@c

void LeoFrame::OnTangle(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; tangle();
}
</t>
<t tx="T116">@ &lt;&lt; LeoFrame methods &gt;&gt; (41 of 157)
@c

void LeoFrame::OnUntangleAll(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; untangleAll();
}
</t>
<t tx="T117">@ &lt;&lt; LeoFrame methods &gt;&gt; (42 of 157)
@c

void LeoFrame::OnUntangleMarked(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; untangleMarked();
}
</t>
<t tx="T118">@ &lt;&lt; LeoFrame methods &gt;&gt; (43 of 157)
@c

void LeoFrame::OnUntangle(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; untangle();
}
</t>
<t tx="T119">@ &lt;&lt; LeoFrame methods &gt;&gt; (44 of 157)
@c

void LeoFrame::OnImportFiles(wxCommandEvent&amp; WXUNUSED(event))
{
	// Create the Open dialog.
	wxFileDialog d (
		NULL, "Import Files",
		"", // default directory
		"", // default file
		"*.*", // wildcard
		wxOPEN | wxMULTIPLE | wxFILE_MUST_EXIST,  // style of dialog.
		wxDefaultPosition);

	if ( d.ShowModal() == wxID_OK ) {
		wxArrayString paths;
		d.GetPaths(paths);
		mCommands -&gt; ImportFilesCommand (&amp;paths);
	}
}
</t>
<t tx="T120">@ &lt;&lt; LeoFrame methods &gt;&gt; (45 of 157)
@c

void LeoFrame::OnImportCWEBFiles(wxCommandEvent&amp; WXUNUSED(event))
{
	// Create the Open dialog.
	wxFileDialog d (
		NULL, "Import CWEB Files",
		"", // default directory
		"", // default file
		"*.*", // wildcard
		wxOPEN | wxMULTIPLE | wxFILE_MUST_EXIST,  // style of dialog.
		wxDefaultPosition);

	if ( d.ShowModal() == wxID_OK ) {
		wxArrayString paths;
		d.GetPaths(paths);
		mCommands -&gt; CWEBToOutlineCommand (&amp;paths);
	}
}
</t>
<t tx="T121">@ &lt;&lt; LeoFrame methods &gt;&gt; (46 of 157)
@c

void LeoFrame::OnImportNowebFiles(wxCommandEvent&amp; WXUNUSED(event))
{
	////
}
</t>
<t tx="T122">@ &lt;&lt; LeoFrame methods &gt;&gt; (47 of 157)
@c

void LeoFrame::OnImportMoreText(wxCommandEvent&amp; WXUNUSED(event))
{
	// Create the Open dialog.
	wxFileDialog d (
		NULL, "Import MORE Text",
		"", // default directory
		"", // default file
		"*.*", // wildcard
		wxOPEN | wxFILE_MUST_EXIST,  // style of dialog.
		wxDefaultPosition);

	if ( d.ShowModal() == wxID_OK ) {
		wxArrayString paths;
		d.GetPaths(paths);
		mCommands -&gt; importMoreText (&amp;paths);
	}
}
</t>
<t tx="T123">@ &lt;&lt; LeoFrame methods &gt;&gt; (48 of 157)
@c

void LeoFrame::OnFlattenOutline(wxCommandEvent&amp; WXUNUSED(event))
{
	// Create the Open dialog.
	wxFileDialog d (
		NULL, "Flatten Outline",
		"", // default directory
		"flat.txt", // default file
		"*.*", // wildcard
		wxSAVE | wxOVERWRITE_PROMPT,  // style of dialog.
		wxDefaultPosition);

	if ( d.ShowModal() == wxID_OK ) {
		wxArrayString paths;
		d.GetPaths(paths);
		mCommands -&gt; flattenOutline (&amp;paths);
	}
}
</t>
<t tx="T124">@ &lt;&lt; LeoFrame methods &gt;&gt; (49 of 157)
@c

void LeoFrame::OnUpdateCopy ( wxUpdateUIEvent&amp; event )
{
	wxWindow * w = this -&gt; FindFocus();

	if ( w &amp;&amp; w == mBodyCtrl )
		event.Enable( mBodyCtrl-&gt; CanCopy( ) ) ;
	else if ( w &amp;&amp; w == mLogCtrl )
		event.Enable( mLogCtrl-&gt; CanCopy( ) ) ;
	else
		event.Enable( FALSE ) ;
}
</t>
<t tx="T125">@ &lt;&lt; LeoFrame methods &gt;&gt; (50 of 157)
@c

void LeoFrame::OnUpdateCut ( wxUpdateUIEvent&amp; event )
{
	wxWindow * w = this -&gt; FindFocus();

	if ( w &amp;&amp; w == mBodyCtrl )
		event.Enable( mBodyCtrl-&gt; CanCut( ) ) ;
	else if ( w &amp;&amp; w == mLogCtrl )
		event.Enable( mLogCtrl-&gt; CanCut( ) ) ;
	else
		event.Enable( FALSE ) ;
}
</t>
<t tx="T126">@ &lt;&lt; LeoFrame methods &gt;&gt; (51 of 157)
@c

void LeoFrame::OnUpdateDelete ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mBodyCtrl &amp;&amp; mBodyCtrl -&gt; CanCut( ) ) ;
}
</t>
<t tx="T127">@ &lt;&lt; LeoFrame methods &gt;&gt; (52 of 157)
@c

void LeoFrame::OnUpdateExtract ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canExtract() ) ;
}
</t>
<t tx="T128">@ &lt;&lt; LeoFrame methods &gt;&gt; (53 of 157)
@c

void LeoFrame::OnUpdateExtractNames ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canExtractSectionNames() ) ;
}
</t>
<t tx="T129">@ &lt;&lt; LeoFrame methods &gt;&gt; (54 of 157)
@c

void LeoFrame::OnUpdateExtractSection ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canExtractSection() ) ;
}
</t>
<t tx="T130">@ &lt;&lt; LeoFrame methods &gt;&gt; (55 of 157)
@c

void LeoFrame::OnUpdateFind ( wxUpdateUIEvent&amp; event )
{
	event.Enable( find_text . Length() &gt; 0 ) ;
}
</t>
<t tx="T131">@ &lt;&lt; LeoFrame methods &gt;&gt; (56 of 157)
@c

void LeoFrame::OnUpdatePaste ( wxUpdateUIEvent&amp; event )
{
	#ifdef __WXMSW__ // apparent bug.
		event.Enable(TRUE);
	#else
		wxWindow * w = this -&gt; FindFocus();

		if ( w &amp;&amp; w == mBodyCtrl )
			event.Enable( mBodyCtrl-&gt; CanPaste( ) ) ;
		else if ( w &amp;&amp; w == mLogCtrl )
			event.Enable( mLogCtrl-&gt; CanPaste( ) ) ;
		else
			event.Enable( FALSE ) ;
	#endif
}
</t>
<t tx="T132">@ &lt;&lt; LeoFrame methods &gt;&gt; (57 of 157)
@c

void LeoFrame::OnUpdateRedo ( wxUpdateUIEvent&amp; event )
{
	bool enabled = FALSE ;

	// The Tree view does not support redo.

	#ifdef __WXGTK__ // text control does not support undo/redo on wxGTK
		enabled = FALSE ;
	#else
		enabled = ( mBodyCtrl &amp;&amp; mBodyCtrl -&gt; CanRedo() ) ;
	#endif

	event.Enable( enabled ) ;
}
</t>
<t tx="T133">@ &lt;&lt; LeoFrame methods &gt;&gt; (58 of 157)
@c

void LeoFrame::OnUpdateReplace ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; changeIsEnabled() ) ;
}
</t>
<t tx="T134">@ &lt;&lt; LeoFrame methods &gt;&gt; (59 of 157)
@c

void LeoFrame::OnUpdateSelectAll ( wxUpdateUIEvent&amp; event )
{
	wxWindow * w = this -&gt; FindFocus();

	event.Enable( w &amp;&amp; ( w == mBodyCtrl || w == mLogCtrl ) ) ;
}
</t>
<t tx="T135">@ &lt;&lt; LeoFrame methods &gt;&gt; (60 of 157)
@c

void LeoFrame::OnUpdateUndo ( wxUpdateUIEvent&amp; event )
{
	wxWindow * w = this -&gt; FindFocus();
	bool enabled = FALSE ;

	// FindFocus seems to be a bit flakey, so use it only when absolutely needed.

	if ( w == mTreeCtrl )
		enabled = mCommands -&gt; canUndo() ;
	else
		// Don't use FindFocus.
		#ifdef __WXGTK__ // text control does not support undo/redo on wxGTK
			enabled = FALSE ;
		#else
			enabled = ( mBodyCtrl &amp;&amp; mBodyCtrl -&gt; CanUndo() ) ;
		#endif

	event.Enable( enabled ) ;
}
</t>
<t tx="T136">@ &lt;&lt; LeoFrame methods &gt;&gt; (61 of 157)
@c

bool LeoFrame::hasSelection ( void )
{

	 if ( mBodyCtrl ) {
		long from, to ;
		mBodyCtrl  -&gt; GetSelection(&amp;from, &amp;to);
		return from != to ;
	}
	else return FALSE ;

#if 0 // old code:  now we just test mBodyCtrl.
	wxWindow * w = this -&gt; FindFocus();
	if ( w == NULL )
		return FALSE ;
	else if ( w == mBodyCtrl ) {
		long from, to ;
		mBodyCtrl  -&gt; GetSelection(&amp;from, &amp;to);
		return from != to ;
	}
	else if ( w == mTreeCtrl ) {
		#ifdef __WXMSW__
		wxTextCtrl * text = mTreeCtrl -&gt; GetEditControl() ;
		if ( text ) {
				long from, to ;
				text  -&gt; GetSelection(&amp;from, &amp;to);
				return from != to ;
		}
		#endif
	}

	return FALSE ;
#endif

}
</t>
<t tx="T137">@ &lt;&lt; LeoFrame methods &gt;&gt; (62 of 157)
@c

void LeoFrame::OnUndo(wxCommandEvent&amp; WXUNUSED(event))
{
	wxWindow * w = this -&gt; FindFocus();

	// FindFocus seems to be a bit flakey, so use it only when absolutely needed.

	if ( w == mTreeCtrl )
		mCommands -&gt; undo();

#ifndef __WXGTK__ // text control does not support undo/redo on wxGTK
	else if ( mBodyCtrl &amp;&amp; mBodyCtrl -&gt; CanUndo() )
		mBodyCtrl -&gt; Undo();
#endif

}
</t>
<t tx="T138">@ &lt;&lt; LeoFrame methods &gt;&gt; (63 of 157)
@c

void LeoFrame::OnRedo(wxCommandEvent&amp; WXUNUSED(event))
{
	// The tree control does not support redo.

#ifndef __WXGTK__ // text control does not support undo/redo on wxGTK
	if ( mBodyCtrl &amp;&amp; mBodyCtrl -&gt; CanRedo() )
		mBodyCtrl -&gt; Redo();
#endif

}
</t>
<t tx="T139">@ &lt;&lt; LeoFrame methods &gt;&gt; (64 of 157)
@c

void LeoFrame::OnCut(wxCommandEvent&amp; WXUNUSED(event))
{
	wxWindow * w = this -&gt; FindFocus();

	if ( w &amp;&amp; w == mBodyCtrl )
		mBodyCtrl-&gt; Cut( ) ;
	else if ( w &amp;&amp; w == mLogCtrl )
		mLogCtrl-&gt; Cut( ) ;
}
</t>
<t tx="T140">@ &lt;&lt; LeoFrame methods &gt;&gt; (65 of 157)
@c

void LeoFrame::OnCopy(wxCommandEvent&amp; WXUNUSED(event))
{
	wxWindow * w = this -&gt; FindFocus();

	if ( w &amp;&amp; w == mBodyCtrl )
		mBodyCtrl-&gt; Copy( ) ;
	else if ( w &amp;&amp; w == mLogCtrl )
		mLogCtrl-&gt; Copy( ) ;
}
</t>
<t tx="T141">@ &lt;&lt; LeoFrame methods &gt;&gt; (66 of 157)
@c

void LeoFrame::OnPaste(wxCommandEvent&amp; WXUNUSED(event))
{
	wxWindow * w = this -&gt; FindFocus();

	if ( w &amp;&amp; w == mBodyCtrl )
		mBodyCtrl-&gt; Paste( ) ;
	else if ( w &amp;&amp; w == mLogCtrl )
		mLogCtrl-&gt; Paste( ) ;
}
</t>
<t tx="T142">@ &lt;&lt; LeoFrame methods &gt;&gt; (67 of 157)
@c

void LeoFrame::OnDelete(wxCommandEvent&amp; WXUNUSED(event))
{
	if ( mBodyCtrl ) {
		long from, to ;
		mBodyCtrl -&gt; GetSelection(&amp;from, &amp;to);
		if ( from &lt; to )
			mBodyCtrl -&gt; Remove(from, to);
		else
			mBodyCtrl -&gt; Remove(to, from);
	}
}
</t>
<t tx="T143">@ &lt;&lt; LeoFrame methods &gt;&gt; (68 of 157)
@c

void LeoFrame::OnSelectAll(wxCommandEvent&amp; WXUNUSED(event))
{
	wxWindow * w = this -&gt; FindFocus();

	if ( w == mBodyCtrl ) {
		long to = mBodyCtrl -&gt; GetLastPosition();
		mBodyCtrl -&gt; SetSelection(0, to);
	}
	else if ( w == mLogCtrl ) {
		long to = mLogCtrl -&gt; GetLastPosition();
		mLogCtrl -&gt; SetSelection(0, to);
	}
}
</t>
<t tx="T144">@ &lt;&lt; LeoFrame methods &gt;&gt; (69 of 157)
@c

void LeoFrame::OnEditHeadline(wxCommandEvent&amp; WXUNUSED(event))
{
#ifndef __WXMSW__ // EditLabel is buggy.  Hitting a control key or tab will crash.
	wxTreeItemId item = mTreeCtrl-&gt;GetSelection();
	if ( item )
		mTreeCtrl-&gt;EditLabel( item );
#endif
}
</t>
<t tx="T145">@ &lt;&lt; LeoFrame methods &gt;&gt; (70 of 157)
@c

void LeoFrame::OnFontPanel(wxCommandEvent&amp; WXUNUSED(event))
{
	wxFontData data;
	data.SetInitialFont(mBodyCtrl -&gt; GetFont());
	data.SetColour(mBodyCtrl -&gt; GetForegroundColour());

	wxFontDialog dialog(this, &amp;data);
	#ifndef __WXGTK__  // Causes problems on GTK+ version of wxWindows.
		dialog.CentreOnScreen();
	#endif

	if (dialog.ShowModal() != wxID_OK)  return ;

	wxFontData retData = dialog.GetFontData();
	wxFont font = retData.GetChosenFont();
	wxColour color = retData.GetColour();

	// On Linux, SetFont apparently clears the text control's text string!

	#ifdef __WXGTK__
		wxString contents = mBodyCtrl -&gt; GetValue();
		mBodyCtrl -&gt; SetFont ( font ) ;
		mBodyCtrl -&gt; SetForegroundColour(color);
		mBodyCtrl -&gt; SetValue(contents);
	#else
		mBodyCtrl -&gt; SetFont ( font ) ;
		mBodyCtrl -&gt; SetForegroundColour(color);
	#endif

	this -&gt; Refresh();

	TRACEP("font_info",
		es("face: "); es( font . GetFaceName() . c_str() ) ; ecs();
		es("family: "); es( font . GetFamilyString() . c_str() ) ; enl();
		es("size: "); eint( font . GetPointSize() ) ; ecs();
		es("style: "); es( font. GetStyleString() . c_str() ) ; ecs();
		es("weight: "); es( font . GetWeightString() . c_str() ) ; enl();
	);
}
</t>
<t tx="T146">@ &lt;&lt; LeoFrame methods &gt;&gt; (71 of 157)
@c

void LeoFrame::OnSyntaxColoring(wxCommandEvent&amp; WXUNUSED(event))
{
	////
}
</t>
<t tx="T147">@ &lt;&lt; LeoFrame methods &gt;&gt; (72 of 157)
@c

void LeoFrame::OnPreferences(wxCommandEvent&amp; WXUNUSED(event))
{
	if ( gPrefsFrame == NULL ) {
		gPrefsFrame = new PrefsFrame ();
		gPrefsFrame -&gt; initialize();
	}

	gPrefsFrame -&gt; CenterOnScreen();
	gPrefsFrame -&gt; Show(TRUE);
	gPrefsFrame -&gt; Raise();
}
</t>
<t tx="T148">@ &lt;&lt; LeoFrame methods &gt;&gt; (73 of 157)
@c

void LeoFrame::OnConvertBlanks(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; convertBlanks();
}
</t>
<t tx="T149">@ &lt;&lt; LeoFrame methods &gt;&gt; (74 of 157)
@c

void LeoFrame::OnExtractSection(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; extractSection();
}
</t>
<t tx="T150">@ &lt;&lt; LeoFrame methods &gt;&gt; (75 of 157)
@c

void LeoFrame::OnExtractNames(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; extractSectionNames();
}
</t>
<t tx="T151">@ &lt;&lt; LeoFrame methods &gt;&gt; (76 of 157)
@c

void LeoFrame::OnExtract(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; extract();
}
</t>
<t tx="T152">@ &lt;&lt; LeoFrame methods &gt;&gt; (77 of 157)
@c

void LeoFrame::OnFindPanel(wxCommandEvent&amp; WXUNUSED(event))
{
	if ( gFindFrame == NULL )
		gFindFrame = new FindFrame ();

	// On windows, this activates the frame.
	gFindFrame -&gt; Show();
	gFindFrame -&gt; Raise();
}
</t>
<t tx="T153">@ &lt;&lt; LeoFrame methods &gt;&gt; (78 of 157)
@c

void LeoFrame::OnFindNext(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; doFindNextCommand();
}
</t>
<t tx="T154">@ &lt;&lt; LeoFrame methods &gt;&gt; (79 of 157)
@c

void LeoFrame::OnFindPrevious(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; doFindPreviousCommand();
}
</t>
<t tx="T155">@ &lt;&lt; LeoFrame methods &gt;&gt; (80 of 157)
@c

void LeoFrame::OnReplace(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; doChangeCommand();
}
</t>
<t tx="T156">@ &lt;&lt; LeoFrame methods &gt;&gt; (81 of 157)
@c

void LeoFrame::OnReplaceThenFind(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; doChangeThenFindCommand();
}
</t>
<t tx="T157">@ &lt;&lt; LeoFrame methods &gt;&gt; (82 of 157)
@c

void LeoFrame::OnUpdateCutNode ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canCutOutline() ) ;
}
</t>
<t tx="T158">@ &lt;&lt; LeoFrame methods &gt;&gt; (83 of 157)
@c

void LeoFrame::OnUpdateDeleteNode ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canDeleteHeadline() ) ;
}
</t>
<t tx="T159">@ &lt;&lt; LeoFrame methods &gt;&gt; (84 of 157)
@c

void LeoFrame::OnUpdatePasteNode ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canPasteOutline() ) ;
}
</t>
<t tx="T160">@ &lt;&lt; LeoFrame methods &gt;&gt; (85 of 157)
@c

void LeoFrame::OnUpdateSortNode ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canSort() ) ;
}
</t>
<t tx="T161">@ &lt;&lt; LeoFrame methods &gt;&gt; (86 of 157)
@c

void LeoFrame::OnUpdateExpandAll ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canExpandAllHeadlines() ) ;
}
</t>
<t tx="T162">@ &lt;&lt; LeoFrame methods &gt;&gt; (87 of 157)
@c

void LeoFrame::OnUpdateExpandAllChildren ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canExpandAllSubheads() ) ;
}
</t>
<t tx="T163">@ &lt;&lt; LeoFrame methods &gt;&gt; (88 of 157)
@c

void LeoFrame::OnUpdateExpandChildren ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canExpandAllSubheads() ) ;
}
</t>
<t tx="T164">@ &lt;&lt; LeoFrame methods &gt;&gt; (89 of 157)
@c

void LeoFrame::OnUpdateContractAll ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canContractAllHeadlines() ) ;
}
</t>
<t tx="T165">@ &lt;&lt; LeoFrame methods &gt;&gt; (90 of 157)
@c

void LeoFrame::OnUpdateContractAllChildren ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canContractAllSubheads() ) ;
}
</t>
<t tx="T166">@ &lt;&lt; LeoFrame methods &gt;&gt; (91 of 157)
@c

void LeoFrame::OnUpdateContractChildren ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canContractSubheads() ) ;
}
</t>
<t tx="T167">@ &lt;&lt; LeoFrame methods &gt;&gt; (92 of 157)
@c

void LeoFrame::OnUpdateMoveDown ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canMoveOutlineDown() ) ;
}
</t>
<t tx="T168">@ &lt;&lt; LeoFrame methods &gt;&gt; (93 of 157)
@c

void LeoFrame::OnUpdateMoveLeft ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canMoveOutlineLeft() ) ;
}
</t>
<t tx="T169">@ &lt;&lt; LeoFrame methods &gt;&gt; (94 of 157)
@c

void LeoFrame::OnUpdateMoveRight ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canMoveOutlineRight() ) ;
}
</t>
<t tx="T170">@ &lt;&lt; LeoFrame methods &gt;&gt; (95 of 157)
@c

void LeoFrame::OnUpdateMoveUp ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canMoveOutlineUp() ) ;
}
</t>
<t tx="T171">@ &lt;&lt; LeoFrame methods &gt;&gt; (96 of 157)
@c

void LeoFrame::OnUpdatePromote ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canPromote() ) ;
}
</t>
<t tx="T172">@ &lt;&lt; LeoFrame methods &gt;&gt; (97 of 157)
@c

void LeoFrame::OnUpdateDemote ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canDemote() ) ;
}
</t>
<t tx="T173">@ &lt;&lt; LeoFrame methods &gt;&gt; (98 of 157)
@c

void LeoFrame::OnUpdateGoPrevVisible ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canSelectVisBack() ) ;
}
</t>
<t tx="T174">@ &lt;&lt; LeoFrame methods &gt;&gt; (99 of 157)
@c

void LeoFrame::OnUpdateGoNextVisible ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canSelectVisNext() ) ;
}
</t>
<t tx="T175">@ &lt;&lt; LeoFrame methods &gt;&gt; (100 of 157)
@c

void LeoFrame::OnUpdateGoBack ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canSelectThreadBack() ) ;
}
</t>
<t tx="T176">@ &lt;&lt; LeoFrame methods &gt;&gt; (101 of 157)
@c

void LeoFrame::OnUpdateGoNext ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canSelectThreadNext() ) ;
}
</t>
<t tx="T177">@ &lt;&lt; LeoFrame methods &gt;&gt; (102 of 157)
@c

void LeoFrame::OnUpdateMark ( wxUpdateUIEvent&amp; event )
{
	vnode * v = mCommands -&gt; currentVnode();
	event.SetText( ( v &amp;&amp; v-&gt;isMarked()) ? "Unmark" : "Mark") ;
}
</t>
<t tx="T178">@ &lt;&lt; LeoFrame methods &gt;&gt; (103 of 157)
@c

void LeoFrame::OnUpdateMarkSubheads ( wxUpdateUIEvent&amp; event )
{
	vnode * v = mCommands -&gt; currentVnode();
	event.Enable( v &amp;&amp; v -&gt; hasChildren() ) ;
}
</t>
<t tx="T179">@ &lt;&lt; LeoFrame methods &gt;&gt; (104 of 157)
@c

void LeoFrame::OnUpdateMarkChangedItems ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canMarkChangedHeadlines() ) ;
}
</t>
<t tx="T180">@ &lt;&lt; LeoFrame methods &gt;&gt; (105 of 157)
@c

void LeoFrame::OnUpdateMarkChangedRoots ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canMarkChangedRoots() ) ;
}
</t>
<t tx="T181">@ &lt;&lt; LeoFrame methods &gt;&gt; (106 of 157)
@c

void LeoFrame::OnUpdateGoToNextMarked ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canGoToNextMarkedHeadline() ) ;
}
</t>
<t tx="T182">@ &lt;&lt; LeoFrame methods &gt;&gt; (107 of 157)
@c

void LeoFrame::OnUpdateGoToNextChanged ( wxUpdateUIEvent&amp; event )
{
	event.Enable( mCommands -&gt; canGoToNextDirtyHeadline() ) ;
}
</t>
<t tx="T183">@ &lt;&lt; LeoFrame methods &gt;&gt; (108 of 157)
@c

void LeoFrame::OnCutNode(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; cutOutline();
}
</t>
<t tx="T184">@ &lt;&lt; LeoFrame methods &gt;&gt; (109 of 157)
@c

void LeoFrame::OnCopyNode(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; copyOutline();
}
</t>
<t tx="T185">@ &lt;&lt; LeoFrame methods &gt;&gt; (110 of 157)
@c

void LeoFrame::OnPasteNode(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; pasteOutline();
}
</t>
<t tx="T186">@ &lt;&lt; LeoFrame methods &gt;&gt; (111 of 157)
@c

void LeoFrame::OnDeleteNode(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; deleteHeadline();
}
</t>
<t tx="T187">@ &lt;&lt; LeoFrame methods &gt;&gt; (112 of 157)
@c

void LeoFrame::OnInsertNode(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; insertHeadline();
}
</t>
<t tx="T188">@ &lt;&lt; LeoFrame methods &gt;&gt; (113 of 157)
@c

void LeoFrame::OnCloneNode(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; clone();
}
</t>
<t tx="T189">@ &lt;&lt; LeoFrame methods &gt;&gt; (114 of 157)
@c

void LeoFrame::OnSortNode(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; sort();
}
</t>
<t tx="T190">@ &lt;&lt; LeoFrame methods &gt;&gt; (115 of 157)
@c

void LeoFrame::OnExpandAll(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandAllHeadlines();
}
</t>
<t tx="T191">@ &lt;&lt; LeoFrame methods &gt;&gt; (116 of 157)
@c

void LeoFrame::OnExpandAllChildren(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandAllSubheads();
}
</t>
<t tx="T192">@ &lt;&lt; LeoFrame methods &gt;&gt; (117 of 157)
@c

void LeoFrame::OnExpandChildren(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandSubheads();
}
</t>
<t tx="T193">@ &lt;&lt; LeoFrame methods &gt;&gt; (118 of 157)
@c

void LeoFrame::OnContractAll(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; contractAllHeadlines();
}
</t>
<t tx="T194">@ &lt;&lt; LeoFrame methods &gt;&gt; (119 of 157)
@c

void LeoFrame::OnContractAllChildren(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; contractAllSubheads();
}
</t>
<t tx="T195">@ &lt;&lt; LeoFrame methods &gt;&gt; (120 of 157)
@c

void LeoFrame::OnContractChildren(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; contractSubheads();
}
</t>
<t tx="T196">@ &lt;&lt; LeoFrame methods &gt;&gt; (121 of 157)
@c

void LeoFrame::OnExpandNextLevel(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandNextLevel();
}
</t>
<t tx="T197">@ &lt;&lt; LeoFrame methods &gt;&gt; (122 of 157)
@c

void LeoFrame::OnExpandToLevel1(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandLevel1();
}
</t>
<t tx="T198">@ &lt;&lt; LeoFrame methods &gt;&gt; (123 of 157)
@c

void LeoFrame::OnExpandToLevel2(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandLevel2();
}
</t>
<t tx="T199">@ &lt;&lt; LeoFrame methods &gt;&gt; (124 of 157)
@c

void LeoFrame::OnExpandToLevel3(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandLevel3();
}
</t>
<t tx="T200">@ &lt;&lt; LeoFrame methods &gt;&gt; (125 of 157)
@c

void LeoFrame::OnExpandToLevel4(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandLevel4();
}
</t>
<t tx="T201">@ &lt;&lt; LeoFrame methods &gt;&gt; (126 of 157)
@c

void LeoFrame::OnExpandToLevel5(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandLevel5();
}
</t>
<t tx="T202">@ &lt;&lt; LeoFrame methods &gt;&gt; (127 of 157)
@c

void LeoFrame::OnExpandToLevel6(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandLevel6();
}
</t>
<t tx="T203">@ &lt;&lt; LeoFrame methods &gt;&gt; (128 of 157)
@c

void LeoFrame::OnExpandToLevel7(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandLevel7();
}
</t>
<t tx="T204">@ &lt;&lt; LeoFrame methods &gt;&gt; (129 of 157)
@c

void LeoFrame::OnExpandToLevel8(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandLevel8();
}
</t>
<t tx="T205">@ &lt;&lt; LeoFrame methods &gt;&gt; (130 of 157)
@c

void LeoFrame::OnExpandToLevel9(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; expandLevel9();
}
</t>
<t tx="T206">@ &lt;&lt; LeoFrame methods &gt;&gt; (131 of 157)
@c

void LeoFrame::OnMoveDown(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; moveOutlineDown();
}
</t>
<t tx="T207">@ &lt;&lt; LeoFrame methods &gt;&gt; (132 of 157)
@c

void LeoFrame::OnMoveLeft(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; moveOutlineLeft();
}
</t>
<t tx="T208">@ &lt;&lt; LeoFrame methods &gt;&gt; (133 of 157)
@c

void LeoFrame::OnMoveRight(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; moveOutlineRight();
}
</t>
<t tx="T209">@ &lt;&lt; LeoFrame methods &gt;&gt; (134 of 157)
@c

void LeoFrame::OnMoveUp(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; moveOutlineUp();
}
</t>
<t tx="T210">@ &lt;&lt; LeoFrame methods &gt;&gt; (135 of 157)
@c

void LeoFrame::OnPromote(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; promote();
}
</t>
<t tx="T211">@ &lt;&lt; LeoFrame methods &gt;&gt; (136 of 157)
@c

void LeoFrame::OnDemote(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; demote();
}
</t>
<t tx="T212">@ &lt;&lt; LeoFrame methods &gt;&gt; (137 of 157)
@c

void LeoFrame::OnGoPrevVisible(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; moveOutlineUp();
}
</t>
<t tx="T213">@ &lt;&lt; LeoFrame methods &gt;&gt; (138 of 157)
@c

void LeoFrame::OnGoNextVisible(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; selectVisNext();
}
</t>
<t tx="T214">@ &lt;&lt; LeoFrame methods &gt;&gt; (139 of 157)
@c

void LeoFrame::OnGoBack(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; selectThreadBack();
}
</t>
<t tx="T215">@ &lt;&lt; LeoFrame methods &gt;&gt; (140 of 157)
@c

void LeoFrame::OnGoNext(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; selectThreadNext();
}
</t>
<t tx="T216">@ &lt;&lt; LeoFrame methods &gt;&gt; (141 of 157)
@c

void LeoFrame::OnMark(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; markHeadline();
}
</t>
<t tx="T217">@ &lt;&lt; LeoFrame methods &gt;&gt; (142 of 157)
@c

void LeoFrame::OnMarkSubheads(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; markSubheads();
}
</t>
<t tx="T218">@ &lt;&lt; LeoFrame methods &gt;&gt; (143 of 157)
@c

void LeoFrame::OnMarkChangedItems(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; markChangedHeadlines();
}
</t>
<t tx="T219">@ &lt;&lt; LeoFrame methods &gt;&gt; (144 of 157)
@c

void LeoFrame::OnMarkChangedRoots(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; markChangedRoots();
}
</t>
<t tx="T220">@ &lt;&lt; LeoFrame methods &gt;&gt; (145 of 157)
@c

void LeoFrame::OnMarkAllAtFileNodesDirty(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; markAllAtFileNodesDirty();
}
</t>
<t tx="T221">@ &lt;&lt; LeoFrame methods &gt;&gt; (146 of 157)
@c

void LeoFrame::OnMarkAtFileNodesDirty(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; markAtFileNodesDirty();
}
</t>
<t tx="T222">@ &lt;&lt; LeoFrame methods &gt;&gt; (147 of 157)
@c

void LeoFrame::OnUnmarkAll(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; unmarkAll();
}
</t>
<t tx="T223">@ &lt;&lt; LeoFrame methods &gt;&gt; (148 of 157)
@c

void LeoFrame::OnGoToNextMarked(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; goToNextMarkedHeadline();
}
</t>
<t tx="T224">@ &lt;&lt; LeoFrame methods &gt;&gt; (149 of 157)
@c

void LeoFrame::OnGoToNextChanged(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; goToNextDirtyHeadline();
}
</t>
<t tx="T225">@ &lt;&lt; LeoFrame methods &gt;&gt; (150 of 157)
@c

void LeoFrame::OnEqualSizedPanes(wxCommandEvent&amp; WXUNUSED(event))
{
	mCommands -&gt; equalSizedPanes();
}
</t>
<t tx="T226">@ &lt;&lt; LeoFrame methods &gt;&gt; (151 of 157)
@c

void LeoFrame::OnToggleActivePane(wxCommandEvent&amp; WXUNUSED(event))
{
	wxWindow * w = this -&gt; FindFocus();

	if ( w == NULL || w == mTreeCtrl )
		mBodyCtrl -&gt; SetFocus();
	else
		mTreeCtrl -&gt; SetFocus();
}
</t>
<t tx="T227">@ &lt;&lt; LeoFrame methods &gt;&gt; (152 of 157)
@c

void LeoFrame::OnChangeDirection(wxCommandEvent&amp; WXUNUSED(event))
{
	int mode = mSplitter1 -&gt; GetSplitMode();
	mSplitter1 -&gt; Unsplit(); // Hides the text control.

	if ( mode == wxSPLIT_VERTICAL )
		mSplitter1 -&gt; SplitHorizontally(mTreeCtrl, mBodyCtrl, 0);
	else
		mSplitter1 -&gt; SplitVertically(mTreeCtrl, mBodyCtrl, 0);

	mBodyCtrl -&gt; Show();
	mBodyCtrl -&gt; SetFocus();
}
</t>
<t tx="T228">@ &lt;&lt; LeoFrame methods &gt;&gt; (153 of 157)
@c

void LeoFrame::OnCascade(wxCommandEvent&amp; WXUNUSED(event))
{
	wxPoint p ( 10, 10 ) ;

	for ( LeoFrame * f = gLeoFrameList ; f ; f = f -&gt; mNextFrame ) {
		f -&gt; Move ( p ) ;
		p.x += 30 ;
		p.y += 30 ;
		if ( p.x &gt; 200 ) {
			p.x = 10 ;
			p.y = 40 ;
		}
	}
}
</t>
<t tx="T229">@ &lt;&lt; LeoFrame methods &gt;&gt; (154 of 157)
@c

void LeoFrame::OnMinimizeAll(wxCommandEvent&amp; WXUNUSED(event))
{
	if ( gPrefsFrame )
		gPrefsFrame -&gt; Iconize();
	if ( gFindFrame )
		gFindFrame -&gt; Iconize();
	if ( gPythonFrame )
		gPythonFrame -&gt; Iconize();

	for ( LeoFrame * f = gLeoFrameList ; f ; f = f -&gt; mNextFrame )
		f -&gt; Iconize();

}
</t>
<t tx="T230">@ &lt;&lt; LeoFrame methods &gt;&gt; (155 of 157)
@c

#ifdef __WXMSW__
#define SWIGEXPORT(a,b) a _export b
extern "C" SWIGEXPORT(void,initleoc)();
#else
extern "C" void initleoc();
#endif

#ifdef __WXMSW__
void LeoFrame::OnOpenPythonWindow(wxCommandEvent&amp; WXUNUSED(event))
{
	gPythonFrame = wxPythonFrame::create((char *)"leoc", (char *)"leo", (void (*)()) initleoc);
	gPythonFrame -&gt; Show(TRUE);
}
</t>
<t tx="T231">#endif // __WXMSW__
// &lt;&lt; LeoFrame methods &gt;&gt; (156 of 157)
void LeoFrame::OnRecentWindows(wxCommandEvent&amp; WXUNUSED(event))
{
	//// Not ready yet.
}
</t>
<t tx="T232">@ &lt;&lt; LeoFrame methods &gt;&gt; (157 of 157)
@c

void LeoFrame::OnAbout(wxCommandEvent&amp; WXUNUSED(event))
{
	wxString message =
"wxLeo Version 0.08 (beta), October 24, 2001\n\
Copyright © 2001 by Edward K. Ream\n\
All Rights Reserved \n\
Leo is distributed under the Python License";

	wxMessageBox(
		message,"About Leo",
		wxCenter,
		this);
}
</t>
<t tx="T233">&lt;&lt; LeoPrefs declarations &gt;&gt;

@others
</t>
<t tx="T234">// &lt;&lt; LeoPrefs private constants &gt;&gt;
/*
	These must match the order of items in the wxRadioBox.
	These are _not_ the same as vars in args.h.
*/
enum {
	c_target = 0,
	cweb_target,
	html_target,
	java_target,
	pascal_target,
	perl_target,
	perlpod_target,
	plain_text_target,
	python_target,
	bad_last_target
} ;
</t>
<t tx="T235">BEGIN_EVENT_TABLE(PrefsFrame, wxFrame)

	EVT_ACTIVATE ( PrefsFrame::OnActivatePrefsFrame)
	EVT_CLOSE( PrefsFrame::OnClosePrefsFrame)

	// Global options panel...
	EVT_TEXT ( cPrefsPageWidthText, PrefsFrame::OnPageWidthText )
	EVT_CHECKBOX ( cPrefsDoneBatCheckBox, PrefsFrame::OnDoneBatCheckBox )
	EVT_CHECKBOX ( cPrefsUnBatCheckBox, PrefsFrame::OnUnBatCheckBox )

	// Tangle options panel...
	EVT_TEXT ( cPrefsTangleDirectoryText, PrefsFrame::OnTangleDirectoryText )
	EVT_CHECKBOX ( cPrefsHeaderCheckBox, PrefsFrame::OnHeaderCheckBox )
	EVT_CHECKBOX ( cPrefsDocChunksCheckBox, PrefsFrame::OnDocChunksCheckBox )

	// Target language panel...
	EVT_RADIOBOX ( cPrefsTargetLanguageRadioBox, PrefsFrame::OnTargetLanguageRadioBox )

END_EVENT_TABLE()

BEGIN_EVENT_TABLE(PrefsPanel, wxPanel)

END_EVENT_TABLE()</t>
<t tx="T236">PrefsFrame::PrefsFrame()

	: wxFrame((wxFrame *)NULL, -1, "Leo Preferences",
		wxPoint(50, 50), wxDefaultSize,
		wxMINIMIZE_BOX | wxTHICK_FRAME | wxSYSTEM_MENU | wxCAPTION)
{
	mPrefsPanel = new PrefsPanel(this);

	// Resize to fit the panel.
	wxBoxSizer * sizer = new wxBoxSizer(wxVERTICAL);
	sizer -&gt; Add ( mPrefsPanel );
	SetAutoLayout( TRUE );  // tell dialog to use sizer
	SetSizer( sizer );  // actually set the sizer
	sizer -&gt; Fit( this ); // set size to minimum size as calculated by the sizer
	sizer -&gt; SetSizeHints( this ); // set size hints to honour mininum size

	// Set the window icon.
	#ifdef __WXMSW__
	  this -&gt;SetIcon(wxIcon("LeoIcon"));
	#endif
}
</t>
<t tx="T237">@ &lt;&lt; LeoPrefs methods &gt;&gt; (2 of 14)
@c

void PrefsFrame::initialize( void )
{
	// This may be called during construction.
	if ( ! gPrefsFrame ) return ;

	wxString s("");

	if ( gActiveFrame ) {
		s += wxString::Format("%d", gActiveFrame -&gt; mPageWidth);
		mPrefsPanel -&gt; mPrefsPageWidthText -&gt;
			SetValue(s) ;
		mPrefsPanel -&gt; mPrefsDoneBatCheckBox -&gt;
			SetValue(gActiveFrame -&gt; mTangleBatchFlag) ;
		mPrefsPanel -&gt; mPrefsUnBatCheckBox -&gt;
			SetValue(gActiveFrame -&gt; mUntangleBatchFlag) ;

		mPrefsPanel -&gt; mPrefsTangleDirectoryText -&gt;
			SetValue(gActiveFrame -&gt; mDefaultDirectory) ;
		mPrefsPanel -&gt; mPrefsHeaderCheckBox -&gt;
			SetValue(gActiveFrame -&gt; mUseHeaderFlag) ;
		mPrefsPanel -&gt; mPrefsDocChunksCheckBox -&gt;
			SetValue(gActiveFrame -&gt; mOutputDocFlag) ;

		mPrefsPanel -&gt; mTargetLanguageRadioBox -&gt;
			SetSelection(languageToTarget(gActiveFrame -&gt; mTargetLanguage)) ;
	}
	else {
		s += wxString::Format("%d", arg_page_width);
		mPrefsPanel -&gt; mPrefsPageWidthText -&gt; SetValue(s) ;
		mPrefsPanel -&gt; mPrefsDoneBatCheckBox -&gt; SetValue(arg_tangle_batch) ;
		mPrefsPanel -&gt; mPrefsUnBatCheckBox -&gt; SetValue(arg_untangle_batch) ;

		// No global setting for director.
		mPrefsPanel -&gt; mPrefsHeaderCheckBox -&gt; SetValue(arg_use_header_flag) ;
		mPrefsPanel -&gt; mPrefsDocChunksCheckBox -&gt; SetValue(arg_output_doc_flag) ;

		mPrefsPanel -&gt; mTargetLanguageRadioBox -&gt;
			SetSelection(languageToTarget(arg_target_language)) ;
	}
}
</t>
<t tx="T238">@ &lt;&lt; LeoPrefs methods &gt;&gt; (3 of 14)
@c

long PrefsFrame::targetToLanguage ( long target )
{
	switch ( target ) {
	case c_target :     return c_language ;
	case cweb_target:   return cweb_language ;
	case html_target:   return html_language ;
	case java_target:   return java_language ;
	case perl_target:   return perl_language ;
	case perlpod_target: return perlpod_language ;
	case pascal_target: return pascal_language ;
	case plain_text_target: return plain_text_language ;
	case python_target: return python_language ;
	default:            return plain_text_language ;
	}
}
</t>
<t tx="T239">@ &lt;&lt; LeoPrefs methods &gt;&gt; (4 of 14)
@c

long PrefsFrame::languageToTarget ( long language )
{
	switch ( language ) {
	case c_language:      return c_target ;
	case cweb_language:   return cweb_target ;
	case html_language:   return html_target ;
	case java_language:   return java_target ;
	case pascal_language: return pascal_target ;
	case perl_language:   return perl_target ;
	case perlpod_language: return perlpod_target ;
	case plain_text_language: return plain_text_target ;
	case python_language: return python_target ;
	default:              return plain_text_target ;
	}
}
</t>
<t tx="T240">@ &lt;&lt; LeoPrefs methods &gt;&gt; (5 of 14)
@c

void PrefsFrame::OnActivatePrefsFrame(wxActivateEvent&amp; event)
{
	if ( gPrefsFrame &amp;&amp; event.GetActive() )
		gPrefsFrame -&gt; initialize();
}
</t>
<t tx="T241">@ &lt;&lt; LeoPrefs methods &gt;&gt; (6 of 14)
This is an event handler function called when the user has tried to close a frame or dialog box. It is called via the  wxWindow::Close function, so that the application can also invoke the handler programmatically.  You should check whether the application is forcing the deletion of the window using CanVeto. If CanVeto returns FALSE, it is  not possible to skip window deletion; destroy the window using wxWindow::Destroy. If not, it is up to you whether you respond  by destroying the window.  If you don't destroy the window, you should call wxCloseEvent::Veto to let the calling code know that you did not destroy the  window. This allows the wxWindow::Close function to return TRUE or FALSE depending on whether the close instruction was  honoured or not.
@c

void PrefsFrame::OnClosePrefsFrame(wxCloseEvent&amp; event)
{
	if ( event.CanVeto() ) {
		event.Veto();  // Did not destroy the window.
		this -&gt; Show(FALSE);  // Just hide the window.
	}
	else {
		this -&gt; Destroy();
		gPrefsFrame = NULL ;
	}
}
</t>
<t tx="T242">@ &lt;&lt; LeoPrefs methods &gt;&gt; (7 of 14)
@c

void PrefsFrame::OnPageWidthText (wxCommandEvent&amp; event)
{
	wxTextCtrl * text = (wxTextCtrl *) event.GetEventObject() ;
	wxString s = text -&gt; GetValue();
	long n = 0 ;
	if ( s.ToLong(&amp;n) ) {
		arg_page_width = default_page_width = n ;
		if ( gActiveFrame )
			gActiveFrame -&gt; mPageWidth = arg_page_width ;
	}
}
</t>
<t tx="T243">@ &lt;&lt; LeoPrefs methods &gt;&gt; (8 of 14)
@c

void PrefsFrame::OnDoneBatCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	arg_tangle_batch = default_tangle_batch = box -&gt; GetValue() ;
	if ( gActiveFrame ) gActiveFrame -&gt; mTangleBatchFlag = arg_tangle_batch ;
}
</t>
<t tx="T244">@ &lt;&lt; LeoPrefs methods &gt;&gt; (9 of 14)
@c

void PrefsFrame::OnUnBatCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	arg_untangle_batch = default_untangle_batch = box -&gt; GetValue() ;
	if ( gActiveFrame ) gActiveFrame -&gt; mUntangleBatchFlag = arg_untangle_batch ;
}
</t>
<t tx="T245">@ &lt;&lt; LeoPrefs methods &gt;&gt; (10 of 14)
@c

void PrefsFrame::OnTangleDirectoryText (wxCommandEvent&amp; event)
{
	wxTextCtrl * text = (wxTextCtrl *) event.GetEventObject() ;
	wxString s = text -&gt; GetValue();
	if ( gActiveFrame ) {
		gActiveFrame -&gt; mDefaultDirectory = s ;
		if ( gActiveFrame -&gt; mDefaultDirectory . Length() &gt; 0 )
			wxSetWorkingDirectory ( gActiveFrame -&gt; mDefaultDirectory ) ;
		else if ( gActiveFrame -&gt; mOpenDirectory . Length() &gt; 0 )
			wxSetWorkingDirectory ( gActiveFrame -&gt; mOpenDirectory ) ;
	}
}
</t>
<t tx="T246">@ &lt;&lt; LeoPrefs methods &gt;&gt; (11 of 14)
@c

void PrefsFrame::OnHeaderCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	arg_use_header_flag = default_use_header_flag = box -&gt; GetValue() ;
	if ( gActiveFrame ) gActiveFrame -&gt; mUseHeaderFlag = arg_use_header_flag ;
}
</t>
<t tx="T247">@ &lt;&lt; LeoPrefs methods &gt;&gt; (12 of 14)
@c

void PrefsFrame::OnDocChunksCheckBox (wxCommandEvent&amp; event)
{
	wxCheckBox * box = (wxCheckBox *)event.GetEventObject() ;
	arg_output_doc_flag = default_output_doc_flag = box -&gt; GetValue();
	if ( gActiveFrame ) gActiveFrame -&gt; mOutputDocFlag = arg_output_doc_flag ;
}
</t>
<t tx="T248">@ &lt;&lt; LeoPrefs methods &gt;&gt; (13 of 14)
@c

void PrefsFrame::OnTargetLanguageRadioBox (wxCommandEvent&amp; event)
{
	wxRadioBox * box = (wxRadioBox *)event.GetEventObject() ;
	long targetIndex = box -&gt; GetSelection();
	default_target_language = arg_target_language = targetToLanguage(targetIndex );

	// Careful:  The @language or @nocolor will override this.
	if ( gActiveFrame ) {
		gActiveFrame -&gt; mTargetLanguage = arg_target_language ;
		Commands * commands = gActiveFrame -&gt; mCommands ;
		vnode * v = commands -&gt; currentVnode();
		gActiveFrame -&gt; mCommands -&gt; scanAllDirectives( v,
			cDontRequirePath, cDontIssueErrors );

		#if 0 //// syntax coloring
		TSyntaxMemoParser * parser = NULL ;
		if ( commands -&gt; useSyntaxColoring(v) )
			parser = commands -&gt; TSMParser ( arg_present_language ) ;
		else
			parser = commands -&gt; TSMParser ( plain_text_language )  ;

		commands -&gt; mSyntaxMemo -&gt; Parser1 = parser ;
		gActiveFrame -&gt; mParser = parser ;
		#endif
	}
}
</t>
<t tx="T249">@ &lt;&lt; LeoPrefs methods &gt;&gt; (14 of 14)
@c

PrefsPanel::PrefsPanel(wxFrame *frame)
	   : wxPanel(frame, -1)
{
	// &lt;&lt; Create the preferences controls &gt;&gt;
	wxBoxSizer * topSizer = new wxBoxSizer(wxVERTICAL);

	// &lt;&lt; Create the Global Options static box &gt;&gt;
	wxStaticBox * globalOptionsBox = new wxStaticBox(this, -1,
		"Global Options",
		wxPoint(10,10), wxSize(250,110), 0, "" );

	wxStaticBoxSizer * sizer = new wxStaticBoxSizer(globalOptionsBox, wxVERTICAL);
	wxBoxSizer * lineSizer = new wxBoxSizer(wxHORIZONTAL);
	sizer -&gt; Add ( 0, 5 ) ; // Extra vertical space.

	// Text control.
	mPrefsPageWidthText = new wxTextCtrl(this,
		cPrefsPageWidthText, "132",
		wxDefaultPosition, wxSize(50,25), 0,
		wxDefaultValidator, "") ;
	lineSizer -&gt; Add ( mPrefsPageWidthText );
	lineSizer -&gt; Add ( 20, 0 ) ; // Width.

	// Label for text control.
	lineSizer -&gt; Add (
		new wxStaticText(this, -1, "Page Width",
			wxPoint(-1,10), wxSize(100,25), 0, "") ,
		0, wxBORDER | wxTOP, 5);  // Vertical offset 5.
	sizer -&gt; Add ( lineSizer );

	mPrefsDoneBatCheckBox = new wxCheckBox(this,
		cPrefsDoneBatCheckBox,
		"Execute Leo_done.bat after Tangle",
		wxDefaultPosition, wxSize(235,25), 0,
		wxDefaultValidator, "") ;
	sizer -&gt; Add ( mPrefsDoneBatCheckBox );

	mPrefsUnBatCheckBox = new wxCheckBox(this,
		cPrefsUnBatCheckBox,
		"Execute Leo_un.bat after Untangle",
		wxDefaultPosition, wxSize(235,25), 0,
		wxDefaultValidator, "") ;
	sizer -&gt; Add ( mPrefsUnBatCheckBox );
	// -- end -- &lt;&lt; Create the Global Options static box &gt;&gt;
	topSizer -&gt; Add ( sizer );
	topSizer -&gt; Add ( 0, 10 );
	// &lt;&lt; Create the Default Tangle Options static box &gt;&gt;
	wxStaticBox * optionsBox = new wxStaticBox(this, -1,
		"Default Tangle Options",
		wxDefaultPosition, wxSize(250,210),
		0, "zzzz" );

	wxStaticBoxSizer * sizer2 = new wxStaticBoxSizer(optionsBox, wxVERTICAL);
	sizer2 -&gt; Add ( 0, 10 ) ;  // Vertical space.

	// Label.
	sizer2 -&gt; Add (
		new wxStaticText(this, -1,
			"Default Tangle directory",
			wxDefaultPosition, wxSize(165,25), 0, ""),
		0, wxBORDER | wxLEFT, 30);  // Indent 30.

	mPrefsTangleDirectoryText = new wxTextCtrl(this,
		cPrefsTangleDirectoryText, "",
		wxDefaultPosition, wxSize(230,25), 0,
		wxDefaultValidator, "") ;
	sizer2 -&gt; Add ( mPrefsTangleDirectoryText );

	mPrefsHeaderCheckBox = new wxCheckBox(this,
		cPrefsHeaderCheckBox,
		"Tangle outputs header line",
		wxDefaultPosition, wxSize(235,25), 0,
		wxDefaultValidator, "") ;
	sizer2 -&gt; Add ( mPrefsHeaderCheckBox );

	mPrefsDocChunksCheckBox = new wxCheckBox(this,
		cPrefsDocChunksCheckBox,
		"Tangle outputs document chunks",
		wxDefaultPosition, wxSize(235,25), 0,
		wxDefaultValidator, "") ;
	sizer2 -&gt; Add ( mPrefsDocChunksCheckBox );
	// -- end -- &lt;&lt; Create the Default Tangle Options static box &gt;&gt;
	topSizer -&gt; Add ( sizer2 );
	topSizer -&gt; Add ( 0, 10 );
	// &lt;&lt; Create the Default Target Language radio buttons &gt;&gt;
	wxString targetLanguageChoices[] = {
		"C/C++", "CWEB", "HTML", "Java",
		"Pascal", "Perl", "Perl + POD", "Plain text", "Python",
	};

	// We specify rows so that items will be sorted down the columns.
	mTargetLanguageRadioBox = new wxRadioBox( this,
		cPrefsTargetLanguageRadioBox,
		"Default Target Language",
		wxDefaultPosition, wxSize( 245, 145 ),
		WXSIZEOF(targetLanguageChoices),
		targetLanguageChoices,
		5, wxRA_SPECIFY_ROWS);
	// -- end -- &lt;&lt; Create the Default Target Language radio buttons &gt;&gt;
	topSizer -&gt; Add ( mTargetLanguageRadioBox );

	SetAutoLayout( TRUE );  // tell dialog to use sizer
	SetSizer( topSizer );  // actually set the sizer
	topSizer -&gt; Fit( this ); // set size to minimum size as calculated by the sizer
	topSizer -&gt; SetSizeHints( this ); // set size hints to honour mininum size
	// -- end -- &lt;&lt; Create the preferences controls &gt;&gt;
}
</t>
<t tx="T250">@ You may have to change the paths to the wxWindows docs by hand:  find/change doesn't work in headlines.
</t>
<t tx="T251"></t>
<t tx="T252"></t>
<t tx="T253"></t>
<t tx="T254"></t>
<t tx="T255"></t>
<t tx="T256"></t>
<t tx="T257"></t>
<t tx="T258"></t>
<t tx="T259"></t>
<t tx="T260"></t>
<t tx="T261"></t>
<t tx="T262"></t>
<t tx="T263"></t>
<t tx="T264"></t>
<t tx="T265"></t>
<t tx="T266"></t>
<t tx="T267"></t>
<t tx="T268"></t>
<t tx="T269"></t>
<t tx="T270"></t>
<t tx="T271"></t>
<t tx="T272"></t>
<t tx="T273"></t>
<t tx="T274"></t>
<t tx="T275"></t>
<t tx="T276"></t>
<t tx="T277"></t>
<t tx="T278"></t>
<t tx="T279"></t>
<t tx="T280"></t>
<t tx="T281"></t>
<t tx="T282"></t>
<t tx="T283"></t>
<t tx="T284">Will I ever have to use wxArray, wxList, wxStream, wxString.

In particular, can I use Python strings instead of wxStrings?

Can I create multiple windows without using the wxDoc classes?</t>
<t tx="T285"># Executing the following script creates a wxWindows prototype of Leo.
# Just do the Execute Script command from here.
# For this to work the path to wxLeo.py must be in sys.path.

# The first time you do this the window is created twice: once for the import and once for the reload.
# Thereafter only the reload takes effect, so only one window gets created.
# The purpose of reload is so you can change the prototype code without restarting Leo.

# To do:
# - convert this to a plugin that overrides Leo's actual code.
# - Create an icons area and put row/column numbers in the status area.
	

import wxLeo
reload(wxLeo)
</t>
<t tx="T286">from wxPython import wx

true  = 1==1
false = 1==0

cSplitterWindow = 101
cTreeCtrl = 102
cBodyCtrl = 103
cLogCtrl = 104
cOuterFrame = 105
cIconFrame = 106

cAboutLeoMenuItem = 1001

width = 600 

@others

def trace(): print "trace"

app = leoApp()
frame = leoFrame()
app.SetTopWindow(frame)
frame.Show(true)
app.MainLoop()</t>
<t tx="T287">class leoApp (wx.wxApp):
	
	@others
</t>
<t tx="T288">def OnInit(self):
	# print "leoApp:OnInit"
	return true</t>
<t tx="T289">class leoFrame(wx.wxFrame):
	@others</t>
<t tx="T290">def __init__ (self):
	
	wx.wxFrame.__init__(self, None, -1, "leoFrame")
		# wx.wxDefaultPosition, wx.wxDefaultSize,
		#wx.wxSUNKEN_BORDER,
		#wx.wxNO_3D # hangs.
		#"leoFrame")

	#self.outerPanel = wx.wxPanel(self,-1)
	
	##self.iconPanel = wx.wxPanel(self.outerPanel, -1, "iconPanel")
	
	self.CreateStatusBar()
	#self.createMenus()
	self.createMenuBar()
	
	self.splitter1 = wx.wxSplitterWindow(self,
		cSplitterWindow,
		wx.wxDefaultPosition, wx.wxDefaultSize,
		wx.wxSP_NOBORDER)
		
	# No effect.
	self.splitter1.SetForegroundColour(wx.wxRED)
	self.splitter1.SetBackgroundColour(wx.wxRED)

	self.splitter2 = wx.wxSplitterWindow(self.splitter1, -1,
		wx.wxDefaultPosition, wx.wxDefaultSize,
		wx.wxSP_NOBORDER)
		# wx.wxSP_BORDER | wx.wxSP_3D, "splitterWindow");
	
	self.splitter1.SetMinimumPaneSize(4)
	self.splitter2.SetMinimumPaneSize(4)
	
	self.tree = wx.wxTreeCtrl(self.splitter2, cTreeCtrl,
		wx.wxDefaultPosition, wx.wxDefaultSize,
		wx.wxTR_HAS_BUTTONS | wx.wxTR_EDIT_LABELS, wx.wxDefaultValidator, "treeCtrl")

	self.body = wx.wxTextCtrl(self.splitter1, cBodyCtrl, "",
		wx.wxDefaultPosition, wx.wxDefaultSize,
		wx.wxTE_MULTILINE)
	
	self.log = wx.wxTextCtrl(self.splitter2, cLogCtrl, "",
		wx.wxDefaultPosition, wx.wxDefaultSize, wx.wxTE_MULTILINE )
	
	# Attach the controls to the splitter.
	self.splitter1.SplitHorizontally(self.splitter2, self.body, 0)
	self.splitter2.SplitVertically(self.tree, self.log, width/2)</t>
<t tx="T291">def createMenus(self):

	menuBar = wx.wxMenuBar()
	if 0: # Constants not defined yet.
		&lt;&lt; Create the File menu &gt;&gt;
		&lt;&lt; Create the Edit menu &gt;&gt;
		&lt;&lt; Create the Outline menu &gt;&gt;
		&lt;&lt; Create the Window menu &gt;&gt;
	&lt;&lt; Create the Help menu &gt;&gt;
	if 0:
		menuBar.Append(fileMenu, "&amp;File")
		menuBar.Append(editMenu, "&amp;Edit")
		menuBar.Append(outlineMenu, "&amp;Outline")
		menuBar.Append(windowMenu, "&amp;Window")
		
	menuBar.Append(helpMenu, "&amp;Help")
	self.SetMenuBar(menuBar)  # attach the menu bar to the frame</t>
<t tx="T292">fileMenu = wx.wxMenu()
&lt;&lt; Create the initial items of the file menu &gt;&gt;
&lt;&lt; Create the Read/Write submenu &gt;&gt;
&lt;&lt; Create the Tangle submenu &gt;&gt;
&lt;&lt; Create the Untangle submenu &gt;&gt;
&lt;&lt; Create the Import Files submenu &gt;&gt;

fileMenu.AppendSeparator()

fileMenu.Append(cQuitMenuItem, "E&amp;xit\tCtrl-Q", "Quit Leo")</t>
<t tx="T293">fileMenu.Append ( cNewMenuItem, "&amp;New\tCtrl-N",
	"Open new Leo window" )
fileMenu.Append ( cOpenMenuItem,
	"&amp;Open\tCtrl-O", "Open Leo file")

fileMenu.AppendSeparator()

fileMenu.Append ( cCloseMenuItem,
	"&amp;Close\tCtrl-W", "Close window" )
fileMenu.Append ( cSaveMenuItem,
	"&amp;Save\tCtrl-S", "Save window" )
fileMenu.Append ( cSaveAsMenuItem,
	"Save &amp;As\tShift-Ctrl-S", "Save window as" )
fileMenu.Append ( cSaveToMenuItem,
	"Save &amp;To", "Save window to" )
fileMenu.Append ( cRevertMenuItem,
	"&amp;Revert", "Revert window to saved" )

fileMenu.AppendSeparator()

fileMenu.Append ( cPageSetupMenuItem,
	"Page S&amp;etup\tShift-Ctrl-P", "Specify printer settings" )
fileMenu.Append ( cPrintMenuItem,
	"&amp;Print\tCtrl-P", "Print (Weave) window" )

# Disabled unused items
fileMenu.Enable(cPrintMenuItem, FALSE)
fileMenu.Enable(cPageSetupMenuItem, FALSE)

fileMenu.AppendSeparator()</t>
<t tx="T294">readWriteMenu = wx.wxMenu()

readWriteMenu.Append (cReadOutlineOnlyMenuItem,
	"Read Outline Only", "Read outline only")
readWriteMenu.Append (cReadAtFileNodesMenuItem,
	"Read @file Nodes", "Read @file nodes")
readWriteMenu.Append (cWriteOutlineOnlyMenuItem,
	"Write Outline Only", "Write outline only")
readWriteMenu.Append (cWriteAtFileNodesMenuItem,
	"Write @file Nodes", "Write @file nodes")

fileMenu.Append(cReadWriteSubmenuItem, "Read/Write...", readWriteMenu, "")</t>
<t tx="T295">tangleMenu = wx.wxMenu()

tangleMenu.Append (cTangleAllMenuItem,
	"Tangle &amp;All\tShift-Ctrl-A", "Tangle all roots")
tangleMenu.Append (cTangleMarkedMenuItem,
	"Tangle &amp;Marked\tShift-Ctrl-M", "Tangle all marked roots")
tangleMenu.Append (cTangleMenuItem,
	"&amp;Tangle\tShift-Ctrl-T", "Tangle selected headline")

fileMenu.Append(cTangleSubmenuItem, "&amp;Tangle...", tangleMenu, "")

# Doesn't work either.
fileMenu.SetHelpString(cTangleSubmenuItem, "Tangle commands...")</t>
<t tx="T296">untangleMenu = wx.wxMenu()

untangleMenu.Append (cUntangleAllMenuItem,
	"Untangle &amp;All", "Tangle all roots")
untangleMenu.Append (cUntangleMarkedMenuItem,
	"Untangle &amp;Marked", "Tangle all marked roots")
untangleMenu.Append (cUntangleMenuItem,
	"&amp;Untangle\tShift-Ctrl-U", "Tangle selected headline")

fileMenu.Append(cUntangleSubmenuItem, "&amp;Untangle...", untangleMenu, "")</t>
<t tx="T297">importMenu = wx.wxMenu()

importMenu.Append (cImportFilesMenuItem,
	"Import Files\tShift-Ctrl-F", "Convert source files to outline" )
importMenu.Append (cImportCWEBFilesMenuItem,
	"Import CWEB Files", "Convert CWEB file to outline")
importMenu.Append (cImportNowebFilesMenuItem,
	"Import noweb Files", "Convert noweb file to outline")

importMenu.Enable(cImportNowebFilesMenuItem, FALSE)

importMenu.Append (cImportMORETextMenuItem,
	"Import MORE Text", "Convert MORE file to outline")
importMenu.Append (cFlattenOutlineMenuItem,
	"Flatten Outline", "Write Leo outline to text file")

fileMenu.Append(cImportExportSubmenuItem,
	"&amp;Import Files...", importMenu, "Import commands")</t>
<t tx="T298">editMenu = wx.wxMenu()
&lt;&lt; Create the initial items of the Edit menu &gt;&gt;
&lt;&lt; Create the Edit Body submenu &gt;&gt;
&lt;&lt; Create the Find submenu &gt;&gt;
&lt;&lt; Create the final items of the Edit menu &gt;&gt;</t>
<t tx="T299">editMenu.Append ( cUndoMenuItem, "&amp;Undo\tCtrl-Z", "Undo last operation" )

if 0: #ifndef __WXGTK__ # For now, neither tree nor text controls support Redo.
	editMenu.Append ( cRedoMenuItem,
		"&amp;Redo\tShift-Ctrl-Z", "Redo previous operation" )

editMenu.AppendSeparator()

editMenu.Append ( cCutMenuItem,
	"Cu&amp;t\tCtrl-X", "Cut text" )
editMenu.Append ( cCopyMenuItem,
	"&amp;Copy\tCtrl-C", "Copy text" )
editMenu.Append ( cPasteMenuItem,
	"&amp;Paste\tCtrl-V", "Paste text" )
editMenu.Append ( cDeleteMenuItem,
	"&amp;Delete", "Delete text" )
editMenu.Append ( cSelectAllMenuItem,
	"Select A&amp;ll\tCtrl-A", "Select all" )

editMenu.AppendSeparator()

editMenu.Append ( cEditHeadlineMenuItem,
	"Edit &amp;Headline\tShift-Ctrl-H", "Edit headline text" )</t>
<t tx="T300">findMenu = wx.wxMenu()

findMenu.Append ( cFindPanelMenuItem,
	"&amp;Find Panel\tCtrl-F", "Open Find panel" )

findMenu.AppendSeparator()

if 0: #ifdef __WXGTK__  # bugs: can't recognize shift-F keys
	findMenu.Append ( cFindNextMenuItem,
		"Find &amp;Next\tF3", "Find next" )
	findMenu.Append ( cFindPreviousMenuItem,
		"Find &amp;Prev\tF4", "Find previous" )
	findMenu.Append ( cReplaceMenuItem,
		"&amp;Replace\tF5", "Replace" )
	findMenu.Append ( cReplaceThenFindMenuItem,
		"Replace &amp;Then Find\tF6", "Replace, then find again" )
else:
	findMenu.Append ( cFindNextMenuItem,
		"Find &amp;Next\tF3", "Find next" )
	findMenu.Append ( cFindPreviousMenuItem,
		"Find &amp;Prev\tShift-F3", "Find previous" )
	findMenu.Append ( cReplaceMenuItem,
		"&amp;Replace\tF4", "Replace" )
	findMenu.Append ( cReplaceThenFindMenuItem,
		"Replace &amp;Then Find\tShift-F4", "Replace, then find again" )

editMenu.Append( cFindSubmenuItem,
	"&amp;Find...", findMenu, "")</t>
<t tx="T301">editMenu.Append ( cFontPanelMenuItem,
	"&amp;Font Panel\tAlt-Shift-T", "Open Font panel" )

editMenu.Append ( cSyntaxColoringMenuItem,
	"&amp;Syntax Coloring...\tAlt-Shift-S", "Set syntax coloring options" )

editMenu.Enable(cSyntaxColoringMenuItem, FALSE)

editMenu.AppendSeparator()

editMenu.Append ( cPreferencesMenuItem,
	"Preferences\tCtrl-Y", "Open Preferences panel" )</t>
<t tx="T302">editBodyMenu = wx.wxMenu()

editBodyMenu.Append ( cExtractSectionMenuItem,
	"&amp;Extract Section\tShift-Ctrl-E",
	"Extract section to child" )
editBodyMenu.Append ( cExtractNamesMenuItem,
	"Extract Section &amp;Names\tShift-Ctrl-N",
	"Extract section names to children" )
editBodyMenu.Append ( cExtractMenuItem,
	"Extract\tShift-Ctrl-D",
	"Extract section text to child" )
editBodyMenu.Append ( cConvertBlanksMenuItem,
	"&amp;Convert Blanks\tShift-Ctrl-B", "Convert blanks" )

editMenu.Append(cEditBodySubmenuItem, "&amp;Edit Body...", editBodyMenu, "")</t>
<t tx="T303">outlineMenu = wx.wxMenu()
&lt;&lt; Create the initial items of the Outline menu &gt;&gt;
&lt;&lt; Create the Expand/Contract submenu &gt;&gt;
&lt;&lt; Create the Move/Select submenu &gt;&gt;
&lt;&lt; Create the Mark/Go To submenu &gt;&gt;
</t>
<t tx="T304">outlineMenu.Append ( cCutNodeMenuItem,
	"Cu&amp;t Node\tShift-Ctrl-X", "Cut node")
outlineMenu.Append ( cCopyNodeMenuItem,
	"&amp;Copy Node\tShift-Ctrl-C", "Copy node" )
outlineMenu.Append ( cPasteNodeMenuItem,
	"&amp;Paste Node\tShift-Ctrl-V", "Paste node" )
outlineMenu.Append ( cDeleteNodeMenuItem,
	# Shift-Ctrl-BkSp not validcPreferencesMenuItem
	"&amp;Delete Node", "Delete node" )

outlineMenu.AppendSeparator()

outlineMenu.Append ( cInsertNodeMenuItem,
	"&amp;Insert Node\tCtrl-I", "Insert new node" )

outlineMenu.Append ( cCloneNodeMenuItem,
	"&amp;Clone Node\tShift-Ctrl-I", "Clone node" )

outlineMenu.Append ( cSortNodeMenuItem,
	"&amp;Sort Node", "Sort node's childdren" )

outlineMenu.AppendSeparator()</t>
<t tx="T305">expandContractMenu = wx.wxMenu()

expandContractMenu.Append ( cExpandAllChildrenMenuItem,
	"Expand All Children", "Expand node fully" )
expandContractMenu.Append ( cExpandChilrenMenuItem,
	"Expand Children", "Expand node" )

expandContractMenu.AppendSeparator()

expandContractMenu.Append ( cContractAllChildrenMenuItem,
	"Contract All Children", "Contract node fully" )
expandContractMenu.Append ( cContractChilrenMenuItem,
	"Contract Children", "Contract node" )

expandContractMenu.AppendSeparator()

expandContractMenu.Append ( cExpandNextLevelMenuItem,
	"Expand &amp;Next Level\tAlt-N", "Expand outline another level" )
expandContractMenu.Append ( cExpandToLevel1MenuItem,  # better than contract all
	"Contract All\tAlt-1", "Contract all" )
expandContractMenu.Append ( cExpandToLevel2MenuItem,
	"Expand To Level 2\tAlt-2", "Expand to level 2" )
expandContractMenu.Append ( cExpandToLevel3MenuItem,
	"Expand To Level 3\tAlt-3", "Expand to level 3" )
expandContractMenu.Append ( cExpandToLevel4MenuItem,
	"Expand To Level 4\tAlt-4", "Expand to level 4" )
expandContractMenu.Append ( cExpandToLevel5MenuItem,
	"Expand To Level 5\tAlt-5", "Expand to level 5" )
expandContractMenu.Append ( cExpandToLevel6MenuItem,
	"Expand To Level 6\tAlt-6", "Expand to level 6" )
expandContractMenu.Append ( cExpandToLevel7MenuItem,
	"Expand To Level 7\tAlt-7", "Expand to level 7" )
expandContractMenu.Append ( cExpandToLevel8MenuItem,
	"Expand To Level 8\tAlt-8", "Expand to level 8" )
expandContractMenu.Append ( cExpandAllMenuItem,
	"Expand All\tAlt-9", "Expand all" )

outlineMenu.Append(cExpandContractSubmenuItem,
	"Expand/Contract...", expandContractMenu, "")</t>
<t tx="T306">moveSelectMenu = wx.wxMenu()

moveSelectMenu.Append ( cMoveDownMenuItem,
	"Move &amp;Down\tCtrl-D", "Move node down" )
moveSelectMenu.Append ( cMoveLeftMenuItem,
	"Move &amp;Left\tCtrl-L", "Move node left" )
moveSelectMenu.Append ( cMoveRightMenuItem,
	"Move &amp;Right\tCtrl-R", "Move node right" )
moveSelectMenu.Append ( cMoveUpMenuItem,
	"Move &amp;Up\tCtrl-U", "Move node up" )

moveSelectMenu.AppendSeparator()

# Can't use control-] and control-[ anywhere.
moveSelectMenu.Append ( cPromoteMenuItem,
	"&amp;Promote", "Promote children" )

moveSelectMenu.Append ( cDemoteMenuItem,
	"&amp;Demote", "Demote following siblings" )

moveSelectMenu.AppendSeparator()

if 1: #ifdef __WXMSW__  # Up and down keys handled by tree &amp; text control
	moveSelectMenu.Append ( cGoPrevVisibleMenuItem,
		"Go Prev Visible\tUp", "Select previous visible node" )
	moveSelectMenu.Append ( cGoNextVisibleMenuItem,
		"Go Next Visible\tDown", "Select next visible node" )
else:
 	moveSelectMenu.Append ( cGoPrevVisibleMenuItem,
		"Go Prev Visible", "Select previous visible node" )
	moveSelectMenu.Append ( cGoNextVisibleMenuItem,
		"Go Next Visible", "Select next visible node" )

moveSelectMenu.AppendSeparator()

moveSelectMenu.Append ( cGoBackMenuItem,
	"Go Prev", "Select previous node" )
moveSelectMenu.Append ( cGoNextMenuItem,
	"Go Next", "Select next node" )

outlineMenu.Append(cMoveSelectSubmenuItem,
	"Move/&amp;Select...", moveSelectMenu, "")</t>
<t tx="T307">markGoToMenu = wx.wxMenu()

markGoToMenu.Append ( cMarkMenuItem,
	"&amp;Mark\tCtrl-M", "Mark node" )
markGoToMenu.Append ( cMarkSubheadsMenuItem,
	"Mark &amp;Subheads\tAlt-S", "Mark children of node" )
markGoToMenu.Append ( cMarkChangedItemsMenuItem,
	"Mark &amp;Changed Items\tAlt-C", "Mark all changed nodes" )
markGoToMenu.Append ( cMarkChangedRootsMenuItem,
	"Mark Changed &amp;Roots\tAlt-R", "Mark all changed root nodes" )
markGoToMenu.Append ( cMarkAllAtFileNodesDirtyMenuItem,
	"Mark All @file Nodes Dirty", "Mark all @file nodes" )
markGoToMenu.Append ( cMarkAtFileNodesDirtyMenuItem,
	"Mark @file Nodes Dirty", "Mark @file nodes" )

markGoToMenu.AppendSeparator()

markGoToMenu.Append ( cUnmarkAllMenuItem,
	"&amp;Unmark All\tAlt-U", "Unmark all nodes" )
markGoToMenu.Append ( cGoToNextMarkedMenuItem,
	"&amp;Go To Next Marked\tAlt-M", "Select next marked node" )
markGoToMenu.Append ( cGoToNextChangedMenuItem,
	"Go To Next Changed\tAlt-D", "Select next changed node" )

outlineMenu.Append(cMarkGotoSubmenuItem,
	"&amp;Mark/Go To...", markGoToMenu, "")</t>
<t tx="T308">windowMenu = wx.wxMenu()

if 0: #ifdef __WXGTK__  # Control-E conflicts with shift-control-E

	windowMenu.Append ( cEqualSizedPanesMenuItem,
		"&amp;Equal Sized Panes", "Make each pane the same size")
else:
	windowMenu.Append ( cEqualSizedPanesMenuItem,
		"&amp;Equal Sized Panes\tCtrl-E", "Make each pane the same size")

windowMenu.Append ( cToggleActivePaneMenuItem,
	"&amp;Toggle Active Pane\tCtrl-T", "Switch the active pane")

if 0: #ifdef __WXGTK__
	windowMenu.Enable(cToggleActivePaneMenuItem, FALSE)

windowMenu.Append ( cSplitPaneDirectionMenuItem,
	"&amp;Split Pane Vertically", "Change orientation of pane")

windowMenu.AppendSeparator()

windowMenu.Append ( cCascadeMenuItem,
	"&amp;Cascade Windows", "Cascade all open windows")

windowMenu.Append ( cMinimizeAllMenuItem,
	"Minimize &amp;All Windows", "Minimize all open windows")

windowMenu.AppendSeparator()

if 1: #ifdef __WXMSW__
	windowMenu.Append ( cOpenPythonWindowMenuItem,
		"Open &amp;Python Window\tAlt-P", "Open the Python window")

if 0: # Not ready yet: use wxFileHistory
	windowMenu.AppendSeparator()

	windowMenu.Append ( cRecentWindowsMenuItem,
		"Recent Windows", "List of recent windows")</t>
<t tx="T309">helpMenu = wx.wxMenu()

helpMenu.Append(cAboutLeoMenuItem,
	"&amp;About Leo...",
	"Show about dialog")</t>
<t tx="T310">def createMenuBar(self):
	
	menuBar = wx.wxMenuBar()
	
	self.menuShortcuts = []
	if 0: # not ready yet: methods in tables must be defined
		&lt;&lt; create the file menu &gt;&gt;
		&lt;&lt; create the edit menu &gt;&gt;
		&lt;&lt; create the outline menu &gt;&gt;
		doHook("create-optional-menus",c=c)
		&lt;&lt; create the window menu &gt;&gt;
	&lt;&lt; create the help menu &gt;&gt;

	if 0:
		menuBar.Append(fileMenu, "&amp;File")
		menuBar.Append(editMenu, "&amp;Edit")
		menuBar.Append(outlineMenu, "&amp;Outline")
		menuBar.Append(windowMenu, "&amp;Window")
		
	menuBar.Append(helpMenu, "&amp;Help")
	self.SetMenuBar(menuBar)  # attach the menu bar to the frame
	
	# app().menuWarningsGiven = true</t>
<t tx="T311">editMenu = self.createNewMenu("&amp;Edit")
&lt;&lt; create the first top-level edit entries &gt;&gt;
&lt;&lt; create the edit body submenu &gt;&gt;
&lt;&lt; create the edit headline submenu &gt;&gt;
&lt;&lt; create the find submenu &gt;&gt;
&lt;&lt; create the last top-level edit entries &gt;&gt;
</t>
<t tx="T312">table = (
	("Can't Undo","Ctrl+Z",self.OnUndo), # &amp;U reserved for Undo
	("Can't Redo","Shift+Ctrl+Z",self.OnRedo), # &amp;R reserved for Redo
	("-",None,None),
	("Cu&amp;t","Ctrl+X",self.OnCutFromMenu), 
	("Cop&amp;y","Ctrl+C",self.OnCopyFromMenu),
	("&amp;Paste","Ctrl+V",self.OnPasteFromMenu),
	("&amp;Delete",None,self.OnDelete),
	("Select &amp;All","Ctrl+A",self.OnSelectAll),
	("-",None,None))

self.createMenuEntries(editMenu,table)
</t>
<t tx="T313">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

table = (
	("Extract &amp;Section","Shift+Ctrl+E",self.OnExtractSection),
	("Extract &amp;Names","Shift+Ctrl+N",self.OnExtractNames),
	("&amp;Extract","Shift+Ctrl+D",self.OnExtract),
	("-",None,None),
	("Convert All B&amp;lanks",None,self.OnConvertAllBlanks),
	("Convert All T&amp;abs",None,self.OnConvertAllTabs),
	("Convert &amp;Blanks","Shift+Ctrl+B",self.OnConvertBlanks),
	("Convert &amp;Tabs","Shift+Ctrl+J",self.OnConvertTabs),
	("Insert Body Time/&amp;Date","Shift+Ctrl+G",self.OnInsertBodyTime),
	("&amp;Reformat Paragraph","Shift+Ctrl+P",self.OnReformatParagraph),
	("-",None,None),
	("&amp;Indent","Ctrl+]",self.OnIndent),
	("&amp;Unindent","Ctrl+[",self.OnDedent),
	("&amp;Match Brackets","Ctrl+K",self.OnFindMatchingBracket))
	
self.createMenuEntries(editBodyMenu,table)

</t>
<t tx="T314">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

table = (
	("Edit &amp;Headline","Ctrl+H",self.OnEditHeadline),
	("&amp;End Edit Headline","Escape",self.OnEndEditHeadline),
	("&amp;Abort Edit Headline","Shift-Escape",self.OnAbortEditHeadline),
	("Insert Headline Time/&amp;Date","Shift+Ctrl+H",self.OnInsertHeadlineTime))
	
	# 5/16/03 EKR: I dislike this command.
	#("Toggle Angle Brackets","Ctrl+B",self.OnToggleAngleBrackets)
	
self.createMenuEntries(editHeadlineMenu,table)

</t>
<t tx="T315">findMenu = self.createNewMenu("&amp;Find...","Edit")

table = (
	("&amp;Find Panel","Ctrl+F",self.OnFindPanel),
	("-",None,None),
	("Find &amp;Next","F3",self.OnFindNext),
	("Find &amp;Previous","F4",self.OnFindPrevious),
	("&amp;Replace","Ctrl+=",self.OnReplace),
	("Replace, &amp;Then Find","Ctrl+-",self.OnReplaceThenFind))

self.createMenuEntries(findMenu,table)
</t>
<t tx="T316">label = choose(c.tree.colorizer.showInvisibles,"Hide In&amp;visibles","Show In&amp;visibles")

table = (
	("&amp;Go To Line Number","Alt+G",self.OnGoToLineNumber),
	("&amp;Execute Script","Alt+Shift+E",self.OnExecuteScript),
	("Set Fon&amp;t...","Shift+Alt+T",self.OnFontPanel),
	("Set &amp;Colors...","Shift+Alt+C",self.OnColorPanel),
	(label,"Alt+V",self.OnViewAllCharacters),
	("-",None,None),
	("Prefere&amp;nces","Ctrl+Y",self.OnPreferences))

self.createMenuEntries(editMenu,table)</t>
<t tx="T317">fileMenu = self.createNewMenu("&amp;File")
&lt;&lt; create the top-level file entries &gt;&gt;
&lt;&lt; create the recent files submenu &gt;&gt;
fileMenu.add_separator()
&lt;&lt; create the read/write submenu &gt;&gt;
&lt;&lt; create the tangle submenu &gt;&gt;
&lt;&lt; create the untangle submenu &gt;&gt;
&lt;&lt; create the import submenu &gt;&gt;
&lt;&lt; create the export submenu &gt;&gt;
fileMenu.add_separator()
# Create the last entries.
exitTable = (("E&amp;xit","Ctrl-Q",self.OnQuit),)
self.createMenuEntries(fileMenu,exitTable)

</t>
<t tx="T318">@ leo.py will probably never have a Print command.  Instead, export text files that may be formatted and printed as desired.
@c

table = (
	("&amp;New","Ctrl+N",self.OnNew),
	("&amp;Open...","Ctrl+O",self.OnOpen))
self.createMenuEntries(fileMenu,table)

# 7/1/03: Create a new menu rather than call OnOpenWith.
self.createNewMenu("Open &amp;With...","File")

table = (
	("-",None,None),
	("&amp;Close","Ctrl+W",self.OnClose),
	("&amp;Save","Ctrl+S",self.OnSave),
	("Save &amp;As","Shift+Ctrl+S",self.OnSaveAs),
	("Save To",None,self.OnSaveTo), # &amp;Tangle
	("Re&amp;vert To Saved",None,self.OnRevert)) # &amp;Read/Write
self.createMenuEntries(fileMenu,table)</t>
<t tx="T319">recentFilesMenu = self.createNewMenu("Recent &amp;Files...","File")
self.recentFiles = app().config.getRecentFiles()
self.createRecentFilesMenuItems()

</t>
<t tx="T320">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

table = [
		("&amp;Read Outline Only","Shift+Ctrl+R",self.OnReadOutlineOnly),
		("Read @file &amp;Nodes",None,self.OnReadAtFileNodes),
		("-",None,None),
		("Write &amp;Dirty @file Nodes","Shift+Ctrl+Q",self.OnWriteDirtyAtFileNodes),
		("Write &amp;Missing @file Nodes",None,self.OnWriteMissingAtFileNodes),
		("Write &amp;Outline Only",None,self.OnWriteOutlineOnly),
		("&amp;Write @file Nodes","Shift+Ctrl+W",self.OnWriteAtFileNodes)]

self.createMenuEntries(readWriteMenu,table)</t>
<t tx="T321">tangleMenu = self.createNewMenu("&amp;Tangle...","File")

table = (
	("Tangle &amp;All","Shift+Ctrl+A",self.OnTangleAll),
	("Tangle &amp;Marked","Shift+Ctrl+M",self.OnTangleMarked),
	("&amp;Tangle","Shift+Ctrl+T",self.OnTangle))

self.createMenuEntries(tangleMenu,table)

</t>
<t tx="T322">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

table = (
	("Untangle &amp;All",None,self.OnUntangleAll),
	("Untangle &amp;Marked",None,self.OnUntangleMarked),
	("&amp;Untangle","Shift+Ctrl+U",self.OnUntangle))
	
self.createMenuEntries(untangleMenu,table)

</t>
<t tx="T323">importMenu = self.createNewMenu("&amp;Import...","File")

table = (
	("Import To @&amp;file","Shift+Ctrl+F",self.OnImportAtFile),
	("Import To @&amp;root",None,self.OnImportAtRoot),
	("Import &amp;CWEB Files",None,self.OnImportCWEBFiles),
	("Import &amp;noweb Files",None,self.OnImportNowebFiles),
	("Import Flattened &amp;Outline",None,self.OnImportFlattenedOutline))

self.createMenuEntries(importMenu,table)

</t>
<t tx="T324">exportMenu = self.createNewMenu("&amp;Export...","File")

table = [
	("Export &amp;Headlines",None,self.OnExportHeadlines),
	("Outline To &amp;CWEB",None,self.OnOutlineToCWEB),
	("Outline To &amp;Noweb",None,self.OnOutlineToNoweb),
	("&amp;Flatten Outline",None,self.OnFlattenOutline),
	("&amp;Remove Sentinels",None,self.OnRemoveSentinels),
	("&amp;Weave",None,self.OnWeave)]

self.createMenuEntries(exportMenu,table)
</t>
<t tx="T325">outlineMenu = self.createNewMenu("&amp;Outline")
&lt;&lt; create top-level outline menu &gt;&gt;
&lt;&lt; create expand/contract submenu &gt;&gt;
&lt;&lt; create move submenu &gt;&gt;
&lt;&lt; create mark submenu &gt;&gt;
&lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="T326">table = (
	("C&amp;ut Node","Shift+Ctrl+X",self.OnCutNode),
	("C&amp;opy Node","Shift+Ctrl+C",self.OnCopyNode),
	("&amp;Paste Node","Shift+Ctrl+V",self.OnPasteNode),
	("&amp;Delete Node","Shift+Ctrl+BkSp",self.OnDeleteNode),
	("-",None,None),
	("&amp;Insert Node","Ctrl+I",self.OnInsertNode),
	("&amp;Clone Node","Ctrl+`",self.OnCloneNode),
	("Sort C&amp;hildren",None,self.OnSortChildren),
	("&amp;Sort Siblings","Alt-A",self.OnSortSiblings),
	("-",None,None))

self.createMenuEntries(outlineMenu,table)</t>
<t tx="T327">expandMenu = self.createNewMenu("&amp;Expand/Contract...","Outline")

table = (
	("&amp;Contract All","Alt+-",self.OnContractAll),
	("Contract &amp;Node","Alt+[",self.OnContractNode),
	("Contract &amp;Parent","Alt+0",self.OnContractParent),
	("-",None,None),
	("Expand P&amp;rev Level","Alt+.",self.OnExpandPrevLevel),
	("Expand N&amp;ext Level","Alt+=",self.OnExpandNextLevel),
	("-",None,None),
	("Expand To Level &amp;1","Alt+1",self.OnExpandToLevel1),
	("Expand To Level &amp;2","Alt+2",self.OnExpandToLevel2),
	("Expand To Level &amp;3","Alt+3",self.OnExpandToLevel3),
	("Expand To Level &amp;4","Alt+4",self.OnExpandToLevel4),
	("Expand To Level &amp;5","Alt+5",self.OnExpandToLevel5),
	("Expand To Level &amp;6","Alt+6",self.OnExpandToLevel6),
	("Expand To Level &amp;7","Alt+7",self.OnExpandToLevel7),
	("Expand To Level &amp;8","Alt+8",self.OnExpandToLevel8),
	# ("Expand To Level &amp;9","Alt+9",self.OnExpandToLevel9),
	("-",None,None),
	("Expand &amp;All","Alt+9",self.OnExpandAll),
	("Expand N&amp;ode","Alt+]",self.OnExpandNode))


self.createMenuEntries(expandMenu,table)</t>
<t tx="T328">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

table = (
	("Move &amp;Down", "Ctrl+D",self.OnMoveDown),
	("Move &amp;Left", "Ctrl+L",self.OnMoveLeft),
	("Move &amp;Right","Ctrl+R",self.OnMoveRight),
	("Move &amp;Up",   "Ctrl+U",self.OnMoveUp),
	("-",None,None),
	("&amp;Promote","Ctrl+{",self.OnPromote),
	("&amp;Demote", "Ctrl+}",self.OnDemote))
	
self.createMenuEntries(moveSelectMenu,table)
</t>
<t tx="T329">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

table = (
	("&amp;Mark","Ctrl-M",self.OnMark),
	("Mark &amp;Subheads","Alt+S",self.OnMarkSubheads),
	("Mark Changed &amp;Items","Alt+C",self.OnMarkChangedItems),
	("Mark Changed &amp;Roots","Alt+R",self.OnMarkChangedRoots),
	("Mark &amp;Clones","Alt+K",self.OnMarkClones),
	("&amp;Unmark All","Alt+U",self.OnUnmarkAll))
	
self.createMenuEntries(markMenu,table)
</t>
<t tx="T330">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

table = (
	("Go Back",None,self.OnGoPrevVisitedNode), # Usually use buttons for this.
	("Go Forward",None,self.OnGoNextVisitedNode),
	("-",None,None),
	("Go To Next &amp;Marked","Alt+M",self.OnGoToNextMarked),
	("Go To Next C&amp;hanged","Alt+D",self.OnGoToNextChanged),
	("Go To Next &amp;Clone","Alt+N",self.OnGoToNextClone),
	("-",None,None),
	("Go To &amp;First Node","Alt+Shift+G",self.OnGoToFirstNode),
	("Go To &amp;Last Node","Alt+Shift+H",self.OnGoToLastNode),
	("Go To &amp;Parent","Alt+Shift+P",self.OnGoToParent),
	("Go To P&amp;rev Sibling","Alt+Shift+R",self.OnGoToPrevSibling),
	("Go To Next &amp;Sibling","Alt+Shift+S",self.OnGoToNextSibling),
	("-",None,None),
	("Go To Prev V&amp;isible","Alt-UpArrow",self.OnGoPrevVisible),
	("Go To Next &amp;Visible","Alt-DnArrow",self.OnGoNextVisible),
	("Go To Prev Node","Alt-Shift+UpArrow",self.OnGoBack),
	("Go To Next Node","Alt-Shift-DnArrow",self.OnGoNext))
	
self.createMenuEntries(gotoMenu,table)
</t>
<t tx="T331">windowMenu = self.createNewMenu("&amp;Window")

table = (
	("&amp;Equal Sized Panes","Ctrl-E",self.OnEqualSizedPanes),
	("Toggle &amp;Active Pane","Ctrl-T",self.OnToggleActivePane),
	("Toggle &amp;Split Direction",None,self.OnToggleSplitDirection),
	("-",None,None),
	("Casca&amp;de",None,self.OnCascade),
	("&amp;Minimize All",None,self.OnMinimizeAll),
	("-",None,None),
	("Open &amp;Compare Window",None,self.OnOpenCompareWindow),
	("Open &amp;Python Window","Alt+P",self.OnOpenPythonWindow))

self.createMenuEntries(windowMenu,table)
</t>
<t tx="T332">helpMenu = self.createNewMenu("&amp;Help")

table = (
	("&amp;About Leo...",None,self.OnAbout),)
	#("Online &amp;Home Page",None,self.OnLeoHome),
	#("-",None,None),
	#("Open Online &amp;Tutorial",None,self.OnLeoTutorial))

self.createMenuEntries(helpMenu,table)

if 0: # not ready yet.

	if sys.platform=="win32":
		table = (("Open &amp;Offline Tutorial",None,self.OnLeoHelp),)
		self.createMenuEntries(helpMenu,table)
	
	table = (
		("Open Leo&amp;Docs.leo",None,self.OnLeoDocumentation),
		("-",None,None),
		("Open Leo&amp;Config.leo",None,self.OnLeoConfig),
		("Apply &amp;Settings",None,self.OnApplyConfig))

	self.createMenuEntries(helpMenu,table)</t>
<t tx="T333">def createNewMenu(self,name):
	
	return wx.wxMenu()</t>
<t tx="T334">@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=0):
	
	for label,accel,command in table:
		id = const(label)
		menu.Append(id,label,label)
		
		if 1:
			wx.EVT_MENU(self,id,command)

		else: # Doesn't help: methods must be defined in the table.
			def generalCommand(event=None,label=label):
				print "generalCommand",label # ,event
			wx.EVT_MENU(self,id,generalCommand)</t>
<t tx="T335">def OnAbout (self,event=None):
	
	print "OnAbout" # ,event</t>
<t tx="T336">const_dict = {}
const_lastVal = 100
	
def const(name):
	
	"""Return the wx id associated with name"""
	
	# Should this canonicalize the label?  Just remove '&amp;' ??
	
	id = const_dict.get(name)
	if id != None:
		return id
	else:
		global const_lastVal
		const_lastVal += 1
		return const_lastVal</t>
<t tx="T337">@ It is usually best not to catch exceptions in plugins.  doHook catches all exceptions and disables further calls to plugins.
@c</t>
<t tx="T338"></t>
<t tx="T339"></t>
<t tx="T340">"""Import cisco configuration files"""

from leoPlugins import *
from leoGlobals import *
import tkFileDialog

&lt;&lt; about this plugin &gt;&gt;
@others

if 0:
	
	if not app().gui:
		app().createTkGui()

	if app().gui.guiName() == "tkinter":

		registerHandler(("start2","open2","command2"), create_import_cisco_menu)

		__version__ = "1.3" # Set version for the plugin handler.
		plugin_signon(__name__)</t>
<t tx="T341">@ This plugin adds a menu item under the File-&gt;Import menu to import
Cisco configuration files.

The plugin will:

1) create a new node, under the current node, where the configuration will be
written. This node will typically have references to several sections (see below).

2) create sections (child nodes) for the indented blocks present in the original
config file. These child nodes will have sub-nodes grouping similar blocks (e.g.
there will be an 'interface' child node, with as many sub-nodes as there are real
interfaces in the configuration file).

3) create sections for the custom keywords specified in the customBlocks[] list in
importCiscoConfig(). You can modify this list to specify different keywords. DO
NOT put keywords that are followed by indented blocks (these are taken care of by
point 2 above). The negated form of the keywords (for example, if the keyword is
'service', the negated form is 'no service') is also included in the sections.

4) not display consecutive empty comment lines (lines with only a '!').

All created sections are alphabetically ordered.

Feedback on this plugin can be sent to Davide Salomoni (dsalomoni@yahoo.com).
</t>
<t tx="T342">def create_import_cisco_menu(tag, keywords):
	if	(tag=="open2" or
		(tag=="start2" and not keywords.has_key('c')) or
		(tag=="command2" and keywords.get("label")=="new")):

		c = top()
		importMenu = c.frame.getMenu('import')
		newEntries = (
			("-", None, None),
			("Import C&amp;isco Configuration", "Shift+Ctrl+I", importCiscoConfig))
		
		c.frame.createMenuEntries(importMenu, newEntries)</t>
<t tx="T343">def importCiscoConfig(event=None):
	c = top(); current = c.currentVnode()
	if current == None: return
	&lt;&lt; open file &gt;&gt;

	# define which additional child nodes will be created
	# these keywords must NOT be followed by indented blocks
	customBlocks = ['aaa','ip as-path','ip prefix-list','ip route',
					'ip community-list','access-list','snmp-server','ntp',
					'boot','service','logging']
	out = []
	blocks = {}
	children = []
	lines = len(linelist)
	i = 0
	skipToNextLine = 0
	# create level-0 and level-1 children
	while i&lt;(lines-1):
		for customLine in customBlocks:
			if (linelist[i].startswith(customLine) or
				linelist[i].startswith('no %s' % customLine)):
				&lt;&lt; process custom line &gt;&gt;
				skipToNextLine = 1
				break
		if skipToNextLine:
			skipToNextLine = 0
		else:
			if linelist[i+1].startswith(' '):
				&lt;&lt; process indented block &gt;&gt;
			else:
				out.append(linelist[i])
		i=i+1
	# process last line
	out.append(linelist[i])
	
	&lt;&lt; complete outline &gt;&gt;</t>
<t tx="T344">name = tkFileDialog.askopenfilename(
	title="Import Cisco Configuration File",
	filetypes=[("All files", "*")]
	)
if name == "":	return

v = current.insertAsNthChild(0)
c.beginUpdate()
v.setHeadString("cisco config: %s" % name)
c.endUpdate()

try:
	fh = open(name)
	es("importing: %s" % name)
	linelist = fh.read().splitlines()
	fh.close()
except IOError,msg:
	es("error reading %s: %s" % (name, msg))
	return</t>
<t tx="T345">if not blocks.has_key(customLine):
	blocks[customLine] = []
	out.append(angleBrackets(customLine))
	# create first-level child
	child = v.insertAsNthChild(0)
	child.setHeadStringOrHeadline(angleBrackets(customLine))
	children.append(child)

blocks[customLine].append(linelist[i])</t>
<t tx="T346">space = linelist[i].find(' ')
if space == -1:
	space = len(linelist[i])
key = linelist[i][:space]
if not blocks.has_key(key):
	blocks[key] = []
	out.append(angleBrackets(key))
	# create first-level child
	child = v.insertAsNthChild(0)
	child.setHeadStringOrHeadline(angleBrackets(key))
	children.append(child)

value = [linelist[i]]
# loop through the indented lines
i = i+1
try:
	while linelist[i].startswith(' '):
		value.append(linelist[i])
		i = i+1
except:
	# EOF
	pass
i = i-1 # restore index
# now add the value to the dictionary
blocks[key].append(value)</t>
<t tx="T347"># first print the level-0 text
outClean = []
prev = ''
for line in out:
	if line=='!' and prev=='!':
		pass # skip repeated comment lines
	else:
		outClean.append(line)
	prev = line
v.setBodyStringOrPane('\n'.join(outClean))

# scan through the created outline and add children
for child in children:
	# extract the key from the headline. Uhm... :)
	key = child.headString().split('&lt;&lt;'
		)[1].split('&gt;&gt;')[0].strip()
	if blocks.has_key(key):
		if type(blocks[key][0]) == type(''):
			# it's a string, no sub-children, so just print the text
			child.setBodyStringOrPane('\n'.join(blocks[key]))
		else:
			# it's a multi-level node
			for value in blocks[key]:
				# each value is a list containing the headline and then the text
				subchild = child.insertAsNthChild(0)
				subchild.setHeadStringOrHeadline(value[0])
				subchild.setBodyStringOrPane('\n'.join(value))
		child.sortChildren()
	else:
		# this should never happen
		es("Unknown key: %s" % key)
v.sortChildren()</t>
<t tx="T348">@ignore
@language plain
@comment !
@ This node has an example of a flat configuration file (i.e. just the output of a 
'show running' command on a cisco router), and of the same configuration file 
imported by the plugin.
</t>
<t tx="T349">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable
!
hostname rpr1
!
boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3
logging buffered 100000 debugging
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
!
controller SONET 1/0/0
 framing sdh
!
controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2
!
controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
!
interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast
!
interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex
!
interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex
!
interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.2
 no ip directed-broadcast
!
interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode
!
interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast
!
interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast
!
interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal
!
interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed
!
interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010
!
interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010
!
interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address
!
interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable
!
router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0
!
router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary
!
ip classless
ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3
ip bgp-community new-format
ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
logging facility local6
logging 10.10.10.1
access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any
route-map only permit 2
 match community 65001:2
 set origin igp
!
route-map only1 permit 10
 match community 1 65001:1
 set origin igp
!
route-map only3 permit 10
 match community 100
!
route-map tag_com permit 10
 match tag 1
 set community 65001:1
!
route-map tag_com permit 20
 match tag 3
 set community 65001:3
!
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware
line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0
!
ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer
end

rpr1#
</t>
<t tx="T350">rpr1#sh runn    
Building configuration...

Current configuration : 4927 bytes
!
! Last configuration change at 13:28:04 CET Wed Feb 19 2003
! NVRAM config last updated at 16:56:51 CET Fri Feb 14 2003
!
version 12.0
&lt;&lt;service&gt;&gt;
!
hostname rpr1
!
&lt;&lt;boot&gt;&gt;
&lt;&lt;logging&gt;&gt;
enable secret 5 somepassword
!
clock timezone CET 1
ip subnet-zero
ip cef
ip name-server 10.10.10.1
ip multicast-routing
ip ssh time-out 120
ip ssh authentication-retries 3
clns routing
frame-relay switching
!
&lt;&lt;controller&gt;&gt;
!
controller E1 5/0/2
!
controller E1 5/0/3
!
controller E1 5/0/4
!
controller E1 5/0/5
!
controller E1 5/0/6
!
controller E1 5/0/7
!
&lt;&lt;interface&gt;&gt;
!
&lt;&lt;router&gt;&gt;
!
ip classless
&lt;&lt;ip route&gt;&gt;
ip bgp-community new-format
&lt;&lt;ip community-list&gt;&gt;
ip ospf name-lookup
ip pim rp-address 192.168.4.1
ip pim send-rp-discovery scope 1
!
&lt;&lt;access-list&gt;&gt;
&lt;&lt;route-map&gt;&gt;
!
tacacs-server host 10.10.10.1
tacacs-server key somepassword
!
line con 0
&lt;&lt;line&gt;&gt;
!
&lt;&lt;ntp&gt;&gt;
end

rpr1#</t>
<t tx="T351">access-list 173 deny   ip 224.0.0.0 31.255.255.255 any
access-list 173 permit ip any any</t>
<t tx="T352">boot system flash rsp-k3pv-mz.120-21.S4.bin
boot system flash rsp-pv-mz.120-21.S1.bin
boot bootldr bootflash:rsp-boot-mz.120-11.S3</t>
<t tx="T353"></t>
<t tx="T354">controller E1 5/0/0
 framing NO-CRC4 
 clock source internal
 channel-group 1 timeslots 1
 channel-group 2 timeslots 2</t>
<t tx="T355">controller E1 5/0/1
 framing NO-CRC4 
 channel-group 0 timeslots 1</t>
<t tx="T356">controller SONET 1/0/0
 framing sdh</t>
<t tx="T357"></t>
<t tx="T358">interface Async1
 no ip address
 no ip directed-broadcast
 async mode interactive
 no peer default ip address</t>
<t tx="T359">interface Dialer0
 no ip address
 no ip directed-broadcast
 pulse-time 0
 no cdp enable</t>
<t tx="T360">interface FastEthernet0/0/0
 description *to 2600-1 via switch*
 bandwidth 10000
 ip address 192.168.3.1 255.255.255.0
 no ip directed-broadcast
 ip pim sparse-mode
 ip route-cache flow
 no ip route-cache distributed
 no ip mroute-cache
 delay 750
 full-duplex</t>
<t tx="T361">interface FastEthernet0/0/1
 description **trunk link**
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 full-duplex</t>
<t tx="T362">interface FastEthernet0/0/1.1
 encapsulation dot1Q 25
 ip address 192.168.25.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="T363">interface FastEthernet0/0/1.2
 no ip directed-broadcast</t>
<t tx="T364">interface FastEthernet0/0/1.3
 encapsulation dot1Q 3
 ip address 192.168.4.1 255.255.255.252
 ip access-group 173 in
 no ip directed-broadcast
 ip pim sparse-mode</t>
<t tx="T365">interface FastEthernet0/0/1.5
 encapsulation dot1Q 5
 ip address 192.168.5.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="T366">interface FastEthernet0/0/1.50
 description to KPN-test
 encapsulation dot1Q 50
 ip address 192.168.40.1 255.255.255.252
 no ip directed-broadcast</t>
<t tx="T367">interface Loopback0
 ip address 192.168.20.1 255.255.255.255
 no ip directed-broadcast</t>
<t tx="T368">interface POS4/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 loopback internal</t>
<t tx="T369">interface Serial5/0/0:1
 ip address 10.31.9.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="T370">interface Serial5/0/0:2
 ip address 10.10.10.1 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="T371">interface Serial5/0/1:0
 ip address 10.31.9.5 255.255.255.252
 no ip directed-broadcast
 no ip route-cache distributed</t>
<t tx="T372">interface Serial5/1/0
 no ip address
 no ip directed-broadcast
 no ip route-cache distributed
 no ip mroute-cache
 shutdown
 framing g751
 dsu bandwidth 34010</t>
<t tx="T373">interface Serial5/1/1
 ip address 192.168.6.1 255.255.255.252
 no ip directed-broadcast
 encapsulation frame-relay IETF
 no ip route-cache distributed
 no ip mroute-cache
 loopback local
 framing g751
 dsu bandwidth 34010</t>
<t tx="T374">ip community-list 1 permit 65001:1
ip community-list 100 permit 65001:3</t>
<t tx="T375">ip route 0.0.0.0 0.0.0.0 192.168.3.2 tag 3</t>
<t tx="T376"></t>
<t tx="T377">line aux 0
 transport input all
 stopbits 1
 flowcontrol hardware</t>
<t tx="T378">line vty 0 4
 exec-timeout 0 0
 password 7 somepassword
 logging synchronous
 login
 length 0</t>
<t tx="T379">logging buffered 100000 debugging
logging facility local6
logging 10.10.10.1</t>
<t tx="T380">ntp clock-period 17179348
ntp update-calendar
ntp peer 192.168.3.2 prefer</t>
<t tx="T381"></t>
<t tx="T382">route-map only permit 2
 match community 65001:2
 set origin igp</t>
<t tx="T383">route-map only1 permit 10
 match community 1 65001:1
 set origin igp</t>
<t tx="T384">route-map only3 permit 10
 match community 100</t>
<t tx="T385">route-map tag_com permit 10
 match tag 1
 set community 65001:1</t>
<t tx="T386">route-map tag_com permit 20
 match tag 3
 set community 65001:3</t>
<t tx="T387"></t>
<t tx="T388">router bgp 65001
 no synchronization
 redistribute static
 neighbor 192.168.3.2 remote-as 65000
 neighbor 192.168.3.2 remove-private-AS
 neighbor 192.168.3.3 remote-as 65002
 neighbor 192.168.3.3 next-hop-self
 neighbor 192.168.4.2 remote-as 65001 nlri unicast multicast
 neighbor 192.168.4.2 next-hop-self
 neighbor 192.168.4.2 default-originate
 neighbor 192.168.4.2 soft-reconfiguration inbound
 no auto-summary</t>
<t tx="T389">router ospf 1
 log-adjacency-changes
 passive-interface FastEthernet0/0/0
 network 192.168.3.1 0.0.0.0 area 0
 network 192.168.4.0 0.0.0.3 area 0</t>
<t tx="T390">no service pad
service timestamps debug datetime localtime show-timezone
service timestamps log datetime localtime show-timezone
service password-encryption
no service single-slot-reload-enable</t>
<t tx="T391">"""Modify the way exported outlines are displayed"""

from leoPlugins import *
from leoGlobals import *

def onStart (tag,keywords):
	import leoNodes
	funcToMethod(newMoreHead,leoNodes.vnode,"moreHead")

@others

if 0: # Register the handlers...
	registerHandler("start2", onStart)
	
	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T392"># Returns the headline string in MORE format.

def newMoreHead (self,firstLevel,useVerticalBar=true):

	useVerticalBar = true # Force the vertical bar

	v = self
	level = self.level() - firstLevel
	if level &gt; 0:
		if useVerticalBar:
			s = " |\t" * level
		else:
			s = "\t"
	else:
		s = ""
	s += choose(v.hasChildren(), "+ ", "- ")
	s += v.headString()
	return s
</t>
<t tx="T393"></t>
<t tx="T394">[Main]
active = Yes
interval = 600

</t>
<t tx="T395">"""Autosave the Leo document every so often"""

# By Paul Paterson.

from leoPlugins import *
from leoGlobals import *

import ConfigParser
import time, os

@others

if 0: # Register the handlers...

	AUTOSAVE_INTERVAL = 600
	ACTIVE = "Yes"
	LAST_AUTOSAVE = time.time()
	applyConfiguration()

	__version__ = "0.1"
	registerHandler("idle", autosave)
	es("auto save")
</t>
<t tx="T396">def applyConfiguration(config=None):
	
	"""Called when the user presses the "Apply" button on the Properties form"""

	global LAST_AUTOSAVE, ACTIVE, AUTOSAVE_INTERVAL

	if config is None:
		fileName = os.path.join(app().loadDir,"../","plugins","mod_autosave.ini")
		config = ConfigParser.ConfigParser()
		config.read(fileName)

	ACTIVE = config.get("Main", "Active")
	AUTOSAVE_INTERVAL = int(config.get("Main", "Interval"))</t>
<t tx="T397">def autosave(tag, keywords):
	
	"""Save the current document if it has a name"""

	global LAST_AUTOSAVE

	if ACTIVE == "Yes":
		if time.time() - LAST_AUTOSAVE &gt; AUTOSAVE_INTERVAL:
			f = top().frame
			if f.mFileName and f.commands.changed:
				es("Autosave: %s" % time.ctime())
				f.commands.fileCommands.save(f.mFileName)
			LAST_AUTOSAVE = time.time()</t>
<t tx="T398">"""Timestamp all save operations to show when they occur"""

# By Paul Paterson.

from leoPlugins import *
from leoGlobals import *

import time
	
@others

if 0: # Register the handlers...

	registerHandler("command1", timestamp)

	__version__ = "0.1" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T399">def timestamp(tag=None, keywords=None):
	
	cmd = keywords.get('label', 'save')

	if cmd.startswith("save") or cmd.startswith("tangle"):
		es("%s: %s" % (cmd, time.ctime()))
</t>
<t tx="T400"></t>
<t tx="T401">"""Dump globals at startup"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("start2", onStart)

	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T402">def onStart (tag,keywords):

	print "\nglobals..."
	for s in globals():
		if s not in __builtins__:
			print s
	
	print "\nlocals..."
	for s in locals():
		if s not in __builtins__:
			print s
</t>
<t tx="T403">"""Enable debugging for garbage collector"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("start2", onStart)
	
	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T404">def onStart (tag,keywords):

	try:
		import gc
		gc.set_debug(gc.DEBUG_LEAK)
	except: pass</t>
<t tx="T405">"""Trace changes to objects at idle time"""

from leoPlugins import *
from leoGlobals import *

def printIdleRefs(tag,keywords):
	printGcRefs(verbose=false)

def printIdleGC(tag,keywords):
	
	# Calling printGc is too expensive to do on every idle call.
	# Note: printGc only works if debugGc is true in leoGlobals.py.
	# At present, this code does _not_ set that constant.
	if tag == "idle":
		global count ; count += 1
		if (count % 20) == 0:
			# collectGarbage() # Has no effect.
			printGc(tag,onlyPrintChanges=true)
	else:
		printGc(tag,onlyPrintChanges=false)
		
if 0:
	registerHandler("command2", printIdleRefs)

if 0: # Register the handlers...

	count = 0 # For Pychecker: don't define this unless we are using this module.

	if 1: # Very effective.
		registerHandler("idle", printIdleGC)
	else: # Very precise.
		registerHandler("all", printIdleGC)
	
	__version__ = "1.2"
	plugin_signon(__name__)
</t>
<t tx="T406">"""Trace keystrokes in the outline and body panes"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler(("bodykey1","bodykey2","headkey1","headkey2"), onKey)
	
	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T407">def onKey (tag,keywords):

	ch = keywords.get("ch")
	if ch and len(ch) &gt; 0:
		es("key",`ch`)</t>
<t tx="T408">"""Trace most comment events, but not key, drag or idle events"""

from leoPlugins import *
from leoGlobals import *

tagCount = 0

@others

if 0: # Register the handlers...
	registerHandler("all", trace_tags)

	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T409">def trace_tags (tag,keywords):
	
	global tagCount # 8/28/03

	# Almost all tags have both c and v keys in the keywords dict.
	if tag not in ("start1","end1","open1","open2"):
		c = keywords.get("c")
		v = keywords.get("v")
		if not c:
			print tagCount,tag, "c = None"
		if not v:
			if tag not in ("select1","select2","unselect1","unselect2"):
				print tagCount,tag, "v = None"
	
	if tag not in (
		"bodykey1","bodykey2","dragging1","dragging2",
		"headkey1","headkey2","idle"):
	
		tagCount += 1 # Count all other hooks.
	
		if tag in ("command1","command2"):
			print tagCount,tag,keywords.get("label")
		elif tag in ("open1","open2"):
			print tagCount,tag,keywords.get("fileName")
		else:
			if 1: # Brief
				print tagCount,tag
			else: # Verbose
				keys = keywords.items()
				keys.sort()
				for key,value in keys:
					print tagCount,tag,key,value
				print</t>
<t tx="T410"></t>
<t tx="T411">"""Support new @direcives"""

from leoPlugins import *
from leoGlobals import *

if 1:
	directives = "markup", # A tuple with one string.
else:
	directives = ("markup","markup2")
	
@others

if 1: # Register the handlers...

	registerHandler("start1",addPluginDirectives)
	registerHandler("scan-directives",scanPluginDirectives)
	
	__version__ = "1.1"
	plugin_signon(__name__)</t>
<t tx="T412">def addPluginDirectives (tag,keywords):
	
	"""Add all new directives to globalDirectivesList"""
	
	global directives

	if 0:
		s = ""
		for d in directives:
			s += '@' + d + ' '
		es(s,color="blue")

	for d in directives:
		if d not in globalDirectiveList:
			globalDirectiveList.append(d)</t>
<t tx="T413">def scanPluginDirectives (tag, keywords):
	
	"""Add a tuple (d,v,s,k) to list for every directive d found"""
	
	global directives

	keys = ("c","v","s","old_dict","dict","pluginsList")
	c,v,s,old_dict,dict,pluginsList = [keywords.get(key) for key in keys]

	for d in directives:
		if not old_dict.has_key(d) and dict.has_key(d):
			# Point k at whatever follows the directive.
			k = dict[d]
			k += 1 + len(d) # Skip @directive
			k = skip_ws(s,k) # Skip whitespace
			# trace(`d`,`k`)
			pluginsList.append((d,v,s,k),)
</t>
<t tx="T414"></t>
<t tx="T415">"""Handle coloring for markup in doc parts and Python triple-double-quoted strings"""

from leoPlugins import *
from leoGlobals import *
import string  # zfill does not exist in Python 2.2.1

@others

if 1: # Register the handlers...

	if not app().gui:
		app().createTkGui()

	if app().gui.guiName() == "tkinter":

		registerHandler("color-optional-markup", colorWikiMarkup)
		registerHandler("init-color-markup", initAnyMarkup)
	
		__version__ = "1.1"
		plugin_signon(__name__)</t>
<t tx="T416">def initAnyMarkup (tag,keywords):
	
	"""initialize colorer.markup_string
	
	The colorer completely recolors the body pane when this changes"""
	
	keys = ("colorer","v")
	colorer,v = [keywords.get(key) for key in keys]

	c = colorer.commands
	if not c or not v or not top(): return

	# trace()
	dict = scanDirectives(c,v=v) # v arg is essential.
	pluginsList = dict.get("pluginsList")
	
	if pluginsList:
		for d,v,s,k in pluginsList:
			if d == "markup":
				kind = s[k:]
				if kind:
					colorer.markup_string = kind
					return
					
	colorer.markup_string = "unknown" # default</t>
<t tx="T417">colorCount = 0

def colorWikiMarkup (tag,keywords):

	keys = ("colorer","v","s","i","j","colortag")
	colorer,v,s,i,j,colortag = [keywords.get(key) for key in keys]

	global colorCount ; colorCount += 1
	
	c = colorer.commands
	dict = scanDirectives(c,v=v) # v arg is essential.
	pluginsList = dict.get("pluginsList")
	
	if pluginsList:
		for d,v,s2,k in pluginsList:
			if d == "markup":
				# trace(`colorCount`,`d`)
				if match_word(s2,k,"wiki"):
					doWikiText(colorer,v,s,i,j,colortag)
					return true # We have colored the text.
			
	# trace(`colorCount`,"no markup")
	return None # We have not colored the text.</t>
<t tx="T418">def doWikiText (colorer,v,s,i,end,colortag):

	firsti = i ; inserted = 0

	while i &lt; end:
		&lt;&lt; set first to a tuple describing the first tag to be handled &gt;&gt;
		if first:
			tag,n1,n2,delim1,delim2 = first
			i = n2 + len(delim2)
			&lt;&lt; handle the tag using n1,n2,delim1,delim2 &gt;&gt;
		else: i = end
		
	colorer.tag(colortag,firsti,end+inserted)</t>
<t tx="T419">first = None

for tag,delim1,delim2 in (
	("bold","__","__"),
	("italic","''","''"),
	("picture","{picture file=","}"),
	("color","~~","~~")):
	n1 = s.find(delim1,i,end)
	if n1 &gt; -1:
		n2 = s.find(delim2,n1+len(delim1),end)
		if n2 &gt; -1:
			if not first or (first and n1 &lt; first[1]):
				first = tag,n1,n2,delim1,delim2
</t>
<t tx="T420">if tag =="picture":
	colorer.tag("elide",n1,n2+len(delim2)) # Elide everything.
	filename = s[n1+len(delim1):n2]
	filename = os.path.join(app().loadDir,filename)
	filename = os.path.normpath(filename)
	inserted += insertWikiPicture(colorer,filename,n2+len(delim2))
elif tag == "color":
	&lt;&lt; parse and handle color field &gt;&gt;
else:
	# look for nested bold or italic.
	if tag == "bold":
		delim3,delim4 = "''","''" # Look for nested italic.
	else:
		delim3,delim4 = "__","__" # Look for nested bold.
	n3 = s.find(delim3,n1+len(delim1),n2) ; n4 = -1
	if n3 &gt; -1:
		n4 = s.find(delim4,n3+len(delim3),n2+len(delim2))
	if n3 &gt; -1 and n4 &gt; -1:
		colorer.tag("elide",n1,n1+len(delim1))
		colorer.tag("elide",n2,n2+len(delim2))
		colorer.tag("elide",n3,n3+len(delim3))
		colorer.tag("elide",n4,n4+len(delim4))
		colorer.tag(tag,n1+len(delim1),n3)
		colorer.tag("bolditalic",n3+len(delim3),n4)
		colorer.tag(tag,n4+len(delim4),n2)
	else:
		# No nested tag.
		colorer.tag("elide",n1,n1+len(delim1))
		colorer.tag("elide",n2,n2+len(delim2))
		colorer.tag(tag,n1+len(delim1),n2)</t>
<t tx="T421"># Parse the color value.
j = n1+len(delim1)
n = s.find(":",j,n2)
if n2 &gt; n &gt; j &gt; -1:
	name = s[j:n]
	if name[0] == '#' and len(name) &gt; 1:
		name = '#' + string.zfill(name[1:],6)
	if name in colorer.color_tags_list:
		colorer.tag("elide",n1,n+1)
		colorer.tag(name,n+1,n2)
		colorer.tag("elide",n2,n2+len(delim2))
	else:
		try:
			# print "entering", name
			colorer.body.tag_configure(name,foreground=name)
			colorer.color_tags_list.append(name)
			colorer.tag("elide",n1,n+1)
			colorer.tag(name,n+1,n2)
			colorer.tag("elide",n2,n2+len(delim2))
		except: # an invalid color name: elide nothing.
			pass # es_exception()</t>
<t tx="T422">def insertWikiPicture (colorer,filename,i):
	
	"""Try to insert a picture with the give filename.
	
	Returns the number of characters actually inserted"""
	
	# trace(`colorer.color_pass`)
	if colorer.color_pass == 0:
		colorer.redoColoring = true # schedule a two-pass recoloring.
		return 0
		
	if colorer.color_pass == 2:
		return 0 # The second redo pass.
		
	# trace(`filename`,`v`)
	if not os.path.exists(filename):
		return 0

	try:
		# Create the image
		photo = Tkinter.PhotoImage(master=app().root, file=filename)
		image = colorer.body.image_create(colorer.index(i),image=photo,padx=0)
		
		# Keep references so images stay on the canvas.
		colorer.image_references.append((photo,image,colorer.line_index,i),)
		return 1
	except:
		es_exception()
		return 0</t>
<t tx="T423">"""Handle images in body text"""

from leoPlugins import *
from leoGlobals import *

@others

if 1: # Register the handlers...

	if app().gui == None:
		app().createTkGui()

	if app().gui.guiName() == "tkinter":
		
		registerHandler("select2", onSelect)
		registerHandler("unselect1", onUnselect)
		
		__version__ = "1.2" # Set version for the plugin handler.
		plugin_signon(__name__)
</t>
<t tx="T424">def onSelect (tag,keywords):

	import Tkinter,os

	new_v = keywords.get("new_v")
	h = new_v.headString()
	if h[:7] == "@image ":
		filename = h[7:]
		&lt;&lt; Select Image &gt;&gt;</t>
<t tx="T425"># Display the image file in the text pane, if you can find the file
a = app()
c = keywords.get("c")
body = c.frame.body

if os.path.isfile(filename):
	try:
		# Note that Tkinter only understands GIF
		photo = Tkinter.PhotoImage(master=a.root, file=filename)
	except:
		es("error: cannot load image")
		return
	# Nicely display the image at the center top and push the text below.
	a.gsphoto = photo # This is soooo important.
	photoWidth = photo.width()
	bodyWidth = body.winfo_width()
	padding = int((bodyWidth - photoWidth - 16) / 2)
	padding = max(0,padding)
	a.gsimage = body.image_create("1.0",image=photo,padx=padding)
else:
	es("warning: missing image file")</t>
<t tx="T426">def onUnselect (tag,keywords):

	import Tkinter, os.path

	a = app()
	old_v = keywords.get("old_v")
	if old_v:
		h = old_v.headString()
		if h[:7] == "@image ":
			&lt;&lt; Unselect Image &gt;&gt;
	else: # Leo is initializing.
		a.gsphoto = None # Holds our photo file
		a.gsimage = None # Holds our image instance within the text pane</t>
<t tx="T427"># Erase image if it was previously displayed
a = app() ; c = keywords.get("c")

if a.gsimage:
	try:
		 c.frame.body.delete(a.gsimage)
	except:
		es("info: no image to erase")

# And forget about it
a.gsimage = None
a.gsphoto = None
</t>
<t tx="T428">"""Adds navigation buttons to icon bar"""

from leoPlugins import *
from leoGlobals import *
from leoDialog import listBoxDialog
import os, Tkinter

@others
	
globalInfo = globalInfoClass()

Tk = Tkinter

if 1: # Register the handlers...

	if app().gui == None:
		app().createTkGui()

	if app().gui.guiName() == "tkinter":

		registerHandler("after-create-leo-frame", globalInfo.addNavWidgets)
		registerHandler("select2",globalInfo.updateRecentSections)
		registerHandler("command2",globalInfo.updateMarksAfterCommand)
		registerHandler(("set-mark","clear-mark"),globalInfo.updateMarks)
		registerHandler("close-frame",globalInfo.destroyFrame)
		registerHandler("destroy-all-global-windows",globalInfo.destroyAllFrames)
	
		# 7/12/03: Moved marksDialog and recentSectionsDialog into this plugin.
		# 7/12/03: Handled "set-mark" and "clear-mark" hooks.
		__version__ = "1.2"
		plugin_signon(__name__)</t>
<t tx="T429">class commanderInfoClass:
	@others</t>
<t tx="T430">def __init__ (self,c,globalInfo):
	
	self.c = c
	self.globalInfo = globalInfo
	
	# The icon frame in c.
	self.iconFrame = c.frame.iconFrame
	
	# Dialogs.
	self.marksDialog = None
	self.recentSectionsDialog = None

	# Images for arrow buttons.
	self.lt_nav_disabled_image = self.lt_nav_enabled_image = None
	self.rt_nav_disabled_image = self.rt_nav_enabled_image = None
	
	# The arrow and text buttons.
	self.lt_nav_button = self.rt_nav_button = None
	sections_button = self.marks_button = None
	
	self.nav_buttons = None
</t>
<t tx="T431">def addWidgets (self):
	
	c = self.c ; d = self
	
	d.lt_nav_disabled_image = self.createImage("../Icons/lt_arrow_disabled.gif")
	d.lt_nav_enabled_image  = self.createImage("../Icons/lt_arrow_enabled.gif")
	
	d.rt_nav_disabled_image = self.createImage("../Icons/rt_arrow_disabled.gif")
	d.rt_nav_enabled_image  = self.createImage("../Icons/rt_arrow_enabled.gif")
	
	for image in (
		self.lt_nav_disabled_image, self.lt_nav_enabled_image,
		self.rt_nav_disabled_image, self.rt_nav_enabled_image):
		if not image:
			return
	
	# It's so nice to be able to add ivars to classes at any time!
	self.lt_nav_button = c.frame.addIconButton(
		image=self.lt_nav_disabled_image,
		command=c.frame.OnGoPrevVisitedNode)
		
	&lt;&lt; define callbacks &gt;&gt;

	self.sections_button = c.frame.addIconButton(
		text="Recent",command=onRecentButton)
		
	self.marks_button = c.frame.addIconButton(
		text="Marks",command=onMarksButton)
	
	self.rt_nav_button = c.frame.addIconButton(
		image=self.rt_nav_disabled_image,
		command=c.frame.OnGoNextVisitedNode)
		
	# Don't dim the button when it is inactive.
	for b in (self.lt_nav_button,self.rt_nav_button):
		fg = b.cget("foreground")
		b.configure(disabledforeground=fg)
		
	# Package these buttons for the recentSectionsDialog class in leoDialog.py
	self.nav_buttons = (self.lt_nav_button, self.rt_nav_button)</t>
<t tx="T432"># These are functions, not methods, so we must bind self at definition time.

def onMarksButton(self=self):

	self.marksButtonCallback()
	
def onRecentButton(self=self):

	self.recentButtonCallback()</t>
<t tx="T433">def createImage (self,path):
	
	path = os.path.join(app().loadDir,path)
	path = os.path.normpath(path)
	
	try:
		image = Tkinter.PhotoImage(master=app().root,file=path)
	except:
		es("can not load icon: " + shortFileName(path))
		image = None
	return image

</t>
<t tx="T434">def updateNavButtons (self):	

	d = self ; c = self.c
	
	# Make sure we have initialized properly.
	if not hasattr(d,"lt_nav_button") or not hasattr(d,"rt_nav_button"):
		return
		
	if not d.lt_nav_button or not d.rt_nav_button: # 6/30/03
		return
	
	b = d.lt_nav_button
	if c.beadPointer &gt; 0:
		image = self.lt_nav_enabled_image
		state = "normal"
	else:
		image = d.lt_nav_disabled_image
		state = "normal" # "disabled" makes the icon look bad.
	b.configure(image=image,state=state)
	
	b = d.rt_nav_button
	if c.beadPointer + 1 &lt; len(c.beadList):
		image =self.rt_nav_enabled_image
		state = "normal"
	else:
		image = self.rt_nav_disabled_image
		state = "normal" # "disabled" makes the icon look bad.
	b.configure(image=image,state=state)
</t>
<t tx="T435"></t>
<t tx="T436">def marksButtonCallback(self,event=None):
	
	c = self.c ; d = self.marksDialog

	if d:
		d.top.deiconify()
	else:
		# Create and run the dialog.
		title = "Marks"
		label = "Marks: " + shortFileName(c.frame.mFileName)
		d = marksDialog(c,title,label)
		self.marksDialog = d
		d.root.wait_window(d.top)
</t>
<t tx="T437">def recentButtonCallback(self,event=None):
	
	c = self.c ; d = self.recentSectionsDialog
	
	if d:
		d.top.deiconify()
		d.fillbox()
	else:
		# Create and run the dialog.]
		title = "Recent Nodes"
		label = "Recent nodes: " + shortFileName(c.frame.mFileName)
		d = recentSectionsDialog(c,self.nav_buttons,title,label)
		self.recentSectionsDialog = d
		d.root.wait_window(d.top)
</t>
<t tx="T438">class globalInfoClass:
	@others</t>
<t tx="T439">def __init__ (self):
	
	self.commanderInfo = {} # keys are commanders, values are navCommanderInfo objects
</t>
<t tx="T440">def addNavWidgets(self,tag,keywords):
	
	c = keywords.get("c")
	
	# Create the commanderInfo object.
	d = commanderInfoClass(c,self)
	self.commanderInfo[c] = d
	
	# Add the widgets.
	d.addWidgets()
	
</t>
<t tx="T441">def destroyAllFrames(self,tag,keywords):
	
	for d in self.commanderInfo.values():
		self.destroyOneFrame(d)
		
def destroyFrame(self,tag,keywords):

	c = keywords.get("c")
	d = self.commanderInfo.get(c)
	if d:
		self.destroyOneFrame(d)
		
def destroyOneFrame(self,d):

	if d.marksDialog:
		d.marksDialog.top.destroy()
	if d.recentSectionsDialog:
		d.recentSectionsDialog.top.destroy()
	del self.commanderInfo[d.c]</t>
<t tx="T442">def updateRecentSections (self,tag,keywords):
	
	c = keywords.get("c")
	info = self.commanderInfo.get(c)

	if info:
		info.updateNavButtons()
		d = info.recentSectionsDialog
		if d:
			d.fillbox()
</t>
<t tx="T443">def updateMarksAfterCommand (self,tag,keywords):
	
	"""Update the marks dialog when a new window is opened."""
	
	name = keywords.get("label")
	
	if name and name.lower() in ("open","new"):
		self.updateMarks(tag,keywords)
	
def updateMarks (self,tag,keywords):
	
	"""Update the marks dialog."""
	
	c = keywords.get("c")
	# trace()
	info = self.commanderInfo.get(c)
	if info and info.marksDialog:
		info.marksDialog.fillbox()</t>
<t tx="T444">def updateNavButtons (self,tag,keywords):

	"""Update the colors of c's nav buttons"""
	
	c = keywords.get("c")
	info = self.commanderInfo.get(c)
	
	if info:
		info.updateNavButtons()
</t>
<t tx="T445">class marksDialog (listBoxDialog):
	
	"""A class to create the marks dialog"""

	@others</t>
<t tx="T446">def __init__ (self,c,title,label):
	
	"""Create a Marks listbox dialog."""

	listBoxDialog.__init__(self,c,title,label)
</t>
<t tx="T447">def createFrame(self):
	
	"""Create the frame for a Marks listbox dialog."""

	listBoxDialog.createFrame(self)
	self.addButtons()</t>
<t tx="T448">def addButtons (self):
	
	"""Add buttons to a Marks listbox dialog."""
	
	f = Tk.Frame(self.outerFrame)
	f.pack()
	self.addStdButtons(f)</t>
<t tx="T449">def fillbox(self,event=None):

	"""Update a Marks listbox dialog and update the listbox and update vnodeList &amp; tnodeList ivars"""

	self.box.delete(0,"end")
	self.vnodeList = []
	self.tnodeList = []

	# Make sure the node still exists.
	# Insert only the last cloned node.
	c = self.c ; v = c.rootVnode()
	i = 0
	while v:
		if v.isMarked() and v.t not in self.tnodeList:
			self.box.insert(i,v.headString().strip())
			self.tnodeList.append(v.t)
			self.vnodeList.append(v)
			i += 1
		v = v.threadNext()</t>
<t tx="T450">class recentSectionsDialog (listBoxDialog):
	
	"""A class to create the recent sections dialog"""

	@others</t>
<t tx="T451">def __init__ (self,c,buttons,title,label):
	
	"""Create a Recent Sections listbox dialog."""
	
	self.lt_nav_iconFrame_button, self.rt_nav_iconFrame_button = buttons

	listBoxDialog.__init__(self,c,title,label)

</t>
<t tx="T452">def addButtons (self):
	
	"""Add buttons for a Recent Sections listbox dialog."""

	self.buttonFrame = f = Tk.Frame(self.outerFrame)
	f.pack()
	
	row1 = Tk.Frame(f)
	row1.pack()
	
	# Create the back and forward buttons, cloning the images &amp; commands of the already existing buttons.
	image   = self.lt_nav_iconFrame_button.cget("image")
	command = self.lt_nav_iconFrame_button.cget("command")

	self.lt_nav_button = b = Tk.Button(row1,image=image,command=command)
	b.pack(side="left",pady=2,padx=5)
	
	image   = self.rt_nav_iconFrame_button.cget("image")
	command = self.rt_nav_iconFrame_button.cget("command")

	self.rt_nav_button = b = Tk.Button(row1,image=image,command=command)
	b.pack(side="left",pady=2,padx=5)
	
	row2 = Tk.Frame(f)
	row2.pack()
	self.addStdButtons(row2)
	
	row3 = Tk.Frame(f)
	row3.pack()
	
	self.clear_button = b =  Tk.Button(row3,text="Clear All",
		width=6,command=self.clearAll)
	b.pack(side="left",pady=2,padx=5)
	
	self.delete_button = b =  Tk.Button(row3,text="Delete",
		width=6,command=self.deleteEntry)
	b.pack(side="left",pady=2,padx=5)
</t>
<t tx="T453">def clearAll (self,event=None):

	"""Handle clicks in the "Delete" button of the Recent Sections listbox dialog."""

	self.c.visitedList = []
	self.vnodeList = []
	self.fillbox()
</t>
<t tx="T454">def createFrame(self):
	
	"""Create the frame of a Recent Sections listbox dialog."""
	
	listBoxDialog.createFrame(self)	
	self.addButtons()
</t>
<t tx="T455">def deleteEntry (self,event=None):

	"""Handle clicks in the "Delete" button of a Recent Sections listbox dialog."""
	
	c = self.c ; box = self.box
	
	# Work around an old Python bug.  Convert strings to ints.
	items = box.curselection()
	try:
		items = map(int, items)
	except ValueError: pass

	if items:
		n = items[0]
		v = self.vnodeList[n]
		del self.vnodeList[n]
		if v in c.visitedList:
			c.visitedList.remove(v)
		self.fillbox()
</t>
<t tx="T456">def destroy (self,event=None):
	
	"""Hide a Recent Sections listbox dialog and mark it inactive.
	
	This is an escape from possible performace penalties"""
		
	# This is enough to disable fillbox.
	self.top.withdraw()
</t>
<t tx="T457">def fillbox(self,event=None):

	"""Update a Recent Sections listbox dialog and update vnodeList &amp; tnodeList ivars"""

	# Only fill the box if the dialog is visible.
	# This is an important protection against bad performance.

	if self.top.state() == "normal":
		&lt;&lt; reconstruct the contents of self.box &gt;&gt;
		self.synchButtons()</t>
<t tx="T458">c = self.c

self.box.delete(0,"end")
self.vnodeList = []
self.tnodeList = []

# Make sure the node still exists.
# Insert only the last cloned node.
i = 0
for v in c.visitedList:
	if v.exists(self.c) and v.t not in self.tnodeList:
		self.box.insert(i,v.headString().strip())
		self.tnodeList.append(v.t)
		self.vnodeList.append(v)
		i += 1
</t>
<t tx="T459">def synchButtons (self):
	
	"""Synchronize the arrow boxes of a Recent Sections listbox dialog."""

	image = self.lt_nav_iconFrame_button.cget("image")
	self.lt_nav_button.configure(image=image)
	
	image = self.rt_nav_iconFrame_button.cget("image")
	self.rt_nav_button.configure(image=image)</t>
<t tx="T460"></t>
<t tx="T461">"""Create menu for Open With command and handle the resulting commands"""

from leoPlugins import *
from leoGlobals import *

@others

if 1: # Register the handlers...

	app().hasOpenWithMenu = true
	registerHandler("idle", on_idle)
	registerHandler(("start2","open2","command2"), create_open_with_menu)

	__version__ = "1.4" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T462"># frame.OnOpenWith creates the dict with the following entries:
# "body", "c", "encoding", "f", "path", "time" and "v".

def on_idle (tag,keywords):

	import os
	a = app()
	for dict in a.openWithFiles:
		path = dict.get("path")
		c = dict.get("c")
		encoding = dict.get("encoding",None)
		v = dict.get("v")
		old_body = dict.get("body")
		if path and os.path.exists(path):
			try:
				time = os.path.getmtime(path)
				if time and time != dict.get("time"):
					dict["time"] = time # inhibit endless dialog loop.
					# The file has changed.
					&lt;&lt; update v's body text &gt;&gt;
			except:
				es_exception() ## testing
				pass</t>
<t tx="T463">&lt;&lt; set s to the file text &gt;&gt;

# Convert body to whatever encoding is in effect.
body = v.bodyString()
body = toEncodedString(body,encoding,reportErrors=true)

conflict = body != old_body and body != s

# Set update if we should update the outline from the file.
if conflict:
	# See how the user wants to resolve the conflict.
	import leoDialog
	es("conflict in " + shortFileName(path),color="red")
	message = "Replace changed outline with external changes?"
	result = leoDialog.askYesNo("Conflict!",message).run(modal=true)
	update = result.lower() == "yes"
else:
	update = s != body

if update:
	es("updated from: " + shortFileName(path),color="blue")
	v.setBodyStringOrPane(s)
	c.selectVnode(v)
	dict["body"] = s
elif conflict:
	es("not updated from: " + shortFileName(path),color="blue")</t>
<t tx="T464">try:
	# Update v from the changed temp file.
	f=open(path)
	s=f.read()
	f.close()
except:
	es("can not open " + shortFileName(path))
	break
</t>
<t tx="T465">def create_open_with_menu (tag,keywords):

	if  (tag in ("start2","open2") or
		(tag=="command2" and keywords.get("label")=="new")):

		&lt;&lt; create the Open With menu &gt;&gt;
		# Enable the idle-time hook so we can check temp files created by Open With.
		from leoGlobals import enableIdleTimeHook
		enableIdleTimeHook(idleTimeDelay=500)
</t>
<t tx="T466">@ Entries in the following table are the tuple (commandName,shortcut,data).

- data is the tuple (command,arg,ext).
- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the extension ext,
Otherwise, Leo computes an extension based on what @language directive is in effect.
@c

idle_arg = "c:/python22/tools/idle/idle.py -e "

if 1: # Default table.
	table = (
		# Opening idle this way doesn't work so well.
		# ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
		("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
		("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
elif 1: # Test table.
	table = ("&amp;Word","Alt+Shift+W",("os.startfile",None,".doc")),
else: # David McNab's table.
	table = ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)),

top().frame.createOpenWithMenuFromTable(table)</t>
<t tx="T467">"""vim handler"""

# Contributed by Andrea Galimberti.

#  To use this plugin do the following:
#
# - Start VIM as server: vim --servername "VIM"
#   The name of the server *must* be "VIM".
#
# - Single-click on a node's icon to open that node in VIM.
#
# - Leo will update the node in the outline when you save the file in VIM.

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("iconclick2", open_in_vim)
	
	__version__ = "1.3" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T468">def open_in_vim (tag,keywords):
	if not top():
		return

	v=keywords['v']
	# Find dictionary with infos about this node
	this=filter(lambda x: id(x['v'])==id(v), app().openWithFiles)
	
	# Retrieve the name of the temporary file (if any).
	if this != []:
		path=this[0]['path']
	else:
		path=''

	if os.path.exists(path):
		# Get previous node contents.
		try:
			old=v.OpenWithOldBody
		except AttributeError:
			old=''

	if v.bodyString() != old:
		# delete old temp file
		os.remove(path)
		# remove old temp file from list
		app().openWithFiles=filter(lambda x: x['path']!=path,app().openWithFiles)
		# update old body with new contents
		v.OpenWithOldBody=v.bodyString()
		# open the node in vim (note the space after --remote)
		top().frame.OnOpenWith(("os.system", "vim --remote ", None),) # 6/27/03: add comma.</t>
<t tx="T469">"""emacs handler"""

from leoPlugins import *
from leoGlobals import *

# path = "/usr/bin/gnuclient"
path = r"c:\Program Files\XEmacs\XEmacs-21.4.13\i586-pc-win32\xemacs.exe"

def open_in_emacs (tag,keywords):
	if top():
		top().frame.OnOpenWith(("os.spawnl", path , None),) # 6/27/03: add comma.

if 0: # Register the handlers...
	registerHandler("iconclick2", open_in_emacs)
	if 0: # This edits _everything_ in xemacs.  That's a bit much for my taste.
		registerHandler("select2", open_in_emacs)
	
	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T470"></t>
<t tx="T471">"""Exports an outline to a word document.

Make sure word is running with an open (empty) document.

Click "plugins ... word export ... export"
to export the selected outline to Word."""

@language python

from leoPlugins import *
from leoGlobals import *

import win32com.client # From win32 extensions: http://www.python.org/windows/win32/
import ConfigParser

@others

if 1: # Register the handlers...

	# No hooks, we just use the cmd_Export to trigger an export
	__version__ = "0.1"
	__name__ = "Word Export"

	plugin_signon("word_export")</t>
<t tx="T472">def getConfiguration():
	
	"""Called when the user presses the "Apply" button on the Properties form"""

	fileName = os.path.join(app().loadDir,"../","plugins","word_export.ini")
	config = ConfigParser.ConfigParser()
	config.read(fileName)
	return config
</t>
<t tx="T473">def getWordConnection():
	
	"""Get a connection to Word"""

	es("Trying to connect to Word")
	try:
		word = win32com.client.Dispatch("Word.Application")
		return word
	except Exception, err:
		# es("Failed to connect to Word: %s", err)
		es("Failed to connect to Word",color="blue")
		es("Please make sure word is running with an open (empty) document.")
		return None</t>
<t tx="T474">def doPara(word, text, style=None):
	
	"""Write a paragraph to word"""
	
	doc = word.Documents(word.ActiveDocument)
	sel = word.Selection
	if style:
		try:
			sel.Style = doc.Styles(style)
		except:
			es("Unknown style: '%s'" % style)
	sel.TypeText(text)
	sel.TypeParagraph()</t>
<t tx="T475">def writeNodeAndTree(word, header_style, level, maxlevel=3, usesections=1, sectionhead="", vnode=None):
	
	"""Write a node and its children to Word"""

	commands = top().frame.commands
	if vnode is None:
		vnode = top().currentVnode()
	#
	dict = scanDirectives(commands,v=vnode)
	encoding = dict.get("encoding",None)
	if encoding == None:
		encoding = app().config.default_derived_file_encoding
	# 
	s = vnode.bodyString()
	s = toEncodedString(s,encoding,reportErrors=true)
	doPara(word, s)
	#
	for i in range(vnode.numberOfChildren()):
		if usesections:
			thishead = "%s%d." % (sectionhead, i+1)
		else:
			thishead = ""
		child = vnode.nthChild(i)
		h = child.headString()
		h = toEncodedString(h, encoding, reportErrors=true)
		doPara(word, "%s %s" % (thishead, h), "%s %d" % (header_style, min(level, maxlevel)))
		writeNodeAndTree(word, header_style, level+1, maxlevel, usesections, thishead, child)
</t>
<t tx="T476">def cmd_Export(event):
	
	"""Export the current node to Word"""

	try:
		word = getWordConnection()
		if word:
			header_style = getConfiguration().get("Main", "Header_Style")
			# Based on the rst plugin
			es("Writing tree to Word",color="blue")
			config = getConfiguration()
			writeNodeAndTree(word,
				config.get("Main", "header_style").strip(),
				1,
				int(config.get("Main", "max_headings")),
				config.get("Main", "use_section_numbers") == "Yes",
				"")						 
			es("Done!")
	except Exception,err:
		es("Failed to connect to Word",color="blue")
		es("Please make sure an empty word document is open.")</t>
<t tx="T477">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading

</t>
<t tx="T478"></t>
<t tx="T479">"""Open any empty file as a minimal .leo file"""

from leoPlugins import *
from leoGlobals import *

&lt;&lt; define minimal .leo file &gt;&gt;
@others

if 0: # Register the handlers...
	registerHandler("open1", onOpen)
	
	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T480">empty_leo_file = """&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/&gt;
&lt;globals body_outline_ratio="0.5"&gt;
	&lt;global_window_position top="145" left="110" height="24" width="80"/&gt;
	&lt;global_log_window_position top="0" left="0" height="0" width="0"/&gt;
&lt;/globals&gt;
&lt;preferences allow_rich_text="0"&gt;
&lt;/preferences&gt;
&lt;find_panel_settings&gt;
	&lt;find_string&gt;&lt;/find_string&gt;
	&lt;change_string&gt;&lt;/change_string&gt;
&lt;/find_panel_settings&gt;
&lt;vnodes&gt;
&lt;v a="V"&gt;&lt;vh&gt;NewHeadline&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;"""</t>
<t tx="T481">def onOpen (tag,keywords):

	import os
	file_name = keywords.get('fileName')

	if file_name and os.path.getsize(file_name)==0:
		# Rewrite the file before really opening it.
		es("rewriting empty .leo file: %s" % (file_name))
		file = open(file_name,'w')
		file.write(empty_leo_file)
		file.flush()
		file.close()

</t>
<t tx="T482">@language python

"""Opens up cmd and explorer window to same directory 
as @file nodes or children ..."""

&lt;&lt; about the open shell plugin &gt;&gt;

import leo,os,os.path,sys
from leoPlugins import *
from leoGlobals import *

pathToExplorer = 'c:/windows/explorer.exe'
pathToCmd = 'c:/windows/system32/cmd.exe'

@others

if 0: # Register the plugin

	registerHandler("after-create-leo-frame", load_menu)
	__version__ = "1.3"
	plugin_signon(__name__)</t>
<t tx="T483">@ Written by Ed Taekema.  Modified by E.K.Ream

Please submit bugs / feature requests to etaekema@earthlink.net"""

This is a simple plugin for leo 3.12 that allows the user to open either an xterm on linux or a cmd windows/explorer window on win32 in the directory of the current @file.  This allows quick navigation to facilitate testing and navigating large systems with complex direcgtories.

Current limitations ...

1. Not tested on Mac OS X ...
2. On win32, the cmd window will not open in the right directory if the @file location is on a different drive than the .leo file that is being edited.
3. On linux, xterm must be in your path.
</t>
<t tx="T484">def load_menu(tag,keywords):
	
	if sys.platform=="win32":
		table = (
			("&amp;Open Console Window",None,launchCmd),
			("Open &amp;Explorer",None,launchExplorer)) 
	else:
		table = ( ("Open &amp;xterm",None,launchxTerm), ) 
	
	top().frame.createNewMenu("E&amp;xtensions","top")
	top().frame.createMenuItemsFromTable("Extensions",table)
</t>
<t tx="T485">def _getpath(c,v):
	dict = scanDirectives(c,v)
	d = dict.get("path")

	if d == None:

		if v.isAtFileNode():
			filename = v.atFileNodeName()
		if v.isAtNoSentinelsFileNode():
			filename = v.atNoSentinelsFileNodeName()
		if v.isAtRawFileNode():
			filename = v.atRawFileNodeName()
		if v.isAtSilentFileNode():
			filename = v.atSilentFileNodeName()

		d = os.path.dirname(filename)

	d = os.path.normpath(d)
	return d
</t>
<t tx="T486">def _getCurrentNodePath():
	c = leo.top()
	v = c.currentVnode()
	f = v.atFileNodeName()
	d = _getpath(c,v)
	return d
</t>
<t tx="T487">def launchCmd(not_used):
	
	global pathToCmd

	d = _getCurrentNodePath()
	myCmd = 'cd ' + d
	os.spawnl(os.P_NOWAIT, pathToCmd, '/k ', myCmd)</t>
<t tx="T488">def launchExplorer(not_used):
	
	global pathToExplorer

	d = _getCurrentNodePath()
	os.spawnl(os.P_NOWAIT,pathToExplorer, ' ', d)

</t>
<t tx="T489">def launchxTerm(not_used):

	d = _getCurrentNodePath()
	curdir = os.getcwd()
	os.chdir(d)
	os.spawnlp(os.P_NOWAIT, 'xterm', '-title Leo')
	os.chdir(curdir)</t>
<t tx="T490">In Python 2.3 the source files should declare the encoding.

See http://www.python.org/peps/pep-0263.html for full details.</t>
<t tx="T491">@first # -*- coding: utf-8 -*-

"""Translate a few menu items into French"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler(("start1","menu1"), onMenu)
	
	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T492">@ The translation table used by setRealMenuNamesFromTable has entries of the form:

	("official name","translated name"),

Ampersands in the translated name indicate that the following character is to be underlined.

The official name can be any name equivalent to the standard English menu names.  Leo "canonicalizes" the official name by converting to lower case and removing any non-letters.  Thus, the following are  equivalent:
	("Open...","&amp;Ouvre"),
	("open",   "&amp;Ouvre"),
	("&amp;Open",  "&amp;Ouvre"),
@c
def onMenu (tag,keywords):
	table = (
		("Open...","&amp;Ouvre"),
		("OpenWith","O&amp;uvre Avec..."),
		("close","&amp;Ferme"),
		("Undo Typing","French &amp;Undo Typing"), # Shows you how much French I know ;-)
		("Redo Typing","French &amp;Redo Typing"),
		("Can't Undo", "French Can't Undo"),
		("Can't Redo", "French Can't Redo"))
	# Call the convenience routine to do the work.
	app().setRealMenuNamesFromTable(table)
</t>
<t tx="T493">@first # -*- coding: utf-8 -*-
@language python

"""traduit les menus en Français"""

# French translation completed by Frédéric Momméja, Spring 2003

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler(("start1","menu1"), onMenu)
	
	__version__ = "1.4" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T494">def onMenu (tag,keywords):
	table = (
		("File","&amp;Fichier"),
			("New","&amp;Nouveau"),
			("Open...","&amp;Ouvrir"),
			("OpenWith","Ouvrir Ave&amp;c..."),
			("Close","&amp;Fermer"),
			("Save","Enregi&amp;strer"),
			("Save As","Enre&amp;gistrer sous..."),
			("Save To","Enregistrer une co&amp;pie..."),
			("Revert To Saved","&amp;Version Enregistrée"),
			("Recent Files...","&amp;Fichiers récents..."),
			("Read/Write...", "&amp;Lire/Écrire..."),
				("Read Outline Only", "Relire &amp;Arborescence seule"),
				("Read @file Nodes", "Relire Structure @&amp;file seule"),
				("Write missing @file Nodes", "Écrire @file &amp;manquants sur Disque"),
				("Write Outline Only", "Écrire Arborescence &amp;seule"),
				("Write @file Nodes", "Écrire &amp;Noeuds @file seuls"),
			("Tangle...", "&amp;Transférer (Tangle)..."),
				("Tangle All", "&amp;Tout"),
				("Tangle Marked", "Noeuds &amp;Marqués"),
				("Tangle", "&amp;Sélection"),
			("Untangle...", "&amp;Ramener (Untangle)..."),
				("Untangle All", "&amp;Tout"),
				("Untangle Marked", "Noeuds &amp;Marqués"),
				("Untangle", "&amp;Sélection"),
			("Import...", "&amp;Importer..."),
				("Import To @file", "Dans Structure @&amp;file"),
				("Import To @root", "Dans Structure @&amp;root"),
				("Import CWEB Files", "Fichier &amp;CWEB"),
				("Import noweb Files", "Fichier &amp;Noweb"),
				("Import Flattened Outline", "Fichier &amp;MORE"),
			("Export...", "&amp;Exporter..."),
				("Export Headlines", "&amp;Entêtes Noeuds descendants vers .txt"),
				("Outline To CWEB", "Arborescence vers &amp;CWEB"),
				("Outline To Noweb", "Arborescence vers &amp;Noweb"),
				("Flatten Outline", "Arborescence vers &amp;MORE"),
				("Remove Sentinels", "En supprimant &amp;Sentinelles"),
				("Weave", "&amp;Arborescence descendante vers .txt"),
			("Exit","&amp;Quitter"),
		("Edit","&amp;Edition"),
			("Undo Typing","Ann&amp;uler saisie"),
			("Redo Typing","&amp;Répèter saisie"),
			("Can't Undo", "Impossible d'annuler"),
			("Can't Redo", "Impossible de répéter"),
			("Cut", "C&amp;ouper"),
			("Copy", "Co&amp;pier"),
			("Paste", "Co&amp;ller"),
			("Delete", "&amp;Supprimer"),
			("Select All", "&amp;Tout Sélectionner"),
			("Edit Body...", "Éditer &amp;Contenu..."),
				("Extract Section", "E&amp;xtraire Section"),
				("Extract Names", "Extraire &amp;Noms de Sections"),
				("Extract", "&amp;Extraire Sélection"),
				("Convert All Blanks", "Convertir Espaces &amp;Arborescence"),
				("Convert All Tabs", "Convertir Tabulations Ar&amp;borescence"),
				("Convert Blanks", "Convertir &amp;Espaces"),
				("Convert Tabs", "Convertir &amp;Tabulations"),
				("Insert Body Time/Date", "Insérer la &amp;Date/Heure"),
				("Reformat Paragraph", "Reformater &amp;Paragraphe"),
				("Indent", "&amp;Indenter"),
				("Unindent", "Dé&amp;sindenter"),
				("Match Brackets", "&amp;Vérifier Parité des Signes"), #  &lt;({["), #EKR
			("Edit Headline...", "Éditer &amp;Entête..."),
				("Edit Headline", "&amp;Modifier l'Entête"),
				("End Edit Headline", "Modification &amp;Terminée"),
				("Abort Edit Headline", "&amp;Annuler Modification"),
				("Insert Headline Time/Date", "Insérer la &amp;Date/Heure"),
				("Toggle Angle Brackets", "Ajouter/supprimer Marques de &amp;Section"),
			("Find...", "C&amp;hercher..."),
				("Find Panel", "Dialogue de Re&amp;cherche"),
				("Find Next", "Chercher &amp;Suivant"),
				("Find Previous", "Chercher &amp;Précédent"),
				("Replace", "&amp;Remplacer"),
				("Replace, Then Find", "Remplacer Chercher à &amp;Nouveau"),
			("Go To Line Number", "&amp;Atteindre Ligne No..."),
			("Execute Script", "E&amp;xécuter un Script Python"),
			("Set Font...", "&amp;Définir les Polices..."),
			("Set Colors...", "Dé&amp;finir les Couleurs..."),
			("Show Invisibles", "Afficher Caractères &amp;invisibles"),
			("Hide Invisibles", "Masquer Caractères &amp;invisibles"),
			("Preferences", "Préfére&amp;nces"),
		("Outline", "Arb&amp;orescence"),
			("Cut Node", "Co&amp;uper le Noeud"),
			("Copy Node", "C&amp;opier le Noeud"),
			("Paste Node", "Co&amp;ller le Noeud"),
			("Delete Node", "&amp;Supprimer le Noeud"),
			("Insert Node", "Insé&amp;rer un Noeud"),
			("Clone Node", "Clo&amp;ner le Noeud"),
			("Sort Children", "&amp;Trier les Noeuds Enfants"),
			("Sort Siblings", "Trier le Ni&amp;veau"),
			("Expand/Contract...", "&amp;Déployer/Refermer"),
				("Contract All", "&amp;Tout Refermer"),
				("Contract Node", "&amp;Refermer Noeud"),
				("Contract Parent", "Refermer Noeud &amp;Parent"),
				("Expand Prev Level", "Déployer Niveau pré&amp;cédent"),
				("Expand Next Level", "Déployer Niveau &amp;suivant"),
				("Expand To Level 1", "Déployer &amp;1 Niveau"),
				("Expand To Level 2", "Déployer &amp;2 Niveaux"),
				("Expand To Level 3", "Déployer &amp;3 Niveaux"),
				("Expand To Level 4", "Déployer &amp;4 Niveaux"),
				("Expand To Level 5", "Déployer &amp;5 Niveaux"),
				("Expand To Level 6", "Déployer &amp;6 Niveaux"),
				("Expand To Level 7", "Déployer &amp;7 Niveaux"),
				("Expand To Level 8", "Déployer &amp;8 Niveaux"),
				("Expand All", "Tout &amp;Déployer"),
				("Expand Node", "Déplo&amp;yer Noeud"),
			("Move...", "Dé&amp;placer..."),
				("Move Down", "Vers le &amp;Bas"),
				("Move Left", "Vers la &amp;Gauche"),
				("Move Right", "Vers la &amp;Droite"),
				("Move Up", "Vers le &amp;Haut"),
				("Promote", "&amp;Enfants vers la Gauche"),
				("Demote", "&amp;Noeuds suivants vers la Droite"),
			("Mark/Unmark...", "Mar&amp;quage..."),
				("Mark", "&amp;Marquer/Effacer Marque"),
				("Mark Subheads", "Marquer En&amp;fants"),
				("Mark Changed Items", "Marquer &amp;Noeuds modifiés"),
				("Mark Changed Roots", "Marquer @&amp;root modifiés"),
				("Mark Clones", "Marquer &amp;Clones"),
				("Unmark All", "&amp;Effacer toutes les Marques"),
			("Go To...", "Se Dépla&amp;cer vers..."),
				("Go To Next Marked", "&amp;Marque suivante"),
				("Go To Next Changed", "M&amp;odification suivante"),
				("Go To Next Clone", "&amp;Clone suivant"),
				("Go To First Node", "&amp;Premier Noeud"),
				("Go To Last Node", "&amp;Dernier Noeud"),
				("Go To Parent", "&amp;Noeud Parent"),
				("Go To Prev Sibling", "Noe&amp;ud précédent"),
				("Go To Next Sibling", "Noeud &amp;suivant"),
				("Go To Prev Visible", "Noeud &amp;Visible précédent"),
				("Go To Next Visible", "Noeud V&amp;isible suivant"),
				("Go Back", "De&amp;rnière Position"),
				("Go Next", "Posi&amp;tion suivante"),
		("Window", "Fenê&amp;tre"),
			("Equal Sized Panes", "Panneaux de &amp;même taille"),
			("Toggle Active Pane", "&amp;Bascule Panneau actif"),
			("Toggle Split Direction", "Bascule &amp;Horiz/Vert"),
			("Cascade", "Fenêtres Leo en &amp;Cascade"),
			("Minimize All", "&amp;Réduit toutes les Fenêtres"),
			("Open Compare Window", "Ouvrir Fenêtre de Com&amp;paraison..."),
			("Open Python Window", "Ouvrir Fenêtre Python (IDLE)..."),
		("Help", "&amp;Aide"),
			("About Leo...", "Au &amp;sujet de Leo..."),
			("Online Home Page", "&amp;Page d'Accueil en ligne"),
			("Open Online Tutorial", "Ouvrir &amp;Tutoriel en ligne"),
			("Open LeoDocs.leo", "Ouvrir Leo&amp;Docs.leo"),
			("Open LeoConfig.leo", "Ouvrir Leo&amp;Config.leo"),
			("Apply Settings", "Appliquer les &amp;Réglages"))
	# Call the convenience routine to do the work.
	app().setRealMenuNamesFromTable(table)
</t>
<t tx="T495"></t>
<t tx="T496">"""Rebind up/down arrow keys"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("open2", onOpen)
	
	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T497"># Warning: the bindings created this way conflict with shift-arrow keys.

def onOpen (tag,keywords):

	c = keywords.get("new_c")
	body = c.frame.body
	tree = c.frame.tree

	# Add "hard" bindings to have up/down arrows move by visual lines.
	old_binding = body.bind("&lt;Up&gt;")
	if len(old_binding) == 0:
		body.bind("&lt;Up&gt;",tree.OnUpKey)

	old_binding = body.bind("&lt;Down&gt;")
	if len(old_binding) == 0:
		body.bind("&lt;Down&gt;",tree.OnDownKey)
</t>
<t tx="T498"></t>
<t tx="T499"></t>
<t tx="T500">"""Create a Plugins menu"""

# Written by Paul A. Paterson.  Revised by Edward K. Ream.

## To do: confine the imports to the plugins directory.
## This does _not_ happen now!  import test gets a module from the Python directory!

## To do: add Revert button to each dialog.

from leoPlugins import *
from leoGlobals import *
import ConfigParser,glob,os,sys,Tkinter

Tk = Tkinter

@others

if 1: # Register the handlers...

	if app().gui == None:
		app().createTkGui()

	if app().gui.guiName() == "tkinter":
		registerHandler("create-optional-menus",createPluginsMenu)
		
		__version__ = "1.2"
		plugin_signon(__name__)</t>
<t tx="T501">class PlugIn:

	"""A class to hold information about one plugin"""

	@others
	
</t>
<t tx="T502">def __init__(self, filename):

	"""Initialize the plug-in"""

	# Import the file to find out some interesting stuff
	# Do not use the imp module: we only want to import these files once!
	self.mod = self.doc = self.version = None
	try:
		self.mod = __import__(os.path.splitext(os.path.basename(filename))[0])
		if not self.mod:
			return
		self.name = self.mod.__name__
		self.doc = self.mod.__doc__
		self.version = self.mod.__dict__.get("__version__") # "&lt;unknown&gt;")
		# if self.version: print self.version,shortFileName(filename)
	except: return

	&lt;&lt; Check if this can be configured &gt;&gt;
	&lt;&lt; Check if this has an apply &gt;&gt;
	&lt;&lt; Look for additional commands &gt;&gt;</t>
<t tx="T503"># Look for a configuration file
self.configfilename = "%s.ini" % os.path.splitext(filename)[0]
self.hasconfig = os.path.isfile(self.configfilename)
</t>
<t tx="T504">@ Look for an apply function ("applyConfiguration") in the module.

This is used to apply changes in configuration from the properties window
@c

self.hasapply = hasattr(self.mod, "applyConfiguration")
</t>
<t tx="T505">@ Additional commands can be added to the plugin menu by having functions in the module called "cmd_whatever". These are added to the main menu and will be called when clicked
@c

self.othercmds = {}

for item in self.mod.__dict__.keys():
	if item.startswith("cmd_"):
		self.othercmds[item[4:]] = self.mod.__dict__[item]
</t>
<t tx="T506">def about(self, arg):
	
	"""Put up an "about" dialog for this plugin"""

	PluginAbout(self.name, self.version, self.doc)</t>
<t tx="T507">def properties(self, arg):
	
	"""Create a modal properties dialog for this plugin"""

	PropertiesWindow(self.configfilename, self)
</t>
<t tx="T508">class PropertiesWindow:

	"""A class to create and run a Properties dialog for a plugin"""

	@others</t>
<t tx="T509">def __init__(self, filename, plugin):

	"""Initialize the property window"""
	
	&lt;&lt; initialize all ivars &gt;&gt;
	&lt;&lt; create the frame from the configuration data &gt;&gt;</t>
<t tx="T510"># config stuff.
config = ConfigParser.ConfigParser()
config.read(filename)
self.filename = filename
self.config = config
self.plugin = plugin

# self.entries is a list of tuples (section, option, e),
# where section and options are strings and e is a Tk.Entry widget.
# This list is used by writeConfiguration to write all settings.
self.entries = []
</t>
<t tx="T511">root = app().root

&lt;&lt; Create the top level and the main frame &gt;&gt;
&lt;&lt; Create widgets for each section and option &gt;&gt;
&lt;&lt; Create Ok, Cancel and Apply buttons &gt;&gt;

center_dialog(top) # Do this after packing.
top.grab_set() # Make the dialog a modal dialog.
top.focus_force() # Get all keystrokes.
root.wait_window(top)</t>
<t tx="T512">self.top = top = Tk.Toplevel(root)
attachLeoIcon(self.top)
top.title("Properties of "+ plugin.name)
top.resizable(0,0) # neither height or width is resizable.
	
self.frame = frame = Tk.Frame(top)
frame.pack(side="top")</t>
<t tx="T513"># Create all the entry boxes on the screen to allow the user to edit the properties
sections = config.sections()
sections.sort()
for section in sections:
	# Create a frame for the section.
	f = Tk.Frame(top, relief="groove",bd=2)
	f.pack(side="top",padx=5,pady=5)
	Tk.Label(f, text=section.capitalize()).pack(side="top")
	# Create an inner frame for the options.
	b = Tk.Frame(f)
	b.pack(side="top",padx=2,pady=2)
	# Create a Tk.Label and Tk.Entry for each option.
	options = config.options(section)
	options.sort()
	row = 0
	for option in options:
		e = Tk.Entry(b)
		e.insert(0, config.get(section, option))
		Tk.Label(b, text=option).grid(row=row, col=0, sticky="e", pady=4)
		e.grid(row=row, col=1, sticky="ew", pady = 4)
		row += 1
		self.entries.append((section, option, e))</t>
<t tx="T514">box = Tk.Frame(top, borderwidth=5)
box.pack(side="bottom")

list = [("OK",self.onOk),("Cancel",top.destroy)]
if plugin.hasapply:
	list.append(("Apply",self.onApply),)

for text,f in list:
	Tk.Button(box,text=text,width=6,command=f).pack(side="left",padx=5)</t>
<t tx="T515">def onApply(self):
	
	"""Event handler for Apply button"""
	self.writeConfiguration()
	self.plugin.mod.applyConfiguration(self.config)

def onOk(self):

	"""Event handler for Ok button"""
	self.writeConfiguration()
	self.top.destroy()</t>
<t tx="T516">def writeConfiguration(self):
	
	"""Write the configuration to disk"""

	# Set values back into the config item.
	for section, option, entry in self.entries:
		self.config.set(section, option, entry.get())

	# Write out to the file.
	f = open(self.filename, "w")
	self.config.write(f)
	f.close()
</t>
<t tx="T517">class PluginAbout:
	
	"""A class to create and run an About Plugin dialog"""
	
	@others
</t>
<t tx="T518">def __init__(self, name, version, about):
	
	"""# Create and run a modal dialog giving the name,
	version and description of a plugin.
	"""

	root = app().root
	self.top = top = Tk.Toplevel(root)
	attachLeoIcon(self.top)
	top.title("About " + name)
	top.resizable(0,0) # neither height or width is resizable.
	
	frame = Tk.Frame(top)
	frame.pack(side="top")
	&lt;&lt; Create the contents of the about box &gt;&gt;
	&lt;&lt; Create the close button &gt;&gt;
	
	center_dialog(top) # Do this after packing.
	top.grab_set() # Make the dialog a modal dialog.
	top.focus_force() # Get all keystrokes.
	root.wait_window(top)</t>
<t tx="T519">if 0: # The name is now in the window's title.
	Tk.Label(frame, text="Name:").grid(row=0, col=0, sticky="E")
	Tk.Label(frame, text=name).grid(row=0, col=1, sticky="W")
	Tk.Label(frame, text="Version").grid(row=1, col=0, sticky="E")
	Tk.Label(frame, text=version).grid(row=1, col=1, sticky="W")
	Tk.Label(frame, text=about, borderwidth=10, justify="left").grid(columnspan=2)
else:
	Tk.Label(frame, text="Version " + version).pack()
	Tk.Label(frame, text=about, borderwidth=10).pack()</t>
<t tx="T520">buttonbox = Tk.Frame(top, borderwidth=5)
buttonbox.pack(side="bottom")

self.button = Tk.Button(buttonbox, text="Close", command=top.destroy)
self.button.pack(side="bottom")</t>
<t tx="T521">def createPluginsMenu (tag,keywords):

	c = keywords.get("c")
	old_path = sys.path[:] # Make a _copy_ of the path.

	path = os.path.join(app().loadDir,"..","plugins")
	sys.path = path
	
	if os.path.exists(path):
		# Create a list of all active plugins.
		files = glob.glob(os.path.join(path,"*.py"))
		files.sort()
		plugins = [PlugIn(file) for file in files]
		items = [(p.name,p) for p in plugins if p.version]
		if items:
			items.sort()
			c.pluginsMenu = pluginMenu = c.frame.createNewMenu("&amp;Plugins")
			&lt;&lt; add items to the plugins menu &gt;&gt;
			
	sys.path = old_path


</t>
<t tx="T522">for name,p in items:
	if p.hasconfig:
		m = c.frame.createNewMenu(p.name, "&amp;Plugins")
		table = [("About...", None, p.about),
				 ("Properties...", None, p.properties)]
		if p.othercmds:
			table.append(("-", None, None))
			items = [(cmd,None,fn) for cmd,fn in p.othercmds.iteritems()]
			items.sort()
			table.extend(items)
		c.frame.createMenuEntries(m, table)
	else:
		table = ((p.name, None, p.about),)
		c.frame.createMenuEntries(pluginMenu, table)</t>
<t tx="T523">@ignore
@language python

"""Test file for Plugins menu protocols"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...

	if app().gui == None:
		app().createTkGui()

	if app().gui.guiName() == "tkinter":

		registerHandler("select2", onSelect)
		registerHandler("unselect1", onUnselect)
		
		__version__ = "1.1"
		plugin_signon(__name__)</t>
<t tx="T524">def applyConfiguration(config):
	
	sections = config.sections()
	sections.sort()

	for section in sections:
		options = config.options(section)
		options.sort()
		for option in options:
			print section, option, config.get(section, option)
</t>
<t tx="T525">def cmd_fn1(x):
	es("Fn1",color="blue")

def cmd_fn2(x):
	es("Fn2",color="blue")

def cmd_fn3(x):
	es("Fn3",color="blue")
</t>
<t tx="T526">def onSelect (tag,keywords):

	import Tkinter,os

	new_v = keywords.get("new_v")
	h = new_v.headString()
	if h[:7] == "@image ":
		filename = h[7:]
		&lt;&lt; Select Image &gt;&gt;</t>
<t tx="T527"># Display the image file in the text pane, if you can find the file
a = app()
c = keywords.get("c")
body = c.frame.body

if os.path.isfile(filename):
	try:
		# Note that Tkinter only understands GIF
		photo = Tkinter.PhotoImage(master=a.root, file=filename)
	except:
		es("error: cannot load image")
		return
	# Nicely display the image at the center top and push the text below.
	a.gsphoto = photo # This is soooo important.
	photoWidth = photo.width()
	bodyWidth = body.winfo_width()
	padding = int((bodyWidth - photoWidth - 16) / 2)
	padding = max(0,padding)
	a.gsimage = body.image_create("1.0",image=photo,padx=padding)
else:
	es("warning: missing image file")</t>
<t tx="T528">def onUnselect (tag,keywords):

	import Tkinter, os.path
	a = app()
	c = keywords.get("c")
	old_v = keywords.get("old_v")

	if old_v:
		h = old_v.headString()
		if h[:7] == "@image ":
			&lt;&lt; Unselect Image &gt;&gt;
	else: # Leo is initializing.
		a.gsphoto = None # Holds our photo file
		a.gsimage = None # Holds our image instance within the text pane</t>
<t tx="T529"># Erase image if it was previously displayed
if a.gsimage:
	try:
		 c.frame.body.delete(a.gsimage)
	except:
		es("info: no image to erase")

# And forget about it
a.gsimage = None
a.gsphoto = None
</t>
<t tx="T530">@nocolor</t>
<t tx="T531">Reorganized the code so I can find various classes more easily.
Used @others to simply the outline.

Sorted all entries in dialogs.
Sorted all entries in Plugins menu, regardless of whether they are configurable.

For all dialogs:
	Added top ivar and removed root/master params and ivars.
	Added Leo icon and title.
	Centered dialogs.

Ctors now run all dialogs as modal dialogs: this could easily be undone.

Used a grid in the properties dialog to align widgets.</t>
<t tx="T532">- We will use a new settings file called leoSettings.txt:
- Each setting will have its _own section_ in leoSettings.txt with the following items (most optional)
	val = present value of settings: Use parent setting if this does not exist.
	help = help string (displayed near setting if it exists)
	prompt = prompt string (defaults to setting name, i.e., the section name)
	group = name of group dialog containing this item (use general section if this does not exist)
	type = one of the following:
		value			meaning
		bool			followed by true/false prompts for radio buttons
		color			color picker
		font			font picker
		parent			name of parent config file (set/get setting in that file)
		entry			followed by arbitrary text in an entry widget
		text			followed by arbitrary text in a text widget
		number			any number, or followed by a range of valid values for an entry widget.
		numberlist  followed by a list valid values for a listbox.
		list			followed by a list of valid strings in a listbox.
Notes:
- We could use yaml or ConfigParser or Pickle.  yaml might be best.
- The options dialog will have a separate frame for each group or subgroup.
- We will want a Create Options file command (useful for converting old leoConfig.txt files)
- All options may have a use parent settings (for all widgets?)
- The separate "Groups" section may indicate which groups are subgroups of other groups for multi-level displays.</t>
<t tx="T533">I wrote myself a plug-in which would automatically save the Leo file every so often and in doing so realized that it would be useful to be able to configure the interval between saves. Anyway, to cut a long story short, I generalized the idea and came up with the attached patch. 
 
All code resides under the "Plug in changes" node. The additions are all under the "create the plug-in menu" node with another couple of lines in "createMenuBar". Structurally this is ugly - but it helps keep all the changes in one place!
 
The basic idea is to allow plug-ins to be configured and also allow them to expose additional functions which can be accessed by a menu item. The advantage is that people don't have to mess with adding menus to Leo. Existing plug-ins don't need to be changed in any way to work with the new patch.
 
Ok, here's what it does....
 
1. A new "Plug-ins" menu item is added
 
2. Each plug-in gets an "About x...." entry.
 
    - clicking on "About x..." brings up an about box which shows name, version and documentation for the plug in
    - name comes from the module name
    - version is the module __version__ if present
    - documentation is the module docstring 
 
3. If the plug-in is configurable then a sub menu is created
 
    - configurable means that a corresponding ".ini" file is found with the same names as the plug-in (ie mod_image.py has mod_image.ini)
    - the sub menu contains
        - the "About x..." as before
        - a "Properties..." menu entry to edit the properties (*)
 
4. A further search is made for plug-in specific commands
 
    - we look for functions called "cmd_*" in the module
    - if found we add them to the plug-in menu
    - when you click on the menu item the function is called with a single parameter
 
(*) How does the property window work,
 
5. The property window reads the ini file which is assumed to be in standard ini file format (ie sections and parameters)
    - each section gets a frame in the window
    - each property gets an entry box
 
6. From the property window the user can "Cancel" or "OK", which saves changes
 
7. If the module contains an "applyConfiguration" function then there is also an "Apply" button on the form. The apply configuration function is called with the current configuration when the "Apply" button is pressed.
</t>
<t tx="T534">"""Create a Scripts menu for LeoPy.leo"""

from leoPlugins import *
from leoGlobals import *
import glob,os

@others

if 1: # Register the handlers...
	registerHandler("create-optional-menus",createScriptsMenu)
	
	__version__ = "1.4"
	plugin_signon(__name__)</t>
<t tx="T535">def createScriptsMenu (tag,keywords):

	c = keywords.get("c")
	path = os.path.join(app().loadDir,"..","scripts")
	
	if os.path.exists(path):

		# Create lists of scripts and subdirectories.
		entries = glob.glob(os.path.join(path,"*"))
		top_scripts = glob.glob(os.path.join(path,"*.py"))
		dirs = [f for f in entries if os.path.isdir(f)]
		&lt;&lt; Return if no scripts exist anywhere &gt;&gt;
	
		scriptsMenu = c.frame.createNewMenu("&amp;Scripts")
		table = []
		&lt;&lt; Create top-level entries for every script in top_scripts &gt;&gt;
		for dir in dirs:
			files = glob.glob(os.path.join(dir,"*.py"))
			if files:
				&lt;&lt; Create a submenu for dir containing each file in files &gt;&gt;</t>
<t tx="T536">if not top_scripts:
	found = false
	for dir in dirs:
		scripts = glob.glob(os.path.join(dir,"*.py"))
		if scripts:
			found = true ; break
	if not found:
		return
</t>
<t tx="T537">table = []
top_scripts.sort()
for script in top_scripts:
	name = shortFileName(script)
	def doScript(event=None,name=name):
		executeScript(name)
	table.append((name,None,doScript),)
	
c.frame.createMenuEntries(scriptsMenu, table)
</t>
<t tx="T538"># Create the submenu.
name = os.path.join("scripts",shortFileName(dir))
menu = c.frame.createNewMenu(name,"&amp;Scripts")

# Populate the submenu.
table = []
for file in files:
	name = shortFileName(file)
	def doScript(event=None,name=name):
		from leoGlobals import executeScript
		executeScript(name)
	table.append((name,None,doScript),)

c.frame.createMenuEntries(menu, table)</t>
<t tx="T539"></t>
<t tx="T540">"""Synchronize @folder nodes with folders"""

from leoPlugins import *
from leoGlobals import *

&lt;&lt; about this plugin &gt;&gt;
@others

def onSelect (tag,keywords):
	v = keywords.get("new_v")
	h = v.headString()
	if match_word(h,0,"@folder"):
		sync_node_to_folder(v,h[8:])

if 0: # Register the handlers...
	registerHandler("select1", onSelect)

	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T541">@ If a node is named '@folder path_to_folder', the content (filenames) of the
folder and the children of that node will be sync. Whenever a new file is put
there, a new node will appear on top of the children list (with mark). So that
I can put my description (ie. annotation) as the content of that node. In this
way, I can find any files much easier from leo.

Moreover, I add another feature to allow you to group files(in leo) into
children of another group. This will help when there are many files in that
folder. You can logically group it in leo (or even clone it to many groups),
while keep every files in a flat/single directory on your computer.
</t>
<t tx="T542">def sync_node_to_folder(parent,d):

	oldlist = {}
	newlist = []
	#get children info
	v = parent
	after_v = parent.nodeAfterTree()
	while v != after_v:
		if not v.hasChildren():
			oldlist[v.headString()] = v.bodyString()
		v = v.threadNext()
	#compare folder content to children
	for name in os.listdir(d):
		if name in oldlist:
			del oldlist[name]
		else:
			newlist.append(name)
	#insert newlist
	newlist.sort()
	newlist.reverse()
	for name in newlist:
		v = parent.insertAsNthChild(0)
		v.setHeadStringOrHeadline(name)
		v.setMarked()
	#warn for orphan oldlist
	if len(oldlist)&gt;0:
		es('missing: '+','.join(oldlist.keys()))
</t>
<t tx="T543">"""Inhibit changes to @read-only nodes"""

# Contributed by Davide Salomoni &lt;dsalomoni@yahoo.com&gt;

from leoPlugins import *
from leoGlobals import *
import ftplib, urllib, urlparse, os, cStringIO, tkFileDialog
from formatter import AbstractFormatter, DumbWriter
from htmllib import HTMLParser

@others

if 0: # Register the handlers...

	if not app().gui:
		app().createTkGui()

	if app().gui.guiName() == "tkinter":

		registerHandler(("start2","open2"), on_open2)
		registerHandler("bodykey1", on_bodykey1)
		registerHandler("headkey2", on_headkey2)
		if 0: # doesn't work: the cursor stops blinking.
			registerHandler("select1", on_select1)
			registerHandler("select2", on_select2)
	
		__version__ = "1.5" # Set version for the plugin handler.
		plugin_signon(__name__)
</t>
<t tx="T544">@ Dear Leo users,

Here's my first attempt at customizing leo. I wanted to have the ability to
import files in "read-only" mode, that is, in a mode where files could only
be read by leo (not tangled), and also kept in sync with the content on the
drive.

The reason for this is for example that I have external programs that generate
resource files. I want these files to be part of a leo outline, but I don't
want leo to tangle or in any way modify them. At the same time, I want them
to be up-to-date in the leo outline.

So I coded the directive plugin. It has the following characteristics:

- It reads the specified file and puts it into the node content.

- If the @read-only directive was in the leo outline already, and the file content
on disk has changed from what is stored in the outline, it marks the node as
changed and prints a "changed" message to the log window; if, on the other hand,
the file content has _not_ changed, the file is simply read and the node is
not marked as changed.

- When you write a @read-only directive, the file content is added to the node
immediately, i.e. as soon as you press Enter (no need to call a menu
entry to import the content).

- If you want to refresh/update the content of the file, just edit the headline
and press Enter. The file is reloaded, and if in the meantime it has changed,
a "change" message is sent to the log window.

- The body text of a @read-only file cannot be modified in leo.

Davide Salomoni
</t>
<t tx="T545">@ The syntax to access files in @read-only via ftp/http is the following:

@read-only http://www.ietf.org/rfc/rfc0791.txt
@read-only ftp://ftp.someserver.org/filepath

If FTP authentication (username/password) is required, it can be specified as follows:

@read-only ftp://username:password@ftp.someserver.org/filepath

For more details, see the doc string for the class FTPurl.
</t>
<t tx="T546">class FTPurl:
	"""An FTP wrapper class to store/retrieve files using an FTP URL.

    To create a connection, call the class with the constructor:

        FTPurl(url[, mode])

    The url should have the following syntax:
    
        ftp://[username:password@]remotehost/filename
    
    If username and password are left out, the connection is made using
    username=anonymous and password=realuser@host (for more information,
    see the documentation of module ftplib).
    
    The mode can be '' (default, for ASCII mode) or 'b' (for binary mode).
	This class raises an IOError exception if something goes wrong.
	"""
	
	@others
</t>
<t tx="T547">def __init__(self, ftpURL, mode=''):
	parse = urlparse.urlparse(ftpURL)
	if parse[0] != 'ftp':
		raise IOError, "error reading %s: malformed ftp URL" % ftpURL

	# ftp URL; syntax: ftp://[username:password@]hostname/filename
	self.mode = mode
	authIndex = parse[1].find('@')
	if authIndex == -1:
		auth = None
		ftphost = parse[1]
	else:
		auth = parse[1][:authIndex]
		ftphost = parse[1][authIndex+1:]
	self.ftp = ftplib.FTP(ftphost)
	if auth == None:
		self.ftp.login()
	else:
		# the URL has username/password
		pwdIndex = auth.find(':')
		if pwdIndex == -1:
			raise IOError, "error reading %s: malformed ftp URL" % ftpURL
		user = auth[:pwdIndex]
		password = auth[pwdIndex+1:]
		self.ftp.login(user, password)
	self.path = parse[2][1:]
	self.filename = os.path.basename(self.path)
	self.dirname = os.path.dirname(self.path)
	self.isConnectionOpen = 1
	self.currentLine = 0
</t>
<t tx="T548"></t>
<t tx="T549">def read(self):
	"""Read the filename specified in the constructor and return it as a string.
    If the constructor specifies no filename, or if the URL ends with '/',
    return the list of files in the URL directory.
	"""
	self.checkParams()
	if self.filename=='' or self.path[-1]=='/':
		return self.dir()

	try:
		if self.mode == '':  # mode='': ASCII mode
			slist = []
			self.ftp.retrlines('RETR %s' % self.path, slist.append)
			s = '\n'.join(slist)
		else: # mode='b': binary mode
			file = cStringIO.StringIO()
			self.ftp.retrbinary('RETR %s' % self.path, file.write)
			s = file.getvalue()
			file.close()
		return s
	except:
		exception, msg, tb = sys.exc_info()
		raise IOError, msg

</t>
<t tx="T550">def readline(self):
	"""Read one entire line from the remote file."""
	try:
		self.lst
	except AttributeError:
		self.lst = self.read().splitlines(1)
	
	if self.currentLine &lt; len(self.lst):
		s = self.lst[self.currentLine]
		self.currentLine = self.currentLine + 1
		return s
	else:
		return ''
</t>
<t tx="T551"></t>
<t tx="T552">def write(self, s):
	"""write(s) stores the string s to the filename specified in the
    constructor."""
	self.checkParams()
	if self.filename == '':
		raise IOError, 'filename not specified'
	
	try:
		file = cStringIO.StringIO(s)
		if self.mode == '':  # mode='': ASCII mode
			self.ftp.storlines('STOR %s' % self.path, file)
		else: # mode='b': binary mode
			self.ftp.storbinary('STOR %s' % self.path, file)
		file.close()
	except:
		exception, msg, tb = sys.exc_info()
		raise IOError, msg
</t>
<t tx="T553"></t>
<t tx="T554">def seek(offset=0):
	self.currentLine = 0  # we don't support fancy seeking via FTP
</t>
<t tx="T555">def flush():
	pass # no fancy stuff here.</t>
<t tx="T556">def dir(self, path=None):
	"""Issue a LIST command passing the specified argument and return output as a string."""
	s = []

	if path == None:
		path = self.dirname
	try:
		listcmd = 'LIST %s' % path
		self.ftp.retrlines(listcmd.rstrip(), s.append)
		return '\n'.join(s)
	except:
		exception, msg, tb = sys.exc_info()
		raise IOError, msg
</t>
<t tx="T557">def exists(self, path=None):
	"""Return 1 if the specified path exists. If path is omitted, the current file name is tried."""
	if path == None:
		path = self.filename

	s = self.dir(path)
	if s.lower().find('no such file') == -1:
		return 1
	else:
		return 0
</t>
<t tx="T558">def checkParams(self):
	if self.mode not in ('','b'):
		raise IOError, 'invalid mode: %s' % self.mode
	if not self.isConnectionOpen:
		raise IOError, 'ftp connection closed'
</t>
<t tx="T559">def close(self):
	"""Close an existing FTPurl connection."""
	try:
		self.ftp.quit()
	except:
		self.ftp.close()
	del self.ftp
	self.isConnectionOpen = 0</t>
<t tx="T560"># Alas, these do not seem to work on XP:
# disabling the body text _permanently_ stops the cursor from blinking.

def enable_body(body):
	global insertOnTime,insertOffTime
	if body.cget("state") == "disabled":
		try:
			es("enable")
			print insertOffTime,insertOnTime
			body.configure(state="normal")
			body.configure(insertontime=insertOnTime,insertofftime=insertOffTime)
		except: es_exception()
			
def disable_body(body):
	global insertOnTime,insertOffTime
	if body.cget("state") == "normal":
		try:
			es("disable")
			insertOnTime = body.cget("insertontime")
			insertOffTime = body.cget("insertofftime")
			print insertOffTime,insertOnTime
			body.configure(state="disabled")
		except: es_exception()
</t>
<t tx="T561"># Sets v's body text from the file with the given name.
# Returns true if the body text changed.
def insert_read_only_node (c,v,name):
	if name=="":
		name = tkFileDialog.askopenfilename(
			title="Open",
			filetypes=[("All files", "*")]
			)
		c.beginUpdate()
		v.setHeadString("@read-only %s" % name)
		c.endUpdate()
	parse = urlparse.urlparse(name)
	try:
		if parse[0] == 'ftp':
			file = FTPurl(name)  # FTP URL
		elif parse[0] == 'http':
			file = urllib.urlopen(name)  # HTTP URL
		else:
			file = open(name,"r")  # local file
		# es("..." + name)
		new = file.read()
		file.close()
	except IOError,msg:
		# es("error reading %s: %s" % (name, msg))
		# es("...not found: " + name)
		v.setBodyStringOrPane("") # Clear the body text.
		return true # Mark the node as changed.
	else:
		ext = os.path.splitext(parse[2])[1]
		if ext.lower() in ['.htm', '.html']:
			&lt;&lt; convert HTML to text &gt;&gt;
		previous = v.t.bodyString
		v.setBodyStringOrPane(new)
		changed = (toUnicode(new,'ascii') != toUnicode(previous,'ascii'))
		if changed and previous != "":
			es("changed: %s" % name) # A real change.
		return changed


</t>
<t tx="T562">fh = cStringIO.StringIO()
fmt = AbstractFormatter(DumbWriter(fh))
# the parser stores parsed data into fh (file-like handle)
parser = HTMLParser(fmt)

# send the HTML text to the parser
parser.feed(new)
parser.close()

# now replace the old string with the parsed text
new = fh.getvalue()
fh.close()

# finally, get the list of hyperlinks and append to the end of the text
hyperlinks = parser.anchorlist
numlinks = len(hyperlinks)
if numlinks &gt; 0:
	hyperlist = ['\n\n--Hyperlink list follows--']
	for i in xrange(numlinks):
		hyperlist.append("\n[%d]: %s" % (i+1,hyperlinks[i])) # 3/26/03: was i.
	new = new + ''.join(hyperlist)</t>
<t tx="T563">#  scan the outline and process @read-only nodes.
def on_open2 (tag,keywords):
	
	
	if tag == "start2":
		c = top()
	else:
		c = keywords.get("new_c")

	v = c.rootVnode()
	es("scanning for @read-only nodes...",color="blue")
	c.beginUpdate()
	while v:
		h = v.headString()
		if match_word(h,0,"@read-only"):
			changed = insert_read_only_node(c,v,h[11:])
			if changed:
				if not v.isDirty():
					v.setDirty()
				if not c.isChanged():
					c.setChanged(changed)
		v = v.threadNext()
	c.endUpdate()
</t>
<t tx="T564"># override the body key handler if we are in an @read-only node.

def on_bodykey1 (tag,keywords):

	c = keywords.get("c")
	v = keywords.get("v")
	h = v.headString()
	if match_word(h,0,"@read-only"):
		# The following code causes problems with scrolling and syntax coloring.
		# Its advantage is that it makes clear that the text can't be changed,
		# but perhaps that is obvious anyway...
		if 0: # Davide Salomoni requests that this code be eliminated.
			# An @read-only node: do not change its text.
			body = c.frame.body
			body.delete("1.0","end")
			body.insert("1.0",v.bodyString())
		return 1 # Override the body key event handler.</t>
<t tx="T565"># update the body text when we press enter

def on_headkey2 (tag,keywords):

	c = keywords.get("c")
	v = keywords.get("v")
	h = v.headString()
	ch = keywords.get("ch")
	if ch == '\r' and match_word(h,0,"@read-only"):
		# on-the-fly update of @read-only directives
		changed = insert_read_only_node(c,v,h[11:])
		c.setChanged(changed)</t>
<t tx="T566">def on_select1 (tag,keywords):

	# Doesn't work: the cursor doesn't start blinking.
	# Enable the body text so select will work properly.
	c = keywords.get("c")
	enable_body(c.frame.body)
</t>
<t tx="T567">def on_select2 (tag,keywords):

	c = keywords.get("c")
	v = c.currentVnode()
	h = v.headString()
	if match_word(h,0,"@read-only"):
		disable_body(c.frame.body)
	else:
		enable_body(c.frame.body)
</t>
<t tx="T568">"""If a headline starts with @rst &lt;filename&gt;, double-clicking on it will 
write a file in outline order, with the headlines converted to reStructuredText 
section headings.
If the name of the &lt;filename&gt; has the extension .html or .htm, and if you have
docutils installed, it will generate HTML."""

# By Josef Dalcolmo: contributed under the same licensed as Leo.py itself.

# EKR: The code now lets other plugins handle @folder and @url nodes.

from leoPlugins import *
from leoGlobals import *

&lt;&lt; about this plugin &gt;&gt;
&lt;&lt; change log &gt;&gt;

@others

if 0: # Register the handlers...
	registerHandler("icondclick1",onIconDoubleClick)
	
	__version__ = "1.5" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T569">@ This plugin writes out @rst nodes as a reStructuredText file.

If the filename ends in .html or .htm and if you have docutils_ (a Python
module) installed, then it will be written as HTML. The HTML converter is far
from bug-free, but remember, docutils is alpha software. (Perhaps a future
version will allow automatic translation to other formats, like OpenOffice.org
as well).

Headlines are translated into reStructuredText headlines, e.g. underlined
depending on the level and empty line separated from body text otherwise, text
is written as it is. The "#" character is not used for underlining, so it may
be used for a title as in::

	#####
	Title
	#####

Otherwise, section underlining is discouraged, since it is automatically generated.

.. _docutils: http://docutils.sourceforge.net
</t>
<t tx="T570">@ Change log:

- New tree types: @rst has been added.

- EKR: The code now lets other plugins handle @folder and @url nodes.

- HTML generation: @rst nodes can now generate HTML, if Python docutils_ are
  installed. Simply give the filename an extension .htm or .html. You can try
  this out by renaming the filename in this @rst tree.

- underlines: I changed the order of the underline characters again. The "&gt;" is
  doesn't really look good as an underline in my opinion, so I moved it to a very
  low level.

- JD 2003-03-10 (rev 1.3): some more corrections to the unicode-&gt; encoding translation.
  No only check for missing docutils (doesn't mask other errors any more).

- JD 2003-03-11 (rev 1.4): separated out the file launching code to a different pluging.



</t>
<t tx="T571"># by Josef Dalcolmo 2003-01-13
#
# this does not check for proper filename syntax.
# path is the current dir, or the place @folder points to
# this should probably be changed to @path or so.

def onIconDoubleClick(tag,keywords):

	import os
	v = keywords.get("v")
	commands = keywords.get("c")
	h = v.headString().strip()
	if match_word(h,0,"@rst"):
		fname = h[5:]
		ext = os.path.splitext(fname)[1].lower()
		if ext in ('.htm','.html'):
			&lt;&lt; write rST as HTML &gt;&gt;
		else:
			&lt;&lt; write rST file &gt;&gt;
</t>
<t tx="T572">try:
	import docutils
except:
	docutils = None
	es('HTML generation requires docutils')
if docutils:
	import StringIO
	rstFile = StringIO.StringIO()
	writeTreeAsRst(rstFile, fname, v, commands)
	rstText = rstFile.getvalue()
	&lt;&lt; convert rST to HTML &gt;&gt;
	htmlFile = file(fname,'w')
	htmlFile.write(output)
	htmlFile.close()
	rstFile.close()
	es('written: '+`fname`)</t>
<t tx="T573"># this code snipped has been taken from code contributed by Paul Paterson 2002-12-05
from docutils.core import Publisher
from docutils.io import StringOutput, StringInput

pub = Publisher()
# Initialize the publisher
pub.source = StringInput(pub.settings, source=rstText)
pub.destination = StringOutput(pub.settings, encoding="utf-8")
pub.set_reader('standalone', None, 'restructuredtext')
pub.set_writer('html')
output = pub.publish()</t>
<t tx="T574">rstFile = file(fname,'w')
writeTreeAsRst(rstFile, fname, v, commands)
rstFile.close()
es('written: '+`fname`)</t>
<t tx="T575">def writeTreeAsRst(rstFile, fname, vnode, commands):
	'Writes the tree under vnode to the file rstFile (fname is the filename)'
	# we don't write a title, so the titlepage can be customized
	# use '#' for title under/overline
	# 3/7/03
	dict = scanDirectives(commands,v=vnode)
	encoding = dict.get("encoding",None)
	if encoding == None:
		encoding = app().config.default_derived_file_encoding
	# 3/7/03
	s = toEncodedString(fname,encoding,reportErrors=true)
	rstFile.write('.. filename: '+s+'\n')
	rstFile.write('\n')
	# 3/7/03
	s = vnode.bodyString()
	s = toEncodedString(s,encoding,reportErrors=true)
	rstFile.write(s+'\n')		# write body of titlepage
	rstFile.write('\n')
	
	toplevel = vnode.level()
	stopHere = vnode.nodeAfterTree()
	v = vnode.threadNext()
	# repeat for all nodes in this tree
	while v != stopHere:
		# 3/7/03
		h = v.headString()
		h = toEncodedString(h,encoding,reportErrors=true)
		rstFile.write(h+'\n')
		rstFile.write(underline(h,v.level()-toplevel))
		rstFile.write('\n')
		# 3/7/03
		s = v.bodyString()
		s = toEncodedString(s,encoding,reportErrors=true)
		rstFile.write(s+'\n')
		rstFile.write('\n')
		v = v.threadNext()</t>
<t tx="T576"># note the first character is intentionally unused, to serve as the underline
# character in a title (in the body of the @rst node)
def underline(h,level):
	str = """#=+*^~"'`-:&gt;&lt;_"""[level]
	return str*max(len(h),4)+'\n'</t>
<t tx="T577">"""Lauches (starts) a file with the name of the headline on double-clicking it.
Uses the @folder path if the headline is under an @folder headline.
Otherwise the path is relative to the Leo file.
Headlines starting with an '@' are ignored.
This does not work on Linux (yet)."""

# By Josef Dalcolmo: contributed under the same license as Leo.py itself.

from leoPlugins import *
from leoGlobals import *

&lt;&lt; about this plugin &gt;&gt;
&lt;&lt; change log &gt;&gt;

@others

if 0: # Register the handlers...
	registerHandler("icondclick1",onIconDoubleClick)
	
	__version__ = "1.1" # Set version for the plugin handler.
	plugin_signon(__name__)</t>
<t tx="T578">@ This plugin starts a file with the name of a headline.


</t>
<t tx="T579">@ Change log

- JD: 2003-03-11 separated out from rst plugin



</t>
<t tx="T580"># @folder behavior after an idea and sample code by:
# korakot ( Korakot Chaovavanich ) @folder for files annotation 2002-11-27 02:39
# 
# open file (double-click = startfile) behavior added 
# nodes with @url, @folder, @rst are treated special
#
# by Josef Dalcolmo 2003-01-13
#
# this does not check for proper filename syntax.
# path is the current dir, or the place @folder points to
# this should probably be changed to @path or so.

def onIconDoubleClick(tag,keywords):

	import os
	v = keywords.get("v")
	commands = keywords.get("c")
	h = v.headString().strip()
	if len(h)==0 or h[0]=='@':
		return # Let other plugins handle these
	else:
		# open file with associated application
		&lt;&lt; find path and start file &gt;&gt;</t>
<t tx="T581"># Set the base directory by searching for @folder directives in ancestors.
try:
	basedir = os.curdir	# use current dir as default.
	parv = v.parent()	# start with parent
	while parv:	# stop when no more parent found
		p = parv.headString().strip()
		if match_word(p,0,'@folder'):
			basedir = p[8:]	# take rest of headline as pathname
			break	# we found the closest @folder
		else:
			parv = parv.parent()	# try the parent of the parent
	fname = os.path.join(basedir,h) # join path and filename
	os.startfile(fname)	# Try to open the file; it may not work for all file types.
except:
	es(os.path.join(os.getcwd(),fname)+' - file or application not found')
	es_exception()
</t>
<t tx="T582"></t>
<t tx="T583">from leoPlugins import *
from leoGlobals import *

@others

if 0: # Override classes &amp; methods...

	if 0:
		&lt;&lt; override the LeoFrame class &gt;&gt;

	if 0:
		&lt;&lt; override methods of the LeoApp class &gt;&gt;

	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T584"># print "overriding LeoFrame class"

import leoFrame

assert(leoFrame.leoCoreFrame.instances==0)

class myLeoFrame(leoFrame.leoCoreFrame):
	
	pass
	
	if 0:
		def __init__(self,title=None):
			print "myLeoFrame ctor",title
			leoFrame.leoCoreFrame.__init__(self,title)

leoFrame.LeoFrame = myLeoFrame</t>
<t tx="T585">import leoApp

# print "overriding app.closeLeoWindow"

oldAppCloseLeoWindow = app().closeLeoWindow

def myAppCloseLeoWindow(self,frame):
	
	global oldAppCloseLeoWindow

	oldAppCloseLeoWindow(frame)
	print "after closeLeoWindow"

funcToMethod(myAppCloseLeoWindow,leoApp.LeoApp,"closeLeoWindow")</t>
<t tx="T586">"""Override the Equal Sized Pane command"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("command1", onCommand)
	
	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T587">def onCommand (tag,keywords):

	if keywords.get("label")=="equalsizedpanes":
		es("over-riding Equal Sized Panes")
		return "override" # Anything other than None overrides.</t>
<t tx="T588">"""Redefine the "put" and "put_nl" methods"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("start2", onStart)
	
	__version__ = "1.2"
	plugin_signon(__name__)</t>
<t tx="T589">@ This code illustrates how to redefine _any_ method of Leo.
Python makes this is almost too easy :-)
@c

def onStart (tag,keywords):

	import leoFrame
	
	# Replace frame.put with newPut.
	funcToMethod(newPut,leoFrame.LeoFrame,"put")
	
	# Replace frame.putnl with newPutNl.
	funcToMethod(newPutNl,leoFrame.LeoFrame,"putnl")
</t>
<t tx="T590"># Contrived examples of how to redefine frame.put and frame.putnl

# Same as frame.put except converts everything to upper case.
def newPut (self,s,color="black"):
	# print "newPut",s,
	if app().quitting &gt; 0: return
	s = s.upper()
	if self.log:
			self.log.insert("end",s)
			self.log.see("end")
			self.log.update_idletasks()
	else: print s,

# Same as frame.putnl except writes two newlines.
def newPutNl (self):
	# print "newPutNl"
	if app().quitting &gt; 0: return
	if self.log:
		self.log.insert("end","\n\n")
		self.log.see("end")
		self.log.update_idletasks()
	else: print</t>
<t tx="T591">"""Send all output to the log pane"""

from leoPlugins import *
from leoGlobals import *

def onStart (tag,keywords):
	from leoGlobals import redirectStdout,redirectStderr
	redirectStdout() # Redirect stdout
	redirectStderr() # Redirect stderr

if 0: # Register the handlers...
	registerHandler("start2", onStart)

	__version__ = "1.3" # Set version for the plugin handler.
	plugin_signon(__name__)

</t>
<t tx="T592">"""Send output from the Execute Script command to the end of the body pane"""

from leoPlugins import *
from leoGlobals import *

@others

if 0: # Register the handlers...
	registerHandler("start1", onStart)

	__version__ = "1.2" # Set version for the plugin handler.
	plugin_signon(__name__)
</t>
<t tx="T593">def onStart (tag,keywords):
	
	import leoFrame
	
	# Replace frame.put with newPut.
	funcToMethod(newExecuteScript,leoFrame.LeoFrame,"OnExecuteScript")
</t>
<t tx="T594"># Execute the _selected_ body text as a Python script and sends the output to the end of the body pane.

def newExecuteScript(self,event=None,v=None):
	
	c = self.commands ; body = self.body ; s = None
	if v == None:
		v = c.currentVnode() 

	# Assume any selected body text is a script.
	start,end = getTextSelection(body)
	if start and end and start != end: # 7/7/03
		s = body.get(start,end)
	else:
		s = ""
	s = s.strip()
	if s and len(s) &gt; 0:
		s += '\n' # Make sure we end the script properly.
		try:
			# Switch output.
			import leoFrame,leoGlobals
			oldput = leoFrame.LeoFrame.put
			oldputnl = leoFrame.LeoFrame.putnl
			oldes = leoGlobals.es
			oldenl = leoGlobals.enl
			oldecnl = leoGlobals.ecnl
			oldecnls = leoGlobals.ecnls
			leoGlobals.es = newEs
			leoGlobals.enl = newEnl
			leoGlobals.ecnl = newEcnl
			leoGlobals.ecnls = newEcnls
			funcToMethod(newPut,leoFrame.LeoFrame,"put")
			funcToMethod(newPutNl,leoFrame.LeoFrame,"putNl")
			redirectStderr()
			redirectStdout()
			exec s in {} # Use {} to get a pristine environment!
			# Restore output.
			funcToMethod(oldput,leoFrame.LeoFrame,"put")
			funcToMethod(oldputnl,leoFrame.LeoFrame,"putNl")
			leoGlobals.es = oldes
			leoGlobals.enl = oldenl
			leoGlobals.ecnl = oldecnl
			leoGlobals.ecnls = oldecnls
			restoreStderr()
			restoreStdout()
		except:
			es("exception executing script")
			es_exception(full=false)
	else:
		es("no script selected")
</t>
<t tx="T595"># Same as frame.put except sends output to the end of the body text.
def newPut (self,s):
	if self.body:
			self.body.insert("end",s)
			# self.body.see("end")
			c = self.commands ; v = c.currentVnode()
			self.tree.onBodyChanged(v,"Typing")
	else: print s,

# Same as frame.putnl exceptsends output to the end of the body text.
def newPutNl (self):
	newPut (self,'\n')</t>
<t tx="T596">def newEnl():
	print
	
def newEcnl():
	print
	
def newEcnls(n):
	while n &gt; 0:
		n -= 1
		print

def newEs(s,*args,**keys):
	newline = keys.get("newline",true)
	if type(s) != type("") and type(s) != type(u""):
		s = repr(s)
	for arg in args:
		if type(arg) != type("") and type(arg) != type(u""):
			arg = repr(arg)
		s = s + ", " + arg
	if newline:
		print s
	else:
		print s,
</t>
<t tx="T597"></t>
<t tx="T598">colour
colourful
coloured
</t>
<t tx="T599"># Configuration file for mod_spelling plugin.

[main]

aspell_dir=c:\aspell\bin\aspell.exe

local_leo_dictionary=c:\prog\leoCVS\leo\plugins\mod_spelling.txt

local_language_code=en</t>
<t tx="T600">"""Spell Checker Plugin

- Perfoms spell checking on nodes within a Leo document.
- Uses aspell.exe to do the checking and suggest alternatives."""

import leoFind,os,popen2,re,sys,Tkinter,traceback
from leoPlugins import *
from leoGlobals import *

Tk = Tkinter

@others

if 1: # Register the handlers...

	if app().gui == None:
		app().createTkGui()

	if app().gui.guiName() == "tkinter":

		spellFrame = spellDialog()
		spellFrame.top.withdraw()
		app().globalWindows.append(spellFrame)
		
		registerHandler("create-optional-menus",createSpellMenu)
		registerHandler("select2",onSelect)
		registerHandler("command2",onCommand) # For any command that might change the text.
		registerHandler("bodykey2",onSelect) # For updating buttons.
		registerHandler(("bodyclick2","bodydclick2","bodyrclick2"),onSelect) # These affect selection.
		
		__version__ = "0.2.0"
		plugin_signon(__name__)</t>
<t tx="T601"></t>
<t tx="T602">def createSpellMenu(tag,keywords):
	
	"""Create the Check Spelling menu item in the Edit menu."""
	
	c = keywords.get("c")

	table = (
		("-",None,None),
		("Check Spelling","Alt+Shift+A",spellFrame.checkSpelling))

	c.frame.createMenuItemsFromTable("Edit",table)</t>
<t tx="T603">def onSelect (tag,keywords):
	
	"""A new vnode has just been selected.  Update the Spell Check window."""

	c = keywords.get("c")
	v = keywords.get("new_v")
	global spellFrame
	
	if top() and c and c.currentVnode():
		if c.currentVnode() != spellFrame.v:
			# print "onSelect",tag,`c.currentVnode()`,`spellFrame.v`
			spellFrame.update(show=false,fill=true)
		else:
			spellFrame.updateButtons()</t>
<t tx="T604">def onCommand (tag,keywords):
	
	"""Update the Spell Check window after any command that might change text."""

	global spellFrame
	
	if top() and top().currentVnode():
		
		# print "onCommand",tag
		spellFrame.update(show=false,fill=false)</t>
<t tx="T605">class Aspell:
	
	"""A wrapper class for Aspell spell checker"""
	
	@others
</t>
<t tx="T606"></t>
<t tx="T607">def __init__(self,local_dictionary_file,local_language_code):
	
	"""Ctor for the Aspell class."""
	
	self.altre = re.compile(".\s(.+)\s(\d+)\s(\d+):(.*)")
	self.attached = None
	self.input,self.output = None,None
	self.signonGiven = false
	
	self.aspell_exe_loc = self.getAspellDirectory()
	self.local_language_code = local_language_code
	
	if local_dictionary_file:
		self.local_dictionary_file = local_dictionary_file
		self.local_dictionary = "%s.wl" % os.path.splitext(local_dictionary_file)[0]
	else:
		print "failed to set aspell.local_dictionary"
		self.local.dictionary_file = None
		self.local_dictionary = None</t>
<t tx="T608">def getAspellDirectory(self):
	
	"""Get the directory containing aspell.exe from mod_spelling.ini"""

	import ConfigParser

	try:
		fileName = os.path.join(app().loadDir,"../","plugins","mod_spelling.ini")
		config = ConfigParser.ConfigParser()
		config.read(fileName)
		return config.get("main","aspell_dir")
	except:
		es_exception()
		return None</t>
<t tx="T609">def openPipes (self):
	
	"""Open the pipes to aspell.exe"""
	
	if self.input or self.output:
		print "pipes already open!"
		self.closePipes()
	
	&lt;&lt; Ensure local dictionary is present &gt;&gt;
	cmd = "%s pipe %s" % (self.aspell_exe_loc, add_dicts)
	if not self.local_dictionary:
		print "openPipes: command = " + cmd
	
	try:
		self.input, self.output = popen2.popen2(cmd)
	except:
		print "exception opening pipe"
		self.input = self.output = None
	
	if self.input:
		self.attached = self.input.readline()
	else:
		self.attached = None
		
	if not self.signonGiven:
		self.signonGiven = true
		if self.attached:
			print self.attached
			es(self.attached,color="blue")
		else:
			print "can not open aspell"
			es("can not open aspell",color="red")</t>
<t tx="T610">add_dicts = ""

if self.local_dictionary:
	if self.updateDictionary():
		add_dicts = "--add-extra-dicts %s" % self.local_dictionary


</t>
<t tx="T611">def closePipes (self):
	
	"""Close the pipes to aspell.exe"""
	
	# if self.input or self.output: print "closePipes"
	
	if self.input:
		self.input.close()
		self.input = None

	if self.output:
		self.output.close()
		self.output = None</t>
<t tx="T612">def listAlternates(self, aspell_return):
	
	"""Return a list of alternates from aspell."""
	
	match = self.altre.match(aspell_return)

	if match:
		return [item.strip() for item in match.groups()[3].split(",")]
	else:
		return []</t>
<t tx="T613">def processWord(self, word):

	"""Pass a word to aspell and return the list of alternatives."""
	
	if not self.attached:
		return None

	# print "processWord",`word`,`self.output`
	
	self.output.write("%s\n" % word)
	
	ret,junk = self.input.readline(),self.input.readline()

	if ret == "*\n":
		return None
	else:
		return self.listAlternates(ret)</t>
<t tx="T614">def updateDictionary(self):
	
	"""Update the aspell dictionary from a list of words.
	
	Return true if the dictionary was update correctly."""

	try:
		# Create master list
		basename = os.path.splitext(self.local_dictionary)[0]
		cmd = (
			"%s --lang=%s create master %s.wl &lt; %s.txt" %
			(self.aspell_exe_loc,self.local_language_code,basename,basename))
		os.popen(cmd)
		return true

	except Exception, err:
		es("Unable to update local aspell dictionary: %s" % err)
		print err
		add_dicts = ""
		return false</t>
<t tx="T615">class spellDialog (leoFind.leoFindBase):
	
	"""A class to create and manage Leo's Spell Check dialog."""
	
	@others</t>
<t tx="T616"></t>
<t tx="T617">def __init__ (self):
	
	"""Ctor for the Leo Spelling dialog."""
	
	# Call the base ctor to create the dialog.
	leoFind.leoFindBase.__init__(self,"Leo Spell Checking",resizeable=false)
	
	self.local_dictionary_file = self.getLocalDictionary()
	self.local_language_code = self.getLocalLanguageCode("en")
	self.aspell = Aspell(self.local_dictionary_file,self.local_language_code)
	&lt;&lt; set self.dictionary &gt;&gt;
	
	self.createFrame()
	self.fillbox([])
	
	# State variables.
	self.currentWord = None
	self.suggestions = []
	self.c = None
	self.v = None
	self.body = None
	self.work = Tk.Text(None) # A text widget for scanning.

	self.listBox.bind("&lt;Double-Button-1&gt;",self.onChangeThenFindButton)
	self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
	self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="T618">if self.local_dictionary_file:

	self.dictionary = self.readLocalDictionary(self.local_dictionary_file)
	if self.dictionary:
		# print "Local dictionary:", self.local_dictionary_file
		es("Local dictionary: %s" % shortFileName(self.local_dictionary_file),color="blue")
		if 0:
			keys = self.dictionary.keys()
			keys.sort()
			print "local dict:", keys
	else:
		self.dictionary = {}
		self.local_dictionary_file = None
else:
	self.dictionary = {}</t>
<t tx="T619">def getLocalDictionary(self):
	
	"""Get the dictionaries containing words not in the standard dictionary from mod_spelling.ini"""

	import ConfigParser

	try:
		fileName = os.path.join(app().loadDir,"../","plugins","mod_spelling.ini")
		config = ConfigParser.ConfigParser()
		config.read(fileName)
		return config.get("main","local_leo_dictionary",None)
	except:
		es_exception()
		return None</t>
<t tx="T620">def getLocalLanguageCode(self,defaultLanguageCode):
	
	"""Get the dictionaries containing words not in the standard dictionary from mod_spelling.ini"""

	import ConfigParser

	try:
		fileName = os.path.join(app().loadDir,"../","plugins","mod_spelling.ini")
		config = ConfigParser.ConfigParser()
		config.read(fileName)
		return config.get("main","local_language_code",defaultLanguageCode)
	except:
		es_exception()
		return defaultLanguageCode</t>
<t tx="T621">def readLocalDictionary (self,local_dictionary):
	
	"""Read the dictionary of words which we use as a local dictionary
	
	Although Aspell itself has the functionality to handle this kind of things
	we duplicate it here so that we can also use it for the "ignore" functionality
	and so that in future a Python only solution could be developed."""

	try:
		f = open(local_dictionary,"r")
	except IOError:
		es("Unable to open local dictionary '%s' - using a blank one instead" % local_dictionary)
		return None
	
	try:
		# Create the dictionary - there are better ways to do this
		# in later Python's but we stick with this method for compatibility
		dct = {}
		for word in f.readlines():
			dct[word.strip().lower()] = 0
	finally:
		f.close()

	return dct</t>
<t tx="T622">def createFrame (self):
	
	"""Create the Spelling dialog."""
	
	# Create the find panel...
	outer = Tk.Frame(self.frame,relief="groove",bd=2)
	outer.pack(padx=2,pady=2,expand=1,fill="both")

	&lt;&lt; Create the text and suggestion panes &gt;&gt;
	&lt;&lt; Create the spelling buttons &gt;&gt;
</t>
<t tx="T623">f = outer

f2 = Tk.Frame(f)
f2.pack(expand=1,fill="x")
self.wordLabel = Tk.Label(f2, text="Suggestions for:")
self.wordLabel.pack(side="left")

fpane = Tk.Frame(f,bd=2)
fpane.pack(side="top", expand=1, fill="x")

self.listBox = Tk.Listbox(fpane,height=30,selectmode="single")
self.listBox.pack(side="left", expand=1, fill="both")

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

for bar,txt in ((listBoxBar,self.listBox),):
	txt['yscrollcommand'] = bar.set
	bar['command'] = txt.yview
	bar.pack(side="right", fill="y")
</t>
<t tx="T624"># Create the button panes
buttons1  = Tk.Frame(outer,bd=1)
buttons1.pack (anchor="n",expand=1,fill="x")

buttons2  = Tk.Frame(outer,bd=1)
buttons2.pack (anchor="n",expand=1,fill="none")

buttonList = []
for text,command in (
	("Find",self.onFindButton),
	("Change",self.onChangeButton),
	("Change, Find",self.onChangeThenFindButton),
	("Add",self.onAddButton)):
	width = max(6,len(text))
	b=Tk.Button(buttons1,width=width,text=text,command=command)
	b.pack(side="left",fill="none",expand=1)
	buttonList.append(b)
		
for text,command in (
	("Undo",self.onUndoButton),
	("Redo",self.onRedoButton),
	("Ignore",self.onIgnoreButton),
	("Hide",self.onHideButton)):
	width = max(6,len(text))
	b=Tk.Button(buttons2,width=width,text=text,command=command)
	b.pack(side="left",fill="none",expand=0)
	buttonList.append(b)

# We need these to enable or disable buttons.
(self.findButton, self.changeButton,
 self.changeFindButton, self.addButton, 
 self.undoButton, self.redoButton,
 self.ignoreButton, self.hideButton) = buttonList</t>
<t tx="T625"></t>
<t tx="T626">def onAddButton (self):
	
	"""Handle a click in the Add button in the Check Spelling dialog."""

	self.add()
	self.closePipes()

</t>
<t tx="T627">def onIgnoreButton (self):

	"""Handle a click in the Ignore button in the Check Spelling dialog."""

	self.ignore()
	self.closePipes()</t>
<t tx="T628">def onChangeButton (self):
	
	"""Handle a click in the Change button in the Check Spelling dialog."""

	self.change()
	self.closePipes()
	self.updateButtons()
	
# Event needed for double-click event.
def onChangeThenFindButton (self,event=None): 
		
	"""Handle a click in the "Change, Find" button in the Check Spelling dialog."""

	if self.change():
		self.find()
	self.closePipes()
	self.updateButtons()</t>
<t tx="T629">def onFindButton (self):
	
	"""Handle a click in the Find button in the Check Spelling dialog."""

	self.find()
	self.updateButtons()
	self.closePipes()</t>
<t tx="T630">def onHideButton (self):
	
	"""Handle a click in the Hide button in the Check Spelling dialog."""

	self.closePipes()
	self.top.withdraw()
</t>
<t tx="T631">def onRedoButton (self):
	
	"""Handle a click in the Redo button in the Check Spelling dialog."""

	self.c.undoer.redo() # Not a command, so command hook doesn't fire.
	self.update(show=false,fill=false)
	self.c.frame.body.focus_force()
	
def onUndoButton (self):
	
	"""Handle a click in the Undo button in the Check Spelling dialog."""

	self.c.undoer.undo() # Not a command, so command hook doesn't fire.
	self.update(show=false,fill=false)
	self.c.frame.body.focus_force()</t>
<t tx="T632"></t>
<t tx="T633">def add (self):

	"""Add the selected suggestion to the dictionary."""
	
	if not self.local_dictionary_file:
		return
	
	try:
		f = None
		try:
			# Rewrite the dictionary in alphabetical order.
			f = open(self.local_dictionary_file,"r")
			words = f.readlines()
			f.close()
			words = [word.strip() for word in words]
			words.append(self.currentWord)
			words.sort()
			f = open(self.local_dictionary_file,"w")
			for word in words:
				f.write("%s\n" % word)
			f.flush()
			f.close()
			es("Adding ",color="blue",newline=false) ; es('%s' % self.currentWord)
		except IOError:
			es("Can not add %s to dictionary" % self.currentWord,color="red")
	finally:
		if f: f.close()
		
	self.dictionary[self.currentWord.lower()] = 0
	
	# Restart aspell so that it re-reads its dictionary.
	self.aspell.closePipes()
	self.aspell.openPipes()
	
	self.onFindButton()</t>
<t tx="T634">def change(self):
	
	"""Make the selected change to the text"""

	c = self.c ; v = self.v ; t = self.body
	
	selection = self.getSuggestion()
	if selection:
		start,end = oldSel = getTextSelection(t)
		if start:
			if t.compare(start, "&gt;", end):
				start,end = end,start
			t.delete(start,end)
			t.insert(start,selection)
			setTextSelection(t,start,start + "+%dc" % (len(selection)))
			newSel = getTextSelection(t)

			# update node, undo status, dirty flag, changed mark &amp; recolor
			c.beginUpdate()
			c.tree.onBodyChanged(v,"Change",oldSel=oldSel,newSel=newSel)
			c.endUpdate(true)
			t.focus_set()
			return true

	# The focus must never leave the body pane.
	t.focus_set()
	return false</t>
<t tx="T635">def checkSpelling (self,event=None):
	
	"""Open the Check Spelling dialog."""

	self.top.deiconify()
	self.top.lift()
	self.update(show=true,fill=false)</t>
<t tx="T636">def find(self):
	
	"""Find the next unknown word."""
	
	# Reload the work pane from the present node.
	s = self.body.get("1.0","end").rstrip()
	self.work.delete("1.0","end")
	self.work.insert("end",s)
	
	# Reset the insertion point of the work widget.
	ins = self.body.index("insert")
	self.work.mark_set("insert",ins)

	alts,word = self.findNextMisspelledWord()
	self.currentWord = word # Need to remember this for 'add' and 'ignore'
	
	if alts:
		self.fillbox(alts,word)
		self.body.focus_set()
					
		# Copy the working selection range to the body pane
		start,end = getTextSelection (self.work)
		setTextSelection (self.body,start,end)
	else:
		es("no more misspellings")
		self.fillbox([])</t>
<t tx="T637">def ignore (self):
	
	"""Ignore the incorrect word for the duration of this spell check session."""
	
	es("Ignoring ",color="blue",newline=false) ; es('%s' % self.currentWord)
	self.dictionary[self.currentWord.lower()] = 0
	self.onFindButton()</t>
<t tx="T638"></t>
<t tx="T639">def closePipes(self):
	
	self.aspell.closePipes()</t>
<t tx="T640">def fillbox(self,alts,word=None):

	"""Update the suggestions listbox in the Check Spelling dialog."""
	
	self.suggestions = alts
	
	if not word:
		word = ""

	self.wordLabel.configure(text = "Suggestions for: " + word)
	self.listBox.delete(0,"end")

	for i in xrange(len(self.suggestions)):
		self.listBox.insert(i,self.suggestions[i])
	
	if len(self.suggestions):
		self.listBox.select_set(1) # This doesn't show up because we don't have focus.</t>
<t tx="T641">def findNextMisspelledWord(self):
	
	"""Find the next unknown word."""
	
	aspell = self.aspell ; alts = None ; word = None
	c = self.c ; v = self.v
	try:
		aspell.openPipes()
		try:
			while 1:
				v,word = self.findNextWord(v) 
				if not v or not word:
					alts = None
					break
				&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
				alts = aspell.processWord(word)
				if alts:
					self.v = v
					c.beginUpdate()
					c.tree.expandAllAncestors(v)
					c.selectVnode(v)
					c.endUpdate()
					break
		except:
			es_exception()
	finally:
		aspell.closePipes()
		return alts, word</t>
<t tx="T642">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not true and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
	
	# print "Ignored", word
	continue
	
# print "Didn't ignore '%s'" % word</t>
<t tx="T643">def findNextWord (self,v):
	
	"""Scan for the next word, leaving the result in the work widget"""

	t = self.work
	word_start = string.letters + '_'
	t.mark_set("insert","insert wordend + 1c")
	while 1:
		# print `t.index("insert")`,`t.index("end-1c")`
		if t.compare("insert","&gt;=","end - 1c"):
			v = v.threadNext()
			if not v: return None,None
			t.delete("1.0","end")
			t.insert("end",v.bodyString())
			t.mark_set("insert","1.0")
		elif t.compare("insert","&gt;=","insert lineend - 1c"):
			t.mark_set("insert","insert lineend + 1line")
		else:
			ch = t.get("insert")
			if ch in word_start:
				word = t.get("insert wordstart","insert wordend")
				setTextSelection(t,"insert wordstart","insert wordend")
				# print "findNextWord:",`word`
				return v,word
			elif ch:
				t.mark_set("insert","insert + 1c")</t>
<t tx="T644">def getSuggestion (self):
	
	"""Return the selected suggestion from the listBox."""
	
	# Work around an old Python bug.  Convert strings to ints.
	items = self.listBox.curselection()
	try:
		items = map(int, items)
	except ValueError: pass

	if items:
		n = items[0]
		suggestion = self.suggestions[n]
		return suggestion
	else:
		return None</t>
<t tx="T645">def onMap (self,event=None):
	
	"""Respond to a Tk &lt;Map&gt; event."""
	
	self.update(show=false,fill=false)</t>
<t tx="T646">def onSelectListBox (self,event=None):
	
	"""Respond to a click in the selection listBox."""
	
	self.updateButtons()
	self.body.focus_set()
</t>
<t tx="T647">def update (self,show=true,fill=false):
	
	"""Update the Spell Check dialog."""
	
	# print "update(show=%d,fill=%d)" % (show,fill)
	
	# Always assume that the user has changed text.
	self.c = c = top()
	self.v = c.currentVnode()
	self.body = c.frame.body
	if fill:
		self.fillbox([])
	self.updateButtons()
	if show:
		self.top.deiconify()
		# Don't interfere with Edit Headline commands.
		self.body.focus_set()
		
	# Give the signon if it hasn't been given yet.
	if not self.aspell.signonGiven:
		self.aspell.openPipes()
		self.aspell.closePipes()</t>
<t tx="T648">def updateButtons (self):
	
	"""Enable or disable buttons in the Check Spelling dialog."""
	
	start,end = getTextSelection(self.body)
	state = choose(self.suggestions and start,"normal","disabled")
	
	self.changeButton.configure(state=state)
	self.changeFindButton.configure(state=state)

	state = choose(self.c.undoer.canRedo(),"normal","disabled")
	self.redoButton.configure(state=state)
	
	state = choose(self.c.undoer.canUndo(),"normal","disabled")
	self.undoButton.configure(state=state)
	
	state = choose(self.local_dictionary_file,"normal","disabled")
	self.addButton.configure(state=state)

	self.ignoreButton.configure(state="normal")</t>
<t tx="T649">@ignore</t>
<t tx="T650">@nocolor

Attached is some proof-of-concept code for a Leo Plugin manager.

To try it out ... (warning: it will write files to your c:\temp directory)

1. Start 'leopm_server.py' ... Should display a message saying "Listening on 8001"
2. Start 'leopm_client.py' ... Should bring up an ugly Tkinter window

How it works:

1. The client attaches to the remote server (via XMLRPC) 
2. Client asks for a list of plug-ins
3. Server responds
4. Client asks for details of files required + version for each plugin
5. Client checks local plugin directory to see if these files are there and if they are the right version.
6. Client displays list of available + installed plugins
7. User selects plugin and clicks 'Install'
8. Client requests files from server
9. Server sends back files
10. Client installs files in local directory (currently c:\temp)

In the current code, the client side is functional - the server side is
actually dummy methods just returning the right kind of data. There's no
point doing anything clever there until the client functionality is
fully fleshed out. Although it is all running locally in the demo there
aren't any code changes required to run remotely.

It is all pretty primitive, but I think the functionality maps quite
closely with jEdit. Tidying the Tkinter interface and fleshing out the
server side shouldn't take too long and then it could be wrapped as a
plugin itself.

Advantages of this (XMLRPC) approach,

- can go over HTTP port
- client and server are nicely decoupled (server needn't be in Python if the web host doesn't support it)
- client/server stuff is so transparent (look at the server implementation!) compared to other approaches.

Some kind of 'submit plugin' option would be interesting, but suddenly security issues start to loom!

Do you think this is worth pursuing?</t>
<t tx="T651">@first #!/usr/bin/env python

"""A client implementing a plug-in manager for Leo

The client is based on an XML server architecture. Methods exist
to query the plug-ins on the server, find version numbers, help information and
to download the actual source. In the future it might be possible to upload
plug-ins as well."""

from Tkinter import *
import os,re,xmlrpclib

__version__ = "0.1"

PORT = 8001 # The port the server is listening on
HOST = "http://localhost:%d" % PORT
ROOTDIR = r"c:\temp" # Where the plugins will end up

@others

if __name__ == "__main__":
    server = xmlrpclib.ServerProxy(HOST)
    root = Tk()
    client = LeoPMClient(root, server, ROOTDIR)
    root.mainloop()
</t>
<t tx="T652">class LeoPMClient:
	
	"""The client to talk to the LeoPM server"""

	@others
</t>
<t tx="T653">def __init__(self, master, server, rootdir):
    """Initialize the client"""
    self.server = server
    self.master = master
    self.rootdir = rootdir
    #
    frame = Frame(master)
    frame.pack()
    #
    l = Label(frame, text="Leo Plugin Manager")
    l.pack(side=TOP)
    # Get the list of plugins
    listbox = Listbox(frame)
    listbox.pack(side=TOP)
    self.listbox = listbox
    self.initListbox()
    # Detail box for additional information
    text = Text(frame)
    text.pack(side=TOP)
    self.text = text
    #
    buttonframe = Frame(frame)
    buttonframe.pack(side=BOTTOM)
    #
    quit = Button(buttonframe, text="QUIT", fg="red", command=master.quit)
    quit.pack(side=RIGHT)
    #
    download = Button(buttonframe, text="Download", command=self.downloadPlugin)
    download.pack(side=LEFT)
    # Start polling for changes in selection
    self.lastselection = None
    self.poll() </t>
<t tx="T654">def poll(self):
    """Poll and update the detail view if appropriate"""
    now = self._getSelectedPluginName()
    if now is not None and now != self.lastselection:
        self.updateDetail(now)
        self.lastselection = now
    self.master.after(250, self.poll)
</t>
<t tx="T655">def _getSelectedPluginName(self):
    """Return the currently selected plugin name"""
    sel = self.listbox.curselection()
    if sel:
        return self.plugins[int(sel[0])]
    else:
        return None
</t>
<t tx="T656">def updateDetail(self, name):
    """Update the detail view of a plugin"""
    self.text.delete(1.0, END)
    self.text.insert(END, self.server.getPluginDescription(name))
</t>
<t tx="T657">def downloadPlugin(self):
    """Download the selected plugin"""
    self.text.insert(END, "\n\nInstalling\n")
    data = self.server.getPlugin(self._getSelectedPluginName())
    self.text.insert(END, "Got plugin data\n")
    for filename, text in data:
        self.text.insert(END, "Copying file '%s' ..." % filename)
        f = file(os.path.join(self.rootdir, filename), "w")
        f.write(text)
        f.close()
        self.text.insert(END, "Done!\n")
    self.text.insert(END, "\n\nPlugin installed\n")
    self.initListbox()
</t>
<t tx="T658">def getPluginList(self):
    """Return a list of plugins on the server
    
    We markup the list to show which plugins are installed etc
    
    """
    ret = []
    self.plugins = server.getPluginNames()
    for name in self.plugins:
        version = server.getPluginVersion(name)
        files = server.getPluginFilenames(name)
        #
        found = 0
        version = None
        #
        for fname in files:
            # Is file already installed?
            filename = os.path.join(self.rootdir, fname)
            if os.path.isfile(filename):
                found += 1
                # Check version
                version = version or self.getVersionOfFile(filename)
        #
        if found == len(files):
            version = version or "Unknown"
            ret.append("%s - installed (v%s)" % (name, version))
        elif found:
            ret.append("%s - partially installed" % name)
        else:
            ret.append(name)
    #
    return ret
</t>
<t tx="T659">def initListbox(self):
    """Initialize the listbox"""
    plugin_list = self.getPluginList()
    self.listbox.delete(0, END)
    for item in plugin_list:
        self.listbox.insert(END, item)
</t>
<t tx="T660">def getVersionOfFile(self, filename):
    """Check the version of a plugin file"""
    ver = re.compile('.*__version__\s*=\s"(.*?)".*', re.DOTALL+re.MULTILINE)
    f = file(filename, "r")
    text = f.read()
    f.close()
    match = ver.match(text)
    if match:
        return match.groups()[0]
    else:
        return None
</t>
<t tx="T661">@first #!/usr/bin/env python

"""A server implementing a plug-in manager for Leo

The server is based on an XML server architecture. Methods exist
to query the plug-ins on the server, find version numbers, help information and to
download the actual source. In the future it might be possible to upload
plug-ins as well."""

import SimpleXMLRPCServer

__version__ = "0.1"

PORT = 8001

@others
        
if __name__ == "__main__":
    # Create the server
    leoPluginManager = LeoPM()
    server = SimpleXMLRPCServer.SimpleXMLRPCServer(("localhost", PORT))
    server.register_instance(leoPluginManager)
    # Go into the main listener loop
    print "LeoPM (v%s) Started\nListening on port %s" % (__version__, PORT)
    server.serve_forever()</t>
<t tx="T662">class LeoPM:
	"""The Leo Plugin manager XMLRPC server"""
	@others
</t>
<t tx="T663">def __init__(self, plugin_dir="."):
    """Start the server with plugins located in the specified directory"""
</t>
<t tx="T664">    #self._locatePlugins()
    
def getPluginNames(self):
    """Return a list of the plug-ins by name"""
    return ["one", "two", "three"]
</t>
<t tx="T665">def getPluginDescription(self, name):
	
    """Return the description of the plugin"""

    return "%s - v%s\n\n%s" % (name, len(name), "Some important details about it")
</t>
<t tx="T666">def getPlugin(self, name):

    """Get the source files for a plugin
    
    Files are returned as a list of tuples (filename, text)"""

    return [("%s1.py" % name, 'this is #1\n__version__ = "%d"' % len(name)),
            ("%s2.py" % name, 'this is #2\n__version__ = "%d"' % len(name))]
</t>
<t tx="T667">def getPluginVersion(self, name):
	
    """Return the plugin version"""

    return len(name)
</t>
<t tx="T668">def getPluginFilenames(self, name):
	
    """Return a list of the files needed by a plugin"""
    return ("%s1.py" % name, "%s2.py" % name)</t>
</tnodes>
</leo_file>
