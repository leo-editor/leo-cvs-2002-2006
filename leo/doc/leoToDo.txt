#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20060116073938:To do 4.4a6-b3
#@+node:ekr.20060215055823:Arrow keys destroy UNL line
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3577022
By: tfer

You can click nodes and get the UNL to display, but when arrowing around the
tree, UNL area flashes the unl and then clears it immediately.
#@nonl
#@-node:ekr.20060215055823:Arrow keys destroy UNL line
#@+node:ekr.20051126122638:Autocompletion tab
- Use typing completion to select desired word.
- No auto-scan: use database instead.
- Scan button does manual scan.
- Use import or inspect instead of text scan.
- @strings autocompleter-info
list of names for which classes are known: c,frame,g,k,p,t,tree,v etc.
  (Autocompleter may already do this)
#@+node:ekr.20060214110318:Options
- Manual update only.
#@nonl
#@-node:ekr.20060214110318:Options
#@+node:ekr.20051205093049:Use dir for auto-complete ?
@nocolor

Working throught the IronPython tutorial just now I saw how useful the dir function could be, especially dir(object)

I'm thinking that Leo might use dir(object) to discover members for the auto-complete command.  It's not clear if or how this can be made to work, but it might be slick.
#@nonl
#@-node:ekr.20051205093049:Use dir for auto-complete ?
#@+node:ekr.20051025144611:Reference (Do not delete)
#@+node:ekr.20051025144611.1:Configuration
@nocolor
#@nonl
#@+node:ekr.20051025144611.2:autocompleter.ini
The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.
#@nonl
#@-node:ekr.20051025144611.2:autocompleter.ini
#@+node:ekr.20051025144611.3:.ato files in the autocompleter folder
The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word(     ) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.
#@nonl
#@-node:ekr.20051025144611.3:.ato files in the autocompleter folder
#@-node:ekr.20051025144611.1:Configuration
#@+node:ekr.20051025144611.4:autocompleter.py
<< docstring >>
<<imports>>
<<version history>>
<<a note on newCreateControl>>
<<coding conventions>>
<< configuration >>

#These two global determine if the autocompleter and calltip systems are used.  Default is on.
useauto = 1
usecall = 1

<<globals>>
<<patterns>>

@others
#@nonl
#@+node:ekr.20051025144611.5:<< docstring >>
'''Autocompletion and calltips plugin.

- ``.`` summons the autocompletion.
- ``(`` summons the calltips
- ``Escape`` closes either box.
- ``Ctrl`` selects an item.
- ``alt-up_arrow``, ``alt-down_arrow`` move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocomplete.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesnt find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleters runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.
'''
#@nonl
#@-node:ekr.20051025144611.5:<< docstring >>
#@+node:ekr.20051025144611.6:<< imports >>
## import leoTkinterFrame 

import sets 
import threading
import weakref
#@nonl
#@-node:ekr.20051025144611.6:<< imports >>
#@+node:ekr.20051025144611.7:<<version history>>
@
.425:
    -The initial scan thread is now a daemon thread.
    -Creates autocompleter box and Calltip box once.
    -Broke long functions apart.
    -'Esc'now closes autobox and calltip.

.500 EKR:
    - Made minor changes based on .425:
    -Improved docstring.
    -Converted to 4.2style.
.501 EKR:
    - Changed select method following patch by original author.
    - Added event.keysym=='Up' case to
.55 Lu:
     - Made the watcher def more greedy.  See def for rationale
     - Made the calltip identification regex more liberal.
     - streamlined some code.
     - added DictSet class, experimental in the sense that I haven't had a bug with it yet.  see <<DictSet>> node, under << globals>>
     - discovered dependency between this and Chapters, auto needs to be loaded first
.60 Lu
    - Changed some method names to more acuaretely reflect what they do.  Added more comments.
    - processKeyStroke cleaned up.
    - added Functionality where any mouse button press, anywhere in Leo will turn off autobox and calltip label.
    - waiting for Chapters( or chapters ) to have its walkChapters def fixed up, so we can walk the chapters on startup.
 .7 Lu( The placer revolution!)
   -migrated to the placer!  This got rid of Canvas based drawing.  The placer may be a good tool to know in the future.  This seemed to
   be about an even replacement codewise, but I think it gives us an efficiency boost.
   -changed some lambdas to defs, more for clarities sake then anything.
   -made global changes to how objects are referred to
   -got rid of factory defs, autobox and calltip label are created at Editor creation time
   -dependency between this and Chapters eliminated.
   -added code to automatically create the .ini file and the autocompleter directory if they do not exist.
   -added a section about how to configure autocompleter
   -switched the patterns from using '+' to add pieces together to using '%s'.
.71 investigated and hopefully fixed startup bug on Windows. Changes that appear to have fixed it:
1. We synchronize with an threading Event object.  IO acting screw on windows in a thread.
2. There is a global flag indicating whether the config file needs to be read again.
3. Explicitly set the file type to 't'.  This could all be attributed to a bug in ConfigParser.  I looked at the source and it doesnt write its data with a 't'.  This indicates trouble with windows.
4. Make the 'aini' path composed of os.sep instead of the char '/'.  Im uncertain if the config file ever got read on Windows at this point because of the explicit '/' , instead of using os.path.
5. Moved createConfig part out of thread. problems seems centered on Windows/IO/Threading.

 .72 The thesis and experiments to confirm the problem identified in .71 appear
completely wrong. I could not recreate threading+writeIO staling on XP at all.
Windows 98 didnt even work. But after commenting out g.es calls it did work. My
new target for the problem is now focused on keeping g.es calls out of the
initialScan thread. This will just entail moving all the reading and writing of
the config and language files out of the thread.

.73 EKR:
    - Changed 'new_c' logic to 'c' logic in initialScan.
    - Added init function.
.74 EKR:
    - Changed 'start2' hook to 'new' hook.
.75 EKR:
    - Disable scan during unit testing.
#@nonl
#@-node:ekr.20051025144611.7:<<version history>>
#@+node:ekr.20051025144611.8:<<a note on newCreateControl>>
@

the function newCreateControl decorates the leoTkinterFrame.leoTkinterBody.createControl method.
It does so to intercept the point where the editor is created.  By doing so, autocompleter is able
to ensure that the placer is used instead of the packer.  By using the placer autocompleter is able
to put the autobox and calltip label over the editor when the appropiate time is reached.  In versions
prior to .7, this was achieved by using a Tk Canvas as the background of the Editor.  The placer is simpler
and from what I see more efficient.

#@-node:ekr.20051025144611.8:<<a note on newCreateControl>>
#@+node:ekr.20051025144611.10:<<coding conventions>>
@

context - means the widget that backs the editor.  In versions before .7 it was called c and was a canvas.  context is the new name, and it is no longer a canvas. c, now means commander.

context.autobox - means the Pmw.ScrolledListBox that offers the autocompletion options.

The autobox contains other widgets that can be accessed by autobox.component( 'widgetname' )

context.calltip - means the Tk.Label that offers calltip information

context.which = 0 indicates its in autocompleter mode
context.which = 1 indicates its in calltip mode
#@nonl
#@-node:ekr.20051025144611.10:<<coding conventions>>
#@+node:ekr.20051025144611.11:<< configuration >>
@
Autocompleter looks in the plugin directory for a file called autocompleter.ini

This file contains two options under the [ autocompleter ] section:
    useauto
    usecalltips
    setting either to 1 will turn on the feature. 0 means off.
If there is a section called [ newlanguages ] it will read each option as a new language for autocompleter to recognize,
and compile its value as a regex pattern for the autocompleter system to recognize as a calltip.  This has relevance for the .ato
system described below.

languages that currently have patterns:
    python, java, c++, c and perl
This file will automatically be generated for the user if it does not exist at startup time.


Autocompleter looks in the plugin directory for a directory called autocompleter.  If it doesnt find one
it will attempt to create this directory.  This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a languages name.  For example:
    python.ato
    autocompleter recognizes python, and will scan this file.  The contents are read with the same mechanism that
    reads the information in the nodes, so calltip and autocompleter information is added to autocompleters runtime database.
If a new language has been added in the autocompleter.ini file then an .ato file that starts with the new languages name will be recognized and read in.  Note, this language needs to be recognizable to Leo.
Used correctly an .ato file is a mechanism by which a user can carry autocompletion and calltip information between .leo files/sessions.
#@nonl
#@-node:ekr.20051025144611.11:<< configuration >>
#@+node:ekr.20051025144611.12:<< globals >>
orig_CreateControl = leoTkinterFrame.leoTkinterBody.createControl 

<<DictSet>>
#watchwords ={} switched to DictSet
watchwords = DictSet() # a DictSet that is the autocompleter database.
#calltips ={} switched to DictSet
calltips = DictSet( factory = DictSet) # a DictSet that is the calltip database
pats ={} #used to hold regex patterns to find defintions for calltips
lang = None #determines what language is in effect.  Though its global, only one autobox or calltip label should be visible for the entire leo instance.
configfilesread = False #Determines if the config files need to be read
haveseen = weakref.WeakKeyDictionary()# a dict that tracks the commanders that have been seen without stopping garbage collection of that commander.
#@+node:ekr.20051025144611.13:<<DictSet>>
class DictSet( dict ):
    '''A dictionary that always returns either a fresh sets.Set or one that has been stored from a previous call.
    a different datatype can be used by setting the factory keyword in __init__ to a different class.'''
    
    def __init__( self , factory = sets.Set ):
        dict.__init__( self )
        self.factory = factory
        
    def __getitem__( self, key ):
        try:
            return dict.__getitem__( self, key ) # EAFTP
        except:
            dict.__setitem__( self, key, self.factory() )
            return dict.__getitem__( self, key )
#@-node:ekr.20051025144611.13:<<DictSet>>
#@-node:ekr.20051025144611.12:<< globals >>
#@+node:ekr.20051025144611.14:<< patterns >>
# This section defines patterns for calltips.
space = r'[ \t\r\f\v ]+'
end = r'\w+\s*\([^)]*\)'

pats ['python'] = re.compile(r'def\s+%s' % end)

pats ['java'] = re.compile(
    r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
        space, space, end))

pats ['perl'] = re.compile(r'sub\s+%s' % end)

pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (space,end))

pats ['c'] = re.compile(r'\w+%s%s' % (space,end))

r = string.punctuation.replace('(','').replace('.','')
pt = string.digits + string.letters + r

ripout = string.punctuation + string.whitespace + '\n'
ripout = ripout.replace('_','')

okchars = {}
for z in string.ascii_letters:
    okchars [z] = z
okchars ['_'] = '_'
#@nonl
#@-node:ekr.20051025144611.14:<< patterns >>
#@+node:ekr.20051025170832:Initialization
#@+node:ekr.20051025144611.15:init
def init ():
    
    ok = Pmw and Tk and not g.app.unitTesting # Not for unit tests: modifies core classes.
    
    if ok:
        leoTkinterFrame.leoTkinterBody.createControl = newCreateControl 
        leoPlugins.registerHandler(('new','open2'),initialScan)   
        g.plugin_signon(__name__)
        
    return ok
#@nonl
#@-node:ekr.20051025144611.15:init
#@+node:ekr.20051025170832.1:Config stuff
#@+node:ekr.20051025144611.24:has read config file meths
#These functions determine if the config and language files have been read or not.
# No need to read it more than once.

def hasReadConfig():
    return configfilesread

def setReadConfig():
    global configfilesread
    configfilesread = True
#@nonl
#@-node:ekr.20051025144611.24:has read config file meths
#@+node:ekr.20051025144611.25:readConfigFile
def readConfigFile (aini):
    '''reads the autocompleter config file in.'''
    global usecall, useauto 
    
    try:
        cp = ConfigParser.ConfigParser()
        fp = open( aini, 'rt' )
        cp.readfp( fp )
        fp.close()
    except Exception, x:
        g.es( "Could not open %s because of %s" % ( aini, x ), color = 'red' )
    ac = None 
    
    for z in cp.sections():
        if z.strip()=='autocompleter':
            ac = z 
        else:
            continue
        if cp.has_section(ac):
            if cp.has_option(ac,'useauto'):
                useauto = int(cp.get(ac,'useauto'))
                if useauto:
                    g.es( "autocompleter enabled", color = 'blue' )
            if cp.has_option(ac,'usecalltips'):
                usecall = int(cp.get(ac,'usecalltips'))
                if usecall:
                    g.es( "calltips enabled" , color = 'blue' )
        break

    nl = None
    for z in cp.sections():
        if z.strip()=='newlanguages':
            nl = z 
        else:
            continue
        if nl and cp.has_section( nl ):
            for z in cp.options( nl ):
                try:
                    pats[ z ] = re.compile( cp.get( nl, z ) )
                    g.es( 'added %s to autocompleter languages' % z , color = 'blue' )
                except Exception, x:
                    g.es( "Could not add %s pattern, because of %s " %( z, x ) , color = 'red')
                    
        break
#@-node:ekr.20051025144611.25:readConfigFile
#@+node:ekr.20051025144611.26:createConfigFile
def createConfigFile( aini ):
    '''This function creates a config file identified by the parameter aini'''
    cp = ConfigParser.ConfigParser()
    cp.add_section( 'autocompleter' )
    cp.set( 'autocompleter', 'useauto', '1' )
    cp.set( 'autocompleter', 'usecalltips', '1' )
    cp.add_section( 'newlanguages' )
    try:
        ini = open( aini, 'wt' )
        cp.write( ini )
        ini.close()
        g.es( "autocompleter .ini file created in %s" % aini, color = 'blue' )
    except Exception, x:
        g.es( "Error in creating %s, caused by %s" % ( aini, x ) , color = 'red' )


#@-node:ekr.20051025144611.26:createConfigFile
#@+node:ekr.20051025144611.27:readLanguageFiles
def readLanguageFiles (bankpath):
    '''reads language files in directory specified by the bankpath parameter'''
    global lang
    if not os.path.exists( bankpath ):
        try:
            os.mkdir( bankpath )
        except Exception, x:
            g.es( "Could not make %s because of %s" %( bankpath, x ) )
    for z in pats:
        bpath = bankpath+z+'.ato'
        if os.path.exists(bpath):
            f = open(bpath)
            lang = z 
            map( scanText, f )
            #for x in f:
            #    scanText(x)
            f.close()
#@nonl
#@-node:ekr.20051025144611.27:readLanguageFiles
#@+node:ekr.20051025144611.28:readOutline
def readOutline (c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    global lang
    if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
        import chapters 
        it = chapters.walkChapters()
        for x in it:
            lang = None 
            setLanguage(x)
            scanText(x.bodyString())
    else:
        for z in c.rootPosition().allNodes_iter():
            setLanguage( z )
            scanText( z.bodyString() )
#@nonl
#@-node:ekr.20051025144611.28:readOutline
#@-node:ekr.20051025170832.1:Config stuff
#@+node:ekr.20051025144611.16:watcher
watchitems = ('.',')')
txt_template = '%s%s%s'

def watcher (event):
    '''A function that tracks what chars are typed in the Text Editor.
    Certain chars activate the text scanning code.'''
    global lang
    if not (event.char.isspace() or event.char in watchitems):
        return
        
@
This if statement ensures that attributes set in another node are put in the
database.Of course the user has to type a whitespace to make sure it happens.
We try to be selective so that we dont burn through the scanText def for  every
whitespace char entered.This will help when the nodes become big.
@c
    bCtrl = event.widget
    if event.char.isspace():
        # Do nothing if the previous char was a whitespace
        if bCtrl.get('insert -1c').isspace(): return
        if bCtrl.get('insert -1c wordstart -1c') != '.': return
    c = bCtrl.commander
    lang = c.frame.body.getColorizer().language
    txt = txt_template % (
        bCtrl.get("1.0",'insert'),
        event.char, bCtrl.get('insert',"end"))
        # Add the newest char; its not in the bCtrl yet
    scanText(txt)
#@nonl
#@-node:ekr.20051025144611.16:watcher
#@+node:ekr.20051025144611.23:initialScan
def initialScan (tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")
    if not c or haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    pth = os.path.split(g.app.loadDir)  
    aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    if not os.path.exists(aini):
        createConfigFile( aini )
    try:
        if not hasReadConfig():
            if os.path.exists(aini):
                readConfigFile(aini) 

            bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
            readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    finally:
        setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.            
    def scan():
        #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
        # During unit testing c gets destroyed before the scan finishes.
        if not g.app.unitTesting:
            readOutline( c )
        
    t = threading.Thread( target = scan )
    t.setDaemon(True)
    t.start()
#@-node:ekr.20051025144611.23:initialScan
#@-node:ekr.20051025170832:Initialization
#@+node:ekr.20051025144611.17:scanText
def scanText (txt):

    '''This function guides what gets scanned.'''

    if useauto:
        scanForAutoCompleter(txt)
    if usecall:
        scanForCallTip(txt)
#@nonl
#@-node:ekr.20051025144611.17:scanText
#@+node:ekr.20051025144611.18:scanForAutoCompleter
def scanForAutoCompleter (txt):
    
    '''This function scans text for the autocompleter database.'''

    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b:makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            #if watchwords.has_key(a):
            #    watchwords[a].add(b)
            #else:
            #    watchwords[a] = sets.Set([b])
            watchwords[ a ].add( b )
            # we are using the experimental DictSet class here.
            # usage removed the above statements
            # notice we have cut it down to one line of code here!
#@nonl
#@-node:ekr.20051025144611.18:scanForAutoCompleter
#@+node:ekr.20051025144611.19:scanForCallTip
def scanForCallTip (txt):

    '''this function scans text for calltip info'''

    # pat2 = pats['python']
    # if lang:
        # if pats.has_key(lang):
            # pat2 = pats[lang]

    pat2 = pats.get(lang or 'python')
    g2 = pat2.findall(txt) or []

    for z in g2:
        if isinstance(z,tuple):
            z = z [0]
        pieces2 = z.split('(')
        pieces2 [0] = pieces2 [0].split() [ -1]
        a, b = pieces2 [0], pieces2 [1]
        calltips [lang][a].add(z)
#@nonl
#@-node:ekr.20051025144611.19:scanForCallTip
#@+node:ekr.20051025144611.20:makeAutocompletionList
def makeAutocompletionList (a,b,glist):
    
    '''A helper function for autocompletion'''
    a1 = _reverseFindWhitespace(a)
    if a1:
        b2 = _getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 

#@-node:ekr.20051025144611.20:makeAutocompletionList
#@+node:ekr.20051025144611.21:_getCleanString
def _getCleanString (s):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    for n, l in enumerate(s):
        if l in okchars:pass 
        else:return s[:n]
    return s 
#@-node:ekr.20051025144611.21:_getCleanString
#@+node:ekr.20051025144611.22:_reverseFindWhitespace
def _reverseFindWhitespace (s):
    '''A helper for autocompletion scan'''
    for n, l in enumerate(s):
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
#@-node:ekr.20051025144611.22:_reverseFindWhitespace
#@+node:ekr.20051025144611.29:reducer
def reducer (lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
#@-node:ekr.20051025144611.29:reducer
#@+node:ekr.20051025144611.30:unbind
def unbind (context):

    '''This method turns everything off and removes the calltip and autobox from the canvas.'''

    if context.on: #no need to do this stuff, if were not 'on'
        context.on = False
        context.clean_editor()
        map(context.unbind,(
            "<Control_L>", "<Control_R>", "<Alt-Up>", "<Alt-Down>", "<Alt_L>", "<Alt_R>"))
        context.unbind_all('<Button>')
        context.update_idletasks()
#@nonl
#@-node:ekr.20051025144611.30:unbind
#@+node:ekr.20051025144611.31:moveSelItem
def moveSelItem (event, context ):

    '''Move the selection in the autobox up or down.'''

    autobox = context.autobox
    i = autobox.curselection()
    if len(i)==0:
        return None 
    i = int(i[0])
    # g.trace(event.keysym,i)
    try:
        if event.keysym=='Down':
            if autobox.size() - 1 > autobox.index( i ):
                i += 1
            elif i!=0:
                i -1  ## Can't be correct.
        elif event.keysym=='Up': # EKR.
            if i > 0:
                i -= 1
    finally:
        autobox.select_clear( 0, 'end' )
        autobox.select_set( i )
        autobox.see( i )
        context.update_idletasks()
        return "break"
#@-node:ekr.20051025144611.31:moveSelItem
#@+node:ekr.20051025144611.32:processKeyStroke
def processKeyStroke (event,context,body):

    '''Take action based on the state of context (a Tk.Canvas) and the event'''
    
    autobox = context.autobox

    if not context.on or event.keysym in ("??","Shift_L","Shift_R"):
        return None
    elif testForUnbind(event,context):
        unbind(context)
        return None
    elif context.which == 1:
        return None # It is calltip time.
        
    index = body.index('insert-1c wordstart')
    pat = body.get(index,'insert') + event.char
    pat = pat.lstrip('.')
    ww = list(autobox.get(0,'end'))
    aList = reducer(ww,pat)
    if not aList: return None
    # Select which item to select based on what the user has typed.
    i = ww.index(aList[0])
    # Set the current selection to match what the user has typed.
    autobox.select_clear(0,'end') 
    autobox.select_set(i)
    autobox.see(i)
    return 'break'
#@nonl
#@-node:ekr.20051025144611.32:processKeyStroke
#@+node:ekr.20051025144611.33:testForUnbind
def testForUnbind( event, context ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if event.keysym in ('parenright','Control_L','Control_R', 'Escape' ):
        return True
    elif not context.which and event.char in ripout:
        return True
    return False
#@-node:ekr.20051025144611.33:testForUnbind
#@+node:ekr.20051025144611.34:processAutoBox
def processAutoBox(event, context , body ):
    '''This method processes the selection from the autobox.'''
    if event.keysym in("Alt_L","Alt_R"):
        return None 

    a = context.autobox.getvalue()
    if len(a)==0:return None 
    try:
        a = a[0]
        ind = body.index('insert-1c wordstart')
        pat = body.get(ind,'insert')
        pat = pat.lstrip('.')

        if a.startswith(pat):a = a[len(pat):]
        body.insert('insert',a)
        body.event_generate("<Key>")
        body.update_idletasks()
    finally:
        unbind( context )
#@-node:ekr.20051025144611.34:processAutoBox
#@+node:ekr.20051025144611.35:add_item
def add_item (event, context ,body,colorizer):
    '''This function will add the autobox or the calltip label.'''
    if not event.char in('.','(')or context.on:return None 
    txt = body.get('insert linestart','insert')
    txt = _reverseFindWhitespace(txt)
    if event.char!='('and not watchwords.has_key(txt):
         return None 

    if event.char=='.' and useauto:

        ww = list(watchwords[txt])
        ww.sort()
        autobox = context.autobox
        configureAutoBox( autobox, ww )
        autolist = autobox.component( 'listbox' )
        #We have to hand the listbox in, its the only thing providing accuracy of size and position.
        calculatePlace( body, autolist, context, autobox )
        autobox.select_set( 0 )
        context.which = 0 #indicates it's in autocompletion mode
        add_bindings( context, body )
    
    elif event.char=='(' and usecall:
        language = colorizer.language 
        if calltips.has_key(language):
            if calltips[language].has_key(txt):

                s = list(calltips[language][txt])
                t = '\n'.join(s)
                calltip = context.calltip 
                calltip.configure(text=t)
                #The calltip provides sufficient size information to calculate its place on top of the context. 
                calculatePlace(body, calltip ,context, calltip  )
                context.which = 1 #indicates it's in calltip mode
        
        else:
            context.on = False 
            return None 

#@-node:ekr.20051025144611.35:add_item
#@+node:ekr.20051025144611.36:add_bindings
def add_bindings( context, body ):
    
    '''This def adds bindings to the Canvas so it can work with the autobox properly.'''
            
    event = Tk.Event()
    event.keysym = ''

    def processAutoBoxHandler( event = event , context = context, body = body  ): 
        processAutoBox( event, context , body  )
        
    context.autobox.configure( selectioncommand = processAutoBoxHandler )
    
    def moveSelItemHandler( event, context = context ): 
        moveSelItem( event, context )
    
    bindings = ( ( "<Control_L>", processAutoBoxHandler ), ( "<Control_R>", processAutoBoxHandler ),
                 ( "<Alt-Up>", moveSelItemHandler, '+' ), ( "<Alt-Down>", moveSelItemHandler , '+'),
                 ( "<Alt_L>", processAutoBoxHandler ), ( "<Alt_R>", processAutoBoxHandler ) )
         
    def bind2( args ): context.bind( *args )
    map( bind2, bindings )
#@nonl
#@-node:ekr.20051025144611.36:add_bindings
#@+node:ekr.20051025144611.37:configureAutoBox
def configureAutoBox ( autobox ,ww):
    '''sets data and size of autobox.'''
    autobox.setlist(ww)
    lb = autobox.component('listbox')
    height = len(ww)
    if height>5:height = 5
    lb.configure(height=height)
#@-node:ekr.20051025144611.37:configureAutoBox
#@+node:ekr.20051025144611.38:calculatePlace
def calculatePlace (body,cwidg, context ,toBePlaced):
     '''This def determines where the autobox or calltip label goes on the canvas.
       And then it puts it on the canvas.
       body is the Tk Text instance.
       cwidg is the widget from which we derive the calculations.
       context is the parent of the cwidg, we bind the context in this function.
       toBePlaced is the widget that is placed with the calculatsions performed.'''
     try:
        x, y, lww, lwh = body.bbox('insert -1c')
        x, y = x+lww, y+lwh 
     except:
         x = 1
         y = 1
     rwidth = cwidg.winfo_reqwidth()
     rheight = cwidg.winfo_reqheight()
     if body.winfo_width()<x+rwidth:  
        x = x-rwidth 
     if y>body.winfo_height()/2:
        h2 = rheight 
        h3 = h2+lwh 
        y = y-h3 

     toBePlaced.place( x = x, y = y )
     context.on = True
     context.bind_all( '<Button>', context.do_unbind )
#@-node:ekr.20051025144611.38:calculatePlace
#@+node:ekr.20051025144611.39:setLanguage
def setLanguage ( pos ):
    '''This method checks a node for the current language in effect
       and accends the parent line until it finds a language.'''
    global lang 
    while pos:
        xs1 = pos.bodyString()
        dict = g.get_directives_dict(xs1)
        if dict.has_key('language'):
            lang = g.set_language(xs1,dict['language'])[0]
            break 
        pos = pos.parent()
#@-node:ekr.20051025144611.39:setLanguage
#@+node:ekr.20051025144611.40:newCreateControl
def newCreateControl (self,frame,parentFrame):
    '''A decoration of the createControl def.
    We set up the ancestory of the control so we can draw
    widgets over the Text editor without disturbing the text.'''

@
Creating the background:
- We now use a placer: simpler to use and more efficient.
- We have to decorate the Tk.Text widget with a constructor that creates an
  intermediate Frame for the Text to be placed instead of packed.
  Had no idea that the placer could do this so nicely.
  With a couple changes in 3 places, we are using the placer !
@c
    orig_init = Tk.Text.__init__ #We stash the original init of Tk.Text
    def pre_init (self,master,*args,**kwords):

        context = Tk.Frame(master)
            #This is what we need to put in before the text to make place work.
        orig_init(self,context,*args,**kwords)

    Tk.Text.__init__ = pre_init #We restore the original init of Tk.Text
    body = orig_CreateControl(self,frame,parentFrame) #orig_CreatControl is the method this def decorates
    Tk.Text.__init__ = orig_init

    context = body.master #This is the Frame we created to intercept the passed in master.
    context.pack(expand=1,fill='both',after=frame.bodyBar) #We have to add it to the environment, since we pass on it in the __init__
    body.place(relwidth=1.0,relheight=1.0)
    body.commander = self.c #used in watcher
    context.on = False #determines if the system is autocompleting or calltiping
    addAutoboxAndCalltipWidgets(context)
    #These used to be lambdas, but I think this is clearer.
    def processKeyStrokeHandler (event,context=context,body=body):
        processKeyStroke(event,context,body)
    def addItemHandler (event,context=context,body=body,colorizer=frame.body):
        add_item(event,context,body,colorizer.getColorizer())

    for z in (watcher,processKeyStrokeHandler,addItemHandler):
        context.bind("<Key>",z,'+')

    ignore = [] #ignore items added to this list when a Button event occurs.
    if hasattr(context,'autobox'):
        ignore.append(context.autobox.component('listbox'))
        ignore.append(context.autobox.component('vertscrollbar'))
    def do_unbind (event):
        '''This def is for doing the unbind on any <Button> events.
           It only is in effect when the autobox or calltip label are showing.'''
        if event.widget not in ignore: #This ensures a click or scroll in the autobox takes effect.
                unbind(context)

    context.do_unbind = do_unbind

    # This part protects this plugin from others that use Alt-Up, Alt-Down.
    # The frame didnt seem to work.  Im assuming it was not appropiate enought in the bindtag order for the event.
    context.block_alt = Tk.Entry()
    def block_alt (event):
        '''This def blocks specific keyboard commands from reaching the Text editor.  'breaking' in
           the context does not occur before the event reaches the Text editor, so it has no effect'''
        if context.on: return 'break'
    for z in ('<Alt-Up>','<Alt-Down>'): context.block_alt.bind(z,block_alt)

    #set the bindtags for the body, protects the autocompleter from other plugins unbinding this plugins bindings.
    ctags = []
    ctags.append(context.bindtags()[0])
    ctags.append(context.block_alt.bindtags()[0])
    ctags.extend(body.bindtags())
    body.bindtags(tuple(ctags))

    return body
#@nonl
#@-node:ekr.20051025144611.40:newCreateControl
#@+node:ekr.20051025144611.41:addAutoboxAndCalltipWidgets
def addAutoboxAndCalltipWidgets( context ):
    '''This builds the autobox and the calltip label for the editor.
      It should be called once for every editor created.'''
    
    call_pack_forget = []

    if useauto:
        context.autobox = Pmw.ScrolledListBox(
            context ,hscrollmode='none',
            listbox_selectbackground='#FFE7C6',
            listbox_selectforeground='blue',
            listbox_background='white',
            listbox_foreground='blue',
            vertscrollbar_background='#FFE7C6',
            vertscrollbar_width=10)
        call_pack_forget.append( context.autobox.component( 'hull' ) )
    
    if usecall:            
        context.calltip = Tk.Label(context,background='lightyellow',foreground='black')
        call_pack_forget.append( context.calltip )
    
    def clean_editor( ca = call_pack_forget ):
        #This def makes removing the autobox or calltip label easy.
        # No need for an intermediate variable like 'current'.
        for z in ca: z.place_forget()

    context.clean_editor = clean_editor
#@nonl
#@-node:ekr.20051025144611.41:addAutoboxAndCalltipWidgets
#@+node:ekr.20051025144611.42:onOpenWindow
def onOpenWindow ():

    #what does this do?
    c = keywords.get("c")
    if haveseen.has_key(c):
        return 
        
    autocompleter = autocomplet(c)
#@nonl
#@-node:ekr.20051025144611.42:onOpenWindow
#@-node:ekr.20051025144611.4:autocompleter.py
#@-node:ekr.20051025144611:Reference (Do not delete)
#@+node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.4062:center_dialog
def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4062:center_dialog
#@+node:ekr.20031218072017.4063:create_labeled_frame
# Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) > 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f
#@nonl
#@-node:ekr.20031218072017.4063:create_labeled_frame
#@-node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4065:get_focus
def get_focus(self,c):
    
    """Returns the widget that has focus, or body if None."""

    return c.frame.top.focus_displayof()
#@nonl
#@-node:ekr.20031218072017.4065:get_focus
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@-node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            << try to use the PIL and tkIcon packages to draw the icon >>
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None
#@nonl
#@+node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("<Visibility>",visibilityCallback)

if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)
#@nonl
#@-node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
#@+node:ekr.20031218072017.4070:createLeoIcon
# This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.4070:createLeoIcon
#@-node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
#@-node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
#@-node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4075:firstIndex
def firstIndex (self):

    return "1.0"
#@nonl
#@-node:ekr.20031218072017.4075:firstIndex
#@+node:ekr.20031218072017.4076:lastIndex
def lastIndex (self):

    return "end"
#@nonl
#@-node:ekr.20031218072017.4076:lastIndex
#@+node:ekr.20031218072017.4077:moveIndexBackward
def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
#@-node:ekr.20031218072017.4077:moveIndexBackward
#@+node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
#@nonl
#@-node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
#@+node:ekr.20031218072017.4079:compareIndices
def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False
#@nonl
#@-node:ekr.20031218072017.4079:compareIndices
#@+node:ekr.20031218072017.4080:getindex
def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))
#@nonl
#@-node:ekr.20031218072017.4080:getindex
#@-node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4082:getInsertPoint
def getInsertPoint(self,t):
    
    try:
        return t.index("insert")
    except Exception:
        return '1.0'
#@nonl
#@-node:ekr.20031218072017.4082:getInsertPoint
#@+node:ekr.20031218072017.4083:setInsertPoint
def setInsertPoint (self,t,pos):

    try:
        t.mark_set("insert",pos)
    except Exception:
        pass
#@nonl
#@-node:ekr.20031218072017.4083:setInsertPoint
#@-node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4085:getSelectionRange
def getSelectionRange (self,t):
    
    try:
        # Warning: this can return None.
        return t.tag_ranges("sel")
    except Exception:
        return 0,0
#@nonl
#@-node:ekr.20031218072017.4085:getSelectionRange
#@+node:ekr.20051126125950:getSelectedText
def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
#@nonl
#@-node:ekr.20051126125950:getSelectedText
#@+node:ekr.20031218072017.4086:getTextSelection
def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, ">", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert
#@nonl
#@-node:ekr.20031218072017.4086:getTextSelection
#@+node:ekr.20051126171929:hasSelection
def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j
#@nonl
#@-node:ekr.20051126171929:hasSelection
#@+node:ekr.20031218072017.4088:setSelectionRangeWithLength
def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))
#@nonl
#@-node:ekr.20031218072017.4088:setSelectionRangeWithLength
#@+node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return
        
    try:
        if t.compare(start, ">", end):
            start,end = end,start
            
        t.tag_remove("sel","1.0",start)
        t.tag_add("sel",start,end)
        t.tag_remove("sel",end,"end")
        
        # New in 4.4a5: this logic ensures compatibility with previous code.
        if insert == 'sel.end':
            g.app.gui.setInsertPoint(t,end)
        elif insert is not None:
            g.app.gui.setInsertPoint(t,insert)
    except Exception:
        pass
    
setSelectionRange = setTextSelection
#@nonl
#@-node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
#@-node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4091:getAllText
def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4091:getAllText
#@+node:ekr.20031218072017.4092:getCharAfterIndex
def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c",">=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4092:getCharAfterIndex
#@+node:ekr.20031218072017.4093:getCharAtIndex
def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4093:getCharAtIndex
#@+node:ekr.20031218072017.4094:getCharBeforeIndex
def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4094:getCharBeforeIndex
#@+node:ekr.20031218072017.4095:getLineContainingIndex
def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4095:getLineContainingIndex
#@+node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)
#@nonl
#@-node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
#@-node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20031218072017.4098:makeIndexVisible
def makeIndexVisible(self,t,index):

    return t.see(index)
#@nonl
#@-node:ekr.20031218072017.4098:makeIndexVisible
#@-node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20051220144507:isTextWidget
def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) 
#@nonl
#@-node:ekr.20051220144507:isTextWidget
#@-node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20051126123249:class autoCompleterClass (prototype)
class autoCompleterCommandsClass (baseEditCommandsClass):
    
    '''Similar to typing completion in the minibuffer,
    but the presently selected completion is shown in the widget itself.'''

    @others
#@nonl
#@+node:ekr.20051126123759: birth
#@+node:ekr.20051126123759.1: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.c = c
    self.k = c.k
    self.membersList = None
    self.prefix = None
    self.tabList = []
    self.tabListIndex = -1
    self.text = None # For Escape.
    self.widget = None
#@nonl
#@-node:ekr.20051126123759.1: ctor
#@+node:ekr.20051126123759.2: getPublicCommands (autoCommandsClass)
def getPublicCommands (self):

    k = self.k

    return {
        'auto-complete':    self.autoComplete,
    }
#@nonl
#@-node:ekr.20051126123759.2: getPublicCommands (autoCommandsClass)
#@-node:ekr.20051126123759: birth
#@+node:ekr.20051127105431:abort
def abort (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    
    c.widgetWantsFocus(w)

    w.delete('1.0','end')
    w.insert('1.0',self.text)
    gui.setTextSelection(w,'1.0','1.0')
#@nonl
#@-node:ekr.20051127105431:abort
#@+node:ekr.20051126122952.1:autoComplete
def autoComplete (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    self.widget = w = event and event.widget 
    self.prefix = gui.getSelectedText(w) or ''
    self.text = gui.getAllText(w)

    c.frame.log.clearTab('Completion') # Creates the tab if necessary.
    self.membersList = c.commandsDict.keys() ## Testing only.
    k.setState('auto-completer',1,handler=self.stateHandler)
    self.computeCompletionList()
#@nonl
#@-node:ekr.20051126122952.1:autoComplete
#@+node:ekr.20051126123149:computeCompletionList (autoCompleter)
def computeCompletionList (self):
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    c.widgetWantsFocus(w)
    s = gui.getSelectedText(w)
    if s:
        self.tabList,common_prefix = g.itemsMatchingPrefixInList(s,self.membersList)
        c.frame.log.clearTab('Completion') # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            g.es('%s' % (name),tabName='Completion')
#@nonl
#@-node:ekr.20051126123149:computeCompletionList (autoCompleter)
#@+node:ekr.20051126131103:doBackSpace
def doBackSpace (self):

    '''Cut back to previous prefix.'''

    self.prefix = self.prefix[:-1]
    self.setSelection(self.prefix)
    self.computeCompletionList()
#@nonl
#@-node:ekr.20051126131103:doBackSpace
#@+node:ekr.20051126123249.1:doTabCompletion (autoCompleter)
def doTabCompletion (self):
    
    '''Handle tab completion when the user hits a tab.'''
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    s = gui.getSelectedText(w)

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex >= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20051126123249.1:doTabCompletion (autoCompleter)
#@+node:ekr.20051127065601:extendSelection
def extendSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
    else:
        i = j = gui.getInsertPoint(w)
    
    w.insert(j,s)
    j = w.index('%s + 1c' % (j))
    gui.setSelectionRange(w,i,j)
#@nonl
#@-node:ekr.20051127065601:extendSelection
#@+node:ekr.20051127105102:finish
def finish (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.widgetWantsFocus(w)
    
    i,j = gui.getTextSelection(w)
    if i != j:
        gui.setTextSelection(w,j,j)
#@nonl
#@-node:ekr.20051127105102:finish
#@+node:ekr.20051127070018:setSelection
def setSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = gui.getInsertPoint(w)
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    gui.setSelectionRange(w,i,j)
#@nonl
#@-node:ekr.20051127070018:setSelection
#@+node:ekr.20051126124705:stateHandler (autoCompleter)
def stateHandler (self,event):
    
    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.widget
    keysym = event and event.keysym
    ch = event and event.char or ''
    # g.trace(repr(ch),repr(keysym))
    if keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.finish()
    elif keysym == 'Escape':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif ch in string.printable:
        self.extendSelection(ch)
        s = gui.getSelectedText(w)
        if s.startswith(self.prefix):
            self.prefix = self.prefix + ch
            # g.trace('prefix',self.prefix)
        self.computeCompletionList()
#@nonl
#@-node:ekr.20051126124705:stateHandler (autoCompleter)
#@-node:ekr.20051126123249:class autoCompleterClass (prototype)
#@-node:ekr.20051126122638:Autocompletion tab
#@+node:ekr.20060214110318.1:After autocompleter
#@+node:ekr.20060209201859.1:Trap AttributeErrors in dummy base classes
Having to define dummy methods is getting odious.
#@nonl
#@-node:ekr.20060209201859.1:Trap AttributeErrors in dummy base classes
#@+node:ekr.20060122183544:Improve isearch
@nocolor

- Handle backspace for isearch: keep a stack of previous matches.
- Allow cross-node isearches.
#@-node:ekr.20060122183544:Improve isearch
#@+node:ekr.20060214072931:Improve unit testing
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3575014
By: ktenney

> it seems my Leo file must have a @button Unit Test  

Good point. I'll add a run-unit-test command soon.

> the @test output goes to the console.

It goes to sys.stderr, iirc.  Perhaps run-unit-test should support this setting:

@bool unit_test_output_to_log_pane = True
#@nonl
#@-node:ekr.20060214072931:Improve unit testing
#@+node:ekr.20060213094300:Fix problems with open with
#@+node:ekr.20060213145539:The causes
@nocolor

1.  Both the vim and xemacs plugins require that open_with plugin be enabled.
    I changed the docstrings for each.

2.  The open_with plugin now explicitly calls g.enableIdleTimeHook.
    That is, the idle time hook is no longer enabled by default.
   
These were easy fixes to make.  A similar fix should be done for files opened from the Open With menu, but it's too late to do that for b2.
#@nonl
#@-node:ekr.20060213145539:The causes
#@+node:ekr.20060213144352:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3573148
By: yarkot

With the "latest" CVS snapshot. Do this:

[] Open LeoDocs.leo from the latest workspace;
[] Expand node "What's new in Leo 4.4" (I'll refer to this as the "parent");
[] Dbl-click parent (VIM opens text; text is single line: "@nocolor");
[] Add a second "@nocolor" line; write and save from VIM;
[] Leo view does not show line;
[] re-open w/ vim - vim shows new line;

[] Save;  add more text;  shows w/ vim, not in Leo; Apparently doesn't get save.
You can add a line in Leo, "This is a test", modify it in vim - "This was a
test", save vim, save Leo - close leo, re-open leo - the vim changes never got
saved.

Ok  - that's one.

Here's the second (same file, node, fresh session):

[] Open parent w/ vim (dbl-clk); opens ok;
[] open child "New commands not in legacy Leo" w/ vim; opens ok.
[] FAILS:  try to open first child: "Minibuffer-oriented find commands" - vim
doesn't open, status line flashes node name (once for each click it looks like),
and console window shows this:

open_in_vim: {'p': <pos 20987888 lvl: 1 [0] New commands not in legacy Leo>,
'c'
: Commander 25144936: u'C:\\Workspace\\Leo\\leo\\doc\\LeoDocs.leo', 'event':
<Tk
inter.Event instance at 0x0132BE90>, 'v': <pos 20987888 lvl: 1 [0] New commands
not in legacy Leo>}
#@nonl
#@-node:ekr.20060213144352:Report
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@nonl
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False
#@nonl
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args & keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@nonl
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@nonl
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@nonl
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@nonl
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@nonl
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@nonl
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@nonl
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@nonl
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@-node:ekr.20060213094300:Fix problems with open with
#@+node:ekr.20060211184834:Review all commands in leoEditCommands.py
Any command that alters text should call begin/endCommand.
#@nonl
#@+node:ekr.20060122185244.2:Fix unindent command
# unindent-region should work in all panes.
#@nonl
#@-node:ekr.20060122185244.2:Fix unindent command
#@-node:ekr.20060211184834:Review all commands in leoEditCommands.py
#@+node:ekr.20060213151918:Add baloons
#@+node:ekr.20060212125650:createBalloon
def createBalloon (tab,sv):

    'Create a balloon for a widget.' ''

    balloon = Pmw.Balloon(tab,initwait=100)
    balloon.bind(tab,'')
    hull = balloon.component('hull')
    def blockExpose (event):
        if sv.get() == '':
             hull.withdraw()
    hull.bind('<Expose>',blockExpose,'+')
    balloon._label.configure(textvariable=sv)
#@nonl
#@-node:ekr.20060212125650:createBalloon
#@-node:ekr.20060213151918:Add baloons
#@+node:ekr.20060116083043:Use special Help menu on the Mac
# http://sourceforge.net/forum/message.php?msg_id=3237845
#@nonl
#@+node:ekr.20031218072017.3803:createHelpMenuFromTable
def createHelpMenuFromTable (self):

    if 0: ## sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu()
        if not helpMenu: return
    else:
        helpMenu = self.createNewMenu("&Help")
    
    self.createMenuEntries(helpMenu,self.helpMenuTopTable)
    
    if sys.platform=="win32":
        self.createMenuEntries(helpMenu,self.helpMenuTop2Table)
    
    self.createMenuEntries(helpMenu,self.helpMenuTop3Table)
#@nonl
#@-node:ekr.20031218072017.3803:createHelpMenuFromTable
#@+node:ekr.20031218072017.4113:new_menu
def new_menu(self,parent,tearoff=False):
    
    """Wrapper for the Tkinter new_menu menu method."""

    return Tk.Menu(parent,tearoff=tearoff)
#@nonl
#@-node:ekr.20031218072017.4113:new_menu
#@+node:ekr.20031218072017.3804:createNewMenu (contains Tk code)
def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName) # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&")
            label = label.replace("&","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&")
                index_label = index_label.replace("&","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20031218072017.3804:createNewMenu (contains Tk code)
#@+node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    return self.menus.get(cmn)
    
def setMenu (self,menuName,menu):
    
    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu
    
def destroyMenu (self,menuName):
    
    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]
#@nonl
#@-node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
#@+node:ekr.20060211144330.1:getMacHelpMenu
def getMacHelpMenu (self):
    
    return None ###
    
    try:
        helpMenu = Tk.Menu('top.help')
        return helpMenu
        
    except Exception:
        g.trace('Can not get MacOS Help menu')
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20060211144330.1:getMacHelpMenu
#@-node:ekr.20060116083043:Use special Help menu on the Mac
#@+node:ekr.20060211100150:Fix chapters plugin
#@-node:ekr.20060211100150:Fix chapters plugin
#@+node:ekr.20060122185507:New commands
#@+node:ekr.20060210140415:Most important
#@+node:ekr.20060211093935:Support for @list and on-enter-mode
#@-node:ekr.20060211093935:Support for @list and on-enter-mode
#@+node:ekr.20060113090042:open-outline-by-name & filename completion
#@-node:ekr.20060113090042:open-outline-by-name & filename completion
#@+node:ekr.20060122194643:isearch-headline (forward & backward)
#@-node:ekr.20060122194643:isearch-headline (forward & backward)
#@+node:ekr.20060116085649:find-word-on-line, find-character-on-line (forward & backward)
#@-node:ekr.20060116085649:find-word-on-line, find-character-on-line (forward & backward)
#@+node:ekr.20060206103922:Minibuffer interface for GoToLine number
#@-node:ekr.20060206103922:Minibuffer interface for GoToLine number
#@+node:ekr.20060116074839.2:extend-to-word
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20060117115212:Rename buffer doesn't seem to work
#@-node:ekr.20060117115212:Rename buffer doesn't seem to work
#@+node:ekr.20060123091352:Incremental search in switch-to-buffer
#@-node:ekr.20060123091352:Incremental search in switch-to-buffer
#@+node:ekr.20060104083551:move-line-up/down (LeoUser)
http://sourceforge.net/forum/message.php?msg_id=3488030

move-region-up

Swap the selection with the line above it. If we are at the top of a node, the
node identified by threadBack() is selected and the text is moved to the bottom
of the node.

move-region-down

Swap the selection with the line below it. If we are at the bottom of the node,
the node identified by threadNext() is selected and the text is moved to the top
of the node.

In all cases the moved text remains selected, even when the text moves to another node.
#@nonl
#@-node:ekr.20060104083551:move-line-up/down (LeoUser)
#@+node:ekr.20060116084526.1:insert/remove spaces/tabs from lines (LeoUser)
http://sourceforge.net/forum/message.php?msg_id=3488030

add-space-to-lines      Adds a space is added to start of all selected lines.

add-tab-to-line         Adds 4 spaces to start of all selected lines.

remove-space-from lines Removes a space from start of all selected lines.

remove-tab-from lines   Removes a space from start of all selected lines.
#@nonl
#@-node:ekr.20060116084526.1:insert/remove spaces/tabs from lines (LeoUser)
#@+node:ekr.20060123095316:clear-selection
Useful, e.g., after a find.
#@nonl
#@-node:ekr.20060123095316:clear-selection
#@+node:ekr.20051202095626:help-for-command
Use docstrings as the help message.
#@nonl
#@-node:ekr.20051202095626:help-for-command
#@+node:ekr.20060116090428:Expand 'point' so it indicates node as well as text location
#@-node:ekr.20060116090428:Expand 'point' so it indicates node as well as text location
#@+node:ekr.20060214140221:update-settings-file command
#@-node:ekr.20060214140221:update-settings-file command
#@-node:ekr.20060210140415:Most important
#@+node:ekr.20060210140415.1:Others
#@+node:ekr.20060209105218.2:contract-all-except-present-tree
#@-node:ekr.20060209105218.2:contract-all-except-present-tree
#@+node:ekr.20060206114203:toggle-find-tab-views
show/hide buttons, etc.
#@-node:ekr.20060206114203:toggle-find-tab-views
#@+node:ekr.20060206104205:Finish query-replace
#@-node:ekr.20060206104205:Finish query-replace
#@+node:ekr.20060109183500.1:execute-named-script
execute-named-script executes script in leo/scripts.
#@nonl
#@-node:ekr.20060109183500.1:execute-named-script
#@+node:ekr.20060116074450:Drive tabs from keyboard
- create-tab
- clear-tab
- delete-tab
- hide-tab
- show-tab, show-log

These might get the tab name from the minibuffer...
#@nonl
#@-node:ekr.20060116074450:Drive tabs from keyboard
#@+node:ekr.20051021074728:Space completion
#@-node:ekr.20051021074728:Space completion
#@-node:ekr.20060210140415.1:Others
#@+node:ekr.20060202231708.1:Use minibuffer names for all menu entries
This will allow @menu nodes in leoSettings.leo
#@nonl
#@-node:ekr.20060202231708.1:Use minibuffer names for all menu entries
#@+node:ekr.20051121070552:Finish Cmds menu
#@+node:ekr.20060117112444:What I did
@nocolor

- Call menu.defineMenuTables from menu.createMenusFromTables.
  This ensures the keyHandler class has been created.

- Added support for using minibuffer command names instead of command in menu
tables. This is a signal that the command is a new-style minibuffer command
rather than a legacy command. This required minor changes in createMenu entries
and defineMenuCallback.
#@nonl
#@-node:ekr.20060117112444:What I did
#@+node:ekr.20060117114903:Others
#@+node:ekr.20050920085536.65:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    special = keysym in (
        'Caps_Lock','Num_Lock','Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None

    if trace and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and g.safeStringCompare(stroke,k.abortAllModesKey): # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    elif k.inState():
        return 'break' # New in 4.4b2: ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event)
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.
k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65:masterCommand & helpers
#@+node:ekr.20031218072017.4117:defineMenuCallback
def defineMenuCallback(self,command,name,minibufferCommand):
    
    if minibufferCommand:
        
        # Create a dummy event as a signal to doCommand.
        event = g.Bunch(keysym='',char='',widget='')
        
        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label,event)
    
        return minibufferMenuCallback
        
    else:
    
        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label)
    
        return legacyMenuCallback
#@nonl
#@-node:ekr.20031218072017.4117:defineMenuCallback
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@+node:ekr.20031218072017.3752:defineMenuTables & helpers
def defineMenuTables (self):
    
    c = self.c
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()
#@nonl
#@+node:ekr.20031218072017.3753:defineEditMenuTables & helpers
def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditCursorTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
#@nonl
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo",c.undoer.undo), # &U reserved for Undo
        ("Can't Redo",c.undoer.redo), # &R reserved for Redo
        ("-",None),
        ("Cu&t",f.OnCutFromMenu), 
        ("Cop&y",f.OnCopyFromMenu),
        ("&Paste",f.OnPasteFromMenu),
        ("&Delete",c.editCommands.backwardDeleteCharacter),
        ("Select &All",f.body.selectAllText),
        ("-",None),
    ]

    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20050711091931:defineEditMenuEditCursorTable
def defineEditMenuEditCursorTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    if 0: ### Not ready yet.
        # These should have Emacs names...
        self.editMenuEditCursorTable = [
            ('Delete Right',c.deleteRightChar), 
            ('Delete Left',c.deleteLeftChar), 
            # Moving the cursor.
            ('Start of Line',c.moveToStartOfLine), 
            ('End of Line',c.moveToEndOfLine), 
            ('Start of Node',c.moveToStartOfNode),
            ('End of Node',c.moveToEndOfNode), 
            ('-',None,None),
            # Extending the selection...
            ('Select Line',c.selectEntireLine),
            ('Extend To Start of Word',c.extendToStartOfWord),
            ('Extend To End of Word',c.extendToEndOfWord),
            ('Extend To Start Of Line',c.extendToStartOfLine), 
            ('Extend To End Of Line',c.extendToEndOfLine), 
            ('Extend To End of Node',c.extendToEndOfNode),
            # The mark...
        ]
#@nonl
#@-node:ekr.20050711091931:defineEditMenuEditCursorTable
#@+node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
def defineEditMenuEditBodyTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuEditBodyTable = [
        ("Extract &Section",c.extractSection),
        ("Extract &Names",c.extractSectionNames),
        ("&Extract",c.extract),
        ("-",None,None),
        ("Convert All B&lanks",c.convertAllBlanks),
        ("Convert All T&abs",c.convertAllTabs),
        ("Convert &Blanks",c.convertBlanks),
        ("Convert &Tabs",c.convertTabs),
        ("Insert Body Time/&Date",c.insertBodyTime),
        ("&Reformat Paragraph",c.reformatParagraph),
        ("-",None,None),
        ("&Indent",c.indentBody),
        ("&Unindent",c.dedentBody),
        ("&Match Brackets",c.findMatchingBracket),
        ("Add Comments",c.addComments),
        ("Delete Comments",c.deleteComments),
    ]
    # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
#@nonl
#@-node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
#@+node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
def defineEditMenuEditHeadlineTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    self.editMenuEditHeadlineTable = [
        ("Edit &Headline",c.editHeadline),
        ("&End Edit Headline",f.endEditLabelCommand),
        ("&Abort Edit Headline",f.abortEditLabelCommand),
        ("Insert Headline Time/&Date",f.insertHeadlineTime),
        ("Toggle Angle Brackets",c.toggleAngleBrackets),
    ]
#@nonl
#@-node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    # Bind to the Find tab.
    sc = c.searchCommands
    self.editMenuFindMenuTable = [
        ("&Show Find Tab",  sc.openFindTab),
        ("&Hide Find Tab",  sc.hideFindTab),
        ("-",None),
        ("Find &Next",          sc.findTabFindNext),
        ("Find &Previous",      sc.findTabFindPrev),
        ("&Replace",            sc.findTabChange),
        ("Replace, &Then Find", sc.findTabChangeThenFind),
    ]
#@nonl
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20031218072017.3757:defineEditMenuTop2Table
def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&visibles","Show In&visibles")
        
    self.editMenuTop2Table = [
        ("&Go To Line Number",c.goToLineNumber),
        ("&Execute Script",c.executeScript),
        (label,c.viewAllCharacters),
        ("Setti&ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.3757:defineEditMenuTop2Table
#@-node:ekr.20031218072017.3753:defineEditMenuTables & helpers
#@+node:ekr.20031218072017.3758:defineFileMenuTables & helpers
def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
#@nonl
#@+node:ekr.20031218072017.3759:defineFileMenuTopTable
def defineFileMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTopTable = [
        ("&New",c.new),
        ("&Open...",c.open),
    ]
#@nonl
#@-node:ekr.20031218072017.3759:defineFileMenuTopTable
#@+node:ekr.20031218072017.3760:defineFileMenuTop2Table
def defineFileMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop2Table = [
        ("-",None),
        ("&Close",c.close),
        ("&Save",c.save),
        ("Save &As",c.saveAs),
        ("Save To",c.saveTo), # &Tangle
        ("Re&vert To Saved",c.revert), # &Read/Write
    ]
#@nonl
#@-node:ekr.20031218072017.3760:defineFileMenuTop2Table
#@+node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame ; fc = c.fileCommands

    self.fileMenuReadWriteMenuTable = [
        ("&Read Outline Only",c.readOutlineOnly),
        ("Read @file &Nodes",c.readAtFileNodes),
        ("-",None),
        ("Write &Dirty @file Nodes",fc.writeDirtyAtFileNodes),
        ("Write &Missing @file Nodes",fc.writeMissingAtFileNodes),
        ("Write &Outline Only",fc.writeOutlineOnly),
        ("&Write @file Nodes",fc.writeAtFileNodes),
    ]
#@nonl
#@-node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
#@+node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
def defineFileMenuTangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTangleMenuTable = [
        ("Tangle &All",c.tangleAll),
        ("Tangle &Marked",c.tangleMarked),
        ("&Tangle",c.tangle),
    ]
#@nonl
#@-node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
#@+node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
def defineFileMenuUntangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuUntangleMenuTable = [
        ("Untangle &All",c.untangleAll),
        ("Untangle &Marked",c.untangleMarked),
        ("&Untangle",c.untangle),
    ]
#@nonl
#@-node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
#@+node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
def defineFileMenuImportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuImportMenuTable = [
        ("Import Derived File",c.importDerivedFile),
        ("Import To @&file",c.importAtFile),
        ("Import To @&root",c.importAtRoot),
        ("Import &CWEB Files",c.importCWEBFiles),
        ("Import &noweb Files",c.importNowebFiles),
        ("Import Flattened &Outline",c.importFlattenedOutline),
    ]
#@nonl
#@-node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
#@+node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
def defineFileMenuExportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuExportMenuTable = [
        ("Export &Headlines",c.exportHeadlines),
        ("Outline To &CWEB",c.outlineToCWEB),
        ("Outline To &Noweb",c.outlineToNoweb),
        ("&Flatten Outline",c.flattenOutline),
        ("&Remove Sentinels",c.removeSentinels),
        ("&Weave",c.weave),
    ]
#@nonl
#@-node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
#@+node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
def defineFileMenuTop3MenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop3MenuTable = [
        ("E&xit",g.app.onQuit),
    ]
#@nonl
#@-node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
#@-node:ekr.20031218072017.3758:defineFileMenuTables & helpers
#@+node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
#@nonl
#@+node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&ut Node",c.cutOutline),
        ("C&opy Node",c.copyOutline),
        ("&Paste Node",c.pasteOutline),
        ("Pas&te Node As Clone",c.pasteOutlineRetainingClones),
        ("&Delete Node",c.deleteOutline),
        ("-",None,None),
        ("&Insert Node",c.insertHeadline),
        ("&Clone Node",c.clone),
        ("Sort Childre&n",c.sortChildren), # Conflicted with Hoist.
        ("&Sort Siblings",c.sortSiblings),
        ("-",None),
        ("&Hoist",c.hoist),
        ("D&e-Hoist",f.c.dehoist),
        ("-",None),
    ]
    # Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
    # Bindings for entries that go to submenus: a,g,k,m,x
#@nonl
#@-node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
#@+node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &Outline",c.checkOutline),
        ("&Dump Outline",c.dumpOutline),
        ("-",None),
        ("Check &All Python Code",c.checkAllPythonCode),
        ("&Check Python &Code",c.checkPythonCode),
        ("-",None),
        ("Pretty P&rint All Python Code",c.prettyPrintAllPythonCode),
        ("&Pretty Print Python Code",c.prettyPrintPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r
#@nonl
#@-node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
#@+node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&Contract All",c.contractAllHeadlines),
        ("Contract &Node",c.contractNode),
        ("Contract &Parent",c.contractParent),
        ("Contract Or Go Left",c.contractNodeOrGoToParent),
        ("-",None),
        ("Expand P&rev Level",c.expandPrevLevel),
        ("Expand N&ext Level",c.expandNextLevel),
        ("Expand And Go Right",c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",c.expandNodeOrGoToFirstChild),
        ("-",None),
        ("Expand To Level &1",c.expandLevel1),
        ("Expand To Level &2",c.expandLevel2),
        ("Expand To Level &3",c.expandLevel3),
        ("Expand To Level &4",c.expandLevel4),
        ("Expand To Level &5",c.expandLevel5),
        ("Expand To Level &6",c.expandLevel6),
        ("Expand To Level &7",c.expandLevel7),
        ("Expand To Level &8",c.expandLevel8),
        ("-",None),
        ("Expand &All",c.expandAllHeadlines),
        ("Expand N&ode",c.expandNode),
    ]
#@nonl
#@-node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
#@+node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &Down",c.moveOutlineDown),
        ("Move &Left",c.moveOutlineLeft),
        ("Move &Right",c.moveOutlineRight),
        ("Move &Up",c.moveOutlineUp),
        ("-",None),
        ("&Promote",c.promote),
        ("&Demote",c.demote),
    ]
#@nonl
#@-node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
#@+node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&Mark",c.markHeadline),
        ("Mark &Subheads",c.markSubheads),
        ("Mark Changed &Items",c.markChangedHeadlines),
        ("Mark Changed &Roots",c.markChangedRoots),
        ("Mark &Clones",c.markClones),
        ("&Unmark All",c.unmarkAll),
    ]
#@nonl
#@-node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
#@+node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",c.goNextVisitedNode),
        ("Go To Prev Node",c.selectThreadBack),
        ("Go To Next Node",c.selectThreadNext),
        ("-",None),
        ("Go To Next Marked",c.goToNextMarkedHeadline),
        ("Go To Next Changed",c.goToNextDirtyHeadline),
        ("Go To Next Clone",c.goToNextClone),
        ("-",None),
        ("Go To First Node",c.goToFirstNode),
        ("Go To Prev Visible",c.selectVisBack),
        ("Go To Next Visible",c.selectVisNext),
        ("Go To Last Node",c.goToLastNode),
        ('Go To Last Visible',c.goToLastVisibleNode),
        ("-",None),
        ("Go To Parent",c.goToParent),
        ('Go To First Sibling',c.goToFirstSibling),
        ('Go To Last Sibling',c.goToLastSibling),
        ("Go To Prev Sibling",c.goToPrevSibling),
        ("Go To Next Sibling",c.goToNextSibling),
    ]
#@nonl
#@-node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
#@-node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
#@+node:ekr.20050921103230:defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):
    
    self.defineCmdsMenuTopTable()
    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCenterTable()
    self.defineCmdsMenuChangeCaseTable()
    self.defineCmdsMenuIndentTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuSortTable()
    self.defineCmdsMenuSpellCheckTable()
#@+node:ekr.20060117094955: defineCmdsMenuTopTable
def defineCmdsMenuTopTable (self):
    
    self.cmdsMenuTopTable = [
        ('Repeat Last Complex Command','repeat-complex-command'),
        ('Execute Named Command','full-command'),
        ("-",None),
    ]
#@-node:ekr.20060117094955: defineCmdsMenuTopTable
#@+node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable (to do)
def defineCmdsMenuAbbrevTable (self):
    
    c = self.c
    
    self.cmdsMenuAbbrevTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable (to do)
#@+node:ekr.20060117095212:defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        ('Append To Buffer',             'append-to-buffer'),
        ('Kill Buffer',                  'kill-buffer'),
        ('List Buffers',                 'list-buffers'),
        ('List Buffers Alphbetically',   'list-buffers-alphabetically'),
        ('Prepend To Buffer',            'prepend-to-buffer'),
        ('Rename Buffer',                'rename-buffer'),
        ('Switch To Buffer',             'switch-to-buffer'),
    ]
#@nonl
#@-node:ekr.20060117095212:defineCmdsMenuBufferTable
#@+node:ekr.20060117095212.5:defineCmdsMenuCenterTable
def defineCmdsMenuCenterTable (self):

    c = self.c

    self.cmdsMenuCenterTable = [
        ('Center Line',     'center-line'),
        ('Center Region',   'center-region'),
    ]
#@nonl
#@-node:ekr.20060117095212.5:defineCmdsMenuCenterTable
#@+node:ekr.20060117095212.4:defineCmdsMenuChangeCaseTable
def defineCmdsMenuChangeCaseTable (self):

    c = self.c

    self.cmdsMenuChangeCaseTable = [
        ('Capitalize Word', 'capitalize-word'),
        ('Downcase Region', 'downcase-region'),
        ('Downcase Word',   'downcase-word'),
        ('Upcase Region',   'upcase-region'), # Crashes.
        ('Upcase Word',     'upcase-word'),
    ]
    
#@nonl
#@-node:ekr.20060117095212.4:defineCmdsMenuChangeCaseTable
#@+node:ekr.20060117095212.6:defineCmdsMenuIndentTable
def defineCmdsMenuIndentTable (self):

    c = self.c

    self.cmdsMenuIndentTable = [
        ('Indent Region',   'indent-region'),
        ('Indent Relative', 'indent-relative'),
        ('Indent Rigidly',  'indent-rigidly'),
        ('Unindent Region', 'unindent-region'),
    ]
#@nonl
#@-node:ekr.20060117095212.6:defineCmdsMenuIndentTable
#@+node:ekr.20060117114315:defineCmdsMenuMacroTable(to do)
def defineCmdsMenuMacroTable (self):

    c = self.c

    self.cmdsMenuMacroTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117114315:defineCmdsMenuMacroTable(to do)
#@+node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable(to do)
def defineCmdsMenuRectanglesTable (self):

    c = self.c

    self.cmdsMenuRectanglesTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable(to do)
#@+node:ekr.20060117095212.1:defineCmdsMenuRegistersTable(to do)
def defineCmdsMenuRegistersTable (self):

    c = self.c

    self.cmdsMenuRegistersTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117095212.1:defineCmdsMenuRegistersTable(to do)
#@+node:ekr.20060117095212.3:defineCmdsMenuSortTable
def defineCmdsMenuSortTable (self):

    c = self.c

    self.cmdsMenuSortTable = [
        ('Sort Columns',    'sort-columns'),
        ('Sort Fields',     'sort-fields'),
        ('Sort Lines',      'sort-lines'),
    ]
#@nonl
#@-node:ekr.20060117095212.3:defineCmdsMenuSortTable
#@+node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    c = self.c

    self.cmdsMenuSpellCheckTable = [
        ('Check Spelling',      'open-spell-tab'),
        ('Change',              'spell-change'),
        ('Change, Then Find',   'spell-change-then-find'),
        ('Find',                'spell-find'),
        ('Ignore',              'spell-ignore'),
    ]
#@nonl
#@-node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
#@-node:ekr.20050921103230:defineCmdsMenuTables & helpers
#@+node:ekr.20031218072017.3773:defineWindowMenuTables
def defineWindowMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.windowMenuTopTable = [
        ("&Equal Sized Panes",f.equalSizedPanes),
        ("Toggle &Active Pane",f.toggleActivePane),
        ("Toggle &Split Direction",f.toggleSplitDirection),
        ("-",None),
        ("Resize To Screen",f.resizeToScreen),
        ("Casca&de",f.cascade),
        ("&Minimize All",f.minimizeAll),
        ("-",None),
        ("Open &Compare Window",c.openCompareWindow),
        ("Open &Python Window",c.openPythonWindow),
    ]
#@nonl
#@-node:ekr.20031218072017.3773:defineWindowMenuTables
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.helpMenuTopTable = [
        ("&About Leo...",c.about),
        ("Online &Home Page",c.leoHome),
        ("Open Online &Tutorial",c.leoTutorial),
    ]

    self.helpMenuTop2Table = [
        ("Open &Offline Tutorial",f.leoHelp),
    ]

    self.helpMenuTop3Table = [
        ("-",None,None),
        ("Open Leo&Docs.leo",c.leoDocumentation),
        ("Open Leo&Plugins.leo",c.openLeoPlugins),
        ("Open Leo&Settings.leo",c.openLeoSettings),
    ]
#@nonl
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20031218072017.3752:defineMenuTables & helpers
#@+node:ekr.20031218072017.3785:createMenusFromTables & helpers
def createMenusFromTables (self):
    
    c = self.c
    
    self.defineMenuTables()
    
    self.createFileMenuFromTable()
    self.createEditMenuFromTable()
    self.createOutlineMenuFromTable()
    
    g.doHook("create-optional-menus",c=c)
    
    if self.useCmdMenu:
        self.createCmndsMenuFromTable()

    self.createWindowMenuFromTable()
    self.createHelpMenuFromTable()
#@nonl
#@+node:ekr.20031218072017.3790:createFileMenuFromTable
def createFileMenuFromTable (self):
    
    c = self.c
    fileMenu = self.createNewMenu("&File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    << create the recent files submenu >>
    self.add_separator(fileMenu)
    << create the read/write submenu >>
    << create the tangle submenu >>
    << create the untangle submenu >>
    << create the import submenu >>
    << create the export submenu >>
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
#@nonl
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
#@nonl
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("&Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
#@nonl
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
#@nonl
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
#@nonl
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
#@nonl
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:createFileMenuFromTable
#@+node:ekr.20031218072017.3786:createEditMenuFromTable
def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    << create the edit body submenu >>
    << create the edit headline submenu >>
    << create the find submenu >>
    
    self.createMenuEntries(editMenu,self.editMenuTop2Table)
#@nonl
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
#@nonl
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
#@nonl
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
#@nonl
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:createEditMenuFromTable
#@+node:ekr.20031218072017.3797:createOutlineMenuFromTable
def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&Outline")
    
    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)
    
    << create check submenu >>
    << create expand/contract submenu >>
    << create move submenu >>
    << create mark submenu >>
    << create goto submenu >>
#@nonl
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
#@nonl
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
#@nonl
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
#@nonl
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
#@nonl
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
#@nonl
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:createOutlineMenuFromTable
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('C&mds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table,sep in (
        ('Abbrev...',       self.cmdsMenuAbbrevTable,       False),
        ('Buffers...',      self.cmdsMenuBuffersTable,      False),
        ('Center...',       self.cmdsMenuCenterTable,       False),
        ('Change Case...',  self.cmdsMenuChangeCaseTable,   False),
        ('Indent...',       self.cmdsMenuIndentTable,       False),
        ('Macro...',        self.cmdsMenuMacroTable,        False),
        ('Rectangles...',   self.cmdsMenuRectanglesTable,   False),
        ('Registers...',    self.cmdsMenuRegistersTable,    False),
        ('Sort...',         self.cmdsMenuSortTable,         False),
        ('Spell Check...',  self.cmdsMenuSpellCheckTable,   False),
    ):
        menu = self.createNewMenu(name,'Cmds')
        self.createMenuEntries(menu,table)
        if sep: self.add_separator(cmdsMenu)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20031218072017.3802:createWindowMenuFromTable
def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&Window")
    
    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
#@nonl
#@-node:ekr.20031218072017.3802:createWindowMenuFromTable
#@+node:ekr.20031218072017.3803:createHelpMenuFromTable
def createHelpMenuFromTable (self):

    if 0: ## sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu()
        if not helpMenu: return
    else:
        helpMenu = self.createNewMenu("&Help")
    
    self.createMenuEntries(helpMenu,self.helpMenuTopTable)
    
    if sys.platform=="win32":
        self.createMenuEntries(helpMenu,self.helpMenuTop2Table)
    
    self.createMenuEntries(helpMenu,self.helpMenuTop3Table)
#@nonl
#@-node:ekr.20031218072017.3803:createHelpMenuFromTable
#@-node:ekr.20031218072017.3785:createMenusFromTables & helpers
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('C&mds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table,sep in (
        ('Abbrev...',       self.cmdsMenuAbbrevTable,       False),
        ('Buffers...',      self.cmdsMenuBuffersTable,      False),
        ('Center...',       self.cmdsMenuCenterTable,       False),
        ('Change Case...',  self.cmdsMenuChangeCaseTable,   False),
        ('Indent...',       self.cmdsMenuIndentTable,       False),
        ('Macro...',        self.cmdsMenuMacroTable,        False),
        ('Rectangles...',   self.cmdsMenuRectanglesTable,   False),
        ('Registers...',    self.cmdsMenuRegistersTable,    False),
        ('Sort...',         self.cmdsMenuSortTable,         False),
        ('Spell Check...',  self.cmdsMenuSpellCheckTable,   False),
    ):
        menu = self.createNewMenu(name,'Cmds')
        self.createMenuEntries(menu,table)
        if sep: self.add_separator(cmdsMenu)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and k.prettyPrintKey(accelerator).lstrip('<').rstrip('>')
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@nonl
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20060117114903:Others
#@+node:ekr.20060117123143:editing commands
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
       
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
      
#@-node:ekr.20060117123143:editing commands
#@+node:ekr.20050921103230:defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):
    
    self.defineCmdsMenuTopTable()
    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCenterTable()
    self.defineCmdsMenuChangeCaseTable()
    self.defineCmdsMenuIndentTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuSortTable()
    self.defineCmdsMenuSpellCheckTable()
#@+node:ekr.20060117094955: defineCmdsMenuTopTable
def defineCmdsMenuTopTable (self):
    
    self.cmdsMenuTopTable = [
        ('Repeat Last Complex Command','repeat-complex-command'),
        ('Execute Named Command','full-command'),
        ("-",None),
    ]
#@-node:ekr.20060117094955: defineCmdsMenuTopTable
#@+node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable (to do)
def defineCmdsMenuAbbrevTable (self):
    
    c = self.c
    
    self.cmdsMenuAbbrevTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable (to do)
#@+node:ekr.20060117095212:defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        ('Append To Buffer',             'append-to-buffer'),
        ('Kill Buffer',                  'kill-buffer'),
        ('List Buffers',                 'list-buffers'),
        ('List Buffers Alphbetically',   'list-buffers-alphabetically'),
        ('Prepend To Buffer',            'prepend-to-buffer'),
        ('Rename Buffer',                'rename-buffer'),
        ('Switch To Buffer',             'switch-to-buffer'),
    ]
#@nonl
#@-node:ekr.20060117095212:defineCmdsMenuBufferTable
#@+node:ekr.20060117095212.5:defineCmdsMenuCenterTable
def defineCmdsMenuCenterTable (self):

    c = self.c

    self.cmdsMenuCenterTable = [
        ('Center Line',     'center-line'),
        ('Center Region',   'center-region'),
    ]
#@nonl
#@-node:ekr.20060117095212.5:defineCmdsMenuCenterTable
#@+node:ekr.20060117095212.4:defineCmdsMenuChangeCaseTable
def defineCmdsMenuChangeCaseTable (self):

    c = self.c

    self.cmdsMenuChangeCaseTable = [
        ('Capitalize Word', 'capitalize-word'),
        ('Downcase Region', 'downcase-region'),
        ('Downcase Word',   'downcase-word'),
        ('Upcase Region',   'upcase-region'), # Crashes.
        ('Upcase Word',     'upcase-word'),
    ]
    
#@nonl
#@-node:ekr.20060117095212.4:defineCmdsMenuChangeCaseTable
#@+node:ekr.20060117095212.6:defineCmdsMenuIndentTable
def defineCmdsMenuIndentTable (self):

    c = self.c

    self.cmdsMenuIndentTable = [
        ('Indent Region',   'indent-region'),
        ('Indent Relative', 'indent-relative'),
        ('Indent Rigidly',  'indent-rigidly'),
        ('Unindent Region', 'unindent-region'),
    ]
#@nonl
#@-node:ekr.20060117095212.6:defineCmdsMenuIndentTable
#@+node:ekr.20060117114315:defineCmdsMenuMacroTable(to do)
def defineCmdsMenuMacroTable (self):

    c = self.c

    self.cmdsMenuMacroTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117114315:defineCmdsMenuMacroTable(to do)
#@+node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable(to do)
def defineCmdsMenuRectanglesTable (self):

    c = self.c

    self.cmdsMenuRectanglesTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable(to do)
#@+node:ekr.20060117095212.1:defineCmdsMenuRegistersTable(to do)
def defineCmdsMenuRegistersTable (self):

    c = self.c

    self.cmdsMenuRegistersTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117095212.1:defineCmdsMenuRegistersTable(to do)
#@+node:ekr.20060117095212.3:defineCmdsMenuSortTable
def defineCmdsMenuSortTable (self):

    c = self.c

    self.cmdsMenuSortTable = [
        ('Sort Columns',    'sort-columns'),
        ('Sort Fields',     'sort-fields'),
        ('Sort Lines',      'sort-lines'),
    ]
#@nonl
#@-node:ekr.20060117095212.3:defineCmdsMenuSortTable
#@+node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    c = self.c

    self.cmdsMenuSpellCheckTable = [
        ('Check Spelling',      'open-spell-tab'),
        ('Change',              'spell-change'),
        ('Change, Then Find',   'spell-change-then-find'),
        ('Find',                'spell-find'),
        ('Ignore',              'spell-ignore'),
    ]
#@nonl
#@-node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
#@-node:ekr.20050921103230:defineCmdsMenuTables & helpers
#@-node:ekr.20051121070552:Finish Cmds menu
#@-node:ekr.20060122185507:New commands
#@+node:ekr.20060206104841:New features
#@+node:ekr.20060116083043.1:Add context-menus on nodes or text
#@-node:ekr.20060116083043.1:Add context-menus on nodes or text
#@+node:ekr.20060122184114:Support the exectution of a command when entering a mode
- Entering outline mode should call c.endEditing.
- Entering edit mode shouldn't call c.endEditing!
#@-node:ekr.20060122184114:Support the exectution of a command when entering a mode
#@+node:ekr.20060202235215.1:Make sure the user doesn't specify Enter and Leave bindings by mistake
#@-node:ekr.20060202235215.1:Make sure the user doesn't specify Enter and Leave bindings by mistake
#@+node:ekr.20051112075511:Switch cursor when changing search direction
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3424153
By: rogererens

When reversing the search direction, it would be better to place the cursor
'on the other side' of the current hit, and then proceed to find the next occurrence
of <pattern>. At the current state of affairs, searching in the reverse direction
first finds the current occurrence _again_, just placing the cursor on the other
side of the higlighted selection.

This suggestion is based on the way searching in Vim works.
#@nonl
#@-node:ekr.20051112075511:Switch cursor when changing search direction
#@+node:ekr.20060125113540:Specify open-with bindings from settings
Maybe the entire table should be specified this way.
#@nonl
#@-node:ekr.20060125113540:Specify open-with bindings from settings
#@+node:ekr.20060203165231:Change outline or body text background when changing panes.
#@-node:ekr.20060203165231:Change outline or body text background when changing panes.
#@+node:ekr.20060202141338.4:Add support for widget bindings
#@-node:ekr.20060202141338.4:Add support for widget bindings
#@+node:ekr.20060116085217:Make scroll-pane-up/down work in tree
@nocolor

The following commands already work in the body pane.

scroll-down
scroll-down-extend-selection  
scroll-up
scroll-up-extend-selection

Note: arrow keys scroll the outline as needed, so there *is* a way to scroll the outline without the UniversalScrolling plugin.
#@nonl
#@-node:ekr.20060116085217:Make scroll-pane-up/down work in tree
#@+node:ekr.20060206131908.1:set-first-search-node command (indicate it in the find tab)
@nocolor

This will indicate the start of searches.
It would be shown in the Find tab.
#@nonl
#@-node:ekr.20060206131908.1:set-first-search-node command (indicate it in the find tab)
#@-node:ekr.20060206104841:New features
#@+node:ekr.20060116173818:*** Fix vampire nodes
#@-node:ekr.20060116173818:*** Fix vampire nodes
#@-node:ekr.20060214110318.1:After autocompleter
#@+node:ekr.20060122184800:Later
#@+node:ekr.20060117074259:Handle Mac issues
#@+node:ekr.20060117074259.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3526056
By: nobody

Hi Edward. I've been using the linux and windows version but would like to try
leo on the mac. The install instructions seem a bit out of date. I take it any
additional downloading of TclTkAqua is unneccessary?

I have python2.4 in addition to the stock python 2.3.5 that comes with osx 10.4.
Launching leo like so:  "python2.4 leo.py", as I do on linux, seems to run just
fine.

I don't know if this was fixed on osx or in leo in general, but moving the mouse
to each of the panes and scrolling with the wheel works just great now. Thanks.

Plugin manager: the plugin text font is really tiny, and the window opens to
a default width such that the 'Installed Plugins' button reads 'talled Plugi'.
Resizing the window does stretch the buttons horizontally.

Ok -- here's maybe a big issue. I open a new leo file (File->New) and type in:

for i in range(3):

I hit return after the colon, but a newline is not entered.

Stephen
#@-node:ekr.20060117074259.1:Report
#@-node:ekr.20060117074259:Handle Mac issues
#@+node:ekr.20060111152145:Improve scripts menu plugin
- Organize scripts menu from subfolders of leo/scripts folder.

- Create minibuffer commands for each script?
#@nonl
#@-node:ekr.20060111152145:Improve scripts menu plugin
#@+node:ekr.20060108120501:Add @find node to scripting plugin
This is the easy way to do script finds!
#@nonl
#@-node:ekr.20060108120501:Add @find node to scripting plugin
#@+node:ekr.20051202102337:Finish minibuffer commands
@nocolor
#@nonl
#@+node:ekr.20051202102337.1:abbrevCommandsClass (not ready yet)
auto-complete command is merely a prototype.
#@nonl
#@-node:ekr.20051202102337.1:abbrevCommandsClass (not ready yet)
#@+node:ekr.20051202102337.2:bufferCommandsClass Inot ready yet)
ok:

list-buffers

Not ready yet:

append-to-buffer
copy-to-buffer
insert-to-buffer
kill-buffer
prepend-to-buffer
rename-buffer       probably should change headline too
switch-to-buffer    use typing completion to get node name (headline)
#@nonl
#@-node:ekr.20051202102337.2:bufferCommandsClass Inot ready yet)
#@+node:ekr.20051202102337.3:controlCommandsClass (ok)
advertised-undo
keyboard-quit
iconify-frame
save-buffers-kill-leo
shell-command
shell-command-on-region
suspend
#@nonl
#@-node:ekr.20051202102337.3:controlCommandsClass (ok)
#@+node:ekr.20051202102337.4:editCommandsClass
back-sentence
back-to-indentation
backward-char
backward-delete-char
backward-kill-paragraph
backward-paragraph
backward-word
beginning-of-buffer
beginning-of-line
capitalize-word
center-line
center-region
count-region
cycle-focus
dabbrev-completion
dabbrev-expands
delete-char
delete-indentation
delete-spaces
downcase-region
downcase-word
end-of-buffer
end-of-line
escape
eval-expression
exchange-point-mark
fill-paragraph
fill-region
fill-region-as-paragraph
flush-lines
focus-to-body
focus-to-log
focus-to-minibuffer
focus-to-tree
forward-char
forward-paragraph
forward-sentence
forward-word
goto-char
goto-line
how-many
# Use indentBody in leoCommands.py
#indent-region
indent-relative
indent-rigidly
indent-to-comment-column
insert-newline
insert-parentheses
keep-lines
kill-paragraph
line-number
move-past-close
newline-and-indent
next-line
previous-line
remove-blank-lines
replace-regex
replace-string
reverse-region
scroll-down
scroll-up
select-paragraph
# Exists, but can not be executed via the minibuffer.
# self-insert-command
set-comment-column
set-fill-column
set-fill-prefix
set-mark-command
show-colors
show-fonts
# save-buffer
sort-columns
sort-fields
sort-lines
split-line
tabify
transpose-chars
transpose-lines
transpose-words
untabify
upcase-region
upcase-word
view-lossage
what-line
#@nonl
#@-node:ekr.20051202102337.4:editCommandsClass
#@+node:ekr.20051202102337.6:editFileCommandsClass
delete-file
diff
insert-file
make-directory
remove-directory
save-file
#@nonl
#@-node:ekr.20051202102337.6:editFileCommandsClass
#@+node:ekr.20051202102752.1:keyHandlerCommandsClass (not ready yet)
digit-argument
help
hide-mini-buffer
negative-argument
number-command
number-command-0
number-command-1
number-command-2
number-command-3
number-command-4
number-command-5
number-command-6
number-command-7
number-command-8
number-command-9
print-bindings
print-commands
repeat-complex-command
show-mini-buffer
toggle-mini-buffer
universal-argument
#@nonl
#@-node:ekr.20051202102752.1:keyHandlerCommandsClass (not ready yet)
#@+node:ekr.20051202102752.2:killBufferCommandsClass
backward-kill-sentence
backward-kill-word
kill-line
kill-word
kill-sentence
kill-region
kill-region-save
yank
yank-pop
zap-to-character
#@nonl
#@-node:ekr.20051202102752.2:killBufferCommandsClass
#@+node:ekr.20051202102752.3:macroCommandsClass
call-last-keyboard-macro
end-kbd-macro
name-last-kbd-macro
load-file
insert-keyboard-macro 
start-kbd-macro
#@nonl
#@-node:ekr.20051202102752.3:macroCommandsClass
#@+node:ekr.20051202102752.4:queryReplaceCommandsClass
query-replace
query-replace-regex
#@nonl
#@-node:ekr.20051202102752.4:queryReplaceCommandsClass
#@+node:ekr.20051202102752.5:rectangleCommandsClass (ok)
clear-rectangle
close-rectangle
delete-rectangle
kill-rectangle
open-rectangle
string-rectangle
yank-rectangle
#@nonl
#@-node:ekr.20051202102752.5:rectangleCommandsClass (ok)
#@+node:ekr.20051202102752.6:registerCommandsClass (ok, but could be expanded)
append-to-register
copy-rectangle-to-register
copy-to-register
increment-register
insert-register
jump-to-register
number-to-register not used: used copy-to-register insead.
point-to-register
prepend-to-register
view-register

To do:

point-to-register should write an 'expanded point' so inter-node jumps are possible.
#@nonl
#@-node:ekr.20051202102752.6:registerCommandsClass (ok, but could be expanded)
#@+node:ekr.20051202102752.7:searchCommandsClass (ok, but could be expanded)
hide-find-tab
open-find-tab
find-tab-find
find-tab-find-prev
find-tab-change
find-tab-change-then-find

isearch-forward
isearch-backward
isearch-forward-regexp
isearch-backward-regexp

re-search-forward
re-search-backward

search-forward
search-backward
word-search-forward
word-search-backward
#@nonl
#@-node:ekr.20051202102752.7:searchCommandsClass (ok, but could be expanded)
#@+node:ekr.20051202102752.8:spellCommandsClass (ok)
ok:

hide-spell-tab
open-spell-tab
spell-find
spell-change
spell-change-then-find
spell-ignore
#@nonl
#@-node:ekr.20051202102752.8:spellCommandsClass (ok)
#@-node:ekr.20051202102337:Finish minibuffer commands
#@+node:ekr.20050916180203:Make more commands undoable
#@-node:ekr.20050916180203:Make more commands undoable
#@+node:ekr.20060202235215.3:Remove deprecation warning
#@+node:EKR.20040627114602:getDescendentUnknownAttributes
# Only @thin vnodes have the descendentTnodeUnknownAttributes field.
# The question is: what are we to do about this?

def getDescendentUnknownAttributes (self,s):
    
    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except (TypeError,pickle.UnpicklingError,ImportError):
        g.trace('oops: getDescendentUnknownAttributes')
        return None
#@nonl
#@-node:EKR.20040627114602:getDescendentUnknownAttributes
#@-node:ekr.20060202235215.3:Remove deprecation warning
#@+node:ekr.20060207085518:Improve c.insertHeadline (minor)
c.insertHeadlineTime uses the edit widget.  It shouldn't.
#@nonl
#@-node:ekr.20060207085518:Improve c.insertHeadline (minor)
#@-node:ekr.20060122184800:Later
#@-node:ekr.20060116073938:To do 4.4a6-b3
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
