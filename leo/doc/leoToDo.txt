#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20060226131603:To do 4.4b3
#@+node:ekr.20060227133940:Post re breaking @ref links
#@-node:ekr.20060227133940:Post re breaking @ref links
#@+node:ekr.20060227123644:There are still problems with focus: remove the optimizations
@ It's much better to call g.app.gui.set_focus a few extra times than to mess up the focus!

- Make c.invalidateFocus a do-nothing method.
#@nonl
#@-node:ekr.20060227123644:There are still problems with focus: remove the optimizations
#@+node:ekr.20060227125713:Fix colorizer problems
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3585710
By: e

sometimes it seems to happen no matter what.
here are two (I hope) repeatable cases.

happens if the previous line has a comment or string
@language python
some=expr #trailing comment
another line
copy then paste 'another line' line
it colorized like a comment, or all one color.
a sure way to fix it is goto another node then back.
it won't naturally resynch by itself 
even if you goto end of body and back.

after that,
cut something inside next line after a comment same thing.
similar problem if previous line ends in a string.
same if cut/paste and trailing comment is on the same line.
undo restores the previous coloring, correct or not.
its been this way since early 4.4alpha I think.
still using 4.4b1

the final color was comment color as I write this,
as I open a fresh Leo and repeat, its text color.
there may be more than one trigger to the problem.

I know its a tradeoff of constant colorizing runs vrs incremental update, its
not technically a new problem, but this seems way buggier.
#@nonl
#@-node:ekr.20060227125713:Fix colorizer problems
#@+node:ekr.20060211100150:Fix chapters plugin
#@+node:ekr.20051217175058:Add commands
show-chapters
hide-chapters
add-chapter
delete-this-chapter
#@nonl
#@-node:ekr.20051217175058:Add commands
#@+node:ekr.20060201150547:Chapters
@ignore

from __future__ import generators
import java
import java.awt as awt
import java.awt.event as aevent
import javax.swing as swing
import javax.swing.event as sevent
import javax.swing.tree as stree
import java.util.concurrent.locks as locks
import leoNodes
import leoGlobals as g
import leoSwingUndo
import javax.swing.undo as undo
from utilities.DefCallable import DefCallable
from utilities.Phaser import Phaser
from utilities.Slider import Slider
from leoSwingFrame import leoSwingTree


class Chapters( sevent.ChangeListener ):
    
    def __init__( self, c ):
        
        self.c = c
        self.book = None
        path = g.os_path_join( g.app.loadDir,"..","Icons", "x.png" )
        self.icon = swing.ImageIcon( path )
        self.popup = self.ChaptersPopup( self )
        self.chapters = {}
        self.trees_chapters = {}
        self.current_chapter = self.Chapter()
        self.chapterlist = []
        #let's skip adding the first chapter
        #self.chapterlist.append( self.current_chapter )
        self.current_chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
        self.updateLock = locks.ReentrantLock() #this increase by 1 for each lock call. -1 for each unlock.  If it becomes 0, the lock is released
        self.chaptersIterationBlocked = 0
        self.chaptersundoer = undo.UndoManager()
        self.chaptersPromptingForRemove = False
        
    
    def getChapter( self ):
        return self.current_chapter
    
    def startPromptingForRemove( self ):
        self.chaptersPromptingForRemove = True
        
    def stopPromptingForRemove( self ):
        self.chaptersPromptingForRemove = False
    
    def isPromptingForRemove( self ):
        return self.chaptersPromptingForRemove
    
    
    
    def disablePopup( self ):
        self.popup.disable()
        
    def enablePopup( self ):
        self.popup.enable()
    
    def beginUpdate( self ):
        self.updateLock.lock()
        
    def endUpdate( self ):
        self.updateLock.unlock()
    
    def getWidget( self ):
        if self.book is None:
            # We defer creating until here because otherwise the book variable might miss a L&amp;F change
            self.book = swing.JTabbedPane()
            self.book.addMouseListener( self.popup )
            ssm = self.book.getModel()
            ssm.addChangeListener( self )
        return self.book
        
    def getSelectedChapter( self ):
        return self.current_chapter
    
    def getSelectedChapterWidget( self ):
        
        return self.book.getSelectedComponent()
    
    @others
    

#@+node:ekr.20060201150547.1:What are Chapters?
@
Chapters simply put are multiple Outlines within the Leo instance.  The definition doesn't stop there though since having more than one Outline defines an interaction model between these Outlines.  It is better to think of it like so:
    An Outline is composed of at least 1 Chapter.
    A writen Outline with multiple Chapters should be indistinguishable from an Outline with one Chapter.  The only mark is that the roots will have a uA marking them as belonging to a specific Chapter.
    So at read time, the Outline is read in then broken into its separate Chapters.
    At write time, the Outline is reconstituted as one Outline during output.  The reunification is only realised on disk.  Internally we use magic unfication iterators that give the write process a sense that it is writing one outline.  These special iterators mean that there is a low impact upon the write code.  Much of it has stayed the same except that it now uses a different iterator.
#@-node:ekr.20060201150547.1:What are Chapters?
#@+node:ekr.20060201150547.2:Things A Developer should know about Chapters
@
Observation 1: Do not start a beginUpdate in one chapter and finish it with a endUpdate in another chapter.  You will lose your ability to work with the outline/chapter where the beginUpdate started.  I have seen this happen, so let this be a warning to you.  I guess a protective fix against this would be to keep track of which chapter an endUpdate belongs to.  Hence doing a beginUpdate in one chapter followed by and endUpdate in another chapter would target the first chapter.  Im unsure if this would work, but it is a thought that may make the implementation more robust.

Observation 2: root positions should not become stale.  Since we aggresively copy everytime the root or current position is asked for from the chapter, the main copy should never change unless it is explicitly set.

Observation 3: Sliders and Phasers work better than dialogs with Chapters.  Ive found it disruptive when working with Chapters to suddenly have a dialog pop up grabbing my attention away from the Chapter Im working on.  Hence Ive moved informational and querying of the user primarily to Sliders.  Not only does it attach a question or notification to a Chapter better it also is very nice animation to observe.  Keeping our focus on the Chapter in question is essential!

Observation 4: We use the doHook mechanism to notify listeners that the current chapter has changed.  This makes it easy to monitor the changing of chapters, but the devloper must ensure that the chapter belongs to the chapters instance he is interested in.  Hence the commander is passed in as well.  If you are interested in the a specific Chapters instance the Commander should be enough to discern which chapters the chapter belongs to.  See the Node "A Note about Chapters and Commanders".

#@-node:ekr.20060201150547.2:Things A Developer should know about Chapters
#@+node:ekr.20060201150547.3:A Note about Chapters and Commanders
@

Chapters Swing takes the lessons learned from past Chapters plugins and simplifies the implementation by making the Chapters instance the provider of the root, current and top positions.  The Command is no longer in charge of this and will delegate the:
    getCurrentPosition() # or is it c.currentPosition()? :D
    getTopPosition()
    getRootPosition()

to the Chapters instance.  Each Commander now has a Chapters instance upon instantiation.

Also setting the variables will be delegated to the Chapters instance, which in turn delegates to a Chapter instance.

Hence we can keep the Commander interface and just restructure the internals and Chapters are now available.
#@nonl
#@-node:ekr.20060201150547.3:A Note about Chapters and Commanders
#@+node:ekr.20060201150547.4:commander delegates
def setRootPosition( self, p ):
    
    #if self.loading: return
    if p:
        p = p.copy()
    if self.current_chapter:
        self.current_chapter.setRootPosition( p )
    #self.roots[ self.current_chapter ] = p


def getRootPosition( self ):
    
    #if self.loading: return
    if self.current_chapter:
        return self.current_chapter.getRootPosition()
    return None   
    #return self.roots[ self.current_chapter ].copy()
    #rv = self.roots.get( self.current_chapter, None )
    #if rv: rv = rv.copy()
    #return rv
    
    
def setCurrentPosition( self, p ):
    
    #if self.loading: return    
    if p:
        p = p.copy()
    if self.current_chapter:
        self.current_chapter.setCurrentPosition( p )   
    #self.currentPositions[ self.current_chapter ] = p
        
    
def getCurrentPosition( self ):
    
    #if self.loading: return
    if self.current_chapter:
        return self.current_chapter.getCurrentPosition()
    return None
        
    #return self.currentPositions[ self.current_chapter ].copy()
    #rv = self.currentPositions.get( self.current_chapter, None )
    #if rv: rv = rv.copy()
    #return rv
#@nonl
#@-node:ekr.20060201150547.4:commander delegates
#@+node:ekr.20060201150547.5:stateChanged
def stateChanged( self, event ):
    
    c = self.c
    try:
        self.beginUpdate()
        index = self.book.getSelectedIndex()
        component = self.book.getComponentAt( index )
        chapter = self.chapters[ component ]
        c.frame.tree = chapter.tree
        self.current_chapter = chapter
        #chapter.tree.jtree.treeDidChange()
        c.beginUpdate()
        c.endUpdate()
        #c.selectPosition( chapter.getCurrentPosition() )
        self.current_chapter.undoer.setMenu( forceupdate = 1 )
        g.doHook( "chapter-changed", c = self.c, chapter = chapter )
    finally:
        self.endUpdate()
        
    #if chapter.root:
    #    chapter.root.linkAsRoot( None )

@   
    oldchapter = self.current_chapter
    index = self.book.getSelectedIndex()
    title = self.book.getTitleAt( index )
    self.current_chapter = title
    nwroot = self.chapters[ title ]
    oldroot = self.c.rootPosition().copy()
    self.chapters[ oldchapter ] = oldroot
    c.beginUpdate()
    c.setRootPosition( nwroot.copy() )
    c.endUpdate()


#@-node:ekr.20060201150547.5:stateChanged
#@+node:ekr.20060201150547.6:getChaptersIterator
def iterateOverChapters( self ):
    
    for x in self.chaptersIterator():
        print x
        
    

#@-node:ekr.20060201150547.6:getChaptersIterator
#@+node:ekr.20060201150547.7:markNodesForChapterization
def markNodesForChapterization( self ):

    if not self.chaptersIterationBlocked:    
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for n in xrange( len(self.chapterlist)):
            chapter = self.chapterlist[ n ]
            rp = chapter.getRootPosition()
            rp_base = rp.copy()
            for z in rp.self_and_siblings_iter( copy = True ):
                v = z.v
                if not hasattr( v, "unknownAttributes" ):
                    v.unknownAttributes = {}
                v.unknownAttributes[ 'chapter' ] = n
                if z == rp_base:
                    v.unknownAttributes[ 'chapter_name' ] = chapter.name
    else:
        rp = self.getRootPosition()
        rp_base = rp.copy()
        for z in rp.self_and_siblings_iter( copy = True ):
            v = z.v
            if not hasattr( v, "unknownAttributs" ):
                v.unknownAttributes = {}
            v.unknownAttributes[ 'chapter' ] = 0
            if z == rp_base:
                v.unknownAttributes[ 'chapter_name' ] = self.current_chapter.name
#@nonl
#@-node:ekr.20060201150547.7:markNodesForChapterization
#@+node:ekr.20060201150547.8:utility
def changeChaptersName( self ):
       
    chapter = self.current_chapter
    if chapter.isMessaging(): return
    chapter.startMessaging()
    jp = swing.JPanel( java.awt.BorderLayout() )
    slider = Slider( jp, direction = Slider.down )
    #phaser = Phaser( jp )
    nlabel = swing.JLabel( "Chapter Name:" )
    jp.add( nlabel, java.awt.BorderLayout.NORTH )
    jtf = swing.JTextField()
    slider.setComponentToFocus( jtf )
    #phaser.setComponentToFocus( jtf )
    jtf.setText( str( chapter.name ) )
    jp.add( jtf )
    top = self.c.frame.top
    def closeAndChange():
        chapter.doneMessaging()
        nw_name = jtf.getText()
        book = self.book
        index = book.getSelectedIndex()
        old_name= book.getTitleAt( index ) 
        book.setTitleAt( index, nw_name )
        self.chaptersundoer.addEdit( self.UndoChangeChapterName( self, chapter, old_name, nw_name ) )
        chapter.name = nw_name
        slider.startRemoving()
        #phaser.phaseRemove()
    
    class aa( swing.AbstractAction ):
        def __init__( self, *args ):
            swing.AbstractAction.__init__( self, *args )
        
        def actionPerformed( self, ae ):
            closeAndChange()
    ks = swing.KeyStroke.getKeyStroke( "ENTER" )
    if ks:
        am = jtf.getActionMap()
        im = jtf.getInputMap()
        im.put( ks, "enter" )
        am.put( "enter", aa() )
    jp2 = swing.JPanel() 
    jb = swing.JButton( "Ok" )
    jb.actionPerformed = lambda event : closeAndChange()
    jp2.add( jb )
    jp.add( jp2, java.awt.BorderLayout.SOUTH )
    tree = self.c.frame.tree
    jtree = tree.jtree
    bg = jtree.getBackground()
    fg = jtree.getForeground()
    jp.setBackground( bg )
    jp.setForeground( fg )
    nlabel.setForeground( fg )
    jp2.setBackground( bg )
    jp2.setForeground( fg )
    lb = swing.border.LineBorder( fg )
    jp.setBorder( lb )
    main_widget = tree.getWidget()
    vrect = tree.jspane.getViewportBorderBounds()
    height = slider.getPreferredSize().height
    #height = phaser.getPreferredSize().height
    vrect.height = height
    slider.setBounds( vrect )
    #phaser.setBounds( vrect )
    gp = main_widget.getGlassPane()
    gp.setVisible( True )
    gp.add( slider )
    #gp.add( phaser )



#@+node:ekr.20060201150547.9:changeChaptersName
#@-node:ekr.20060201150547.9:changeChaptersName
#@+node:ekr.20060201150547.10:moveNodeToChapter
def moveNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
        
    if cpos.isRoot():
        testroot = cpos.copy()
        testroot.moveToNext()
        if not testroot:
            return
    
    parent = cpos.getParent()    
    if parent:
        ok =  c.checkMoveWithParentWithWarning( pos.copy(), parent, True )
    else:
        ok = 1
        
    if not ok:
        return
    
    try:    
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        pos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        pos.linkAfter( cpos )
        c.endUpdate()
    

        self.current_chapter = current
        c.frame.tree = current.tree
    finally:
        self.endUpdate()

#@-node:ekr.20060201150547.10:moveNodeToChapter
#@+node:ekr.20060201150547.11:copyNodeToChapter
def copyNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
    
    nwpos = pos.copyTreeAfter()    
    #if cpos.isRoot():
    #    testroot = cpos.copy()
    #    testroot.moveToNext()
    #    if not testroot:
    #        return
    
    #parent = cpos.getParent()    
    #if parent:
    #    ok =  c.checkMoveWithParentWithWarning( pos.copy(), parent, True )
    #else:
    #    ok = 1
        
    #if not ok:
    #    return
    try:
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        nwpos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        nwpos.linkAfter( cpos )
        undo = leoSwingUndo.UndoableInsertNode( self.c, [ "Insert Node", nwpos.copy(), ], {} )
        chapter.undoer.addUndo( undo )
        c.endUpdate()
        self.current_chapter = current
        c.frame.tree = current.tree
        current.undoer.setMenu( forceupdate = 1 )
    finally:
        self.endUpdate()
#@-node:ekr.20060201150547.11:copyNodeToChapter
#@+node:ekr.20060201150547.12:cloneNodeToChapter
def cloneNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
    
    nwpos = pos.clone( pos.copy() )
        
    #if cpos.isRoot():
    #    testroot = cpos.copy()
    #    testroot.moveToNext()
    #    if not testroot:
    #        return
    
    parent = cpos.getParent()    
    if parent:
        ok =  c.checkMoveWithParentWithWarning( nwpos.copy(), parent, True )
    else:
        ok = 1
        
    if not ok:
        nwpos.unlink()
        c.beginUpdate()
        c.endUpdate()
        return
    
    try:
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        nwpos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        nwpos.linkAfter( cpos )
        undo = leoSwingUndo.UndoableInsertNode( self.c, [ "Insert Node", nwpos.copy(), ], {} )
        chapter.undoer.addUndo( undo )
    finally:
        c.endUpdate()
    

    self.current_chapter = current
    c.frame.tree = current.tree
    self.endUpdate()
    current.undoer.setMenu( forceupdate = 1 )
#@nonl
#@-node:ekr.20060201150547.12:cloneNodeToChapter
#@+node:ekr.20060201150547.13:testNode
def testNode( self ):
    
    chapter = self.current_chapter
    pos = chapter.getCurrentPosition()
    
    print pos
    for ancestor in pos.self_and_parents_iter(): #copy = 1):
        print ancestor, ancestor.isCloned()
#@nonl
#@-node:ekr.20060201150547.13:testNode
#@+node:ekr.20060201150547.14:swapChapters
def swapChapters( self, chapter1, chapter2, undo = True ):

    try:    
        self.beginUpdate()
        widget1 = chapter1.tree.getWidget()
        widget2 = chapter2.tree.getWidget()
        index1 = self.book.indexOfComponent( widget1 )
        index2 = self.book.indexOfComponent( widget2 )
        jp = swing.JPanel() #place holder, keeps order
        self.book.setComponentAt( index1, jp )
        self.book.setComponentAt( index2, widget1 )
        self.book.setComponentAt( index1, widget2 )
        self.book.setTitleAt( index1, chapter2.name )
        self.book.setTitleAt( index2, chapter1.name )
        i1 = self.chapterlist.index( chapter1 )
        i2 = self.chapterlist.index( chapter2 )
        self.chapterlist[ i1 ] = chapter2
        self.chapterlist[ i2 ] = chapter1
        self.current_chapter = chapter2
        self.c.frame.tree = chapter2.tree
        self.c.beginUpdate()
        self.c.endUpdate()
        if undo:
            self.chaptersundoer.addEdit( self.UndoSwapChapters( self, chapter1, chapter2 )) 
    finally:
        self.endUpdate()
    
    
#@nonl
#@-node:ekr.20060201150547.14:swapChapters
#@+node:ekr.20060201150547.15:mergeChapters
def mergeChapters( self, chapter1, chapter2 ):

	try:    
        self.beginUpdate()
    
        rp = chapter2.getRootPosition()
        nodes = []
        for z in rp.self_and_siblings_iter( copy = True ):
            nodes.append( z )
    
        for z in nodes:
            z.unlink()
        
        rp2 = chapter1.getRootPosition()
        for z in rp2.self_and_siblings_iter( copy = True ):
            pass   
        base = z.copy()

    
        self.c.beginUpdate()
    
        for z in nodes:
            z.linkAfter( base )
            base = z.copy()
        
        self.quietRemoveChapter( chapter2 )
        self.c.endUpdate()    
    finally:
        self.endUpdate()
#@nonl
#@-node:ekr.20060201150547.15:mergeChapters
#@+node:ekr.20060201150547.16:selectChapter
def selectChapter( self, chapter ):
    
    widget = chapter.tree.getWidget()
    index = self.book.indexOfComponent( widget )
    if index != -1:
        self.book.setSelectedComponent( widget )
    
#@nonl
#@-node:ekr.20060201150547.16:selectChapter
#@+node:ekr.20060201150547.17:insertChapter
def insertChapter( self, chapter ):
    
    self.chapterlist.append( chapter )
    tree = chapter.tree 
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()   
    self.chapters[ widget ] = chapter
    ic = self.IconCloser( self.icon, self.removeChapter )
    self.book.addTab( chapter.name, ic, widget )

#@-node:ekr.20060201150547.17:insertChapter
#@+node:ekr.20060201150547.18:findChapterForNode
def findChapterForNode( self, p ):
    
    for n in xrange( self.book.getTabCount() ):
        widget = self.book.getComponentAt( n )
        chapter = self.chapters[ widget ]
        rp = chapter.getRootPosition()
        for z in rp.fromSelfAllNodes_iter( copy = True ):
            if z == p: return chapter
        
    return None
#@nonl
#@-node:ekr.20060201150547.18:findChapterForNode
#@+node:ekr.20060201150547.19:turnNodeIntoChapter
def turnNodeIntoChapter( self ):
    
    cp = self.current_chapter.getCurrentPosition()
    if cp.isRoot():
        testroot = cp.copy()
        testroot.moveToNext()
        if not testroot:
            return
    self.c.beginUpdate()
    cp.unlink()
    rp = self.current_chapter.getRootPosition()
    self.current_chapter.setCurrentPosition( rp )
    self.c.endUpdate()
    self.freshChapter( p = cp )
#@nonl
#@-node:ekr.20060201150547.19:turnNodeIntoChapter
#@-node:ekr.20060201150547.8:utility
#@+node:ekr.20060201150547.20:import and export
@others
#@+node:ekr.20060201150547.21:import outline
def importOutline( self ):
    
    fc = swing.JFileChooser()
    fc.showOpenDialog( None )
    sfile = fc.getSelectedFile()
    if sfile:
        self.loadFileAsChapter( sfile.getAbsolutePath() )
    
def loadFileAsChapter( self, fname ):
    
    c = self.c
    targetfile = java.io.File( fname )
    if not targetfile.exists() or targetfile.isDirectory():
        return
    
    mungedname = targetfile.getName()
    if mungedname.endswith( ".leo") : mungedname = mungedname[ : -4 ]
    def run():
        self.freshChapter( name = mungedname, edit = False, undo = False )
        
    dc = DefCallable( run )
    ft = dc.wrappedAsFutureTask()
    if java.awt.EventQueue.isDispatchThread():
        ft.run()
    else:
        swing.SwingUtilities.invokeAndWait( ft )
    
    edit = sel.UndoImport( self, self.current_chapter )
    self.chaptersundoer.addEdit( edit )
    c.frame.disableResizing()
    p = c.fileCommands.getLeoFileAsOutline( fname )
    c.frame.enableResizing()
    oldir = c.frame.openDirectory
    parent = targetfile.getParentFile()
    c.frame.openDirectory = parent.getAbsolutePath()
    c.atFileCommands.readAll( c.rootPosition().copy() ,partialFlag=False)
    c.frame.openDirectory= oldir
    self.deferedChapterization( c.rootPosition(), selectchapter = self.getSelectedChapterWidget(), edit = edit )

#@-node:ekr.20060201150547.21:import outline
#@+node:ekr.20060201150547.22:export outline
def exportOutline( self ):
    
    self.chaptersIterationBlocked = 1
    self.beginUpdate()
    fc = swing.JFileChooser()
    fc.showSaveDialog( None )
    sfile = fc.getSelectedFile()
    if not sfile:
        g.es( "No file name entered." )
        return
    fileName = fc.getName( sfile )
    if not fileName.endswith( ".leo" ):
        fileName = "%s.leo" % fileName
    self.c.fileCommands.write_Leo_file( fileName, True )
    self.chaptersIterationBlocked = 0
    self.endUpdate()
    g.es( "Done Exporting %s as %s" % ( self.current_chapter.name, fileName ) )
#@nonl
#@-node:ekr.20060201150547.22:export outline
#@-node:ekr.20060201150547.20:import and export
#@+node:ekr.20060201150547.23:adding and removing chapters
@others
#@+node:ekr.20060201150547.24:addChapter
def addChapter( self, name, p = None ):
    

    c = self.c
    chapter = self.Chapter()
    self.chapterlist.append( chapter )
    chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
    chapter.setRootPosition( p )
    chapter.setCurrentPosition( p )
    #self.current_chapter = current
    cm = self.ChapterModel( c , chapter) #, p )
    tree = leoSwingTree( frame = c.frame, model = cm, chapter= chapter )
    tree.createAuxilaryWidgets()
    #self.c.frame.tree = tree
    chapter.setTree( tree )
    chapter.name = name
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()
    
    self.chapters[ widget ] = chapter
    ic = self.IconCloser( self.icon, self.removeChapter )
    self.book.addTab( name, ic, widget )

    if not self.current_chapter:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        self.endUpdate()

    return tree



#@-node:ekr.20060201150547.24:addChapter
#@+node:ekr.20060201150547.25:addChapterForSettingsTree
def addChapterForSettingsTree( self, name, p = None , controller = None):
    
    c = self.c
    chapter = self.current_chapter
    #chapter = self.Chapter()
    #chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
    chapter.setRootPosition( p )
    chapter.setCurrentPosition( p )
    #c.chapters.current_chapter = chapter
    #chapter = self.current_chapter
    cm = self.ChapterModel( c , chapter)
    import leoConfig
    tree = leoConfig.settingsTree( frame = c.frame, model = cm, chapter = chapter, controller = controller )
    chapter.setTree( tree )
    chapter.name = name
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()
    
    self.chapters[ widget ] = chapter
    self.book = self.getWidget()
    self.book.addTab( name, widget )
    if not self.current_chapter:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        self.endUpdate()

    return tree




#@-node:ekr.20060201150547.25:addChapterForSettingsTree
#@+node:ekr.20060201150547.26:freshChapter
def freshChapter( self, p = None, name = None, edit = True, undo = True ):
    
    c = self.c
    if not p:
        t = leoNodes.tnode( headString = "NewHeadline" )
        v = leoNodes.vnode( c, t )
        p = leoNodes.position( v, [] )
    if not name:
        name = "New Chapter"
    tree = self.addChapter( name, p = p )                    
    chapter = self.trees_chapters[ tree ]
    if undo:
        self.chaptersundoer.addEdit( self.UndoAddChapter( self, chapter ) ) 
    try:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        p.linkAsRoot( None )
        #self.current_chapter = current 
        widget = tree.getWidget()
        self.book.setSelectedComponent( widget )   
    finally:
        self.endUpdate()
    tree.loaded = 1
    if edit:
        self.c.editPosition( p.copy() )
#@nonl
#@-node:ekr.20060201150547.26:freshChapter
#@+node:ekr.20060201150547.27:removeChapter
def removeChapter( self, chapter = None, undo = True ):

    tree = self.c.frame.tree
    vrect = tree.jspane.getViewportBorderBounds()
    main_widget = tree.getWidget()
    gp = main_widget.getGlassPane()
    bgc = tree.jtree.getBackground()
    fgc = tree.jtree.getForeground() 
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    fg = self.book.getForegroundAt( index )
    bg = self.book.getBackgroundAt( index )
    if chapter.isMessaging() or self.isPromptingForRemove(): return
    chapter.startMessaging()
    self.startPromptingForRemove()
    self.book.setForegroundAt( index, bg )
    self.book.setBackgroundAt( index, fg )
    if self.book.getTabCount() == 1:
        def ok( chapter = chapter ):
            self.stopPromptingForRemove()
            chapter.doneMessaging()
            self.book.setForegroundAt( index, fg )
            self.book.setBackgroundAt( index, bg )
        buttons = ( ( "Ok", ok ), )
        sa = self.SliderMessageButtons( "Can't remove the only Chapter", buttons = buttons, bgc = bgc, fgc = fgc )
        gp.setVisible( True )
        swidget = sa.getSlider()
        height = swidget.getPreferredSize().height
        vrect.height = height
        swidget.setBounds( vrect )
        gp.add( swidget )
        return
    else:
        message = "Do you want to remove Chapter: %s ?" % chapter.name
        def yes( component = component, chapter = chapter ):
            self.book.remove( component )
            chapter.doneMessaging()
            self.chapterlist.remove( chapter )
            tree = chapter.tree 
            del self.trees_chapters[ tree ]
            del self.chapters[ component ]
            self.chaptersundoer.addEdit( self.UndoRemoveChapter( self, chapter ) )
            try:
                index = self.book.getSelectedIndex()
                component = self.book.getComponentAt( index )
                #self.chapters[ widget ] = chapter
                chapter = self.chapters[ component ]
                self.beginUpdate()
                self.current_chapter = chapter
                self.c.frame.tree = chapter.tree
            finally:
                self.endUpdate()
            self.stopPromptingForRemove()            
            g.doHook( "chapter-removed", c = self.c, chapter = chapter )
            
        def no( chapter = chapter ):
            self.stopPromptingForRemove()
            chapter.doneMessaging()
            self.book.setForegroundAt( index, fg )
            self.book.setBackgroundAt( index, bg )
            
        buttons = ( ( "Yes", yes ), ( "No", no ) )
        sa = self.SliderMessageButtons( message, buttons = buttons, bgc = bgc, fgc = fgc )
        gp.setVisible( True )
        swidget = sa.getSlider()
        height = swidget.getPreferredSize().height
        vrect.height = height
        swidget.setBounds( vrect )
        gp.add( swidget )            
           
@    
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    rv = swing.JOptionPane.showConfirmDialog( None,
                                             "Do you want to remove Chapter: %s" % chapter.name,
                                             "Remove a Chapter?",
swing.JOptionPane.YES_NO_OPTION )
    if rv == swing.JOptionPane.NO_OPTION: return


    self.book.removeTabAt( index ) #removing does not fire a change event
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    self.chapterlist.remove( chapter )
    try:
        self.beginUpdate()
        self.current_chapter = chapter
        self.c.frame.tree = chapter.tree
    finally:
        self.endUpdate()
    g.doHook( "chapter-removed", c = self.c, chapter = chapter )
#@-node:ekr.20060201150547.27:removeChapter
#@+node:ekr.20060201150547.28:quietRemoveChapter
def quietRemoveChapter( self, chapter ):
    
    tree = chapter.tree
    component = tree.getWidget()
    self.book.remove( component )
    self.chapterlist.remove( chapter )
    del self.trees_chapters[ tree ]
    del self.chapters[ component ]    
#@-node:ekr.20060201150547.28:quietRemoveChapter
#@-node:ekr.20060201150547.23:adding and removing chapters
#@+node:ekr.20060201150547.29:transforming an Outline into Chapers components
@others
#@+node:ekr.20060201150547.30:deferedChaperization
def deferedChapterization (self,pos,selectchapter=None,edit=None):

    x = lambda: self.breakOutlineIntoChapters(pos,selectchapter,edit)
    dc = DefCallable(x)
    ft = dc.wrappedAsFutureTask()
    swing.SwingUtilities.invokeLater(ft)
#@nonl
#@-node:ekr.20060201150547.30:deferedChaperization
#@+node:ekr.20060201150547.31:breakOutlineIntoChapters
def breakOutlineIntoChapters( self, p, selectchapter = None, edit = None ):
    
    #self.loading = 1
    self.beginUpdate()
    #self.updateLock.unlock()
    n = 0 
    last_z = None
    p2 = p.copy()
    level_0 = []
    for z in p.self_and_siblings_iter( copy = True ):
        level_0.append( z )

    if level_0:
        p1 = level_0[ 0 ]
        v1 = p1.v
        if hasattr( v1, "unknownAttributes" ):
            uA = v1.unknownAttributes
            if uA.has_key( "chapter_name" ):
                name = uA[ 'chapter_name' ]
                i = self.book.getSelectedIndex()
                self.book.setTitleAt( i, name )
                if self.current_chapter: #This needs to be set here or its lost in the next save
                    self.current_chapter.name = name

    for z in level_0:
        v = z.v
        name = "New Chapter"
        if hasattr( v, "unknownAttributes" ):
            if v.unknownAttributes.has_key( "chapter" ):
                a_n = v.unknownAttributes[ "chapter" ]
            else:
                a_n = n
            if v.unknownAttributes.has_key( "chapter_name" ):
                name = v.unknownAttributes[ "chapter_name" ]
        else:
            a_n = n
   
        if a_n != n:
            #self.c.endUpdate()
            n = a_n
            #z.doDelete( p2 )
            z.unlink()
            tree = self.c.chapters.addChapter( name, z.copy() )
            widget = tree.getWidget()
            chapter = self.chapters[ widget ]
            self.c.frame.tree = chapter.tree
            self.current_chapter = chapter
            if edit and hasattr( edit, "addChapter" ):
                edit.addChapter( chapter )
            ic = self.IconCloser( self.icon, self.removeChapter )
            self.book.addTab( name, ic, widget )
            #self.book.addTab( name, widget )
            self.book.setSelectedComponent( widget )
            #self.c.beginUpdate()
            last_z = z
            z.linkAsRoot( None )
            tree.loaded = 1
            continue
        
        if last_z:
            #z.moveAfter( last_z )
            z.unlink() 
            z.linkAfter( last_z )
        last_z = z           
    
    if not selectchapter:
        selectchapter = self.book.getComponentAt( 0 )       
    self.book.setSelectedComponent( selectchapter )
    self.c.beginUpdate()
    self.c.endUpdate()       
    self.endUpdate()
#@nonl
#@-node:ekr.20060201150547.31:breakOutlineIntoChapters
#@-node:ekr.20060201150547.29:transforming an Outline into Chapers components
#@+node:ekr.20060201150547.32:class ChaptersPopup
class ChaptersPopup( aevent.MouseAdapter ):
    
    def __init__( self, chapters ):
        aevent.MouseAdapter.__init__( self )
        self.chapters = chapters
        self.copyNodeToChapter = self.CopyNodeToChapter( chapters )
        self.cloneNodeToChapter = self.CloneNodeToChapter( chapters )
        self.swapChapters = self.SwapChapters( chapters )
        self.mergeChapters = self.MergeChapters( chapters )
        self.enabled = True
        
    def disable( self ):
        self.enabled = False
        
    def enable( self ):
        self.enabled = True
        
    @others
#@nonl
#@+node:ekr.20060201150547.33:mousePressed
def mousePressed( self, mE ):
                
    if mE.getClickCount() == 1 and self.enabled:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()
            DefAction = self.chapters.DefAction        
            popup = swing.JPopupMenu()            
            popup.add( DefAction( "Add Chapter", self.chapters.freshChapter ) ) 
            #popup.add( DefAction( "Remove Chapter", self.chapters.removeChapter ) )
            #popup.add( DefAction( "ITERATE!", self.chapters.iterateOverChapters ) ) 
            popup.add( DefAction( "Edit Chapters Name", self.chapters.changeChaptersName ) )
            popup.addSeparator()
            popup.add( self.copyNodeToChapter.getWidget() )
            popup.add( self.cloneNodeToChapter.getWidget() )
            popup.add( self.swapChapters.getWidget() )
            popup.add( self.mergeChapters.getWidget() )
            popup.add( DefAction( "Copy Node Into Chapter", self.chapters.turnNodeIntoChapter ) )
            #popup.add( DefAction( "Test NODE", self.chapters.testNode ) )
            popup.addSeparator()
            menu = swing.JMenu( "Import/Export" )
            popup.add( menu )
            menu.add( DefAction( "Import Outline", self.chapters.importOutline ) )
            menu.add( DefAction( "Export Chapter as Outline", self.chapters.exportOutline ) )
            popup.addSeparator()
            undoer = self.chapters.chaptersundoer
            utext = undoer.getUndoPresentationName()
            item = popup.add( DefAction( utext, undoer.undo ) )
            if not undoer.canUndo():
                item.setEnabled( False )
                
            rtext = undoer.getRedoPresentationName()
            item = popup.add( DefAction( rtext, undoer.redo ) )
            if not undoer.canRedo():
                item.setEnabled( False )    
                              
            source = mE.getSource()                
            popup.show( source, x, y )
#@-node:ekr.20060201150547.33:mousePressed
#@+node:ekr.20060201150547.34:class CopyNodeToChapter
class CopyNodeToChapter( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Copy Node To Chapter" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        cpos = current.getCurrentPosition()
        root = current.getRootPosition()
        #if cpos == root:
        #    roottest = cpos.copy()
        #    roottest.moveToNext()
        #    if not roottest:
        #        return
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mvnd = lambda event, cpos = cpos.copy(), chapter = z: self.chapters.copyNodeToChapter( cpos, chapter )
            jmi.actionPerformed = mvnd
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
#@-node:ekr.20060201150547.34:class CopyNodeToChapter
#@+node:ekr.20060201150547.35:class CloneNodeToChapter
class CloneNodeToChapter( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Clone Node To Chapter" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        cpos = current.getCurrentPosition()
        root = current.getRootPosition()
        #if cpos == root:
        #    roottest = cpos.copy()
        #    roottest.moveToNext()
        #    if not roottest:
        #        return
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mvnd = lambda event, cpos = cpos.copy(), chapter = z: self.chapters.cloneNodeToChapter( cpos, chapter )
            jmi.actionPerformed = mvnd
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
#@-node:ekr.20060201150547.35:class CloneNodeToChapter
#@+node:ekr.20060201150547.36:class SwapChapters
class SwapChapters( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Swap Chapters" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            swapchap = lambda event,  chapter = z: self.chapters.swapChapters( current, chapter )
            jmi.actionPerformed = swapchap
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
#@-node:ekr.20060201150547.36:class SwapChapters
#@+node:ekr.20060201150547.37:class MergeChapters
class MergeChapters( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Merge Chapters" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mergechapters = lambda event,  chapter = z: self.chapters.mergeChapters( current, chapter )
            jmi.actionPerformed = mergechapters
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
#@-node:ekr.20060201150547.37:class MergeChapters
#@-node:ekr.20060201150547.32:class ChaptersPopup
#@+node:ekr.20060201150547.38:Action Classes
@others
#@+node:ekr.20060201150547.39:DefAction
class DefAction( swing.AbstractAction ):
    
    def __init__( self, name, function ):
        swing.AbstractAction.__init__( self, name )
        self.function = function
    
    def actionPerformed( self, event ):
        self.function()
#@nonl
#@-node:ekr.20060201150547.39:DefAction
#@-node:ekr.20060201150547.38:Action Classes
#@+node:ekr.20060201150547.40:class ChapterModel
class ChapterModel( stree.TreeModel, java.lang.Runnable ):
    
    
    
    def __init__( self, c , chapter ):#, proot ):

        self.c = c
        self.tmlisteners = java.util.ArrayList();
        self._root = self._rootN( c, chapter ) # , proot )
        self._rTreePath = stree.TreePath( self._root ) 
        self.chapter = chapter
        self.drunning = 0

        
    def getChapter( self ):
        return self.chapter

    def getRoot( self ):
        return self._root

    def reload( self, full_reload = False ):
        
        
        if full_reload:
            t_r = self.c.frame.tree.tree_reloader
            #for z in self.c.rootPosition().allNodes_iter( copy = True ):
            for z in self._root.getRootPosition().allNodes_iter( copy = True ):
                if z.isExpanded():
                    t_r.expand( z )
        
        import jarray
        a = jarray.zeros( 1, stree.TreeNode )
        a[ 0 ] = self._root
        e = sevent.TreeModelEvent( self._root, a )
        for z in list( self.tmlisteners ):
            z.treeStructureChanged( e )

            
    def dRun( self ):
        self.drunning = 1
        swing.SwingUtilities.invokeLater( self )
            
    def run( self ):
        
        try:
            import jarray
            a = jarray.zeros( 1, stree.TreeNode )
            a[ 0 ] = self._root
            e = sevent.TreeModelEvent( self._root, a )
            for z in list( self.tmlisteners ):
                z.treeStructureChanged( e )
            if self.chapter.tree.jtree:
                self.chapter.tree.jtree.fireTreeExpanded( self._rTreePath )
                cp = self.chapter.getCurrentPosition()
                cpp = self.getPathToRoot( cp )
                self.chapter.tree.jtree.setSelectionPath( cpp )
        finally:
            self.drunning = 0
    
    def addTreeModelListener( self, listener ):
        self.tmlisteners.add( listener )
        
    def removeTreeModelListener( self, listener ):
        self.tmlisteners.remove( listener )
    
    def getChild( self, parent, ind ):
        if parent is self._root:
            return parent.getChildAt( ind ).copy()
        return parent.getNthChild( ind ).copy()
        
    def getChildCount( self, parent ):
        
        if parent is self._root:
            return parent.getChildCount()
        if parent:
            return parent.numberOfChildren()
        else:
            return 0
        
    def getIndexOfChild( self, parent, child ):
        if parent is self._root:
            return self._root.getIndex( child )
        else:
            return child.childIndex()


    
    def valueForPathChanged( self, path, value ):

        pos = path.getLastPathComponent()
        pos.setHeadString( value )
        
    def isLeaf( self, node ):
        if node is self._root: return False
        if node:
            if node.numberOfChildren(): return False
            else: return True
        else:
            return True
            
            
    def getPathToRoot( self, node, masterlist = None ):
        
        path = []
        #if not node:
        #    node = self.c.rootPosition()
        stopat = None
        if self.chapter.hoistStack:
            bunch = self.chapter.hoistStack[ -1 ]
            stopat = bunch.p.copy()
            
        while node and node.level() != 0:
            path.append( node.copy() )
            if node == stopat: break
            node = node.getParent()
            if masterlist:
                if node in masterlist:
                    masterlist.remove( node )
        else:
            path.append( node.copy() )
        
        path.append( self._root )  
        path.reverse()
        tp = stree.TreePath( path )
        return tp
            
    class _rootN( stree.TreeNode ):
        
        def __init__( self, c, chapter ):#, proot ):
            self.c = c
            self.chapter = chapter
            self.v = None # These are for comparisons with positions, we must pretend to be a position
            self.stack = None
            
            #self.chapters = c.chapters
            #self.proot = proot
        def expand( self ): pass
        def contract( self ): pass
        
        def getChildIndex( self ):
            return -1
        
        def getRootPosition( self ):
            rp = self.chapter.getRootPosition()
            return rp

        
        def getChildAt(self, childIndex):
            rp = self.getRootPosition() #self.c.rootPosition()                
            #if len( self.c.hoistStack ) != 0: #Hoist Code
            if len( self.chapter.hoistStack ) != 0:
                #rp = self.c.hoistStack[ -1 ].p.copy()
                rp = self.chapter.hoistStack[ -1 ].p.copy()
                def getParent( root = self ): #This slight modification to a copy allows the Tree to keep its expanded state
                    return root
                rp.getParent = getParent
                return rp #End of Hoist Code
            if not rp: return None
            i = 0
            for z in rp.siblings_iter():
                if i == childIndex:
                    return z
                i = i + 1
            return None       
        
        def getChildCount( self ):
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            if len( self.chapter.hoistStack ) != 0:
                return 1
            #if len( self.c.hoistStack ) != 0:
            #    return 1
            i = 0
            for z in rp.siblings_iter():
                i = i + 1
            return i
        
        def getParent( self ):
            return None
            
        def getIndex( self, node):
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            if len( self.chapter.hoistStack ) != 0:
                return 0
            i = 0
            for z in rp.siblings_iter():
                if z == node: return i
                i = i + 1
            return -1
            
        def getAllowsChildren( self ):
            return True
            
        def isLeaf( self ):
            return False
            
        def equal( self, x ):
            if self is x: return True
            else: return False
            
        def equals( self, x ):
            if self is x: return True
            else:
                return False
            
        def copy( self ):
            return self
            
        def bodyString( self ):
            return ""
            
        def headString( self ):
            return ""
            
        def children( self ):
            
            class _enum( util.Enumeration ):
                
                def __init__( self, iter ):
                    self.iter = iter
                    try:
                        self.next = iter.next()
                    except:
                        self.next = None
                
                def hasMoreElements( self ):
                    if self.next: return True
                    else: return False
                    
                def nextElement( self ):
                    
                    try:
                        rt = self.next
                        self.next = iter.next()
                    finally:
                        return rt
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            return _enum( rp.siblings_iter( copy = True ) )
            #return _enum( self.c.rootPosition.siblings_iter( copy = True ) )


#@-node:ekr.20060201150547.40:class ChapterModel
#@+node:ekr.20060201150547.41:class Chapter
class Chapter:
    
    def __init__( self ):
        
        self.root = None
        self.currentPosition = None
        self.tree = None
        self.name = None
        self.hoistStack = []
        self.undoer = None
        self.messaging = False
        
    def startMessaging( self ):
        self.messaging = True
    
    def isMessaging( self ):
        return self.messaging
        
    def doneMessaging( self ):
        self.messaging = False
        
    def isValid( self ):
        widget = self.tree.getWidget()
        if widget.getParent(): return True
        else:
            return False    
        
    def setUndoer( self, undoer ):
        self.undoer = undoer
        
    def getUndoer( self ):
        return self.undoer
        
    def getName( self ):
        return self.name
        
    def setName( self, name ):
        self.name = name
        
    
    def getTree( self ):
        return self.tree
        
    def setTree( self, tree ):
        self.tree = tree
    
    def setRootPosition( self, p ):
        if p:
            p = p.copy()
        self.root = p

    def getRootPosition( self ):
        p = self.root
        if p:
            p = p.copy()
        return p
    
    def setCurrentPosition( self, p ):
        if p:
            p = p.copy()        
        self.currentPosition = p
        
    
    def getCurrentPosition( self ):
        p = self.currentPosition
        if p:
            p = p.copy()
        return p
#@nonl
#@-node:ekr.20060201150547.41:class Chapter
#@+node:ekr.20060201150547.42:class SliderMessageButtons
class SliderMessageButtons( sevent.AncestorListener ):
    '''A class that manages creates a message with 0 to N buttons for
       the user to select.  After selecting the button, the slider is removed.
       After removal the function corresponding to the button is fired'''
       
    def __init__( self, message, buttons = (), direction = Slider.down, bgc = None, fgc = None ):
        
        self.backingpanel = swing.JPanel( awt.BorderLayout() )
        self.slider = Slider( self.backingpanel, direction )
        if fgc:
            lb = swing.border.LineBorder( fgc )
            self.backingpanel.setBorder( lb )
        else:
            lb = swing.border.LineBorder( self.backingpanel.getForeground() )
            self.backingpanel.setBorder( lb )
        jl = swing.JLabel( message )
        jl.setHorizontalAlignment( swing.SwingConstants.CENTER )
        self.backingpanel.add( jl )
        jp2 = swing.JPanel()
        self.func = None
        for z in buttons:
            label = z[ 0 ]
            func = z[ 1 ]
            b = swing.JButton( label )
            b.actionPerformed = lambda event, func = func: self.__removeCall( func )
            jp2.add( b )

        self.backingpanel.add( jp2, awt.BorderLayout.SOUTH )
        self.slider.setSize( self.slider.getPreferredSize() )
        if not fgc is None:
            self.backingpanel.setForeground( fgc )
            jp2.setForeground( fgc )
            jl.setForeground( fgc )
        if not bgc is None:
            self.backingpanel.setBackground( bgc )
            jp2.setBackground( bgc )
            jl.setBackground( bgc )
        
    def __removeCall( self, func ):
        self.slider.addAncestorListener( self )
        self.slider.startRemoving()
        self.func = func
        
    def ancestorAdded( self, event):
        pass
        
    def ancestorMoved( self, event ):
        pass
        
    def ancestorRemoved( self, event ):
        if not self.func is None:
            self.func()
        
    def getSlider( self ):
        return self.slider

#@-node:ekr.20060201150547.42:class SliderMessageButtons
#@+node:ekr.20060201150547.43:IconCloser
class IconCloser( swing.Icon, aevent.MouseAdapter ):
    
    def __init__( self, iicon, callback ):
        
        aevent.MouseAdapter.__init__( self )
        self.iicon = iicon
        self.component = None
        self.x = None
        self.y = None
        self.callback = callback
        
    def mousePressed( self, event ):
        
        if event.getButton() == event.BUTTON1:
            x = event.getX(); y = event.getY()
            rec = awt.Rectangle( self.x, self.y, self.iicon.getIconWidth(), self.iicon.getIconHeight() )
            if rec.contains( x,y ):
                self.component.removeMouseListener( self )
                self.component = None
                dc = DefCallable(self.callback)
                swing.SwingUtilities.invokeLater(dc.wrappedAsFutureTask())
        
    def getIconHeight( self ):
        
        return self.iicon.getIconHeight()
        
    def getIconWidth( self ):
        
        return self.iicon.getIconWidth()
        
    def paintIcon( self, jc, g, x, y ):
        
        if self.component == None:
            self.component = jc
            jc.addMouseListener( self )
        self.x = x
        self.y = y
        self.iicon.paintIcon( jc, g, x ,y )
        
#@nonl
#@-node:ekr.20060201150547.43:IconCloser
#@+node:ekr.20060201150547.44:iterators
@others
#@+node:ekr.20060201150547.45:chaptersIterator
def chaptersIterator( self ):

    if not self.chaptersIterationBlocked:
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            rp = chapter.getRootPosition()
            for z in rp.fromSelfAllNodes_iter( copy = True ):
                yield z
    else:
        
        for z in self.c.allNodes_iter( copy = 1 ):
            yield z            

                
#@-node:ekr.20060201150547.45:chaptersIterator
#@+node:ekr.20060201150547.46:topLevelSiblingsIterator
def topLevelSiblingsIterator( self, ):

    if not self.chaptersIterationBlocked:
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            rp = chapter.getRootPosition()
            for z in rp.self_and_siblings_iter( copy = True ):
                yield z
    else:
        rp = self.c.rootPosition()
        for z in rp.self_and_siblings_iter( copy = True ):
            yield z
            
#@-node:ekr.20060201150547.46:topLevelSiblingsIterator
#@+node:ekr.20060201150547.47:cycleThroughChapters
def cycleThroughChapters( self, swap = 1 ):

    if not self.chaptersIterationBlocked:
        current = self.current_chapter
        if swap: self.beginUpdate()
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            if swap:    
                self.current_chapter = chapter
            yield chapter
    
        self.current_chapter = current
        if swap: self.endUpdate()
    else:
        yield self.current_chapter
    
#@-node:ekr.20060201150547.47:cycleThroughChapters
#@-node:ekr.20060201150547.44:iterators
#@+node:ekr.20060201150547.48:Undo
@others
#@nonl
#@+node:ekr.20060201150547.49:UndoRemoveChapter
class UndoRemoveChapter( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter = chapter
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Remove Chapter %s" % self.chapter.name
    def getRedoPresentationName( self ): return "Redo Removing %s" % self.chapter.name
    def getUndoPresentationName( self ): return "Undo Removing %s" % self.chapter.name
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.quietRemoveChapter( self.chapter )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.insertChapter( self.chapter )
        self.undone = True
    
#@-node:ekr.20060201150547.49:UndoRemoveChapter
#@+node:ekr.20060201150547.50:UndoChangeChapterName
class UndoChangeChapterName( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter, name1, name2 ):
        self.chapters = chapters
        self.chapter = chapter
        self.name1 = name1
        self.name2 = name2
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Changing Chapter Name From %s to %s" % ( self.name1, self.name2 )
    def getRedoPresentationName( self ): return "Redo Changing Name From %s to %s" %  ( self.name1, self.name2 )
    def getUndoPresentationName( self ): return "Undo Changing Name From %s to %s" % ( self.name1, self.name2 )
    def isSignificant( self ): return True
    def redo( self ):
        
        book = self.chapters.book
        index = book.indexOfComponent( self.chapter.tree.getWidget() )
        book.setTitleAt( index, self.name2 )
        self.chapter.name = self.name2
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        book = self.chapters.book
        index = book.indexOfComponent( self.chapter.tree.getWidget() )
        book.setTitleAt( index, self.name1 )
        self.chapter.name = self.name1
        self.undone = True
#@-node:ekr.20060201150547.50:UndoChangeChapterName
#@+node:ekr.20060201150547.51:UndoAddChapter
class UndoAddChapter( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter = chapter
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Add Chapter"
    def getRedoPresentationName( self ): return "Redo Add Chapter"
    def getUndoPresentationName( self ): return "Undo Add Chapter"
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.insertChapter( self.chapter )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.quietRemoveChapter( self.chapter )
        self.undone = True
    
#@-node:ekr.20060201150547.51:UndoAddChapter
#@+node:ekr.20060201150547.52:UndoImport
class UndoImport( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter_list = []
        self.chapter_list.append( chapter )
        self.undone = False
    
    def addChapter( self, chapter ):
        self.chapter_list.append( chapter )
           
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Import Outline"
    def getRedoPresentationName( self ): return "Redo Import Outline"
    def getUndoPresentationName( self ): return "Undo Import Outline"
    def isSignificant( self ): return True
    def redo( self ):
        
        for z in self.chapter_list:
            self.chapters.insertChapter( z )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        for z in self.chapter_list:
            self.chapters.quietRemoveChapter( z )
        self.undone = True
    
#@-node:ekr.20060201150547.52:UndoImport
#@+node:ekr.20060201150547.53:UndoSwapChapters
class UndoSwapChapters( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter1, chapter2 ):
        self.chapters = chapters
        self.chapter1 = chapter1
        self.chapter2 = chapter2
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Swap Chapters %s , %s" % ( self.chapter1.name, self.chapter2.name )
    def getRedoPresentationName( self ): return "Redo Swap Chapters %s, %s" % ( self.chapter1.name , self.chapter2.name )
    def getUndoPresentationName( self ): return "Undo Swap Chapters %s, %s" % ( self.chapter1.name , self.chapter2.name )
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.swapChapters( self.chapter1, self.chapter2, undo = False )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.swapChapters( self.chapter1, self.chapter2, undo = False )
        self.undone = True
    
#@-node:ekr.20060201150547.53:UndoSwapChapters
#@-node:ekr.20060201150547.48:Undo
#@+node:ekr.20060201161901:(Important)
#@+node:ekr.20060201150547.7:markNodesForChapterization
def markNodesForChapterization( self ):

    if not self.chaptersIterationBlocked:    
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for n in xrange( len(self.chapterlist)):
            chapter = self.chapterlist[ n ]
            rp = chapter.getRootPosition()
            rp_base = rp.copy()
            for z in rp.self_and_siblings_iter( copy = True ):
                v = z.v
                if not hasattr( v, "unknownAttributes" ):
                    v.unknownAttributes = {}
                v.unknownAttributes[ 'chapter' ] = n
                if z == rp_base:
                    v.unknownAttributes[ 'chapter_name' ] = chapter.name
    else:
        rp = self.getRootPosition()
        rp_base = rp.copy()
        for z in rp.self_and_siblings_iter( copy = True ):
            v = z.v
            if not hasattr( v, "unknownAttributs" ):
                v.unknownAttributes = {}
            v.unknownAttributes[ 'chapter' ] = 0
            if z == rp_base:
                v.unknownAttributes[ 'chapter_name' ] = self.current_chapter.name
#@nonl
#@-node:ekr.20060201150547.7:markNodesForChapterization
#@+node:ekr.20060201150547.29:transforming an Outline into Chapers components
@others
#@+node:ekr.20060201150547.30:deferedChaperization
def deferedChapterization (self,pos,selectchapter=None,edit=None):

    x = lambda: self.breakOutlineIntoChapters(pos,selectchapter,edit)
    dc = DefCallable(x)
    ft = dc.wrappedAsFutureTask()
    swing.SwingUtilities.invokeLater(ft)
#@nonl
#@-node:ekr.20060201150547.30:deferedChaperization
#@+node:ekr.20060201150547.31:breakOutlineIntoChapters
def breakOutlineIntoChapters( self, p, selectchapter = None, edit = None ):
    
    #self.loading = 1
    self.beginUpdate()
    #self.updateLock.unlock()
    n = 0 
    last_z = None
    p2 = p.copy()
    level_0 = []
    for z in p.self_and_siblings_iter( copy = True ):
        level_0.append( z )

    if level_0:
        p1 = level_0[ 0 ]
        v1 = p1.v
        if hasattr( v1, "unknownAttributes" ):
            uA = v1.unknownAttributes
            if uA.has_key( "chapter_name" ):
                name = uA[ 'chapter_name' ]
                i = self.book.getSelectedIndex()
                self.book.setTitleAt( i, name )
                if self.current_chapter: #This needs to be set here or its lost in the next save
                    self.current_chapter.name = name

    for z in level_0:
        v = z.v
        name = "New Chapter"
        if hasattr( v, "unknownAttributes" ):
            if v.unknownAttributes.has_key( "chapter" ):
                a_n = v.unknownAttributes[ "chapter" ]
            else:
                a_n = n
            if v.unknownAttributes.has_key( "chapter_name" ):
                name = v.unknownAttributes[ "chapter_name" ]
        else:
            a_n = n
   
        if a_n != n:
            #self.c.endUpdate()
            n = a_n
            #z.doDelete( p2 )
            z.unlink()
            tree = self.c.chapters.addChapter( name, z.copy() )
            widget = tree.getWidget()
            chapter = self.chapters[ widget ]
            self.c.frame.tree = chapter.tree
            self.current_chapter = chapter
            if edit and hasattr( edit, "addChapter" ):
                edit.addChapter( chapter )
            ic = self.IconCloser( self.icon, self.removeChapter )
            self.book.addTab( name, ic, widget )
            #self.book.addTab( name, widget )
            self.book.setSelectedComponent( widget )
            #self.c.beginUpdate()
            last_z = z
            z.linkAsRoot( None )
            tree.loaded = 1
            continue
        
        if last_z:
            #z.moveAfter( last_z )
            z.unlink() 
            z.linkAfter( last_z )
        last_z = z           
    
    if not selectchapter:
        selectchapter = self.book.getComponentAt( 0 )       
    self.book.setSelectedComponent( selectchapter )
    self.c.beginUpdate()
    self.c.endUpdate()       
    self.endUpdate()
#@nonl
#@-node:ekr.20060201150547.31:breakOutlineIntoChapters
#@-node:ekr.20060201150547.29:transforming an Outline into Chapers components
#@-node:ekr.20060201161901:(Important)
#@-node:ekr.20060201150547:Chapters
#@+node:ekr.20060201161901.1:Postings re undo
#@+node:ekr.20060201161901.2:@url http://sourceforge.net/forum/message.php?msg_id=3332355
@nocolor

By: Edward K. Ream - edream 
   RE: Dividing The Undo: doing w/o v.uA 
2005-09-09 14:17  
> If we can open up how [Leo] reads xml, it may make it simpler to start developing a stash scheme. 
 
I agree that reading xml more properly would be A Good Thing (tm). As we shall see, however, it is not the main issue. 
 
> DOM seems like a good path to start out on. 
 
This is not the path I would have chosen. The new colorizer at in leoPlugins.leo at: 
 
Plugins-->Experimental/unfinished-->New colorizer-->@thin __jEdit_colorizer__.py 
 
uses sax. I like the light-weight approach. I would rather do a bit more work in the initial parsing and create the data structures myself then relying on DOM. 
 
But parsing is irrelevant. The problem is the design of *thin* derived files and the code that reads such files. Let us consider how we can "do without" v.unknownAttributes in thin derived files. I **shall not** change the format of thin derived files, so some trickery is required. The first step is read this section of Leo's new docs: 
 
http://webpages.charter.net/edreamleo/customizing.html#adding-extensible-attributes-to-nodes-and-leo-files  /> 
The key here is the so-called 'hidden machinery'. This is an essential feature of the code that reads and writes thin derived files and it **will not** change. **Note**: Leo has two sets of read code: the code that reads .leo files has no trouble whatever recreating vnodes. It is only vnodes in thin derived files that may not have attributes. 
 
**Important**: for @thin trees (in the outline) Leo saves *only* the <v> element corresponding to the @thin node itself. It is this <v> element that contains the 'hidden machinery'. Don't even think about having Leo write the whole tree of <v> elements: the 4.0 read code is made possible because these <v> elements do *not* exist. This eliminates all the error 'recovery' schemes that can not, if fact, be robust enough. 
 
So the only real alternative is to add uA's sufficient to recreate elements in the *reconstituted* vnodes that Leo creates in the leoAtFile read logic. Happily, we can do this as follows. When writing, a plugin (or an extended Leo) would 'piggyback' the vnode attributes in the corresponding **t**.unknownAttributes field. When reading, the plugin (or Leo) would put the vnode attributes "where they belong" in the appropriate vnode. We associate a 'vnode traversal index' with each vnode. This is simply how many previous "same" vnodes appeared in the traversal before getting to the desired vnode. Something like this:: 
 
vx = {} # traversal indices for vnodes. 
for p in c.allNodes_iter(): 
....n = vx.get(p.v.t,0) # n is the traversal index for vnode p.v. 
....vx[p.v.t] = n+1 # bump the index for the next v such that v.t == p.v.t 
 
We store attributes for vnode v in v.t.unknownAttributes, along with the traversal index. The read code uses the traversal index to copy vnode attributes from t.unknownAttributes to v.unknownAttrutes. Rather than forcing each plugin to do this, Leo should probably have support for this in the leoFileCommands read/write code. In short, the t.unknownAttributes machinery suffices in theory, and in practice a bit of support code would be good. 
 
Glad you asked :-) . I have been willing to live without v.uA's in thin derived files. I never thought much about this until you asked, but necessity is the mother... So this is good. A way exists to treat all vnodes as first-class citizens. 
 
Edward 
#@-node:ekr.20060201161901.2:@url http://sourceforge.net/forum/message.php?msg_id=3332355
#@-node:ekr.20060201161901.1:Postings re undo
#@+node:ekr.20060201152349:NodeUndoer.py
@ignore

<<imports>>
#commanders = util.WeakHashMap()
commanders = {}


class NodeUndoer:
    '''A class that manages NodeUndoerBase instances for tnodes'''
    
    undoers = {} #util.WeakHashMap()
    checksums = util.WeakHashMap()
    
    def __init__( self, c, umenu, rmenu, gtnu, gtnr, vunstack, clearundo ):
        '''c -> a commander
           umenu -> a JMenuItem that is the 'undo' action
           rmenu -> a JMenuItem that is the 'redo' action
           gtnu -> a JMenuItem that is the 'goto next undo' action
           gtnr -> a JMenuItem that is the 'goto next redo' action
           vunstack -> a JMenuItem that is the 'visualise undo stack' action
           clearundo -> a JMenuItem that is the 'clear undo stack' action
        '''
        
        self.c = c
        self.umenu = umenu
        umenu.actionPerformed = lambda event: self.undo()
        self.rmenu = rmenu
        rmenu.actionPerformed = lambda event: self.redo()
        self.gtnu = gtnu
        gtnu.actionPerformed = lambda event: self.gotoNextUndoSpot()
        self.gtnr = gtnr
        gtnr.actionPerformed = lambda event : self.gotoNextRedoSpot()
        self.umanager = None
        self.vunstack = vunstack
        vunstack.actionPerformed = lambda event: self.visualiseUndoStack()
        self.clearundo = clearundo
        clearundo.actionPerformed = lambda event: self.clearUndo()
        self.ignore = 0
        self.tnode = None
        self.compound = None 
        self.checksums_ok = 1
        self.checksum_violations = []
        wm1 = WeakMethod( self, "serializeForLeoFile" ); wm2 = WeakMethod( self, "unserializeFromLeoFile" )
        wm3 = WeakMethod( self, "checkSumViolation" )
        leoPlugins.registerHandler( "write-leo-file-data", wm1 )
        leoPlugins.registerHandler( "read-leo-file-data", wm2 )
        leoPlugins.registerHandler( "checksum-violation", wm3 )
    
    def undo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.undo()
        self.setMenu()
        self.ignore = 0
        return
        
    def redo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.redo()
        self.setMenu()
        self.ignore = 0
        return
        
    
    def setNode( self, p ):
        
        #print "SETTING NODE!!! %s" % t
        #print "FILEINDEX %s" % t.fileIndex
        #java.lang.Thread.dumpStack()
        v = p.v
        t = v.t
        #vid = v.vid
        
        if self.tnode:
            self.checksums[ self.tnode ] = md5.md5( self.tnode.bodyString ).hexdigest()
        
        #if self.undoers.containsKey( t ):
        if self.undoers.has_key( v ):
            #print "CONTAINTS %s" % t
            ua = self.undoers[ v ]
            print "--!!!!!!-- %s" % v
            print ua.__class__
            if ua.__class__ == leoSwingUndo.UndoBase:
                self.umanager = self.undoers[ v ]
                #if self.checksums.containsKey( v ):
                #    checksum = self.checksums[ v ]
                #    amd5 = md5.md5( t.bodyString )
                #    if amd5.hexdigest() != checksum:
                #        self.umanager.discardAllEdits()
                #        g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                #        #self.tnode = t
                #        #return
                #for z in self.umanager.undostack:
                #    commanders[ z ] = self.c
            else:
                print "UNPICKLING!!!!!"
                ua = cPickle.loads( ua )
                print "UNPICKLED Is now %s %s" % ( ua, len( ua.undostack ) )
                self.undoers[ v ] = ua
                self.umanager = ua
            if self.checksums.containsKey( t ):
                checksum = self.checksums[ t ]
                amd5 = md5.md5( t.bodyString )
                if amd5.hexdigest() != checksum:
                    self.umanager.discardAllEdits()
                    print "DISCARDED EDITSS!!!!"
                    g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                    #self.tnode = t
                    #return
            for z in self.umanager.undostack:
                commanders[ z ] = self.c
                                    
        else:
            print "V not in Undoers %s" % v
            #print v.vid
            self.umanager = leoSwingUndo.UndoBase()
            self.undoers[ v ] = self.umanager

        self.tnode = t
        self.setMenu()
        
    def __addUndo( self, undo ):
        #self.umanager.addEdit( undo )
        self.umanager.addUndo( undo )
        #upe = self.UndoableProxyEvent( undo, self.umanager, self, self.c )
        #self.c.undoer.addUndo( upe )
        #die_listeners[ undo ] = upe
        
        
    def addUndo( self, undo ):
        
        if not self.ignore:
            
            if self.compound:
                self.compound.addEdit( undo )
                return
            
            self.__addUndo( undo )                
    
        self.setMenu()
            
    def setMenu( self ):
        
        self.umenu.setText( self.umanager.getUndoPresentationName() )
        self.umenu.setEnabled( self.umanager.canUndo() )
        if self.umanager.canUndo():
            self.gtnu.setEnabled( 1 )
        else:
            self.gtnu.setEnabled( 0 )
        self.rmenu.setText( self.umanager.getRedoPresentationName() )    
        self.rmenu.setEnabled( self.umanager.canRedo() ) 
        if self.umanager.canRedo():
            self.gtnr.setEnabled( 1 )
        else:
            self.gtnr.setEnabled( 0 )
        
        self.c.undoer.setMenu()
               
    
    
    def getUStack( self, tnode ):
            
        if hasattr( tnode, 'unknownAttributes' ):
            uas = tnode.unknownAttributes
        else:
            tnode.unknownAttributes = uas = {}
        
        return uas
        

    def clearUndo( self ):
        
        self.umanager.discardAllEdits()
        self.setMenu()
        
    def gotoNextUndoSpot( self ):
        
        ua = self.umanager.editToBeUndone()
        if ua:
            spot = ua.spot
            self.c.frame.body._current_editor.setCaretPosition( spot )
            return
            
    def gotoNextRedoSpot( self ):
        ua = self.umanager.editToBeRedone()
        if ua:
            spot = ua.spot
            self.c.frame.body._current_editor.setCaretPosition( spot )
            return

    @others
    

                    
<<UndoableDocumentEvent>>
<<UndoableCompoundEvent>>




#@+node:ekr.20060201152349.1:<<imports>>
import java
import java.util as util
import javax.swing as swing
import javax.swing.undo as sundo
import javax.swing.event as sevent
import java.io as io
import jarray
import md5
import org.python.util as putil
import NodeUndoerBase
import LeoCompoundEdit
import leoGlobals as g
import zlib
import leoSwingUndo
import leoPlugins
import leoNodes
import base64
import pickle
import cPickle
from utilities.WeakMethod import WeakMethod
#@nonl
#@-node:ekr.20060201152349.1:<<imports>>
#@+node:ekr.20060201152349.2:visualiseUndoStack
def visualiseUndoStack( self ):
    
    umanager = self.umanager            
    table = swing.JTable( self.UneditableTableModel() )#( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    table.setSelectionMode( swing.ListSelectionModel.SINGLE_SELECTION )
    self.setDataForTable( table )

    
    jd = swing.JDialog()
    jd.setTitle( "Undo Stack" )
    cp = jd.getContentPane()
    cp.add( swing.JScrollPane( table ) )
    bholder = swing.JPanel()
    cp.add( bholder, java.awt.BorderLayout.SOUTH )
    uto = swing.JButton( "Undo To" )
    bholder.add( uto )
    <<_undoTo>>
    uto.actionPerformed = _undoTo
    
    rto = swing.JButton( "Redo To" )
    bholder.add( rto )
    <<_redoTo>>
    rto.actionPerformed = _redoTo
    
        
    jb = swing.JButton( "Close" )
    jb.actionPerformed = lambda event : jd.dispose()
    bholder.add( jb )
    jd.pack()
    g.app.gui.center_dialog( jd )
    jd.setModal( 1 )
    jd.show()
    
    
#@+node:ekr.20060201152349.3:<<_undoTo>>
def _undoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canUndo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Undo To This Point", 
                                            "Illegal Undo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
    self.ignore = 1
    umanager.undoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
#@-node:ekr.20060201152349.3:<<_undoTo>>
#@+node:ekr.20060201152349.4:<<_redoTo>>
def _redoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canRedo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Redo To This Point", 
                                            "Illegal Redo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
        
    self.ignore = 1
    umanager.redoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
    
#@-node:ekr.20060201152349.4:<<_redoTo>>
#@-node:ekr.20060201152349.2:visualiseUndoStack
#@+node:ekr.20060201152349.5:buildTableData
def buildTableData( self ):
    
    data = util.Vector()
    editu = self.umanager.editToBeUndone()
    editr = self.umanager.editToBeRedone()
    umanager = self.umanager
    cu = cr = -1
    edits = umanager.getEdits()
    for z in edits:
        if z.__class__ == LeoCompoundEdit:
            vec = java.util.Vector()
            edits2 = z.getEdits()
            spot = edits2[ 0 ].spot
            vec.add( spot )
            vec.add( "?" )
            vec.add( z.getPresentationName() )
            vec.add( "" )
        else:
            vec = z.getForTableModel()
            
        if z is editu:
            vec.set( 3, 'current undo' )
            cu = edits.indexOf( z )
        elif z.canUndo():
            vec.set( 3, 'undo' )
        if z is editr:
            vec.set( 3, 'current redo' )
            cr = edits.indexOf( z )
        elif z.canRedo():
            vec.set( 3, 'redo' )
        data.add( vec )
    
    return data, cu, cr


#@-node:ekr.20060201152349.5:buildTableData
#@+node:ekr.20060201152349.6:setDataForTable
def setDataForTable( self, table ):
    
    data, cu, cr = self.buildTableData()
    dm = table.getModel()
    dm.setDataVector( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    lsm = table.getSelectionModel()
    if cu != -1:
        lsm.setLeadSelectionIndex( cu )
    elif cr != -1:
        lsm.setLeadSelectionIndex( cr )
        
    
#@nonl
#@-node:ekr.20060201152349.6:setDataForTable
#@+node:ekr.20060201152349.7:pickle and unpickle
def serializeForLeoFile( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c:
        nwundoers = {}
        for z in self.undoers:
            if  self.undoers[ z ].__class__ == leoSwingUndo.UndoBase:
                nwundoers[ z.vid ] = cPickle.dumps( self.undoers[ z ] )
            else:
                nwundoers[ z.vid ] = self.undoers[ z ]
                
        store.addData( "tundoer", nwundoers ) #the storage class does the rest of the work for us
        

def unserializeFromLeoFile( self, tag, *args, **kwords ):

    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c and self.checksums_ok:
        try:
            udata = store.getData( "tundoer" )
            if udata:
                for z in udata:
                    if leoNodes.vid_vnode.has_key( z ):
                        #print "A connection %s %s" % ( z, leoNodes.vid_vnode[ z ] )
                        v = leoNodes.vid_vnode[ z ]
                        self.undoers[ v ] = udata[ z ]

        except:
            self.undostack = []
            self.undopointer = 0

    if not self.checksums_ok:
        self.checksums_ok = 1
        self.checksum_violations = []
        self.undostack = []
        self.undopointer = 0
        
#@-node:ekr.20060201152349.7:pickle and unpickle
#@+node:ekr.20060201152349.8:checkSumViolation
def checkSumViolation( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    filename = args[ 0 ][ 'filename' ]
    if c == self.c:
        self.checksums_ok = 0
        self.checksum_violations.append( filename )
#@nonl
#@-node:ekr.20060201152349.8:checkSumViolation
#@+node:ekr.20060201152349.9:startCompounding stopCompounding
def startCompounding( self, name ):
    self.compound = UndoableCompoundEvent( name )
    #self.compound = LeoCompoundEdit( name )
        
def stopCompounding( self ):
        
    compound = self.compound
    compound.end()
    self.compound = None
    #print "COMPOUND is %s" % compound
    self.__addUndo( compound )
    self.setMenu()
#@-node:ekr.20060201152349.9:startCompounding stopCompounding
#@+node:ekr.20060201152349.10:infrastructure
@others
#@nonl
#@+node:ekr.20060201152349.11:UneditableTableModel
class UneditableTableModel( swing.table.DefaultTableModel ):
    
    def __init__( self ):
        swing.table.DefaultTableModel.__init__( self )
        
    def isCellEditable( self, row, column ):
        return 0
        
#@-node:ekr.20060201152349.11:UneditableTableModel
#@+node:ekr.20060201152349.12:PickleProxy
class PickleProxy:
    '''This class exists to pickle the NodeUndoerBase instance into a form
       that can be safely stored in a Leo ua.'''
       
    def __init__( self, undoer, t ):
        self.undoer = undoer
        self.t = t
            
    def getPickleProxy( self ):
        
      
        try:
            #array = self.undoer.serializeSelf()
            data = pickle.dumps( self.undoer )
            ds = len( data )
            pp = zlib.compress( data, level = 9 )
            ps = len( pp )
            amd5 = md5.md5( self.t.bodyString )
            checksum = amd5.hexdigest()
            return pp, checksum 
        except Exception, x:
            return "", ""  
#@-node:ekr.20060201152349.12:PickleProxy
#@-node:ekr.20060201152349.10:infrastructure
#@+node:ekr.20060201152349.13:UndoableProxyEvent
class UndoableProxyEvent( sundo.UndoableEdit ):

       
    def __init__( self, event, owner, master , c):
        
        self.event = event
        self.owner = owner
        self.master = master
        self.c = c
        self.cp = c.currentPosition().copy()
        self._can_undo = event.canUndo()
        self._can_redo = event.canRedo()
        self.can_undo = self._can_undo
        self.can_redo = self._can_redo
        self.dieable = 0
        self.ignore = 0
        
    
    def __canRedo( self ):
        return self._can_redo == self.event.canRedo()
        
    def __canUndo( self ):
        return self._can_undo == self.event.canUndo()
            
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        #if self.__canUndo():
        return self.can_redo
        #else:
        #    return self.event.canRedo()
        
    def canUndo( self ):
        #if self.__canRedo():
        return self.can_undo
        #else:
        #    return self.event.canUndo()
        
    def isAlive( self ):
        return self.can_redo or self.can_undo
    
    def invalidate( self ):
        self.c.undoer.killFromEvent( self )
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
        #edits = self.owner.getEdits()
        #spot = edits.indexOf( self.event )
        #self.owner.trimEdits( spot, edits.size() )
    
        
    def getPresentationName( self ):
        return self.event.getPresentationName()
        
    def getRedoPresentationName( self ):
        
        if self.__canRedo():
            return self.event.getRedoPresentationName()
        elif self.isAlive():
            return "Expended %s" % self.event.getRedoPresentationName()
        else:
            return "Dead %s" % self.event.getRedoPresentationName()
        
    def getUndoPresentationName( self ):
        
        if self.__canUndo():
            return self.event.getUndoPresentationName()
        elif self.isAlive():
            return "Expended %s" % self.event.getUndoPresentationName()
        else:
            return "Dead %s" % self.event.getUndoPresentationName()
        
        
    def isSignificant( self ):
        return 1
    
    def sync( self ):
        self._can_redo = self.event.canRedo()
        self._can_undo = self.event.canUndo()
        
    def redo( self ):
        
        self.c.selectPosition( self.cp.copy() )
        self.can_redo = 0
        self.can_undo = 1
        if self.__canRedo():
            self.master.ignore = 1
            if not self.ignore:
                self.owner.redo()
            self.master.ignore = 0
            self.master.setMenu()
            
        self.sync()
            
        
    def undo( self ):
        
        self.c.selectPosition( self.cp.copy() )
        self.can_undo = 0
        self.can_redo = 1
        if self.__canUndo():
            self.master.ignore = 1
            if not self.ignore:
                self.owner.undo()
            self.master.ignore = 0
            self.master.setMenu()
            
        self.sync()
        
    def replaceEdit( self, edit ):
        return 0
        

#@-node:ekr.20060201152349.13:UndoableProxyEvent
#@+node:ekr.20060201152349.14:<<UndoableDocumentEvent>>
class UndoableDocumentEvent3:#( sundo.UndoableEdit, io.Serializable ):
    '''A class that takes the current Editors document and does undo changes
       upon the data within the Editor.  It is assumed that the data in the document
       will be in sync with the changes represented within the UndoableDocumentEvent'''
       
    def __init__( self, c, event, txt = "" ):
        
        commanders[ self ] = c
        self.spot = event.getOffset()
        self.length = event.getLength()
        self.txt = txt

        self.can_undo = 1
        self.can_redo = 0
        if self.txt.isspace():
           name_txt = "%s whitespaces" % len( self.txt )
        else:
           name_txt = self.txt
        
        if event.getType() == sevent.DocumentEvent.EventType.INSERT:
            self.etype = "insert"
        elif event.getType() == sevent.DocumentEvent.EventType.REMOVE:
            self.etype = "remove"

            
            
        if self.etype == "insert":
            self.name = "insert %s" % name_txt  
        elif self.etype == "remove":
            self.name = "remove %s" % name_txt
    
    #def __getstate__( self ):
    #    dic = self.__dict__
    #    import copy
    #    rv = copy.copy( dic )
    #    #del rv[ c ]
    #    return rv        
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
        #if die_listeners.has_key( self ):
        #    dlistener = die_listeners[ self ]
        #    if dlistener.dieable:
        #        print "WHACKING %s" % dlistener
        #        dlistener.invalidate()
    
        
    def getPresentationName( self ):
        return self.name 
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        
    def redo( self ):
        
        self.can_redo = 0
        self.can_undo = 1
        self.redoEvent()
        
    def undo( self ):
        
        self.can_undo = 0
        self.can_redo = 1
        self.undoEvent()
        
    def replaceEdit( self, edit ):
        return 0
        
    def redoEvent( self ):
        
        c = commanders.get( self )
        doc = c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            doc.insertString( self.spot, self.txt, None )
            return       
        elif self.etype == "remove":            
            doc.remove( self.spot, self.length )
            return    
        
    def undoEvent( self ):
        

        c = commanders.get( self )                
        doc = c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            print 'undoing spot %s %s %s' % ( self.spot, self.length, self.txt )
            doc.remove( self.spot, self.length )
            print 'undone %s' % self
            return  
        elif self.etype == "remove":
            doc.insertString( self.spot, self.txt, None )
            return 

    def getForTableModel( self ):
        return util.Vector( [ self.spot, self.txt, self.name, '' ] )
        


#@-node:ekr.20060201152349.14:<<UndoableDocumentEvent>>
#@+node:ekr.20060201152349.15:<<UndoableCompoundEvent>>
class UndoableCompoundEvent3:
    
    def __init__( self, pname ):
        #self.ce = sundo.CompoundEdit()
        self.pname = pname
        self.undostack = []
        self.can_undo = 1
        self.can_redo = 0
        
    def getPresentationName( self ):
        return self.pname
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.pname
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.pname
        
    def canUndo( self ):
        return self.can_undo
        #return self.ce.canUndo()
        
    def canRedo( self ):
        return self.can_redo
        #return self.ce.canRedo()
        
    def undo( self ):
        for z in self.undostack:
            print z
            z.undo()
        self.can_undo = 0
        self.can_redo = 1
        
    def redo( self ):
        
        self.undostack.reverse()
        for z in self.undostack:
            print z
            z.redo()
        
        self.undostack.reverse()
        self.can_undo = 1
        self.can_redo = 0
        
    def isSignificant( self ):
        return 1
        #return self.ce.isSignificant()
        
    def addEdit( self, edit ):
        self.undostack.insert( 0, edit )
        

    
    def die( self ):
        pass
        #return self.ce.die()
        
    def end( self ):
        pass
        #return self.ce.end()
        
        

            
        

#@-node:ekr.20060201152349.15:<<UndoableCompoundEvent>>
#@-node:ekr.20060201152349:NodeUndoer.py
#@-node:ekr.20060211100150:Fix chapters plugin
#@+node:ekr.20060220155313:Script: update-leo-settings-file
#@-node:ekr.20060220155313:Script: update-leo-settings-file
#@+node:ekr.20060122183544:Improve isearch
@nocolor

- Handle backspace for isearch: keep a stack of previous matches.
- Allow cross-node isearches.
#@-node:ekr.20060122183544:Improve isearch
#@+node:ekr.20060210140415:Most important new commands
#@+node:ekr.20060211093935:Support for @list and on-enter-mode
#@-node:ekr.20060211093935:Support for @list and on-enter-mode
#@+node:ekr.20060113090042:open-outline-by-name & filename completion
#@-node:ekr.20060113090042:open-outline-by-name & filename completion
#@+node:ekr.20060122194643:isearch-headline (forward & backward)
#@-node:ekr.20060122194643:isearch-headline (forward & backward)
#@+node:ekr.20060116085649:find-word-on-line, find-character-on-line (forward & backward)
#@-node:ekr.20060116085649:find-word-on-line, find-character-on-line (forward & backward)
#@+node:ekr.20060206103922:Minibuffer interface for GoToLine number
#@-node:ekr.20060206103922:Minibuffer interface for GoToLine number
#@+node:ekr.20060116074839.2:extend-to-word
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20060117115212:Rename buffer doesn't seem to work
#@-node:ekr.20060117115212:Rename buffer doesn't seem to work
#@+node:ekr.20060123091352:Incremental search in switch-to-buffer
#@-node:ekr.20060123091352:Incremental search in switch-to-buffer
#@+node:ekr.20060104083551:move-line-up/down (LeoUser)
http://sourceforge.net/forum/message.php?msg_id=3488030

move-region-up

Swap the selection with the line above it. If we are at the top of a node, the
node identified by threadBack() is selected and the text is moved to the bottom
of the node.

move-region-down

Swap the selection with the line below it. If we are at the bottom of the node,
the node identified by threadNext() is selected and the text is moved to the top
of the node.

In all cases the moved text remains selected, even when the text moves to another node.
#@nonl
#@-node:ekr.20060104083551:move-line-up/down (LeoUser)
#@+node:ekr.20060116084526.1:insert/remove spaces/tabs from lines (LeoUser)
http://sourceforge.net/forum/message.php?msg_id=3488030

add-space-to-lines      Adds a space is added to start of all selected lines.

add-tab-to-line         Adds 4 spaces to start of all selected lines.

remove-space-from lines Removes a space from start of all selected lines.

remove-tab-from lines   Removes a space from start of all selected lines.
#@nonl
#@-node:ekr.20060116084526.1:insert/remove spaces/tabs from lines (LeoUser)
#@+node:ekr.20060123095316:clear-selection
Useful, e.g., after a find.
#@nonl
#@-node:ekr.20060123095316:clear-selection
#@+node:ekr.20051202095626:help-for-command
Use docstrings as the help message.
#@nonl
#@-node:ekr.20051202095626:help-for-command
#@+node:ekr.20060116090428:Expand 'point' so it indicates node as well as text location
#@-node:ekr.20060116090428:Expand 'point' so it indicates node as well as text location
#@+node:ekr.20060214140221:update-settings-file command
#@-node:ekr.20060214140221:update-settings-file command
#@-node:ekr.20060210140415:Most important new commands
#@+node:ekr.20060213094300:Fix problems with open with
#@+node:ekr.20060213145539:The causes
@nocolor

1.  Both the vim and xemacs plugins require that open_with plugin be enabled.
    I changed the docstrings for each.

2.  The open_with plugin now explicitly calls g.enableIdleTimeHook.
    That is, the idle time hook is no longer enabled by default.
   
These were easy fixes to make.  A similar fix should be done for files opened from the Open With menu, but it's too late to do that for b2.
#@nonl
#@-node:ekr.20060213145539:The causes
#@+node:ekr.20060213144352:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3573148
By: yarkot

With the "latest" CVS snapshot. Do this:

[] Open LeoDocs.leo from the latest workspace;
[] Expand node "What's new in Leo 4.4" (I'll refer to this as the "parent");
[] Dbl-click parent (VIM opens text; text is single line: "@nocolor");
[] Add a second "@nocolor" line; write and save from VIM;
[] Leo view does not show line;
[] re-open w/ vim - vim shows new line;

[] Save;  add more text;  shows w/ vim, not in Leo; Apparently doesn't get save.
You can add a line in Leo, "This is a test", modify it in vim - "This was a
test", save vim, save Leo - close leo, re-open leo - the vim changes never got
saved.

Ok  - that's one.

Here's the second (same file, node, fresh session):

[] Open parent w/ vim (dbl-clk); opens ok;
[] open child "New commands not in legacy Leo" w/ vim; opens ok.
[] FAILS:  try to open first child: "Minibuffer-oriented find commands" - vim
doesn't open, status line flashes node name (once for each click it looks like),
and console window shows this:

open_in_vim: {'p': <pos 20987888 lvl: 1 [0] New commands not in legacy Leo>,
'c'
: Commander 25144936: u'C:\\Workspace\\Leo\\leo\\doc\\LeoDocs.leo', 'event':
<Tk
inter.Event instance at 0x0132BE90>, 'v': <pos 20987888 lvl: 1 [0] New commands
not in legacy Leo>}
#@nonl
#@-node:ekr.20060213144352:Report
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@nonl
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False
#@nonl
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args & keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@nonl
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@nonl
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@nonl
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@nonl
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@nonl
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@nonl
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@nonl
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@nonl
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@-node:ekr.20060213094300:Fix problems with open with
#@+node:ekr.20060211184834:Review all commands in leoEditCommands.py
Any command that alters text should call begin/endCommand.
#@nonl
#@+node:ekr.20060122185244.2:Fix unindent command
# unindent-region should work in all panes.
#@nonl
#@-node:ekr.20060122185244.2:Fix unindent command
#@-node:ekr.20060211184834:Review all commands in leoEditCommands.py
#@+node:ekr.20060116173818:*** Fix vampire nodes
#@-node:ekr.20060116173818:*** Fix vampire nodes
#@+node:ekr.20060227124057:Lua
#@+node:ekr.20060227120635:Lua patch
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3572598
By: davidmcnab

I have added support to Leo for the Lua programming language (www.lua.org).

A patch, against Leo 4.4 beta 1, build  1.375, is up at:
http://www.freenet.org.nz/misc/leo-with-lua.patch.gz

Patch should be executed with '-p1' inside the leo 'src' directory.

Summary: support for importing Lua files; support for Lua comments and keywords;
no auto-detect of Lua function definitions or classes (because Lua function/class
idioms vary); no support for Lua v5+ metamethods.

Implementation method - I loaded LeoPy.leo, searched the whole outline for 'java',
and added lua counterparts throughout, including a Lua comment scanner.
#@nonl
#@-node:ekr.20060227120635:Lua patch
#@-node:ekr.20060227124057:Lua
#@-node:ekr.20060226131603:To do 4.4b3
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
