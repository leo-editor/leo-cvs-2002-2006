#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@@nocolor

#@+all
#@+node:ekr.20041022091645.6:Today
#@+node:ekr.20041018194900:(Support drawing hooks)
if not g.doHook("xxx",c==c,p==p,v==v,event=event):
                
"boxclick1"    yes      before click in +- box            c,v,event
"boxclick2"             after  click in +- box            c,v,event

"drag1"        yes      before start of drag              c,v,event
"drag2"                 after  start of drag              c,v,event
"dragging1"    yes      before continuing to drag         c,v,event
"dragging2"             after  continuing to drag         c,v,event

"enddrag1"     yes      before end of drag                c,v,event
"enddrag2"              after  end of drag                c,v,event

"iconclick1"   yes      before single click in icon box   c,v,event
"iconclick2"            after  single click in icon box   c,v,event
"iconrclick1"  yes      before right click in icon box    c,v,event
"iconrclick2"           after  right click in icon box    c,v,event
"icondclick1"  yes      before double click in icon box   c,v,event
"icondclick2"           after  double click in icon box   c,v,event
#@nonl
#@+node:ekr.20041018200949:From OLD code
#@+node:ekr.20041018200728.8:tree.injectCallbacks (class method)
def injectCallbacks(self):
	
	import leoNodes
	
	<< define tkinter callbacks to be injected in the vnode class >>

	for f in (
		OnBoxClick,OnDrag,OnEndDrag,
		OnHeadlineClick,OnHeadlineRightClick,OnHeadlineKey,
		OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave,
		OnIconClick,OnIconDoubleClick,OnIconRightClick):

		# trace(f)
		funcToMethod(f,leoNodes.vnode)
#@nonl
#@+node:ekr.20041018200728.9:<< define tkinter callbacks to be injected in the vnode class >>
# N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
#@nonl
#@+node:ekr.20041018200728.10:OnBoxClick
# Called when the box is clicked.

def OnBoxClick(self,event=None):
	
	"""Callback injected into vnode class."""

	# trace()
	try:
		v = self ; c = v.c
		if not doHook("boxclick1",c=c,v=v,event=event):
			c.frame.tree.OnBoxClick(v)
		doHook("boxclick2",c=c,v=v,event=event)
	except:
		es_event_exception("boxclick")
#@nonl
#@-node:ekr.20041018200728.10:OnBoxClick
#@+node:ekr.20041018200728.11:OnDrag
def OnDrag(self,event=None):
	
	"""Callback injected into vnode class."""

	# trace()
	try:
		v = self ; c = v.c
		if c.frame.tree.dragging():
			if not doHook("dragging1",c=c,v=v,event=event):
				c.frame.tree.OnDrag(v,event)
			doHook("dragging2",c=c,v=v,event=event)
		else:
			if not doHook("drag1",c=c,v=v,event=event):
				c.frame.tree.OnDrag(v,event)
			doHook("drag2",c=c,v=v,event=event)
	except:
		es_event_exception("drag")
#@nonl
#@-node:ekr.20041018200728.11:OnDrag
#@+node:ekr.20041018200728.12:OnEndDrag
def OnEndDrag(self,event=None):
	
	"""Callback injected into vnode class."""
	
	# trace()

	try:
		v = self ; c = v.c
		# 7/10/03: Always call frame.OnEndDrag, regardless of state.
		if not doHook("enddrag1",c=c,v=v,event=event):
			c.frame.tree.OnEndDrag(v,event)
		doHook("enddrag2",c=c,v=v,event=event)
	except:
		es_event_exception("enddrag")
#@nonl
#@-node:ekr.20041018200728.12:OnEndDrag
#@+node:ekr.20041018200728.13:OnHeadlineClick & OnHeadlineRightClick
def OnHeadlineClick(self,event=None):
	"""Callback injected into vnode class."""
	#trace()
	try:
		v = self ; c = v.c
		if not doHook("headclick1",c=c,v=v,event=event):
			c.frame.tree.OnActivate(v)
		doHook("headclick2",c=c,v=v,event=event)
	except:
		es_event_exception("headclick")
	
def OnHeadlineRightClick(self,event=None):
	"""Callback injected into vnode class."""
	#trace()
	try:
		v = self ; c = v.c
		if not doHook("headrclick1",c=c,v=v,event=event):
			c.frame.tree.OnActivate(v)
			c.frame.tree.OnPopup(self,event)
		doHook("headrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("headrclick")
#@nonl
#@-node:ekr.20041018200728.13:OnHeadlineClick & OnHeadlineRightClick
#@+node:ekr.20041018200728.14:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event):
	
	"""Callback injected into vnode class."""

	# trace()
	try:
		v = self ; c = v.c
		if not doHook("hypercclick1",c=c,v=v,event=event):
			c.beginUpdate()
			c.selectVnode(v)
			c.endUpdate()
			c.frame.bodyCtrl.mark_set("insert","1.0")
		doHook("hypercclick2",c=c,v=v,event=event)
	except:
		es_event_exception("hypercclick")
#@nonl
#@-node:ekr.20041018200728.14:OnHyperLinkControlClick
#@+node:ekr.20041018200728.15:OnHeadlineKey
def OnHeadlineKey (self,event=None):

	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.c
		if not doHook("headkey1",c=c,v=v,event=event):
			c.frame.tree.OnHeadlineKey(v,event)
		doHook("headkey2",c=c,v=v,event=event)
	except:
		es_event_exception("headkey")
#@nonl
#@-node:ekr.20041018200728.15:OnHeadlineKey
#@+node:ekr.20041018200728.16:OnHyperLinkEnter
def OnHyperLinkEnter (self,event=None):
	
	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.c
		if not doHook("hyperenter1",c=c,v=v,event=event):
			if 0: # This works, and isn't very useful.
				c.frame.bodyCtrl.tag_config(v.tagName,background="green")
		doHook("hyperenter2",c=c,v=v,event=event)
	except:
		es_event_exception("hyperenter")
#@nonl
#@-node:ekr.20041018200728.16:OnHyperLinkEnter
#@+node:ekr.20041018200728.17:OnHyperLinkLeave
def OnHyperLinkLeave (self,event=None):
	
	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.c
		if not doHook("hyperleave1",c=c,v=v,event=event):
			if 0: # This works, and isn't very useful.
				c.frame.bodyCtrl.tag_config(v.tagName,background="white")
		doHook("hyperleave2",c=c,v=v,event=event)
	except:
		es_event_exception("hyperleave")
#@nonl
#@-node:ekr.20041018200728.17:OnHyperLinkLeave
#@+node:ekr.20041018200728.18:OnIconClick & OnIconRightClick
def OnIconClick(self,event=None):
	
	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.c
		if not doHook("iconclick1",c=c,v=v,event=event):
			c.frame.tree.OnIconClick(v,event)
		doHook("iconclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconclick")
	
def OnIconRightClick(self,event=None):
	
	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.c
		if not doHook("iconrclick1",c=c,v=v,event=event):
			c.frame.tree.OnIconRightClick(v,event)
		doHook("iconrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconrclick")
#@-node:ekr.20041018200728.18:OnIconClick & OnIconRightClick
#@+node:ekr.20041018200728.19:OnIconDoubleClick
def OnIconDoubleClick(self,event=None):
	
	"""Callback injected into vnode class."""

	try:
		v = self ; c = v.c
		if not doHook("icondclick1",c=c,v=v,event=event):
			c.frame.tree.OnIconDoubleClick(self)
		doHook("icondclick2",c=c,v=v,event=event)
	except:
		es_event_exception("icondclick")
#@-node:ekr.20041018200728.19:OnIconDoubleClick
#@-node:ekr.20041018200728.9:<< define tkinter callbacks to be injected in the vnode class >>
#@-node:ekr.20041018200728.8:tree.injectCallbacks (class method)
#@+node:ekr.20041018200728.25:idle_redraw
def idle_redraw (self):
	
	self.redrawScheduled = false # 7/10/03: Always do this here.
	
	if 0: # This can be called as the result of update_idletasks, so the count need not be 0.
		trace(self.updateCount)

	frame = self.c.frame
	if frame not in app.windowList or app.quitting:
		# trace("no frame")
		return
		
	if self.drag_v:
		# trace("dragging",self.drag_v)
		return

	# trace(frame)
	# print_bindings("canvas",self.canvas)

	self.expandAllAncestors(self.currentVnode())
	oldcursor = self.canvas['cursor']
	self.canvas['cursor'] = "watch"
	self.allocatedNodes = 0
	if not doHook("redraw-entire-outline",c=self.c):
		# Erase and redraw the entire tree.
		self.setTopVnode(None)
		self.deleteBindings()
		self.canvas.delete("all")
		self.deleteWidgets()
		self.setVisibleAreaToFullCanvas()
		self.drawTopTree()
		# Set up the scroll region after the tree has been redrawn.
		x0, y0, x1, y1 = self.canvas.bbox("all")
		self.canvas.configure(scrollregion=(0, 0, x1, y1))
		# Do a scrolling operation after the scrollbar is redrawn
		# printGc()
		self.canvas.after_idle(self.idle_scrollTo)
		if self.trace:
			self.redrawCount += 1
			print "idle_redraw allocated:",self.redrawCount, self.allocatedNodes
		doHook("after_redraw-outline",c=self.c)

	self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20041018200728.25:idle_redraw
#@+node:ekr.20041018200728.29:drawBox (tag_bind)
def drawBox (self,v,x,y):
	
	y += 7 # draw the box at x, y+7

	tree = self
	iconname = choose(v.isExpanded(),"minusnode.gif", "plusnode.gif")
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y,image=image)
	
	if 1: # use vnode callbacks
		id1 = self.canvas.tag_bind(id, "<1>", v.OnBoxClick)
	else:
		<< define onBoxClickCallback >>
		id1 = self.canvas.tag_bind(id, "<1>", onBoxClickCallback)
	id2 = self.canvas.tag_bind(id, "<Double-1>", lambda x: None)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
#@nonl
#@+node:ekr.20041018200728.30:<< define onBoxClickCallback >>
def onBoxClickCallback(event,tree=tree,v=v):
	try:
		c = v.c
		if not doHook("boxclick1",c=c,v=v,event=event):
			tree.OnBoxClick(v)
		doHook("boxclick2",c=c,v=v,event=event)
	except:
		es_event_exception("boxclick")
#@nonl
#@-node:ekr.20041018200728.30:<< define onBoxClickCallback >>
#@-node:ekr.20041018200728.29:drawBox (tag_bind)
#@+node:ekr.20041018200728.31:drawIcon (tag_bind)
def drawIcon(self,v,x=None,y=None):
	
	"""Draws icon for v at x,y, or at v.iconx,v.icony if x,y = None,None"""

	tree = self
	
	if x is None and y is None:
		try:
			x,y = v.iconx, v.icony
		except:
			# Inject the ivars.
			x,y = v.iconx, v.icony = 0,0
	else:
		# Inject the ivars.
		v.iconx, v.icony = x,y

	y += 2 # draw icon at y + 2

	# Always recompute icon.
	val = v.iconVal = v.computeIcon()
	assert(0 <= val <= 15)
	
	# Compute the image name
	imagename = "box"
	if val < 10: imagename += "0"
	imagename += `val`

	# Get the image
	image = self.getIconImage(imagename + ".GIF")
	id = self.canvas.create_image(x,y,anchor="nw",image=image)
	self.icon_id_dict[id] = v # Remember which vnode belongs to the icon.
	
	if 1: # use vnode callbacks.
		id1 = self.canvas.tag_bind(id,"<1>",v.OnIconClick)
		id2 = self.canvas.tag_bind(id,"<Double-1>",v.OnIconDoubleClick)
		id3 = self.canvas.tag_bind(id,"<3>",v.OnIconRightClick)
	else:
		<< define icon click callbacks >>
		id1 = self.canvas.tag_bind(id,"<1>",onIconClickCallback)
		id2 = self.canvas.tag_bind(id,"<Double-1>",onIconDoubleClickCallback)
		id3 = self.canvas.tag_bind(id,"<3>",onIconRightClickCallback)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
	self.tagBindings.append((id,id3,"<3>"),)

	return 0 # dummy icon height
#@nonl
#@+node:ekr.20041018200728.32:<< define icon click callbacks >>
def onIconClickCallback(event,tree=tree,v=v):
	try:
		c = v.c
		if not doHook("iconclick1",c=c,v=v,event=event):
			tree.OnIconClick(v,event)
		doHook("iconclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconclick")
		
def onIconDoubleClickCallback(event,tree=tree,v=v):
	try:
		c = v.c
		if not doHook("icondclick1",c=c,v=v,event=event):
			tree.OnIconDoubleClick(self)
		doHook("icondclick2",c=c,v=v,event=event)
	except:
		es_event_exception("icondclick")
	
def onIconRightClickCallback(event,tree=tree,v=v):
	try:
		c = v.c
		if not doHook("iconrclick1",c=c,v=v,event=event):
			tree.OnIconRightClick(v,event)
		doHook("iconrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconrclick")
#@-node:ekr.20041018200728.32:<< define icon click callbacks >>
#@-node:ekr.20041018200728.31:drawIcon (tag_bind)
#@+node:ekr.20041018200728.34:drawText (bind)
# draws text for v at x,y

def drawText(self,v,x,y):
	
	tree = self
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)
	self.edit_text_dict[v] = t # Remember which text widget belongs to v.
	
	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	<< configure the text depending on state >>

	if 1: # Use vnode callbacks.
		id1 = t.bind("<1>",v.OnHeadlineClick)
		id2 = t.bind("<3>",v.OnHeadlineRightClick)
	else:
		<< define the headline click callbacks >>
		id1 = t.bind("<1>",onHeadlineClickCallback)
		id2 = t.bind("<3>",onHeadlineRightClickCallback)
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("<Double-1>", v.OnBoxClick)
	id3 = t.bind("<Key>", v.OnHeadlineKey)
	id4 = t.bind("<Control-t>",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"<1>"),)
	self.bindings.append((t,id2,"<3>"),)
	self.bindings.append((t,id3,"<Key>"),)
	self.bindings.append((t,id4,"<Control-t>"),)

	id = self.canvas.create_window(x,y,anchor="nw",window=t)
	self.canvas.tag_lower(id)

	return self.line_height
#@nonl
#@+node:ekr.20041018200728.35:<< configure the text depending on state >>
if v == self.currentVnode():
	if v == self.editVnode():
		self.setNormalLabelState(v)
	else:
		self.setDisabledLabelState(v) # selected, disabled
else:
	self.setUnselectedLabelState(v) # unselected
#@nonl
#@-node:ekr.20041018200728.35:<< configure the text depending on state >>
#@+node:ekr.20041018200728.36:<< define the headline click callbacks >>
def onHeadlineClickCallback(event,tree=tree,v=v):
	try:
		c = v.c
		if not doHook("headclick1",c=c,v=v,event=event):
			tree.OnActivate(v)
		doHook("headclick2",c=c,v=v,event=event)
	except:
		es_event_exception("headclick")
	
def onHeadlineRightClickCallback(event,tree=tree,v=v):
	try:
		c = v.c
		if not doHook("headrclick1",c=c,v=v,event=event):
			tree.OnActivate(v)
			tree.OnPopup(v,event)
		doHook("headrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("headrclick")
#@nonl
#@-node:ekr.20041018200728.36:<< define the headline click callbacks >>
#@-node:ekr.20041018200728.34:drawText (bind)
#@+node:ekr.20041018200728.67:idle_head_key
def idle_head_key (self,v,ch=None):
	
	"""Update headline text at idle time."""

	c = self.c
	if not v or not v.edit_text() or v != c.currentVnode():
		return "break"
	if doHook("headkey1",c=c,v=v,ch=ch):
		return "break" # The hook claims to have handled the event.

	<< set s to the widget text >>
	<< set head to vnode text >>
	changed = s != head
	done = ch and (ch == '\r' or ch == '\n')
	if not changed and not done:
		return "break"
	if changed:
		c.undoer.setUndoParams("Change Headline",v,newText=s,oldText=head)
	index = v.edit_text().index("insert")
	if changed:
		<< update v and all nodes joined to v >>
	<< reconfigure v and all nodes joined to v >>
	<< update the screen >>

	doHook("headkey2",c=c,v=v,ch=ch)
	return "break"
#@nonl
#@+node:ekr.20041018200728.68:<< set s to the widget text >>
s = v.edit_text().get("1.0","end")
s = toUnicode(s,app.tkEncoding) # 2/25/03

if not s:
	s = u""
s = s.replace('\n','')
s = s.replace('\r','')
# trace(`s`)
#@-node:ekr.20041018200728.68:<< set s to the widget text >>
#@+node:ekr.20041018200728.69:<< set head to vnode text >>
head = v.headString()
if head == None:
	head = u""
head = toUnicode(head,"utf-8")
#@-node:ekr.20041018200728.69:<< set head to vnode text >>
#@+node:ekr.20041018200728.70:<< update v and all nodes joined to v >>
c.beginUpdate()

# Update changed bit.
if not c.changed:
	c.setChanged(true)

# Update all dirty bits.
v.setDirty()

# Update v.
v.initHeadString(s)
v.edit_text().delete("1.0","end")
v.edit_text().insert("end",s)
v.edit_text().mark_set("insert",index)

# Update all joined nodes.
for v2 in v.t.joinList:
	if v2 != v:
		v2.initHeadString(s)
		if v2.edit_text(): # v2 may not be visible
			v2.edit_text().delete("1.0","end")
			v2.edit_text().insert("end",s)

c.endUpdate(false) # do not redraw now.
#@nonl
#@-node:ekr.20041018200728.70:<< update v and all nodes joined to v >>
#@+node:ekr.20041018200728.71:<< reconfigure v and all nodes joined to v >>
# Reconfigure v's headline.
if done:
	self.setDisabledLabelState(v)

v.edit_text().configure(width=self.headWidth(v))

# Reconfigure all joined headlines.
for v2 in v.t.joinList:
	if v2 != v:
		if v2.edit_text(): # v2 may not be visible
			v2.edit_text().configure(width=self.headWidth(v2))
#@nonl
#@-node:ekr.20041018200728.71:<< reconfigure v and all nodes joined to v >>
#@+node:ekr.20041018200728.72:<< update the screen >>
if done:
	c.beginUpdate()
	self.endEditLabel()
	c.endUpdate()

elif changed:
	# update v immediately.  Joined nodes are redrawn later by endEditLabel.
	# Redrawing the whole screen now messes up the cursor in the headline.
	self.drawIcon(v) # just redraw the icon.
#@nonl
#@-node:ekr.20041018200728.72:<< update the screen >>
#@-node:ekr.20041018200728.67:idle_head_key
#@+node:ekr.20041018200728.73:tree.OnIconClick & OnIconRightClick
def OnIconClick (self,v,event):

	tree = self ; canvas = tree.canvas
	if event:
		canvas_x = canvas.canvasx(event.x)
		canvas_y = canvas.canvasy(event.y)
		id = canvas.find_closest(canvas_x,canvas_y)
		if id != None:
			try: id = id[0]
			except: pass
			self.drag_v = v
			self.drag_id = id
			if 1: # Use vnode callbacks.
				id4 = canvas.tag_bind(id,"<B1-Motion>", v.OnDrag)
				id5 = canvas.tag_bind(id,"<Any-ButtonRelease-1>", v.OnEndDrag)
			else:
				<< define drag callbacks >>
				id4 = canvas.tag_bind(id,"<B1-Motion>", onDragCallback)
				id5 = canvas.tag_bind(id,"<Any-ButtonRelease-1>", onEndDragCallback)
			# Remember the bindings so deleteBindings can delete them.
			self.tagBindings.append((id,id4,"<B1-Motion>"),)
			self.tagBindings.append((id,id5,"<Any-ButtonRelease-1>"),)
	tree.select(v)
	
def OnIconRightClick (self,v,event):

	self.select(v)
#@nonl
#@+node:ekr.20041018200728.74:<< define drag callbacks >>
def onDragCallback(event,tree=tree,v=v):
	try:
		c = v.c
		if tree.dragging():
			if not doHook("dragging1",c=c,v=v,event=event):
				tree.OnDrag(v,event)
			doHook("dragging2",c=c,v=v,event=event)
		else:
			if not doHook("drag1",c=c,v=v,event=event):
				tree.OnDrag(v,event)
			doHook("drag2",c=c,v=v,event=event)
	except:
		es_event_exception("drag")
		
def onEndDragCallback(event,tree=tree,v=v):
	try:
		c = v.c
		if not doHook("enddrag1",c=c,v=v,event=event):
			tree.OnEndDrag(v,event)
		doHook("enddrag2",c=c,v=v,event=event)
	except:
		es_event_exception("enddrag")
		
		
#@-node:ekr.20041018200728.74:<< define drag callbacks >>
#@-node:ekr.20041018200728.73:tree.OnIconClick & OnIconRightClick
#@+node:ekr.20041018200728.75:tree.OnPopup & allies
def OnPopup (self,v,event):
	
	"""Handle right-clicks in the outline."""
	
	# Note: "headrclick" hooks handled by vnode callback routine.

	if event != None:
		c = self.c
		if not doHook("create-popup-menu",c=c,v=v,event=event):
			self.createPopupMenu(event)
		if not doHook("enable-popup-menu-items",c=c,v=v,event=event):
			self.enablePopupMenuItems(v,event)
		if not doHook("show-popup-menu",c=c,v=v,event=event):
			self.showPopupMenu(event)

	return "break"
#@nonl
#@+node:ekr.20041018200728.76:OnPopupFocusLost
@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the <FocusOut> event and explicitly unpost.  In order to process the <FocusOut> event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

	self.popupMenu.unpost()
	
#@-node:ekr.20041018200728.76:OnPopupFocusLost
#@+node:ekr.20041018200728.77:createPopupMenu
def createPopupMenu (self,event):
	
	c = self.c ; frame = c.frame
	
	# If we are going to recreate it, we had better destroy it.
	if self.popupMenu:
		self.popupMenu.destroy()
		self.popupMenu = None
	
	self.popupMenu = menu = Tkinter.Menu(app.root, tearoff=0)
	
	# Add the Open With entries if they exist.
	if app.openWithTable:
		frame.menu.createMenuEntries(menu,app.openWithTable,openWith=1)
		table = (("-",None,None),)
		frame.menu.createMenuEntries(menu,table)
		
	<< Create the menu table >>
	
	# 11/27/03: Don't actually set binding: it would conflict with previous.
	frame.menu.createMenuEntries(menu,table,dontBind=true)
#@nonl
#@+node:ekr.20041018200728.78:<< Create the menu table >>
table = (
	("&Read @file Nodes",None,c.readAtFileNodes),
	("&Write @file Nodes",None,c.fileCommands.writeAtFileNodes),
	("-",None,None),
	("&Tangle","Shift+Ctrl+T",c.tangle),
	("&Untangle","Shift+Ctrl+U",c.untangle),
	("-",None,None),
	# 2/16/04: Remove shortcut for Toggle Angle Brackets command.
	("Toggle Angle &Brackets",None,c.toggleAngleBrackets),
	("-",None,None),
	("Cut Node","Shift+Ctrl+X",c.cutOutline),
	("Copy Node","Shift+Ctrl+C",c.copyOutline),
	("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
	("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
	("-",None,None),
	("&Insert Node","Ctrl+I",c.insertHeadline),
	("&Clone Node","Ctrl+`",c.clone),
	("Sort C&hildren",None,c.sortChildren),
	("&Sort Siblings","Alt-A",c.sortSiblings),
	("-",None,None),
	("Contract Parent","Alt+0",c.contractParent))
#@nonl
#@-node:ekr.20041018200728.78:<< Create the menu table >>
#@-node:ekr.20041018200728.77:createPopupMenu
#@+node:ekr.20041018200728.79:enablePopupMenuItems
def enablePopupMenuItems (self,v,event):
	
	"""Enable and disable items in the popup menu."""
	
	c = self.c ; menu = self.popupMenu

	<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
	isAtFile = choose(isAtFile,1,0)
	isAtRoot = choose(isAtRoot,1,0)
	canContract = v.parent() != None
	canContract = choose(canContract,1,0)
	
	enable = self.frame.menu.enableMenu
	
	for name in ("Read @file Nodes", "Write @file Nodes"):
		enable(menu,name,isAtFile)
	for name in ("Tangle", "Untangle"):
		enable(menu,name,isAtRoot)

	enable(menu,"Cut Node",c.canCutOutline())
	enable(menu,"Delete Node",c.canDeleteHeadline())
	enable(menu,"Paste Node",c.canPasteOutline())
	enable(menu,"Sort Children",c.canSortChildren())
	enable(menu,"Sort Siblings",c.canSortSiblings())
	enable(menu,"Contract Parent",c.canContractParent())
#@nonl
#@+node:ekr.20041018200728.80:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
isAtFile = false ; isAtRoot = false
v2 = v ; next = v.nodeAfterTree()

while (not isAtFile or not isAtRoot) and v2 != None and v2 != next:
	if (
		v2.isAtFileNode() or
		v.isAtRawFileNode() or
		v.isAtSilentFileNode() or
		v.isAtNoSentinelsFileNode()):
		isAtFile = true

	isRoot, junk = is_special(v2.bodyString(),0,"@root")
	if isRoot:
		isAtRoot = true
	v2 = v2.threadNext()
#@nonl
#@-node:ekr.20041018200728.80:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
#@-node:ekr.20041018200728.79:enablePopupMenuItems
#@+node:ekr.20041018200728.81:showPopupMenu
def showPopupMenu (self,event):
	
	"""Show a popup menu."""
	
	c = self.c ; menu = self.popupMenu ; gui = app.gui

	if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
		menu.bind("<FocusOut>",self.OnPopupFocusLost)
	
	menu.post(event.x_root, event.y_root)

	# Make certain we have focus so we know when we lose it.
	# I think this is OK for all OSes.
	gui.set_focus(c,menu)
#@nonl
#@-node:ekr.20041018200728.81:showPopupMenu
#@-node:ekr.20041018200728.75:tree.OnPopup & allies
#@+node:ekr.20041018200728.94:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,v,updateBeadList=true):

	<< define vars and stop editing >>

	if not doHook("unselect1",c=c,new_v=v,old_v=old_v):
		<< unselect the old node >>
	else: old_body = u""

	doHook("unselect2",c=c,new_v=v,old_v=old_v)
	
	if not doHook("select1",c=c,new_v=v,old_v=old_v):
		<< select the new node >>
		if v and v != old_v: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(v)
			except: pass
		<< update c.beadList or c.beadPointer >>
		<< update c.visitedList >>

	<< set the current node and redraw >>
	doHook("select2",c=c,new_v=v,old_v=old_v)
	doHook("select3",c=c,new_v=v,old_v=old_v)
#@+node:ekr.20041018200728.95:<< define vars and stop editing >>
c = self.c ; frame = c.frame ; body = frame.bodyCtrl
old_v = c.currentVnode()

# Unselect any previous selected but unedited label.
self.endEditLabel()
old = self.currentVnode()
self.setUnselectedLabelState(old)
#@nonl
#@-node:ekr.20041018200728.95:<< define vars and stop editing >>
#@+node:ekr.20041018200728.96:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

# Remember the old body text
old_body = body.get("1.0","end")

if old and old != v and old.edit_text():
	old.t.scrollBarSpot = yview
	old.t.insertSpot = insertSpot
#@-node:ekr.20041018200728.96:<< unselect the old node >>
#@+node:ekr.20041018200728.97:<< select the new node >>
frame.setWrap(v)

# Delete only if necessary: this may reduce flicker slightly.
s = v.t.bodyString
s = toUnicode(s,"utf-8")
old_body = toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(v)

if v and v.t.scrollBarSpot != None:
	first,last = v.t.scrollBarSpot
	body.yview("moveto",first)

if v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.frame.bodyCtrl.mark_set("insert",v.t.insertSpot)
	c.frame.bodyCtrl.see(v.t.insertSpot)
else:
	c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20041018200728.97:<< select the new node >>
#@+node:ekr.20041018200728.98:<< update c.beadList or c.beadPointer >>
if updateBeadList:
	
	if c.beadPointer > -1:
		present_v = c.beadList[c.beadPointer]
	else:
		present_v = None
	
	if v != present_v:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(v)
		
	# trace(c.beadPointer,v,present_v)

#@-node:ekr.20041018200728.98:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20041018200728.99:<< update c.visitedList >>
# Make v the most recently visited node on the list.
if v in c.visitedList:
	c.visitedList.remove(v)
	
c.visitedList.insert(0,v)
#@nonl
#@-node:ekr.20041018200728.99:<< update c.visitedList >>
#@+node:ekr.20041018200728.100:<< set the current node and redraw >>
self.setCurrentVnode(v)
self.setSelectedLabelState(v)
self.frame.scanForTabWidth(v) # 9/13/02 #GS I believe this should also get into the select1 hook
app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20041018200728.100:<< set the current node and redraw >>
#@-node:ekr.20041018200728.94:tree.select
#@-node:ekr.20041018200949:From OLD code
#@-node:ekr.20041018194900:(Support drawing hooks)
#@+node:ekr.20041022080257:Mac Bugs 3
#@+node:ekr.20041022081937:Get cvs working again on mac
Just remove the cvs key files?
#@nonl
#@-node:ekr.20041022081937:Get cvs working again on mac
#@+node:ekr.20041007052853:(Fix problems with paste on Linux)
@color
#@nonl
#@+node:ekr.20041007052853.1:@url http://www.freedesktop.org/standards/clipboards-spec/clipboards.txt
#@-node:ekr.20041007052853.1:@url http://www.freedesktop.org/standards/clipboards-spec/clipboards.txt
#@+node:ekr.20031218072017.844:Clipboard (tkGui) NOT USED AT PRESENT
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui) NOT USED AT PRESENT
#@+node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
def OnCut (self,event=None):
    
    """The handler for the virtual Cut event."""

    frame = self ; c = frame.c ; v = c.currentVnode()
    
    if 0: # g.app.gui.win32clipboard is always None.
        if g.app.gui.win32clipboard:
            data = frame.body.getSelectedText()
            if data:
                g.app.gui.replaceClipboardWith(data)

    # Activate the body key handler by hand.
    frame.body.forceFullRecolor()
    frame.body.onBodyWillChange(v,"Cut")

def OnCutFromMenu (self):
    
    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Cut"))
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)



#@-node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
#@+node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
def OnCopy (self,event=None):
    
    frame = self

    if 0: # g.app.gui.win32clipboard is always None.
        if g.app.gui.win32clipboard:
            data = frame.body.getSelectedText()
            if data:
                g.app.gui.replaceClipboardWith(data)
        
    # Copy never changes dirty bits or syntax coloring.
    
def OnCopyFromMenu (self):

    frame = self
    w = frame.getFocus()
    w.event_generate(g.virtual_event_name("Copy"))
#@-node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
#@+node:ekr.20031218072017.843:frame.OnPaste & OnPasteFromMenu
def OnPaste (self,event=None):
    
    frame = self ; c = frame.c ; v = c.currentVnode()
    
    if 0: # sys.platform=="linux2": # ??? workaround paste problems on Linux.
        bodyCtrl = frame.body.bodyCtrl
        s = bodyCtrl.selection_get( selection='CLIPBOARD' )
        bodyCtrl.insert('insert', s)
        bodyCtrl.event_generate('<Key>')
        bodyCtrl.update_idletasks()
    else:
        # Activate the body key handler by hand.
        frame.body.forceFullRecolor()
        frame.body.onBodyWillChange(v,"Paste")
    
def OnPasteFromMenu (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Paste"))
    
    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)
#@nonl
#@-node:ekr.20031218072017.843:frame.OnPaste & OnPasteFromMenu
#@-node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,frame):
    
    t = self.bodyCtrl
    
    # Event handlers...
    t.bind("<Button-1>", frame.OnBodyClick)
    if sys.platform == "win32":
        # Support Linux middle-button paste easter egg.
        t.bind("<Button-2>", frame.OnPaste)
    t.bind("<Button-3>", frame.OnBodyRClick)
    t.bind("<Double-Button-1>", frame.OnBodyDoubleClick)
    t.bind("<Key>", frame.body.onBodyKey)

    # Gui-dependent commands...
    t.bind(g.virtual_event_name("Cut"), frame.OnCut)
    t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
    t.bind(g.virtual_event_name("Paste"), frame.OnPaste)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:EKR.20040604082214:Use virtual events for Copy, Paste etc.
@nocolor

- This might fix some binding problems on some platforms.

- Might want to define <<localUndo>> for undo in Find Panel.

- Probably should define <<selectAll>> for Find Panel and similar stuff.
#@nonl
#@-node:EKR.20040604082214:Use virtual events for Copy, Paste etc.
#@-node:ekr.20041007052853:(Fix problems with paste on Linux)
#@+node:ekr.20040918093558:(Fix Font dialog problems on the Mac)
#@+node:ekr.20041022080455:Report
@killcolor

There seems to be a bug when setting font preferences on the Mac.  If I 
check more than one box and then apply a font change, the change is set 
correctly when I restart Leo but doesn't always preview correctly 
before that.  I set headline and body text to the same font and the 
headlines did not change to show the new font until I started up again. 
  Not a big deal.

-- Dan Windler
#@-node:ekr.20041022080455:Report
#@+node:ekr.20041030082554:Report 2

http://sourceforge.net/forum/message.php?msg_id=2823643

there are two bugs with the setting of the font.

1. it does not get saved, if you exit leo without saving the file. or in other
words: you have to save a file, otherwise the font settings are not saved.

2. the outline font does not change until you restart leo.
#@-node:ekr.20041030082554:Report 2
#@-node:ekr.20040918093558:(Fix Font dialog problems on the Mac)
#@-node:ekr.20041022080257:Mac Bugs 3
#@-node:ekr.20041022091645.6:Today
#@+node:EKR.20040609091327:To do: 4.3
#@+node:ekr.20041018195347:Docs 2
#@+node:ekr.20041018195347.1:Improve MacOS Docs
I just succeeded at installing Leo under os x (10.2.8) by folliwing  
your instructions with modification.  It would be nice to get the  
modification added to your page for others. I actually found the mods  
by doing a search for help after following the present instructions  
failed. The step that is missing (as clearly as I can see) is step 3  
(using the Package Manager) in the following that comes from

http://coding.derkeiler.com/Archive/Python/comp.lang.python/2003-12/ 
3431.html

> What I did that worked on Jaguar:
>  - Installed MacPython 2.3 for Jaguar using the binary installer from:
>  <http://homepages.cwi.nl/~jack/macpython/macpython-osx.html>
>  - Installed Tcl/Tk 8.4.4 using the binary installer from
>  <http://www.maths.mq.edu.au/~steffen/tcltk/TclTkAqua/>
>  - Used Package Manager (in /Applications/MacPython) to install  
> _tkinter
>  (and also readlines and some other useful stuff)
>
[x]
   - type "rehash" in a terminal
   - type pythonw to start Python and then test Tkinter with the  
following:
>
> import Tkinter
>  root = Tkinter.Tk()
>
>
> should bring up a window.

(It was also nice to have a test included so you could see that  
everything was installed properly.)

I also edited the leo file that is part of the leo distribution so it  
read:

pythonw /usr/local/lib/leo/src/leo.pyw "$1"

That way I can just type "leo" to start leo rather than doing

/usr/local/bin/pythonw leo.pyw

Finally, when leo is run for the first time, it creates a window that  
is centered on the screen asking for an ID. The screen happened to  
appear under existing terminal windows and I didn't see it there and  
thought something was wrong with leo on my system. After I found it  
(accidentally) and entered a user name, all went as advertised.

Seeing the leo project in python is inspiring.  Thanks for making this  
available.

/c
#@nonl
#@-node:ekr.20041018195347.1:Improve MacOS Docs
#@+node:ekr.20040226094105:Put the scrollWheel workaround in the FAQ (or in the code??)
@nocolor
#@nonl
#@+node:ekr.20040226094105.1:halw

https://sourceforge.net/forum/message.php?msg_id=2437859
By: halw

David,

I agree that your solution is best -- the problem is it doesn't work. 

If you look at the original post you'll note that the mouse wheel works fine
in all other Leo panes (which are native text panes, not a custom canvas).

In fact, a stock RH9 system does set up X as those pages indicate. The problem
is elsewhere, perhaps Tk or Tkinter.

If Edward doesn't want to ship a workaround, that's fine. It should, IMO, make
it into the FAQ, though.

--Hal

#@-node:ekr.20040226094105.1:halw
#@+node:ekr.20040226094105.2:djsg
https://sourceforge.net/forum/message.php?msg_id=2435622
By: djsg

Tk is complying with the behavior of XFree86, and not hiding that behavior. 

Documentation for XFree86 4.2.0 -- documentation for a 4.4 development version
matches it, so 4.3.0 ought to match it also:

http://www.xfree86.org/4.2.0/mouse7.html

An example of configuration for XFree86 3.3.2.

First, the URL: 

http://www.genius-europe.com/service/faq/tuxmouse.htm

o save their bandwidth, the example follows: 


All mices with scroll wheel or stick

XFree86 >= 3.3.2 (or other XServer with wheel to mouse button support)
The mouse must be setup in XF86Config to send the mouse buttons 4 and 5 for
wheel actions.
Edit /etc/XF86Config with your favorite editor
Add the following line to the "Pointer" section.

ZAxisMapping 4 5

Make sure your Protocol is set to either "IMPS/2" for a PS/2 mouse
or for serial mice set it to "IntelliMouse" or "Auto".
Example for PS/2 wheel mouse:

Section "Pointer"
Protocol "IMPS/2"
Device "/dev/psaux"
SampleRate 60
BaudRate 1200
ZAxisMapping 4 5
Buttons 3
EndSection

After XWindows is started run :
imwheel -k


#@-node:ekr.20040226094105.2:djsg
#@+node:ekr.20040226094105.3:The actual workaround

https://sourceforge.net/forum/message.php?msg_id=2433628
By: halw

Okay, I have a workaround that works for me with my existing Tk version. My
Tkinter skills are weak, but I don't think this will hurt anything else :)

Turns out this Tk version (or X or Tkinter or 	) doesn't generate MouseWheel
events, but maps to buttons 4 (up) & 5 (down).

Add to if clause 
# Handle mouse wheel in the outline pane.
if sys.platform == "linux2": # This crashes tcl83.dll
..canvas.bind("<MouseWheel>", frame.OnMouseWheel)
..def mapWheel(e):
    if e.num == 4:
    ..e.delta = 120
    ..return frame.OnMouseWheel(e)
    elif e.num == 5:
    ..e.delta = -120
    ..return frame.OnMouseWheel(e)
..canvas.bind("<ButtonPress>", mapWheel, add=1)
#@nonl
#@-node:ekr.20040226094105.3:The actual workaround
#@-node:ekr.20040226094105:Put the scrollWheel workaround in the FAQ (or in the code??)
#@-node:ekr.20041018195347:Docs 2
#@+node:ekr.20041022080257:Mac Bugs 3
#@+node:ekr.20041022081937:Get cvs working again on mac
Just remove the cvs key files?
#@nonl
#@-node:ekr.20041022081937:Get cvs working again on mac
#@+node:ekr.20041007052853:(Fix problems with paste on Linux)
@color
#@nonl
#@+node:ekr.20041007052853.1:@url http://www.freedesktop.org/standards/clipboards-spec/clipboards.txt
#@-node:ekr.20041007052853.1:@url http://www.freedesktop.org/standards/clipboards-spec/clipboards.txt
#@+node:ekr.20031218072017.844:Clipboard (tkGui) NOT USED AT PRESENT
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui) NOT USED AT PRESENT
#@+node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
def OnCut (self,event=None):
    
    """The handler for the virtual Cut event."""

    frame = self ; c = frame.c ; v = c.currentVnode()
    
    if 0: # g.app.gui.win32clipboard is always None.
        if g.app.gui.win32clipboard:
            data = frame.body.getSelectedText()
            if data:
                g.app.gui.replaceClipboardWith(data)

    # Activate the body key handler by hand.
    frame.body.forceFullRecolor()
    frame.body.onBodyWillChange(v,"Cut")

def OnCutFromMenu (self):
    
    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Cut"))
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)



#@-node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
#@+node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
def OnCopy (self,event=None):
    
    frame = self

    if 0: # g.app.gui.win32clipboard is always None.
        if g.app.gui.win32clipboard:
            data = frame.body.getSelectedText()
            if data:
                g.app.gui.replaceClipboardWith(data)
        
    # Copy never changes dirty bits or syntax coloring.
    
def OnCopyFromMenu (self):

    frame = self
    w = frame.getFocus()
    w.event_generate(g.virtual_event_name("Copy"))
#@-node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
#@+node:ekr.20031218072017.843:frame.OnPaste & OnPasteFromMenu
def OnPaste (self,event=None):
    
    frame = self ; c = frame.c ; v = c.currentVnode()
    
    if 0: # sys.platform=="linux2": # ??? workaround paste problems on Linux.
        bodyCtrl = frame.body.bodyCtrl
        s = bodyCtrl.selection_get( selection='CLIPBOARD' )
        bodyCtrl.insert('insert', s)
        bodyCtrl.event_generate('<Key>')
        bodyCtrl.update_idletasks()
    else:
        # Activate the body key handler by hand.
        frame.body.forceFullRecolor()
        frame.body.onBodyWillChange(v,"Paste")
    
def OnPasteFromMenu (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Paste"))
    
    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)
#@nonl
#@-node:ekr.20031218072017.843:frame.OnPaste & OnPasteFromMenu
#@-node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,frame):
    
    t = self.bodyCtrl
    
    # Event handlers...
    t.bind("<Button-1>", frame.OnBodyClick)
    if sys.platform == "win32":
        # Support Linux middle-button paste easter egg.
        t.bind("<Button-2>", frame.OnPaste)
    t.bind("<Button-3>", frame.OnBodyRClick)
    t.bind("<Double-Button-1>", frame.OnBodyDoubleClick)
    t.bind("<Key>", frame.body.onBodyKey)

    # Gui-dependent commands...
    t.bind(g.virtual_event_name("Cut"), frame.OnCut)
    t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
    t.bind(g.virtual_event_name("Paste"), frame.OnPaste)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:EKR.20040604082214:Use virtual events for Copy, Paste etc.
@nocolor

- This might fix some binding problems on some platforms.

- Might want to define <<localUndo>> for undo in Find Panel.

- Probably should define <<selectAll>> for Find Panel and similar stuff.
#@nonl
#@-node:EKR.20040604082214:Use virtual events for Copy, Paste etc.
#@-node:ekr.20041007052853:(Fix problems with paste on Linux)
#@+node:ekr.20040918093558:(Fix Font dialog problems on the Mac)
#@+node:ekr.20041022080455:Report
@killcolor

There seems to be a bug when setting font preferences on the Mac.  If I 
check more than one box and then apply a font change, the change is set 
correctly when I restart Leo but doesn't always preview correctly 
before that.  I set headline and body text to the same font and the 
headlines did not change to show the new font until I started up again. 
  Not a big deal.

-- Dan Windler
#@-node:ekr.20041022080455:Report
#@+node:ekr.20041030082554:Report 2

http://sourceforge.net/forum/message.php?msg_id=2823643

there are two bugs with the setting of the font.

1. it does not get saved, if you exit leo without saving the file. or in other
words: you have to save a file, otherwise the font settings are not saved.

2. the outline font does not change until you restart leo.
#@-node:ekr.20041030082554:Report 2
#@-node:ekr.20040918093558:(Fix Font dialog problems on the Mac)
#@-node:ekr.20041022080257:Mac Bugs 3
#@+node:ekr.20041006110656:Urgent 7 + 0
#@+node:ekr.20040831092540:Allow uA's to be stored as plain strings (or base64)
I would like to store unknown
attributes as a simple string. The reason, is because I am using an unknown
attribute to carry additional markup information, in this case, to carry color
information for each node. (I used Joe Orr's XSL stylesheet as a startpoint for
HTML generation).

In order to achieve my nefarious aim, I have had to edit leoFileCommands.py but
I would prefer not to have to edit the main source code.

Martin Clifford
Senior Software Engineer
Snell & Wilcox
#@+node:ekr.20041004091238:example file
Edward

This is a follow up to my email at the end of August, regarding unknown attributes.

I have attached an HTML file (LeoToHTML) hat I generated from a Leo file.

It demonstrates the uses that I have made of unknown attributes.

My hope is that it will provide food for thought in your discussions on the subject.

Regards
Martin
#@-node:ekr.20041004091238:example file
#@-node:ekr.20040831092540:Allow uA's to be stored as plain strings (or base64)
#@+node:ekr.20041002165019:Emacs-style movement commands
http://sourceforge.net/forum/message.php?msg_id=2499058
By: sgbotsford

> Second level would be in implement the movement commands that aren't in leo.

That would be pretty easy in a plugin.  This is probably the most important thing that Leo should have in its core to support "driving" the editor as in Emacs.  The other thing is to support the emacs style of handling keystrokes (writing keystroke info to a status line).  Better feedback on the status line will happen asap.
#@nonl
#@-node:ekr.20041002165019:Emacs-style movement commands
#@+node:ekr.20041004193600:Add safeguards on @button and @script
#@+node:ekr.20041004193600.1:Paul's first posting
@killcolor
http://sourceforge.net/forum/message.php?msg_id=2788477
By: paulpaterson

Perhaps some minor bridling ...

What about managing the security of scripts using some algorithm like this,

1. When Leo scans for @buttons, @scripts etc it makes a list of scripts
2. For each script ...
3.   Calculate a secure hash of the script contents
4.   Consult central repository to see if hash is recognized
5.   If hash recognized
6.     Accept it
7.   Else
8.     Force user to acknowledge the script or disable it

The cental repository could be a file in your Leo directory which stores "approved"
hashes.

Clicking on a @buttons, @script node and selecting "Approve script" would add
the hash to the repository. Selecting "Disable script" would remove it. There
could also be a menu item to bring up a window of approved/not approved script
nodes so that you could centrally manage them.


Additional housekeeping on the list of hashes is possible but probably isn't
required since the size is small and there shouldn't be any collisions. If required
you could just blow away the file and then re-enable all scripts.

Using this approach, no new script would be able to run without being enabled
by the user. There is still the possibility that another plugin or script could
disable the security mechanism or tamper with the repository but with Leo's
architecture a plugin could already do anything anyway so this isn't an additional
hole.

It would protect from 

@script
import os
os.system("del *.*")

being submitted to an OS project!
#@nonl
#@-node:ekr.20041004193600.1:Paul's first posting
#@+node:ekr.20041005075955:Pault's second posting
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2789123
By: paulpaterson

I'm not an expert but from the Python docs this looks like the way to do it,

> import sha
> s = sha.sha("hello there")
> s.hexdigest()
'6e71b3cac15d32fe2d36c270887df9479c25c640'

> s = sha.sha("hello there hacked")
'a42837bba84c53cabd52a98f3671809d475c707f'

It looks like the md5 module offers a similar function but uses less bits.

From what I understand the hexdigest should be different for any change in the
text. Also no two strings should give the same hash (although I seem to recall
that someone found a collision recently).
#@-node:ekr.20041005075955:Pault's second posting
#@+node:ekr.20041003115036:Add --noscripting command-line option
This will disable @button, @script, etc.
#@nonl
#@-node:ekr.20041003115036:Add --noscripting command-line option
#@-node:ekr.20041004193600:Add safeguards on @button and @script
#@+node:EKR.20040602153716:(Finish drawUserIcons)
#@+node:ekr.20040317050439:Right-click to add user-specified attributes and icons
Also add corresponding commands.
#@nonl
#@-node:ekr.20040317050439:Right-click to add user-specified attributes and icons
#@+node:ekr.20040317184631:Design
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2477913
By: edream

A better design for user icons

Using tuples in t.unknownAttributes["icons"] is too constricted.  Much better
to have t.unknownAttributes["icons"] be a list of Python _dictionaries_ rather
than a list of tuples.  Each of these "subsidiary" dictionaries could have the
following keys:

"type"

"file", "icon" or "url".  At present my prototype code uses "file" to specify
the location of an icon.

"where":

"beforeBox", "beforeIcon", "beforeHeadLine", "afterHeadline".  This specifies
where to put the icon.  The default would be "beforeHeadline".  "beforeBox"
means before the plus/minus box.  "beforeIcon" means before the standard icon.

"height":

the height of the icon to use when calculating the line height.  Default: get
from the icon itself, if possible.

"width":

the width of the icon to use when calculating where to put the following element.
Default: get from the icon, if possible.

"xoffset"

Leo draws the icon at x + xoffset, where x is determined by the where param
above.  Default 0.

"xpad"

The amount of extra space following the icon.  Default 0.

"yoffset"

Leo draws the icon at y + yoffset.  Default 0.

"ypad"

The amount of extra vertical space to add to the line height.  Default 0.

These offset and pad values are integer pixel values and may be positive or
negative.

"lineHeight"  NOT USED.

Overrides any calculated line height.  Default:  lineHeight = yoffset + height + ypad.

"onClick", "onRightClick", "onDoubleClick"

commands to call when the specified event happens.  By default, the "onRightClick"
icon will be bound to a popup menu that offers the user a chance to delete the
icon,  and maybe other options such as "nudging" the icon up or down, left or
right.

"popUpMenu"

a list of items to put in a popup menu.  This would be a convenience to avoid
having to use "onRightClick".

I think you get the idea.  We want the drawing code to support lots of common
things that plugins would like to do.  I'll probably think of other goodies,
but this already is a big step forward.  Note that each of these keys will have
a default, so plugins only need to specify keys that have non-default values.

Edward

P.S.  Other gui's might not be able to support all these options.  That's ok.
The drawing code in gui plugins should degrade gracefully.

EKR
#@nonl
#@-node:ekr.20040317184631:Design
#@+node:ekr.20040317184631.2:Changes
@nocolor

"lineHeight"

This key won't be used.

t.unknownAttributes["lineYOffset"] 

An integer y offset for the entire line (except user icons, which are flexible enough).  You can use this to center the following vertically: the plus/minus box, the horizontal line to the plus/minus box, the standard headline box, and the Tk.Text widget for the headline.
#@nonl
#@-node:ekr.20040317184631.2:Changes
#@+node:ekr.20040317184631.1:To do
@nocolor

"onClick", "onRightClick", "onDoubleClick"

commands to call when the specified event happens.  By default, the "onRightClick"
icon will be bound to a popup menu that offers the user a chance to delete the
icon,  and maybe other options such as "nudging" the icon up or down, left or
right.

"popUpMenu"

a list of items to put in a popup menu.  This would be a convenience to avoid
having to use "onRightClick".

I think you get the idea.  We want the drawing code to support lots of common
things that plugins would like to do.  I'll probably think of other goodies,
but this already is a big step forward.  Note that each of these keys will have
a default, so plugins only need to specify keys that have non-default values.
#@nonl
#@-node:ekr.20040317184631.1:To do
#@+node:EKR.20040526202501:putUnknownAttributes
def putUnknownAttributes (self,torv,toString=False):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    result = []
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        try:
            val = attrDict[key]
            s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            self.put(attr)

        except pickle.PicklingError:
            # New in 4.2 beta 1: keep going after error.
            g.es("ignoring non-pickleable attribute %s in %s" % (
                key,torv),color="blue")
#@nonl
#@-node:EKR.20040526202501:putUnknownAttributes
#@-node:EKR.20040602153716:(Finish drawUserIcons)
#@+node:ekr.20040919182750.1:Support for CVS
#@+node:ekr.20040916122326:Check Import command
- Ignore position of blank lines wrt sentinels.
- Ignore (optionally?) underindented blank lines.
#@nonl
#@-node:ekr.20040916122326:Check Import command
#@+node:ekr.20031218072017.658:Resolve CVS Conflicts command
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@+node:ekr.20031218072017.659:Jonathon 1
https://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  

 
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?

More things to think about.

Gil
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20031218072017.658:Resolve CVS Conflicts command
#@+node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2674828
By: bwmulder

If I understand correctly, there are two different problems:

- Trailing whitespaces
- Left indented comments

1. Before commenting on these, a question:

If I write something like
    a=b
    if a:
        @others

[four spaces indentation]

I sometimes see tab characters before the lines inserted for '@others'.

It seems that Leo remembers 'two levels of indentation', and then
fabricates this indentation using tab characters.

I think it might be more robust if Leo remembered the actual
characters in front of @others and would use them for indentation.

I suspect that many indentation errors I had with Leo could have been
avoided had not Leo had its own ideas on how to do indentation.

Maybe Leo could use the exact sequence of characters in front of
@others for all inserted lines?

2. I do not care much about trailing whitespaces. Most of the time
they are invisible, but sometimes they are very misleading (trailing in python or C).

As far as I am concerned, Leo need never produce trailing whitespaces.

Maybe we need special machinerie if sources have trailing whitespaces
and the sources are not under our control. 

Not sure if everybody would be happy if we essentially ban all trailing
whitespaces.

3. Unindented commentlines could be dealt with by using indentation to
indicate structure.

Of course, this might break the correspondance Leo structure / Python
structure, which is very ugly.

4. One possible alternative might be a new directive which indicates outindent:

@outindent <number>.

This would apply to the next comment block.

To me, 4. looks a little bit less ugly than 3.

5. As indicated in a different post, I suspect that Leo has a problem
if almost every node in an outline is changed. Profiling should point
to the culprit.

> 2. Have Leo strip whitespace from otherwise blank lines, and hope
that that solves all problems in Perfect Import. This is solving the
problem in the atFile code. The problem is that if we apply settings
in general we will get massive changes to derived files. In most
programming settings these changes might be welcome, but the problem
is actually making these changes. My first few attempts met with
abject failure.

Are you saying that you could not remove trailing blanks? What kind of
problems did you run into?

Summary:
- Use actual characters in front of @others or <<>> for indentation.
- Don't write trailing whitespaces
- Introduce directive for left-indendet comments.
- Profile to find out what slows Leo down if many nodes change.
#@nonl
#@-node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:ekr.20040930075711:Handle underindented lines
#@+node:ekr.20040720065022: Notes
@nocolor

Leo can't represent some files using nodes!

I call this the "underindented blank line" problem.

Example:

@color

class aClass:
    def spam(): pass
# comment line
    def eggs(): pass
    
@nocolor

Leo's import code can't handle this:
    
- If the import code puts the comment line in a node, the line won't be output with the proper indentation!!

- Having the comment line stop the scanning of aClass is even worse.

- This usually shows up with an unindented blank line instead of the comment line.
#@nonl
#@-node:ekr.20040720065022: Notes
#@-node:ekr.20040930075711:Handle underindented lines
#@+node:ekr.20040930075920:Whitespace options
#@+node:ekr.20040720103642.1:Script to remove trailing body newlines VERY DANGEROUS
import leoGlobals as g

c = g.top() ; current = c.currentPosition()
count = 0

for p in c.all_positions_iter():
    s = p.bodyString().rstrip()
    if s:
        s = p.bodyString().rstrip() + '\n'
        if s != p.bodyString():
            # Do NOT set anything dirty here!
            ## p.v.t.setTnodeText(s)
            count += 1

print "%d nodes converted" % count
print "You MUST do Write All Nodes AND Save this file to complete the conversion"
#@nonl
#@-node:ekr.20040720103642.1:Script to remove trailing body newlines VERY DANGEROUS
#@+node:EKR.20040603092958.1:Add new options for handling newlines in body text
@nocolor

Alas, this really does not solve problems with Import.

- "asis":  ideal, maybe not possible?
- "zero": no trailing newlines.
- "one": exactly one trailing newline.

Special case code is required so empty nodes stay empty with "one" option.
#@nonl
#@+node:ekr.20040722132104:Write script to report underindented lines
#@-node:ekr.20040722132104:Write script to report underindented lines
#@+node:ekr.20040802063546.1:(Made sure body text changes reported properly)
# This may have to change when mass whitespace changes happen)
#@nonl
#@+node:ekr.20031218072017.1812:top_df.read
# The caller has enclosed this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False):
    
    """Common read logic for any derived file."""
    
    at = self ; c = at.c
    at.errors = 0
    importing = importFileName is not None
    << set fileName from root and importFileName >>
    << open file or return False >>
    g.es("reading: " + root.headString())
    firstLines,read_new,derivedFileIsThin = at.scanHeader(theFile,fileName)
    df = g.choose(read_new,at.new_df,at.old_df)
    # g.trace(g.choose(df==at.new_df,"new","old"))
    << copy ivars to df >>
    root.clearVisitedInTree()
    try:
        # 1/28/04: Don't set comment delims when importing.
        # 1/28/04: Call scanAllDirectives here, not in readOpenFile.
        importing = importFileName is not None
        df.scanAllDirectives(root,importing=importing,reading=True)
        df.readOpenFile(root,theFile,firstLines)
    except:
        at.error("Unexpected exception while reading derived file")
        g.es_exception()
    theFile.close()
    root.clearDirty() # May be set dirty below.
    after = root.nodeAfterTree()
    << warn about non-empty unvisited nodes >>
    if df.errors == 0:
        if not df.importing:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return df.errors == 0
#@nonl
#@+node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
at.scanDefaultDirectory(root,importing=importing)
if at.errors: return

if importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@nonl
#@-node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
#@+node:ekr.20031218072017.1814:<< open file or return false >>
fn = g.os_path_join(at.default_directory,fileName)
fn = g.os_path_normpath(fn)

try:
    # 11/4/03: open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile = open(fn,'rb')
    if theFile:
        << warn on read-only file >>
    else: return False
except:
    at.error("Can not open: " + '"@file ' + fn + '"')
    root.setDirty()
    return False
#@nonl
#@+node:ekr.20031218072017.1815:<< warn on read-only file >>
try:
    read_only = not os.access(fn,os.W_OK)
    if read_only:
        g.es("read only: " + fn,color="red")
except:
    pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20031218072017.1815:<< warn on read-only file >>
#@-node:ekr.20031218072017.1814:<< open file or return false >>
#@+node:ekr.20031218072017.1816:<< copy ivars to df >>
# Telling what kind of file we are reading.
df.importing = importFileName != None
df.raw = False
if importing and df == at.new_df:
    thinFile = True
df.thinFile = thinFile

# Set by scanHeader.
df.encoding = at.encoding
df.endSentinelComment = at.endSentinelComment
df.startSentinelComment = at.startSentinelComment

# Set other common ivars.
df.errors = 0
df.file = theFile
df.importRootSeen = False
df.indent = 0
df.targetFileName = fileName
df.root = root
df.root_seen = False
df.perfectImportRoot = None # Set only in readOpenFile.
#@nonl
#@-node:ekr.20031218072017.1816:<< copy ivars to df >>
#@+node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file:" + p.headString())
        p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@nonl
#@-node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
#@-node:ekr.20031218072017.1812:top_df.read
#@-node:ekr.20040802063546.1:(Made sure body text changes reported properly)
#@-node:EKR.20040603092958.1:Add new options for handling newlines in body text
#@+node:ekr.20040930075920.1:Common to both options
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.disableSave = False
    self.failedPlugins = [] # List of loaded plugins that have failed to load.
    self.globalWindows = []
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.trace = False # True: enable debugging traces.
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.findFrame = None
    self.pythonFrame = None
    
    << Define global constants >>
    << Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "_\\_ _(_ _)_", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20031218072017.2404:<< define defaultsDict >>
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

# Defaults for ivars are specified in the ctor, _not_ here.

defaultsDict = {
    # compare options...
    "ignore_blank_lines" : 1,
    "limit_count" : 9,
    "print_mismatching_lines" : 1,
    "print_trailing_lines" : 1,
    # find/change options...
    "search_body" : 1,
    "whole_word" : 1,
    # Prefs panel.
    "default_target_language" : "Python",
    "tab_width" : -4,
    "page_width" : 132,
    "output_doc_chunks" : 1,
    "tangle_outputs_header" : 1,
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    "color_directives_in_plain_text" : 1,
    "underline_undefined_section_names" : 1,
    # Window options...
    "allow_clone_drags" : 1,
    "body_pane_wraps" : 1,
    "body_text_font_family" : "Courier",
    "body_text_font_size" : defaultBodyFontSize,
    "body_text_font_slant" : "roman",
    "body_text_font_weight" : "normal",
    "enable_drag_messages" : 1,
    "headline_text_font_size" : defaultTreeFontSize,
    "headline_text_font_slant" : "roman",
    "headline_text_font_weight" : "normal",
    "log_text_font_size" : defaultLogFontSize,
    "log_text_font_slant" : "roman",
    "log_text_font_weight" : "normal",
    "initial_window_height" : 600, # 7/24/03: In pixels.
    "initial_window_width" :  800, # 7/24/03: In pixels.
    "initial_window_left" : 10,
    "initial_window_top" : 10,
    "initial_splitter_orientation" : "vertical",
    "initial_vertical_ratio" : 0.5,
    "initial_horizontal_ratio" : 0.3,
    "initial_horizontal_secondary_ratio" : 0.5,
    "initial_vertical_secondary_ratio" : 0.7,
    "outline_pane_scrolls_horizontally" : 0,
    "split_bar_color" : "LightSteelBlue2",
    "split_bar_relief" : "groove",
    "split_bar_width" : 7 }
#@nonl
#@-node:ekr.20031218072017.2404:<< define defaultsDict >>
#@+node:ekr.20031218072017.3004:<< initialize ivars that may be set by config options >>
# Defaults for these ivaars are specified here, _not_ in defaultsDict.

self.at_root_bodies_start_in_doc_mode = True # For compatibility with previous versions.
self.config = None # The current instance of ConfigParser
self.config_encoding = "utf-8" # Encoding used for leoConfig.txt.
self.create_nonexistent_directories = False
self.default_derived_file_encoding = "utf-8"
self.new_leo_file_encoding = "UTF-8" # Upper case for compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.read_only = True # Make sure we don't alter an illegal leoConfig.txt file!
self.redirect_execute_script_output_to_log_pane = False
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = False
self.stylesheet = None
self.tkEncoding = None # Defaults to None so it doesn't override better defaults.
self.trailing_body_newlines = "asis"
self.use_plugins = False # Should never be True here!
self.use_psyco = False
self.undo_granularity = "word" # "char","word","line","node"
self.write_strips_blank_lines = False
#@nonl
#@-node:ekr.20031218072017.3004:<< initialize ivars that may be set by config options >>
#@+node:ekr.20031218072017.1421:<< get config options >>
@ Rewritten 10/11/02 as follows:

1. We call initConfigParam and initBooleanConfigParam to get the values.

The general purpose code will enter all these values into configDict.  This allows update() to write the configuration section without special case code.  configDict is not accessible by the user.  Rather, for greater speed the user access these values via the ivars of this class.

2. We pass the ivars themselves as params so that default initialization is done in the ctor, as would normally be expected.
@c

self.at_root_bodies_start_in_doc_mode = self.initBooleanConfigParam(
    "at_root_bodies_start_in_doc_mode",self.at_root_bodies_start_in_doc_mode)
    
encoding = self.initConfigParam(
    "config_encoding",self.config_encoding)
    
if g.isValidEncoding(encoding):
    self.config_encoding = encoding
else:
    g.es("bad config_encoding: " + encoding)
    
self.create_nonexistent_directories = self.initBooleanConfigParam(
    "create_nonexistent_directories",self.create_nonexistent_directories)
    
encoding = self.initConfigParam(
    "default_derived_file_encoding",self.default_derived_file_encoding)

if g.isValidEncoding(encoding):
    self.default_derived_file_encoding = encoding
else:
    g.es("bad default_derived_file_encoding: " + encoding)
    
encoding = self.initConfigParam(
    "new_leo_file_encoding",
    self.new_leo_file_encoding)

if g.isValidEncoding(encoding):
    self.new_leo_file_encoding = encoding
else:
    g.es("bad new_leo_file_encoding: " + encoding)

self.output_initial_comment = self.initConfigParam(
    "output_initial_comment",self.output_initial_comment)

self.output_newline = self.initConfigParam(
    "output_newline",self.output_newline)

self.read_only = self.initBooleanConfigParam(
    "read_only",self.read_only)

self.relative_path_base_directory = self.initConfigParam(
    "relative_path_base_directory",self.relative_path_base_directory)
    
self.redirect_execute_script_output_to_log_pane = self.initBooleanConfigParam(
    "redirect_execute_script_output_to_log_pane",
    self.redirect_execute_script_output_to_log_pane)
    
self.remove_sentinels_extension = self.initConfigParam(
    "remove_sentinels_extension",self.remove_sentinels_extension)

self.save_clears_undo_buffer = self.initBooleanConfigParam(
    "save_clears_undo_buffer",self.save_clears_undo_buffer)
    
self.stylesheet = self.initConfigParam(
    "stylesheet",self.stylesheet)
    
encoding = self.initConfigParam(
    "tk_encoding",self.tkEncoding)
    
if encoding and len(encoding) > 0: # May be None.
    if g.isValidEncoding(encoding):
        self.tkEncoding = encoding
    else:
        g.es("bad tk_encoding: " + encoding)
        
# New in 4.2
self.trailing_body_newlines = self.initConfigParam(
    "trailing_body_newlines",self.trailing_body_newlines)
    
self.use_plugins = self.initBooleanConfigParam(
    "use_plugins",self.use_plugins)

self.use_psyco = self.initBooleanConfigParam(
    "use_psyco",self.use_psyco)
    
self.undo_granularity = self.initConfigParam(
    "undo_granularity",self.undo_granularity)

# New in 4.2
self.write_strips_blank_lines = self.initBooleanConfigParam(
    "write_strips_blank_lines",self.write_strips_blank_lines)
    
#g.trace("write_strips_blank_lines",self.write_strips_blank_lines)
#g.trace("trailing_body_newlines",self.trailing_body_newlines)
#@nonl
#@-node:ekr.20031218072017.1421:<< get config options >>
#@-node:ekr.20040930075920.1:Common to both options
#@+node:ekr.20040718050922:(trailing_body_newlines option)
@color
#@nonl
#@+node:ekr.20040720105309:Notes
@killcolor

My first idea was to do this in the body text setters.  However, this converts everything when reading any .leo file, and that is _very_ slow.  It also appears to be very dangerous.
#@nonl
#@-node:ekr.20040720105309:Notes
#@+node:ekr.20031218072017.2772:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""

    at = self ; c = self.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(endNode)
#@nonl
#@+node:ekr.20040904081433:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20040717133944:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@nonl
#@-node:ekr.20040717133944:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20040904081433:<< indicate that the node has been changed >>
#@-node:ekr.20031218072017.2772:readEndNode (4.x)
#@+node:ekr.20031218072017.1485:setTnodeText
# This sets the text in the tnode from the given string.

def setTnodeText (self,s,encoding="utf-8"):
    
    """Set the body text of a tnode to the given string."""
    
    s = g.toUnicode(s,encoding,reportErrors=True)
    
    if 0: # DANGEROUS:  This automatically converts everything when reading files.

        option = g.app.config.trailing_body_newlines
        
        if option == "one":
            s = s.rstrip() + '\n'
        elif option == "zero":
            s = s.rstrip()
    
    self.bodyString = s
#@nonl
#@-node:ekr.20031218072017.1485:setTnodeText
#@+node:ekr.20031218072017.1319:(Key handlers)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@+node:ekr.20031218072017.1320:body key handlers
@ The <Key> event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1321:idle_body_key
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"

    if g.doHook("bodykey1",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            << Do auto indent >>
        elif ch == '\t' and tab_width < 0:
            << convert tab to blanks >>
        elif ch in (chr(8)) and tab_width < 0:
            << handle backspace with negative tab_width >>
    << set s to widget text, removing trailing newlines if necessary >>
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
# Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if g.app.config.getBoolWindowPref("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18
#@nonl
#@-node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
#@+node:ekr.20031218072017.1325:<< convert tab to blanks >>
# Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20031218072017.1325:<< convert tab to blanks >>
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1321:idle_body_key
#@+node:ekr.20031218072017.1329:onBodyChanged (called from core)
# Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.c
    if not p:
        p = c.currentPosition()

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
#@nonl
#@-node:ekr.20031218072017.1329:onBodyChanged (called from core)
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event):
    
    """Handle any key press event in the body pane."""

    c = self.c ; ch = event.char
    
    # This translation is needed on MacOS.
    if ch == '':
        d = {'Return':'\r', 'Tab':'\t', 'BackSpace':chr(8)}
        ch = d.get(event.keysym,'')

    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()

    if 0: # won't work when menu keys are bound.
        self.handleStatusLineKey(event)
        
    # We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,"Typing",ch)
#@nonl
#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)>0:
        << trace the key event >>

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.1331:onBodyWillChange
# Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)
#@nonl
#@-node:ekr.20031218072017.1331:onBodyWillChange
#@-node:ekr.20031218072017.1320:body key handlers
#@+node:ekr.20040803072955.91:idle_head_key
def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c

    if not p or not p.isCurrentPosition():
        return "break"
        
    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    << set head to vnode text >>
    done = ch in ('\r','\n')
    if done:
        << set the widget text to head >>
    << set s to the widget text >>
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        << update p >>
    if done or changed:
        << reconfigure p and all nodes joined to p >>
        << update the screen >>

    g.doHook("headkey2",c=c,p=p,ch=ch)
    return "break"
#@nonl
#@+node:ekr.20040803072955.92:<< set head to vnode text >>
head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")
#@nonl
#@-node:ekr.20040803072955.92:<< set head to vnode text >>
#@+node:ekr.20040803072955.93:<< set the widget text to head >>
self.setText(edit_text,head,tag="idle_head_key")
edit_text.mark_set("insert",index)
#@nonl
#@-node:ekr.20040803072955.93:<< set the widget text to head >>
#@+node:ekr.20040803072955.94:<< set s to the widget text >>
s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i > -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) > limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')
#@nonl
#@-node:ekr.20040803072955.94:<< set s to the widget text >>
#@+node:ekr.20040803072955.95:<< update p >>
c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    # Bug fix 8/2/04: must call p.setDirty even if p is dirty!
    p.setDirty()
    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s,tag="idle_head_key2")
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.
#@nonl
#@-node:ekr.20040803072955.95:<< update p >>
#@+node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
# Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))
#@nonl
#@-node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
#@+node:ekr.20040803072955.97:<< update the screen >>
if done:
    # g.trace("done")
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20040803072955.97:<< update the screen >>
#@-node:ekr.20040803072955.91:idle_head_key
#@-node:ekr.20031218072017.1319:(Key handlers)
#@-node:ekr.20040718050922:(trailing_body_newlines option)
#@+node:ekr.20040720075446.1:(write_strips_blank_lines option)
#@+node:ekr.20031218072017.2134:putCodeLine
def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.app.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
#@nonl
#@-node:ekr.20031218072017.2134:putCodeLine
#@-node:ekr.20040720075446.1:(write_strips_blank_lines option)
#@-node:ekr.20040930075920:Whitespace options
#@-node:ekr.20040919182750.1:Support for CVS
#@+node:ekr.20041022083005:More flexible plugin manager
#@+node:ekr.20041022070154:(To do: options for setting working directory during startup)
#@+node:ekr.20041022070154.1:Request & response
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2815599
By: Antonio Pala

All plugins I have tried (notably @run and the @rst variants) have their working
directory set to my home directory, regardless of the position of the Leo file
and all @path directives. This renders most of them useless, since I would have
to use absolute pathnames. Is this the way they were meant to work, or is there
a bug somewhere? Or maybe I have missed some configuration parameter?

I am using Leo 4.2 with Python 2.3 on Linux.

> All plugins I have tried (notably @run and the @rst variants) have their working directory set to my home directory, regardless of the position of the Leo file and all @path directives.

Directory issues are different on different platforms.

I would welcome specific proposals for setting directories during startup.  Early in the startup process Leo sets g.app.loadDir to the directory from which Leo was loaded.  Plugins can use this directory to set the working directory as they choose.

@path directives will have no effect on plugins:  they are loaded before the outline.

> This renders most [plugins] useless, since I would have to use absolute pathnames.

No, it means you might have to add a few lines of code to your plugin to make it work just as you would like it to work.

> Is this the way they were meant to work?

I don't have much control over how plugins were "meant" to work.  However, an improved plugin manager might have facilities for setting the working directory.

This is a non-trivial issue;   Leo uses and sets paths in many places in the code.  It seems dubious to have plugins change the working directory at random times.  Perhaps an option that inits the working directory would be good.  The new config system will allow per-outline options as well as global option. I believe such options could be loaded before plugins.

Edward
#@-node:ekr.20041022070154.1:Request & response
#@-node:ekr.20041022070154:(To do: options for setting working directory during startup)
#@+node:ekr.20041022083005.1:unregisterhook
#@-node:ekr.20041022083005.1:unregisterhook
#@+node:ekr.20041024085554:specify load oarder, compatibilty
https://sourceforge.net/forum/message.php?msg_id=2818661

One thing to think about is to have the plugin author be able to specify if the plugin needs to be loaded before or after a set of plugins. Something like: 
 
plugin_signon( __name__, before = ( 'chapters', ), after = ( 'textdance', ) ) 
 
This may assist in ensuring that some plugins with dependencies get loaded right. :)

----------

http://sourceforge.net/forum/message.php?msg_id=2818661

maybe it would be good for some flag to indicate plugins the plugin is incompatible with.

plugin_signon( __name__, before = ( 'chapters', ), after = ( 'textdance', ),
clash = ( 'webpage_machine' ) )

where clash indicates the incompatibility.  What should it do?  Maybe not load?
#@nonl
#@-node:ekr.20041024085554:specify load oarder, compatibilty
#@-node:ekr.20041022083005:More flexible plugin manager
#@-node:ekr.20041006110656:Urgent 7 + 0
#@+node:ekr.20040919101448:Major (Must do) 4 + 0
#@+node:ekr.20040916122326.1:Revise Undo...
#@+node:ekr.20041011092930:Fix undo bug
http://sourceforge.net/forum/message.php?msg_id=2795653

By: Paul Paterson - paulpaterson
Bug: minor asymmetry with undo insert node  
2004-10-08 13:49
Very minor hangnail,

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. There is no longer a node selected in the tree so keyboard tree navigation etc commands don't work until you click on something with the mouse

In an ideal world, after #3 it should be as if #2 never happened.

----------------

http://sourceforge.net/forum/message.php?msg_id=2795656
By: paulpaterson

Hmm, there's something interesting here after all.

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. Hit Hoist before clicking on anything

Now you are hoisted on the recently removed node! The node is dead but his memory
lives on ...
#@-node:ekr.20041011092930:Fix undo bug
#@+node:EKR.20040601133022.1:(Finish the new undo)
#@+node:EKR.20040606195417.5:To do
@nocolor

- (done) Create u.saveNode, u.saveNodeAndChildren, u.saveListOfNodes.
- Create u.appendSavedNode.
- Use u.appendSavedNode in Change All command.
- Unit tests.
#@nonl
#@-node:EKR.20040606195417.5:To do
#@+node:EKR.20040528075307:u.saveTree
def saveTree (self,p,treeInfo=None):
    
    """Create all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    << about u.saveTree >>
    
    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,p.v.createUndoInfo(),p.v.t.createUndoInfo())
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
#@+node:EKR.20040530114124:<< about u.saveTree >>
@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo) where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.
#@-node:EKR.20040530114124:<< about u.saveTree >>
#@-node:EKR.20040528075307:u.saveTree
#@+node:EKR.20040606195417.2:u.saveNodeAndChildren
def saveNodeAndChildren (self,p):
    
    """Create all info needed for a node and all its immediate children."""

    u = self
    treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,p.v.createUndoInfo(),p.v.t.createUndoInfo())
    treeInfo.append(data)

    # Add info for all children.
    child = p.firstChild()
    while child:
        data = (child.v,child.v.createUndoInfo(),child.v.t.createUndoInfo())
        treeInfo.append(data)
        child = child.next()

    return treeInfo

#@-node:EKR.20040606195417.2:u.saveNodeAndChildren
#@+node:EKR.20040606195417.1:u.saveNode
def saveNode (self,p):
    
    """Create all info for a single vnode."""
    
    u = self

    treeInfo = (p.v,p.v.createUndoInfo(),p.v.t.createUndoInfo())
    return treeInfo
#@nonl
#@-node:EKR.20040606195417.1:u.saveNode
#@+node:EKR.20040606195417.3:u.saveListOfNodes
def saveListOfNodes (self,listOfVnodes):
    
    """Create all info for a list of vnodes."""
    
    u = self ; treeInfo = []

    for v in listOfVnodes:
        data = (v,v.createUndoInfo(),v.t.createUndoInfo())
        treeInfo.append(data)

    return treeInfo
#@nonl
#@-node:EKR.20040606195417.3:u.saveListOfNodes
#@-node:EKR.20040601133022.1:(Finish the new undo)
#@+node:ekr.20040323084434:(Add granularity setting for undo)
#@+node:ekr.20040328111626:Notes
@nocolor

- "node" and "line" granularity are easy:
    - Node: just replace "new" text with present text.
    - Line: create a new node if the present line isn't the same as the "line" attribute of the undo node.
        (Very similar to node granularity.

- "word" granularity is still fairly easy:
    - inWord flag is True or False.
    - create a new node if we are starting a new word.

- copy/paste always start new undo typing nodes.
    
#@nonl
#@-node:ekr.20040328111626:Notes
#@+node:ekr.20031218072017.3606:undo.__init__ & clearIvars
def __init__ (self,c):
    
    u = self ; u.c = c
    
    # Ivars to transition to new undo scheme...
    u.debug = False # True: enable debugging code in new undo scheme.
    u.debug_print = False # True: enable print statements in debug code.
    u.new_undo = True # True: enable new debug code.

    # Statistics comparing old and new ways (only if u.debug is on).
    u.new_mem = 0
    u.old_mem = 0

    # State ivars...
    u.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    u.redoMenuLabel = "Can't Redo"
    u.undoMenuLabel = "Can't Undo"
    u.realRedoMenuLabel = "Can't Redo"
    u.realUndoMenuLabel = "Can't Undo"
    u.undoing = False # True if executing an Undo command.
    u.redoing = False # True if executing a Redo command.
    
    # New in 4.2...
    << Define optional ivars >>
    << define redoDispatchDict >>
    << define undoDispatchDict >>
    u.updateSetChangedFlag = True
    u.redrawFlag = True
#@nonl
#@+node:ekr.20031218072017.3607:clearIvars
def clearIvars (self):
    
    u = self
    
    u.p = None # The position/node being operated upon for undo and redo.
    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
#@nonl
#@-node:ekr.20031218072017.3607:clearIvars
#@+node:ekr.20031218072017.3604:<< Define optional ivars >>
# New in 4.2: this is now an ivar, not a global, and it's a list, not a tuple.

u.optionalIvars = [
    "lastChild",
    "parent","oldParent",
    "back","oldBack",
    "n","oldN","oldV",
    "oldText","newText",
    "oldSel","newSel",
    "sort","select",
    "oldTree","newTree", # Added newTree 10/14/03
    "yview",
    # For incremental undo typing...
    "leading","trailing",
    "oldMiddleLines","newMiddleLines",
    "oldNewlines","newNewlines" ]
#@nonl
#@-node:ekr.20031218072017.3604:<< Define optional ivars >>
#@+node:EKR.20040526072519:<< define redoDispatchDict >>
u.redoDispatchDict = {
    "Change":             u.redoTyping,
    "Change All":         u.redoChangeAll,
    "Change Headline":    u.redoChangeHeadline,
    "Clone Node":         u.redoClone,
    "Convert All Blanks": u.redoReplaceNodesContents,
    "Convert All Tabs":   u.redoReplaceNodesContents,
    "Convert Blanks":     u.redoTyping,
    "Convert Tabs":       u.redoTyping,
    "Cut":                u.redoTyping,
    "Cut Node":           u.redoDeleteNode,
    "De-Hoist":           u.redoDehoist,
    "Delete":             u.redoTyping,
    "Delete Node":        u.redoDeleteNode,
    "Demote":             u.redoDemote,
    "Drag":               u.redoMoveNode,
    "Drag & Clone":       u.redoClone,
    "Extract":            u.redoReplaceNodes,
    "Extract Names":      u.redoReplaceNodes,
    "Extract Section":    u.redoReplaceNodes,
    "Hoist":              u.redoHoist,
    "Import":             u.redoInsertNodes,
    "Indent":             u.redoTyping,
    "Insert Node":        u.redoInsertNodes,
    "Move Down":          u.redoMoveNode,
    "Move Left":          u.redoMoveNode,
    "Move Right":         u.redoMoveNode,
    "Move Up":            u.redoMoveNode,
    "Paste":              u.redoTyping,
    "Paste Node":         u.redoInsertNodes,
    "Pretty Print":       u.redoChangeAll,
    "Promote":            u.redoPromote,
    "Read @file Nodes":   u.redoReplaceNodes,
    "Reformat Paragraph": u.redoTyping,
    "Sort Children":      u.redoSortChildren,
    "Sort Siblings":      u.redoSortSiblings,
    "Sort Top Level":     u.redoSortTopLevel,
    "Typing":             u.redoTyping,
    "Undent":             u.redoTyping }
#@nonl
#@-node:EKR.20040526072519:<< define redoDispatchDict >>
#@+node:EKR.20040526075238:<< define undoDispatchDict >>
u.undoDispatchDict = {
    "Change":             u.undoTyping,
    "Change All":         u.undoChangeAll,
    "Change Headline":    u.undoChangeHeadline,
    "Clone Node":         u.undoClone,
    "Convert All Blanks": u.undoReplaceNodesContents,
    "Convert All Tabs":   u.undoReplaceNodesContents,
    "Convert Blanks":     u.undoTyping,
    "Convert Tabs":       u.undoTyping,
    "Cut":                u.undoTyping,
    "Cut Node":           u.undoDeleteNode,
    "De-Hoist":           u.undoDehoist,
    "Delete":             u.undoTyping,
    "Delete Node":        u.undoDeleteNode,
    "Demote":             u.undoDemote,
    "Drag":               u.undoMoveNode,
    "Drag & Clone":       u.undoDragClone, # redo uses redoClone.
    "Extract":            u.undoReplaceNodes,
    "Extract Names":      u.undoReplaceNodes,
    "Extract Section":    u.undoReplaceNodes,
    "Hoist":              u.undoHoist,
    "Import":             u.undoInsertNodes,
    "Indent":             u.undoTyping,
    "Insert Node":        u.undoInsertNodes,
    "Move Down":          u.undoMoveNode,
    "Move Left":          u.undoMoveNode,
    "Move Right":         u.undoMoveNode,
    "Move Up":            u.undoMoveNode,
    "Paste":              u.undoTyping,
    "Paste Node":         u.undoInsertNodes,
    "Pretty Print":       u.undoChangeAll,
    "Promote":            u.undoPromote,
    "Read @file Nodes":   u.undoReplaceNodes,
    "Reformat Paragraph": u.undoTyping,
    "Sort Children":      u.undoSortChildren,
    "Sort Siblings":      u.undoSortSiblings,
    "Sort Top Level":     u.undoSortTopLevel,
    "Typing":             u.undoTyping,
    "Undent":             u.undoTyping }
#@nonl
#@-node:EKR.20040526075238:<< define undoDispatchDict >>
#@-node:ekr.20031218072017.3606:undo.__init__ & clearIvars
#@+node:ekr.20031218072017.1421:<< get config options >>
@ Rewritten 10/11/02 as follows:

1. We call initConfigParam and initBooleanConfigParam to get the values.

The general purpose code will enter all these values into configDict.  This allows update() to write the configuration section without special case code.  configDict is not accessible by the user.  Rather, for greater speed the user access these values via the ivars of this class.

2. We pass the ivars themselves as params so that default initialization is done in the ctor, as would normally be expected.
@c

self.at_root_bodies_start_in_doc_mode = self.initBooleanConfigParam(
    "at_root_bodies_start_in_doc_mode",self.at_root_bodies_start_in_doc_mode)
    
encoding = self.initConfigParam(
    "config_encoding",self.config_encoding)
    
if g.isValidEncoding(encoding):
    self.config_encoding = encoding
else:
    g.es("bad config_encoding: " + encoding)
    
self.create_nonexistent_directories = self.initBooleanConfigParam(
    "create_nonexistent_directories",self.create_nonexistent_directories)
    
encoding = self.initConfigParam(
    "default_derived_file_encoding",self.default_derived_file_encoding)

if g.isValidEncoding(encoding):
    self.default_derived_file_encoding = encoding
else:
    g.es("bad default_derived_file_encoding: " + encoding)
    
encoding = self.initConfigParam(
    "new_leo_file_encoding",
    self.new_leo_file_encoding)

if g.isValidEncoding(encoding):
    self.new_leo_file_encoding = encoding
else:
    g.es("bad new_leo_file_encoding: " + encoding)

self.output_initial_comment = self.initConfigParam(
    "output_initial_comment",self.output_initial_comment)

self.output_newline = self.initConfigParam(
    "output_newline",self.output_newline)

self.read_only = self.initBooleanConfigParam(
    "read_only",self.read_only)

self.relative_path_base_directory = self.initConfigParam(
    "relative_path_base_directory",self.relative_path_base_directory)
    
self.redirect_execute_script_output_to_log_pane = self.initBooleanConfigParam(
    "redirect_execute_script_output_to_log_pane",
    self.redirect_execute_script_output_to_log_pane)
    
self.remove_sentinels_extension = self.initConfigParam(
    "remove_sentinels_extension",self.remove_sentinels_extension)

self.save_clears_undo_buffer = self.initBooleanConfigParam(
    "save_clears_undo_buffer",self.save_clears_undo_buffer)
    
self.stylesheet = self.initConfigParam(
    "stylesheet",self.stylesheet)
    
encoding = self.initConfigParam(
    "tk_encoding",self.tkEncoding)
    
if encoding and len(encoding) > 0: # May be None.
    if g.isValidEncoding(encoding):
        self.tkEncoding = encoding
    else:
        g.es("bad tk_encoding: " + encoding)
        
# New in 4.2
self.trailing_body_newlines = self.initConfigParam(
    "trailing_body_newlines",self.trailing_body_newlines)
    
self.use_plugins = self.initBooleanConfigParam(
    "use_plugins",self.use_plugins)

self.use_psyco = self.initBooleanConfigParam(
    "use_psyco",self.use_psyco)
    
self.undo_granularity = self.initConfigParam(
    "undo_granularity",self.undo_granularity)

# New in 4.2
self.write_strips_blank_lines = self.initBooleanConfigParam(
    "write_strips_blank_lines",self.write_strips_blank_lines)
    
#g.trace("write_strips_blank_lines",self.write_strips_blank_lines)
#g.trace("trailing_body_newlines",self.trailing_body_newlines)
#@nonl
#@-node:ekr.20031218072017.1421:<< get config options >>
#@+node:ekr.20031218072017.1490:setUndoTypingParams
@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    # g.trace(undo_type,p,"old:",oldText,"new:",newText)
    u = self ; c = u.c
    << return if there is nothing to do >>
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    u.setUndoTypes() # Recalculate the menu labels.
    return d
#@nonl
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    return None

if oldText == newText:
    # g.trace("no change")
    return None
#@nonl
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p
#@nonl
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]
    
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    g.trace()
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
#@nonl
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply v.bodyString().
@c

if u.new_undo:
    if u.debug:
        # Remember the complete text for comparisons...
        u.oldText = oldText
        u.newText = newText
        # Compute statistics comparing old and new ways...
        # The old doesn't often store the old text, so don't count it here.
        u.old_mem += len(newText)
        s1 = string.join(old_middle_lines,'\n')
        s2 = string.join(new_middle_lines,'\n')
        u.new_mem += len(s1) + len(s2)
    else:
        u.oldText = None
        u.newText = None
else:
    u.oldText = oldText
    u.newText = newText

self.leading = leading
self.trailing = trailing
self.oldMiddleLines = old_middle_lines
self.newMiddleLines = new_middle_lines
self.oldNewlines = old_newlines
self.newNewlines = new_newlines
#@nonl
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
# Push params on undo stack, clearing all forward entries.
u.bead += 1
d = u.setBead(u.bead)
u.beads[u.bead:] = [d]

# g.trace(len(u.beads), u.bead)
#@nonl
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@+node:ekr.20031218072017.2038:<< redo typing cases >>
elif redoType in ( "Typing",
    "Change","Convert Blanks","Convert Tabs","Cut",
    "Delete","Indent","Paste","Reformat Paragraph","Undent"):

    # g.trace(redoType,u.p)
    # selectVnode causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectVnode(u.p)
    elif redoType in ("Cut","Paste"):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=redoType)
    
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.frame.body.setYScrollPosition(u.yview)
    redrawFlag = (current != u.p)
        
elif redoType == "Change All":

    count = 0
    while 1:
        u.bead += 1
        d = u.getBead(u.bead+1)
        assert(d)
        redoType = u.undoType
        # g.trace(redoType,u.p,u.newText)
        if redoType == "Change All":
            c.selectVnode(u.p)
            break
        elif redoType == "Change":
            u.p.v.setTnodeText(u.newText)
            u.p.setDirty()
            count += 1
        elif redoType == "Change Headline":
            u.p.initHeadString(u.newText)
            count += 1
        else: assert(False)
    g.es("redo %d instances" % count)

elif redoType == "Change Headline":
    
    # g.trace(redoType,u.p,u.newText)
    u.p.setHeadStringOrHeadline(u.newText)
    c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2038:<< redo typing cases >>
#@+node:ekr.20031218072017.2047:<< undo typing cases >>
@ When making "large" changes to text, we simply save the old and new text for undo and redo.  This happens rarely, so the expense is minor.

But for typical typing situations, where we are typing a single character, saving both the old and new text wastes a huge amount of space and puts extreme stress on the garbage collector.  This in turn can cause big performance problems.
@c
    
elif undoType in ( "Typing",
    "Change","Convert Blanks","Convert Tabs","Cut",
    "Delete","Indent","Paste","Reformat Paragraph","Undent"):

    # g.trace(undoType,u.p)
    # selectVnode causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectVnode(u.p)
    elif undoType in ("Cut","Paste"):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=undoType)
    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.frame.body.setYScrollPosition(u.yview)
    redrawFlag = (current != u.p)
        
elif undoType == "Change All":

    count = 0
    while 1:
        u.bead -= 1
        d = u.getBead(u.bead)
        assert(d)
        undoType = u.undoType
        # g.trace(undoType,u.p,u.oldText)
        if undoType == "Change All":
            c.selectVnode(u.p)
            break
        elif undoType == "Change":
            u.p.setTnodeText(u.oldText)  # p.setTnodeText
            count += 1
            u.p.setDirty()
        elif undoType == "Change Headline":
            u.p.initHeadString(u.oldText)  # p.initHeadString
            count += 1
        else: assert(False)
    g.es("undo %d instances" % count)
        
elif undoType == "Change Headline":
    
    # g.trace(u.oldText)
    u.p.setHeadStringOrHeadline(u.oldText)
    c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2047:<< undo typing cases >>
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    u = self ; c = u.c
    assert(p == c.currentPosition())
    v = p.v

    << Incrementally update the Tk.Text widget >>
    << Compute the result using v's body text >>
    # g.trace(v)
    # g.trace("old:",v.bodyString())
    v.setTnodeText(result)
    # g.trace("new:",v.bodyString())
    << Get textResult from the Tk.Text widget >>
    if textResult == result:
        if undoType in ("Cut","Paste"):
            # g.trace("non-incremental undo")
            c.frame.body.recolor(p,incremental=False)
        else:
            # g.trace("incremental undo:",leading,trailing)
            c.frame.body.recolor_range(p,leading,trailing)
    else: # 11/19/02: # Rewrite the pane and do a full recolor.
        if u.debug_print:
            << print mismatch trace >>
        # g.trace("non-incremental undo")
        p.setBodyStringOrPane(result)
#@nonl
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading > 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len > 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading > 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
while newlines > oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines > newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
# Recreate the text using the present body text.
body = v.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s
if u.debug_print:
    print "body:  ",body
    print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) > 0 and textResult[:-1] == result:
        textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20040323084434:(Add granularity setting for undo)
#@-node:ekr.20040916122326.1:Revise Undo...
#@+node:ekr.20031218072017.828:Rewrite the config manager
http://sourceforge.net/forum/message.php?msg_id=2329053
By: dsalomoni

I would be reluctant to run this script in a linux environment, for the following
reasons:

1) chmod 666 on the leo config file makes it writable by anybody. 

2) on the other hand, leo is currently IMHO not suitable for generic linux
installations, because it does not support per-user config files, so you actually
need to either carve leoconfig.txt in stone (not realistic), or make it writable
by any user as above (not advisable).

3) having a single dummy leoID defeats its main purpose in a multi-user environment.
If you could set per-user config files, the leoID could by default simply derived
from the username.

As a matter of fact, I've been suggesting to friends etc wanting to try out
leo/install it on their systems not to do that globally.

So, my view is that we could:

1) in the short term, provide a simple per-user installation based for example
on the script above, but with path defaults pointing to the user's home dir
(and of course w/o the requirement to be root) -- with leoID generated by default
looking at the username.

2) in the medium term, provide per-user config possibilities -- this would possibly
allow for a system-wide installation of leo and still allow configuration, per-user
plugins, etc. But this is linked I guess to the decommissioning of/changes to
the leoConfig.leo machinery.

Davide
#@nonl
#@+node:ekr.20041002150740:0. Design
#@+node:ekr.20040226105601:Design for new config system (alpaha, etc.) Tom
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2434323
By: nobody

Okay, so 4.2 is to address a graphical interface to configuring Leo, so I'm
going to go over some of the ways the Alpha, AlphaX, and AlphaTk family of
editors handle this. These are editors that use Tcl as the core scripting
language, much as elisp does for Emacs. In AlphaTk, all of the code is in Tcl &
Tk, so it run on any system that support Tcl/Tk 8.3+, and shows off the type of
dialogs that can be given to Leo as it also (currently) uses the Tk half of
this. It is available for Windows, and has a 45 day free demo period. It works
fine with The Tcl/Tk we use to run Leo so you only need to download AlphaTk.exe
via this link: http://www.santafe.edu/~vince/alphatk/download.html

In Alpha, like Emacs, their are "modes" specfic to each language that give you
useful functionality when you are editing code in that language. Each mode has
its own namespace (e.g. 'pyth' for the python Mode) that hold all the variables
and functions that provide the functionality mentioned above. There is a set of
variables and functions that form a sort of "global mode" that would be useful
in editing plain text, and provides values and simple editting bahavior if no
such simularly named things exists in the pyth namespace, if these do exist,
them overide these global values & functions when in that editting mode.

Modes are held in a directory named "Modes", in Leo this would probably be a
subdirectory of 'plugins'. In Alpha a simple mode can be defined in a single
file, Leo should proabably use the multi-file method, each mode is given its own
subdirectory (e.g. ...\plugins\Modes\Python Mode\), then various files to define
that mode's functionality would be placed in that directory. Thus you could
include the syntax files directly from jEdit here. 

Alpha only concerns itself with what it needs to know to accomplish what its
user is trying to do, thus, if a user never edits a c++ file in a session, Alpha
never loads in the details of the C Mode (which includes c++), it knows it has a
C Mode, what file extensions it should activate for & has a short description to
give if the users ask for help on the mode, but only loads the rest of the code
that defines the mode if it is called on to edit a c or c++ file. It does this
by scanning all of the subdirectories files for a function call that has all
this info as parameters. These are gathered into a cache (a script file) that
gets executed when alpha starts up. This cache has a dictionary of filenames to
modification dates so that the cache remains valid as long as the files scanned
are already in the dictionary and have the same modification dates. Any conflict
gets caught at start-up and triggers a rescanning. 

Alpha has a function, 'newPref', that builds dictionaries of various kinds of
variables, consisting of variable_name to a tuple. That tuple varies according
to the type of variable, but has as a minimum, the default value and the
namespace it is to be created in. Other parts of the tuple might include a list
of the possible values, or a series of tuples (<text to present in drop down
box>, <value>). Any change by the user to a value other than the default gets
that choice written to a cache that gets loaded the first time a mode is
activated. When newPref executes it checks to see if the variable already
exists, and only creates that variable and intializes it to the default if it
doesn't. A further wrinkle is that any comment immediately preceding a newPref
call gets stored as help text for that variable.

These dictionaries are used to allow the configuration dialog for a mode be
automatically created on the fly. Flag dictionaries get their keys dumped and
sorted to create an array of checkboxes, their stored comments forms a "tooltip"
box of text displayed when the arrow hovers over the checkbox.

Other dictionaries drive other types of widgets in the dialog panes.

More later, but much of this could be adapted to Leo. Other things to check out
are the keysetting dialogs, an example of which is under "Config->Special
Keys...".

Tom
#@+node:ekr.20040227053137:More alpha stuff
https://sourceforge.net/forum/message.php?msg_id=2444789
By: nobody

To continue on things that Alpha contribute to Leo, let me tell you the some of
the reasons behind the design.

File structure: Alpha has the equivalent of a plugin directory, however, the
actual plug-ins are organized in subdirectories; files that tell alpha how to
support languages are placed in the "Modes" directory, files that add
functionality exposed primarily through an add-in menu are placed in the "Menus"
directory (Leo might use "Menus & Widgets" to include things like the new search
plug-in), other code that provides functionality that is not tied to a
particular language, and is not primarily invoked via a menu are placed in the
"Packages" directory, (e.g. the completion package that provide general word
completion).

This helps out when someone wants to roll their own code, if you want to add a
language look at the examples that are in the 'Modes' directory, you can quickly
cobble together elementary support and then extend it over time.

Installing a plug-in is really just a matter of putting the files in the right
place and have Alpha update its indexes. Now that does not mean that the new
features are enabled (other than for a language, those activate whenever Alpha
realises that it is editting a file of that language), if you go to
"Config->Global-Setup->Features" or "Config->Global-Setup->Menus", you get a
panel of checkboxes for Features or Menus that you can check to enable Globally,
(i.e. no matter what mode is currently active). Note that a tooltip box giving a
description is available whenever you hover the mouse over the feature/menu
name. These are built dynamically, are sorted alphabetically, and continued on
another page whenever their are too many to position on a single page. This
means no carefully redesign of a dialog box is needed to accomadate new
features.

The preferences for a language are only settable when a given mode is active.
Although in Alpha this is dependent on the file you are editing, Leo can be
thought of as in a given language mode dependent on what language directive is
in effect for the current cursor position. Once you are in a mode, the
"Config-><mode> Mode Prefs" Menu becomes active, Allowing you to choose what
Menus & Feature you would like available when you are in this mode. You also
have access to the Preferences that are available in that mode.

Note that any preference, feature set, menus that you chose are all store in a
cache of code that sets them to your chosen values whenever you start Alpha.
These values can be saved and used when you upgade to a new version (of Alpha or
any of its packages), conversely, discarded the Prefs directory restores you to
all the defaults as orginally specified. Mechanisms exist to prune out cached
values that are no longer used, and to ensure that a new variable that has been
added is set if it needs to be before some code gets executed.

Tom

#@-node:ekr.20040227053137:More alpha stuff
#@-node:ekr.20040226105601:Design for new config system (alpaha, etc.) Tom
#@+node:ekr.20040216153659.1:Find some way to translate all other Leo messages.
Including, e.g., Undo messages.
#@nonl
#@-node:ekr.20040216153659.1:Find some way to translate all other Leo messages.
#@+node:ekr.20031218072017.656:Different fonts settings for Linux/Mac
@nocolor

By: sanori ( Joo-won Jung ) 
 How about split font config for win and unix?   
2003-02-10 12:02  
Developer Forum

How about split the font's configurations like IDLE, python IDE? 
Because the 10pt size in Windows and Unix (X window, exactly) is not the same. Moreover, the font set that the OS provides does not the same. 

I'm using leo on both windows and Linux, and leo is in the vfat partition to use it both OS. Of course, I can change the font size by using the font dialog. But, I want leo to be more comportable. :)

-Sanori 
#@-node:ekr.20031218072017.656:Different fonts settings for Linux/Mac
#@+node:ekr.20041005083816:Use g.bunch to encapsulate plugins options
http://sourceforge.net/forum/message.php?msg_id=2789076
By: e

can we add some notation to style guide:
instead of globals, try to arrange your code
so that various True/False or numeric constants
can be captured in a python dict type.
myconfig = g.Bunch(
  latebinding = True,
  enablebuttons = True,
  enableplugins = False,
  etc,
  )

this way you are already setup to save options in config
under your plugin name. and the user will be able to override
the defaults without editing the plugin source with @options.
mod_scripting come to mind with several T/F of note.
local options could be preceeded with _ 
and ignored by the config code.
maybe g.plugin_signon could do something usefull
and collect these options compare them with previous
local and global ini and pass back the results to the plugin.
the spellpyx plugin is another bad example, 
in spite of its using mod_spelling.ini, 
c:\aspell is hardcoded in the plugin.

#@-node:ekr.20041005083816:Use g.bunch to encapsulate plugins options
#@-node:ekr.20041002150740:0. Design
#@+node:ekr.20041002150740.1:1.  Search for settings in various places
#@+node:ekr.20040922073523:comments from e
@killcolor
http://sourceforge.net/forum/message.php?msg_id=2769775
By: nobody

Leo should make it a priority to determine leoID
and users HOME and other dir of interest
before plugins are loaded so thay can have access.
at 'after-create-leo-frame' g.app.leoID not defined
but g.app.loadDir and many others are.
if there will be more than one config, a system,
a per user in HOME, and maybe per currentdir or
in the same dir as the leo, they should be known.

g.app.homeDir = os.getenv('HOME', 
                    default= os.path.abspath('./'))
on windows this can point many places
best to set HOME if you want it in a specific place.
otherwise it can be %WINDIR%/APPDATA or %ROOT%/APPDATA
APPDATA can be an env variable, probably win2k or later.

# abspath resolves './' sometimes returned curdir
import user, os
print os.path.abspath(user.home) 
print os.path.abspath(os.path.expanduser("~"))

obviously this will need allot of work to get
crossplatform and bulletproof. you would think
it would be easy to know where everything should go
or how to nail down how to find everything.
no such luck, all I've seen is bits and pieces.
#@nonl
#@+node:ekr.20040924081853:more comments
https://sourceforge.net/forum/message.php?msg_id=2771155
By: nobody

>>I'll get everything correct eventually :-)

with no doubt many security and data integrity
roadblocks along the way. I stumbled on to
the leoID not being set yet in htmlize.
rather than only adding a leoID to the temp file
created in %tmp% I would much prefer to
put the file into the users %HOME% to avoid
using %tmp% as it shows up on the bugtrack
as a security hole in so many apps.
lets not have Leo get its widest exposure that way.
plugins should not have to roll their own access to the same areas the config
will later need anyway. for now, I will just defer creating such
filenames till the first time they are needed.

e
#@-node:ekr.20040924081853:more comments
#@+node:ekr.20040928085738:still more comments
https://sourceforge.net/forum/message.php?msg_id=2776098
By: nobody

do we not discuss config options after every release?
it is worth taking the time to get it right.

>>This is a happy development. It means that there is now a natural way to keep
three kinds of configuration options:
per-project options in .leo files, per-user options in a leoConfig.txt file
in the user's home directory, and per-installation in a leoConfig.txt file in
Leo's installation directory.

the exact details of conflict resolution to be announced?
the leo, then the user, then the system. for everything?
can the leo specify its local plugin directory, leoID?
that could have implications for downloading a leo.
the local leo options would seem to need an override.
a ./config in the same dir, env variable or commandline.
maybe if the leoID is different than the users
all destructive options should be overridden.
it would then be up to the user only to determine
if the leoID is different than their own to be safe.
safe meaning no reads or writes outside the current dir.
probably a long list of other restrictions.


I noticed this in docutils doc's
see the docutils config help file, paraphrased:

"The default implicit config file paths can be overridden by the DOCUTILSCONFIG
environment variable. DOCUTILSCONFIG should contain a colon-separated
(semicolon-separated on Windows) sequence of config file paths to search
 ...
In addition, a configuration file may be explicitly specified with the "--config"
command-line option. "

continuing: "docutils uses ConfigParser"

I wonder if subclassing and adding support
for comments (a glaring oversight) would improve things.
although, I see mentioned in docutils config page,
Lines beginning with "#" or ";" are ignored and may be used to provide comments.
perhaps I misremember ConfigParser eating comments.
maybe it doesn't rewrite them in the correct order?
I dont think many programs rewrite their configs, so
this is probably not a problem for them.

the rearranging of rewritten config options is wrong.
but as with many of the config methods utilizing an
undecorated dict, it would have to be determined
if useful enough to go through the trouble to maintain
the origional order. and then, what happens to new values,
are they inserted or appended. the comments saved too.
are the section names themselves rearanged in the file?
many of us will in a pinch hand edit or machine generate
or read config files and the less surprize the better.

there are about 5 other config modules out there
attempting to fix various problems in ConfigParser.
some projects subclass ConfigParser to their own design,
(from memory) pygame, distutils among others.
I realize the "not invented here syndrome" will preclude
using any of these in Leo, but perhaps like twisted often
does, they can be branched into Leo and worked on directly.
plugin ini files should be able to use 
(but not required to use) what Leo knows 
to parse config files or use config options
as early as possible while the plugins are loading.
storing them in ../plugins makes them global to all users.
the user might even want their own plugins dir. 
concider Leo is installed not writable to a user.
they can then not use any custom plugins.
the ability to turn off plugins already loaded
would require Leo to support unhook of some kind
and loading plugins on demand when apply config
could be a problem on some plugins.
how far should the new config go with plugins?
pluginManager.txt isn't very user friendly, forcing
all leo's to have the same plugins all the time.

<http://docutils.sf.net/docs/config.htm>
<http://www.tundraware.com/Software/tconfpy>
<https://sourceforge.net/projects/config-py/>  
  attempting to be a replacement for ConfigParser
  no mention of comments in the config files though.
<http://cvs.zope.org/%2Acheckout%2A/ZODB3/ZConfig/doc/zconfig.pdf?rev=HEAD
ZConfig>
  I haven't looked at it, but,
  can be used separately and has distro on pypi
     <http://www.python.org/pypi>
     <http://www.zope.org/Members/fdrake/zconfig/>
<http://www.voidspace.org.uk/atlantibots/pythonutils.html>
   configobj does support comments.

I don't know which if any of these support unicode, 
in later version of ConfigParser, unicode may be ok.
filenames on many systems are unicode, Leo is unicode
aware, that would seem to be a necessary option.

py-tconfpy being the most ambitious and flexible,
does support comments. in addition to the standard
config type use, it has a kind of limited python syntax.
worth a look. offloading some of the user customization
smarts into the config file itself is unproven controlable.
the more complicated the config file is, the easier it is
to mess up and the harder it is to recover from mistakes.

>>. In other words it is like blocking the users from setting certain things. 
or from shooting yourself in the foot as root.

e

______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit: 
https://sourceforge.net/forum/unmonitor.php?forum_id=10226

#@-node:ekr.20040928085738:still more comments
#@-node:ekr.20040922073523:comments from e
#@+node:ekr.20040105080119:Search for settings in various places: Rodrigo
@nocolor

https://sourceforge.net/forum/message.php?msg_id=2355843
By: rodrigo_b

The better would be to have

$HOME/.leo/
$HOME/.leo/leoConfig.txt
$HOME/.leo/plugins/pluginManager.txt
$HOME/.leo/plugins/<myplugins>.py

look for .leoConfig.txt, then leoConfig.txt
#@nonl
#@+node:ekr.20040919075839:Stephen Schaefer
By: Stephen Schaefer - thyrsus
RE: 4.2 rc1 released  
2004-09-18 05:32
It took me two hours to track it down, but I did manage to get leoConfit.txt and .leoID.txt to be taken from $HOME/.leoconfig

Mostly it took so long because the documenation assumed a knowledge of Python operation I didn't posess.

First, the current leo requires Python 2.3, and I'm running on a Red Hat 7.3 system where the "native" python is 1.5.2, and "python2" is 2.2.2. It's far cheaper to add another python than to make sure a different python doesn't break things, so my python 2.3 is rooted at /apps/python/python-2.3.2. There is a file that python looks for but is not present when it is installed from source:

/apps/python/python-2.3.2/lib/python2.3/sitecusomize.py

I created that file with the following contents (. for leading space):

import sys
import os
try:
    sys.leo_config_directory = os.environ['HOME'] + '/.leoconfig'
except KeyError:
    sys.leo_config_directory = None

If I were more sophisticated, I would check that $HOME/.leoconfig was a directory, and if not also set sys.leo_config_directory to None.

It doesn't seem appropriate to insist that anyone using python 2.3.2 for any reason whatsoever would be forced to have a .leoconfig in their home directory (think of a limited account that doesn't have a writable home directory), but it would be appropriate for leo to create $HOME/.leoconfig if it weren't present and set sys.leo_config_directory at that point -- indeed the entire logic could be handled outside of sitecustomize.py. I'll post code for the above if someone else doesn't beat me to it :-).
#@-node:ekr.20040919075839:Stephen Schaefer
#@-node:ekr.20040105080119:Search for settings in various places: Rodrigo
#@+node:ekr.20040208112836:EKR: specify shortcuts, ampersand bindings & translations in the same place
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2415127
By: edream

I have just hacked the code to allow & in entries in leoConfig.txt that describe
shortcuts.

This is a hack because it probably interacts poorly with the present mechanism
that allows menu entries to be translated.  I haven't looked into this in detail:
possibly everything works when menus are translated.  More likely things break.
If so, not using & in leoConfig.txt will probably "restore" things to their
former not-very-good state.

It appears that I shall have to revisit this whole gruesome topic when
the configuration code gets rewritten.
#@nonl
#@-node:ekr.20040208112836:EKR: specify shortcuts, ampersand bindings & translations in the same place
#@+node:ekr.20040212094034:Another comment
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2420426
By: dalcolmo

> One copy of leoConfig.txt might specify installation options; other copies
might specify per-folder or per-file options.

Maybe I misunderstand this, but would the .leo file be the place for any per-file
options?

> "inheritable" copies of leoConfig.txt.

Yes! I want a copy per user, so I won't have to manually update the latest
installation of leo with my configurations. The typical global rc file (in /etc
or in the leo program dir) and local config file in ~/.leo would do fine. As
far as I am concerned, that would also be my preferred setup under Windows,
but I am sure most people would disagree.

Please move all global configuration options to one place. Currently, besides
having to edit leoConfig.leo, I have also to edit leoPlugins.leo or
pluginsManager.txt

I believe, these should also be configuration settings.

Best regards - Josef Dalcolmo
#@nonl
#@-node:ekr.20040212094034:Another comment
#@+node:ekr.20040213060739:Config stuff: write protected leoConfig.txt
@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 4.1rc4 Plug-in Bug?   
2004-02-13 03:32  

 if you write protect leoconfig.txt you also notice via traceback that it opens for write on entry too, not sure if it actually writes anything at that time.

looking forward to what the team dreams up for config options.
checkbox or dropdown & edit of available options
with spin boxes for font size etc

a positive way to lock all the panes ito the same scheme or allow individual choice.
and all the other per user options maybe an override on the command line to enable or disable a plugin or select a particular config.txt
 
#@-node:ekr.20040213060739:Config stuff: write protected leoConfig.txt
#@+node:ekr.20031218072017.655:multiple copies of leoConfig.txt
@nocolor

> It just leaves still the problem of merging ones personal settings of leoConfig.txt 
with the ones in the new distribution. 

I am going to work on this just after 3.11b1 goes out the door. I think what I shall do is have Leo looks for several different files: first leoConfig.txt, then leoSiteConfig.txt, with the latter overriding the former. That way you can have stable settings (leoSiteConfig.txt won't be part of distributions). 

I may also have Leo look for leoLinuxConfig.txt, leoWinConfig.txt and leoMacConfig.txt, depending on the platform, so you can have stable platform settings as well. 
#@nonl
#@-node:ekr.20031218072017.655:multiple copies of leoConfig.txt
#@+node:ekr.20040225061559:Look at older config files when reading config data the first time for a new install
@nocolor

Is there a way that a "new" Leo installation could query the older one for config data?

Every time I get a new copy, I need to do a side-by-side compare and edit with the previous leoConfig.leo in order to change the settings to the way I want them. It would be really nice if this could be automated in some fashion.
#@nonl
#@-node:ekr.20040225061559:Look at older config files when reading config data the first time for a new install
#@+node:EKR.20040422132037.4:config problem on Linux
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2373816
By: sbeards

A related issue is that leoConfig.txt gets auto-tangled and overwritten on startup.
This will be a problem if Leo is run by a non-root user or the file is not readable.
For example, I get the following traceback after starting Leo (when leoConfig.txt
is read-only):

Traceback (most recent call last):
  File "/usr/local/share/leo-4.1-rc3/src/leoConfig.py", line 672, in update
    cf = open(self.configFileName,mode)
IOError: [Errno 13] Permission denied:
'/usr/local/share/leo-4.1-rc3/src/../config/leoConfig.txt'

Is there a reason leoConfig.txt gets auto-tangled on startup? Is there anyway
to disable this? Is this by design?
#@-node:EKR.20040422132037.4:config problem on Linux
#@+node:ekr.20040327050211:Fix problems with updating leoConfig.txt
#@+node:ekr.20040330092305:Preserve comments in config files (so we can use sentinels!)
@nocolor

> I don't know how to read [an @file-nosent config] file into the body of that node.

You can't, at least not automatically.  Leo needs sentinels in order to read a derived file, that is, in order to update the outline using information in a derived file.

I've been dithering about exactly what to do about configuration files.  Your question reminds me that we would prefer to have sentinels in config files.  In order to do that, Leo must preserve comments in config files, which of course would be much better than the present pathetic situation in which Python's configParser module strips comments.  As I have said before, using configParser was a blunder.  Somehow I'll fix this for 4.2.

Edward
#@nonl
#@-node:ekr.20040330092305:Preserve comments in config files (so we can use sentinels!)
#@+node:ekr.20040124073801:Add nullConfig class?
#@-node:ekr.20040124073801:Add nullConfig class?
#@+node:EKR.20040606193130:(Fix problems with negative tab width in prefs)
#@+node:EKR.20040606193323:Report
@nocolor

Open discussion
http://sourceforge.net/forum/message.php?msg_id=2603738

I always set tabs to -4 in the config. when you open the prefs it says 4 but
there is a checkmark for convert tabs to space. open a new leo, open prefs. its
not checked! open another leo, its checked.

The problem is that tab_width is usually stored in leoConfig.txt, not the .leo file.
I'm going to ignore this problem for now...
#@nonl
#@-node:EKR.20040606193323:Report
#@+node:ekr.20031218072017.2062:getPrefs
def getPrefs (self):

    c = self.c ; config = g.app.config
    
    if self.getOpenTag("<preferences"):
        return # <preferences/> seeen

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))
    
    done = False
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag("/>"):
                done = True ; break
            if self.matchTag(">"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    if not done: # 8/31/04
        while 1:
            if self.matchTag("<defaultDirectory>"):
                # New in version 0.16.
                c.tangle_directory = self.getEscapedString()
                self.getTag("</defaultDirectory>")
                if not g.os_path_exists(c.tangle_directory):
                    g.es("default tangle directory not found:" + c.tangle_directory)
            elif self.matchTag("<TSyntaxMemo_options>"):
                self.getEscapedString() # ignored
                self.getTag("</TSyntaxMemo_options>")
            else: break
        self.getTag("</preferences>")

    # Override .leo file's preferences if settings are in leoConfig.txt.
    if config.configsExist:
        config.setCommandsIvars(c)
#@nonl
#@+node:ekr.20031218072017.2063:getTargetLanguage
def getTargetLanguage (self):
    
    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language
            
    return "c" # default
#@nonl
#@-node:ekr.20031218072017.2063:getTargetLanguage
#@-node:ekr.20031218072017.2062:getPrefs
#@-node:EKR.20040606193130:(Fix problems with negative tab width in prefs)
#@-node:ekr.20040327050211:Fix problems with updating leoConfig.txt
#@-node:ekr.20041002150740.1:1.  Search for settings in various places
#@+node:ekr.20041002150740.2:2.  Set config options using dialogs
#@+node:ekr.20031218072017.651:Suggestion from RodrigoB
http://sourceforge.net/forum/message.php?msg_id=2312787
By: nobody

I had the idea some days ago, and I think I have not posted it yet.

The idea is simple but usefull, it is related about how to get a better configuration
interface for Leo.
The idea is:

let the configuration interface be a Plugin. This plugin define the
@configuration-file nodes. Under that nodes (and they childs), when selecting
the body, the body text is parsed to construct a tk dialog directly into the
body pane (replacing the text view, or as a window element in the text). When
modifying the menu, the text is changed. If something go wrong with the text
format, an error is raised and the original text is show.

The advantage of this plugin is that it is easier to devellop and integrate
very well with the actual scheme. It allow to define the configuration as a
hierarchy of nodes, similar to the linux kernel configuration, and use the power
of Leo.

The text format could be

option1 = 1 # checkbox <= the plugin infere that it have to show the option1
as a checkbox
option2 = bla # [bla, blo, bli] <= the plugin infere that it have to show a
combobox for option2, with options bla, blo, bli
option3 = rodrigo # text   <= trivial, etc...

The comment after the option could allow to specify python code for conditions,
etc, etc	
Obviously the comment can be placed, the line before, or the line after, or
under what ever format required.

That is the idea, it is implementable, and, to my eyes, would solve the problem.

RodrigoB.


#@-node:ekr.20031218072017.651:Suggestion from RodrigoB
#@+node:ekr.20031218072017.652:Add settings menu
- Add Settings menu.
    - Create Settings menu dynamically from leoConfig.txt
- Write leoConfig.txt by hand.

- Remove Open LeoConfig.leo command
- Remove Apply Settings command (will be done with apply, cancel, ok, revert buttons in all Settings submenus)
#@nonl
#@+node:ekr.20031218072017.653:Notes
@nocolor

It would be an understatement to say that the way Leo handles configuration settings could be improved.  The present scheme involves editing leoConfig.leo, then remembering to save all .leo files before tangling leoConfig.leo.  Moreover, even when doing this properly, not all changes to settings "take" immediately.  Furthermore, there are no easy analogies to the typical "apply" or "revert" or "revert to default" buttons commonly seen in options dialogs.

Last night I studied the way the jEdit editor handles options.  See http://www.jedit.org/
Visually, jEdit's "Global Options" dialogs are very impressive.  There is a tree view on the left, there is a unique panel on the left for each item in the tree view.  All options are set visually.

Something like this could be done in Leo, but actually I like the opening up leoConfig.leo and setting options in a typical Leo window.  The advantage of leoConfig.leo is that there is plenty of room to explain what each setting does.

Leo's Set Colors and Set Font dialogs can and should affect the settings in leoConfig.leo, but at present they only affect leoConfig.txt, which is most annoying, and basically wrong.

This morning I realized that a large part of Leo's difficulties with configuration options stems from me trying to work around the limitations of Python's ConfigParser module.  Relying on this module may be the worst mistake I have made in the Python version of Leo.  This mistake has had several ramifications:

-  leoConfig.leo uses @root trees rather than @file trees because ConfigParser deletes all comments when writing leoConfig.txt.  Suppose instead that Leo would read and write leoConfig.txt without the "help" of the ConfigParser module.  For reading, all that is needed is that Leo parse leoConfig.txt into a single configuration dictionary.  This would, in fact, be very easy to do.

- Leo needs to do a better job of ensuring that leoConfig.txt always matches the settings in effect.  This can be done if Leo can _rewrite_ leoConfig.txt as it was (with all comments and especially sentinel lines), merely substituting new settings for old.  This is only slightly harder to do.

Other improvements come to mind, not directly related to the problems with ConfigParser:

- There should be a separate Settings Menu.  This would have the Set Colors and Set Font commands, as well as the following commands: Edit Settings (Same as present Open leoConfig.leo command) and Use Default Settings command (rewrites leoConfig.txt using preset defaults) and possibly Set Default Settings, Apply Settings and Revert Settings commands.

- All classes that use configuration settings should implement a configure method that immediately updates settings to the values just written to leoConfig.txt.  This includes the commands, frame and tree classes, and others.

With this long background, there are two main approaches to improving how Leo handles options:

1. Use a graphical scheme like jEdit does, and dispense with leoConfig.leo entirely.  leoConfig.txt would be the only repository for options.  This graphical scheme would use typical Apply, Revert, OK and Cancel buttons, much like the present Set Colors and Set Font dialogs.

2. Improve how Leo handles leoConfig.leo and leoConfig.txt so that leoConfig.leo can use @file trees and so that settings are _reliably_ updated when the user would expect them to be.

At present, I favor the second scheme.  It is simple to implement, it is the most Leonine, and moreover it allows for full discussion of all options.  True, the graphical way is good looking, but that is about all it has going for it.  I suppose a help feature could be added to the graphical way, but we are talking about a lot of effort for very little real value to the user.

Actually though, the issues of keeping leoConfig.txt up-to-date and of applying settings immediately remain mostly the same regardless of which way is chosen.  In particular, without the "help" of the ConfigParser module Leo could maintain options much more easily.

Anyway, this is how I see matters.  Any comments?

Edward
#@-node:ekr.20031218072017.653:Notes
#@+node:ekr.20031218072017.654:Cleanup prefs code?
I'm not at all sure that it is worthwhile now.
#@nonl
#@-node:ekr.20031218072017.654:Cleanup prefs code?
#@-node:ekr.20031218072017.652:Add settings menu
#@+node:ekr.20031218072017.829:gui interface for plugins manager
@nocolor

Interim design:
    
- use pluginsManager.txt in plugins directory.
    - Load file, scan for non-comment lines whose files are in plugins directory
- load plugins only if they are in pluginsManager.txt
- (later?) do a graphical interface for pluginsManager.txt

Simplest graphical interface:

- Listbox of all files.
- Enable, Disable, Revert, Cancel, OK buttons, Enable All, Disable All.
- Selecting an item in the Listbox enables one of the Enable/Disable buttons
- Selecting OK rewrites the file "in place" without altering comment lines.
- Opening file creates one entry for each .py file in plugins directory.

This is like the Spell-check plugin.
#@nonl
#@-node:ekr.20031218072017.829:gui interface for plugins manager
#@-node:ekr.20041002150740.2:2.  Set config options using dialogs
#@-node:ekr.20031218072017.828:Rewrite the config manager
#@+node:ekr.20031218072017.734:Rewrite (threaded) colorizer to use jEdit language descriptionfiles
#@+node:ekr.20031218072017.735:Option: case insensitive keywords
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2097076
By: nobody

Using Jason's code for Rebol and a visual DIFF, I was able to quickly add the
keywords for the assembler I use. I'm wondering if there is a way to tell Leo
to ignore keyword case -- at the present, each keyword is entered twice. Not
a big problem with modern editors, but it _would_ be nicer...

--Rich
#@-node:ekr.20031218072017.735:Option: case insensitive keywords
#@+node:ekr.20041002112001:Use threaded Colorizer
#@-node:ekr.20041002112001:Use threaded Colorizer
#@-node:ekr.20031218072017.734:Rewrite (threaded) colorizer to use jEdit language descriptionfiles
#@+node:ekr.20041022164727:Rewrite plugins manager core code
#@+node:ekr.20041022164727.1:Specify order of plugins
http://sourceforge.net/forum/message.php?msg_id=2818384

One thing to think about is to have the plugin author be able to specify if the plugin needs to be loaded before or after a set of plugins. Something like: 
 
plugin_signon( __name__, before = ( 'chapters', ), after = ( 'textdance', ) ) 
 
This may assist in ensuring that some plugins with dependencies get loaded right. :)
#@nonl
#@-node:ekr.20041022164727.1:Specify order of plugins
#@-node:ekr.20041022164727:Rewrite plugins manager core code
#@-node:ekr.20040919101448:Major (Must do) 4 + 0
#@+node:ekr.20041001182730:Easy 0 + 7
#@+node:ekr.20041029083459:Remember Import directory
By: Kent Tenney - ktenney
Import to @file request  
2004-10-28 11:27
Howdy, 
 
Please ignore if this is a difficult feature to implement. 
 
File->Import->Import to @file  
always starts in .../leo/src 
 
I would prefer if it opened to the last directory from 
which a file was imported. 
 
I often find myself importing several files from the same area of the directory tree, and repeatedly navigating there from leo/src gets tiresome. 
 
Thanks, 
Kent
#@-node:ekr.20041029083459:Remember Import directory
#@+node:ekr.20041016134312.1:Allow multiple @language directives in a single node
@killcolor

Treat @language like @color: ambiguous nodes (nodes containing more than one
@language directive) should not affect descendent nodes.
#@nonl
#@-node:ekr.20041016134312.1:Allow multiple @language directives in a single node
#@+node:ekr.20041001182730.2:Allow other directive lead-ins besides @
#@-node:ekr.20041001182730.2:Allow other directive lead-ins besides @
#@+node:ekr.20031218072017.801:Zipped .leo files
By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57


Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
#@+node:ekr.20040226092546:Saving .leo files with file compression
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442772
By: ejoy

I made an experiment last night. I replaced the call to open()in leofilecommand.py
with a call to gzip.open().
The LeoPy.leo file saved this way is only 600K! And there is no significant
speed down in saving.

I think it is a good idea to add compression support for load/save .leo files.
When reading or writing file with name ending with ".leo.gz", leo can call gzip
module to uncompress/compress the file, saving a lot of disk space.

What do you think of this?
#@-node:ekr.20040226092546:Saving .leo files with file compression
#@-node:ekr.20031218072017.801:Zipped .leo files
#@+node:ekr.20031218072017.805:Allow other section delims besides << and >>
Maybe the section operator could be customizable, 
I personally prefer the wiki way [[name of section]]. 

@setlink-tag [[ ]] 
#@-node:ekr.20031218072017.805:Allow other section delims besides << and >>
#@+node:ekr.20040918165519:Mark Task & Clone To Task commands
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2415033
By: nobody

Ive been scanning Speed Reams Slash post and the Faq and saw an interesting
usage pattern: Creating a node called a Task and adding cloned nodes to it that
represent that task(I hope that explains it).  I can see myself using this idiom
in the future.  Now my question is does the Task/clone idiom warrant special
commands in Leo?  My basis:

1. Do enough Leo users work with this idiom that making it easier to utilize
would be desirable?  I guess a good rule of thumb might be, if the sequence
of actions occur more frequently than the primitive commands like opening a
file it should be considered.

Maybe a way of doing it:

1. A special mark node as Task command.
2. A Add to lask marked task command, that clones a node and moves that node
into the Task node.
#@nonl
#@-node:ekr.20040918165519:Mark Task & Clone To Task commands
#@+node:ekr.20031218072017.736:Use xml parser to read .leo files
http://www.reportlab.com

import xml.sax
#@-node:ekr.20031218072017.736:Use xml parser to read .leo files
#@-node:ekr.20041001182730:Easy 0 + 7
#@+node:ekr.20041022081937.1:Others 1 + 2
#@+node:ekr.20041007081134:* Convert Leo to Tix
http://sourceforge.net/forum/message.php?msg_id=2792402
By: nobody

- Pmw plays ok with Tix.

- It seems that Tix and Tk can play ok together but the first Toplevel must be
derived from Tix. Something must happen during that initial creation that sets
things up. If Tkinter.Tk() is done first, it appears all bets are off.
#@nonl
#@-node:ekr.20041007081134:* Convert Leo to Tix
#@+node:EKR.20040628085831:@import, @shadow
#@+node:ekr.20040718033104:@shadow
#@-node:ekr.20040718033104:@shadow
#@+node:ekr.20040718032616:@import
#@-node:ekr.20040718032616:@import
#@+node:EKR.20040503160843:@directory-import (Generalization of @import)
#@-node:EKR.20040503160843:@directory-import (Generalization of @import)
#@-node:EKR.20040628085831:@import, @shadow
#@+node:ekr.20040217153407:User customizeable tangling and untangling
#@+node:ekr.20031218072017.803:@template directive?
#@-node:ekr.20031218072017.803:@template directive?
#@+node:ekr.20031218072017.795:Metatags
@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 3.11 todo list & schedule   
2003-02-11 03:25  

Here are some features I'd like to see: 
 
3. Metatags. @sectionname or @savedate are expanded to the appropriate text when saved.

-marshall-  
#@-node:ekr.20031218072017.795:Metatags
#@-node:ekr.20040217153407:User customizeable tangling and untangling
#@-node:ekr.20041022081937.1:Others 1 + 2
#@-node:EKR.20040609091327:To do: 4.3
#@+node:ekr.20041022091645:Top ROTI
ROTI: Return on Time Investment
#@nonl
#@+node:ekr.20041022091645.1:* Find Next Clone command
#@-node:ekr.20041022091645.1:* Find Next Clone command
#@+node:ekr.20041007081134:* Convert Leo to Tix
http://sourceforge.net/forum/message.php?msg_id=2792402
By: nobody

- Pmw plays ok with Tix.

- It seems that Tix and Tk can play ok together but the first Toplevel must be
derived from Tix. Something must happen during that initial creation that sets
things up. If Tkinter.Tk() is done first, it appears all bets are off.
#@nonl
#@-node:ekr.20041007081134:* Convert Leo to Tix
#@+node:ekr.20031218072017.833:Use @file extension by default if no @language
@nocolor

Open discussion
By: jasonic ( Jason Cunliffe ) 
 use of @language   
2003-07-16 03:40  

I am wondering why Leo does not default to just use the file suffix in @file nodes, instead of obliging @language line in in the body pane 

For example any @file ending with a suffix as defined in the language extensions could just default to use those. 

".py" for python 
".r" for rebol 
".as" for actionscript etc.. 

Should anyone need to over-ride those, they could use @language.
#@nonl
#@-node:ekr.20031218072017.833:Use @file extension by default if no @language
#@-node:ekr.20041022091645:Top ROTI
#@+node:ekr.20041022091645.2:Top Big Picture
#@+node:ekr.20041022091645.3:Drive Leo using only keystrokes
#@-node:ekr.20041022091645.3:Drive Leo using only keystrokes
#@+node:ekr.20041022091645.4:Better integration with Emacs/Pymacs
#@+node:ekr.20041022144159:Q: Pymacs bridge
I'm trying to use the Pymacs bridge to add a symbol completion facility to
Emacs's python-mode.  Neither the Python nor Emacs Lisp portions are all
that complex, but I'm having trouble passing a list of strings from Emacs
Lisp into Python.  On the Emacs Lisp side it looks like this:

    (pymacs-load "pycomplete")

    (defun py-complete ()
      (interactive)
      (pycomplete-pycomplete (py-symbol-near-point)
                             (py-find-global-imports)))

(py-find-global-imports) returns a (Lisp) list of strings, e.g.:

    ("import time", "import sys")

On the Python side I have this function:

    def pycomplete(s, imports=None):
        completions = get_all_completions(s, imports)
        dots = s.split(".")
        return os.path.commonprefix([k[len(dots[-1]):] for k in completions])

Unfortunately, the imports arg does not come across as a Python list of
strings (s does come across the bridge as a normal Python string).  Its
repr() prints out like this:

    lisp('("import time")')

What do I need to do to convert that object into a true Python list of
strings?  I'm afraid I don't quite understand the description of the lisp
object in the Pymacs docs.  I tried imports.value() but that just gave me

    (aref pymacs-lisp 0)

Any help appreciated...

Skip
#@nonl
#@-node:ekr.20041022144159:Q: Pymacs bridge
#@+node:ekr.20041022144159.1:A: pymacs-forget-mutability
"""
Proper Emacs Lisp lists, those for which the cdr of last cell is nil, are
normally transmitted opaquely to Python. If pymacs-forget-mutability is
set, or if Python later asks for these to be expanded, proper Emacs Lisp
lists get converted into Python lists, if we except the empty list, which
is always converted as Python None. In the other direction, Python lists
are always converted into proper Emacs Lisp lists.
"""

So, maybe try

    (defun py-complete ()
      (interactive)
      (let ((pymacs-forget-mutability t)) 
	(pycomplete-pycomplete (py-symbol-near-point)
                               (py-find-global-imports))))
#@-node:ekr.20041022144159.1:A: pymacs-forget-mutability
#@-node:ekr.20041022091645.4:Better integration with Emacs/Pymacs
#@+node:ekr.20041022092601:Get more comfortable with Linux/Emacs
#@-node:ekr.20041022092601:Get more comfortable with Linux/Emacs
#@+node:ekr.20041007081134:* Convert Leo to Tix
http://sourceforge.net/forum/message.php?msg_id=2792402
By: nobody

- Pmw plays ok with Tix.

- It seems that Tix and Tk can play ok together but the first Toplevel must be
derived from Tix. Something must happen during that initial creation that sets
things up. If Tkinter.Tk() is done first, it appears all bets are off.
#@nonl
#@-node:ekr.20041007081134:* Convert Leo to Tix
#@+node:ekr.20040329182535.4:Leo + zodb
#@+node:ekr.20041002151816:ZODB docs
#@+node:ekr.20041002151816.1:What is the ZODB?
http://zope.org/Wikis/ZODB/FrontPage/guide/node2.html#SECTION000210000000000000000

1.1 What is the ZODB?

The ZODB is a persistence system for Python objects. Persistent programming
languages provide facilities that automatically write objects to disk and read
them in again when they're required by a running program. By installing the
ZODB, you add such facilities to Python.

#@-node:ekr.20041002151816.1:What is the ZODB?
#@+node:ekr.20041002151816.2:How ZODB Works
2.2 How ZODB Works

The ZODB is conceptually simple. Python classes subclass a persistent.Persistent
class to become ZODB-aware. Instances of persistent objects are brought in from
a permanent storage medium, such as a disk file, when the program needs them,
and remain cached in RAM. The ZODB traps modifications to objects, so that when
a statement such as obj.size = 1 is executed, the modified object is marked as
``dirty.'' On request, any dirty objects are written out to permanent storage;
this is called committing a transaction. Transactions can also be aborted or
rolled back, which results in any changes being discarded, dirty objects
reverting to their initial state before the transaction began.

#@-node:ekr.20041002151816.2:How ZODB Works
#@+node:ekr.20041002151816.3:Rules for Writing Persistent Classes
2.6 Rules for Writing Persistent Classes

Practically all persistent languages impose some restrictions on programming
style, warning against constructs they can't handle or adding subtle semantic
changes, and the ZODB is no exception. Happily, the ZODB's restrictions are
fairly simple to understand, and in practice it isn't too painful to work around
them.

The summary of rules is as follows:

* If you modify a mutable object that's the value of an object's attribute, the
ZODB can't catch that, and won't mark the object as dirty. The solution is to
either set the dirty bit yourself when you modify mutable objects, or use a
wrapper for Python's lists and dictionaries (PersistentList, PersistentMapping)
that will set the dirty bit properly.

* Recent versions of the ZODB allow writing a class with __setattr__ ,
__getattr__, or __delattr__ methods. (Older versions didn't support this at
all.) If you write such a __setattr__ or __delattr__ method, its code has to set
the dirty bit manually.

* A persistent class should not have an __del__ method. The database moves
objects freely between memory and storage. If an object has not been used in a
while, it may be released and its contents loaded from storage the next time it
is used. Since the Python interpreter is unaware of persistence, it would call
the __del__ each time the object was freed.
#@nonl
#@-node:ekr.20041002151816.3:Rules for Writing Persistent Classes
#@-node:ekr.20041002151816:ZODB docs
#@+node:ekr.20031218072017.404:LeoN, Zope & collaboration info
@nocolor
#@nonl
#@+node:ekr.20031218072017.405:Kent Tenny Notes
@nocolor

Outlook: server for email, addresses & calendar.  Groupware.  Chandler similar.

Zope: back end is ZODB.  Zope like an OS: run Python code on Zope.

Zope: another way to access Leo files.  Maybe twisted is better?

Wiki anology: edit Leo files with browser.  Write through the web.

longrun.org

Wiki principles: 
	- Sharing is 90% of collaboration.
	- Zope: Subscribe to a wiki: email when page changes.
	- RSS: xml that defines piece of info(tile,url,abstract)
		- Client has a list of rss feeds: an xml file.
		- List of intesting people: notified when they say something.

Two goals:
	- publish Leo files
	- edit Leo files

Brother needs cvs.
Kent not so worried about cvs.
	-Leo file is a web site!
	- Helper layer between user and OS.
		- Look at aap project.  Author of vim. a-p.org
			- Replacement for make in Python.  Automating tool.
		- Expert prepares Leo file.  User uses it.
#@nonl
#@-node:ekr.20031218072017.405:Kent Tenny Notes
#@+node:ekr.20031218072017.406:url's
#@+node:ekr.20031218072017.407:@url http://24.243.129.68:8080/members/sandbox
#@-node:ekr.20031218072017.407:@url http://24.243.129.68:8080/members/sandbox
#@+node:ekr.20031218072017.408:@url http://www.zopelabs.com/cookbook
#@-node:ekr.20031218072017.408:@url http://www.zopelabs.com/cookbook
#@+node:ekr.20031218072017.409:@url http://zwiki.org/FrontPage  Zope implementation of wiki
#@-node:ekr.20031218072017.409:@url http://zwiki.org/FrontPage  Zope implementation of wiki
#@-node:ekr.20031218072017.406:url's
#@+node:ekr.20031218072017.410:Collaboration & Sharing
#@+node:ekr.20031218072017.411:From Rodrigo
Developers Forum
By: rodrigo_b ( Rodrigo Benenson ) 
 RE: Leo over the network   
2003-05-10 00:06  
So this is my first proposal: 

Requirements 
-------------------- 

* Read remote outlines. 
** With Leo clients. 
** Over the web. 

* Edit remote outlines. 

* Import remote outlines (retrieve outlines from the web). 

* Synchronize local outlines with remote ones (web to local and local to web). 

* Publish outlines (send outlines to the web). 

* The Leo client have to be keept lighweigth. 

* The Leo remote outline access server should be a lighweigth daemon. 

* This daemon should automagically render HTML from the outlines. 

* The outlines should be editable from the web and via Leo client. 

* Concurency management is must. 

* The remote servers should be included in the leo client as leo nodes (just like leo files, but remotes). 
"@leo-outline leo.server.org:854" 

* By this way I could have access to local server nodes. 
"@leo-outline localhost:854" 

* The remote server should offer one and only one big outline with sub nodes, and so on, and so on... 

* At least the concurency should be managed as "when someone write, all the other ones only can read" 

* It is better if Leo devellop simultaneaously some hypertext/wiki extensions. 

---------------------------- 
End of requeriments 

This requeriments requires a client-server architecture, with basic commands as: 
- Update node 
- Lock/release node 
- Edit outline 
- Download outline 
- Upload outline 

well that is by the moment, I hope that we will be able to create a Finite, clear, requeriments list for this branch of Leo. 

RodrigoB.  

#@-node:ekr.20031218072017.411:From Rodrigo
#@-node:ekr.20031218072017.410:Collaboration & Sharing
#@+node:ekr.20031218072017.412:Zope
#@+node:ekr.20031218072017.413:From Rodrigo re: Zope.
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007586
By: rodrigo_b

z2.py,
>Supposing that that I did find this file, what would I be looking for? 

This is the Main script, the principal program, the code that startup all the
servers, the only python program that make run Zope, it the code called by start.py,
and it is the one to which you pass the command lines.

With the command line you can indicate which services to start up at which ports.
This is IMPORTANT. Also you can enable/disable the Debug mode.

python z2.py --help will give you some infos about what I'm talking about.

In linux the debug or not debug mode, enable the console or daemon mode (that
means 'background task mode').

In windows, I'm not sure that disabling the debug mode will be enough.
I know that at the install time you can setup Zope as a Windows Service, so
it will start automatically every time Windows Startup, and it will not open
a console window.

But first look at the debug mode.

Start.bat give some defaults command lines to z2.py

Webdav,
>What issues are involved in this choice, and why should I care today? 

from www.webdav.org

What is WebDAV? 
Briefly: WebDAV stands for "Web-based Distributed Authoring and Versioning".
It is a set of extensions to the HTTP protocol which allows users to collaboratively
edit and manage files on remote web servers.

For example that means that you can open you Windows Explorer (from your mail
I understand that you work on an MsWindows OS),
tip the url "localhost:%i"%(your webdav port) and you will be able to navigate,
view and edit the Zope Objects just as a normal file system (well, almost).

WebDav is a standard and there are Python implementations. WebDav is support
by  Oscom.

WebDav is cool.
WebDav is the 'highest level tool'.

ZODB,

>Does that mean that gnx's aren't needed with Zope? Could Leo nodes live in
the ZODB?

You have to thinks to ZODB just as what it is: a Persistent Object Database.
Most objects in Zope are Persistents, that mean that their instances do not
die when you shutdown the server.

The ZODB store his data in it own format.
I think that GNX should be keeped.
You have to basic ways to put nodes into Zope.

First: the hard way: create a new Product (Products are something like Zope
plugins) that is based on the Leo code, but were there is no node storage, instead
the node should be Persistents. Then add rendering code to this objects.

Leo node object + Persistence + ZClass + Rendering Code -> Leo Zope node.

Additionaly you should create an Folder like object that should be an 'Leo Outline
Zope Object',  actuating as an Leo nodes container.

This shema is similar to the Zwiki way, with a Zwiki Web and the Zwiki Pages.

Second: Use A zope folder just as Leo manage the @file nodes. Let have simple
DTMLDocuments, edited via WebDav, with <dtml-comments> , and stuff like that.
The Leo import/export that nodes.

RodrigoB.

#@-node:ekr.20031218072017.413:From Rodrigo re: Zope.
#@+node:ekr.20031218072017.414:Clarification from Kent Tenny
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2009081
By: ktenney

Edward,

I don't see ZLeo replacing Leo, rather a method of accessing
Leo files.

When I write, I almost always want it to be web accessable,
so that I can access it from any browser, and so that I can
share it easily. I would like myfile.leo to live
at http://longrun.org/leo/myfile.leo. It can be read and
written to from any browser (according to how permissions are
configured) The page describing how to configure Apache would
be found at http://longrun.org/leo/myfile.leo/Apache/configure
The only requirement to work with Leo files is a browser.

I wouldn't want to lose the capability to edit outside
the browser, using a standalone version of Leo or Zope's
ExternalEditor product. ExternalEditor allows me to click
an icon to open the page I'm viewing in any editor. I could
open it in Leo as a Leo file, or open just the page in
Vim (http://vim.sourceforge.net/index.php)

Zope is ponderous, I think of it as more of a platform
than an application. My understanding of how Zope works
grows slowly, in the mean time my focus is on _products_.
Installing a product in Zope is like installing an application
in Windows or Linux.

One of the most evolved products is Plone/CMF http://plone.org
which is basically a turnkey web site.

twisted http://twistedmatrix.com is a brilliant set of network
programming tools. That's all I know about it.

I'm not sure about Chandler (http://www.osafoundation.org/) 
(they did choose Python and ZODB http://www.osafoundation.org/technology.htm)

You might try subscribing to a Zope mailing list or two
http://www.zope.org/Resources/MailingLists
The community of users and developers is very important to Zope.

Thanks,
Kent
#@-node:ekr.20031218072017.414:Clarification from Kent Tenny
#@+node:ekr.20031218072017.415:From Rodrigo re: ip
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007817
By: rodrigo_b

If zope is running some server then this server will be accesible from your
network if and only if there is no firewall in the way.

The people can access to your services using (normally on internet you do not
have a domain name)

your_ip:the_service_port

Example:
zope http service on port 8080 on your machine.
When  you connect to internet your machine got an extra IP.
Then simple put on the web browser

http://your_conexion_ip:8080

and Tada you will see the root_zope/index_html object rendered intro HTML.

Most of the ISP give you a dinamic IP.
Some companies provides you dinamic IP Domain Name services, allowing to attach
a domain name to your machine dinamically (each time you reconect).

then you can have:

http://leo.edward.com:8080/

The 8080 stuff can be avoied if you setup zope to use the standard port 80 for
HTTP service.

With this in mind you can access ftp

ftp://your_ip_or_domain_name:8021

or webdav, or anything else.
#@-node:ekr.20031218072017.415:From Rodrigo re: ip
#@+node:ekr.20031218072017.416:Other servers
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007832
By: rodrigo_b

I would made a warning.

Zope IT IS NOT the only way to obtain an local HTTP server, pythonic and
flexible.

There is a lot of other way.

Also Zope IT IS NOT THE BEST pythonic http/ftp/webdav or anything server
aviable.

I think that we should define better 

What we want to do?

before choosing the tool.

As I said, I had already used Zope, I choosed it because of very specific features,
but nothing indicate that Zope is the best way to get Leo to the colaborative
network universe.

I think that we should at least consider:
- SimpleHTTPServer
- To take of the Medusa Server from Zope (that is use Zope code in the standard
Leo distribution, avoying dependences)
- Twisted matrix (I had no experience with it, but it looks much more
flexible/powerfull)

Zope provides you a specific framework, you have to match you application to
this framework, Zope (in my opinion) it is not a tool, it's an ambient.

It's seems that Edward it is new in the web oriented software, I think it has
a lot of potencialities and it will benefits Leo devellopment.

Please Edward, look at Zope as an example but not as THE options. Think about
what can be done, what should be done, and then we will take the best tool.

Anyway my opinion:
- SimpleHTTP server: usefull, it is in python, not very eficiente, just http
server	
- Medusa: usefull, very eficiente, just http server...
- Twisted Matrix: very powerfull, fresh comunity, confusing documentation, a
new paradigm, a devellopment tool.
- Zope: powerfull, eficient, comes with battery included, bad documentation,
to very paradigm oriented, the apps have to fit the paradigm, don't believe
all the promises, strong enthousiast comunity, poor web examples.


RodrigoB. 
#@-node:ekr.20031218072017.416:Other servers
#@+node:ekr.20031218072017.417:Is my ip public?
https://sourceforge.net/forum/message.php?msg_id=2007962
By: bwmulder

Since no one else answered this question, let me take a first take on the
question:

If you are connected to the internet, people can use your IP number to connect
to your computer. This IP number is often given dynamically, though some DSL
providers give you fixed IP numbers for an additional fee. If you did not ask
for fixed IP numbers, you probably have an dynamic IP number (I think).

An IP number consist of four digits. A connection to the (example) IP number
111.222.333.444 can by made via the request http://111.222.333.444

If you have a dynamic IP number, and your Internet provider provides you with
some space to publish HTML, you could, via a script, upload your current IP
number dynamically.

You might also consider buying a domain name. In this case, people can use the
domain name to connect to your computer instead of the IP number.

Another consideration are firewalls. Normally, you want a firewall isolating
your computer from attacks from the Internet. I firewall can be some additional
software. I am currently using a router, a piece of hardware, as a firewall.
Windows XP has firewall software build in. You might have to configure your
firewall to let requests for your server go through.

Finally, you might want to check the agreement you entered with your Internet
service provider, if you are allowed to run a server from your connection. It
might become a problem if your server becomes very popular.
#@-node:ekr.20031218072017.417:Is my ip public?
#@+node:ekr.20031218072017.418:Back ends for storing/retrieving nodes: Paul Paterson
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2009279
By: paulpaterson

What I see Zope offering is an alternative way of storing and retrieving nodes.
What you also get for "free" with Zope is concurrent access, security,
http/ftp/webdav access to the same node information etc. The hidden price you
pay is that Zope is big and many users will have other tools which can provide
these facilities also.

So, my thinking is that we can abstract the basic idea (alternative ways of
storing and retrieving node information) into Leo and then let the magic really
happen in the concrete implementation stage.

What does this mean? Well, we could change Leo so that whenever it goes to retrieve
Headline or Body it goes to a Node Server object to do that. The Node Server
object uses whatever method it wants to retrieve or set the information. The
Node server would also be responsible for telling Leo what child nodes an object
has and whether they are clones or not.

The cool part is that we could implement different kinds of Node server to talk
to different back-ends. These can then be thought of as drivers. So we might
have,

- a file system driver where all information is stored in files and directories
- a database driver where the DB stores all information
- an ftp driver
- a Zope driver
- the default Leo driver

People could write a driver to their own back end storage system. 

What is the advantage of this?

Well, the magic really happens in the back-end. If you choose a back end which
supports versioning, security, concurrent working, web access, etc etc then
Leo now supports them. If you choose a back-end which supports dynamic mark-up
or some other fancy stuff then Leo supports it. The key is that Leo doesn't
need to bind itself to any one system to achieve this - the end user can install
the relevant driver, configure the back-end and just go with it.

Paul
#@-node:ekr.20031218072017.418:Back ends for storing/retrieving nodes: Paul Paterson
#@+node:ekr.20031218072017.419:From Paul Paterson
Ok, I'll have a bash in a rough order or when things occurred...


1. Everything is web based. I had the same problem you did. I ran the
thing and said, "ok, so what did it do". Others have pointed you in the
right direction now with visiting http://localhost:8080 and
http://localhost:8080/manage to view the site and mange it respectively.

If you are running WinNT, 2000 or XP you can also run Zope as a service,
which is much more convenient as you don't need the console window open
all the time.


2. Everything in Zope is an object. Ok, you'll see this a lot. The best
thing to do is think "wow, cool" and then forget it again as you
probably wont really see how this helps at all until you get much deeper
into Zope. 


3. DTML allows you to construct web pages by piecing together bits much
like writing a program from functions. In fact you will find DTML is a
lot like tangling Leo's @root nodes. Here's a bit...

<!-- start html -->

<h>DTML allows you to assemble web pages much like Leo tangles
documents</h>

<p>For instance, have a look at how this page is constructed</p>

<dtml-var first_bit>
<dtml-var second_bit>
<dtml-var third_bit>

<!-- end html -->

The <dtml-var name> bit is like a < < name > > directive. It effectively
inserts the object (could be HTML, an image or something more complex)
in the current page. 

To see this snippet in action you can visit my server at
http://24.243.129.68:8080/members/sandbox/index_html

To see the code, visit http://24.243.129.68:8080/members/sandbox/manage
(username=edream, pwd=leo) and then click on the index_html to see the
main DTML. Feel free to mess around in here but please don't publish the
IP address as my ISP doesn't allow servers!


4. There is a lot of power in Zope products. Try going to www.zope.org
and seeing what is available. As an example I put a Wiki in the sandbox
area http://24.243.129.68:8080/members/sandbox/edswiki


5. If you are looking for a good book to begin with then steer clear of
"The Zope Book"! If you don't mind paying then "The book of Zope" is a
much better introduction. When you have read this then "The Zope Book"
will make some sense but really I found this book tremendously hard to
get through.


6. Web standards are very cool! Zope supports FTP. Point your favourite
FTP tool to,

ftp://24.243.129.68:8021/members/sandbox/

Or try using WebDav by creating a network place pointing to

http://24.243.129.68:8080/members/sandbox

You can then use windows explorer or an ftp tool to browse your objects.


7. Everything is an object! I can't do justice to the concept of
Acquisition here but by the time you have messed around with Zope a bit
you should start to see how acquisition starts to make things really
work like classes in Python. 


I realize this isn't very coherent - if I get a spare moment this
weekend I'll knock up a quick demo showing Leo interacting with Zope.

Regards,

Paul
#@-node:ekr.20031218072017.419:From Paul Paterson
#@-node:ekr.20031218072017.412:Zope
#@+node:ekr.20031218072017.420:Jabber
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2016634
By: jasonic

I have been thinking about LeoZopeWiki integration. I am a recovering Zope addict
[1999-2001] :-)  I believe Zope offers a very valuable client and server for
Leo.

I think Ed higlighted the distinction of collboration vs. sharing. So consdering
that re:  Leo and CVS , Leo and Zope, Leo and wikis, I had another idea this
morning..

LEO+JABBER

Jabber is an open XML-based  instant messaging and *presence* system. Although
Jabber is typically used for IM chat, its core designers have a much bigger
vision in mind.

Jabber Software Foundation
http://www.jabber.org/
O'Reilly Book
http://www.oreilly.com/catalog/jabber/
Python Jabber library
http://jabberpy.sourceforge.net/

CVS etc all depend on runing diff on posted static files which are checked in
or out. Clearly valuable, and good for __sharing__ but not so suitable as the
communication paradigm needed for collboration.

Wikis and Zope all suffer from problem of versioning and the time delay and
lack of timely communications to their cobtributors. There is no 'shared state'
or persistence in the collaboration beyond their own files or objectdatabases.

For example if two people want to edit a wiki or Zope site, they have an imeedaiet
problem of knowing whether or not the someone else is working one it already.

Score:
Sharing 1
Collaboration 0

Two  or more people wanting to edit a common project based on Leo have the same
dilemma. They can check the leo file into a wiki, Zope or CVS, but they still
don't have direct communication at teh content level.

score:
Sharing 1
Collaboration 0

PROPOSAL: LeoJabber
1. Integrate a Jabber client into Leo 
2. Add special Leo module to jabberd [Jabber's server daemon]

Leo-based developers could work in direct communication with each other allowing
them to add, edit and comment nodes in a shared le-space, local or remote. Static
publishing via upload/import etc all still apply.

LeoJabber would mean subscribing developers could immediately be aware of changes
and then apply whatever strategy is appropriate for handling them, such as:
 
a. autoUpdate()
b. makeNewNode()
c. runDiffFunctions()
d. notifyPartners()
e. notifyPublic()
etc..

Jabber via its presencing mechanism offers real-time and just-in time communcations.
If you are logged out, then mesages are queued.

An open Jabber message session is actually one long piece of XML data passed
over an XMLSocket :-) Sounds like a great fit for Leo

- All Jabber configs are XML.
- Good smart open source community.
- Similar open embracing philsophy as Leo
- Jabber connects diverse messaging systems., MSN, AOL etc [Most are
close/proprietary, though the trend is toward greater openness and connectivity]
- Many Jabber clients already. There is even one written in Flash so that any
webpage can participate.

Embedding Jabber in Leo would allow 'discussion' threads to  be integrated.
Developers need to bounce idea and notes around just as this forum does. But
often they need to be more provate or more focused on project specifics.
WORKFLOW 
It is important to know  which code is uptodate, but arguably, even *more* important
is to know which people and what discussions are uptodate. And if not, what
their status is. The larger, longer the more global the develpoment office/project,
the more this is true.

IM [instant messaging] are popular largely becuae they offer direct communication
with status feedback to crucial people's workflow:
"off-line", "on-line", "back-soon", "later" etc

Jabber extends this idea to create a platform for any presence application.
That is its long term-goal.

So in a Leo deevlopment project, that presence might apply to adding status
mesages such as
"making changes" "new version" "debugging" "review only" "major re-write"

or perhaps status/presence woudl be used for much lower level Leo-specific
purposes.

"new node"
"cloned to .."
"@file imported"
"version uploaded"
etc

I am not suggesting that Leo forget CVS or file upload storage. But I think
Jabber may truly provide the Missing Link, literally for Leo collaboration.

Jabber Software Foundation
http://www.jabber.org/
O'Reilly Book
http://www.oreilly.com/catalog/jabber/
Python Jabber library
http://jabberpy.sourceforge.net/

hope this makes sense
Jason
#@-node:ekr.20031218072017.420:Jabber
#@-node:ekr.20031218072017.404:LeoN, Zope & collaboration info
#@+node:ekr.20040107064101.5:Zope notes
#@+node:ekr.20040107065006:posting
@nocolor

Yes he's absolutely right -- focus on the ZODB.

..stay alway from ZTP. ZPT, TPZ, CMF, Plone and all that other stuff for now.

I jsut came accross a handy slide show overview from last spring:
http://jace.seacrow.com/tech/zope/blug-zodb

BerkeyDB Storage is cool too and fits Leo well I think. plays nicely wiht ZODB
standalnioe and in Zope.
#@-node:ekr.20040107065006:posting
#@+node:ekr.20040107064854:example Code
from ZODG import FileStorage,DB
from Persistence import Persistent

# Connect to db.
# FileStorage is standard: entire db is stored in a single file.
storage = FileStorage.FileStorage("/tmp/test-filestorage.fs")
db = DB.(storage)
conn = db.open()

# Get the root of the db.
root = conn.root()

# Defining user classes.
class leoData(Persistent):
	pass
	
# Commit or revert.
get_transaction().commit()
get_transaction().abort()
#@nonl
#@-node:ekr.20040107064854:example Code
#@+node:ekr.20040107080609.1:Zshell
@nocolor

By: jasonic ( Jason Cunliffe )
ZShell  
2003-12-31 22:25

Hi, Just another friendly reminder to check out Jerome Alet's ZShell, one of Zope's best kept secrets:

http://www.librelogiciel.com/software/

ZShell : Manipulate the Zope Object DataBase with Unix shell like commands

and also

ZShellScripts : Unifies the Zope notion of Scripts and provides several Script interpreters : Python, Unix shell , Lisp, Perl, PHP, Ruby, and Zope ZShell

Not only for obvious usefullness, but also as a valuable study of Python access to the ZODB.

JAXML is cool too..
http://www.librelogiciel.com/software/jaxml/action_Presentation

- Jason
#@nonl
#@-node:ekr.20040107080609.1:Zshell
#@+node:ekr.20040107064854.1:@url http://zope.org/Products/StandaloneZODB
#@-node:ekr.20040107064854.1:@url http://zope.org/Products/StandaloneZODB
#@+node:ekr.20040107064854.2:@url http://jace.seacrow.com/tech/zope/blug-zodb
#@-node:ekr.20040107064854.2:@url http://jace.seacrow.com/tech/zope/blug-zodb
#@-node:ekr.20040107064101.5:Zope notes
#@+node:ekr.20040117092727.2:using zodb versions
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2379351
By: korakot

If leo use database storage (ZODB or otherwise)
it could scale much better. This will bring us some
possiblity to store all versions of changes to a node
or a tree.

Cloning will then point to a specific version. If there
is no conflict, it can update to a later version when
the primary clone change. If there is a conflict
we can deal with it wisely using 'diff information'
because we have 'all versions' stored.

#@-node:ekr.20040117092727.2:using zodb versions
#@+node:ekr.20040226114127:Zope test
@color

import leoGlobals as g
import ZODB

if 1:
    storage = ZODB.FileStorage.FileStorage(r"c:\prog\zopeTemp\leo.fs") 
    db = ZODB.DB(storage)
    g.es(storage)
    g.es(db)
    db.close()
#@nonl
#@-node:ekr.20040226114127:Zope test
#@+node:ekr.20031218072017.737:Leo & data bases
From: "Scott Chapman" <scott_list@mischko.com>
To: <edreamleo@charter.net>
Sent: Monday, November 10, 2003 11:05 AM
Subject: Enhancement request: Make Leo deal with a database

It would be Way Cool if Leo could deal with psycopg or other DataBase 
API compliant implementations and fetch and store database records.

Details of what I'd like to see:

I'm working on Python source code. I want Leo to pull a source code file 
from a database record built something like this:

filename: text
updated: datetimestamp
code: text

Leo would insert a new record, not update an existing one, each time a 
Save was done, with a more current time stamp.  

When a File Open was requested (i.e. a node on a existing Leo outline 
was being pulled from a database), Leo would fetch the most recent 
time-stamped version only.

I use this same technique for my wiki pages.  It's very easy to 
implement in SQL and works great.

Leo would also need the ability to save the same file to a regular 
python source code file on disk at a specific location, so you'd have 
to be able to put more than one save/load directive in a given node.

This would provide a nice version history and could lead to other Useful 
Things in Leo.

Scott
#@nonl
#@-node:ekr.20031218072017.737:Leo & data bases
#@-node:ekr.20040329182535.4:Leo + zodb
#@-node:ekr.20041022091645.2:Top Big Picture
#@+node:ekr.20040329182535.7:1 hour to 1 day projects
#@+node:ekr.20041022083833:New commands 1
#@+node:ekr.20041022091645.1:* Find Next Clone command
#@-node:ekr.20041022091645.1:* Find Next Clone command
#@+node:ekr.20031218072017.792:Double Click Node command
#@-node:ekr.20031218072017.792:Double Click Node command
#@+node:ekr.20040315060557:Declone command
By: nobody ( Nobody/Anonymous ) 
 having a declone() method for vnodes?   
2004-03-15 04:36  

 hi,

Ive had a use for a declone() method in vnodes recently. Have you ever thought about adding a method that declones a clone? This would entail:

1. Making a clone node a normal node.

I can see this happening when cutting a node and pasting a node that is a clone. But there doesn't seem to be a dedicated function to do the operation. :)  
#@nonl
#@-node:ekr.20040315060557:Declone command
#@+node:ekr.20031218072017.748:Import/Export to yaml
Need a good yaml parser first: I don't want to write another parser by hand.
#@nonl
#@-node:ekr.20031218072017.748:Import/Export to yaml
#@+node:ekr.20040329094003:Apply patch command
#@-node:ekr.20040329094003:Apply patch command
#@-node:ekr.20041022083833:New commands 1
#@+node:ekr.20041022091645.5:New config options 1
#@+node:ekr.20040213090121:* Insert at end
@nocolor

By: tibi ( Thibaut Champenier ) 
 inserting a new node   
2004-02-13 13:23  

 Hi,

When doing ctrl+i I on the node that has children I would prefer Leo to insert the new node as the last children instead of the first. It just makes more sense to me, for exemple when you take a big file and cut it in subnodes you typically start at the top and create new nodes while paging down the file.
What do you think ?
To try it just make this little change:
RCS file: /cvsroot/leo/leo/src/leoCommands.py,v
retrieving revision 1.76
diff -r1.76 leoCommands.py
2516c2516
< v = current.insertAsNthChild(0)
---
> v = current.insertAsLastChild()  
#@nonl
#@-node:ekr.20040213090121:* Insert at end
#@+node:ekr.20040311022923:Make sentinel name in @-node optional
#@-node:ekr.20040311022923:Make sentinel name in @-node optional
#@-node:ekr.20041022091645.5:New config options 1
#@+node:ekr.20041022083833.1:Better commands 1
#@+node:ekr.20031218072017.800:* Enhancements to extract section
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1858824
By: gilshwartz
Open discusstion

Currently Extract Section is only available if the first line in a selection
is a section name <<x>>. I would like to propose a few enhancements I think
should be useful, while I believe most of the code is already implemented in
Leo.

1. If the first line in a selection is not <<x>>, than Extract Section WILL
make a section name from the first line (or a version of it, see below), leave
the section name in the body, create a new node with that section name, and
will copy the selection including the first line to the new node.

Rational: this is useful when selecting a function or a class. Thus the section
name becomes the function or the class definition. The section name can either
be the full first line, or, knowing the language, Leo can make a nice section
name like it does in import, e.g. "function foo", or "class bar", without the
parameters list.

2. Even better, when Extract Section is called WITHOUT a selection it will look
for the first function/class definition before the cursor's position and will
either use it as a selection and do 1 above, or just mark it as selection, which
will enable 1 above upon a second Extract Section.

Rational: Leo does it beautifully in import and when a node's code starts to
build it is most convenient. Also, I think a variation on this was recently
asked by another user.

3. Add an option Merge Section, which when called from a named section will
merge it back to all the sections containing it.

Rational: make it easy (together with 2) to create/delete sections until the
sections picture of a new code becomes clear.

Gil

--

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1859516
By: nobody

Simpler & more intutive:
Mark text, select from menu - 'extract section', this presents a dialog box
in which you fill in the section name. It is too much work to type <<name>>
then select the whole thing...

As an enhancement, the dialog can show the first line of the selection as the
default section name, which obviously can be changed.

- Rajiv Bhagwat
#@-node:ekr.20031218072017.800:* Enhancements to extract section
#@+node:ekr.20041022083005.3:@path and other directives accept python expressions
#@-node:ekr.20041022083005.3:@path and other directives accept python expressions
#@+node:ekr.20031218072017.740:Disallow writes outside a "top-level" folder
1. Warn when creating _any_ new file.

2. Warn when rewriting any file that was not read properly.

This prevents "hijacking" an already existing file.
#@nonl
#@-node:ekr.20031218072017.740:Disallow writes outside a "top-level" folder
#@+node:ekr.20040217090833:Change how Open with works?
By: rogererens ( Roger Erens ) 
 RE: Documentation for 4.1rc3   
2004-02-04 10:04  

@nocolor

It is stated that you can edit the temporary file with the editor as named in the "Open with..." submenu.
However, the temporary files are edited with the application that is associated with their extension. In my case I always fire up vim with .txt-files.

Hence the menu item would be better called something like "Open as..." with submenu items like ".doc file" or ".txt file"

Or, use something else instead of "os.startfile" to really use the intended editor.
#@nonl
#@-node:ekr.20040217090833:Change how Open with works?
#@+node:ekr.20041022083005.8:Catch mixed tab & space in derived files
add python -t to test suite to catch mixed tab & space in derived files.
#@nonl
#@-node:ekr.20041022083005.8:Catch mixed tab & space in derived files
#@+node:ekr.20031218072017.754:Open text files in text window
#@-node:ekr.20031218072017.754:Open text files in text window
#@-node:ekr.20041022083833.1:Better commands 1
#@+node:ekr.20041022083226:Better directives 1
#@+node:ekr.20031218072017.833:Use @file extension by default if no @language
@nocolor

Open discussion
By: jasonic ( Jason Cunliffe ) 
 use of @language   
2003-07-16 03:40  

I am wondering why Leo does not default to just use the file suffix in @file nodes, instead of obliging @language line in in the body pane 

For example any @file ending with a suffix as defined in the language extensions could just default to use those. 

".py" for python 
".r" for rebol 
".as" for actionscript etc.. 

Should anyone need to over-ride those, they could use @language.
#@nonl
#@-node:ekr.20031218072017.833:Use @file extension by default if no @language
#@+node:ekr.20031218072017.745:@@first <n>
@nocolor

Hate to break into the grand design discussions, but here's a hopefully small thing. If you need to place a good sized copyright statement at the top of your files, LEO doesn't handle this case very cleanly. As I'm sure you're aware, you wind up with a matching number of @@first lines for each leading line in your source. 

As an example: 
# 1 
# 2 
# 3 
# 4 
# 5 
#@verbatim
#@+leo 
#@verbatim
#@+node:0::@file /tmp/firstcheck.py 
#@verbatim
#@+body 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@+doc 
# 
# How many firsts do I get? 

#@verbatim
#@-doc 
#@verbatim
#@@c 
Start code. 
#@verbatim
#@-body 
#@verbatim
#@-node:0::@file /tmp/firstcheck.py 
#@verbatim
#@-leo 

My fellow co-workers who don't use LEO, aren't exactly loving me here. 

Might we introduce an: 

@@first <num> 

Type tag instead? So one '@@first 5' could represent all 5 of the above @@first lines? It makes for a smaller, cleaner LEO footprint and will tick off non-LEO users much less. 

Thanks. 

- ordinarius 
#@nonl
#@-node:ekr.20031218072017.745:@@first <n>
#@+node:ekr.20031218072017.807:Put up file dialog on empty @url, etc.
@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2003457
By: dsalomoni

Proposal: modify the code for @url so that if you type for example just "@url"
(no file specified) in a headline, a window pops up allowing you to browse the
local file system and select the file (similar to what browsers do when you
want to open a file).

This would be more convenient than manually writing @url
file://a/long/path/to/the/file. @read-only nodes already allow this, it would
perhaps be nice if all these types of plugins (@folder might be another one
for example) and directives (@file etc) had the same behavior (and this should
probably be specified in some guidelines for writing new plugins -see e.g. the
jedit plugin guidelines).

Davide
#@-node:ekr.20031218072017.807:Put up file dialog on empty @url, etc.
#@+node:ekr.20040217154134:XML as a @language
#@-node:ekr.20040217154134:XML as a @language
#@+node:ekr.20031218072017.797:Allow @file http & @file ftp
I'd like to see leo's @file can be extended to cover more protocols, like REBOL's "read" does. 

in short, it would be very sweet if the following work: 

@file http://www.somedomain.org/python/foo.py 

@file pass@ftp.sd.org/python/foo.py" target="_blank" target="_new">ftp://user:pass@ftp.sd.org/python/foo.py> 

while we are at it, what about xmlrpc/soap? 

should there be new directive, like @source ?
#@nonl
#@+node:ekr.20031218072017.810:Remote access Scott Powell
I will wait. Here's clarification, when you're ready for it:

All of my projects are stored on remote computers, and accessed via FTP. 
What I want is basically the ability to open up these projects directly 
through leo, instead of transferring the files manually between my computer 
and the computers that hold my projects, preferably through FTP.

My solution: A new menu item called 'FTP' or 'Remote'. Click on this, and an 
FTP dialog opens up, with an empty list of FTP sites, and the ability to add 
more. You select a site, and it brings up a list of files. You select a 
file, and it is added to your project. When you hit 'save', it automatically 
does an FTP send.

Python makes this a lot easier with the builtin module 'ftplib'. I'm sure 
there are similar things for C++. I hope you take this idea into 
consideration.

Scott Powell
CEO, Dev Designs
#@-node:ekr.20031218072017.810:Remote access Scott Powell
#@-node:ekr.20031218072017.797:Allow @file http & @file ftp
#@-node:ekr.20041022083226:Better directives 1
#@+node:ekr.20041022083833.2:Better dialogs
#@+node:ekr.20031218072017.790:Import dialog improvements
@nocolor

Other options I though would be really handy:

1. Use an existing node as a source also

2. Use an node from another Leo file.. I am not sure what the syntax for that
would be exactly

3. From a URL.. this would be really cool. People could post outlines not only
as existing Leo xml files, but as text files or even dynamic scripts. The code
to handle these would presumably need to deal with http:// intelligently. But
that's easy in Python. Rebol is great at that too.

4. Other XML file with valid filepaths in them.
That's probably a much bigger project like Leo 3.10  

Jason
#@-node:ekr.20031218072017.790:Import dialog improvements
#@-node:ekr.20041022083833.2:Better dialogs
#@+node:ekr.20041022083226.1:Better plugins
#@-node:ekr.20041022083226.1:Better plugins
#@+node:ekr.20041022083226.2:Better scripting 2
#@+node:ekr.20031218072017.733:* Execute scripts like IDE's do
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2321235
By: paulpaterson

I think I understand what Samir is getting at. 

In PythonWin, or other IDE's for other languages, you are able to execute the
"current program" in a way that it will behave identically to if it had been
run from the command line.

For Python this requires,

1. That the script run with __name__ == "__main__", so that the standard "if
__name__ ..." section will be executed properly.

2. You are able to pass command line parameters to the script. In some IDE's
you are able to set default command line parameters and these are "injected"
into the sys.argv (or equivalent) so that, as far as the program is concerned,
it looks like you ran it from the command line with some aruments.

The underlying assumption is that you want to run an entire program from Leo,
not just a script. I would find this very useful also as I could run unit tests
or even my entire apps by just hitting, for exampe, F5.

Paul
#@nonl
#@+node:ekr.20041022083005.5:Define name == "__main__"
#@-node:ekr.20041022083005.5:Define name == "__main__"
#@-node:ekr.20031218072017.733:* Execute scripts like IDE's do
#@+node:ekr.20041022083005.6:* Allow parameters to scripts
#@-node:ekr.20041022083005.6:* Allow parameters to scripts
#@+node:EKR.20040611081747.1:Look at windows scripting
------cut openleo.pys
@path c:\bIn\pys\
@lineending crnl
@
w04609p09:57:19 a pys to open leo and do something.
you need the win32 extensions and you have to enable 
the script engine. details how on google or on the win32 page.

the sendkeys method can insert any test or control codes
msdn or microsoft.com/scripting

@c
pypath = r'C:\c\py\Python233'
py =  pypath + r'\python.exe -itOO '
leosrc = r'c:\c\leo\leo4CVS233\src'
name = "blank.leo"

WshShell = WScript.CreateObject("WScript.Shell")

#look like it comes up untitled 
# if it cant find an existing leo of that name?

WshShell.Run(py + leosrc + r'\Leo.py ../' + name)
WScript.Sleep(4900) 

wname = "untitled"

WshShell.AppActivate(wname);  WScript.Sleep(2100)
WshShell.SendKeys("%Fe");   WScript.Sleep(1300);  #^Q

---end openleo.pys
#@nonl
#@-node:EKR.20040611081747.1:Look at windows scripting
#@+node:EKR.20040422132037.7:Problems with run script command on Mac x11
Jon Schull <jschull@softlock.com>  
Date:  2003/12/30 Tue PM 05:50:51 EST 
To:  edreamleo@charter.net 
Subject:  Leo, Mac OS X 10.3, and VPython 
             
I've been evaluating leo or vpython programming on  Mac OS X 10.3, and 
have some observations and a suggestion.

Observations.
        Leo runs under X11 as well as under OS X.
        My X11 python configuration was created using the recipe at XXX 
(which enables vpython).
        The OS X configuration is vanilla MacPython from MacPython.org, along 
with AquaTclTk batteries included XXX.
        In both environments I can run leo under python leo.py and under idle.
        Under OS X we get font smoothing, but we can't run visual python 
programs (python crashes;  this is a known incompatibility with 
MacPython.)
    
        Under X11 we can run visual python programs like this one
            #box.py
            from visual import *
            box()
            
    And we can even run them under leo (under X11). HOWEVER, when the 
visual python program is terminated, leo vanishes (leo and the vp 
program apparently run in the same space)
    
    Under x11, we can keep leo alive by putting the vp program in its own 
space:
    
        os.popen3('/sw/bin/python /Users/jis/box.py')
    
    However,  this doesn't let us see the output of stderr and stdout.  
Those text streams are available...
        
        def do(cmd='ls'):
            from os import popen3
            pIn,pOut,pErr=0,1,2
            popenResults=popen3(cmd)
            print popenResults[pOut].read()
            print popenResults[pErr].read()
        
        import os	
        do('/sw/bin/python /Users/jis/box.py')
        
    ...but only when the vpython program terminates.
    
    Here's the good news:  if we execute our vp program with 
/sw/bin/idle.py rather than with python, we get to see the program 
output in real time (under idle, under X11).
    
        import os	
        os.chdir('/sw/lib/python2.3/idlelib')
        os.popen3('/sw/bin/python idle.py -r /Users/jis/box.py')
        
        #this runs as an executed script in leo, and produces a live idle 
with real time ongoing output.
    
    Now, while idle is running, leo sits in suspended animation.  But when 
the vpython program terminates, we are left in idle, and when idle is 
terminated, leo becomes active again.
    
    It would be even better if leo were not suspended (using os.spawn, 
perhaps) but the real point is that I would really really like leo's 
"Execute script" command to execute code this way and spare me having 
to  hard-write the path to box.py.  It ought to be possible to 
eliminate os.chdir as well.

------------------
Jon Schull, Ph.D.
Associate Professor
Information Technology
Rochester Institute of Technology
schull@digitalgoods.com 585-738-6696
#@-node:EKR.20040422132037.7:Problems with run script command on Mac x11
#@-node:ekr.20041022083226.2:Better scripting 2
#@+node:ekr.20041022083226.3:Better windows
#@+node:ekr.20041022083005.2:add a Stop button for find/change
#@-node:ekr.20041022083005.2:add a Stop button for find/change
#@+node:ekr.20041022083005.4:insert/overstrike mode in body
#@-node:ekr.20041022083005.4:insert/overstrike mode in body
#@+node:ekr.20041022083005.7:Tabbed log/Find/config window
#@-node:ekr.20041022083005.7:Tabbed log/Find/config window
#@+node:ekr.20031218072017.746:Minimizing/maximizing windows
@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2090601
By: jasonic

I'll be happy to run some test and report to you. But  I suspect from your post
a slight misunderstanding about Alt+Tab.

Alt+Tab just toggles the active window.
It works fine with Leo on Windows wherver I have tried it.

Resizing wondows via hotkeys is another matter.
The special "Windows" Key + m will minimize all windows. 

But unfortunately I've not yet discovered any opposite shortcut to  maximize
all windows :-(
I've tried various 3rd party hotkey utililties, but somehow always end up dropping
them.

<rant>
I really hate wasting any time dragging windows around and resizing them or
clicking to bring them into top focus. As I work mainly with graphics, and mult-task
intesenlty bwetn apps,  it is especially important to reduce visual clutter
on screen.

For many years the way to do this has been combining maximized [or minimized]
windows with  Alt+Tab. Alt+Tab  lets one jump rapidly betwen open apps and windows
without ever need to repostion or resize them.

As a consultant, its one of the first things I ever teach clients. Often it
transforms their perception of using Windows.

It is so painful to watch people dragging and rescaling  windows all over the
place. Ironically, I've witnessed some very smart programmers fly through vi
or emacs but then slow to tortoises when navigation mice and windows. I beleive
as long as we have the curertn wnidows UI paradigm,  use of Alt+Tab is an essential
part of  GUI 'litteracy' - an essentail skill all shoudl have. Alas its still
little known or discussed.

There is also a nice toggle feature so one can jump back to the last app/window
as its first "stop". Typically one is working between two apps for some specific
task, even though many are open.

Keeping one's finger on the 'Alt' key then tapping 'Tab' lets one hop along
the list.

Adding 'shift' to the mix helps one to go in reverse. 

Above all one can keep one hand on the mouse, the other on the keyboard [ALt+Tab]
and ones mind/eye on teh screen. For me it means left hand "plays" the bass
pattern using Alt+Tab along with the clipboard shortcuts [CTRL+ z,x,c,v] ,while
right hand on the mouse mouse  provides the melody.

I've been using variations on the above since 1987 when I bought an Amiga2000.
I seem to recall SGI had one also. And after learning about Alt+Tab on windows,
I  found a utility to work the same way on Macintosh.  I am very happy to discover
that MacOSX now has built-in ALt+Tab :-)
</rant>

Meanwhile, Iam  still wondering how to set Leo [3.12 beta 1, Python 2.2.2, Tk
8.3.2] default to a maxmimized or minimized window size by itself.

And also to remember the last size/position it had. I vaguely remember that
it used to do that, but perhaps I am mistaking it for some other software ?

thanks
Jason
#@-node:ekr.20031218072017.746:Minimizing/maximizing windows
#@+node:ekr.20031218072017.852:Scroll improvement
@nocolor

By: jwashin ( James Washington ) 
 Scrolling and the Tree Frame in Linux   
2003-10-20 12:13  

I'm using tk-8.4.3, python-2.2.3 on linux. The MouseWheel events do not work for me in the Tree Frame.

I added <Button-4> and <Button-5> bindings similar to the existing <MouseWheel> binding in LeoFrame.finishCreate(), associating them with two methods, LeoFrame.OnMouseScrollDown and LeoFrame.OnMouseScrollUp that took the appropriate parts of OnMouseWheel()

Now it works, sort-of. It scrolls properly unless the cursor is an I-Bar, e.g., over text. But at least this removes in-part the most glaring UI problem for me with Leo in tk. I suppose I am spoiled with the mouse wheel and want it to work everywhere.

Thanks for the great program.

-- Jim Washington  
#@-node:ekr.20031218072017.852:Scroll improvement
#@+node:ekr.20040220110030:Change cursor when caps lock is down
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2431552
By: nobody

From: Rich

 I just got nipped twice by the following effect: the Caps-Lock key is ON, but
because the LED is on the Caps-Lock key, it is hidden behind my hand. I hit
Ctrl-x, expecting to cut my selection, but the entire node is cut.

   I know there's a problem with tk and the shift key status, so I'm wondering
if it would be possible to change the shape of the cursor when the Caps-Lock
is ON (preferrably a big red flashing blot 8-), or otherwise show that Caps-Lock
is active ( "CAPS" on a status line, for instance).

  Another way: I don't know if this goes against an "anti-modalism rule," but
only allowing Ctrl-Shift-x|c|v in the outline pane would also be acceptable
to me.
#@nonl
#@-node:ekr.20040220110030:Change cursor when caps lock is down
#@+node:ekr.20040908104644:Leo splash screen
To create a splash screen:
    
- Draw the screen.
- Erase the screen with self.after(5000, self.destroy)
#@+node:ekr.20040908221501:@url http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/120687
#@-node:ekr.20040908221501:@url http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/120687
#@-node:ekr.20040908104644:Leo splash screen
#@+node:ekr.20031218072017.793:Keep right panes constant when tiling horizontally (Tix)
This is done automatically now!  I may have to use configure events.

> When I have the 'split mode' set to display tree and log on left, and viewpane
on right, I sometimes need to increase the width of the window.

When I do the resize, the tree/log panes grow in proportion. I don't know about
others, but I'd much prefer if the tree/log panes stayed at the same width,
and only the view pane grew.
#@-node:ekr.20031218072017.793:Keep right panes constant when tiling horizontally (Tix)
#@+node:EKR.20040517090625.1:@url http://komodo.nique.net/~grayrest/leoUIproposal.txt
#@-node:EKR.20040517090625.1:@url http://komodo.nique.net/~grayrest/leoUIproposal.txt
#@+node:ekr.20031218072017.743:Note windows (plugin)
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2205285
By: nobody

From: Rich

Some of the things I'd like to see in Leo:

A note window for each node. This is similar to (1), but a little fancier
looking. I envision a short window at the bottom of the edit window that could
hold notes and comments about the code, such as "Test this harder" or "Find
a better way of phrasing this". This is currently available in uSoft Office
and the Eclipse IDE (http://www.eclipse.org). Perhaps a numeric reference, such
as "<<1>>" could be used.

(2) Color ''and'' italic/bold characters with @markup. One thing I'd like to
''not'' see are the markup characters in @file-nosent files.  "~~red:NOTE:~~"
does nothing for readability in plain text.
#@nonl
#@-node:ekr.20031218072017.743:Note windows (plugin)
#@-node:ekr.20041022083226.3:Better windows
#@-node:ekr.20040329182535.7:1 hour to 1 day projects
#@+node:ekr.20040329182535.3:2 day to 2 week projects
#@+node:ekr.20040329182535.4:Leo + zodb
#@+node:ekr.20041002151816:ZODB docs
#@+node:ekr.20041002151816.1:What is the ZODB?
http://zope.org/Wikis/ZODB/FrontPage/guide/node2.html#SECTION000210000000000000000

1.1 What is the ZODB?

The ZODB is a persistence system for Python objects. Persistent programming
languages provide facilities that automatically write objects to disk and read
them in again when they're required by a running program. By installing the
ZODB, you add such facilities to Python.

#@-node:ekr.20041002151816.1:What is the ZODB?
#@+node:ekr.20041002151816.2:How ZODB Works
2.2 How ZODB Works

The ZODB is conceptually simple. Python classes subclass a persistent.Persistent
class to become ZODB-aware. Instances of persistent objects are brought in from
a permanent storage medium, such as a disk file, when the program needs them,
and remain cached in RAM. The ZODB traps modifications to objects, so that when
a statement such as obj.size = 1 is executed, the modified object is marked as
``dirty.'' On request, any dirty objects are written out to permanent storage;
this is called committing a transaction. Transactions can also be aborted or
rolled back, which results in any changes being discarded, dirty objects
reverting to their initial state before the transaction began.

#@-node:ekr.20041002151816.2:How ZODB Works
#@+node:ekr.20041002151816.3:Rules for Writing Persistent Classes
2.6 Rules for Writing Persistent Classes

Practically all persistent languages impose some restrictions on programming
style, warning against constructs they can't handle or adding subtle semantic
changes, and the ZODB is no exception. Happily, the ZODB's restrictions are
fairly simple to understand, and in practice it isn't too painful to work around
them.

The summary of rules is as follows:

* If you modify a mutable object that's the value of an object's attribute, the
ZODB can't catch that, and won't mark the object as dirty. The solution is to
either set the dirty bit yourself when you modify mutable objects, or use a
wrapper for Python's lists and dictionaries (PersistentList, PersistentMapping)
that will set the dirty bit properly.

* Recent versions of the ZODB allow writing a class with __setattr__ ,
__getattr__, or __delattr__ methods. (Older versions didn't support this at
all.) If you write such a __setattr__ or __delattr__ method, its code has to set
the dirty bit manually.

* A persistent class should not have an __del__ method. The database moves
objects freely between memory and storage. If an object has not been used in a
while, it may be released and its contents loaded from storage the next time it
is used. Since the Python interpreter is unaware of persistence, it would call
the __del__ each time the object was freed.
#@nonl
#@-node:ekr.20041002151816.3:Rules for Writing Persistent Classes
#@-node:ekr.20041002151816:ZODB docs
#@+node:ekr.20031218072017.404:LeoN, Zope & collaboration info
@nocolor
#@nonl
#@+node:ekr.20031218072017.405:Kent Tenny Notes
@nocolor

Outlook: server for email, addresses & calendar.  Groupware.  Chandler similar.

Zope: back end is ZODB.  Zope like an OS: run Python code on Zope.

Zope: another way to access Leo files.  Maybe twisted is better?

Wiki anology: edit Leo files with browser.  Write through the web.

longrun.org

Wiki principles: 
	- Sharing is 90% of collaboration.
	- Zope: Subscribe to a wiki: email when page changes.
	- RSS: xml that defines piece of info(tile,url,abstract)
		- Client has a list of rss feeds: an xml file.
		- List of intesting people: notified when they say something.

Two goals:
	- publish Leo files
	- edit Leo files

Brother needs cvs.
Kent not so worried about cvs.
	-Leo file is a web site!
	- Helper layer between user and OS.
		- Look at aap project.  Author of vim. a-p.org
			- Replacement for make in Python.  Automating tool.
		- Expert prepares Leo file.  User uses it.
#@nonl
#@-node:ekr.20031218072017.405:Kent Tenny Notes
#@+node:ekr.20031218072017.406:url's
#@+node:ekr.20031218072017.407:@url http://24.243.129.68:8080/members/sandbox
#@-node:ekr.20031218072017.407:@url http://24.243.129.68:8080/members/sandbox
#@+node:ekr.20031218072017.408:@url http://www.zopelabs.com/cookbook
#@-node:ekr.20031218072017.408:@url http://www.zopelabs.com/cookbook
#@+node:ekr.20031218072017.409:@url http://zwiki.org/FrontPage  Zope implementation of wiki
#@-node:ekr.20031218072017.409:@url http://zwiki.org/FrontPage  Zope implementation of wiki
#@-node:ekr.20031218072017.406:url's
#@+node:ekr.20031218072017.410:Collaboration & Sharing
#@+node:ekr.20031218072017.411:From Rodrigo
Developers Forum
By: rodrigo_b ( Rodrigo Benenson ) 
 RE: Leo over the network   
2003-05-10 00:06  
So this is my first proposal: 

Requirements 
-------------------- 

* Read remote outlines. 
** With Leo clients. 
** Over the web. 

* Edit remote outlines. 

* Import remote outlines (retrieve outlines from the web). 

* Synchronize local outlines with remote ones (web to local and local to web). 

* Publish outlines (send outlines to the web). 

* The Leo client have to be keept lighweigth. 

* The Leo remote outline access server should be a lighweigth daemon. 

* This daemon should automagically render HTML from the outlines. 

* The outlines should be editable from the web and via Leo client. 

* Concurency management is must. 

* The remote servers should be included in the leo client as leo nodes (just like leo files, but remotes). 
"@leo-outline leo.server.org:854" 

* By this way I could have access to local server nodes. 
"@leo-outline localhost:854" 

* The remote server should offer one and only one big outline with sub nodes, and so on, and so on... 

* At least the concurency should be managed as "when someone write, all the other ones only can read" 

* It is better if Leo devellop simultaneaously some hypertext/wiki extensions. 

---------------------------- 
End of requeriments 

This requeriments requires a client-server architecture, with basic commands as: 
- Update node 
- Lock/release node 
- Edit outline 
- Download outline 
- Upload outline 

well that is by the moment, I hope that we will be able to create a Finite, clear, requeriments list for this branch of Leo. 

RodrigoB.  

#@-node:ekr.20031218072017.411:From Rodrigo
#@-node:ekr.20031218072017.410:Collaboration & Sharing
#@+node:ekr.20031218072017.412:Zope
#@+node:ekr.20031218072017.413:From Rodrigo re: Zope.
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007586
By: rodrigo_b

z2.py,
>Supposing that that I did find this file, what would I be looking for? 

This is the Main script, the principal program, the code that startup all the
servers, the only python program that make run Zope, it the code called by start.py,
and it is the one to which you pass the command lines.

With the command line you can indicate which services to start up at which ports.
This is IMPORTANT. Also you can enable/disable the Debug mode.

python z2.py --help will give you some infos about what I'm talking about.

In linux the debug or not debug mode, enable the console or daemon mode (that
means 'background task mode').

In windows, I'm not sure that disabling the debug mode will be enough.
I know that at the install time you can setup Zope as a Windows Service, so
it will start automatically every time Windows Startup, and it will not open
a console window.

But first look at the debug mode.

Start.bat give some defaults command lines to z2.py

Webdav,
>What issues are involved in this choice, and why should I care today? 

from www.webdav.org

What is WebDAV? 
Briefly: WebDAV stands for "Web-based Distributed Authoring and Versioning".
It is a set of extensions to the HTTP protocol which allows users to collaboratively
edit and manage files on remote web servers.

For example that means that you can open you Windows Explorer (from your mail
I understand that you work on an MsWindows OS),
tip the url "localhost:%i"%(your webdav port) and you will be able to navigate,
view and edit the Zope Objects just as a normal file system (well, almost).

WebDav is a standard and there are Python implementations. WebDav is support
by  Oscom.

WebDav is cool.
WebDav is the 'highest level tool'.

ZODB,

>Does that mean that gnx's aren't needed with Zope? Could Leo nodes live in
the ZODB?

You have to thinks to ZODB just as what it is: a Persistent Object Database.
Most objects in Zope are Persistents, that mean that their instances do not
die when you shutdown the server.

The ZODB store his data in it own format.
I think that GNX should be keeped.
You have to basic ways to put nodes into Zope.

First: the hard way: create a new Product (Products are something like Zope
plugins) that is based on the Leo code, but were there is no node storage, instead
the node should be Persistents. Then add rendering code to this objects.

Leo node object + Persistence + ZClass + Rendering Code -> Leo Zope node.

Additionaly you should create an Folder like object that should be an 'Leo Outline
Zope Object',  actuating as an Leo nodes container.

This shema is similar to the Zwiki way, with a Zwiki Web and the Zwiki Pages.

Second: Use A zope folder just as Leo manage the @file nodes. Let have simple
DTMLDocuments, edited via WebDav, with <dtml-comments> , and stuff like that.
The Leo import/export that nodes.

RodrigoB.

#@-node:ekr.20031218072017.413:From Rodrigo re: Zope.
#@+node:ekr.20031218072017.414:Clarification from Kent Tenny
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2009081
By: ktenney

Edward,

I don't see ZLeo replacing Leo, rather a method of accessing
Leo files.

When I write, I almost always want it to be web accessable,
so that I can access it from any browser, and so that I can
share it easily. I would like myfile.leo to live
at http://longrun.org/leo/myfile.leo. It can be read and
written to from any browser (according to how permissions are
configured) The page describing how to configure Apache would
be found at http://longrun.org/leo/myfile.leo/Apache/configure
The only requirement to work with Leo files is a browser.

I wouldn't want to lose the capability to edit outside
the browser, using a standalone version of Leo or Zope's
ExternalEditor product. ExternalEditor allows me to click
an icon to open the page I'm viewing in any editor. I could
open it in Leo as a Leo file, or open just the page in
Vim (http://vim.sourceforge.net/index.php)

Zope is ponderous, I think of it as more of a platform
than an application. My understanding of how Zope works
grows slowly, in the mean time my focus is on _products_.
Installing a product in Zope is like installing an application
in Windows or Linux.

One of the most evolved products is Plone/CMF http://plone.org
which is basically a turnkey web site.

twisted http://twistedmatrix.com is a brilliant set of network
programming tools. That's all I know about it.

I'm not sure about Chandler (http://www.osafoundation.org/) 
(they did choose Python and ZODB http://www.osafoundation.org/technology.htm)

You might try subscribing to a Zope mailing list or two
http://www.zope.org/Resources/MailingLists
The community of users and developers is very important to Zope.

Thanks,
Kent
#@-node:ekr.20031218072017.414:Clarification from Kent Tenny
#@+node:ekr.20031218072017.415:From Rodrigo re: ip
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007817
By: rodrigo_b

If zope is running some server then this server will be accesible from your
network if and only if there is no firewall in the way.

The people can access to your services using (normally on internet you do not
have a domain name)

your_ip:the_service_port

Example:
zope http service on port 8080 on your machine.
When  you connect to internet your machine got an extra IP.
Then simple put on the web browser

http://your_conexion_ip:8080

and Tada you will see the root_zope/index_html object rendered intro HTML.

Most of the ISP give you a dinamic IP.
Some companies provides you dinamic IP Domain Name services, allowing to attach
a domain name to your machine dinamically (each time you reconect).

then you can have:

http://leo.edward.com:8080/

The 8080 stuff can be avoied if you setup zope to use the standard port 80 for
HTTP service.

With this in mind you can access ftp

ftp://your_ip_or_domain_name:8021

or webdav, or anything else.
#@-node:ekr.20031218072017.415:From Rodrigo re: ip
#@+node:ekr.20031218072017.416:Other servers
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007832
By: rodrigo_b

I would made a warning.

Zope IT IS NOT the only way to obtain an local HTTP server, pythonic and
flexible.

There is a lot of other way.

Also Zope IT IS NOT THE BEST pythonic http/ftp/webdav or anything server
aviable.

I think that we should define better 

What we want to do?

before choosing the tool.

As I said, I had already used Zope, I choosed it because of very specific features,
but nothing indicate that Zope is the best way to get Leo to the colaborative
network universe.

I think that we should at least consider:
- SimpleHTTPServer
- To take of the Medusa Server from Zope (that is use Zope code in the standard
Leo distribution, avoying dependences)
- Twisted matrix (I had no experience with it, but it looks much more
flexible/powerfull)

Zope provides you a specific framework, you have to match you application to
this framework, Zope (in my opinion) it is not a tool, it's an ambient.

It's seems that Edward it is new in the web oriented software, I think it has
a lot of potencialities and it will benefits Leo devellopment.

Please Edward, look at Zope as an example but not as THE options. Think about
what can be done, what should be done, and then we will take the best tool.

Anyway my opinion:
- SimpleHTTP server: usefull, it is in python, not very eficiente, just http
server	
- Medusa: usefull, very eficiente, just http server...
- Twisted Matrix: very powerfull, fresh comunity, confusing documentation, a
new paradigm, a devellopment tool.
- Zope: powerfull, eficient, comes with battery included, bad documentation,
to very paradigm oriented, the apps have to fit the paradigm, don't believe
all the promises, strong enthousiast comunity, poor web examples.


RodrigoB. 
#@-node:ekr.20031218072017.416:Other servers
#@+node:ekr.20031218072017.417:Is my ip public?
https://sourceforge.net/forum/message.php?msg_id=2007962
By: bwmulder

Since no one else answered this question, let me take a first take on the
question:

If you are connected to the internet, people can use your IP number to connect
to your computer. This IP number is often given dynamically, though some DSL
providers give you fixed IP numbers for an additional fee. If you did not ask
for fixed IP numbers, you probably have an dynamic IP number (I think).

An IP number consist of four digits. A connection to the (example) IP number
111.222.333.444 can by made via the request http://111.222.333.444

If you have a dynamic IP number, and your Internet provider provides you with
some space to publish HTML, you could, via a script, upload your current IP
number dynamically.

You might also consider buying a domain name. In this case, people can use the
domain name to connect to your computer instead of the IP number.

Another consideration are firewalls. Normally, you want a firewall isolating
your computer from attacks from the Internet. I firewall can be some additional
software. I am currently using a router, a piece of hardware, as a firewall.
Windows XP has firewall software build in. You might have to configure your
firewall to let requests for your server go through.

Finally, you might want to check the agreement you entered with your Internet
service provider, if you are allowed to run a server from your connection. It
might become a problem if your server becomes very popular.
#@-node:ekr.20031218072017.417:Is my ip public?
#@+node:ekr.20031218072017.418:Back ends for storing/retrieving nodes: Paul Paterson
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2009279
By: paulpaterson

What I see Zope offering is an alternative way of storing and retrieving nodes.
What you also get for "free" with Zope is concurrent access, security,
http/ftp/webdav access to the same node information etc. The hidden price you
pay is that Zope is big and many users will have other tools which can provide
these facilities also.

So, my thinking is that we can abstract the basic idea (alternative ways of
storing and retrieving node information) into Leo and then let the magic really
happen in the concrete implementation stage.

What does this mean? Well, we could change Leo so that whenever it goes to retrieve
Headline or Body it goes to a Node Server object to do that. The Node Server
object uses whatever method it wants to retrieve or set the information. The
Node server would also be responsible for telling Leo what child nodes an object
has and whether they are clones or not.

The cool part is that we could implement different kinds of Node server to talk
to different back-ends. These can then be thought of as drivers. So we might
have,

- a file system driver where all information is stored in files and directories
- a database driver where the DB stores all information
- an ftp driver
- a Zope driver
- the default Leo driver

People could write a driver to their own back end storage system. 

What is the advantage of this?

Well, the magic really happens in the back-end. If you choose a back end which
supports versioning, security, concurrent working, web access, etc etc then
Leo now supports them. If you choose a back-end which supports dynamic mark-up
or some other fancy stuff then Leo supports it. The key is that Leo doesn't
need to bind itself to any one system to achieve this - the end user can install
the relevant driver, configure the back-end and just go with it.

Paul
#@-node:ekr.20031218072017.418:Back ends for storing/retrieving nodes: Paul Paterson
#@+node:ekr.20031218072017.419:From Paul Paterson
Ok, I'll have a bash in a rough order or when things occurred...


1. Everything is web based. I had the same problem you did. I ran the
thing and said, "ok, so what did it do". Others have pointed you in the
right direction now with visiting http://localhost:8080 and
http://localhost:8080/manage to view the site and mange it respectively.

If you are running WinNT, 2000 or XP you can also run Zope as a service,
which is much more convenient as you don't need the console window open
all the time.


2. Everything in Zope is an object. Ok, you'll see this a lot. The best
thing to do is think "wow, cool" and then forget it again as you
probably wont really see how this helps at all until you get much deeper
into Zope. 


3. DTML allows you to construct web pages by piecing together bits much
like writing a program from functions. In fact you will find DTML is a
lot like tangling Leo's @root nodes. Here's a bit...

<!-- start html -->

<h>DTML allows you to assemble web pages much like Leo tangles
documents</h>

<p>For instance, have a look at how this page is constructed</p>

<dtml-var first_bit>
<dtml-var second_bit>
<dtml-var third_bit>

<!-- end html -->

The <dtml-var name> bit is like a < < name > > directive. It effectively
inserts the object (could be HTML, an image or something more complex)
in the current page. 

To see this snippet in action you can visit my server at
http://24.243.129.68:8080/members/sandbox/index_html

To see the code, visit http://24.243.129.68:8080/members/sandbox/manage
(username=edream, pwd=leo) and then click on the index_html to see the
main DTML. Feel free to mess around in here but please don't publish the
IP address as my ISP doesn't allow servers!


4. There is a lot of power in Zope products. Try going to www.zope.org
and seeing what is available. As an example I put a Wiki in the sandbox
area http://24.243.129.68:8080/members/sandbox/edswiki


5. If you are looking for a good book to begin with then steer clear of
"The Zope Book"! If you don't mind paying then "The book of Zope" is a
much better introduction. When you have read this then "The Zope Book"
will make some sense but really I found this book tremendously hard to
get through.


6. Web standards are very cool! Zope supports FTP. Point your favourite
FTP tool to,

ftp://24.243.129.68:8021/members/sandbox/

Or try using WebDav by creating a network place pointing to

http://24.243.129.68:8080/members/sandbox

You can then use windows explorer or an ftp tool to browse your objects.


7. Everything is an object! I can't do justice to the concept of
Acquisition here but by the time you have messed around with Zope a bit
you should start to see how acquisition starts to make things really
work like classes in Python. 


I realize this isn't very coherent - if I get a spare moment this
weekend I'll knock up a quick demo showing Leo interacting with Zope.

Regards,

Paul
#@-node:ekr.20031218072017.419:From Paul Paterson
#@-node:ekr.20031218072017.412:Zope
#@+node:ekr.20031218072017.420:Jabber
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2016634
By: jasonic

I have been thinking about LeoZopeWiki integration. I am a recovering Zope addict
[1999-2001] :-)  I believe Zope offers a very valuable client and server for
Leo.

I think Ed higlighted the distinction of collboration vs. sharing. So consdering
that re:  Leo and CVS , Leo and Zope, Leo and wikis, I had another idea this
morning..

LEO+JABBER

Jabber is an open XML-based  instant messaging and *presence* system. Although
Jabber is typically used for IM chat, its core designers have a much bigger
vision in mind.

Jabber Software Foundation
http://www.jabber.org/
O'Reilly Book
http://www.oreilly.com/catalog/jabber/
Python Jabber library
http://jabberpy.sourceforge.net/

CVS etc all depend on runing diff on posted static files which are checked in
or out. Clearly valuable, and good for __sharing__ but not so suitable as the
communication paradigm needed for collboration.

Wikis and Zope all suffer from problem of versioning and the time delay and
lack of timely communications to their cobtributors. There is no 'shared state'
or persistence in the collaboration beyond their own files or objectdatabases.

For example if two people want to edit a wiki or Zope site, they have an imeedaiet
problem of knowing whether or not the someone else is working one it already.

Score:
Sharing 1
Collaboration 0

Two  or more people wanting to edit a common project based on Leo have the same
dilemma. They can check the leo file into a wiki, Zope or CVS, but they still
don't have direct communication at teh content level.

score:
Sharing 1
Collaboration 0

PROPOSAL: LeoJabber
1. Integrate a Jabber client into Leo 
2. Add special Leo module to jabberd [Jabber's server daemon]

Leo-based developers could work in direct communication with each other allowing
them to add, edit and comment nodes in a shared le-space, local or remote. Static
publishing via upload/import etc all still apply.

LeoJabber would mean subscribing developers could immediately be aware of changes
and then apply whatever strategy is appropriate for handling them, such as:
 
a. autoUpdate()
b. makeNewNode()
c. runDiffFunctions()
d. notifyPartners()
e. notifyPublic()
etc..

Jabber via its presencing mechanism offers real-time and just-in time communcations.
If you are logged out, then mesages are queued.

An open Jabber message session is actually one long piece of XML data passed
over an XMLSocket :-) Sounds like a great fit for Leo

- All Jabber configs are XML.
- Good smart open source community.
- Similar open embracing philsophy as Leo
- Jabber connects diverse messaging systems., MSN, AOL etc [Most are
close/proprietary, though the trend is toward greater openness and connectivity]
- Many Jabber clients already. There is even one written in Flash so that any
webpage can participate.

Embedding Jabber in Leo would allow 'discussion' threads to  be integrated.
Developers need to bounce idea and notes around just as this forum does. But
often they need to be more provate or more focused on project specifics.
WORKFLOW 
It is important to know  which code is uptodate, but arguably, even *more* important
is to know which people and what discussions are uptodate. And if not, what
their status is. The larger, longer the more global the develpoment office/project,
the more this is true.

IM [instant messaging] are popular largely becuae they offer direct communication
with status feedback to crucial people's workflow:
"off-line", "on-line", "back-soon", "later" etc

Jabber extends this idea to create a platform for any presence application.
That is its long term-goal.

So in a Leo deevlopment project, that presence might apply to adding status
mesages such as
"making changes" "new version" "debugging" "review only" "major re-write"

or perhaps status/presence woudl be used for much lower level Leo-specific
purposes.

"new node"
"cloned to .."
"@file imported"
"version uploaded"
etc

I am not suggesting that Leo forget CVS or file upload storage. But I think
Jabber may truly provide the Missing Link, literally for Leo collaboration.

Jabber Software Foundation
http://www.jabber.org/
O'Reilly Book
http://www.oreilly.com/catalog/jabber/
Python Jabber library
http://jabberpy.sourceforge.net/

hope this makes sense
Jason
#@-node:ekr.20031218072017.420:Jabber
#@-node:ekr.20031218072017.404:LeoN, Zope & collaboration info
#@+node:ekr.20040107064101.5:Zope notes
#@+node:ekr.20040107065006:posting
@nocolor

Yes he's absolutely right -- focus on the ZODB.

..stay alway from ZTP. ZPT, TPZ, CMF, Plone and all that other stuff for now.

I jsut came accross a handy slide show overview from last spring:
http://jace.seacrow.com/tech/zope/blug-zodb

BerkeyDB Storage is cool too and fits Leo well I think. plays nicely wiht ZODB
standalnioe and in Zope.
#@-node:ekr.20040107065006:posting
#@+node:ekr.20040107064854:example Code
from ZODG import FileStorage,DB
from Persistence import Persistent

# Connect to db.
# FileStorage is standard: entire db is stored in a single file.
storage = FileStorage.FileStorage("/tmp/test-filestorage.fs")
db = DB.(storage)
conn = db.open()

# Get the root of the db.
root = conn.root()

# Defining user classes.
class leoData(Persistent):
	pass
	
# Commit or revert.
get_transaction().commit()
get_transaction().abort()
#@nonl
#@-node:ekr.20040107064854:example Code
#@+node:ekr.20040107080609.1:Zshell
@nocolor

By: jasonic ( Jason Cunliffe )
ZShell  
2003-12-31 22:25

Hi, Just another friendly reminder to check out Jerome Alet's ZShell, one of Zope's best kept secrets:

http://www.librelogiciel.com/software/

ZShell : Manipulate the Zope Object DataBase with Unix shell like commands

and also

ZShellScripts : Unifies the Zope notion of Scripts and provides several Script interpreters : Python, Unix shell , Lisp, Perl, PHP, Ruby, and Zope ZShell

Not only for obvious usefullness, but also as a valuable study of Python access to the ZODB.

JAXML is cool too..
http://www.librelogiciel.com/software/jaxml/action_Presentation

- Jason
#@nonl
#@-node:ekr.20040107080609.1:Zshell
#@+node:ekr.20040107064854.1:@url http://zope.org/Products/StandaloneZODB
#@-node:ekr.20040107064854.1:@url http://zope.org/Products/StandaloneZODB
#@+node:ekr.20040107064854.2:@url http://jace.seacrow.com/tech/zope/blug-zodb
#@-node:ekr.20040107064854.2:@url http://jace.seacrow.com/tech/zope/blug-zodb
#@-node:ekr.20040107064101.5:Zope notes
#@+node:ekr.20040117092727.2:using zodb versions
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2379351
By: korakot

If leo use database storage (ZODB or otherwise)
it could scale much better. This will bring us some
possiblity to store all versions of changes to a node
or a tree.

Cloning will then point to a specific version. If there
is no conflict, it can update to a later version when
the primary clone change. If there is a conflict
we can deal with it wisely using 'diff information'
because we have 'all versions' stored.

#@-node:ekr.20040117092727.2:using zodb versions
#@+node:ekr.20040226114127:Zope test
@color

import leoGlobals as g
import ZODB

if 1:
    storage = ZODB.FileStorage.FileStorage(r"c:\prog\zopeTemp\leo.fs") 
    db = ZODB.DB(storage)
    g.es(storage)
    g.es(db)
    db.close()
#@nonl
#@-node:ekr.20040226114127:Zope test
#@+node:ekr.20031218072017.737:Leo & data bases
From: "Scott Chapman" <scott_list@mischko.com>
To: <edreamleo@charter.net>
Sent: Monday, November 10, 2003 11:05 AM
Subject: Enhancement request: Make Leo deal with a database

It would be Way Cool if Leo could deal with psycopg or other DataBase 
API compliant implementations and fetch and store database records.

Details of what I'd like to see:

I'm working on Python source code. I want Leo to pull a source code file 
from a database record built something like this:

filename: text
updated: datetimestamp
code: text

Leo would insert a new record, not update an existing one, each time a 
Save was done, with a more current time stamp.  

When a File Open was requested (i.e. a node on a existing Leo outline 
was being pulled from a database), Leo would fetch the most recent 
time-stamped version only.

I use this same technique for my wiki pages.  It's very easy to 
implement in SQL and works great.

Leo would also need the ability to save the same file to a regular 
python source code file on disk at a specific location, so you'd have 
to be able to put more than one save/load directive in a given node.

This would provide a nice version history and could lead to other Useful 
Things in Leo.

Scott
#@nonl
#@-node:ekr.20031218072017.737:Leo & data bases
#@-node:ekr.20040329182535.4:Leo + zodb
#@+node:ekr.20040130073846:Use Python indices instead of Tk indices
This would really help when writing gui plugins.

The first place it would be useful would be in eliminating calls to the Tk search routine.
#@nonl
#@+node:ekr.20040105120208.1:Use string.find or re.find instead of tk.find
#@-node:ekr.20040105120208.1:Use string.find or re.find instead of tk.find
#@+node:ekr.20040203075059:use pos linestart + 1 lines to go to next line?
This might be the best way to reliably have Tk move to the next line!
#@-node:ekr.20040203075059:use pos linestart + 1 lines to go to next line?
#@-node:ekr.20040130073846:Use Python indices instead of Tk indices
#@+node:ekr.20040124074218.3:pyGtk plugin
#@-node:ekr.20040124074218.3:pyGtk plugin
#@+node:ekr.20040914095432:Use TreeCC to create generalized import
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2754954
RE: euphoria or general language plugins  
2004-09-11 20:37
>>Leo doesn't really understand languages otherwise.
import is another area Leo is too hardwired
wrt language. if a plugin for each language
could preprocess the file or code string and insert some minimal sentinals to create nodes and headlines,
then pass the string to Leo to do the dirty work, adding new languages for import could be easier.
I'm at this point in a new html file import,
creating the nodes while parsing is more complicated than one would like.
I think this has been discussed before, so
maybe will have to search the forums before I say more.

e

---------

http://sourceforge.net/forum/message.php?msg_id=2758616
By: differance

Check out treecc:
http://www.southern-storm.com.au/treecc.html
http://www.southern-storm.com.au/treecc_essay.html

It was developed for DotGNU, but I think you should be able to use it.

Seth

#@-node:ekr.20040914095432:Use TreeCC to create generalized import
#@+node:ekr.20041016134312.2:Create a proper Weave command
Use noweb and TeX, or maybe Pyx.
#@nonl
#@-node:ekr.20041016134312.2:Create a proper Weave command
#@+node:ekr.20041029085429:Use pdb.pm as starting point for integrated Leo debugger
@killcolor

> pdb.set_trace() is...quite a pain to use if you are used to pdb.pm() in an interactive session.

Whaterver pdb.pm does (I haven't used it) this might be the starting point for the design of a better interface between pdb and Leo.

#@-node:ekr.20041029085429:Use pdb.pm as starting point for integrated Leo debugger
#@-node:ekr.20040329182535.3:2 day to 2 week projects
#@+node:ekr.20040123102724:Can't or wont
#@+node:ekr.20040217153407.1:Unify @root and @file
#@-node:ekr.20040217153407.1:Unify @root and @file
#@+node:ekr.20031218072017.835:(Use pywin extensions to improve cut/paste between apps)
@color

@ This is not going well :-(  Probably what is happening is that Tk is competing with the win32 extensions in setting the clipboard.  It might not be so easy to

a) completely disable Tk's clipboard handling, in _both_ headlines and body text.
b) do the cut/paste operations "by hand".

This might require new body routlines to replace the selected text in the body.  And then there are issues relating to whether the headline or body text should be changed.  All in all, this is much harder than it looks.

Also, if one is not careful one can take fatal Python errors related to missing threads.  Pretty much a nightmare.
#@nonl
#@+node:ekr.20031218072017.836:updateEditMenu
def updateEditMenu (self):

    c = self.c ; frame = c.frame ; gui = g.app.gui
    if not c: return
    try:
        # Top level Edit menu...
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("Edit")
        c.undoer.enableMenuItems()
        << enable cut/paste >>
        if 0: # Always on for now.
            menu = frame.menu.getMenu("Find...")
            enable(menu,"Find Next",c.canFind())
            flag = c.canReplace()
            enable(menu,"Replace",flag)
            enable(menu,"Replace, Then Find",flag)
        # Edit Body submenu...
        menu = frame.menu.getMenu("Edit Body...")
        enable(menu,"Extract Section",c.canExtractSection())
        enable(menu,"Extract Names",c.canExtractSectionNames())
        enable(menu,"Extract",c.canExtract())
        enable(menu,"Match Brackets",c.canFindMatchingBracket())
    except:
        g.es("exception updating Edit menu")
        g.es_exception()
#@nonl
#@+node:ekr.20040130164211:<< enable cut/paste >>
if frame.body.hasFocus():
    data = frame.body.getSelectedText()
    canCut = data and len(data) > 0
else:
    # This isn't strictly correct, but we can't get the Tk headline selection.
    canCut = True

enable(menu,"Cut",canCut)
enable(menu,"Copy",canCut)

data = gui.getTextFromClipboard()
canPaste = data and len(data) > 0
enable(menu,"Paste",canPaste)
#@nonl
#@-node:ekr.20040130164211:<< enable cut/paste >>
#@-node:ekr.20031218072017.836:updateEditMenu
#@+node:ekr.20031218072017.837: tkinterGui.__init__
def __init__ (self):

    # Initialize the base class.
    leoGui.leoGui.__init__(self,"tkinter")

    self.bitmap_name = None
    self.bitmap = None
    self.win32clipboard = None
    
    if 0: # This seems both dangerous and non-functional.
        if sys.platform == "win32":
            try:
                import win32clipboard
                self.win32clipboard = win32clipboard
            except:
                g.es_exception()
#@nonl
#@-node:ekr.20031218072017.837: tkinterGui.__init__
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,frame):
    
    t = self.bodyCtrl
    
    # Event handlers...
    t.bind("<Button-1>", frame.OnBodyClick)
    if sys.platform == "win32":
        # Support Linux middle-button paste easter egg.
        t.bind("<Button-2>", frame.OnPaste)
    t.bind("<Button-3>", frame.OnBodyRClick)
    t.bind("<Double-Button-1>", frame.OnBodyDoubleClick)
    t.bind("<Key>", frame.body.onBodyKey)

    # Gui-dependent commands...
    t.bind(g.virtual_event_name("Cut"), frame.OnCut)
    t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
    t.bind(g.virtual_event_name("Paste"), frame.OnPaste)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:ekr.20031218072017.839:<< define editMenuTopTable >>
self.editMenuTopTable = (
    ("Can't Undo","Ctrl+Z",c.undoer.undo), # &U reserved for Undo
    ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &R reserved for Redo
    ("-",None,None),
    ("Cu&t","Ctrl+X",f.OnCutFromMenu), 
    ("Cop&y","Ctrl+C",f.OnCopyFromMenu),
    ("&Paste","Ctrl+V",f.OnPasteFromMenu),
    ("&Delete",None,c.delete),
    ("Select &All","Ctrl+A",f.body.selectAllText),
    ("-",None,None))
#@nonl
#@-node:ekr.20031218072017.839:<< define editMenuTopTable >>
#@+node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
def OnCut (self,event=None):
    
    """The handler for the virtual Cut event."""

    frame = self ; c = frame.c ; v = c.currentVnode()
    
    if 0: # g.app.gui.win32clipboard is always None.
        if g.app.gui.win32clipboard:
            data = frame.body.getSelectedText()
            if data:
                g.app.gui.replaceClipboardWith(data)

    # Activate the body key handler by hand.
    frame.body.forceFullRecolor()
    frame.body.onBodyWillChange(v,"Cut")

def OnCutFromMenu (self):
    
    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Cut"))
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)



#@-node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
#@+node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
def OnCopy (self,event=None):
    
    frame = self

    if 0: # g.app.gui.win32clipboard is always None.
        if g.app.gui.win32clipboard:
            data = frame.body.getSelectedText()
            if data:
                g.app.gui.replaceClipboardWith(data)
        
    # Copy never changes dirty bits or syntax coloring.
    
def OnCopyFromMenu (self):

    frame = self
    w = frame.getFocus()
    w.event_generate(g.virtual_event_name("Copy"))
#@-node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
#@+node:ekr.20031218072017.843:frame.OnPaste & OnPasteFromMenu
def OnPaste (self,event=None):
    
    frame = self ; c = frame.c ; v = c.currentVnode()
    
    if 0: # sys.platform=="linux2": # ??? workaround paste problems on Linux.
        bodyCtrl = frame.body.bodyCtrl
        s = bodyCtrl.selection_get( selection='CLIPBOARD' )
        bodyCtrl.insert('insert', s)
        bodyCtrl.event_generate('<Key>')
        bodyCtrl.update_idletasks()
    else:
        # Activate the body key handler by hand.
        frame.body.forceFullRecolor()
        frame.body.onBodyWillChange(v,"Paste")
    
def OnPasteFromMenu (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Paste"))
    
    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)
#@nonl
#@-node:ekr.20031218072017.843:frame.OnPaste & OnPasteFromMenu
#@-node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.844:Clipboard (tkGui) NOT USED AT PRESENT
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui) NOT USED AT PRESENT
#@-node:ekr.20031218072017.835:(Use pywin extensions to improve cut/paste between apps)
#@+node:ekr.20031218072017.753:Emacs comint-mode:  The improved Execute Script command does most of this
@nocolor

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
#@-node:ekr.20031218072017.753:Emacs comint-mode:  The improved Execute Script command does most of this
#@+node:ekr.20031218072017.729:HTML rendering in Leo's body pane
#@+node:ekr.20031218072017.731:HTML plugin: opml
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2283466
By: billp9619

FYI
I played around with opml a while back and it seemed very versatile.

It basically consists of an xml file of nested outline tags similiar to v-nodes
in leo xml. This then works with an xsl stylesheet that displays the outline
in a browser with scripted outline manipulation. (Uses div tags for this
display.)

What I discovered is that any html can make up the outline nodes , even forms,
etc. which collapse with the outline interaction. Just that the angle brackets
in the html must be escaped as is done within leo t nodes in .leo xml.

Actually, it would be interesting to see an addin that just passes leo nodes
to opml and then pops into the default browser. Also keep in mind that javascript
has an eval() statement that can be passed any script as a string. The leo text
box could be a form textarea box except that then there is no way to emulate
syntax coloring. Alternatively, this could be a floating window wrappiing node
text in html/body. (if nothing else, just destroy/close the window and reinitialize).
Maybe the images used in the opml could have javascript events like onclick()
to trigger refreshing leo text box from the t-nodes stored in an array or in
hidden form boxes.

Of course the effect of the stylesheet could be done via python script if no
xslt in the receiving browser. The minimal html and script might be just boilerplate
output.

regards,
bill p
#@nonl
#@-node:ekr.20031218072017.731:HTML plugin: opml
#@-node:ekr.20031218072017.729:HTML rendering in Leo's body pane
#@+node:ekr.20040216054459:@h @f @endh and @endf directives
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2424151
By: ksejlod ( Peter Barrel ) 
 I Have a (maybe) great idea!   
2004-02-15 04:29

I've been using LEO for a while and finding surprinsingly powerfull new uses now and then, (hey, not a week passes that i dont think to myself : "why did'nt anyone thought of that kind of tool that is LEO. It's so stupid to program such a tool, yet no one thought of doing such a thing ! ")

I was wondering if there was a leo keyword (beginning with "@") that would do a feature I thought would be great: something such as :
@h
@endh
and of course, similarily...
@f
@endf

Standing for "Header", "End Header", "Footer" and "End Footer". Let me please explain ...

When creating files with @file (or nosentinels) I use the keyword "@others" in the starting node body of the file and place in the file, as it's decendants (children, grand-children & so on) some clones of other stuff somewhere else outside of this file (usualy, clones of parts of program regrouped as children of a "components" node up in the leo outline. Typical Example:

-Introduction
-+components
-a
-b
-c
-+@file program.BAS
-b
-c
-a

a, b, and c are clones and the @file node contains @others.

As you see, I proceed that way because in older programming languages or in lower level languages, the order of components such as procs, declarations, etc as an importance. It also has the implication that << and >> brackets are irrelevant in my way of using leo.

Now, my feature that I looked for in the doc but could not find (so i suggest it here in case no one had any need of this before) is that when used in the BODY of a node part of an "@file" the @h and @endh would define a chunk of text in the body, you've guessed it, to be added before _each_ children node and ONLY children no grandchildren or any deeper. But It could also be used INSIDE the body of a children to define headers or footers for IT'S OWN direct children.

so, eehh, do you see the relevance of such a feature? Have i explained it clearly? maybe this would help:
CONST baba=2 AS INTEGER
CONST bebe=7 AS INTEGER
CONST zaza=5 AS INTEGER
CONST bobo=1 AS INTEGER
... the beginning and end of each of those "parts-of-a-program" is the same for a potential lot of lines... 

To Be Precise :
It's just really for adding something at end or beginning of a direct children of a node part of an @file in the tangling process. 

Is this feature already implemented but i have not found it? I'm pretty sure it easy to implement... what do you people think of this?
Thanks 
--
k

p.s. I'm the guy who proposed that in the untangling process, a clone would not be updated by it's _Last-Instance-Found_ in the @file beeing untangled, but instead updated by the _Last-Modified-One-Found_ in the @file... :)

(ooouuuuhh that would be slick...)  

By: ksejlod ( Peter Barrel ) 
 RE: I Have a (maybe) great idea!   
2004-02-15 04:35  

 The tree i tried to draw in ascii did not came out the way i did it, sourceforge "eated" leading spaces sorry a, b and c are children of their "+" node just above them		.
--
k  
#@nonl
#@-node:ekr.20040216054459:@h @f @endh and @endf directives
#@+node:ekr.20040123102724.2:Templates
@nocolor
#@nonl
#@+node:ekr.20040123102724.3:daliuslt
https://sourceforge.net/forum/message.php?msg_id=2385991
By: nobody

I often found myself using the same template for many projects but something differs in them. E.g. name of files. So my offer is add new directive variable:

@variable ProjectName MyFunProject

Later in parent node, child nodes or headers I could use this as:

$(ProjectNode).py or smth. similar.
This line when tangling could be replaces with
MyFunProject.py

Of course, there comes some complexity with untangling, but it is just an offer :)

Dalius
#@-node:ekr.20040123102724.3:daliuslt
#@+node:ekr.20040123102724.4:Rich: @constant
https://sourceforge.net/forum/message.php?msg_id=2386199
By: nobody

Dalius-
FWIW, I like it! I also can think of a LOAD of variations (i.e., multi-line
variables, etc.), but I'll limit myself to one thing: 'variable' by definition
should be changeable. May I suggest you call the directive "@constant"?

--Rich
#@nonl
#@-node:ekr.20040123102724.4:Rich: @constant
#@+node:ekr.20040123102724.5:paulpaterson
https://sourceforge.net/forum/message.php?msg_id=2386359
By: paulpaterson

I like this idea because I think templating is an important "design pattern"
that Leo could usefully support. Currently you can only do this in a limited
way by cloning nodes across derived files, which is something Edward doesn't
like to do because it makes reading derived files ambiguous (same information
in more than one place). I still do this because I rarely read files into Leo,
I mostly explicitely tangle files out of Leo.

Back to your idea ;) ISTM that your idea works well for directives (you can
do the variable substitution) but for general text (where I think there is a
bigger gain) there are two issues,

1. The template itself is now present in multiple derived files (see above)

2. The file derived from the template has now lost the variable name because
it was substituted out for the variable value

The end result is that templated files would almost certainly have to be a one
way street for Leo - they are derived from the Leo file but never read back
in. If you don't mind having this restriction, which basically means you have
to use @root nodes, then I don't see a problem.

Presumably most of this could all be done with a tangle_done script - the only
problem is how to change directives.
#@nonl
#@-node:ekr.20040123102724.5:paulpaterson
#@+node:ekr.20040123102724.6:daliuslt
http://sourceforge.net/forum/message.php?msg_id=2389750
By: daliuslt

Just for your interests where is one way to create constants in leo (even multiline).
Let's way we have outline:

+-[ ] @file-nosent objects.mak
|   +-[clone] << my_const >>
+-[ ] @file-nosent makefile
    +-[close] << my_const >>

objects.mak is:
--
<< my_const >>.o:
gcc -g -c << my_const >>.c -o << my_const >>.o

<< my_const >>cmd.o:
gcc -g -c << my_const >>cmd.c -o << my_const >>cmd.o
--

makefile is
--
<< my_const >>:
gcc << my_const >>.o << my_const >>cmd.o -o << my_const >>
--

<< my_const >> can be:
test

While it works pretty good it still have some drawbacks:
1. You are forced to use @file-nosent. You can edit your files outside of Leo.
2. You can't use << my_const >> in header lines, while it would be really nice
if you could write
@file-nosent obj_<< my_const >>.mak
(Leo lacks introspection?)
3. Result is not 100% what you expect.

---

(constant = variable = define) ???

Constants and clones in fact are the same. Usually clones are used like symbolic
links (or shortcuts) not like clones or constants. I think this could be
separated.

Constants could be read back into leo. E.g.: you have constant value in leo
file and while reading back files to outline you change all values with constant
name.

I hope I am clear :)
Dalius
#@nonl
#@-node:ekr.20040123102724.6:daliuslt
#@-node:ekr.20040123102724.2:Templates
#@+node:ekr.20040329185649:Bugs: can't be fixed or can wait
#@+node:ekr.20031218072017.663:Bug: can't be fixed
#@+node:ekr.20031218072017.664:Cut/paste bug on X windows (waiting for help)
@nocolor

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse.

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node.

Doing copy and paste works normally when done through the edit menu.

@color
#@nonl
#@+node:ekr.20031218072017.665:(Cut & Paste ) (Middle-button bug reported by Timo)
#@+node:ekr.20031218072017.666: Paste bug report
@nocolor

By: riotnrrrd ( Timo Honkasalo ) 
 Pasted text doesn't stick   
2002-11-01 13:38  
System: Linux 

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse. 

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node. 

Doing copy and paste works normally when done through the edit menu. 

-------------------

I also found out that if you do an extra "click" on the control key, it will
stick from then on.

If your text should have color in it, you can see that right before you "click",
the text has no color and the color back on right after you click the control.

It maybe a clue to someone, but seems strange to me. 
#@-node:ekr.20031218072017.666: Paste bug report
#@+node:ekr.20031218072017.667: Test
abc bbb bbbxyz bbb
#@nonl
#@-node:ekr.20031218072017.667: Test
#@-node:ekr.20031218072017.665:(Cut & Paste ) (Middle-button bug reported by Timo)
#@+node:ekr.20031218072017.668:Automatic select & Paste bug (Linux?)
@nocolor

Bumping the thread because the bug still persists. 

I've also noticed that the automatic select'n'paste doesn't work between nodes. That is, I can select text and paste a copy of it in the same node with middle button, but if I change click to another node, the paste buffer is erased. The automatic pasting works between Leo and other applications, however, and I can paste between nodes if I copy the selection to buffer by CTR-C. 

Maybe this is related to the non-sticking bug?

----

This may be a Linux-only bug related to the control-v workaround.
#@nonl
#@-node:ekr.20031218072017.668:Automatic select & Paste bug (Linux?)
#@-node:ekr.20031218072017.664:Cut/paste bug on X windows (waiting for help)
#@+node:ekr.20031218072017.669:Linux-only Bugs
These may indicate problems with Tk on Linux.  I can not reproduce them on XP.
#@nonl
#@+node:ekr.20031218072017.670:Possible webbrowser bug
(In Linux) The home page and online tutorial options in the menu only work properly if Mozilla window is already open. If not, a Mozilla window opens, but with empty page and url field. 
#@nonl
#@-node:ekr.20031218072017.670:Possible webbrowser bug
#@+node:ekr.20031218072017.671:Fix horiz scrollbar bug when tiling horizontally
When in 'vertical split' mode (with viewpane on right, and tree pane over log pane on left), the horixontal scrollbar at bottom of screen is at full width, despite the fact that not all of the tree pane area is displayed. 

Another way of saying this - I narrow the tree and log panes, to the extent that the display of tree node headings is truncated. But the horizontal scrollbar at the bottom doesn't contract, and doesn't allow me to horizontally scroll the tree pane to expose the rest of the node headings. 
#@-node:ekr.20031218072017.671:Fix horiz scrollbar bug when tiling horizontally
#@+node:ekr.20031218072017.672:Control-V doesn't work on Linux
This has been and continues to be a known issue with Tk. Has been logged as a bug; no response from the Tk folks. 

Here is a link to the Tk bug report: 

http://sourceforge.net/tracker/?func=detail&aid=605277&group_id=12997&atid=112997 

Note the work-around/patch in the followup post at the bottom of that page. Commenting out some statements in text.tcl removes the problem. 
#@-node:ekr.20031218072017.672:Control-V doesn't work on Linux
#@-node:ekr.20031218072017.669:Linux-only Bugs
#@+node:ekr.20031218072017.673:Tk bugs
The following bugs can not be fixed because they are Tk bugs.
#@nonl
#@+node:EKR.20040523192553:(Crash when pasting large text into headlines)
#@+node:EKR.20040606104355:Report
@nocolor

From: <eltronic@juno.com>
To: <edreamleo@charter.net>
Sent: Sunday, May 23, 2004 9:36 AM
Subject: fatal bug in Leo headline handling


> found a fatal bug in Leo headline handling.
> not sure if anyone reported before,
> an oversize string can crash python 2.3.3
> 
> 
> the text was about 4500 bytes. nothing but text.
> opened the  leo again, copy a large page of text,
> insert headline, paste, fatal error in python.
> 
> I have by mistake pasted whatever node xml was in 
> the copy buffer into a headline w/o problem.
> but that was just dumb luck. just verified,
> had the node been large enough it crashes.
> 
> Leo 4.1 final, py2.3.3 win98
> PYTHON caused an invalid page fault in
> module TK84.DLL at 0167:1022b74f.
> 
> Leo 4.1 final, py2.2 win98
> paste a 15k node copy into headline. no problem.
> 
> this is the first repeatable hard crash I've stumbled on
> and thought it best to report it privately.
> I can think of no advantage to allowing a headline 
> of this size anyway. think of the tooltip that would create!
> 
> there are latent bugs in the selectall and delete from 
> the edit menu related to headline as well on the todo list.
> reported many times. 
> covert destruction of the selected body text.
> use of virtual events, with out proper focus to headline.
> 
> without myself being able to supply a patch, I'll guess,
> the virtual event paste called can as well point 
> to a function that checks the size before pasting.
> or simply sets the headline directly with 
> g.app.gui.getTextFromClipboard()[:1024]
> 
> 
> e
#@-node:EKR.20040606104355:Report
#@-node:EKR.20040523192553:(Crash when pasting large text into headlines)
#@+node:ekr.20031218072017.674:Caps lock affects keyboard shortcuts on Windows
Using leo under Windows, the keyboard shortcuts seem to use the "Caps Lock" state in determining the shift state when executing a shortcut.   For example, if the caps-lock key is on, then Ctrl-X is interpreted as Shift-Ctrl-X and cuts a node rather than selected text, and Shift-Ctrl-X is interpreted as Ctrl-X and cuts text.
#@-node:ekr.20031218072017.674:Caps lock affects keyboard shortcuts on Windows
#@+node:ekr.20031218072017.675:Tree problems
1. The border of the tree control is gray, and it is overwritten with large headlines.  This may be a Tk or Tkinter bug.

2. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this glitch because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.
#@nonl
#@-node:ekr.20031218072017.675:Tree problems
#@+node:ekr.20031218072017.676:Control-T can't be overridden in canvas text.
#@-node:ekr.20031218072017.676:Control-T can't be overridden in canvas text.
#@+node:ekr.20031218072017.677:(Alt-ctrl = Alt)
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1765069
By: dalcolmo

I use the bindings that come with Leo:

[keyboard shortcuts]
pastenode = Shift+Ctrl+V
gonextvisible = Alt+DnArrow
importtofile = Shift+Ctrl+F
writefilenodes = Shift+Ctrl+W
editheadline = Ctrl+H
markchangeditems = Alt+C
replace = Ctrl+=
goprevvisible = Alt+UpArrow
gotonextmarked = Alt+M
readoutlineonly = Shift+Ctrl+R
extractnames = Shift+Ctrl+N
gonext = Alt+Shift+DnArrow
findpanel = Ctrl+F
close = Ctrl+W
demote = Ctrl+}
tangle = Shift+Ctrl+T
extract = Shift+Ctrl+D
openpythonwindow = Alt+P
marksubheads = Alt+S
saveas = Shift+Ctrl+S
cut = Ctrl+X
preferences = Ctrl+Y
equalsizedpanes = Ctrl+E
cantundo = Ctrl+Z
open = Ctrl+O
promote = Ctrl+{
sortsiblings = Alt-A
unmarkall = Alt+U
mark = Ctrl+M
showinvisibles = Alt+V
exit = Ctrl-Q
insertnode = Ctrl+I
findprevious = F4
converttabs = Shift+Ctrl+J
save = Ctrl+S
tanglemarked = Shift+Ctrl+M
moveup = Ctrl+U
copynode = Shift+Ctrl+C
contractparent = Alt+0
selectall = Ctrl+A
setfont = Alt+Shift+T
aborteditheadline = Shift+Esc
goback = Alt+Shift+UpArrow
toggleactivepane = Ctrl+T
findnext = F3
tangleall = Shift+Ctrl+A
endeditheadline = Esc
deletenode = Shift+Ctrl+BkSp
cantredo = Shift+Ctrl+Z
new = Ctrl+N
contractall = Alt+1
moveleft = Ctrl+L
copy = Ctrl+C
paste = Ctrl+V
convertblanks = Shift+Ctrl+B
expandall = Alt+9
markchangedroots = Alt+R
cutnode = Shift+Ctrl+X
indent = Ctrl+]
gotonextchanged = Alt+D
expandnextlevel = Alt+=
setcolors = Alt+Shift+S
matchbrackets = Ctrl+K
movedown = Ctrl+D
clonenode = Ctrl+`
untangle = Shift+Ctrl+U
expandtolevel7 = Alt+7
expandtolevel6 = Alt+6
expandtolevel5 = Alt+5
expandtolevel4 = Alt+4
expandtolevel3 = Alt+3
expandtolevel2 = Alt+2
moveright = Ctrl+R
unindent = Ctrl+[
replacethenfind = Ctrl+-
extractsection = Shift+Ctrl+E
expandtolevel8 = Alt+8


However, I use a utility called AllChars (Free as in beer :-(  ) to be able
to type all kinds of chars on my US keyboard, and "Handything" to place the
windows on the screen (Win2000). Perhaps this makes a difference, although disabling
them did not seem to make it go away. Still, on pressing alt+ctrl+uparrow I
end up at the next upper node etc...

- Josef

#@-node:ekr.20031218072017.677:(Alt-ctrl = Alt)
#@+node:ekr.20031218072017.678:Report Tk bugs
Create a Tk demo for each bug.
#@nonl
#@+node:ekr.20031218072017.679:Tk code
@color
#@nonl
#@+node:ekr.20031218072017.680:@file c:/prog/test/leoSplitter.tcl
# This file creates tk test code for prototyping.
@language tcltk
@others

go
#@nonl
#@+node:ekr.20031218072017.681:go
proc go {} {
    # createLeo 1
    # createLeo 2
    # createFindPanel
    # createPrefsPanel
    # createColorPanel
    # toplevel .font
    # createFontPanel .font
    # createComparePanel
    # createWindowWithIcon
    # createWindowWithCursor
}
#@-node:ekr.20031218072017.681:go
#@+node:ekr.20031218072017.682:createLeo
proc createLeo { n } {

    toplevel .leo$n

    # Create two splitters
    createSplitter .leo$n.s 1
    createSplitter .leo$n.s.pane1.s 0 ;# contains tree and log
    
    text      .leo$n.s.pane2.body -bd 2 -yscrollcommand ".leo$n.s.pane2.scroll set" -setgrid 1
    scrollbar .leo$n.s.pane2.scroll -command ".leo$n.s.pane2.body yview"

    pack .leo$n.s.pane2.scroll -side right -fill y
    pack .leo$n.s.pane2.body -expand yes -fill both

    text .leo$n.s.pane1.s.pane1.tree -bd 2 -yscrollcommand ".leo$n.s.pane1.s.pane1.scroll set" -setgrid 1
    scrollbar .leo$n.s.pane1.s.pane1.scroll -command ".leo$n.s.pane1.s.pane1.tree yview"
    
    pack .leo$n.s.pane1.s.pane1.scroll -side right -fill y
    pack .leo$n.s.pane1.s.pane1.tree   -expand yes -fill both

    # -padx is needed to handle overlap of splitter bar
    text      .leo$n.s.pane1.s.pane2.log    -yscrollcommand ".leo$n.s.pane1.s.pane2.scroll set" -setgrid 1 -padx 4
    scrollbar .leo$n.s.pane1.s.pane2.scroll -command ".leo$n.s.pane1.s.pane2.log yview"
    pack .leo$n.s.pane1.s.pane2.scroll -side right -fill y
    pack .leo$n.s.pane1.s.pane2.log -expand yes -fill both
    
    createMenus $n
}
#@nonl
#@-node:ekr.20031218072017.682:createLeo
#@+node:ekr.20031218072017.683:createMenus
proc createMenus { n } {

    # Create the menu bar
    menu .leo$n.menu -tearoff 0

    set m .leo$n.menu.file
    menu $m -tearoff 0

    .leo$n.menu add cascade -label "File" -menu $m -underline 0
    # to do: fill in the commands...
    $m add command -label "Open..." -command {""}
    $m add command -label "New" -command {""}
    $m add command -label "Save" -command {""}
    $m add command -label "Save As..." -command {""}
    $m add separator
    $m add command -label "Print Setup..." -command {""}
    $m add command -label "Print..." -command {""}
    $m add separator
    $m add command -label "Quit" -command "destroy ."
    
    .leo$n configure -menu .leo$n.menu
}
#@nonl
#@-node:ekr.20031218072017.683:createMenus
#@+node:ekr.20031218072017.684:createSplitter
#@+node:ekr.20031218072017.685:createSplitter
# Create a splitter window into which the caller packs widgets.

proc createSplitter {w verticalFlag} {
    # verticalFlag, height, width could be params
    frame $w -width 4i -height 3i
    frame $w.pane1
    frame $w.pane2
    if { $verticalFlag } {
        # Panes arranged vertically; horizontal splitter bar
        frame $w.bar -height 7
        place $w.pane1 -relx 0.5 -rely   0 -anchor n -relwidth 1.0 -relheight 0.5
        place $w.pane2 -relx 0.5 -rely 1.0 -anchor s -relwidth 1.0 -relheight 0.5
        place $w.bar   -relx 0.5 -rely 0.5 -anchor c -relwidth 1.0
        bind $w.bar <ButtonPress-1>		"onGrabSplitterBar $w 1"
        bind $w.bar <B1-Motion>			"onDragSplitterBar $w 1 %y"
        bind $w.bar <ButtonRelease-1>	"onDropSplitterBar $w 1 %y"
    } else {
        # Panes arranged horizontally; vertical splitter bar
        frame $w.bar -width 7
        place $w.pane1 -rely 0.5 -relx   0 -anchor w -relheight 1.0 -relwidth 0.5
        place $w.pane2 -rely 0.5 -relx 1.0 -anchor e -relheight 1.0 -relwidth 0.5
        place $w.bar   -rely 0.5 -relx 0.5 -anchor c -relheight 1.0
        bind $w.bar <ButtonPress-1>		"onGrabSplitterBar $w 0"
        bind $w.bar <B1-Motion>			"onDragSplitterBar $w 0 %x"
        bind $w.bar <ButtonRelease-1>	"onDropSplitterBar $w 0 %x"
    }
    # Borderwidth required
    $w.bar configure -borderwidth 2 -relief raised -background LightSteelBlue2 
    pack $w -expand yes -fill both
}
#@-node:ekr.20031218072017.685:createSplitter
#@+node:ekr.20031218072017.686:onGrabSplitterBar
proc onGrabSplitterBar {w verticalFlag} {

    # We should change the cursor here.
    
    # Changing the relief is pointless.
        # $w.bar configure -relief sunken
    
    # Changing colors is really bad
        # $w.bar configure -relief sunken -background LightSteelBlue4
        # $w.bar configure -background LightSteelBlue4
}
#@nonl
#@-node:ekr.20031218072017.686:onGrabSplitterBar
#@+node:ekr.20031218072017.687:onDropSplitterBar
proc onDropSplitterBar {w verticalFlag xy} {

    # We should reset the cursor here.
    $w.bar configure -relief raised -background LightSteelBlue2
}
#@-node:ekr.20031218072017.687:onDropSplitterBar
#@+node:ekr.20031218072017.688:onDragSplitterBar
# xy is the coordinate of the cursor relative to the bar, not the main window.

proc onDragSplitterBar {w verticalFlag xy} {

    if { $verticalFlag } {
        # Panes arranged vertically; horizontal splitter bar
        set wRoot	[winfo rooty $w]
        set barRoot [winfo rooty $w.bar]
        set wMax	[winfo height $w]
    } else {
        # Panes arranged horizontally; vertical splitter bar
        set wRoot	[winfo rootx $w]
        set barRoot [winfo rootx $w.bar]
        set wMax	[winfo width $w]
    }
    set offset [expr double($barRoot) + $xy - $wRoot ]
    # Adjust the pixels, not the frac.
    if { $offset < 3 } { set offset 3 }
    if { $offset > [expr $wMax - 2] } { set offset [expr $wMax - 2] }
    set frac [ expr double($offset) / $wMax ]
    # This redraws the splitter as the drag is occuring.
    # We could also redraw in onDropSplitterBar for non-dynamic updates.
    divideSplitter $w $verticalFlag $frac
    return $frac ;# No longer used
}
#@nonl
#@-node:ekr.20031218072017.688:onDragSplitterBar
#@+node:ekr.20031218072017.689:divideSplitter
proc divideSplitter {w verticalFlag frac} {

    if { $verticalFlag } {
        # Panes arranged vertically; horizontal splitter bar
        place $w.bar -rely $frac
        place $w.pane1 -relheight $frac
        place $w.pane2 -relheight [expr 1 - $frac]
    } else {
        # Panes arranged horizontally; vertical splitter bar
        place $w.bar -relx $frac
        place $w.pane1 -relwidth $frac
        place $w.pane2 -relwidth [expr 1 - $frac]
    }
}
#@nonl
#@-node:ekr.20031218072017.689:divideSplitter
#@-node:ekr.20031218072017.684:createSplitter
#@+node:ekr.20031218072017.690:createFindPanel
proc createFindPanel {} {

    toplevel .find
    << Create the Find and Change panes >>
    << Create two columns of checkboxes >>
    << Create two rows of buttons >>
}
#@+node:ekr.20031218072017.691:<< Create the Find and Change panes >>
frame .find.fc -bd 1m
pack  .find.fc -anchor n -expand yes -fill x

frame .find.fc.fpane -bd 1 -height 0.95i -width 1.5i
frame .find.fc.cpane -bd 1 -height 0.95i -width 1.5i

pack  .find.fc.fpane -anchor n -expand yes -fill x
pack  .find.fc.cpane -anchor s -expand yes -fill x

# Create the labels and text fields.
label .find.fc.fpane.lab -width 8 -text "Find:"
label .find.fc.cpane.lab -width 8 -text "Change:"
text  .find.fc.fpane.t -height 2 -width 20 ; # 2 lines, 20 characters
text  .find.fc.cpane.t -height 2 -width 20

pack  .find.fc.fpane.lab -side left 
pack  .find.fc.cpane.lab -side left
pack  .find.fc.cpane.t -side right -expand yes -fill both
pack  .find.fc.fpane.t -side right -expand yes -fill both
#@-node:ekr.20031218072017.691:<< Create the Find and Change panes >>
#@+node:ekr.20031218072017.692:<< Create two columns of checkboxes >>
frame .find.boxes -bd 1m
pack  .find.boxes -anchor n -expand yes -fill x

frame .find.boxes.lt -bd 1
frame .find.boxes.rt -bd 1
pack  .find.boxes.lt -side left  -padx 5m
pack  .find.boxes.rt -side right -ipadx 2m

# Create the left column
checkbutton .find.boxes.lt.batch -anchor w -text "Batch"
checkbutton .find.boxes.lt.wrap  -anchor w -text "Wrap around"
checkbutton .find.boxes.lt.word  -anchor w -text "Whole word"
checkbutton .find.boxes.lt.case  -anchor w -text "Ignore case"
checkbutton .find.boxes.lt.pat   -anchor w -text "Pattern match"
pack .find.boxes.lt.batch -fill x
pack .find.boxes.lt.wrap  -fill x
pack .find.boxes.lt.word  -fill x
pack .find.boxes.lt.case  -fill x
pack .find.boxes.lt.pat    -fill x

# Create the right column
checkbutton .find.boxes.rt.headline -anchor w -text "Search Headline Text"
checkbutton .find.boxes.rt.body     -anchor w -text "Search Body Text"
checkbutton .find.boxes.rt.outline  -anchor w -text "Suboutline Only"
checkbutton .find.boxes.rt.mark     -anchor w -text "Mark Changes"
checkbutton .find.boxes.rt.markch   -anchor w -text "Mark Finds"
pack .find.boxes.rt.headline -side top -fill x
pack .find.boxes.rt.body     -side top -fill x
pack .find.boxes.rt.outline  -side top -fill x
pack .find.boxes.rt.mark     -side top -fill x
pack .find.boxes.rt.markch   -side top -fill x
#@-node:ekr.20031218072017.692:<< Create two columns of checkboxes >>
#@+node:ekr.20031218072017.693:<< Create two rows of buttons >>
# Create the button panes
frame .find.buttons -bd 1
pack  .find.buttons -anchor n -expand yes -fill x

frame .find.buttons2 -bd 1
pack  .find.buttons2 -anchor n -expand yes -fill x

# Create the first row of buttons
button      .find.buttons.find    -width 8 -text "Find"
checkbutton .find.buttons.reverse -width 8 -text "Reverse"
button      .find.buttons.findAll -width 8 -text "Find All"

pack .find.buttons.find    -pady 1m -padx 1m -side left
pack .find.buttons.reverse -pady 1m          -side left -expand 1
pack .find.buttons.findAll -pady 1m -padx 1m -side right

# Create the second row of buttons
button .find.buttons2.change     -width 8 -text "Change"
button .find.buttons2.changeFind           -text "Change, Then Find"
button .find.buttons2.changeAll  -width 8 -text "Change All"

pack .find.buttons2.change       -pady 1m -padx 1m -side left
pack .find.buttons2.changeFind   -pady 1m          -side left -expand 1
pack .find.buttons2.changeAll    -pady 1m -padx 1m -side right
#@-node:ekr.20031218072017.693:<< Create two rows of buttons >>
#@-node:ekr.20031218072017.690:createFindPanel
#@+node:ekr.20031218072017.694:createPrefsPanel
proc createPrefsPanel {} {

    toplevel .prefs
    << Create the Global Options frame >>
    << Create the Tangle Options frame >>
    << Create the Target Language frame >>
}
#@nonl
#@+node:ekr.20031218072017.695:<< Create the Global Options frame >>
frame .prefs.glob -bd 1m -relief groove
pack  .prefs.glob -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.glob.title -text "Global Options..."
pack  .prefs.glob.title -pady 1m

# Page width & page width
frame .prefs.glob.f
pack  .prefs.glob.f -anchor w -pady 1m -expand 1 -fill x

label .prefs.glob.f.lab -anchor w -padx 1m -text "Page width:"
text  .prefs.glob.f.txt -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab .prefs.glob.f.txt -side left

label .prefs.glob.f.lab2 -padx 1m -text "Tab width:"
text  .prefs.glob.f.txt2 -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab2 .prefs.glob.f.txt2 -side left

# Checkbuttons
checkbutton .prefs.glob.done -anchor w -text "Execute Leo_done.bat after Tangle"
checkbutton .prefs.glob.un   -anchor w -text "Execute Leo_un.bat after Tangle"
pack .prefs.glob.done .prefs.glob.un -fill x
#@-node:ekr.20031218072017.695:<< Create the Global Options frame >>
#@+node:ekr.20031218072017.696:<< Create the Tangle Options frame >>
# Frame and title
frame .prefs.tangle -bd 1m -relief groove
pack  .prefs.tangle -anchor n -ipadx 1m -expand 1 -fill x

label .prefs.tangle.title -text "Default Options..."
pack  .prefs.tangle.title -pady 1m

# Label and text
label .prefs.tangle.lab -anchor w -text "Default tangle directory"
text  .prefs.tangle.txt -height 1 -width 30 ;# width significant

pack  .prefs.tangle.lab           -padx 1m -pady 1m -fill x
pack  .prefs.tangle.txt -anchor w -padx 1m -pady 1m -fill x

# Checkbuttons
checkbutton .prefs.tangle.header -anchor w -text "Tangle outputs header line"
checkbutton .prefs.tangle.doc    -anchor w -text "Tangle outputs document chunks"
pack .prefs.tangle.header .prefs.tangle.doc -fill x
#@-node:ekr.20031218072017.696:<< Create the Tangle Options frame >>
#@+node:ekr.20031218072017.697:<< Create the Target Language frame >>
# Frame and title
frame .prefs.target -bd 1m -relief groove
pack  .prefs.target -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.target.title -text "Default Target Language..."
pack  .prefs.target.title -pady 1m

# Frames for two columns of radio buttons
frame .prefs.target.lt 
frame .prefs.target.rt
pack  .prefs.target.lt -side left
pack  .prefs.target.rt -side right

## To do: make radio buttons functional.

# Left column of radio buttons
radiobutton .prefs.target.lt.c      -anchor w -text "C/C++"
radiobutton .prefs.target.lt.cweb   -anchor w -text "CWEB"
radiobutton .prefs.target.lt.html   -anchor w -text "HTML"
radiobutton .prefs.target.lt.java   -anchor w -text "Java"
radiobutton .prefs.target.lt.pascal -anchor w -text "Pascal"

pack .prefs.target.lt.c      -fill x
pack .prefs.target.lt.cweb   -fill x
pack .prefs.target.lt.html   -fill x
pack .prefs.target.lt.java   -fill x
pack .prefs.target.lt.pascal -fill x

# Right column of radio buttons
radiobutton .prefs.target.rt.perl   -width 12 -anchor w -text "Perl"
radiobutton .prefs.target.rt.pod              -anchor w -text "Perl + POD"
radiobutton .prefs.target.rt.plain            -anchor w -text "Plain Text"
radiobutton .prefs.target.rt.python           -anchor w -text "Python"

pack .prefs.target.rt.perl   -fill x
pack .prefs.target.rt.pod    -fill x
pack .prefs.target.rt.plain  -fill x
pack .prefs.target.rt.python -fill x
#@-node:ekr.20031218072017.697:<< Create the Target Language frame >>
#@-node:ekr.20031218072017.694:createPrefsPanel
#@+node:ekr.20031218072017.698:createColorPanel
proc showColorPicker {} {
    tk_chooseColor
}

proc createColorPanel {} {

    toplevel .color
    wm title .color "Syntax Coloring"

    frame .color.f -bd 2 -relief groove
    pack  .color.f -anchor n -pady 2 -ipady 1 -ipadx 0 -expand 1 -fill x
    
    # label .color.f.lab -text "Choose syntax colors..."
    # pack  .color.f.lab -side top -fill x
    
    frame .color.f.docF -bd 2
    pack  .color.f.docF
    label .color.f.docF.lab -text "Doc parts:" -width 14 -anchor e
    button .color.f.docF.show -text "" -bg "red" -width 4
    button .color.f.docF.set -text "Set..." -command showColorPicker
    pack  .color.f.docF.lab .color.f.docF.show .color.f.docF.set -side left -padx 3
    
    frame .color.f.cF -bd 2
    pack  .color.f.cF
    label .color.f.cF.lab -text "Comments:" -width 14 -anchor e
    button .color.f.cF.show -text "" -bg "red" -width 4
    button .color.f.cF.set -text "Set..." -command showColorPicker
    pack  .color.f.cF.lab .color.f.cF.show .color.f.cF.set -side left -padx 3

    frame .color.f.sF -bd 2
    pack  .color.f.sF
    label .color.f.sF.lab  -text "Strings:" -width 14 -anchor e
    button .color.f.sF.show -bg "green" -width 4
    button .color.f.sF.set -text "Set..." -command showColorPicker
    pack  .color.f.sF.lab .color.f.sF.show .color.f.sF.set -side left -padx 3
    
    frame .color.f.kF -bd 2
    pack  .color.f.kF
    label .color.f.kF.lab  -text "Keywords:" -width 14 -anchor e
    button .color.f.kF.show -bg "blue" -width 4
    button .color.f.kF.set -text "Set..." -command showColorPicker
    pack  .color.f.kF.lab .color.f.kF.show .color.f.kF.set -side left -padx 3
    
    frame .color.f.dF -bd 2
    pack  .color.f.dF
    label .color.f.dF.lab  -text "Directives:" -width 14 -anchor e
    button .color.f.dF.show -bg "blue" -width 4
    button .color.f.dF.set -text "Set..." -command showColorPicker
    pack  .color.f.dF.lab .color.f.dF.show .color.f.dF.set -side left -padx 3

    frame .color.f.snF -bd 2
    pack  .color.f.snF
    label .color.f.snF.lab  -text "Section names:" -width 14 -anchor e
    button .color.f.snF.show -bg "red" -width 4
    button .color.f.snF.set -text "Set..." -command showColorPicker
    pack  .color.f.snF.lab .color.f.snF.show .color.f.snF.set -side left -padx 3

    frame .color.f.unF -bd 2
    pack  .color.f.unF
    label .color.f.unF.lab  -text "Undefined names:" -width 14 -anchor e
    button .color.f.unF.show -bg "orange" -width 4 
    button .color.f.unF.set -text "Set..." -command showColorPicker
    pack  .color.f.unF.lab .color.f.unF.show .color.f.unF.set -side left -padx 3
}
#@nonl
#@-node:ekr.20031218072017.698:createColorPanel
#@+node:ekr.20031218072017.699:createFontPanel
proc createFontPanel {w} {

    frame $w.top
    frame $w.size -bd 2 -relief "ridge"
    frame $w.sample -bd 2 -relief "ridge"
    pack $w.top $w.size $w.sample -pady 2 -ipadx 5 -anchor w -fill both
    
    << create family pane >>
    << create style pane >>
    << create buttons >>
    << create size pane >>
    << create sample pane >>
}
#@nonl
#@+node:ekr.20031218072017.700:<< create family pane >>
frame $w.top.family -bd 2 -relief "ridge"
label $w.top.family.lab -text "family"
listbox $w.top.family.box
pack $w.top.family.lab $w.top.family.box -anchor w

frame $w.top.style -bd 2 -relief "ridge"
frame $w.top.right -bd 2 -relief "flat"
pack $w.top.family $w.top.style $w.top.right -side left -fill y -padx 2 -pady 2 ; # -ipadx 5 -ipady 5
#@nonl
#@-node:ekr.20031218072017.700:<< create family pane >>
#@+node:ekr.20031218072017.701:<< create style pane >>
label $w.top.style.lab -text "Style"
pack  $w.top.style.lab -anchor w
foreach {name text} {
    b Bold
    i Italic
    u Underline
    o Overstrike
} {
    checkbutton $w.top.style.$name -text $text
    pack $w.top.style.$name -side top -anchor w -expand 1
}
#@nonl
#@-node:ekr.20031218072017.701:<< create style pane >>
#@+node:ekr.20031218072017.702:<< create buttons >>
foreach {name text} {
    ok OK
    cancel Cancel
    apply Apply
} {
    button $w.top.right.$name -text $text -width 6
    pack   $w.top.right.$name -side top -anchor w -pady 2m ; # -expand 1
}
#@nonl
#@-node:ekr.20031218072017.702:<< create buttons >>
#@+node:ekr.20031218072017.703:<< create size pane >>
frame $w.size.left
label $w.size.lab -text "Size"

text  $w.size.text -height 1 -width 4
pack  $w.size.lab -anchor w
pack  $w.size.left -side left
pack  $w.size.text -side left -fill x -expand 1

frame $w.size.left.row1
frame $w.size.left.row2
pack $w.size.left.row1 $w.size.left.row2 -side top

foreach {size} {
    8 12 18
} {
    radiobutton $w.size.left.row1.radio$size -text $size -variable size
    pack $w.size.left.row1.radio$size -side left
}
foreach {size} {
    10 14 24
} {
    radiobutton $w.size.left.row2.radio$size -text $size -variable size
    pack $w.size.left.row2.radio$size -side left
}
#@nonl
#@-node:ekr.20031218072017.703:<< create size pane >>
#@+node:ekr.20031218072017.704:<< create sample pane >>
label $w.sample.lab -text "Sample"
pack  $w.sample.lab -side top -anchor w

label $w.sample.text -text "ABCabcXYZxyz123(may be changed)"

# entry $w.sample.text -background [$w.sample cget -background]
# $w.sample.text insert 0 "ABCabcXYZxyz123(may be changed)"

pack $w.sample.text -side top -anchor c -expand 1 -fill none

# $w.sample.text insert 0 "ABCabcXYZxyz123(may be changed)"
# $w.sample.text configure -state disabled
#@nonl
#@-node:ekr.20031218072017.704:<< create sample pane >>
#@-node:ekr.20031218072017.699:createFontPanel
#@+node:ekr.20031218072017.705:dkffontCreateFontPanel
@ Build the font panel (except for the apply button, which is handled by the 'configure_apply procedure...
@c

proc origCreateFontPanel {w} {
    # Framed regions.  Do this with grid and labels, as that seems
    # to be the most effective technique in practise!
    frame $w.border1 -class DKFChooseFontFrame
    frame $w.border2 -class DKFChooseFontFrame
    frame $w.border3 -class DKFChooseFontFrame
    frame $w.border4 -class DKFChooseFontFrame
    set gap [get_gap $w]
    grid $w.border1 -row 0 -column 0 -rowspan 4 -columnspan 4 \
        -padx $gap -pady $gap -sticky nsew
    grid $w.border2 -row 0 -column 4 -rowspan 4 -columnspan 3 \
        -padx $gap -pady $gap -sticky nsew
    grid $w.border3 -row 4 -column 0 -rowspan 3 -columnspan 9 \
        -padx $gap -pady $gap -sticky nsew
    grid $w.border4 -row 7 -column 0 -rowspan 3 -columnspan 9 \
        -padx $gap -pady $gap -sticky nsew
    incr gap $gap
    foreach col {0 3 4 6 8} {
        grid columnconfigure $w $col -minsize $gap
    }
    foreach row {0 3 4 6 7 9} {
        grid rowconfigure    $w $row -minsize $gap
    }
    grid columnconfigure $w 1 -weight 1
    grid rowconfigure    $w 1 -weight 1
    grid rowconfigure    $w 8 -weight 1

    # Labels for the framed boxes & focus accelerators for their contents
    foreach {subname row col focusWin} {
        Family 0 1 .family     
        Style  0 5 .style.sBold
        Size   4 1 .size.b8    
        Sample 7 1 .sample.text
    } {
        set l [label $w.lbl$subname]
        grid $l -row $row -column $col -sticky w
        ## set accel [get_accel $l]
        ## if {[string length $accel]} {
            ## bind $w <$accel> [list focus $w$focusWin]
        ##}
    }

    # Font families
    frame $w.familyBox
    listbox $w.family -exportsel 0 -selectmode browse \
        -xscrollcommand [list $w.familyX set] \
        -yscrollcommand [list $w.familyY set]
    scrollbar $w.familyX -command [list $w.family xview]
    scrollbar $w.familyY -command [list $w.family yview]
    ##foreach family [list_families] {
    ##	$w.family insert end ['map 'capitalise $family]
    ##}
    grid $w.familyBox -row 1 -column 1 -rowspan 1 -columnspan 2 -sticky nsew
    grid columnconfigure $w.familyBox 0 -weight 1
    grid rowconfigure    $w.familyBox 0 -weight 1
    grid $w.family  $w.familyY -sticky nsew -in $w.familyBox
    grid $w.familyX            -sticky nsew -in $w.familyBox
    ## bind $w.family <1> [namespace code {'change_family %W [%W nearest %y]}]
    ## bindtags $w.family [concat [bindtags $w.family] key$w.family]
    ## bind key$w.family <Key> [namespace code {'change_family %W active %A}]

    # Font styles.
    frame $w.style
    grid $w.style -row 1 -column 5 -sticky news
    grid columnconfigure $w.style 0 -weight 1
    foreach {fontstyle lcstyle row next prev} {
        Bold      bold       0 Italic    {}
        Italic    italic     1 Underline Bold
        Underline underline  2 Strikeout Italic
        Strikeout overstrike 3 {}        Underline
    } {
        set b $w.style.s$fontstyle
        checkbutton $b -variable [namespace current]::Style($lcstyle) \
            -command [namespace code 'set_font]
        grid $b -sticky nsew -row $row
        grid rowconfigure $w.style $row -weight 1
        if {[string length $next]} {
            ## bind $b <Down> [list focus $w.style.s$next]
        }
        if {[string length $prev]} {
            ## bind $b <Up> [list focus $w.style.s$prev]
        }
        ## bind $b <Tab>       "[list focus $w.size.b8];break"
        ## bind $b <Shift-Tab> "[list focus $w.family ];break"
        ## set accel ['get_accel $b]
        ## if {[string length $accel]} {
            ## bind $w <$accel> "focus $b; $b invoke"
        ## }
        ## bind $b <Return> "$b invoke; break"
    }
    
    # Size adjustment.  Common sizes with radio buttons, and an
    # entry for everything else.
    frame $w.size
    grid $w.size -row 5 -column 1 -rowspan 1 -columnspan 7 -sticky nsew
    foreach {size row col u d l r} {
        8  0 0  {} 10 {} 12
        10 1 0   8 {} {} 14
        12 0 1  {} 14  8 18
        14 1 1  12 {} 10 24
        18 0 2  {} 24 12 {}
        24 1 2  18 {} 14 {}
    } {
        set b $w.size.b$size
        radiobutton $b -variable [namespace current]::Size -value $size \
            -command [namespace code 'set_font]
        grid $b -row $row -column $col -sticky ew
        #grid columnconfigure $w.size $col -weight 1
        ## bif {[string length $u]} {bind $b <Up>    [list focus $w.size.b$u]}
        ## bif {[string length $d]} {bind $b <Down>  [list focus $w.size.b$d]}
        ## bif {[string length $l]} {bind $b <Left>  [list focus $w.size.b$l]}
        ## bif {[string length $r]} {bind $b <Right> [list focus $w.size.b$r]}
        ## bind $b <Tab>       "[list focus $w.size.entry ];break"
        ## bind $b <Shift-Tab> "[list focus $w.style.sBold];break"
        ## set accel ['get_accel $b]
        ## if {[string length $accel]} {
            ## bind $w <$accel> "focus $b; $b invoke"
        ## }
        ## bind $b <Return> "$b invoke; break"
    }
    entry $w.size.entry -textvariable [namespace current]::Size
    grid $w.size.entry -row 0 -column 3 -rowspan 2 -sticky ew
    grid columnconfigure $w.size 3 -weight 1
    ## bind $w.size.entry <Return> [namespace code {'set_font;break}]
    
    # Sample text.  Note that this is editable
    frame $w.sample
    grid $w.sample -row 8 -column 1 -columnspan 7 -sticky nsew
    grid propagate $w.sample 0
    entry $w.sample.text -background [$w.sample cget -background]
    $w.sample.text insert 0 [option get $w.sample.text text Text]
    grid $w.sample.text
    
    # OK, Cancel and (partially) Apply.  See also 'configure_apply
    frame $w.butnframe
    grid $w.butnframe -row 0 -column 7 -rowspan 4 -columnspan 2 -sticky nsew -pady $gap
    foreach {but code} {
        ok  0
        can 1
    } {
        button $w.butnframe.$but -command [namespace code [list set Done $code]]
        pack   $w.butnframe.$but -side top -fill x -padx [expr {$gap/2}] -pady [expr {$gap/2}]
    }
    button $w.butnframe.apl
    ## bind $w.butnframe.ok <Down> [list focus $w.butnframe.can]
    ## bind $w.butnframe.can <Up> [list focus $w.butnframe.ok]
}
#@nonl
#@+node:ekr.20031218072017.706:get_accel
# Convenience proc to get the accelerator for a particular window
# if the user has given one.  Makes it simpler to get this right
# everywhere it is needed...

proc get_accel {w} {
    option get $w accelerator Accelerator
}
#@nonl
#@-node:ekr.20031218072017.706:get_accel
#@+node:ekr.20031218072017.707:get_gap
# Get the gap spacing for the frameboxes.  Use a user-specified
# default if there is one (that is a valid integer) and fall back
# to measuring/guessing otherwise.
proc get_gap {w} {
    set gap [option get $w lineGap LineGap]
    if {[catch {incr gap 0}]} {
        # Some cunning font measuring!
        label $w._testing
        set font [$w._testing cget -font]
        set gap [expr {[font metrics $font -linespace]/2+1}]
        destroy $w._testing
    }
    return $gap
}
#@nonl
#@-node:ekr.20031218072017.707:get_gap
#@+node:ekr.20031218072017.708:list_families
# Get a sorted lower-case list of all the font families defined on
# the system.  A canonicalisation of [font families]
proc list_families {} {
    lsort [string tolower [font families]]
}
#@-node:ekr.20031218072017.708:list_families
#@-node:ekr.20031218072017.705:dkffontCreateFontPanel
#@+node:ekr.20031218072017.709:createComparePanel
# Path 1: text box
# Path 2: text box

# check: File extension: text box

# Radio buttons:
# 	* print all lines
# 	* print mismatches
# 	* print matches
    
# check: stop after first mismatch
# check: send result to file: text box
# check: generate diffs
# check: ignore whitespace
# check: ignore blank lines

proc createComparePanel {} {

    toplevel .comparePanel
}
#@nonl
#@-node:ekr.20031218072017.709:createComparePanel
#@+node:ekr.20031218072017.710:createWindowWithCursor
# apparantly this is a Tk bug on XP.
proc createWindowWithCursor {} {

    toplevel .panel
    text     .panel.text
    .panel.text configure -cursor {gumby red green}
    pack .panel.text
}
#@nonl
#@-node:ekr.20031218072017.710:createWindowWithCursor
#@+node:ekr.20031218072017.711:createWindowWithIcon
proc createWindowWithIcon {} {

    global tk_library
    global tcl_patchLevel

    toplevel .panel
    
    # ***** Bitmaps apparently must be only 2 colors.  Photos are everything else!

    # wm iconbitmap .panel [image create photo -file c:/prog/leoCVS/leo/Icons/box00.GIF]
    #wm iconbitmap .panel [image create bitmap -file c:/prog/leoCVS/leo/Icons/box00.bmp]
    
    # no errors, no icon
    #wm iconbitmap .panel [image create bitmap @[file join c:/ Tcl lib tk8.3 demos images face.bmp]]
    # wm iconbitmap .panel @[file join c:/ Tcl lib tk8.3 demos images face.bmp]
    
    wm iconbitmap .panel info
    
    # Bitmap image1 not defined
    #wm iconbitmap .panel [image create photo -file [file join c:/ prog leoCVS leo Icons Leoapp.GIF]]
    
    # works
    #label .panel.bitmap -borderwidth 2 -relief sunken -bitmap @[file join $tk_library demos images face.bmp]
    #label .panel.lab -text $tk_library
    # label .panel.lab -borderwidth 2 -relief sunken -bitmap @[file join c:/ Tcl lib tk8.3 demos images face.bmp]
    # label .panel.lab -borderwidth 2 -relief sunken -bitmap @[file join c:/ prog leoCVS leo Icons face.bmp]
    
    # works!! (Only GIF allowed?)
    label .panel.lab -borderwidth 2 -relief sunken -image \
        [image create photo -file [file join c:/ prog leoCVS leo Icons Leoapp.GIF]]
    pack  .panel.lab

    label .panel.lab2 -text $tcl_patchLevel
    pack  .panel.lab2
}
#@nonl
#@-node:ekr.20031218072017.711:createWindowWithIcon
#@+node:ekr.20031218072017.712:myFrame
# w is the frame to be created.
# This configures w.f to be the content.
# Typically, the user will pack more content into w.f.

proc myFrame {w args} {

    # Args must come in pairs.
    if {([llength $args] % 2) != 0} {
        error {wrong # args: should be "myFrame pathName ?options?"}
    }
    # Initialize the local vars.
    set allopts {} # options that apply everywhere.
    set fopts {} # border options.
    set lopts {} # label options (only for labels that are Tk label widgets)
    set labelanchor nw # The usual default.
    set padx 0
    set pady 0
    set bd 2
    set relief groove
    set labelwindow "" # Can be any Tk widget!
    set text "" # The user usually just sets this.
    # Set vars based on args.
    foreach {opt val} $args {
        switch -- $opt {
            -bd - -borderwidth {
                set bd $val
            }
            -relief {
                set relief $val
            }
            -text {
                lappend lopts $opt $val
                set text $val
            }
            -font - -fg - -foreground {
                lappend lopts $opt $val
            }
            -labelanchor {
                set labelanchor $val
            }
            -labelwindow {
                set labelwindow $val
            }
            -padx {
                set padx $val
            }
            -pady {
                set pady $val
            }
            -bg - -background - -cursor {
                lappend allopts $opt $val
            }
            default {
                error "Unknown or unsupported option: $opt"
            }
        }
    }
    # relief and border options are frame options.
    lappend fopts -relief $relief -bd $bd 
    # Create the frame and its border, w.bd.
    eval frame $w $allopts
    eval frame $w.bd $fopts $allopts
    # Create lw depending on args.
    if {$labelwindow != ""} {
        # Used the window the user passed in.
        set lw $labelwindow
        raise $labelwindow $w
    } elseif {$text != ""} {
        set lw $w.l
        # This is typical.
        eval label $lw $lopts $allopts -highlightthickness 0 -bd 0
    } else {
        set lw ""
    }
    # Create the frame's grid.
    eval frame $w.f $allopts
    # Configure w as a grid with 5 rows and columns:
    # 1 border, 2 pad, 3 w.f, 4 pad, 5 border.
    grid columnconfigure $w {2 4} -minsize $padx
    grid rowconfigure    $w {2 4} -minsize $pady
    grid columnconfigure $w 3     -weight 1
    grid rowconfigure    $w 3     -weight 1
    grid columnconfigure $w {1 5} -minsize $bd
    grid rowconfigure    $w {1 5} -minsize $bd
    # Create the border, w.bd.
    grid $w.bd -row 1 -col 1 -rowspan 5 -columnspan 5 -sticky news
    # Create the content, w.f in the center.
    grid $w.f -row 3 -col 3 -sticky news
    # Optional: configure lw, the label window in the frame.
    if {$lw != ""} {
        # n*, s*, w* and e* are patterns to -glob.
        switch -glob $labelanchor {
            n* {
                grid $lw -in $w -row 0 -col 2 -rowspan 2 -columnspan 3 -padx 4
            }
            s* {
                grid $lw -in $w -row 5 -col 2 -rowspan 2 -columnspan 3 -padx 4
            }
            w* {
                grid $lw -in $w -row 2 -col 0 -rowspan 3 -columnspan 2 -pady 4
            }
            e* {
                grid $lw -in $w -row 2 -col 5 -rowspan 3 -columnspan 2 -pady 4
            }
        }
        # set the sticky param to the first character of the labelanchor, i.e., n,s,e or w.
        grid $lw -sticky [string index $labelanchor 1]
    }
}
#@nonl
#@-node:ekr.20031218072017.712:myFrame
#@+node:ekr.20031218072017.713:tk labeled frames
proc makeLeoFrame {} {

    # Create the outer labeld frame (doesn't actually have a label).
    myFrame .f -relief ridge -padx 5 -pady 5
    pack .f -fill both -expand 1 -padx 5 -pady 5
    
    # Initialize the grid positioin.
    set row 0
    set col 0
    # lp is the labelanchor value: 1 or two characters, the first character indicates side.
    foreach lp {nw n ne en e es se s sw ws w wn} {
        set w .f.f.f$lp
        # Create a myFrame: everything after %w are args.
        myFrame $w -text "Hej" -padx 2 -pady 2 -labelanchor $lp
        # Place the frame in the grid.
        grid $w -row $row -col $col -sticky news -padx 5 -pady 5
        # Create two buttons and pack them in the labeled frame.
        button $w.f.b1 -text Hoppsan
        button $w.f.b2 -text Quit -command exit
        pack $w.f.b1 $w.f.b2 -side top -fill x -padx 2 -pady 2
        # Bump the grid position.
        incr col
        if {$col == 3} {
            incr row
            set col 0
        }
    }
    
    # Create the last row.
    foreach wl {l1 l2 l3} {
        # Create the "special" label w.
        switch $wl {
            l1 {
                label .$wl -text Hej -bd 2 -relief groove
            } 
            l2 {
                checkbutton .$wl -text Hej
            } 
            l3 {
                radiobutton .$wl -text Hej
            }
        } 
        set w .f.f.f$wl
    
        # Create the labled frame using the -labelwindow option.
        myFrame $w -labelwindow .$wl -padx 2 -pady 2 -labelanchor nw
        # Place the labeled frame in the grid
        grid $w -row $row -col $col -sticky news -padx 5 -pady 5
        # Create two buttons and pack them in the labeled frame.
        button $w.f.b1 -text Hoppsan
        button $w.f.b2 -text Quit -command exit
        pack $w.f.b1 $w.f.b2 -side top -fill x -padx 2 -pady 2
        # Bump the grid position.
        incr col
        if {$col == 3} {
            incr row
            set col 0
        }
    }
}
#@nonl
#@-node:ekr.20031218072017.713:tk labeled frames
#@-node:ekr.20031218072017.680:@file c:/prog/test/leoSplitter.tcl
#@+node:ekr.20031218072017.714:tkBugs.tcl
#@+node:ekr.20031218072017.715:@file c:/prog/test/tkBugs.tcl
# This file creates tk test code for prototyping.
@language tcltk
@others

bindBug
#@+node:ekr.20031218072017.716:canvasBug
proc canvasBug {} {
    toplevel .test -bg "blue"
    canvas .test.c -bd 20 -bg "white" -relief "raised"
    pack .test.c -expand 1 -fill "both"
    text .test.c.t -height 1 -background "red"
    pack .test.c.t
    menu .test 
}
#@-node:ekr.20031218072017.716:canvasBug
#@+node:ekr.20031218072017.717:bindBug
proc bindBug {} {

    toplevel .top
    
    text .top.t
    pack .top.t
    
    menu .top.m   -tearoff 0
    menu .top.m.f -tearoff 0
    menu .top.m.e -tearoff 0
    
    .top.m.f add separator
    .top.m.f add command -label "A" -command {""}
    .top.m.f add command -label "B" -command {""}

    .top.m add cascade -label "File" -menu top.m.f -underline 0
    .top.m add cascade -label "Edit" -menu top.m.e -underline 0
    
    .top configure -menu .top.m
}
#@-node:ekr.20031218072017.717:bindBug
#@-node:ekr.20031218072017.715:@file c:/prog/test/tkBugs.tcl
#@-node:ekr.20031218072017.714:tkBugs.tcl
#@-node:ekr.20031218072017.679:Tk code
#@-node:ekr.20031218072017.678:Report Tk bugs
#@+node:ekr.20031218072017.718:(tab bug)
#@+node:ekr.20040117092727:This is definitely a Tk bug
By: dthein ( Dave Hein ) 
 RE: BUG: Non-leading tabs not working properl   
2004-01-17 14:40  

 This seems to be a TK bug. I've reproduced the problem directly in Tk.

It's been around for a long time :-(

More details on this page, along with a patch for an earlier version.

http://www.qs.co.nz/Tcl/TkTabs.html

The Tk folks fixed a bug I reported with Ctrl-V behavior, but it took about a year for them to get to it. I don't have high expectations with this problem either, but I'll probably put together a patch for some of the recent version of Tk and submit the patches and bug report.  
#@-node:ekr.20040117092727:This is definitely a Tk bug
#@+node:ekr.20040118090055:Patch and bug report
https://sourceforge.net/forum/message.php?msg_id=2380238
By: dthein

I've submitted a patch and bug report to the Tk project.

The patch, #879073, for those that want to fix this problem on their systems,
is at:

http://sourceforge.net/tracker/?func=detail&aid=879073&group_id=12997&atid=31299
7

And the bug report, #879077, is at:

http://sourceforge.net/tracker/?func=detail&aid=879077&group_id=12997&atid=11299
7

The patch is for 8.4.2.  If you have a different version, you can probably figure
out the changes needed by looking at the patch file.  If not, let me know your
version and I may be able to produce a patch for it.

Note: If you use tabs for anything other than leading whitespace, you will find
this patch really helpful.  I make lots of little tables when I'm documenting
or note-taking ... this fix really helped my sanity when making those tables
inside Leo.

Dave Hein
#@nonl
#@-node:ekr.20040118090055:Patch and bug report
#@+node:ekr.20031218072017.719:Report
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1906790
By: dspeed
Open Discussion

-- Tabs are not expanded correctly in .c files, when language in preferences is set to c, and when the tabs occur in the middle of a line. The tabs are expanded as spaces until the next tab location is reached, then the tabs are expanded correctly. 
#@-node:ekr.20031218072017.719:Report
#@+node:ekr.20040105070023.5:Report 2
Leo 4.1 rc3, build 1.62 , December 19, 2003
Python 2.3.0, Tk 8.4.2
Linux 2.4.22-21mdkenterprise

1. Any tab typed before the first tab stop behaves correctly (the cursor is moved to the tab stop). Good.

2. Any tab typed after a non-tab character (even a space) _and_ after the first tab stop position doesn't behave like a tab and doesn't move the cursor to the next tab stop. Bad.

3. Any tab typed after a tab character will behave properly no matter what position on the line. Okay.

To reproduce this, set your global tab prefernence to 4. Show invisibles. And then create a node containing:

[BEGIN BODY TEXT]
@language plain
@tabwidth 8
[END BODY TEXT]

Create a child node to that one, containing:

[BEGIN BODY TEXT]
@root-code somefilename
\t\tThis works
bbb\tAnd This works
So\tdoes this

But, this \tdoes not.
Here is the two-tab \t\t behavior.
[END BODY TEXT]

I hope this is a Leo bug and not a Tk bug. 

Dave Hein 
#@nonl
#@-node:ekr.20040105070023.5:Report 2
#@+node:ekr.20031218072017.720:Minimal test
This is a test line.
#@nonl
#@-node:ekr.20031218072017.720:Minimal test
#@+node:ekr.20031218072017.721:Test File for Non Expanding Tabs
This is a test line.
put the text insertion point in the space between 'a' and 'test' above. Enter 3 tabs in a row and watch it not work.

If your expansion works correctly, then maybe something with leoconfig?  But wait, Im using the leoconfig from the beta download.

The contents of my Log Windows when opening this file:

Leo Log Window...
Pyton 2.2.2, Tk 8.3.2
reading d:\test.leo


#@-node:ekr.20031218072017.721:Test File for Non Expanding Tabs
#@+node:ekr.20031218072017.722:setTabWidth
def setTabWidth (self, w):
    
    try: # This can fail when called from scripts
        # Use the present font for computations.
        font = self.bodyCtrl.cget("font")
        root = g.app.root # 4/3/03: must specify root so idle window will work properly.
        font = tkFont.Font(root=root,font=font)
        tabw = font.measure(" " * abs(w)) # 7/2/02
        self.bodyCtrl.configure(tabs=tabw)
        self.tab_width = w
        # g.trace(w,tabw)
    except:
        g.es_exception()
        pass
#@-node:ekr.20031218072017.722:setTabWidth
#@-node:ekr.20031218072017.718:(tab bug)
#@-node:ekr.20031218072017.673:Tk bugs
#@+node:ekr.20031218072017.723:Bugs: can't recreate
#@+node:ekr.20031218072017.724:(Uppercase bug) (Can't recreate)
#@+node:ekr.20031218072017.725:Report (I can't recreate this)
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1819473
By: nobody

When I create a @file node for a file with an uppercase name like TEST.CPP, by
picking up its name, an empty node is created. On saving the leo file, it
empties the TEST.CPP file!! BAD.

On the other hand, if I key in the filename in the dialog box as 'test.cpp'
(all lowercase) the node is created properly.

Rajiv Bhagwat
#@-node:ekr.20031218072017.725:Report (I can't recreate this)
#@-node:ekr.20031218072017.724:(Uppercase bug) (Can't recreate)
#@-node:ekr.20031218072017.723:Bugs: can't recreate
#@+node:ekr.20031218072017.726:Put the setup stuff in the dist folder where they belong
#@-node:ekr.20031218072017.726:Put the setup stuff in the dist folder where they belong
#@+node:ekr.20040129133809.8:top node not saved
When opening a .leo file Leo selects the correct node but it is no longer the top most node in the window.

(no) Probably related to Leo now saving of the body pane size.
#@nonl
#@+node:ekr.20040130174232:What I did
@nocolor

- Eliminated entries like a="":  This happened because Leo no longer writes clone bits.

- Made sure Leo writes a="T" entries.  However, Leo really can't use this easily.

Another possibility would be to save the scrolling state, but that is very gui-dependent.
#@nonl
#@-node:ekr.20040130174232:What I did
#@+node:ekr.20031218072017.1579:putVnodes
def putVnodes (self):

    """Puts all <v> elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("<vnodes>") ; self.put_nl()

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition,ignored=False) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            self.putVnode(p,ignored=False) # Write the next top-level node.

    self.put("</vnodes>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1579:putVnodes
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    c = self.c ; v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched <v.
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUnknownAttribute("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.

    << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    g.trace(t)
    raise invalidPaste
#@nonl
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p,ignored):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isIgnore = False
    if 0: # Wrong: must check all parents.
        ignored = ignored or p.isAtIgnoreNode()
    else:
        for p2 in p.self_and_parents_iter():
            if p2.isAtIgnoreNode():
                isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("<v")
    << Put tnode index >>
    << Put attribute bits >>
    << Put tnodeList and unKnownAttributes >>
    fc.put(">")
    << Write the head text >>

    if not self.usingClipboard:
        << issue informational messages >>

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,ignored)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    fc.put(" t=") ; fc.put_in_dquotes(gnx)

    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):   attr += "T" # was a bottleneck
    if c.isCurrentPosition(p):      attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20040702085529:<< issue informational messages >>
if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@nonl
#@-node:ekr.20040702085529:<< issue informational messages >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
    fc.put("<vh>")
    fc.putEscapedString(headString)
    fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.2297:fileCommands.open
def open(self,theFile,fileName):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    c.beginUpdate()
    ok, ratio = self.getLeoFile(fileName,atFileNodesFlag=True)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio) # 12/2/03
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    c.endUpdate()
    # delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
#@-node:ekr.20031218072017.2297:fileCommands.open
#@+node:ekr.20031218072017.3030:fileCommands.readOutlineOnly
def readOutlineOnly (self,theFile,fileName):

    c = self.c
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    c.beginUpdate()
    ok, ratio = self.getLeoFile(fileName,atFileNodesFlag=False)
    c.endUpdate()
    c.frame.deiconify()
    vflag,junk,secondary_ratio = self.frame.initialRatios()
    c.frame.resizePanesToRatio(ratio,secondary_ratio)
    if 0: # 1/30/04: this is useless.
        # This should be done after the pane size has been set.
        if self.topPosition:
            c.frame.tree.setTopPosition(self.topPosition)
            c.redraw()
    # delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
#@-node:ekr.20031218072017.3030:fileCommands.readOutlineOnly
#@-node:ekr.20040129133809.8:top node not saved
#@-node:ekr.20031218072017.663:Bug: can't be fixed
#@+node:ekr.20040105064959:Bugs: can wait
@nocolor
#@nonl
#@+node:ekr.20040115165036:bug in xml doc parts (hard to fix?)
@language html
@ignore
@color
#@nonl
#@+node:ekr.20040115165036.1:Demo XML comment bug
@ 
This document demonstrates what appears to be a bug in Leo 4.1 rc3, build 1.62 of December 19, 2003.

It has manifested when Leo is executed under Python 2.3.3, Tk 8.4.3 under Windows 2000.

In brief, derived XML files are not well-formed with respect to comments under some conditions.  Comments can wind up nested, which looks okay to humans but not to XML parsers.
@c
#@nonl
#@-node:ekr.20040115165036.1:Demo XML comment bug
#@+node:ekr.20040115165036.3:@file xmlcommentbug.xml
@first
@language HTML
<HiMom>
@ This will produce, in the derived file, an XML comment with another XML comment embedded.  Or, if you prefer, it will produce an unclosed XML comment followed by a well-formed one, followed by a string of text containing a comment-close marker.

This text is sitting in the inner comment, according to the first view.
@c


@
This comment is well-formed, seemingly because its content does not begin on the same line as the at-sign.
@c
</HiMom>
#@nonl
#@-node:ekr.20040115165036.3:@file xmlcommentbug.xml
#@+node:ekr.20040115165036.4:xmlcommentbug.xml
<?xml version='1.0'?>
<!--@+leo-ver=4-->
<!--@+node:@file xmlcommentbug.xml-->
<!--@@first-->
<!--@@language HTML-->
<HiMom>
<!--@+at -->
<!--
<!--@nonl-->
This will produce, in the derived file, an XML comment with another XML 
comment embedded.  Or, if you prefer, it will produce an unclosed XML comment 
followed by a well-formed one, followed by a string of text containing a 
comment-close marker.

This text is sitting in the inner comment, according to the first view.
-->
<!--@-at-->
<!--@@c-->


<!--@+at-->
<!--
This comment is well-formed, seemingly because its content does not begin on 
the same line as the at-sign.
-->
<!--@-at-->
<!--@@c-->
</HiMom>
<!--@nonl-->
<!--@-node:@file xmlcommentbug.xml-->
<!--@-leo-->
#@nonl
#@-node:ekr.20040115165036.4:xmlcommentbug.xml
#@-node:ekr.20040115165036:bug in xml doc parts (hard to fix?)
#@+node:ekr.20040125114453:Import bug?control-alt-f of python code misalloctes code (waiting for answer)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2391076
By: thyrsus

There is a lot of correct intepretation going on, but there are some errors.
As an example, the anaconda code, in text.py, contains the following lines.
I'll use periods for leading whitespace, the two characters ^I for leading tabs,
and a $ to indicate a newline:

class WaitWindow:
def pop(self):
    self.screen.popWindow()
    self.screen.refresh()

def __init__(self, screen, title, text):
    self.screen = screen
    width = 40
    if (len(text) < width): width = len(text)

    t = TextboxReflowed(width, text)

    g = GridForm(self.screen, title, 1, 1)
    g.add(t, 0, 0)
    g.draw()
    self.screen.refresh()


After importing file text.py, I get three associated nodes like so:

[class WaitWindow]
.|
.+-[pop]
.|
.+-[__init__]

However, the contents of the nodes are off.  In node [class WaitWindow] the
text is

class WaitWindow:
@others
    self.screen = screen
    width = 40
    if (len(text) < width): width = len(text)

    t = TextboxReflowed(width, text)
    g = GridForm(self.screen, title, 1, 1)
    g.add(t, 0, 0)
    g.draw()
    self.screen.refresh()

Node [pop] contains the text

def pop(self):

Node [__init__] contains the text

self.screen.popWindow()
self.screen.refresh()

def __init__(self, screen, title, text):

This anaconda code is being correctly interpreted by the python 1.5 interpreter.
I'm too green with python to pronounce on whether the formatting is conventional.
I don't consider this a bug a major problem, but it should probably be addressed
before we start touting Leo for large collections of existing code.

This is my first experience importing python; in the past I've imported perl
code, and Leo gave me just one big @file node, and I was on my own to better
structure it.  Given the perversity of perl syntax ("Nothing but perl can parse
Perl." - Tom Christiansen), that's probably the right thing to do.  It's a judgement
call for whomever wants to take responsibility for the python importer as to
whether that may be the right thing to do for python.
#@nonl
#@-node:ekr.20040125114453:Import bug?control-alt-f of python code misalloctes code (waiting for answer)
#@+node:ekr.20040129133809.5:Expand/contract may not work after drag (works for me)
sometimes after a drag of a node, 
then the expand/contract doesnt work.
click or menu has no effect.
in an open leo
maybe it is ok after you save the file
other times only fix is to exit & restart.
#@nonl
#@-node:ekr.20040129133809.5:Expand/contract may not work after drag (works for me)
#@-node:ekr.20040105064959:Bugs: can wait
#@-node:ekr.20040329185649:Bugs: can't be fixed or can wait
#@-node:ekr.20040123102724:Can't or wont
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
