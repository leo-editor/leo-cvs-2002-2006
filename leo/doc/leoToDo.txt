#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@@nocolor

#@+all
#@+node:EKR.20040503091111.1:Before beta 1
- Import derived file supports @file-thin.
#@nonl
#@+node:EKR.20040503093407:Import derived file
#@-node:EKR.20040503093407:Import derived file
#@+node:EKR.20040514104902:Go To Line Number
#@-node:EKR.20040514104902:Go To Line Number
#@-node:EKR.20040503091111.1:Before beta 1
#@+node:ekr.20031218072017.646:To do...
#@+node:ekr.20040414093758:Suggestions
@nocolor
 RE: Leo's reorganized to-do list   
2004-03-31 05:48  

 in order of most likely to least possible,

+1 on defineing __main__ and allowing parameters to scripts.

add python -t to test suite to catch mixed tab & space in derived files.
leoFind.py: inconsistent use of tabs and spaces 

Edit-> Delete while in headline deletes body text.

unregisterhook()

we can script the find, can we script the compare?

insert/overstrike mode in body

@path and other directives accept python expressions

add a Stop button for find/change 
and other possibly long running scripts.
possibly a plugin can already do this.

Tabbed log/Find/config window.

 
#@-node:ekr.20040414093758:Suggestions
#@+node:EKR.20040517090625:Suggestions for user interface improvement
#@+node:EKR.20040517090625.1:@url http://komodo.nique.net/~grayrest/leoUIproposal.txt
#@-node:EKR.20040517090625.1:@url http://komodo.nique.net/~grayrest/leoUIproposal.txt
#@-node:EKR.20040517090625:Suggestions for user interface improvement
#@+node:ekr.20040117092727.1: Notes
@nocolor
#@nonl
#@+node:ekr.20040117092727.2:using zodb versions
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2379351
By: korakot

If leo use database storage (ZODB or otherwise)
it could scale much better. This will bring us some
possiblity to store all versions of changes to a node
or a tree.

Cloning will then point to a specific version. If there
is no conflict, it can update to a later version when
the primary clone change. If there is a conflict
we can deal with it wisely using 'diff information'
because we have 'all versions' stored.

#@-node:ekr.20040117092727.2:using zodb versions
#@+node:ekr.20040117111232:svn links
https://sourceforge.net/forum/message.php?msg_id=2379777
By: nobody

Here is my results of a short surfing:

- The SubVersion book (explain concepts, usage, etc..)
http://svnbook.red-bean.com/html-chunk/

-SubVersion applications can be programmed in Python
http://svnbook.red-bean.com/html-chunk/ch08s02.html
http://pysvn.tigris.org/

 The main problem of using SubVersion will be the binary dependencies (no more
pure python code).

- Zope Version Control
Similar Plone access to SVN (Plone is a Zope application Plone->Zope->Python),
could give some ideas
http://plone.org/events/conferences/1/archive/PloneSVN2003.pdf

Got nothing very clear...
I think we should start by creating a requirements document.
What exactly we want to create ?

rodrigob
#@-node:ekr.20040117111232:svn links
#@+node:ekr.20040226085005:Java notes
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442609
By: nobody

>>Anyway, I can import java, javax, javax.swing. And I just created my first
JTree.

good man.  You will probably be subclassing JApplet.  You subclass a Java class
like this:

class EdwardsApplet(JApplet):
   pass

Id recommend getting the SDK javadoc on your PC or have a good link to the SDK
javadoc.  Read the JApplet doc in the Swing package.  The thing to keep in mind
is that you will be adding things to the JApplet's content pane, which will
be using a Layout Manager.  I believe the default for it is the BorderLayout.
This means after you get a reference to the ContentPane, you should be able
to add your components with:

cp = getContentPane()
cp.add( JTree() , BorderLayout.EAST )

Ill have to look at how Jython should package applets but you will be using,
I believe, a program called appletviewer that comes with the JDK to view your
applet.  Remember that Jython is a couple of versions behind CPython, so stick
to only features available in 2.1.  As is, you will be calling things like you
did in Python.  The Jython home page might have tips on building an applet.

What would be cool is if Leo could be totally packaged as a Jython applet, then
a demoer could test a pretty full fledged Leo throught there browser. :)

______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit: 
https://sourceforge.net/forum/unmonitor.php?forum_id=10226
#@-node:ekr.20040226085005:Java notes
#@-node:ekr.20040117092727.1: Notes
#@+node:ekr.20040329182535:plugins
#@+node:ekr.20040130185920.1:** Add incremental search to search plugin (make find panel smaller)
#@-node:ekr.20040130185920.1:** Add incremental search to search plugin (make find panel smaller)
#@+node:ekr.20031218072017.757:Calltips
Jonathan M. Gilligan

Calltips, as in IDLE. 
#@nonl
#@+node:ekr.20031218072017.758:Study for Tooltips/Auto-completion
@ignore
@language python
#@nonl
#@+node:ekr.20031218072017.759:Writing an Idle extension
@nocolor

Writing an IDLE extension

An IDLE extension can define new key bindings and menu entries for IDLE
edit windows.  There is a simple mechanism to load extensions when IDLE
starts up and to attach them to each edit window. (It is also possible
to make other changes to IDLE, but this must be done by editing the IDLE
source code.)

The list of extensions loaded at startup time is configured by editing
the file config.txt; see below for details.

An IDLE extension is defined by a class.  Methods of the class define
actions that are invoked by those bindings or menu entries. Class (or
instance) variables define the bindings and menu additions; these are
automatically applied by IDLE when the extension is linked to an edit
window.

An IDLE extension class is instantiated with a single argument,
`editwin', an EditorWindow instance. The extension cannot assume much
about this argument, but it is guarateed to have the following instance
variables:

    text	a Text instance (a widget)
    io		an IOBinding instance (more about this later)
    flist	the FileList instance (shared by all edit windows)

(There are a few more, but they are rarely useful.)

The extension class must not bind key events.  Rather, it must define
one or more virtual events, e.g. <<zoom-height>>, and corresponding
methods, e.g. zoom_height_event(), and have one or more class (or instance)
variables that define mappings between virtual events and key sequences,
e.g. <Alt-F2>.  When the extension is loaded, these key sequences will
be bound to the corresponding virtual events, and the virtual events
will be bound to the corresponding methods.  (This indirection is done
so that the key bindings can easily be changed, and so that other
sources of virtual events can exist, such as menu entries.)

The following class or instance variables are used to define key
bindings for virtual events:

    keydefs		for all platforms
    mac_keydefs		for Macintosh
    windows_keydefs	for Windows
    unix_keydefs	for Unix (and other platforms)

Each of these variables, if it exists, must be a dictionary whose
keys are virtual events, and whose values are lists of key sequences.

An extension can define menu entries in a similar fashion.  This is done
with a class or instance variable named menudefs; it should be a list of
pair, where each pair is a menu name (lowercase) and a list of menu
entries. Each menu entry is either None (to insert a separator entry) or
a pair of strings (menu_label, virtual_event).  Here, menu_label is the
label of the menu entry, and virtual_event is the virtual event to be
generated when the entry is selected.  An underscore in the menu label
is removed; the character following the underscore is displayed
underlined, to indicate the shortcut character (for Windows).

At the moment, extensions cannot define whole new menus; they must
define entries in existing menus.  Some menus are not present on some
windows; such entry definitions are then ignored, but the key bindings
are still applied.  (This should probably be refined in the future.)

Here is a complete example example:

class ZoomHeight:

    menudefs = [
        ('edit', [
            None, # Separator
            ('_Zoom Height', '<<zoom-height>>'),
         ])
    ]

    windows_keydefs = {
        '<<zoom-height>>': ['<Alt-F2>'],
    }
    unix_keydefs = {
        '<<zoom-height>>': ['<Control-z><Control-z>'],
    }

    def __init__(self, editwin):
        self.editwin = editwin

    def zoom_height_event(self, event):
        "...Do what you want here..."

The final piece of the puzzle is the file "config.txt", which is used
to to configure the loading of extensions.  For each extension,
you must include a section in config.txt (or in any of the other
configuration files that are consulted at startup: config-unix.txt,
config-win.txt, or ~/.idle).  A section is headed by the module name
in square brackets, e.g.

    [ZoomHeight]

The section may be empty, or it may define configuration options for
the extension.  (See ParenMatch.py for an example.)  A special option
is 'enable': including

    enable = 0

in a section disables that extension.  More than one configuration
file may specify options for the same extension, so a user may disable
an extension that is loaded by default, or enable an extension that is
disabled by default.

Extensions can define key bindings and menu entries that reference
events they don't implement (including standard events); however this is
not recommended (and may be forbidden in the future).

Extensions are not required to define menu entries for all events they
implement.

Note: in order to change key bindings, you must currently edit the file
keydefs.  It contains two dictionaries named and formatted like the
keydefs dictionaries described above, one for the Unix bindings and one
for the Windows bindings.  In the future, a better mechanism will be
provided.

#@-node:ekr.20031218072017.759:Writing an Idle extension
#@+node:ekr.20031218072017.760:config.txt
# IDLE reads several config files to determine user preferences.  This 
# file is the default config file.  When IDLE starts, it will look in
# the following four files in order:
#     config.txt                      the default config file
#     config-[win/unix/mac].txt       the generic platform config file
#     config-[sys.platform].txt       the specific platform config file
#     ~/.idle                         the user config file
#
# The last definition of each option is used.  For example, you can
# override the default window size (80x24) by defining width and
# height options in the EditorWindow section of your ~/.idle file
#
# IDLE extensions can be enabled and disabled by adding them to one of
# the config files.  To enable an extension, create a section with the
# same name as the extension, e.g. the [ParenMatch] section below.  To
# disable an extension, either remove the section or add the 'enable'
# option with the value 0.  

[EditorWindow]
width= 80
height= 24
# fonts defined in config-[win/unix].txt

[Colors]
normal-foreground= black
normal-background= white
# These color types are not explicitly defined= sync, todo, stdin
keyword-foreground= #ff7700
comment-foreground= #dd0000
string-foreground= #00aa00
definition-foreground= #0000ff
hilite-foreground= #000068
hilite-background= #006868
break-foreground= #ff7777
hit-foreground= #ffffff
hit-background= #000000
stdout-foreground= blue
stderr-foreground= red
console-foreground= #770000
error-background= #ff7777
cursor-background= black

[SearchBinding]

[AutoIndent]

[AutoExpand]

[FormatParagraph]

[ZoomHeight]

[ScriptBinding]

[CallTips]

[ParenMatch]
enable= 0
style= expression
flash-delay= 500
bell= 1
hilite-foreground= black
hilite-background= #43cd80
#@-node:ekr.20031218072017.760:config.txt
#@+node:ekr.20031218072017.761:AutoExpand.py (idle extension)
@ignore
@language python

import string
import re

###$ event <<expand-word>>
###$ win <Alt-slash>
###$ unix <Alt-slash>

class AutoExpand:
	<< decls >>
@others

#@+node:ekr.20031218072017.762:<< decls >>
keydefs = {
    '<<expand-word>>': ['<Alt-slash>'],
}

unix_keydefs = {
    '<<expand-word>>': ['<Meta-slash>', '<Alt-slash>'],
}

menudefs = [
    ('edit', [
        ('E_xpand word', '<<expand-word>>'),
     ]),
]

wordchars = string.ascii_letters + string.digits + "_"

#@-node:ekr.20031218072017.762:<< decls >>
#@+node:ekr.20031218072017.763:__init__
def __init__(self, editwin):
    self.text = editwin.text
    self.state = None
#@-node:ekr.20031218072017.763:__init__
#@+node:ekr.20031218072017.764:expand_word_event
def expand_word_event(self, event):
    curinsert = self.text.index("insert")
    curline = self.text.get("insert linestart", "insert lineend")
    if not self.state:
        words = self.getwords()
        index = 0
    else:
        words, index, insert, line = self.state
        if insert != curinsert or line != curline:
            words = self.getwords()
            index = 0
    if not words:
        self.text.bell()
        return "break"
    word = self.getprevword()
    self.text.delete("insert - %d chars" % len(word), "insert")
    newword = words[index]
    index = (index + 1) % len(words)
    if index == 0:
        self.text.bell()            # Warn we cycled around
    self.text.insert("insert", newword)
    curinsert = self.text.index("insert")
    curline = self.text.get("insert linestart", "insert lineend")
    self.state = words, index, curinsert, curline
    return "break"
#@-node:ekr.20031218072017.764:expand_word_event
#@+node:ekr.20031218072017.765:getwords
def getwords(self):
    word = self.getprevword()
    if not word:
        return []
    before = self.text.get("1.0", "insert wordstart")
    wbefore = re.findall(r"\b" + word + r"\w+\b", before)
    del before
    after = self.text.get("insert wordend", "end")
    wafter = re.findall(r"\b" + word + r"\w+\b", after)
    del after
    if not wbefore and not wafter:
        return []
    words = []
    dict = {}
    # search backwards through words before
    wbefore.reverse()
    for w in wbefore:
        if dict.get(w):
            continue
        words.append(w)
        dict[w] = w
    # search onwards through words after
    for w in wafter:
        if dict.get(w):
            continue
        words.append(w)
        dict[w] = w
    words.append(word)
    return words
#@nonl
#@-node:ekr.20031218072017.765:getwords
#@+node:ekr.20031218072017.766:getprevword
def getprevword(self):

    line = self.text.get("insert linestart", "insert")
    i = len(line)
    while i > 0 and line[i-1] in self.wordchars:
        i = i-1
    return line[i:]
#@-node:ekr.20031218072017.766:getprevword
#@-node:ekr.20031218072017.761:AutoExpand.py (idle extension)
#@+node:ekr.20031218072017.767:CallTips.py (idle extension)
# An IDLE extension that provides "Call Tips" - ie, a floating window that
# displays parameter information as you open parens.

import string,sys,types

class CallTips:
	<< class CallTips members >>

@others
#@+node:ekr.20031218072017.768:<< class CallTips members >>
@others
#@nonl
#@+node:ekr.20031218072017.769: data members
menudefs = [ ]

keydefs = {
    '<<paren-open>>': ['<Key-parenleft>'],
    '<<paren-close>>': ['<Key-parenright>'],
    '<<check-calltip-cancel>>': ['<KeyRelease>'],
    '<<calltip-cancel>>': ['<ButtonPress>', '<Key-Escape>'],
}

windows_keydefs = { }

unix_keydefs = { }

#@-node:ekr.20031218072017.769: data members
#@+node:ekr.20031218072017.770:__init__
def __init__(self, editwin):

    self.editwin = editwin
    self.text = editwin.text
    self.calltip = None

    if hasattr(self.text, "make_calltip_window"):
        self._make_calltip_window = self.text.make_calltip_window
    else:
        self._make_calltip_window = self._make_tk_calltip_window
#@-node:ekr.20031218072017.770:__init__
#@+node:ekr.20031218072017.771:close
def close(self):

    self._make_calltip_window = None
#@-node:ekr.20031218072017.771:close
#@+node:ekr.20031218072017.772:_make_tk_calltip_window
# Makes a Tk based calltip window.
# Used by IDLE, but not Pythonwin.
# See __init__ above for how this is used.

def _make_tk_calltip_window(self):

    import CallTipWindow
    return CallTipWindow.CallTip(self.text)
#@-node:ekr.20031218072017.772:_make_tk_calltip_window
#@+node:ekr.20031218072017.773:_remove_calltip_window
def _remove_calltip_window(self):
	
    if self.calltip:
        self.calltip.hidetip()
        self.calltip = None

#@-node:ekr.20031218072017.773:_remove_calltip_window
#@+node:ekr.20031218072017.774:paren_open_event
def paren_open_event(self, event):

    self._remove_calltip_window()
    arg_text = get_arg_text(self.get_object_at_cursor())
    if arg_text:
        self.calltip_start = self.text.index("insert")
        self.calltip = self._make_calltip_window()
        self.calltip.showtip(arg_text)
    return "" #so the event is handled normally.
#@-node:ekr.20031218072017.774:paren_open_event
#@+node:ekr.20031218072017.775:paren_close_event
def paren_close_event(self, event):
	
    # Now just hides, but later we should check if other
    # paren'd expressions remain open.
    self._remove_calltip_window()
    return "" #so the event is handled normally.

#@-node:ekr.20031218072017.775:paren_close_event
#@+node:ekr.20031218072017.776:check_calltip_cancel_event
def check_calltip_cancel_event(self, event):

    if self.calltip:
        # If we have moved before the start of the calltip,
        # or off the calltip line, then cancel the tip.
        # (Later need to be smarter about multi-line, etc)
        if self.text.compare("insert", "<=", self.calltip_start) or \
           self.text.compare("insert", ">", self.calltip_start + " lineend"):
            self._remove_calltip_window()

    return "" #so the event is handled normally.
#@-node:ekr.20031218072017.776:check_calltip_cancel_event
#@+node:ekr.20031218072017.777:calltip_cancel_event
def calltip_cancel_event(self, event):

    self._remove_calltip_window()
    return "" #so the event is handled normally.
#@-node:ekr.20031218072017.777:calltip_cancel_event
#@+node:ekr.20031218072017.778:get_object_at_cursor
def get_object_at_cursor(self,wordchars="._" + string.ascii_letters + string.digits):
    # Usage of ascii_letters is necessary to avoid UnicodeErrors
    # if chars contains non-ASCII.

    # XXX - This needs to be moved to a better place
    # so the "." attribute lookup code can also use it.
    text = self.text
    chars = text.get("insert linestart", "insert")
    i = len(chars)
    while i and chars[i-1] in wordchars:
        i = i-1
    word = chars[i:]
    if word:
        # How is this for a hack!
        import sys, __main__
        namespace = sys.modules.copy()
        namespace.update(__main__.__dict__)
        try:
            return eval(word, namespace)
        except:
            pass
    return None # Can't find an object.
#@-node:ekr.20031218072017.778:get_object_at_cursor
#@-node:ekr.20031218072017.768:<< class CallTips members >>
#@+node:ekr.20031218072017.779:_find_constructor
@ Given a class object, return a function object used for the constructor,
i.e., __init__() or None if we can't find one.
@c

def _find_constructor(class_ob):

    try:
        return class_ob.__init__.im_func

    except AttributeError:
        for base in class_ob.__bases__:
            rc = _find_constructor(base)
            if rc is not None: return rc

    return None
#@-node:ekr.20031218072017.779:_find_constructor
#@+node:ekr.20031218072017.780:get_arg_text
def get_arg_text(ob):

    # Get a string describing the arguments for the given object.
	argText = "" ; argOffset = 0
	if ob is not None:
		<< set fob depending on the type of ob >>
		<< get argText for functions and lambdas >>
		<< append the docstring if it exists >>
    return argText
#@nonl
#@+node:ekr.20031218072017.781:<< set fob depending on the type of ob >>
if type(ob)==types.ClassType:
    # Look for the highest __init__ in the class chain.
    fob = _find_constructor(ob)
    if fob is None:
        fob = lambda: None
    else:
        argOffset = 1

elif type(ob)==types.MethodType:
    # A hack for methods: turn it into a function but drop the "self" param.
    fob = ob.im_func
    argOffset = 1

else:
    fob = ob
#@nonl
#@-node:ekr.20031218072017.781:<< set fob depending on the type of ob >>
#@+node:ekr.20031218072017.782:<< get argText for functions and lambdas >>
@ Examples

1. string.replace(  generates:

	(s, old, new, maxsplit=-1)
	replace (str, old, new[,maxsplit]) -> string

2. d = {} ; d.get( generates:
	D.get(k[,d]) -> D[k] if D.has_key(k), else d.  d defaults to None.

This last presumably comes from the docstring.
@c

# Try and build one for Python defined functions
if type(fob) in [types.FunctionType, types.LambdaType]:
    try:
        realArgs = fob.func_code.co_varnames[argOffset:fob.func_code.co_argcount]
        defaults = fob.func_defaults or []
		# Use "=value" for each value in defaults
        defaults = list(map(lambda name: "=%s" % name, defaults))
		# Use "" for all args without defaults.
        defaults = [""] * (len(realArgs)-len(defaults)) + defaults
		# Set items to a list of arg+deflt values.
        items = map(
			lambda arg, dflt: arg+dflt, realArgs, defaults )
	
        if fob.func_code.co_flags & 0x4: items.append("...")
        if fob.func_code.co_flags & 0x8: items.append("***")
        argText = string.join(items,", ")
        argText = "(%s)" % argText
    except:pass
#@nonl
#@-node:ekr.20031218072017.782:<< get argText for functions and lambdas >>
#@+node:ekr.20031218072017.783:<< append the docstring if it exists >>
doc = getattr(ob, "__doc__", "")
if doc:
	# Remove all leading tabs, blanks and newlines.
    while doc[:1] in " \t\n":
        doc = doc[1:]
		
	# EKR: I would replace runs of whitespace by a single blank.
	doc = doc.replace("\t"," ")
	while 1:
		n = len(doc)
		doc = string.replace("  "," ")
		if n == len(doc): break

	# Take at most 70 characters of the docstring.
    pos = doc.find("\n")
    if pos < 0 or pos > 70: pos = 70

	# Append the result to argText.
    if argText: argText += "\n"
    argText += doc[:pos]
#@nonl
#@-node:ekr.20031218072017.783:<< append the docstring if it exists >>
#@-node:ekr.20031218072017.780:get_arg_text
#@+node:ekr.20031218072017.784:Test code
if __name__=='__main__':

    def t1(): "()"
    def t2(a, b=None): "(a, b=None)"
    def t3(a, *args): "(a, ...)"
    def t4(*args): "(...)"
    def t5(a, *args): "(a, ...)"
    def t6(a, b=None, *args, **kw): "(a, b=None, ..., ***)"

    class TC:
        "(a=None, ...)"
        def __init__(self, a=None, *b): "(a=None, ...)"
        def t1(self): "()"
        def t2(self, a, b=None): "(a, b=None)"
        def t3(self, a, *args): "(a, ...)"
        def t4(self, *args): "(...)"
        def t5(self, a, *args): "(a, ...)"
        def t6(self, a, b=None, *args, **kw): "(a, b=None, ..., ***)"

    def test( tests ):
        failed=[]
        for t in tests:
            expected = t.__doc__ + "\n" + t.__doc__
            if get_arg_text(t) != expected:
                failed.append(t)
                print "%s - expected %s, but got %s" % (t, `expected`, `get_arg_text(t)`)
        print "%d of %d tests failed" % (len(failed), len(tests))

    tc = TC()
    tests = t1, t2, t3, t4, t5, t6, \
            TC, tc.t1, tc.t2, tc.t3, tc.t4, tc.t5, tc.t6

    test(tests)
#@-node:ekr.20031218072017.784:Test code
#@-node:ekr.20031218072017.767:CallTips.py (idle extension)
#@-node:ekr.20031218072017.758:Study for Tooltips/Auto-completion
#@+node:ekr.20031218072017.785:Test
@ We have _lots_ of object available while Leo is running, so it would be possible to pass those objects to the tooltip routines.  However, it is not clear how useful all those global names will be.
@c

from leoGlobals import *
#print app()
#import __main__
#print __main__
#print __main__.__dict__
print es
#@nonl
#@-node:ekr.20031218072017.785:Test
#@+node:ekr.20031218072017.816:call tips to extend headlines
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1861038
By: korakot

I would like leo to have something similar to call tips
for the tree pane. It's always inconvenient that I must
resize the pane just to read the full headString.
Allowing horizontal scroll is an option, though I prefer
that leo could popup a call tip of the full headstring
when the full headstring could not be display.

Please see how 'windows explorer' do this. It help
my 'exploring' a lot.
#@-node:ekr.20031218072017.816:call tips to extend headlines
#@-node:ekr.20031218072017.757:Calltips
#@+node:ekr.20040217154256:Autocompletion
#@+node:ekr.20031218072017.798:@dictionary
@nocolor

Developers
By: jasonic ( Jason Cunliffe ) 
 @dictionary   
2003-08-21 07:51

Auto-completion dictionary files would be excellent.
Ideally each Leo language extension could just point to a separate .dict file. 

Hopefully we can build some Leo plugin utilities to generate these .dict files by parsing any file you'd like to use a 'source' for Leo dictionary. They might need manual cleanup, but vcould be big timesaver, especially for XML formats and the like. Great to be able to sahre these easily. 

Interesting uses for Leo dictionaries beyond just autocompletion. 
I am thinking they might open the door to some powerful macro/template behavior. 

For example, you load a special dictionary to help certain kinds of repetitive formatted content. CSS and XSLT could be good candidates, but also any kind of mild databases or lists. Documentation.

So first we need basic dicts for Leo supported languages: Python, Perl, Javascript etc..

Then we need to consider that any Leo Node could have its own dictionary defined inline..

@dictionary filepath-to-custom-leo-dict

With collaborative LeoN this would be very useful because connected Leo sessions could invoke each other's dictionaries!!

- Jason  
#@-node:ekr.20031218072017.798:@dictionary
#@-node:ekr.20040217154256:Autocompletion
#@+node:ekr.20040125114744:Leo to docbook xml plugin: Leo2AsciiDoc
http://sourceforge.net/forum/message.php?msg_id=2388444
By: mdawson

I use DocBook XML for my computer documentation, and lately for
publishing just about any text document.  Naturally, I wanted an
easy way to use DocBook to publish Leo outlines.

I've written a small Leo module, called Leo2AsciiDoc, that enables
automatic publication of a plain text Leo outline to HTML or PDF, or
as a web site or man page.  Stuart Rackham's AsciiDoc program (in
Python) is what makes this possible.
    Leo2AsciiDoc exports a Leo outline to a text file, from whence
it can be converted to DocBook XML by AsciiDoc, and then
automatically published via DocBook to HTML or PDF.

One Leo outline can contain any number of documents, or web sites
(via DocBook Website).

I'm also learning Literate Programming, and am happy to be able to
automatically publish (via make) a program's source and
documentation from Leo.

An example of the product is the paged HTML documentation for the
module at:
    http://devguide.leo.marshallresearch.ca

The web page for Leo2AsciiDoc is
at:
    http://leo.marshallresearch.ca

That web site is produced from a Leo outline.

    ----------------------------------------
    Michael Dawson
#@nonl
#@-node:ekr.20040125114744:Leo to docbook xml plugin: Leo2AsciiDoc
#@+node:ekr.20031218072017.830:Finish wx plugin & improve how Leo uses indices
#@-node:ekr.20031218072017.830:Finish wx plugin & improve how Leo uses indices
#@+node:ekr.20040208095208:Mark Task & Clone To Task commands
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2415033
By: nobody

Ive been scanning Speed Reams Slash post and the Faq and saw an interesting
usage pattern: Creating a node called a Task and adding cloned nodes to it that
represent that task(I hope that explains it).  I can see myself using this idiom
in the future.  Now my question is does the Task/clone idiom warrant special
commands in Leo?  My basis:

1. Do enough Leo users work with this idiom that making it easier to utilize
would be desirable?  I guess a good rule of thumb might be, if the sequence
of actions occur more frequently than the primitive commands like opening a
file it should be considered.

Maybe a way of doing it:

1. A special mark node as Task command.
2. A Add to lask marked task command, that clones a node and moves that node
into the Task node.
#@nonl
#@-node:ekr.20040208095208:Mark Task & Clone To Task commands
#@-node:ekr.20040329182535:plugins
#@+node:ekr.20040329182535.1:1-2 week projects
#@+node:ekr.20031218072017.828:Rewrite the config manager
http://sourceforge.net/forum/message.php?msg_id=2329053
By: dsalomoni

I would be reluctant to run this script in a linux environment, for the following
reasons:

1) chmod 666 on the leo config file makes it writable by anybody. 

2) on the other hand, leo is currently IMHO not suitable for generic linux
installations, because it does not support per-user config files, so you actually
need to either carve leoconfig.txt in stone (not realistic), or make it writable
by any user as above (not advisable).

3) having a single dummy leoID defeats its main purpose in a multi-user environment.
If you could set per-user config files, the leoID could by default simply derived
from the username.

As a matter of fact, I've been suggesting to friends etc wanting to try out
leo/install it on their systems not to do that globally.

So, my view is that we could:

1) in the short term, provide a simple per-user installation based for example
on the script above, but with path defaults pointing to the user's home dir
(and of course w/o the requirement to be root) -- with leoID generated by default
looking at the username.

2) in the medium term, provide per-user config possibilities -- this would possibly
allow for a system-wide installation of leo and still allow configuration, per-user
plugins, etc. But this is linked I guess to the decommissioning of/changes to
the leoConfig.leo machinery.

Davide
#@nonl
#@+node:ekr.20040105080119:Search for settings in various places: Rodrigo
@nocolor

https://sourceforge.net/forum/message.php?msg_id=2355843
By: rodrigo_b

At least pluginManager should be there too	

(or both files could be merged... who knows)

The better would be to have

$HOME/.leo/
$HOME/.leo/leoConfig.txt
$HOME/.leo/plugins/pluginManager.txt
$HOME/.leo/plugins/<myplugins>.py

look for .leoConfig.txt, then leoConfig.txt
#@nonl
#@-node:ekr.20040105080119:Search for settings in various places: Rodrigo
#@+node:ekr.20040208112836:Specify shortcuts, ampersand bindings & translations in the same place
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2415127
By: edream

I have just hacked the code to allow & in entries in leoConfig.txt that describe
shortcuts.

This is a hack because it probably interacts poorly with the present mechanism
that allows menu entries to be translated.  I haven't looked into this in detail:
possibly everything works when menus are translated.  More likely things break.
If so, not using & in leoConfig.txt will probably "restore" things to their
former not-very-good state.

It appears that I shall have to revisit this whole gruesome topic when
the configuration code gets rewritten.
#@nonl
#@-node:ekr.20040208112836:Specify shortcuts, ampersand bindings & translations in the same place
#@+node:ekr.20040212094034:Another comment
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2420426
By: dalcolmo

> One copy of leoConfig.txt might specify installation options; other copies
might specify per-folder or per-file options.

Maybe I misunderstand this, but would the .leo file be the place for any per-file
options?

> "inheritable" copies of leoConfig.txt.
Yes! I want a copy per user, so I won't have to manually update the latest
installation of leo with my configurations. The typical global rc file (in /etc
or in the leo program dir) and local config file in ~/.leo would do fine. As
far as I am concerned, that would also be my preferred setup under Windows,
but I am sure most people would disagree.

Please move all global configuration options to one place. Currently, besides
having to edit leoConfig.leo, I have also to edit leoPlugins.leo or
pluginsManager.txt
I believe, these should also be configuration settings.

Best regards - Josef Dalcolmo
#@nonl
#@-node:ekr.20040212094034:Another comment
#@+node:ekr.20040213060739:Config stuff
@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 4.1rc4 Plug-in Bug?   
2004-02-13 03:32  

 if you write protect leoconfig.txt you also notice via traceback that it opens for write on entry too, not sure if it actually writes anything at that time.

looking forward to what the team dreams up for config options.
checkbox or dropdown & edit of available options
with spin boxes for font size etc
a positive way to lock all the panes ito the same scheme or allow individual choice.
and all the other per user options maybe an override on the command line to enable or disable a plugin or select a particular config.txt
 
#@-node:ekr.20040213060739:Config stuff
#@+node:ekr.20040216153659.1:Find some way to translate all other Leo messages.
Including, e.g., Undo messages.
#@nonl
#@-node:ekr.20040216153659.1:Find some way to translate all other Leo messages.
#@+node:ekr.20031218072017.651:Suggestion from RodrigoB
http://sourceforge.net/forum/message.php?msg_id=2312787
By: nobody

I had the idea some days ago, and I think I have not posted it yet.

The idea is simple but usefull, it is related about how to get a better configuration
interface for Leo.
The idea is:

let the configuration interface be a Plugin. This plugin define the
@configuration-file nodes. Under that nodes (and they childs), when selecting
the body, the body text is parsed to construct a tk dialog directly into the
body pane (replacing the text view, or as a window element in the text). When
modifying the menu, the text is changed. If something go wrong with the text
format, an error is raised and the original text is show.

The advantage of this plugin is that it is easier to devellop and integrate
very well with the actual scheme. It allow to define the configuration as a
hierarchy of nodes, similar to the linux kernel configuration, and use the power
of Leo.

The text format could be

option1 = 1 # checkbox <= the plugin infere that it have to show the option1
as a checkbox
option2 = bla # [bla, blo, bli] <= the plugin infere that it have to show a
combobox for option2, with options bla, blo, bli
option3 = rodrigo # text   <= trivial, etc...

The comment after the option could allow to specify python code for conditions,
etc, etc	
Obviously the comment can be placed, the line before, or the line after, or
under what ever format required.

That is the idea, it is implementable, and, to my eyes, would solve the problem.

RodrigoB.


#@-node:ekr.20031218072017.651:Suggestion from RodrigoB
#@+node:ekr.20031218072017.652:Add settings menu
- Add Settings menu.
	- Create Settings menu dynamically from leoConfig.txt
- Write leoConfig.txt by hand.

- Remove Open LeoConfig.leo command
- Remove Apply Settings command (will be done with apply, cancel, ok, revert buttons in all Settings submenus)
#@nonl
#@+node:ekr.20031218072017.653:Notes
@nocolor

It would be an understatement to say that the way Leo handles configuration settings could be improved.  The present scheme involves editing leoConfig.leo, then remembering to save all .leo files before tangling leoConfig.leo.  Moreover, even when doing this properly, not all changes to settings "take" immediately.  Furthermore, there are no easy analogies to the typical "apply" or "revert" or "revert to default" buttons commonly seen in options dialogs.

Last night I studied the way the jEdit editor handles options.  See http://www.jedit.org/
Visually, jEdit's "Global Options" dialogs are very impressive.  There is a tree view on the left, there is a unique panel on the left for each item in the tree view.  All options are set visually.

Something like this could be done in Leo, but actually I like the opening up leoConfig.leo and setting options in a typical Leo window.  The advantage of leoConfig.leo is that there is plenty of room to explain what each setting does.

Leo's Set Colors and Set Font dialogs can and should affect the settings in leoConfig.leo, but at present they only affect leoConfig.txt, which is most annoying, and basically wrong.

This morning I realized that a large part of Leo's difficulties with configuration options stems from me trying to work around the limitations of Python's ConfigParser module.  Relying on this module may be the worst mistake I have made in the Python version of Leo.  This mistake has had several ramifications:

-  leoConfig.leo uses @root trees rather than @file trees because ConfigParser deletes all comments when writing leoConfig.txt.  Suppose instead that Leo would read and write leoConfig.txt without the "help" of the ConfigParser module.  For reading, all that is needed is that Leo parse leoConfig.txt into a single configuration dictionary.  This would, in fact, be very easy to do.

- Leo needs to do a better job of ensuring that leoConfig.txt always matches the settings in effect.  This can be done if Leo can _rewrite_ leoConfig.txt as it was (with all comments and especially sentinel lines), merely substituting new settings for old.  This is only slightly harder to do.

Other improvements come to mind, not directly related to the problems with ConfigParser:

- There should be a separate Settings Menu.  This would have the Set Colors and Set Font commands, as well as the following commands: Edit Settings (Same as present Open leoConfig.leo command) and Use Default Settings command (rewrites leoConfig.txt using preset defaults) and possibly Set Default Settings, Apply Settings and Revert Settings commands.

- All classes that use configuration settings should implement a configure method that immediately updates settings to the values just written to leoConfig.txt.  This includes the commands, frame and tree classes, and others.

With this long background, there are two main approaches to improving how Leo handles options:

1. Use a graphical scheme like jEdit does, and dispense with leoConfig.leo entirely.  leoConfig.txt would be the only repository for options.  This graphical scheme would use typical Apply, Revert, OK and Cancel buttons, much like the present Set Colors and Set Font dialogs.

2. Improve how Leo handles leoConfig.leo and leoConfig.txt so that leoConfig.leo can use @file trees and so that settings are _reliably_ updated when the user would expect them to be.

At present, I favor the second scheme.  It is simple to implement, it is the most Leonine, and moreover it allows for full discussion of all options.  true, the graphical way is good looking, but that is about all it has going for it.  I suppose a help feature could be added to the graphical way, but we are talking about a lot of effort for very little real value to the user.

Actually though, the issues of keeping leoConfig.txt up-to-date and of applying settings immediately remain mostly the same regardless of which way is chosen.  In particular, without the "help" of the ConfigParser module Leo could maintain options much more easily.

Anyway, this is how I see matters.  Any comments?

Edward
#@-node:ekr.20031218072017.653:Notes
#@+node:ekr.20031218072017.654:Cleanup prefs code?
I'm not at all sure that it is worthwhile now.
#@nonl
#@-node:ekr.20031218072017.654:Cleanup prefs code?
#@-node:ekr.20031218072017.652:Add settings menu
#@+node:ekr.20031218072017.655:multiple copies of leoConfig.txt
@nocolor

> It just leaves still the problem of merging ones personal settings of leoConfig.txt 
with the ones in the new distribution. 

I am going to work on this just after 3.11b1 goes out the door. I think what I shall do is have Leo looks for several different files: first leoConfig.txt, then leoSiteConfig.txt, with the latter overriding the former. That way you can have stable settings (leoSiteConfig.txt won't be part of distributions). 

I may also have Leo look for leoLinuxConfig.txt, leoWinConfig.txt and leoMacConfig.txt, depending on the platform, so you can have stable platform settings as well. 
#@nonl
#@-node:ekr.20031218072017.655:multiple copies of leoConfig.txt
#@+node:ekr.20031218072017.656:Different fonts for Linux/Mac
@nocolor

By: sanori ( Joo-won Jung ) 
 How about split font config for win and unix?   
2003-02-10 12:02  
Developer Forum

How about split the font's configurations like IDLE, python IDE? 
Because the 10pt size in Windows and Unix (X window, exactly) is not the same. Moreover, the font set that the OS provides does not the same. 

I'm using leo on both windows and Linux, and leo is in the vfat partition to use it both OS. Of course, I can change the font size by using the font dialog. But, I want leo to be more comportable. :)

-Sanori 
#@-node:ekr.20031218072017.656:Different fonts for Linux/Mac
#@+node:ekr.20040226105601:Design for new config system (alpaha, etc.) Tom
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2434323
By: nobody

Okay, so 4.2 is to address a graphical interface to configuring Leo, so I'm
going to go over some of the ways the Alpha, AlphaX, and AlphaTk family of
editors handle this. These are editors that use Tcl as the core scripting
language, much as elisp does for Emacs. In AlphaTk, all of the code is in Tcl &
Tk, so it run on any system that support Tcl/Tk 8.3+, and shows off the type of
dialogs that can be given to Leo as it also (currently) uses the Tk half of
this. It is available for Windows, and has a 45 day free demo period. It works
fine with The Tcl/Tk we use to run Leo so you only need to download AlphaTk.exe
via this link: http://www.santafe.edu/~vince/alphatk/download.html

In Alpha, like Emacs, their are "modes" specfic to each language that give you
useful functionality when you are editing code in that language. Each mode has
its own namespace (e.g. 'pyth' for the python Mode) that hold all the variables
and functions that provide the functionality mentioned above. There is a set of
variables and functions that form a sort of "global mode" that would be useful
in editing plain text, and provides values and simple editting bahavior if no
such simularly named things exists in the pyth namespace, if these do exist,
them overide these global values & functions when in that editting mode.

Modes are held in a directory named "Modes", in Leo this would probably be a
subdirectory of 'plugins'. In Alpha a simple mode can be defined in a single
file, Leo should proabably use the multi-file method, each mode is given its own
subdirectory (e.g. ...\plugins\Modes\Python Mode\), then various files to define
that mode's functionality would be placed in that directory. Thus you could
include the syntax files directly from jEdit here. 

Alpha only concerns itself with what it needs to know to accomplish what its
user is trying to do, thus, if a user never edits a c++ file in a session, Alpha
never loads in the details of the C Mode (which includes c++), it knows it has a
C Mode, what file extensions it should activate for & has a short description to
give if the users ask for help on the mode, but only loads the rest of the code
that defines the mode if it is called on to edit a c or c++ file. It does this
by scanning all of the subdirectories files for a function call that has all
this info as parameters. These are gathered into a cache (a script file) that
gets executed when alpha starts up. This cache has a dictionary of filenames to
modification dates so that the cache remains valid as long as the files scanned
are already in the dictionary and have the same modification dates. Any conflict
gets caught at start-up and triggers a rescanning. 

Alpha has a function, 'newPref', that builds dictionaries of various kinds of
variables, consisting of variable_name to a tuple. That tuple varies according
to the type of variable, but has as a minimum, the default value and the
namespace it is to be created in. Other parts of the tuple might include a list
of the possible values, or a series of tuples (<text to present in drop down
box>, <value>). Any change by the user to a value other than the default gets
that choice written to a cache that gets loaded the first time a mode is
activated. When newPref executes it checks to see if the variable already
exists, and only creates that variable and intializes it to the default if it
doesn't. A further wrinkle is that any comment immediately preceding a newPref
call gets stored as help text for that variable.

These dictionaries are used to allow the configuration dialog for a mode be
automatically created on the fly. Flag dictionaries get their keys dumped and
sorted to create an array of checkboxes, their stored comments forms a "tooltip"
box of text displayed when the arrow hovers over the checkbox.

Other dictionaries drive other types of widgets in the dialog panes.

More later, but much of this could be adapted to Leo. Other things to check out
are the keysetting dialogs, an example of which is under "Config->Special
Keys...".

Tom
#@+node:ekr.20040227053137:More alpha stuff
https://sourceforge.net/forum/message.php?msg_id=2444789
By: nobody

To continue on things that Alpha contribute to Leo, let me tell you the some of
the reasons behind the design.

File structure: Alpha has the equivalent of a plugin directory, however, the
actual plug-ins are organized in subdirectories; files that tell alpha how to
support languages are placed in the "Modes" directory, files that add
functionality exposed primarily through an add-in menu are placed in the "Menus"
directory (Leo might use "Menus & Widgets" to include things like the new search
plug-in), other code that provides functionality that is not tied to a
particular language, and is not primarily invoked via a menu are placed in the
"Packages" directory, (e.g. the completion package that provide general word
completion).

This helps out when someone wants to roll their own code, if you want to add a
language look at the examples that are in the 'Modes' directory, you can quickly
cobble together elementary support and then extend it over time.

Installing a plug-in is really just a matter of putting the files in the right
place and have Alpha update its indexes. Now that does not mean that the new
features are enabled (other than for a language, those activate whenever Alpha
realises that it is editting a file of that language), if you go to
"Config->Global-Setup->Features" or "Config->Global-Setup->Menus", you get a
panel of checkboxes for Features or Menus that you can check to enable Globally,
(i.e. no matter what mode is currently active). Note that a tooltip box giving a
description is available whenever you hover the mouse over the feature/menu
name. These are built dynamically, are sorted alphabetically, and continued on
another page whenever their are too many to position on a single page. This
means no carefully redesign of a dialog box is needed to accomadate new
features.

The preferences for a language are only settable when a given mode is active.
Although in Alpha this is dependent on the file you are editing, Leo can be
thought of as in a given language mode dependent on what language directive is
in effect for the current cursor position. Once you are in a mode, the
"Config-><mode> Mode Prefs" Menu becomes active, Allowing you to choose what
Menus & Feature you would like available when you are in this mode. You also
have access to the Preferences that are available in that mode.

Note that any preference, feature set, menus that you chose are all store in a
cache of code that sets them to your chosen values whenever you start Alpha.
These values can be saved and used when you upgade to a new version (of Alpha or
any of its packages), conversely, discarded the Prefs directory restores you to
all the defaults as orginally specified. Mechanisms exist to prune out cached
values that are no longer used, and to ensure that a new variable that has been
added is set if it needs to be before some code gets executed.

Tom

#@-node:ekr.20040227053137:More alpha stuff
#@-node:ekr.20040226105601:Design for new config system (alpaha, etc.) Tom
#@-node:ekr.20031218072017.828:Rewrite the config manager
#@+node:ekr.20040217153407.3:** Emacs-style keystroke handling
#@+node:ekr.20031218072017.806:Auto-completion (probably won't be done)
Jonathan M. Gilligan

Autocompletion of some sort (like IDLE's edit/expand-word command). It would be
nice also to have an autocompletion for noweb node names, possibly also with
autocompletion of abbreviations (as many text editors do) and/or
language-specific keywords taken from a dictionary selected by @language.
#@-node:ekr.20031218072017.806:Auto-completion (probably won't be done)
#@+node:ekr.20031218072017.789:Delay body display so alt+arrow keys aren't slowed
@nocolor

need a delay on body display so alt+arrow keys arent slowed down while navigating.

EKR: Alt-Up and Alt-Down are bound to Go To Next/Prev visible.  The idea is that if we don't display the body text these keys will work faster.  
#@nonl
#@-node:ekr.20031218072017.789:Delay body display so alt+arrow keys aren't slowed
#@+node:ekr.20031218072017.749:Meta key
#@+node:ekr.20031218072017.750:Comments
@nocolor

As recent experiments have shown, it is very difficult to make changes in the body key handlers.

Furthermore, emacs essentially takes over the handling of _all_ keystrokes.  I like this approach, and it is way too much to do in 3.11 or 4.0.
#@nonl
#@-node:ekr.20031218072017.750:Comments
#@+node:ekr.20031218072017.751:Request
@nocolor

How about a Emacs style meta-key(Esc?) followed by up or down? or F1/F2 ? anything to escape having to hold down three keys at the same time -- which seems to be common to other shortcut combinations too. so if you could put this in as an option in the preferences -- to turn on or off meta-key binding, that would let people choose what they prefer...

EKR:  This would require Leo to remember state in the event handlers.  It could be done, and having user-configurable shortcuts should reduce the need for this considerably.
#@-node:ekr.20031218072017.751:Request
#@+node:ekr.20031218072017.752:From Brian Theado
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1864564
By: btheado

WAS:RE: Leo 3.10 comments
edream wrote:
>This is due to apparent glitches in the Tk event dispatching. The problem is
that pressing a control or alt or shift key _all by themselves_ will generate
keypress events that are passed on to Leo's key handlers

This should be easy to make simpler--just bind an empty script to <Alt-KeyPress>,
<Shift-KeyPress>, etc.  Tk chooses the most specific event it can find, so the
more general <KeyPress> handler will not fire.

On a broader note, when programming the text widget in Tcl/Tk, watching key
events is not the easiest way to detect changes in the text.  The only way the
text in a text widget can change is if either the delete or the insert subcommands
(methods) are called.  Any keypresses that end up changing text will have called
one of these subcommands.

So the simplest way to detect changes is to just intercept the calls to insert
and delete.  In Tcl/Tk intercepting these calls is pretty straightforward. 
I don't know if the same is true in Tkinter.

Also note the text widget in Tk8.4 (http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm#M72)
has a built-in way of seeing if the text has changed

All this is just food for thought.  I don't know the details of Leo's code,
so it may not be very helpful.

Brian Theado

-----

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1864584
By: btheado

If you don't already know about Tk's bindtags command, then check it out.  It
should make things like this easy.  It basically allows you to dynamically add
and remove a whole group of bindings all at once without affecting any other
bindings.

i.e. if you have a window called .text:

# Enter escape mode
bind .text <Esc> {
    # add EscapeMode to .text's list of bindings by
    # using the bindtags command (not shown)
}
bind EscapeMode <Up> {
    # Add special escape mode up handling code here
    break
}
bind EscapeMode <Down> {
    # Add special escape mode down handling code
    break
}
etc.

# Leave escape mode
bind EscapeMode <Esc> {
    # remove EscapeMode from .text's list of bindings
    # by using the bindtags command (not shown)
}

See (http://wiki.tcl.tk/bindtags) for a page with more information about bindtags
and a link to the bindtags man page.

I just wanted you to be aware of this functionality if and when you do tackle
this.  I have found Tk's event handling, bindtags functionality very powerful,
easy to use, and quite elegant for the coding I've done.

Brian Theado
#@nonl
#@-node:ekr.20031218072017.752:From Brian Theado
#@-node:ekr.20031218072017.749:Meta key
#@+node:ekr.20040401121456:emacs roadmap
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2499058
By: sgbotsford

Actually, I don't particularly care if VIM or gvim, or vi or whatever actually
works with leo.  What I would like is for the vi command keys mostly work in
leo.  It doesn't have to be
complete vi, although the closer it is, the easier for people to adapt. 

-------

Thanks for these remarks.  It's good to know what is most important for a (typical?) Emacs user.

> A first level approximation to this would be just a different shortcut keymap.

That's already possible: just edit leoConfig.txt.

> Second level would be in implement the movement commands that aren't in leo.

That would be pretty easy in a plugin.  This is probably the most important thing that Leo should have in its core to support "driving" the editor as in Emacs.  The other thing is to support the emacs style of handling keystrokes (writing keystroke info to a status line).  Better feedback on the status line will happen asap.

> Third level would be to put the hooks in for running external commands.

That already exists in various forms.  However, if what already exists isn't exactly what you want it would be very easy to write a plugin to do it.

Edward
#@nonl
#@-node:ekr.20040401121456:emacs roadmap
#@-node:ekr.20040217153407.3:** Emacs-style keystroke handling
#@+node:ekr.20031218072017.829:** gui interface for plugins manager
@nocolor

Interim design:
	
- use pluginsManager.txt in plugins directory.
	- Load file, scan for non-comment lines whose files are in plugins directory
- load plugins only if they are in pluginsManager.txt
- (later?) do a graphical interface for pluginsManager.txt

Simplest graphical interface:

- Listbox of all files.
- Enable, Disable, Revert, Cancel, OK buttons, Enable All, Disable All.
- Selecting an item in the Listbox enables one of the Enable/Disable buttons
- Selecting OK rewrites the file "in place" without altering comment lines.
- Opening file creates one entry for each .py file in plugins directory.

This is like the Spell-check plugin.
#@nonl
#@-node:ekr.20031218072017.829:** gui interface for plugins manager
#@+node:ekr.20040130073846:Use only Python indices (simplifies plugins)
This would really help when writing gui plugins.

The first place it would be useful would be in eliminating calls to the Tk search routine.
#@nonl
#@+node:ekr.20040105120208.1:Use string.find or re.find instead of tk.find
#@-node:ekr.20040105120208.1:Use string.find or re.find instead of tk.find
#@-node:ekr.20040130073846:Use only Python indices (simplifies plugins)
#@+node:ekr.20040124074218.3:pyGtk plugin
#@-node:ekr.20040124074218.3:pyGtk plugin
#@+node:ekr.20040217153407:** User customizeable tangling and untangling
#@+node:ekr.20031218072017.805:Allow other section delims besides << and >>
Maybe the section operator could be customizable, 
I personally prefer the wiki way [[name of section]]. 

@setlink-tag [[ ]] 
#@-node:ekr.20031218072017.805:Allow other section delims besides << and >>
#@+node:ekr.20031218072017.803:@template directive?
#@-node:ekr.20031218072017.803:@template directive?
#@+node:ekr.20031218072017.795:Metatags
@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 3.11 todo list & schedule   
2003-02-11 03:25  

Here are some features I'd like to see: 
 

 
3. Metatags. @sectionname or @savedate are expanded to the appropriate text when saved.

-marshall-  
#@-node:ekr.20031218072017.795:Metatags
#@-node:ekr.20040217153407:** User customizeable tangling and untangling
#@+node:ekr.20040217153407.1:** Unify @root and @file
#@-node:ekr.20040217153407.1:** Unify @root and @file
#@+node:ekr.20031218072017.658:Resolve Conflicts command (may not be needed with @thin)
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@+node:ekr.20031218072017.659:Jonathon 1
https://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  

 
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?

More things to think about.

Gil
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20031218072017.658:Resolve Conflicts command (may not be needed with @thin)
#@+node:ekr.20031218072017.811:Split panes (could be done in gui plugins)
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1759009
By: davidmcnab

Hi,

I know I've put this one before, but as I use Leo more and more, the lack of
this is really pressing.

I tried your previous suggestion - opening another editor to have a view of
the file, but this is really painful, especially when I'm wanting to work on
two or more files simultaneously.

I've tried having files open in Emacs and writing them out, then doing a 'read
@file nodes', but this doesn't always work - the changes made in Emacs aren't
getting incorporated into the Leo tree (unless I quit/restart Leo).

(BTW - I'm using latest CVS of Leo).

What would make for Total Hacking Heaven is the ability to split a body pane
vertically or horizontally, and to be able to split the sub-panes
vertically/horizontally.

What that, hotkeys would move the cursor between panes (ie make different panes
'active'). Also, clicking on a node would display that node in the *currently
active* body pane.

This in place, as well as an accurage 'goto line number' feature would make
Leo even more of a killer app.

Cheers
David

#@-node:ekr.20031218072017.811:Split panes (could be done in gui plugins)
#@-node:ekr.20040329182535.1:1-2 week projects
#@+node:ekr.20040329182535.3:2 day projects
#@+node:ekr.20040330064657:(@file-thin-wait)
#@-node:ekr.20040330064657:(@file-thin-wait)
#@+node:ekr.20031218072017.734:** Rewrite colorizer to use jEdit language descriptionfiles
#@+node:ekr.20031218072017.735:Option: case insensitive keywords
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2097076
By: nobody

Using Jason's code for Rebol and a visual DIFF, I was able to quickly add the
keywords for the assembler I use. I'm wondering if there is a way to tell Leo
to ignore keyword case -- at the present, each keyword is entered twice. Not
a big problem with modern editors, but it _would_ be nicer...

--Rich
#@-node:ekr.20031218072017.735:Option: case insensitive keywords
#@-node:ekr.20031218072017.734:** Rewrite colorizer to use jEdit language descriptionfiles
#@+node:ekr.20040217152936.1:Incremental drawing of outline pane: see projects
#@-node:ekr.20040217152936.1:Incremental drawing of outline pane: see projects
#@+node:ekr.20031218072017.743:Note windows
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2205285
By: nobody

From: Rich

Some of the things I'd like to see in Leo:

A note window for each node. This is similar to (1), but a little fancier
looking. I envision a short window at the bottom of the edit window that could
hold notes and comments about the code, such as "Test this harder" or "Find
a better way of phrasing this". This is currently available in uSoft Office
and the Eclipse IDE (http://www.eclipse.org). Perhaps a numeric reference, such
as "<<1>>" could be used.

(2) Color ''and'' italic/bold characters with @markup. One thing I'd like to
''not'' see are the markup characters in @file-nosent files.  "~~red:NOTE:~~"
does nothing for readability in plain text.
#@nonl
#@-node:ekr.20031218072017.743:Note windows
#@+node:ekr.20031218072017.754:Open text files in text window
#@-node:ekr.20031218072017.754:Open text files in text window
#@+node:ekr.20040329182535.4:Leo + zodb
#@+node:ekr.20040226114127:Zope test
from leoGlobals import *

from ZODB import FileStorage, DB

if 1:
	print "-"*20
	storage = FileStorage.FileStorage(r"c:\prog\zopeTemp\leo.fs") 
	db = DB(storage)
	print storage ; print db
	db.close()
#@-node:ekr.20040226114127:Zope test
#@+node:ekr.20031218072017.737:Leo & data bases
From: "Scott Chapman" <scott_list@mischko.com>
To: <edreamleo@charter.net>
Sent: Monday, November 10, 2003 11:05 AM
Subject: Enhancement request: Make Leo deal with a database

It would be Way Cool if Leo could deal with psycopg or other DataBase 
API compliant implementations and fetch and store database records.

Details of what I'd like to see:

I'm working on Python source code. I want Leo to pull a source code file 
from a database record built something like this:

filename: text
updated: datetimestamp
code: text

Leo would insert a new record, not update an existing one, each time a 
Save was done, with a more current time stamp.  

When a File Open was requested (i.e. a node on a existing Leo outline 
was being pulled from a database), Leo would fetch the most recent 
time-stamped version only.

I use this same technique for my wiki pages.  It's very easy to 
implement in SQL and works great.

Leo would also need the ability to save the same file to a regular 
python source code file on disk at a specific location, so you'd have 
to be able to put more than one save/load directive in a given node.

This would provide a nice version history and could lead to other Useful 
Things in Leo.

Scott
#@nonl
#@-node:ekr.20031218072017.737:Leo & data bases
#@-node:ekr.20040329182535.4:Leo + zodb
#@+node:ekr.20031218072017.797:Allow @file http & @file ftp
I'd like to see leo's @file can be extended to cover more protocols, like REBOL's "read" does. 

in short, it would be very sweet if the following work: 

@file http://www.somedomain.org/python/foo.py 

@file pass@ftp.sd.org/python/foo.py" target="_blank" target="_new">ftp://user:pass@ftp.sd.org/python/foo.py> 

while we are at it, what about xmlrpc/soap? 

should there be new directive, like @source ?
#@nonl
#@+node:ekr.20031218072017.810:Remote access Scott Powell
I will wait. Here's clarification, when you're ready for it:

All of my projects are stored on remote computers, and accessed via FTP. 
What I want is basically the ability to open up these projects directly 
through leo, instead of transferring the files manually between my computer 
and the computers that hold my projects, preferably through FTP.

My solution: A new menu item called 'FTP' or 'Remote'. Click on this, and an 
FTP dialog opens up, with an empty list of FTP sites, and the ability to add 
more. You select a site, and it brings up a list of files. You select a 
file, and it is added to your project. When you hit 'save', it automatically 
does an FTP send.

Python makes this a lot easier with the builtin module 'ftplib'. I'm sure 
there are similar things for C++. I hope you take this idea into 
consideration.

Scott Powell
CEO, Dev Designs
#@-node:ekr.20031218072017.810:Remote access Scott Powell
#@-node:ekr.20031218072017.797:Allow @file http & @file ftp
#@+node:ekr.20040310092400.1:Use calltips in outline pane
#@+node:ekr.20040324075752:Request
@nocolor

https://sourceforge.net/forum/message.php?msg_id=2460535
By: nobody

See CallTipWindow.py in IDLE 1.0.2

Fairly simple implementation - uses a new toplevel window without a border.

Read the comments in the code for potential drawbacks on some platforms.

Regards, Myles.
#@nonl
#@-node:ekr.20040324075752:Request
#@+node:ekr.20040324071749:CallTips.py
"""CallTips.py - An IDLE Extension to Jog Your Memory

Call Tips are floating windows which display function, class, and method
parameter and docstring information when you type an opening parenthesis, and
which disappear when you type a closing parenthesis.

Future plans include extending the functionality to include class attributes.

"""

import sys
import string
import types

import CallTipWindow

import __main__

@others
#@+node:ekr.20040324071749.2:class CallTips
class CallTips:
	menudefs = [ ]
	
@others

#@+node:ekr.20040324071749.4:__init__
def __init__(self, editwin=None):

    if editwin == None:  # subprocess and test
        self.editwin = None
        return

    self.editwin = editwin
    self.text = editwin.text
    self.calltip = None
    self._make_calltip_window = self._make_tk_calltip_window
#@nonl
#@-node:ekr.20040324071749.4:__init__
#@+node:ekr.20040324071749.5:close
def close(self):

    self._make_calltip_window = None
#@-node:ekr.20040324071749.5:close
#@+node:ekr.20040324071749.6:_make_tk_calltip_window
def _make_tk_calltip_window(self):
	
    # See __init__ for usage
    return CallTipWindow.CallTip(self.text)
#@nonl
#@-node:ekr.20040324071749.6:_make_tk_calltip_window
#@+node:ekr.20040324071749.7:_remove_calltip_window
def _remove_calltip_window(self):

    if self.calltip:
        self.calltip.hidetip()
        self.calltip = None
#@nonl
#@-node:ekr.20040324071749.7:_remove_calltip_window
#@+node:ekr.20040324071749.8:paren_open_event
def paren_open_event(self, event):

    self._remove_calltip_window()
    name = self.get_name_at_cursor()
    arg_text = self.fetch_tip(name)
    if arg_text:
        self.calltip_start = self.text.index("insert")
        self.calltip = self._make_calltip_window()
        self.calltip.showtip(arg_text)
    return "" #so the event is handled normally.
#@nonl
#@-node:ekr.20040324071749.8:paren_open_event
#@+node:ekr.20040324071749.9:paren_close_event
def paren_close_event(self, event):

    # Now just hides, but later we should check if other
    # paren'd expressions remain open.
    self._remove_calltip_window()

    return "" #so the event is handled normally.
#@-node:ekr.20040324071749.9:paren_close_event
#@+node:ekr.20040324071749.10:check_calltip_cancel_event
def check_calltip_cancel_event(self, event):

    if self.calltip:
        # If we have moved before the start of the calltip,
        # or off the calltip line, then cancel the tip.
        # (Later need to be smarter about multi-line, etc)
        if self.text.compare("insert", "<=", self.calltip_start) or \
           self.text.compare("insert", ">", self.calltip_start
                             + " lineend"):
            self._remove_calltip_window()

    return "" #so the event is handled normally.
#@-node:ekr.20040324071749.10:check_calltip_cancel_event
#@+node:ekr.20040324071749.11:calltip_cancel_event
def calltip_cancel_event(self, event):

    self._remove_calltip_window()

    return "" #so the event is handled normally.
#@-node:ekr.20040324071749.11:calltip_cancel_event
#@+node:ekr.20040324071749.12:get_name_at_cursor
__IDCHARS = "._" + string.ascii_letters + string.digits

def get_name_at_cursor(self):
    idchars = self.__IDCHARS
    str = self.text.get("insert linestart", "insert")
    i = len(str)
    while i and str[i-1] in idchars:
        i -= 1
    return str[i:]
#@-node:ekr.20040324071749.12:get_name_at_cursor
#@+node:ekr.20040324071749.13:fetch_tip
def fetch_tip(self, name):

    """Return the argument list and docstring of a function or class

    If there is a Python subprocess, get the calltip there.  Otherwise,
    either fetch_tip() is running in the subprocess itself or it was called
    in an IDLE EditorWindow before any script had been run.

    The subprocess environment is that of the most recently run script.  If
    two unrelated modules are being edited some calltips in the current
    module may be inoperative if the module was not the last to run.

    """
    try:
        rpcclt = self.editwin.flist.pyshell.interp.rpcclt
    except:
        rpcclt = None
    if rpcclt:
        return rpcclt.remotecall("exec", "get_the_calltip",
                                 (name,), {})
    else:
        entity = self.get_entity(name)
        return get_arg_text(entity)
#@nonl
#@-node:ekr.20040324071749.13:fetch_tip
#@+node:ekr.20040324071749.14:get_entity
def get_entity(self, name):

    "Lookup name in a namespace spanning sys.modules and __main.dict__"
    if name:
        namespace = sys.modules.copy()
        namespace.update(__main__.__dict__)
        try:
            return eval(name, namespace)
        except:
            return None
#@nonl
#@-node:ekr.20040324071749.14:get_entity
#@-node:ekr.20040324071749.2:class CallTips
#@+node:ekr.20040324071749.15:_find_constructor
def _find_constructor(class_ob):
	
    # Given a class object, return a function object used for the
    # constructor (ie, __init__() ) or None if we can't find one.
	
    try:
        return class_ob.__init__.im_func
    except AttributeError:
        for base in class_ob.__bases__:
            rc = _find_constructor(base)
            if rc is not None: return rc
    return None

#@-node:ekr.20040324071749.15:_find_constructor
#@+node:ekr.20040324071749.16:get_arg_text
def get_arg_text(ob):
    "Get a string describing the arguments for the given object"
    argText = ""
    if ob is not None:
        argOffset = 0
        if type(ob)==types.ClassType:
            # Look for the highest __init__ in the class chain.
            fob = _find_constructor(ob)
            if fob is None:
                fob = lambda: None
            else:
                argOffset = 1
        elif type(ob)==types.MethodType:
            # bit of a hack for methods - turn it into a function
            # but we drop the "self" param.
            fob = ob.im_func
            argOffset = 1
        else:
            fob = ob
        # Try and build one for Python defined functions
        if type(fob) in [types.FunctionType, types.LambdaType]:
            try:
                realArgs = fob.func_code.co_varnames[argOffset:fob.func_code.co_argcount]
                defaults = fob.func_defaults or []
                defaults = list(map(lambda name: "=%s" % name, defaults))
                defaults = [""] * (len(realArgs)-len(defaults)) + defaults
                items = map(lambda arg, dflt: arg+dflt, realArgs, defaults)
                if fob.func_code.co_flags & 0x4:
                    items.append("...")
                if fob.func_code.co_flags & 0x8:
                    items.append("***")
                argText = ", ".join(items)
                argText = "(%s)" % argText
            except:
                pass
        # See if we can use the docstring
        doc = getattr(ob, "__doc__", "")
        if doc:
            doc = doc.lstrip()
            pos = doc.find("\n")
            if pos < 0 or pos > 70:
                pos = 70
            if argText:
                argText += "\n"
            argText += doc[:pos]
    return argText
#@-node:ekr.20040324071749.16:get_arg_text
#@+node:ekr.20040324071749.17:t1
#################################################
#
# Test code
#
if __name__=='__main__':

    def t1(): "()"
    def t2(a, b=None): "(a, b=None)"
    def t3(a, *args): "(a, ...)"
    def t4(*args): "(...)"
    def t5(a, *args): "(a, ...)"
    def t6(a, b=None, *args, **kw): "(a, b=None, ..., ***)"

    class TC:
        "(a=None, ...)"
        def __init__(self, a=None, *b): "(a=None, ...)"
        def t1(self): "()"
        def t2(self, a, b=None): "(a, b=None)"
        def t3(self, a, *args): "(a, ...)"
        def t4(self, *args): "(...)"
        def t5(self, a, *args): "(a, ...)"
        def t6(self, a, b=None, *args, **kw): "(a, b=None, ..., ***)"

    def test(tests):
        ct = CallTips()
        failed=[]
        for t in tests:
            expected = t.__doc__ + "\n" + t.__doc__
            name = t.__name__
            arg_text = ct.fetch_tip(name)
            if arg_text != expected:
                failed.append(t)
                print "%s - expected %s, but got %s" % (t, expected,
                                                        get_arg_text(entity))
        print "%d of %d tests failed" % (len(failed), len(tests))

    tc = TC()
    tests = (t1, t2, t3, t4, t5, t6,
             TC, tc.t1, tc.t2, tc.t3, tc.t4, tc.t5, tc.t6)

    test(tests)
#@-node:ekr.20040324071749.17:t1
#@-node:ekr.20040324071749:CallTips.py
#@+node:ekr.20040324072124:CallTipWindow.py
"""A CallTip window class for Tkinter/IDLE.

After ToolTip.py, which uses ideas gleaned from PySol
Used by the CallTips IDLE extension.

"""

import Tkinter as Tk
import leoGlobals as g

@others

if 1:
	main()
#@nonl
#@+node:ekr.20040324072124.2:class CallTip
class CallTip:

@others
#@+node:ekr.20040324072124.3:__init__
def __init__(self,widget):

	self.widget = widget
	self.tipwindow = None
	self.id = None
	self.x = self.y = 0
#@nonl
#@-node:ekr.20040324072124.3:__init__
#@+node:ekr.20040324072124.4:showtip
def showtip (self,text):

	""" Display text in calltip window"""

	if self.tipwindow or not text: return

	# truncate overly long calltip
	if len(text) >= 79: text = text[:75] + ' ...'
	self.text = text

	self.widget.see("insert")
	x,y,cx,cy = self.widget.bbox("insert")
	x = x + self.widget.winfo_rootx() + 2
	y = y + cy + self.widget.winfo_rooty()
	self.tipwindow = tw = Tk.Toplevel(self.widget)

	<< remove the border >>
	tw.wm_geometry("+%d+%d" % (x, y))
	<< Mac-specific code >>

	label = Tk.Label(tw,text=text, justify="left",
		background="#ffffe0",relief="solid",borderwidth=1,
		font=self.widget['font'])

	label.pack()
#@nonl
#@+node:ekr.20040324073536:<< remove the border >>
@
The following command has two effects:
- It removes the calltip window border (good)
- Causes (at least on Linux) the calltip to show as a top level window,
  burning through any other window dragged over it.
  Also, shows on all viewports!
@c

tw.wm_overrideredirect(1)
#@nonl
#@-node:ekr.20040324073536:<< remove the border >>
#@+node:ekr.20040324073536.1:<< Mac-specific code >>
@
This command is only needed and available on Tk >= 8.4.0 for OSX.
Without it, call tips intrude on the typing process by grabbing the focus.
@c

try:
	tw.tk.call("::tk::unsupported::MacWindowStyle",
		"style",tw._w,"help","noActivates")
except Tk.TclError:
	pass
#@nonl
#@-node:ekr.20040324073536.1:<< Mac-specific code >>
#@-node:ekr.20040324072124.4:showtip
#@+node:ekr.20040324072124.5:hidetip
def hidetip(self):

	tw = self.tipwindow
	self.tipwindow = None
	if tw:
		tw.destroy()
#@nonl
#@-node:ekr.20040324072124.5:hidetip
#@-node:ekr.20040324072124.2:class CallTip
#@+node:ekr.20040324072124.6:class container (test code)
class container: # Conceptually an editor_window

@others
#@nonl
#@+node:ekr.20040324072124.7:__init__
def __init__(self):

	root = Tk.Tk()
	text = self.text = Tk.Text(root)
	text.pack(side="left", fill="both", expand=1)
	text.insert("insert","string.split")
	root.update()
	self.calltip = CallTip(text)

	text.event_add(g.virtual_event_name("calltip-show"),"(")
	text.event_add(g.virtual_event_name("calltip-hide"),")")

	text.bind(g.virtual_event_name("calltip-show"),self.calltip_show)
	text.bind(g.virtual_event_name("calltip-hide"),self.calltip_hide)

	text.focus_set()
	root.mainloop()
#@nonl
#@-node:ekr.20040324072124.7:__init__
#@+node:ekr.20040324072124.8:calltip_show
def calltip_show(self, event):

	self.calltip.showtip("Hello world")
#@nonl
#@-node:ekr.20040324072124.8:calltip_show
#@+node:ekr.20040324072124.9:calltip_hide
def calltip_hide(self, event):

	self.calltip.hidetip()
#@nonl
#@-node:ekr.20040324072124.9:calltip_hide
#@-node:ekr.20040324072124.6:class container (test code)
#@+node:ekr.20040324072124.10:main
def main():

	# Test code
	c=container()
#@nonl
#@-node:ekr.20040324072124.10:main
#@-node:ekr.20040324072124:CallTipWindow.py
#@-node:ekr.20040310092400.1:Use calltips in outline pane
#@+node:ekr.20031218072017.736:Use xml parser to read .leo files
http://www.reportlab.com

import xml.sax
#@-node:ekr.20031218072017.736:Use xml parser to read .leo files
#@+node:ekr.20040411152933:Jython (when Jython supports Python 2.2)
#@-node:ekr.20040411152933:Jython (when Jython supports Python 2.2)
#@-node:ekr.20040329182535.3:2 day projects
#@+node:ekr.20040329182535.5:1 day projects
#@+node:ekr.20031218072017.801:Zipped .leo files
By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57


Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
#@+node:ekr.20040226092546:Saving .leo files with file compression
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442772
By: ejoy

I made an experiment last night. I replaced the call to open()in leofilecommand.py
with a call to gzip.open().
The LeoPy.leo file saved this way is only 600K! And there is no significant
speed down in saving.

I think it is a good idea to add compression support for load/save .leo files.
When reading or writing file with name ending with ".leo.gz", leo can call gzip
module to uncompress/compress the file, saving a lot of disk space.

What do you think of this?
#@-node:ekr.20040226092546:Saving .leo files with file compression
#@-node:ekr.20031218072017.801:Zipped .leo files
#@+node:ekr.20031218072017.755:Delay converting tabs to spaces
Developers

 RE: tab spacing test   
2003-07-01 17:05  
Another thought that hit me last night. In vim for example, tabs are tabs until you're off the line if you've set expandtab. Never really thought about it before, but that's how it works. 

So you could do \t\t\t and then delete the entire space with 3 backspaces. But if you move the cursor off the line then it would take 12 backspaces (assuming you set the tabwidth to 4) because its been replaced with spaces. Its nice, and works well. 

- ordinarius  
#@-node:ekr.20031218072017.755:Delay converting tabs to spaces
#@+node:ekr.20040203075059:use pos linestart + 1 lines to go to next line?
This might be the best way to reliably have Tk move to the next line!
#@-node:ekr.20040203075059:use pos linestart + 1 lines to go to next line?
#@+node:ekr.20031218072017.733:Execute scripts like IDE's do
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2321235
By: paulpaterson

I think I understand what Samir is getting at. 

In PythonWin, or other IDE's for other languages, you are able to execute the
"current program" in a way that it will behave identically to if it had been
run from the command line.

For Python this requires,

1. That the script run with __name__ == "__main__", so that the standard "if
__name__ ..." section will be executed properly.

2. You are able to pass command line parameters to the script. In some IDE's
you are able to set default command line parameters and these are "injected"
into the sys.argv (or equivalent) so that, as far as the program is concerned,
it looks like you ran it from the command line with some aruments.


The underlying assumption is that you want to run an entire program from Leo,
not just a script. I would find this very useful also as I could run unit tests
or even my entire apps by just hitting, for exampe, F5.

Paul
#@nonl
#@-node:ekr.20031218072017.733:Execute scripts like IDE's do
#@+node:ekr.20031218072017.747:Mutliple cut/paste buffers?
#@-node:ekr.20031218072017.747:Mutliple cut/paste buffers?
#@+node:ekr.20031218072017.748:Import/Export to yaml
Need a good yaml parser first: I don't want to write another parser by hand.
#@nonl
#@-node:ekr.20031218072017.748:Import/Export to yaml
#@+node:ekr.20031218072017.790:Import dialog improvements
@nocolor

Other options I though would be really handy:

1. Use an existing node as a source also

2. Use an node from another Leo file.. I am not sure what the syntax for that
would be exactly

3. From a URL.. this would be really cool. People could post outlines not only
as existing Leo xml files, but as text files or even dynamic scripts. The code
to handle these would presumably need to deal with http:// intelligently. But
that's easy in Python. Rebol is great at that too.

4. Other XML file with valid filepaths in them.
That's probably a much bigger project like Leo 3.10  

Jason
#@-node:ekr.20031218072017.790:Import dialog improvements
#@+node:ekr.20031218072017.793:Keep right panes constant when tiling horizontally
This is done automatically now!  I may have to use configure events.

> When I have the 'split mode' set to display tree and log on left, and viewpane
on right, I sometimes need to increase the width of the window.

When I do the resize, the tree/log panes grow in proportion. I don't know about
others, but I'd much prefer if the tree/log panes stayed at the same width,
and only the view pane grew.
#@-node:ekr.20031218072017.793:Keep right panes constant when tiling horizontally
#@+node:ekr.20031218072017.800:Enhancements to extract section
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1858824
By: gilshwartz
Open discusstion

Currently Extract Section is only available if the first line in a selection
is a section name <<x>>. I would like to propose a few enhancements I think
should be useful, while I believe most of the code is already implemented in
Leo.

1. If the first line in a selection is not <<x>>, than Extract Section WILL
make a section name from the first line (or a version of it, see below), leave
the section name in the body, create a new node with that section name, and
will copy the selection including the first line to the new node.

Rational: this is useful when selecting a function or a class. Thus the section
name becomes the function or the class definition. The section name can either
be the full first line, or, knowing the language, Leo can make a nice section
name like it does in import, e.g. "function foo", or "class bar", without the
parameters list.

2. Even better, when Extract Section is called WITHOUT a selection it will look
for the first function/class definition before the cursor's position and will
either use it as a selection and do 1 above, or just mark it as selection, which
will enable 1 above upon a second Extract Section.

Rational: Leo does it beautifully in import and when a node's code starts to
build it is most convenient. Also, I think a variation on this was recently
asked by another user.

3. Add an option Merge Section, which when called from a named section will
merge it back to all the sections containing it.

Rational: make it easy (together with 2) to create/delete sections until the
sections picture of a new code becomes clear.

Gil

--

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1859516
By: nobody

Simpler & more intutive:
Mark text, select from menu - 'extract section', this presents a dialog box
in which you fill in the section name. It is too much work to type <<name>>
then select the whole thing...

As an enhancement, the dialog can show the first line of the selection as the
default section name, which obviously can be changed.

- Rajiv Bhagwat
#@-node:ekr.20031218072017.800:Enhancements to extract section
#@+node:ekr.20040329094003:Apply patch command
#@-node:ekr.20040329094003:Apply patch command
#@-node:ekr.20040329182535.5:1 day projects
#@+node:ekr.20040329182535.7:1-2 hour projects
#@+node:ekr.20040329190314:Most important
#@+node:ekr.20040115163454:@killcolor directive
#@-node:ekr.20040115163454:@killcolor directive
#@+node:ekr.20031218072017.833:Use @file extension by default if no @language
@nocolor

Open discussion
By: jasonic ( Jason Cunliffe ) 
 use of @language   
2003-07-16 03:40  

I am wondering why Leo does not default to just use the file suffix in @file nodes, instead of obliging @language line in in the body pane 

For example any @file ending with a suffix as defined in the language extensions could just default to use those. 

".py" for python 
".r" for rebol 
".as" for actionscript etc.. 

Should anyone need to over-ride those, they could use @language.
#@nonl
#@-node:ekr.20031218072017.833:Use @file extension by default if no @language
#@+node:ekr.20031218072017.856:context menu in body pane
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2311537
By: ejoy

Hello delevepers:
  I think add a right button context menu in body panel is useful. Especially
for cut&copy&paste operations.


from windows' notepad:
undo
-----
cut
copy
paste
delete
------
select all

It's better to let plugin customize the menu.  
#@nonl
#@-node:ekr.20031218072017.856:context menu in body pane
#@+node:ekr.20031218072017.746:Minimizing/maximizing windows
@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2090601
By: jasonic

I'll be happy to run some test and report to you. But  I suspect from your post
a slight misunderstanding about Alt+Tab.

Alt+Tab just toggles the active window.
It works fine with Leo on Windows wherver I have tried it.

Resizing wondows via hotkeys is another matter.
The special "Windows" Key + m will minimize all windows. 

But unfortunately I've not yet discovered any opposite shortcut to  maximize
all windows :-(
I've tried various 3rd party hotkey utililties, but somehow always end up dropping
them.

<rant>
I really hate wasting any time dragging windows around and resizing them or
clicking to bring them into top focus. As I work mainly with graphics, and mult-task
intesenlty bwetn apps,  it is especially important to reduce visual clutter
on screen.

For many years the way to do this has been combining maximized [or minimized]
windows with  Alt+Tab. Alt+Tab  lets one jump rapidly betwen open apps and windows
without ever need to repostion or resize them.

As a consultant, its one of the first things I ever teach clients. Often it
transforms their perception of using Windows.

It is so painful to watch people dragging and rescaling  windows all over the
place. Ironically, I've witnessed some very smart programmers fly through vi
or emacs but then slow to tortoises when navigation mice and windows. I beleive
as long as we have the curertn wnidows UI paradigm,  use of Alt+Tab is an essential
part of  GUI 'litteracy' - an essentail skill all shoudl have. Alas its still
little known or discussed.

There is also a nice toggle feature so one can jump back to the last app/window
as its first "stop". Typically one is working between two apps for some specific
task, even though many are open.

Keeping one's finger on the 'Alt' key then tapping 'Tab' lets one hop along
the list.

Adding 'shift' to the mix helps one to go in reverse. 

Above all one can keep one hand on the mouse, the other on the keyboard [ALt+Tab]
and ones mind/eye on teh screen. For me it means left hand "plays" the bass
pattern using Alt+Tab along with the clipboard shortcuts [CTRL+ z,x,c,v] ,while
right hand on the mouse mouse  provides the melody.

I've been using variations on the above since 1987 when I bought an Amiga2000.
I seem to recall SGI had one also. And after learning about Alt+Tab on windows,
I  found a utility to work the same way on Macintosh.  I am very happy to discover
that MacOSX now has built-in ALt+Tab :-)
</rant>

Meanwhile, Iam  still wondering how to set Leo [3.12 beta 1, Python 2.2.2, Tk
8.3.2] default to a maxmimized or minimized window size by itself.

And also to remember the last size/position it had. I vaguely remember that
it used to do that, but perhaps I am mistaking it for some other software ?

thanks
Jason
#@-node:ekr.20031218072017.746:Minimizing/maximizing windows
#@+node:ekr.20031218072017.791:automatic "tab nanny" and syntax checking of Python code
#@-node:ekr.20031218072017.791:automatic "tab nanny" and syntax checking of Python code
#@+node:ekr.20031218072017.742:Show diffs of changed node in top_df.read
- Show changes:
	When a derived file is modified by an editor it would be very nice if Leo would:
	- flag the file as modified and,
	- flag (underline, color, diff, whatever) the parts that were modified.
#@nonl
#@-node:ekr.20031218072017.742:Show diffs of changed node in top_df.read
#@+node:ekr.20040220110030:Change cursor when caps lock is down
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2431552
By: nobody

From: Rich

 I just got nipped twice by the following effect: the Caps-Lock key is ON, but
because the LED is on the Caps-Lock key, it is hidden behind my hand. I hit
Ctrl-x, expecting to cut my selection, but the entire node is cut.

   I know there's a problem with tk and the shift key status, so I'm wondering
if it would be possible to change the shape of the cursor when the Caps-Lock
is ON (preferrably a big red flashing blot 8-), or otherwise show that Caps-Lock
is active ( "CAPS" on a status line, for instance).

  Another way: I don't know if this goes against an "anti-modalism rule," but
only allowing Ctrl-Shift-x|c|v in the outline pane would also be acceptable
to me.
#@nonl
#@-node:ekr.20040220110030:Change cursor when caps lock is down
#@+node:ekr.20040315060557:declone command
By: nobody ( Nobody/Anonymous ) 
 having a declone() method for vnodes?   
2004-03-15 04:36  

 hi,

Ive had a use for a declone() method in vnodes recently. Have you ever thought about adding a method that declones a clone? This would entail:

1. Making a clone node a normal node.

I can see this happening when cutting a node and pasting a node that is a clone. But there doesn't seem to be a dedicated function to do the operation. :)  
#@nonl
#@-node:ekr.20040315060557:declone command
#@+node:ekr.20031218072017.792:Double Click Node command
#@-node:ekr.20031218072017.792:Double Click Node command
#@+node:ekr.20031218072017.852:Scroll improvement
@nocolor

By: jwashin ( James Washington ) 
 Scrolling and the Tree Frame in Linux   
2003-10-20 12:13  

I'm using tk-8.4.3, python-2.2.3 on linux. The MouseWheel events do not work for me in the Tree Frame.

I added <Button-4> and <Button-5> bindings similar to the existing <MouseWheel> binding in LeoFrame.finishCreate(), associating them with two methods, LeoFrame.OnMouseScrollDown and LeoFrame.OnMouseScrollUp that took the appropriate parts of OnMouseWheel()

Now it works, sort-of. It scrolls properly unless the cursor is an I-Bar, e.g., over text. But at least this removes in-part the most glaring UI problem for me with Leo in tk. I suppose I am spoiled with the mouse wheel and want it to work everywhere.

Thanks for the great program.

-- Jim Washington  
#@-node:ekr.20031218072017.852:Scroll improvement
#@-node:ekr.20040329190314:Most important
#@+node:ekr.20040329190314.2:Others
#@+node:ekr.20040213090121:Insert at end
@nocolor

By: tibi ( Thiébaut Champenier ) 
 inserting a new node   
2004-02-13 13:23  

 Hi,

When doing ctrl+i I on the node that has children I would prefer Leo to insert the new node as the last children instead of the first. It just makes more sense to me, for exemple when you take a big file and cut it in subnodes you typically start at the top and create new nodes while paging down the file.
What do you think ?
To try it just make this little change:
RCS file: /cvsroot/leo/leo/src/leoCommands.py,v
retrieving revision 1.76
diff -r1.76 leoCommands.py
2516c2516
< v = current.insertAsNthChild(0)
---
> v = current.insertAsLastChild()  
#@nonl
#@-node:ekr.20040213090121:Insert at end
#@+node:ekr.20031218072017.740:Disallow writes outside a "top-level" folder
1. Warn when creating _any_ new file.

2. Warn when rewriting any file that was not read properly.

This prevents "hijacking" an already existing file.
#@nonl
#@-node:ekr.20031218072017.740:Disallow writes outside a "top-level" folder
#@+node:ekr.20031218072017.756:Document how to use pdb plugin
#@-node:ekr.20031218072017.756:Document how to use pdb plugin
#@+node:ekr.20031218072017.745:@@first <n>
@nocolor

Hate to break into the grand design discussions, but here's a hopefully small thing. If you need to place a good sized copyright statement at the top of your files, LEO doesn't handle this case very cleanly. As I'm sure you're aware, you wind up with a matching number of @@first lines for each leading line in your source. 

As an example: 
# 1 
# 2 
# 3 
# 4 
# 5 
#@verbatim
#@+leo 
#@verbatim
#@+node:0::@file /tmp/firstcheck.py 
#@verbatim
#@+body 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@+doc 
# 
# How many firsts do I get? 

#@verbatim
#@-doc 
#@verbatim
#@@c 
Start code. 
#@verbatim
#@-body 
#@verbatim
#@-node:0::@file /tmp/firstcheck.py 
#@verbatim
#@-leo 

My fellow co-workers who don't use LEO, aren't exactly loving me here. 

Might we introduce an: 

@@first <num> 

Type tag instead? So one '@@first 5' could represent all 5 of the above @@first lines? It makes for a smaller, cleaner LEO footprint and will tick off non-LEO users much less. 

Thanks. 

- ordinarius 
#@nonl
#@-node:ekr.20031218072017.745:@@first <n>
#@+node:ekr.20031218072017.807:Put up file dialog on empty @url, etc.
@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2003457
By: dsalomoni

Proposal: modify the code for @url so that if you type for example just "@url"
(no file specified) in a headline, a window pops up allowing you to browse the
local file system and select the file (similar to what browsers do when you
want to open a file).

This would be more convenient than manually writing @url
file://a/long/path/to/the/file. @read-only nodes already allow this, it would
perhaps be nice if all these types of plugins (@folder might be another one
for example) and directives (@file etc) had the same behavior (and this should
probably be specified in some guidelines for writing new plugins -see e.g. the
jedit plugin guidelines).

Davide
#@-node:ekr.20031218072017.807:Put up file dialog on empty @url, etc.
#@+node:ekr.20040226094105:Put the scrollWheel workaround in the FAQ (or in the code??)
@nocolor
#@nonl
#@+node:ekr.20040226094105.1:halw

https://sourceforge.net/forum/message.php?msg_id=2437859
By: halw

David,

I agree that your solution is best -- the problem is it doesn't work. 

If you look at the original post you'll note that the mouse wheel works fine
in all other Leo panes (which are native text panes, not a custom canvas).

In fact, a stock RH9 system does set up X as those pages indicate. The problem
is elsewhere, perhaps Tk or Tkinter.

If Edward doesn't want to ship a workaround, that's fine. It should, IMO, make
it into the FAQ, though.

--Hal

#@-node:ekr.20040226094105.1:halw
#@+node:ekr.20040226094105.2:djsg
https://sourceforge.net/forum/message.php?msg_id=2435622
By: djsg

Tk is complying with the behavior of XFree86, and not hiding that behavior. 

Documentation for XFree86 4.2.0 -- documentation for a 4.4 development version
matches it, so 4.3.0 ought to match it also:

http://www.xfree86.org/4.2.0/mouse7.html

An example of configuration for XFree86 3.3.2.

First, the URL: 

http://www.genius-europe.com/service/faq/tuxmouse.htm

o save their bandwidth, the example follows: 


All mices with scroll wheel or stick

XFree86 >= 3.3.2 (or other XServer with wheel to mouse button support)
The mouse must be setup in XF86Config to send the mouse buttons 4 and 5 for
wheel actions.
Edit /etc/XF86Config with your favorite editor
Add the following line to the "Pointer" section.

ZAxisMapping 4 5

Make sure your Protocol is set to either "IMPS/2" for a PS/2 mouse
or for serial mice set it to "IntelliMouse" or "Auto".
Example for PS/2 wheel mouse:

Section "Pointer"
Protocol "IMPS/2"
Device "/dev/psaux"
SampleRate 60
BaudRate 1200
ZAxisMapping 4 5
Buttons 3
EndSection

After XWindows is started run :
imwheel -k


#@-node:ekr.20040226094105.2:djsg
#@+node:ekr.20040226094105.3:The actual workaround

https://sourceforge.net/forum/message.php?msg_id=2433628
By: halw

Okay, I have a workaround that works for me with my existing Tk version. My
Tkinter skills are weak, but I don't think this will hurt anything else :)

Turns out this Tk version (or X or Tkinter or 	) doesn't generate MouseWheel
events, but maps to buttons 4 (up) & 5 (down).

Add to if clause 
# Handle mouse wheel in the outline pane.
if sys.platform == "linux2": # This crashes tcl83.dll
..canvas.bind("<MouseWheel>", frame.OnMouseWheel)
..def mapWheel(e):
	if e.num == 4:
	..e.delta = 120
	..return frame.OnMouseWheel(e)
	elif e.num == 5:
	..e.delta = -120
	..return frame.OnMouseWheel(e)
..canvas.bind("<ButtonPress>", mapWheel, add=1)
#@nonl
#@-node:ekr.20040226094105.3:The actual workaround
#@-node:ekr.20040226094105:Put the scrollWheel workaround in the FAQ (or in the code??)
#@+node:ekr.20040217090833:Change how Open with works?
By: rogererens ( Roger Erens ) 
 RE: Documentation for 4.1rc3   
2004-02-04 10:04  

@nocolor

It is stated that you can edit the temporary file with the editor as named in the "Open with..." submenu.
However, the temporary files are edited with the application that is associated with their extension. In my case I always fire up vim with .txt-files.

Hence the menu item would be better called something like "Open as..." with submenu items like ".doc file" or ".txt file"

Or, use something else instead of "os.startfile" to really use the intended editor.
#@nonl
#@-node:ekr.20040217090833:Change how Open with works?
#@+node:ekr.20040311022923:Make sentinel name in @-node optional
#@-node:ekr.20040311022923:Make sentinel name in @-node optional
#@+node:ekr.20040217154134:XML as a @language
#@-node:ekr.20040217154134:XML as a @language
#@-node:ekr.20040329190314.2:Others
#@-node:ekr.20040329182535.7:1-2 hour projects
#@+node:ekr.20040123102724:Can't or wont
#@+node:ekr.20031218072017.835:(Use pywin extensions to improve cut/paste between apps)
@color

@ This is not going well :-(  Probably what is happening is that Tk is competing with the win32 extensions in setting the clipboard.  It might not be so easy to

a) completely disable Tk's clipboard handling, in _both_ headlines and body text.
b) do the cut/paste operations "by hand".

This might require new body routlines to replace the selected text in the body.  And then there are issues relating to whether the headline or body text should be changed.  All in all, this is much harder than it looks.

Also, if one is not careful one can take fatal Python errors related to missing threads.  Pretty much a nightmare.
#@nonl
#@+node:ekr.20031218072017.836:updateEditMenu
def updateEditMenu (self):

	c = self.c ; frame = c.frame ; gui = g.app.gui
	if not c: return
	try:
		# Top level Edit menu...
		enable = frame.menu.enableMenu
		menu = frame.menu.getMenu("Edit")
		c.undoer.enableMenuItems()
		<< enable cut/paste >>
		if 0: # Always on for now.
			menu = frame.menu.getMenu("Find...")
			enable(menu,"Find Next",c.canFind())
			flag = c.canReplace()
			enable(menu,"Replace",flag)
			enable(menu,"Replace, Then Find",flag)
		# Edit Body submenu...
		menu = frame.menu.getMenu("Edit Body...")
		enable(menu,"Extract Section",c.canExtractSection())
		enable(menu,"Extract Names",c.canExtractSectionNames())
		enable(menu,"Extract",c.canExtract())
		enable(menu,"Match Brackets",c.canFindMatchingBracket())
	except:
		g.es("exception updating Edit menu")
		g.es_exception()
#@nonl
#@+node:ekr.20040130164211:<< enable cut/paste >>
if frame.body.hasFocus():
	data = frame.body.getSelectedText()
	canCut = data and len(data) > 0
else:
	# This isn't strictly correct, but we can't get the Tk headline selection.
	canCut = true

enable(menu,"Cut",canCut)
enable(menu,"Copy",canCut)

data = gui.getTextFromClipboard()
canPaste = data and len(data) > 0
enable(menu,"Paste",canPaste)
#@nonl
#@-node:ekr.20040130164211:<< enable cut/paste >>
#@-node:ekr.20031218072017.836:updateEditMenu
#@+node:ekr.20031218072017.837: tkinterGui.__init__
def __init__ (self):

	# Initialize the base class.
	leoGui.leoGui.__init__(self,"tkinter")

	self.bitmap_name = None
	self.bitmap = None
	self.win32clipboard = None
	
	if 0: # This seems both dangerous and non-functional.
		if sys.platform == "win32":
			try:
				import win32clipboard
				self.win32clipboard = win32clipboard
			except:
				g.es_exception()
#@nonl
#@-node:ekr.20031218072017.837: tkinterGui.__init__
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,frame):
	
	t = self.bodyCtrl
	
	# Event handlers...
	t.bind("<Button-1>", frame.OnBodyClick)
	t.bind("<Button-3>", frame.OnBodyRClick)
	t.bind("<Double-Button-1>", frame.OnBodyDoubleClick)
	t.bind("<Key>", frame.body.onBodyKey)

	# Gui-dependent commands...
	t.bind(g.virtual_event_name("Cut"), frame.OnCut)
	t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
	t.bind(g.virtual_event_name("Paste"), frame.OnPaste)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:ekr.20031218072017.839:<< define editMenuTopTable >>
self.editMenuTopTable = (
	("Can't Undo","Ctrl+Z",c.undoer.undo), # &U reserved for Undo
	("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &R reserved for Redo
	("-",None,None),
	("Cu&t","Ctrl+X",f.OnCutFromMenu), 
	("Cop&y","Ctrl+C",f.OnCopyFromMenu),
	("&Paste","Ctrl+V",f.OnPasteFromMenu),
	("&Delete",None,c.delete),
	("Select &All","Ctrl+A",f.body.selectAllText),
	("-",None,None))
#@nonl
#@-node:ekr.20031218072017.839:<< define editMenuTopTable >>
#@+node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
def OnCut (self,event=None):
	
	"""The handler for the virtual Cut event."""

	frame = self ; c = frame.c ; v = c.currentVnode()
	
	# This is probably being subverted by Tk.
	if g.app.gui.win32clipboard:
		data = frame.body.getSelectedText()
		if data:
			g.app.gui.replaceClipboardWith(data)

	# Activate the body key handler by hand.
	frame.body.forceFullRecolor()
	frame.body.onBodyWillChange(v,"Cut")

def OnCutFromMenu (self):
	
	w = self.getFocus()
	w.event_generate(g.virtual_event_name("Cut"))
	
	frame = self ; c = frame.c ; v = c.currentVnode()

	if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
		frame.tree.onHeadChanged(v)




#@-node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
#@+node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
def OnCopy (self,event=None):
	
	frame = self

	if g.app.gui.win32clipboard:
		data = frame.body.getSelectedText()
		if data:
			g.app.gui.replaceClipboardWith(data)
		
	# Copy never changes dirty bits or syntax coloring.
	
def OnCopyFromMenu (self):

	frame = self
	w = frame.getFocus()
	w.event_generate(g.virtual_event_name("Copy"))

#@-node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
#@+node:ekr.20031218072017.843:frame.OnPaste, OnPasteNode, OnPasteFromMenu
def OnPaste (self,event=None):
	
	frame = self ; c = frame.c ; v = c.currentVnode()

	# Activate the body key handler by hand.
	frame.body.forceFullRecolor()
	frame.body.onBodyWillChange(v,"Paste")
	
def OnPasteFromMenu (self):
	
	frame = self ; c = frame.c ; v = c.currentVnode()

	w = self.getFocus()
	w.event_generate(g.virtual_event_name("Paste"))
	
	if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
		frame.tree.onHeadChanged(v)
#@nonl
#@-node:ekr.20031218072017.843:frame.OnPaste, OnPasteNode, OnPasteFromMenu
#@-node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):
	
	wcb = g.app.gui.win32clipboard

	if wcb:
		try:
			wcb.OpenClipboard(0)
			wcb.EmptyClipboard()
			wcb.SetClipboardText(s)
			wcb.CloseClipboard()
		except:
			g.es_exception()
	else:
		self.root.clipboard_clear()
		self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
	
	wcb = g.app.gui.win32clipboard
	
	if wcb:
		try:
			wcb.OpenClipboard(0)
			data = wcb.GetClipboardData()
			wcb.CloseClipboard()
			# g.trace(data)
			return data
		except TypeError:
			# g.trace(None)
			return None
		except:
			g.es_exception()
			return None
	else:
		try:
			return self.root.selection_get(selection="CLIPBOARD")
		except:
			return None
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@-node:ekr.20031218072017.835:(Use pywin extensions to improve cut/paste between apps)
#@+node:ekr.20031218072017.753:Emacs comint-mode:  The improved Execute Script command does most of this
@nocolor

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
#@-node:ekr.20031218072017.753:Emacs comint-mode:  The improved Execute Script command does most of this
#@+node:ekr.20031218072017.729:HTML rendering in Leo's body pane
#@+node:ekr.20031218072017.731:HTML plugin: opml
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2283466
By: billp9619

FYI
I played around with opml a while back and it seemed very versatile.

It basically consists of an xml file of nested outline tags similiar to v-nodes
in leo xml. This then works with an xsl stylesheet that displays the outline
in a browser with scripted outline manipulation. (Uses div tags for this
display.)

What I discovered is that any html can make up the outline nodes , even forms,
etc. which collapse with the outline interaction. Just that the angle brackets
in the html must be escaped as is done within leo t nodes in .leo xml.

Actually, it would be interesting to see an addin that just passes leo nodes
to opml and then pops into the default browser. Also keep in mind that javascript
has an eval() statement that can be passed any script as a string. The leo text
box could be a form textarea box except that then there is no way to emulate
syntax coloring. Alternatively, this could be a floating window wrappiing node
text in html/body. (if nothing else, just destroy/close the window and reinitialize).
Maybe the images used in the opml could have javascript events like onclick()
to trigger refreshing leo text box from the t-nodes stored in an array or in
hidden form boxes.

Of course the effect of the stylesheet could be done via python script if no
xslt in the receiving browser. The minimal html and script might be just boilerplate
output.

regards,
bill p
#@nonl
#@-node:ekr.20031218072017.731:HTML plugin: opml
#@-node:ekr.20031218072017.729:HTML rendering in Leo's body pane
#@+node:ekr.20040216054459:@h @f @endh and @endf directives
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2424151
By: ksejlod ( Peter Barrel ) 
 I Have a (maybe) great idea!   
2004-02-15 04:29

I've been using LEO for a while and finding surprinsingly powerfull new uses now and then, (hey, not a week passes that i dont think to myself : "why did'nt anyone thought of that kind of tool that is LEO. It's so stupid to program such a tool, yet no one thought of doing such a thing ! ")

I was wondering if there was a leo keyword (beginning with "@") that would do a feature I thought would be great: something such as :
@h
@endh
and of course, similarily...
@f
@endf

Standing for "Header", "End Header", "Footer" and "End Footer". Let me please explain ...

When creating files with @file (or nosentinels) I use the keyword "@others" in the starting node body of the file and place in the file, as it's decendants (children, grand-children & so on) some clones of other stuff somewhere else outside of this file (usualy, clones of parts of program regrouped as children of a "components" node up in the leo outline. Typical Example:

-Introduction
-+components
-a
-b
-c
-+@file program.BAS
-b
-c
-a

a, b, and c are clones and the @file node contains @others.

As you see, I proceed that way because in older programming languages or in lower level languages, the order of components such as procs, declarations, etc as an importance. It also has the implication that << and >> brackets are irrelevant in my way of using leo.

Now, my feature that I looked for in the doc but could not find (so i suggest it here in case no one had any need of this before) is that when used in the BODY of a node part of an "@file" the @h and @endh would define a chunk of text in the body, you've guessed it, to be added before _each_ children node and ONLY children no grandchildren or any deeper. But It could also be used INSIDE the body of a children to define headers or footers for IT'S OWN direct children.

so, eehh, do you see the relevance of such a feature? Have i explained it clearly? maybe this would help:
CONST baba=2 AS INTEGER
CONST bebe=7 AS INTEGER
CONST zaza=5 AS INTEGER
CONST bobo=1 AS INTEGER
... the beginning and end of each of those "parts-of-a-program" is the same for a potential lot of lines... 

To Be Precise :
It's just really for adding something at end or beginning of a direct children of a node part of an @file in the tangling process. 

Is this feature already implemented but i have not found it? I'm pretty sure it easy to implement... what do you people think of this?
Thanks 
--
k

p.s. I'm the guy who proposed that in the untangling process, a clone would not be updated by it's _Last-Instance-Found_ in the @file beeing untangled, but instead updated by the _Last-Modified-One-Found_ in the @file... :)

(ooouuuuhh that would be slick...)  

By: ksejlod ( Peter Barrel ) 
 RE: I Have a (maybe) great idea!   
2004-02-15 04:35  

 The tree i tried to draw in ascii did not came out the way i did it, sourceforge "eated" leading spaces sorry a, b and c are children of their "+" node just above them		.
--
k  
#@nonl
#@-node:ekr.20040216054459:@h @f @endh and @endf directives
#@+node:ekr.20040123102724.2:Templates
@nocolor
#@nonl
#@+node:ekr.20040123102724.3:daliuslt
https://sourceforge.net/forum/message.php?msg_id=2385991
By: nobody

I often found myself using the same template for many projects but something differs in them. E.g. name of files. So my offer is add new directive variable:

@variable ProjectName MyFunProject

Later in parent node, child nodes or headers I could use this as:

$(ProjectNode).py or smth. similar.
This line when tangling could be replaces with
MyFunProject.py

Of course, there comes some complexity with untangling, but it is just an offer :)

Dalius
#@-node:ekr.20040123102724.3:daliuslt
#@+node:ekr.20040123102724.4:Rich: @constant
https://sourceforge.net/forum/message.php?msg_id=2386199
By: nobody

Dalius-
FWIW, I like it! I also can think of a LOAD of variations (i.e., multi-line
variables, etc.), but I'll limit myself to one thing: 'variable' by definition
should be changeable. May I suggest you call the directive "@constant"?

--Rich
#@nonl
#@-node:ekr.20040123102724.4:Rich: @constant
#@+node:ekr.20040123102724.5:paulpaterson
https://sourceforge.net/forum/message.php?msg_id=2386359
By: paulpaterson

I like this idea because I think templating is an important "design pattern"
that Leo could usefully support. Currently you can only do this in a limited
way by cloning nodes across derived files, which is something Edward doesn't
like to do because it makes reading derived files ambiguous (same information
in more than one place). I still do this because I rarely read files into Leo,
I mostly explicitely tangle files out of Leo.

Back to your idea ;) ISTM that your idea works well for directives (you can
do the variable substitution) but for general text (where I think there is a
bigger gain) there are two issues,

1. The template itself is now present in multiple derived files (see above)

2. The file derived from the template has now lost the variable name because
it was substituted out for the variable value

The end result is that templated files would almost certainly have to be a one
way street for Leo - they are derived from the Leo file but never read back
in. If you don't mind having this restriction, which basically means you have
to use @root nodes, then I don't see a problem.

Presumably most of this could all be done with a tangle_done script - the only
problem is how to change directives.
#@nonl
#@-node:ekr.20040123102724.5:paulpaterson
#@+node:ekr.20040123102724.6:daliuslt
http://sourceforge.net/forum/message.php?msg_id=2389750
By: daliuslt

Just for your interests where is one way to create constants in leo (even multiline).
Let's way we have outline:

+-[ ] @file-nosent objects.mak
|   +-[clone] << my_const >>
+-[ ] @file-nosent makefile
    +-[close] << my_const >>

objects.mak is:
--
<< my_const >>.o:
gcc -g -c << my_const >>.c -o << my_const >>.o

<< my_const >>cmd.o:
gcc -g -c << my_const >>cmd.c -o << my_const >>cmd.o
--

makefile is
--
<< my_const >>:
gcc << my_const >>.o << my_const >>cmd.o -o << my_const >>
--

<< my_const >> can be:
test

While it works pretty good it still have some drawbacks:
1. You are forced to use @file-nosent. You can edit your files outside of Leo.
2. You can't use << my_const >> in header lines, while it would be really nice
if you could write
@file-nosent obj_<< my_const >>.mak
(Leo lacks introspection?)
3. Result is not 100% what you expect.

---

(constant = variable = define) ???

Constants and clones in fact are the same. Usually clones are used like symbolic
links (or shortcuts) not like clones or constants. I think this could be
separated.

Constants could be read back into leo. E.g.: you have constant value in leo
file and while reading back files to outline you change all values with constant
name.

I hope I am clear :)
Dalius
#@nonl
#@-node:ekr.20040123102724.6:daliuslt
#@-node:ekr.20040123102724.2:Templates
#@+node:ekr.20040329185649:Bugs: can't be fixed or can wait
#@+node:ekr.20031218072017.663:Bug: can't be fixed
#@+node:ekr.20031218072017.664:Cut/paste bug on X windows (waiting for help)
@nocolor

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse.

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node.

Doing copy and paste works normally when done through the edit menu.

@color
#@nonl
#@+node:ekr.20031218072017.665:(Cut & Paste ) (Middle-button bug reported by Timo)
#@+node:ekr.20031218072017.666: Paste bug report
@nocolor

By: riotnrrrd ( Timo Honkasalo ) 
 Pasted text doesn't stick   
2002-11-01 13:38  
System: Linux 

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse. 

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node. 

Doing copy and paste works normally when done through the edit menu. 

-------------------

I also found out that if you do an extra "click" on the control key, it will
stick from then on.

If your text should have color in it, you can see that right before you "click",
the text has no color and the color back on right after you click the control.

It maybe a clue to someone, but seems strange to me. 
#@-node:ekr.20031218072017.666: Paste bug report
#@+node:ekr.20031218072017.667: Test
abc bbb bbbxyz bbb
#@nonl
#@-node:ekr.20031218072017.667: Test
#@-node:ekr.20031218072017.665:(Cut & Paste ) (Middle-button bug reported by Timo)
#@+node:ekr.20031218072017.668:Automatic select & Paste bug (Linux?)
@nocolor

Bumping the thread because the bug still persists. 

I've also noticed that the automatic select'n'paste doesn't work between nodes. That is, I can select text and paste a copy of it in the same node with middle button, but if I change click to another node, the paste buffer is erased. The automatic pasting works between Leo and other applications, however, and I can paste between nodes if I copy the selection to buffer by CTR-C. 

Maybe this is related to the non-sticking bug?

----

This may be a Linux-only bug related to the control-v workaround.
#@nonl
#@-node:ekr.20031218072017.668:Automatic select & Paste bug (Linux?)
#@-node:ekr.20031218072017.664:Cut/paste bug on X windows (waiting for help)
#@+node:ekr.20031218072017.669:Linux-only Bugs
These may indicate problems with Tk on Linux.  I can not reproduce them on XP.
#@nonl
#@+node:ekr.20031218072017.670:Possible webbrowser bug
(In Linux) The home page and online tutorial options in the menu only work properly if Mozilla window is already open. If not, a Mozilla window opens, but with empty page and url field. 
#@nonl
#@-node:ekr.20031218072017.670:Possible webbrowser bug
#@+node:ekr.20031218072017.671:Fix horiz scrollbar bug when tiling horizontally
When in 'vertical split' mode (with viewpane on right, and tree pane over log pane on left), the horixontal scrollbar at bottom of screen is at full width, despite the fact that not all of the tree pane area is displayed. 

Another way of saying this - I narrow the tree and log panes, to the extent that the display of tree node headings is truncated. But the horizontal scrollbar at the bottom doesn't contract, and doesn't allow me to horizontally scroll the tree pane to expose the rest of the node headings. 
#@-node:ekr.20031218072017.671:Fix horiz scrollbar bug when tiling horizontally
#@+node:ekr.20031218072017.672:Control-V doesn't work on Linux
This has been and continues to be a known issue with Tk. Has been logged as a bug; no response from the Tk folks. 

Here is a link to the Tk bug report: 

http://sourceforge.net/tracker/?func=detail&aid=605277&group_id=12997&atid=112997 

Note the work-around/patch in the followup post at the bottom of that page. Commenting out some statements in text.tcl removes the problem. 
#@-node:ekr.20031218072017.672:Control-V doesn't work on Linux
#@-node:ekr.20031218072017.669:Linux-only Bugs
#@+node:ekr.20031218072017.673:Tk bugs
The following bugs can not be fixed because they are Tk bugs.
#@nonl
#@+node:ekr.20031218072017.674:Caps lock affects keyboard shortcuts on Windows
Using leo under Windows, the keyboard shortcuts seem to use the "Caps Lock" state in determining the shift state when executing a shortcut.   For example, if the caps-lock key is on, then Ctrl-X is interpreted as Shift-Ctrl-X and cuts a node rather than selected text, and Shift-Ctrl-X is interpreted as Ctrl-X and cuts text.
#@-node:ekr.20031218072017.674:Caps lock affects keyboard shortcuts on Windows
#@+node:ekr.20031218072017.675:Tree problems
1. The border of the tree control is gray, and it is overwritten with large headlines.  This may be a Tk or Tkinter bug.

2. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this glitch because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.
#@nonl
#@-node:ekr.20031218072017.675:Tree problems
#@+node:ekr.20031218072017.676:Control-T can't be overridden in canvas text.
#@-node:ekr.20031218072017.676:Control-T can't be overridden in canvas text.
#@+node:ekr.20031218072017.677:(Alt-ctrl = Alt)
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1765069
By: dalcolmo

I use the bindings that come with Leo:

[keyboard shortcuts]
pastenode = Shift+Ctrl+V
gonextvisible = Alt+DnArrow
importtofile = Shift+Ctrl+F
writefilenodes = Shift+Ctrl+W
editheadline = Ctrl+H
markchangeditems = Alt+C
replace = Ctrl+=
goprevvisible = Alt+UpArrow
gotonextmarked = Alt+M
readoutlineonly = Shift+Ctrl+R
extractnames = Shift+Ctrl+N
gonext = Alt+Shift+DnArrow
findpanel = Ctrl+F
close = Ctrl+W
demote = Ctrl+}
tangle = Shift+Ctrl+T
extract = Shift+Ctrl+D
openpythonwindow = Alt+P
marksubheads = Alt+S
saveas = Shift+Ctrl+S
cut = Ctrl+X
preferences = Ctrl+Y
equalsizedpanes = Ctrl+E
cantundo = Ctrl+Z
open = Ctrl+O
promote = Ctrl+{
sortsiblings = Alt-A
unmarkall = Alt+U
mark = Ctrl+M
showinvisibles = Alt+V
exit = Ctrl-Q
insertnode = Ctrl+I
findprevious = F4
converttabs = Shift+Ctrl+J
save = Ctrl+S
tanglemarked = Shift+Ctrl+M
moveup = Ctrl+U
copynode = Shift+Ctrl+C
contractparent = Alt+0
selectall = Ctrl+A
setfont = Alt+Shift+T
aborteditheadline = Shift+Esc
goback = Alt+Shift+UpArrow
toggleactivepane = Ctrl+T
findnext = F3
tangleall = Shift+Ctrl+A
endeditheadline = Esc
deletenode = Shift+Ctrl+BkSp
cantredo = Shift+Ctrl+Z
new = Ctrl+N
contractall = Alt+1
moveleft = Ctrl+L
copy = Ctrl+C
paste = Ctrl+V
convertblanks = Shift+Ctrl+B
expandall = Alt+9
markchangedroots = Alt+R
cutnode = Shift+Ctrl+X
indent = Ctrl+]
gotonextchanged = Alt+D
expandnextlevel = Alt+=
setcolors = Alt+Shift+S
matchbrackets = Ctrl+K
movedown = Ctrl+D
clonenode = Ctrl+`
untangle = Shift+Ctrl+U
expandtolevel7 = Alt+7
expandtolevel6 = Alt+6
expandtolevel5 = Alt+5
expandtolevel4 = Alt+4
expandtolevel3 = Alt+3
expandtolevel2 = Alt+2
moveright = Ctrl+R
unindent = Ctrl+[
replacethenfind = Ctrl+-
extractsection = Shift+Ctrl+E
expandtolevel8 = Alt+8


However, I use a utility called AllChars (Free as in beer :-(  ) to be able
to type all kinds of chars on my US keyboard, and "Handything" to place the
windows on the screen (Win2000). Perhaps this makes a difference, although disabling
them did not seem to make it go away. Still, on pressing alt+ctrl+uparrow I
end up at the next upper node etc...

- Josef

#@-node:ekr.20031218072017.677:(Alt-ctrl = Alt)
#@+node:ekr.20031218072017.678:Report Tk bugs
Create a Tk demo for each bug.
#@nonl
#@+node:ekr.20031218072017.679:Tk code
@color
#@nonl
#@+node:ekr.20031218072017.680:@file c:/prog/test/leoSplitter.tcl
# This file creates tk test code for prototyping.
@language tcltk
@others

go
#@nonl
#@+node:ekr.20031218072017.681:go
proc go {} {
	# createLeo 1
	# createLeo 2
	# createFindPanel
	# createPrefsPanel
	# createColorPanel
	# toplevel .font
	# createFontPanel .font
	# createComparePanel
	# createWindowWithIcon
	# createWindowWithCursor
}
#@-node:ekr.20031218072017.681:go
#@+node:ekr.20031218072017.682:createLeo
proc createLeo { n } {

	toplevel .leo$n

	# Create two splitters
	createSplitter .leo$n.s 1
	createSplitter .leo$n.s.pane1.s 0 ;# contains tree and log
	
	text      .leo$n.s.pane2.body -bd 2 -yscrollcommand ".leo$n.s.pane2.scroll set" -setgrid 1
	scrollbar .leo$n.s.pane2.scroll -command ".leo$n.s.pane2.body yview"

	pack .leo$n.s.pane2.scroll -side right -fill y
	pack .leo$n.s.pane2.body -expand yes -fill both

	text .leo$n.s.pane1.s.pane1.tree -bd 2 -yscrollcommand ".leo$n.s.pane1.s.pane1.scroll set" -setgrid 1
	scrollbar .leo$n.s.pane1.s.pane1.scroll -command ".leo$n.s.pane1.s.pane1.tree yview"
	
	pack .leo$n.s.pane1.s.pane1.scroll -side right -fill y
	pack .leo$n.s.pane1.s.pane1.tree   -expand yes -fill both

	# -padx is needed to handle overlap of splitter bar
	text      .leo$n.s.pane1.s.pane2.log    -yscrollcommand ".leo$n.s.pane1.s.pane2.scroll set" -setgrid 1 -padx 4
	scrollbar .leo$n.s.pane1.s.pane2.scroll -command ".leo$n.s.pane1.s.pane2.log yview"
	pack .leo$n.s.pane1.s.pane2.scroll -side right -fill y
	pack .leo$n.s.pane1.s.pane2.log -expand yes -fill both
	
	createMenus $n
}
#@nonl
#@-node:ekr.20031218072017.682:createLeo
#@+node:ekr.20031218072017.683:createMenus
proc createMenus { n } {

	# Create the menu bar
	menu .leo$n.menu -tearoff 0

    set m .leo$n.menu.file
    menu $m -tearoff 0

    .leo$n.menu add cascade -label "File" -menu $m -underline 0
	# to do: fill in the commands...
    $m add command -label "Open..." -command {""}
    $m add command -label "New" -command {""}
    $m add command -label "Save" -command {""}
    $m add command -label "Save As..." -command {""}
    $m add separator
    $m add command -label "Print Setup..." -command {""}
    $m add command -label "Print..." -command {""}
    $m add separator
    $m add command -label "Quit" -command "destroy ."
	
	.leo$n configure -menu .leo$n.menu
}
#@nonl
#@-node:ekr.20031218072017.683:createMenus
#@+node:ekr.20031218072017.684:createSplitter
#@+node:ekr.20031218072017.685:createSplitter
# Create a splitter window into which the caller packs widgets.

proc createSplitter {w verticalFlag} {
	# verticalFlag, height, width could be params
	frame $w -width 4i -height 3i
	frame $w.pane1
	frame $w.pane2
	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		frame $w.bar -height 7
		place $w.pane1 -relx 0.5 -rely   0 -anchor n -relwidth 1.0 -relheight 0.5
		place $w.pane2 -relx 0.5 -rely 1.0 -anchor s -relwidth 1.0 -relheight 0.5
		place $w.bar   -relx 0.5 -rely 0.5 -anchor c -relwidth 1.0
		bind $w.bar <ButtonPress-1>		"onGrabSplitterBar $w 1"
		bind $w.bar <B1-Motion>			"onDragSplitterBar $w 1 %y"
		bind $w.bar <ButtonRelease-1>	"onDropSplitterBar $w 1 %y"
	} else {
		# Panes arranged horizontally; vertical splitter bar
		frame $w.bar -width 7
		place $w.pane1 -rely 0.5 -relx   0 -anchor w -relheight 1.0 -relwidth 0.5
		place $w.pane2 -rely 0.5 -relx 1.0 -anchor e -relheight 1.0 -relwidth 0.5
		place $w.bar   -rely 0.5 -relx 0.5 -anchor c -relheight 1.0
		bind $w.bar <ButtonPress-1>		"onGrabSplitterBar $w 0"
		bind $w.bar <B1-Motion>			"onDragSplitterBar $w 0 %x"
		bind $w.bar <ButtonRelease-1>	"onDropSplitterBar $w 0 %x"
	}
	# Borderwidth required
	$w.bar configure -borderwidth 2 -relief raised -background LightSteelBlue2 
	pack $w -expand yes -fill both
}
#@-node:ekr.20031218072017.685:createSplitter
#@+node:ekr.20031218072017.686:onGrabSplitterBar
proc onGrabSplitterBar {w verticalFlag} {

	# We should change the cursor here.
	
	# Changing the relief is pointless.
		# $w.bar configure -relief sunken
	
	# Changing colors is really bad
		# $w.bar configure -relief sunken -background LightSteelBlue4
		# $w.bar configure -background LightSteelBlue4
}
#@nonl
#@-node:ekr.20031218072017.686:onGrabSplitterBar
#@+node:ekr.20031218072017.687:onDropSplitterBar
proc onDropSplitterBar {w verticalFlag xy} {

	# We should reset the cursor here.
	$w.bar configure -relief raised -background LightSteelBlue2
}
#@-node:ekr.20031218072017.687:onDropSplitterBar
#@+node:ekr.20031218072017.688:onDragSplitterBar
# xy is the coordinate of the cursor relative to the bar, not the main window.

proc onDragSplitterBar {w verticalFlag xy} {

	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		set wRoot	[winfo rooty $w]
		set barRoot [winfo rooty $w.bar]
		set wMax	[winfo height $w]
	} else {
		# Panes arranged horizontally; vertical splitter bar
		set wRoot	[winfo rootx $w]
		set barRoot [winfo rootx $w.bar]
		set wMax	[winfo width $w]
	}
	set offset [expr double($barRoot) + $xy - $wRoot ]
	# Adjust the pixels, not the frac.
	if { $offset < 3 } { set offset 3 }
	if { $offset > [expr $wMax - 2] } { set offset [expr $wMax - 2] }
	set frac [ expr double($offset) / $wMax ]
	# This redraws the splitter as the drag is occuring.
	# We could also redraw in onDropSplitterBar for non-dynamic updates.
	divideSplitter $w $verticalFlag $frac
	return $frac ;# No longer used
}
#@nonl
#@-node:ekr.20031218072017.688:onDragSplitterBar
#@+node:ekr.20031218072017.689:divideSplitter
proc divideSplitter {w verticalFlag frac} {

	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		place $w.bar -rely $frac
		place $w.pane1 -relheight $frac
		place $w.pane2 -relheight [expr 1 - $frac]
	} else {
		# Panes arranged horizontally; vertical splitter bar
		place $w.bar -relx $frac
		place $w.pane1 -relwidth $frac
		place $w.pane2 -relwidth [expr 1 - $frac]
	}
}
#@nonl
#@-node:ekr.20031218072017.689:divideSplitter
#@-node:ekr.20031218072017.684:createSplitter
#@+node:ekr.20031218072017.690:createFindPanel
proc createFindPanel {} {

	toplevel .find
	<< Create the Find and Change panes >>
	<< Create two columns of checkboxes >>
	<< Create two rows of buttons >>
}
#@+node:ekr.20031218072017.691:<< Create the Find and Change panes >>
frame .find.fc -bd 1m
pack  .find.fc -anchor n -expand yes -fill x

frame .find.fc.fpane -bd 1 -height 0.95i -width 1.5i
frame .find.fc.cpane -bd 1 -height 0.95i -width 1.5i

pack  .find.fc.fpane -anchor n -expand yes -fill x
pack  .find.fc.cpane -anchor s -expand yes -fill x

# Create the labels and text fields.
label .find.fc.fpane.lab -width 8 -text "Find:"
label .find.fc.cpane.lab -width 8 -text "Change:"
text  .find.fc.fpane.t -height 2 -width 20 ; # 2 lines, 20 characters
text  .find.fc.cpane.t -height 2 -width 20

pack  .find.fc.fpane.lab -side left 
pack  .find.fc.cpane.lab -side left
pack  .find.fc.cpane.t -side right -expand yes -fill both
pack  .find.fc.fpane.t -side right -expand yes -fill both
#@-node:ekr.20031218072017.691:<< Create the Find and Change panes >>
#@+node:ekr.20031218072017.692:<< Create two columns of checkboxes >>
frame .find.boxes -bd 1m
pack  .find.boxes -anchor n -expand yes -fill x

frame .find.boxes.lt -bd 1
frame .find.boxes.rt -bd 1
pack  .find.boxes.lt -side left  -padx 5m
pack  .find.boxes.rt -side right -ipadx 2m

# Create the left column
checkbutton .find.boxes.lt.batch -anchor w -text "Batch"
checkbutton .find.boxes.lt.wrap  -anchor w -text "Wrap around"
checkbutton .find.boxes.lt.word  -anchor w -text "Whole word"
checkbutton .find.boxes.lt.case  -anchor w -text "Ignore case"
checkbutton .find.boxes.lt.pat   -anchor w -text "Pattern match"
pack .find.boxes.lt.batch -fill x
pack .find.boxes.lt.wrap  -fill x
pack .find.boxes.lt.word  -fill x
pack .find.boxes.lt.case  -fill x
pack .find.boxes.lt.pat    -fill x

# Create the right column
checkbutton .find.boxes.rt.headline -anchor w -text "Search Headline Text"
checkbutton .find.boxes.rt.body     -anchor w -text "Search Body Text"
checkbutton .find.boxes.rt.outline  -anchor w -text "Suboutline Only"
checkbutton .find.boxes.rt.mark     -anchor w -text "Mark Changes"
checkbutton .find.boxes.rt.markch   -anchor w -text "Mark Finds"
pack .find.boxes.rt.headline -side top -fill x
pack .find.boxes.rt.body     -side top -fill x
pack .find.boxes.rt.outline  -side top -fill x
pack .find.boxes.rt.mark     -side top -fill x
pack .find.boxes.rt.markch   -side top -fill x
#@-node:ekr.20031218072017.692:<< Create two columns of checkboxes >>
#@+node:ekr.20031218072017.693:<< Create two rows of buttons >>
# Create the button panes
frame .find.buttons -bd 1
pack  .find.buttons -anchor n -expand yes -fill x

frame .find.buttons2 -bd 1
pack  .find.buttons2 -anchor n -expand yes -fill x

# Create the first row of buttons
button      .find.buttons.find    -width 8 -text "Find"
checkbutton .find.buttons.reverse -width 8 -text "Reverse"
button      .find.buttons.findAll -width 8 -text "Find All"

pack .find.buttons.find    -pady 1m -padx 1m -side left
pack .find.buttons.reverse -pady 1m          -side left -expand 1
pack .find.buttons.findAll -pady 1m -padx 1m -side right

# Create the second row of buttons
button .find.buttons2.change     -width 8 -text "Change"
button .find.buttons2.changeFind           -text "Change, Then Find"
button .find.buttons2.changeAll  -width 8 -text "Change All"

pack .find.buttons2.change       -pady 1m -padx 1m -side left
pack .find.buttons2.changeFind   -pady 1m          -side left -expand 1
pack .find.buttons2.changeAll    -pady 1m -padx 1m -side right
#@-node:ekr.20031218072017.693:<< Create two rows of buttons >>
#@-node:ekr.20031218072017.690:createFindPanel
#@+node:ekr.20031218072017.694:createPrefsPanel
proc createPrefsPanel {} {

	toplevel .prefs
	<< Create the Global Options frame >>
	<< Create the Tangle Options frame >>
	<< Create the Target Language frame >>
}
#@nonl
#@+node:ekr.20031218072017.695:<< Create the Global Options frame >>
frame .prefs.glob -bd 1m -relief groove
pack  .prefs.glob -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.glob.title -text "Global Options..."
pack  .prefs.glob.title -pady 1m

# Page width & page width
frame .prefs.glob.f
pack  .prefs.glob.f -anchor w -pady 1m -expand 1 -fill x

label .prefs.glob.f.lab -anchor w -padx 1m -text "Page width:"
text  .prefs.glob.f.txt -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab .prefs.glob.f.txt -side left

label .prefs.glob.f.lab2 -padx 1m -text "Tab width:"
text  .prefs.glob.f.txt2 -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab2 .prefs.glob.f.txt2 -side left

# Checkbuttons
checkbutton .prefs.glob.done -anchor w -text "Execute Leo_done.bat after Tangle"
checkbutton .prefs.glob.un   -anchor w -text "Execute Leo_un.bat after Tangle"
pack .prefs.glob.done .prefs.glob.un -fill x
#@-node:ekr.20031218072017.695:<< Create the Global Options frame >>
#@+node:ekr.20031218072017.696:<< Create the Tangle Options frame >>
# Frame and title
frame .prefs.tangle -bd 1m -relief groove
pack  .prefs.tangle -anchor n -ipadx 1m -expand 1 -fill x

label .prefs.tangle.title -text "Default Options..."
pack  .prefs.tangle.title -pady 1m

# Label and text
label .prefs.tangle.lab -anchor w -text "Default tangle directory"
text  .prefs.tangle.txt -height 1 -width 30 ;# width significant

pack  .prefs.tangle.lab           -padx 1m -pady 1m -fill x
pack  .prefs.tangle.txt -anchor w -padx 1m -pady 1m -fill x

# Checkbuttons
checkbutton .prefs.tangle.header -anchor w -text "Tangle outputs header line"
checkbutton .prefs.tangle.doc    -anchor w -text "Tangle outputs document chunks"
pack .prefs.tangle.header .prefs.tangle.doc -fill x
#@-node:ekr.20031218072017.696:<< Create the Tangle Options frame >>
#@+node:ekr.20031218072017.697:<< Create the Target Language frame >>
# Frame and title
frame .prefs.target -bd 1m -relief groove
pack  .prefs.target -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.target.title -text "Default Target Language..."
pack  .prefs.target.title -pady 1m

# Frames for two columns of radio buttons
frame .prefs.target.lt 
frame .prefs.target.rt
pack  .prefs.target.lt -side left
pack  .prefs.target.rt -side right

## To do: make radio buttons functional.

# Left column of radio buttons
radiobutton .prefs.target.lt.c      -anchor w -text "C/C++"
radiobutton .prefs.target.lt.cweb   -anchor w -text "CWEB"
radiobutton .prefs.target.lt.html   -anchor w -text "HTML"
radiobutton .prefs.target.lt.java   -anchor w -text "Java"
radiobutton .prefs.target.lt.pascal -anchor w -text "Pascal"

pack .prefs.target.lt.c      -fill x
pack .prefs.target.lt.cweb   -fill x
pack .prefs.target.lt.html   -fill x
pack .prefs.target.lt.java   -fill x
pack .prefs.target.lt.pascal -fill x

# Right column of radio buttons
radiobutton .prefs.target.rt.perl   -width 12 -anchor w -text "Perl"
radiobutton .prefs.target.rt.pod              -anchor w -text "Perl + POD"
radiobutton .prefs.target.rt.plain            -anchor w -text "Plain Text"
radiobutton .prefs.target.rt.python           -anchor w -text "Python"

pack .prefs.target.rt.perl   -fill x
pack .prefs.target.rt.pod    -fill x
pack .prefs.target.rt.plain  -fill x
pack .prefs.target.rt.python -fill x
#@-node:ekr.20031218072017.697:<< Create the Target Language frame >>
#@-node:ekr.20031218072017.694:createPrefsPanel
#@+node:ekr.20031218072017.698:createColorPanel
proc showColorPicker {} {
	tk_chooseColor
}

proc createColorPanel {} {

	toplevel .color
	wm title .color "Syntax Coloring"

	frame .color.f -bd 2 -relief groove
	pack  .color.f -anchor n -pady 2 -ipady 1 -ipadx 0 -expand 1 -fill x
	
	# label .color.f.lab -text "Choose syntax colors..."
	# pack  .color.f.lab -side top -fill x
	
	frame .color.f.docF -bd 2
	pack  .color.f.docF
	label .color.f.docF.lab -text "Doc parts:" -width 14 -anchor e
	button .color.f.docF.show -text "" -bg "red" -width 4
	button .color.f.docF.set -text "Set..." -command showColorPicker
	pack  .color.f.docF.lab .color.f.docF.show .color.f.docF.set -side left -padx 3
	
	frame .color.f.cF -bd 2
	pack  .color.f.cF
	label .color.f.cF.lab -text "Comments:" -width 14 -anchor e
	button .color.f.cF.show -text "" -bg "red" -width 4
	button .color.f.cF.set -text "Set..." -command showColorPicker
	pack  .color.f.cF.lab .color.f.cF.show .color.f.cF.set -side left -padx 3

	frame .color.f.sF -bd 2
	pack  .color.f.sF
	label .color.f.sF.lab  -text "Strings:" -width 14 -anchor e
	button .color.f.sF.show -bg "green" -width 4
	button .color.f.sF.set -text "Set..." -command showColorPicker
	pack  .color.f.sF.lab .color.f.sF.show .color.f.sF.set -side left -padx 3
	
	frame .color.f.kF -bd 2
	pack  .color.f.kF
	label .color.f.kF.lab  -text "Keywords:" -width 14 -anchor e
	button .color.f.kF.show -bg "blue" -width 4
	button .color.f.kF.set -text "Set..." -command showColorPicker
	pack  .color.f.kF.lab .color.f.kF.show .color.f.kF.set -side left -padx 3
	
	frame .color.f.dF -bd 2
	pack  .color.f.dF
	label .color.f.dF.lab  -text "Directives:" -width 14 -anchor e
	button .color.f.dF.show -bg "blue" -width 4
	button .color.f.dF.set -text "Set..." -command showColorPicker
	pack  .color.f.dF.lab .color.f.dF.show .color.f.dF.set -side left -padx 3

	frame .color.f.snF -bd 2
	pack  .color.f.snF
	label .color.f.snF.lab  -text "Section names:" -width 14 -anchor e
	button .color.f.snF.show -bg "red" -width 4
	button .color.f.snF.set -text "Set..." -command showColorPicker
	pack  .color.f.snF.lab .color.f.snF.show .color.f.snF.set -side left -padx 3

	frame .color.f.unF -bd 2
	pack  .color.f.unF
	label .color.f.unF.lab  -text "Undefined names:" -width 14 -anchor e
	button .color.f.unF.show -bg "orange" -width 4 
	button .color.f.unF.set -text "Set..." -command showColorPicker
	pack  .color.f.unF.lab .color.f.unF.show .color.f.unF.set -side left -padx 3
}
#@nonl
#@-node:ekr.20031218072017.698:createColorPanel
#@+node:ekr.20031218072017.699:createFontPanel
proc createFontPanel {w} {

	frame $w.top
	frame $w.size -bd 2 -relief "ridge"
	frame $w.sample -bd 2 -relief "ridge"
	pack $w.top $w.size $w.sample -pady 2 -ipadx 5 -anchor w -fill both
	
	<< create family pane >>
	<< create style pane >>
	<< create buttons >>
	<< create size pane >>
	<< create sample pane >>
}
#@nonl
#@+node:ekr.20031218072017.700:<< create family pane >>
frame $w.top.family -bd 2 -relief "ridge"
label $w.top.family.lab -text "family"
listbox $w.top.family.box
pack $w.top.family.lab $w.top.family.box -anchor w

frame $w.top.style -bd 2 -relief "ridge"
frame $w.top.right -bd 2 -relief "flat"
pack $w.top.family $w.top.style $w.top.right -side left -fill y -padx 2 -pady 2 ; # -ipadx 5 -ipady 5
#@nonl
#@-node:ekr.20031218072017.700:<< create family pane >>
#@+node:ekr.20031218072017.701:<< create style pane >>
label $w.top.style.lab -text "Style"
pack  $w.top.style.lab -anchor w
foreach {name text} {
	b Bold
	i Italic
	u Underline
	o Overstrike
} {
	checkbutton $w.top.style.$name -text $text
	pack $w.top.style.$name -side top -anchor w -expand 1
}
#@nonl
#@-node:ekr.20031218072017.701:<< create style pane >>
#@+node:ekr.20031218072017.702:<< create buttons >>
foreach {name text} {
	ok OK
	cancel Cancel
	apply Apply
} {
	button $w.top.right.$name -text $text -width 6
	pack   $w.top.right.$name -side top -anchor w -pady 2m ; # -expand 1
}
#@nonl
#@-node:ekr.20031218072017.702:<< create buttons >>
#@+node:ekr.20031218072017.703:<< create size pane >>
frame $w.size.left
label $w.size.lab -text "Size"

text  $w.size.text -height 1 -width 4
pack  $w.size.lab -anchor w
pack  $w.size.left -side left
pack  $w.size.text -side left -fill x -expand 1

frame $w.size.left.row1
frame $w.size.left.row2
pack $w.size.left.row1 $w.size.left.row2 -side top

foreach {size} {
	8 12 18
} {
	radiobutton $w.size.left.row1.radio$size -text $size -variable size
	pack $w.size.left.row1.radio$size -side left
}
foreach {size} {
	10 14 24
} {
	radiobutton $w.size.left.row2.radio$size -text $size -variable size
	pack $w.size.left.row2.radio$size -side left
}
#@nonl
#@-node:ekr.20031218072017.703:<< create size pane >>
#@+node:ekr.20031218072017.704:<< create sample pane >>
label $w.sample.lab -text "Sample"
pack  $w.sample.lab -side top -anchor w

label $w.sample.text -text "ABCabcXYZxyz123(may be changed)"

# entry $w.sample.text -background [$w.sample cget -background]
# $w.sample.text insert 0 "ABCabcXYZxyz123(may be changed)"

pack $w.sample.text -side top -anchor c -expand 1 -fill none

# $w.sample.text insert 0 "ABCabcXYZxyz123(may be changed)"
# $w.sample.text configure -state disabled
#@nonl
#@-node:ekr.20031218072017.704:<< create sample pane >>
#@-node:ekr.20031218072017.699:createFontPanel
#@+node:ekr.20031218072017.705:dkffontCreateFontPanel
@ Build the font panel (except for the apply button, which is handled by the 'configure_apply procedure...
@c

proc origCreateFontPanel {w} {
	# Framed regions.  Do this with grid and labels, as that seems
	# to be the most effective technique in practise!
	frame $w.border1 -class DKFChooseFontFrame
	frame $w.border2 -class DKFChooseFontFrame
	frame $w.border3 -class DKFChooseFontFrame
	frame $w.border4 -class DKFChooseFontFrame
	set gap [get_gap $w]
	grid $w.border1 -row 0 -column 0 -rowspan 4 -columnspan 4 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border2 -row 0 -column 4 -rowspan 4 -columnspan 3 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border3 -row 4 -column 0 -rowspan 3 -columnspan 9 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border4 -row 7 -column 0 -rowspan 3 -columnspan 9 \
		-padx $gap -pady $gap -sticky nsew
	incr gap $gap
	foreach col {0 3 4 6 8} {
		grid columnconfigure $w $col -minsize $gap
	}
	foreach row {0 3 4 6 7 9} {
		grid rowconfigure    $w $row -minsize $gap
	}
	grid columnconfigure $w 1 -weight 1
	grid rowconfigure    $w 1 -weight 1
	grid rowconfigure    $w 8 -weight 1

	# Labels for the framed boxes & focus accelerators for their contents
	foreach {subname row col focusWin} {
		Family 0 1 .family     
		Style  0 5 .style.sBold
		Size   4 1 .size.b8    
		Sample 7 1 .sample.text
	} {
		set l [label $w.lbl$subname]
		grid $l -row $row -column $col -sticky w
		## set accel [get_accel $l]
		## if {[string length $accel]} {
			## bind $w <$accel> [list focus $w$focusWin]
		##}
	}

	# Font families
	frame $w.familyBox
	listbox $w.family -exportsel 0 -selectmode browse \
		-xscrollcommand [list $w.familyX set] \
		-yscrollcommand [list $w.familyY set]
	scrollbar $w.familyX -command [list $w.family xview]
	scrollbar $w.familyY -command [list $w.family yview]
	##foreach family [list_families] {
	##	$w.family insert end ['map 'capitalise $family]
	##}
	grid $w.familyBox -row 1 -column 1 -rowspan 1 -columnspan 2 -sticky nsew
	grid columnconfigure $w.familyBox 0 -weight 1
	grid rowconfigure    $w.familyBox 0 -weight 1
	grid $w.family  $w.familyY -sticky nsew -in $w.familyBox
	grid $w.familyX            -sticky nsew -in $w.familyBox
	## bind $w.family <1> [namespace code {'change_family %W [%W nearest %y]}]
	## bindtags $w.family [concat [bindtags $w.family] key$w.family]
	## bind key$w.family <Key> [namespace code {'change_family %W active %A}]

	# Font styles.
	frame $w.style
	grid $w.style -row 1 -column 5 -sticky news
	grid columnconfigure $w.style 0 -weight 1
	foreach {fontstyle lcstyle row next prev} {
		Bold      bold       0 Italic    {}
		Italic    italic     1 Underline Bold
		Underline underline  2 Strikeout Italic
		Strikeout overstrike 3 {}        Underline
	} {
		set b $w.style.s$fontstyle
		checkbutton $b -variable [namespace current]::Style($lcstyle) \
			-command [namespace code 'set_font]
		grid $b -sticky nsew -row $row
		grid rowconfigure $w.style $row -weight 1
		if {[string length $next]} {
			## bind $b <Down> [list focus $w.style.s$next]
		}
		if {[string length $prev]} {
			## bind $b <Up> [list focus $w.style.s$prev]
		}
		## bind $b <Tab>       "[list focus $w.size.b8];break"
		## bind $b <Shift-Tab> "[list focus $w.family ];break"
		## set accel ['get_accel $b]
		## if {[string length $accel]} {
			## bind $w <$accel> "focus $b; $b invoke"
		## }
		## bind $b <Return> "$b invoke; break"
	}
	
	# Size adjustment.  Common sizes with radio buttons, and an
	# entry for everything else.
	frame $w.size
	grid $w.size -row 5 -column 1 -rowspan 1 -columnspan 7 -sticky nsew
	foreach {size row col u d l r} {
		8  0 0  {} 10 {} 12
		10 1 0   8 {} {} 14
		12 0 1  {} 14  8 18
		14 1 1  12 {} 10 24
		18 0 2  {} 24 12 {}
		24 1 2  18 {} 14 {}
	} {
		set b $w.size.b$size
		radiobutton $b -variable [namespace current]::Size -value $size \
			-command [namespace code 'set_font]
		grid $b -row $row -column $col -sticky ew
		#grid columnconfigure $w.size $col -weight 1
		## bif {[string length $u]} {bind $b <Up>    [list focus $w.size.b$u]}
		## bif {[string length $d]} {bind $b <Down>  [list focus $w.size.b$d]}
		## bif {[string length $l]} {bind $b <Left>  [list focus $w.size.b$l]}
		## bif {[string length $r]} {bind $b <Right> [list focus $w.size.b$r]}
		## bind $b <Tab>       "[list focus $w.size.entry ];break"
		## bind $b <Shift-Tab> "[list focus $w.style.sBold];break"
		## set accel ['get_accel $b]
		## if {[string length $accel]} {
			## bind $w <$accel> "focus $b; $b invoke"
		## }
		## bind $b <Return> "$b invoke; break"
	}
	entry $w.size.entry -textvariable [namespace current]::Size
	grid $w.size.entry -row 0 -column 3 -rowspan 2 -sticky ew
	grid columnconfigure $w.size 3 -weight 1
	## bind $w.size.entry <Return> [namespace code {'set_font;break}]
	
	# Sample text.  Note that this is editable
	frame $w.sample
	grid $w.sample -row 8 -column 1 -columnspan 7 -sticky nsew
	grid propagate $w.sample 0
	entry $w.sample.text -background [$w.sample cget -background]
	$w.sample.text insert 0 [option get $w.sample.text text Text]
	grid $w.sample.text
	
	# OK, Cancel and (partially) Apply.  See also 'configure_apply
	frame $w.butnframe
	grid $w.butnframe -row 0 -column 7 -rowspan 4 -columnspan 2 -sticky nsew -pady $gap
	foreach {but code} {
		ok  0
		can 1
	} {
		button $w.butnframe.$but -command [namespace code [list set Done $code]]
		pack   $w.butnframe.$but -side top -fill x -padx [expr {$gap/2}] -pady [expr {$gap/2}]
	}
	button $w.butnframe.apl
	## bind $w.butnframe.ok <Down> [list focus $w.butnframe.can]
	## bind $w.butnframe.can <Up> [list focus $w.butnframe.ok]
}
#@nonl
#@+node:ekr.20031218072017.706:get_accel
# Convenience proc to get the accelerator for a particular window
# if the user has given one.  Makes it simpler to get this right
# everywhere it is needed...

proc get_accel {w} {
	option get $w accelerator Accelerator
}
#@nonl
#@-node:ekr.20031218072017.706:get_accel
#@+node:ekr.20031218072017.707:get_gap
# Get the gap spacing for the frameboxes.  Use a user-specified
# default if there is one (that is a valid integer) and fall back
# to measuring/guessing otherwise.
proc get_gap {w} {
	set gap [option get $w lineGap LineGap]
	if {[catch {incr gap 0}]} {
		# Some cunning font measuring!
		label $w._testing
		set font [$w._testing cget -font]
		set gap [expr {[font metrics $font -linespace]/2+1}]
		destroy $w._testing
	}
	return $gap
}
#@nonl
#@-node:ekr.20031218072017.707:get_gap
#@+node:ekr.20031218072017.708:list_families
# Get a sorted lower-case list of all the font families defined on
# the system.  A canonicalisation of [font families]
proc list_families {} {
	lsort [string tolower [font families]]
}
#@-node:ekr.20031218072017.708:list_families
#@-node:ekr.20031218072017.705:dkffontCreateFontPanel
#@+node:ekr.20031218072017.709:createComparePanel
# Path 1: text box
# Path 2: text box

# check: File extension: text box

# Radio buttons:
# 	* print all lines
# 	* print mismatches
# 	* print matches
	
# check: stop after first mismatch
# check: send result to file: text box
# check: generate diffs
# check: ignore whitespace
# check: ignore blank lines

proc createComparePanel {} {

	toplevel .comparePanel
}
#@nonl
#@-node:ekr.20031218072017.709:createComparePanel
#@+node:ekr.20031218072017.710:createWindowWithCursor
# apparantly this is a Tk bug on XP.
proc createWindowWithCursor {} {

	toplevel .panel
	text     .panel.text
	.panel.text configure -cursor {gumby red green}
	pack .panel.text
}
#@nonl
#@-node:ekr.20031218072017.710:createWindowWithCursor
#@+node:ekr.20031218072017.711:createWindowWithIcon
proc createWindowWithIcon {} {

	global tk_library
	global tcl_patchLevel

	toplevel .panel
	
	# ***** Bitmaps apparently must be only 2 colors.  Photos are everything else!

	# wm iconbitmap .panel [image create photo -file c:/prog/leoCVS/leo/Icons/box00.GIF]
	#wm iconbitmap .panel [image create bitmap -file c:/prog/leoCVS/leo/Icons/box00.bmp]
	
	# no errors, no icon
	#wm iconbitmap .panel [image create bitmap @[file join c:/ Tcl lib tk8.3 demos images face.bmp]]
	# wm iconbitmap .panel @[file join c:/ Tcl lib tk8.3 demos images face.bmp]
	
	wm iconbitmap .panel info
	
	# Bitmap image1 not defined
	#wm iconbitmap .panel [image create photo -file [file join c:/ prog leoCVS leo Icons Leoapp.GIF]]
	
	# works
	#label .panel.bitmap -borderwidth 2 -relief sunken -bitmap @[file join $tk_library demos images face.bmp]
	#label .panel.lab -text $tk_library
	# label .panel.lab -borderwidth 2 -relief sunken -bitmap @[file join c:/ Tcl lib tk8.3 demos images face.bmp]
	# label .panel.lab -borderwidth 2 -relief sunken -bitmap @[file join c:/ prog leoCVS leo Icons face.bmp]
	
	# works!! (Only GIF allowed?)
	label .panel.lab -borderwidth 2 -relief sunken -image \
		[image create photo -file [file join c:/ prog leoCVS leo Icons Leoapp.GIF]]
	pack  .panel.lab

	label .panel.lab2 -text $tcl_patchLevel
	pack  .panel.lab2
}
#@nonl
#@-node:ekr.20031218072017.711:createWindowWithIcon
#@+node:ekr.20031218072017.712:myFrame
# w is the frame to be created.
# This configures w.f to be the content.
# Typically, the user will pack more content into w.f.

proc myFrame {w args} {

	# Args must come in pairs.
    if {([llength $args] % 2) != 0} {
        error {wrong # args: should be "myFrame pathName ?options?"}
    }
	# Initialize the local vars.
    set allopts {} # options that apply everywhere.
    set fopts {} # border options.
    set lopts {} # label options (only for labels that are Tk label widgets)
    set labelanchor nw # The usual default.
    set padx 0
    set pady 0
    set bd 2
    set relief groove
    set labelwindow "" # Can be any Tk widget!
    set text "" # The user usually just sets this.
	# Set vars based on args.
    foreach {opt val} $args {
        switch -- $opt {
            -bd - -borderwidth {
                set bd $val
            }
            -relief {
                set relief $val
            }
            -text {
                lappend lopts $opt $val
                set text $val
            }
            -font - -fg - -foreground {
                lappend lopts $opt $val
            }
            -labelanchor {
                set labelanchor $val
            }
            -labelwindow {
                set labelwindow $val
            }
            -padx {
                set padx $val
            }
            -pady {
                set pady $val
            }
            -bg - -background - -cursor {
                lappend allopts $opt $val
            }
            default {
                error "Unknown or unsupported option: $opt"
            }
        }
    }
	# relief and border options are frame options.
    lappend fopts -relief $relief -bd $bd 
	# Create the frame and its border, w.bd.
    eval frame $w $allopts
    eval frame $w.bd $fopts $allopts
	# Create lw depending on args.
    if {$labelwindow != ""} {
		# Used the window the user passed in.
        set lw $labelwindow
        raise $labelwindow $w
    } elseif {$text != ""} {
        set lw $w.l
		# This is typical.
        eval label $lw $lopts $allopts -highlightthickness 0 -bd 0
    } else {
        set lw ""
    }
	# Create the frame's grid.
    eval frame $w.f $allopts
	# Configure w as a grid with 5 rows and columns:
	# 1 border, 2 pad, 3 w.f, 4 pad, 5 border.
    grid columnconfigure $w {2 4} -minsize $padx
    grid rowconfigure    $w {2 4} -minsize $pady
    grid columnconfigure $w 3     -weight 1
    grid rowconfigure    $w 3     -weight 1
    grid columnconfigure $w {1 5} -minsize $bd
    grid rowconfigure    $w {1 5} -minsize $bd
	# Create the border, w.bd.
    grid $w.bd -row 1 -col 1 -rowspan 5 -columnspan 5 -sticky news
	# Create the content, w.f in the center.
    grid $w.f -row 3 -col 3 -sticky news
	# Optional: configure lw, the label window in the frame.
    if {$lw != ""} {
		# n*, s*, w* and e* are patterns to -glob.
        switch -glob $labelanchor {
            n* {
                grid $lw -in $w -row 0 -col 2 -rowspan 2 -columnspan 3 -padx 4
            }
            s* {
                grid $lw -in $w -row 5 -col 2 -rowspan 2 -columnspan 3 -padx 4
            }
            w* {
                grid $lw -in $w -row 2 -col 0 -rowspan 3 -columnspan 2 -pady 4
            }
            e* {
                grid $lw -in $w -row 2 -col 5 -rowspan 3 -columnspan 2 -pady 4
            }
        }
		# set the sticky param to the first character of the labelanchor, i.e., n,s,e or w.
        grid $lw -sticky [string index $labelanchor 1]
    }
}
#@nonl
#@-node:ekr.20031218072017.712:myFrame
#@+node:ekr.20031218072017.713:tk labeled frames
proc makeLeoFrame {} {

	# Create the outer labeld frame (doesn't actually have a label).
	myFrame .f -relief ridge -padx 5 -pady 5
	pack .f -fill both -expand 1 -padx 5 -pady 5
	
	# Initialize the grid positioin.
	set row 0
	set col 0
	# lp is the labelanchor value: 1 or two characters, the first character indicates side.
	foreach lp {nw n ne en e es se s sw ws w wn} {
		set w .f.f.f$lp
		# Create a myFrame: everything after %w are args.
		myFrame $w -text "Hej" -padx 2 -pady 2 -labelanchor $lp
		# Place the frame in the grid.
		grid $w -row $row -col $col -sticky news -padx 5 -pady 5
		# Create two buttons and pack them in the labeled frame.
		button $w.f.b1 -text Hoppsan
		button $w.f.b2 -text Quit -command exit
		pack $w.f.b1 $w.f.b2 -side top -fill x -padx 2 -pady 2
		# Bump the grid position.
		incr col
		if {$col == 3} {
			incr row
			set col 0
		}
	}
	
	# Create the last row.
	foreach wl {l1 l2 l3} {
		# Create the "special" label w.
		switch $wl {
			l1 {
				label .$wl -text Hej -bd 2 -relief groove
			} 
			l2 {
				checkbutton .$wl -text Hej
			} 
			l3 {
				radiobutton .$wl -text Hej
			}
		} 
		set w .f.f.f$wl
	
		# Create the labled frame using the -labelwindow option.
		myFrame $w -labelwindow .$wl -padx 2 -pady 2 -labelanchor nw
		# Place the labeled frame in the grid
		grid $w -row $row -col $col -sticky news -padx 5 -pady 5
		# Create two buttons and pack them in the labeled frame.
		button $w.f.b1 -text Hoppsan
		button $w.f.b2 -text Quit -command exit
		pack $w.f.b1 $w.f.b2 -side top -fill x -padx 2 -pady 2
		# Bump the grid position.
		incr col
		if {$col == 3} {
			incr row
			set col 0
		}
	}
}
#@nonl
#@-node:ekr.20031218072017.713:tk labeled frames
#@-node:ekr.20031218072017.680:@file c:/prog/test/leoSplitter.tcl
#@+node:ekr.20031218072017.714:tkBugs.tcl
#@+node:ekr.20031218072017.715:@file c:/prog/test/tkBugs.tcl
# This file creates tk test code for prototyping.
@language tcltk
@others

bindBug
#@+node:ekr.20031218072017.716:canvasBug
proc canvasBug {} {
	toplevel .test -bg "blue"
	canvas .test.c -bd 20 -bg "white" -relief "raised"
	pack .test.c -expand 1 -fill "both"
	text .test.c.t -height 1 -background "red"
	pack .test.c.t
	menu .test 
}
#@-node:ekr.20031218072017.716:canvasBug
#@+node:ekr.20031218072017.717:bindBug
proc bindBug {} {

	toplevel .top
	
	text .top.t
	pack .top.t
	
	menu .top.m   -tearoff 0
	menu .top.m.f -tearoff 0
	menu .top.m.e -tearoff 0
	
	.top.m.f add separator
	.top.m.f add command -label "A" -command {""}
	.top.m.f add command -label "B" -command {""}

	.top.m add cascade -label "File" -menu top.m.f -underline 0
	.top.m add cascade -label "Edit" -menu top.m.e -underline 0
	
	.top configure -menu .top.m
}
#@-node:ekr.20031218072017.717:bindBug
#@-node:ekr.20031218072017.715:@file c:/prog/test/tkBugs.tcl
#@-node:ekr.20031218072017.714:tkBugs.tcl
#@-node:ekr.20031218072017.679:Tk code
#@-node:ekr.20031218072017.678:Report Tk bugs
#@+node:ekr.20031218072017.718:(tab bug)
#@+node:ekr.20040117092727:This is definitely a Tk bug
By: dthein ( Dave Hein ) 
 RE: BUG: Non-leading tabs not working properl   
2004-01-17 14:40  

 This seems to be a TK bug. I've reproduced the problem directly in Tk.

It's been around for a long time :-(

More details on this page, along with a patch for an earlier version.

http://www.qs.co.nz/Tcl/TkTabs.html

The Tk folks fixed a bug I reported with Ctrl-V behavior, but it took about a year for them to get to it. I don't have high expectations with this problem either, but I'll probably put together a patch for some of the recent version of Tk and submit the patches and bug report.  
#@-node:ekr.20040117092727:This is definitely a Tk bug
#@+node:ekr.20040118090055:Patch and bug report
https://sourceforge.net/forum/message.php?msg_id=2380238
By: dthein

I've submitted a patch and bug report to the Tk project.

The patch, #879073, for those that want to fix this problem on their systems,
is at:

http://sourceforge.net/tracker/?func=detail&aid=879073&group_id=12997&atid=31299
7

And the bug report, #879077, is at:

http://sourceforge.net/tracker/?func=detail&aid=879077&group_id=12997&atid=11299
7

The patch is for 8.4.2.  If you have a different version, you can probably figure
out the changes needed by looking at the patch file.  If not, let me know your
version and I may be able to produce a patch for it.

Note: If you use tabs for anything other than leading whitespace, you will find
this patch really helpful.  I make lots of little tables when I'm documenting
or note-taking ... this fix really helped my sanity when making those tables
inside Leo.

Dave Hein
#@nonl
#@-node:ekr.20040118090055:Patch and bug report
#@+node:ekr.20031218072017.719:Report
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1906790
By: dspeed
Open Discussion

-- Tabs are not expanded correctly in .c files, when language in preferences is set to c, and when the tabs occur in the middle of a line. The tabs are expanded as spaces until the next tab location is reached, then the tabs are expanded correctly. 
#@-node:ekr.20031218072017.719:Report
#@+node:ekr.20040105070023.5:Report 2
Leo 4.1 rc3, build 1.62 , December 19, 2003
Python 2.3.0, Tk 8.4.2
Linux 2.4.22-21mdkenterprise

1. Any tab typed before the first tab stop behaves correctly (the cursor is moved to the tab stop). Good.

2. Any tab typed after a non-tab character (even a space) _and_ after the first tab stop position doesn't behave like a tab and doesn't move the cursor to the next tab stop. Bad.

3. Any tab typed after a tab character will behave properly no matter what position on the line. Okay.

To reproduce this, set your global tab prefernence to 4. Show invisibles. And then create a node containing:

[BEGIN BODY TEXT]
@language plain
@tabwidth 8
[END BODY TEXT]

Create a child node to that one, containing:

[BEGIN BODY TEXT]
@root-code somefilename
\t\tThis works
bbb\tAnd This works
So\tdoes this

But, this \tdoes not.
Here is the two-tab \t\t behavior.
[END BODY TEXT]

I hope this is a Leo bug and not a Tk bug. 

Dave Hein 
#@nonl
#@-node:ekr.20040105070023.5:Report 2
#@+node:ekr.20031218072017.720:Minimal test
This is a test line.
#@nonl
#@-node:ekr.20031218072017.720:Minimal test
#@+node:ekr.20031218072017.721:Test File for Non Expanding Tabs
This is a test line.
put the text insertion point in the space between 'a' and 'test' above. Enter 3 tabs in a row and watch it not work.

If your expansion works correctly, then maybe something with leoconfig?  But wait, Im using the leoconfig from the beta download.

The contents of my Log Windows when opening this file:

Leo Log Window...
Pyton 2.2.2, Tk 8.3.2
reading d:\test.leo


#@-node:ekr.20031218072017.721:Test File for Non Expanding Tabs
#@+node:ekr.20031218072017.722:setTabWidth
def setTabWidth (self, w):
	
	try: # This can fail when called from scripts
		# Use the present font for computations.
		font = self.bodyCtrl.cget("font")
		root = g.app.root # 4/3/03: must specify root so idle window will work properly.
		font = tkFont.Font(root=root,font=font)
		tabw = font.measure(" " * abs(w)) # 7/2/02
		self.bodyCtrl.configure(tabs=tabw)
		self.tab_width = w
		# g.trace(w,tabw)
	except:
		g.es_exception()
		pass
#@-node:ekr.20031218072017.722:setTabWidth
#@-node:ekr.20031218072017.718:(tab bug)
#@-node:ekr.20031218072017.673:Tk bugs
#@+node:ekr.20031218072017.723:Bugs: can't recreate
#@+node:ekr.20031218072017.724:(Uppercase bug) (Can't recreate)
#@+node:ekr.20031218072017.725:Report (I can't recreate this)
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1819473
By: nobody

When I create a @file node for a file with an uppercase name like TEST.CPP, by
picking up its name, an empty node is created. On saving the leo file, it
empties the TEST.CPP file!! BAD.

On the other hand, if I key in the filename in the dialog box as 'test.cpp'
(all lowercase) the node is created properly.

Rajiv Bhagwat
#@-node:ekr.20031218072017.725:Report (I can't recreate this)
#@-node:ekr.20031218072017.724:(Uppercase bug) (Can't recreate)
#@-node:ekr.20031218072017.723:Bugs: can't recreate
#@+node:ekr.20031218072017.726:Put the setup stuff in the dist folder where they belong
#@-node:ekr.20031218072017.726:Put the setup stuff in the dist folder where they belong
#@+node:ekr.20040129133809.8:top node not saved
When opening a .leo file Leo selects the correct node but it is no longer the top most node in the window.

(no) Probably related to Leo now saving of the body pane size.
#@nonl
#@+node:ekr.20040130174232:What I did
@nocolor

- Eliminated entries like a="":  This happened because Leo no longer writes clone bits.

- Made sure Leo writes a="T" entries.  However, Leo really can't use this easily.

Another possibility would be to save the scrolling state, but that is very gui-dependent.
#@nonl
#@-node:ekr.20040130174232:What I did
#@+node:ekr.20031218072017.1579:putVnodes
def putVnodes (self):

	"""Puts all <v> elements in the order in which they appear in the outline."""

	c = self.c
	c.clearAllVisited()

	self.put("<vnodes>") ; self.put_nl()

	# Make only one copy for all calls.
	self.currentPosition = c.currentPosition() 
	self.topPosition     = c.topPosition()

	if self.usingClipboard:
		self.putVnode(self.currentPosition) # Write only current tree.
	else:
		for p in c.rootPosition().self_and_siblings_iter():
			self.putVnode(p) # Write the next top-level node.

	self.put("</vnodes>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1579:putVnodes
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

	c = self.c ; v = None
	setCurrent = setExpanded = setMarked = setOrphan = setTop = false
	tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
	# we have already matched <v.
	while 1:
		if self.matchTag("a=\""):
			<< Handle vnode attribute bits >>
		elif self.matchTag("t="):
			# New for 4.1.  Read either "Tnnn" or "gnx".
			tref = self.getDqString()
		elif self.matchTag("vtag=\"V"):
			self.getIndex() ; self.getDquote() # ignored
		elif self.matchTag("tnodeList="):
			s = self.getDqString()
			tnodeList = self.getTnodeList(s) # New for 4.0
		elif self.matchTag(">"):
			break
		else: # New for 4.0: allow unknown attributes.
			# New in 4.2: allow pickle'd and hexlify'ed values.
			attr,val = self.getUnknownAttribute()
			attrDict[attr] = val
	# Headlines are optional.
	if self.matchTag("<vh>"):
		headline = self.getEscapedString() ; self.getTag("</vh>")
	
	# g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
	if skip:
		v = self.getExistingVnode(tref)
	else:
		v,skip = self.createVnode(parent,back,tref,headline,attrDict)
		if tnodeList:
			v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
			# g.trace("%4d" % len(tnodeList),v)

	<< Set the remembered status bits >>

	# Recursively create all nested nodes.
	parent = v ; back = None
	while self.matchTag("<v"):
		append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
		append2 = appendToTopStack and len(self.topVnodeStack) == 0
		back = self.getVnode(parent,back,skip,
			appendToCurrentStack=append1,appendToTopStack=append2)
			
	<< Append to current or top stack >>

	# End this vnode.
	self.getTag("</v>")
	return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
	if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
	elif self.matchChar('D'): pass # Not used.
	elif self.matchChar('E'): setExpanded = true
	elif self.matchChar('M'): setMarked = true
	elif self.matchChar('O'): setOrphan = true
	elif self.matchChar('T'): setTop = true
	elif self.matchChar('V'): setCurrent = true
	else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
	self.currentVnodeStack = [v]

if setTop:
	self.topVnodeStack = [v]
	
if setExpanded:
	v.initExpandedBit()
	
if setMarked:
	v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
	v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
	#g.trace("append current",v)
	self.currentVnodeStack.append(v)
	
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
	#g.trace("append top",v)
	self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

	"""Write a <v> element corresponding to a vnode."""

	fc = self ; c = fc.c ; v = p.v
	isThin = p.isAtThinFileNode()

	fc.put("<v")
	<< Put tnode index >>
	<< Put attribute bits >>
	<< Put tnodeList and unKnownAttributes >>
	fc.put(">")
	<< Write the head text >>

	# New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
	if p.hasChildren():
		if isThin and not p.isOrphan() and not self.usingClipboard:
			# g.trace("skipping child vnodes for", p.headString())
			pass
		else:
			fc.put_nl()
			# This optimization eliminates all "recursive" copies.
			p.moveToFirstChild()
			while 1:
				fc.putVnode(p)
				if p.hasNext(): p.moveToNext()
				else:           break
			p.moveToParent()

	fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(v.t.fileIndex)
		fc.put(" t=") ; fc.put_in_dquotes(gnx)
	else:
		fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
		
	# g.trace(v.t)
	if not isThin or self.usingClipboard:
		v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
	g.trace(v.t.fileIndex,v)
	g.es("error writing file(bad v.t.fileIndex)!")
	g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
	# Almost 30% of the entire writing time came from here!!!
	if p.equal(self.topPosition):     attr += "T" # was a bottleneck
	if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
	if v.isAnyAtFileNode() and not v.isAtThinFileNode():
		if hasattr(v.t,"tnodeList"):
			g.trace(v.headString(),len(v.t.tnodeList))
		else:
			g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
	fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
	self.putUnknownAttributes(v)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
	fc.put("<vh>")
	fc.putEscapedString(headString)
	fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.2297:fileCommands.open
def open(self,file,fileName):

	c = self.c ; frame = c.frame
	# Read the entire file into the buffer
	self.fileBuffer = file.read() ; file.close()
	self.fileIndex = 0
	<< Set the default directory >>
	self.topPosition = None
	c.beginUpdate()
	ok, ratio = self.getLeoFile(fileName,atFileNodesFlag=true)
	frame.resizePanesToRatio(ratio,frame.secondary_ratio) # 12/2/03
	if 0: # 1/30/04: this is useless.
		if self.topPosition: 
			c.setTopVnode(self.topPosition)
	c.endUpdate()
	# delete the file buffer
	self.fileBuffer = ""
	return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

dir = g.os_path_dirname(fileName)

if len(dir) > 0:
	c.openDirectory = dir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
#@-node:ekr.20031218072017.2297:fileCommands.open
#@+node:ekr.20031218072017.3030:fileCommands.readOutlineOnly
def readOutlineOnly (self,file,fileName):

	c = self.c
	# Read the entire file into the buffer
	self.fileBuffer = file.read() ; file.close()
	self.fileIndex = 0
	<< Set the default directory >>
	c.beginUpdate()
	ok, ratio = self.getLeoFile(fileName,atFileNodesFlag=false)
	c.endUpdate()
	c.frame.deiconify()
	vflag,junk,secondary_ratio = self.frame.initialRatios()
	c.frame.resizePanesToRatio(ratio,secondary_ratio)
	if 0: # 1/30/04: this is useless.
		# This should be done after the pane size has been set.
		if self.topPosition:
			c.frame.tree.setTopPosition(self.topPosition)
			c.redraw()
	# delete the file buffer
	self.fileBuffer = ""
	return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

dir = g.os_path_dirname(fileName)

if len(dir) > 0:
	c.openDirectory = dir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
#@-node:ekr.20031218072017.3030:fileCommands.readOutlineOnly
#@-node:ekr.20040129133809.8:top node not saved
#@-node:ekr.20031218072017.663:Bug: can't be fixed
#@+node:ekr.20040105064959:Bugs: can wait
@nocolor
#@nonl
#@+node:ekr.20040115165036:bug in xml doc parts (hard to fix?)
@language html
@ignore
@color
#@nonl
#@+node:ekr.20040115165036.1:Demo XML comment bug
@ 
This document demonstrates what appears to be a bug in Leo 4.1 rc3, build 1.62 of December 19, 2003.

It has manifested when Leo is executed under Python 2.3.3, Tk 8.4.3 under Windows 2000.

In brief, derived XML files are not well-formed with respect to comments under some conditions.  Comments can wind up nested, which looks okay to humans but not to XML parsers.
@c
#@nonl
#@-node:ekr.20040115165036.1:Demo XML comment bug
#@+node:ekr.20040115165036.3:@file xmlcommentbug.xml
@first
@language HTML
<HiMom>
@ This will produce, in the derived file, an XML comment with another XML comment embedded.  Or, if you prefer, it will produce an unclosed XML comment followed by a well-formed one, followed by a string of text containing a comment-close marker.

This text is sitting in the inner comment, according to the first view.
@c


@
This comment is well-formed, seemingly because its content does not begin on the same line as the at-sign.
@c
</HiMom>
#@nonl
#@-node:ekr.20040115165036.3:@file xmlcommentbug.xml
#@+node:ekr.20040115165036.4:xmlcommentbug.xml
<?xml version='1.0'?>
<!--@+leo-ver=4-->
<!--@+node:@file xmlcommentbug.xml-->
<!--@@first-->
<!--@@language HTML-->
<HiMom>
<!--@+at -->
<!--
<!--@nonl-->
This will produce, in the derived file, an XML comment with another XML 
comment embedded.  Or, if you prefer, it will produce an unclosed XML comment 
followed by a well-formed one, followed by a string of text containing a 
comment-close marker.

This text is sitting in the inner comment, according to the first view.
-->
<!--@-at-->
<!--@@c-->


<!--@+at-->
<!--
This comment is well-formed, seemingly because its content does not begin on 
the same line as the at-sign.
-->
<!--@-at-->
<!--@@c-->
</HiMom>
<!--@nonl-->
<!--@-node:@file xmlcommentbug.xml-->
<!--@-leo-->
#@nonl
#@-node:ekr.20040115165036.4:xmlcommentbug.xml
#@-node:ekr.20040115165036:bug in xml doc parts (hard to fix?)
#@+node:ekr.20040125114453:Import bug?control-alt-f of python code misalloctes code (waiting for answer)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2391076
By: thyrsus

There is a lot of correct intepretation going on, but there are some errors.
As an example, the anaconda code, in text.py, contains the following lines.
I'll use periods for leading whitespace, the two characters ^I for leading tabs,
and a $ to indicate a newline:

class WaitWindow:
def pop(self):
	self.screen.popWindow()
	self.screen.refresh()

def __init__(self, screen, title, text):
	self.screen = screen
	width = 40
	if (len(text) < width): width = len(text)

	t = TextboxReflowed(width, text)

	g = GridForm(self.screen, title, 1, 1)
	g.add(t, 0, 0)
	g.draw()
	self.screen.refresh()


After importing file text.py, I get three associated nodes like so:

[class WaitWindow]
.|
.+-[pop]
.|
.+-[__init__]

However, the contents of the nodes are off.  In node [class WaitWindow] the
text is

class WaitWindow:
@others
	self.screen = screen
	width = 40
	if (len(text) < width): width = len(text)

	t = TextboxReflowed(width, text)
	g = GridForm(self.screen, title, 1, 1)
	g.add(t, 0, 0)
	g.draw()
	self.screen.refresh()

Node [pop] contains the text

def pop(self):

Node [__init__] contains the text

self.screen.popWindow()
self.screen.refresh()

def __init__(self, screen, title, text):

This anaconda code is being correctly interpreted by the python 1.5 interpreter.
I'm too green with python to pronounce on whether the formatting is conventional.
I don't consider this a bug a major problem, but it should probably be addressed
before we start touting Leo for large collections of existing code.

This is my first experience importing python; in the past I've imported perl
code, and Leo gave me just one big @file node, and I was on my own to better
structure it.  Given the perversity of perl syntax ("Nothing but perl can parse
Perl." - Tom Christiansen), that's probably the right thing to do.  It's a judgement
call for whomever wants to take responsibility for the python importer as to
whether that may be the right thing to do for python.
#@nonl
#@-node:ekr.20040125114453:Import bug?control-alt-f of python code misalloctes code (waiting for answer)
#@+node:ekr.20040129133809.5:Expand/contract may not work after drag (works for me)
sometimes after a drag of a node, 
then the expand/contract doesnt work.
click or menu has no effect.
in an open leo
maybe it is ok after you save the file
other times only fix is to exit & restart.
#@nonl
#@-node:ekr.20040129133809.5:Expand/contract may not work after drag (works for me)
#@-node:ekr.20040105064959:Bugs: can wait
#@-node:ekr.20040329185649:Bugs: can't be fixed or can wait
#@-node:ekr.20040123102724:Can't or wont
#@-node:ekr.20031218072017.646:To do...
#@+node:EKR.20040430163619:To Do: 4.2
#@+node:ekr.20040323170225:General bugs
#@+node:ekr.20040327123438:Idle hooks are not working properly!  (add unregisterHandler)
#@+node:ekr.20040327132739.3:Notes
@nocolor
	
1. "idle" hooks keep getting called even after a window goes away.
2. Idle hooks in one window interfere with idle hooks in another window.
3. It's confusing to set idle hooks.
	- At least one  plugin may have to call enableIdleTimeHook.

Also, the doHook logic seems much too complex.
	- It doesn't correspond to the registerHandler logic.
	- And why is there a separate doHandlersForTag method???
#@nonl
#@-node:ekr.20040327132739.3:Notes
#@+node:ekr.20031218072017.3139:Hooks & plugins (leoGlobals)
#@+node:ekr.20031218072017.1315:enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every idleTimeDelay milliseconds.
@c
def enableIdleTimeHook(idleTimeDelay=100):
	app.idleTimeHook = true
	app.idleTimeDelay = idleTimeDelay # Delay in msec.
	app.gui.setIdleTimeHook(idleTimeHookHandler)
	
# Disables the "idle" hook.
def disableIdleTimeHook():
	app.idleTimeHook = false
	
# An internal routine used to dispatch the "idle" hook.
trace_count = 0
def idleTimeHookHandler(*args,**keys):
	
	if 0:
		global trace_count ; trace_count += 1
		if trace_count % 10 == 0: g.trace(trace_count)

	# New for Python 2.3: may be called during shutdown.
	if app.killed: return
	c = g.top()
	if c: v = c.currentVnode()
	else: v = None
	g.doHook("idle",c=c,v=v)
	# Requeue this routine after 100 msec.  Faster requeues overload the system.
	if app.idleTimeHook:
		app.gui.setIdleTimeHookAfterDelay(app.idleTimeDelay,idleTimeHookHandler)
		app.afterHandler = idleTimeHookHandler
	else:
		app.afterHandler = None
#@nonl
#@-node:ekr.20031218072017.1315:enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler
#@+node:ekr.20031218072017.1596:frame.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):

	c = g.top() # c may be None during startup.
	
	if app.killed or app.hookError:
		return None
	elif not app.config.use_plugins:
		if tag == "start1":
			g.es("Plugins disabled: use_plugins is 0",color="blue")
		return None
	elif c and c.hookFunction:
		try:
			return c.hookFunction(tag,keywords)
		except:
			g.es("exception in c.hookFunction for " + c.frame.getTitle())
	elif app.hookFunction:
		try:
			return app.hookFunction(tag,keywords)
		except:
			g.es("exception in app.hookFunction")
	else:
		import leoPlugins
		try:
			app.hookFunction = leoPlugins.doPlugins
			return app.hookFunction(tag,keywords)
		except:
			app.hookFunction = None
			g.es("exception in plugin")

	# Handle all exceptions.
	g.es_exception()
	app.hookError = true # Supress this function.
	app.idleTimeHook = false # Supress idle-time hook
	return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:frame.doHook
#@+node:ekr.20031218072017.1318:plugin_signon
def plugin_signon(module_name,verbose=false):
	
	exec("import %s ; m = %s" % (module_name,module_name))
	
	if verbose:
		g.es("...%s.py v%s: %s" % (
			m.__name__, m.__version__, g.plugin_date(m)))

		print m.__name__, m.__version__
		
	app.loadedPlugins.append(module_name)
#@nonl
#@-node:ekr.20031218072017.1318:plugin_signon
#@-node:ekr.20031218072017.3139:Hooks & plugins (leoGlobals)
#@-node:ekr.20040327123438:Idle hooks are not working properly!  (add unregisterHandler)
#@+node:ekr.20040329094003.1:Fix or improve Import command
#@+node:ekr.20040319102251:Import bug: section names when importing C files
By: nobody ( Nobody/Anonymous ) 
 Undocumented Program Feature???   
2004-03-18 14:44  

 From: Rich

I'm following the thread on body pane sluggishness, and decided to see what happened when I imported a huge (7676 lines) C file as @root.

Leo did well with the includes & declarations, and separated the functions well. Each function node has <<SC functions >>= at the top. My puzzlement is that the top node has the lines

<< SC #includes >>
<< SC declarations >>
<< SC methods >>

... but "SC methods" is undefined. I'm guessing that "methods" should be replaced by "functions" or vice-versa.
#@nonl
#@-node:ekr.20040319102251:Import bug: section names when importing C files
#@+node:ekr.20040329094003.2:Import bug: @tabwidth -4 doesn't work
#@-node:ekr.20040329094003.2:Import bug: @tabwidth -4 doesn't work
#@+node:ekr.20040329094003.3:Import bug: Import should create absolute path
#@-node:ekr.20040329094003.3:Import bug: Import should create absolute path
#@+node:ekr.20040129080256.1:(Import bugs: fixed??)
#@+node:ekr.20040125114612:Can't import extensionless file: works on Windows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2387427
By: dthein

Minor bug, I guess.

But if I try to import (either as root or file node) a file called README, I
get an error saying Leo couldn't find "README.py".

I had to rename the file to README.txt and then import it, then change the @file-code
heading to "@file-code README" ... same with @root-code directive.


Dave Hein
#@-node:ekr.20040125114612:Can't import extensionless file: works on Windows
#@+node:ekr.20040105103517:Importing @file issues
#@+node:ekr.20040129094501:Reports
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2355533
By: sbeards

So, here is a summary of these issues.

Scott
#@nonl
#@+node:ekr.20040129100453:Imported @files have an extra newline in the body
This is a bit more complicated than I first thought. We found that this issue
does not cause a "cannot send headers" warning for a PHP file. This problem
is caused when you have more than one character after the ?> (a newline or any
other character will do it). I must have had some other problem with my source
file.

Further, Leo does _not_ add a newline at the end of the body text for imported
files. When there is a newline at the end of the source file Leo acts as TextPad
acts (shows the last valid cursor position as the beginning of the line after
the last line). When there is no newline at the end of the source file Leo will
show the last valid cursor position as the end of the last line. This is the
expected behavior.
#@nonl
#@-node:ekr.20040129100453:Imported @files have an extra newline in the body
#@+node:ekr.20040129100453.1:@last fails with multiple newlines
The ending ?> will not exist in the derived file when multiple newlines exist
after the @last directive.
Test body text:
@last

Test derived file output:
#@verbatim
#@+leo-ver=4
#@verbatim
#@+node:@file test.txt
#@verbatim
#@@last
                                                                           
#@verbatim
#@-node:@file test.txt
#@verbatim
#@-leo
#@-node:ekr.20040129100453.1:@last fails with multiple newlines
#@+node:ekr.20040129100453.2:derived files with @last always end with a newline character
When using @last the last character in a derived file is always a newline
(when using @file or @file-nosent and maybe always?).

This will only be a problem in special cases when you do not want the derived
file to end in a newline (when generating binary files maybe?).
#@nonl
#@-node:ekr.20040129100453.2:derived files with @last always end with a newline character
#@-node:ekr.20040129094501:Reports
#@+node:ekr.20040105103916:Fix?
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2355564
By: sbeards

When importing a PHP file with a short open tag (see
http://www.php.net/manual/en/configuration.directives.php#ini.short-open-tag)
or an open tag with all caps or mixed case Leo will recognize the file as mixed
HTML and PHP. This prevents the file from being automatically expanded by Leo
(a very cool automation process).

One way that I fixed this in my copy of Leo was to make the following change
in leoImport.py:scanPHPtext():
change:

if not s.startswith("<?php") to if not s.startswith("<?")

However, this will not work if the file starts with an xml open tag (since an
open tag for an xml file is <?xml).

maybe the following will work?

if not (
	s.startswith("<?P") or s.startswith("<?p") or s.startswith("<?=") or
	s.startswith("<?\n") or s.startswith("<? ") or s.startswith("<?\t") or
	s.startswith("<?\r"))

This way seems really messy and not fully complete. Does anyone have a better
way?

Also maybe the next line in leoImport.py should be changed to check for

s.endswith("?>\r")

This way it'll work for our Mac friends too.

Scott
#@nonl
#@-node:ekr.20040105103916:Fix?
#@+node:ekr.20031218072017.3243:<< Append file if not pure PHP >>
# If the file does not begin with <?php or end with ?> then
# it is simply appended like a generic import would do.

s.strip() # Remove inadvertent whitespace.

#if (
#	not s.startswith("<?php")
#	or not (s.endswith("?>") or s.endswith("?>\n") or s.endswith("?>\r\n")
#):

if (
	not (
		s.startswith("<?P") or
		s.startswith("<?p") or
		s.startswith("<?=") or
		s.startswith("<?\n") or
		s.startswith("<?\r") or
		s.startswith("<? ") or
		s.startswith("<?\t")
	) or not (
		s.endswith("?>\n") or
		s.endswith("?>\r") or
		s.endswith("?>\r\n")
	)
):
	g.es("File seems to be mixed HTML and PHP; importing as plain text file.")
	parent.setBodyStringOrPane("@ignore\n" + self.rootLine + s)
	return
#@nonl
#@-node:ekr.20031218072017.3243:<< Append file if not pure PHP >>
#@+node:ekr.20031218072017.3242:scanPHPText (Dave Hein)
# 08-SEP-2002 DTHEIN: Added for PHP import support.
#
# PHP uses both # and // as line comments, and /* */ as block comments

def scanPHPText (self,s,parent):

	"""Creates a child of parent for each class and function definition seen."""

	import re
	<< Append file if not pure PHP >>

	<< define scanPHPText vars >>
	# 14-SEP-2002 DTHEIN: Make leading <?php use the @first directive
	parent.appendStringToBody("@first ")	
	parent.appendStringToBody(s[:startOfCode])
	scan_start = i = startOfCode
	while i < endOfCode:
		# line = g.get_line(s,i) ; g.trace(line)
		ch = s[i]
		# These cases skip tokens.
		if ch == '/' or ch == '#':
			<< handle possible PHP comments >>
		elif ch == '<':
			<< handle possible heredoc string >>
		elif ch == '"' or ch == '\'':
			i = g.skip_string(s,i)
		# These cases help determine where functions start.
		# FIXME: probably want to capture 'var's as class member data
		elif ch == 'f' or ch =='c':
			<< handle possible class or function >>
		elif class_start and (ch == '}'):
			<< handle end of class >>
		else: i += 1
	<< Append any unused text to the parent's body text >>
	# 14-SEP-2002 DTHEIN: Make leading <?php use the @first directive
	parent.appendStringToBody("@last ")	
	parent.appendStringToBody(s[endOfCode:])
#@nonl
#@+node:ekr.20031218072017.3243:<< Append file if not pure PHP >>
# If the file does not begin with <?php or end with ?> then
# it is simply appended like a generic import would do.

s.strip() # Remove inadvertent whitespace.

#if (
#	not s.startswith("<?php")
#	or not (s.endswith("?>") or s.endswith("?>\n") or s.endswith("?>\r\n")
#):

if (
	not (
		s.startswith("<?P") or
		s.startswith("<?p") or
		s.startswith("<?=") or
		s.startswith("<?\n") or
		s.startswith("<?\r") or
		s.startswith("<? ") or
		s.startswith("<?\t")
	) or not (
		s.endswith("?>\n") or
		s.endswith("?>\r") or
		s.endswith("?>\r\n")
	)
):
	g.es("File seems to be mixed HTML and PHP; importing as plain text file.")
	parent.setBodyStringOrPane("@ignore\n" + self.rootLine + s)
	return
#@nonl
#@-node:ekr.20031218072017.3243:<< Append file if not pure PHP >>
#@+node:ekr.20031218072017.3244:<< define scanPHPText vars >>
scan_start = 0
class_start = 0
function_start = 0
i = 0
class_body = ""
class_node = ""
phpClassName = re.compile("class\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")
phpFunctionName = re.compile("function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")

# 14-SEP-2002 DTHEIN: added these 2 variables to allow use of @first/last
startOfCode = s.find("\n") + 1 # this should be the line containing the initial <?php
endOfCode = s.rfind("?>") # this should be the line containing the last ?>
#@-node:ekr.20031218072017.3244:<< define scanPHPText vars >>
#@+node:ekr.20031218072017.3245:<< handle possible heredoc string >>
if g.match(s,i,"<<<"):
	i = g.skip_heredoc_string(s,i)
else:
	i += 1
#@-node:ekr.20031218072017.3245:<< handle possible heredoc string >>
#@+node:ekr.20031218072017.3246:<< handle possible PHP comments >>
if g.match(s,i,"//"):
	i = g.skip_line(s,i)
elif g.match(s,i,"#"):
	i = g.skip_line(s,i)
elif g.match(s,i,"/*"):
	i = g.skip_block_comment(s,i)
else:
	i += 1
#@nonl
#@-node:ekr.20031218072017.3246:<< handle possible PHP comments >>
#@+node:ekr.20031218072017.3247:<< handle possible class or function >>
@ In PHP, all functions are typeless and start with the keyword "function;  all classes start with the keyword class.

Functions can be nested, but we don't handle that right now (I don't think it is a common practice anyway).
@c
if g.match(s,i,"function "):
	#we want to make the function a subnode of either the @file node or a class node
	# 1. get the function name
	# 2. make a reference in the parent
	# 3. create the child node, and dump the function in it.
	function_start = i
	m = phpFunctionName.match(s[i:])
	if (None == m): # function keyword without function name
		i += len("function ")
	else:
		headline = g.angleBrackets(" function " + m.group(1) + " ")
		# find the end of the function
		openingBrace = s.find('{',i)
		function_end = g.skip_php_braces(s,openingBrace)
		function_end = g.skip_to_end_of_line(s,function_end - 1) + 1 # include the line end
		# Insert skipped text into parent's body.
		if class_start:
			class_body += s[scan_start:function_start]
		else:
			parent.appendStringToBody(s[scan_start:function_start])
		# Append the headline to the parent's body.
		if class_start:
			class_body += (headline + "\n")
		else:
			parent.appendStringToBody(headline + "\n")
		# Backup to capture leading whitespace (for undent purposes)
		while (function_start > 0) and (s[function_start - 1] in [" ", "\t"]):
			function_start -= 1
		# Get the body and undent it
		function_body = s[function_start:function_end]
		function_body = self.undentBody(function_body)
		if self.treeType != "@file":
			function_body = "@code\n\n" + function_body
		# Create the new node
		if class_start:
			self.createHeadline(class_node,function_body,headline)
		else:
			self.createHeadline(parent,function_body,headline)
		i = function_end
		scan_start = i
		function_end = 0
		function_start = 0 #done with this function
		function_body = ""
		
elif g.match(s,i,"class "):
	# we want to make the class a subnode of the @file node
	# 1. get the class name
	# 2. make a reference in the parent
	# 3. create the child node and dump the function in it
	class_start = i
	class_body = ""
	m = phpClassName.match(s[i:])
	if (None == m): # class keyword without class name
		i += len("class ")
	else:
		# Insert skipped text into parent's body.
		parent.appendStringToBody(s[scan_start:class_start])
		# create the headline name
		headline = g.angleBrackets(" class " + m.group(1) + " ")
		# find the place to start looking for methods (functions)
		openingBrace = s.find('{',i)
		# find the end of the class
		class_end = g.skip_php_braces(s,openingBrace)
		class_end = g.skip_to_end_of_line(s,class_end - 1) + 1 # include the line end
		# Append the headline to the parent's body.
		parent.appendStringToBody(headline + "\n")
		# Backup to capture leading whitespace (for undent purposes)
		while (class_start > 0) and (s[class_start - 1] in [" ", "\t"]):
			class_start -= 1
		scan_start = class_start
		# Create the new node
		class_node = self.createHeadline(parent,"",headline)
		i = openingBrace
	
else:
	i += 1
#@nonl
#@-node:ekr.20031218072017.3247:<< handle possible class or function >>
#@+node:ekr.20031218072017.3248:<< handle end of class >>
# Capture the rest of the body
class_body += s[scan_start:class_end]
# insert the class node's body
if self.treeType != "@file":
	class_body = "@code\n\n" + class_body
class_body = self.undentBody(class_body)
class_node.appendStringToBody(class_body)
# reset the indices
i = class_end
scan_start = i
class_end = 0
class_start = 0 #done with this class
class_body=""
#@-node:ekr.20031218072017.3248:<< handle end of class >>
#@+node:ekr.20031218072017.3249:<< Append any unused text to the parent's body text >>
parent.appendStringToBody(s[scan_start:endOfCode])
#@-node:ekr.20031218072017.3249:<< Append any unused text to the parent's body text >>
#@-node:ekr.20031218072017.3242:scanPHPText (Dave Hein)
#@-node:ekr.20040105103517:Importing @file issues
#@-node:ekr.20040129080256.1:(Import bugs: fixed??)
#@+node:ekr.20040104200407:Add @language html when importing html files
#@-node:ekr.20040104200407:Add @language html when importing html files
#@+node:ekr.20040107090747.1:Add @nocolor when importing text files
#@-node:ekr.20040107090747.1:Add @nocolor when importing text files
#@-node:ekr.20040329094003.1:Fix or improve Import command
#@+node:ekr.20040225061559:Look at older config files when reading config data the first time for a new install
1) Is there a way that a "new" Leo installation could query the older one for config data? That is, every time I get a new copy, I need to do a side-by-side compare and edit with the previous leoConfig.leo in order to change the settings to the way I want them. It would be really nice if this could be automated in some fashion.

#@-node:ekr.20040225061559:Look at older config files when reading config data the first time for a new install
#@+node:ekr.20031218072017.744:@tab, @notab (or make @tabwidth -n work again)
#@-node:ekr.20031218072017.744:@tab, @notab (or make @tabwidth -n work again)
#@+node:ekr.20040218053305:Fix names of Leo windows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2429098
By: nobody

can there be a little more consistance in the popup names?
find/change is Leo find change and has the leo icon
prefs is prefs for leo w/Tk icon
compare is Leo Compare . w/Tk icon
open python is *leo*  w/Tk icon
when Leo is the first word, then its not as easy to
select if you have more than one open
from the taskbar. sometimes all you see is Leo...
its also a little nebulous which leo they work on,
maybe good design, but shoulden't they be able to tag the title at least with
the current leo which has focus?
not something immediate, but as new dialogs are comtemplated and plugins can
open them, maybe something in globals can be beefed up to name and open dialogs.
#@nonl
#@-node:ekr.20040218053305:Fix names of Leo windows
#@+node:ekr.20040329094003.4:Preserve whitespace in imports
#@-node:ekr.20040329094003.4:Preserve whitespace in imports
#@+node:ekr.20040310091144:Window position: possible bug
@nocolor

By: dalcolmo ( Josef Dalcolmo ) 
 initial_window position   
2004-03-04 17:57  

 I just installed 4.1 (had 4.1rc4 so far) and now I noticed that the Leo application window doesn't appear in the upper left corner any more, but with a bit of an offset.

I thought this is because of the leoConfig.txt settings of:

initial_window_top = 20
initial_window_left = 20

I tried to set these to 0, but that did not work at all any more!

Then I tried to set this values to 1, which works but the offset is still greater. When saving a file with a position in the corner it still appears with an offset when starting it again.

Since I changed some other configurations on my computer almost at the same time, I am not absolutely sure that the problem isn't coming from somewhere else - still the settings I named above don't seem to work properly.

- Josef
 
---------------------------------------

https://sourceforge.net/forum/message.php?msg_id=2457260
By: dalcolmo


>Iirc the window position gets written to leoConfig.txt if that file exists
and is writable. I would first check that file.

I thought the window position (and size) ist stored in the .leo file (it is
per file).

>The settings you mention are probably (again iirc) for new windows.

I thought they would apply if I start a new Leo without a preexisting file.
They do not work properly in this case either.

Can you position a Leo window (the whole application) so it appears on the upper
left corner of the screen when double-clicking on the leo file?

(I am using Leo 4.1 final with Python 2.3.3 on Win2000. I recently upgraded
both Leo and Python and now I can't place Leo windows in the corner any more
- upon starting).

Best regards - Josef Dalcolmo
#@-node:ekr.20040310091144:Window position: possible bug
#@+node:ekr.20040310092400:Allow </leo_header>
@nocolor

By: billp9619 ( bill palmer ) 
 leo_header optional closetag sb valid?   
2004-03-07 01:21  

 1. <leo_header ... />
vs.
2. <leo_header ... ></leo_header>

Leo saves using style 1 and treats style 2 as invalid.

Both are equivalent and so I think leo should accept both. Some applications for comparing xml insist on style 2. 

billp
 
#@-node:ekr.20040310092400:Allow </leo_header>
#@+node:ekr.20040225061559.1:Change message when derived file not found
(2) On loading leoPlugins.leo, I got "Unexpected end of file. Expecting @-leo sentinel" for the following files:

#@-node:ekr.20040225061559.1:Change message when derived file not found
#@+node:ekr.20031218072017.859:Should mouse up cancel a drag?
Clone dragging isn't working reliably.
#@nonl
#@-node:ekr.20031218072017.859:Should mouse up cancel a drag?
#@+node:ekr.20040216153243.5:Select All in headline affects body text
when in headline, selectall selects the body text then delete will delete it!
obviously, these should only be operating on the headline text at that point.

-selectall now selets all the body, but its not a visable select and delete
delets it while focus is still in the log or headline!


EKR:  The Select All command probably should select all text in the widget that has focus.
#@+node:ekr.20031218072017.839:<< define editMenuTopTable >>
self.editMenuTopTable = (
	("Can't Undo","Ctrl+Z",c.undoer.undo), # &U reserved for Undo
	("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &R reserved for Redo
	("-",None,None),
	("Cu&t","Ctrl+X",f.OnCutFromMenu), 
	("Cop&y","Ctrl+C",f.OnCopyFromMenu),
	("&Paste","Ctrl+V",f.OnPasteFromMenu),
	("&Delete",None,c.delete),
	("Select &All","Ctrl+A",f.body.selectAllText),
	("-",None,None))
#@nonl
#@-node:ekr.20031218072017.839:<< define editMenuTopTable >>
#@-node:ekr.20040216153243.5:Select All in headline affects body text
#@+node:ekr.20040330092305.1:Make "end1" events (and destroy-all-global-windows) work again
@nocolor

 
The 'end1' event is not working. I believe the problem is a logic problem.

in leoApp.py:

@color

def finishQuit(self):

self.killed = true # Disable after events.

a little latter in the method:

doHook("end1")
#@nonl
#@-node:ekr.20040330092305.1:Make "end1" events (and destroy-all-global-windows) work again
#@+node:ekr.20040331152236:Fix unicode problem in config module
@nocolor

By: Maxim Krikun - tws5
 Non-ASCII in plugin config   
2004-03-25 23:34  

 I run Leo 4.1 final, build 1.77 ,
Python 2.3.0, Tk 8.4.3, on windows 98.
For some reason i had to enter non-ascii string in plugin preferences box (header_style for word export plugin, since ms word is localized and has style names different from "Header"). 

I found that the dialog doesn't close on OK button, and the ini file gets broken -- not all options remain there. 

As i investigated, ConfigParser.write() method when writing to a file claimed it can't convert unicode string to ascii. This problem was fixed by setting system default locale in site.py, (s/if: 0/if: 1/ at line 321).

However when re-opeinig properties box the non-ascii settings were displayed correctly. To fix this i had to add unicode constructor before setting Tk widget value: 

(at leoPlugins.leo / PluginsMenu / class PropertiesWindow / __init__ / << Create widgets for each section and option >>)

e = Tk.Entry(b)
e.insert(0, unicode(config.get(section, option)))

I don't know if this problems does exist on other platforms. Setting encoding in site.py is a litl bit tricky. Should such unicode issues be handled in a more uniform way in Leo?  
#@-node:ekr.20040331152236:Fix unicode problem in config module
#@+node:ekr.20040403121321:Cutting and pasting created "invalid outline" messages
@nocolor

These did not harm the actual data.
#@nonl
#@-node:ekr.20040403121321:Cutting and pasting created "invalid outline" messages
#@+node:EKR.20040422091601.1:Syntax Colouring Bug - html mode
@nocolor

By: David McNab - davidmcnab
 Syntax Colouring Bug - html mode   
2004-04-22 07:38  

 Hi,

Within an HTML @file node, where I have '@language html' at the top root, I notice that on typing in a triple-double-quote ("""), the text following gets coloured green, as would be appropriate if the node were actually python.

Cheers
David
 
#@-node:EKR.20040422091601.1:Syntax Colouring Bug - html mode
#@+node:EKR.20040512081330.1:Misleading message in Import Derived File
@nocolor

By: Kent Tenney - ktenney
 'Import Derived File' error   
2004-05-06 13:38  

 Howdy,

In my Leo file is a node with the headline;
@file c:\cygwin\home\ktenney\work\ImageWords\ImageWords.py

When I start a new Leo file and choose; File->Import->Import Derived File

and open the file derived from the first Leo file, I get a node with the headline;
Imported @file C:/Python23/Lib/site-packages/leo/plugins/run_nodes.py

.. no body.

The message pane says;
imported C:/cygwin/home/ktenney/work/ImageWords/ImageWords.py
No absolute directory specified anywhere.

 
#@-node:EKR.20040512081330.1:Misleading message in Import Derived File
#@-node:ekr.20040323170225:General bugs
#@+node:EKR.20040422132037:Mac/Linux bugs
@nocolor
#@nonl
#@+node:EKR.20040422132037.2:Install Leo in the site-packages directory
#@-node:EKR.20040422132037.2:Install Leo in the site-packages directory
#@+node:EKR.20040422132037.3:small bug in install script
@nocolor

https://sourceforge.net/forum/message.php?msg_id=2370629
By: tyndal

I found a small bug in the leo install script.
It doesnt check to see that the $LEO_PREFIX/bin exists before trying to install
the "leo" script into it, giving an error.

you just need to make a small check similar to the one for the lib directory..
(i've included it below)

Thanks,
-Tyndal

#------------------------------
echo ""
echo Making directory structure $LEO_PREFIX/bin

RESULTS=`mkdir -p $LEO_PREFIX/bin 2>&1`
if [ $? -ne 0 ]; then
    echo Failure making directory $LEO_PREFIX/bin
    exit 0;
fi
#
#-----------------------------
#@-node:EKR.20040422132037.3:small bug in install script
#@+node:EKR.20040422132037.4:config problem on Linux
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2373816
By: sbeards

A related issue is that leoConfig.txt gets auto-tangled and overwritten on startup.
This will be a problem if Leo is run by a non-root user or the file is not readable.
For example, I get the following traceback after starting Leo (when leoConfig.txt
is read-only):

Traceback (most recent call last):
  File "/usr/local/share/leo-4.1-rc3/src/leoConfig.py", line 672, in update
    cf = open(self.configFileName,mode)
IOError: [Errno 13] Permission denied:
'/usr/local/share/leo-4.1-rc3/src/../config/leoConfig.txt'

Is there a reason leoConfig.txt gets auto-tangled on startup? Is there anyway
to disable this? Is this by design?
#@-node:EKR.20040422132037.4:config problem on Linux
#@+node:EKR.20040422132037.5:Backspace problems on Linux
Shift+Ctrl+BkSp doesn't delete node   
#@nonl
#@+node:EKR.20040422132037.6:Dave Hein: fix
By: dthein ( Dave Hein ) 
 RE: BUG: Shift+Ctrl+BkSp doesn't delete node   
2004-01-15 03:30  

 OK, the cause of the keymapping problem is a issue with the X11 keyboard mapping, not with Tk.

If you have this problem on your system, issue the command:

xmodmap -pke 

and look in the results for the line for keycode 22. I'll bet it shows something like:

keycode 22 = BackSpace Terminate_Server

That second token ("Terminate_Server") is what is supposed to be mapped to Shift-Backspace. You want this second token to be either not present or to be BackSpace.

To fix this, create a file (e.g. .Xmodmap) and give it the content:

keycode 22 = BackSpace

then run the command:

xmodmap .Xmodmap

And you'll have fixed the problem.

Now, on my system this also disables the ability to terminate the X server using Ctrl-Alt-BackSpace ... this is because of some conflict with xdb (xdb is the newer keyboard mapping facility in XFree86 ... xmodmap is the old original X11 keyboard mapping facility). I'm still working on that.

I'm also not able to get xmodmap to make this change during X11 startup (again because of conflicts with xdb). But I'm working on that as well.
#@nonl
#@-node:EKR.20040422132037.6:Dave Hein: fix
#@-node:EKR.20040422132037.5:Backspace problems on Linux
#@+node:EKR.20040422132037.7:Bug: vpython and mac
Jon Schull <jschull@softlock.com>  
Date:  2003/12/30 Tue PM 05:50:51 EST 
To:  edreamleo@charter.net 
Subject:  Leo, Mac OS X 10.3, and VPython 
             
I've been evaluating leo or vpython programming on  Mac OS X 10.3, and 
have some observations and a suggestion.

Observations.
		Leo runs under X11 as well as under OS X.
		My X11 python configuration was created using the recipe at XXX 
(which enables vpython).
		The OS X configuration is vanilla MacPython from MacPython.org, along 
with AquaTclTk batteries included XXX.
		In both environments I can run leo under python leo.py and under idle.
		Under OS X we get font smoothing, but we can't run visual python 
programs (python crashes;  this is a known incompatibility with 
MacPython.)
	
		Under X11 we can run visual python programs like this one
			#box.py
			from visual import *
			box()
			
    And we can even run them under leo (under X11). HOWEVER, when the 
visual python program is terminated, leo vanishes (leo and the vp 
program apparently run in the same space)
	
	Under x11, we can keep leo alive by putting the vp program in its own 
space:
	
		os.popen3('/sw/bin/python /Users/jis/box.py')
	
	However,  this doesn't let us see the output of stderr and stdout.  
Those text streams are available...
		
		def do(cmd='ls'):
			from os import popen3
			pIn,pOut,pErr=0,1,2
			popenResults=popen3(cmd)
			print popenResults[pOut].read()
			print popenResults[pErr].read()
		
		import os	
		do('/sw/bin/python /Users/jis/box.py')
		
	...but only when the vpython program terminates.
	
	Here's the good news:  if we execute our vp program with 
/sw/bin/idle.py rather than with python, we get to see the program 
output in real time (under idle, under X11).
	
		import os	
		os.chdir('/sw/lib/python2.3/idlelib')
		os.popen3('/sw/bin/python idle.py -r /Users/jis/box.py')
		
		#this runs as an executed script in leo, and produces a live idle 
with real time ongoing output.
	
	Now, while idle is running, leo sits in suspended animation.  But when 
the vpython program terminates, we are left in idle, and when idle is 
terminated, leo becomes active again.
	
	It would be even better if leo were not suspended (using os.spawn, 
perhaps) but the real point is that I would really really like leo's 
"Execute script" command to execute code this way and spare me having 
to  hard-write the path to box.py.  It ought to be possible to 
eliminate os.chdir as well.

------------------
Jon Schull, Ph.D.
Associate Professor
Information Technology
Rochester Institute of Technology
schull@digitalgoods.com 585-738-6696
#@-node:EKR.20040422132037.7:Bug: vpython and mac
#@+node:EKR.20040422132037.8:Mouse / Paste Anomalies
@nocolor

By: Bill Drissel - drissel
2004-04-13 19:43  

Xserver (XFree86 under Cygwin) on PC (W2000); controlling Linux Red Hat;
buncha windows up including one Leo window and many xterms and Xemacs.

A: means action, R: means result

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click
R: text shows in body pane; headline is not marked with blue square; text is not colorized; text is not saved to file

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click; locate mouse symbol in text
R: text shows in body pane; headline is not marked with blue square; text is not colorized; text is not saved to file

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click; up arrow to locate Ibeam in text
R: Joy! colorizes, marks headline and saves!

A: hilite headline text; type on KB
R: keystrokes replace hilited text

A: hilite text in Xemacs window; hilite headline; middle click
R: hilited text appended to headline rather than replacing

This last anomaly seems to persist regardless of how the headline is hilited and regardless of pasting method (middle click or Control-V)
#@nonl
#@-node:EKR.20040422132037.8:Mouse / Paste Anomalies
#@-node:EKR.20040422132037:Mac/Linux bugs
#@+node:ekr.20040411155746:Quick
#@+node:ekr.20040105080119.4:Put drawing hooks back in
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2342120
By: rodrigo_b

Today I was trying to clen some of the hooks of LeoN and I tried the
"draw-outline-text-box" that appears in the plugins documentation. But this
hook was not called when expected, in fact it was not called at all. I search
inside the code of 4.1rc1 and did not found any reference to it	

I would like to try to use "draw-outline-text-box" instead of overwriting the
tree.drawText method as I actually do.

Does this hook exist ? 
#@-node:ekr.20040105080119.4:Put drawing hooks back in
#@+node:ekr.20040206075634.1:Colorizing additions
#@+node:ekr.20031218072017.367:How to add support for a new language
@nocolor

- Add a new entries in << define global data structures >> app

- Add a new Tk.Radiobutton in <<create the Target Language frame>>

- Add an entry to the languages list in <<configure language-specific settings>>

- Add a list of the keywords of the language to << define colorizer keywords >>

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done in this step.

TESTS

- Test the syntax coloring for the new language by using the @language directive.

- Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

- Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

- Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the <preferences> tag (near the top) contains an entry like this:

<preferences allow_rich_text="0" defaultTargetLanguage="Python">
</preferences>

but with the name of your new language instead of "Python".

- Create an @root node and verify that you can Tangle it.

@color
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
	"actionscript" : "// /* */", #jason 2003-07-03
	"c" : "// /* */", # C, C++ or objective C.
	"csharp" : "// /* */",	# C#
	"css" : "/* */", # 4/1/04
	"cweb" : "@q@ @>", # Use the "cweb hack"
	"elisp" : ";",
	"forth" : "_\\_ _(_ _)_", # Use the "REM hack"
	"fortran" : "C",
	"fortran90" : "!",
	"html" : "<!-- -->",
	"java" : "// /* */",
	"latex" : "%",
	"pascal" : "// { }",
	"perl" : "#",
	"perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
	"php" : "//",
	"plain" : "#", # We must pick something.
	"python" : "#",
	"rapidq" : "'", # fil 2004-march-11
	"rebol" : ";",  # jason 2003-07-03
	"shell" : "#",  # shell scripts
	"tcltk" : "#",
	"unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
	"actionscript" : "as", #jason 2003-07-03
	"c" : "c",
	"css" : "css", # 4/1/04
	"cweb" : "w",
	"elisp" : "el",
	"forth" : "forth",
	"fortran" : "f",
	"fortran90" : "f",
	"html" : "html",
	"java" : "java",
	"latex" : "tex", # 1/8/04
	"noweb" : "nw",
	"pascal" : "p",
	"perl" : "perl",
	"perlpod" : "perl",
	"php" : "php",
	"plain" : "txt",
	"python" : "py",
	"rapidq" : "bas", # fil 2004-march-11
	"rebol" : "r",    # jason 2003-07-03
	"shell" : "sh",   # DS 4/1/04
	"tex" : "tex",
	"tcltk" : "tcl",
	"unknown" : "txt" } # Set when @comment is seen.
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@+node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
# Frame and title
w,target = gui.create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
	("ActionScript", "actionscript"),
	("C#",    "csharp"),
	("C/C++", "c"),
	("CSS",   "css"),
	("CWEB",  "cweb"),
	("elisp", "elisp"),
	("HTML",  "html"),
	("Java",  "java"),
	("LaTeX", "latex"),
	("Pascal","pascal")]

for text,value in left_data:
	button = Tk.Radiobutton(lt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x")

# Right column of radio buttons.
right_data = [
	("Perl", "perl"),
	("Perl+POD",   "perlpod"),
	("PHP",        "php"),
	("Plain Text", "plain"),
	("Python",     "python"),
	("RapidQ",     "rapidq"),
	("Rebol",      "rebol"),
	("Shell",      "shell"),
	("tcl/tk",     "tcltk")]

for text,value in right_data:
	button = Tk.Radiobutton(rt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x")
#@nonl
#@-node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
	delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
	delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
	delim1,delim2,delim3 = None,None,None
else:
	delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.has_string = self.language != "plain"
if self.language == "plain":
	self.string_delims = ()
elif self.language in ("elisp","html"):
	self.string_delims = ('"')
else:
	self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
	"actionscript","c","csharp","css","cweb","elisp","html","java","latex",
	"pascal","perl","perlpod","php","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
	for i in self.c_keywords:
		self.keywords.append(i)
	for i in self.cweb_keywords:
		self.keywords.append(i)
else:
	for name in languages:
		if self.language==name: 
			# g.trace("setting keywords for",name)
			self.keywords = getattr(self, name + "_keywords")

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
	self.lb = "<<"
	self.rb = ">>"
else:
	self.lb = g.choose(self.language == "cweb","@<","<<")
	self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords
#@nonl
#@+node:ekr.20031218072017.372:actionscript keywords
actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]
#@nonl
#@-node:ekr.20031218072017.372:actionscript keywords
#@+node:ekr.20040206072057:c# keywords
csharp_keywords = [
	"abstract","as",
	"base","bool","break","byte",
	"case","catch","char","checked","class","const","continue",
	"decimal","default","delegate","do","double",
	"else","enum","event","explicit","extern",
	"false","finally","fixed","float","for","foreach",
	"get","goto",
	"if","implicit","in","int","interface","internal","is",
	"lock","long",
	"namespace","new","null",
	"object","operator","out","override",
	"params","partial","private","protected","public",
	"readonly","ref","return",
	"sbyte","sealed","set","short","sizeof","stackalloc",
	"static","string","struct","switch",
	"this","throw","true","try","typeof",
	"uint","ulong","unchecked","unsafe","ushort","using",
	"value","virtual","void","volatile",
	"where","while",
	"yield"]
#@nonl
#@-node:ekr.20040206072057:c# keywords
#@+node:ekr.20031218072017.373:c/c++ keywords
c_keywords = [
	# C keywords
	"auto","break","case","char","continue",
	"default","do","double","else","enum","extern",
	"float","for","goto","if","int","long","register","return",
	"short","signed","sizeof","static","struct","switch",
	"typedef","union","unsigned","void","volatile","while",
	# C++ keywords
	"asm","bool","catch","class","const","const_cast",
	"delete","dynamic_cast","explicit","false","friend",
	"inline","mutable","namespace","new","operator",
	"private","protected","public","reinterpret_cast","static_cast",
	"template","this","throw","true","try",
	"typeid","typename","using","virtual","wchar_t"]
#@nonl
#@-node:ekr.20031218072017.373:c/c++ keywords
#@+node:ekr.20040401103539:css keywords
css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]
#@nonl
#@-node:ekr.20040401103539:css keywords
#@+node:ekr.20031218072017.374:elisp keywords
# EKR: needs more work.
elisp_keywords = [
	# Maybe...
	"error","princ",
	# More typical of other lisps...
	"apply","eval",
	"t","nil",
	"and","or","not",
	"cons","car","cdr",
	"cond",
	"defconst","defun","defvar",
	"eq","ne","equal","gt","ge","lt","le",
	"if",
	"let",
	"mapcar",
	"prog","progn",
	"set","setq",
	"type-of",
	"unless",
	"when","while"]
#@nonl
#@-node:ekr.20031218072017.374:elisp keywords
#@+node:ekr.20031218072017.375:html keywords
# No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
	unused_keywords = [
		# html constructs.
		"a","body","cf",
		"h1","h2","h3","h4","h5","h6",
		"head","html","hr",
		"i","img","li","lu","meta",
		"p","title","ul",
		# Common tags
		"caption","col","colgroup",
		"table","tbody","td","tfoot","th","thead","tr",
		"script","style"]

	html_specials = [ "<%","%>" ]
#@nonl
#@-node:ekr.20031218072017.375:html keywords
#@+node:ekr.20031218072017.376:java keywords
java_keywords = [
	"abstract","boolean","break","byte","byvalue",
	"case","cast","catch","char","class","const","continue",
	"default","do","double","else","extends",
	"false","final","finally","float","for","future",
	"generic","goto","if","implements","import","inner",
	"instanceof","int","interface","long","native",
	"new","null","operator","outer",
	"package","private","protected","public","rest","return",
	"short","static","super","switch","synchronized",
	"this","throw","transient","true","try",
	"var","void","volatile","while"]
#@nonl
#@-node:ekr.20031218072017.376:java keywords
#@+node:ekr.20031218072017.377:latex keywords
#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
	#special keyworlds
	"\\%", # 11/9/03
	"\\@", "\\(", "\\)", "\\{", "\\}",
	#A
	"\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
	"\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
	"\\appendix", 
	"\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
	#B
	"\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
	"\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
	"\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
	"\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
	#C
	"\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
	"\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
	"\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
	"\\cot", "\\coth",	"csc",
	#D
	"\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
	"\\deg", "\\Delta", 
	"\\delta", "\\depthits", "\\det", 
	"\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
	"\\documentclass", "\\documentstyle", 
	"\\dot", "\\dotfil", "\\downarrow",
	#E
	"\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
	"\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
	"\\eta", "\\example", "\\exists", "\\exp",
	#F
	"\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
	"\\footnotemark", "\\fotenotesize", 
	"\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
	"\\frontmatter",
	#G
	"\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
	"\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
	#H
	"\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
	"\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
	#I
	"\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
	"\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
	#J
	"\\jmath", "\\Join",
	#K
	"\\k", "\\kappa", "\\ker", "\\kill",
	#L
	"\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
	"\\LaTeX", "\\LaTeXe", 
	"\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
	"\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
	"\\linethickness", "\\linewidth",	"\\listfiles",
	"\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
	"\\Longrightarrow",	"longrightarrow",
	#M
	"\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
	"\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
	"\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
	"\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
	#N
	"\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
	"\\newenvironment", "\\newfont",
	"\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
	"\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
	"\\not", "\\nu", "nwarrow",
	#O
	"\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
	"\\overbrace", "\\overline",
	#P
	"\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
	"\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
	"\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
	"\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
	"\\providecomamnd", "\\Psi",	"\\psi", "\\put",
	#Q
	"\\qbezier", "\\quoteblbase", "\\quotesinglbase",
	#R
	"\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
	"\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
	"\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
	"\\Roman", "\\roman", "\\rule", 
	#S
	"\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
	"\\searrow",	"\\sec", "\\section",
	"\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
	"\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
	"\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
	"\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
	"\\sqsupset", "\\SS",
	"\\stackrel", "\\star", "\\subsection", "\\subset", 
	"\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
	#T
	"\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
	"\\tau", "\\telephone",	"\\TeX", "\\textbf",
	"\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
	"\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
	"\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
	"\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
	"\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
	"\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
	"\\Theta", "theta", 
	"\\tilde", "\\thinlines", 
	"\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
	"\\triangle", "\\tt", 
	"\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
	#U
	"\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
	"\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
	"\\usecounter", "\\usepackage", 
	#V
	"\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
	"\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
	"\\vline", "\\vphantom", "\\vspace",
	#W
	"\\widehat", "\\widetilde", "\\widthits", "\\wp",
	#X
	"\\Xi", "\\xi",
	#Z
	"\\zeta" ]
#@nonl
#@-node:ekr.20031218072017.377:latex keywords
#@+node:ekr.20031218072017.378:pascal keywords
pascal_keywords = [
	"and","array","as","begin",
	"case","const","class","constructor","cdecl"
	"div","do","downto","destructor","dispid","dynamic",
	"else","end","except","external",
	"false","file","for","forward","function","finally",
	"goto","if","in","is","label","library",
	"mod","message","nil","not","nodefault""of","or","on",
	"procedure","program","packed","pascal",
	"private","protected","public","published",
	"record","repeat","raise","read","register",
	"set","string","shl","shr","stdcall",
	"then","to","true","type","try","until","unit","uses",
	"var","virtual","while","with","xor"
	# object pascal
	"asm","absolute","abstract","assembler","at","automated",
	"finalization",
	"implementation","inherited","initialization","inline","interface",
	"object","override","resident","resourcestring",
	"threadvar",
	# limited contexts
	"exports","property","default","write","stored","index","name" ]
#@nonl
#@-node:ekr.20031218072017.378:pascal keywords
#@+node:ekr.20031218072017.379:perl keywords
perl_keywords = [
	"continue","do","else","elsif","format","for","format","for","foreach",
	"if","local","package","sub","tr","unless","until","while","y",
	# Comparison operators
	"cmp","eq","ge","gt","le","lt","ne",
	# Matching ooperators
	"m","s",
	# Unary functions
	"alarm","caller","chdir","cos","chroot","exit","eval","exp",
	"getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
	"hex","int","length","localtime","log","ord","oct",
	"require","reset","rand","rmdir","readlink",
	"scalar","sin","sleep","sqrt","srand","umask",
	# Transfer ops
	"next","last","redo","go","dump",
	# File operations...
	"select","open",
	# FL ops
	"binmode","close","closedir","eof",
	"fileno","getc","getpeername","getsockname","lstat",
	"readdir","rewinddir","stat","tell","telldir","write",
	# FL2 ops
	"bind","connect","flock","listen","opendir",
	"seekdir","shutdown","truncate",
	# FL32 ops
	"accept","pipe",
	# FL3 ops
	"fcntl","getsockopt","ioctl","read",
	"seek","send","sysread","syswrite",
	# FL4 & FL5 ops
	"recv","setsocket","socket","socketpair",
	# Array operations
	"pop","shift","split","delete",
	# FLIST ops
	"sprintf","grep","join","pack",
	# LVAL ops
	"chop","defined","study","undef",
	# f0 ops
	"endhostent","endnetent","endservent","endprotoent",
	"endpwent","endgrent","fork",
	"getgrent","gethostent","getlogin","getnetent","getppid",
	"getprotoent","getpwent","getservent",
	"setgrent","setpwent","time","times","wait","wantarray",
	# f1 ops
	"getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
	"sethostent","setnetent","setprotoent","setservent",
	# f2 ops
	"atan2","crypt",
	"gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
	"index","link","mkdir","msgget","rename",
	"semop","setpgrp","symlink","unpack","waitpid",
	# f2 or 3 ops
	"index","rindex","substr",
	# f3 ops
	"msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
	# f4 & f5 ops
	"semctl","shmread","shmwrite","msgrcv",
	# Assoc ops
	"dbmclose","each","keys","values",
	# List ops
	"chmod","chown","die","exec","kill",
	"print","printf","return","reverse",
	"sort","system","syscall","unlink","utime","warn"]
#@nonl
#@-node:ekr.20031218072017.379:perl keywords
#@+node:ekr.20031218072017.380:php keywords
php_keywords = [ # 08-SEP-2002 DTHEIN
	"__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
	"and", "as", "break",
	"case", "cfunction", "class", "const", "continue",
	"declare", "default", "do",
	"else", "elseif", "enddeclare", "endfor", "endforeach",
	"endif", "endswitch",  "endwhile", "eval", "extends",
	"for", "foreach", "function", "global", "if",
	"new", "old_function", "or", "static", "switch",
	"use", "var", "while", "xor" ]
	
# The following are supposed to be followed by ()
php_paren_keywords = [
	"array", "die", "echo", "empty", "exit",
	"include", "include_once", "isset", "list",
	"print", "require", "require_once", "return",
	"unset" ]
	
# The following are handled by special case code:
# "<?php", "?>"
#@-node:ekr.20031218072017.380:php keywords
#@+node:ekr.20031218072017.381:python keywords
python_keywords = [
	"and",       "del",       "for",       "is",        "raise",    
	"assert",    "elif",      "from",      "lambda",    "return",   
	"break",     "else",      "global",    "not",       "try",      
	"class",     "except",    "if",        "or",        "yield",   
	"continue",  "exec",      "import",    "pass",      "while",
	"def",       "finally",   "in",        "print"]
#@nonl
#@-node:ekr.20031218072017.381:python keywords
#@+node:ekr.20040331145826:rapidq keywords
rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]
#@nonl
#@-node:ekr.20040331145826:rapidq keywords
#@+node:ekr.20031218072017.382:rebol keywords
rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]
#@nonl
#@-node:ekr.20031218072017.382:rebol keywords
#@+node:ekr.20040401111125:shell keywords
shell_keywords = [
	# reserved keywords
	"case","do","done","elif","else","esac","fi",
	"for","if","in","then",
	"until","while",
	"break","cd","chdir","continue","eval","exec",
	"exit","kill","newgrp","pwd","read","readonly",
	"return","shift","test","trap","ulimit",
	"umask","wait" ]
#@nonl
#@-node:ekr.20040401111125:shell keywords
#@+node:ekr.20031218072017.383:tcl/tk keywords
tcltk_keywords = [ # Only the tcl keywords are here.
	"after",     "append",    "array",
	"bgerror",   "binary",    "break",
	"catch",     "cd",        "clock",
	"close",     "concat",    "continue",
	"dde",
	"encoding",  "eof",       "eval",
	"exec",      "exit",      "expr",
	"fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
	"filename",  "flush",     "for",       "foreach",   "format",
	"gets",      "glob",      "global",
	"history",
	"if",        "incr",      "info",      "interp",
	"join",
	"lappend",   "lindex",    "linsert",   "list",      "llength",
	"load",      "lrange",    "lreplace",  "lsearch",   "lsort",
	"memory",    "msgcat",
	"namespace",
	"open",
	"package",   "parray",    "pid",
	"proc",      "puts",      "pwd",
	"read",      "regexp",    "registry",   "regsub",
	"rename",    "resource",  "return",
	"scan",      "seek",      "set",        "socket",   "source",
	"split",     "string",    "subst",      "switch",
	"tell",      "time",      "trace",
	"unknown",   "unset",     "update",     "uplevel",   "upvar",
	"variable",  "vwait",
	"while" ]
#@nonl
#@-node:ekr.20031218072017.383:tcl/tk keywords
#@-node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
#@-node:ekr.20031218072017.367:How to add support for a new language
#@+node:ekr.20040331145826.1:(done) RapidQ support
#@+node:ekr.20040331145826:rapidq keywords
rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]
#@nonl
#@-node:ekr.20040331145826:rapidq keywords
#@-node:ekr.20040331145826.1:(done) RapidQ support
#@+node:ekr.20040117111755:(done) css support
#@+node:ekr.20040401104931:Notes
@nocolor

By: grayrest ( Karl Guertin ) 
 diff: css support   
2004-01-09 23:42  

 I got frustrated at leo's lack of support for CSS. The main difficulty I was having is that CSS only specifies the /* and */ comment delimiters and not any single line delimeter. Trying the depricated @comment /* */ doesn't work because it produces the output

/* @@comment /* */ */

which fails because the first */ on the line ends the comment, leaving the second */ as a syntax error in the file.

Anyway, while looking into it I figured I'd just add CSS as a supported language. It took longer than expected (there are a LOT of keywords in css) but the only hangup was that css keywords include dashes (e.g. margin-top). Diff against 4.1RC3 release is below.


In case it gets mangled, the diff can also be found at http://r39h92.res.gatech.edu:8788/leon_files/css.diff
#@nonl
#@-node:ekr.20040401104931:Notes
#@+node:ekr.20040401103539:css keywords
css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]
#@nonl
#@-node:ekr.20040401103539:css keywords
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
	<< handle possible latex keyword >>
elif self.language == "html":
	<< handle possible html keyword >>
else:
	<< handle general keyword >>
i = j
#@nonl
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
	j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03
	word = s[i:j]
	if word in self.latex_keywords:
		self.tag("latexKeyword",i,j)
	else:
		self.tag("latexBackground",i,j)
else:
	self.tag("latexBackground",i,i+1)
	j = i + 1 # skip the character.
#@nonl
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
	if g.match(s,i,"<!---"): k = 5
	else: k = 4
	self.tag("comment",i,i+k)
	j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
	if g.match(s,i,"</"): k = 2
	else: k = 1
	j = self.skip_id(s,i+k)
	self.tag("keyword",i,j)
elif g.match(s,i,"&"):
	j = self.skip_id(s,i+1,';')
	self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
	j = i + 2
	self.tag("keyword",i,j)
elif g.match(s,i,">"):
	j = i + 1
	self.tag("keyword",i,j)
else:
	j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
	j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
	j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
	j = self.skip_id(s,i+1,chars="-")
else:
	j = self.skip_id(s,i)

word = s[i:j]
if word in self.keywords:
	self.tag("keyword",i,j)
elif self.language == "php":
	if word in self.php_paren_keywords and g.match(s,j,"()"):
		self.tag("keyword",i,j+2)
		j += 2
#@nonl
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@-node:ekr.20040117111755:(done) css support
#@+node:ekr.20040117113539.1:(done) Coloring for Shell Scripts (Davide)
#@+node:ekr.20040401111308:Notes
@nocolor

I recently wrote a few shell scripts (on linux) with leo, and I noticed
there was no colorizer support for shell (apart from comments), so I added
it: see the attached leo file. Note that this only adds colorizer support
for vanilla /bin/sh keywords -- one could customize it to add support for
all the different shell flavors out there (bash, ksh, etc), although I
think this is better left out for when we have a more flexible way of
specifying language grammars. Note that I changed the default extension
type for shell scripts from "txt" to "sh" (much more common for shell
scripts, I think).

In addition to what's specified in "How to add support for a new language"
(in LeoPy.leo), I also had to modify the << handle single-line comment >>
block in colorizer.doNormalState to avoid that the built-in shell variable
'$#' starts a single-line comment.

As usual, feel free to modify at will.

Last thing: if I try to "Import to @file" a file with no extension, it
fails saying "<filename>.py does not exist" (where <filename> is the file I
want to load), i.e. Leo always tries to add a ".py" extension to files to
be imported if they don't have one. This is with Leo 4.1rc3 CVS version,
Python 2.3.2 on Linux.
#@nonl
#@-node:ekr.20040401111308:Notes
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
	j = i + len(self.single_comment_start)
	self.tag("comment",i,j)
	self.doLatexLine(s,j,len(s))
	i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
	i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
	j = len(s)
	if not g.doHook("color-optional-markup",
		colorer=self,v=self.p,s=s,i=i,j=j,colortag="comment"):
		self.tag("comment",i,j)
	i = j
#@nonl
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@-node:ekr.20040117113539.1:(done) Coloring for Shell Scripts (Davide)
#@+node:ekr.20040106145421:(not yet) PHP syntax coloring
#@+node:ekr.20040401110507:Notes
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2361052
By: sbeards

It would be nice if [doNormalState] could also catch the following all of which should be valid when the language is PHP.

<?_    (Note: replace the '_' with whitespace)
<?=
<?[pP][hH][pP] (Note: regex/mixed case is OK)

Can't we use the following regex to catch these cases?

"<?(\s|=|[pP][hH][pP])"

Scott

EKR: This doesn't seem to work.  I did add code so that all cases of PHP get recoginized.
#@nonl
#@-node:ekr.20040401110507:Notes
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
	self.tag("keyword",i,i+5)
	i += 5
elif g.match(s,i,"?>"):
	self.tag("keyword",i,i+2)
	i += 2
else:
	i += 1

#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1896:doNormalState
## To do: rewrite using dynamically generated tables.

def doNormalState (self,s,i):

	ch = s[i] ; state = "normal"
	assert(type(ch)==type(u""))

	if ch in string.ascii_letters or ch == '_' or (
		(ch == '\\' and self.language=="latex") or
		(ch in '/&<>' and self.language=="html") or
		(ch == '$' and self.language=="rapidq")
	):
		<< handle possible keyword >>
	elif g.match(s,i,self.lb):
		i = self.doNowebSecRef(s,i)
	elif ch == '@':
		<< handle at keyword >>
	elif g.match(s,i,self.single_comment_start):
		<< handle single-line comment >>
	elif g.match(s,i,self.block_comment_start):
		<< start block comment >>
	elif ch == '%' and self.language=="cweb":
		<< handle latex line >>
	elif self.language=="latex":
		<< handle latex normal character >>
	# ---- From here on self.language != "latex" -----
	elif ch in self.string_delims:
		<< handle string >>
	elif ch == '#' and self.has_pp_directives:
		<< handle C preprocessor line >>
	elif self.language == "php" and (g.match(s,i,"<") or g.match(s,i,"?")):
		# g.trace("%3d" % i,php_re.match(s,i),s)
		<< handle special php keywords >>
	elif ch == ' ':
		<< handle blank >>
	elif ch == '\t':
		<< handle tab >>
	else:
		<< handle normal character >>

	if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
		g.trace(self.progress,i,state)
		assert(self.progress < i)
	return i,state


#@+node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
	<< handle possible latex keyword >>
elif self.language == "html":
	<< handle possible html keyword >>
else:
	<< handle general keyword >>
i = j
#@nonl
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
	j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03
	word = s[i:j]
	if word in self.latex_keywords:
		self.tag("latexKeyword",i,j)
	else:
		self.tag("latexBackground",i,j)
else:
	self.tag("latexBackground",i,i+1)
	j = i + 1 # skip the character.
#@nonl
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
	if g.match(s,i,"<!---"): k = 5
	else: k = 4
	self.tag("comment",i,i+k)
	j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
	if g.match(s,i,"</"): k = 2
	else: k = 1
	j = self.skip_id(s,i+k)
	self.tag("keyword",i,j)
elif g.match(s,i,"&"):
	j = self.skip_id(s,i+1,';')
	self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
	j = i + 2
	self.tag("keyword",i,j)
elif g.match(s,i,">"):
	j = i + 1
	self.tag("keyword",i,j)
else:
	j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
	j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
	j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
	j = self.skip_id(s,i+1,chars="-")
else:
	j = self.skip_id(s,i)

word = s[i:j]
if word in self.keywords:
	self.tag("keyword",i,j)
elif self.language == "php":
	if word in self.php_paren_keywords and g.match(s,j,"()"):
		self.tag("keyword",i,j+2)
		j += 2
#@nonl
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@+node:ekr.20031218072017.1902:<< handle at keyword >>
if self.language == "cweb":
	if g.match(s,i,"@(") or g.match(s,i,"@<"):
		<< handle cweb ref or def >>
	else:
		word = self.getCwebWord(s,i)
		if word:
			<< Handle cweb control word >>
		else:
			i,state = self.doAtKeyword(s,i)
else:
	i,state = self.doAtKeyword(s,i)
#@nonl
#@+node:ekr.20031218072017.1903:<< Handle cweb control word >>
# Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
	state = "doc"
elif word in ("@<","@(","@c","@d","@f","@p"):
	state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@>"
	j = s.find("@>",i)
	if j > -1:
		self.tag("cwebName",i,j)
		self.tag("nameBrackets",j,j+2)
		i = j + 2
#@nonl
#@-node:ekr.20031218072017.1903:<< Handle cweb control word >>
#@+node:ekr.20031218072017.1904:<< handle cweb ref or def >>
self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@>=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
	j = s.find("@>",i+2)

if j == -1:
	i += 2
else:
	self.tag("cwebName",i+2,j)
	self.tag("nameBrackets",j,j+k)
	i = j + k
#@-node:ekr.20031218072017.1904:<< handle cweb ref or def >>
#@-node:ekr.20031218072017.1902:<< handle at keyword >>
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
	j = i + len(self.single_comment_start)
	self.tag("comment",i,j)
	self.doLatexLine(s,j,len(s))
	i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
	i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
	j = len(s)
	if not g.doHook("color-optional-markup",
		colorer=self,v=self.p,s=s,i=i,j=j,colortag="comment"):
		self.tag("comment",i,j)
	i = j
#@nonl
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@+node:ekr.20031218072017.1619:<< start block comment >>
k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
	colorer=self,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
	self.tag("comment",i,i+k)

i += k ; state = "blockComment"
#@nonl
#@-node:ekr.20031218072017.1619:<< start block comment >>
#@+node:ekr.20031218072017.1905:<< handle latex line >>
self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
#@nonl
#@-node:ekr.20031218072017.1905:<< handle latex line >>
#@-node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1907:<< handle latex normal character >>
if self.language=="cweb":
	self.tag("latexModeBackground",i,i+1)
else:
	self.tag("latexBackground",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1907:<< handle latex normal character >>
#@-node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1908:Valid when not in latex_mode
#@+node:ekr.20031218072017.1612:<< handle string >>
if self.language == "python":

	delim = s[i:i+3]
	j, state = self.skip_python_string(s,i)
	if delim == '"""':
		# Only handle wiki items in """ strings.
		if not g.doHook("color-optional-markup",
			colorer=self,v=self.p,s=s,i=i,j=j,colortag="string"):
			self.tag("string",i,j)
	else:
		self.tag("string",i,j)
	i = j

else:
	j, state = self.skip_string(s,i)
	self.tag("string",i,j)
	i = j
#@-node:ekr.20031218072017.1612:<< handle string >>
#@+node:ekr.20031218072017.1909:<< handle C preprocessor line >>
# 10/17/02: recognize comments in preprocessor lines.
j = i
while i < len(s):
	if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
		break
	else: i += 1

self.tag("pp",j,i)
#@nonl
#@-node:ekr.20031218072017.1909:<< handle C preprocessor line >>
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
	self.tag("keyword",i,i+5)
	i += 5
elif g.match(s,i,"?>"):
	self.tag("keyword",i,i+2)
	i += 2
else:
	i += 1

#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1911:<< handle blank >>
if self.showInvisibles:
	self.tag("blank",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1911:<< handle blank >>
#@+node:ekr.20031218072017.1912:<< handle tab >>
if self.showInvisibles:
	self.tag("tab",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1912:<< handle tab >>
#@+node:ekr.20031218072017.1913:<< handle normal character >>
# self.tag("normal",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1913:<< handle normal character >>
#@-node:ekr.20031218072017.1908:Valid when not in latex_mode
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
	<< handle possible latex keyword >>
elif self.language == "html":
	<< handle possible html keyword >>
else:
	<< handle general keyword >>
i = j
#@nonl
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
	j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03
	word = s[i:j]
	if word in self.latex_keywords:
		self.tag("latexKeyword",i,j)
	else:
		self.tag("latexBackground",i,j)
else:
	self.tag("latexBackground",i,i+1)
	j = i + 1 # skip the character.
#@nonl
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
	if g.match(s,i,"<!---"): k = 5
	else: k = 4
	self.tag("comment",i,i+k)
	j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
	if g.match(s,i,"</"): k = 2
	else: k = 1
	j = self.skip_id(s,i+k)
	self.tag("keyword",i,j)
elif g.match(s,i,"&"):
	j = self.skip_id(s,i+1,';')
	self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
	j = i + 2
	self.tag("keyword",i,j)
elif g.match(s,i,">"):
	j = i + 1
	self.tag("keyword",i,j)
else:
	j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
	j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
	j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
	j = self.skip_id(s,i+1,chars="-")
else:
	j = self.skip_id(s,i)

word = s[i:j]
if word in self.keywords:
	self.tag("keyword",i,j)
elif self.language == "php":
	if word in self.php_paren_keywords and g.match(s,j,"()"):
		self.tag("keyword",i,j+2)
		j += 2
#@nonl
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@+node:ekr.20031218072017.1902:<< handle at keyword >>
if self.language == "cweb":
	if g.match(s,i,"@(") or g.match(s,i,"@<"):
		<< handle cweb ref or def >>
	else:
		word = self.getCwebWord(s,i)
		if word:
			<< Handle cweb control word >>
		else:
			i,state = self.doAtKeyword(s,i)
else:
	i,state = self.doAtKeyword(s,i)
#@nonl
#@+node:ekr.20031218072017.1903:<< Handle cweb control word >>
# Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
	state = "doc"
elif word in ("@<","@(","@c","@d","@f","@p"):
	state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@>"
	j = s.find("@>",i)
	if j > -1:
		self.tag("cwebName",i,j)
		self.tag("nameBrackets",j,j+2)
		i = j + 2
#@nonl
#@-node:ekr.20031218072017.1903:<< Handle cweb control word >>
#@+node:ekr.20031218072017.1904:<< handle cweb ref or def >>
self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@>=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
	j = s.find("@>",i+2)

if j == -1:
	i += 2
else:
	self.tag("cwebName",i+2,j)
	self.tag("nameBrackets",j,j+k)
	i = j + k
#@-node:ekr.20031218072017.1904:<< handle cweb ref or def >>
#@-node:ekr.20031218072017.1902:<< handle at keyword >>
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
	j = i + len(self.single_comment_start)
	self.tag("comment",i,j)
	self.doLatexLine(s,j,len(s))
	i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
	i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
	j = len(s)
	if not g.doHook("color-optional-markup",
		colorer=self,v=self.p,s=s,i=i,j=j,colortag="comment"):
		self.tag("comment",i,j)
	i = j
#@nonl
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@+node:ekr.20031218072017.1619:<< start block comment >>
k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
	colorer=self,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
	self.tag("comment",i,i+k)

i += k ; state = "blockComment"
#@nonl
#@-node:ekr.20031218072017.1619:<< start block comment >>
#@+node:ekr.20031218072017.1905:<< handle latex line >>
self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
#@nonl
#@-node:ekr.20031218072017.1905:<< handle latex line >>
#@+node:ekr.20031218072017.1907:<< handle latex normal character >>
if self.language=="cweb":
	self.tag("latexModeBackground",i,i+1)
else:
	self.tag("latexBackground",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1907:<< handle latex normal character >>
#@+node:ekr.20031218072017.1612:<< handle string >>
if self.language == "python":

	delim = s[i:i+3]
	j, state = self.skip_python_string(s,i)
	if delim == '"""':
		# Only handle wiki items in """ strings.
		if not g.doHook("color-optional-markup",
			colorer=self,v=self.p,s=s,i=i,j=j,colortag="string"):
			self.tag("string",i,j)
	else:
		self.tag("string",i,j)
	i = j

else:
	j, state = self.skip_string(s,i)
	self.tag("string",i,j)
	i = j
#@-node:ekr.20031218072017.1612:<< handle string >>
#@+node:ekr.20031218072017.1909:<< handle C preprocessor line >>
# 10/17/02: recognize comments in preprocessor lines.
j = i
while i < len(s):
	if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
		break
	else: i += 1

self.tag("pp",j,i)
#@nonl
#@-node:ekr.20031218072017.1909:<< handle C preprocessor line >>
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
	self.tag("keyword",i,i+5)
	i += 5
elif g.match(s,i,"?>"):
	self.tag("keyword",i,i+2)
	i += 2
else:
	i += 1

#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1911:<< handle blank >>
if self.showInvisibles:
	self.tag("blank",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1911:<< handle blank >>
#@+node:ekr.20031218072017.1912:<< handle tab >>
if self.showInvisibles:
	self.tag("tab",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1912:<< handle tab >>
#@+node:ekr.20031218072017.1913:<< handle normal character >>
# self.tag("normal",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1913:<< handle normal character >>
#@-node:ekr.20031218072017.1896:doNormalState
#@-node:ekr.20040106145421:(not yet) PHP syntax coloring
#@+node:ekr.20031218072017.3195:splitLines & joinLines
def splitLines (s):
	
	"""Split s into lines, preserving the number of lines and the ending of the last line."""
	
	if s:
		return s.splitlines(true) # This is a Python string function!
	else:
		return []

	if 0:# Rewritten: 4/2/04.  This works, but why bother?
		if s:
			lines = s.split('\n')
			result = [line + '\n' for line in lines[:-1]]
			if s[-1] != '\n':
				result.append(lines[-1])
			return result
		else:
			return []

def joinLines (aList):
	
	return ''.join(aList)
#@nonl
#@-node:ekr.20031218072017.3195:splitLines & joinLines
#@-node:ekr.20040206075634.1:Colorizing additions
#@+node:ekr.20040317050439:Right-click to add user-specified attributes and icons
Also add corresponding commands.
#@nonl
#@-node:ekr.20040317050439:Right-click to add user-specified attributes and icons
#@+node:EKR.20040424151321:(Status line experiments) TO DO: create status line class
#@+node:ekr.20031218072017.3941: frame.Birth & Death
#@+node:ekr.20031218072017.1801:f.__init__
def __init__(self,title):

	# Init the base class.
	leoFrame.leoFrame.__init__(self)

	self.title = title
	leoTkinterFrame.instances += 1
	self.c = None # Set in finishCreate.

	<< set the leoTkinterFrame ivars >>
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# Created in createLeoFrame and its allies.
self.top = None
self.tree = None
self.f1 = self.f2 = None
self.log = None  ; self.logBar = None
self.body = None ; self.bodyCtrl = None ; self.bodyBar = None ; self.bodyXBar = None
self.canvas = None ; self.treeBar = None
self.splitter1 = self.splitter2 = None
self.icon = None
self.outerFrame = None # 5/20/02
self.iconFrame = None # 5/20/02
self.statusFrame = None # 5/20/02
self.statusText = None # 5/20/02
self.statusLabel = None # 5/20/02

# Used by event handlers...
self.redrawCount = 0
self.draggedItem = None
self.controlKeyIsDown = false # For control-drags
self.revertHeadline = None # Previous headline text for abortEditLabel.
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:f.__init__
#@+node:ekr.20031218072017.3942:f.__repr__
def __repr__ (self):

	return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:f.__repr__
#@+node:ekr.20031218072017.3943:Creating the frame
#@+node:ekr.20031218072017.3944:f.createCanvas
def createCanvas (self,parentFrame):
	
	frame = self ; config = g.app.config ; Tk = Tkinter
	
	scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
	scrolls = g.choose(scrolls,1,0)

	canvas = Tk.Canvas(parentFrame,name="canvas",
		bd=0,bg="white",relief="flat")

	frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
	
	# Bind mouse wheel event to canvas
	if sys.platform != "win32": # Works on 98, crashes on XP.
		canvas.bind("<MouseWheel>", self.OnMouseWheel)
		
	canvas['yscrollcommand'] = self.setCallback
	treeBar['command']     = self.yviewCallback
	
	treeBar.pack(side="right", fill="y")
	if scrolls: 
		treeXBar = Tk.Scrollbar( 
			parentFrame,name='treeXBar',orient="horizontal") 
		canvas['xscrollcommand'] = treeXBar.set 
		treeXBar['command'] = canvas.xview 
		treeXBar.pack(side="bottom", fill="x")
	
	canvas.pack(expand=1,fill="both")

	canvas.bind("<Button-1>", frame.OnActivateTree)

	# Handle mouse wheel in the outline pane.
	if sys.platform == "linux2": # This crashes tcl83.dll
		canvas.bind("<MouseWheel>", frame.OnMouseWheel)
	
	# g.print_bindings("canvas",canvas)
	return canvas
#@nonl
#@-node:ekr.20031218072017.3944:f.createCanvas
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
	
	frame = self ; frame.c = c
	Tk = Tkinter ; gui = g.app.gui

	<< create the toplevel frame >>
	<< create all the subframes >>
	<< create the first tree node >>

	self.menu = leoTkinterMenu.leoTkinterMenu(frame)

	v = c.currentVnode()

	if not g.doHook("menu1",c=c,v=v):
		frame.menu.createMenuBar(self)

	g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log

	g.app.windowList.append(frame)
	
	c.initVersion()
	c.signOnWithVersion()
	
	self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel frame >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

frame.top.bind("<Activate>", frame.OnActivateLeoEvent) # Doesn't work on windows.
frame.top.bind("<Deactivate>", frame.OnDeactivateLeoEvent) # Doesn't work on windows.

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel frame >>
#@+node:ekr.20031218072017.2178:<< create all the subframes >>
# Create the outer frame.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")

self.createIconBar()
<< create both splitters >>

# Create the canvas, tree, log and body.
frame.canvas   = self.createCanvas(self.split2Pane1)
frame.tree     = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log      = leoTkinterLog(frame,self.split2Pane2)
frame.body     = leoTkinterBody(frame,self.split1Pane2)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.  N.B. There may be Tk bugs here that make the order significant!
frame.setTabWidth(c.tab_width)
frame.tree.setTreeColorsFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()

if 0: # No longer done automatically.

	# Create the status line.
	self.createStatusLine()
	self.putStatusLine("Welcome to Leo")
#@nonl
#@+node:ekr.20031218072017.2179:<< create both splitters >>
# Splitter 1 is the main splitter containing splitter2 and the body pane.
f1,bar1,split1Pane1,split1Pane2 = self.createLeoSplitter(outerFrame, self.splitVerticalFlag)
self.f1,self.bar1 = f1,bar1
self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

# Splitter 2 is the secondary splitter containing the tree and log panes.
f2,bar2,split2Pane1,split2Pane2 = self.createLeoSplitter(split1Pane1, not self.splitVerticalFlag)
self.f2,self.bar2 = f2,bar2
self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@-node:ekr.20031218072017.2179:<< create both splitters >>
#@-node:ekr.20031218072017.2178:<< create all the subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(false)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3945:Creating the splitter
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,secondary_ratio):

	self.divideLeoSplitter(self.splitVerticalFlag, ratio)
	self.divideLeoSplitter(not self.splitVerticalFlag, secondary_ratio)
	# g.trace(ratio)
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):
	
	if verticalFlag == self.splitVerticalFlag:
		bar.bind("<B1-Motion>", self.onDragMainSplitBar)

	else:
		bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3948:createLeoSplitter
# 5/20/03: Removed the ancient kludge for forcing the height & width of f.
# The code in leoFileCommands.getGlobals now works!

def createLeoSplitter (self, parent, verticalFlag):
	
	"""Create a splitter window and panes into which the caller packs widgets.
	
	Returns (f, bar, pane1, pane2) """

	Tk = Tkinter
	
	# Create the frames.
	f = Tk.Frame(parent,bd=0,relief="flat")
	f.pack(expand=1,fill="both",pady=1)
	pane1 = Tk.Frame(f)
	pane2 = Tk.Frame(f)
	bar =   Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

	# Configure and place the frames.
	self.configureBar(bar,verticalFlag)
	self.bindBar(bar,verticalFlag)
	self.placeSplitter(bar,pane1,pane2,verticalFlag)

	return f, bar, pane1, pane2
#@nonl
#@-node:ekr.20031218072017.3948:createLeoSplitter
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		bar.place(rely=frac)
		pane1.place(relheight=frac)
		pane2.place(relheight=1-frac)
	else:
		# Panes arranged horizontally; vertical splitter bar
		bar.place(relx=frac)
		pane1.place(relwidth=frac)
		pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
	if self.splitVerticalFlag == verticalFlag:
		self.divideLeoSplitter1(frac,verticalFlag)
		self.ratio = frac # Ratio of body pane to tree pane.
	else:
		self.divideLeoSplitter2(frac,verticalFlag)
		self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
	self.divideAnySplitter(frac, verticalFlag,
		self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
	self.divideAnySplitter (frac, verticalFlag,
		self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
	self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
	self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

	# x and y are the coordinates of the cursor relative to the bar, not the main window.
	bar = event.widget
	x = event.x
	y = event.y
	top = bar.winfo_toplevel()

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		wRoot	= top.winfo_rooty()
		barRoot = bar.winfo_rooty()
		wMax	= top.winfo_height()
		offset = float(barRoot) + y - wRoot
	else:
		# Panes arranged horizontally; vertical splitter bar
		wRoot	= top.winfo_rootx()
		barRoot = bar.winfo_rootx()
		wMax	= top.winfo_width()
		offset = float(barRoot) + x - wRoot

	# Adjust the pixels, not the frac.
	if offset < 3: offset = 3
	if offset > wMax - 2: offset = wMax - 2
	# Redraw the splitter as the drag is occuring.
	frac = float(offset) / wMax
	# g.trace(frac)
	self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
		pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
		bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
	else:
		# Panes arranged horizontally; vertical splitter bar
		# adj gives tree pane more room when tiling vertically.
		adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
		pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
		pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
		bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@-node:ekr.20031218072017.3945:Creating the splitter
#@+node:ekr.20031218072017.3953:Creating the icon area
#@+node:ekr.20031218072017.3954:createIconBar
def createIconBar (self):
	
	"""Create an empty icon bar in the packer's present position"""

	if not self.iconFrame:
		self.iconFrame = Tk.Frame(self.outerFrame,height="5m",bd=2,relief="groove")
		self.iconFrame.pack(fill="x",pady=2)
#@nonl
#@-node:ekr.20031218072017.3954:createIconBar
#@+node:ekr.20031218072017.3955:hideIconBar
def hideIconBar (self):
	
	"""Hide the icon bar by unpacking it.
	
	A later call to showIconBar will repack it in a new location."""
	
	if self.iconFrame:
		self.iconFrame.pack_forget()
#@-node:ekr.20031218072017.3955:hideIconBar
#@+node:ekr.20031218072017.3956:clearIconBar
def clearIconBar(self):
	
	"""Destroy all the widgets in the icon bar"""
	
	f = self.iconFrame
	if not f: return
	
	for slave in f.pack_slaves():
		slave.destroy()

	f.configure(height="5m") # The default height.
	g.app.iconWidgetCount = 0
	g.app.iconImageRefs = []
#@-node:ekr.20031218072017.3956:clearIconBar
#@+node:ekr.20031218072017.3957:showIconBar
def showIconBar(self):
	
	"""Show the icon bar by repacking it"""

	self.iconFrame.pack(fill="x",pady=2)
#@nonl
#@-node:ekr.20031218072017.3957:showIconBar
#@+node:ekr.20031218072017.3958:addIconButton
def addIconButton(self,text=None,imagefile=None,image=None,command=None,bg=None):
	
	"""Add a button containing text or a picture to the icon bar.
	
	Pictures take precedence over text"""
	
	f = self.iconFrame
	if not imagefile and not image and not text: return

	# First define n.	
	try:
		g.app.iconWidgetCount += 1
		n = g.app.iconWidgetCount
	except:
		n = g.app.iconWidgetCount = 1

	if not command:
		def command(n=n):
			print "command for widget %s" % (n)

	if imagefile or image:
		<< create a picture >>
	elif text:
		w = min(6,len(text))
		b = Tk.Button(f,text=text,width=w,relief="groove",bd=2,command=command)
		b.pack(side="left", fill="y")
		return b
		
	return None
#@nonl
#@+node:ekr.20031218072017.3959:<< create a picture >>
try:
	if imagefile:
		# Create the image.  Throws an exception if file not found
		imagefile = g.os_path_join(g.app.loadDir,imagefile)
		imagefile = g.os_path_normpath(imagefile)
		image = Tkinter.PhotoImage(master=g.app.root,file=imagefile)
		
		# Must keep a reference to the image!
		try:
			refs = g.app.iconImageRefs
		except:
			refs = g.app.iconImageRefs = []
	
		refs.append((imagefile,image),)
	
	if not bg:
		bg = f.cget("bg")

	b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
	b.pack(side="left",fill="y")
	return b
	
except:
	g.es_exception()
	return None
#@nonl
#@-node:ekr.20031218072017.3959:<< create a picture >>
#@-node:ekr.20031218072017.3958:addIconButton
#@-node:ekr.20031218072017.3953:Creating the icon area
#@+node:ekr.20031218072017.3960:Creating the status area
@tabwidth 4
#@+node:ekr.20031218072017.3961:createStatusLine
def createStatusLine (self):
	
	if self.statusFrame and self.statusLabel:
		return
	
	self.statusFrame = statusFrame = Tk.Frame(self.outerFrame,bd=2)
	statusFrame.pack(fill="x",pady=1)
	
	text = "line 0, col 0"
	width = len(text) + 4
	self.statusLabel = Tk.Label(statusFrame,text=text,width=width,anchor="w")
	self.statusLabel.pack(side="left",padx=1)
	
	bg = statusFrame.cget("background")
	self.statusText = Tk.Text(statusFrame,height=1,state="disabled",bg=bg,relief="groove")
	self.statusText.pack(side="left",expand=1,fill="x")

	# Register an idle-time handler to update the row and column indicators.
	self.statusFrame.after_idle(self.updateStatusRowCol)
#@nonl
#@-node:ekr.20031218072017.3961:createStatusLine
#@+node:ekr.20031218072017.3962:clearStatusLine
def clearStatusLine (self):
	
	t = self.statusText
	if not t: return
	
	t.configure(state="normal")
	t.delete("1.0","end")
	t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3962:clearStatusLine
#@+node:EKR.20040424153344:enable/disableStatusLine & isEnabled
def disableStatusLine (self):
	
	t = self.statusText
	if t:
		t.configure(state="disabled",background="gray")
	
def enableStatusLine (self):
	
	t = self.statusText
	if t:
		t.configure(state="normal",background="pink")
		t.focus_set()
		
def statusLineIsEnabled(self):
	t = self.statusText
	if t:
		state = t.cget("state")
		return state == "normal"
	else:
		return false
#@nonl
#@-node:EKR.20040424153344:enable/disableStatusLine & isEnabled
#@+node:ekr.20031218072017.3963:putStatusLine
def putStatusLine (self,s,color=None):
	
	t = self.statusText ; tags = self.statusColorTags
	if not t: return

	t.configure(state="normal")
	
	if "black" not in self.log.colorTags:
		tags.append("black")
		
	if color and color not in tags:
		tags.append(color)
		t.tag_config(color,foreground=color)

	if color:
		t.insert("end",s)
		t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
		t.tag_config("black",foreground="black")
		t.tag_add("black","end")
	else:
		t.insert("end",s)
	
	t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3963:putStatusLine
#@+node:EKR.20040424154804:setFocusStatusLine
def setFocusStatusLine (self):
	
	t = self.statusText
	if t:
		t.focus_set()
#@nonl
#@-node:EKR.20040424154804:setFocusStatusLine
#@+node:ekr.20031218072017.1733:updateStatusRowCol
def updateStatusRowCol (self):
	
	c = self.c ; body = self.bodyCtrl ; lab = self.statusLabel
	gui = g.app.gui
	if not lab: return
	
	# New for Python 2.3: may be called during shutdown.
	if g.app.killed:
		return

	if 0: # New code
		index = c.frame.body.getInsertionPoint()
		row,col = c.frame.body.indexToRowColumn(index)
		index1 = c.frame.body.rowColumnToIndex(row,0)
	else:
		index = body.index("insert")
		row,col = gui.getindex(body,index)
	
	if col > 0:
		if 0: # new code
			s = c.frame.body.getRange(index1,index2)
		else:
			s = body.get("%d.0" % (row),index)
		s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03
		col = g.computeWidth (s,self.tab_width)

	if row != self.lastStatusRow or col != self.lastStatusCol:
		s = "line %d, col %d " % (row,col)
		lab.configure(text=s)
		self.lastStatusRow = row
		self.lastStatusCol = col
		
	# Reschedule this routine 100 ms. later.
	# Don't use after_idle: it hangs Leo.
	self.statusFrame.after(100,self.updateStatusRowCol)
#@nonl
#@-node:ekr.20031218072017.1733:updateStatusRowCol
#@-node:ekr.20031218072017.3960:Creating the status area
#@-node:ekr.20031218072017.3943:Creating the frame
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

	"""Clear all links to objects in a Leo window."""

	frame = self ; c = self.c ; tree = frame.tree ; body = self.body

	# Do this first.
	<< clear all vnodes and tnodes in the tree >>

	# Destroy all ivars in subclasses.
	g.clearAllIvars(c.atFileCommands)
	g.clearAllIvars(c.fileCommands)
	g.clearAllIvars(c.importCommands)
	g.clearAllIvars(c.tangleCommands)
	g.clearAllIvars(c.undoer)
	g.clearAllIvars(c)
	g.clearAllIvars(body.colorizer)
	g.clearAllIvars(body)
	g.clearAllIvars(tree)

	# This must be done last.
	frame.destroyAllPanels()
	g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
	vList.append(p.v)
	if p.v.t:
		key = id(p.v.t)
		if not tDict.has_key(key):
			tDict[key] = p.v.t

for key in tDict.keys():
	g.clearAllIvars(tDict[key])

for v in vList:
	g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):
	
	"""Destroy all panels attached to this frame."""
	
	panels = (self.comparePanel, self.colorPanel, self.fontPanel, self.prefsPanel)

	for panel in panels:
		if panel:
			panel.top.destroy()
			
	self.comparePanel = None
	self.colorPanel = None
	self.fontPanel = None
	self.prefsPanel = None
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf
def destroySelf (self):
	
	top = self.top # Remember this: we are about to destroy all of our ivars!

	if g.app.windowList:
		self.destroyAllObjects()

	top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: frame.Birth & Death
#@+node:ekr.20031218072017.3960:Creating the status area
@tabwidth 4
#@+node:ekr.20031218072017.3961:createStatusLine
def createStatusLine (self):
	
	if self.statusFrame and self.statusLabel:
		return
	
	self.statusFrame = statusFrame = Tk.Frame(self.outerFrame,bd=2)
	statusFrame.pack(fill="x",pady=1)
	
	text = "line 0, col 0"
	width = len(text) + 4
	self.statusLabel = Tk.Label(statusFrame,text=text,width=width,anchor="w")
	self.statusLabel.pack(side="left",padx=1)
	
	bg = statusFrame.cget("background")
	self.statusText = Tk.Text(statusFrame,height=1,state="disabled",bg=bg,relief="groove")
	self.statusText.pack(side="left",expand=1,fill="x")

	# Register an idle-time handler to update the row and column indicators.
	self.statusFrame.after_idle(self.updateStatusRowCol)
#@nonl
#@-node:ekr.20031218072017.3961:createStatusLine
#@+node:ekr.20031218072017.3962:clearStatusLine
def clearStatusLine (self):
	
	t = self.statusText
	if not t: return
	
	t.configure(state="normal")
	t.delete("1.0","end")
	t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3962:clearStatusLine
#@+node:EKR.20040424153344:enable/disableStatusLine & isEnabled
def disableStatusLine (self):
	
	t = self.statusText
	if t:
		t.configure(state="disabled",background="gray")
	
def enableStatusLine (self):
	
	t = self.statusText
	if t:
		t.configure(state="normal",background="pink")
		t.focus_set()
		
def statusLineIsEnabled(self):
	t = self.statusText
	if t:
		state = t.cget("state")
		return state == "normal"
	else:
		return false
#@nonl
#@-node:EKR.20040424153344:enable/disableStatusLine & isEnabled
#@+node:ekr.20031218072017.3963:putStatusLine
def putStatusLine (self,s,color=None):
	
	t = self.statusText ; tags = self.statusColorTags
	if not t: return

	t.configure(state="normal")
	
	if "black" not in self.log.colorTags:
		tags.append("black")
		
	if color and color not in tags:
		tags.append(color)
		t.tag_config(color,foreground=color)

	if color:
		t.insert("end",s)
		t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
		t.tag_config("black",foreground="black")
		t.tag_add("black","end")
	else:
		t.insert("end",s)
	
	t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3963:putStatusLine
#@+node:EKR.20040424154804:setFocusStatusLine
def setFocusStatusLine (self):
	
	t = self.statusText
	if t:
		t.focus_set()
#@nonl
#@-node:EKR.20040424154804:setFocusStatusLine
#@+node:ekr.20031218072017.1733:updateStatusRowCol
def updateStatusRowCol (self):
	
	c = self.c ; body = self.bodyCtrl ; lab = self.statusLabel
	gui = g.app.gui
	if not lab: return
	
	# New for Python 2.3: may be called during shutdown.
	if g.app.killed:
		return

	if 0: # New code
		index = c.frame.body.getInsertionPoint()
		row,col = c.frame.body.indexToRowColumn(index)
		index1 = c.frame.body.rowColumnToIndex(row,0)
	else:
		index = body.index("insert")
		row,col = gui.getindex(body,index)
	
	if col > 0:
		if 0: # new code
			s = c.frame.body.getRange(index1,index2)
		else:
			s = body.get("%d.0" % (row),index)
		s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03
		col = g.computeWidth (s,self.tab_width)

	if row != self.lastStatusRow or col != self.lastStatusCol:
		s = "line %d, col %d " % (row,col)
		lab.configure(text=s)
		self.lastStatusRow = row
		self.lastStatusCol = col
		
	# Reschedule this routine 100 ms. later.
	# Don't use after_idle: it hangs Leo.
	self.statusFrame.after(100,self.updateStatusRowCol)
#@nonl
#@-node:ekr.20031218072017.1733:updateStatusRowCol
#@-node:ekr.20031218072017.3960:Creating the status area
#@-node:EKR.20040424151321:(Status line experiments) TO DO: create status line class
#@-node:ekr.20040411155746:Quick
#@+node:ekr.20040409164648.1:Features
#@+node:EKR.20040517074454:To do: Load plugins only from plugins menu
@nocolor

1. The sys.path variable has been reset when the plugins are run. It
is set so that *only* the plugins directory is in the path. This means
that no import of standard modules will work in plugins.

In plugins_menu: createPluginsMenu

replace:
path = os.path.join(g.app().loadDir,"..","plugins")
sys.path = path

by:

path = os.path.join(g.app().loadDir,"..","plugins")
newpath = old_path; newpath.append(path)
sys.path = newpath
#@-node:EKR.20040517074454:To do: Load plugins only from plugins menu
#@+node:ekr.20040408042209:Perfect Import
#@-node:ekr.20040408042209:Perfect Import
#@+node:EKR.20040503160843:@directory-import
#@-node:EKR.20040503160843:@directory-import
#@+node:ekr.20040327050211:Fix problems with updating leoConfig.txt
#@+node:ekr.20040330092305:Preserve comments in config files (so we can use sentinels!)
@nocolor

> I don't know how to read [an @file-nosent config] file into the body of that node.

You can't, at least not automatically.  Leo needs sentinels in order to read a derived file, that is, in order to update the outline using information in a derived file.

I've been dithering about exactly what to do about configuration files.  Your question reminds me that we would prefer to have sentinels in config files.  In order to do that, Leo must preserve comments in config files, which of course would be much better than the present pathetic situation in which Python's configParser module strips comments.  As I have said before, using configParser was a blunder.  Somehow I'll fix this for 4.2.

Edward
#@nonl
#@-node:ekr.20040330092305:Preserve comments in config files (so we can use sentinels!)
#@-node:ekr.20040327050211:Fix problems with updating leoConfig.txt
#@+node:ekr.20040323084434:(Add granularity setting for undo)
#@+node:ekr.20040328111626:Notes
@nocolor

- "node" and "line" granularity are easy:
	- Node: just replace "new" text with present text.
	- Line: create a new node if the present line isn't the same as the "line" attribute of the undo node.
		(Very similar to node granularity.

- "word" granularity is still fairly easy:
	- inWord flag is true or false.
	- create a new node if we are starting a new word.

- copy/paste always start new undo typing nodes.
	
#@nonl
#@-node:ekr.20040328111626:Notes
#@+node:ekr.20031218072017.3606:undo.__init__ & clearIvars
def __init__ (self,c):
	
	u = self ; u.c = c
	
	# Ivars to transition to new undo scheme...
	u.debug = false # true: enable debugging code in new undo scheme.
	u.debug_print = false # true: enable print statements in debug code.
	u.new_undo = true # true: enable new debug code.

	# Statistics comparing old and new ways (only if u.debug is on).
	u.new_mem = 0
	u.old_mem = 0

	# State ivars...
	u.undoType = "Can't Undo"
	# These must be set here, _not_ in clearUndoState.
	u.redoMenuLabel = "Can't Redo"
	u.undoMenuLabel = "Can't Undo"
	u.realRedoMenuLabel = "Can't Redo"
	u.realUndoMenuLabel = "Can't Undo"
	u.undoing = false # true if executing an Undo command.
	u.redoing = false # true if executing a Redo command.
	
	# New in 4.2...
	<< Define optional ivars >>
	<< define redoDispatchDict >>
	<< define undoDispatchDict >>
	u.updateSetChangedFlag = true
	u.redrawFlag = true
#@nonl
#@+node:ekr.20031218072017.3607:clearIvars
def clearIvars (self):
	
	u = self
	
	u.p = None # The position/node being operated upon for undo and redo.
	for ivar in u.optionalIvars:
		setattr(u,ivar,None)
#@nonl
#@-node:ekr.20031218072017.3607:clearIvars
#@+node:ekr.20031218072017.3604:<< Define optional ivars >>
# New in 4.2: this is now an ivar, not a global, and it's a list, not a tuple.

u.optionalIvars = [
	"lastChild",
	"parent","oldParent",
	"back","oldBack",
	"n","oldN","oldV",
	"oldText","newText",
	"oldSel","newSel",
	"sort","select",
	"oldTree","newTree", # Added newTree 10/14/03
	"yview",
	# For incremental undo typing...
	"leading","trailing",
	"oldMiddleLines","newMiddleLines",
	"oldNewlines","newNewlines" ]
#@nonl
#@-node:ekr.20031218072017.3604:<< Define optional ivars >>
#@+node:EKR.20040526072519:<< define redoDispatchDict >>
u.redoDispatchDict = {
	"Change":             u.redoTyping,
	"Change All":         u.redoChangeAll,
	"Change Headline":    u.redoChangeHeadline,
	"Clone Node":         u.redoClone,
	"Convert All Blanks": u.redoReplaceNodesContents,
	"Convert All Tabs":   u.redoReplaceNodesContents,
	"Convert Blanks":     u.redoTyping,
	"Convert Tabs":       u.redoTyping,
	"Cut":                u.redoTyping,
	"Cut Node":           u.redoDeleteNode,
	"De-Hoist":           u.redoDehoist,
	"Delete":             u.redoTyping,
	"Delete Node":        u.redoDeleteNode,
	"Demote":             u.redoDemote,
	"Drag":               u.redoMoveNode,
	"Drag & Clone":       u.redoClone,
	"Extract":            u.redoReplaceNodes,
	"Extract Names":      u.redoReplaceNodes,
	"Extract Section":    u.redoReplaceNodes,
	"Hoist":              u.redoHoist,
	"Import":             u.redoInsertNodes,
	"Indent":             u.redoTyping,
	"Insert Node":        u.redoInsertNodes,
	"Move Down":          u.redoMoveNode,
	"Move Left":          u.redoMoveNode,
	"Move Right":         u.redoMoveNode,
	"Move Up":            u.redoMoveNode,
	"Paste":              u.redoTyping,
	"Paste Node":         u.redoInsertNodes,
	"Promote":            u.redoPromote,
	"Read @file Nodes":   u.redoReplaceNodes,
	"Reformat Paragraph": u.redoTyping,
	"Sort Children":      u.redoSortChildren,
	"Sort Siblings":      u.redoSortSiblings,
	"Sort Top Level":     u.redoSortTopLevel,
	"Typing":             u.redoTyping,
	"Undent":             u.redoTyping }
#@nonl
#@-node:EKR.20040526072519:<< define redoDispatchDict >>
#@+node:EKR.20040526075238:<< define undoDispatchDict >>
u.undoDispatchDict = {
	"Change":             u.undoTyping,
	"Change All":         u.undoChangeAll,
	"Change Headline":    u.undoChangeHeadline,
	"Clone Node":         u.undoClone,
	"Convert All Blanks": u.undoReplaceNodesContents,
	"Convert All Tabs":   u.undoReplaceNodesContents,
	"Convert Blanks":     u.undoTyping,
	"Convert Tabs":       u.undoTyping,
	"Cut":                u.undoTyping,
	"Cut Node":           u.undoDeleteNode,
	"De-Hoist":           u.undoDehoist,
	"Delete":             u.undoTyping,
	"Delete Node":        u.undoDeleteNode,
	"Demote":             u.undoDemote,
	"Drag":               u.undoMoveNode,
	"Drag & Clone":       u.undoDragClone, # redo uses redoClone.
	"Extract":            u.undoReplaceNodes,
	"Extract Names":      u.undoReplaceNodes,
	"Extract Section":    u.undoReplaceNodes,
	"Hoist":              u.undoHoist,
	"Import":             u.undoInsertNodes,
	"Indent":             u.undoTyping,
	"Insert Node":        u.undoInsertNodes,
	"Move Down":          u.undoMoveNode,
	"Move Left":          u.undoMoveNode,
	"Move Right":         u.undoMoveNode,
	"Move Up":            u.undoMoveNode,
	"Paste":              u.undoTyping,
	"Paste Node":         u.undoInsertNodes,
	"Promote":            u.undoPromote,
	"Read @file Nodes":   u.undoReplaceNodes,
	"Reformat Paragraph": u.undoTyping,
	"Sort Children":      u.undoSortChildren,
	"Sort Siblings":      u.undoSortSiblings,
	"Sort Top Level":     u.undoSortTopLevel,
	"Typing":             u.undoTyping,
	"Undent":             u.undoTyping }
#@nonl
#@-node:EKR.20040526075238:<< define undoDispatchDict >>
#@-node:ekr.20031218072017.3606:undo.__init__ & clearIvars
#@+node:ekr.20031218072017.1421:<< get config options >>
@ Rewritten 10/11/02 as follows:

1. We call initConfigParam and initBooleanConfigParam to get the values.

The general purpose code will enter all these values into configDict.  This allows update() to write the configuration section without special case code.  configDict is not accessible by the user.  Rather, for greater speed the user access these values via the ivars of this class.

2. We pass the ivars themselves as params so that default initialization is done in the ctor, as would normally be expected.
@c

self.at_root_bodies_start_in_doc_mode = self.initBooleanConfigParam(
	"at_root_bodies_start_in_doc_mode",self.at_root_bodies_start_in_doc_mode)
	
encoding = self.initConfigParam(
	"config_encoding",self.config_encoding)
	
if g.isValidEncoding(encoding):
	self.config_encoding = encoding
else:
	g.es("bad config_encoding: " + encoding)
	
self.create_nonexistent_directories = self.initBooleanConfigParam(
	"create_nonexistent_directories",self.create_nonexistent_directories)
	
encoding = self.initConfigParam(
	"default_derived_file_encoding",self.default_derived_file_encoding)

if g.isValidEncoding(encoding):
	self.default_derived_file_encoding = encoding
else:
	g.es("bad default_derived_file_encoding: " + encoding)
	
self.load_derived_files_immediately = self.initBooleanConfigParam(
	"load_derived_files_immediately",self.load_derived_files_immediately)
	
encoding = self.initConfigParam(
	"new_leo_file_encoding",
	self.new_leo_file_encoding)

if g.isValidEncoding(encoding):
	self.new_leo_file_encoding = encoding
else:
	g.es("bad new_leo_file_encoding: " + encoding)

self.output_initial_comment = self.initConfigParam(
	"output_initial_comment",self.output_initial_comment)

self.output_newline = self.initConfigParam(
	"output_newline",self.output_newline)

self.read_only = self.initBooleanConfigParam(
	"read_only",self.read_only)

self.relative_path_base_directory = self.initConfigParam(
	"relative_path_base_directory",self.relative_path_base_directory)
	
self.redirect_execute_script_output_to_log_pane = self.initBooleanConfigParam(
	"redirect_execute_script_output_to_log_pane",
	self.redirect_execute_script_output_to_log_pane)
	
self.remove_sentinels_extension = self.initConfigParam(
	"remove_sentinels_extension",self.remove_sentinels_extension)

self.save_clears_undo_buffer = self.initBooleanConfigParam(
	"save_clears_undo_buffer",self.save_clears_undo_buffer)
	
self.stylesheet = self.initConfigParam(
	"stylesheet",self.stylesheet)
	
encoding = self.initConfigParam(
	"tk_encoding",self.tkEncoding)
	
if encoding and len(encoding) > 0: # May be None.
	if g.isValidEncoding(encoding):
		self.tkEncoding = encoding
	else:
		g.es("bad tk_encoding: " + encoding)
		
# g.trace("config.self.tkEncoding",self.tkEncoding)

g.app.use_gnx = self.initBooleanConfigParam(
	"use_gnx",g.app.use_gnx)
# g.trace("g.app.use_gnx",g.app.use_gnx)
	
self.use_plugins = self.initBooleanConfigParam(
	"use_plugins",self.use_plugins)

self.use_psyco = self.initBooleanConfigParam(
	"use_psyco",self.use_psyco)
	
self.undo_granularity = self.initConfigParam(
	"undo_granularity",self.undo_granularity)
	
self.write_old_format_derived_files = self.initBooleanConfigParam(
	"write_old_format_derived_files",self.write_old_format_derived_files)
#@-node:ekr.20031218072017.1421:<< get config options >>
#@+node:ekr.20031218072017.1490:setUndoTypingParams
@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
	
	# g.trace(undo_type,p,"old:",oldText,"new:",newText)
	u = self ; c = u.c
	<< return if there is nothing to do >>
	<< init the undo params >>
	<< compute leading, middle & trailing  lines >>
	<< save undo text info >>
	<< save the selection and scrolling position >>
	<< adjust the undo stack, clearing all forward entries >>
	u.setUndoTypes() # Recalculate the menu labels.
	return d
#@nonl
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
	return None

if undo_type == None:
	return None

if undo_type == "Can't Undo":
	u.clearUndoState()
	return None

if oldText == newText:
	# g.trace("no change")
	return None
#@nonl
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
	setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p
#@nonl
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
	if old_lines[i] != new_lines[i]:
		break
	i += 1
leading = i

if leading == new_len:
	# This happens when we remove lines from the end.
	# The new text is simply the leading lines from the old text.
	trailing = 0
else:
	i = 0
	while i < min_len - leading:
		if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
			break
		i += 1
	trailing = i
	
# NB: the number of old and new middle lines may be different.
if trailing == 0:
	old_middle_lines = old_lines[leading:]
	new_middle_lines = new_lines[leading:]
else:
	old_middle_lines = old_lines[leading:-trailing]
	new_middle_lines = new_lines[leading:-trailing]
	
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
	old_newlines += 1
	i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
	new_newlines += 1
	i -= 1

if u.debug_print:
	g.trace()
	print "lead,trail",leading,trailing
	print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
	print "new mid,nls:",len(new_middle_lines),new_newlines,newText
	#print "lead,trail:",leading,trailing
	#print "old mid:",old_middle_lines
	#print "new mid:",new_middle_lines
	print "---------------------"
#@nonl
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply v.bodyString().
@c

if u.new_undo:
	if u.debug:
		# Remember the complete text for comparisons...
		u.oldText = oldText
		u.newText = newText
		# Compute statistics comparing old and new ways...
		# The old doesn't often store the old text, so don't count it here.
		u.old_mem += len(newText)
		s1 = string.join(old_middle_lines,'\n')
		s2 = string.join(new_middle_lines,'\n')
		u.new_mem += len(s1) + len(s2)
	else:
		u.oldText = None
		u.newText = None
else:
	u.oldText = oldText
	u.newText = newText

self.leading = leading
self.trailing = trailing
self.oldMiddleLines = old_middle_lines
self.newMiddleLines = new_middle_lines
self.oldNewlines = old_newlines
self.newNewlines = new_newlines
#@nonl
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
	u.yview = oldYview
else:
	u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
# Push params on undo stack, clearing all forward entries.
u.bead += 1
d = u.setBead(u.bead)
u.beads[u.bead:] = [d]

# g.trace(len(u.beads), u.bead)
#@nonl
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@+node:ekr.20031218072017.2038:<< redo typing cases >>
elif redoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# g.trace(redoType,u.p)
	# selectVnode causes recoloring, so avoid if possible.
	if current != u.p:
		c.selectVnode(u.p)
	elif redoType in ("Cut","Paste"):
		c.frame.body.forceFullRecolor()

	self.undoRedoText(
		u.p,u.leading,u.trailing,
		u.newMiddleLines,u.oldMiddleLines,
		u.newNewlines,u.oldNewlines,
		tag="redo",undoType=redoType)
	
	if u.newSel:
		c.frame.body.setTextSelection(u.newSel)
	if u.yview:
		c.frame.body.setYScrollPosition(u.yview)
	redrawFlag = (current != u.p)
		
elif redoType == "Change All":

	count = 0
	while 1:
		u.bead += 1
		d = u.getBead(u.bead+1)
		assert(d)
		redoType = u.undoType
		# g.trace(redoType,u.p,u.newText)
		if redoType == "Change All":
			c.selectVnode(u.p)
			break
		elif redoType == "Change":
			u.p.v.setTnodeText(u.newText)
			u.p.setDirty()
			count += 1
		elif redoType == "Change Headline":
			u.p.initHeadString(u.newText)
			count += 1
		else: assert(false)
	g.es("redo %d instances" % count)

elif redoType == "Change Headline":
	
	# g.trace(redoType,u.p,u.newText)
	u.p.setHeadStringOrHeadline(u.newText)
	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2038:<< redo typing cases >>
#@+node:ekr.20031218072017.2047:<< undo typing cases >>
@ When making "large" changes to text, we simply save the old and new text for undo and redo.  This happens rarely, so the expense is minor.

But for typical typing situations, where we are typing a single character, saving both the old and new text wastes a huge amount of space and puts extreme stress on the garbage collector.  This in turn can cause big performance problems.
@c
	
elif undoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# g.trace(undoType,u.p)
	# selectVnode causes recoloring, so don't do this unless needed.
	if current != u.p:
		c.selectVnode(u.p)
	elif undoType in ("Cut","Paste"):
		c.frame.body.forceFullRecolor()

	self.undoRedoText(
		u.p,u.leading,u.trailing,
		u.oldMiddleLines,u.newMiddleLines,
		u.oldNewlines,u.newNewlines,
		tag="undo",undoType=undoType)
	if u.oldSel:
		c.frame.body.setTextSelection(u.oldSel)
	if u.yview:
		c.frame.body.setYScrollPosition(u.yview)
	redrawFlag = (current != u.p)
		
elif undoType == "Change All":

	count = 0
	while 1:
		u.bead -= 1
		d = u.getBead(u.bead)
		assert(d)
		undoType = u.undoType
		# g.trace(undoType,u.p,u.oldText)
		if undoType == "Change All":
			c.selectVnode(u.p)
			break
		elif undoType == "Change":
			u.p.setTnodeText(u.oldText)  # p.setTnodeText
			count += 1
			u.p.setDirty()
		elif undoType == "Change Headline":
			u.p.initHeadString(u.oldText)  # p.initHeadString
			count += 1
		else: assert(false)
	g.es("undo %d instances" % count)
		
elif undoType == "Change Headline":
	
	# g.trace(u.oldText)
	u.p.setHeadStringOrHeadline(u.oldText)
	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2047:<< undo typing cases >>
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
	leading,trailing, # Number of matching leading & trailing lines.
	oldMidLines,newMidLines, # Lists of unmatched lines.
	oldNewlines,newNewlines, # Number of trailing newlines.
	tag="undo", # "undo" or "redo"
	undoType=None):

	u = self ; c = u.c
	assert(p == c.currentPosition())
	v = p.v

	<< Incrementally update the Tk.Text widget >>
	<< Compute the result using v's body text >>
	# g.trace(v)
	# g.trace("old:",v.bodyString())
	v.setTnodeText(result)
	# g.trace("new:",v.bodyString())
	<< Get textResult from the Tk.Text widget >>
	if textResult == result:
		if undoType in ("Cut","Paste"):
			# g.trace("non-incremental undo")
			c.frame.body.recolor(p,incremental=false)
		else:
			# g.trace("incremental undo:",leading,trailing)
			c.frame.body.recolor_range(p,leading,trailing)
	else: # 11/19/02: # Rewrite the pane and do a full recolor.
		if u.debug_print:
			<< print mismatch trace >>
		# g.trace("non-incremental undo")
		p.setBodyStringOrPane(result)
#@nonl
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
	c.frame.body.deleteLine(leading)
	if leading > 0:
		c.frame.body.insertAtEnd('\n')
	c.frame.body.insertAtEnd(mid_text)
else:
	if new_mid_len > 0:
		c.frame.body.deleteLines(leading,new_mid_len)
	elif leading > 0:
		c.frame.body.insertAtStartOfLine(leading,'\n')
	c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
	newlines += 1 ; i -= 1
while newlines > oldNewlines:
	c.frame.body.deleteLastChar()
	newlines -= 1
if oldNewlines > newlines:
	c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
# Recreate the text using the present body text.
body = v.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
	s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
	s.extend(oldMidLines)
if trailing > 0:
	s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
	s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
	s = s + '\n' * oldNewlines
result = s
if u.debug_print:
	print "body:  ",body
	print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
	# Remove the newline from textResult if that is the only difference.
	if len(textResult) > 0 and textResult[:-1] == result:
		textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20040323084434:(Add granularity setting for undo)
#@-node:ekr.20040409164648.1:Features
#@+node:ekr.20040325095459:Conversionn & cleanup
# Is this even necessary??
#@+node:ekr.20031218072017.847:Cleanup
#@+node:ekr.20031218072017.848:Cleanup Pychecker stuff
@color

C:/prog/leoCVS/leo/src\leoAtFile.py:852: Parameter (root) not used
C:/prog/leoCVS/leo/src\leoFileCommands.py:429: Parameter (frame) not used
C:/prog/leoCVS/leo/src\leoUndo.py:1012: Parameter (text) not used
C:/prog/leoCVS/leo/src\leoUndo.py:1088: Parameter (newNewlines) not used
	
C:/prog/leoCVS/leo/src\leoTkinterGui.py:181: Parameter (defaultextension) not used
C:/prog/leoCVS/leo/src\leoTkinterGui.py:192: Parameter (defaultextension) not used
C:/prog/leoCVS/leo/src\leoTkinterGui.py:380: Parameter (defaultSize) not used
#@nonl
#@-node:ekr.20031218072017.848:Cleanup Pychecker stuff
#@+node:ekr.20031218072017.849:Cleanup undo logic
- remove text argument from undoReplace

- remove oldText & newText args from setUndoParams.
#@nonl
#@-node:ekr.20031218072017.849:Cleanup undo logic
#@+node:ekr.20040124073801:Add nullConfig class?
#@-node:ekr.20040124073801:Add nullConfig class?
#@+node:ekr.20040328082044.1:Convert all plugins to "g style"
#@-node:ekr.20040328082044.1:Convert all plugins to "g style"
#@-node:ekr.20031218072017.847:Cleanup
#@+node:ekr.20040304163125:Script to find and replace all functions in leoGlobals.py
import leoGlobals as g
from leoGlobals import true,false
import string
c = g.top()

@others

if 1:
	<< set nameList to the list of functions in leoGlobals.py >>
else:
	p = g.findNodeAnywhere("@file leoGlobals.py")
	nameList = findFunctionsInTree(p)

	nameList.sort() ; g.enl()
	for name in nameList: g.es("'%s'," % name)
	
	s = "%d functions in leoGlobals.py" % len(nameList)
	print s ; g.es(s)

if 0:
	p = g.findTopLevelNode(c,"Code")
	g.enl() ; g.enl()
	count = prependNamesInTree(p,nameList,"g.",replace=true) # Just prints if replace==false.
	s = "%d --- done --- " % count
	print s ; g.es(s)
#@nonl
#@+node:ekr.20040330110202:<< set nameList to the list of functions in leoGlobals.py >>
nameList = (
'alert',
'angleBrackets',
'appendToList',
'callerName',
'CheckVersion',
'choose',
'clearAllIvars',
'clear_stats',
'collectGarbage',
'computeLeadingWhitespace',
'computeWidth',
'computeWindowTitle',
'createTopologyList',
'create_temp_name',
'disableIdleTimeHook',
'doHook',
'dump',
'ecnl',
'ecnls',
'enableIdleTimeHook',
'enl',
'ensure_extension',
'es',
'esDiffTime',
'es_error',
'es_event_exception',
'es_exception',
'escaped',
'executeScript',
'file_date',
'findNodeAnywhere',
'findTopLevelNode',
'findNodeInTree',
'findReference',
'find_line_start',
'find_on_line',
'flattenList',
'funcToMethod',
'getBaseDirectory',
'getOutputNewline',
'getTime',
'get_Sherlock_args',
'get_directives_dict',
'get_leading_ws',
'get_line',
'get_line_after',
'getpreferredencoding',
'idleTimeHookHandler',
'importFromPath',
'initScriptFind',
'init_sherlock',
'init_trace',
'isUnicode',
'isValidEncoding',
'is_c_id',
'is_nl',
'is_special',
'is_ws',
'is_ws_or_nl',
'joinLines',
'listToString',
'makeAllNonExistentDirectories',
'makeDict',
'match',
'match_c_word',
'match_ignoring_case',
'match_word',
'module_date',
'openWithFileName',
'optimizeLeadingWhitespace',
'os_path_abspath',
'os_path_basename',
'os_path_dirname',
'os_path_exists',
'os_path_getmtime',
'os_path_isabs',
'os_path_isdir',
'os_path_isfile',
'os_path_join',
'os_path_norm',
'os_path_normcase',
'os_path_normpath',
'os_path_split',
'os_path_splitext',
'pause',
'plugin_date',
'plugin_signon',
'printDiffTime',
'printGc',
'printGcRefs',
'printGlobals',
'printLeoModules',
'print_bindings',
'print_stats',
'readlineForceUnixNewline',
'redirectStderr',
'redirectStdout',
'removeLeadingWhitespace',
'removeTrailingWs',
'reportBadChars',
'restoreStderr',
'restoreStdout',
'sanitize_filename',
'scanAtEncodingDirective',
'scanAtFileOptions',
'scanAtLineendingDirective',
'scanAtPagewidthDirective',
'scanAtRootOptions',
'scanAtTabwidthDirective',
'scanDirectives',
'scanError',
'scanf',
'set_delims_from_language',
'set_delims_from_string',
'set_language',
'shortFileName',
'skip_blank_lines',
'skip_block_comment',
'skip_braces',
'skip_c_id',
'skip_heredoc_string',
'skip_leading_ws',
'skip_leading_ws_with_indent',
'skip_line',
'skip_long',
'skip_matching_delims',
'skip_nl',
'skip_non_ws',
'skip_parens',
'skip_pascal_begin_end',
'skip_pascal_block_comment',
'skip_pascal_braces',
'skip_pascal_string',
'skip_php_braces',
'skip_pp_directive',
'skip_pp_if',
'skip_pp_part',
'skip_python_string',
'skip_string',
'skip_to_char',
'skip_to_end_of_line',
'skip_to_semicolon',
'skip_typedef',
'skip_ws',
'skip_ws_and_nl',
'splitLines',
'stat',
'stdErrIsRedirected',
'stdOutIsRedirected',
'toEncodedString',
'toUnicode',
'toUnicodeFileEncoding',
'top',
'trace',
'trace_tag',
'update_file_if_changed',
'utils_rename',
'windows',
'wrap_lines')
#@nonl
#@-node:ekr.20040330110202:<< set nameList to the list of functions in leoGlobals.py >>
#@+node:ekr.20040304165432.1:findFunctionsInTree
def findFunctionsInTree(p):
	
	nameList = []
	for p in p.self_and_subtree_iter():
		names = findDefs(p.bodyString())
		if names:
			for name in names:
				if name not in nameList:
					nameList.append(name)
	return nameList
#@nonl
#@-node:ekr.20040304165432.1:findFunctionsInTree
#@+node:ekr.20040304163522:findDefs
def findDefs(body):
	
	lines = body.split('\n')
	names = []
	for s in lines:
		i = g.skip_ws(s,0)
		if g.match(s,i,"class"):
			return [] # The classes are defined in a single node.
		if g.match(s,i,"def"):
			i = g.skip_ws(s,i+3)
			j = g.skip_c_id(s,i)
			if j > i:
				name = s[i:j]
				if g.match(name,0,"__init__"): 
					return [] # Disallow other class methods.
				names.append(name)
	return names
#@nonl
#@-node:ekr.20040304163522:findDefs
#@+node:ekr.20040304164949:prependNamesInTree
def prependNamesInTree(p,nameList,prefix,replace=false):
	
	c = p.c
	
	assert(len(prefix) > 0)
	ch1 = string.letters + '_'
	ch2 = string.letters + string.digits + '_'
	def_s = "def " ; def_n = len(def_s)
	prefix_n = len(prefix)
	total = 0
	c.beginUpdate()
	for p in p.self_and_subtree_iter():
		count = 0 ; s = p.bodyString()
		printFlag = false
		if s:
			for name in nameList:
				i = 0 ; n = len(name)
				while 1:
					<< look for name followed by '(' >>
			if count and replace:
				if 0:
					<< print before and after >>
				p.setBodyStringOrPane(s)
				p.setDirty()
		g.es("%3d %s" % (count,p.headString()))
		total += count
	c.endUpdate()
	return total
#@nonl
#@+node:ekr.20040304173234.1:<< look for name followed by '(' >>
i = s.find(name,i)
if i == -1:
	break
elif g.match(s,i-1,'.'):
	i += n # Already an attribute.
elif g.match(s,i-prefix_n,prefix):
	i += n # Already preceded by the prefix.
elif g.match(s,i-def_n,def_s):
	i += n # preceded by "def"
elif i > 0 and s[i-1] in ch1:
	i += n # Not a word match.
elif i+n < len(s) and s[i+n] in ch2:
	i += n # Not a word match.
else:
	j = i + n
	j = g.skip_ws(s,j)
	if j >= len(s) or s[j] != '(':
		i += n
	else: # Replace name by prefix+name
		s = s[:i] + prefix + name + s[i+n:]
		i += n ; count += 1
		# g.es('.',newline=false)
		if 1:
			if not printFlag:
				printFlag = true
				# print p.headString()
			print g.get_line(s,i-n)
#@nonl
#@-node:ekr.20040304173234.1:<< look for name followed by '(' >>
#@+node:ekr.20040304173234:<< print before and after >>
print "-"*10,count,p.headString()
print "before..."
print p.bodyString()
print "-"*10,"after..."
print s
#@nonl
#@-node:ekr.20040304173234:<< print before and after >>
#@-node:ekr.20040304164949:prependNamesInTree
#@-node:ekr.20040304163125:Script to find and replace all functions in leoGlobals.py
#@+node:ekr.20040315073818:create find-script to complete transition?
@nocolor

- Search for rootVnode,currentVnode.
- change v to p
- Use iterators? (Search for threadNext)
#@-node:ekr.20040315073818:create find-script to complete transition?
#@-node:ekr.20040325095459:Conversionn & cleanup
#@+node:ekr.20040411151636:Other
#@+node:ekr.20040323195916:Documentation
@nocolor

Update acknowledgements.

Link to new scripting chapter.

Convert FAQ to rST

Convert all docs to rST?
#@nonl
#@+node:EKR.20040503091612:Dangers of @file-thin
Using @ignore with @file-thin is asking for trouble.
If you remove the @ignore and then save, you will lose data.

How to recover the data:
	- Read Outline.
	- Remove @ignore
	- Import derived file... 
#@nonl
#@-node:EKR.20040503091612:Dangers of @file-thin
#@-node:ekr.20040323195916:Documentation
#@+node:ekr.20040323195916.1:Tests
@nocolor

** Test for memory leaks.

- Test tangle/untangle commands.
- Create unit tests for Find commands.

- Test all changed code:
	- Make a list of the code that has changed.

- Run profiler on code.
#@nonl
#@-node:ekr.20040323195916.1:Tests
#@-node:ekr.20040411151636:Other
#@+node:ekr.20040414093055:Shadow files plugin
@nocolor

https://sourceforge.net/forum/message.php?msg_id=2521345
By: bwmulder

I am working on a plugin which works with shadow files in a Leo subdirectory.

This is really the same code posted integrated with Leo. New is that
the goto linenumber command works properly as well.

The new code only kicks in if:
   - A leo subdirectory exists, and
   - both directories contain the file in question.
   
To get things started, create a Leo subdirectory, move the source
files there, and then create zero length strings instead of the moved
files. Whenever you change something in the sourcefile, both files
will be brought up to date automatically.

In the future, I might provide a script which provides this initial
setup automatically.

Implementation notes (relative to 4.1):

In order to use this mechanism to annotate foreign code, I am missing
two pieces:
   
   - The import command should import the source *exactly*.
   - I would like to add comments to the source which are *not* output into
source,
     and live in Leo only (or the shadowfile under Leo sentinel comments).
     
I changed the "message_comment" function to do nothing.

I do not think that this function is a good idea, since Leo can not know
if the line structure in a comment.

There might be more to do in this area.

It seems that I can get around the second limitation by writing "//@"
at the beginning of the line in the code sections, since this is
filtered away by the plugin.

Is there some other way to put comments only in the Leo document, but
not in the derived file?

I had to copy quite a bit of source code for the gotolinenr
command. It probably won't work for the next version of Leo

It seems that Leo somewhat encourages a coding style with long
routines, since complexity can be tugged away into subnodes rather
than creating functions to structure the code.

For the read and write command, I decided to inject a new "open"
function into the global namespace of leoAtFile.py. This function
checks if the caller is the read or write function of leoAtFile.py. In
this case, some special processing for synchronization is done.

I did this strange programming since I did not want to copy large
amounts of code and just add a few lines.

Currently the script works for C and python files. It looks at the
file extension to determine if C or python type annotations are
used. Maybe this information can be centralized.
#@-node:ekr.20040414093055:Shadow files plugin
#@-node:EKR.20040430163619:To Do: 4.2
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
