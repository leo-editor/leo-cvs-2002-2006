#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20060301102950:To do 4.4 b3
#@+node:ekr.20060321082832:To do first
#@+node:ekr.20060309132452:Figure out what is really wrong with unicode in onBodyChanged
#@-node:ekr.20060309132452:Figure out what is really wrong with unicode in onBodyChanged
#@+node:ekr.20060306193910:Open with shortcuts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3607355
By: vpe

Alt-Ctrl-T shortcut for Open With external editor does not work in a7. Is it
possible to assign shortcuts to Open With items? I see that there is open-with
minibuffer command, but do not understand how to use it.
#@-node:ekr.20060306193910:Open with shortcuts
#@+node:ekr.20060308103043:Fix crasher in Word plugin
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3617936
By: nobody

I did a clean install of A7. I have the export to word plugin enabled. When
I try to export my outline to word I get the following:

Leo Log Window...
Leo 4.4 a7, build  1.417 , February 28, 2006
Python 2.3.5, Tk 8.4.3, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

reading: C:\Development\VL4\VL4 outline.leo
Trying to connect to Word
Writing tree to Word
Exception writing Word
Traceback (most recent call last):
  File "C:\Program Files\Leo\plugins\word_export.py", line 163, in cmd_Export
    "")
  File "C:\Program Files\Leo\plugins\word_export.py", line 122, in
writeNodeAndTree
    vnode = c.currentVnode()
AttributeError: 'Bunch' object has no attribute 'currentVnode'
#@-node:ekr.20060308103043:Fix crasher in Word plugin
#@+node:ekr.20060307142612:Fix problem with labels plugin
@nocolor

I tried the Labels plugin, and got:

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Leo\src\leoCommands.py", line 265, in doCommand
    val = command(event)
TypeError: menu_add_label() takes exactly 1 argument (2 given)

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Leo\src\leoCommands.py", line 265, in doCommand
    val = command(event)
TypeError: marks_to_label() takes exactly 1 argument (2 given)

--Rich

#@-node:ekr.20060307142612:Fix problem with labels plugin
#@+node:ekr.20060310093345:Improve groupoperations plugin
@nocolor

> G.Ops is another plugin that I found very handy

OK, I found the groupOperations.py plugin.

All that is really required is a call to

k.registerCommand for each command.

However, you need to specify a shortcut to k.registerCommand, so the plugin also needs to handle shortcuts, say by calling c.config.getShortcut('groupOperations_x_shortcut')
for each command x that you want to register.

The value returned is ('setting_name',{list of settings])

The user would define these shortcuts in individual @shortcut nodes.

You could try to do this yourself with these hints.  Otherwise you may have to wait awhile for me to do it.

Edward

#@-node:ekr.20060310093345:Improve groupoperations plugin
#@+node:ekr.20060307074624:Improve autocompleter
#@+node:ekr.20060309132427:Add option to disable self completion
#@-node:ekr.20060309132427:Add option to disable self completion
#@+node:ekr.20060305110016:*** autocompleter text not always sticking
#@-node:ekr.20060305110016:*** autocompleter text not always sticking
#@+node:ekr.20060306194204:Fix problems with autocompleter
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3607477
By: ktenney

Howdy,

With autocomplete active, try typing;
.. url: http://leo.zwiki.org/LeoZWiki

what I find is: (W2K, current CVS)

I have to type 4 "."

after typing "leo." 
I can't type "zwiki", I need to accept a
completion, backspace over it, _then_ type "zwiki".
#@nonl
#@-node:ekr.20060306194204:Fix problems with autocompleter
#@+node:ekr.20060305073002:Separate config setting for self completion
#@-node:ekr.20060305073002:Separate config setting for self completion
#@+node:ekr.20060307074302:*Control-g doesn't work in find completion
#@-node:ekr.20060307074302:*Control-g doesn't work in find completion
#@+node:ekr.20060228071700:Ignore autocompletion for number.
#@-node:ekr.20060228071700:Ignore autocompletion for number.
#@+node:ekr.20060309021641:Document autocompleter better
@nocolor

> is it correct that only ctrl, and a mouse click, should trigger insertion,

No.  The main way to start autocompletion is to type a period.  For example, the last period in:

x.y.z.

Leo will scan to the start (x) to see if x is something it knows about.  In particular, if x is 'self' Leo will see if the current node is in the range of an class definition.  Also, Leo 'knows about' c, g and p, and a few others.  I need to find some way of generalizing what Leo knows about.  Leo also knows about all the modules in sys.modules so typing 'sys.' will bring up the autocompleter.

>Does the autocompleter sometimes insert a word into text with some special markup?

The presently suggested text is highlighted.  You can see the status of the autocompletion by looking at the name of the tab.  For example, after typing 'sys.' the tab will show 'Autocomplete sys.'

Forget the other ways of invoking the autocompleter.

Edward
#@nonl
#@-node:ekr.20060309021641:Document autocompleter better
#@-node:ekr.20060307074624:Improve autocompleter
#@-node:ekr.20060321082832:To do first
#@+node:ekr.20060307074302.1:*set-change-text command should work when entering find text.
#@-node:ekr.20060307074302.1:*set-change-text command should work when entering find text.
#@+node:ekr.20060306195137:Document and test @ifgui and @ifplatform nodes
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3607510
By: spboulet

One suggestion is to have more of the platform detection work be done by leo
('if sys.platform ==' is not all that hard) instead of making it windows default
(e.g. external editors program locations, command vs. control keys). Having
to edit leoConfig.leo should be optional but not necessary in cases like these.

Stephen (my 2 cents)
#@-node:ekr.20060306195137:Document and test @ifgui and @ifplatform nodes
#@+node:ekr.20060227123644:There are still problems with focus: remove the optimizations?
@ It's much better to call g.app.gui.set_focus a few extra times than to mess up the focus!

- Make c.invalidateFocus a do-nothing method.
#@nonl
#@-node:ekr.20060227123644:There are still problems with focus: remove the optimizations?
#@+node:ekr.20060321110256:Create better unit tests for master key handler
Can this be done?  How to tests keys in various states?
#@nonl
#@-node:ekr.20060321110256:Create better unit tests for master key handler
#@-node:ekr.20060301102950:To do 4.4 b3
#@+node:ekr.20060226131603:To do 4.4 b4
#@+node:ekr.20060301080026:Add support for chapters to Leo's core
#@+node:ekr.20060301080738:File
#@+node:ekr.20060301080433.1:getLeoFile
#@+node:ekr.20060301075130.190:getLeoFile  (chapters)
def getLeoFile (self,fc,fileName,readAtFileNodesFlag=True,silent=False):
    
    global iscStringIO # For communication with g.os_path_dirname

    if iscStringIO:
        def dontSetReadOnly (self,name,value):
            if name not in ('read_only','tnodesDict'):
                self.__dict__ [name] = value

        self.read_only = False
        self.__class__.__setattr__ = dontSetReadOnly

    rt = old_getLeoFile(fc,fileName,readAtFileNodesFlag,silent)

    if iscStringIO:
        del self.__class__.__setattr__

    return rt
#@nonl
#@-node:ekr.20060301075130.190:getLeoFile  (chapters)
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        if not silent:
            << raise an alert >>
        ok = False

    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw_now()
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
        
    # g.trace(c.currentPosition())
    
    # New in 4.3.1: do this after reading derived files.
    if not self.usingClipboard:
        << set current and top positions >>

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
if not silent:
    g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:ekr.20040326054052:<< set current and top positions >>
current = self.convertStackToPosition(self.currentVnodeStack)
if current:
    # g.trace('using convertStackToPosition',current)
    c.setCurrentPosition(current)
else:
    # g.trace(self.currentVnodeStack)
    c.setCurrentPosition(c.rootPosition())
    
# At present this is useless: the drawing code doesn't set the top position properly.
if 0:
    top = self.convertStackToPosition(self.topVnodeStack)
    if top:
        c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:<< set current and top positions >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20060301080433.1:getLeoFile
#@+node:ekr.20060301080433.3:open
#@+node:ekr.20060301075130.192:open (chapters)
def open (self,fc,file,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c

    if zipfile.is_zipfile(fileName):
        # Set globals for g.os_path_dirname
        global iscStringIO, stringIOCommander
        iscStringIO = True ; stringIOCommander = c
        chapters = openChaptersFile(fileName)
        g.es(str(len(chapters))+" Chapters To Read",color='blue')
        self.insertChapters(chapters)
        g.es("Finished Reading Chapters",color='blue')
        iscStringIO = False
        return True
    else:
        return old_open(fc,file,fileName,readAtFileNodesFlag,silent)
#@nonl
#@-node:ekr.20060301075130.192:open (chapters)
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    # Delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@-node:ekr.20060301080433.3:open
#@+node:ekr.20060301080738.1:write_Leo_file
#@+node:ekr.20060301075130.194:write_Leo_file & helper (chapters)
def write_Leo_file (self,fc,fileName,outlineOnlyFlag,singleChapter=False):

    c = self.c ; nb = self.nb ; pagenames = nb.pagenames()

    if len(pagenames) > 1 and not singleChapter:
        chapList = []
        fc.__class__.__setattr__ = getMakeStringIO(chapList)
        rv = self.writeChapters(fc,fileName,pagenames,c,outlineOnlyFlag)
        if rv: zipChapters(fileName,pagenames,c,chapList)
        del self.__class__.__setattr__
        return rv
    else:
        global old_write_Leo_file
        return old_write_Leo_file(fc,fileName,outlineOnlyFlag)
#@nonl
#@+node:ekr.20060301075130.195:writeChapters
def writeChapters (self,fc,fileName,pagenames,outlineOnlyFlag):

    '''Writes Chapters to StringIO instances.'''
    
    c = self.c

    for z in pagenames:
        ###sv = self.getStringVar(z)
        ###chapter = self.chapters [sv]
        chapter = self.getChapter(z)
        chapter.setVariables()
        rv = old_write_Leo_file(fc,fileName,outlineOnlyFlag)

    c.cChapter.setVariables()
    return rv
#@nonl
#@-node:ekr.20060301075130.195:writeChapters
#@-node:ekr.20060301075130.194:write_Leo_file & helper (chapters)
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        << write all @file nodes >>
    << return if the .leo file is read-only >>
    try:
        theActualFile = None
        if not toString:
            << create backup file >>
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        if not toString:
            theActualFile = open(fileName, 'wb')
        << put the .leo file >>
        s = self.outputFile.getvalue()
        if toString:
            # For support of chapters plugin.
            g.app.write_Leo_file_string = s
        else:
            theActualFile.write(s)
            theActualFile.close()
            << delete backup file >>
        self.outputFile = None
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        << delete fileName >>
        << rename backupName to fileName >>
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
#@nonl
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20040324080819.1:<< put the .leo file >>
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()
#@nonl
#@-node:ekr.20040324080819.1:<< put the .leo file >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
#@nonl
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@+node:ekr.20050405103712:<< delete fileName >>
if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
#@-node:ekr.20050405103712:<< delete fileName >>
#@+node:ekr.20050405103712.1:<< rename backupName to fileName >>
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)
#@nonl
#@-node:ekr.20050405103712.1:<< rename backupName to fileName >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@-node:ekr.20060301080738.1:write_Leo_file
#@-node:ekr.20060301080738:File
#@+node:ekr.20060301080828:Positions
#@+node:ekr.20060301075130.188:doDelete  (chapters)
def doDelete (self,p):
    
    c = self.c ### ; nb = self.nb ; pagenames = nb.pagenames()
    
    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return
    
    # pagenames = [self.setStringVar(x).get().upper() for x in pagenames]
    # nbnam = nb.getcurselection()
    # if nbnam != None:
        # name = self.getStringVar(nb.getcurselection()).get().upper()
    # else: name = 'TRASH'
    # tsh = 'TRASH'
    
    name = self.nb.getcurselection()
    
    trash = 'Trash'
    # if name != tsh and tsh in pagenames:
    if name != trash and trash in self.nb.pagenames():
        index = pagenames.index(tsh)
        ### trchapter = self.chapters [self.getStringVar(index)]
        trchapter = self.getChapter(trash)
        trashnode = trchapter.rp
        trchapter.setVariables()
        p.moveAfter(trashnode)
        c.cChapter.setVariables()
        c.selectPosition(newNode)
        return p
    else:
        return old_doDelete(p)
#@nonl
#@-node:ekr.20060301075130.188:doDelete  (chapters)
#@+node:ekr.20040303175026.2:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline.  May be undone.

    Returns newPosition."""

    p = self ; c = p.c
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
#@nonl
#@-node:ekr.20040303175026.2:p.doDelete
#@-node:ekr.20060301080828:Positions
#@+node:ekr.20060301080738.2:Gui
#@+node:ekr.20060301080433.2:tree select
#@+node:ekr.20060301075130.191:select (chapters)
def select (self,tree,p,updateBeadList=True):

    c = p.v.c ; h = p.headString() ; nb = self.nb

    c.frame.body.lastPosition = p
    return_val = old_select(tree,p,updateBeadList)
    c.frame.body.lastChapter = nb.getcurselection()

    if hasattr(p.c.frame.body,'r'):
        c.frame.body.r.configure(text=h)

    return return_val
#@nonl
#@-node:ekr.20060301075130.191:select (chapters)
#@+node:ekr.20040803072955.128:tree.select
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('does not exist',p.headString())
        return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
# c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@-node:ekr.20060301080433.2:tree select
#@+node:ekr.20060301080433:endEditLabel
#@+node:ekr.20060301075130.189:endEditLabel  (chapters)
def endEditLabel (self,tree):
    
    c = self.c ; p = c.currentPosition() ; h = p.headString()

    if p and h and hasattr(c.frame.body,'r'):
         c.frame.body.r.configure(text=h)

    return old_editLabel(tree)
#@nonl
#@-node:ekr.20060301075130.189:endEditLabel  (chapters)
#@+node:ekr.20040803072955.126:tree.endEditLabel
def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    if k:
        k.setDefaultUnboundKeyAction()
        # k.showStateAndMode() # Destroys UNL info.
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)
#@nonl
#@-node:ekr.20040803072955.126:tree.endEditLabel
#@-node:ekr.20060301080433:endEditLabel
#@+node:ekr.20060301080026.2:createControl
#@+node:ekr.20060301075130.187:createControl  (chapters)
def createControl(self,body,frame,parentFrame):

    c = self.c ; nb = self.nb
    
    if c not in self.pbodies:
        parentFrame = self.createPanedWidget(parentFrame)

    pbody = self.pbodies [c]
    l, r = self.addHeading(parentFrame)

    ctrl = old_createControl(body,frame,parentFrame)
    
    def focusInCallback(event,self=self,frame=frame):
        return self.getGoodPage(event,frame.body)
    ctrl.bind("<FocusIn>",focusInCallback,'+')
    
    i = 1.0 / len(pbody.panes())
    for z in pbody.panes():
        pbody.configurepane(z,size=i)
    pbody.updatelayout()
    frame.body.l = l
    frame.body.r = r
    frame.body.editorName = self.editorNames [parentFrame]
    if frame not in self.twidgets:
        self.twidgets [frame] = []
    self.twidgets [frame].append(frame.body)
    l.configure(textvariable=self.getStringVar(nb.getcurselection()))
    return ctrl
#@-node:ekr.20060301075130.187:createControl  (chapters)
#@+node:ekr.20031218072017.3998:tkBody.createControl
def createControl (self,frame,parentFrame):
    
    c = self.c

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
        
    trace = c.config.getBool('trace_chapters') and not g.app.unitTesting
    if trace: g.trace('tkBody',body)
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    body['yscrollcommand'] = bodyBar.set
    bodyBar['command'] = body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    return body
#@nonl
#@-node:ekr.20031218072017.3998:tkBody.createControl
#@-node:ekr.20060301080026.2:createControl
#@+node:ekr.20060301080026.1:createCanvas
#@+node:ekr.20060301075130.186:createCanvas (chapters)
def createCanvas (self,frame,parentFrame,tabName='1'):
    
    nb = self.nb
    ### pname = self.nameMaker.next()
    ## pname = self.nextPageName()
    g.trace(tabName)
    pname = tabName
    page = nb.add(pname)
    indx = nb.index(pname)
    tab = nb.tab(indx)
    if indx == 0:
        tab.configure(background='grey',foreground='white')
        
    canvas = old_createCanvas(frame,page) # Substitute page for parentFrame.
    
    hull = nb.component('hull')
    tab.bind('<Button-3>',lambda event: hull.tmenu.post(event.x_root,event.y_root))
    if 1:
        self.stringVars[pname] = sv = Tk.StringVar()
    else:
        page.sv = sv = Tk.StringVar()
    self.createBalloon(tab,sv)
    canvas.name = pname
    return canvas
#@-node:ekr.20060301075130.186:createCanvas (chapters)
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):

    # pageName is not used here: it is used for compatibility with the Chapters plugin.

    c = self.c

    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)

    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")
        
    trace = self.c.config.getBool('trace_chapters') and not g.app.unitTesting
    if trace: g.trace(canvas)
        
    # g.trace('canvas',repr(canvas),'name',frame.c.widget_name(canvas))

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 0:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@+node:ekr.20041221071131:createPmwTreeCanvas (not used)
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
 
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas (not used)
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@-node:ekr.20060301080026.1:createCanvas
#@+node:ekr.20060301080738.3:tree ctor
#@+node:ekr.20060301075130.193:treeInit (chapters)
def treeInit (self,tree,c,frame,canvas,tabName=''):
    
    ### sv = self.getStringVar(canvas.name)
    
    old_tree_init(tree,c,frame,canvas)
    
    g.trace(tabName)
    
    if tabName == '1':
        # We are being called during the initial startup.

        ### self.chapters [sv] = Chapter(c,tree,frame,canvas)
        self.chapters ['1'] = Chapter(c,tree,frame,canvas)
#@nonl
#@-node:ekr.20060301075130.193:treeInit (chapters)
#@+node:ekr.20040803072955.16:__init__ (tkTree)
def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)
    
    trace = c.config.getBool('trace_chapters') and not g.app.unitTesting
    if trace: g.trace('tkTree')
    
    # Configuration and debugging settings.
    self.expanded_click_area    = c.config.getBool('expanded_click_area')
    self.gc_before_redraw       = c.config.getBool('gc_before_redraw')
    self.stayInTree             = c.config.getBool('stayInTreeAfterSelect')

    self.trace                  = c.config.getBool('trace_tree')
    self.trace_alloc            = c.config.getBool('trace_tree_alloc')
    self.trace_edit             = c.config.getBool('trace_tree_edit')
    self.trace_redraw_now       = c.config.getBool('trace_redraw_now')
    self.trace_select           = c.config.getBool('trace_select')
    self.trace_stats            = c.config.getBool('show_tree_stats')
 
    # Objects associated with this tree.
    self.canvas = canvas
    
    << define drawing constants >>
    << old ivars >>
    << inject callbacks into the position class >>
    
    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    
    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount <= 0
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets
   
    self.freeUserIcons = []
#@nonl
#@+node:ekr.20040803072955.17:<< define drawing constants >>
self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height
#@nonl
#@-node:ekr.20040803072955.17:<< define drawing constants >>
#@+node:ekr.20040803072955.18:<< old ivars >>
# Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("<B1-ButtonRelease>", self.redraw_now)
#@nonl
#@-node:ekr.20040803072955.18:<< old ivars >>
#@+node:ekr.20040803072955.19:<< inject callbacks into the position class >>
# The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()
#@nonl
#@-node:ekr.20040803072955.19:<< inject callbacks into the position class >>
#@-node:ekr.20040803072955.16:__init__ (tkTree)
#@-node:ekr.20060301080738.3:tree ctor
#@-node:ekr.20060301080738.2:Gui
#@-node:ekr.20060301080026:Add support for chapters to Leo's core
#@+node:ekr.20060227163504:First
#@+node:ekr.20060227124057:Lua
#@+node:ekr.20060227120635:Lua patch
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3572598
By: davidmcnab

I have added support to Leo for the Lua programming language (www.lua.org).

A patch, against Leo 4.4 beta 1, build  1.375, is up at:
http://www.freenet.org.nz/misc/leo-with-lua.patch.gz

Patch should be executed with '-p1' inside the leo 'src' directory.

Summary: support for importing Lua files; support for Lua comments and keywords;
no auto-detect of Lua function definitions or classes (because Lua function/class
idioms vary); no support for Lua v5+ metamethods.

Implementation method - I loaded LeoPy.leo, searched the whole outline for 'java',
and added lua counterparts throughout, including a Lua comment scanner.
#@nonl
#@-node:ekr.20060227120635:Lua patch
#@-node:ekr.20060227124057:Lua
#@+node:ekr.20060209201859.1:Trap AttributeErrors in dummy base classes
Having to define dummy methods is getting odious.
#@nonl
#@-node:ekr.20060209201859.1:Trap AttributeErrors in dummy base classes
#@+node:ekr.20060227163911:Autocompleter options & directives
- enable_autocomplete_in_nocolor = False

- @noautocomplete.
#@nonl
#@-node:ekr.20060227163911:Autocompleter options & directives
#@-node:ekr.20060227163504:First
#@+node:ekr.20060227163504.1:Bugs
#@+node:ekr.20060227125713:Fix colorizer problems
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3585710
By: e

sometimes it seems to happen no matter what.
here are two (I hope) repeatable cases.

happens if the previous line has a comment or string
@language python
some=expr #trailing comment
another line
copy then paste 'another line' line
it colorized like a comment, or all one color.
a sure way to fix it is goto another node then back.
it won't naturally resynch by itself 
even if you goto end of body and back.

after that,
cut something inside next line after a comment same thing.
similar problem if previous line ends in a string.
same if cut/paste and trailing comment is on the same line.
undo restores the previous coloring, correct or not.
its been this way since early 4.4alpha I think.
still using 4.4b1

the final color was comment color as I write this,
as I open a fresh Leo and repeat, its text color.
there may be more than one trigger to the problem.

I know its a tradeoff of constant colorizing runs vrs incremental update, its
not technically a new problem, but this seems way buggier.
#@nonl
#@-node:ekr.20060227125713:Fix colorizer problems
#@+node:ekr.20060213094300:Fix problems with open with
#@+node:ekr.20060213145539:The causes
@nocolor

1.  Both the vim and xemacs plugins require that open_with plugin be enabled.
    I changed the docstrings for each.

2.  The open_with plugin now explicitly calls g.enableIdleTimeHook.
    That is, the idle time hook is no longer enabled by default.
   
These were easy fixes to make.  A similar fix should be done for files opened from the Open With menu, but it's too late to do that for b2.
#@nonl
#@-node:ekr.20060213145539:The causes
#@+node:ekr.20060213144352:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3573148
By: yarkot

With the "latest" CVS snapshot. Do this:

[] Open LeoDocs.leo from the latest workspace;
[] Expand node "What's new in Leo 4.4" (I'll refer to this as the "parent");
[] Dbl-click parent (VIM opens text; text is single line: "@nocolor");
[] Add a second "@nocolor" line; write and save from VIM;
[] Leo view does not show line;
[] re-open w/ vim - vim shows new line;

[] Save;  add more text;  shows w/ vim, not in Leo; Apparently doesn't get save.
You can add a line in Leo, "This is a test", modify it in vim - "This was a
test", save vim, save Leo - close leo, re-open leo - the vim changes never got
saved.

Ok  - that's one.

Here's the second (same file, node, fresh session):

[] Open parent w/ vim (dbl-clk); opens ok;
[] open child "New commands not in legacy Leo" w/ vim; opens ok.
[] FAILS:  try to open first child: "Minibuffer-oriented find commands" - vim
doesn't open, status line flashes node name (once for each click it looks like),
and console window shows this:

open_in_vim: {'p': <pos 20987888 lvl: 1 [0] New commands not in legacy Leo>,
'c'
: Commander 25144936: u'C:\\Workspace\\Leo\\leo\\doc\\LeoDocs.leo', 'event':
<Tk
inter.Event instance at 0x0132BE90>, 'v': <pos 20987888 lvl: 1 [0] New commands
not in legacy Leo>}
#@nonl
#@-node:ekr.20060213144352:Report
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@nonl
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False
#@nonl
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args & keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@nonl
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@nonl
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@nonl
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@nonl
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@nonl
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@nonl
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@nonl
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@nonl
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@-node:ekr.20060213094300:Fix problems with open with
#@+node:ekr.20060211184834:Review all commands in leoEditCommands.py
Any command that alters text should call begin/endCommand.
#@nonl
#@+node:ekr.20060122185244.2:Fix unindent command
# unindent-region should work in all panes.
#@nonl
#@-node:ekr.20060122185244.2:Fix unindent command
#@-node:ekr.20060211184834:Review all commands in leoEditCommands.py
#@-node:ekr.20060227163504.1:Bugs
#@+node:ekr.20060227163504.3:Important
#@+node:ekr.20060211100150:Fix chapters plugin
@nocolor

Add these commands:

show-chapters
hide-chapters
add-chapter
delete-this-chapter
#@nonl
#@-node:ekr.20060211100150:Fix chapters plugin
#@+node:ekr.20060220155313:Script: update-leo-settings-file
#@-node:ekr.20060220155313:Script: update-leo-settings-file
#@+node:ekr.20060122183544:Improve isearch
@nocolor

- Handle backspace for isearch: keep a stack of previous matches.
- Allow cross-node isearches.
#@-node:ekr.20060122183544:Improve isearch
#@+node:ekr.20060210140415:Most important new commands
#@+node:ekr.20060211093935:Support for @list and on-enter-mode
#@-node:ekr.20060211093935:Support for @list and on-enter-mode
#@+node:ekr.20060113090042:open-outline-by-name & filename completion
#@-node:ekr.20060113090042:open-outline-by-name & filename completion
#@+node:ekr.20060122194643:isearch-headline (forward & backward)
#@-node:ekr.20060122194643:isearch-headline (forward & backward)
#@+node:ekr.20060116085649:find-word-on-line, find-character-on-line (forward & backward)
#@-node:ekr.20060116085649:find-word-on-line, find-character-on-line (forward & backward)
#@+node:ekr.20060206103922:Minibuffer interface for GoToLine number
#@-node:ekr.20060206103922:Minibuffer interface for GoToLine number
#@+node:ekr.20060116074839.2:extend-to-word
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20060117115212:Rename buffer doesn't seem to work
#@-node:ekr.20060117115212:Rename buffer doesn't seem to work
#@+node:ekr.20060123091352:Incremental search in switch-to-buffer
#@-node:ekr.20060123091352:Incremental search in switch-to-buffer
#@+node:ekr.20060104083551:move-line-up/down (LeoUser)
http://sourceforge.net/forum/message.php?msg_id=3488030

move-region-up

Swap the selection with the line above it. If we are at the top of a node, the
node identified by threadBack() is selected and the text is moved to the bottom
of the node.

move-region-down

Swap the selection with the line below it. If we are at the bottom of the node,
the node identified by threadNext() is selected and the text is moved to the top
of the node.

In all cases the moved text remains selected, even when the text moves to another node.
#@nonl
#@-node:ekr.20060104083551:move-line-up/down (LeoUser)
#@+node:ekr.20060116084526.1:insert/remove spaces/tabs from lines (LeoUser)
http://sourceforge.net/forum/message.php?msg_id=3488030

add-space-to-lines      Adds a space is added to start of all selected lines.

add-tab-to-line         Adds 4 spaces to start of all selected lines.

remove-space-from lines Removes a space from start of all selected lines.

remove-tab-from lines   Removes a space from start of all selected lines.
#@nonl
#@-node:ekr.20060116084526.1:insert/remove spaces/tabs from lines (LeoUser)
#@+node:ekr.20060123095316:clear-selection
Useful, e.g., after a find.
#@nonl
#@-node:ekr.20060123095316:clear-selection
#@+node:ekr.20051202095626:help-for-command
Use docstrings as the help message.
#@nonl
#@-node:ekr.20051202095626:help-for-command
#@+node:ekr.20060116090428:Expand 'point' so it indicates node as well as text location
#@-node:ekr.20060116090428:Expand 'point' so it indicates node as well as text location
#@+node:ekr.20060214140221:update-settings-file command
#@-node:ekr.20060214140221:update-settings-file command
#@-node:ekr.20060210140415:Most important new commands
#@+node:ekr.20060116173818:*** Fix vampire nodes
#@-node:ekr.20060116173818:*** Fix vampire nodes
#@+node:ekr.20060228072202:New undoer
#@+node:ekr.20060201161901.1:Postings re undo
#@+node:ekr.20060201161901.2:@url http://sourceforge.net/forum/message.php?msg_id=3332355
@nocolor

By: Edward K. Ream - edream 
   RE: Dividing The Undo: doing w/o v.uA 
2005-09-09 14:17  
> If we can open up how [Leo] reads xml, it may make it simpler to start developing a stash scheme. 
 
I agree that reading xml more properly would be A Good Thing (tm). As we shall see, however, it is not the main issue. 
 
> DOM seems like a good path to start out on. 
 
This is not the path I would have chosen. The new colorizer at in leoPlugins.leo at: 
 
Plugins-->Experimental/unfinished-->New colorizer-->@thin __jEdit_colorizer__.py 
 
uses sax. I like the light-weight approach. I would rather do a bit more work in the initial parsing and create the data structures myself then relying on DOM. 
 
But parsing is irrelevant. The problem is the design of *thin* derived files and the code that reads such files. Let us consider how we can "do without" v.unknownAttributes in thin derived files. I **shall not** change the format of thin derived files, so some trickery is required. The first step is read this section of Leo's new docs: 
 
http://webpages.charter.net/edreamleo/customizing.html#adding-extensible-attributes-to-nodes-and-leo-files  /> 
The key here is the so-called 'hidden machinery'. This is an essential feature of the code that reads and writes thin derived files and it **will not** change. **Note**: Leo has two sets of read code: the code that reads .leo files has no trouble whatever recreating vnodes. It is only vnodes in thin derived files that may not have attributes. 
 
**Important**: for @thin trees (in the outline) Leo saves *only* the <v> element corresponding to the @thin node itself. It is this <v> element that contains the 'hidden machinery'. Don't even think about having Leo write the whole tree of <v> elements: the 4.0 read code is made possible because these <v> elements do *not* exist. This eliminates all the error 'recovery' schemes that can not, if fact, be robust enough. 
 
So the only real alternative is to add uA's sufficient to recreate elements in the *reconstituted* vnodes that Leo creates in the leoAtFile read logic. Happily, we can do this as follows. When writing, a plugin (or an extended Leo) would 'piggyback' the vnode attributes in the corresponding **t**.unknownAttributes field. When reading, the plugin (or Leo) would put the vnode attributes "where they belong" in the appropriate vnode. We associate a 'vnode traversal index' with each vnode. This is simply how many previous "same" vnodes appeared in the traversal before getting to the desired vnode. Something like this:: 
 
vx = {} # traversal indices for vnodes. 
for p in c.allNodes_iter(): 
....n = vx.get(p.v.t,0) # n is the traversal index for vnode p.v. 
....vx[p.v.t] = n+1 # bump the index for the next v such that v.t == p.v.t 
 
We store attributes for vnode v in v.t.unknownAttributes, along with the traversal index. The read code uses the traversal index to copy vnode attributes from t.unknownAttributes to v.unknownAttrutes. Rather than forcing each plugin to do this, Leo should probably have support for this in the leoFileCommands read/write code. In short, the t.unknownAttributes machinery suffices in theory, and in practice a bit of support code would be good. 
 
Glad you asked :-) . I have been willing to live without v.uA's in thin derived files. I never thought much about this until you asked, but necessity is the mother... So this is good. A way exists to treat all vnodes as first-class citizens. 
 
Edward 
#@-node:ekr.20060201161901.2:@url http://sourceforge.net/forum/message.php?msg_id=3332355
#@-node:ekr.20060201161901.1:Postings re undo
#@+node:ekr.20060201152349:NodeUndoer.py
@ignore

<<imports>>
#commanders = util.WeakHashMap()
commanders = {}


class NodeUndoer:
    '''A class that manages NodeUndoerBase instances for tnodes'''
    
    undoers = {} #util.WeakHashMap()
    checksums = util.WeakHashMap()
    
    def __init__( self, c, umenu, rmenu, gtnu, gtnr, vunstack, clearundo ):
        '''c -> a commander
           umenu -> a JMenuItem that is the 'undo' action
           rmenu -> a JMenuItem that is the 'redo' action
           gtnu -> a JMenuItem that is the 'goto next undo' action
           gtnr -> a JMenuItem that is the 'goto next redo' action
           vunstack -> a JMenuItem that is the 'visualise undo stack' action
           clearundo -> a JMenuItem that is the 'clear undo stack' action
        '''
        
        self.c = c
        self.umenu = umenu
        umenu.actionPerformed = lambda event: self.undo()
        self.rmenu = rmenu
        rmenu.actionPerformed = lambda event: self.redo()
        self.gtnu = gtnu
        gtnu.actionPerformed = lambda event: self.gotoNextUndoSpot()
        self.gtnr = gtnr
        gtnr.actionPerformed = lambda event : self.gotoNextRedoSpot()
        self.umanager = None
        self.vunstack = vunstack
        vunstack.actionPerformed = lambda event: self.visualiseUndoStack()
        self.clearundo = clearundo
        clearundo.actionPerformed = lambda event: self.clearUndo()
        self.ignore = 0
        self.tnode = None
        self.compound = None 
        self.checksums_ok = 1
        self.checksum_violations = []
        wm1 = WeakMethod( self, "serializeForLeoFile" ); wm2 = WeakMethod( self, "unserializeFromLeoFile" )
        wm3 = WeakMethod( self, "checkSumViolation" )
        leoPlugins.registerHandler( "write-leo-file-data", wm1 )
        leoPlugins.registerHandler( "read-leo-file-data", wm2 )
        leoPlugins.registerHandler( "checksum-violation", wm3 )
    
    def undo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.undo()
        self.setMenu()
        self.ignore = 0
        return
        
    def redo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.redo()
        self.setMenu()
        self.ignore = 0
        return
        
    
    def setNode( self, p ):
        
        #print "SETTING NODE!!! %s" % t
        #print "FILEINDEX %s" % t.fileIndex
        #java.lang.Thread.dumpStack()
        v = p.v
        t = v.t
        #vid = v.vid
        
        if self.tnode:
            self.checksums[ self.tnode ] = md5.md5( self.tnode.bodyString ).hexdigest()
        
        #if self.undoers.containsKey( t ):
        if self.undoers.has_key( v ):
            #print "CONTAINTS %s" % t
            ua = self.undoers[ v ]
            print "--!!!!!!-- %s" % v
            print ua.__class__
            if ua.__class__ == leoSwingUndo.UndoBase:
                self.umanager = self.undoers[ v ]
                #if self.checksums.containsKey( v ):
                #    checksum = self.checksums[ v ]
                #    amd5 = md5.md5( t.bodyString )
                #    if amd5.hexdigest() != checksum:
                #        self.umanager.discardAllEdits()
                #        g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                #        #self.tnode = t
                #        #return
                #for z in self.umanager.undostack:
                #    commanders[ z ] = self.c
            else:
                print "UNPICKLING!!!!!"
                ua = cPickle.loads( ua )
                print "UNPICKLED Is now %s %s" % ( ua, len( ua.undostack ) )
                self.undoers[ v ] = ua
                self.umanager = ua
            if self.checksums.containsKey( t ):
                checksum = self.checksums[ t ]
                amd5 = md5.md5( t.bodyString )
                if amd5.hexdigest() != checksum:
                    self.umanager.discardAllEdits()
                    print "DISCARDED EDITSS!!!!"
                    g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                    #self.tnode = t
                    #return
            for z in self.umanager.undostack:
                commanders[ z ] = self.c
                                    
        else:
            print "V not in Undoers %s" % v
            #print v.vid
            self.umanager = leoSwingUndo.UndoBase()
            self.undoers[ v ] = self.umanager

        self.tnode = t
        self.setMenu()
        
    def __addUndo( self, undo ):
        #self.umanager.addEdit( undo )
        self.umanager.addUndo( undo )
        #upe = self.UndoableProxyEvent( undo, self.umanager, self, self.c )
        #self.c.undoer.addUndo( upe )
        #die_listeners[ undo ] = upe
        
        
    def addUndo( self, undo ):
        
        if not self.ignore:
            
            if self.compound:
                self.compound.addEdit( undo )
                return
            
            self.__addUndo( undo )                
    
        self.setMenu()
            
    def setMenu( self ):
        
        self.umenu.setText( self.umanager.getUndoPresentationName() )
        self.umenu.setEnabled( self.umanager.canUndo() )
        if self.umanager.canUndo():
            self.gtnu.setEnabled( 1 )
        else:
            self.gtnu.setEnabled( 0 )
        self.rmenu.setText( self.umanager.getRedoPresentationName() )    
        self.rmenu.setEnabled( self.umanager.canRedo() ) 
        if self.umanager.canRedo():
            self.gtnr.setEnabled( 1 )
        else:
            self.gtnr.setEnabled( 0 )
        
        self.c.undoer.setMenu()
               
    
    
    def getUStack( self, tnode ):
            
        if hasattr( tnode, 'unknownAttributes' ):
            uas = tnode.unknownAttributes
        else:
            tnode.unknownAttributes = uas = {}
        
        return uas
        

    def clearUndo( self ):
        
        self.umanager.discardAllEdits()
        self.setMenu()
        
    def gotoNextUndoSpot( self ):
        
        ua = self.umanager.editToBeUndone()
        if ua:
            spot = ua.spot
            self.c.frame.body._current_editor.setCaretPosition( spot )
            return
            
    def gotoNextRedoSpot( self ):
        ua = self.umanager.editToBeRedone()
        if ua:
            spot = ua.spot
            self.c.frame.body._current_editor.setCaretPosition( spot )
            return

    @others
    

                    
<<UndoableDocumentEvent>>
<<UndoableCompoundEvent>>




#@+node:ekr.20060201152349.1:<<imports>>
import java
import java.util as util
import javax.swing as swing
import javax.swing.undo as sundo
import javax.swing.event as sevent
import java.io as io
import jarray
import md5
import org.python.util as putil
import NodeUndoerBase
import LeoCompoundEdit
import leoGlobals as g
import zlib
import leoSwingUndo
import leoPlugins
import leoNodes
import base64
import pickle
import cPickle
from utilities.WeakMethod import WeakMethod
#@nonl
#@-node:ekr.20060201152349.1:<<imports>>
#@+node:ekr.20060201152349.2:visualiseUndoStack
def visualiseUndoStack( self ):
    
    umanager = self.umanager            
    table = swing.JTable( self.UneditableTableModel() )#( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    table.setSelectionMode( swing.ListSelectionModel.SINGLE_SELECTION )
    self.setDataForTable( table )

    
    jd = swing.JDialog()
    jd.setTitle( "Undo Stack" )
    cp = jd.getContentPane()
    cp.add( swing.JScrollPane( table ) )
    bholder = swing.JPanel()
    cp.add( bholder, java.awt.BorderLayout.SOUTH )
    uto = swing.JButton( "Undo To" )
    bholder.add( uto )
    <<_undoTo>>
    uto.actionPerformed = _undoTo
    
    rto = swing.JButton( "Redo To" )
    bholder.add( rto )
    <<_redoTo>>
    rto.actionPerformed = _redoTo
    
        
    jb = swing.JButton( "Close" )
    jb.actionPerformed = lambda event : jd.dispose()
    bholder.add( jb )
    jd.pack()
    g.app.gui.center_dialog( jd )
    jd.setModal( 1 )
    jd.show()
    
    
#@+node:ekr.20060201152349.3:<<_undoTo>>
def _undoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canUndo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Undo To This Point", 
                                            "Illegal Undo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
    self.ignore = 1
    umanager.undoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
#@-node:ekr.20060201152349.3:<<_undoTo>>
#@+node:ekr.20060201152349.4:<<_redoTo>>
def _redoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canRedo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Redo To This Point", 
                                            "Illegal Redo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
        
    self.ignore = 1
    umanager.redoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
    
#@-node:ekr.20060201152349.4:<<_redoTo>>
#@-node:ekr.20060201152349.2:visualiseUndoStack
#@+node:ekr.20060201152349.5:buildTableData
def buildTableData( self ):
    
    data = util.Vector()
    editu = self.umanager.editToBeUndone()
    editr = self.umanager.editToBeRedone()
    umanager = self.umanager
    cu = cr = -1
    edits = umanager.getEdits()
    for z in edits:
        if z.__class__ == LeoCompoundEdit:
            vec = java.util.Vector()
            edits2 = z.getEdits()
            spot = edits2[ 0 ].spot
            vec.add( spot )
            vec.add( "?" )
            vec.add( z.getPresentationName() )
            vec.add( "" )
        else:
            vec = z.getForTableModel()
            
        if z is editu:
            vec.set( 3, 'current undo' )
            cu = edits.indexOf( z )
        elif z.canUndo():
            vec.set( 3, 'undo' )
        if z is editr:
            vec.set( 3, 'current redo' )
            cr = edits.indexOf( z )
        elif z.canRedo():
            vec.set( 3, 'redo' )
        data.add( vec )
    
    return data, cu, cr


#@-node:ekr.20060201152349.5:buildTableData
#@+node:ekr.20060201152349.6:setDataForTable
def setDataForTable( self, table ):
    
    data, cu, cr = self.buildTableData()
    dm = table.getModel()
    dm.setDataVector( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    lsm = table.getSelectionModel()
    if cu != -1:
        lsm.setLeadSelectionIndex( cu )
    elif cr != -1:
        lsm.setLeadSelectionIndex( cr )
        
    
#@nonl
#@-node:ekr.20060201152349.6:setDataForTable
#@+node:ekr.20060201152349.7:pickle and unpickle
def serializeForLeoFile( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c:
        nwundoers = {}
        for z in self.undoers:
            if  self.undoers[ z ].__class__ == leoSwingUndo.UndoBase:
                nwundoers[ z.vid ] = cPickle.dumps( self.undoers[ z ] )
            else:
                nwundoers[ z.vid ] = self.undoers[ z ]
                
        store.addData( "tundoer", nwundoers ) #the storage class does the rest of the work for us
        

def unserializeFromLeoFile( self, tag, *args, **kwords ):

    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c and self.checksums_ok:
        try:
            udata = store.getData( "tundoer" )
            if udata:
                for z in udata:
                    if leoNodes.vid_vnode.has_key( z ):
                        #print "A connection %s %s" % ( z, leoNodes.vid_vnode[ z ] )
                        v = leoNodes.vid_vnode[ z ]
                        self.undoers[ v ] = udata[ z ]

        except:
            self.undostack = []
            self.undopointer = 0

    if not self.checksums_ok:
        self.checksums_ok = 1
        self.checksum_violations = []
        self.undostack = []
        self.undopointer = 0
        
#@-node:ekr.20060201152349.7:pickle and unpickle
#@+node:ekr.20060201152349.8:checkSumViolation
def checkSumViolation( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    filename = args[ 0 ][ 'filename' ]
    if c == self.c:
        self.checksums_ok = 0
        self.checksum_violations.append( filename )
#@nonl
#@-node:ekr.20060201152349.8:checkSumViolation
#@+node:ekr.20060201152349.9:startCompounding stopCompounding
def startCompounding( self, name ):
    self.compound = UndoableCompoundEvent( name )
    #self.compound = LeoCompoundEdit( name )
        
def stopCompounding( self ):
        
    compound = self.compound
    compound.end()
    self.compound = None
    #print "COMPOUND is %s" % compound
    self.__addUndo( compound )
    self.setMenu()
#@-node:ekr.20060201152349.9:startCompounding stopCompounding
#@+node:ekr.20060201152349.10:infrastructure
@others
#@nonl
#@+node:ekr.20060201152349.11:UneditableTableModel
class UneditableTableModel( swing.table.DefaultTableModel ):
    
    def __init__( self ):
        swing.table.DefaultTableModel.__init__( self )
        
    def isCellEditable( self, row, column ):
        return 0
        
#@-node:ekr.20060201152349.11:UneditableTableModel
#@+node:ekr.20060201152349.12:PickleProxy
class PickleProxy:
    '''This class exists to pickle the NodeUndoerBase instance into a form
       that can be safely stored in a Leo ua.'''
       
    def __init__( self, undoer, t ):
        self.undoer = undoer
        self.t = t
            
    def getPickleProxy( self ):
        
      
        try:
            #array = self.undoer.serializeSelf()
            data = pickle.dumps( self.undoer )
            ds = len( data )
            pp = zlib.compress( data, level = 9 )
            ps = len( pp )
            amd5 = md5.md5( self.t.bodyString )
            checksum = amd5.hexdigest()
            return pp, checksum 
        except Exception, x:
            return "", ""  
#@-node:ekr.20060201152349.12:PickleProxy
#@-node:ekr.20060201152349.10:infrastructure
#@+node:ekr.20060201152349.13:UndoableProxyEvent
class UndoableProxyEvent( sundo.UndoableEdit ):

       
    def __init__( self, event, owner, master , c):
        
        self.event = event
        self.owner = owner
        self.master = master
        self.c = c
        self.cp = c.currentPosition().copy()
        self._can_undo = event.canUndo()
        self._can_redo = event.canRedo()
        self.can_undo = self._can_undo
        self.can_redo = self._can_redo
        self.dieable = 0
        self.ignore = 0
        
    
    def __canRedo( self ):
        return self._can_redo == self.event.canRedo()
        
    def __canUndo( self ):
        return self._can_undo == self.event.canUndo()
            
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        #if self.__canUndo():
        return self.can_redo
        #else:
        #    return self.event.canRedo()
        
    def canUndo( self ):
        #if self.__canRedo():
        return self.can_undo
        #else:
        #    return self.event.canUndo()
        
    def isAlive( self ):
        return self.can_redo or self.can_undo
    
    def invalidate( self ):
        self.c.undoer.killFromEvent( self )
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
        #edits = self.owner.getEdits()
        #spot = edits.indexOf( self.event )
        #self.owner.trimEdits( spot, edits.size() )
    
        
    def getPresentationName( self ):
        return self.event.getPresentationName()
        
    def getRedoPresentationName( self ):
        
        if self.__canRedo():
            return self.event.getRedoPresentationName()
        elif self.isAlive():
            return "Expended %s" % self.event.getRedoPresentationName()
        else:
            return "Dead %s" % self.event.getRedoPresentationName()
        
    def getUndoPresentationName( self ):
        
        if self.__canUndo():
            return self.event.getUndoPresentationName()
        elif self.isAlive():
            return "Expended %s" % self.event.getUndoPresentationName()
        else:
            return "Dead %s" % self.event.getUndoPresentationName()
        
        
    def isSignificant( self ):
        return 1
    
    def sync( self ):
        self._can_redo = self.event.canRedo()
        self._can_undo = self.event.canUndo()
        
    def redo( self ):
        
        self.c.selectPosition( self.cp.copy() )
        self.can_redo = 0
        self.can_undo = 1
        if self.__canRedo():
            self.master.ignore = 1
            if not self.ignore:
                self.owner.redo()
            self.master.ignore = 0
            self.master.setMenu()
            
        self.sync()
            
        
    def undo( self ):
        
        self.c.selectPosition( self.cp.copy() )
        self.can_undo = 0
        self.can_redo = 1
        if self.__canUndo():
            self.master.ignore = 1
            if not self.ignore:
                self.owner.undo()
            self.master.ignore = 0
            self.master.setMenu()
            
        self.sync()
        
    def replaceEdit( self, edit ):
        return 0
        

#@-node:ekr.20060201152349.13:UndoableProxyEvent
#@+node:ekr.20060201152349.14:<<UndoableDocumentEvent>>
class UndoableDocumentEvent3:#( sundo.UndoableEdit, io.Serializable ):
    '''A class that takes the current Editors document and does undo changes
       upon the data within the Editor.  It is assumed that the data in the document
       will be in sync with the changes represented within the UndoableDocumentEvent'''
       
    def __init__( self, c, event, txt = "" ):
        
        commanders[ self ] = c
        self.spot = event.getOffset()
        self.length = event.getLength()
        self.txt = txt

        self.can_undo = 1
        self.can_redo = 0
        if self.txt.isspace():
           name_txt = "%s whitespaces" % len( self.txt )
        else:
           name_txt = self.txt
        
        if event.getType() == sevent.DocumentEvent.EventType.INSERT:
            self.etype = "insert"
        elif event.getType() == sevent.DocumentEvent.EventType.REMOVE:
            self.etype = "remove"

            
            
        if self.etype == "insert":
            self.name = "insert %s" % name_txt  
        elif self.etype == "remove":
            self.name = "remove %s" % name_txt
    
    #def __getstate__( self ):
    #    dic = self.__dict__
    #    import copy
    #    rv = copy.copy( dic )
    #    #del rv[ c ]
    #    return rv        
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
        #if die_listeners.has_key( self ):
        #    dlistener = die_listeners[ self ]
        #    if dlistener.dieable:
        #        print "WHACKING %s" % dlistener
        #        dlistener.invalidate()
    
        
    def getPresentationName( self ):
        return self.name 
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        
    def redo( self ):
        
        self.can_redo = 0
        self.can_undo = 1
        self.redoEvent()
        
    def undo( self ):
        
        self.can_undo = 0
        self.can_redo = 1
        self.undoEvent()
        
    def replaceEdit( self, edit ):
        return 0
        
    def redoEvent( self ):
        
        c = commanders.get( self )
        doc = c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            doc.insertString( self.spot, self.txt, None )
            return       
        elif self.etype == "remove":            
            doc.remove( self.spot, self.length )
            return    
        
    def undoEvent( self ):
        

        c = commanders.get( self )                
        doc = c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            print 'undoing spot %s %s %s' % ( self.spot, self.length, self.txt )
            doc.remove( self.spot, self.length )
            print 'undone %s' % self
            return  
        elif self.etype == "remove":
            doc.insertString( self.spot, self.txt, None )
            return 

    def getForTableModel( self ):
        return util.Vector( [ self.spot, self.txt, self.name, '' ] )
        


#@-node:ekr.20060201152349.14:<<UndoableDocumentEvent>>
#@+node:ekr.20060201152349.15:<<UndoableCompoundEvent>>
class UndoableCompoundEvent3:
    
    def __init__( self, pname ):
        #self.ce = sundo.CompoundEdit()
        self.pname = pname
        self.undostack = []
        self.can_undo = 1
        self.can_redo = 0
        
    def getPresentationName( self ):
        return self.pname
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.pname
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.pname
        
    def canUndo( self ):
        return self.can_undo
        #return self.ce.canUndo()
        
    def canRedo( self ):
        return self.can_redo
        #return self.ce.canRedo()
        
    def undo( self ):
        for z in self.undostack:
            print z
            z.undo()
        self.can_undo = 0
        self.can_redo = 1
        
    def redo( self ):
        
        self.undostack.reverse()
        for z in self.undostack:
            print z
            z.redo()
        
        self.undostack.reverse()
        self.can_undo = 1
        self.can_redo = 0
        
    def isSignificant( self ):
        return 1
        #return self.ce.isSignificant()
        
    def addEdit( self, edit ):
        self.undostack.insert( 0, edit )
        

    
    def die( self ):
        pass
        #return self.ce.die()
        
    def end( self ):
        pass
        #return self.ce.end()
        
        

            
        

#@-node:ekr.20060201152349.15:<<UndoableCompoundEvent>>
#@-node:ekr.20060201152349:NodeUndoer.py
#@-node:ekr.20060228072202:New undoer
#@-node:ekr.20060227163504.3:Important
#@+node:ekr.20060227163911.1:Leo's web site
@nocolor

- Put more screen shots on Leo's web site.
- Put complete slide show on Leo's web site.
#@nonl
#@-node:ekr.20060227163911.1:Leo's web site
#@-node:ekr.20060226131603:To do 4.4 b4
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
