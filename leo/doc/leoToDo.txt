#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@@nocolor

#@+all
#@+node:EKR.20040430163619:To do: 4.2
#@+node:ekr.20040702064435:(Fix problem with xml parsing)
@nocolor
@language html
https://sourceforge.net/forum/message.php?msg_id=2645776
By: billp9619

Yes this works now. However, the opposite should also be true ...that instead
of <find_string></find_string> an outside process or editor is free to change
it to <find_string/>. This currently causes Leo to fail to load the file reprting
it was looking for </find_string>.

This is original Leo xml:

@color
<preferences>
</preferences>
<find_panel_settings>
<find_string></find_string>
<change_string></change_string>
</find_panel_settings>
@nocolor

My xml editor automatically changed it to this:

@color
<preferences/>
<find_panel_settings>
<find_string/>
<change_string/>
</find_panel_settings>
@nocolor

Leo will not load the edited "/>" type empty tags. 

Both forms of empty tags should always be accepted because it is officially
identical in meaning for xml.
#@nonl
#@-node:ekr.20040702064435:(Fix problem with xml parsing)
#@+node:EKR.20040506075328.3:(Perfect Import)
#@+node:EKR.20040506091116: Notes
@nocolor

2.  Write a _virtual output file_ to a string.  This is easily done:  we pass a file-like-object to Leo's atFile.write routines.  This virtual file will have @file-thin sentinels.  In other words, the virtual file will specify _all_ aspects of the structure of the newly imported outline.

3.  Convert the string got by writing the virtual output file to a list of lines.  This will become the fat_lines argument.

The strategy is simple:  we want to make corrections to fat_lines using Bernhard's algorithm.  If in fact the fat_lines has changed, we will delete root's outline and recreate the outline using the atFile.read code applied to the virtual output file, i.e., fat_lines.

4.  Set i_lines to the contents of the virtual output file (fat_lines) stripped of sentinels.  Set j_lines to the lines of the original imported file.  As stated above, set fat_lines to the lines of the virtual output file.  Call propagateDiffsToSentinelsLines to update fat_lines to make it equivalent to the original imported file.  Replace root's outline if a real change has happened.
#@-node:EKR.20040506091116: Notes
#@+node:ekr.20040414093055: Shadow files plugin
@nocolor

https://sourceforge.net/forum/message.php?msg_id=2521345
By: bwmulder

I am working on a plugin which works with shadow files in a Leo subdirectory.

This is really the same code posted integrated with Leo. New is that
the goto linenumber command works properly as well.

The new code only kicks in if:
   - A leo subdirectory exists, and
   - both directories contain the file in question.
   
To get things started, create a Leo subdirectory, move the source
files there, and then create zero length strings instead of the moved
files. Whenever you change something in the sourcefile, both files
will be brought up to date automatically.

In the future, I might provide a script which provides this initial
setup automatically.

Implementation notes (relative to 4.1):

In order to use this mechanism to annotate foreign code, I am missing
two pieces:
   
   - The import command should import the source *exactly*.
   - I would like to add comments to the source which are *not* output into
source,
     and live in Leo only (or the shadowfile under Leo sentinel comments).
     
I changed the "message_comment" function to do nothing.

I do not think that this function is a good idea, since Leo can not know
if the line structure in a comment.

There might be more to do in this area.

It seems that I can get around the second limitation by writing "//@"
at the beginning of the line in the code sections, since this is
filtered away by the plugin.

Is there some other way to put comments only in the Leo document, but
not in the derived file?

I had to copy quite a bit of source code for the gotolinenr
command. It probably won't work for the next version of Leo

It seems that Leo somewhat encourages a coding style with long
routines, since complexity can be tugged away into subnodes rather
than creating functions to structure the code.

For the read and write command, I decided to inject a new "open"
function into the global namespace of leoAtFile.py. This function
checks if the caller is the read or write function of leoAtFile.py. In
this case, some special processing for synchronization is done.

I did this strange programming since I did not want to copy large
amounts of code and just add a few lines.

Currently the script works for C and python files. It looks at the
file extension to determine if C or python type annotations are
used. Maybe this information can be centralized.
#@-node:ekr.20040414093055: Shadow files plugin
#@+node:EKR.20040504150046:class mulderUpdateAlgorithm (leoGlobals)
import difflib,shutil

class mulderUpdateAlgorithm:
    
    """A class to update derived files using
    diffs in files without sentinels."""
    
    @others
    
def doMulderUpdateAlgorithm(sourcefilename,targetfilename):

    mu = mulderUpdateAlgorithm()

    mu.pull_source(sourcefilename,targetfilename)
    mu.copy_time(targetfilename,sourcefilename)
#@nonl
#@+node:EKR.20040505103527:TO DO
@

- is_sentinel is not strictly correct.  There must be an atFile method that does the job absolutely correctly.

- Similarly, marker_from_extension can probably be replaced by a call to some method in leoGlobals.py.
#@-node:EKR.20040505103527:TO DO
#@+node:EKR.20040504150046.3:__init__
def __init__ (self,testing=False,verbose=False):
    
    self.testing = testing
    self.verbose = False
    self.do_backups = False
#@nonl
#@-node:EKR.20040504150046.3:__init__
#@+node:EKR.20040504150046.9:copy_sentinels
@ This script retains _all_ sentinels.  If lines are replaced, or deleted,
we restore deleted sentinel lines by checking for gaps in the mapping.
@c

def copy_sentinels (self,write_lines,fat_lines,fat_pos,mapping,startline,endline):
    """
    
    Copy sentinel lines from fat_lines to write_lines.

    Copy all sentinels _after_ the current reader postion up to,
    but not including, mapping[endline].

    """

    j_last = mapping[startline]
    i = startline + 1
    while i <= endline:
        j = mapping[i]
        if j_last + 1 != j:
            fat_pos = j_last + 1
            # Copy the deleted sentinels that comprise the gap.
            while fat_pos < j:
                line = fat_lines[fat_pos]
                write_lines.append(line)
                if self.testing and self.verbose: print "Copy sentinel:",fat_pos,line,
                fat_pos += 1
        j_last = j ; i += 1

    fat_pos = mapping[endline]
    return fat_pos
#@nonl
#@-node:EKR.20040504150046.9:copy_sentinels
#@+node:EKR.20040504155109:copy_time
def copy_time(self,sourcefilename,targetfilename):
    
    """
    Set the target file's modification time to
    that of the source file.
    """

    st = os.stat(sourcefilename)
    if hasattr(os, 'utime'):
        os.utime(targetfilename, (st.st_atime, st.st_mtime))
    elif hasattr(os, 'mtime'):
        os.mtime(targetfilename, st.st_mtime)
    else:
        g.trace("Can not set modification time")
#@nonl
#@-node:EKR.20040504155109:copy_time
#@+node:EKR.20040504150046.6:create_mapping
def create_mapping (self,lines,marker):
    """

    'lines' is a list of lines of a file with sentinels.
 
    Returns:

    result: lines with all sentinels removed.

    mapping: a list such that result[mapping[i]] == lines[i]
    for all i in range(len(result))

    """

    mapping = [] ; result = []
    for i in xrange(len(lines)):
        line = lines[i]
        if not self.is_sentinel(line,marker):
            result.append(line)
            mapping.append(i)

    # Create a last mapping entry for copy_sentinels.
    mapping.append(i)

    return result, mapping
#@nonl
#@-node:EKR.20040504150046.6:create_mapping
#@+node:EKR.20040504154039:is_sentinel NOT CORRECT
def is_sentinel (self,line,marker):
    
    """
    Check if line starts with a sentinel comment.
    """
    
    return line.lstrip().startswith(marker)
#@-node:EKR.20040504154039:is_sentinel NOT CORRECT
#@+node:EKR.20040504150046.4:marker_from_extension
def marker_from_extension(self,filename):
    """
    Tries to guess the sentinel leadin
    comment from the filename extension.
    
    This code should probably be shared
    with the main Leo code.
    """
    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
    if ext in ('.h', '.c'):
        marker = "//@"
    elif ext in (".py", ".cfg", ".bat", ".ksh"):
        marker = "#@"
    else:
        g.trace("unknown extension %s" % ext)
        marker = None

    return marker
#@nonl
#@-node:EKR.20040504150046.4:marker_from_extension
#@+node:EKR.20040505080156:Get or remove sentinel lines
# These routines originally were part of push_filter & push_filter_lines.
#@nonl
#@+node:EKR.20040505081121:separateSentinelsFromFile/Lines
def separateSentinelsFromFile (self,filename):
    
    """Separate the lines of the file into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the file."""
    
    lines = file(filename).readlines()
    marker = self.marker_from_extension(filename)
    
    return self.separateSentinelsFromLines(lines,marker)
    
def separateSentinelsFromLines (self,lines,marker):
    
    """Separate lines (a list of lines) into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the original list."""
    
    strippedLines = self.removeSentinelsFromLines(lines,marker)
    sentinelLines = self.getSentinelsFromLines(lines,marker)
    
    return strippedLines,sentinelLines
#@nonl
#@-node:EKR.20040505081121:separateSentinelsFromFile/Lines
#@+node:EKR.20040505080156.2:removeSentinelsFromFile/Lines
def removeSentinelsFromFile (self,filename):
    
    """Return a copy of file with all sentinels removed."""
    
    lines = file(filename).readlines()
    marker = self.marker_from_extension(filename)
    
    return removeSentinelsFromLines(lines,marker)
    
def removeSentinelsFromLines (self,lines,marker):

    """Return a copy of lines with all sentinels removed."""
    
    return [line for line in lines if not self.is_sentinel(line,marker)]
#@nonl
#@-node:EKR.20040505080156.2:removeSentinelsFromFile/Lines
#@+node:EKR.20040505080156.3:getSentinelsFromFile/Lines
def getSentinelsFromFile (self,filename,marker):
    
    """Returns all sentinels lines in a file."""
    
    lines = file(filename).readlines()
    marker = self.marker_from_extension(filename)

    return getSentinelsFromLines(lines,marker)
    
def getSentinelsFromLines (self,lines,marker):
    
    """Returns all sentinels lines in lines."""
    
    return [line for line in lines if self.is_sentinel(line,marker)]
#@nonl
#@-node:EKR.20040505080156.3:getSentinelsFromFile/Lines
#@-node:EKR.20040505080156:Get or remove sentinel lines
#@+node:EKR.20040504150046.10:propagateDiffsToSentinelsFile
def propagateDiffsToSentinelsFile(self,sourcefilename,targetfilename):
    
    << init propagateDiffsToSentinelsFile vars >>
    
    write_lines = self.propagateDiffsToSentinelsLines(
        i_lines,j_lines,fat_lines,mapping)
        
    # Update _source_ file if it is not the same as write_lines.
    written = self.write_if_changed(write_lines,targetfilename,sourcefilename)
    if written:
        << paranoia check>>
#@nonl
#@+node:EKR.20040504150046.11:<< init propagateDiffsToSentinelsFile vars >>
# Get the sentinel comment marker.
marker = self.marker_from_extension(sourcefilename)
if not marker:
    return

try:
    # Create the readers.
    sfile = file(sourcefilename)
    tfile = file(targetfilename)
    
    fat_lines = sfile.readlines() # Contains sentinels.
    j_lines   = tfile.readlines() # No sentinels.
    
    i_lines,mapping = self.create_mapping(fat_lines,marker)
    
    sfile.close()
    tfile.close()
except:
    g.es_exception("can not open files")
    return
#@nonl
#@-node:EKR.20040504150046.11:<< init propagateDiffsToSentinelsFile vars >>
#@+node:EKR.20040504150046.12:<<paranoia check>>
# Check that 'push' will re-create the changed file.
strippedLines,sentinel_lines = self.separateSentinelsFromFile(sourcefilename)

if strippedLines != j_lines:
    self.report_mismatch(strippedLines, j_lines,
        "Propagating diffs did not work as expected",
        "Content of sourcefile:",
        "Content of modified file:")

# Check that no sentinels got lost.
fat_sentinel_lines = self.getSentinelsFromLines(fat_lines,marker)

if sentinel_lines != fat_sentinel_lines:
    self.report_mismatch(sentinel_lines,fat_sentinel_lines,
        "Propagating diffs modified sentinel lines:",
        "Current sentinel lines:",
        "Old sentinel lines:")
#@nonl
#@-node:EKR.20040504150046.12:<<paranoia check>>
#@-node:EKR.20040504150046.10:propagateDiffsToSentinelsFile
#@+node:EKR.20040504145804.1:propagateDiffsToSentinelsLines
def propagateDiffsToSentinelsLines (self,i_lines,j_lines,fat_lines,mapping):
    
    """Compare the 'i_lines' with 'j_lines' and propagate the diffs back into
    'write_lines' making sure that all sentinels of 'fat_lines' are copied.

    i/j_lines have no sentinels.  fat_lines does."""

    << init propagateDiffsToSentinelsLines vars >>
    << copy the sentinels at the beginning of the file >>
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        if testing:
            if verbose: print
            print "Opcode %7s %3d %3d %3d %3d" % (tag,i1,i2,j1,j2)
            if verbose: print
        << update and check the loop invariant >>
        if tag == 'equal':
            << handle 'equal' tag >>
        elif tag == 'replace':
            << handle 'replace' tag >>
        elif tag == 'delete':
            << handle 'delete' tag >>
        elif tag == 'insert':
            << handle 'insert' tag >>
        else: assert 0,"bad tag"
    << copy the sentinels at the end of the file >>
    return write_lines
#@nonl
#@+node:EKR.20040504145804.2:<< init propagateDiffsToSentinelsLines vars >>
# Indices into i_lines, j_lines & fat_lines.
i_pos = j_pos = fat_pos = 0

# These vars check that all ranges returned by get_opcodes() are contiguous.
i2_old = j2_old = -1

# Create the output lines.
write_lines = []

matcher = difflib.SequenceMatcher(None,i_lines,j_lines)

testing = self.testing
verbose = self.verbose
#@nonl
#@-node:EKR.20040504145804.2:<< init propagateDiffsToSentinelsLines vars >>
#@+node:EKR.20040504145804.3:<< copy the sentinels at the beginning of the file >>
while fat_pos < mapping[0]:
    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing and verbose: print "copy initial line",fat_pos,line,
    fat_pos += 1
#@nonl
#@-node:EKR.20040504145804.3:<< copy the sentinels at the beginning of the file >>
#@+node:EKR.20040504145804.4:<< update and check the loop invariant>>
# We need the ranges returned by get_opcodes to completely cover the source lines being compared.
# We also need the ranges not to overlap.

assert(i2_old in (-1,i1))
assert(j2_old in (-1,j1))

i2_old = i2 ; j2_old = j2

# Check the loop invariants.
assert i_pos == i1
assert j_pos == j1
assert fat_pos == mapping[i1]

if 0: # not yet.
    if testing: # A bit costly.
        t_sourcelines,t_sentinel_lines = push_filter_lines(write_lines, marker)
        # Check that we have all the modifications so far.
        assert t_sourcelines == j_lines[:j1],"t_sourcelines == j_lines[:j1]"
        # Check that we kept all sentinels so far.
        assert t_sentinel_lines == push_filter_lines(fat_lines[:fat_pos], marker)[1]
#@nonl
#@-node:EKR.20040504145804.4:<< update and check the loop invariant>>
#@+node:EKR.20040504145804.5:<< handle 'equal' tag >>
# Copy the lines, including sentinels.
while fat_pos <= mapping[i2-1]:
    line = fat_lines[fat_pos]
    if 0: # too verbose.
        if testing: print "Equal: copying ", line,
    write_lines.append(line)
    fat_pos += 1

if testing and verbose:
    print "Equal: synch i", i_pos,i2
    print "Equal: synch j", j_pos,j2

i_pos = i2
j_pos = j2

# Copy the sentinels which might follow the lines.       
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i2-1,i2)
#@nonl
#@-node:EKR.20040504145804.5:<< handle 'equal' tag >>
#@+node:EKR.20040504145804.6:<< handle 'replace' tag >>
@ Replace lines that may span sentinels.

For now, we put all the new contents after the first sentinel.

A more complex approach: run the difflib across the different lines and try to
construct a mapping changed line => orignal line.
@c

while j_pos < j2:
    line = j_lines[j_pos]
    if testing:
        print "Replace i:",i_pos,repr(i_lines[i_pos])
        print "Replace j:",j_pos,repr(line)
        i_pos += 1

    write_lines.append(line)
    j_pos += 1

i_pos = i2

# Copy the sentinels which might be between the changed code.         
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)
#@nonl
#@-node:EKR.20040504145804.6:<< handle 'replace' tag >>
#@+node:EKR.20040504145804.7:<< handle 'delete' tag >>
if testing and verbose:
    print "delete: i",i_pos,i1
    print "delete: j",j_pos,j1

j_pos = j2
i_pos = i2

# Restore any deleted sentinels.
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)
#@nonl
#@-node:EKR.20040504145804.7:<< handle 'delete' tag >>
#@+node:EKR.20040504145804.8:<< handle 'insert' tag >>
while j_pos < j2:
    line = j_lines[j_pos]
    if testing: print "Insert:", line,
    write_lines.append(line)
    j_pos += 1

# The input streams are already in synch.
#@nonl
#@-node:EKR.20040504145804.8:<< handle 'insert' tag >>
#@+node:EKR.20040504145804.9:<< copy the sentinels at the end of the file >>
while fat_pos < len(fat_lines):
    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing and verbose: print "Append last line",line
    fat_pos += 1
#@nonl
#@-node:EKR.20040504145804.9:<< copy the sentinels at the end of the file >>
#@-node:EKR.20040504145804.1:propagateDiffsToSentinelsLines
#@+node:EKR.20040504150046.5:report_mismatch
def report_mismatch (self,lines1,lines2,message,lines1_message,lines2_message):

    """
    Generate a report when something goes wrong.
    """

    print '='*20
    print message
    
    if 0:
        print lines1_message
        print '-'*20
        for line in lines1:
          print line,
         
        print '='*20
    
        print lines2_message
        print '-'*20
        for line in lines2:
            print line,
#@nonl
#@-node:EKR.20040504150046.5:report_mismatch
#@+node:EKR.20040504160820:write_if_changed
def write_if_changed(self,lines,sourcefilename,targetfilename):
    """
    
    Replaces target file if it is not the same as 'lines',
    and makes the modification date of target file the same as the source file.
    
    Optionally backs up the overwritten file.

    """
    
    copy = not os.path.exists(targetfilename) or lines != file(targetfilename).readlines()
        
    if self.testing:
        if copy:
            print "Writing",targetfilename,"without sentinals"
        else:
            print "Files are identical"

    if copy:
        if self.do_backups:
            << make backup file >>
        outfile = open(targetfilename, "w")
        for line in lines:
            outfile.write(line)
        outfile.close()
        self.copy_time(sourcefilename,targetfilename)
    return copy
#@+node:EKR.20040504160820.1:<< make backup file >>
if os.path.exists(targetfilename):
    count = 0
    backupname = "%s.~%s~" % (targetfilename,count)
    while os.path.exists(backupname):
        count += 1
        backupname = "%s.~%s~" % (targetfilename,count)
    os.rename(targetfilename, backupname)
    if testing:
        print "backup file in ", backupname
#@nonl
#@-node:EKR.20040504160820.1:<< make backup file >>
#@-node:EKR.20040504160820:write_if_changed
#@-node:EKR.20040504150046:class mulderUpdateAlgorithm (leoGlobals)
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.
    
    The caller is responsible for handling newlines correctly."""

    def __init__(self): self.list = []
    def clear (self):   self.list = []

    def close (self): pass
    def flush (self): pass

    def get (self):
        return string.join(self.list,'')

    def write (self,s):
        if s: self.list.append(s)
#@nonl
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files,treeType):

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.treeType = treeType
    c.beginUpdate()
    if 1: # range of update...
        if len(files) == 2:
            << Create a parent for two files having a common prefix >>
        for fileName in files:
            v = self.createOutline(fileName,current)
            self.perfectImport(fileName,v)
            if v: # 8/11/02: createOutline may fail.
                g.es("imported " + fileName)
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    c.endUpdate()
    c.selectVnode(current)
#@nonl
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@nonl
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@+node:EKR.20040506075328.2:perfectImport
def perfectImport (self,fileName,p):
    
    return ### not ready yet.

    g.trace(fileName,p)
    
    << write p to a virtual thin derived file s >>
    if not s: return
    
    mu = g.mulderUpdateAlgorithm(testing=True)
    marker = mu.marker_from_extension(fileName)

    fat_lines = s.splitlines(True) # Keep line endings.
    
    i_lines,mapping = mu.create_mapping(fat_lines,marker)
    j_lines = file(fileName).readlines()
    
    if i_lines != j_lines:
        g.trace("correcting import")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        << replace root's tree using write_lines >>
    else:
        g.trace("imported lines are perfect")
#@+node:EKR.20040506105049:<< write p to a virtual thin derived file s >>
try:
    df = self.c.atFileCommands.new_df
    df.targetFileName = "<virtual-file>"
    df.outputFile = fo = g.fileLikeObject()
    df.writeOpenFile(p)
    s = fo.get()
except:
    g.es("Exception in Perfect Import (write)")
    g.es_exception()
    s = None
#@-node:EKR.20040506105049:<< write p to a virtual thin derived file s >>
#@+node:EKR.20040506115229:<< replace root's tree using write_lines >>
if 0: # Not ready yet.

    # Remove all of root's tree.
    while p.hasChildren():
        child = p.firstChild()
        child.doDelete(p)
        
    p.setBodyStringOrPane("")

    try:
        df = self.c.atFileCommands.new_df
        df.targetFileName = "<virtual-file>"
        df.inputFile = fo = g.fileLikeObject()
        fo.set(string.join(write_lines))
        df.readOpenFile(p)
    except:
        g.es("Exception in Perfect Import (read)")
        g.es_exception()
        s = None
#@nonl
#@-node:EKR.20040506115229:<< replace root's tree using write_lines >>
#@-node:EKR.20040506075328.2:perfectImport
#@-node:EKR.20040506075328.3:(Perfect Import)
#@+node:EKR.20040503160843:@directory-import (Generalization of @import)
#@-node:EKR.20040503160843:@directory-import (Generalization of @import)
#@+node:EKR.20040422132037:Linux bugs 4
@nocolor
#@nonl
#@+node:EKR.20040422132037.4:config problem on Linux
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2373816
By: sbeards

A related issue is that leoConfig.txt gets auto-tangled and overwritten on startup.
This will be a problem if Leo is run by a non-root user or the file is not readable.
For example, I get the following traceback after starting Leo (when leoConfig.txt
is read-only):

Traceback (most recent call last):
  File "/usr/local/share/leo-4.1-rc3/src/leoConfig.py", line 672, in update
    cf = open(self.configFileName,mode)
IOError: [Errno 13] Permission denied:
'/usr/local/share/leo-4.1-rc3/src/../config/leoConfig.txt'

Is there a reason leoConfig.txt gets auto-tangled on startup? Is there anyway
to disable this? Is this by design?
#@-node:EKR.20040422132037.4:config problem on Linux
#@+node:EKR.20040422132037.5:Backspace problems on Linux
Shift+Ctrl+BkSp doesn't delete node   
#@nonl
#@+node:EKR.20040422132037.6:Dave Hein: fix
By: dthein ( Dave Hein ) 
 RE: BUG: Shift+Ctrl+BkSp doesn't delete node   
2004-01-15 03:30  

 OK, the cause of the keymapping problem is a issue with the X11 keyboard mapping, not with Tk.

If you have this problem on your system, issue the command:

xmodmap -pke 

and look in the results for the line for keycode 22. I'll bet it shows something like:

keycode 22 = BackSpace Terminate_Server

That second token ("Terminate_Server") is what is supposed to be mapped to Shift-Backspace. You want this second token to be either not present or to be BackSpace.

To fix this, create a file (e.g. .Xmodmap) and give it the content:

keycode 22 = BackSpace

then run the command:

xmodmap .Xmodmap

And you'll have fixed the problem.

Now, on my system this also disables the ability to terminate the X server using Ctrl-Alt-BackSpace ... this is because of some conflict with xdb (xdb is the newer keyboard mapping facility in XFree86 ... xmodmap is the old original X11 keyboard mapping facility). I'm still working on that.

I'm also not able to get xmodmap to make this change during X11 startup (again because of conflicts with xdb). But I'm working on that as well.
#@nonl
#@-node:EKR.20040422132037.6:Dave Hein: fix
#@-node:EKR.20040422132037.5:Backspace problems on Linux
#@+node:EKR.20040422132037.7:Bug: vpython and mac
Jon Schull <jschull@softlock.com>  
Date:  2003/12/30 Tue PM 05:50:51 EST 
To:  edreamleo@charter.net 
Subject:  Leo, Mac OS X 10.3, and VPython 
             
I've been evaluating leo or vpython programming on  Mac OS X 10.3, and 
have some observations and a suggestion.

Observations.
		Leo runs under X11 as well as under OS X.
		My X11 python configuration was created using the recipe at XXX 
(which enables vpython).
		The OS X configuration is vanilla MacPython from MacPython.org, along 
with AquaTclTk batteries included XXX.
		In both environments I can run leo under python leo.py and under idle.
		Under OS X we get font smoothing, but we can't run visual python 
programs (python crashes;  this is a known incompatibility with 
MacPython.)
	
		Under X11 we can run visual python programs like this one
			#box.py
			from visual import *
			box()
			
    And we can even run them under leo (under X11). HOWEVER, when the 
visual python program is terminated, leo vanishes (leo and the vp 
program apparently run in the same space)
	
	Under x11, we can keep leo alive by putting the vp program in its own 
space:
	
		os.popen3('/sw/bin/python /Users/jis/box.py')
	
	However,  this doesn't let us see the output of stderr and stdout.  
Those text streams are available...
		
		def do(cmd='ls'):
			from os import popen3
			pIn,pOut,pErr=0,1,2
			popenResults=popen3(cmd)
			print popenResults[pOut].read()
			print popenResults[pErr].read()
		
		import os	
		do('/sw/bin/python /Users/jis/box.py')
		
	...but only when the vpython program terminates.
	
	Here's the good news:  if we execute our vp program with 
/sw/bin/idle.py rather than with python, we get to see the program 
output in real time (under idle, under X11).
	
		import os	
		os.chdir('/sw/lib/python2.3/idlelib')
		os.popen3('/sw/bin/python idle.py -r /Users/jis/box.py')
		
		#this runs as an executed script in leo, and produces a live idle 
with real time ongoing output.
	
	Now, while idle is running, leo sits in suspended animation.  But when 
the vpython program terminates, we are left in idle, and when idle is 
terminated, leo becomes active again.
	
	It would be even better if leo were not suspended (using os.spawn, 
perhaps) but the real point is that I would really really like leo's 
"Execute script" command to execute code this way and spare me having 
to  hard-write the path to box.py.  It ought to be possible to 
eliminate os.chdir as well.

------------------
Jon Schull, Ph.D.
Associate Professor
Information Technology
Rochester Institute of Technology
schull@digitalgoods.com 585-738-6696
#@-node:EKR.20040422132037.7:Bug: vpython and mac
#@+node:EKR.20040422132037.8:Mouse / Paste Anomalies
@nocolor

By: Bill Drissel - drissel
2004-04-13 19:43  

Xserver (XFree86 under Cygwin) on PC (W2000); controlling Linux Red Hat;
buncha windows up including one Leo window and many xterms and Xemacs.

A: means action, R: means result

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click
R: text shows in body pane; headline is not marked with blue square; text is not colorized; text is not saved to file

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click; locate mouse symbol in text
R: text shows in body pane; headline is not marked with blue square; text is not colorized; text is not saved to file

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click; up arrow to locate Ibeam in text
R: Joy! colorizes, marks headline and saves!

A: hilite headline text; type on KB
R: keystrokes replace hilited text

A: hilite text in Xemacs window; hilite headline; middle click
R: hilited text appended to headline rather than replacing

This last anomaly seems to persist regardless of how the headline is hilited and regardless of pasting method (middle click or Control-V)
#@nonl
#@-node:EKR.20040422132037.8:Mouse / Paste Anomalies
#@-node:EKR.20040422132037:Linux bugs 4
#@+node:EKR.20040628085831:Features: 4
#@+node:ekr.20040323084434:(Add granularity setting for undo)
#@+node:ekr.20040328111626:Notes
@nocolor

- "node" and "line" granularity are easy:
	- Node: just replace "new" text with present text.
	- Line: create a new node if the present line isn't the same as the "line" attribute of the undo node.
		(Very similar to node granularity.

- "word" granularity is still fairly easy:
	- inWord flag is True or False.
	- create a new node if we are starting a new word.

- copy/paste always start new undo typing nodes.
	
#@nonl
#@-node:ekr.20040328111626:Notes
#@+node:ekr.20031218072017.3606:undo.__init__ & clearIvars
def __init__ (self,c):
    
    u = self ; u.c = c
    
    # Ivars to transition to new undo scheme...
    u.debug = False # True: enable debugging code in new undo scheme.
    u.debug_print = False # True: enable print statements in debug code.
    u.new_undo = True # True: enable new debug code.

    # Statistics comparing old and new ways (only if u.debug is on).
    u.new_mem = 0
    u.old_mem = 0

    # State ivars...
    u.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    u.redoMenuLabel = "Can't Redo"
    u.undoMenuLabel = "Can't Undo"
    u.realRedoMenuLabel = "Can't Redo"
    u.realUndoMenuLabel = "Can't Undo"
    u.undoing = False # True if executing an Undo command.
    u.redoing = False # True if executing a Redo command.
    
    # New in 4.2...
    << Define optional ivars >>
    << define redoDispatchDict >>
    << define undoDispatchDict >>
    u.updateSetChangedFlag = True
    u.redrawFlag = True
#@nonl
#@+node:ekr.20031218072017.3607:clearIvars
def clearIvars (self):
    
    u = self
    
    u.p = None # The position/node being operated upon for undo and redo.
    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
#@nonl
#@-node:ekr.20031218072017.3607:clearIvars
#@+node:ekr.20031218072017.3604:<< Define optional ivars >>
# New in 4.2: this is now an ivar, not a global, and it's a list, not a tuple.

u.optionalIvars = [
    "lastChild",
    "parent","oldParent",
    "back","oldBack",
    "n","oldN","oldV",
    "oldText","newText",
    "oldSel","newSel",
    "sort","select",
    "oldTree","newTree", # Added newTree 10/14/03
    "yview",
    # For incremental undo typing...
    "leading","trailing",
    "oldMiddleLines","newMiddleLines",
    "oldNewlines","newNewlines" ]
#@nonl
#@-node:ekr.20031218072017.3604:<< Define optional ivars >>
#@+node:EKR.20040526072519:<< define redoDispatchDict >>
u.redoDispatchDict = {
    "Change":             u.redoTyping,
    "Change All":         u.redoChangeAll,
    "Change Headline":    u.redoChangeHeadline,
    "Clone Node":         u.redoClone,
    "Convert All Blanks": u.redoReplaceNodesContents,
    "Convert All Tabs":   u.redoReplaceNodesContents,
    "Convert Blanks":     u.redoTyping,
    "Convert Tabs":       u.redoTyping,
    "Cut":                u.redoTyping,
    "Cut Node":           u.redoDeleteNode,
    "De-Hoist":           u.redoDehoist,
    "Delete":             u.redoTyping,
    "Delete Node":        u.redoDeleteNode,
    "Demote":             u.redoDemote,
    "Drag":               u.redoMoveNode,
    "Drag & Clone":       u.redoClone,
    "Extract":            u.redoReplaceNodes,
    "Extract Names":      u.redoReplaceNodes,
    "Extract Section":    u.redoReplaceNodes,
    "Hoist":              u.redoHoist,
    "Import":             u.redoInsertNodes,
    "Indent":             u.redoTyping,
    "Insert Node":        u.redoInsertNodes,
    "Move Down":          u.redoMoveNode,
    "Move Left":          u.redoMoveNode,
    "Move Right":         u.redoMoveNode,
    "Move Up":            u.redoMoveNode,
    "Paste":              u.redoTyping,
    "Paste Node":         u.redoInsertNodes,
    "Promote":            u.redoPromote,
    "Read @file Nodes":   u.redoReplaceNodes,
    "Reformat Paragraph": u.redoTyping,
    "Sort Children":      u.redoSortChildren,
    "Sort Siblings":      u.redoSortSiblings,
    "Sort Top Level":     u.redoSortTopLevel,
    "Typing":             u.redoTyping,
    "Undent":             u.redoTyping }
#@nonl
#@-node:EKR.20040526072519:<< define redoDispatchDict >>
#@+node:EKR.20040526075238:<< define undoDispatchDict >>
u.undoDispatchDict = {
    "Change":             u.undoTyping,
    "Change All":         u.undoChangeAll,
    "Change Headline":    u.undoChangeHeadline,
    "Clone Node":         u.undoClone,
    "Convert All Blanks": u.undoReplaceNodesContents,
    "Convert All Tabs":   u.undoReplaceNodesContents,
    "Convert Blanks":     u.undoTyping,
    "Convert Tabs":       u.undoTyping,
    "Cut":                u.undoTyping,
    "Cut Node":           u.undoDeleteNode,
    "De-Hoist":           u.undoDehoist,
    "Delete":             u.undoTyping,
    "Delete Node":        u.undoDeleteNode,
    "Demote":             u.undoDemote,
    "Drag":               u.undoMoveNode,
    "Drag & Clone":       u.undoDragClone, # redo uses redoClone.
    "Extract":            u.undoReplaceNodes,
    "Extract Names":      u.undoReplaceNodes,
    "Extract Section":    u.undoReplaceNodes,
    "Hoist":              u.undoHoist,
    "Import":             u.undoInsertNodes,
    "Indent":             u.undoTyping,
    "Insert Node":        u.undoInsertNodes,
    "Move Down":          u.undoMoveNode,
    "Move Left":          u.undoMoveNode,
    "Move Right":         u.undoMoveNode,
    "Move Up":            u.undoMoveNode,
    "Paste":              u.undoTyping,
    "Paste Node":         u.undoInsertNodes,
    "Promote":            u.undoPromote,
    "Read @file Nodes":   u.undoReplaceNodes,
    "Reformat Paragraph": u.undoTyping,
    "Sort Children":      u.undoSortChildren,
    "Sort Siblings":      u.undoSortSiblings,
    "Sort Top Level":     u.undoSortTopLevel,
    "Typing":             u.undoTyping,
    "Undent":             u.undoTyping }
#@nonl
#@-node:EKR.20040526075238:<< define undoDispatchDict >>
#@-node:ekr.20031218072017.3606:undo.__init__ & clearIvars
#@+node:ekr.20031218072017.1421:<< get config options >>
@ Rewritten 10/11/02 as follows:

1. We call initConfigParam and initBooleanConfigParam to get the values.

The general purpose code will enter all these values into configDict.  This allows update() to write the configuration section without special case code.  configDict is not accessible by the user.  Rather, for greater speed the user access these values via the ivars of this class.

2. We pass the ivars themselves as params so that default initialization is done in the ctor, as would normally be expected.
@c

self.at_root_bodies_start_in_doc_mode = self.initBooleanConfigParam(
    "at_root_bodies_start_in_doc_mode",self.at_root_bodies_start_in_doc_mode)
    
encoding = self.initConfigParam(
    "config_encoding",self.config_encoding)
    
if g.isValidEncoding(encoding):
    self.config_encoding = encoding
else:
    g.es("bad config_encoding: " + encoding)
    
self.create_nonexistent_directories = self.initBooleanConfigParam(
    "create_nonexistent_directories",self.create_nonexistent_directories)
    
encoding = self.initConfigParam(
    "default_derived_file_encoding",self.default_derived_file_encoding)

if g.isValidEncoding(encoding):
    self.default_derived_file_encoding = encoding
else:
    g.es("bad default_derived_file_encoding: " + encoding)
    
self.load_derived_files_immediately = self.initBooleanConfigParam(
    "load_derived_files_immediately",self.load_derived_files_immediately)
    
encoding = self.initConfigParam(
    "new_leo_file_encoding",
    self.new_leo_file_encoding)

if g.isValidEncoding(encoding):
    self.new_leo_file_encoding = encoding
else:
    g.es("bad new_leo_file_encoding: " + encoding)

self.output_initial_comment = self.initConfigParam(
    "output_initial_comment",self.output_initial_comment)

self.output_newline = self.initConfigParam(
    "output_newline",self.output_newline)

self.read_only = self.initBooleanConfigParam(
    "read_only",self.read_only)

self.relative_path_base_directory = self.initConfigParam(
    "relative_path_base_directory",self.relative_path_base_directory)
    
self.redirect_execute_script_output_to_log_pane = self.initBooleanConfigParam(
    "redirect_execute_script_output_to_log_pane",
    self.redirect_execute_script_output_to_log_pane)
    
self.remove_sentinels_extension = self.initConfigParam(
    "remove_sentinels_extension",self.remove_sentinels_extension)

self.save_clears_undo_buffer = self.initBooleanConfigParam(
    "save_clears_undo_buffer",self.save_clears_undo_buffer)
    
self.stylesheet = self.initConfigParam(
    "stylesheet",self.stylesheet)
    
encoding = self.initConfigParam(
    "tk_encoding",self.tkEncoding)
    
if encoding and len(encoding) > 0: # May be None.
    if g.isValidEncoding(encoding):
        self.tkEncoding = encoding
    else:
        g.es("bad tk_encoding: " + encoding)
        
# g.trace("config.self.tkEncoding",self.tkEncoding)

g.app.use_gnx = self.initBooleanConfigParam(
    "use_gnx",g.app.use_gnx)
# g.trace("g.app.use_gnx",g.app.use_gnx)
    
self.use_plugins = self.initBooleanConfigParam(
    "use_plugins",self.use_plugins)

self.use_psyco = self.initBooleanConfigParam(
    "use_psyco",self.use_psyco)
    
self.undo_granularity = self.initConfigParam(
    "undo_granularity",self.undo_granularity)
    
self.write_old_format_derived_files = self.initBooleanConfigParam(
    "write_old_format_derived_files",self.write_old_format_derived_files)
#@-node:ekr.20031218072017.1421:<< get config options >>
#@+node:ekr.20031218072017.1490:setUndoTypingParams
@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    # g.trace(undo_type,p,"old:",oldText,"new:",newText)
    u = self ; c = u.c
    << return if there is nothing to do >>
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    u.setUndoTypes() # Recalculate the menu labels.
    return d
#@nonl
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    return None

if oldText == newText:
    # g.trace("no change")
    return None
#@nonl
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p
#@nonl
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]
    
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    g.trace()
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
#@nonl
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply v.bodyString().
@c

if u.new_undo:
    if u.debug:
        # Remember the complete text for comparisons...
        u.oldText = oldText
        u.newText = newText
        # Compute statistics comparing old and new ways...
        # The old doesn't often store the old text, so don't count it here.
        u.old_mem += len(newText)
        s1 = string.join(old_middle_lines,'\n')
        s2 = string.join(new_middle_lines,'\n')
        u.new_mem += len(s1) + len(s2)
    else:
        u.oldText = None
        u.newText = None
else:
    u.oldText = oldText
    u.newText = newText

self.leading = leading
self.trailing = trailing
self.oldMiddleLines = old_middle_lines
self.newMiddleLines = new_middle_lines
self.oldNewlines = old_newlines
self.newNewlines = new_newlines
#@nonl
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
# Push params on undo stack, clearing all forward entries.
u.bead += 1
d = u.setBead(u.bead)
u.beads[u.bead:] = [d]

# g.trace(len(u.beads), u.bead)
#@nonl
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@+node:ekr.20031218072017.2038:<< redo typing cases >>
elif redoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# g.trace(redoType,u.p)
	# selectVnode causes recoloring, so avoid if possible.
	if current != u.p:
		c.selectVnode(u.p)
	elif redoType in ("Cut","Paste"):
		c.frame.body.forceFullRecolor()

	self.undoRedoText(
		u.p,u.leading,u.trailing,
		u.newMiddleLines,u.oldMiddleLines,
		u.newNewlines,u.oldNewlines,
		tag="redo",undoType=redoType)
	
	if u.newSel:
		c.frame.body.setTextSelection(u.newSel)
	if u.yview:
		c.frame.body.setYScrollPosition(u.yview)
	redrawFlag = (current != u.p)
		
elif redoType == "Change All":

	count = 0
	while 1:
		u.bead += 1
		d = u.getBead(u.bead+1)
		assert(d)
		redoType = u.undoType
		# g.trace(redoType,u.p,u.newText)
		if redoType == "Change All":
			c.selectVnode(u.p)
			break
		elif redoType == "Change":
			u.p.v.setTnodeText(u.newText)
			u.p.setDirty()
			count += 1
		elif redoType == "Change Headline":
			u.p.initHeadString(u.newText)
			count += 1
		else: assert(False)
	g.es("redo %d instances" % count)

elif redoType == "Change Headline":
	
	# g.trace(redoType,u.p,u.newText)
	u.p.setHeadStringOrHeadline(u.newText)
	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2038:<< redo typing cases >>
#@+node:ekr.20031218072017.2047:<< undo typing cases >>
@ When making "large" changes to text, we simply save the old and new text for undo and redo.  This happens rarely, so the expense is minor.

But for typical typing situations, where we are typing a single character, saving both the old and new text wastes a huge amount of space and puts extreme stress on the garbage collector.  This in turn can cause big performance problems.
@c
	
elif undoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# g.trace(undoType,u.p)
	# selectVnode causes recoloring, so don't do this unless needed.
	if current != u.p:
		c.selectVnode(u.p)
	elif undoType in ("Cut","Paste"):
		c.frame.body.forceFullRecolor()

	self.undoRedoText(
		u.p,u.leading,u.trailing,
		u.oldMiddleLines,u.newMiddleLines,
		u.oldNewlines,u.newNewlines,
		tag="undo",undoType=undoType)
	if u.oldSel:
		c.frame.body.setTextSelection(u.oldSel)
	if u.yview:
		c.frame.body.setYScrollPosition(u.yview)
	redrawFlag = (current != u.p)
		
elif undoType == "Change All":

	count = 0
	while 1:
		u.bead -= 1
		d = u.getBead(u.bead)
		assert(d)
		undoType = u.undoType
		# g.trace(undoType,u.p,u.oldText)
		if undoType == "Change All":
			c.selectVnode(u.p)
			break
		elif undoType == "Change":
			u.p.setTnodeText(u.oldText)  # p.setTnodeText
			count += 1
			u.p.setDirty()
		elif undoType == "Change Headline":
			u.p.initHeadString(u.oldText)  # p.initHeadString
			count += 1
		else: assert(False)
	g.es("undo %d instances" % count)
		
elif undoType == "Change Headline":
	
	# g.trace(u.oldText)
	u.p.setHeadStringOrHeadline(u.oldText)
	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2047:<< undo typing cases >>
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    u = self ; c = u.c
    assert(p == c.currentPosition())
    v = p.v

    << Incrementally update the Tk.Text widget >>
    << Compute the result using v's body text >>
    # g.trace(v)
    # g.trace("old:",v.bodyString())
    v.setTnodeText(result)
    # g.trace("new:",v.bodyString())
    << Get textResult from the Tk.Text widget >>
    if textResult == result:
        if undoType in ("Cut","Paste"):
            # g.trace("non-incremental undo")
            c.frame.body.recolor(p,incremental=False)
        else:
            # g.trace("incremental undo:",leading,trailing)
            c.frame.body.recolor_range(p,leading,trailing)
    else: # 11/19/02: # Rewrite the pane and do a full recolor.
        if u.debug_print:
            << print mismatch trace >>
        # g.trace("non-incremental undo")
        p.setBodyStringOrPane(result)
#@nonl
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading > 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len > 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading > 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
while newlines > oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines > newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
# Recreate the text using the present body text.
body = v.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s
if u.debug_print:
    print "body:  ",body
    print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) > 0 and textResult[:-1] == result:
        textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20040323084434:(Add granularity setting for undo)
#@+node:ekr.20031218072017.791:(Finish Check Tabs, Check Python Syntax and PrettyPrint Python commands)
@

- Put readLinesClass in leoGlobals.py or find similar code in an existing Python module.
- Create and test the actual commands.
#@nonl
#@+node:EKR.20040611074752:use standard alternative for readLinesClass or put in leoGlobals
#@-node:EKR.20040611074752:use standard alternative for readLinesClass or put in leoGlobals
#@-node:ekr.20031218072017.791:(Finish Check Tabs, Check Python Syntax and PrettyPrint Python commands)
#@+node:EKR.20040602153716:(Finish drawUserIcons)
#@+node:ekr.20040317050439:Right-click to add user-specified attributes and icons
Also add corresponding commands.
#@nonl
#@-node:ekr.20040317050439:Right-click to add user-specified attributes and icons
#@+node:ekr.20040317184631:Design
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2477913
By: edream

A better design for user icons

Using tuples in t.unknownAttributes["icons"] is too constricted.  Much better
to have t.unknownAttributes["icons"] be a list of Python _dictionaries_ rather
than a list of tuples.  Each of these "subsidiary" dictionaries could have the
following keys:

"type"

"file", "icon" or "url".  At present my prototype code uses "file" to specify
the location of an icon.

"where":

"beforeBox", "beforeIcon", "beforeHeadLine", "afterHeadline".  This specifies
where to put the icon.  The default would be "beforeHeadline".  "beforeBox"
means before the plus/minus box.  "beforeIcon" means before the standard icon.

"height":

the height of the icon to use when calculating the line height.  Default: get
from the icon itself, if possible.

"width":

the width of the icon to use when calculating where to put the following element.
Default: get from the icon, if possible.

"xoffset"

Leo draws the icon at x + xoffset, where x is determined by the where param
above.  Default 0.

"xpad"

The amount of extra space following the icon.  Default 0.

"yoffset"

Leo draws the icon at y + yoffset.  Default 0.

"ypad"

The amount of extra vertical space to add to the line height.  Default 0.

These offset and pad values are integer pixel values and may be positive or
negative.

"lineHeight"  NOT USED.

Overrides any calculated line height.  Default:  lineHeight = yoffset + height + ypad.

"onClick", "onRightClick", "onDoubleClick"

commands to call when the specified event happens.  By default, the "onRightClick"
icon will be bound to a popup menu that offers the user a chance to delete the
icon,  and maybe other options such as "nudging" the icon up or down, left or
right.

"popUpMenu"

a list of items to put in a popup menu.  This would be a convenience to avoid
having to use "onRightClick".

I think you get the idea.  We want the drawing code to support lots of common
things that plugins would like to do.  I'll probably think of other goodies,
but this already is a big step forward.  Note that each of these keys will have
a default, so plugins only need to specify keys that have non-default values.

Edward

P.S.  Other gui's might not be able to support all these options.  That's ok.
The drawing code in gui plugins should degrade gracefully.

EKR
#@nonl
#@-node:ekr.20040317184631:Design
#@+node:ekr.20040317184631.2:Changes
@nocolor

"lineHeight"

This key won't be used.

t.unknownAttributes["lineYOffset"] 

An integer y offset for the entire line (except user icons, which are flexible enough).  You can use this to center the following vertically: the plus/minus box, the horizontal line to the plus/minus box, the standard headline box, and the Tk.Text widget for the headline.
#@nonl
#@-node:ekr.20040317184631.2:Changes
#@+node:ekr.20040317184631.1:To do
@nocolor

"onClick", "onRightClick", "onDoubleClick"

commands to call when the specified event happens.  By default, the "onRightClick"
icon will be bound to a popup menu that offers the user a chance to delete the
icon,  and maybe other options such as "nudging" the icon up or down, left or
right.

"popUpMenu"

a list of items to put in a popup menu.  This would be a convenience to avoid
having to use "onRightClick".

I think you get the idea.  We want the drawing code to support lots of common
things that plugins would like to do.  I'll probably think of other goodies,
but this already is a big step forward.  Note that each of these keys will have
a default, so plugins only need to specify keys that have non-default values.
#@nonl
#@-node:ekr.20040317184631.1:To do
#@+node:ekr.20031218072017.4140:<< drawing constants >>
box_padding = 5 # extra padding between box and icon
box_width = 9 + box_padding
icon_width = 20
icon_padding = 2
text_indent = 4 # extra padding between icon and tex
child_indent = 28 # was 20
hline_y = 7 # Vertical offset of horizontal line
root_left = 7 + box_width
root_top = 2
hiding = True # True if we don't reallocate items
line_height = 17 + 2 # To be replaced by Font height
#@nonl
#@-node:ekr.20031218072017.4140:<< drawing constants >>
#@+node:ekr.20040317094609:drawUserIcons
def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for dict in iconsList:
            h2,w2 = self.drawUserIcon(where,x+w,y,dict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    return h,w
#@nonl
#@-node:ekr.20040317094609:drawUserIcons
#@+node:ekr.20040317095510:drawUserIcon
def drawUserIcon (self,where,x,y,dict):
    
    h,w = 0,0

    if where != dict.get("where","beforeHeadline"):
        return h,w
        
    # g.trace(where,x,y,dict)
    
    << set offsets and pads >>
    type = dict.get("type")
    if type == "icon":
        s = dict.get("icon")
        << draw the icon in string s >>
    elif type == "file":
        file = dict.get("file")
        << draw the icon at file >>
    elif type == "url":
        url = dict.get("url")
        << draw the icon at url >>
        
    # Allow user to specify height, width explicitly.
    h = dict.get("height",h)
    w = dict.get("width",w)

    return h,w
#@nonl
#@+node:ekr.20040317173849:<< set offsets and pads >>
xoffset = dict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = dict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = dict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = dict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040317173849:<< set offsets and pads >>
#@+node:ekr.20040317095153:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040317095153:<< draw the icon in string s >>
#@+node:ekr.20040317095153.1:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040317095153.1:<< draw the icon at url >>
#@+node:ekr.20040317100702:<< draw the icon at file >>
try:
    image = self.iconimages[file]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",file)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    id = self.canvas.create_image(x+xoffset,y+yoffset,anchor="nw",image=image)
    self.canvas.lift(id)
    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad
#@nonl
#@-node:ekr.20040317100702:<< draw the icon at file >>
#@-node:ekr.20040317095510:drawUserIcon
#@+node:ekr.20031218072017.4147:tree.getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20031218072017.4147:tree.getIconImage
#@+node:EKR.20040526202501:putUnknownAttributes
def putUnknownAttributes (self,torv,toString=False):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    result = []
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        try:
            val = attrDict[key]
            s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            self.put(attr)

        except pickle.PicklingError:
            # New in 4.2 beta 1: keep going after error.
            g.es("ignoring non-pickleable attribute %s in %s" % (
                key,torv),color="blue")
#@nonl
#@-node:EKR.20040526202501:putUnknownAttributes
#@-node:EKR.20040602153716:(Finish drawUserIcons)
#@+node:EKR.20040601133022.1:(Finish the new undo)
#@+node:EKR.20040606195417.5:To do
@nocolor

- (done) Create u.saveNode, u.saveNodeAndChildren, u.saveListOfNodes.
- Create u.appendSavedNode.
- Use u.appendSavedNode in Change All command.
- Unit tests.
#@nonl
#@-node:EKR.20040606195417.5:To do
#@+node:EKR.20040528075307:u.saveTree
def saveTree (self,p,treeInfo=None):
    
    """Create all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    << about u.saveTree >>
    
    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,p.v.createUndoInfo(),p.v.t.createUndoInfo())
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
#@+node:EKR.20040530114124:<< about u.saveTree >>
@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo) where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.
#@-node:EKR.20040530114124:<< about u.saveTree >>
#@-node:EKR.20040528075307:u.saveTree
#@+node:EKR.20040606195417.2:u.saveNodeAndChildren
def saveNodeAndChildren (self,p):
    
    """Create all info needed for a node and all its immediate children."""

    u = self
    treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,p.v.createUndoInfo(),p.v.t.createUndoInfo())
    treeInfo.append(data)

    # Add info for all children.
    child = p.firstChild()
    while child:
        data = (child.v,child.v.createUndoInfo(),child.v.t.createUndoInfo())
        treeInfo.append(data)
        child = child.next()

    return treeInfo

#@-node:EKR.20040606195417.2:u.saveNodeAndChildren
#@+node:EKR.20040606195417.1:u.saveNode
def saveNode (self,p):
    
    """Create all info for a single vnode."""
    
    u = self

    treeInfo = (p.v,p.v.createUndoInfo(),p.v.t.createUndoInfo())
    return treeInfo
#@nonl
#@-node:EKR.20040606195417.1:u.saveNode
#@+node:EKR.20040606195417.3:u.saveListOfNodes
def saveListOfNodes (self,listOfVnodes):
    
    """Create all info for a list of vnodes."""
    
    u = self ; treeInfo = []

    for v in listOfVnodes:
        data = (v,v.createUndoInfo(),v.t.createUndoInfo())
        treeInfo.append(data)

    return treeInfo
#@nonl
#@-node:EKR.20040606195417.3:u.saveListOfNodes
#@-node:EKR.20040601133022.1:(Finish the new undo)
#@-node:EKR.20040628085831:Features: 4
#@+node:EKR.20040609155110:Docs
#@+node:EKR.20040503091612:Dangers of @file-thin: converting to @file-thin
Using @ignore with @file-thin is asking for trouble.
If you remove the @ignore and then save, you will lose data.

How to recover the data:
	- Read Outline.
	- Remove @ignore
	- Import derived file... 
#@nonl
#@-node:EKR.20040503091612:Dangers of @file-thin: converting to @file-thin
#@+node:ekr.20031218072017.756:Document how to use pdb plugin
#@-node:ekr.20031218072017.756:Document how to use pdb plugin
#@+node:EKR.20040608091618:Document @thin and @all on Leo's web site
#@-node:EKR.20040608091618:Document @thin and @all on Leo's web site
#@+node:EKR.20040610130112:Document @killcolor on Leo's web site
#@-node:EKR.20040610130112:Document @killcolor on Leo's web site
#@+node:EKR.20040610143355:Document Paste Retaining Clones
#@-node:EKR.20040610143355:Document Paste Retaining Clones
#@+node:EKR.20040609101343:Contribute to Python success stories
#@+node:EKR.20040609101343.1:@url http://python.oreilly.com/news/python_success_stories.pdf
#@-node:EKR.20040609101343.1:@url http://python.oreilly.com/news/python_success_stories.pdf
#@-node:EKR.20040609101343:Contribute to Python success stories
#@+node:EKR.20040607073134:Download and study wingide
#@+node:EKR.20040607073134.1:@url http://wingide.com/
#@-node:EKR.20040607073134.1:@url http://wingide.com/
#@-node:EKR.20040607073134:Download and study wingide
#@+node:EKR.20040611081747.1:Look at windows scripting
------cut openleo.pys
@path c:\bIn\pys\
@lineending crnl
@
w04609p09:57:19 a pys to open leo and do something.
you need the win32 extensions and you have to enable 
the script engine. details how on google or on the win32 page.

the sendkeys method can insert any test or control codes
msdn or microsoft.com/scripting

@c
pypath = r'C:\c\py\Python233'
py =  pypath + r'\python.exe -itOO '
leosrc = r'c:\c\leo\leo4CVS233\src'
name = "blank.leo"

WshShell = WScript.CreateObject("WScript.Shell")

#look like it comes up untitled 
# if it cant find an existing leo of that name?

WshShell.Run(py + leosrc + r'\Leo.py ../' + name)
WScript.Sleep(4900) 

wname = "untitled"

WshShell.AppActivate(wname);  WScript.Sleep(2100)
WshShell.SendKeys("%Fe");   WScript.Sleep(1300);  #^Q

---end openleo.pys
#@nonl
#@-node:EKR.20040611081747.1:Look at windows scripting
#@+node:EKR.20040616112407:Create a FAQ entry about using @thin in a cooperative environment
@nocolor

The general idea is that developers should use @thin in a cvs environment, and only commit thin derived files.

Consider .leo files to be private in a cooperative environment.  Only "reference" .leo files get committed to cvs: each developer uses a private copy.

Edward
#@nonl
#@-node:EKR.20040616112407:Create a FAQ entry about using @thin in a cooperative environment
#@-node:EKR.20040609155110:Docs
#@+node:ekr.20040706080747:Plugins
#@+node:ekr.20040629121906:Don't specify font in buttons on the Mac
#@-node:ekr.20040629121906:Don't specify font in buttons on the Mac
#@+node:ekr.20040629121906.1:Fix Node Navagator bugs
- Names don't show up in the Marks button until a node has been marked.

- Parent nodes don't always get expanded.

- Leaks memory slightly.
#@nonl
#@-node:ekr.20040629121906.1:Fix Node Navagator bugs
#@+node:EKR.20040622060649:Fix plugin bugs
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2629405
By: nobody

nodenavigator plugin gets confused 
when you open another leo,
its recent becomes the recent 
of the new leo. which wouldent be bad 
as a sideeffect if it didn't also loose 
all the old previously visited nodes. 
and of course, if you close the new leo,
its completely hosed for good. marks too.

searchbox has a similar problem, reported before with fix. 
search, open new leo, go back to first 
hit go it searches in the new leo.

#@verbatim
#@@tabwidth -4 in pluginsmanager.txt 
but there are tabs in the file

double clicking the @rst in leoDoc.leo
Leo's HTML Users Guide (Created using the rst2 plugin)
failed and took down some plugins too.
<string>:51: (ERROR/3) Unknown target name: "front Matter".
<string>:51: (ERROR/3) Unknown target name: "front Matter".
list.index(x): x not in list
Exiting due to error.  Use "--traceback" to diagnose.
Please report errors to <docutils-users@lists.sf.net>.
Include "--traceback" output, Docutils version (0.3.2),
Python version (2.3.3), your OS type & version, and the
command line used.
exception in app.hookFunction
[...]
  File "c:\c\leo\tempLeo42\leo\plugins\rst2.py", line 149, in onIconDoubleClick
    output = pub.publish()
  File "C:\C\PY\PYTHON233\Lib\site-packages\docutils\core.py", line 222, in
publish
    sys.exit(1)
SystemExit: 1
other @rst generated html works fine.
have both recent versions docutils and silvercity
also the print in the rst2 plugin describing
the conversions it makes are lost to the console. should be g.es() to the log
window.

you might concider going straight to a release candidate with so few bugs
reported.

Leo 4.2 alpha 3, build  1.117 , June 1, 2004
Python 2.3.3, Tk 8.4.3, win32

e
#@nonl
#@-node:EKR.20040622060649:Fix plugin bugs
#@+node:EKR.20040616111653:Test: Get cleo working with @thin trees
#@-node:EKR.20040616111653:Test: Get cleo working with @thin trees
#@+node:EKR.20040625160558:(Fix problems with nmarks plugin)
# Doesn't become active until a node is marked.
# Node isn't necessarily visible in outine pane when selected.
#@nonl
#@-node:EKR.20040625160558:(Fix problems with nmarks plugin)
#@+node:EKR.20040618070817:Install latest version of dynabutton
#@+node:EKR.20040618070854:@url http://rclick.netfirms.com/rCpython.htm
#@-node:EKR.20040618070854:@url http://rclick.netfirms.com/rCpython.htm
#@-node:EKR.20040618070817:Install latest version of dynabutton
#@+node:ekr.20040706080747.1:Make sure all plugins work with 4.2 code base
#@-node:ekr.20040706080747.1:Make sure all plugins work with 4.2 code base
#@+node:ekr.20040310092400.1:Use calltips in outline pane Isn't this a plugin??
#@+node:ekr.20040324075752:Request
@nocolor

https://sourceforge.net/forum/message.php?msg_id=2460535
By: nobody

See CallTipWindow.py in IDLE 1.0.2

Fairly simple implementation - uses a new toplevel window without a border.

Read the comments in the code for potential drawbacks on some platforms.

Regards, Myles.
#@nonl
#@-node:ekr.20040324075752:Request
#@+node:ekr.20040324071749:CallTips.py
"""CallTips.py - An IDLE Extension to Jog Your Memory

Call Tips are floating windows which display function, class, and method
parameter and docstring information when you type an opening parenthesis, and
which disappear when you type a closing parenthesis.

Future plans include extending the functionality to include class attributes.

"""

import sys
import string
import types

import CallTipWindow

import __main__

@others
#@+node:ekr.20040324071749.2:class CallTips
class CallTips:
	menudefs = [ ]
	
@others

#@+node:ekr.20040324071749.4:__init__
def __init__(self, editwin=None):

    if editwin == None:  # subprocess and test
        self.editwin = None
        return

    self.editwin = editwin
    self.text = editwin.text
    self.calltip = None
    self._make_calltip_window = self._make_tk_calltip_window
#@nonl
#@-node:ekr.20040324071749.4:__init__
#@+node:ekr.20040324071749.5:close
def close(self):

    self._make_calltip_window = None
#@-node:ekr.20040324071749.5:close
#@+node:ekr.20040324071749.6:_make_tk_calltip_window
def _make_tk_calltip_window(self):
	
    # See __init__ for usage
    return CallTipWindow.CallTip(self.text)
#@nonl
#@-node:ekr.20040324071749.6:_make_tk_calltip_window
#@+node:ekr.20040324071749.7:_remove_calltip_window
def _remove_calltip_window(self):

    if self.calltip:
        self.calltip.hidetip()
        self.calltip = None
#@nonl
#@-node:ekr.20040324071749.7:_remove_calltip_window
#@+node:ekr.20040324071749.8:paren_open_event
def paren_open_event(self, event):

    self._remove_calltip_window()
    name = self.get_name_at_cursor()
    arg_text = self.fetch_tip(name)
    if arg_text:
        self.calltip_start = self.text.index("insert")
        self.calltip = self._make_calltip_window()
        self.calltip.showtip(arg_text)
    return "" #so the event is handled normally.
#@nonl
#@-node:ekr.20040324071749.8:paren_open_event
#@+node:ekr.20040324071749.9:paren_close_event
def paren_close_event(self, event):

    # Now just hides, but later we should check if other
    # paren'd expressions remain open.
    self._remove_calltip_window()

    return "" #so the event is handled normally.
#@-node:ekr.20040324071749.9:paren_close_event
#@+node:ekr.20040324071749.10:check_calltip_cancel_event
def check_calltip_cancel_event(self, event):

    if self.calltip:
        # If we have moved before the start of the calltip,
        # or off the calltip line, then cancel the tip.
        # (Later need to be smarter about multi-line, etc)
        if self.text.compare("insert", "<=", self.calltip_start) or \
           self.text.compare("insert", ">", self.calltip_start
                             + " lineend"):
            self._remove_calltip_window()

    return "" #so the event is handled normally.
#@-node:ekr.20040324071749.10:check_calltip_cancel_event
#@+node:ekr.20040324071749.11:calltip_cancel_event
def calltip_cancel_event(self, event):

    self._remove_calltip_window()

    return "" #so the event is handled normally.
#@-node:ekr.20040324071749.11:calltip_cancel_event
#@+node:ekr.20040324071749.12:get_name_at_cursor
__IDCHARS = "._" + string.ascii_letters + string.digits

def get_name_at_cursor(self):
    idchars = self.__IDCHARS
    str = self.text.get("insert linestart", "insert")
    i = len(str)
    while i and str[i-1] in idchars:
        i -= 1
    return str[i:]
#@-node:ekr.20040324071749.12:get_name_at_cursor
#@+node:ekr.20040324071749.13:fetch_tip
def fetch_tip(self, name):

    """Return the argument list and docstring of a function or class

    If there is a Python subprocess, get the calltip there.  Otherwise,
    either fetch_tip() is running in the subprocess itself or it was called
    in an IDLE EditorWindow before any script had been run.

    The subprocess environment is that of the most recently run script.  If
    two unrelated modules are being edited some calltips in the current
    module may be inoperative if the module was not the last to run.

    """
    try:
        rpcclt = self.editwin.flist.pyshell.interp.rpcclt
    except:
        rpcclt = None
    if rpcclt:
        return rpcclt.remotecall("exec", "get_the_calltip",
                                 (name,), {})
    else:
        entity = self.get_entity(name)
        return get_arg_text(entity)
#@nonl
#@-node:ekr.20040324071749.13:fetch_tip
#@+node:ekr.20040324071749.14:get_entity
def get_entity(self, name):

    "Lookup name in a namespace spanning sys.modules and __main.dict__"
    if name:
        namespace = sys.modules.copy()
        namespace.update(__main__.__dict__)
        try:
            return eval(name, namespace)
        except:
            return None
#@nonl
#@-node:ekr.20040324071749.14:get_entity
#@-node:ekr.20040324071749.2:class CallTips
#@+node:ekr.20040324071749.15:_find_constructor
def _find_constructor(class_ob):
	
    # Given a class object, return a function object used for the
    # constructor (ie, __init__() ) or None if we can't find one.
	
    try:
        return class_ob.__init__.im_func
    except AttributeError:
        for base in class_ob.__bases__:
            rc = _find_constructor(base)
            if rc is not None: return rc
    return None

#@-node:ekr.20040324071749.15:_find_constructor
#@+node:ekr.20040324071749.16:get_arg_text
def get_arg_text(ob):
    "Get a string describing the arguments for the given object"
    argText = ""
    if ob is not None:
        argOffset = 0
        if type(ob)==types.ClassType:
            # Look for the highest __init__ in the class chain.
            fob = _find_constructor(ob)
            if fob is None:
                fob = lambda: None
            else:
                argOffset = 1
        elif type(ob)==types.MethodType:
            # bit of a hack for methods - turn it into a function
            # but we drop the "self" param.
            fob = ob.im_func
            argOffset = 1
        else:
            fob = ob
        # Try and build one for Python defined functions
        if type(fob) in [types.FunctionType, types.LambdaType]:
            try:
                realArgs = fob.func_code.co_varnames[argOffset:fob.func_code.co_argcount]
                defaults = fob.func_defaults or []
                defaults = list(map(lambda name: "=%s" % name, defaults))
                defaults = [""] * (len(realArgs)-len(defaults)) + defaults
                items = map(lambda arg, dflt: arg+dflt, realArgs, defaults)
                if fob.func_code.co_flags & 0x4:
                    items.append("...")
                if fob.func_code.co_flags & 0x8:
                    items.append("***")
                argText = ", ".join(items)
                argText = "(%s)" % argText
            except:
                pass
        # See if we can use the docstring
        doc = getattr(ob, "__doc__", "")
        if doc:
            doc = doc.lstrip()
            pos = doc.find("\n")
            if pos < 0 or pos > 70:
                pos = 70
            if argText:
                argText += "\n"
            argText += doc[:pos]
    return argText
#@-node:ekr.20040324071749.16:get_arg_text
#@+node:ekr.20040324071749.17:t1
#################################################
#
# Test code
#
if __name__=='__main__':

    def t1(): "()"
    def t2(a, b=None): "(a, b=None)"
    def t3(a, *args): "(a, ...)"
    def t4(*args): "(...)"
    def t5(a, *args): "(a, ...)"
    def t6(a, b=None, *args, **kw): "(a, b=None, ..., ***)"

    class TC:
        "(a=None, ...)"
        def __init__(self, a=None, *b): "(a=None, ...)"
        def t1(self): "()"
        def t2(self, a, b=None): "(a, b=None)"
        def t3(self, a, *args): "(a, ...)"
        def t4(self, *args): "(...)"
        def t5(self, a, *args): "(a, ...)"
        def t6(self, a, b=None, *args, **kw): "(a, b=None, ..., ***)"

    def test(tests):
        ct = CallTips()
        failed=[]
        for t in tests:
            expected = t.__doc__ + "\n" + t.__doc__
            name = t.__name__
            arg_text = ct.fetch_tip(name)
            if arg_text != expected:
                failed.append(t)
                print "%s - expected %s, but got %s" % (t, expected,
                                                        get_arg_text(entity))
        print "%d of %d tests failed" % (len(failed), len(tests))

    tc = TC()
    tests = (t1, t2, t3, t4, t5, t6,
             TC, tc.t1, tc.t2, tc.t3, tc.t4, tc.t5, tc.t6)

    test(tests)
#@-node:ekr.20040324071749.17:t1
#@-node:ekr.20040324071749:CallTips.py
#@+node:ekr.20040324072124:CallTipWindow.py
"""A CallTip window class for Tkinter/IDLE.

After ToolTip.py, which uses ideas gleaned from PySol
Used by the CallTips IDLE extension.

"""

import Tkinter as Tk
import leoGlobals as g

@others

if 1:
	main()
#@nonl
#@+node:ekr.20040324072124.2:class CallTip
class CallTip:

@others
#@+node:ekr.20040324072124.3:__init__
def __init__(self,widget):

	self.widget = widget
	self.tipwindow = None
	self.id = None
	self.x = self.y = 0
#@nonl
#@-node:ekr.20040324072124.3:__init__
#@+node:ekr.20040324072124.4:showtip
def showtip (self,text):

	""" Display text in calltip window"""

	if self.tipwindow or not text: return

	# truncate overly long calltip
	if len(text) >= 79: text = text[:75] + ' ...'
	self.text = text

	self.widget.see("insert")
	x,y,cx,cy = self.widget.bbox("insert")
	x = x + self.widget.winfo_rootx() + 2
	y = y + cy + self.widget.winfo_rooty()
	self.tipwindow = tw = Tk.Toplevel(self.widget)

	<< remove the border >>
	tw.wm_geometry("+%d+%d" % (x, y))
	<< Mac-specific code >>

	label = Tk.Label(tw,text=text, justify="left",
		background="#ffffe0",relief="solid",borderwidth=1,
		font=self.widget['font'])

	label.pack()
#@nonl
#@+node:ekr.20040324073536:<< remove the border >>
@
The following command has two effects:
- It removes the calltip window border (good)
- Causes (at least on Linux) the calltip to show as a top level window,
  burning through any other window dragged over it.
  Also, shows on all viewports!
@c

tw.wm_overrideredirect(1)
#@nonl
#@-node:ekr.20040324073536:<< remove the border >>
#@+node:ekr.20040324073536.1:<< Mac-specific code >>
@
This command is only needed and available on Tk >= 8.4.0 for OSX.
Without it, call tips intrude on the typing process by grabbing the focus.
@c

try:
	tw.tk.call("::tk::unsupported::MacWindowStyle",
		"style",tw._w,"help","noActivates")
except Tk.TclError:
	pass
#@nonl
#@-node:ekr.20040324073536.1:<< Mac-specific code >>
#@-node:ekr.20040324072124.4:showtip
#@+node:ekr.20040324072124.5:hidetip
def hidetip(self):

	tw = self.tipwindow
	self.tipwindow = None
	if tw:
		tw.destroy()
#@nonl
#@-node:ekr.20040324072124.5:hidetip
#@-node:ekr.20040324072124.2:class CallTip
#@+node:ekr.20040324072124.6:class container (test code)
class container: # Conceptually an editor_window

@others
#@nonl
#@+node:ekr.20040324072124.7:__init__
def __init__(self):

	root = Tk.Tk()
	text = self.text = Tk.Text(root)
	text.pack(side="left", fill="both", expand=1)
	text.insert("insert","string.split")
	root.update()
	self.calltip = CallTip(text)

	text.event_add(g.virtual_event_name("calltip-show"),"(")
	text.event_add(g.virtual_event_name("calltip-hide"),")")

	text.bind(g.virtual_event_name("calltip-show"),self.calltip_show)
	text.bind(g.virtual_event_name("calltip-hide"),self.calltip_hide)

	text.focus_set()
	root.mainloop()
#@nonl
#@-node:ekr.20040324072124.7:__init__
#@+node:ekr.20040324072124.8:calltip_show
def calltip_show(self, event):

	self.calltip.showtip("Hello world")
#@nonl
#@-node:ekr.20040324072124.8:calltip_show
#@+node:ekr.20040324072124.9:calltip_hide
def calltip_hide(self, event):

	self.calltip.hidetip()
#@nonl
#@-node:ekr.20040324072124.9:calltip_hide
#@-node:ekr.20040324072124.6:class container (test code)
#@+node:ekr.20040324072124.10:main
def main():

	# Test code
	c=container()
#@nonl
#@-node:ekr.20040324072124.10:main
#@-node:ekr.20040324072124:CallTipWindow.py
#@-node:ekr.20040310092400.1:Use calltips in outline pane Isn't this a plugin??
#@+node:ekr.20040701041539:(Check plugins for memory leaks & other performance problems)
#@+node:ekr.20040705074955:Notes
@killcolor

Leo's core looks pretty good.  Most (all?) of the "leaks" happen in the undo logic.

There are a few leaks in plugins.
#@nonl
#@-node:ekr.20040705074955:Notes
#@+node:ekr.20031218072017.1588:Garbage Collection
debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

if debugGC:
    try: 
        import gc
        gc.set_debug(
            gc.DEBUG_STATS | # prints statistics.
            # gc.DEBUG_LEAK | # Same as all below.
            # gc.DEBUG_COLLECTABLE
            # gc.DEBUG_UNCOLLECTABLE
            gc.DEBUG_INSTANCES |
            gc.DEBUG_OBJECTS
            # gc.DEBUG_SAVEALL
        )
    except ImportError:
        traceback.print_exc()

@others
#@nonl
#@+node:ekr.20031218072017.1589:clearAllIvars
def clearAllIvars (o):
    
    """Clear all ivars of o, a member of some class."""
    
    o.__dict__.clear()
#@-node:ekr.20031218072017.1589:clearAllIvars
#@+node:ekr.20031218072017.1590:collectGarbage
def collectGarbage(message=None):
    
    if not debugGC: return
    
    if not message:
        message = g.callerName(n=2)
    
    try: gc.collect()
    except: pass
    
    if 0:
        g.printGc(message)
    
    if 1: # This isn't needed unless we want to look at individual objects.
    
        << make a list of the new objects >>
        print "%25s: %d new, %d total objects" % (message,len(newObjects),len(objects))
#@+node:ekr.20031218072017.1591:<< make a list of the new objects >>
# WARNING: the id trick is not proper because newly allocated objects can have the same address as old objets.

global lastObjectsDict
objects = gc.get_objects()

newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]

lastObjectsDict = {}
for o in objects:
    lastObjectsDict[id(o)]=o
#@nonl
#@-node:ekr.20031218072017.1591:<< make a list of the new objects >>
#@-node:ekr.20031218072017.1590:collectGarbage
#@+node:ekr.20031218072017.1592:printGc
def printGc(message=None,onlyPrintChanges=False):
    
    if not debugGC: return None
    
    if not message:
        message = g.callerName(n=2)
    
    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount

        print '-' * 30
        print "garbage: %d, objects: %+6d =%7d %s" % (n,delta,n2,message)
        
        << print number of each type of object >>
        if 0:
            << print added functions >>

        lastObjectCount = n2
        return delta
    except:
        traceback.print_exc()
        return None
#@nonl
#@+node:ekr.20040703054646:<< print number of each type of object >>
global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    typesDict[type(obj)] = n + 1
    
# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

keys.sort()
for key in keys:
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        print "%+6d =%7d %s" % (delta2,n2,key)
    
lastTypesDict = typesDict
typesDict = {}
#@nonl
#@-node:ekr.20040703054646:<< print number of each type of object >>
#@+node:ekr.20040703065638:<< print added functions >>
import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if not lastFunctionsDict.has_key(key):
            print ; print obj
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            print "args", args
            if varargs: print "varargs",varargs
            if varkw: print "varkw",varkw
            if defaults:
                print "defaults..."
                for s in defaults: print s

lastFunctionsDict = funcDict
funcDict = {}
#@nonl
#@-node:ekr.20040703065638:<< print added functions >>
#@-node:ekr.20031218072017.1592:printGc
#@+node:ekr.20031218072017.1593:printGcRefs
def printGcRefs (verbose=True):

    refs = gc.get_referrers(app.windowList[0])
    print '-' * 30

    if verbose:
        print "refs of", app.windowList[0]
        for ref in refs:
            print type(ref)
    else:
        print "%d referers" % len(refs)
#@nonl
#@-node:ekr.20031218072017.1593:printGcRefs
#@-node:ekr.20031218072017.1588:Garbage Collection
#@+node:ekr.20031218072017.4144:Drawing (tkTree)
#@+node:ekr.20031218072017.4145:About drawing and updating
@ About drawing and updating strategy.

This version of Leo draws the outline "by hand" using the Tk canvas widget.  Surprisingly, this is not only easy, but simplifies the vnode and Commands classes.

1.  Updating and redraw.  The tree.redraw() method is called automatically from the "outermost" call to tree.endUpdate.  Moreover, calling .tree.redraw() inside a tree.beginUpdate/tree.endUpdate pair does nothing.  c.redraw(), c.beginUpdate() and c.endUpdate() just call the corresponding tree methods.  Finally, beginUpdate()/endUpdate(False) can be used to suppress redrawing entirely.

Therefore, the Commands class never needs to worry about extra calls to tree.redraw() provided all code that draws to the tree is enclosed in a tree.beginUpdate/tree.endUpdate pair.  The tree.idle_body_key event handler manages redrawing "by hand" by maintaining a redraw_flag and then calling endUpdate(redraw_flag).

2.  The tree.redraw() method deletes all old canvas items and recomputes all data, including v.iconVal.  This means that v.doDelete need not actually delete vnodes for them to disappear from the screen.  Indeed, vnode are never actually deleted, only unlinked.  It would be valid for "dependent" vnodes to be deleted, but there really is no need to do so.
#@-node:ekr.20031218072017.4145:About drawing and updating
#@+node:ekr.20031218072017.1000:drawBox (tag_bind)
def drawBox (self,p,x,y):
    
    tree = self ; canvas = self.canvas
    y += 7 # draw the box at x, y+7
    
    if not g.doHook("draw-outline-box",tree=tree,p=p,v=p,x=x,y=y):

        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        box_id = canvas.create_image(x,y+self.lineyoffset,image=image)
    
        id1 = canvas.tag_bind(box_id, "<1>", p.OnBoxClick)
        id2 = canvas.tag_bind(box_id, "<Double-1>", lambda x2: None)

        self.tagBindings.append((box_id,id1,"<1>"),)
        self.tagBindings.append((box_id,id2,"<Double-1>"),)
        
        return box_id
#@nonl
#@-node:ekr.20031218072017.1000:drawBox (tag_bind)
#@+node:ekr.20031218072017.1002:drawIcon (tag_bind)
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    tree = self ; v = p.v # Make sure the bindings refer to the _present_ position.

    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=tree,p=p,v=v,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        id = self.canvas.create_image(x,y+self.lineyoffset,anchor="nw",image=image,tag="iconBox")
        self.icon_id_dict[id] = p # Remember which vnode belongs to the icon.
    
        id1 = self.canvas.tag_bind(id,"<1>",p.OnIconClick)
        id2 = self.canvas.tag_bind(id,"<Double-1>",p.OnIconDoubleClick)
        id3 = self.canvas.tag_bind(id,"<3>",p.OnIconRightClick)
        
        # Remember the bindings so deleteBindings can delete them.
        self.tagBindings.append((id,id1,"<1>"),)
        self.tagBindings.append((id,id2,"<Double-1>"),)
        self.tagBindings.append((id,id3,"<3>"),)
    
    return 0,icon_width # dummy icon height,width
#@nonl
#@+node:EKR.20040602150338:<< compute x,y and iconVal >>

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:EKR.20040602150338:<< compute x,y and iconVal >>
#@-node:ekr.20031218072017.1002:drawIcon (tag_bind)
#@+node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

    """Draw horizontal line from vertical line to icon"""
    
    tree = self ; v = p.v
    
    data = g.doHook("draw-outline-node",tree=tree,p=p,v=v,x=x,y=y)
    if data is not None: return data
    
    # g.trace(p)
    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
        
    self.canvas.create_line(x,y+7+self.lineyoffset,
        x+box_width,y+7+self.lineyoffset,
        tag="lines",fill="gray50") # stipple="gray25")

    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040317171729:force_draw_node (new)
def force_draw_node(self,p,x,y):

    self.allocatedNodes += 1
    h,w = self.drawUserIcons(p,"beforeBox",x,y)
    xw = w # The extra indentation before the icon box.
    if p.hasChildren():
        box_id = self.drawBox(p,x+w,y)
    else:
        box_id = None

    w += box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x+w,y)
    h = max(h,h2) ; w += w2 ; xw += w2

    h2,w2 = self.drawIcon(p,x+w,y)
    h = max(h,h2) ; w += w2

    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x+w,y)
    h = max(h,h2) ; w += w2

    expand_x = x+w # save this for later.
    h2 = self.drawText(p,x+w,y,box_id)
    h = max(h,h2)
    w += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x+w,y)
    h = max(h,h2)
    
    self.drawClickFrame(p,y)

    return h,xw
#@nonl
#@-node:ekr.20040317171729:force_draw_node (new)
#@+node:ekr.20040318090335:force_draw_node (old)
def force_draw_nodeOLD(self,p,x,y):

    self.allocatedNodes += 1

    if p.hasChildren():
        box_id = self.drawBox(p,x,y)
    w = box_width # Even if the box isn't drawn.

    h2,w2 = self.drawIcon(p,x+w,y)
    w += w2

    h = self.drawText(p,x+w,y)
    
    return h,0
#@-node:ekr.20040318090335:force_draw_node (old)
#@-node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y,box_id=None):
    
    """draw text for v at nominal coordinates x,y."""

    tree = self ; c = self.c ; v = p.v
    h = self.line_height
    x += text_indent
    
    data = g.doHook("draw-outline-text-box",tree=tree,p=p,v=v,x=x,y=y)
    if data is not None: return data

    self.lastText = t = Tk.Text(self.canvas,
        font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

    # New in 4.2: entries are pairs (p,t) indexed by v.
    # Remember which text widget belongs to v.
    d = self.edit_text_dict
    val = d.get(v,[])
    val.append((p,t),)
    d[v] = val
    # g.trace("entry",d[p.v])

    # Remember the widget so deleteBindings can delete it.
    self.widgets.append(t) # Fixes a _huge_ memory leak.

    t.insert("end", v.headString())
    << configure the text depending on state >>

    if 1: # use bind here, else use bind_tag in drawTopTree.
        # Use vnode or postion callbacks.
        id1 = t.bind("<1>",p.OnHeadlineClick)
        id2 = t.bind("<3>",p.OnHeadlineRightClick)
        id3 = t.bind("<Key>", p.OnHeadlineKey)
        id4 = t.bind("<Control-t>",self.OnControlT)
            # 10/16/02: Stamp out the erroneous control-t binding.
        # Remember the bindings so deleteBindings can delete them.
        self.bindings.append((t,id1,"<1>"),)
        self.bindings.append((t,id2,"<3>"),)
        self.bindings.append((t,id3,"<Key>"),)
        self.bindings.append((t,id4,"<Control-t>"),)
    
    << highlight text widget on enter events >>
        
    id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t,tag="textBox")
    self.canvas.tag_lower(id)
    
    # This doesn't work: must call update_idletasks first, and that's hard here.
    # g.trace(t,t.winfo_height(),t.winfo_width())
    
    return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
    if p == self.editPosition():
        self.setNormalLabelState(p)
    else:
        self.setDisabledLabelState(p) # selected, disabled
else:
    self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@+node:ekr.20040709194954:<< highlight text widget on enter events >>
if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
    
if 1: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '<Enter>', enterRect, '+' )
    self.bindings.append((t,bind_enter,"<Enter>"),)
#@nonl
#@-node:ekr.20040709194954:<< highlight text widget on enter events >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20031218072017.2029:drawTopTree (tag_bind)
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        try: self.redrawCount += 1
        except: self.radrawCount = 1
        g.trace(self.redrawCount)
    # import traceback ; traceback.print_stack()
    
    self.lastClickFrameId = None # id of last entered clickBox.
    self.lastColoredText = None # last colored text widget.
    
    if c.hoistStack:
        p,junk = c.hoistStack[-1]
        self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),root_left,root_top,0,0)
        
    canvas.lower("lines")
    canvas.lower("colorBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox")
    
    if 0:
        << define callbacks >>
        # Use vnode or postion callbacks.
        canvas.tag_bind("textBox","<1>",onHeadlineClickCallback)
        canvas.tag_bind("textBox","<3>",onHeadlineRightClickCallback)
        canvas.tag_bind("textBox","<Key>", onHeadlineKeyCallback)
        canvas.tag_bind("textBox","<Control-t>",self.OnControlT)
            # Stamp out erroneous control-t binding.
#@nonl
#@+node:ekr.20040710060809:<< define callbacks >>
def onHeadlineClickCallback(tree=self):
    
    g.trace()
    c = tree.c
    p = c.currentPosition()
    p.onHeadlineClick()
    
def onHeadlineRightClickCallback(tree=self):
    
    g.trace()
    c = tree.c
    p = c.currentPosition()
    p.OnHeadlineRightClick()
    
def onHeadlineKeyCallback(tree=self):
    
    g.trace()
    c = tree.c
    p = c.currentPosition()
    p.OnHeadlineKey()
    
    
#@nonl
#@-node:ekr.20040710060809:<< define callbacks >>
#@-node:ekr.20031218072017.2029:drawTopTree (tag_bind)
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; v = p.v
    yfirst = ylast = y
    if level==0: yfirst += 10
    w = 0
    
    # We must make copies for drawText and drawBox and drawIcon,
    # So making copies here actually reduces the total number of copies.
    ### This will change for incremental redraw.
    p = p.copy()
    
    data = g.doHook("draw-sub-outline",tree=tree,p=p,v=v,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        h,w = self.drawNode(p,x,y)
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
            x += w2 ; w += w2
        if hoistFlag: break
        else:         p = p.next()
    << draw vertical line >>
    return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
    x, yfirst-hline_y,
    x, ylast+hline_y-h,
    fill="gray50", # stipple="gray50"
    tag="lines")

# self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20040317095510:drawUserIcon
def drawUserIcon (self,where,x,y,dict):
    
    h,w = 0,0

    if where != dict.get("where","beforeHeadline"):
        return h,w
        
    # g.trace(where,x,y,dict)
    
    << set offsets and pads >>
    type = dict.get("type")
    if type == "icon":
        s = dict.get("icon")
        << draw the icon in string s >>
    elif type == "file":
        file = dict.get("file")
        << draw the icon at file >>
    elif type == "url":
        url = dict.get("url")
        << draw the icon at url >>
        
    # Allow user to specify height, width explicitly.
    h = dict.get("height",h)
    w = dict.get("width",w)

    return h,w
#@nonl
#@+node:ekr.20040317173849:<< set offsets and pads >>
xoffset = dict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = dict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = dict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = dict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040317173849:<< set offsets and pads >>
#@+node:ekr.20040317095153:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040317095153:<< draw the icon in string s >>
#@+node:ekr.20040317095153.1:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040317095153.1:<< draw the icon at url >>
#@+node:ekr.20040317100702:<< draw the icon at file >>
try:
    image = self.iconimages[file]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",file)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    id = self.canvas.create_image(x+xoffset,y+yoffset,anchor="nw",image=image)
    self.canvas.lift(id)
    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad
#@nonl
#@-node:ekr.20040317100702:<< draw the icon at file >>
#@-node:ekr.20040317095510:drawUserIcon
#@+node:ekr.20040317094609:drawUserIcons
def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for dict in iconsList:
            h2,w2 = self.drawUserIcon(where,x+w,y,dict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    return h,w
#@nonl
#@-node:ekr.20040317094609:drawUserIcons
#@+node:ekr.20031218072017.1010:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@nonl
#@-node:ekr.20031218072017.1010:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040710050236:tree.drawClickFrame
def drawClickFrame (self,p,y):
    
    h = self.line_height ;  defaultColor = ""
    
    # Define a slighly larger rect to catch clicks.

    click_rect = self.canvas.create_rectangle(0,y,1000,y+h-3,tag="clickBox")
    self.canvas.itemconfig(click_rect,fill=defaultColor,outline=defaultColor)
    
    id_click = self.canvas.tag_bind(click_rect, "<1>", p.OnBoxClick)
    self.tagBindings.append((click_rect,id_click,"<1>"),)
    
    if 1: # A major change to the user interface.
        
        # Define a slighly smaller rect to colorize.
        color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
        self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)
        
        # Color the click box or the headline
        def enterRect(event,id=color_rect,p=p,t=self.lastText):
            if 1: # Color or underline the headline
                t2 = self.lastColoredText
                if t2: # decolor the old headline.
                    if 1: # deunderline
                        t2.tag_delete('underline')
                    else: # decolor
                        t2.configure(background="white")
                if t and p != self.editPosition():
                    if 1: # underline
                        t.tag_add('underline','1.0','end')
                        t.tag_configure('underline',underline=True)
                    else: # color
                        t.configure(background="LightSteelBlue1")
                    self.lastColoredText = t
                else: self.lastColoredText = None
            else: # Color the click box.
                if self.lastClickFrameId:
                    self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
                self.lastClickFrameId = id
                color = "LightSteelBlue1"
                self.canvas.itemconfig(id,fill=color,outline=color)
    
        bind_id = self.canvas.tag_bind(click_rect, "<Enter>", enterRect) # , '+')
        self.tagBindings.append((click_rect,bind_id,"<Enter>"),)
    
#@nonl
#@-node:ekr.20040710050236:tree.drawClickFrame
#@+node:ekr.20031218072017.4147:tree.getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20031218072017.4147:tree.getIconImage
#@+node:ekr.20031218072017.1018:tree.idle_scrollTo
def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that v is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""

    c = self.c ; frame = c.frame
    if not p: p = self.c.currentPosition()
    if not p: p = self.c.rootPosition() # 4/8/04.
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)
    except:
        g.es_exception()
#@nonl
#@+node:ekr.20040314092716:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040314092716:<< compute approximate line height >>
#@+node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20031218072017.1018:tree.idle_scrollTo
#@+node:ekr.20031218072017.4148:tree.numberOfVisibleNodes
def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n
#@nonl
#@-node:ekr.20031218072017.4148:tree.numberOfVisibleNodes
#@+node:ekr.20040322122232:tree.scrollTo
def scrollTo (self,p):
    
    def scrollToCallback(event=None,self=self,p=p):
        g.trace(event,self,p)
        self.idle_scrollTo(p)
    
    self.canvas.after_idle(scrollToCallback)
#@nonl
#@-node:ekr.20040322122232:tree.scrollTo
#@+node:ekr.20031218072017.4149:tree.yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.  For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self, v1):

    # if not v1.isVisible(): print "yoffset not visible:",v1
    root = self.c.rootPosition()
    h, flag = self.yoffsetTree(root,v1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

# Returns the visible height of the tree and all sibling trees, stopping at p1

def yoffsetTree(self,p,p1):

    h = 0
    for p in p.siblings_iter():
        # print "yoffsetTree:", p
        if p == p1:
            return h, True
        h += self.line_height
        if p.isExpanded() and p.hasChildren():
            child = p.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    
    return h, False
#@nonl
#@-node:ekr.20031218072017.4149:tree.yoffset
#@-node:ekr.20031218072017.4144:Drawing (tkTree)
#@+node:ekr.20031218072017.4141:tree.Birth & death (Tkinter)
#@+node:ekr.20031218072017.1017:tree.__init__
def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Objects associated with this tree.
    self.canvas = canvas

    # Miscellaneous info.
    self.iconimages = {} # Image cache set by getIconImage().
    self.active = False # True if tree is active
    self._editPosition = None
    self.lineyoffset = 0 # y offset for this headline.
    self.disableRedraw = False # True: reschedule a redraw for later.
    self.lastClickFrameId = None # id of last entered clickBox.
    self.lastColoredText = None # last colored text widget.
    
    # Set self.font and self.fontName.
    self.setFontFromConfig()
    
    # Recycling bindings.
    self.bindings = [] # List of bindings to be unbound when redrawing.
    self.tagBindings = [] # List of tag bindings to be unbound when redrawing.
    self.icon_id_dict = {} # New in 3.12: keys are icon id's, values are vnodes.
    self.widgets = [] # Widgets that must be destroyed when redrawing.
    
    # Drag and drop
    self.drag_p = None
    self.controlDrag = False # True: control was down when drag started.
    self.drag_id = None # To reset bindings after drag
    
    # 20-SEP-2002 DTHEIN: keep track of popup menu so we can handle
    #                     behavior better on Linux
    # Context menu
    self.popupMenu = None
    
    # Incremental redraws:
    self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
    self.trace = False # True enabling of various traces.
    self.prevMoveToFrac = None
    self.visibleArea = None
    self.expandedVisibleArea = None
    
    self.allocatedNodes = 0 # A crucial statistic.
        # Incremental drawing allocates visible nodes at most twice.
        # Non-incremetal drawing allocates all visible nodes once.
        
    if self.allocateOnlyVisibleNodes:
        self.frame.bar1.bind("<B1-ButtonRelease>", self.redraw)
    
    if not leoTkinterTree.callbacksInjected: # Class var.
        leoTkinterTree.callbacksInjected = True
        self.injectCallbacks()
#@nonl
#@-node:ekr.20031218072017.1017:tree.__init__
#@+node:ekr.20031218072017.4142:tree.deleteBindings
def deleteBindings (self):
    
    """Delete all tree bindings and all references to tree widgets."""
    
    # g.trace(len(self.tagBindings),len(self.bindings))

    count = 0
    # Unbind all the tag bindings.
    if 0:  # testing.
        self.tagBindings = []
        self.bindings = []
    else:
        for id,id2,binding in self.tagBindings:
            self.canvas.tag_unbind(id,binding,id2)
            count += 1
        self.tagBindings = []
        # Unbind all the text bindings.
        for t,id,binding in self.bindings:
            t.unbind(binding,id)
            count += 1
        self.bindings = []

        # g.trace("bindings freed:",count)
#@nonl
#@-node:ekr.20031218072017.4142:tree.deleteBindings
#@+node:ekr.20031218072017.4143:tree.deleteWidgets
# canvas.delete("all") does _not_ delete the Tkinter objects associated with those objects!

def deleteWidgets (self):
    
    """Delete all widgets in the canvas"""
    
    # g.trace(len(self.widgets))
    
    self.icon_id_dict = {} # Delete all references to icons.
    self.edit_text_dict = {} # Delete all references to Tk.Edit widgets.
        
    # Fixes a _huge_ memory leak.
    for w in self.widgets:
        w.destroy() 

    self.widgets = []

    # g.trace("done")
#@nonl
#@-node:ekr.20031218072017.4143:tree.deleteWidgets
#@+node:ekr.20031218072017.1956:tree.injectCallbacks (class method)
def injectCallbacks(self):
    
    import leoNodes
    
    << define tkinter callbacks to be injected in the position class >>

    for f in (
        OnBoxClick,OnDrag,OnEndDrag,
        OnHeadlineClick,OnHeadlineRightClick,OnHeadlineKey,
        OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave,
        OnIconClick,OnIconDoubleClick,OnIconRightClick):
        
        g.funcToMethod(f,leoNodes.position)
#@nonl
#@+node:ekr.20031218072017.1957:<< define tkinter callbacks to be injected in the position class >>
# N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
#@nonl
#@+node:ekr.20031218072017.1958:OnBoxClick
# Called when the box is clicked.

def OnBoxClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("boxclick1",c=c,p=p,event=event):
            c.frame.tree.OnBoxClick(p)
        g.doHook("boxclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("boxclick")
#@nonl
#@-node:ekr.20031218072017.1958:OnBoxClick
#@+node:ekr.20031218072017.1959:OnDrag
def OnDrag(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if c.frame.tree.dragging():
            if not g.doHook("dragging1",c=c,p=p,event=event):
                c.frame.tree.OnDrag(p,event)
            g.doHook("dragging2",c=c,p=p,event=event)
        else:
            if not g.doHook("drag1",c=c,p=p,event=event):
                c.frame.tree.OnDrag(p,event)
            g.doHook("drag2",c=c,p=p,event=event)
    except:
        g.es_event_exception("drag")
#@nonl
#@-node:ekr.20031218072017.1959:OnDrag
#@+node:ekr.20031218072017.1960:OnEndDrag
def OnEndDrag(self,event=None):
    
    """Callback injected into vnode or position class."""
    
    # g.trace()

    try:
        p = self ; c = p.c
        # 7/10/03: Always call frame.OnEndDrag, regardless of state.
        if not g.doHook("enddrag1",c=c,p=p,event=event):
            c.frame.tree.OnEndDrag(p,event)
        g.doHook("enddrag2",c=c,p=p,event=event)
    except:
        g.es_event_exception("enddrag")
#@nonl
#@-node:ekr.20031218072017.1960:OnEndDrag
#@+node:ekr.20031218072017.1961:OnHeadlineClick & OnHeadlineRightClick
def OnHeadlineClick(self,event=None):
    """Callback injected into vnode or position class."""
    try:
        p = self ; c = p.c
        if not g.doHook("headclick1",c=c,p=p,event=event):
            c.frame.tree.OnActivate(p)
        g.doHook("headclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headclick")
    
def OnHeadlineRightClick(self,event=None):

    """Callback injected into vnode or position class."""

    #g.trace()
    try:
        p = self ; c = p.c
        if not g.doHook("headrclick1",c=c,p=p,event=event):
            c.frame.tree.OnActivate(p)
            c.frame.tree.OnPopup(self,event)
        g.doHook("headrclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headrclick")
#@nonl
#@-node:ekr.20031218072017.1961:OnHeadlineClick & OnHeadlineRightClick
#@+node:ekr.20031218072017.1962:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event):
    
    """Callback injected into vnode or position class."""

    # g.trace()
    try:
        p = self ; c = p.c
        if not g.doHook("hypercclick1",c=c,p=p,event=event):
            c.beginUpdate()
            c.selectVnode(p)
            c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hypercclick")
#@nonl
#@-node:ekr.20031218072017.1962:OnHyperLinkControlClick
#@+node:ekr.20031218072017.1963:OnHeadlineKey
def OnHeadlineKey (self,event=None):

    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("headkey1",c=c,p=p,event=event):
            c.frame.tree.OnHeadlineKey(p,event)
        g.doHook("headkey2",c=c,p=p,event=event)
    except:
        g.es_event_exception("headkey")
#@nonl
#@-node:ekr.20031218072017.1963:OnHeadlineKey
#@+node:ekr.20031218072017.1964:OnHyperLinkEnter
def OnHyperLinkEnter (self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperenter1",c=c,p=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hyperenter")
#@nonl
#@-node:ekr.20031218072017.1964:OnHyperLinkEnter
#@+node:ekr.20031218072017.1965:OnHyperLinkLeave
def OnHyperLinkLeave (self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperleave1",c=c,p=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,event=event)
    except:
        g.es_event_exception("hyperleave")
#@nonl
#@-node:ekr.20031218072017.1965:OnHyperLinkLeave
#@+node:ekr.20031218072017.1966:OnIconClick & OnIconRightClick
def OnIconClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("iconclick1",c=c,p=p,event=event):
            c.frame.tree.OnIconClick(p,event)
        g.doHook("iconclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("iconclick")
    
def OnIconRightClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("iconrclick1",c=c,p=p,event=event):
            c.frame.tree.OnIconRightClick(p,event)
        g.doHook("iconrclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("iconrclick")
#@-node:ekr.20031218072017.1966:OnIconClick & OnIconRightClick
#@+node:ekr.20031218072017.1967:OnIconDoubleClick
def OnIconDoubleClick(self,event=None):
    
    """Callback injected into vnode or position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("icondclick1",c=c,p=p,event=event):
            c.frame.tree.OnIconDoubleClick(self)
        g.doHook("icondclick2",c=c,p=p,event=event)
    except:
        g.es_event_exception("icondclick")
#@-node:ekr.20031218072017.1967:OnIconDoubleClick
#@-node:ekr.20031218072017.1957:<< define tkinter callbacks to be injected in the position class >>
#@-node:ekr.20031218072017.1956:tree.injectCallbacks (class method)
#@-node:ekr.20031218072017.4141:tree.Birth & death (Tkinter)
#@+node:ekr.20031218072017.892:p.__init__
def __init__ (self,v,stack):

    """Create a new position."""
    
    if v: self.c = v.c
    else: self.c = g.top()
    self.v = v
    assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.
    
    g.app.positions += 1
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20031218072017.892:p.__init__
#@+node:ekr.20031218072017.1015:idle_redraw
def idle_redraw (self,scroll=True):
    
    c = self.c ; frame = c.frame

    self.redrawScheduled = False # Always do this here.

    << return if disabled, or quitting or dragging >>

    # g.print_bindings("canvas",self.canvas)

    self.expandAllAncestors(c.currentPosition())

    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=self.c):
        self.allocatedNodes = 0
        << Erase and redraw the entire tree >>
        if self.trace:
            self.redrawCount += 1
            print "idle_redraw allocated:",self.redrawCount,self.allocatedNodes
    g.doHook("after-redraw-outline",c=self.c)

    self.canvas['cursor'] = oldcursor
    
    # g.collectGarbage()
    g.printGc()
    # import gc ; print len(gc.get_referents(frame))
    # g.printGcRefs(verbose=False)
    # g.trace("positions",g.app.positions)
#@+node:ekr.20040324090957:<< return if disabled, or quitting or dragging >>
if self.disableRedraw:
    # We have been called as the result of an update_idletasks in the log pane.
    # Don't do anything now.
    return

if frame not in g.app.windowList or g.app.quitting:
    # g.trace("no frame")
    return

if self.drag_p:
    # g.trace("dragging",self.drag_p)
    return
#@-node:ekr.20040324090957:<< return if disabled, or quitting or dragging >>
#@+node:ekr.20040324090957.1:<< Erase and redraw the entire tree >>
# Delete all widgets.
c.setTopVnode(None)
self.deleteBindings()
self.canvas.delete("all")
self.deleteWidgets()

# Redraw the tree.
self.setVisibleAreaToFullCanvas()
self.drawTopTree()

# Set up the scroll region after the tree has been redrawn.
x0, y0, x1, y1 = self.canvas.bbox("all")
self.canvas.configure(scrollregion=(0, 0, x1, y1))

# Do a scrolling operation after the scrollbar is redrawn
if scroll:
    self.canvas.after_idle(self.idle_scrollTo)

#@-node:ekr.20040324090957.1:<< Erase and redraw the entire tree >>
#@-node:ekr.20031218072017.1015:idle_redraw
#@+node:ekr.20031218072017.4157:Selecting & editing (tree)
#@+node:ekr.20031218072017.4158:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

    p = self.c.currentPosition()
    self.setDisabledLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)
#@nonl
#@-node:ekr.20031218072017.4158:dimEditLabel, undimEditLabel
#@+node:ekr.20031218072017.4159:editLabel
def editLabel (self,p):
    
    """Start editing p.edit_text."""
    
    # g.trace(p)

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()
        self.frame.revertHeadline = None
        
    self.setEditPosition(p)

    # Start editing
    if p and p.edit_text():
        self.setNormalLabelState(p)
        self.frame.revertHeadline = p.headString()
        self.setEditPosition(p)
#@nonl
#@-node:ekr.20031218072017.4159:editLabel
#@+node:ekr.20031218072017.4160:endEditLabel
def endEditLabel (self):
    
    """End editing for self.editText."""

    c = self.c ; gui = g.app.gui
    
    p = self.editPosition()

    if p and p.edit_text():
        self.setUnselectedLabelState(p)
        self.setEditPosition(None)

        # force a redraw of joined and ancestor headlines.
        self.force_redraw() 

    gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02
#@nonl
#@-node:ekr.20031218072017.4160:endEditLabel
#@+node:ekr.20031218072017.4161:tree.expandAllAncestors
def expandAllAncestors (self,p):
    
    redraw_flag = False

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    return redraw_flag

#@-node:ekr.20031218072017.4161:tree.expandAllAncestors
#@+node:ekr.20031218072017.1019:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=True):

    if not p: return
    
    << define vars and stop editing >>
    
    # g.trace(p)
    # g.printGc()

    if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # 3/26/03: Suppress duplicate call.
            try: # may fail during initialization
                self.idle_scrollTo(p)
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20031218072017.1020:<< define vars and stop editing >>
c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)
#@nonl
#@-node:ekr.20031218072017.1020:<< define vars and stop editing >>
#@+node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p and old_p != p:
    # g.trace("different node")
    self.endEditLabel()
    self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20031218072017.1022:<< select the new node >>
frame.setWrap(p)

# 6/14/04: Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
body.delete("1.0","end")
body.insert("1.0",s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20031218072017.1022:<< select the new node >>
#@+node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p)
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20031218072017.1024:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p)
#@nonl
#@-node:ekr.20031218072017.1024:<< update c.visitedList >>
#@+node:ekr.20031218072017.1025:<< set the current node >>
self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.1025:<< set the current node >>
#@-node:ekr.20031218072017.1019:tree.select
#@+node:ekr.20031218072017.4162:tree.set...LabelState
def setNormalLabelState (self,p): # selected, editing

    # g.trace(p)
    if p and p.edit_text():
        << set editing headline colors >>
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        g.app.gui.set_focus(self.c,p.edit_text())

def setDisabledLabelState (self,p): # selected, disabled

    # g.trace(p,g.callerName(2),g.callerName(3))
    if p and p.edit_text():
        << set selected, disabled headline colors >>

def setSelectedLabelState (self,p): # selected, not editing

    # g.trace(p)
    self.setDisabledLabelState(p)

def setUnselectedLabelState (self,p): # not selected.

    # g.trace(p)
    if p and p.edit_text():
        << set unselected headline colors >>
#@+node:ekr.20031218072017.4163:<< set editing headline colors >>
config = g.app.config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")

if not fg or not bg:
    fg,bg = "black","white"

try:
    if selfg and selbg:
        p.edit_text().configure(
            selectforeground=selfg,selectbackground=selbg,
            state="normal",highlightthickness=1,fg=fg,bg=bg)
    else:
        p.edit_text().configure(
            state="normal",highlightthickness=1,fg=fg,bg=bg)
except:
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4163:<< set editing headline colors >>
#@+node:ekr.20031218072017.4164:<< set selected, disabled headline colors >>
config = g.app.config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")

if not fg or not bg:
    fg,bg = "black","gray80"

try:
    p.edit_text().configure(
        state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4164:<< set selected, disabled headline colors >>
#@+node:ekr.20031218072017.4165:<< set unselected headline colors >>
config = g.app.config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")

if not fg or not bg:
    fg,bg = "black","white"

try:
    p.edit_text().configure(
        state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4165:<< set unselected headline colors >>
#@-node:ekr.20031218072017.4162:tree.set...LabelState
#@-node:ekr.20031218072017.4157:Selecting & editing (tree)
#@+node:ekr.20031218072017.2812:c.__init__, initIvars
def __init__(self,frame,fileName):

    self.frame = frame
    self.mFileName = fileName
    self.initIvars()

    # initialize the sub-commanders
    self.fileCommands = leoFileCommands.fileCommands(self)
    self.atFileCommands = leoAtFile.atFile(self)
    self.importCommands = leoImport.leoImportCommands(self)
    self.tangleCommands = leoTangle.tangleCommands(self)
    
    if 0 and g.debugGC:
        print
        print "*** using Null undoer ***"
        print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)

def initIvars(self):

    << initialize ivars >>
    self.setIvarsFromFind()
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# per-document info...
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.

# For tangle/untangle
self.tangle_errrors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of vnodes for the Nodes dialog.

# 4.1: for hoist/dehoist commands.
self.hoistStack = [] # Stack of nodes to be root of drawn tree.  Affects only drawing routines.

self.recentFiles = [] # 4.1: moved to commands class.  List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20031218072017.2812:c.__init__, initIvars
#@+node:ekr.20040703145401:To do: traceUndo
#@-node:ekr.20040703145401:To do: traceUndo
#@+node:ekr.20040704102031:Turn off gc while reading .leo files?
#@-node:ekr.20040704102031:Turn off gc while reading .leo files?
#@-node:ekr.20040701041539:(Check plugins for memory leaks & other performance problems)
#@-node:ekr.20040706080747:Plugins
#@+node:ekr.20040323195916.1:Tests & pychecker
@nocolor

- Unit tests for node iterators.

- Unit tests for undo/redo.

** Test for memory leaks.

- Test tangle/untangle commands.

- Create unit tests for Find commands.

- Create unit tests for all dialogs.

- Test all changed code:
	- Make a list of the code that has changed.

- Run profiler on code.
#@nonl
#@+node:EKR.20040628085616.1:Test error recovery when reading descendentTnodeUa's
#@-node:EKR.20040628085616.1:Test error recovery when reading descendentTnodeUa's
#@+node:EKR.20040621184626:Finish unit tests for @asis
@ - Support toString in asis methods
#@-node:EKR.20040621184626:Finish unit tests for @asis
#@+node:ekr.20040701120647:Pychecker stuff...
#@+node:ekr.20040701152235:Fix shawdow warnings ?
@killcolor

cmp,dict,dir,file,id,type are all global functions.
#@+node:ekr.20040701152235.2:leoApp
c:\prog\leoCVS\leo\src\leoApp.py:209: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoApp.py:224: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoApp.py:368: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoApp.py:401: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.2:leoApp
#@+node:ekr.20040701152235.3:leoPlugins
C:\prog\leoCVS\leo\src\leoPlugins.py:40: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoPlugins.py:53: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoPlugins.py:67: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoPlugins.py:72: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoPlugins.py:74: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.3:leoPlugins
#@+node:ekr.20040701152235.4:leoColor
C:\prog\leoCVS\leo\src\leoColor.py:1948: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoColor.py:2059: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.4:leoColor
#@+node:ekr.20040701152235.5:leoNodes
C:\prog\leoCVS\leo\src\leoNodes.py:578: (type) shadows builtin
C:\prog\leoCVS\leo\src\leoNodes.py:1372: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoNodes.py:1394: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoNodes.py:1411: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoNodes.py:1412: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoNodes.py:1419: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoNodes.py:1443: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoNodes.py:1446: (id) shadows builtin
#@nonl
#@-node:ekr.20040701152235.5:leoNodes
#@+node:ekr.20040701152235.6:leoCompare
C:\prog\leoCVS\leo\src\leoCompare.py:44: (cmp) shadows builtin
C:\prog\leoCVS\leo\src\leoCompare.py:397: (cmp) shadows builtin
C:\prog\leoCVS\leo\src\leoCompare.py:468: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.6:leoCompare
#@+node:ekr.20040701152235.8:leoFind
c:\prog\leoCVS\leo\src\leoFind.py:864: (type) shadows builtin
#@nonl
#@-node:ekr.20040701152235.8:leoFind
#@+node:ekr.20040701152235.9:leoMenu
c:\prog\leoCVS\leo\src\leoMenu.py:656: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoMenu.py:700: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.9:leoMenu
#@+node:ekr.20040701152235.10:leoTkinterTree
C:\prog\leoCVS\leo\src\leoTkinterTree.py:162: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:167: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:586: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:639: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:783: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:844: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:883: (type) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:893: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:911: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:949: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:1390: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:1588: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterTree.py:1590: (id) shadows builtin
#@nonl
#@-node:ekr.20040701152235.10:leoTkinterTree
#@+node:ekr.20040701152235.11:leoTkinterFrame
C:\prog\leoCVS\leo\src\leoTkinterFrame.py:807: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1233: (file) shadows builtin

c:\prog\leoCVS\leo\src\leoFrame.py:522: (type) shadows builtin
c:\prog\leoCVS\leo\src\leoFrame.py:566: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.11:leoTkinterFrame
#@+node:ekr.20040701152235.12:leoTkinterPrefs
c:\prog\leoCVS\leo\src\leoTkinterPrefs.py:295: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.12:leoTkinterPrefs
#@+node:ekr.20040701152235.13:leoTkinterGui
c:\prog\leoCVS\leo\src\leoTkinterGui.py:78: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.13:leoTkinterGui
#@+node:ekr.20040701152235.14:leoAtFile
C:\prog\leoCVS\leo\src\leoAtFile.py:336: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoAtFile.py:473: (dir) shadows builtin
C:\prog\leoCVS\leo\src\leoAtFile.py:490: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoAtFile.py:549: (dir) shadows builtin
C:\prog\leoCVS\leo\src\leoAtFile.py:551: (dir) shadows builtin
C:\prog\leoCVS\leo\src\leoAtFile.py:2142: (dir) shadows builtin
C:\prog\leoCVS\leo\src\leoAtFile.py:2157: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoAtFile.py:2278: (dir) shadows builtin
C:\prog\leoCVS\leo\src\leoAtFile.py:2280: (dir) shadows builtin
#@-node:ekr.20040701152235.14:leoAtFile
#@+node:ekr.20040701152235.15:leoFileCommands
C:\prog\leoCVS\leo\src\leoFileCommands.py:90: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoFileCommands.py:866: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoFileCommands.py:990: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoFileCommands.py:1191: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoFileCommands.py:1228: (dir) shadows builtin
C:\prog\leoCVS\leo\src\leoFileCommands.py:1269: (dir) shadows builtin
C:\prog\leoCVS\leo\src\leoFileCommands.py:1318: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoFileCommands.py:1756: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoFileCommands.py:2018: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.15:leoFileCommands
#@+node:ekr.20040701152235.16:leoImport
C:\prog\leoCVS\leo\src\leoImport.py:52: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:273: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:473: (type) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:1626: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:1648: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:1650: (id) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:2303: (type) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:2348: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:2371: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:2398: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:2426: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:2476: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:2727: (type) shadows builtin
C:\prog\leoCVS\leo\src\leoImport.py:2792: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.16:leoImport
#@+node:ekr.20040701152235.17:leoTangle
c:\prog\leoCVS\leo\src\leoTangle.py:540: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:541: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:666: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:718: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:911: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:924: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:2038: (type) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3563: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3656: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3667: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3780: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3865: (type) shadows builtin
#@nonl
#@-node:ekr.20040701152235.17:leoTangle
#@+node:ekr.20040701152235.18:leoCommands
C:\prog\leoCVS\leo\src\leoCommands.py:324: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:340: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:346: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:465: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:468: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:480: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:495: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:734: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:1238: (file) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:1677: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:1721: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:1770: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:1800: (dict) shadows builtin
C:\prog\leoCVS\leo\src\leoCommands.py:2280: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.18:leoCommands
#@-node:ekr.20040701152235:Fix shawdow warnings ?
#@+node:ekr.20040701123332:To do: redirect output (for unit tests)
- Redirect output to a file-like-object, then check the contents of that object.
#@nonl
#@-node:ekr.20040701123332:To do: redirect output (for unit tests)
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        print ; print "Warning: pychecker.checker running..." ; print
    except:
        pass
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@-node:ekr.20040701120647:Pychecker stuff...
#@-node:ekr.20040323195916.1:Tests & pychecker
#@+node:ekr.20040707060750:RsT plugin should say where files get written
#@-node:ekr.20040707060750:RsT plugin should say where files get written
#@-node:EKR.20040430163619:To do: 4.2
#@+node:ekr.20040629110559:Cool Mac stuff
#@+node:ekr.20040629111136:Native Max OS X Leo app

http://sourceforge.net/forum/message.php?msg_id=2630116
By: genthaler

Hi Mac OS X users,

I've put a native Mac OS X Leo application at

http://idisk.mac.com/genthaler-Public/Leo.zip

Just unzip it and put it in /Applications or ~/Applications

The Leo version I've used is 4.2a3 i.e. the latest version on SF. Living on
the edge...

It includes application and document icons (just the 32*32 ones, I don't have
time to create 128*128) as well as .leo extension associations.

AFAIK, it requires 10.3 (it uses the python in
/System/Library/Frameworks/Python.framework) and the MacPython-Panther addon
(http://ftp.cwi.nl/jack/python/mac/MacPython-Panther-2.3-2.dmg).
It also requires Aqua Tcl/Tk - I used the BI version from
http://prdownloads.sourceforge.net/tcltkaqua/TclTkAquaBI-8.4.6.1.dmg?download
The standard version should work, though.

Once they're installed, use /Applications/MacPython-2.3/PackageManager to install
_tkinter.

The control -> command key swapping announced above works nicely too. I changed
EditHeadline in leoConfig.leo (<< F-keys and others >>) to Ctrl+Command+H so
that Command-H still hides the application in standard fashion.

An accidental goodness is that the Leo plugins folder coincides with the standard
Mac OS X application bundle plugins folder - this means that you can use the
Finder's Get Info window to add, delete, enable & disable Leo plugins!

One minor unpleasantness is that you can only double-click or drag-drop a document
icon when Leo isn't open, and Leo closes when the last document is closed. You
can still use Leo's File->Open to open multiple documents, though.

Ed, feel free to copy this into the download area.

Guenther.
#@nonl
#@+node:ekr.20040629111733:@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)
#@-node:ekr.20040629111733:@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)
#@-node:ekr.20040629111136:Native Max OS X Leo app
#@+node:ekr.20040629111733.1:@url http://www.wordtech-software.com/leo.html  (Mac Bundle)
#@-node:ekr.20040629111733.1:@url http://www.wordtech-software.com/leo.html  (Mac Bundle)
#@-node:ekr.20040629110559:Cool Mac stuff
#@+node:EKR.20040609091327:To do: 4.3: configuration, plugins & translation
#@+node:ekr.20031218072017.828:(Must do) Rewrite the config manager
http://sourceforge.net/forum/message.php?msg_id=2329053
By: dsalomoni

I would be reluctant to run this script in a linux environment, for the following
reasons:

1) chmod 666 on the leo config file makes it writable by anybody. 

2) on the other hand, leo is currently IMHO not suitable for generic linux
installations, because it does not support per-user config files, so you actually
need to either carve leoconfig.txt in stone (not realistic), or make it writable
by any user as above (not advisable).

3) having a single dummy leoID defeats its main purpose in a multi-user environment.
If you could set per-user config files, the leoID could by default simply derived
from the username.

As a matter of fact, I've been suggesting to friends etc wanting to try out
leo/install it on their systems not to do that globally.

So, my view is that we could:

1) in the short term, provide a simple per-user installation based for example
on the script above, but with path defaults pointing to the user's home dir
(and of course w/o the requirement to be root) -- with leoID generated by default
looking at the username.

2) in the medium term, provide per-user config possibilities -- this would possibly
allow for a system-wide installation of leo and still allow configuration, per-user
plugins, etc. But this is linked I guess to the decommissioning of/changes to
the leoConfig.leo machinery.

Davide
#@nonl
#@+node:ekr.20040105080119:Search for settings in various places: Rodrigo
@nocolor

https://sourceforge.net/forum/message.php?msg_id=2355843
By: rodrigo_b

At least pluginManager should be there too	

(or both files could be merged... who knows)

The better would be to have

$HOME/.leo/
$HOME/.leo/leoConfig.txt
$HOME/.leo/plugins/pluginManager.txt
$HOME/.leo/plugins/<myplugins>.py

look for .leoConfig.txt, then leoConfig.txt
#@nonl
#@-node:ekr.20040105080119:Search for settings in various places: Rodrigo
#@+node:ekr.20040208112836:Specify shortcuts, ampersand bindings & translations in the same place
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2415127
By: edream

I have just hacked the code to allow & in entries in leoConfig.txt that describe
shortcuts.

This is a hack because it probably interacts poorly with the present mechanism
that allows menu entries to be translated.  I haven't looked into this in detail:
possibly everything works when menus are translated.  More likely things break.
If so, not using & in leoConfig.txt will probably "restore" things to their
former not-very-good state.

It appears that I shall have to revisit this whole gruesome topic when
the configuration code gets rewritten.
#@nonl
#@-node:ekr.20040208112836:Specify shortcuts, ampersand bindings & translations in the same place
#@+node:ekr.20040212094034:Another comment
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2420426
By: dalcolmo

> One copy of leoConfig.txt might specify installation options; other copies
might specify per-folder or per-file options.

Maybe I misunderstand this, but would the .leo file be the place for any per-file
options?

> "inheritable" copies of leoConfig.txt.
Yes! I want a copy per user, so I won't have to manually update the latest
installation of leo with my configurations. The typical global rc file (in /etc
or in the leo program dir) and local config file in ~/.leo would do fine. As
far as I am concerned, that would also be my preferred setup under Windows,
but I am sure most people would disagree.

Please move all global configuration options to one place. Currently, besides
having to edit leoConfig.leo, I have also to edit leoPlugins.leo or
pluginsManager.txt
I believe, these should also be configuration settings.

Best regards - Josef Dalcolmo
#@nonl
#@-node:ekr.20040212094034:Another comment
#@+node:ekr.20040213060739:Config stuff
@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 4.1rc4 Plug-in Bug?   
2004-02-13 03:32  

 if you write protect leoconfig.txt you also notice via traceback that it opens for write on entry too, not sure if it actually writes anything at that time.

looking forward to what the team dreams up for config options.
checkbox or dropdown & edit of available options
with spin boxes for font size etc
a positive way to lock all the panes ito the same scheme or allow individual choice.
and all the other per user options maybe an override on the command line to enable or disable a plugin or select a particular config.txt
 
#@-node:ekr.20040213060739:Config stuff
#@+node:ekr.20040216153659.1:Find some way to translate all other Leo messages.
Including, e.g., Undo messages.
#@nonl
#@-node:ekr.20040216153659.1:Find some way to translate all other Leo messages.
#@+node:ekr.20031218072017.651:Suggestion from RodrigoB
http://sourceforge.net/forum/message.php?msg_id=2312787
By: nobody

I had the idea some days ago, and I think I have not posted it yet.

The idea is simple but usefull, it is related about how to get a better configuration
interface for Leo.
The idea is:

let the configuration interface be a Plugin. This plugin define the
@configuration-file nodes. Under that nodes (and they childs), when selecting
the body, the body text is parsed to construct a tk dialog directly into the
body pane (replacing the text view, or as a window element in the text). When
modifying the menu, the text is changed. If something go wrong with the text
format, an error is raised and the original text is show.

The advantage of this plugin is that it is easier to devellop and integrate
very well with the actual scheme. It allow to define the configuration as a
hierarchy of nodes, similar to the linux kernel configuration, and use the power
of Leo.

The text format could be

option1 = 1 # checkbox <= the plugin infere that it have to show the option1
as a checkbox
option2 = bla # [bla, blo, bli] <= the plugin infere that it have to show a
combobox for option2, with options bla, blo, bli
option3 = rodrigo # text   <= trivial, etc...

The comment after the option could allow to specify python code for conditions,
etc, etc	
Obviously the comment can be placed, the line before, or the line after, or
under what ever format required.

That is the idea, it is implementable, and, to my eyes, would solve the problem.

RodrigoB.


#@-node:ekr.20031218072017.651:Suggestion from RodrigoB
#@+node:ekr.20031218072017.652:Add settings menu
- Add Settings menu.
	- Create Settings menu dynamically from leoConfig.txt
- Write leoConfig.txt by hand.

- Remove Open LeoConfig.leo command
- Remove Apply Settings command (will be done with apply, cancel, ok, revert buttons in all Settings submenus)
#@nonl
#@+node:ekr.20031218072017.653:Notes
@nocolor

It would be an understatement to say that the way Leo handles configuration settings could be improved.  The present scheme involves editing leoConfig.leo, then remembering to save all .leo files before tangling leoConfig.leo.  Moreover, even when doing this properly, not all changes to settings "take" immediately.  Furthermore, there are no easy analogies to the typical "apply" or "revert" or "revert to default" buttons commonly seen in options dialogs.

Last night I studied the way the jEdit editor handles options.  See http://www.jedit.org/
Visually, jEdit's "Global Options" dialogs are very impressive.  There is a tree view on the left, there is a unique panel on the left for each item in the tree view.  All options are set visually.

Something like this could be done in Leo, but actually I like the opening up leoConfig.leo and setting options in a typical Leo window.  The advantage of leoConfig.leo is that there is plenty of room to explain what each setting does.

Leo's Set Colors and Set Font dialogs can and should affect the settings in leoConfig.leo, but at present they only affect leoConfig.txt, which is most annoying, and basically wrong.

This morning I realized that a large part of Leo's difficulties with configuration options stems from me trying to work around the limitations of Python's ConfigParser module.  Relying on this module may be the worst mistake I have made in the Python version of Leo.  This mistake has had several ramifications:

-  leoConfig.leo uses @root trees rather than @file trees because ConfigParser deletes all comments when writing leoConfig.txt.  Suppose instead that Leo would read and write leoConfig.txt without the "help" of the ConfigParser module.  For reading, all that is needed is that Leo parse leoConfig.txt into a single configuration dictionary.  This would, in fact, be very easy to do.

- Leo needs to do a better job of ensuring that leoConfig.txt always matches the settings in effect.  This can be done if Leo can _rewrite_ leoConfig.txt as it was (with all comments and especially sentinel lines), merely substituting new settings for old.  This is only slightly harder to do.

Other improvements come to mind, not directly related to the problems with ConfigParser:

- There should be a separate Settings Menu.  This would have the Set Colors and Set Font commands, as well as the following commands: Edit Settings (Same as present Open leoConfig.leo command) and Use Default Settings command (rewrites leoConfig.txt using preset defaults) and possibly Set Default Settings, Apply Settings and Revert Settings commands.

- All classes that use configuration settings should implement a configure method that immediately updates settings to the values just written to leoConfig.txt.  This includes the commands, frame and tree classes, and others.

With this long background, there are two main approaches to improving how Leo handles options:

1. Use a graphical scheme like jEdit does, and dispense with leoConfig.leo entirely.  leoConfig.txt would be the only repository for options.  This graphical scheme would use typical Apply, Revert, OK and Cancel buttons, much like the present Set Colors and Set Font dialogs.

2. Improve how Leo handles leoConfig.leo and leoConfig.txt so that leoConfig.leo can use @file trees and so that settings are _reliably_ updated when the user would expect them to be.

At present, I favor the second scheme.  It is simple to implement, it is the most Leonine, and moreover it allows for full discussion of all options.  True, the graphical way is good looking, but that is about all it has going for it.  I suppose a help feature could be added to the graphical way, but we are talking about a lot of effort for very little real value to the user.

Actually though, the issues of keeping leoConfig.txt up-to-date and of applying settings immediately remain mostly the same regardless of which way is chosen.  In particular, without the "help" of the ConfigParser module Leo could maintain options much more easily.

Anyway, this is how I see matters.  Any comments?

Edward
#@-node:ekr.20031218072017.653:Notes
#@+node:ekr.20031218072017.654:Cleanup prefs code?
I'm not at all sure that it is worthwhile now.
#@nonl
#@-node:ekr.20031218072017.654:Cleanup prefs code?
#@-node:ekr.20031218072017.652:Add settings menu
#@+node:ekr.20031218072017.655:multiple copies of leoConfig.txt
@nocolor

> It just leaves still the problem of merging ones personal settings of leoConfig.txt 
with the ones in the new distribution. 

I am going to work on this just after 3.11b1 goes out the door. I think what I shall do is have Leo looks for several different files: first leoConfig.txt, then leoSiteConfig.txt, with the latter overriding the former. That way you can have stable settings (leoSiteConfig.txt won't be part of distributions). 

I may also have Leo look for leoLinuxConfig.txt, leoWinConfig.txt and leoMacConfig.txt, depending on the platform, so you can have stable platform settings as well. 
#@nonl
#@-node:ekr.20031218072017.655:multiple copies of leoConfig.txt
#@+node:ekr.20031218072017.656:Different fonts for Linux/Mac
@nocolor

By: sanori ( Joo-won Jung ) 
 How about split font config for win and unix?   
2003-02-10 12:02  
Developer Forum

How about split the font's configurations like IDLE, python IDE? 
Because the 10pt size in Windows and Unix (X window, exactly) is not the same. Moreover, the font set that the OS provides does not the same. 

I'm using leo on both windows and Linux, and leo is in the vfat partition to use it both OS. Of course, I can change the font size by using the font dialog. But, I want leo to be more comportable. :)

-Sanori 
#@-node:ekr.20031218072017.656:Different fonts for Linux/Mac
#@+node:ekr.20040226105601:Design for new config system (alpaha, etc.) Tom
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2434323
By: nobody

Okay, so 4.2 is to address a graphical interface to configuring Leo, so I'm
going to go over some of the ways the Alpha, AlphaX, and AlphaTk family of
editors handle this. These are editors that use Tcl as the core scripting
language, much as elisp does for Emacs. In AlphaTk, all of the code is in Tcl &
Tk, so it run on any system that support Tcl/Tk 8.3+, and shows off the type of
dialogs that can be given to Leo as it also (currently) uses the Tk half of
this. It is available for Windows, and has a 45 day free demo period. It works
fine with The Tcl/Tk we use to run Leo so you only need to download AlphaTk.exe
via this link: http://www.santafe.edu/~vince/alphatk/download.html

In Alpha, like Emacs, their are "modes" specfic to each language that give you
useful functionality when you are editing code in that language. Each mode has
its own namespace (e.g. 'pyth' for the python Mode) that hold all the variables
and functions that provide the functionality mentioned above. There is a set of
variables and functions that form a sort of "global mode" that would be useful
in editing plain text, and provides values and simple editting bahavior if no
such simularly named things exists in the pyth namespace, if these do exist,
them overide these global values & functions when in that editting mode.

Modes are held in a directory named "Modes", in Leo this would probably be a
subdirectory of 'plugins'. In Alpha a simple mode can be defined in a single
file, Leo should proabably use the multi-file method, each mode is given its own
subdirectory (e.g. ...\plugins\Modes\Python Mode\), then various files to define
that mode's functionality would be placed in that directory. Thus you could
include the syntax files directly from jEdit here. 

Alpha only concerns itself with what it needs to know to accomplish what its
user is trying to do, thus, if a user never edits a c++ file in a session, Alpha
never loads in the details of the C Mode (which includes c++), it knows it has a
C Mode, what file extensions it should activate for & has a short description to
give if the users ask for help on the mode, but only loads the rest of the code
that defines the mode if it is called on to edit a c or c++ file. It does this
by scanning all of the subdirectories files for a function call that has all
this info as parameters. These are gathered into a cache (a script file) that
gets executed when alpha starts up. This cache has a dictionary of filenames to
modification dates so that the cache remains valid as long as the files scanned
are already in the dictionary and have the same modification dates. Any conflict
gets caught at start-up and triggers a rescanning. 

Alpha has a function, 'newPref', that builds dictionaries of various kinds of
variables, consisting of variable_name to a tuple. That tuple varies according
to the type of variable, but has as a minimum, the default value and the
namespace it is to be created in. Other parts of the tuple might include a list
of the possible values, or a series of tuples (<text to present in drop down
box>, <value>). Any change by the user to a value other than the default gets
that choice written to a cache that gets loaded the first time a mode is
activated. When newPref executes it checks to see if the variable already
exists, and only creates that variable and intializes it to the default if it
doesn't. A further wrinkle is that any comment immediately preceding a newPref
call gets stored as help text for that variable.

These dictionaries are used to allow the configuration dialog for a mode be
automatically created on the fly. Flag dictionaries get their keys dumped and
sorted to create an array of checkboxes, their stored comments forms a "tooltip"
box of text displayed when the arrow hovers over the checkbox.

Other dictionaries drive other types of widgets in the dialog panes.

More later, but much of this could be adapted to Leo. Other things to check out
are the keysetting dialogs, an example of which is under "Config->Special
Keys...".

Tom
#@+node:ekr.20040227053137:More alpha stuff
https://sourceforge.net/forum/message.php?msg_id=2444789
By: nobody

To continue on things that Alpha contribute to Leo, let me tell you the some of
the reasons behind the design.

File structure: Alpha has the equivalent of a plugin directory, however, the
actual plug-ins are organized in subdirectories; files that tell alpha how to
support languages are placed in the "Modes" directory, files that add
functionality exposed primarily through an add-in menu are placed in the "Menus"
directory (Leo might use "Menus & Widgets" to include things like the new search
plug-in), other code that provides functionality that is not tied to a
particular language, and is not primarily invoked via a menu are placed in the
"Packages" directory, (e.g. the completion package that provide general word
completion).

This helps out when someone wants to roll their own code, if you want to add a
language look at the examples that are in the 'Modes' directory, you can quickly
cobble together elementary support and then extend it over time.

Installing a plug-in is really just a matter of putting the files in the right
place and have Alpha update its indexes. Now that does not mean that the new
features are enabled (other than for a language, those activate whenever Alpha
realises that it is editting a file of that language), if you go to
"Config->Global-Setup->Features" or "Config->Global-Setup->Menus", you get a
panel of checkboxes for Features or Menus that you can check to enable Globally,
(i.e. no matter what mode is currently active). Note that a tooltip box giving a
description is available whenever you hover the mouse over the feature/menu
name. These are built dynamically, are sorted alphabetically, and continued on
another page whenever their are too many to position on a single page. This
means no carefully redesign of a dialog box is needed to accomadate new
features.

The preferences for a language are only settable when a given mode is active.
Although in Alpha this is dependent on the file you are editing, Leo can be
thought of as in a given language mode dependent on what language directive is
in effect for the current cursor position. Once you are in a mode, the
"Config-><mode> Mode Prefs" Menu becomes active, Allowing you to choose what
Menus & Feature you would like available when you are in this mode. You also
have access to the Preferences that are available in that mode.

Note that any preference, feature set, menus that you chose are all store in a
cache of code that sets them to your chosen values whenever you start Alpha.
These values can be saved and used when you upgade to a new version (of Alpha or
any of its packages), conversely, discarded the Prefs directory restores you to
all the defaults as orginally specified. Mechanisms exist to prune out cached
values that are no longer used, and to ensure that a new variable that has been
added is set if it needs to be before some code gets executed.

Tom

#@-node:ekr.20040227053137:More alpha stuff
#@-node:ekr.20040226105601:Design for new config system (alpaha, etc.) Tom
#@+node:ekr.20040327050211:Fix problems with updating leoConfig.txt
#@+node:ekr.20040330092305:Preserve comments in config files (so we can use sentinels!)
@nocolor

> I don't know how to read [an @file-nosent config] file into the body of that node.

You can't, at least not automatically.  Leo needs sentinels in order to read a derived file, that is, in order to update the outline using information in a derived file.

I've been dithering about exactly what to do about configuration files.  Your question reminds me that we would prefer to have sentinels in config files.  In order to do that, Leo must preserve comments in config files, which of course would be much better than the present pathetic situation in which Python's configParser module strips comments.  As I have said before, using configParser was a blunder.  Somehow I'll fix this for 4.2.

Edward
#@nonl
#@-node:ekr.20040330092305:Preserve comments in config files (so we can use sentinels!)
#@+node:ekr.20040124073801:Add nullConfig class?
#@-node:ekr.20040124073801:Add nullConfig class?
#@+node:EKR.20040606193130:(Fix problems with negative tab width in prefs)
#@+node:EKR.20040606193323:Report
@nocolor

Open discussion
http://sourceforge.net/forum/message.php?msg_id=2603738

I always set tabs to -4 in the config. when you open the prefs it says 4 but
there is a checkmark for convert tabs to space. open a new leo, open prefs. its
not checked! open another leo, its checked.

The problem is that tab_width is usually stored in leoConfig.txt, not the .leo file.
I'm going to ignore this problem for now...
#@nonl
#@-node:EKR.20040606193323:Report
#@+node:ekr.20031218072017.2062:getPrefs
def getPrefs (self):

    c = self.c ; config = g.app.config
    
    if self.getOpenTag("<preferences"):
        return

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))
    
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag(">"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    while 1:
        if self.matchTag("<defaultDirectory>"):
            # New in version 0.16.
            c.tangle_directory = self.getEscapedString()
            self.getTag("</defaultDirectory>")
            if not g.os_path_exists(c.tangle_directory):
                g.es("default tangle directory not found:" + c.tangle_directory)
        elif self.matchTag("<TSyntaxMemo_options>"):
            self.getEscapedString() # ignored
            self.getTag("</TSyntaxMemo_options>")
        else: break
    self.getTag("</preferences>")
    
    # Override .leo file's preferences if settings are in leoConfig.txt.
    if config.configsExist:
        config.setCommandsIvars(c)
#@nonl
#@+node:ekr.20031218072017.2063:getTargetLanguage
def getTargetLanguage (self):
    
    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language
            
    return "c" # default
#@nonl
#@-node:ekr.20031218072017.2063:getTargetLanguage
#@-node:ekr.20031218072017.2062:getPrefs
#@-node:EKR.20040606193130:(Fix problems with negative tab width in prefs)
#@+node:ekr.20040225061559:Look at older config files when reading config data the first time for a new install
@nocolor

Is there a way that a "new" Leo installation could query the older one for config data?

Every time I get a new copy, I need to do a side-by-side compare and edit with the previous leoConfig.leo in order to change the settings to the way I want them. It would be really nice if this could be automated in some fashion.
#@nonl
#@-node:ekr.20040225061559:Look at older config files when reading config data the first time for a new install
#@-node:ekr.20040327050211:Fix problems with updating leoConfig.txt
#@-node:ekr.20031218072017.828:(Must do) Rewrite the config manager
#@+node:ekr.20031218072017.829:(Must do) gui interface for plugins manager
@nocolor

Interim design:
	
- use pluginsManager.txt in plugins directory.
	- Load file, scan for non-comment lines whose files are in plugins directory
- load plugins only if they are in pluginsManager.txt
- (later?) do a graphical interface for pluginsManager.txt

Simplest graphical interface:

- Listbox of all files.
- Enable, Disable, Revert, Cancel, OK buttons, Enable All, Disable All.
- Selecting an item in the Listbox enables one of the Enable/Disable buttons
- Selecting OK rewrites the file "in place" without altering comment lines.
- Opening file creates one entry for each .py file in plugins directory.

This is like the Spell-check plugin.
#@nonl
#@-node:ekr.20031218072017.829:(Must do) gui interface for plugins manager
#@+node:ekr.20031218072017.734:(Must do) Rewrite colorizer to use jEdit language descriptionfiles
#@+node:ekr.20031218072017.735:Option: case insensitive keywords
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2097076
By: nobody

Using Jason's code for Rebol and a visual DIFF, I was able to quickly add the
keywords for the assembler I use. I'm wondering if there is a way to tell Leo
to ignore keyword case -- at the present, each keyword is entered twice. Not
a big problem with modern editors, but it _would_ be nicer...

--Rich
#@-node:ekr.20031218072017.735:Option: case insensitive keywords
#@-node:ekr.20031218072017.734:(Must do) Rewrite colorizer to use jEdit language descriptionfiles
#@+node:ekr.20040130073846:(Must do) Use Python indices instead of Tk indices
This would really help when writing gui plugins.

The first place it would be useful would be in eliminating calls to the Tk search routine.
#@nonl
#@+node:ekr.20040105120208.1:Use string.find or re.find instead of tk.find
#@-node:ekr.20040105120208.1:Use string.find or re.find instead of tk.find
#@+node:ekr.20040203075059:use pos linestart + 1 lines to go to next line?
This might be the best way to reliably have Tk move to the next line!
#@-node:ekr.20040203075059:use pos linestart + 1 lines to go to next line?
#@-node:ekr.20040130073846:(Must do) Use Python indices instead of Tk indices
#@+node:EKR.20040507095329.1:(Must do) More flexible atFile classes
#@+node:EKR.20040507100502:about calling scanDirectives
- called by top_df.read just before calling df.readOpenFile.

- called by atFile.openWriteFile
#@nonl
#@-node:EKR.20040507100502:about calling scanDirectives
#@+node:ekr.20031218072017.2622:<< class baseAtFile methods >>
@others
#@nonl
#@+node:ekr.20031218072017.2623:atFile.__init__ & initIvars
def __init__(self,c):
    
    self.c = c
    self.fileCommands = self.c.fileCommands
    
    # Create subcommanders to handler old and new format derived files.
    self.old_df = oldDerivedFile(c)
    self.new_df = newDerivedFile(c)
    
    self.initIvars()
    
def initIvars(self):
    
    # Set by scanDefaultDirectory.
    self.default_directory = None
    self.errors = 0

    # Set by scanHeader when reading. Set by scanAllDirectives...
    self.encoding = g.app.config.default_derived_file_encoding
    self.endSentinelComment = ""
    self.startSentinelComment = ""
#@nonl
#@-node:ekr.20031218072017.2623:atFile.__init__ & initIvars
#@+node:ekr.20031218072017.2624:top_df.error
def error(self,message):

    g.es(message,color="red")
    print message
    self.errors += 1
#@nonl
#@-node:ekr.20031218072017.2624:top_df.error
#@+node:ekr.20031218072017.2625:Reading
#@+node:ekr.20031218072017.2626: top_df.readAll
def readAll(self,root,partialFlag=False):
    
    """Scan vnodes, looking for @file nodes to read."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    anyRead = False
    at.initIvars()
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            if partialFlag:
                # We are forcing the read.
                at.read(p)
            else:
                # if p is an orphan, we don't expect to see a derived file,
                # and we shall read a derived file if it exists.
                wasOrphan = p.isOrphan()
                ok = at.read(p)
                if wasOrphan and not ok:
                    # Remind the user to fix the problem.
                    p.setDirty()
                    c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for p in c.allNodes_iter():
        p.v.clearOrphan()
        
    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")
#@nonl
#@-node:ekr.20031218072017.2626: top_df.readAll
#@+node:EKR.20040604155223.1:top_df.parseLeoSentinel
def parseLeoSentinel (self,s):
    
    at = self
    new_df = False ; valid = True ; n = len(s)
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    << set the opening comment delim >>
    << make sure we have @+leo >>
    << read optional version param >>
    << read optional thin param >>
    << read optional encoding param >>
    << set the closing comment delim >>
    return valid,new_df,start,end
#@nonl
#@+node:EKR.20040604155223:<< set the opening comment delim >>
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j < i:
    start = s[j:i]
else:
    valid = False
#@nonl
#@-node:EKR.20040604155223:<< set the opening comment delim >>
#@+node:ekr.20031218072017.2635:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False
#@nonl
#@-node:ekr.20031218072017.2635:<< make sure we have @+leo >>
#@+node:ekr.20031218072017.2636:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
    # Skip to the next minus sign or end-of-line
    i += len(version_tag)
    j = i
    while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
        i += 1

    if j < i:
        pass # version = s[j:i]
    else:
        valid = False
#@-node:ekr.20031218072017.2636:<< read optional version param >>
#@+node:EKR.20040503105354:<< read optional thin param >>
if g.match(s,i,thin_tag):
    i += len(tag)
#@nonl
#@-node:EKR.20040503105354:<< read optional thin param >>
#@+node:ekr.20031218072017.2637:<< read optional encoding param >>
# Set the default encoding
at.encoding = g.app.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j > -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 1 # 6/8/04
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j > -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            print "bad encoding in derived file:",encoding
            g.es("bad encoding in derived file:",encoding)
    else:
        valid = False
#@-node:ekr.20031218072017.2637:<< read optional encoding param >>
#@+node:ekr.20031218072017.2638:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
#@nonl
#@-node:ekr.20031218072017.2638:<< set the closing comment delim >>
#@-node:EKR.20040604155223.1:top_df.parseLeoSentinel
#@+node:ekr.20031218072017.1812:top_df.read
# The caller has enclosed this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False):
    
    """Common read logic for any derived file."""
    
    at = self ; c = at.c
    at.errors = 0
    importing = importFileName is not None
    << set fileName from root and importFileName >>
    << open file or return False >>
    g.es("reading: " + root.headString())
    firstLines,read_new = at.scanHeader(file,fileName)
    df = g.choose(read_new,at.new_df,at.old_df)
    # g.trace(g.choose(df==at.new_df,"new","old"))
    << copy ivars to df >>
    root.clearVisitedInTree()
    try:
        # 1/28/04: Don't set comment delims when importing.
        # 1/28/04: Call scanAllDirectives here, not in readOpenFile.
        importing = importFileName is not None
        df.scanAllDirectives(root,importing=importing,reading=True)
        df.readOpenFile(root,file,firstLines)
    except:
        at.error("Unexpected exception while reading derived file")
        g.es_exception()
    file.close()
    root.clearDirty() # May be set dirty below.
    after = root.nodeAfterTree()
    << warn about non-empty unvisited nodes >>
    if df.errors == 0:
        if not df.importing:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return df.errors == 0
#@nonl
#@+node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
at.scanDefaultDirectory(root,importing=importing)
if at.errors: return

if importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@nonl
#@-node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
#@+node:ekr.20031218072017.1814:<< open file or return false >>
fn = g.os_path_join(at.default_directory,fileName)
fn = g.os_path_normpath(fn)

try:
    # 11/4/03: open the file in binary mode to allow 0x1a in bodies & headlines.
    file = open(fn,'rb')
    if file:
        << warn on read-only file >>
    else: return False
except:
    at.error("Can not open: " + '"@file ' + fn + '"')
    root.setDirty()
    return False
#@nonl
#@+node:ekr.20031218072017.1815:<< warn on read-only file >>
try:
    read_only = not os.access(fn,os.W_OK)
    if read_only:
        g.es("read only: " + fn,color="red")
except:
    pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20031218072017.1815:<< warn on read-only file >>
#@-node:ekr.20031218072017.1814:<< open file or return false >>
#@+node:ekr.20031218072017.1816:<< copy ivars to df >>
# Telling what kind of file we are reading.
df.importing = importFileName != None
df.raw = False
if importing and df == at.new_df:
    thinFile = True
df.thinFile = thinFile

# Set by scanHeader.
df.encoding = at.encoding
df.endSentinelComment = at.endSentinelComment
df.startSentinelComment = at.startSentinelComment

# Set other common ivars.
df.errors = 0
df.file = file
df.importRootSeen = False
df.indent = 0
df.targetFileName = fileName
df.root = root
df.root_seen = False
#@nonl
#@-node:ekr.20031218072017.1816:<< copy ivars to df >>
#@+node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file:" + p.headString())
        p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@nonl
#@-node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
#@-node:ekr.20031218072017.1812:top_df.read
#@+node:ekr.20031218072017.2639:top_df.readLine
def readLine (self,file):

    """Reads one line from file using the present encoding"""
    
    s = g.readlineForceUnixNewline(file)
    u = g.toUnicode(s,self.encoding)
    return u
#@nonl
#@-node:ekr.20031218072017.2639:top_df.readLine
#@+node:ekr.20031218072017.2627:top_df.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):
    
    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return
        
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        if dict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@nonl
#@+node:ekr.20031218072017.2628:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04
    
dir = g.choose(name,g.os_path_dirname(name),None)

if dir and g.os_path_isabs(dir):
    if g.os_path_exists(dir):
        at.default_directory = dir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(dir)
        if not at.default_directory:
            at.error("Directory \"" + dir + "\" does not exist")
#@nonl
#@-node:ekr.20031218072017.2628:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20031218072017.2629:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
# We set the current director to a path so future writes will go to that directory.

k = dict["path"]
<< compute relative path from s[k:] >>

if path and len(path) > 0:
    base = g.getBaseDirectory() # returns "" on error.
    path = g.os_path_join(base,path)
    
    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: " + path)
else:
    at.error("ignoring empty @path")

#@+node:ekr.20031218072017.2630:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()
#@nonl
#@-node:ekr.20031218072017.2630:<< compute relative path from s[k:] >>
#@+node:ekr.20031218072017.2631:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path)
    if not at.default_directory:
        at.error("invalid @path: " + path)
#@nonl
#@-node:ekr.20031218072017.2631:<< handle absolute path >>
#@-node:ekr.20031218072017.2629:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20031218072017.2632:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory() # returns "" on error.
    for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if dir and len(dir) > 0:
            dir = g.os_path_join(base,dir)
            if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
                if g.os_path_exists(dir):
                    at.default_directory = dir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(dir)
#@-node:ekr.20031218072017.2632:<< Set current directory >>
#@-node:ekr.20031218072017.2627:top_df.scanDefaultDirectory
#@+node:ekr.20031218072017.2633:top_df.scanHeader
def scanHeader(self,file,fileName):
    
    """Scan the @+leo sentinel.
    
    Sets self.encoding, and self.start/endSentinelComment.
    
    Returns (firstLines,new_df) where:
    firstLines contains all @first lines,
    new_df is True if we are reading a new-format derived file."""
    
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False
    << skip any non @+leo lines >>
    if valid:
        valid,new_df,start,end = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    else:
        at.error("Bad @+leo sentinel in " + fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines, new_df
#@nonl
#@+node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(file)
while len(s) > 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(file)
    
n = len(s)
valid = n > 0
#@-node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
#@-node:ekr.20031218072017.2633:top_df.scanHeader
#@-node:ekr.20031218072017.2625:Reading
#@+node:ekr.20031218072017.2640:Writing
#@+node:ekr.20031218072017.2015:top_df.writeAll
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):
    
    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    write_new = not g.app.config.write_old_format_derived_files
    df = g.choose(write_new,at.new_df,at.old_df)
    df.initIvars()
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave
#@nonl
#@+node:ekr.20031218072017.2016:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
    
for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@nonl
#@-node:ekr.20031218072017.2016:<< Clear all orphan bits >>
#@+node:ekr.20031218072017.2017:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    df.fileChangedFlag = False # 1/9/04
    autoSave = False
    
    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if df.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@nonl
#@-node:ekr.20031218072017.2017:<< handle v's tree >>
#@+node:ekr.20031218072017.2018:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@nonl
#@-node:ekr.20031218072017.2018:<< say the command is finished >>
#@-node:ekr.20031218072017.2015:top_df.writeAll
#@+node:ekr.20031218072017.2641:top_df.write, norefWrite, asisWrite
def norefWrite (self,p,toString=False):
    at = self
    write_new = not g.app.config.write_old_format_derived_files
    df = g.choose(write_new,at.new_df,at.old_df)
    try:    df.norefWrite(p,toString=toString)
    except: at.writeException(p)
    
rawWrite = norefWrite # Compatibility with old scripts.
    
def asisWrite (self,p,toString=False):
    at = self
    try: at.old_df.asisWrite(p,toString=toString) # No new_df.asisWrite method.
    except: at.writeException(p)
    
selentWrite = asisWrite # Compatibility with old scripts.
    
def write (self,p,nosentinels=False,thinFile=False,toString=False):
    at = self
    write_new = thinFile or not g.app.config.write_old_format_derived_files
    df = g.choose(write_new,at.new_df,at.old_df)
    try:    df.write(p,nosentinels=nosentinels,thinFile=thinFile,toString=toString)
    except: at.writeException(p)
#@nonl
#@-node:ekr.20031218072017.2641:top_df.write, norefWrite, asisWrite
#@+node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles
def writeOldDerivedFiles (self,toString=False):
    
    self.writeDerivedFiles(write_old=True,toString=toString)

def writeNewDerivedFiles (self,toString=False):

    self.writeDerivedFiles(write_old=False,toString=toString)
    
def writeDerivedFiles (self,write_old,toString=False):
    
    config = g.app.config
    old = config.write_old_format_derived_files
    config.write_old_format_derived_files = write_old
    self.writeAll(writeAtFileNodesFlag=True,toString=toString)
    config.write_old_format_derived_files = old
#@nonl
#@-node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles
#@+node:ekr.20031218072017.2019:top_df.writeMissing
def writeMissing(self,p,toString=False):

    at = self

    write_new = not g.app.config.write_old_format_derived_files
    df = g.choose(write_new,at.new_df,at.old_df)
    df.initIvars()
    writtenFiles = False ; changedFiles = False

    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after: # Don't use iterator.
        if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
            missing = False ; valid = True
            df.targetFileName = p.anyAtFileNodeName()
            << set missing if the file does not exist >>
            if valid and missing:
                << create df.outputFile >>
                if df.outputFile:
                    << write the @file node >>
                    df.closeWriteFile()
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    
    if writtenFiles > 0:
        g.es("finished")
    else:
        g.es("no missing @file node in the selected tree")
        
    return changedFiles # So caller knows whether to do an auto-save.
#@nonl
#@+node:ekr.20031218072017.2020:<< set missing if the file does not exist >>
# This is similar, but not the same as, the logic in openWriteFile.

valid = df.targetFileName and len(df.targetFileName) > 0

if valid:
    try:
        # Creates missing directives if option is enabled.
        df.scanAllDirectives(p)
        valid = df.errors == 0
    except:
        g.es("exception in atFile.scanAllDirectives")
        g.es_exception()
        valid = False

if valid:
    try:
        fn = df.targetFileName
        df.shortFileName = fn # name to use in status messages.
        df.targetFileName = g.os_path_join(df.default_directory,fn)
        df.targetFileName = g.os_path_normpath(df.targetFileName)

        path = df.targetFileName # Look for the full name, not just the directory.
        valid = path and len(path) > 0
        if valid:
            missing = not g.os_path_exists(path)
    except:
        g.es("exception creating path:" + fn)
        g.es_exception()
        valid = False
#@nonl
#@-node:ekr.20031218072017.2020:<< set missing if the file does not exist >>
#@+node:ekr.20031218072017.2021:<< create df.outputFile >>
if toString:
    df.outputFileName = "<string: %s>" % df.targetFileName
    df.outputFile = g.fileLikeObject()
else:
    try:
        df.outputFileName = df.targetFileName
        df.outputFile = open(df.outputFileName,'wb')
        if df.outputFile is None:
            g.es("can not open " + df.outputFileName)
    except IOError:
        g.es("Can not open " + df.outputFileName)
        g.es_exception()
        df.outputFile = None
#@nonl
#@-node:ekr.20031218072017.2021:<< create df.outputFile >>
#@+node:ekr.20031218072017.2022:<< write the @file node >>
if p.isAtAsisFileNode():
    at.asisWrite(p)
elif p.isAtNorefFileNode():
    at.norefWrite(p)
elif p.isAtNoSentFileNode():
    at.write(p,nosentinels=True)
elif p.isAtFileNode():
    at.write(p)
else: assert(0)

writtenFiles = True

if df.fileChangedFlag: # Set by replaceTargetFileIfDifferent.
    changedFiles = True
#@nonl
#@-node:ekr.20031218072017.2022:<< write the @file node >>
#@-node:ekr.20031218072017.2019:top_df.writeMissing
#@+node:EKR.20040620103353:top_df.writeException
def writeException(self,p):

    self.error("Unexpected exception while writing " + p.headString())
    g.es_exception()
#@nonl
#@-node:EKR.20040620103353:top_df.writeException
#@-node:ekr.20031218072017.2640:Writing
#@-node:ekr.20031218072017.2622:<< class baseAtFile methods >>
#@+node:ekr.20031218072017.2387:old_df.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(dict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20031218072017.2388:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = g.app.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.2388:<< Set ivars >>
#@+node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

dir = g.choose(name,g.os_path_dirname(name),None)

if dir and len(dir) > 0 and g.os_path_isabs(dir):
    if g.os_path_exists(dir):
        self.default_directory = dir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(dir)
        if not self.default_directory:
            self.error("Directory \"" + dir + "\" does not exist")
#@nonl
#@-node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20031218072017.2390:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
    k = dict["comment"]
    # 11/14/02: Similar to fix below.
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
    k = dict["language"]
    # 11/14/02: Fix bug reported by J.M.Gilligan.
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.2390:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.2391:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20031218072017.2391:<< Test for @encoding >>
#@+node:ekr.20031218072017.2392:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20031218072017.2392:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.2393:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,dict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.2393:<< Test for @lineending >>
#@+node:ekr.20031218072017.2394:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: " + path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20031218072017.2395:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.2395:<< compute relative path from s[k:] >>
#@+node:ekr.20031218072017.2396:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: " + path)
#@-node:ekr.20031218072017.2396:<< handle absolute path >>
#@-node:ekr.20031218072017.2394:<< Test for @path >>
#@+node:ekr.20031218072017.2397:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.2397:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.2398:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20031218072017.2398:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.2399:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory() # returns "" on error.
    for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if dir and len(dir) > 0:
            dir = g.os_path_join(base,dir)
            if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
                if g.os_path_exists(dir):
                    self.default_directory = dir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(dir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20031218072017.2399:<< Set current directory >>
#@+node:ekr.20031218072017.2400:<< Set comment strings from delims >>
if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20031218072017.2400:<< Set comment strings from delims >>
#@-node:ekr.20031218072017.2387:old_df.scanAllDirectives
#@+node:EKR.20040507095329.2:To do
@nocolor

- Reading and writing to/from strings.
	- Use these routines in perfectImport and Execute Script command.

- User alterable reading/writing (tangling/untangling)
#@nonl
#@-node:EKR.20040507095329.2:To do
#@+node:ekr.20031218072017.2647:old_df.readOpenFile
def readOpenFile(self,root,file,firstLines):
    
    """Read an open 3.x derived file."""
    
    at = self

    # Scan the file buffer
    lastLines = at.scanText(file,root,[],endLeo)
    root.v.t.setVisited() # Disable warning about set nodes.

    # Handle first and last lines.
    try: body = root.v.t.tempBodyString
    except: body = ""
    lines = body.split('\n')
    at.completeFirstDirectives(lines,firstLines)
    at.completeLastDirectives(lines,lastLines)
    s = '\n'.join(lines).replace('\r', '')
    root.v.t.tempBodyString = s
#@nonl
#@-node:ekr.20031218072017.2647:old_df.readOpenFile
#@+node:ekr.20031218072017.2757:new_df.readOpenFile
def readOpenFile(self,root,file,firstLines):
    
    """Read an open 4.x thick or thin derived file."""
    
    at = self

    # Scan the 4.x file.
    at.tnodeListIndex = 0
    # 4/27/04: at.thinFile tells scanText4 whether this is a thin file or not.
    lastLines = at.scanText4(file,root)
    root.v.t.setVisited() # Disable warning about set nodes.
    
    # Handle first and last lines.
    try: body = root.v.t.tempBodyString
    except: body = ""
    lines = body.split('\n')
    at.completeFirstDirectives(lines,firstLines)
    at.completeLastDirectives(lines,lastLines)
    s = '\n'.join(lines).replace('\r', '')
    root.v.t.tempBodyString = s
#@nonl
#@-node:ekr.20031218072017.2757:new_df.readOpenFile
#@+node:EKR.20040506075328:new_df.writeOpenFile
def writeOpenFile(self,root,nosentinels=False,scriptFile=None,thinFile=False,toString=False):
    
    at = self ; c = at.c
    
    << init atFile ivars for writing >>
    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    << put all @first lines in root >>

    # Put the main part of the file.
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    
    << put all @last lines in root >>
    
    if not toString and not scriptFile and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
#@nonl
#@+node:EKR.20040506075328.1:<< init atFile ivars for writing >>
# Set flags telling what kind of writing we are doing.
at.sentinels = not nosentinels
at.thinFile = thinFile
at.scripting = scriptFile is not None
at.raw = False
assert(at.toStringFlag == toString) # Must have been set earlier.

# Init other ivars.
at.errors = 0
c.setIvarsFromPrefs()
at.root = root
at.root.v.t.tnodeList = []

c.endEditing() # Capture the current headline.
#@nonl
#@-node:EKR.20040506075328.1:<< init atFile ivars for writing >>
#@+node:ekr.20031218072017.2118:<< put all @first lines in root >> (4.x)
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    self.os(line) ; self.onl()
    i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20031218072017.2118:<< put all @first lines in root >> (4.x)
#@+node:ekr.20031218072017.2119:<< put all @last lines in root >> (4.x)
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"

# 4/17/04 Use g.splitLines to preserve trailing newlines.
lines = g.splitLines(root.v.t.bodyString)
n = len(lines) ; j = k = n - 1

# Scan backwards for @last directives.
while j >= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    elif not line.strip():
        j -= 1
    else: break
    
# Write the @last lines.
for line in lines[j+1:k+1]:
    if g.match(line,0,tag):
        i = len(tag) ; i = g.skip_ws(line,i)
        self.os(line[i:])
#@nonl
#@-node:ekr.20031218072017.2119:<< put all @last lines in root >> (4.x)
#@-node:EKR.20040506075328:new_df.writeOpenFile
#@-node:EKR.20040507095329.1:(Must do) More flexible atFile classes
#@+node:EKR.20040424151321:(Status line experiments) TO DO: create status line class
#@+node:ekr.20031218072017.3941: frame.Birth & Death
#@+node:ekr.20031218072017.1801:f.__init__
def __init__(self,title):

    # Init the base class.
    leoFrame.leoFrame.__init__(self)

    self.title = title
    leoTkinterFrame.instances += 1
    self.c = None # Set in finishCreate.

    << set the leoTkinterFrame ivars >>
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# Created in createLeoFrame and its allies.
self.top = None
self.tree = None
self.f1 = self.f2 = None
self.log = None  ; self.logBar = None
self.body = None ; self.bodyCtrl = None ; self.bodyBar = None ; self.bodyXBar = None
self.canvas = None ; self.treeBar = None
self.splitter1 = self.splitter2 = None
self.icon = None
self.outerFrame = None # 5/20/02
self.iconFrame = None # 5/20/02
self.statusFrame = None # 5/20/02
self.statusText = None # 5/20/02
self.statusLabel = None # 5/20/02

# Used by event handlers...
self.redrawCount = 0
self.draggedItem = None
self.controlKeyIsDown = False # For control-drags
self.revertHeadline = None # Previous headline text for abortEditLabel.
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:f.__init__
#@+node:ekr.20031218072017.3942:f.__repr__
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:f.__repr__
#@+node:ekr.20031218072017.3943:Creating the frame
#@+node:ekr.20031218072017.3944:f.createCanvas
def createCanvas (self,parentFrame):
    
    frame = self ; config = g.app.config
    
    scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)

    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", self.OnMouseWheel)
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
#@nonl
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
import threading
import time
way = 'Down' # global.
ev = threading.Event()

def run(ev = ev):
    global way
    while 1:
        ev.wait()
        if way=='Down': canvas.yview("scroll", 1,"units")
        else:           canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()
    
def exe(event,ev=ev,theWay='Down',canvas=canvas):
    global way
    if event.widget!=canvas: return
    if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    way = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    canvas.bind_all('<Shift Button-3>',exe)
    canvas.bind_all('<Shift Button-1>',lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all('<Shift ButtonRelease-1>', off)
    canvas.bind_all('<Shift ButtonRelease-3>', off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>', exe)
    canvas.bind_all( '<Button-1>', lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all( '<ButtonRelease-1>', off)
    canvas.bind_all( '<ButtonRelease-3>', off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20031218072017.3944:f.createCanvas
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui

    << create the toplevel frame >>
    << create all the subframes >>
    << create the first tree node >>

    self.menu = leoTkinterMenu.leoTkinterMenu(frame)

    v = c.currentVnode()

    if not g.doHook("menu1",c=c,v=v):
        frame.menu.createMenuBar(self)

    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log

    g.app.windowList.append(frame)
    
    c.initVersion()
    c.signOnWithVersion()
    
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel frame >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

frame.top.bind("<Activate>", frame.OnActivateLeoEvent) # Doesn't work on windows.
frame.top.bind("<Deactivate>", frame.OnDeactivateLeoEvent) # Doesn't work on windows.

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel frame >>
#@+node:ekr.20031218072017.2178:<< create all the subframes >>
# Create the outer frame.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")

self.createIconBar()
<< create both splitters >>

# Create the canvas, tree, log and body.
frame.canvas   = self.createCanvas(self.split2Pane1)
frame.tree     = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log      = leoTkinterLog(frame,self.split2Pane2)
frame.body     = leoTkinterBody(frame,self.split1Pane2)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.  N.B. There may be Tk bugs here that make the order significant!
frame.setTabWidth(c.tab_width)
frame.tree.setTreeColorsFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()

if 0: # No longer done automatically.

    # Create the status line.
    self.createStatusLine()
    self.putStatusLine("Welcome to Leo")
#@nonl
#@+node:ekr.20031218072017.2179:<< create both splitters >>
# Splitter 1 is the main splitter containing splitter2 and the body pane.
f1,bar1,split1Pane1,split1Pane2 = self.createLeoSplitter(outerFrame, self.splitVerticalFlag)
self.f1,self.bar1 = f1,bar1
self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

# Splitter 2 is the secondary splitter containing the tree and log panes.
f2,bar2,split2Pane1,split2Pane2 = self.createLeoSplitter(split1Pane1, not self.splitVerticalFlag)
self.f2,self.bar2 = f2,bar2
self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@-node:ekr.20031218072017.2179:<< create both splitters >>
#@-node:ekr.20031218072017.2178:<< create all the subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3945:Creating the splitter
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,secondary_ratio):

    self.divideLeoSplitter(self.splitVerticalFlag, ratio)
    self.divideLeoSplitter(not self.splitVerticalFlag, secondary_ratio)
    # g.trace(ratio)
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):
    
    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3948:createLeoSplitter
# 5/20/03: Removed the ancient kludge for forcing the height & width of f.
# The code in leoFileCommands.getGlobals now works!

def createLeoSplitter (self, parent, verticalFlag):
    
    """Create a splitter window and panes into which the caller packs widgets.
    
    Returns (f, bar, pane1, pane2) """
    
    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    pane1 = Tk.Frame(f)
    pane2 = Tk.Frame(f)
    bar =   Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,pane1,pane2,verticalFlag)

    return f, bar, pane1, pane2
#@nonl
#@-node:ekr.20031218072017.3948:createLeoSplitter
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@-node:ekr.20031218072017.3945:Creating the splitter
#@+node:ekr.20031218072017.3953:Creating the icon area
#@+node:ekr.20031218072017.3954:createIconBar
def createIconBar (self):
    
    """Create an empty icon bar in the packer's present position"""

    if not self.iconFrame:
        self.iconFrame = Tk.Frame(self.outerFrame,height="5m",bd=2,relief="groove")
        self.iconFrame.pack(fill="x",pady=2)
#@nonl
#@-node:ekr.20031218072017.3954:createIconBar
#@+node:ekr.20031218072017.3955:hideIconBar
def hideIconBar (self):
    
    """Hide the icon bar by unpacking it.
    
    A later call to showIconBar will repack it in a new location."""
    
    if self.iconFrame:
        self.iconFrame.pack_forget()
#@-node:ekr.20031218072017.3955:hideIconBar
#@+node:ekr.20031218072017.3956:clearIconBar
def clearIconBar(self):
    
    """Destroy all the widgets in the icon bar"""
    
    f = self.iconFrame
    if not f: return
    
    for slave in f.pack_slaves():
        slave.destroy()

    f.configure(height="5m") # The default height.
    g.app.iconWidgetCount = 0
    g.app.iconImageRefs = []
#@-node:ekr.20031218072017.3956:clearIconBar
#@+node:ekr.20031218072017.3957:showIconBar
def showIconBar(self):
    
    """Show the icon bar by repacking it"""

    self.iconFrame.pack(fill="x",pady=2)
#@nonl
#@-node:ekr.20031218072017.3957:showIconBar
#@+node:ekr.20031218072017.3958:addIconButton
def addIconButton(self,text=None,imagefile=None,image=None,command=None,bg=None):
    
    """Add a button containing text or a picture to the icon bar.
    
    Pictures take precedence over text"""
    
    f = self.iconFrame
    if not imagefile and not image and not text: return

    # First define n.	
    try:
        g.app.iconWidgetCount += 1
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 1

    if not command:
        def command(n=n):
            print "command for widget %s" % (n)

    if imagefile or image:
        << create a picture >>
    elif text:
        w = min(6,len(text))
        b = Tk.Button(f,text=text,width=w,relief="groove",bd=2,command=command)
        b.pack(side="left", fill="y")
        return b
        
    return None
#@nonl
#@+node:ekr.20031218072017.3959:<< create a picture >>
try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)
        
        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []
    
        refs.append((imagefile,image),)
    
    if not bg:
        bg = f.cget("bg")

    b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b
    
except:
    g.es_exception()
    return None
#@nonl
#@-node:ekr.20031218072017.3959:<< create a picture >>
#@-node:ekr.20031218072017.3958:addIconButton
#@-node:ekr.20031218072017.3953:Creating the icon area
#@+node:ekr.20031218072017.3960:Creating the status area


#@+node:ekr.20031218072017.3961:createStatusLine
def createStatusLine (self):
    
    if self.statusFrame and self.statusLabel:
        return
    
    self.statusFrame = statusFrame = Tk.Frame(self.outerFrame,bd=2)
    statusFrame.pack(fill="x",pady=1)
    
    text = "line 0, col 0"
    width = len(text) + 4
    self.statusLabel = Tk.Label(statusFrame,text=text,width=width,anchor="w")
    self.statusLabel.pack(side="left",padx=1)
    
    bg = statusFrame.cget("background")
    self.statusText = Tk.Text(statusFrame,height=1,state="disabled",bg=bg,relief="groove")
    self.statusText.pack(side="left",expand=1,fill="x")

    # Register an idle-time handler to update the row and column indicators.
    self.statusFrame.after_idle(self.updateStatusRowCol)
#@nonl
#@-node:ekr.20031218072017.3961:createStatusLine
#@+node:ekr.20031218072017.3962:clearStatusLine
def clearStatusLine (self):
    
    t = self.statusText
    if not t: return
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3962:clearStatusLine
#@+node:EKR.20040424153344:enable/disableStatusLine & isEnabled
def disableStatusLine (self):
    
    t = self.statusText
    if t:
        t.configure(state="disabled",background="gray")
    
def enableStatusLine (self):
    
    t = self.statusText
    if t:
        t.configure(state="normal",background="pink")
        t.focus_set()
        
def statusLineIsEnabled(self):
    t = self.statusText
    if t:
        state = t.cget("state")
        return state == "normal"
    else:
        return False
#@nonl
#@-node:EKR.20040424153344:enable/disableStatusLine & isEnabled
#@+node:ekr.20031218072017.3963:putStatusLine
def putStatusLine (self,s,color=None):
    
    t = self.statusText ; tags = self.statusColorTags
    if not t: return

    t.configure(state="normal")
    
    if "black" not in self.log.colorTags:
        tags.append("black")
        
    if color and color not in tags:
        tags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3963:putStatusLine
#@+node:EKR.20040424154804:setFocusStatusLine
def setFocusStatusLine (self):
    
    t = self.statusText
    if t:
        t.focus_set()
#@nonl
#@-node:EKR.20040424154804:setFocusStatusLine
#@+node:ekr.20031218072017.1733:updateStatusRowCol
def updateStatusRowCol (self):
    
    c = self.c ; body = self.bodyCtrl ; lab = self.statusLabel
    gui = g.app.gui
    if not lab: return
    
    # New for Python 2.3: may be called during shutdown.
    if g.app.killed:
        return

    if 0: # New code
        index = c.frame.body.getInsertionPoint()
        row,col = c.frame.body.indexToRowColumn(index)
        index1 = c.frame.body.rowColumnToIndex(row,0)
    else:
        index = body.index("insert")
        row,col = gui.getindex(body,index)
    
    if col > 0:
        if 0: # new code
            s = c.frame.body.getRange(index1,index2)
        else:
            s = body.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03
        col = g.computeWidth (s,self.tab_width)

    if row != self.lastStatusRow or col != self.lastStatusCol:
        s = "line %d, col %d " % (row,col)
        lab.configure(text=s)
        self.lastStatusRow = row
        self.lastStatusCol = col
        
    # Reschedule this routine 100 ms. later.
    # Don't use after_idle: it hangs Leo.
    self.statusFrame.after(100,self.updateStatusRowCol)
#@nonl
#@-node:ekr.20031218072017.1733:updateStatusRowCol
#@-node:ekr.20031218072017.3960:Creating the status area
#@-node:ekr.20031218072017.3943:Creating the frame
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subclasses.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):
    
    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
            
    self.comparePanel = None
    self.colorPanel = None
    self.fontPanel = None
    self.prefsPanel = None
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf
def destroySelf (self):
    
    top = self.top # Remember this: we are about to destroy all of our ivars!

    if g.app.windowList:
        self.destroyAllObjects()

    top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: frame.Birth & Death
#@+node:ekr.20031218072017.3960:Creating the status area


#@+node:ekr.20031218072017.3961:createStatusLine
def createStatusLine (self):
    
    if self.statusFrame and self.statusLabel:
        return
    
    self.statusFrame = statusFrame = Tk.Frame(self.outerFrame,bd=2)
    statusFrame.pack(fill="x",pady=1)
    
    text = "line 0, col 0"
    width = len(text) + 4
    self.statusLabel = Tk.Label(statusFrame,text=text,width=width,anchor="w")
    self.statusLabel.pack(side="left",padx=1)
    
    bg = statusFrame.cget("background")
    self.statusText = Tk.Text(statusFrame,height=1,state="disabled",bg=bg,relief="groove")
    self.statusText.pack(side="left",expand=1,fill="x")

    # Register an idle-time handler to update the row and column indicators.
    self.statusFrame.after_idle(self.updateStatusRowCol)
#@nonl
#@-node:ekr.20031218072017.3961:createStatusLine
#@+node:ekr.20031218072017.3962:clearStatusLine
def clearStatusLine (self):
    
    t = self.statusText
    if not t: return
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3962:clearStatusLine
#@+node:EKR.20040424153344:enable/disableStatusLine & isEnabled
def disableStatusLine (self):
    
    t = self.statusText
    if t:
        t.configure(state="disabled",background="gray")
    
def enableStatusLine (self):
    
    t = self.statusText
    if t:
        t.configure(state="normal",background="pink")
        t.focus_set()
        
def statusLineIsEnabled(self):
    t = self.statusText
    if t:
        state = t.cget("state")
        return state == "normal"
    else:
        return False
#@nonl
#@-node:EKR.20040424153344:enable/disableStatusLine & isEnabled
#@+node:ekr.20031218072017.3963:putStatusLine
def putStatusLine (self,s,color=None):
    
    t = self.statusText ; tags = self.statusColorTags
    if not t: return

    t.configure(state="normal")
    
    if "black" not in self.log.colorTags:
        tags.append("black")
        
    if color and color not in tags:
        tags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3963:putStatusLine
#@+node:EKR.20040424154804:setFocusStatusLine
def setFocusStatusLine (self):
    
    t = self.statusText
    if t:
        t.focus_set()
#@nonl
#@-node:EKR.20040424154804:setFocusStatusLine
#@+node:ekr.20031218072017.1733:updateStatusRowCol
def updateStatusRowCol (self):
    
    c = self.c ; body = self.bodyCtrl ; lab = self.statusLabel
    gui = g.app.gui
    if not lab: return
    
    # New for Python 2.3: may be called during shutdown.
    if g.app.killed:
        return

    if 0: # New code
        index = c.frame.body.getInsertionPoint()
        row,col = c.frame.body.indexToRowColumn(index)
        index1 = c.frame.body.rowColumnToIndex(row,0)
    else:
        index = body.index("insert")
        row,col = gui.getindex(body,index)
    
    if col > 0:
        if 0: # new code
            s = c.frame.body.getRange(index1,index2)
        else:
            s = body.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03
        col = g.computeWidth (s,self.tab_width)

    if row != self.lastStatusRow or col != self.lastStatusCol:
        s = "line %d, col %d " % (row,col)
        lab.configure(text=s)
        self.lastStatusRow = row
        self.lastStatusCol = col
        
    # Reschedule this routine 100 ms. later.
    # Don't use after_idle: it hangs Leo.
    self.statusFrame.after(100,self.updateStatusRowCol)
#@nonl
#@-node:ekr.20031218072017.1733:updateStatusRowCol
#@-node:ekr.20031218072017.3960:Creating the status area
#@-node:EKR.20040424151321:(Status line experiments) TO DO: create status line class
#@+node:EKR.20040612081353:Remove app.use_gnx and related config settings
@

This implies:
    
- Deprecating old-style file formats.
- Removing commands that write old-style formats.
#@nonl
#@-node:EKR.20040612081353:Remove app.use_gnx and related config settings
#@+node:EKR.20040603092958.1:Add new options for handling newlines in body text
@nocolor

Alas, this really does not solve problems with Import.

- "asis":  ideal, maybe not possible?
- "zero": no trailing newlines.
- "one": exactly one trailing newline.

Special case code is required so empty nodes stay empty with "one" option.
#@nonl
#@-node:EKR.20040603092958.1:Add new options for handling newlines in body text
#@+node:ekr.20040217153407:User customizeable tangling and untangling
#@+node:ekr.20031218072017.805:Allow other section delims besides << and >>
Maybe the section operator could be customizable, 
I personally prefer the wiki way [[name of section]]. 

@setlink-tag [[ ]] 
#@-node:ekr.20031218072017.805:Allow other section delims besides << and >>
#@+node:ekr.20031218072017.803:@template directive?
#@-node:ekr.20031218072017.803:@template directive?
#@+node:ekr.20031218072017.795:Metatags
@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 3.11 todo list & schedule   
2003-02-11 03:25  

Here are some features I'd like to see: 
 

 
3. Metatags. @sectionname or @savedate are expanded to the appropriate text when saved.

-marshall-  
#@-node:ekr.20031218072017.795:Metatags
#@-node:ekr.20040217153407:User customizeable tangling and untangling
#@+node:ekr.20040217153407.3:Emacs-style keystroke handling
#@+node:ekr.20031218072017.806:Auto-completion (probably won't be done)
Jonathan M. Gilligan

Autocompletion of some sort (like IDLE's edit/expand-word command). It would be
nice also to have an autocompletion for noweb node names, possibly also with
autocompletion of abbreviations (as many text editors do) and/or
language-specific keywords taken from a dictionary selected by @language.
#@-node:ekr.20031218072017.806:Auto-completion (probably won't be done)
#@+node:ekr.20031218072017.789:Delay body display so alt+arrow keys aren't slowed
@nocolor

need a delay on body display so alt+arrow keys arent slowed down while navigating.

EKR: Alt-Up and Alt-Down are bound to Go To Next/Prev visible.  The idea is that if we don't display the body text these keys will work faster.  
#@nonl
#@-node:ekr.20031218072017.789:Delay body display so alt+arrow keys aren't slowed
#@+node:ekr.20031218072017.749:Meta key
#@+node:ekr.20031218072017.750:Comments
@nocolor

As recent experiments have shown, it is very difficult to make changes in the body key handlers.

Furthermore, emacs essentially takes over the handling of _all_ keystrokes.  I like this approach, and it is way too much to do in 3.11 or 4.0.
#@nonl
#@-node:ekr.20031218072017.750:Comments
#@+node:ekr.20031218072017.751:Request
@nocolor

How about a Emacs style meta-key(Esc?) followed by up or down? or F1/F2 ? anything to escape having to hold down three keys at the same time -- which seems to be common to other shortcut combinations too. so if you could put this in as an option in the preferences -- to turn on or off meta-key binding, that would let people choose what they prefer...

EKR:  This would require Leo to remember state in the event handlers.  It could be done, and having user-configurable shortcuts should reduce the need for this considerably.
#@-node:ekr.20031218072017.751:Request
#@+node:ekr.20031218072017.752:From Brian Theado
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1864564
By: btheado

WAS:RE: Leo 3.10 comments
edream wrote:
>This is due to apparent glitches in the Tk event dispatching. The problem is
that pressing a control or alt or shift key _all by themselves_ will generate
keypress events that are passed on to Leo's key handlers

This should be easy to make simpler--just bind an empty script to <Alt-KeyPress>,
<Shift-KeyPress>, etc.  Tk chooses the most specific event it can find, so the
more general <KeyPress> handler will not fire.

On a broader note, when programming the text widget in Tcl/Tk, watching key
events is not the easiest way to detect changes in the text.  The only way the
text in a text widget can change is if either the delete or the insert subcommands
(methods) are called.  Any keypresses that end up changing text will have called
one of these subcommands.

So the simplest way to detect changes is to just intercept the calls to insert
and delete.  In Tcl/Tk intercepting these calls is pretty straightforward. 
I don't know if the same is true in Tkinter.

Also note the text widget in Tk8.4 (http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm#M72)
has a built-in way of seeing if the text has changed

All this is just food for thought.  I don't know the details of Leo's code,
so it may not be very helpful.

Brian Theado

-----

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1864584
By: btheado

If you don't already know about Tk's bindtags command, then check it out.  It
should make things like this easy.  It basically allows you to dynamically add
and remove a whole group of bindings all at once without affecting any other
bindings.

i.e. if you have a window called .text:

# Enter escape mode
bind .text <Esc> {
    # add EscapeMode to .text's list of bindings by
    # using the bindtags command (not shown)
}
bind EscapeMode <Up> {
    # Add special escape mode up handling code here
    break
}
bind EscapeMode <Down> {
    # Add special escape mode down handling code
    break
}
etc.

# Leave escape mode
bind EscapeMode <Esc> {
    # remove EscapeMode from .text's list of bindings
    # by using the bindtags command (not shown)
}

See (http://wiki.tcl.tk/bindtags) for a page with more information about bindtags
and a link to the bindtags man page.

I just wanted you to be aware of this functionality if and when you do tackle
this.  I have found Tk's event handling, bindtags functionality very powerful,
easy to use, and quite elegant for the coding I've done.

Brian Theado
#@nonl
#@-node:ekr.20031218072017.752:From Brian Theado
#@-node:ekr.20031218072017.749:Meta key
#@+node:ekr.20040401121456:emacs roadmap
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2499058
By: sgbotsford

Actually, I don't particularly care if VIM or gvim, or vi or whatever actually
works with leo.  What I would like is for the vi command keys mostly work in
leo.  It doesn't have to be
complete vi, although the closer it is, the easier for people to adapt. 

-------

Thanks for these remarks.  It's good to know what is most important for a (typical?) Emacs user.

> A first level approximation to this would be just a different shortcut keymap.

That's already possible: just edit leoConfig.txt.

> Second level would be in implement the movement commands that aren't in leo.

That would be pretty easy in a plugin.  This is probably the most important thing that Leo should have in its core to support "driving" the editor as in Emacs.  The other thing is to support the emacs style of handling keystrokes (writing keystroke info to a status line).  Better feedback on the status line will happen asap.

> Third level would be to put the hooks in for running external commands.

That already exists in various forms.  However, if what already exists isn't exactly what you want it would be very easy to write a plugin to do it.

Edward
#@nonl
#@-node:ekr.20040401121456:emacs roadmap
#@-node:ekr.20040217153407.3:Emacs-style keystroke handling
#@+node:ekr.20031218072017.736:Use xml parser to read .leo files
http://www.reportlab.com

import xml.sax
#@-node:ekr.20031218072017.736:Use xml parser to read .leo files
#@+node:ekr.20040329182535:plugins
#@+node:ekr.20040130185920.1:** Add incremental search to search plugin (make find panel smaller)
#@-node:ekr.20040130185920.1:** Add incremental search to search plugin (make find panel smaller)
#@+node:ekr.20040217154256:Autocompletion
#@+node:ekr.20031218072017.798:@dictionary
@nocolor

Developers
By: jasonic ( Jason Cunliffe ) 
 @dictionary   
2003-08-21 07:51

Auto-completion dictionary files would be excellent.
Ideally each Leo language extension could just point to a separate .dict file. 

Hopefully we can build some Leo plugin utilities to generate these .dict files by parsing any file you'd like to use a 'source' for Leo dictionary. They might need manual cleanup, but vcould be big timesaver, especially for XML formats and the like. Great to be able to sahre these easily. 

Interesting uses for Leo dictionaries beyond just autocompletion. 
I am thinking they might open the door to some powerful macro/template behavior. 

For example, you load a special dictionary to help certain kinds of repetitive formatted content. CSS and XSLT could be good candidates, but also any kind of mild databases or lists. Documentation.

So first we need basic dicts for Leo supported languages: Python, Perl, Javascript etc..

Then we need to consider that any Leo Node could have its own dictionary defined inline..

@dictionary filepath-to-custom-leo-dict

With collaborative LeoN this would be very useful because connected Leo sessions could invoke each other's dictionaries!!

- Jason  
#@-node:ekr.20031218072017.798:@dictionary
#@-node:ekr.20040217154256:Autocompletion
#@+node:ekr.20040125114744:Leo to docbook xml plugin: Leo2AsciiDoc
http://sourceforge.net/forum/message.php?msg_id=2388444
By: mdawson

I use DocBook XML for my computer documentation, and lately for
publishing just about any text document.  Naturally, I wanted an
easy way to use DocBook to publish Leo outlines.

I've written a small Leo module, called Leo2AsciiDoc, that enables
automatic publication of a plain text Leo outline to HTML or PDF, or
as a web site or man page.  Stuart Rackham's AsciiDoc program (in
Python) is what makes this possible.
    Leo2AsciiDoc exports a Leo outline to a text file, from whence
it can be converted to DocBook XML by AsciiDoc, and then
automatically published via DocBook to HTML or PDF.

One Leo outline can contain any number of documents, or web sites
(via DocBook Website).

I'm also learning Literate Programming, and am happy to be able to
automatically publish (via make) a program's source and
documentation from Leo.

An example of the product is the paged HTML documentation for the
module at:
    http://devguide.leo.marshallresearch.ca

The web page for Leo2AsciiDoc is
at:
    http://leo.marshallresearch.ca

That web site is produced from a Leo outline.

    ----------------------------------------
    Michael Dawson
#@nonl
#@-node:ekr.20040125114744:Leo to docbook xml plugin: Leo2AsciiDoc
#@+node:ekr.20031218072017.830:Finish wx plugin & improve how Leo uses indices
#@-node:ekr.20031218072017.830:Finish wx plugin & improve how Leo uses indices
#@+node:ekr.20040208095208:Mark Task & Clone To Task commands
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2415033
By: nobody

Ive been scanning Speed Reams Slash post and the Faq and saw an interesting
usage pattern: Creating a node called a Task and adding cloned nodes to it that
represent that task(I hope that explains it).  I can see myself using this idiom
in the future.  Now my question is does the Task/clone idiom warrant special
commands in Leo?  My basis:

1. Do enough Leo users work with this idiom that making it easier to utilize
would be desirable?  I guess a good rule of thumb might be, if the sequence
of actions occur more frequently than the primitive commands like opening a
file it should be considered.

Maybe a way of doing it:

1. A special mark node as Task command.
2. A Add to lask marked task command, that clones a node and moves that node
into the Task node.
#@nonl
#@-node:ekr.20040208095208:Mark Task & Clone To Task commands
#@-node:ekr.20040329182535:plugins
#@-node:EKR.20040609091327:To do: 4.3: configuration, plugins & translation
#@+node:ekr.20040329182535.7:1-2 hour projects
#@+node:EKR.20040604082214:Use virtual events for Copy, Paste etc.
@nocolor

- This might fix some binding problems on some platforms.

- Might want to define <<localUndo>> for undo in Find Panel.

- Probably should define <<selectAll>> for Find Panel and similar stuff.
#@nonl
#@-node:EKR.20040604082214:Use virtual events for Copy, Paste etc.
#@+node:ekr.20040414093758:Suggestions
@nocolor
 RE: Leo's reorganized to-do list   
2004-03-31 05:48  

 in order of most likely to least possible,

+1 on defining __main__ and allowing parameters to scripts.

add python -t to test suite to catch mixed tab & space in derived files.
leoFind.py: inconsistent use of tabs and spaces 

Edit-> Delete while in headline deletes body text.

unregisterhook()

we can script the find, can we script the compare?

insert/overstrike mode in body

@path and other directives accept python expressions

add a Stop button for find/change 
and other possibly long running scripts.
possibly a plugin can already do this.

Tabbed log/Find/config window.

 
#@-node:ekr.20040414093758:Suggestions
#@+node:ekr.20040329190314:Most important
#@+node:ekr.20031218072017.833:Use @file extension by default if no @language
@nocolor

Open discussion
By: jasonic ( Jason Cunliffe ) 
 use of @language   
2003-07-16 03:40  

I am wondering why Leo does not default to just use the file suffix in @file nodes, instead of obliging @language line in in the body pane 

For example any @file ending with a suffix as defined in the language extensions could just default to use those. 

".py" for python 
".r" for rebol 
".as" for actionscript etc.. 

Should anyone need to over-ride those, they could use @language.
#@nonl
#@-node:ekr.20031218072017.833:Use @file extension by default if no @language
#@+node:ekr.20031218072017.746:Minimizing/maximizing windows
@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2090601
By: jasonic

I'll be happy to run some test and report to you. But  I suspect from your post
a slight misunderstanding about Alt+Tab.

Alt+Tab just toggles the active window.
It works fine with Leo on Windows wherver I have tried it.

Resizing wondows via hotkeys is another matter.
The special "Windows" Key + m will minimize all windows. 

But unfortunately I've not yet discovered any opposite shortcut to  maximize
all windows :-(
I've tried various 3rd party hotkey utililties, but somehow always end up dropping
them.

<rant>
I really hate wasting any time dragging windows around and resizing them or
clicking to bring them into top focus. As I work mainly with graphics, and mult-task
intesenlty bwetn apps,  it is especially important to reduce visual clutter
on screen.

For many years the way to do this has been combining maximized [or minimized]
windows with  Alt+Tab. Alt+Tab  lets one jump rapidly betwen open apps and windows
without ever need to repostion or resize them.

As a consultant, its one of the first things I ever teach clients. Often it
transforms their perception of using Windows.

It is so painful to watch people dragging and rescaling  windows all over the
place. Ironically, I've witnessed some very smart programmers fly through vi
or emacs but then slow to tortoises when navigation mice and windows. I beleive
as long as we have the curertn wnidows UI paradigm,  use of Alt+Tab is an essential
part of  GUI 'litteracy' - an essentail skill all shoudl have. Alas its still
little known or discussed.

There is also a nice toggle feature so one can jump back to the last app/window
as its first "stop". Typically one is working between two apps for some specific
task, even though many are open.

Keeping one's finger on the 'Alt' key then tapping 'Tab' lets one hop along
the list.

Adding 'shift' to the mix helps one to go in reverse. 

Above all one can keep one hand on the mouse, the other on the keyboard [ALt+Tab]
and ones mind/eye on teh screen. For me it means left hand "plays" the bass
pattern using Alt+Tab along with the clipboard shortcuts [CTRL+ z,x,c,v] ,while
right hand on the mouse mouse  provides the melody.

I've been using variations on the above since 1987 when I bought an Amiga2000.
I seem to recall SGI had one also. And after learning about Alt+Tab on windows,
I  found a utility to work the same way on Macintosh.  I am very happy to discover
that MacOSX now has built-in ALt+Tab :-)
</rant>

Meanwhile, Iam  still wondering how to set Leo [3.12 beta 1, Python 2.2.2, Tk
8.3.2] default to a maxmimized or minimized window size by itself.

And also to remember the last size/position it had. I vaguely remember that
it used to do that, but perhaps I am mistaking it for some other software ?

thanks
Jason
#@-node:ekr.20031218072017.746:Minimizing/maximizing windows
#@+node:ekr.20031218072017.742:Show diffs of changed node in top_df.read
- Show changes:
	When a derived file is modified by an editor it would be very nice if Leo would:
	- flag the file as modified and,
	- flag (underline, color, diff, whatever) the parts that were modified.
#@nonl
#@-node:ekr.20031218072017.742:Show diffs of changed node in top_df.read
#@+node:ekr.20040220110030:Change cursor when caps lock is down
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2431552
By: nobody

From: Rich

 I just got nipped twice by the following effect: the Caps-Lock key is ON, but
because the LED is on the Caps-Lock key, it is hidden behind my hand. I hit
Ctrl-x, expecting to cut my selection, but the entire node is cut.

   I know there's a problem with tk and the shift key status, so I'm wondering
if it would be possible to change the shape of the cursor when the Caps-Lock
is ON (preferrably a big red flashing blot 8-), or otherwise show that Caps-Lock
is active ( "CAPS" on a status line, for instance).

  Another way: I don't know if this goes against an "anti-modalism rule," but
only allowing Ctrl-Shift-x|c|v in the outline pane would also be acceptable
to me.
#@nonl
#@-node:ekr.20040220110030:Change cursor when caps lock is down
#@+node:ekr.20040315060557:declone command
By: nobody ( Nobody/Anonymous ) 
 having a declone() method for vnodes?   
2004-03-15 04:36  

 hi,

Ive had a use for a declone() method in vnodes recently. Have you ever thought about adding a method that declones a clone? This would entail:

1. Making a clone node a normal node.

I can see this happening when cutting a node and pasting a node that is a clone. But there doesn't seem to be a dedicated function to do the operation. :)  
#@nonl
#@-node:ekr.20040315060557:declone command
#@+node:ekr.20031218072017.792:Double Click Node command
#@-node:ekr.20031218072017.792:Double Click Node command
#@+node:ekr.20031218072017.852:Scroll improvement
@nocolor

By: jwashin ( James Washington ) 
 Scrolling and the Tree Frame in Linux   
2003-10-20 12:13  

I'm using tk-8.4.3, python-2.2.3 on linux. The MouseWheel events do not work for me in the Tree Frame.

I added <Button-4> and <Button-5> bindings similar to the existing <MouseWheel> binding in LeoFrame.finishCreate(), associating them with two methods, LeoFrame.OnMouseScrollDown and LeoFrame.OnMouseScrollUp that took the appropriate parts of OnMouseWheel()

Now it works, sort-of. It scrolls properly unless the cursor is an I-Bar, e.g., over text. But at least this removes in-part the most glaring UI problem for me with Leo in tk. I suppose I am spoiled with the mouse wheel and want it to work everywhere.

Thanks for the great program.

-- Jim Washington  
#@-node:ekr.20031218072017.852:Scroll improvement
#@-node:ekr.20040329190314:Most important
#@+node:ekr.20040329190314.2:Others
#@+node:ekr.20040213090121:Insert at end
@nocolor

By: tibi ( Thibaut Champenier ) 
 inserting a new node   
2004-02-13 13:23  

 Hi,

When doing ctrl+i I on the node that has children I would prefer Leo to insert the new node as the last children instead of the first. It just makes more sense to me, for exemple when you take a big file and cut it in subnodes you typically start at the top and create new nodes while paging down the file.
What do you think ?
To try it just make this little change:
RCS file: /cvsroot/leo/leo/src/leoCommands.py,v
retrieving revision 1.76
diff -r1.76 leoCommands.py
2516c2516
< v = current.insertAsNthChild(0)
---
> v = current.insertAsLastChild()  
#@nonl
#@-node:ekr.20040213090121:Insert at end
#@+node:ekr.20031218072017.740:Disallow writes outside a "top-level" folder
1. Warn when creating _any_ new file.

2. Warn when rewriting any file that was not read properly.

This prevents "hijacking" an already existing file.
#@nonl
#@-node:ekr.20031218072017.740:Disallow writes outside a "top-level" folder
#@+node:ekr.20031218072017.745:@@first <n>
@nocolor

Hate to break into the grand design discussions, but here's a hopefully small thing. If you need to place a good sized copyright statement at the top of your files, LEO doesn't handle this case very cleanly. As I'm sure you're aware, you wind up with a matching number of @@first lines for each leading line in your source. 

As an example: 
# 1 
# 2 
# 3 
# 4 
# 5 
#@verbatim
#@+leo 
#@verbatim
#@+node:0::@file /tmp/firstcheck.py 
#@verbatim
#@+body 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@+doc 
# 
# How many firsts do I get? 

#@verbatim
#@-doc 
#@verbatim
#@@c 
Start code. 
#@verbatim
#@-body 
#@verbatim
#@-node:0::@file /tmp/firstcheck.py 
#@verbatim
#@-leo 

My fellow co-workers who don't use LEO, aren't exactly loving me here. 

Might we introduce an: 

@@first <num> 

Type tag instead? So one '@@first 5' could represent all 5 of the above @@first lines? It makes for a smaller, cleaner LEO footprint and will tick off non-LEO users much less. 

Thanks. 

- ordinarius 
#@nonl
#@-node:ekr.20031218072017.745:@@first <n>
#@+node:ekr.20031218072017.807:Put up file dialog on empty @url, etc.
@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2003457
By: dsalomoni

Proposal: modify the code for @url so that if you type for example just "@url"
(no file specified) in a headline, a window pops up allowing you to browse the
local file system and select the file (similar to what browsers do when you
want to open a file).

This would be more convenient than manually writing @url
file://a/long/path/to/the/file. @read-only nodes already allow this, it would
perhaps be nice if all these types of plugins (@folder might be another one
for example) and directives (@file etc) had the same behavior (and this should
probably be specified in some guidelines for writing new plugins -see e.g. the
jedit plugin guidelines).

Davide
#@-node:ekr.20031218072017.807:Put up file dialog on empty @url, etc.
#@+node:ekr.20040226094105:Put the scrollWheel workaround in the FAQ (or in the code??)
@nocolor
#@nonl
#@+node:ekr.20040226094105.1:halw

https://sourceforge.net/forum/message.php?msg_id=2437859
By: halw

David,

I agree that your solution is best -- the problem is it doesn't work. 

If you look at the original post you'll note that the mouse wheel works fine
in all other Leo panes (which are native text panes, not a custom canvas).

In fact, a stock RH9 system does set up X as those pages indicate. The problem
is elsewhere, perhaps Tk or Tkinter.

If Edward doesn't want to ship a workaround, that's fine. It should, IMO, make
it into the FAQ, though.

--Hal

#@-node:ekr.20040226094105.1:halw
#@+node:ekr.20040226094105.2:djsg
https://sourceforge.net/forum/message.php?msg_id=2435622
By: djsg

Tk is complying with the behavior of XFree86, and not hiding that behavior. 

Documentation for XFree86 4.2.0 -- documentation for a 4.4 development version
matches it, so 4.3.0 ought to match it also:

http://www.xfree86.org/4.2.0/mouse7.html

An example of configuration for XFree86 3.3.2.

First, the URL: 

http://www.genius-europe.com/service/faq/tuxmouse.htm

o save their bandwidth, the example follows: 


All mices with scroll wheel or stick

XFree86 >= 3.3.2 (or other XServer with wheel to mouse button support)
The mouse must be setup in XF86Config to send the mouse buttons 4 and 5 for
wheel actions.
Edit /etc/XF86Config with your favorite editor
Add the following line to the "Pointer" section.

ZAxisMapping 4 5

Make sure your Protocol is set to either "IMPS/2" for a PS/2 mouse
or for serial mice set it to "IntelliMouse" or "Auto".
Example for PS/2 wheel mouse:

Section "Pointer"
Protocol "IMPS/2"
Device "/dev/psaux"
SampleRate 60
BaudRate 1200
ZAxisMapping 4 5
Buttons 3
EndSection

After XWindows is started run :
imwheel -k


#@-node:ekr.20040226094105.2:djsg
#@+node:ekr.20040226094105.3:The actual workaround

https://sourceforge.net/forum/message.php?msg_id=2433628
By: halw

Okay, I have a workaround that works for me with my existing Tk version. My
Tkinter skills are weak, but I don't think this will hurt anything else :)

Turns out this Tk version (or X or Tkinter or 	) doesn't generate MouseWheel
events, but maps to buttons 4 (up) & 5 (down).

Add to if clause 
# Handle mouse wheel in the outline pane.
if sys.platform == "linux2": # This crashes tcl83.dll
..canvas.bind("<MouseWheel>", frame.OnMouseWheel)
..def mapWheel(e):
	if e.num == 4:
	..e.delta = 120
	..return frame.OnMouseWheel(e)
	elif e.num == 5:
	..e.delta = -120
	..return frame.OnMouseWheel(e)
..canvas.bind("<ButtonPress>", mapWheel, add=1)
#@nonl
#@-node:ekr.20040226094105.3:The actual workaround
#@-node:ekr.20040226094105:Put the scrollWheel workaround in the FAQ (or in the code??)
#@+node:ekr.20040217090833:Change how Open with works?
By: rogererens ( Roger Erens ) 
 RE: Documentation for 4.1rc3   
2004-02-04 10:04  

@nocolor

It is stated that you can edit the temporary file with the editor as named in the "Open with..." submenu.
However, the temporary files are edited with the application that is associated with their extension. In my case I always fire up vim with .txt-files.

Hence the menu item would be better called something like "Open as..." with submenu items like ".doc file" or ".txt file"

Or, use something else instead of "os.startfile" to really use the intended editor.
#@nonl
#@-node:ekr.20040217090833:Change how Open with works?
#@+node:ekr.20040311022923:Make sentinel name in @-node optional
#@-node:ekr.20040311022923:Make sentinel name in @-node optional
#@+node:ekr.20040217154134:XML as a @language
#@-node:ekr.20040217154134:XML as a @language
#@-node:ekr.20040329190314.2:Others
#@-node:ekr.20040329182535.7:1-2 hour projects
#@+node:ekr.20040329182535.5:1 day projects
#@+node:EKR.20040517090625.1:@url http://komodo.nique.net/~grayrest/leoUIproposal.txt
#@-node:EKR.20040517090625.1:@url http://komodo.nique.net/~grayrest/leoUIproposal.txt
#@+node:ekr.20031218072017.801:Zipped .leo files
By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57


Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
#@+node:ekr.20040226092546:Saving .leo files with file compression
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442772
By: ejoy

I made an experiment last night. I replaced the call to open()in leofilecommand.py
with a call to gzip.open().
The LeoPy.leo file saved this way is only 600K! And there is no significant
speed down in saving.

I think it is a good idea to add compression support for load/save .leo files.
When reading or writing file with name ending with ".leo.gz", leo can call gzip
module to uncompress/compress the file, saving a lot of disk space.

What do you think of this?
#@-node:ekr.20040226092546:Saving .leo files with file compression
#@-node:ekr.20031218072017.801:Zipped .leo files
#@+node:ekr.20031218072017.733:Execute scripts like IDE's do
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2321235
By: paulpaterson

I think I understand what Samir is getting at. 

In PythonWin, or other IDE's for other languages, you are able to execute the
"current program" in a way that it will behave identically to if it had been
run from the command line.

For Python this requires,

1. That the script run with __name__ == "__main__", so that the standard "if
__name__ ..." section will be executed properly.

2. You are able to pass command line parameters to the script. In some IDE's
you are able to set default command line parameters and these are "injected"
into the sys.argv (or equivalent) so that, as far as the program is concerned,
it looks like you ran it from the command line with some aruments.


The underlying assumption is that you want to run an entire program from Leo,
not just a script. I would find this very useful also as I could run unit tests
or even my entire apps by just hitting, for exampe, F5.

Paul
#@nonl
#@-node:ekr.20031218072017.733:Execute scripts like IDE's do
#@+node:ekr.20031218072017.748:Import/Export to yaml
Need a good yaml parser first: I don't want to write another parser by hand.
#@nonl
#@-node:ekr.20031218072017.748:Import/Export to yaml
#@+node:ekr.20031218072017.790:Import dialog improvements
@nocolor

Other options I though would be really handy:

1. Use an existing node as a source also

2. Use an node from another Leo file.. I am not sure what the syntax for that
would be exactly

3. From a URL.. this would be really cool. People could post outlines not only
as existing Leo xml files, but as text files or even dynamic scripts. The code
to handle these would presumably need to deal with http:// intelligently. But
that's easy in Python. Rebol is great at that too.

4. Other XML file with valid filepaths in them.
That's probably a much bigger project like Leo 3.10  

Jason
#@-node:ekr.20031218072017.790:Import dialog improvements
#@+node:ekr.20031218072017.793:Keep right panes constant when tiling horizontally
This is done automatically now!  I may have to use configure events.

> When I have the 'split mode' set to display tree and log on left, and viewpane
on right, I sometimes need to increase the width of the window.

When I do the resize, the tree/log panes grow in proportion. I don't know about
others, but I'd much prefer if the tree/log panes stayed at the same width,
and only the view pane grew.
#@-node:ekr.20031218072017.793:Keep right panes constant when tiling horizontally
#@+node:ekr.20031218072017.800:Enhancements to extract section
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1858824
By: gilshwartz
Open discusstion

Currently Extract Section is only available if the first line in a selection
is a section name <<x>>. I would like to propose a few enhancements I think
should be useful, while I believe most of the code is already implemented in
Leo.

1. If the first line in a selection is not <<x>>, than Extract Section WILL
make a section name from the first line (or a version of it, see below), leave
the section name in the body, create a new node with that section name, and
will copy the selection including the first line to the new node.

Rational: this is useful when selecting a function or a class. Thus the section
name becomes the function or the class definition. The section name can either
be the full first line, or, knowing the language, Leo can make a nice section
name like it does in import, e.g. "function foo", or "class bar", without the
parameters list.

2. Even better, when Extract Section is called WITHOUT a selection it will look
for the first function/class definition before the cursor's position and will
either use it as a selection and do 1 above, or just mark it as selection, which
will enable 1 above upon a second Extract Section.

Rational: Leo does it beautifully in import and when a node's code starts to
build it is most convenient. Also, I think a variation on this was recently
asked by another user.

3. Add an option Merge Section, which when called from a named section will
merge it back to all the sections containing it.

Rational: make it easy (together with 2) to create/delete sections until the
sections picture of a new code becomes clear.

Gil

--

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1859516
By: nobody

Simpler & more intutive:
Mark text, select from menu - 'extract section', this presents a dialog box
in which you fill in the section name. It is too much work to type <<name>>
then select the whole thing...

As an enhancement, the dialog can show the first line of the selection as the
default section name, which obviously can be changed.

- Rajiv Bhagwat
#@-node:ekr.20031218072017.800:Enhancements to extract section
#@+node:ekr.20040329094003:Apply patch command
#@-node:ekr.20040329094003:Apply patch command
#@-node:ekr.20040329182535.5:1 day projects
#@+node:ekr.20040329182535.3:2 day projects
#@+node:ekr.20040217152936.1:Incremental drawing of outline pane: see projects
#@-node:ekr.20040217152936.1:Incremental drawing of outline pane: see projects
#@+node:ekr.20031218072017.743:Note windows
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2205285
By: nobody

From: Rich

Some of the things I'd like to see in Leo:

A note window for each node. This is similar to (1), but a little fancier
looking. I envision a short window at the bottom of the edit window that could
hold notes and comments about the code, such as "Test this harder" or "Find
a better way of phrasing this". This is currently available in uSoft Office
and the Eclipse IDE (http://www.eclipse.org). Perhaps a numeric reference, such
as "<<1>>" could be used.

(2) Color ''and'' italic/bold characters with @markup. One thing I'd like to
''not'' see are the markup characters in @file-nosent files.  "~~red:NOTE:~~"
does nothing for readability in plain text.
#@nonl
#@-node:ekr.20031218072017.743:Note windows
#@+node:ekr.20031218072017.754:Open text files in text window
#@-node:ekr.20031218072017.754:Open text files in text window
#@+node:ekr.20040329182535.4:Leo + zodb
#@+node:ekr.20040117111232:svn links
https://sourceforge.net/forum/message.php?msg_id=2379777
By: nobody

Here is my results of a short surfing:

- The SubVersion book (explain concepts, usage, etc..)
http://svnbook.red-bean.com/html-chunk/

-SubVersion applications can be programmed in Python
http://svnbook.red-bean.com/html-chunk/ch08s02.html
http://pysvn.tigris.org/

 The main problem of using SubVersion will be the binary dependencies (no more
pure python code).

- Zope Version Control
Similar Plone access to SVN (Plone is a Zope application Plone->Zope->Python),
could give some ideas
http://plone.org/events/conferences/1/archive/PloneSVN2003.pdf

Got nothing very clear...
I think we should start by creating a requirements document.
What exactly we want to create ?

rodrigob
#@-node:ekr.20040117111232:svn links
#@+node:ekr.20040117092727.2:using zodb versions
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2379351
By: korakot

If leo use database storage (ZODB or otherwise)
it could scale much better. This will bring us some
possiblity to store all versions of changes to a node
or a tree.

Cloning will then point to a specific version. If there
is no conflict, it can update to a later version when
the primary clone change. If there is a conflict
we can deal with it wisely using 'diff information'
because we have 'all versions' stored.

#@-node:ekr.20040117092727.2:using zodb versions
#@+node:ekr.20040226114127:Zope test
import leoGlobals

from ZODB import FileStorage, DB

if 1:
	print "-"*20
	storage = FileStorage.FileStorage(r"c:\prog\zopeTemp\leo.fs") 
	db = DB(storage)
	print storage ; print db
	db.close()
#@nonl
#@-node:ekr.20040226114127:Zope test
#@+node:ekr.20031218072017.737:Leo & data bases
From: "Scott Chapman" <scott_list@mischko.com>
To: <edreamleo@charter.net>
Sent: Monday, November 10, 2003 11:05 AM
Subject: Enhancement request: Make Leo deal with a database

It would be Way Cool if Leo could deal with psycopg or other DataBase 
API compliant implementations and fetch and store database records.

Details of what I'd like to see:

I'm working on Python source code. I want Leo to pull a source code file 
from a database record built something like this:

filename: text
updated: datetimestamp
code: text

Leo would insert a new record, not update an existing one, each time a 
Save was done, with a more current time stamp.  

When a File Open was requested (i.e. a node on a existing Leo outline 
was being pulled from a database), Leo would fetch the most recent 
time-stamped version only.

I use this same technique for my wiki pages.  It's very easy to 
implement in SQL and works great.

Leo would also need the ability to save the same file to a regular 
python source code file on disk at a specific location, so you'd have 
to be able to put more than one save/load directive in a given node.

This would provide a nice version history and could lead to other Useful 
Things in Leo.

Scott
#@nonl
#@-node:ekr.20031218072017.737:Leo & data bases
#@-node:ekr.20040329182535.4:Leo + zodb
#@+node:ekr.20031218072017.797:Allow @file http & @file ftp
I'd like to see leo's @file can be extended to cover more protocols, like REBOL's "read" does. 

in short, it would be very sweet if the following work: 

@file http://www.somedomain.org/python/foo.py 

@file pass@ftp.sd.org/python/foo.py" target="_blank" target="_new">ftp://user:pass@ftp.sd.org/python/foo.py> 

while we are at it, what about xmlrpc/soap? 

should there be new directive, like @source ?
#@nonl
#@+node:ekr.20031218072017.810:Remote access Scott Powell
I will wait. Here's clarification, when you're ready for it:

All of my projects are stored on remote computers, and accessed via FTP. 
What I want is basically the ability to open up these projects directly 
through leo, instead of transferring the files manually between my computer 
and the computers that hold my projects, preferably through FTP.

My solution: A new menu item called 'FTP' or 'Remote'. Click on this, and an 
FTP dialog opens up, with an empty list of FTP sites, and the ability to add 
more. You select a site, and it brings up a list of files. You select a 
file, and it is added to your project. When you hit 'save', it automatically 
does an FTP send.

Python makes this a lot easier with the builtin module 'ftplib'. I'm sure 
there are similar things for C++. I hope you take this idea into 
consideration.

Scott Powell
CEO, Dev Designs
#@-node:ekr.20031218072017.810:Remote access Scott Powell
#@-node:ekr.20031218072017.797:Allow @file http & @file ftp
#@+node:ekr.20040411152933:Jython (when Jython supports Python 2.2)
#@-node:ekr.20040411152933:Jython (when Jython supports Python 2.2)
#@-node:ekr.20040329182535.3:2 day projects
#@+node:ekr.20040329182535.1:1-2 week projects
#@+node:ekr.20040124074218.3:pyGtk plugin
#@-node:ekr.20040124074218.3:pyGtk plugin
#@+node:ekr.20040217153407.1:** Unify @root and @file
#@-node:ekr.20040217153407.1:** Unify @root and @file
#@+node:ekr.20031218072017.658:Resolve Conflicts command (may not be needed with @thin)
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@+node:ekr.20031218072017.659:Jonathon 1
https://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  

 
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?

More things to think about.

Gil
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20031218072017.658:Resolve Conflicts command (may not be needed with @thin)
#@+node:ekr.20031218072017.811:Split panes (could be done in gui plugins)
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1759009
By: davidmcnab

Hi,

I know I've put this one before, but as I use Leo more and more, the lack of
this is really pressing.

I tried your previous suggestion - opening another editor to have a view of
the file, but this is really painful, especially when I'm wanting to work on
two or more files simultaneously.

I've tried having files open in Emacs and writing them out, then doing a 'read
@file nodes', but this doesn't always work - the changes made in Emacs aren't
getting incorporated into the Leo tree (unless I quit/restart Leo).

(BTW - I'm using latest CVS of Leo).

What would make for Total Hacking Heaven is the ability to split a body pane
vertically or horizontally, and to be able to split the sub-panes
vertically/horizontally.

What that, hotkeys would move the cursor between panes (ie make different panes
'active'). Also, clicking on a node would display that node in the *currently
active* body pane.

This in place, as well as an accurage 'goto line number' feature would make
Leo even more of a killer app.

Cheers
David

#@-node:ekr.20031218072017.811:Split panes (could be done in gui plugins)
#@-node:ekr.20040329182535.1:1-2 week projects
#@+node:ekr.20040123102724:Can't or wont
#@+node:ekr.20031218072017.835:(Use pywin extensions to improve cut/paste between apps)
@color

@ This is not going well :-(  Probably what is happening is that Tk is competing with the win32 extensions in setting the clipboard.  It might not be so easy to

a) completely disable Tk's clipboard handling, in _both_ headlines and body text.
b) do the cut/paste operations "by hand".

This might require new body routlines to replace the selected text in the body.  And then there are issues relating to whether the headline or body text should be changed.  All in all, this is much harder than it looks.

Also, if one is not careful one can take fatal Python errors related to missing threads.  Pretty much a nightmare.
#@nonl
#@+node:ekr.20031218072017.836:updateEditMenu
def updateEditMenu (self):

    c = self.c ; frame = c.frame ; gui = g.app.gui
    if not c: return
    try:
        # Top level Edit menu...
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("Edit")
        c.undoer.enableMenuItems()
        << enable cut/paste >>
        if 0: # Always on for now.
            menu = frame.menu.getMenu("Find...")
            enable(menu,"Find Next",c.canFind())
            flag = c.canReplace()
            enable(menu,"Replace",flag)
            enable(menu,"Replace, Then Find",flag)
        # Edit Body submenu...
        menu = frame.menu.getMenu("Edit Body...")
        enable(menu,"Extract Section",c.canExtractSection())
        enable(menu,"Extract Names",c.canExtractSectionNames())
        enable(menu,"Extract",c.canExtract())
        enable(menu,"Match Brackets",c.canFindMatchingBracket())
    except:
        g.es("exception updating Edit menu")
        g.es_exception()
#@nonl
#@+node:ekr.20040130164211:<< enable cut/paste >>
if frame.body.hasFocus():
    data = frame.body.getSelectedText()
    canCut = data and len(data) > 0
else:
    # This isn't strictly correct, but we can't get the Tk headline selection.
    canCut = True

enable(menu,"Cut",canCut)
enable(menu,"Copy",canCut)

data = gui.getTextFromClipboard()
canPaste = data and len(data) > 0
enable(menu,"Paste",canPaste)
#@nonl
#@-node:ekr.20040130164211:<< enable cut/paste >>
#@-node:ekr.20031218072017.836:updateEditMenu
#@+node:ekr.20031218072017.837: tkinterGui.__init__
def __init__ (self):

    # Initialize the base class.
    leoGui.leoGui.__init__(self,"tkinter")

    self.bitmap_name = None
    self.bitmap = None
    self.win32clipboard = None
    
    if 0: # This seems both dangerous and non-functional.
        if sys.platform == "win32":
            try:
                import win32clipboard
                self.win32clipboard = win32clipboard
            except:
                g.es_exception()
#@nonl
#@-node:ekr.20031218072017.837: tkinterGui.__init__
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,frame):
    
    t = self.bodyCtrl
    
    # Event handlers...
    t.bind("<Button-1>", frame.OnBodyClick)
    t.bind("<Button-3>", frame.OnBodyRClick)
    t.bind("<Double-Button-1>", frame.OnBodyDoubleClick)
    t.bind("<Key>", frame.body.onBodyKey)

    # Gui-dependent commands...
    t.bind(g.virtual_event_name("Cut"), frame.OnCut)
    t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
    t.bind(g.virtual_event_name("Paste"), frame.OnPaste)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:ekr.20031218072017.839:<< define editMenuTopTable >>
self.editMenuTopTable = (
    ("Can't Undo","Ctrl+Z",c.undoer.undo), # &U reserved for Undo
    ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &R reserved for Redo
    ("-",None,None),
    ("Cu&t","Ctrl+X",f.OnCutFromMenu), 
    ("Cop&y","Ctrl+C",f.OnCopyFromMenu),
    ("&Paste","Ctrl+V",f.OnPasteFromMenu),
    ("&Delete",None,c.delete),
    ("Select &All","Ctrl+A",f.body.selectAllText),
    ("-",None,None))
#@nonl
#@-node:ekr.20031218072017.839:<< define editMenuTopTable >>
#@+node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
def OnCut (self,event=None):
    
    """The handler for the virtual Cut event."""

    frame = self ; c = frame.c ; v = c.currentVnode()
    
    # This is probably being subverted by Tk.
    if g.app.gui.win32clipboard:
        data = frame.body.getSelectedText()
        if data:
            g.app.gui.replaceClipboardWith(data)

    # Activate the body key handler by hand.
    frame.body.forceFullRecolor()
    frame.body.onBodyWillChange(v,"Cut")

def OnCutFromMenu (self):
    
    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Cut"))
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)




#@-node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
#@+node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
def OnCopy (self,event=None):
    
    frame = self

    if g.app.gui.win32clipboard:
        data = frame.body.getSelectedText()
        if data:
            g.app.gui.replaceClipboardWith(data)
        
    # Copy never changes dirty bits or syntax coloring.
    
def OnCopyFromMenu (self):

    frame = self
    w = frame.getFocus()
    w.event_generate(g.virtual_event_name("Copy"))

#@-node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
#@+node:ekr.20031218072017.843:frame.OnPaste & OnPasteFromMenu
def OnPaste (self,event=None):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    # Activate the body key handler by hand.
    frame.body.forceFullRecolor()
    frame.body.onBodyWillChange(v,"Paste")
    
def OnPasteFromMenu (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Paste"))
    
    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)
#@-node:ekr.20031218072017.843:frame.OnPaste & OnPasteFromMenu
#@-node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):
    
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            return self.root.selection_get(selection="CLIPBOARD")
        except:
            return None
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@-node:ekr.20031218072017.835:(Use pywin extensions to improve cut/paste between apps)
#@+node:ekr.20031218072017.753:Emacs comint-mode:  The improved Execute Script command does most of this
@nocolor

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
#@-node:ekr.20031218072017.753:Emacs comint-mode:  The improved Execute Script command does most of this
#@+node:ekr.20031218072017.729:HTML rendering in Leo's body pane
#@+node:ekr.20031218072017.731:HTML plugin: opml
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2283466
By: billp9619

FYI
I played around with opml a while back and it seemed very versatile.

It basically consists of an xml file of nested outline tags similiar to v-nodes
in leo xml. This then works with an xsl stylesheet that displays the outline
in a browser with scripted outline manipulation. (Uses div tags for this
display.)

What I discovered is that any html can make up the outline nodes , even forms,
etc. which collapse with the outline interaction. Just that the angle brackets
in the html must be escaped as is done within leo t nodes in .leo xml.

Actually, it would be interesting to see an addin that just passes leo nodes
to opml and then pops into the default browser. Also keep in mind that javascript
has an eval() statement that can be passed any script as a string. The leo text
box could be a form textarea box except that then there is no way to emulate
syntax coloring. Alternatively, this could be a floating window wrappiing node
text in html/body. (if nothing else, just destroy/close the window and reinitialize).
Maybe the images used in the opml could have javascript events like onclick()
to trigger refreshing leo text box from the t-nodes stored in an array or in
hidden form boxes.

Of course the effect of the stylesheet could be done via python script if no
xslt in the receiving browser. The minimal html and script might be just boilerplate
output.

regards,
bill p
#@nonl
#@-node:ekr.20031218072017.731:HTML plugin: opml
#@-node:ekr.20031218072017.729:HTML rendering in Leo's body pane
#@+node:ekr.20040216054459:@h @f @endh and @endf directives
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2424151
By: ksejlod ( Peter Barrel ) 
 I Have a (maybe) great idea!   
2004-02-15 04:29

I've been using LEO for a while and finding surprinsingly powerfull new uses now and then, (hey, not a week passes that i dont think to myself : "why did'nt anyone thought of that kind of tool that is LEO. It's so stupid to program such a tool, yet no one thought of doing such a thing ! ")

I was wondering if there was a leo keyword (beginning with "@") that would do a feature I thought would be great: something such as :
@h
@endh
and of course, similarily...
@f
@endf

Standing for "Header", "End Header", "Footer" and "End Footer". Let me please explain ...

When creating files with @file (or nosentinels) I use the keyword "@others" in the starting node body of the file and place in the file, as it's decendants (children, grand-children & so on) some clones of other stuff somewhere else outside of this file (usualy, clones of parts of program regrouped as children of a "components" node up in the leo outline. Typical Example:

-Introduction
-+components
-a
-b
-c
-+@file program.BAS
-b
-c
-a

a, b, and c are clones and the @file node contains @others.

As you see, I proceed that way because in older programming languages or in lower level languages, the order of components such as procs, declarations, etc as an importance. It also has the implication that << and >> brackets are irrelevant in my way of using leo.

Now, my feature that I looked for in the doc but could not find (so i suggest it here in case no one had any need of this before) is that when used in the BODY of a node part of an "@file" the @h and @endh would define a chunk of text in the body, you've guessed it, to be added before _each_ children node and ONLY children no grandchildren or any deeper. But It could also be used INSIDE the body of a children to define headers or footers for IT'S OWN direct children.

so, eehh, do you see the relevance of such a feature? Have i explained it clearly? maybe this would help:
CONST baba=2 AS INTEGER
CONST bebe=7 AS INTEGER
CONST zaza=5 AS INTEGER
CONST bobo=1 AS INTEGER
... the beginning and end of each of those "parts-of-a-program" is the same for a potential lot of lines... 

To Be Precise :
It's just really for adding something at end or beginning of a direct children of a node part of an @file in the tangling process. 

Is this feature already implemented but i have not found it? I'm pretty sure it easy to implement... what do you people think of this?
Thanks 
--
k

p.s. I'm the guy who proposed that in the untangling process, a clone would not be updated by it's _Last-Instance-Found_ in the @file beeing untangled, but instead updated by the _Last-Modified-One-Found_ in the @file... :)

(ooouuuuhh that would be slick...)  

By: ksejlod ( Peter Barrel ) 
 RE: I Have a (maybe) great idea!   
2004-02-15 04:35  

 The tree i tried to draw in ascii did not came out the way i did it, sourceforge "eated" leading spaces sorry a, b and c are children of their "+" node just above them		.
--
k  
#@nonl
#@-node:ekr.20040216054459:@h @f @endh and @endf directives
#@+node:ekr.20040123102724.2:Templates
@nocolor
#@nonl
#@+node:ekr.20040123102724.3:daliuslt
https://sourceforge.net/forum/message.php?msg_id=2385991
By: nobody

I often found myself using the same template for many projects but something differs in them. E.g. name of files. So my offer is add new directive variable:

@variable ProjectName MyFunProject

Later in parent node, child nodes or headers I could use this as:

$(ProjectNode).py or smth. similar.
This line when tangling could be replaces with
MyFunProject.py

Of course, there comes some complexity with untangling, but it is just an offer :)

Dalius
#@-node:ekr.20040123102724.3:daliuslt
#@+node:ekr.20040123102724.4:Rich: @constant
https://sourceforge.net/forum/message.php?msg_id=2386199
By: nobody

Dalius-
FWIW, I like it! I also can think of a LOAD of variations (i.e., multi-line
variables, etc.), but I'll limit myself to one thing: 'variable' by definition
should be changeable. May I suggest you call the directive "@constant"?

--Rich
#@nonl
#@-node:ekr.20040123102724.4:Rich: @constant
#@+node:ekr.20040123102724.5:paulpaterson
https://sourceforge.net/forum/message.php?msg_id=2386359
By: paulpaterson

I like this idea because I think templating is an important "design pattern"
that Leo could usefully support. Currently you can only do this in a limited
way by cloning nodes across derived files, which is something Edward doesn't
like to do because it makes reading derived files ambiguous (same information
in more than one place). I still do this because I rarely read files into Leo,
I mostly explicitely tangle files out of Leo.

Back to your idea ;) ISTM that your idea works well for directives (you can
do the variable substitution) but for general text (where I think there is a
bigger gain) there are two issues,

1. The template itself is now present in multiple derived files (see above)

2. The file derived from the template has now lost the variable name because
it was substituted out for the variable value

The end result is that templated files would almost certainly have to be a one
way street for Leo - they are derived from the Leo file but never read back
in. If you don't mind having this restriction, which basically means you have
to use @root nodes, then I don't see a problem.

Presumably most of this could all be done with a tangle_done script - the only
problem is how to change directives.
#@nonl
#@-node:ekr.20040123102724.5:paulpaterson
#@+node:ekr.20040123102724.6:daliuslt
http://sourceforge.net/forum/message.php?msg_id=2389750
By: daliuslt

Just for your interests where is one way to create constants in leo (even multiline).
Let's way we have outline:

+-[ ] @file-nosent objects.mak
|   +-[clone] << my_const >>
+-[ ] @file-nosent makefile
    +-[close] << my_const >>

objects.mak is:
--
<< my_const >>.o:
gcc -g -c << my_const >>.c -o << my_const >>.o

<< my_const >>cmd.o:
gcc -g -c << my_const >>cmd.c -o << my_const >>cmd.o
--

makefile is
--
<< my_const >>:
gcc << my_const >>.o << my_const >>cmd.o -o << my_const >>
--

<< my_const >> can be:
test

While it works pretty good it still have some drawbacks:
1. You are forced to use @file-nosent. You can edit your files outside of Leo.
2. You can't use << my_const >> in header lines, while it would be really nice
if you could write
@file-nosent obj_<< my_const >>.mak
(Leo lacks introspection?)
3. Result is not 100% what you expect.

---

(constant = variable = define) ???

Constants and clones in fact are the same. Usually clones are used like symbolic
links (or shortcuts) not like clones or constants. I think this could be
separated.

Constants could be read back into leo. E.g.: you have constant value in leo
file and while reading back files to outline you change all values with constant
name.

I hope I am clear :)
Dalius
#@nonl
#@-node:ekr.20040123102724.6:daliuslt
#@-node:ekr.20040123102724.2:Templates
#@+node:ekr.20040329185649:Bugs: can't be fixed or can wait
#@+node:ekr.20031218072017.663:Bug: can't be fixed
#@+node:ekr.20031218072017.664:Cut/paste bug on X windows (waiting for help)
@nocolor

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse.

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node.

Doing copy and paste works normally when done through the edit menu.

@color
#@nonl
#@+node:ekr.20031218072017.665:(Cut & Paste ) (Middle-button bug reported by Timo)
#@+node:ekr.20031218072017.666: Paste bug report
@nocolor

By: riotnrrrd ( Timo Honkasalo ) 
 Pasted text doesn't stick   
2002-11-01 13:38  
System: Linux 

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse. 

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node. 

Doing copy and paste works normally when done through the edit menu. 

-------------------

I also found out that if you do an extra "click" on the control key, it will
stick from then on.

If your text should have color in it, you can see that right before you "click",
the text has no color and the color back on right after you click the control.

It maybe a clue to someone, but seems strange to me. 
#@-node:ekr.20031218072017.666: Paste bug report
#@+node:ekr.20031218072017.667: Test
abc bbb bbbxyz bbb
#@nonl
#@-node:ekr.20031218072017.667: Test
#@-node:ekr.20031218072017.665:(Cut & Paste ) (Middle-button bug reported by Timo)
#@+node:ekr.20031218072017.668:Automatic select & Paste bug (Linux?)
@nocolor

Bumping the thread because the bug still persists. 

I've also noticed that the automatic select'n'paste doesn't work between nodes. That is, I can select text and paste a copy of it in the same node with middle button, but if I change click to another node, the paste buffer is erased. The automatic pasting works between Leo and other applications, however, and I can paste between nodes if I copy the selection to buffer by CTR-C. 

Maybe this is related to the non-sticking bug?

----

This may be a Linux-only bug related to the control-v workaround.
#@nonl
#@-node:ekr.20031218072017.668:Automatic select & Paste bug (Linux?)
#@-node:ekr.20031218072017.664:Cut/paste bug on X windows (waiting for help)
#@+node:ekr.20031218072017.669:Linux-only Bugs
These may indicate problems with Tk on Linux.  I can not reproduce them on XP.
#@nonl
#@+node:ekr.20031218072017.670:Possible webbrowser bug
(In Linux) The home page and online tutorial options in the menu only work properly if Mozilla window is already open. If not, a Mozilla window opens, but with empty page and url field. 
#@nonl
#@-node:ekr.20031218072017.670:Possible webbrowser bug
#@+node:ekr.20031218072017.671:Fix horiz scrollbar bug when tiling horizontally
When in 'vertical split' mode (with viewpane on right, and tree pane over log pane on left), the horixontal scrollbar at bottom of screen is at full width, despite the fact that not all of the tree pane area is displayed. 

Another way of saying this - I narrow the tree and log panes, to the extent that the display of tree node headings is truncated. But the horizontal scrollbar at the bottom doesn't contract, and doesn't allow me to horizontally scroll the tree pane to expose the rest of the node headings. 
#@-node:ekr.20031218072017.671:Fix horiz scrollbar bug when tiling horizontally
#@+node:ekr.20031218072017.672:Control-V doesn't work on Linux
This has been and continues to be a known issue with Tk. Has been logged as a bug; no response from the Tk folks. 

Here is a link to the Tk bug report: 

http://sourceforge.net/tracker/?func=detail&aid=605277&group_id=12997&atid=112997 

Note the work-around/patch in the followup post at the bottom of that page. Commenting out some statements in text.tcl removes the problem. 
#@-node:ekr.20031218072017.672:Control-V doesn't work on Linux
#@-node:ekr.20031218072017.669:Linux-only Bugs
#@+node:ekr.20031218072017.673:Tk bugs
The following bugs can not be fixed because they are Tk bugs.
#@nonl
#@+node:EKR.20040523192553:(Crash when pasting large text into headlines)
#@+node:EKR.20040606104355:Report
@nocolor

From: <eltronic@juno.com>
To: <edreamleo@charter.net>
Sent: Sunday, May 23, 2004 9:36 AM
Subject: fatal bug in Leo headline handling


> found a fatal bug in Leo headline handling.
> not sure if anyone reported before,
> an oversize string can crash python 2.3.3
> 
> 
> the text was about 4500 bytes. nothing but text.
> opened the  leo again, copy a large page of text,
> insert headline, paste, fatal error in python.
> 
> I have by mistake pasted whatever node xml was in 
> the copy buffer into a headline w/o problem.
> but that was just dumb luck. just verified,
> had the node been large enough it crashes.
> 
> Leo 4.1 final, py2.3.3 win98
> PYTHON caused an invalid page fault in
> module TK84.DLL at 0167:1022b74f.
> 
> Leo 4.1 final, py2.2 win98
> paste a 15k node copy into headline. no problem.
> 
> this is the first repeatable hard crash I've stumbled on
> and thought it best to report it privately.
> I can think of no advantage to allowing a headline 
> of this size anyway. think of the tooltip that would create!
> 
> there are latent bugs in the selectall and delete from 
> the edit menu related to headline as well on the todo list.
> reported many times. 
> covert destruction of the selected body text.
> use of virtual events, with out proper focus to headline.
> 
> without myself being able to supply a patch, I'll guess,
> the virtual event paste called can as well point 
> to a function that checks the size before pasting.
> or simply sets the headline directly with 
> g.app.gui.getTextFromClipboard()[:1024]
> 
> 
> e
#@-node:EKR.20040606104355:Report
#@+node:EKR.20040610093947:This looks like a Tk bug
#@-node:EKR.20040610093947:This looks like a Tk bug
#@+node:ekr.20031218072017.1332:headline key handlers (tree)
@ The <Key> event generates the event before the headline text is changed(!), so we register an idle-event handler to do the work later.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1333:onHeadChanged
def onHeadChanged (self,p):
    
    """Handle a change to headline text."""
    
    self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p)

#@-node:ekr.20031218072017.1333:onHeadChanged
#@+node:ekr.20031218072017.1334:OnHeadlineKey
def OnHeadlineKey (self,p,event):
    
    """Handle a key event in a headline."""

    ch = event.char
    self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p,ch)


#@-node:ekr.20031218072017.1334:OnHeadlineKey
#@+node:ekr.20031218072017.1335:idle_head_key
def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c ; v = p.v

    if not p or not p.edit_text() or p != c.currentPosition():
        return "break"
        
    edit_text = p.edit_text()
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    << set head to vnode text >>
    done = ch in ('\r','\n')
    if done:
        << set the widget text to head >>
    << set s to the widget text >>
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        << update v and all nodes joined to v >>
    if done or changed:
        << reconfigure v and all nodes joined to v >>
        << update the screen >>

    g.doHook("headkey2",c=c,p=p,ch=ch)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1337:<< set head to vnode text >>
head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")
#@nonl
#@-node:ekr.20031218072017.1337:<< set head to vnode text >>
#@+node:EKR.20040614075003:<< set the widget text to head >>
edit_text.delete("1.0","end")
edit_text.insert("end",head)
edit_text.mark_set("insert",index)
#@nonl
#@-node:EKR.20040614075003:<< set the widget text to head >>
#@+node:ekr.20031218072017.1336:<< set s to the widget text >>
s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i > -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    if len(s) > 250:
        g.es("Truncating headline to 250 characters",color="blue")
        s = s[:250]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')
#@nonl
#@-node:ekr.20031218072017.1336:<< set s to the widget text >>
#@+node:ekr.20031218072017.1338:<< update v and all nodes joined to v >>
c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    if not p.isDirty():
        p.setDirty()
    # Update v.
    v.initHeadString(s)
    edit_text.delete("1.0","end")
    edit_text.insert("end",s)
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.
#@nonl
#@-node:ekr.20031218072017.1338:<< update v and all nodes joined to v >>
#@+node:ekr.20031218072017.1339:<< reconfigure v and all nodes joined to v >>
# Reconfigure v's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(v))
#@nonl
#@-node:ekr.20031218072017.1339:<< reconfigure v and all nodes joined to v >>
#@+node:ekr.20031218072017.1340:<< update the screen >>
if done:
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # Update v immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20031218072017.1340:<< update the screen >>
#@-node:ekr.20031218072017.1335:idle_head_key
#@-node:ekr.20031218072017.1332:headline key handlers (tree)
#@-node:EKR.20040523192553:(Crash when pasting large text into headlines)
#@+node:ekr.20031218072017.674:Caps lock affects keyboard shortcuts on Windows
Using leo under Windows, the keyboard shortcuts seem to use the "Caps Lock" state in determining the shift state when executing a shortcut.   For example, if the caps-lock key is on, then Ctrl-X is interpreted as Shift-Ctrl-X and cuts a node rather than selected text, and Shift-Ctrl-X is interpreted as Ctrl-X and cuts text.
#@-node:ekr.20031218072017.674:Caps lock affects keyboard shortcuts on Windows
#@+node:ekr.20031218072017.675:Tree problems
1. The border of the tree control is gray, and it is overwritten with large headlines.  This may be a Tk or Tkinter bug.

2. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this glitch because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.
#@nonl
#@-node:ekr.20031218072017.675:Tree problems
#@+node:ekr.20031218072017.676:Control-T can't be overridden in canvas text.
#@-node:ekr.20031218072017.676:Control-T can't be overridden in canvas text.
#@+node:ekr.20031218072017.677:(Alt-ctrl = Alt)
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1765069
By: dalcolmo

I use the bindings that come with Leo:

[keyboard shortcuts]
pastenode = Shift+Ctrl+V
gonextvisible = Alt+DnArrow
importtofile = Shift+Ctrl+F
writefilenodes = Shift+Ctrl+W
editheadline = Ctrl+H
markchangeditems = Alt+C
replace = Ctrl+=
goprevvisible = Alt+UpArrow
gotonextmarked = Alt+M
readoutlineonly = Shift+Ctrl+R
extractnames = Shift+Ctrl+N
gonext = Alt+Shift+DnArrow
findpanel = Ctrl+F
close = Ctrl+W
demote = Ctrl+}
tangle = Shift+Ctrl+T
extract = Shift+Ctrl+D
openpythonwindow = Alt+P
marksubheads = Alt+S
saveas = Shift+Ctrl+S
cut = Ctrl+X
preferences = Ctrl+Y
equalsizedpanes = Ctrl+E
cantundo = Ctrl+Z
open = Ctrl+O
promote = Ctrl+{
sortsiblings = Alt-A
unmarkall = Alt+U
mark = Ctrl+M
showinvisibles = Alt+V
exit = Ctrl-Q
insertnode = Ctrl+I
findprevious = F4
converttabs = Shift+Ctrl+J
save = Ctrl+S
tanglemarked = Shift+Ctrl+M
moveup = Ctrl+U
copynode = Shift+Ctrl+C
contractparent = Alt+0
selectall = Ctrl+A
setfont = Alt+Shift+T
aborteditheadline = Shift+Esc
goback = Alt+Shift+UpArrow
toggleactivepane = Ctrl+T
findnext = F3
tangleall = Shift+Ctrl+A
endeditheadline = Esc
deletenode = Shift+Ctrl+BkSp
cantredo = Shift+Ctrl+Z
new = Ctrl+N
contractall = Alt+1
moveleft = Ctrl+L
copy = Ctrl+C
paste = Ctrl+V
convertblanks = Shift+Ctrl+B
expandall = Alt+9
markchangedroots = Alt+R
cutnode = Shift+Ctrl+X
indent = Ctrl+]
gotonextchanged = Alt+D
expandnextlevel = Alt+=
setcolors = Alt+Shift+S
matchbrackets = Ctrl+K
movedown = Ctrl+D
clonenode = Ctrl+`
untangle = Shift+Ctrl+U
expandtolevel7 = Alt+7
expandtolevel6 = Alt+6
expandtolevel5 = Alt+5
expandtolevel4 = Alt+4
expandtolevel3 = Alt+3
expandtolevel2 = Alt+2
moveright = Ctrl+R
unindent = Ctrl+[
replacethenfind = Ctrl+-
extractsection = Shift+Ctrl+E
expandtolevel8 = Alt+8


However, I use a utility called AllChars (Free as in beer :-(  ) to be able
to type all kinds of chars on my US keyboard, and "Handything" to place the
windows on the screen (Win2000). Perhaps this makes a difference, although disabling
them did not seem to make it go away. Still, on pressing alt+ctrl+uparrow I
end up at the next upper node etc...

- Josef

#@-node:ekr.20031218072017.677:(Alt-ctrl = Alt)
#@+node:ekr.20031218072017.678:Report Tk bugs
Create a Tk demo for each bug.
#@nonl
#@+node:ekr.20031218072017.679:Tk code
@color
#@nonl
#@+node:ekr.20031218072017.680:@file c:/prog/test/leoSplitter.tcl
# This file creates tk test code for prototyping.
@language tcltk
@others

go
#@nonl
#@+node:ekr.20031218072017.681:go
proc go {} {
	# createLeo 1
	# createLeo 2
	# createFindPanel
	# createPrefsPanel
	# createColorPanel
	# toplevel .font
	# createFontPanel .font
	# createComparePanel
	# createWindowWithIcon
	# createWindowWithCursor
}
#@-node:ekr.20031218072017.681:go
#@+node:ekr.20031218072017.682:createLeo
proc createLeo { n } {

	toplevel .leo$n

	# Create two splitters
	createSplitter .leo$n.s 1
	createSplitter .leo$n.s.pane1.s 0 ;# contains tree and log
	
	text      .leo$n.s.pane2.body -bd 2 -yscrollcommand ".leo$n.s.pane2.scroll set" -setgrid 1
	scrollbar .leo$n.s.pane2.scroll -command ".leo$n.s.pane2.body yview"

	pack .leo$n.s.pane2.scroll -side right -fill y
	pack .leo$n.s.pane2.body -expand yes -fill both

	text .leo$n.s.pane1.s.pane1.tree -bd 2 -yscrollcommand ".leo$n.s.pane1.s.pane1.scroll set" -setgrid 1
	scrollbar .leo$n.s.pane1.s.pane1.scroll -command ".leo$n.s.pane1.s.pane1.tree yview"
	
	pack .leo$n.s.pane1.s.pane1.scroll -side right -fill y
	pack .leo$n.s.pane1.s.pane1.tree   -expand yes -fill both

	# -padx is needed to handle overlap of splitter bar
	text      .leo$n.s.pane1.s.pane2.log    -yscrollcommand ".leo$n.s.pane1.s.pane2.scroll set" -setgrid 1 -padx 4
	scrollbar .leo$n.s.pane1.s.pane2.scroll -command ".leo$n.s.pane1.s.pane2.log yview"
	pack .leo$n.s.pane1.s.pane2.scroll -side right -fill y
	pack .leo$n.s.pane1.s.pane2.log -expand yes -fill both
	
	createMenus $n
}
#@nonl
#@-node:ekr.20031218072017.682:createLeo
#@+node:ekr.20031218072017.683:createMenus
proc createMenus { n } {

	# Create the menu bar
	menu .leo$n.menu -tearoff 0

    set m .leo$n.menu.file
    menu $m -tearoff 0

    .leo$n.menu add cascade -label "File" -menu $m -underline 0
	# to do: fill in the commands...
    $m add command -label "Open..." -command {""}
    $m add command -label "New" -command {""}
    $m add command -label "Save" -command {""}
    $m add command -label "Save As..." -command {""}
    $m add separator
    $m add command -label "Print Setup..." -command {""}
    $m add command -label "Print..." -command {""}
    $m add separator
    $m add command -label "Quit" -command "destroy ."
	
	.leo$n configure -menu .leo$n.menu
}
#@nonl
#@-node:ekr.20031218072017.683:createMenus
#@+node:ekr.20031218072017.684:createSplitter
#@+node:ekr.20031218072017.685:createSplitter
# Create a splitter window into which the caller packs widgets.

proc createSplitter {w verticalFlag} {
	# verticalFlag, height, width could be params
	frame $w -width 4i -height 3i
	frame $w.pane1
	frame $w.pane2
	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		frame $w.bar -height 7
		place $w.pane1 -relx 0.5 -rely   0 -anchor n -relwidth 1.0 -relheight 0.5
		place $w.pane2 -relx 0.5 -rely 1.0 -anchor s -relwidth 1.0 -relheight 0.5
		place $w.bar   -relx 0.5 -rely 0.5 -anchor c -relwidth 1.0
		bind $w.bar <ButtonPress-1>		"onGrabSplitterBar $w 1"
		bind $w.bar <B1-Motion>			"onDragSplitterBar $w 1 %y"
		bind $w.bar <ButtonRelease-1>	"onDropSplitterBar $w 1 %y"
	} else {
		# Panes arranged horizontally; vertical splitter bar
		frame $w.bar -width 7
		place $w.pane1 -rely 0.5 -relx   0 -anchor w -relheight 1.0 -relwidth 0.5
		place $w.pane2 -rely 0.5 -relx 1.0 -anchor e -relheight 1.0 -relwidth 0.5
		place $w.bar   -rely 0.5 -relx 0.5 -anchor c -relheight 1.0
		bind $w.bar <ButtonPress-1>		"onGrabSplitterBar $w 0"
		bind $w.bar <B1-Motion>			"onDragSplitterBar $w 0 %x"
		bind $w.bar <ButtonRelease-1>	"onDropSplitterBar $w 0 %x"
	}
	# Borderwidth required
	$w.bar configure -borderwidth 2 -relief raised -background LightSteelBlue2 
	pack $w -expand yes -fill both
}
#@-node:ekr.20031218072017.685:createSplitter
#@+node:ekr.20031218072017.686:onGrabSplitterBar
proc onGrabSplitterBar {w verticalFlag} {

	# We should change the cursor here.
	
	# Changing the relief is pointless.
		# $w.bar configure -relief sunken
	
	# Changing colors is really bad
		# $w.bar configure -relief sunken -background LightSteelBlue4
		# $w.bar configure -background LightSteelBlue4
}
#@nonl
#@-node:ekr.20031218072017.686:onGrabSplitterBar
#@+node:ekr.20031218072017.687:onDropSplitterBar
proc onDropSplitterBar {w verticalFlag xy} {

	# We should reset the cursor here.
	$w.bar configure -relief raised -background LightSteelBlue2
}
#@-node:ekr.20031218072017.687:onDropSplitterBar
#@+node:ekr.20031218072017.688:onDragSplitterBar
# xy is the coordinate of the cursor relative to the bar, not the main window.

proc onDragSplitterBar {w verticalFlag xy} {

	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		set wRoot	[winfo rooty $w]
		set barRoot [winfo rooty $w.bar]
		set wMax	[winfo height $w]
	} else {
		# Panes arranged horizontally; vertical splitter bar
		set wRoot	[winfo rootx $w]
		set barRoot [winfo rootx $w.bar]
		set wMax	[winfo width $w]
	}
	set offset [expr double($barRoot) + $xy - $wRoot ]
	# Adjust the pixels, not the frac.
	if { $offset < 3 } { set offset 3 }
	if { $offset > [expr $wMax - 2] } { set offset [expr $wMax - 2] }
	set frac [ expr double($offset) / $wMax ]
	# This redraws the splitter as the drag is occuring.
	# We could also redraw in onDropSplitterBar for non-dynamic updates.
	divideSplitter $w $verticalFlag $frac
	return $frac ;# No longer used
}
#@nonl
#@-node:ekr.20031218072017.688:onDragSplitterBar
#@+node:ekr.20031218072017.689:divideSplitter
proc divideSplitter {w verticalFlag frac} {

	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		place $w.bar -rely $frac
		place $w.pane1 -relheight $frac
		place $w.pane2 -relheight [expr 1 - $frac]
	} else {
		# Panes arranged horizontally; vertical splitter bar
		place $w.bar -relx $frac
		place $w.pane1 -relwidth $frac
		place $w.pane2 -relwidth [expr 1 - $frac]
	}
}
#@nonl
#@-node:ekr.20031218072017.689:divideSplitter
#@-node:ekr.20031218072017.684:createSplitter
#@+node:ekr.20031218072017.690:createFindPanel
proc createFindPanel {} {

	toplevel .find
	<< Create the Find and Change panes >>
	<< Create two columns of checkboxes >>
	<< Create two rows of buttons >>
}
#@+node:ekr.20031218072017.691:<< Create the Find and Change panes >>
frame .find.fc -bd 1m
pack  .find.fc -anchor n -expand yes -fill x

frame .find.fc.fpane -bd 1 -height 0.95i -width 1.5i
frame .find.fc.cpane -bd 1 -height 0.95i -width 1.5i

pack  .find.fc.fpane -anchor n -expand yes -fill x
pack  .find.fc.cpane -anchor s -expand yes -fill x

# Create the labels and text fields.
label .find.fc.fpane.lab -width 8 -text "Find:"
label .find.fc.cpane.lab -width 8 -text "Change:"
text  .find.fc.fpane.t -height 2 -width 20 ; # 2 lines, 20 characters
text  .find.fc.cpane.t -height 2 -width 20

pack  .find.fc.fpane.lab -side left 
pack  .find.fc.cpane.lab -side left
pack  .find.fc.cpane.t -side right -expand yes -fill both
pack  .find.fc.fpane.t -side right -expand yes -fill both
#@-node:ekr.20031218072017.691:<< Create the Find and Change panes >>
#@+node:ekr.20031218072017.692:<< Create two columns of checkboxes >>
frame .find.boxes -bd 1m
pack  .find.boxes -anchor n -expand yes -fill x

frame .find.boxes.lt -bd 1
frame .find.boxes.rt -bd 1
pack  .find.boxes.lt -side left  -padx 5m
pack  .find.boxes.rt -side right -ipadx 2m

# Create the left column
checkbutton .find.boxes.lt.batch -anchor w -text "Batch"
checkbutton .find.boxes.lt.wrap  -anchor w -text "Wrap around"
checkbutton .find.boxes.lt.word  -anchor w -text "Whole word"
checkbutton .find.boxes.lt.case  -anchor w -text "Ignore case"
checkbutton .find.boxes.lt.pat   -anchor w -text "Pattern match"
pack .find.boxes.lt.batch -fill x
pack .find.boxes.lt.wrap  -fill x
pack .find.boxes.lt.word  -fill x
pack .find.boxes.lt.case  -fill x
pack .find.boxes.lt.pat    -fill x

# Create the right column
checkbutton .find.boxes.rt.headline -anchor w -text "Search Headline Text"
checkbutton .find.boxes.rt.body     -anchor w -text "Search Body Text"
checkbutton .find.boxes.rt.outline  -anchor w -text "Suboutline Only"
checkbutton .find.boxes.rt.mark     -anchor w -text "Mark Changes"
checkbutton .find.boxes.rt.markch   -anchor w -text "Mark Finds"
pack .find.boxes.rt.headline -side top -fill x
pack .find.boxes.rt.body     -side top -fill x
pack .find.boxes.rt.outline  -side top -fill x
pack .find.boxes.rt.mark     -side top -fill x
pack .find.boxes.rt.markch   -side top -fill x
#@-node:ekr.20031218072017.692:<< Create two columns of checkboxes >>
#@+node:ekr.20031218072017.693:<< Create two rows of buttons >>
# Create the button panes
frame .find.buttons -bd 1
pack  .find.buttons -anchor n -expand yes -fill x

frame .find.buttons2 -bd 1
pack  .find.buttons2 -anchor n -expand yes -fill x

# Create the first row of buttons
button      .find.buttons.find    -width 8 -text "Find"
checkbutton .find.buttons.reverse -width 8 -text "Reverse"
button      .find.buttons.findAll -width 8 -text "Find All"

pack .find.buttons.find    -pady 1m -padx 1m -side left
pack .find.buttons.reverse -pady 1m          -side left -expand 1
pack .find.buttons.findAll -pady 1m -padx 1m -side right

# Create the second row of buttons
button .find.buttons2.change     -width 8 -text "Change"
button .find.buttons2.changeFind           -text "Change, Then Find"
button .find.buttons2.changeAll  -width 8 -text "Change All"

pack .find.buttons2.change       -pady 1m -padx 1m -side left
pack .find.buttons2.changeFind   -pady 1m          -side left -expand 1
pack .find.buttons2.changeAll    -pady 1m -padx 1m -side right
#@-node:ekr.20031218072017.693:<< Create two rows of buttons >>
#@-node:ekr.20031218072017.690:createFindPanel
#@+node:ekr.20031218072017.694:createPrefsPanel
proc createPrefsPanel {} {

	toplevel .prefs
	<< Create the Global Options frame >>
	<< Create the Tangle Options frame >>
	<< Create the Target Language frame >>
}
#@nonl
#@+node:ekr.20031218072017.695:<< Create the Global Options frame >>
frame .prefs.glob -bd 1m -relief groove
pack  .prefs.glob -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.glob.title -text "Global Options..."
pack  .prefs.glob.title -pady 1m

# Page width & page width
frame .prefs.glob.f
pack  .prefs.glob.f -anchor w -pady 1m -expand 1 -fill x

label .prefs.glob.f.lab -anchor w -padx 1m -text "Page width:"
text  .prefs.glob.f.txt -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab .prefs.glob.f.txt -side left

label .prefs.glob.f.lab2 -padx 1m -text "Tab width:"
text  .prefs.glob.f.txt2 -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab2 .prefs.glob.f.txt2 -side left

# Checkbuttons
checkbutton .prefs.glob.done -anchor w -text "Execute Leo_done.bat after Tangle"
checkbutton .prefs.glob.un   -anchor w -text "Execute Leo_un.bat after Tangle"
pack .prefs.glob.done .prefs.glob.un -fill x
#@-node:ekr.20031218072017.695:<< Create the Global Options frame >>
#@+node:ekr.20031218072017.696:<< Create the Tangle Options frame >>
# Frame and title
frame .prefs.tangle -bd 1m -relief groove
pack  .prefs.tangle -anchor n -ipadx 1m -expand 1 -fill x

label .prefs.tangle.title -text "Default Options..."
pack  .prefs.tangle.title -pady 1m

# Label and text
label .prefs.tangle.lab -anchor w -text "Default tangle directory"
text  .prefs.tangle.txt -height 1 -width 30 ;# width significant

pack  .prefs.tangle.lab           -padx 1m -pady 1m -fill x
pack  .prefs.tangle.txt -anchor w -padx 1m -pady 1m -fill x

# Checkbuttons
checkbutton .prefs.tangle.header -anchor w -text "Tangle outputs header line"
checkbutton .prefs.tangle.doc    -anchor w -text "Tangle outputs document chunks"
pack .prefs.tangle.header .prefs.tangle.doc -fill x
#@-node:ekr.20031218072017.696:<< Create the Tangle Options frame >>
#@+node:ekr.20031218072017.697:<< Create the Target Language frame >>
# Frame and title
frame .prefs.target -bd 1m -relief groove
pack  .prefs.target -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.target.title -text "Default Target Language..."
pack  .prefs.target.title -pady 1m

# Frames for two columns of radio buttons
frame .prefs.target.lt 
frame .prefs.target.rt
pack  .prefs.target.lt -side left
pack  .prefs.target.rt -side right

## To do: make radio buttons functional.

# Left column of radio buttons
radiobutton .prefs.target.lt.c      -anchor w -text "C/C++"
radiobutton .prefs.target.lt.cweb   -anchor w -text "CWEB"
radiobutton .prefs.target.lt.html   -anchor w -text "HTML"
radiobutton .prefs.target.lt.java   -anchor w -text "Java"
radiobutton .prefs.target.lt.pascal -anchor w -text "Pascal"

pack .prefs.target.lt.c      -fill x
pack .prefs.target.lt.cweb   -fill x
pack .prefs.target.lt.html   -fill x
pack .prefs.target.lt.java   -fill x
pack .prefs.target.lt.pascal -fill x

# Right column of radio buttons
radiobutton .prefs.target.rt.perl   -width 12 -anchor w -text "Perl"
radiobutton .prefs.target.rt.pod              -anchor w -text "Perl + POD"
radiobutton .prefs.target.rt.plain            -anchor w -text "Plain Text"
radiobutton .prefs.target.rt.python           -anchor w -text "Python"

pack .prefs.target.rt.perl   -fill x
pack .prefs.target.rt.pod    -fill x
pack .prefs.target.rt.plain  -fill x
pack .prefs.target.rt.python -fill x
#@-node:ekr.20031218072017.697:<< Create the Target Language frame >>
#@-node:ekr.20031218072017.694:createPrefsPanel
#@+node:ekr.20031218072017.698:createColorPanel
proc showColorPicker {} {
	tk_chooseColor
}

proc createColorPanel {} {

	toplevel .color
	wm title .color "Syntax Coloring"

	frame .color.f -bd 2 -relief groove
	pack  .color.f -anchor n -pady 2 -ipady 1 -ipadx 0 -expand 1 -fill x
	
	# label .color.f.lab -text "Choose syntax colors..."
	# pack  .color.f.lab -side top -fill x
	
	frame .color.f.docF -bd 2
	pack  .color.f.docF
	label .color.f.docF.lab -text "Doc parts:" -width 14 -anchor e
	button .color.f.docF.show -text "" -bg "red" -width 4
	button .color.f.docF.set -text "Set..." -command showColorPicker
	pack  .color.f.docF.lab .color.f.docF.show .color.f.docF.set -side left -padx 3
	
	frame .color.f.cF -bd 2
	pack  .color.f.cF
	label .color.f.cF.lab -text "Comments:" -width 14 -anchor e
	button .color.f.cF.show -text "" -bg "red" -width 4
	button .color.f.cF.set -text "Set..." -command showColorPicker
	pack  .color.f.cF.lab .color.f.cF.show .color.f.cF.set -side left -padx 3

	frame .color.f.sF -bd 2
	pack  .color.f.sF
	label .color.f.sF.lab  -text "Strings:" -width 14 -anchor e
	button .color.f.sF.show -bg "green" -width 4
	button .color.f.sF.set -text "Set..." -command showColorPicker
	pack  .color.f.sF.lab .color.f.sF.show .color.f.sF.set -side left -padx 3
	
	frame .color.f.kF -bd 2
	pack  .color.f.kF
	label .color.f.kF.lab  -text "Keywords:" -width 14 -anchor e
	button .color.f.kF.show -bg "blue" -width 4
	button .color.f.kF.set -text "Set..." -command showColorPicker
	pack  .color.f.kF.lab .color.f.kF.show .color.f.kF.set -side left -padx 3
	
	frame .color.f.dF -bd 2
	pack  .color.f.dF
	label .color.f.dF.lab  -text "Directives:" -width 14 -anchor e
	button .color.f.dF.show -bg "blue" -width 4
	button .color.f.dF.set -text "Set..." -command showColorPicker
	pack  .color.f.dF.lab .color.f.dF.show .color.f.dF.set -side left -padx 3

	frame .color.f.snF -bd 2
	pack  .color.f.snF
	label .color.f.snF.lab  -text "Section names:" -width 14 -anchor e
	button .color.f.snF.show -bg "red" -width 4
	button .color.f.snF.set -text "Set..." -command showColorPicker
	pack  .color.f.snF.lab .color.f.snF.show .color.f.snF.set -side left -padx 3

	frame .color.f.unF -bd 2
	pack  .color.f.unF
	label .color.f.unF.lab  -text "Undefined names:" -width 14 -anchor e
	button .color.f.unF.show -bg "orange" -width 4 
	button .color.f.unF.set -text "Set..." -command showColorPicker
	pack  .color.f.unF.lab .color.f.unF.show .color.f.unF.set -side left -padx 3
}
#@nonl
#@-node:ekr.20031218072017.698:createColorPanel
#@+node:ekr.20031218072017.699:createFontPanel
proc createFontPanel {w} {

	frame $w.top
	frame $w.size -bd 2 -relief "ridge"
	frame $w.sample -bd 2 -relief "ridge"
	pack $w.top $w.size $w.sample -pady 2 -ipadx 5 -anchor w -fill both
	
	<< create family pane >>
	<< create style pane >>
	<< create buttons >>
	<< create size pane >>
	<< create sample pane >>
}
#@nonl
#@+node:ekr.20031218072017.700:<< create family pane >>
frame $w.top.family -bd 2 -relief "ridge"
label $w.top.family.lab -text "family"
listbox $w.top.family.box
pack $w.top.family.lab $w.top.family.box -anchor w

frame $w.top.style -bd 2 -relief "ridge"
frame $w.top.right -bd 2 -relief "flat"
pack $w.top.family $w.top.style $w.top.right -side left -fill y -padx 2 -pady 2 ; # -ipadx 5 -ipady 5
#@nonl
#@-node:ekr.20031218072017.700:<< create family pane >>
#@+node:ekr.20031218072017.701:<< create style pane >>
label $w.top.style.lab -text "Style"
pack  $w.top.style.lab -anchor w
foreach {name text} {
	b Bold
	i Italic
	u Underline
	o Overstrike
} {
	checkbutton $w.top.style.$name -text $text
	pack $w.top.style.$name -side top -anchor w -expand 1
}
#@nonl
#@-node:ekr.20031218072017.701:<< create style pane >>
#@+node:ekr.20031218072017.702:<< create buttons >>
foreach {name text} {
	ok OK
	cancel Cancel
	apply Apply
} {
	button $w.top.right.$name -text $text -width 6
	pack   $w.top.right.$name -side top -anchor w -pady 2m ; # -expand 1
}
#@nonl
#@-node:ekr.20031218072017.702:<< create buttons >>
#@+node:ekr.20031218072017.703:<< create size pane >>
frame $w.size.left
label $w.size.lab -text "Size"

text  $w.size.text -height 1 -width 4
pack  $w.size.lab -anchor w
pack  $w.size.left -side left
pack  $w.size.text -side left -fill x -expand 1

frame $w.size.left.row1
frame $w.size.left.row2
pack $w.size.left.row1 $w.size.left.row2 -side top

foreach {size} {
	8 12 18
} {
	radiobutton $w.size.left.row1.radio$size -text $size -variable size
	pack $w.size.left.row1.radio$size -side left
}
foreach {size} {
	10 14 24
} {
	radiobutton $w.size.left.row2.radio$size -text $size -variable size
	pack $w.size.left.row2.radio$size -side left
}
#@nonl
#@-node:ekr.20031218072017.703:<< create size pane >>
#@+node:ekr.20031218072017.704:<< create sample pane >>
label $w.sample.lab -text "Sample"
pack  $w.sample.lab -side top -anchor w

label $w.sample.text -text "ABCabcXYZxyz123(may be changed)"

# entry $w.sample.text -background [$w.sample cget -background]
# $w.sample.text insert 0 "ABCabcXYZxyz123(may be changed)"

pack $w.sample.text -side top -anchor c -expand 1 -fill none

# $w.sample.text insert 0 "ABCabcXYZxyz123(may be changed)"
# $w.sample.text configure -state disabled
#@nonl
#@-node:ekr.20031218072017.704:<< create sample pane >>
#@-node:ekr.20031218072017.699:createFontPanel
#@+node:ekr.20031218072017.705:dkffontCreateFontPanel
@ Build the font panel (except for the apply button, which is handled by the 'configure_apply procedure...
@c

proc origCreateFontPanel {w} {
	# Framed regions.  Do this with grid and labels, as that seems
	# to be the most effective technique in practise!
	frame $w.border1 -class DKFChooseFontFrame
	frame $w.border2 -class DKFChooseFontFrame
	frame $w.border3 -class DKFChooseFontFrame
	frame $w.border4 -class DKFChooseFontFrame
	set gap [get_gap $w]
	grid $w.border1 -row 0 -column 0 -rowspan 4 -columnspan 4 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border2 -row 0 -column 4 -rowspan 4 -columnspan 3 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border3 -row 4 -column 0 -rowspan 3 -columnspan 9 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border4 -row 7 -column 0 -rowspan 3 -columnspan 9 \
		-padx $gap -pady $gap -sticky nsew
	incr gap $gap
	foreach col {0 3 4 6 8} {
		grid columnconfigure $w $col -minsize $gap
	}
	foreach row {0 3 4 6 7 9} {
		grid rowconfigure    $w $row -minsize $gap
	}
	grid columnconfigure $w 1 -weight 1
	grid rowconfigure    $w 1 -weight 1
	grid rowconfigure    $w 8 -weight 1

	# Labels for the framed boxes & focus accelerators for their contents
	foreach {subname row col focusWin} {
		Family 0 1 .family     
		Style  0 5 .style.sBold
		Size   4 1 .size.b8    
		Sample 7 1 .sample.text
	} {
		set l [label $w.lbl$subname]
		grid $l -row $row -column $col -sticky w
		## set accel [get_accel $l]
		## if {[string length $accel]} {
			## bind $w <$accel> [list focus $w$focusWin]
		##}
	}

	# Font families
	frame $w.familyBox
	listbox $w.family -exportsel 0 -selectmode browse \
		-xscrollcommand [list $w.familyX set] \
		-yscrollcommand [list $w.familyY set]
	scrollbar $w.familyX -command [list $w.family xview]
	scrollbar $w.familyY -command [list $w.family yview]
	##foreach family [list_families] {
	##	$w.family insert end ['map 'capitalise $family]
	##}
	grid $w.familyBox -row 1 -column 1 -rowspan 1 -columnspan 2 -sticky nsew
	grid columnconfigure $w.familyBox 0 -weight 1
	grid rowconfigure    $w.familyBox 0 -weight 1
	grid $w.family  $w.familyY -sticky nsew -in $w.familyBox
	grid $w.familyX            -sticky nsew -in $w.familyBox
	## bind $w.family <1> [namespace code {'change_family %W [%W nearest %y]}]
	## bindtags $w.family [concat [bindtags $w.family] key$w.family]
	## bind key$w.family <Key> [namespace code {'change_family %W active %A}]

	# Font styles.
	frame $w.style
	grid $w.style -row 1 -column 5 -sticky news
	grid columnconfigure $w.style 0 -weight 1
	foreach {fontstyle lcstyle row next prev} {
		Bold      bold       0 Italic    {}
		Italic    italic     1 Underline Bold
		Underline underline  2 Strikeout Italic
		Strikeout overstrike 3 {}        Underline
	} {
		set b $w.style.s$fontstyle
		checkbutton $b -variable [namespace current]::Style($lcstyle) \
			-command [namespace code 'set_font]
		grid $b -sticky nsew -row $row
		grid rowconfigure $w.style $row -weight 1
		if {[string length $next]} {
			## bind $b <Down> [list focus $w.style.s$next]
		}
		if {[string length $prev]} {
			## bind $b <Up> [list focus $w.style.s$prev]
		}
		## bind $b <Tab>       "[list focus $w.size.b8];break"
		## bind $b <Shift-Tab> "[list focus $w.family ];break"
		## set accel ['get_accel $b]
		## if {[string length $accel]} {
			## bind $w <$accel> "focus $b; $b invoke"
		## }
		## bind $b <Return> "$b invoke; break"
	}
	
	# Size adjustment.  Common sizes with radio buttons, and an
	# entry for everything else.
	frame $w.size
	grid $w.size -row 5 -column 1 -rowspan 1 -columnspan 7 -sticky nsew
	foreach {size row col u d l r} {
		8  0 0  {} 10 {} 12
		10 1 0   8 {} {} 14
		12 0 1  {} 14  8 18
		14 1 1  12 {} 10 24
		18 0 2  {} 24 12 {}
		24 1 2  18 {} 14 {}
	} {
		set b $w.size.b$size
		radiobutton $b -variable [namespace current]::Size -value $size \
			-command [namespace code 'set_font]
		grid $b -row $row -column $col -sticky ew
		#grid columnconfigure $w.size $col -weight 1
		## bif {[string length $u]} {bind $b <Up>    [list focus $w.size.b$u]}
		## bif {[string length $d]} {bind $b <Down>  [list focus $w.size.b$d]}
		## bif {[string length $l]} {bind $b <Left>  [list focus $w.size.b$l]}
		## bif {[string length $r]} {bind $b <Right> [list focus $w.size.b$r]}
		## bind $b <Tab>       "[list focus $w.size.entry ];break"
		## bind $b <Shift-Tab> "[list focus $w.style.sBold];break"
		## set accel ['get_accel $b]
		## if {[string length $accel]} {
			## bind $w <$accel> "focus $b; $b invoke"
		## }
		## bind $b <Return> "$b invoke; break"
	}
	entry $w.size.entry -textvariable [namespace current]::Size
	grid $w.size.entry -row 0 -column 3 -rowspan 2 -sticky ew
	grid columnconfigure $w.size 3 -weight 1
	## bind $w.size.entry <Return> [namespace code {'set_font;break}]
	
	# Sample text.  Note that this is editable
	frame $w.sample
	grid $w.sample -row 8 -column 1 -columnspan 7 -sticky nsew
	grid propagate $w.sample 0
	entry $w.sample.text -background [$w.sample cget -background]
	$w.sample.text insert 0 [option get $w.sample.text text Text]
	grid $w.sample.text
	
	# OK, Cancel and (partially) Apply.  See also 'configure_apply
	frame $w.butnframe
	grid $w.butnframe -row 0 -column 7 -rowspan 4 -columnspan 2 -sticky nsew -pady $gap
	foreach {but code} {
		ok  0
		can 1
	} {
		button $w.butnframe.$but -command [namespace code [list set Done $code]]
		pack   $w.butnframe.$but -side top -fill x -padx [expr {$gap/2}] -pady [expr {$gap/2}]
	}
	button $w.butnframe.apl
	## bind $w.butnframe.ok <Down> [list focus $w.butnframe.can]
	## bind $w.butnframe.can <Up> [list focus $w.butnframe.ok]
}
#@nonl
#@+node:ekr.20031218072017.706:get_accel
# Convenience proc to get the accelerator for a particular window
# if the user has given one.  Makes it simpler to get this right
# everywhere it is needed...

proc get_accel {w} {
	option get $w accelerator Accelerator
}
#@nonl
#@-node:ekr.20031218072017.706:get_accel
#@+node:ekr.20031218072017.707:get_gap
# Get the gap spacing for the frameboxes.  Use a user-specified
# default if there is one (that is a valid integer) and fall back
# to measuring/guessing otherwise.
proc get_gap {w} {
	set gap [option get $w lineGap LineGap]
	if {[catch {incr gap 0}]} {
		# Some cunning font measuring!
		label $w._testing
		set font [$w._testing cget -font]
		set gap [expr {[font metrics $font -linespace]/2+1}]
		destroy $w._testing
	}
	return $gap
}
#@nonl
#@-node:ekr.20031218072017.707:get_gap
#@+node:ekr.20031218072017.708:list_families
# Get a sorted lower-case list of all the font families defined on
# the system.  A canonicalisation of [font families]
proc list_families {} {
	lsort [string tolower [font families]]
}
#@-node:ekr.20031218072017.708:list_families
#@-node:ekr.20031218072017.705:dkffontCreateFontPanel
#@+node:ekr.20031218072017.709:createComparePanel
# Path 1: text box
# Path 2: text box

# check: File extension: text box

# Radio buttons:
# 	* print all lines
# 	* print mismatches
# 	* print matches
	
# check: stop after first mismatch
# check: send result to file: text box
# check: generate diffs
# check: ignore whitespace
# check: ignore blank lines

proc createComparePanel {} {

	toplevel .comparePanel
}
#@nonl
#@-node:ekr.20031218072017.709:createComparePanel
#@+node:ekr.20031218072017.710:createWindowWithCursor
# apparantly this is a Tk bug on XP.
proc createWindowWithCursor {} {

	toplevel .panel
	text     .panel.text
	.panel.text configure -cursor {gumby red green}
	pack .panel.text
}
#@nonl
#@-node:ekr.20031218072017.710:createWindowWithCursor
#@+node:ekr.20031218072017.711:createWindowWithIcon
proc createWindowWithIcon {} {

	global tk_library
	global tcl_patchLevel

	toplevel .panel
	
	# ***** Bitmaps apparently must be only 2 colors.  Photos are everything else!

	# wm iconbitmap .panel [image create photo -file c:/prog/leoCVS/leo/Icons/box00.GIF]
	#wm iconbitmap .panel [image create bitmap -file c:/prog/leoCVS/leo/Icons/box00.bmp]
	
	# no errors, no icon
	#wm iconbitmap .panel [image create bitmap @[file join c:/ Tcl lib tk8.3 demos images face.bmp]]
	# wm iconbitmap .panel @[file join c:/ Tcl lib tk8.3 demos images face.bmp]
	
	wm iconbitmap .panel info
	
	# Bitmap image1 not defined
	#wm iconbitmap .panel [image create photo -file [file join c:/ prog leoCVS leo Icons Leoapp.GIF]]
	
	# works
	#label .panel.bitmap -borderwidth 2 -relief sunken -bitmap @[file join $tk_library demos images face.bmp]
	#label .panel.lab -text $tk_library
	# label .panel.lab -borderwidth 2 -relief sunken -bitmap @[file join c:/ Tcl lib tk8.3 demos images face.bmp]
	# label .panel.lab -borderwidth 2 -relief sunken -bitmap @[file join c:/ prog leoCVS leo Icons face.bmp]
	
	# works!! (Only GIF allowed?)
	label .panel.lab -borderwidth 2 -relief sunken -image \
		[image create photo -file [file join c:/ prog leoCVS leo Icons Leoapp.GIF]]
	pack  .panel.lab

	label .panel.lab2 -text $tcl_patchLevel
	pack  .panel.lab2
}
#@nonl
#@-node:ekr.20031218072017.711:createWindowWithIcon
#@+node:ekr.20031218072017.712:myFrame
# w is the frame to be created.
# This configures w.f to be the content.
# Typically, the user will pack more content into w.f.

proc myFrame {w args} {

	# Args must come in pairs.
    if {([llength $args] % 2) != 0} {
        error {wrong # args: should be "myFrame pathName ?options?"}
    }
	# Initialize the local vars.
    set allopts {} # options that apply everywhere.
    set fopts {} # border options.
    set lopts {} # label options (only for labels that are Tk label widgets)
    set labelanchor nw # The usual default.
    set padx 0
    set pady 0
    set bd 2
    set relief groove
    set labelwindow "" # Can be any Tk widget!
    set text "" # The user usually just sets this.
	# Set vars based on args.
    foreach {opt val} $args {
        switch -- $opt {
            -bd - -borderwidth {
                set bd $val
            }
            -relief {
                set relief $val
            }
            -text {
                lappend lopts $opt $val
                set text $val
            }
            -font - -fg - -foreground {
                lappend lopts $opt $val
            }
            -labelanchor {
                set labelanchor $val
            }
            -labelwindow {
                set labelwindow $val
            }
            -padx {
                set padx $val
            }
            -pady {
                set pady $val
            }
            -bg - -background - -cursor {
                lappend allopts $opt $val
            }
            default {
                error "Unknown or unsupported option: $opt"
            }
        }
    }
	# relief and border options are frame options.
    lappend fopts -relief $relief -bd $bd 
	# Create the frame and its border, w.bd.
    eval frame $w $allopts
    eval frame $w.bd $fopts $allopts
	# Create lw depending on args.
    if {$labelwindow != ""} {
		# Used the window the user passed in.
        set lw $labelwindow
        raise $labelwindow $w
    } elseif {$text != ""} {
        set lw $w.l
		# This is typical.
        eval label $lw $lopts $allopts -highlightthickness 0 -bd 0
    } else {
        set lw ""
    }
	# Create the frame's grid.
    eval frame $w.f $allopts
	# Configure w as a grid with 5 rows and columns:
	# 1 border, 2 pad, 3 w.f, 4 pad, 5 border.
    grid columnconfigure $w {2 4} -minsize $padx
    grid rowconfigure    $w {2 4} -minsize $pady
    grid columnconfigure $w 3     -weight 1
    grid rowconfigure    $w 3     -weight 1
    grid columnconfigure $w {1 5} -minsize $bd
    grid rowconfigure    $w {1 5} -minsize $bd
	# Create the border, w.bd.
    grid $w.bd -row 1 -col 1 -rowspan 5 -columnspan 5 -sticky news
	# Create the content, w.f in the center.
    grid $w.f -row 3 -col 3 -sticky news
	# Optional: configure lw, the label window in the frame.
    if {$lw != ""} {
		# n*, s*, w* and e* are patterns to -glob.
        switch -glob $labelanchor {
            n* {
                grid $lw -in $w -row 0 -col 2 -rowspan 2 -columnspan 3 -padx 4
            }
            s* {
                grid $lw -in $w -row 5 -col 2 -rowspan 2 -columnspan 3 -padx 4
            }
            w* {
                grid $lw -in $w -row 2 -col 0 -rowspan 3 -columnspan 2 -pady 4
            }
            e* {
                grid $lw -in $w -row 2 -col 5 -rowspan 3 -columnspan 2 -pady 4
            }
        }
		# set the sticky param to the first character of the labelanchor, i.e., n,s,e or w.
        grid $lw -sticky [string index $labelanchor 1]
    }
}
#@nonl
#@-node:ekr.20031218072017.712:myFrame
#@+node:ekr.20031218072017.713:tk labeled frames
proc makeLeoFrame {} {

	# Create the outer labeld frame (doesn't actually have a label).
	myFrame .f -relief ridge -padx 5 -pady 5
	pack .f -fill both -expand 1 -padx 5 -pady 5
	
	# Initialize the grid positioin.
	set row 0
	set col 0
	# lp is the labelanchor value: 1 or two characters, the first character indicates side.
	foreach lp {nw n ne en e es se s sw ws w wn} {
		set w .f.f.f$lp
		# Create a myFrame: everything after %w are args.
		myFrame $w -text "Hej" -padx 2 -pady 2 -labelanchor $lp
		# Place the frame in the grid.
		grid $w -row $row -col $col -sticky news -padx 5 -pady 5
		# Create two buttons and pack them in the labeled frame.
		button $w.f.b1 -text Hoppsan
		button $w.f.b2 -text Quit -command exit
		pack $w.f.b1 $w.f.b2 -side top -fill x -padx 2 -pady 2
		# Bump the grid position.
		incr col
		if {$col == 3} {
			incr row
			set col 0
		}
	}
	
	# Create the last row.
	foreach wl {l1 l2 l3} {
		# Create the "special" label w.
		switch $wl {
			l1 {
				label .$wl -text Hej -bd 2 -relief groove
			} 
			l2 {
				checkbutton .$wl -text Hej
			} 
			l3 {
				radiobutton .$wl -text Hej
			}
		} 
		set w .f.f.f$wl
	
		# Create the labled frame using the -labelwindow option.
		myFrame $w -labelwindow .$wl -padx 2 -pady 2 -labelanchor nw
		# Place the labeled frame in the grid
		grid $w -row $row -col $col -sticky news -padx 5 -pady 5
		# Create two buttons and pack them in the labeled frame.
		button $w.f.b1 -text Hoppsan
		button $w.f.b2 -text Quit -command exit
		pack $w.f.b1 $w.f.b2 -side top -fill x -padx 2 -pady 2
		# Bump the grid position.
		incr col
		if {$col == 3} {
			incr row
			set col 0
		}
	}
}
#@nonl
#@-node:ekr.20031218072017.713:tk labeled frames
#@-node:ekr.20031218072017.680:@file c:/prog/test/leoSplitter.tcl
#@+node:ekr.20031218072017.714:tkBugs.tcl
#@+node:ekr.20031218072017.715:@file c:/prog/test/tkBugs.tcl
# This file creates tk test code for prototyping.
@language tcltk
@others

bindBug
#@+node:ekr.20031218072017.716:canvasBug
proc canvasBug {} {
	toplevel .test -bg "blue"
	canvas .test.c -bd 20 -bg "white" -relief "raised"
	pack .test.c -expand 1 -fill "both"
	text .test.c.t -height 1 -background "red"
	pack .test.c.t
	menu .test 
}
#@-node:ekr.20031218072017.716:canvasBug
#@+node:ekr.20031218072017.717:bindBug
proc bindBug {} {

	toplevel .top
	
	text .top.t
	pack .top.t
	
	menu .top.m   -tearoff 0
	menu .top.m.f -tearoff 0
	menu .top.m.e -tearoff 0
	
	.top.m.f add separator
	.top.m.f add command -label "A" -command {""}
	.top.m.f add command -label "B" -command {""}

	.top.m add cascade -label "File" -menu top.m.f -underline 0
	.top.m add cascade -label "Edit" -menu top.m.e -underline 0
	
	.top configure -menu .top.m
}
#@-node:ekr.20031218072017.717:bindBug
#@-node:ekr.20031218072017.715:@file c:/prog/test/tkBugs.tcl
#@-node:ekr.20031218072017.714:tkBugs.tcl
#@-node:ekr.20031218072017.679:Tk code
#@-node:ekr.20031218072017.678:Report Tk bugs
#@+node:ekr.20031218072017.718:(tab bug)
#@+node:ekr.20040117092727:This is definitely a Tk bug
By: dthein ( Dave Hein ) 
 RE: BUG: Non-leading tabs not working properl   
2004-01-17 14:40  

 This seems to be a TK bug. I've reproduced the problem directly in Tk.

It's been around for a long time :-(

More details on this page, along with a patch for an earlier version.

http://www.qs.co.nz/Tcl/TkTabs.html

The Tk folks fixed a bug I reported with Ctrl-V behavior, but it took about a year for them to get to it. I don't have high expectations with this problem either, but I'll probably put together a patch for some of the recent version of Tk and submit the patches and bug report.  
#@-node:ekr.20040117092727:This is definitely a Tk bug
#@+node:ekr.20040118090055:Patch and bug report
https://sourceforge.net/forum/message.php?msg_id=2380238
By: dthein

I've submitted a patch and bug report to the Tk project.

The patch, #879073, for those that want to fix this problem on their systems,
is at:

http://sourceforge.net/tracker/?func=detail&aid=879073&group_id=12997&atid=31299
7

And the bug report, #879077, is at:

http://sourceforge.net/tracker/?func=detail&aid=879077&group_id=12997&atid=11299
7

The patch is for 8.4.2.  If you have a different version, you can probably figure
out the changes needed by looking at the patch file.  If not, let me know your
version and I may be able to produce a patch for it.

Note: If you use tabs for anything other than leading whitespace, you will find
this patch really helpful.  I make lots of little tables when I'm documenting
or note-taking ... this fix really helped my sanity when making those tables
inside Leo.

Dave Hein
#@nonl
#@-node:ekr.20040118090055:Patch and bug report
#@+node:ekr.20031218072017.719:Report
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1906790
By: dspeed
Open Discussion

-- Tabs are not expanded correctly in .c files, when language in preferences is set to c, and when the tabs occur in the middle of a line. The tabs are expanded as spaces until the next tab location is reached, then the tabs are expanded correctly. 
#@-node:ekr.20031218072017.719:Report
#@+node:ekr.20040105070023.5:Report 2
Leo 4.1 rc3, build 1.62 , December 19, 2003
Python 2.3.0, Tk 8.4.2
Linux 2.4.22-21mdkenterprise

1. Any tab typed before the first tab stop behaves correctly (the cursor is moved to the tab stop). Good.

2. Any tab typed after a non-tab character (even a space) _and_ after the first tab stop position doesn't behave like a tab and doesn't move the cursor to the next tab stop. Bad.

3. Any tab typed after a tab character will behave properly no matter what position on the line. Okay.

To reproduce this, set your global tab prefernence to 4. Show invisibles. And then create a node containing:

[BEGIN BODY TEXT]
@language plain
@tabwidth 8
[END BODY TEXT]

Create a child node to that one, containing:

[BEGIN BODY TEXT]
@root-code somefilename
\t\tThis works
bbb\tAnd This works
So\tdoes this

But, this \tdoes not.
Here is the two-tab \t\t behavior.
[END BODY TEXT]

I hope this is a Leo bug and not a Tk bug. 

Dave Hein 
#@nonl
#@-node:ekr.20040105070023.5:Report 2
#@+node:ekr.20031218072017.720:Minimal test
This is a test line.
#@nonl
#@-node:ekr.20031218072017.720:Minimal test
#@+node:ekr.20031218072017.721:Test File for Non Expanding Tabs
This is a test line.
put the text insertion point in the space between 'a' and 'test' above. Enter 3 tabs in a row and watch it not work.

If your expansion works correctly, then maybe something with leoconfig?  But wait, Im using the leoconfig from the beta download.

The contents of my Log Windows when opening this file:

Leo Log Window...
Pyton 2.2.2, Tk 8.3.2
reading d:\test.leo


#@-node:ekr.20031218072017.721:Test File for Non Expanding Tabs
#@+node:ekr.20031218072017.722:setTabWidth
def setTabWidth (self, w):
    
    try: # This can fail when called from scripts
        # Use the present font for computations.
        font = self.bodyCtrl.cget("font")
        root = g.app.root # 4/3/03: must specify root so idle window will work properly.
        font = tkFont.Font(root=root,font=font)
        tabw = font.measure(" " * abs(w)) # 7/2/02
        self.bodyCtrl.configure(tabs=tabw)
        self.tab_width = w
        # g.trace(w,tabw)
    except:
        g.es_exception()
        pass
#@-node:ekr.20031218072017.722:setTabWidth
#@-node:ekr.20031218072017.718:(tab bug)
#@-node:ekr.20031218072017.673:Tk bugs
#@+node:ekr.20031218072017.723:Bugs: can't recreate
#@+node:ekr.20031218072017.724:(Uppercase bug) (Can't recreate)
#@+node:ekr.20031218072017.725:Report (I can't recreate this)
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1819473
By: nobody

When I create a @file node for a file with an uppercase name like TEST.CPP, by
picking up its name, an empty node is created. On saving the leo file, it
empties the TEST.CPP file!! BAD.

On the other hand, if I key in the filename in the dialog box as 'test.cpp'
(all lowercase) the node is created properly.

Rajiv Bhagwat
#@-node:ekr.20031218072017.725:Report (I can't recreate this)
#@-node:ekr.20031218072017.724:(Uppercase bug) (Can't recreate)
#@-node:ekr.20031218072017.723:Bugs: can't recreate
#@+node:ekr.20031218072017.726:Put the setup stuff in the dist folder where they belong
#@-node:ekr.20031218072017.726:Put the setup stuff in the dist folder where they belong
#@+node:ekr.20040129133809.8:top node not saved
When opening a .leo file Leo selects the correct node but it is no longer the top most node in the window.

(no) Probably related to Leo now saving of the body pane size.
#@nonl
#@+node:ekr.20040130174232:What I did
@nocolor

- Eliminated entries like a="":  This happened because Leo no longer writes clone bits.

- Made sure Leo writes a="T" entries.  However, Leo really can't use this easily.

Another possibility would be to save the scrolling state, but that is very gui-dependent.
#@nonl
#@-node:ekr.20040130174232:What I did
#@+node:ekr.20031218072017.1579:putVnodes
def putVnodes (self):

    """Puts all <v> elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("<vnodes>") ; self.put_nl()

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            self.putVnode(p) # Write the next top-level node.

    self.put("</vnodes>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1579:putVnodes
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    c = self.c ; v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched <v.
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = self.getDqString()
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2
            s = self.getDqString()
            dict = self.getDescendentUnknownAttributes(s)
            if dict:
                self.descendentUnknownAttributesDictList.append(dict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUnknownAttribute("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.

    << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isIgnore = False
    for p2 in p.self_and_parents_iter():
        if p2.isAtIgnoreNode():
            isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("<v")
    << Put tnode index >>
    << Put attribute bits >>
    << Put tnodeList and unKnownAttributes >>
    fc.put(">")
    << Write the head text >>

    if not self.usingClipboard:
        << issue informational messages >>

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
    if g.app.use_gnx:
        gnx = g.app.nodeIndices.toString(v.t.fileIndex)
        fc.put(" t=") ; fc.put_in_dquotes(gnx)
    else:
        fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
        
    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):     attr += "T" # was a bottleneck
    if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode() and not v.isAtThinFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
    fc.put("<vh>")
    fc.putEscapedString(headString)
    fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@+node:ekr.20040702085529:<< issue informational messages >>
if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@nonl
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.2297:fileCommands.open
def open(self,file,fileName):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = file.read() ; file.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    c.beginUpdate()
    ok, ratio = self.getLeoFile(fileName,atFileNodesFlag=True)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio) # 12/2/03
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    c.endUpdate()
    # delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

dir = g.os_path_dirname(fileName)

if len(dir) > 0:
    c.openDirectory = dir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
#@-node:ekr.20031218072017.2297:fileCommands.open
#@+node:ekr.20031218072017.3030:fileCommands.readOutlineOnly
def readOutlineOnly (self,file,fileName):

    c = self.c
    # Read the entire file into the buffer
    self.fileBuffer = file.read() ; file.close()
    self.fileIndex = 0
    << Set the default directory >>
    c.beginUpdate()
    ok, ratio = self.getLeoFile(fileName,atFileNodesFlag=False)
    c.endUpdate()
    c.frame.deiconify()
    vflag,junk,secondary_ratio = self.frame.initialRatios()
    c.frame.resizePanesToRatio(ratio,secondary_ratio)
    if 0: # 1/30/04: this is useless.
        # This should be done after the pane size has been set.
        if self.topPosition:
            c.frame.tree.setTopPosition(self.topPosition)
            c.redraw()
    # delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

dir = g.os_path_dirname(fileName)

if len(dir) > 0:
    c.openDirectory = dir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >> in fileCommands.readOutlineOnly
#@-node:ekr.20031218072017.3030:fileCommands.readOutlineOnly
#@-node:ekr.20040129133809.8:top node not saved
#@-node:ekr.20031218072017.663:Bug: can't be fixed
#@+node:ekr.20040105064959:Bugs: can wait
@nocolor
#@nonl
#@+node:ekr.20040115165036:bug in xml doc parts (hard to fix?)
@language html
@ignore
@color
#@nonl
#@+node:ekr.20040115165036.1:Demo XML comment bug
@ 
This document demonstrates what appears to be a bug in Leo 4.1 rc3, build 1.62 of December 19, 2003.

It has manifested when Leo is executed under Python 2.3.3, Tk 8.4.3 under Windows 2000.

In brief, derived XML files are not well-formed with respect to comments under some conditions.  Comments can wind up nested, which looks okay to humans but not to XML parsers.
@c
#@nonl
#@-node:ekr.20040115165036.1:Demo XML comment bug
#@+node:ekr.20040115165036.3:@file xmlcommentbug.xml
@first
@language HTML
<HiMom>
@ This will produce, in the derived file, an XML comment with another XML comment embedded.  Or, if you prefer, it will produce an unclosed XML comment followed by a well-formed one, followed by a string of text containing a comment-close marker.

This text is sitting in the inner comment, according to the first view.
@c


@
This comment is well-formed, seemingly because its content does not begin on the same line as the at-sign.
@c
</HiMom>
#@nonl
#@-node:ekr.20040115165036.3:@file xmlcommentbug.xml
#@+node:ekr.20040115165036.4:xmlcommentbug.xml
<?xml version='1.0'?>
<!--@+leo-ver=4-->
<!--@+node:@file xmlcommentbug.xml-->
<!--@@first-->
<!--@@language HTML-->
<HiMom>
<!--@+at -->
<!--
<!--@nonl-->
This will produce, in the derived file, an XML comment with another XML 
comment embedded.  Or, if you prefer, it will produce an unclosed XML comment 
followed by a well-formed one, followed by a string of text containing a 
comment-close marker.

This text is sitting in the inner comment, according to the first view.
-->
<!--@-at-->
<!--@@c-->


<!--@+at-->
<!--
This comment is well-formed, seemingly because its content does not begin on 
the same line as the at-sign.
-->
<!--@-at-->
<!--@@c-->
</HiMom>
<!--@nonl-->
<!--@-node:@file xmlcommentbug.xml-->
<!--@-leo-->
#@nonl
#@-node:ekr.20040115165036.4:xmlcommentbug.xml
#@-node:ekr.20040115165036:bug in xml doc parts (hard to fix?)
#@+node:ekr.20040125114453:Import bug?control-alt-f of python code misalloctes code (waiting for answer)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2391076
By: thyrsus

There is a lot of correct intepretation going on, but there are some errors.
As an example, the anaconda code, in text.py, contains the following lines.
I'll use periods for leading whitespace, the two characters ^I for leading tabs,
and a $ to indicate a newline:

class WaitWindow:
def pop(self):
	self.screen.popWindow()
	self.screen.refresh()

def __init__(self, screen, title, text):
	self.screen = screen
	width = 40
	if (len(text) < width): width = len(text)

	t = TextboxReflowed(width, text)

	g = GridForm(self.screen, title, 1, 1)
	g.add(t, 0, 0)
	g.draw()
	self.screen.refresh()


After importing file text.py, I get three associated nodes like so:

[class WaitWindow]
.|
.+-[pop]
.|
.+-[__init__]

However, the contents of the nodes are off.  In node [class WaitWindow] the
text is

class WaitWindow:
@others
	self.screen = screen
	width = 40
	if (len(text) < width): width = len(text)

	t = TextboxReflowed(width, text)
	g = GridForm(self.screen, title, 1, 1)
	g.add(t, 0, 0)
	g.draw()
	self.screen.refresh()

Node [pop] contains the text

def pop(self):

Node [__init__] contains the text

self.screen.popWindow()
self.screen.refresh()

def __init__(self, screen, title, text):

This anaconda code is being correctly interpreted by the python 1.5 interpreter.
I'm too green with python to pronounce on whether the formatting is conventional.
I don't consider this a bug a major problem, but it should probably be addressed
before we start touting Leo for large collections of existing code.

This is my first experience importing python; in the past I've imported perl
code, and Leo gave me just one big @file node, and I was on my own to better
structure it.  Given the perversity of perl syntax ("Nothing but perl can parse
Perl." - Tom Christiansen), that's probably the right thing to do.  It's a judgement
call for whomever wants to take responsibility for the python importer as to
whether that may be the right thing to do for python.
#@nonl
#@-node:ekr.20040125114453:Import bug?control-alt-f of python code misalloctes code (waiting for answer)
#@+node:ekr.20040129133809.5:Expand/contract may not work after drag (works for me)
sometimes after a drag of a node, 
then the expand/contract doesnt work.
click or menu has no effect.
in an open leo
maybe it is ok after you save the file
other times only fix is to exit & restart.
#@nonl
#@-node:ekr.20040129133809.5:Expand/contract may not work after drag (works for me)
#@-node:ekr.20040105064959:Bugs: can wait
#@-node:ekr.20040329185649:Bugs: can't be fixed or can wait
#@-node:ekr.20040123102724:Can't or wont
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
