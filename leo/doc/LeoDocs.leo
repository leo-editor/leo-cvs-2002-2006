<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="22681" clone_windows="0"/>
<globals body_outline_ratio="0.60175879397">
	<global_window_position top="43" left="401" height="857" width="913"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20050404094627"><vh>Settings and buttons</vh>
<v t="ekr.20041226081019"><vh>@button Spell</vh></v>
<v t="ekr.20050812090111"><vh>@button rst3</vh></v>
<v t="ekr.20050407144417"><vh>@settings</vh>
<v t="ekr.20050407144342"><vh>@page http plugin</vh>
<v t="ekr.20050407144342.1"><vh>@bool http_active = True</vh></v>
<v t="ekr.20050407144342.2"><vh>@int  port = 8080</vh></v>
<v t="ekr.20050407144342.3"><vh>@string rst_http_attributename = rst_http_attribute</vh></v>
</v>
<v t="ekr.20050812123002"><vh>@page rst3 options</vh>
<v t="ekr.20050812123002.1"><vh>Http options...</vh>
<v t="ekr.20050812123002.2"><vh>@bool rst3_clear_http_attributes = False</vh></v>
<v t="ekr.20050812123002.3"><vh>@string rst3_http_attributename = 'rst_http_attribute'</vh></v>
<v t="ekr.20050812123002.4"><vh>@bool rst3_http_server_support = False</vh></v>
<v t="ekr.20050812123002.5"><vh>@string rst3_node_begin_marker = 'http-node-marker-'</vh></v>
</v>
<v t="ekr.20050812123002.6"><vh>@bool rst3_massage_body = False</vh></v>
<v t="ekr.20050812123002.7"><vh>@bool rst3_format_headlines = True</vh></v>
<v t="ekr.20050812123002.8"><vh>@bool rst3_write_intermediate_file = True</vh></v>
<v t="ekr.20051202072010"><vh>@string rst3_default_path =</vh></v>
</v>
</v>
<v t="ekr.20050901054622"><vh>@button Save</vh></v>
<v t="ekr.20050901055150"><vh>@@button promote</vh></v>
<v t="ekr.20050901060119"><vh>@@button def list</vh>
<v t="ekr.20050901061220"><vh>createDefList</vh></v>
</v>
<v t="ekr.20050901121617"><vh>@@button sentence</vh>
<v t="ekr.20050901121617.1"><vh>splitSentences</vh></v>
</v>
<v t="ekr.20050902080416"><vh>@@button reformat-paragraph</vh></v>
</v>
<v t="ekr.20050831195449"><vh>Read me first</vh></v>
<v t="ekr.20040414161647"><vh>Users Guide</vh>
<v t="ekr.20050831184021.1"><vh>Documentation for rst3 plugin</vh>
<v t="ekr.20050818163826"><vh>@rst html\rstplugin3.html</vh>
<v t="ekr.20050818163826.1"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050818163826.2"><vh>Overview</vh></v>
<v t="ekr.20050818163826.3"><vh>Comparison with previous rst plugins</vh></v>
<v t="ekr.20050818163826.4"><vh>Options</vh>
<v t="ekr.20050818163826.5"><vh>Options supporting the http plugin</vh></v>
<v t="ekr.20050818163826.6"><vh>Options that set command names</vh></v>
</v>
<v t="ekr.20050818163826.7"><vh>Headline Commands</vh></v>
<v t="ekr.20050818163826.8"><vh>Using doc parts</vh></v>
<v t="ekr.20050818163826.9"><vh>Setting defaults</vh></v>
<v t="ekr.20050818163826.10"><vh>The code-block directive</vh></v>
<v t="ekr.20050818163826.11"><vh>Required cascading style sheets</vh></v>
<v t="ekr.20050818163826.12"><vh>Notes about rST markup</vh></v>
<v t="ekr.20050818163826.13"><vh>Examples</vh></v>
<v t="ekr.20050818163826.14"><vh>Theory of operation</vh></v>
<v t="ekr.20050818163826.16"><vh>Acknowledgements</vh></v>
<v t="ekr.20050818163826.17"><vh>@rst-no-head end-of-page stuff</vh></v>
</v>
</v>
<v t="ekr.20050831184021.2"><vh>Table of contents</vh>
<v t="ekr.20040414162124"><vh>@rst html\leo_TOC.html</vh>
<v t="ekr.20050828112159"><vh>@rst-no-head All links (TOC)</vh></v>
<v t="ekr.20040414163815"><vh>Table of Contents</vh></v>
<v t="ekr.20050812134441.3"><vh>@rst-no-head end</vh></v>
</v>
</v>
<v t="ekr.20050831184021.3"><vh>Front matter</vh>
<v t="ekr.20040414172212"><vh>@rst html\frontMatter.html</vh>
<v t="ekr.20050812134441"><vh>@rst-no-head Links</vh></v>
<v t="ekr.20040414172218.2"><vh>Preface</vh></v>
<v t="ekr.20040414172218.4"><vh>Acknowledgements</vh>
<v t="ekr.20040416075437"><vh>@rst-no-head contributors of plugins</vh></v>
<v t="ekr.20040416080538"><vh>@rst-no-head special mentions</vh></v>
</v>
<v t="ekr.20040414172218.5"><vh>Copyright</vh></v>
<v t="ekr.20040414174439"><vh>DISCLAIMER OF LIABILITY</vh></v>
<v t="ekr.20050812125502"><vh>@rst-no-head End stuff</vh></v>
</v>
</v>
<v t="ekr.20050831195331.1"><vh>FAQ</vh>
<v t="ekr.20050830115714"><vh>@rst html\FAQ.html</vh>
<v t="ekr.20050830120007"><vh>@rst-no-head Links</vh></v>
<v t="ekr.20050830115714.1"><vh>Learning to use Leo</vh>
<v t="ekr.20050830115714.2"><vh>What's the best way to learn to use Leo?</vh></v>
<v t="ekr.20050830115714.4"><vh>Why should I use clones?</vh></v>
<v t="ekr.20050830115714.5"><vh>Which should I use: @root trees or @file trees?</vh></v>
<v t="ekr.20050830115714.7"><vh>When is using a section better than using a method?</vh></v>
<v t="ekr.20060111192108"><vh>When is deleting a node dangerous?</vh></v>
</v>
<v t="ekr.20050830115714.12"><vh>How should I use Leo with CVS?</vh></v>
<v t="ekr.20050830115714.13"><vh>Using derived files</vh>
<v t="ekr.20050830115714.14"><vh>How do I inhibit sentinels in derived files?</vh></v>
<v t="ekr.20050830115714.16"><vh>How do I prevent Leo from expanding sections?</vh></v>
<v t="ekr.20050830115714.18"><vh>How can I create Javascript comments?</vh></v>
<v t="ekr.20050830115714.19"><vh>How can I disable PHP comments?</vh></v>
<v t="ekr.20050830115714.20"><vh>How can I use Leo with unsuppoorted languages?</vh></v>
<v t="ekr.20050830115714.21"><vh>How do I make derived files start with a shebang line?</vh></v>
<v t="ekr.20050830115714.22"><vh>How do I use Leo to create CWEB files?</vh></v>
<v t="ekr.20050830115714.24"><vh>Can @file trees contain material not in the derived file?</vh></v>
<v t="ekr.20050830115714.25"><vh>How can I use Leo with older C compilers</vh></v>
</v>
<v t="ekr.20050830115714.26"><vh>Customizing Leo</vh>
<v t="ekr.20050830115714.29"><vh>How can I add support for a new language?</vh></v>
<v t="ekr.20050830115714.30"><vh>How do I submit a plugin?</vh></v>
<v t="ekr.20050830120844"><vh>How do I add a new menu item from a plugin?</vh></v>
</v>
<v t="ekr.20050830115714.118"><vh>Tips and techniques</vh>
<v t="ekr.20050830120857"><vh>How can I use Leo to develop Leo itself?</vh></v>
<v t="ekr.20050830115714.74"><vh>How can I import many files at once?</vh></v>
<v t="ekr.20050830115714.119"><vh>How can I use two copies of Leo to advantage?</vh></v>
<v t="ekr.20050830115714.120"><vh>How can I display graphics in Leo?</vh></v>
<v t="ekr.20050830115714.113"><vh>How can I create a template .leo file?</vh></v>
<v t="ekr.20050830115714.116"><vh>How can I show Leo files with Excel?</vh></v>
</v>
<v t="ekr.20050830115714.76"><vh>Trouble shooting</vh>
<v t="ekr.20060210070421"><vh>I can't run Leo from a cvs sandbox.  What's going on?</vh></v>
<v t="ekr.20050830115714.77"><vh>How can I use Python's pdb debugger with Leo?</vh></v>
<v t="ekr.20050906090012"><vh>How can I run Leo from a console window?</vh></v>
<v t="ekr.20050830115714.9"><vh>Some characters in derived files look funny. What can I do?</vh></v>
<v t="ekr.20050830115714.10"><vh>Some characters are garbled when importing files. What can I do?</vh></v>
<v t="ekr.20050830115714.17"><vh>I can't write Imported files.  What's going on?</vh></v>
<v t="ekr.20050908113904"><vh>Can I scroll the outline pane with the mouse wheel?</vh></v>
<v t="ekr.20050830115714.75"><vh>Leo is hanging on my Linux box.  What should I do?</vh></v>
<v t="ekr.20050830115714.114"><vh>Control-Shift backspace doesn't work.  What should I do?</vh></v>
<v t="ekr.20050830115714.115"><vh>Error messages from the rst3 plugin aren't helpful. What can I do?</vh></v>
<v t="ekr.20050830115714.117"><vh>The new Python decorator syntax causes problems.  What can I do?</vh></v>
</v>
<v t="ekr.20050906105946"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="ekr.20050831184021.4"><vh>What people are saying about Leo</vh>
<v t="ekr.20050830074716"><vh>@rst html\testimonials.html</vh>
<v t="ekr.20050830075229"><vh>@rst-no-head Links</vh></v>
<v t="ekr.20050830074815.1"><vh>Leo is revolutionary</vh></v>
<v t="ekr.20050830074815.2"><vh>Leo is a showcase Python/Tkinter application</vh></v>
<v t="ekr.20050830074815.3"><vh>Leo is fun, even addicting</vh></v>
<v t="ekr.20050830074815.4"><vh>Leo is a flexible, powerful IDE</vh></v>
<v t="ekr.20050830074815.5"><vh>Leo is a superb outliner</vh></v>
<v t="ekr.20050830074815.6"><vh>Leo is an excellent PIM</vh></v>
<v t="ekr.20050830074815.7"><vh>Leo extends, completes and simplifies literate programming</vh></v>
<v t="ekr.20050830074815.8"><vh>Leo is a superb documentation tool</vh></v>
<v t="ekr.20050830074815.9"><vh>Leo simplifies the understanding of complex systems</vh></v>
<v t="ekr.20050830074815.10"><vh>Leo is stable, well designed and well supported</vh></v>
<v t="ekr.20050830074815.11"><vh>Longer quotes...</vh>
<v t="ekr.20050830074815.12"><vh> Speed Ream's slashdot article</vh></v>
<v t="ekr.20050830074815.13"><vh>Joe Orr</vh></v>
<v t="ekr.20050830074815.14"><vh>Dan Winkler</vh></v>
<v t="ekr.20050830074815.15"><vh>Dan Winkler 2</vh></v>
<v t="ekr.20050830074815.16"><vh>Dan Winkler 3</vh></v>
</v>
<v t="ekr.20050830080545"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="ekr.20050831195331.2"><vh>Chapter 1: Installing Leo</vh>
<v t="edream.110203163054.48"><vh>@rst html\install.html</vh>
<v t="ekr.20050901110110"><vh>@rst-no-head links</vh></v>
<v t="edream.110203163054.49"><vh>System requirements</vh></v>
<v t="edream.110203163054.50"><vh>How to install Leo on Linux</vh></v>
<v t="edream.110203163054.51"><vh>How to install Leo on Windows</vh></v>
<v t="ekr.20040219100738"><vh>How to install Leo on MacOS</vh></v>
<v t="ekr.20050225070247"><vh>How to use Platypus to create a Mac launcher for Leo</vh></v>
<v t="ekr.20050225070247.1"><vh>How to create MacOS X .pkg files</vh></v>
<v t="edream.110203163054.60"><vh>How to associate Leo with .leo files on Windows</vh></v>
<v t="edream.110203163054.61"><vh>Putting the Leo icon in Leo windows</vh></v>
<v t="ekr.20050901174937"><vh>Running Leo</vh></v>
<v t="ekr.20060105145125"><vh>How to install the Aspell spell checker</vh></v>
<v t="ekr.20050906105335"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="ekr.20050831195331.3"><vh>Chapter 2: A Tutorial Introduction to Leo</vh>
<v t="ekr.20050816073412"><vh>@rst html\intro.html</vh>
<v t="ekr.20050816073814"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050816073412.1"><vh>Introduction</vh>
<v t="ekr.20050822173420"><vh>Leo's main window</vh></v>
<v t="ekr.20050823082517"><vh>Using Leo as an outliner</vh></v>
</v>
<v t="ekr.20050824151926"><vh>Key features of Leo</vh>
<v t="ekr.20050822173420.1"><vh>Derived files</vh></v>
<v t="ekr.20050822173420.2"><vh>Clones &amp; views</vh></v>
<v t="ekr.20050827055403"><vh>Outline structure is significant everywhere</vh></v>
<v t="ekr.20050822173420.3"><vh>Leo directives</vh></v>
</v>
<v t="ekr.20050827102655"><vh>Leo for Programmers</vh>
<v t="ekr.20050827090532"><vh>Quick start for programmers</vh></v>
<v t="ekr.20050829081318"><vh>Beginner`s reference guide</vh>
<v t="ekr.20050827155902"><vh>Syntax of section names</vh></v>
<v t="ekr.20050827061847"><vh>Code and doc parts</vh></v>
<v t="ekr.20050828205054"><vh>Directives for programming</vh></v>
<v t="ekr.20050828161117"><vh>Orphan nodes</vh></v>
<v t="ekr.20050828103319"><vh>Sentinel lines</vh></v>
<v t="ekr.20050827162537"><vh>Leo and literate programming</vh></v>
</v>
<v t="ekr.20050827094813"><vh>Good style and bad:  sections vs. @others</vh></v>
<v t="ekr.20050822173420.5"><vh>Scripting Leo</vh></v>
<v t="ekr.20050823081317.1"><vh>Plugins &amp; settings</vh></v>
<v t="ekr.20050827090802"><vh>Further study</vh></v>
</v>
<v t="ekr.20050816073824"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="EKR.20040524104904.26"><vh>Chapter 3: Using Outlines</vh>
<v t="ekr.20050901101608"><vh>@rst html\outlines.html</vh>
<v t="ekr.20050901101608.1"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.27"><vh>Cloning nodes</vh></v>
<v t="EKR.20040524104904.36"><vh>Creating and destroying nodes</vh></v>
<v t="EKR.20040524104904.37"><vh>Cutting, pasting and deleting nodes</vh></v>
<v t="EKR.20040524104904.38"><vh>Dragging nodes</vh></v>
<v t="EKR.20040524104904.39"><vh>Editing body text</vh></v>
<v t="EKR.20040524104904.40"><vh>Expanding &amp; contracting nodes</vh></v>
<v t="EKR.20040524104904.41"><vh>Indenting body text automatically</vh></v>
<v t="EKR.20040524104904.43"><vh>Marking nodes</vh></v>
<v t="EKR.20040524104904.44"><vh>Moving &amp; Reorganizing nodes</vh></v>
<v t="EKR.20040524104904.45"><vh>Opening URL's automatically</vh></v>
<v t="EKR.20040524104904.47"><vh>Resizing panes</vh></v>
<v t="EKR.20040524104904.48"><vh>Undoing operations</vh></v>
<v t="ekr.20050901102400"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="ekr.20050831184021.5"><vh>Chapter 4: Programming with Leo</vh>
<v t="ekr.20050828061213"><vh>@rst html\directives.html</vh>
<v t="ekr.20050828160132"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050828065955"><vh>@rst-ignore To do</vh></v>
<v t="ekr.20050828061501.1"><vh>@rst-no-head Intro.</vh></v>
<v t="ekr.20050828163557"><vh>Overview: the six ways of creating derived files</vh></v>
<v t="ekr.20050828211507"><vh>Overview: summary of directives</vh>
<v t="ekr.20050829083129"><vh>@rst-ignore alternate representation</vh></v>
</v>
<v t="ekr.20050828061501.30"><vh>Reference: all about directives</vh>
<v t="ekr.20050828173234"><vh>@ and @doc</vh></v>
<v t="ekr.20050828061501.31"><vh>@all</vh></v>
<v t="ekr.20050828173234.1"><vh>@c and @code</vh></v>
<v t="ekr.20050828061501.32"><vh>@color, @nocolor and @killcolor</vh></v>
<v t="ekr.20050828061501.33"><vh>@comment</vh></v>
<v t="ekr.20050828061501.34"><vh>@delims</vh></v>
<v t="ekr.20050828061501.35"><vh>@encoding</vh></v>
<v t="ekr.20050828061501.36"><vh>@first</vh></v>
<v t="ekr.20050828065955.3"><vh>@ignore</vh></v>
<v t="ekr.20050828061501.37"><vh>@language</vh></v>
<v t="ekr.20050828210721"><vh>@last</vh></v>
<v t="ekr.20050828061501.38"><vh>@lineending</vh></v>
<v t="ekr.20050828064254"><vh>@others</vh></v>
<v t="ekr.20050828061501.39"><vh>@path</vh></v>
<v t="ekr.20050828210721.1"><vh>@pagewidth</vh></v>
<v t="ekr.20050828210721.2"><vh>@tabwidth</vh></v>
<v t="ekr.20050828061501.40"><vh>@raw and @end_raw</vh></v>
<v t="ekr.20050828061501.41"><vh>@root-code and @root-doc</vh></v>
<v t="ekr.20050828061501.50"><vh>@verbose, @terse, @quiet and @silent</vh></v>
<v t="ekr.20050828061501.42"><vh>@wrap and @nowrap</vh></v>
</v>
<v t="ekr.20050828062751"><vh>Reference: the six ways of creating derived files</vh>
<v t="ekr.20050828061501.51"><vh> @file and @thin</vh></v>
<v t="ekr.20050828174453.1"><vh> @nosent</vh></v>
<v t="ekr.20050828174453.2"><vh> @asis and @noref</vh></v>
<v t="ekr.20050828061501.45"><vh> @root</vh>
<v t="ekr.20050828061501.47"><vh>Sections and section definitions</vh></v>
<v t="ekr.20050828061501.48"><vh>Tangling @root trees with the Tangle commands</vh></v>
<v t="ekr.20050828061501.49"><vh>Untangling @root trees with the Untangle commands</vh></v>
</v>
<v t="EKR.20040524104904.282"><vh>Converting @root trees to @file trees</vh></v>
</v>
<v t="ekr.20050828061501.43"><vh>CWEB mode</vh></v>
<v t="ekr.20050828115003"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="EKR.20040524104904.99"><vh>Chapter 5: Using Leo's Commands</vh>
<v t="ekr.20050901101608.2"><vh>@rst html\commands.html</vh>
<v t="ekr.20050901101852"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.100"><vh> The File Menu</vh>
<v t="EKR.20040524104904.101"><vh>Loading, Saving and Reverting Files</vh></v>
<v t="EKR.20040524104904.102"><vh>Communicating with external editors</vh></v>
<v t="EKR.20040524104904.105"><vh>Tangling an outline: Producing Derived Files</vh></v>
<v t="EKR.20040524104904.106"><vh>Untangling: updating an outline</vh></v>
<v t="EKR.20040524104904.108"><vh>Importing Files into Leo Outlines</vh></v>
<v t="EKR.20040524104904.109"><vh>Exporting Files from Leo Outlines</vh></v>
<v t="EKR.20040524104904.110"><vh>Quitting Leo</vh></v>
</v>
<v t="EKR.20040524104904.111"><vh> The Edit Menu</vh>
<v t="EKR.20040524104904.112"><vh>Undoing changes</vh></v>
<v t="EKR.20040524104904.113"><vh>Cutting, pasting and selecting text</vh></v>
<v t="EKR.20040524104904.114"><vh>Shifting body text</vh></v>
<v t="ekr.20050313102319"><vh>Adding and deleting comments in body text</vh></v>
<v t="EKR.20040524104904.115"><vh>Creating nodes from body text</vh></v>
<v t="EKR.20040524104904.116"><vh>Converting leading blanks and tabs in body text</vh></v>
<v t="EKR.20040524104904.117"><vh>Executing Python scripts in body text</vh></v>
<v t="EKR.20040524104904.118"><vh>Finding and changing text</vh></v>
<v t="ekr.20050902160924"><vh>Script search</vh></v>
<v t="EKR.20040524104904.134"><vh>Go To Line Number</vh></v>
<v t="EKR.20040524104904.136"><vh>Inserting the date and time</vh></v>
<v t="EKR.20040524104904.137"><vh>Reformatting paragraphs in body text</vh></v>
<v t="EKR.20040524104904.139"><vh>Matching brackets and parenthesis</vh></v>
<v t="EKR.20040524104904.140"><vh>Specifying settings</vh>
<v t="ekr.20060105214753"><vh>Input modes</vh></v>
</v>
</v>
<v t="EKR.20040524104904.143"><vh> The Outline Menu</vh>
<v t="EKR.20040524104904.144"><vh> Checking outlines</vh></v>
<v t="EKR.20040524104904.145"><vh> Creating &amp; cloning nodes</vh></v>
<v t="EKR.20040524104904.146"><vh> Cutting, pasting and deleting nodes</vh></v>
<v t="EKR.20040524104904.147"><vh> Expanding and contracting nodes</vh></v>
<v t="EKR.20040524104904.149"><vh> Marking nodes</vh></v>
<v t="EKR.20040524104904.150"><vh> Moving, sorting and reorganizing nodes</vh></v>
<v t="EKR.20040524104904.148"><vh> Hoisting &amp; De-hoisting nodes</vh></v>
</v>
<v t="EKR.20040524104904.151"><vh> The Window Menu</vh></v>
<v t="EKR.20040524104904.157"><vh>The Help Menu</vh></v>
<v t="ekr.20050901102400.1"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="EKR.20040524104904.161"><vh>Chapter 6: Leo and Literate Programming</vh>
<v t="ekr.20050901101608.3"><vh>@rst html\design.html</vh>
<v t="ekr.20050901101949"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.162"><vh>Why I like Literate Programming</vh></v>
<v t="EKR.20040524104904.173"><vh>How Leo Improves Literate Programming</vh></v>
<v t="EKR.20040524104904.181"><vh>How Leo Changes the Notion of Literate Programming</vh></v>
<v t="ekr.20050901102400.2"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="ekr.20050831195331.4"><vh>Chapter 7: Scripting Leo with Python</vh>
<v t="ekr.20040403171740"><vh>@rst html\scripting.html</vh>
<v t="ekr.20050812134441.1"><vh>@rst-no-head Links</vh></v>
<v t="ekr.20050901184158"><vh>@rst-ignore Important: you can run these examples!</vh></v>
<v t="ekr.20040403183229" rst_http_attribute="5d71002855443c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3122206e616d653d22687474702d6e6f64652d6d61726b65722d31223e710155043c2f613e71025d710328553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710455063c2f6469763e71055d71062855063c626f64793e710755073c2f626f64793e71085d71092855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710a55073c2f68746d6c3e710b4e65656555243c64697620636c6173733d2273656374696f6e222069643d226f76657276696577223e0a710c55493c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643122206e616d653d226f76657276696577223e4f766572766965773c2f613e3c2f68313e0a710d652e"><vh>Overview</vh></v>
<v t="ekr.20040403173920.3" rst_http_attribute="5d71002855443c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3522206e616d653d22687474702d6e6f64652d6d61726b65722d35223e710155043c2f613e71025d71032855403c64697620636c6173733d2273656374696f6e222069643d22672d746f702d7468652d636f6d6d616e6465722d6f662d7468652d746f702d77696e646f77223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f55363c64697620636c6173733d2273656374696f6e222069643d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e0a711055703c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643322206e616d653d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e672e657328293a20777269746520746f20746865206c6f672070616e653c2f613e3c2f68313e0a7111652e"><vh>g.es writes to the log pane</vh></v>
<v t="ekr.20040403175157.1" rst_http_attribute="5d71002855443c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3722206e616d653d22687474702d6e6f64652d6d61726b65722d37223e710155043c2f613e71025d71032855353c64697620636c6173733d2273656374696f6e222069643d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f55463c64697620636c6173733d2273656374696f6e222069643d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e0a7110558e3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643422206e616d653d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e6170702e77696e646f774c6973743a20746865206c697374206f6620616c6c206f70656e206672616d65733c2f613e3c2f68313e0a7111652e"><vh>app.windowList: the list of all open frames</vh></v>
<v t="ekr.20040403173920.6" rst_http_attribute="5d71002855443c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3922206e616d653d22687474702d6e6f64652d6d61726b65722d39223e710155043c2f613e71025d71032855453c64697620636c6173733d2273656374696f6e222069643d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f55463c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e0a7110558d3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643522206e616d653d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e47657474696e6720616e642073657474696e6720686561646c696e6520616e6420626f647920746578743c2f613e3c2f68313e0a7111652e"><vh>Getting and setting headline and body text</vh></v>
<v t="ekr.20040403173920.9" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313122206e616d653d22687474702d6e6f64652d6d61726b65722d3131223e710155043c2f613e71025d71032855453c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f552f3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e0a7110555f3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643622206e616d653d2274726176657273696e672d6f75746c696e6573223e54726176657273696e67206f75746c696e65733c2f613e3c2f68313e0a7111652e"><vh>Traversing outlines</vh>
<v t="ekr.20050902073404"><vh>About copying positions</vh></v>
<v t="ekr.20040403173920.10" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313322206e616d653d22687474702d6e6f64652d6d61726b65722d3133223e710155043c2f613e71025d710328552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e65656565552b3c64697620636c6173733d2273656374696f6e222069643d22632d616c6c6e6f6465732d69746572223e0a710f55573c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643722206e616d653d22632d616c6c6e6f6465732d69746572223e632e616c6c4e6f6465735f697465723c2f613e3c2f68323e0a7110652e"><vh>c.allNodes_iter</vh></v>
<v t="ekr.20040403173920.13" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313522206e616d653d22687474702d6e6f64652d6d61726b65722d3135223e710155043c2f613e71025d710328552a3c64697620636c6173733d2273656374696f6e222069643d22632d616c6c6e6f6465732d69746572223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a7112552b3c64697620636c6173733d2273656374696f6e222069643d22702d6368696c6472656e2d69746572223e0a711355573c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643822206e616d653d22702d6368696c6472656e2d69746572223e702e6368696c6472656e5f697465723c2f613e3c2f68323e0a7114652e"><vh>p.children_iter</vh></v>
<v t="ekr.20040403173920.14" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313722206e616d653d22687474702d6e6f64652d6d61726b65722d3137223e710155043c2f613e71025d710328552a3c64697620636c6173733d2273656374696f6e222069643d22702d6368696c6472656e2d69746572223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255463c64697620636c6173733d2273656374696f6e222069643d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e0a7113558d3c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643922206e616d653d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e702e706172656e74735f6974657220616e6420702e73656c665f616e645f706172656e74735f697465723c2f613e3c2f68323e0a7114652e"><vh>p.parents_iter &amp; p.self_and_parents_iter</vh></v>
<v t="ekr.20040403173920.15" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313922206e616d653d22687474702d6e6f64652d6d61726b65722d3139223e710155043c2f613e71025d71032855453c64697620636c6173733d2273656374696f6e222069643d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255493c64697620636c6173733d2273656374696f6e222069643d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e0a711355943c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313022206e616d653d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e702e7369626c696e67735f6974657220616e6420702e666f6c6c6f77696e675f7369626c696e67735f697465723c2f613e3c2f68323e0a7114652e"><vh>p.siblings_iter &amp; p.following_siblings_iter</vh></v>
<v t="ekr.20040403173920.16" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323122206e616d653d22687474702d6e6f64652d6d61726b65722d3231223e710155043c2f613e71025d71032855483c64697620636c6173733d2273656374696f6e222069643d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255463c64697620636c6173733d2273656374696f6e222069643d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e0a7113558e3c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313122206e616d653d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e702e737562747265655f6974657220616e6420702e73656c665f616e645f737562747265655f697465723c2f613e3c2f68323e0a7114652e"><vh>p.subtree_iter &amp; p.self_and_subtree_iter</vh></v>
<v t="ekr.20040903100514" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323322206e616d653d22687474702d6e6f64652d6d61726b65722d3233223e710155043c2f613e71025d71032855453c64697620636c6173733d2273656374696f6e222069643d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a7112553f3c64697620636c6173733d2273656374696f6e222069643d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e0a711355803c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313222206e616d653d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e54657374696e672077686574686572206120706f736974696f6e2069732076616c69643c2f613e3c2f68323e0a7114652e"><vh>Testing whether a position is valid</vh></v>
</v>
<v t="ekr.20040403173920.17" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323522206e616d653d22687474702d6e6f64652d6d61726b65722d3235223e710155043c2f613e71025d710328553e3c64697620636c6173733d2273656374696f6e222069643d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255073c2f6469763e0a7113552f3c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e0a711455603c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313322206e616d653d227570646174696e672d7468652d73637265656e223e5570646174696e67207468652073637265656e3c2f613e3c2f68313e0a7115652e"><vh>Updating the screen</vh></v>
<v t="ekr.20040403173920.18" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323722206e616d653d22687474702d6e6f64652d6d61726b65722d3237223e710155043c2f613e71025d710328552e3c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f553a3c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e0a711055763c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313422206e616d653d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e496e766f6b696e6720636f6d6d616e64732066726f6d20736372697074733c2f613e3c2f68313e0a7111652e"><vh>Invoking commands from scripts</vh></v>
<v t="ekr.20050907094633"><vh>Getting settings from @settings trees</vh></v>
<v t="ekr.20040403173920.19" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323922206e616d653d22687474702d6e6f64652d6d61726b65722d3239223e710155043c2f613e71025d71032855393c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f553b3c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e0a711055783c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313522206e616d653d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e47657474696e6720616e642073657474696e6720707265666572656e6365733c2f613e3c2f68313e0a7111652e"><vh>Getting and setting preferences</vh></v>
<v t="ekr.20040403173920.21" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333122206e616d653d22687474702d6e6f64652d6d61726b65722d3331223e710155043c2f613e71025d710328553a3c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f55503c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e0a711055a23c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313622206e616d653d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e46756e6374696f6e7320666f722066696e64696e6720616e64206368616e67696e6720746578742066726f6d20736372697074733c2f613e3c2f68313e0a7111652e"><vh>Functions for finding and changing text from scripts</vh></v>
<v t="ekr.20040403173920.24" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333722206e616d653d22687474702d6e6f64652d6d61726b65722d3337223e710155043c2f613e71025d71032855263c64697620636c6173733d2273656374696f6e222069643d22672d726566696e64616c6c223e710455063c2f6469763e71055d710628554f3c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255073c2f6469763e0a711355353c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e0a7114556c3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313922206e616d653d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e52756e6e696e67204c656f20696e206261746368206d6f64653c2f613e3c2f68313e0a7115652e"><vh>Running Leo in batch mode</vh></v>
<v t="ekr.20040403173920.25" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333922206e616d653d22687474702d6e6f64652d6d61726b65722d3339223e710155043c2f613e71025d71032855343c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f553e3c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e0a7110557e3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323022206e616d653d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e46756e6374696f6e7320646566696e656420696e206c656f476c6f62616c732e70793c2f613e3c2f68313e0a7111652e"><vh>Functions defined in leoGlobals.py</vh></v>
<v t="ekr.20040403173920.5" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343122206e616d653d22687474702d6e6f64652d6d61726b65722d3431223e710155043c2f613e71025d710328553d3c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f553b3c64697620636c6173733d2273656374696f6e222069643d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e0a711055783c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323122206e616d653d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e5265646972656374696e67206f75747075742066726f6d20736372697074733c2f613e3c2f68313e0a7111652e"><vh>Redirecting output from scripts</vh></v>
<v t="ekr.20051101171734"><vh>Adding new Tabs to the log pane</vh></v>
<v t="ekr.20040403173920.26" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343322206e616d653d22687474702d6e6f64652d6d61726b65722d3433223e710155043c2f613e71025d710328553a3c64697620636c6173733d2273656374696f6e222069643d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f55453c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e0a7110558c3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323222206e616d653d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e53756d6d617279206f662074686520766e6f646520616e6420706f736974696f6e20636c61737365733c2f613e3c2f68313e0a7111652e"><vh>Summary of the vnode and position classes</vh>
<v t="ekr.20040411151245" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343522206e616d653d22687474702d6e6f64652d6d61726b65722d3435223e710155043c2f613e71025d71032855443c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555253c64697620636c6173733d2273656374696f6e222069643d226974657261746f7273223e0a710f554c3c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323322206e616d653d226974657261746f7273223e4974657261746f72733c2f613e3c2f68323e0a7110652e"><vh>Iterators</vh></v>
<v t="ekr.20040403173920.27" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343722206e616d653d22687474702d6e6f64652d6d61726b65722d3437223e710155043c2f613e71025d71032855243c64697620636c6173733d2273656374696f6e222069643d226974657261746f7273223e710455063c2f6469763e71055d71062855443c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255233c64697620636c6173733d2273656374696f6e222069643d2267657474657273223e0a711355483c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323422206e616d653d2267657474657273223e476574746572733c2f613e3c2f68323e0a7114652e"><vh>Getters</vh></v>
<v t="ekr.20040403173920.28" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343922206e616d653d22687474702d6e6f64652d6d61726b65722d3439223e710155043c2f613e71025d71032855223c64697620636c6173733d2273656374696f6e222069643d2267657474657273223e710455063c2f6469763e71055d71062855443c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255233c64697620636c6173733d2273656374696f6e222069643d2273657474657273223e0a711355483c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323522206e616d653d2273657474657273223e536574746572733c2f613e3c2f68323e0a7114652e"><vh>Setters</vh></v>
</v>
<v t="ekr.20050901102400.3"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="EKR.20040524104904.211"><vh>Chapter 8: Customizing Leo</vh>
<v t="ekr.20050901101608.4"><vh>@rst html\customizing.html</vh>
<v t="ekr.20050901102055"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050903075144"><vh>Overview</vh></v>
<v t="ekr.20050903161843"><vh>Creating script buttons</vh></v>
<v t="ekr.20050907101918"><vh>@test and @suite nodes</vh></v>
<v t="EKR.20040524104904.224"><vh>Important security warnings</vh></v>
<v t="ekr.20050903074833"><vh>Writing plugins and hooks</vh></v>
<v t="ekr.20050903074833.1"><vh>Summary of hooks</vh></v>
<v t="EKR.20040524104904.231"><vh>Convenience routines for plugins</vh></v>
<v t="EKR.20040524104904.240"><vh>Support for unit testing</vh></v>
<v t="ekr.20050306090601"><vh>Adding extensible attributes to nodes and .leo files</vh></v>
<v t="ekr.20050417072710.1"><vh>How to make operations undoable</vh></v>
<v t="ekr.20050620150517"><vh>Specifying Tk options using .leo_xresources</vh></v>
<v t="ekr.20050901102400.4"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="EKR.20040524104904.245"><vh>Chapter 9: History of Leo</vh>
<v t="ekr.20050901101608.5"><vh>@rst html\history.html</vh>
<v t="ekr.20050901102147"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050902105852"><vh>Beginnings</vh></v>
<v t="ekr.20050902105852.1"><vh>Breakthrough</vh></v>
<v t="ekr.20050902105852.2"><vh>Apple and YellowBox</vh></v>
<v t="ekr.20050902105852.3"><vh>Borland C++</vh></v>
<v t="ekr.20050902105852.4"><vh>Discovering Python</vh></v>
<v t="ekr.20050902105852.5"><vh>SourceForge</vh></v>
<v t="ekr.20050902105852.6"><vh>Allowing sentinel lines in derived files</vh></v>
<v t="ekr.20050902105852.7"><vh>Untangling @file is easy!</vh></v>
<v t="ekr.20050902105852.8"><vh>Leo 3.x: Continuous improvement</vh></v>
<v t="ekr.20050902105852.9"><vh>Leo 4.0: Eliminating error 'recovery'</vh></v>
<v t="ekr.20050902105852.10"><vh>Leo 4.1: The debut of gnx's</vh></v>
<v t="ekr.20050902105852.11"><vh>Leo 4.2: Complete at last</vh></v>
<v t="ekr.20050902105852.12"><vh>Leo 4.3 Settings</vh></v>
<v t="ekr.20050902100834"><vh>@rst-ignore-tree Details</vh>
<v t="EKR.20040524104904.247"><vh>Versions</vh></v>
<v t="EKR.20040524104904.248"><vh>Designing @file trees</vh>
<v t="EKR.20040524104904.249"><vh>Deciding to do Leo2</vh></v>
<v t="EKR.20040524104904.250"><vh>A prototype</vh></v>
<v t="EKR.20040524104904.251"><vh>User interaction</vh></v>
<v t="EKR.20040524104904.252"><vh>The write code</vh></v>
<v t="EKR.20040524104904.253"><vh>The read code</vh></v>
<v t="EKR.20040524104904.254"><vh>The load/save code</vh></v>
<v t="EKR.20040524104904.255"><vh>Attributes, mirroring and dummy nodes</vh></v>
<v t="EKR.20040524104904.256"><vh>Clones</vh></v>
<v t="EKR.20040524104904.257"><vh>Error recovery, at last</vh></v>
</v>
</v>
<v t="ekr.20050901102400.5"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="EKR.20040524104904.261"><vh>Chapter 10: Theory of Operation</vh>
<v t="ekr.20050901101608.6"><vh>@rst html\theory.html</vh>
<v t="ekr.20050901102300"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.262"><vh>Overview</vh></v>
<v t="EKR.20040524104904.263"><vh>Nodes</vh></v>
<v t="EKR.20040524104904.264"><vh>Drawing and events</vh></v>
<v t="EKR.20040524104904.265"><vh>Clones</vh>
<v t="ekr.20050901134017"><vh>@rst-ignore-tree the old way of implementing clones</vh></v>
</v>
<v t="EKR.20040524104904.266"><vh>Find and change commands</vh></v>
<v t="EKR.20040524104904.267"><vh>Tangle and untangle commands</vh></v>
<v t="EKR.20040524104904.268"><vh>Unicode theory of operation</vh></v>
<v t="EKR.20040524104904.269"><vh>Unlimited undo</vh></v>
<v t="ekr.20050901102400.6"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="ekr.20050901084134"><vh>Chapter 11: White papers</vh>
<v t="ekr.20050901092232"><vh>@rst html\whitepapers.html</vh>
<v t="ekr.20050901092232.1"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.259"><vh>Tk is the future of Leo</vh></v>
<v t="EKR.20040524104904.260"><vh>Why I like Python</vh>
<v t="ekr.20050901092232.2"><vh>Clarity</vh></v>
<v t="ekr.20050901092232.3"><vh>Power</vh></v>
<v t="ekr.20050901092232.4"><vh>Safety</vh></v>
<v t="ekr.20050901092232.5"><vh>Speed</vh></v>
<v t="ekr.20050901092232.6"><vh>Conclusions</vh></v>
</v>
<v t="ekr.20050901092232.7"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="ekr.20050912125144"><vh>Chapter 12: Plugins</vh>
<v t="ekr.20050912125144.1"><vh>@rst html\plugins.html</vh>
<v t="ekr.20050912125735"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050912125735.26"><vh>Commands &amp; directives</vh>
<v t="ekr.20050912125735.82"><vh>add_directives.py</vh></v>
<v t="ekr.20050912125735.85"><vh>bibtex.py</vh></v>
<v t="ekr.20050912125735.98"><vh>ConceptualSort.py</vh></v>
<v t="ekr.20050912125735.245"><vh>datenodes.py</vh></v>
<v t="ekr.20050912125735.113"><vh>FileActions.py</vh></v>
<v t="ekr.20050912125735.129"><vh>groupOperations.py</vh></v>
<v t="ekr.20050912125735.28"><vh>import_cisco_config.py</vh></v>
<v t="ekr.20050912125735.273"><vh>Library.py</vh></v>
<v t="ekr.20050912125735.164"><vh>macros.py</vh></v>
<v t="ekr.20050912125735.314"><vh>mod_autosave.py</vh></v>
<v t="ekr.20050912125735.172"><vh>mod_read_dir_outline.py</vh></v>
<v t="ekr.20050912125735.184"><vh>mod_timestamp.py</vh></v>
<v t="ekr.20050912125735.186"><vh>outline_export.py</vh></v>
<v t="ekr.20050912125735.188"><vh>pretty_print.py</vh></v>
<v t="ekr.20050912125735.204"><vh>scheduler.py</vh></v>
<v t="ekr.20050912125735.318"><vh>table.py</vh></v>
<v t="ekr.20050912125735.225"><vh>templates.py</vh></v>
</v>
<v t="ekr.20050912125735.334"><vh>Debugging &amp;  testing</vh>
<v t="ekr.20050912125735.335"><vh>failed_import.py</vh></v>
<v t="ekr.20050912125735.336"><vh>dump_globals.py</vh></v>
<v t="ekr.20050912125735.338"><vh>enable_gc.py</vh></v>
<v t="ekr.20050912125735.341"><vh>trace_gc.py</vh></v>
<v t="ekr.20050912125735.344"><vh>trace_keys.py</vh></v>
<v t="ekr.20050912125735.346"><vh>trace_tags.py</vh></v>
</v>
<v t="ekr.20050912125735.525"><vh>Enhanced nodes</vh>
<v t="ekr.20050912125735.526"><vh>at_folder.py</vh></v>
<v t="ekr.20050912125735.529"><vh>at_produce.py</vh></v>
<v t="ekr.20050912125735.540"><vh>at_view.py</vh></v>
<v t="ekr.20050912125735.699"><vh>autotrees.py</vh></v>
<v t="ekr.20050912125735.556"><vh>base64Packager.py</vh></v>
<v t="ekr.20050912125735.565"><vh>fastGotoNode.py</vh></v>
<v t="ekr.20050912125735.597"><vh>mod_labels.py</vh></v>
<v t="ekr.20050912125735.647"><vh>read_only_nodes.py</vh></v>
<v t="ekr.20050912125735.674"><vh>run_nodes.py</vh></v>
<v t="ekr.20050912125735.694"><vh>startfile.py</vh></v>
</v>
<v t="ekr.20050912125735.868"><vh>Enhancing the body pane</vh>
<v t="ekr.20050912125735.869"><vh>arrows.py</vh></v>
<v t="ekr.20050912125735.874"><vh>image.py</vh></v>
<v t="ekr.20050912125735.880"><vh>rClick.py</vh></v>
<v t="ekr.20050912125735.904"><vh>autocompleter.py</vh></v>
<v t="ekr.20050912125735.942"><vh>color_markup.py</vh></v>
<v t="ekr.20050912125735.974"><vh>script_io_to_body.py</vh></v>
</v>
<v t="ekr.20050912125735.980"><vh>Enhancing the icon and status areas</vh>
<v t="ekr.20050912125735.981"><vh>nav_buttons.py</vh></v>
<v t="ekr.20050912125735.1008"><vh>newButtons.py</vh></v>
<v t="ekr.20050912125735.1041"><vh>hoist.py</vh></v>
<v t="ekr.20050912125735.1050"><vh>nodenavigator.py</vh></v>
<v t="ekr.20050912125735.1072"><vh>searchbox.py</vh></v>
<v t="ekr.20050912125735.1092"><vh>UNL.py</vh></v>
</v>
<v t="ekr.20050912125735.1105"><vh>Enhancing windows</vh>
<v t="ekr.20050912125735.1135" annotate="540c0100003764373130303238353530383730373236393666373236393734373937313031323836333631366536653666373436313734363530613534366235303639363336623663363535363631373230613731303236663731303334643066323736323535303436653666363436353731303532383638303236663731303635353034363636393663363537313037363235353032363236373731303832383638303236663731303935353030373130613632353530393631373236333638363537343739373036353731306232383638303236663731306335353035346637343638363537323731306436323535303236363637373130653238363830323666373130663638306136323735326571002e"><vh>cleo.py</vh></v>
<v t="ekr.20050912125735.1187"><vh>footprints.py</vh></v>
<v t="ekr.20050912125735.1205"><vh>chapters.py</vh></v>
<v t="ekr.20050912125735.1285"><vh>EditAttributes.py</vh></v>
<v t="ekr.20050912125735.1299"><vh>maximizeNewWindows.py</vh></v>
<v t="ekr.20050912125735.1301"><vh>nodebar.py</vh></v>
<v t="ekr.20050912125735.1316"><vh>redirect_to_log.py</vh></v>
<v t="ekr.20050912125735.1317"><vh>TabbedLog.py</vh></v>
<v t="ekr.20050912125735.1323"><vh>UASearch.py</vh></v>
<v t="ekr.20050912125735.1333"><vh>UniversalScrolling.py</vh></v>
<v t="ekr.20050912125735.1342"><vh>URLloader.py</vh></v>
</v>
<v t="ekr.20050912125735.2712"><vh>External editors &amp; Open With</vh>
<v t="ekr.20050912125735.2713"><vh>mod_tempfname.py</vh></v>
<v t="ekr.20050912125735.2716"><vh>open_shell.py</vh></v>
<v t="ekr.20050912125735.2726"><vh>open_with.py</vh></v>
<v t="ekr.20050912125735.3209"><vh>temacs.py &amp; usetemacs.py</vh></v>
<v t="ekr.20050912125735.2736"><vh>vim.py</vh></v>
<v t="ekr.20050912125735.2749"><vh>word_export.py</vh></v>
<v t="ekr.20050912125735.2743"><vh>xemacs.py</vh></v>
</v>
<v t="ekr.20050912125735.2759"><vh>Files</vh>
<v t="ekr.20050912125735.2760"><vh>empty_leo_file.py</vh></v>
<v t="ekr.20050912125735.2763"><vh>lineNumbers.py</vh></v>
<v t="ekr.20050912125735.2768"><vh>multifile.py</vh></v>
<v t="ekr.20050912125735.2779"><vh>niceNosent.py</vh></v>
</v>
<v t="ekr.20050912125735.2786"><vh>LeoN</vh></v>
<v t="ekr.20050912125735.2826"><vh>Menus &amp; translations</vh>
<v t="ekr.20050912125735.2828"><vh>chinese_menu.py</vh></v>
<v t="ekr.20050912125735.2836"><vh>french_fm.py</vh></v>
<v t="ekr.20050912125735.2844"><vh>pie_menus.py</vh></v>
</v>
<v t="ekr.20050912125735.2867"><vh>Plugins manager, updater &amp; menu</vh>
<v t="ekr.20050912125735.3040"><vh>leoupdate.py</vh></v>
<v t="ekr.20050912125735.2918"><vh>plugin_manager.py</vh></v>
<v t="ekr.20050912125735.2869"><vh>plugins_menu.py</vh></v>
</v>
<v t="ekr.20050912125735.3056"><vh>Scripting</vh>
<v t="ekr.20050912125735.363"><vh>dyna_menu</vh></v>
<v t="ekr.20050912125735.3057"><vh>mod_scripting.py</vh></v>
</v>
<v t="ekr.20050912125735.3077"><vh>Servers</vh>
<v t="ekr.20050912125735.3078"><vh>mod_http.py</vh></v>
</v>
<v t="ekr.20050912125735.3136"><vh>Spell Checking</vh>
<v t="ekr.20050912125735.3138"><vh>spellpyx.py</vh></v>
</v>
<v t="ekr.20050912125735.3559"><vh>Text formatting</vh>
<v t="ekr.20050912125735.3642"><vh>Leo to AsciiDoc</vh></v>
<v t="ekr.20050912125735.3832"><vh>rst3.py</vh></v>
<v t="ekr.20050912125735.3621"><vh>xsltWithNodes.py</vh></v>
</v>
<v t="ekr.20050912125735.3944"><vh>Zope and zodb</vh>
<v t="ekr.20050912125735.3945"><vh>zodb.py</vh></v>
</v>
<v t="ekr.20050912133515"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="EKR.20040524104904.274"><vh>Appendices</vh>
<v t="ekr.20050831231852"><vh>@rst html\appendices.html</vh>
<v t="ekr.20050831232205"><vh>@rst-no-head links</vh></v>
<v t="EKR.20040524104904.351"><vh>Bugs</vh></v>
<v t="EKR.20040524104904.307"><vh>Errors while tangling</vh></v>
<v t="EKR.20040524104904.327"><vh>Errors while untangling</vh></v>
<v t="EKR.20040524104904.333"><vh>Errors while reading @file nodes</vh></v>
<v t="EKR.20040524104904.336"><vh>Errors while writing @file nodes</vh></v>
<v t="EKR.20040524104904.357"><vh>Format of .leo files</vh></v>
<v t="EKR.20040524104904.337"><vh>Format of derived files (3.x)</vh></v>
<v t="EKR.20040524104904.349"><vh>Format of derived files (4.x)</vh></v>
<v t="EKR.20040524104904.354"><vh>Unicode reference</vh></v>
<v t="ekr.20050901071613"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="EKR.20040524104904.380"><vh>Glossary</vh>
<v t="ekr.20050901071041"><vh>@rst html\glossary.html</vh>
<v t="ekr.20050901071300"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050901073048"><vh>@rst-no-head glossary</vh></v>
<v t="ekr.20050901083017"><vh>@rst-no-head end stuff</vh></v>
</v>
</v>
<v t="edream.110203163054.1653"><vh>Leaps (Leo Enhancement and Advancement Proposals)</vh>
<v t="edream.110203163054.1654"><vh>100's administering Leaps (and LeoCon)</vh>
<v t="edream.110203163054.1655"><vh>Leap 102: LeoCon 1</vh></v>
</v>
<v t="edream.110203163054.1656"><vh>200's single-user Leo</vh>
<v t="edream.110203163054.1657"><vh>Leap 201. (Finished)  Represent clones as shared trees of vnodes</vh></v>
<v t="edream.110203163054.1658"><vh>Leap 202. (Finished) Create cvs-friendly file format for derived files</vh></v>
<v t="edream.110203163054.1659"><vh>Leap 203. (Finished) Use Python Mega Widgets</vh></v>
</v>
<v t="edream.110203163054.1661"><vh>300's LeoN and beyond</vh>
<v t="edream.110203163054.1662"><vh>Leap 301: Use central server</vh></v>
<v t="edream.110203163054.1663"><vh>Leap 302: Resolve CVS Conflicts command</vh>
<v t="edream.110203163054.1664"><vh>Comments by Josef</vh></v>
</v>
</v>
</v>
<v t="ekr.20051203084745"><vh>JythonShell help</vh>
<v t="ekr.20051203085709"><vh>original</vh></v>
<v t="ekr.20051203084850"><vh>@rst html\jythonShell.html</vh>
<v t="ekr.20051203084850.1"><vh>@rst-no-head links</vh></v>
<v t="ekr.20051203085709.1"><vh>Autocompleter Actions</vh></v>
<v t="ekr.20051203085709.2"><vh>Keystrokes</vh></v>
<v t="ekr.20051203085709.3"><vh>Alt Slash: Dynamic Abbreviations</vh></v>
<v t="ekr.20051203085709.4"><vh>Object Introspection</vh></v>
<v t="ekr.20051203090220"><vh>System access</vh></v>
<v t="ekr.20051203090220.1"><vh>Magic Commands</vh>
<v t="ekr.20051203094826"><vh>%alias anAlias</vh></v>
<v t="ekr.20051203094826.1"><vh>%autocall</vh></v>
<v t="ekr.20051203094826.2"><vh>%autoindent</vh></v>
<v t="ekr.20051203095113"><vh>%bg</vh></v>
<v t="ekr.20051203095113.1"><vh>%cd</vh></v>
<v t="ekr.20051203095113.2"><vh>%clean</vh></v>
<v t="ekr.20051203095113.3"><vh>%clear</vh></v>
<v t="ekr.20051203095113.4"><vh>%cwd</vh></v>
<v t="ekr.20051203095113.5"><vh>%cwd aReference</vh></v>
<v t="ekr.20051203095437"><vh>%deserialize aReference</vh></v>
<v t="ekr.20051203095437.1"><vh>%ed</vh></v>
<v t="ekr.20051203095437.2"><vh>%edit [options] [args]</vh></v>
<v t="ekr.20051203095437.3"><vh>%env</vh></v>
<v t="ekr.20051203095437.4"><vh>%hist [-n] [n1] [n2]</vh></v>
<v t="ekr.20051203095437.5"><vh>%kill n</vh></v>
<v t="ekr.20051203095437.6"><vh>%ls</vh></v>
<v t="ekr.20051203095437.7"><vh>%ls aReference</vh></v>
<v t="ekr.20051203100230"><vh>%lsmagic</vh></v>
<v t="ekr.20051203100230.1"><vh>%macro aMacro</vh></v>
<v t="ekr.20051203100230.2"><vh>%magic</vh></v>
<v t="ekr.20051203100230.3"><vh>%p</vh></v>
<v t="ekr.20051203100230.4"><vh>%pdb</vh></v>
<v t="ekr.20051203100230.5"><vh>%pdoc anObject</vh></v>
<v t="ekr.20051203100230.6"><vh>%pfile obj</vh></v>
<v t="ekr.20051203100230.7"><vh>%pinfo aReference</vh></v>
<v t="ekr.20051203100230.8"><vh>%prun statement</vh></v>
<v t="ekr.20051203100230.9"><vh>%ps</vh></v>
<v t="ekr.20051203100230.10"><vh>%r</vh></v>
<v t="ekr.20051203100930.1"><vh>%rehash and %rehashx</vh></v>
<v t="ekr.20051203100930.2"><vh>%reset</vh></v>
<v t="ekr.20051203100930.3"><vh>%run [-n -i -t [-N n] -d [-b n] -p [profile options]] file [args]</vh></v>
<v t="ekr.20051203100930.4"><vh>%save filename n1:n2 n3:n4 ... n5 .. n6 ...</vh></v>
<v t="ekr.20051203100930.6"><vh>%sc [options] varname=command</vh></v>
<v t="ekr.20051203100930.7"><vh>%see</vh></v>
<v t="ekr.20051203101658"><vh>%send n aReference</vh></v>
<v t="ekr.20051203101658.1"><vh>%serialize aReference</vh></v>
<v t="ekr.20051203101658.2"><vh>%swing aReference</vh></v>
<v t="ekr.20051203101658.3"><vh>%sx aCommand</vh></v>
<v t="ekr.20051203101828"><vh>%threads</vh></v>
<v t="ekr.20051203101828.1"><vh>%unalias anAlias</vh></v>
<v t="ekr.20051203101828.2"><vh>%url ref aUrl</vh></v>
<v t="ekr.20051203101828.3"><vh>%wait n</vh></v>
<v t="ekr.20051203101828.4"><vh>%who</vh></v>
<v t="ekr.20051203101828.5"><vh>%who_ls</vh></v>
<v t="ekr.20051203101828.6"><vh>%whos</vh></v>
<v t="ekr.20051203101828.7"><vh>%xslt ref1 ref2 ref3</vh></v>
</v>
<v t="ekr.20051203090220.2"><vh>A Note on JPIDs and the CWD</vh></v>
<v t="ekr.20051203084850.16"><vh>@rst-no-head end-of-page stuff</vh></v>
</v>
</v>
<v t="ekr.20050914132220"><vh>Other docs</vh>
<v t="ekr.20050916184158"><vh>Leo Tech report</vh>
<v t="ekr.20050916184158.1"><vh>@rst html\techReport.html</vh>
<v t="ekr.20050916184158.2"><vh>Leo’s window, outlines &amp; clones</vh></v>
<v t="ekr.20050916184158.3"><vh>Relations: organizer nodes, views, tasks and metadata</vh></v>
<v t="ekr.20050916184158.4"><vh>Plugins</vh></v>
<v t="ekr.20050916184158.5"><vh>Derived files and special nodes</vh></v>
<v t="ekr.20050916184158.6"><vh>Markup for scripts</vh></v>
<v t="ekr.20050916184158.7"><vh>Scripting Leo</vh></v>
<v t="ekr.20050916184158.8"><vh>Leo’s modules and classes</vh></v>
<v t="ekr.20050916184158.9"><vh>Predefined symbols in scripts</vh></v>
<v t="ekr.20050916184158.10"><vh>Accessing data</vh></v>
<v t="ekr.20050916184158.11"><vh>Traversing outlines</vh></v>
<v t="ekr.20050916184158.12"><vh>Executing commands from scripts</vh></v>
<v t="ekr.20050916184158.13"><vh>Bringing scripts to data</vh></v>
<v t="ekr.20050916184158.14"><vh>Unit Testing with @test and @suite nodes</vh></v>
<v t="ekr.20050916184158.15"><vh>Plugins and hooks</vh></v>
<v t="ekr.20050916184158.16"><vh>Contacts</vh></v>
</v>
</v>
<v t="ekr.20050903174637"><vh>Not used (pdf sources)</vh>
<v t="ekr.20050829134901"><vh>@@rst pdf docs\directives.pdf</vh>
<v t="ekr.20050829134901.1"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050829134901.2"><vh>@rst-ignore-node To do</vh></v>
<v t="ekr.20050829134901.3"><vh>@rst-no-head Intro.</vh></v>
<v t="ekr.20050829134901.4"><vh>Overview: the six ways of creating derived files</vh></v>
<v t="ekr.20050829134901.5"><vh>Overview: summary of directives</vh>
<v t="ekr.20050829134901.6"><vh>@rst-ignore-node alternate representation</vh></v>
</v>
<v t="ekr.20050829134901.7"><vh>Reference: all about directives</vh>
<v t="ekr.20050829134901.8"><vh>@ and @doc</vh></v>
<v t="ekr.20050829134901.9"><vh>@all</vh></v>
<v t="ekr.20050829134901.10"><vh>@c and @code</vh></v>
<v t="ekr.20050829134901.11"><vh>@color, @nocolor and @killcolor</vh></v>
<v t="ekr.20050829134901.12"><vh>@comment</vh></v>
<v t="ekr.20050829134901.13"><vh>@delims</vh></v>
<v t="ekr.20050829134901.14"><vh>@encoding</vh></v>
<v t="ekr.20050829134901.15"><vh>@first</vh></v>
<v t="ekr.20050829134901.16"><vh>@ignore</vh></v>
<v t="ekr.20050829134901.17"><vh>@language</vh></v>
<v t="ekr.20050829134901.18"><vh>@last</vh></v>
<v t="ekr.20050829134901.19"><vh>@lineending</vh></v>
<v t="ekr.20050829134901.20"><vh>@others</vh></v>
<v t="ekr.20050829134901.21"><vh>@path</vh></v>
<v t="ekr.20050829134901.22"><vh>@pagewidth</vh></v>
<v t="ekr.20050829134901.23"><vh>@tabwidth</vh></v>
<v t="ekr.20050829134901.24"><vh>@raw and @end_raw</vh></v>
<v t="ekr.20050829134901.25"><vh>@root-code and @root-doc</vh></v>
<v t="ekr.20050829134901.26"><vh>@verbose, @terse, @quiet and @silent</vh></v>
<v t="ekr.20050829134901.27"><vh>@wrap and @nowrap</vh></v>
</v>
<v t="ekr.20050829134901.28"><vh>Reference: the six ways of creating derived files</vh>
<v t="ekr.20050829134901.29"><vh> @file and @thin</vh></v>
<v t="ekr.20050829134901.30"><vh> @nosent</vh></v>
<v t="ekr.20050829134901.31"><vh> @asis and @noref</vh></v>
<v t="ekr.20050829134901.32"><vh> @root</vh>
<v t="ekr.20050829134901.33"><vh>Sections and section definitions</vh></v>
<v t="ekr.20050829134901.34"><vh>Tangling @root trees with the Tangle commands</vh></v>
<v t="ekr.20050829134901.35"><vh>Untangling @root trees with the Untangle commands</vh></v>
</v>
</v>
<v t="ekr.20050829134901.36"><vh>Cweb mode</vh>
<v t="ekr.20050829140911"><vh>@rst-ignore-node original</vh></v>
</v>
<v t="ekr.20050829134901.37"><vh>@rst-no-head end stuff</vh></v>
</v>
<v t="ekr.20050813102008.1"><vh>@@rst pdf docs\rstplugin3.pdf</vh>
<v t="ekr.20050813102008.2"><vh>@rst-no-head links</vh></v>
<v t="ekr.20050813102008.3"><vh>Overview</vh></v>
<v t="ekr.20050813102008.4"><vh>Comparison with previous rst plugins</vh></v>
<v t="ekr.20050813102008.5"><vh>Options</vh>
<v t="ekr.20050814093016"><vh>Options supporting the http plugin</vh></v>
<v t="ekr.20050816051911"><vh>Options that set command names</vh></v>
</v>
<v t="ekr.20050813102008.6"><vh>Headline Commands</vh></v>
<v t="ekr.20050813102008.7"><vh>Using doc parts</vh></v>
<v t="ekr.20050813102008.9"><vh>Setting defaults</vh></v>
<v t="ekr.20050813102008.10"><vh>The code-block directive</vh></v>
<v t="ekr.20050813102008.11"><vh>Required cascading style sheets</vh></v>
<v t="ekr.20050813102008.12"><vh>Notes about rST markup</vh></v>
<v t="ekr.20050813102008.14"><vh>Examples</vh></v>
<v t="ekr.20050814144727"><vh>Theory of operation</vh></v>
<v t="ekr.20050813102008.13"><vh>@rst-no-head end stuff</vh>
<v t="ekr.20050813102008.15"><vh>Acknowledgements</vh></v>
</v>
<v t="ekr.20050822081728"><vh>@rst-ignore-tree Footnotes</vh></v>
<v t="ekr.20050813102008.16"><vh>@rst-no-head end-of-page stuff</vh></v>
</v>
</v>
<v t="ekr.20050916065715"><vh>suggestions for tutorial</vh></v>
</v>
</v>
<v t="edream.110203163054.46"><vh>Release Notes</vh>
<v t="edream.110203163054.117"><vh>Previous versions...</vh>
<v t="ekr.20060206111717"><vh>Ancient...</vh>
<v t="edream.110203163054.118"><vh>3.x...</vh>
<v t="edream.110203163054.119"><vh>3.12 final</vh>
<v t="edream.110203163054.120"><vh>Bug fixes (major)</vh>
<v t="edream.110203163054.121"><vh>Fixed major undo bug</vh></v>
<v t="edream.110203163054.122"><vh>Fixed huge performance bug when handling read errors</vh></v>
<v t="edream.110203163054.123"><vh>Fixed memory leaks: one minor, one huge</vh></v>
</v>
<v t="edream.110203163054.124"><vh>Bug fixes (minor)</vh>
<v t="edream.110203163054.125"><vh>Fixed bug affecting encoding in headlines</vh></v>
<v t="edream.110203163054.126"><vh>Fixed bug affecting log pane</vh></v>
<v t="edream.110203163054.127"><vh>Fixed bug importing files with upper case extensions</vh></v>
<v t="edream.110203163054.128"><vh>Fixed bug involving log messages during Open commands</vh></v>
<v t="edream.110203163054.129"><vh>Fixed bug that caused some log messages to disappear</vh></v>
<v t="edream.110203163054.130"><vh>Fixed bug that disabled double-clicking when when windows were first opened</vh></v>
<v t="edream.110203163054.131"><vh>Fixed bug that forced body_pane_wraps setting to 1</vh></v>
<v t="edream.110203163054.132"><vh>Fixed bug when deleting trailing newlines in the body pane</vh></v>
<v t="edream.110203163054.133"><vh>Fixed colorizer exception when undoing paste</vh></v>
<v t="edream.110203163054.134"><vh>Fixed Go To Line Number bug</vh></v>
<v t="edream.110203163054.135"><vh>Fixed line-break bug with @nosent files</vh></v>
<v t="edream.110203163054.136"><vh>Fixed new Open With problems</vh></v>
<v t="edream.110203163054.137"><vh>Fixed problems with Convert tabs to blanks preference panel setting</vh></v>
<v t="edream.110203163054.138"><vh>Fixed problems with the code that destroys Leo windows</vh></v>
<v t="edream.110203163054.139"><vh>Fixed recent bug in the Reformat Paragraph command</vh></v>
<v t="edream.110203163054.140"><vh>Fixed refresh problem after Read @file Node command</vh></v>
<v t="edream.110203163054.141"><vh>Fixed several problems with the Open With command</vh></v>
<v t="edream.110203163054.142"><vh>Fixed Sort bug</vh></v>
<v t="edream.110203163054.143"><vh>Leo now updates ow/col numbers when plugins not enabled</vh></v>
<v t="edream.110203163054.144"><vh>Made dragging nodes more robust</vh></v>
<v t="edream.110203163054.145"><vh>Removed improper clones from LeoPy.leo</vh></v>
<v t="edream.110203163054.146"><vh>Removed unused fractional widths from leoFind code</vh></v>
<v t="edream.110203163054.147"><vh>updateRecentFiles now handles Null filenames properly</vh></v>
</v>
<v t="edream.110203163054.148"><vh>Code improvements</vh>
<v t="edream.110203163054.149"><vh>New functions in leoGlobals.py</vh></v>
<v t="edream.110203163054.150"><vh>New scripts</vh></v>
<v t="edream.110203163054.151"><vh>Rewrote dialog code</vh></v>
<v t="edream.110203163054.152"><vh>Reorganized vnodes and tnodes</vh></v>
<v t="edream.110203163054.153"><vh>Simplified startup code</vh></v>
<v t="edream.110203163054.154"><vh>Replaced exec with getattr/setattr throughout the code</vh></v>
</v>
<v t="edream.110203163054.155"><vh>Features</vh>
<v t="edream.110203163054.156"><vh>Added @wrap and @nowrap directives</vh></v>
<v t="edream.110203163054.157"><vh>Added apply button to Font panel</vh></v>
<v t="edream.110203163054.158"><vh>Added Icon &amp; Status areas to Leo window</vh></v>
<v t="edream.110203163054.159"><vh>Added minimal support for Rebol and activescript languages</vh></v>
<v t="edream.110203163054.160"><vh>Added Write Dirty @file Nodes command</vh></v>
<v t="edream.110203163054.161"><vh>Changed OnIconDoubleClick to allow @url url comments</vh></v>
<v t="edream.110203163054.162"><vh>Hyperlinks are now enabled by default</vh></v>
<v t="edream.110203163054.163"><vh>Improved how headlines are highlighted</vh></v>
<v t="edream.110203163054.164"><vh>Improved startup logic so only one frame ever gets opened</vh></v>
<v t="edream.110203163054.165"><vh>Improved the reporting of characters that do not exist in the present encoding</vh></v>
<v t="edream.110203163054.166"><vh>Leo now correctly remembers the sizes of windows</vh></v>
<v t="edream.110203163054.167"><vh>Removed toggle &lt;&lt; &gt;&gt; command</vh></v>
<v t="edream.110203163054.168"><vh>Undo now restores cursor</vh></v>
<v t="edream.110203163054.169"><vh>Updated Marks window in Mark Find and Mark Changes commands</vh></v>
<v t="edream.110203163054.170"><vh>Use "file in directory" format for entries in Recent Files list</vh></v>
</v>
<v t="edream.110203163054.171"><vh>Hooks</vh>
<v t="edream.110203163054.172"><vh>About hooks</vh></v>
<v t="edream.110203163054.173"><vh>Added "clear-mark" and "set-mark" hooks</vh></v>
<v t="edream.110203163054.174"><vh>Added hooks to customize popup menus</vh></v>
<v t="edream.110203163054.175"><vh>Added new hooks so that plugins may extend popup menus </vh></v>
</v>
<v t="edream.110203163054.176"><vh>Plugins</vh>
<v t="edream.110203163054.177"><vh>Added add_directives.py plugin</vh></v>
<v t="edream.110203163054.178"><vh>Added color_markup.py plugin</vh></v>
<v t="edream.110203163054.179"><vh>Added nav_buttons.py plugin</vh></v>
<v t="edream.110203163054.180"><vh>Added plugins_menu.py plugin</vh></v>
<v t="edream.110203163054.181"><vh>Added scripts_menu.py plugin</vh></v>
<v t="edream.110203163054.182"><vh>Improved how Leo loads plugins</vh></v>
</v>
<v t="edream.110203163054.183"><vh>Reorganized Leo folder: big change to cvs</vh>
<v t="edream.110203163054.184"><vh>Added scripts for Linux</vh></v>
</v>
</v>
<v t="edream.110203163054.185"><vh>3.11.1</vh></v>
<v t="edream.110203163054.186"><vh>3.11</vh>
<v t="edream.110203163054.187"><vh>New in 3.11 final</vh>
<v t="edream.110203163054.188"><vh>Bug fixes</vh>
<v t="edream.110203163054.189"><vh>Added call to c.redraw() in fileCommands.readAtFileNodes</vh></v>
<v t="edream.110203163054.190"><vh>Added getpreferredencoding to leoGlobals.py</vh></v>
<v t="edream.110203163054.191"><vh>Eliminated caught exception in frame.setTabWidth</vh></v>
<v t="edream.110203163054.192"><vh>Fixed bug in skip_long</vh></v>
<v t="edream.110203163054.193"><vh>Fixed bug that prevented email line in About Leo from working</vh></v>
<v t="edream.110203163054.194"><vh>Fixed unicode bugs when Tangling and Untangling</vh></v>
<v t="edream.110203163054.195"><vh>Fixed various bugs reported by Pychecker</vh></v>
<v t="edream.110203163054.196"><vh>Removed all __del__ methods</vh></v>
</v>
<v t="edream.110203163054.197"><vh>New and improved features and commands</vh>
<v t="edream.110203163054.198"><vh>Added patch by Davide Salomoni to OnIconDoubleClick</vh></v>
<v t="edream.110203163054.199"><vh>@lineending directive specifies line endings</vh></v>
<v t="edream.110203163054.200"><vh>Added thin_at_file_trees &amp; load_derived_files_immediately options</vh></v>
</v>
</v>
<v t="edream.110203163054.201"><vh>** Leo now uses unicode internally</vh>
<v t="edream.110203163054.202"><vh>Added calls to toEncodedString before all calls to write</vh></v>
<v t="edream.110203163054.203"><vh>Check for valid encoding when setting app().tkEncoding</vh></v>
<v t="edream.110203163054.204"><vh>How Leo handles unicode</vh></v>
<v t="edream.110203163054.205"><vh>Unicode settings</vh></v>
<v t="edream.110203163054.206"><vh>Unicode theory of operation</vh></v>
<v t="edream.110203163054.207"><vh>Use app().tkEncoding when writing to log pane</vh></v>
</v>
<v t="edream.110203163054.208"><vh>** Improved hooks &amp; a new plugin architecture</vh>
<v t="edream.110203163054.209"><vh>New plugin architecture</vh>
<v t="edream.110203163054.210"><vh>@file plugins/mod_open_with.py</vh>
<v t="edream.110203163054.211"><vh>on_idle</vh>
<v t="edream.110203163054.212"><vh>&lt;&lt; update v's body text &gt;&gt;</vh>
<v t="edream.110203163054.213"><vh>&lt;&lt; set s to the new text &gt;&gt;</vh></v>
<v t="edream.110203163054.214"><vh>&lt;&lt; set conflict flag &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.215"><vh>create_open_with_menu</vh>
<v t="edream.110203163054.216"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.217"><vh>Major reorganization of hooks</vh>
<v t="edream.110203163054.218"><vh>About hooks</vh></v>
</v>
<v t="edream.110203163054.219"><vh>Added several new plugins</vh></v>
<v t="edream.110203163054.220"><vh>Improved Open With plugin</vh></v>
<v t="edream.110203163054.221"><vh>Added logic to retain log output until a log exists</vh></v>
</v>
<v t="edream.110203163054.222"><vh>New configuration options &amp; plugins</vh>
<v t="edream.110203163054.223"><vh>Plugins</vh></v>
<v t="edream.110203163054.205"><vh>Unicode settings</vh></v>
<v t="edream.110203163054.224"><vh>Colors for Show Invisibibles command</vh></v>
<v t="edream.110203163054.225"><vh>look_for_control_drag_on_mouse_down option</vh></v>
<v t="edream.110203163054.226"><vh>body_insertion_cursor_color setting</vh></v>
<v t="edream.110203163054.227"><vh>time/date settings</vh></v>
</v>
<v t="edream.110203163054.228"><vh>New commands</vh>
<v t="edream.110203163054.229"><vh>Toggle Angle Brackets</vh></v>
<v t="edream.110203163054.230"><vh>Insert Body/Headline Time/Date</vh></v>
<v t="edream.110203163054.231"><vh>Go To First/last Node</vh></v>
<v t="edream.110203163054.232"><vh>Go To Parent</vh></v>
<v t="edream.110203163054.233"><vh>Go To Next/Previous Sibling</vh></v>
<v t="edream.110203163054.234"><vh>Write Missing @file Nodes</vh></v>
</v>
<v t="edream.110203163054.235"><vh>Improved commands</vh>
<v t="edream.110203163054.236"><vh>Added support for body/headline_gmt_time settings</vh></v>
<v t="edream.110203163054.237"><vh>Tangle now supports output_newline option</vh></v>
<v t="edream.110203163054.238"><vh>Major improvements to expand/contract commands</vh></v>
<v t="edream.110203163054.239"><vh>Leo now allows multiple writes of cloned nodes</vh></v>
<v t="edream.110203163054.240"><vh>The Sort Siblings command can now sort top-level nodes</vh></v>
<v t="edream.110203163054.241"><vh>Changed locks on customizeLeo.py</vh></v>
</v>
<v t="edream.110203163054.242"><vh>Other improvements</vh>
<v t="edream.110203163054.243"><vh>Allow color param when queuing messages to log pane</vh></v>
<v t="edream.110203163054.244"><vh>Improved scrolling when moving right</vh></v>
<v t="edream.110203163054.245"><vh>Put file name first in window title</vh></v>
<v t="edream.110203163054.246"><vh>Leo scrolls partially visible headlines into full view</vh></v>
<v t="edream.110203163054.247"><vh>Allowed @comment with @language plain</vh></v>
<v t="edream.110203163054.248"><vh>The Find button is now default button in the Find panel</vh></v>
<v t="edream.110203163054.249"><vh>Improved syntax coloring for html and xml</vh>
<v t="edream.110203163054.250"><vh>example of syntax coloring for html</vh></v>
</v>
<v t="edream.110203163054.251"><vh>Improved Prefs panel</vh></v>
<v t="edream.110203163054.252"><vh>Removed setup.py from distributed files</vh></v>
</v>
<v t="edream.110203163054.253"><vh>Bug fixes</vh>
<v t="edream.110203163054.254"><vh>Eliminated potential hang in Open With command</vh></v>
<v t="edream.110203163054.255"><vh>Fixed 2 line number bugs</vh></v>
<v t="edream.110203163054.256"><vh>Fixed bug involving nested comments in sentinel lines</vh></v>
<v t="edream.110203163054.257"><vh>Fixed bugs in promote/demote</vh></v>
<v t="edream.110203163054.258"><vh>Fixed configuration bug.</vh></v>
<v t="edream.110203163054.259"><vh>Fixed crasher in undo logic</vh></v>
<v t="edream.110203163054.260"><vh>Fixed drag problem</vh></v>
<v t="edream.110203163054.261"><vh>Fixed huge performance bug in v.unjoinNode</vh></v>
<v t="edream.110203163054.262"><vh>Fixed long-standing control-v bug on Linux</vh></v>
<v t="edream.110203163054.263"><vh>Fixed minor import bugs</vh></v>
<v t="edream.110203163054.264"><vh>Fixed problem with block comments</vh></v>
<v t="edream.110203163054.265"><vh>Fixed several problems revealed by French plugin</vh></v>
<v t="edream.110203163054.266"><vh>Fixed several problems with noweb mode</vh></v>
<v t="edream.110203163054.267"><vh>Fixed syntax coloring bugs</vh></v>
<v t="edream.110203163054.268"><vh>Full recolor after paste</vh></v>
<v t="edream.110203163054.269"><vh>Installer now creates plugins directory</vh></v>
<v t="edream.110203163054.270"><vh>Removed duplicate redraws when renaming nodes</vh></v>
<v t="edream.110203163054.271"><vh>Udated recent files menu when saving a new .leo file</vh></v>
<v t="edream.110203163054.272"><vh>Worked around bugs in Python 2.3 a1</vh></v>
</v>
</v>
<v t="edream.110203163054.273"><vh>3.10</vh>
<v t="edream.110203163054.274"><vh>Fixed bugs</vh>
<v t="edream.110203163054.275"><vh>Allowed abbreviated xml tags.</vh></v>
<v t="edream.110203163054.276"><vh>Changed shortcut to Find Previous so Alt - F4 closes Leo</vh></v>
<v t="edream.110203163054.277"><vh>Changed url of help file</vh></v>
<v t="edream.110203163054.278"><vh>Fixed @nsf bug reported by Travers A. Hough</vh></v>
<v t="edream.110203163054.279"><vh>Fixed a bug in Untangle</vh></v>
<v t="edream.110203163054.280"><vh>Fixed bug in Python importer</vh></v>
<v t="edream.110203163054.281"><vh>Fixed bug involving redrawing screen initially</vh></v>
<v t="edream.110203163054.282"><vh>Fixed bugs involving @nosentinelsfile</vh></v>
<v t="edream.110203163054.283"><vh>Fixed crashers in colorizeAnyLanguage</vh></v>
<v t="edream.110203163054.284"><vh>Fixed environment bug in Execute Script command</vh></v>
<v t="edream.110203163054.285"><vh>Fixed major memory leak</vh></v>
<v t="edream.110203163054.286"><vh>Fixed path problem in paths passed to tangle_done.py</vh></v>
<v t="edream.110203163054.287"><vh>Fixed problems with Open With code in customizeLeo.py</vh></v>
<v t="edream.110203163054.288"><vh>Fixed Recent Files command</vh></v>
<v t="edream.110203163054.289"><vh>Fixed reversion involving @comment &amp; @language together</vh></v>
<v t="edream.110203163054.290"><vh>Fixed undo bug</vh></v>
</v>
<v t="edream.110203163054.291"><vh>Added features</vh>
<v t="edream.110203163054.292"><vh>New Mark Clones and Go To Next Clone commands.</vh></v>
<v t="edream.110203163054.293"><vh>New Export Headlines command</vh></v>
<v t="edream.110203163054.294"><vh>Control-dragging a node now clones it</vh></v>
<v t="edream.110203163054.295"><vh>New "Node Only checkbox in the Find/Change panel</vh></v>
<v t="edream.110203163054.296"><vh>@root options</vh></v>
<v t="edream.110203163054.297"><vh>Converted leoConfig.py to use @root-code</vh></v>
<v t="edream.110203163054.298"><vh>Added @file options</vh></v>
<v t="edream.110203163054.299"><vh>Added support for underlined menu items</vh></v>
<v t="edream.110203163054.300"><vh>Improved Leo's window icon</vh></v>
<v t="edream.110203163054.301"><vh>Added easy way of replacing any Leo code</vh></v>
<v t="edream.110203163054.302"><vh>Added convenience routines to redirect stderr and stdout</vh></v>
<v t="edream.110203163054.303"><vh>Added "event1" and "event2" hooks</vh></v>
<v t="edream.110203163054.304"><vh>Added  contributed code to support @read-only nodes</vh></v>
</v>
<v t="edream.110203163054.305"><vh>Known bugs</vh>
<v t="edream.110203163054.306"><vh>Bugs in undoReplace logic</vh></v>
</v>
</v>
<v t="edream.110203163054.307"><vh>leo.py 3.9</vh>
<v t="edream.110203163054.308"><vh>Fixed bugs</vh>
<v t="edream.110203163054.309"><vh>Fixed bug involving @language</vh></v>
<v t="edream.110203163054.310"><vh>Correctly colors Pascal's "private" and "uses" keywords</vh></v>
<v t="edream.110203163054.311"><vh>Fixed a major bug in top()</vh></v>
<v t="edream.110203163054.312"><vh>Fixed bugs when importing Java files.</vh></v>
<v t="edream.110203163054.313"><vh>Convert All Blanks/Tabs  commands honor @tabwidth directives</vh></v>
</v>
<v t="edream.110203163054.314"><vh>New documentation for leo.py 3.9</vh>
<v t="edream.110203163054.315"><vh>Major performance improvements</vh>
<v t="edream.110203163054.316"><vh>Incremental syntax coloring speeds redraws</vh></v>
<v t="edream.110203163054.317"><vh>Incremental undo reduces memory usages significantly</vh></v>
</v>
<v t="edream.110203163054.318"><vh>Major configuration improvements</vh>
<v t="edream.110203163054.319"><vh>Chapter 8: Customizing Leo</vh>
<v t="ekr.20050122084954"><vh>Using leoSettings.leo and @settings trees</vh></v>
<v t="edream.110203163054.320"><vh>Obsolete: Using leoConfig.leo and leoConfig.txt</vh></v>
<v t="edream.110203163054.321"><vh>Using plugins and hooks</vh>
<v t="edream.110203163054.322"><vh>Overview of plugins and hooks</vh></v>
<v t="edream.110203163054.323"><vh>New plugin architecture</vh>
<v t="edream.110203163054.324"><vh>@file plugins/mod_open_with.py</vh>
<v t="edream.110203163054.325"><vh>on_idle</vh>
<v t="edream.110203163054.326"><vh>&lt;&lt; update v's body text &gt;&gt;</vh>
<v t="edream.110203163054.327"><vh>&lt;&lt; set s to the new text &gt;&gt;</vh></v>
<v t="edream.110203163054.328"><vh>&lt;&lt; set conflict flag &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.329"><vh>create_open_with_menu</vh>
<v t="edream.110203163054.330"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.172"><vh>About hooks</vh></v>
<v t="edream.110203163054.331"><vh>SECURITY WARNINGS</vh>
<v t="edream.110203163054.332"><vh>The danger of trusting code in shared .leo files</vh></v>
<v t="edream.110203163054.333"><vh>NEVER use this kind of code in a hook!!</vh></v>
<v t="edream.110203163054.334"><vh>Don't use rexec !!</vh>
<v t="edream.110203163054.335"><vh>&lt;&lt; change all instances of rexec to exec in v's body &gt;&gt;</vh></v>
<v t="edream.110203163054.336"><vh>&lt;&lt; delete thisNode &gt;&gt;</vh></v>
<v t="edream.110203163054.337"><vh>&lt;&lt; clear the undo stack &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.338"><vh>Convenience routines for plugins</vh>
<v t="edream.110203163054.339"><vh>Convenience functions to enable and disable the "idle" hook</vh></v>
<v t="edream.110203163054.340"><vh>Convenience methods to create, destroy and modify menus</vh>
<v t="edream.110203163054.341"><vh>createMenuItemsFromTable</vh></v>
<v t="edream.110203163054.342"><vh>createNewMenu</vh></v>
<v t="edream.110203163054.343"><vh>createOpenWithMenuFromTable</vh></v>
<v t="edream.110203163054.344"><vh>deleteMenu</vh></v>
<v t="edream.110203163054.345"><vh>deleteMenuItem</vh></v>
<v t="edream.110203163054.346"><vh>Example: how to create a menu</vh></v>
</v>
</v>
<v t="edream.110203163054.347"><vh>Translating menus into other languages</vh></v>
<v t="edream.121403162622"><vh>Support for unit testing</vh></v>
</v>
<v t="edream.110203163054.61"><vh>Putting the Leo icon in Leo windows</vh></v>
<v t="edream.110203163054.348"><vh>Extending the format of .leo files</vh></v>
<v t="edream.120703073611"><vh>Attaching temporary attributes to vnodes and tnodes</vh></v>
<v t="edream.120703073611.1"><vh>Recommended conventions for plugins</vh></v>
<v t="edream.110603190322.6"><vh> Script Find and Script Change</vh>
<v t="edream.111803060152.1"><vh>How it works</vh></v>
<v t="ekr.20040201113232"><vh>Using the initScriptFind script</vh></v>
<v t="edream.111803060152.2"><vh>Ideas for using scripts</vh></v>
</v>
<v t="ekr.20050219093156"><vh>How do I add a new menu item from a plugin?</vh>
<v t="ekr.20050219093156.1"><vh>@url http://www.pythonware.com/library/tkinter/introduction/index.htm</vh></v>
<v t="ekr.20050219093156.2"><vh>@url http://www.tcl.tk/man/tcl8.4/TkCmd/contents.htm</vh></v>
</v>
</v>
<v t="edream.110203163054.349"><vh>More flexible creation of non-existent directories</vh></v>
</v>
<v t="edream.110203163054.350"><vh>New commands &amp; features</vh>
<v t="edream.110203163054.351"><vh>@url</vh></v>
<v t="edream.110203163054.352"><vh>Execute Script command</vh></v>
<v t="edream.110203163054.353"><vh>Go To Line Number command</vh></v>
<v t="edream.110203163054.349"><vh>More flexible creation of non-existent directories</vh></v>
<v t="edream.110203163054.354"><vh>Much better support for cweb</vh>
<v t="edream.110203163054.355"><vh>About cweb mode </vh></v>
</v>
<v t="edream.110203163054.356"><vh>Open With command</vh>
<v t="edream.110203163054.343"><vh>createOpenWithMenuFromTable</vh></v>
</v>
<v t="edream.110203163054.357"><vh>Optional Emacs-style auto-indent</vh></v>
<v t="edream.110203163054.61"><vh>Putting the Leo icon in Leo windows</vh></v>
<v t="edream.110203163054.358"><vh>Reformat Paragraph command</vh></v>
</v>
<v t="edream.110203163054.359"><vh>Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees</vh></v>
</v>
</v>
<v t="edream.110203163054.360"><vh>leo.py 3.8</vh>
<v t="edream.110203163054.361"><vh>Fixed bugs</vh>
<v t="edream.110203163054.362"><vh>Crashers</vh>
<v t="edream.110203163054.363"><vh>Fixed another crasher in scanAllDirectives</vh></v>
</v>
<v t="edream.110203163054.366"><vh>Bugs involving paths &amp; derived files</vh>
<v t="edream.110203163054.368"><vh>Fixed @delims "round trip" bug</vh></v>
<v t="edream.110203163054.369"><vh>Fixed cweb sentinel bug</vh></v>
<v t="edream.110203163054.370"><vh>Fixed import to @root problems</vh></v>
<v t="edream.110203163054.371"><vh>Leo generates @@ sentinels only for real Leo directives</vh></v>
</v>
<v t="edream.110203163054.372"><vh>Minor syntax coloring bugs</vh>
<v t="edream.110203163054.373"><vh>Colorizer now recognizes comments after preprocessor directives</vh></v>
<v t="edream.110203163054.374"><vh>Syntax color perl's alarm function</vh></v>
<v t="edream.110203163054.375"><vh>Fixed block-comment bug in Java and HTML</vh></v>
</v>
<v t="edream.110203163054.376"><vh>Minor user interface bugs</vh>
<v t="edream.110203163054.377"><vh>Worked around Control-T bug</vh></v>
<v t="edream.110203163054.378"><vh>Fixed bug involving menu pastes in headlines</vh></v>
</v>
<v t="edream.110203163054.379"><vh>fixed Unicode bug in setBodyStringOrPane</vh></v>
</v>
<v t="edream.110203163054.380"><vh>New &amp; changed features</vh>
<v t="edream.110203163054.381"><vh>New @rawfile &amp; @silentfile trees</vh>
<v t="edream.110203163054.359"><vh>Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees</vh></v>
</v>
<v t="edream.110203163054.382"><vh>New @raw, @end_raw and @quiet directives</vh>
<v t="edream.110203163054.383"><vh>@raw and @end_raw directives delimit raw text</vh></v>
<v t="edream.110203163054.384"><vh>@verbose, @terse, @quiet and @silent directives control comments in @root trees</vh></v>
</v>
<v t="edream.110203163054.385"><vh>Much better support for CWEB</vh>
<v t="edream.110203163054.355"><vh>About cweb mode </vh></v>
</v>
<v t="edream.110203163054.386"><vh>Allow @comment and @language to coexist</vh></v>
<v t="edream.110203163054.387"><vh>Configuration settings and commands</vh>
<v t="edream.110203163054.388"><vh>Added stylesheet option to support &lt;?xml-stylesheet...?&gt; line</vh></v>
<v t="edream.110203163054.389"><vh>Added Configuration Commands to help menu</vh></v>
<v t="edream.110203163054.390"><vh>Added output_initial_comment option</vh></v>
<v t="edream.110203163054.391"><vh>Added output_newline option</vh></v>
<v t="edream.110203163054.392"><vh>Changed path_directive_creates_directories to create_nonexistent_directories</vh></v>
</v>
<v t="edream.110203163054.393"><vh>Minor changes</vh>
<v t="edream.110203163054.394"><vh>Added support for forth language comments</vh></v>
<v t="edream.110203163054.395"><vh>All export commands now use output_newline option</vh></v>
<v t="edream.110203163054.396"><vh>Changed names of commands in help menu and corresponding entries in leoConfig.leo</vh></v>
<v t="edream.110203163054.397"><vh>Created es_exception</vh></v>
<v t="edream.110203163054.398"><vh>Created reloadAll in leoGlobals.py</vh></v>
<v t="edream.110203163054.399"><vh>Forced focus to body pane after ending headline edit</vh></v>
<v t="edream.110203163054.400"><vh>Use // as single-line comment in Java</vh></v>
<v t="edream.110203163054.401"><vh>wrote "finished" after write @file nodes command</vh></v>
</v>
</v>
<v t="edream.110203163054.402"><vh>Coming soon: Leo 4.0, a major improvement</vh></v>
</v>
<v t="edream.110203163054.403"><vh>leo.py 3.7</vh>
<v t="edream.110203163054.404"><vh>Fixed Bugs</vh>
<v t="edream.110203163054.405"><vh>Language and syntax coloring bugs</vh>
<v t="edream.110203163054.406"><vh>Fixed @comment bug</vh></v>
<v t="edream.110203163054.407"><vh>Fixed colorizing for "while" in C</vh></v>
<v t="edream.110203163054.408"><vh>Fixed @language plain # bug</vh></v>
<v t="edream.110203163054.409"><vh>Fixed @language plain single-quote bug</vh></v>
</v>
<v t="edream.110203163054.410"><vh>Bugs in Edit body commands</vh></v>
<v t="edream.110203163054.411"><vh>Bugs relating to tangling and derived files</vh>
<v t="edream.110203163054.412"><vh>Fixed major bug in @file read code</vh></v>
<v t="edream.110203163054.413"><vh>Fixed minor read bug</vh></v>
<v t="edream.110203163054.406"><vh>Fixed @comment bug</vh></v>
<v t="edream.110203163054.414"><vh>Fixed a bug that affected wrapping in doc parts</vh></v>
</v>
<v t="edream.110203163054.415"><vh>Other bugs</vh>
<v t="edream.110203163054.416"><vh>Fixed reversion in Tangle/Untangle code</vh></v>
<v t="edream.110203163054.417"><vh>Fixed undo cloned headline bug</vh></v>
<v t="edream.110203163054.418"><vh>Fixed Find previous bug</vh></v>
<v t="edream.110203163054.419"><vh>Fixed tab problems</vh></v>
<v t="edream.110203163054.420"><vh>Leo now remembers insert point always</vh></v>
<v t="edream.110203163054.421"><vh>Removed setup.py from binary distribution</vh></v>
</v>
</v>
<v t="edream.110203163054.422"><vh>Improvements</vh>
<v t="edream.110203163054.423"><vh>Many new user options</vh>
<v t="edream.110203163054.424"><vh>General configuration options</vh>
<v t="edream.110203163054.425"><vh>path_directive_creates_directories</vh></v>
<v t="edream.110203163054.426"><vh>relative_path_base_directory</vh></v>
<v t="edream.110203163054.427"><vh>remove_sentinels_extension</vh></v>
<v t="edream.110203163054.428"><vh>write_clone_indices</vh></v>
</v>
<v t="edream.110203163054.429"><vh>Secondary pane ratios</vh></v>
<v t="edream.110203163054.430"><vh>User-configurable colors</vh></v>
<v t="edream.110203163054.431"><vh>User-configurable shortcuts for commands</vh></v>
</v>
<v t="edream.110203163054.432"><vh>Improved support for Unicode</vh></v>
<v t="edream.110203163054.433"><vh>End of cursed newlines</vh></v>
<v t="edream.110203163054.434"><vh>Code is now compatible with Python 2.1</vh></v>
<v t="edream.110203163054.435"><vh>Better file and path handling</vh></v>
<v t="edream.110203163054.436"><vh>Better support for Perl+pod</vh></v>
<v t="edream.110203163054.437"><vh>New End Edit Headline and Abort Edit Headline commands</vh></v>
<v t="edream.110203163054.438"><vh>Allow reads and writes of cloned @file nodes</vh></v>
<v t="edream.110203163054.439"><vh>Leo now closes an empty window when opening a recent file</vh></v>
<v t="edream.110203163054.440"><vh>Improved derived files</vh></v>
<v t="edream.110203163054.441"><vh>Improved enabling of menu items in popup menus</vh></v>
<v t="edream.110203163054.442"><vh>About Leo dialog is now non-modal</vh></v>
</v>
</v>
<v t="edream.110203163054.443"><vh>leo.py 3.6</vh>
<v t="edream.110203163054.444"><vh>Known bug: problems with Python window</vh></v>
<v t="edream.110203163054.445"><vh>Bug fixes</vh>
<v t="edream.110203163054.446"><vh>Fixed problems with opening and writing leoConfig.txt on Linux</vh></v>
<v t="edream.110203163054.447"><vh>Fixed problems renaming files on Linux</vh></v>
<v t="edream.110203163054.448"><vh>Fixed missing headline bug on startup</vh></v>
<v t="edream.110203163054.449"><vh>Improved call to os.path.join in leoApp.finishCreate</vh></v>
<v t="edream.110203163054.450"><vh>Improved how directories are handled in @root trees</vh></v>
<v t="edream.110203163054.451"><vh>Dave Hein: fixed Tk 8.4 problem in Prefs Panel</vh></v>
<v t="edream.110203163054.452"><vh>Dave Hein: added CheckVersion to leoUtils.py</vh></v>
<v t="edream.110203163054.453"><vh>Dave Hein: the Python window now works on Linux.</vh></v>
<v t="edream.110203163054.454"><vh>Steven P. Schaefer: Improved handling of directives in @root trees</vh></v>
<v t="edream.110203163054.455"><vh>Steven P. Schaefer: Fixed cursed newline bug for Linux</vh></v>
</v>
<v t="edream.110203163054.456"><vh>Improvements to existing features</vh>
<v t="edream.110203163054.457"><vh>Leo now remembers scrollbar position and insert point of previously visited nodes</vh></v>
<v t="edream.110203163054.458"><vh>Body pane now gets focus after Go Back/Next</vh></v>
<v t="edream.110203163054.459"><vh>Improved all commands in Help menu</vh></v>
<v t="edream.110203163054.460"><vh>Removed most error messages in atFile::read logic</vh></v>
<v t="edream.110203163054.461"><vh>Added shortcuts for Read/Write @file Nodes commands</vh></v>
<v t="edream.110203163054.462"><vh>Tomaz Ficko: Added support for MouseWheel (Linux only)</vh></v>
</v>
<v t="edream.110203163054.463"><vh>New features</vh>
<v t="edream.110203163054.464"><vh>Added Match Brackets command</vh></v>
<v t="edream.110203163054.465"><vh>Added PHP support</vh></v>
<v t="edream.110203163054.466"><vh>Added LaTex support</vh></v>
</v>
</v>
<v t="edream.110203163054.467"><vh>leo.py 3.5</vh>
<v t="edream.110203163054.468"><vh>Bug fixes</vh>
<v t="edream.110203163054.469"><vh>Called cf.flush in leoConfig.update</vh></v>
<v t="edream.110203163054.470"><vh>Fixed crasher in leoFileCommands.readOutlineOnly</vh></v>
<v t="edream.110203163054.471"><vh>Fixed crasher when leoConfig.txt did not exist</vh></v>
<v t="edream.110203163054.472"><vh>Fixed cursed newline bug in leoAtFile</vh></v>
<v t="edream.110203163054.473"><vh>Rewrote scanAllDirectives routines to handle relative paths</vh></v>
<v t="edream.110203163054.474"><vh>Suppressed erroneous tangle warning about relative paths</vh></v>
</v>
<v t="edream.110203163054.475"><vh>Improvements</vh>
<v t="edream.110203163054.476"><vh>Added configuration settings for horizontal scrollbars</vh></v>
<v t="edream.110203163054.477"><vh>Added commands to the help menu</vh></v>
<v t="edream.110203163054.478"><vh>Added logic to test for read-only files</vh></v>
<v t="edream.110203163054.479"><vh>Added importFiles script</vh></v>
</v>
</v>
<v t="edream.110203163054.480"><vh>leo.py 3.4</vh>
<v t="edream.110203163054.481"><vh>Configuration settings and leoConfig.leo</vh>
<v t="edream.110203163054.482"><vh>Added comments to leoConfig.txt about split direction and ratio</vh></v>
<v t="edream.110203163054.483"><vh>Added save_clears_undo_buffer config option</vh></v>
<v t="edream.110203163054.484"><vh>Corrected spelling of limit_directory_search_extenstion </vh></v>
<v t="edream.110203163054.485"><vh>Created leoConfig.leo</vh></v>
<v t="edream.110203163054.486"><vh>Fixed a major config bug. This fixes font problems</vh></v>
<v t="edream.110203163054.487"><vh>Improved Recent Files menu</vh></v>
<v t="edream.110203163054.488"><vh>Leo honors pane ratio stored in .leo files</vh></v>
<v t="edream.110203163054.489"><vh>Leo writes prefs if leoConfig.txt is read-only</vh></v>
<v t="edream.110203163054.490"><vh>Made leoConfig.txt be read/write by default</vh></v>
<v t="edream.110203163054.491"><vh>Toggle Split Direction now updates leoConfig.txt</vh></v>
</v>
<v t="edream.110203163054.492"><vh>Documentation for code in leo.py that may be of wider interest</vh>
<v t="edream.110203163054.493"><vh>Code hidden in leo.py</vh>
<v t="edream.110203163054.494"><vh>c2py.py</vh></v>
<v t="edream.110203163054.495"><vh>disStats.py</vh></v>
<v t="edream.110203163054.496"><vh>Tkinter utilities</vh></v>
<v t="edream.110203163054.497"><vh>Font dialog</vh></v>
<v t="edream.110203163054.498"><vh>Syntax coloring code</vh></v>
<v t="edream.110203163054.499"><vh>Tree code</vh></v>
</v>
</v>
<v t="edream.110203163054.500"><vh>Fixed bugs</vh>
<v t="edream.110203163054.501"><vh>Fixed another clone bug: created setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="edream.110203163054.502"><vh>Fixed bugs that delayed writing of find and prefs panels</vh></v>
<v t="edream.110203163054.503"><vh>Fixed revert problems in font panel</vh></v>
<v t="edream.110203163054.504"><vh>Fixed several unicode bugs</vh></v>
<v t="edream.110203163054.505"><vh>Fixed wandering insertion point bug</vh></v>
</v>
<v t="edream.110203163054.506"><vh>Minor improvements</vh>
<v t="edream.110203163054.507"><vh>Syntax colorer now honors @comment</vh></v>
<v t="edream.110203163054.508"><vh>Added @ignore to "raw" imported files</vh></v>
<v t="edream.110203163054.509"><vh>Added log message for Remove Sentinels command</vh></v>
<v t="edream.110203163054.510"><vh>Improved highlighting of whitespace</vh></v>
<v t="edream.110203163054.511"><vh>Remove Sentinels command now uses .txt extension instead of .tmp</vh></v>
</v>
</v>
<v t="edream.110203163054.512"><vh>leo.py 3.3</vh>
<v t="edream.110203163054.513"><vh>Added support for Unicode</vh></v>
<v t="edream.110203163054.514"><vh>Improved the Import commands &amp; fixed Javadoc problem</vh></v>
<v t="edream.110203163054.515"><vh>Fixed crasher when Tangling</vh></v>
<v t="edream.110203163054.516"><vh>Fixed problems with negative tab widths</vh></v>
<v t="edream.110203163054.517"><vh>Fixed numerous problems related to configuration settings</vh></v>
</v>
<v t="edream.110203163054.518"><vh>leo.py 3.2</vh>
<v t="edream.110203163054.519"><vh>Nested @others directives now valid</vh>
<v t="edream.110203163054.520"><vh>@file test.txt</vh>
<v t="edream.110203163054.521"><vh>class a</vh>
<v t="edream.110203163054.522"><vh>a::one</vh></v>
<v t="edream.110203163054.523"><vh>a:two</vh></v>
</v>
<v t="edream.110203163054.524"><vh>class b</vh>
<v t="edream.110203163054.525"><vh>b::one</vh></v>
<v t="edream.110203163054.526"><vh>b:two</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.527"><vh>Improved Import command</vh></v>
<v t="edream.110203163054.528"><vh>Reassigned shortcuts in the Outline-Move/Select menu</vh></v>
<v t="edream.110203163054.529"><vh>Fixed crasher in the Preferences Panel</vh></v>
<v t="edream.110203163054.530"><vh>Improved syntax coloring of continued C strings</vh></v>
<v t="edream.110203163054.531"><vh>Made many changes to Color Panel</vh></v>
<v t="edream.110203163054.532"><vh>Added email address &amp; URL to About Leo dialog</vh></v>
<v t="edream.110203163054.533"><vh>added disStats.py</vh></v>
</v>
<v t="edream.110203163054.534"><vh>leo.py 3.1</vh>
<v t="edream.110203163054.535"><vh>Added compare panel</vh></v>
<v t="edream.110203163054.536"><vh>Added new settings to leoConfig.txt</vh></v>
<v t="edream.110203163054.537"><vh>Changed precedence scheme for preferences</vh></v>
<v t="edream.110203163054.538"><vh>Fixed @tabwidth, @pagewidth and @language directives</vh></v>
<v t="edream.110203163054.539"><vh>Flatten Outline now escapes only the first non-blank character of each line.</vh></v>
<v t="edream.110203163054.540"><vh>Open Python Window command adds path to IDLE automatically</vh></v>
<v t="edream.110203163054.541"><vh>Python 2.2 required dialog tells where to download Python 2.2 and Tk 8.3</vh></v>
</v>
<v t="edream.110203163054.542"><vh>leo.py 3.0</vh>
<v t="edream.110203163054.543"><vh>Optional new file format</vh></v>
<v t="edream.110203163054.544"><vh>New features (in approximate order of importance)</vh>
<v t="edream.110203163054.545"><vh>Added many settings to leoConfig.txt file</vh>
<v t="edream.110203163054.546"><vh>New windows now open using config params.</vh></v>
</v>
<v t="edream.110203163054.547"><vh>Added autoscrolling in the outline pane</vh></v>
<v t="edream.110203163054.548"><vh>Color panel</vh></v>
<v t="edream.110203163054.549"><vh>Font panel</vh></v>
<v t="edream.110203163054.550"><vh>Leo now opens windows at the position in which they were saved</vh></v>
<v t="edream.110203163054.551"><vh>Added Toggle Split Direction</vh></v>
<v t="edream.110203163054.552"><vh>Improved syntax coloring for @comment directives</vh></v>
<v t="edream.110203163054.553"><vh>Leo warns and aborts if not Python 2.2 or above</vh></v>
<v t="edream.110203163054.554"><vh>All panels now have labeled frames and grooved borders</vh></v>
<v t="edream.110203163054.555"><vh>Leo directives are now colored green by default</vh></v>
<v t="edream.110203163054.556"><vh>Print a traceback message for all serious exceptions</vh></v>
<v t="edream.110203163054.557"><vh>@comment supports comments starting with REM</vh></v>
</v>
<v t="edream.110203163054.558"><vh>Fixed bugs (one crasher)</vh>
<v t="edream.110203163054.559"><vh>Fixed crasher in atFile.scanAllDirectives</vh></v>
<v t="edream.110203163054.560"><vh>Fixed syntax coloring bug involving Leo directives</vh></v>
<v t="edream.110203163054.561"><vh>Windows now open without visual problems</vh></v>
<v t="edream.110203163054.562"><vh>Made Convert Tabs, Convert All Blanks and Convert All Tabs undoable</vh></v>
<v t="edream.110203163054.563"><vh>Made Prefs panel non-modal</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.564"><vh>2.x...</vh>
<v t="edream.110203163054.565"><vh>leo.py 2.5.1 Many improvements</vh>
<v t="edream.110203163054.566"><vh>New &amp; improved commands</vh>
<v t="edream.110203163054.567"><vh>Tabs and spaces</vh>
<v t="edream.110203163054.568"><vh>Added Convert All Blanks and Convert All Tabs commands</vh></v>
<v t="edream.110203163054.569"><vh>Added Convert Tabs command</vh></v>
<v t="edream.110203163054.570"><vh>Tab widths work</vh></v>
<v t="edream.110203163054.571"><vh>Negative tab width converts tabs to spaces</vh></v>
</v>
<v t="edream.110203163054.572"><vh>Improved Preferences panel</vh></v>
<v t="edream.110203163054.320"><vh>Obsolete: Using leoConfig.leo and leoConfig.txt</vh></v>
<v t="edream.110203163054.573"><vh>Cut and Paste now works properly in all situations</vh></v>
<v t="edream.110203163054.574"><vh>Added Recent Files menu</vh></v>
<v t="edream.110203163054.575"><vh>All Extract and Import commands are now undoable</vh></v>
<v t="edream.110203163054.576"><vh>Made Cascade and Minimize All commands functional</vh></v>
</v>
<v t="edream.110203163054.577"><vh>Significant bug fixes</vh>
<v t="edream.110203163054.578"><vh>Fixed several bugs in the Import commands</vh></v>
<v t="edream.110203163054.579"><vh>Invalid directories no longer cause read errors</vh></v>
</v>
<v t="edream.110203163054.580"><vh>Fixed crashers</vh>
<v t="edream.110203163054.581"><vh>Fixed crasher when saving a new file</vh></v>
<v t="edream.110203163054.582"><vh>Fixed crashers in Remove Sentinels command</vh></v>
<v t="edream.110203163054.583"><vh>Fixed crasher in Import commands</vh></v>
</v>
<v t="edream.110203163054.584"><vh>Fixed minor bugs &amp; improvements</vh>
<v t="edream.110203163054.585"><vh>Recolored body text after extract commands</vh></v>
<v t="edream.110203163054.586"><vh>Fixed bug involving missing clone mark after Move Right command</vh></v>
<v t="edream.110203163054.587"><vh>Changed defaultextension from "x" to ".x" in dialogs.</vh></v>
<v t="edream.110203163054.588"><vh>Fixed minor bug in Save and Save As commands</vh></v>
<v t="edream.110203163054.589"><vh>Fixed minor problems with documentation</vh></v>
<v t="edream.110203163054.590"><vh>Renamed Font to Set Font... and Syntax Coloring... to Set Colors...</vh></v>
</v>
</v>
<v t="edream.110203163054.591"><vh>leo.py 2.4</vh>
<v t="edream.110203163054.592"><vh>Fixed several bugs</vh></v>
<v t="edream.110203163054.593"><vh>Added better error recovery when writing .leo files</vh></v>
<v t="edream.110203163054.594"><vh>Dragging headlines</vh></v>
<v t="edream.110203163054.60"><vh>How to associate Leo with .leo files on Windows</vh></v>
</v>
<v t="edream.110203163054.595"><vh>leo.py 2.3</vh></v>
<v t="edream.110203163054.596"><vh>leo.py 2.2 Bug fixes and documentation revised</vh></v>
<v t="edream.110203163054.597"><vh>2.1 Import &amp; Export commands</vh>
<v t="edream.110203163054.598"><vh>Import and Export commands</vh></v>
<v t="edream.110203163054.599"><vh>Fixed moves up to root position</vh></v>
<v t="edream.110203163054.600"><vh>Improved the syntax colorer</vh></v>
</v>
<v t="edream.110203163054.601"><vh>2.0 Untangle, Unlimited Undo/Redo, Syntax Coloring, etc.</vh>
<v t="edream.110203163054.602"><vh>Format change: no blank lines between sentinels in derived files</vh></v>
<v t="edream.110203163054.603"><vh>Unlimited Undo and Redo</vh></v>
<v t="edream.110203163054.604"><vh>Drawing and syntax coloring</vh>
<v t="edream.110203163054.605"><vh>Syntax coloring works for all languages</vh></v>
<v t="edream.110203163054.606"><vh>Fixed minor syntax coloring bugs</vh></v>
<v t="edream.110203163054.607"><vh>Headlines given more space</vh></v>
<v t="edream.110203163054.608"><vh>Suppressed auto-indent for Python in @nocolor mode</vh></v>
</v>
<v t="edream.110203163054.609"><vh>Tangle/Untangle</vh>
<v t="edream.110203163054.610"><vh>Fixed old bugs in Untangle</vh></v>
<v t="edream.110203163054.611"><vh>@c now is the same as @code</vh></v>
<v t="edream.110203163054.612"><vh>Untangle only trims trailing lines from updated nodes</vh></v>
</v>
<v t="edream.110203163054.613"><vh>Fixed Linux-specific bugs</vh></v>
</v>
<v t="edream.110203163054.614"><vh>1.0 New commands and bug fixes</vh>
<v t="edream.110203163054.615"><vh>Unfinished commands</vh></v>
<v t="edream.110203163054.616"><vh>How to copy an outline from Borland Leo to Leo.py</vh></v>
<v t="edream.110203163054.617"><vh>Fixed bugs</vh></v>
<v t="edream.110203163054.618"><vh>Remaining minor problems</vh></v>
</v>
<v t="edream.110203163054.619"><vh>0.08 Find, Change and Tangle commands &amp; major bugs fixed</vh>
<v t="edream.110203163054.620"><vh>About the Find and Change commands</vh></v>
<v t="edream.110203163054.621"><vh>About the Tangle command</vh></v>
<v t="edream.110203163054.622"><vh>About hyperlinking</vh></v>
<v t="edream.110203163054.623"><vh>Fixed significant bugs</vh></v>
<v t="edream.110203163054.624"><vh>Other improvements</vh></v>
<v t="edream.110203163054.625"><vh>Improved memory management</vh></v>
<v t="edream.110203163054.626"><vh>The trace function (Sherlock tracing)</vh></v>
<v t="edream.110203163054.627"><vh>Improved directory and file name handling</vh></v>
<v t="edream.110203163054.628"><vh>Improvements that will be propagated back to LeoCB</vh></v>
</v>
<v t="edream.110203163054.629"><vh>0.07 Stability and scripting</vh>
<v t="edream.110203163054.630"><vh>Thorough testing</vh></v>
<v t="edream.110203163054.631"><vh>Removed many irritations.  Some remain</vh></v>
<v t="edream.110203163054.632"><vh>Fixed bug that can drop data</vh></v>
<v t="edream.110203163054.633"><vh>Added Python window and scripting support</vh></v>
<v t="edream.110203163054.634"><vh>Added Script to convert from Leo 1 to Leo 2</vh></v>
<v t="edream.110203163054.635"><vh>Added Leo Documentation command</vh></v>
<v t="edream.110203163054.636"><vh>Added Auto indent</vh></v>
</v>
<v t="edream.110203163054.637"><vh>0.06 Minor changes for Linux</vh></v>
<v t="edream.110203163054.638"><vh>0.05 The first functional version</vh>
<v t="edream.110203163054.639"><vh>Testing &amp; Performance</vh></v>
<v t="edream.110203163054.640"><vh>Installing and Running leo.py</vh></v>
<v t="edream.110203163054.641"><vh>Files &amp; Folders</vh></v>
<v t="edream.110203163054.642"><vh>Functional Commands and Features</vh></v>
<v t="edream.110203163054.643"><vh>Non-Functional Commands and Features</vh></v>
<v t="edream.110203163054.644"><vh>Bugs, Problems and Code Quality</vh></v>
<v t="edream.110203163054.645"><vh>New Things To Do</vh></v>
</v>
</v>
<v t="edream.110203163054.646"><vh>Borland PC versions...</vh>
<v t="edream.110203163054.647"><vh>Borland 2.7 Major bug fix: please upgrade</vh></v>
<v t="edream.110203163054.648"><vh>Borland 2.6 Major changes: please upgrade</vh>
<v t="edream.110203163054.649"><vh>Format change: no blank lines between sentinels in derived files</vh></v>
<v t="edream.110203163054.650"><vh>Eliminated spurious read errors</vh></v>
<v t="edream.110203163054.651"><vh>@c now is the same as @code</vh></v>
<v t="edream.110203163054.652"><vh>Fixed old bugs in Untangle</vh></v>
<v t="edream.110203163054.653"><vh>Compatibility with leo.py v2.0</vh></v>
<v t="edream.110203163054.654"><vh>Changed "Batch" check box to "Show Context"</vh></v>
<v t="edream.110203163054.655"><vh>Can not ensure .leo extension</vh></v>
</v>
<v t="edream.110203163054.656"><vh>version 2.5: Fixed several serious bugs</vh></v>
<v t="edream.110203163054.657"><vh>version 2.4: The new Leo2 (Do not use this version)</vh>
<v t="edream.110203163054.658"><vh>Fixed clone bugs</vh></v>
<v t="edream.110203163054.659"><vh>.leo files now contain all data</vh></v>
<v t="edream.110203163054.660"><vh>Replaced archive command</vh></v>
<v t="edream.110203163054.661"><vh>Automatic update of @file trees</vh></v>
<v t="edream.110203163054.662"><vh>Errors while reading</vh></v>
<v t="edream.110203163054.663"><vh>Errors while writing</vh></v>
<v t="edream.110203163054.664"><vh>Drawbacks of @file trees</vh></v>
</v>
<v t="edream.110203163054.665"><vh>version 2.3: Do not use this version</vh>
<v t="edream.110203163054.666"><vh>@first directive</vh></v>
<v t="edream.110203163054.667"><vh>Archive Entire Outline command</vh></v>
<v t="edream.110203163054.668"><vh>Fixed @c syntax coloring</vh></v>
<v t="edream.110203163054.669"><vh>Fixed bugs in the find command</vh></v>
<v t="edream.110203163054.670"><vh>Fixed bug involving @file dirty bits</vh></v>
<v t="edream.110203163054.671"><vh>The Log window is now part of the Leo window</vh></v>
</v>
<v t="edream.110203163054.672"><vh>version 2.2 (beta)</vh></v>
<v t="edream.110203163054.673"><vh>version 2.1 (beta)</vh></v>
<v t="edream.110203163054.674"><vh>1.x versions</vh>
<v t="edream.110203163054.675"><vh>Changes made in version 1.15</vh></v>
<v t="edream.110203163054.676"><vh>Changes made in version 1.14</vh></v>
<v t="edream.110203163054.677"><vh>Changes made in version 1.13</vh></v>
<v t="edream.110203163054.678"><vh>Changes made in version 1.12</vh></v>
<v t="edream.110203163054.679"><vh>Changes made in version 1.11</vh>
<v t="edream.110203163054.680"><vh>Multiple parts not allowed for &lt;&lt; section name &gt;&gt;</vh></v>
<v t="edream.110203163054.681"><vh>Untangling: updating an outline</vh></v>
</v>
<v t="edream.110203163054.682"><vh>Changes made in version 1.10</vh></v>
<v t="edream.110203163054.683"><vh>Changes made in version 1.9</vh>
<v t="edream.110203163054.684"><vh>New Execute Script command</vh></v>
<v t="edream.110203163054.685"><vh>Python window improved</vh></v>
</v>
<v t="edream.110203163054.686"><vh>Changes made in version 1.8</vh></v>
<v t="edream.110203163054.687"><vh>Changes made in version 1.7</vh></v>
<v t="edream.110203163054.688"><vh>Changes made in version 1.6</vh></v>
<v t="edream.110203163054.689"><vh>Changes made in version 1.5</vh></v>
<v t="edream.110203163054.690"><vh>Changes made in version 1.4</vh>
<v t="edream.110203163054.691"><vh>Outline To Noweb command</vh></v>
<v t="edream.110203163054.692"><vh>find/change Python scripts</vh></v>
<v t="edream.110203163054.693"><vh>v.commands() Python method</vh></v>
</v>
<v t="edream.110203163054.694"><vh>Changes made in version 1.3</vh></v>
<v t="edream.110203163054.695"><vh>Changes made in version 1.2</vh></v>
<v t="edream.110203163054.696"><vh>Changes made in version 1.1</vh></v>
<v t="edream.110203163054.697"><vh>Changes made in version 1.0</vh></v>
<v t="edream.110203163054.698"><vh>Changes made in version 0.19</vh>
<v t="edream.110203163054.699"><vh>Fixed directory bug</vh></v>
<v t="edream.110203163054.700"><vh>Added @language HTML, perl and perlpod</vh></v>
<v t="edream.110203163054.701"><vh>Eliminated @noweb &amp; replaced @cweb with @language cweb</vh></v>
<v t="edream.110203163054.355"><vh>About cweb mode </vh></v>
<v t="edream.110203163054.702"><vh>Improved syntax coloring</vh></v>
<v t="edream.110203163054.703"><vh>Improved Print command</vh></v>
<v t="edream.110203163054.704"><vh>Improved how Untangle handles block comments</vh></v>
<v t="edream.110203163054.705"><vh>Eliminated clone windows (but not clone nodes!)</vh></v>
<v t="edream.110203163054.706"><vh>Eliminated Extended noweb Syntax</vh></v>
</v>
<v t="edream.110203163054.707"><vh>Changes made in version 0.18</vh>
<v t="edream.110203163054.708"><vh>File format extended</vh></v>
<v t="edream.110203163054.709"><vh>Fixed bug in languages without block comments</vh></v>
<v t="edream.110203163054.710"><vh>Added @header and @noheader directives</vh></v>
<v t="edream.110203163054.711"><vh>Added @language fortran90</vh></v>
<v t="edream.110203163054.712"><vh>Added @language perlpod</vh></v>
</v>
<v t="edream.110203163054.713"><vh>Changes made in version 0.17</vh>
<v t="edream.110203163054.714"><vh>Support for noweb &lt;&lt;*&gt;&gt; convention</vh></v>
<v t="edream.110203163054.715"><vh>new @cweb, @noweb, @path, @tabwidth and @pagewidth directives</vh></v>
<v t="edream.110203163054.716"><vh>CWEB mode now has a chance of working</vh></v>
<v t="edream.110203163054.717"><vh>Reduced default screen size</vh></v>
</v>
<v t="edream.110203163054.718"><vh>Changes made in version 0.16</vh>
<v t="edream.110203163054.719"><vh>Bug fixes</vh></v>
<v t="edream.110203163054.720"><vh>Fixed crasher involving switching windows</vh></v>
<v t="edream.110203163054.721"><vh>new @language directive</vh></v>
<v t="edream.110203163054.722"><vh>@language and @comment directives can be inherited</vh></v>
<v t="edream.110203163054.723"><vh>Untangle can now handle non-C files</vh></v>
<v t="edream.110203163054.724"><vh>Untangle now removes trailing blank lines</vh></v>
<v t="edream.110203163054.725"><vh>new @verbose, @terse and @silent directives</vh></v>
<v t="edream.110203163054.726"><vh>Default directories</vh></v>
<v t="edream.110203163054.727"><vh>Import Files command now handles Pascal , Python and Java files.</vh></v>
<v t="edream.110203163054.728"><vh>Toggle Active Pane command</vh></v>
<v t="edream.110203163054.729"><vh>Path delimiters are now '\' instead of '/'</vh></v>
<v t="edream.110203163054.730"><vh>Cleaned up code</vh></v>
<v t="edream.110203163054.731"><vh>Fixed crasher involving empty section names</vh></v>
<v t="edream.110203163054.732"><vh>Untangle warns about sections not in the outline</vh></v>
<v t="edream.110203163054.733"><vh>A limitations involving Untangle</vh></v>
</v>
<v t="edream.110203163054.734"><vh>Known Bugs &amp; Limitations</vh></v>
</v>
</v>
</v>
<v t="ekr.20050210102358"><vh>4.0... New read logic eliminates read errors, eliminated child indices</vh>
<v t="edream.110203163054.66"><vh>4.0.1 through 4.0.4</vh></v>
<v t="edream.110203163054.67"><vh>4.0 final</vh>
<v t="edream.110203163054.68"><vh>4.0 beta 4</vh></v>
<v t="edream.110203163054.69"><vh>4.0 beta 3</vh>
<v t="edream.110203163054.70"><vh>Fixed bugs</vh>
<v t="edream.110203163054.71"><vh>Fixed bug that caused some clones not to be marked as clones</vh></v>
<v t="edream.110203163054.72"><vh>Corrected problems with setting icons on Linux</vh></v>
<v t="edream.110203163054.73"><vh>Fixed crasher in sentinelName</vh></v>
<v t="edream.110203163054.74"><vh>Reenabled orphans &amp; ignored test in new write logic</vh></v>
</v>
<v t="edream.110203163054.75"><vh>New features</vh>
<v t="edream.110203163054.76"><vh>Added support for unknown tnode and vnode attributes</vh></v>
<v t="edream.110203163054.77"><vh>Added build number to signon</vh></v>
<v t="edream.110203163054.78"><vh>Added better error message in setDefaultIcon</vh></v>
</v>
</v>
<v t="edream.110203163054.79"><vh>4.0 beta 2</vh>
<v t="edream.110203163054.80"><vh>To-do for 4.0 final</vh></v>
<v t="edream.110203163054.81"><vh>Fixed Bugs</vh>
<v t="edream.110203163054.82"><vh>Added crucial defensive checks in v.headString() and v.bodySting()</vh></v>
<v t="edream.110203163054.83"><vh>Ensured newlines before all sentinels in @rawfile</vh></v>
<v t="edream.110203163054.84"><vh>Fixed bugs involving find params</vh></v>
<v t="edream.110203163054.85"><vh>Fixed Python Import bug</vh></v>
<v t="edream.110203163054.86"><vh>Fixed several more unicode bugs</vh></v>
<v t="edream.110203163054.87"><vh>Fixed crasher in Go To Outline command.</vh></v>
<v t="edream.110203163054.88"><vh>Fixed @rawfile write problem</vh></v>
</v>
<v t="edream.110203163054.89"><vh>Improved commands</vh>
<v t="edream.110203163054.90"><vh>Finished Import Derived File command and made it undoable</vh></v>
<v t="edream.110203163054.91"><vh>Moved Clear Recent Files menu item into Recent Files menu</vh></v>
<v t="edream.110203163054.92"><vh>Added better log message for Convert All Tabs/Blanks commands</vh></v>
<v t="edream.110203163054.93"><vh>Marked changed nodes &amp; make the @file node and the outline dirty.</vh></v>
<v t="edream.110203163054.94"><vh>Rewrote icon code so it doesn't use PIL or tkIcon in Python 2.3</vh></v>
<v t="edream.110203163054.95"><vh>Created leoGui base class for tkinterGui class</vh></v>
</v>
<v t="edream.110203163054.96"><vh>New and improved settings</vh>
<v t="edream.110203163054.97"><vh>Added support for two new settings affecting drags</vh></v>
<v t="edream.110203163054.98"><vh>changed default for config.write_old_format_derived_files</vh></v>
</v>
</v>
<v t="edream.110203163054.99"><vh>4.0 beta 1</vh>
<v t="edream.110203163054.100"><vh>4.0 Theory of operation</vh></v>
<v t="edream.110203163054.101"><vh>New commands &amp; options</vh>
<v t="edream.110203163054.102"><vh>New write_old_format_derived_files option</vh></v>
<v t="edream.110203163054.103"><vh>New Clear Recent Files command</vh></v>
<v t="edream.110203163054.104"><vh>New Import Derived File command</vh></v>
<v t="edream.110203163054.105"><vh>New Write 3.x/4.x Derived Files &amp; autosave</vh></v>
</v>
<v t="edream.110203163054.106"><vh>New plugins</vh></v>
<v t="edream.110203163054.107"><vh>New read logic and greatly inproved error recovery</vh>
<v t="edream.110203163054.108"><vh>Added test for unvisited nodes in read logic</vh></v>
<v t="edream.110203163054.109"><vh>Error recovery is _much_ better than before</vh></v>
</v>
<v t="edream.110203163054.110"><vh>Improvements &amp; bug fixes</vh>
<v t="edream.110203163054.111"><vh>Added horizontal scrollbar in body pane when @nowrap in effect</vh></v>
<v t="edream.110203163054.112"><vh>Added support for Python 2.3</vh></v>
<v t="edream.110203163054.113"><vh>Leo recycles window objects only if more than one window open</vh></v>
<v t="edream.110203163054.114"><vh>Removed "not undoable" message from Read @file Nodes command</vh></v>
<v t="edream.110203163054.115"><vh>Removed Open Python Window command</vh></v>
<v t="edream.110203163054.116"><vh>Simplified read and write code</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050210102150.1"><vh>4.1... gnx's</vh>
<v t="ekr.20040216151748"><vh>4.1 final</vh>
<v t="ekr.20040217085036"><vh>Added several new plugins</vh></v>
<v t="ekr.20040216152948"><vh>Added Toggle Angle Brackets command</vh></v>
<v t="ekr.20040216153725"><vh>Changed Undo/Redo messages</vh></v>
<v t="ekr.20040217075627"><vh>Fixed clone bug when pasting nodes</vh></v>
<v t="ekr.20040217085036.1"><vh>Investigated encoding problem: it's a Python 2.3 bug</vh></v>
</v>
<v t="ekr.20040131040356"><vh>4.1 rc4</vh>
<v t="ekr.20040201114855"><vh>New plugins in 4.1 rc4</vh>
<v t="ekr.20040201114855.42"><vh>mod_http.py plugin: Bernhard Mulder</vh></v>
<v t="ekr.20040201114855.91"><vh>newButtons.py plugin: Paul Paterson</vh></v>
<v t="ekr.20040201114855.29"><vh>nodenavigator.py plugin: Paul Paterson</vh></v>
<v t="ekr.20040201114855.36"><vh>rowcol.py: EKR</vh></v>
<v t="ekr.20040201114855.3"><vh>rst2.py plugin: Steve Zatz</vh></v>
<v t="ekr.20040201114855.13"><vh>searchbox.py plugin: Paul Paterson</vh></v>
<v t="ekr.20040201120903"><vh>status_line.py plugin: EKR</vh></v>
</v>
<v t="ekr.20040131041015"><vh>New features in 4.1 rc4</vh>
<v t="ekr.20040131040544.10"><vh>Leo no longer automatically draws the status area</vh></v>
<v t="ekr.20040131040544.21"><vh>Esc and enter key now work in the find panel</vh></v>
<v t="ekr.20040131040544.55"><vh>Improved message for orphan nodes</vh></v>
<v t="ekr.20040131040544.178"><vh>Eliminated marking nodes dirty unnecessarily</vh></v>
<v t="ekr.20040131040544.222"><vh>Execute Script command now ends all nodes with a newline</vh></v>
<v t="ekr.20040131040544.2"><vh>Added message when plugins are disabled</vh></v>
<v t="ekr.20040201061329"><vh>Created status_line.py plugin</vh></v>
<v t="ekr.20040201114855.105"><vh>Simplified operation of script-find/change &amp; improved documentation</vh>
<v t="edream.110603190322.6"><vh> Script Find and Script Change</vh>
<v t="edream.111803060152.1"><vh>How it works</vh></v>
<v t="ekr.20040201113232"><vh>Using the initScriptFind script</vh></v>
<v t="edream.111803060152.2"><vh>Ideas for using scripts</vh></v>
</v>
</v>
<v t="ekr.20040201114855.106"><vh>Added done message to Mark Changed commands</vh></v>
</v>
<v t="ekr.20040131040356.1"><vh>Bugs fixed in 4.1 rc4</vh>
<v t="ekr.20040131044727"><vh>Fixed several bugs when writing derived files</vh></v>
<v t="ekr.20040131040754"><vh>Fixed several crashers</vh></v>
<v t="ekr.20040131040544.5"><vh>Fixed "bad leo file" when reading some 3.x .leo files</vh></v>
<v t="ekr.20040131040544.18"><vh>Fixed huge performance bug in cut/copy node commands</vh></v>
<v t="ekr.20040131040544.32"><vh>Leo now properly re-enables drawing after exceptions</vh></v>
<v t="ekr.20040201114855.107"><vh>Fixed major bug in tkFind.init</vh></v>
<v t="ekr.20040131040544.73"><vh>Fixed bug in Move Up command</vh></v>
<v t="ekr.20040131040544.81"><vh>Fixed bug in Import Derived File</vh></v>
<v t="ekr.20040131040544.146"><vh>Fixed bugs related to saving read-only files</vh></v>
<v t="ekr.20040131040544.169"><vh>Fixed bug in Import Python Window command when using Python 2.2</vh></v>
<v t="ekr.20040131040544.228"><vh>Fixed bugs in Convert All BlanksTabs commands</vh></v>
<v t="ekr.20040131040544.258"><vh>Fixed crashes in open_shell.py plugin</vh></v>
<v t="ekr.20040131044136"><vh>Fixed several bugs involving cut &amp; paste</vh></v>
<v t="ekr.20040131040544.227"><vh>Fixed whitespace problem in leoTkinterGui.py</vh></v>
<v t="ekr.20040131100557"><vh>Fixed glitches when inserting node in hoisted outline</vh></v>
<v t="ekr.20040203084228"><vh>Fixed bugs in search command</vh></v>
</v>
<v t="ekr.20040131040356.2"><vh>Bug fixed in previous 4.1 releases</vh></v>
<v t="ekr.20040131040356.3"><vh>New code-level features</vh></v>
<v t="ekr.20040131040356.4"><vh>New configuration settings</vh></v>
<v t="ekr.20040131040356.5"><vh>New features</vh></v>
</v>
<v t="edream.121403160546"><vh>4.1 rc3</vh>
<v t="edream.121403165221"><vh>Bugs fixed in this release</vh></v>
<v t="edream.121403161017"><vh>Bug fixed in previous 4.1 releases</vh></v>
<v t="edream.121403161017.1"><vh>New code-level features</vh></v>
<v t="edream.121403161017.2"><vh>New configuration settings</vh></v>
<v t="edream.121403161340"><vh>New features</vh></v>
</v>
<v t="edream.110603185805"><vh>4.1 beta 5</vh>
<v t="edream.120403174147"><vh>Changes made in 4.1 beta 5</vh>
<v t="edream.120403180443"><vh>New and improved features</vh>
<v t="edream.120403174147.105"><vh>Honor outline/body pane ratio when opening files</vh></v>
<v t="edream.120403174147.112"><vh>Leo now adjusts newly opened windows so they fit on the screen</vh></v>
<v t="edream.120403174147.119"><vh>Tested support for Unicode file &amp; directory names</vh></v>
<v t="edream.120403174147.128"><vh>Added code so @url nodes may open .leo files</vh></v>
<v t="edream.120403174147.56"><vh>Fixed problems with @lineending platform</vh></v>
</v>
<v t="edream.120403174241"><vh>Bugs fixed</vh>
<v t="edream.120403174147.30"><vh>Fixed crasher in Apply Settings command</vh></v>
<v t="edream.120403174147.102"><vh>Fixed crasher in Toggle Angle Brackets command</vh></v>
<v t="edream.120403174147.109"><vh>Fixed crasher when setting Icon in Linux)</vh></v>
<v t="edream.120403174147.33"><vh>Fixed Find panel bug on the Mac</vh></v>
<v t="edream.120403174147.36"><vh>Fixed Import backslash-newline bug</vh></v>
<v t="edream.120403174147.61"><vh>Fixed Linux import problem</vh></v>
<v t="edream.120403174147.63"><vh>Fixed Recent files crasher</vh></v>
<v t="edream.120403174147.65"><vh>Fixed Replace Blanks command</vh></v>
<v t="edream.110603190322.8"><vh>Fixed Serious Undo Change All bugs</vh></v>
<v t="edream.120403174147.94"><vh>Fixed several long-standing bugs related to Extract commands</vh></v>
</v>
</v>
<v t="edream.120403180443.1"><vh>Changes made in earlier 4.1 betas</vh>
<v t="edream.110603190234.1"><vh>Code-level features</vh>
<v t="edream.110603190125.3"><vh>Regression tests started</vh></v>
<v t="edream.110603190125.4"><vh>Code reorganized to support other guis</vh></v>
<v t="edream.110303182253.39"><vh>Made app.forceShutdown work in "idle" hook</vh></v>
</v>
<v t="edream.110603190404"><vh>Fixed bugs</vh>
<v t="edream.110603190322.13"><vh>Fixed bug involving 0x1a characters in body text.</vh></v>
<v t="edream.110603190322.11"><vh>Fixed first node-only find bug</vh></v>
<v t="edream.110603190322.3"><vh>Fixed bug in idle_body_key</vh></v>
<v t="edream.111803060643"><vh>Fixed LaTeX syntax coloring bug</vh></v>
</v>
<v t="edream.110603192009"><vh>Improved format of .leo files</vh>
<v t="edream.110603190322.9"><vh>Leo now ignores unknown prefs and find prefs</vh></v>
<v t="edream.110603190322.10"><vh>Leo now writes node_only find prefs</vh></v>
<v t="edream.110603190125.1"><vh>.leo files are now cvs-friendly</vh></v>
</v>
<v t="edream.110603192009.1"><vh>New &amp; improved commands</vh>
<v t="edream.112303173638"><vh>Running Leo in batch mode</vh></v>
<v t="edream.110203163054.833"><vh>Executing Python scripts in body text</vh></v>
<v t="edream.110603190322.14"><vh>Added Check Outline command</vh></v>
<v t="edream.110603190322.15"><vh>Added Hoist/De-Hoist commands</vh></v>
<v t="edream.111803060152"><vh>Added script-based find/change commands</vh>
<v t="edream.110603190322.6"><vh> Script Find and Script Change</vh>
<v t="edream.111803060152.1"><vh>How it works</vh></v>
<v t="ekr.20040201113232"><vh>Using the initScriptFind script</vh></v>
<v t="edream.111803060152.2"><vh>Ideas for using scripts</vh></v>
</v>
</v>
<v t="edream.110303182253.3"><vh>Leo now does an auto-save only if files have actually been changed.</vh></v>
<v t="edream.111803062437"><vh>Shift commands now shift single line if no selection</vh></v>
</v>
<v t="edream.110303182719"><vh>New config settings</vh></v>
</v>
</v>
<v t="edream.110203163054.64"><vh>4.1 alpha 1</vh></v>
</v>
<v t="ekr.20050210102150"><vh>4.2... @file-thin, shared tnodes</vh>
<v t="ekr.20040922074200"><vh>4.2 final</vh></v>
<v t="ekr.20040914103359"><vh>4.2 rc1</vh>
<v t="ekr.20040914103743.1"><vh>Added new features</vh>
<v t="ekr.20040914103359.137"><vh>Added c.frame.openDirectory to sys.path when executing scripts</vh></v>
<v t="ekr.20040914103359.37"><vh>Added expanded_click_area option to disable left click logic in outline pane</vh></v>
<v t="ekr.20040914103359.2"><vh>Restored the "iconclick1/2" hooks</vh></v>
<v t="ekr.20040914103359.19"><vh>(Allow longer headlines for to support long url's)</vh>
<v t="ekr.20040914103359.20"><vh>Report</vh></v>
<v t="ekr.20040914103359.21"><vh>idle_head_key</vh>
<v t="ekr.20040914103359.22"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="ekr.20040914103359.23"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20040914103359.24"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20040914103359.25"><vh>&lt;&lt; update p &gt;&gt;</vh></v>
<v t="ekr.20040914103359.26"><vh>&lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;</vh></v>
<v t="ekr.20040914103359.27"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040914103743"><vh>Fixed bugs</vh>
<v t="ekr.20040914103359.47"><vh>Disabled perfect import</vh></v>
<v t="ekr.20040914103359.127"><vh>Fixed bugs in Tangle/Untangle</vh></v>
<v t="ekr.20040914103359.12"><vh>Fixed Import Derived Files command</vh></v>
<v t="ekr.20040914103359.15"><vh>Fixed parsing of minimal &lt;preferences&gt; tag</vh></v>
<v t="ekr.20040914103359.7"><vh>Fixed problem with tabs on MacOs</vh></v>
<v t="ekr.20040914103359.28"><vh>Fixed read errors with @language html</vh></v>
<v t="ekr.20040914103359.4"><vh>Made sure a proper message is given with invalid versions of Python</vh></v>
<v t="ekr.20040914103359.110"><vh>Removed failed assert from colorizer</vh></v>
<v t="ekr.20040914103359.31"><vh>Removed spurious "Warning: updating changed text" messages</vh></v>
<v t="ekr.20040914103359.129"><vh>Shifted all Alt-shortcuts to Ctrl shortcuts on the Mac</vh></v>
</v>
</v>
<v t="ekr.20040713110718"><vh>4.2 beta 3</vh>
<v t="ekr.20040804165258.1"><vh>Bug fixes</vh>
<v t="ekr.20040804164600.16"><vh>Leo gives the user a chance to save read-only files</vh></v>
<v t="ekr.20040804164600.36"><vh>Fixed some unit-test bugs</vh></v>
<v t="ekr.20040804164600.56"><vh>Added 3 .cascading style sheets to the distribution list</vh></v>
<v t="ekr.20040804164600.98"><vh>Fixed some bugs in g.importFromPath</vh></v>
<v t="ekr.20040804164600.102"><vh>Fixed major bug in write logic</vh></v>
<v t="ekr.20040804164600.265"><vh>Fixed bug in p.isAncestorOf</vh></v>
<v t="ekr.20040804164600.275"><vh>Leo now writes only the currently selected tree when pasting to the clipboard</vh></v>
<v t="ekr.20040804164600.377"><vh>Fixed performance bug when reading .leo files</vh></v>
<v t="ekr.20040804170846"><vh>Leo now reports problems with bad directories more clearly</vh></v>
<v t="ekr.20040804164600.394"><vh>Leo reads collapsed xml tags properly in .leo files</vh></v>
<v t="ekr.20040804164600.406"><vh>Leo makes brings the confirm save box to the front</vh></v>
<v t="ekr.20040804164600.419"><vh>Improved how es_exception gets line number of errors</vh></v>
<v t="ekr.20040804164600.421"><vh>Fixed major bug: changing headline now marks subnodes dirty</vh></v>
<v t="ekr.20040804164600.470"><vh>Leo now gives update warning only once per derived file</vh></v>
<v t="ekr.20040804164600.471"><vh>Leo updates tnodeLists properly in all situations</vh></v>
<v t="ekr.20040804164600.515"><vh>Fixed several leaks of positions</vh></v>
<v t="ekr.20040804171818"><vh>Fixed all unit tests so they work with both Python 2.2 and Python 2.3</vh></v>
</v>
<v t="ekr.20040804165258.2"><vh>Features</vh>
<v t="ekr.20040804172113"><vh>@test and @suite greatly aid unit testing</vh></v>
<v t="ekr.20040804172113.1"><vh>New scripts in test.leo make it very easy to use the gc, profile and timeit modules</vh></v>
<v t="ekr.20040804165258.3"><vh>Import dialogs allow multiple selections</vh></v>
<v t="ekr.20040804165258.4"><vh>New Check menu and commands</vh></v>
<v t="ekr.20040804170531"><vh>Perfect Import feature automatically corrects imported files</vh></v>
<v t="ekr.20040804170657"><vh>Improved performance of outline pane</vh></v>
<v t="ekr.20040804164600.424"><vh>The Go To Line Number command ignores all @all nodes</vh></v>
</v>
</v>
<v t="EKR.20040628095213"><vh>4.2 beta 1 &amp; beta 2</vh>
<v t="EKR.20040628095213.311"><vh>New coding conventions</vh></v>
<v t="EKR.20040524104904.242"><vh>Extending the format of .leo files</vh></v>
<v t="ekr.20040705111716"><vh>in 4.2 b2</vh>
<v t="ekr.20040705111716.1"><vh>Savedmarks and expantion state in &lt;v&gt; elements for @thin nodes</vh></v>
<v t="ekr.20040705111716.45"><vh>Marked all related @thin nodes dirty when a node changesd</vh></v>
<v t="ekr.20040705111716.126"><vh>Fixed bug when reading  4.1 files with topology errors</vh></v>
<v t="ekr.20040705150130"><vh>Leo passes all important pychecker tests</vh></v>
</v>
<v t="ekr.20040705112148"><vh>in 4.2 b1</vh>
<v t="EKR.20040628095213.513"><vh>Changed *nix install script</vh></v>
<v t="EKR.20040628100535"><vh>Fixed bugs</vh>
<v t="EKR.20040628095213.3"><vh>Made "end1" and "ilde"events work again</vh></v>
<v t="EKR.20040628095213.23"><vh>Put drawing hooks back in</vh></v>
<v t="EKR.20040628095213.56"><vh>Fixed syntax colouring Bug in html mode</vh></v>
<v t="EKR.20040628095213.60"><vh>Colorizing fixes</vh></v>
<v t="EKR.20040628095213.113"><vh>Fixed Select All bug</vh></v>
<v t="EKR.20040628095213.121"><vh>Fixed bugs in @tab_width: support backspace with negative tab width</vh></v>
<v t="EKR.20040628095213.143"><vh>Fixed bugs in Remove Sentinel command</vh></v>
<v t="EKR.20040628095213.160"><vh>Eliminated spurious error messages in Import Derived File command</vh></v>
<v t="EKR.20040628095213.192"><vh>Removed gnx in headlines when importing thin derived files</vh></v>
<v t="EKR.20040628095213.202"><vh>Fixed bugs reading 4.1 files</vh></v>
<v t="EKR.20040628095213.213"><vh>Fixed Open With bug</vh></v>
<v t="EKR.20040628095213.225"><vh>Fixed Go To Line Number command</vh></v>
<v t="EKR.20040628095213.246"><vh>Fixed crash when importing Borland wstring.cpp</vh></v>
<v t="EKR.20040628095213.279"><vh>Fixed bug in insertBodyTime</vh></v>
<v t="EKR.20040628095213.297"><vh>Fixed bug when pasting large text into headlines</vh></v>
<v t="EKR.20040628095213.308"><vh>Fixed bug in delete command</vh></v>
<v t="EKR.20040628095213.312"><vh>Fixed oops: nullGui setIdleTimeHook</vh></v>
<v t="EKR.20040628095213.324"><vh>Fixed problems with trailing newlines and spurious changed bit</vh></v>
<v t="EKR.20040628095213.346"><vh>Fixed headline key handling</vh></v>
<v t="EKR.20040628095213.348"><vh>Fixed Problems executing script</vh></v>
<v t="EKR.20040628095213.354"><vh>Fixed problem with PHP and @last</vh></v>
<v t="EKR.20040628095213.366"><vh>Fixed bug when writing unknownAttributes</vh></v>
<v t="EKR.20040628095213.368"><vh>Fixed bugs opening a second file</vh></v>
<v t="EKR.20040628095213.404"><vh>Fixed bug: @last silently failed when extra lines exist</vh></v>
<v t="EKR.20040628095213.407"><vh>Fixed hang when dragging from one clone copy to another</vh></v>
<v t="EKR.20040628095213.412"><vh>Fixed crash in Write Missing</vh></v>
<v t="EKR.20040628095213.442"><vh>Fixed bug in getScript</vh></v>
<v t="EKR.20040628095213.444"><vh>Fixed problems with @all</vh></v>
<v t="EKR.20040628095213.499"><vh>Fixed double print in Execute Script command</vh></v>
<v t="EKR.20040628095213.512"><vh>Fixed bug reading leo.nsi</vh></v>
</v>
<v t="EKR.20040628100535.1"><vh>Added new features</vh>
<v t="EKR.20040628095213.52"><vh>Allowed &lt;/leo_header&gt; tag</vh></v>
<v t="EKR.20040628095213.109"><vh>Replaced the word "Leo" with Leo icon in Find/Compare/Prefs windows</vh></v>
<v t="EKR.20040628095213.110"><vh>Improved Import command slightly</vh></v>
<v t="EKR.20040628095213.197"><vh>Added 3 files to distribution lists</vh></v>
<v t="EKR.20040628095213.198"><vh>Supported @tabwidth in indent/dedent</vh></v>
<v t="EKR.20040628095213.264"><vh>Import now creates absolute path</vh></v>
<v t="EKR.20040628095213.269"><vh>Created @killcolor directive</vh></v>
<v t="EKR.20040628095213.282"><vh>Added Paste Retaining Clones command</vh></v>
<v t="EKR.20040628095213.314"><vh>Added readLineGenerator &amp; readLineClass to leoGlobals</vh></v>
<v t="EKR.20040628095213.334"><vh>Much better error handling in executeScript</vh></v>
<v t="EKR.20040628095213.377"><vh>Recovered nodes when reading .leo files containing topology errors</vh></v>
<v t="EKR.20040628095213.391"><vh>Generalized write-to-string logic</vh></v>
<v t="EKR.20040628095213.408"><vh>Added case_sensitiveLanguage to colorizer</vh></v>
<v t="EKR.20040628095213.425"><vh>Write entire @thin tree on write errors</vh></v>
<v t="EKR.20040628095213.485"><vh>Handled inner @language and @comment properly</vh></v>
<v t="EKR.20040628095213.490"><vh>Better reporting of body text conflicts</vh></v>
<v t="EKR.20040628095213.493"><vh>Improved error handling for unknownAttributes</vh></v>
<v t="EKR.20040628095213.501"><vh>Read and write all t.unknownAttributes in top vnode of an @thin tree</vh></v>
</v>
</v>
</v>
<v t="EKR.20040601084317"><vh>4.2 a3</vh>
<v t="EKR.20040601084317.2"><vh>Bug fixes</vh>
<v t="EKR.20040601101118"><vh>Fixed copy/paste operations involving @thin trees</vh></v>
<v t="EKR.20040601101430"><vh>Fixed Change Headline command</vh></v>
<v t="EKR.20040601084317.99"><vh>Eliminated spurious "Not written x.tmp" message after write errors</vh></v>
<v t="EKR.20040601084317.142"><vh>Fixed problems saving unknownAttribute field</vh></v>
<v t="EKR.20040601102115"><vh>Fixed unicode problem in the Dump Outline command</vh></v>
</v>
<v t="EKR.20040601101227"><vh>New Features</vh>
<v t="EKR.20040601101227.1"><vh>Leo ignores all directives in @all trees</vh></v>
<v t="EKR.20040601101430.1"><vh>@+-middle sentinels allow sections to be defined in grandchildren</vh></v>
<v t="EKR.20040601101510"><vh>@clone sentinel allows siblings to be cloned</vh></v>
<v t="EKR.20040601101547"><vh>Created @thin, @nosent, @noref and @asis abbreviations</vh>
<v t="EKR.20040524104904.92"><vh>Appendix 1 to Chapter 4: Using @asis, @noref and @nosent trees</vh></v>
</v>
<v t="EKR.20040601084317.102"><vh>Made undo extensible</vh></v>
<v t="EKR.20040601102703"><vh>Started work on simple new undo scheme</vh></v>
<v t="EKR.20040601084317.161"><vh>Created new c, p, v iterators</vh></v>
</v>
<v t="EKR.20040601102808"><vh>Known bugs</vh></v>
</v>
<v t="EKR.20040518070558"><vh>4.2 a2</vh>
<v t="EKR.20040518070940.5"><vh>Implemented @file-thin</vh></v>
<v t="EKR.20040518070824"><vh>Fixed bugs</vh>
<v t="EKR.20040518071415"><vh>Fixed clone bug that caused parts of outlines to disappear</vh></v>
<v t="EKR.20040518070940.156"><vh>Fixed long-standing problem with the outline-only command</vh></v>
<v t="EKR.20040518070824.1"><vh>Made sure file indices are always assigned when writing files.</vh></v>
<v t="EKR.20040518070940"><vh>Fixed problems with missing tnodeList with @file-noref</vh></v>
<v t="EKR.20040518070940.164"><vh>Added t.writeBit</vh></v>
</v>
<v t="EKR.20040518075457"><vh>Dangers of @file-thin</vh></v>
</v>
</v>
<v t="ekr.20060206111600"><vh>4.3...@settings</vh>
<v t="ekr.20050917092557"><vh>4.3.3 final</vh>
<v t="ekr.20050917105646"><vh>Fixes made in 4.3.3</vh></v>
<v t="ekr.20050917092557.1"><vh>Rewrote documentation</vh></v>
<v t="ekr.20050917092557.2"><vh>Bug fixes...</vh>
<v t="ekr.20050917092557.3"><vh>Fixed various unicode bugs</vh></v>
<v t="ekr.20050917092557.4"><vh>Fixed bugs relating to recent files</vh></v>
<v t="ekr.20050917092557.5"><vh>Fixed minor crasher in colorizer</vh></v>
<v t="ekr.20050917092557.6"><vh>Protected several methods used by plugin manager</vh></v>
<v t="ekr.20050917092557.7"><vh>Added test files to distribution list and cvs</vh></v>
</v>
<v t="ekr.20050917092557.8"><vh>New and improved  plugins</vh>
<v t="ekr.20050917092557.9"><vh>New rst3 plugin</vh></v>
<v t="ekr.20050917092557.10"><vh>Improved spellpyx plugin</vh></v>
<v t="ekr.20050917092557.11"><vh>Improved vim and openWith plugins</vh></v>
</v>
<v t="ekr.20050917092557.12"><vh>New &amp; improved features...</vh>
<v t="ekr.20050917092557.13"><vh>Added g.es_print, g.es_trace function</vh></v>
<v t="ekr.20050917092557.14"><vh>Improved PrettyPrinting</vh></v>
</v>
</v>
<v t="ekr.20050913131848"><vh>4.3.2 final</vh>
<v t="ekr.20050906104918.1"><vh>Rewrote documentation</vh></v>
<v t="ekr.20050906104931.1"><vh>Bug fixes...</vh>
<v t="ekr.20050909082711"><vh>Fixed various unicode bugs</vh></v>
<v t="ekr.20050906104931.15"><vh>Fixed bugs relating to recent files</vh></v>
<v t="ekr.20050906104931.38"><vh>Fixed minor crasher in colorizer</vh></v>
<v t="ekr.20050906104931.42"><vh>Protected several methods used by plugin manager</vh></v>
<v t="ekr.20050906104931.43"><vh>Added test files to distribution list and cvs</vh></v>
</v>
<v t="ekr.20050908164150"><vh>New and improved  plugins</vh>
<v t="ekr.20050908164150.1"><vh>New rst3 plugin</vh></v>
<v t="ekr.20050908164150.2"><vh>Improved spellpyx plugin</vh></v>
<v t="ekr.20050910143326"><vh>Improved vim and openWith plugins</vh></v>
</v>
<v t="ekr.20050906104931.48"><vh>New &amp; improved features...</vh>
<v t="ekr.20050906104931.49"><vh>Added g.es_print, g.es_trace function</vh></v>
<v t="ekr.20050906104931.56"><vh>Improved PrettyPrinting</vh></v>
</v>
</v>
<v t="ekr.20050906104918"><vh>4.3.2 beta 1</vh></v>
<v t="ekr.20050620144052"><vh>4.3.1</vh>
<v t="ekr.20050620144052.2"><vh>Bug fixes...</vh>
<v t="ekr.20050620144052.3"><vh>Fixed bug in @ratio setting</vh></v>
<v t="ekr.20050620144052.6"><vh>Fixed crasher footprint plugin</vh></v>
<v t="ekr.20050620144052.8"><vh>Fixed invalid position bug)</vh></v>
<v t="ekr.20050620144052.48"><vh>Fixed undo problems in unit tests</vh></v>
<v t="ekr.20050620144052.112"><vh>Made sure same case is used in all recent files entries</vh></v>
<v t="ekr.20050620144052.114"><vh>Made sure all dialogs gets focus when they are run</vh></v>
<v t="ekr.20050620144052.116"><vh>Improved Resize To Screen command</vh></v>
<v t="ekr.20050620144052.119"><vh>Made sure comments are always visible in setting dialog even for non-@ nodes</vh></v>
<v t="ekr.20050620144052.154"><vh>Fixed problem with leading @ in body text</vh></v>
<v t="ekr.20050620144052.166"><vh>Fixed several  crashers while undoing a move involving clones</vh></v>
<v t="ekr.20050620144052.182"><vh>Fixed Unicode encoding problem</vh></v>
<v t="ekr.20050620144052.185"><vh>Fixed problem with coloring @language plain</vh></v>
<v t="ekr.20050620144602"><vh>Fixed bug: Mark Clones command did not work</vh></v>
</v>
<v t="ekr.20050620144052.207"><vh>New features...</vh>
<v t="ekr.20050620144052.208"><vh>Created separate helpers for idle_body_key</vh></v>
<v t="ekr.20050620144052.210"><vh>Made all Mark commands undoable</vh></v>
<v t="ekr.20050620144052.222"><vh>Removed dependence on profile and pstats modules from leoTest.py</vh></v>
<v t="ekr.20050620144052.231"><vh>Added support for tk resource files</vh></v>
<v t="ekr.20050620144425"><vh>Added support for coloring the PL/SQL language</vh></v>
</v>
</v>
<v t="ekr.20050523092026"><vh>4.3-final</vh>
<v t="ekr.20050523092056.1"><vh>Fixed crasher when pie-menu plugin enabled</vh></v>
<v t="ekr.20050523092056.4"><vh>Fixed crasher in Extract Section Command</vh></v>
</v>
<v t="ekr.20050513141852"><vh>4.3-beta 2</vh>
<v t="ekr.20050513141913.1"><vh>Fixed bugs...</vh>
<v t="ekr.20050513141913.16"><vh>Fixed nodenavagator bug</vh></v>
<v t="ekr.20050513141913.17"><vh>Fixed LaTex Coloring bug</vh></v>
<v t="ekr.20050513141913.22"><vh>Error messages in scripts are now redirected properly.</vh></v>
<v t="ekr.20050513141913.30"><vh>Fixed 2 crashers in nav_buttons plugin</vh></v>
<v t="ekr.20050513141913.57"><vh>Fixed crasher in yoffsetTree</vh></v>
<v t="ekr.20050513141913.60"><vh>Fixed crasher in undo</vh></v>
<v t="ekr.20050513141913.82"><vh>Fixed  several problems with Extract and Extract Section</vh></v>
<v t="ekr.20050513141913.91"><vh>Fixed bug with Delete in headlines</vh></v>
<v t="ekr.20050513141913.127"><vh>Fixed bugs re initial_splitter_orientation &amp; @strings &amp; @ints generally</vh></v>
<v t="ekr.20050513141913.140"><vh>Fixed bug with hoist + insert</vh></v>
<v t="ekr.20050513141913.145"><vh>Fixed problem with settings dialog position when panes split horizontally</vh></v>
<v t="ekr.20050513141913.149"><vh>Fixed problem changing shortcut &amp; redid shortcuts widget</vh></v>
</v>
<v t="ekr.20050513141913.187"><vh>New Features...</vh>
<v t="ekr.20050513141913.97"><vh>Marking any node sets the outline changed</vh></v>
<v t="ekr.20050513141913.188"><vh>Allow quoted urls in  @urls nodes</vh></v>
<v t="ekr.20050513141913.194"><vh>Moved executeFile into core</vh></v>
<v t="ekr.20050513141913.197"><vh>Rewrote g.getScript using at.writeFromString</vh></v>
<v t="ekr.20050513141913.233"><vh>Added define_name arg to c.executeScript</vh></v>
</v>
</v>
<v t="ekr.20050429094215"><vh>4.3-beta 1</vh>
<v t="ekr.20050429094215.2"><vh>Fixed bugs...</vh>
<v t="ekr.20050429094215.3"><vh>Made sure NameErrors are reported with tracebacks in scripts</vh></v>
<v t="ekr.20050429094215.22"><vh>Finally! fixed .leoID problem!</vh></v>
<v t="ekr.20050429094215.31"><vh>Investigated problem with LeoPluginsRef.leo</vh></v>
<v t="ekr.20050429094215.41"><vh>Fixed conflicts in menu shortcuts</vh></v>
<v t="ekr.20050429094215.113"><vh>Fixed bug in p.initStatus caught by pychecker</vh></v>
<v t="ekr.20050429094215.116"><vh>Fixed crasher in import logic (leoAtFile)</vh></v>
<v t="ekr.20050429094215.120"><vh>Put in protections against unbounded recursion in idle_scrollTo</vh></v>
</v>
<v t="ekr.20050429094215.130"><vh>New features...</vh>
<v t="ekr.20050429094215.131"><vh>Created stand-alone leoGlobals.py module</vh></v>
<v t="ekr.20050429094215.139"><vh>Leo now ignores problems opening settings file for chapters plugin</vh></v>
<v t="ekr.20050429094215.145"><vh>Improved write logic</vh></v>
<v t="ekr.20050429094215.173"><vh>Rewrote the undo code</vh></v>
<v t="ekr.20050429094215.286"><vh>Implemented undo/redo for Paste Retaining clones</vh></v>
<v t="ekr.20050429094215.316"><vh>Added support for 'str_' uA's</vh></v>
<v t="ekr.20050429094215.347"><vh>Removed unused params from leoAtFile.py</vh></v>
<v t="ekr.20050429094215.353"><vh>Leo  saves recent files info in .leoRecentFiles.txt files</vh>
<v t="ekr.20050429094215.354"><vh>What I did</vh></v>
<v t="ekr.20050429094215.355"><vh>New plan</vh></v>
<v t="ekr.20050429094215.161"><vh>write_Leo_file</vh>
<v t="ekr.20050429094215.162"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20050429094215.163"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20050429094215.164"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20050429094215.165"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20050429094215.166"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050429094215.167"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20050429094215.168"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20050429094215.141"><vh>Scanning @settings (g.app.config)</vh>
<v t="ekr.20050429094215.142"><vh>openSettingsFile</vh></v>
<v t="ekr.20050429094215.143"><vh>config.readSettingsFiles</vh></v>
<v t="ekr.20050429094215.144"><vh>readSettings</vh></v>
</v>
<v t="ekr.20050429094215.350"><vh>setRecentFiles (c.configSettings)</vh></v>
<v t="ekr.20050429094215.356"><vh>appendToRecentFiles (g.app.config)</vh></v>
<v t="ekr.20050429094215.349"><vh>clearRecentFiles</vh></v>
<v t="ekr.20050429094215.357"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20050429094215.358"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20050429094215.359"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20050429094215.360"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
</v>
<v t="ekr.20050429095849"><vh>Finished all @settings coding</vh></v>
</v>
</v>
<v t="ekr.20050313101229"><vh>4.3-a4</vh>
<v t="ekr.20050313101229.2"><vh>Fixed bugs...</vh>
<v t="ekr.20050313101229.69"><vh>Fix colorizer bug for initial @nocolor in @root nodes</vh></v>
<v t="ekr.20050313101229.74"><vh>Fixed @wrap bug</vh></v>
<v t="ekr.20050313101229.77"><vh>Fixed change-all bug</vh></v>
</v>
<v t="ekr.20050313103448"><vh>New features...</vh>
<v t="ekr.20050313101229.95"><vh>Created Add Comments and Delete Comments commands</vh></v>
<v t="ekr.20050313101229.94"><vh>Deprecated new_c key in hooks, added c key</vh></v>
<v t="ekr.20050313103448.1"><vh>Added the 'before-create-leo-frame' hook</vh></v>
<v t="ekr.20050313101229.101"><vh>Added support for mod_labels plugin</vh></v>
</v>
<v t="ekr.20050313101229.100"><vh>Revised plugins for the 4.3 code base</vh></v>
</v>
<v t="ekr.20050221104844"><vh>4.3-a3</vh>
<v t="ekr.20050221104844.2"><vh>Bugs</vh>
<v t="ekr.20050221104844.3"><vh>Fixed crasher in Tangle</vh></v>
<v t="ekr.20050221104844.12"><vh>Applied patch to rst2 plugin</vh></v>
<v t="ekr.20050221104844.14"><vh>Revised searchbox plugin so it works with Leo 4.3</vh></v>
<v t="ekr.20050221104844.27"><vh>Fixed bugs in nav_buttons and nodenavigator plugins</vh></v>
<v t="ekr.20050221104844.45"><vh>Made sure Leo asks for leoID at most once</vh></v>
<v t="ekr.20050221104844.54"><vh>Fixed botch in g.pdb</vh></v>
<v t="ekr.20050222100936"><vh>Fixed crasher when executing a script if the script was selected text in a new window</vh></v>
</v>
<v t="ekr.20050221104844.57"><vh>New features</vh>
<v t="ekr.20050221104844.58"><vh>Added sets.py to distribution</vh></v>
<v t="ekr.20050221104844.59"><vh>Added color='suppress' hack to g.es</vh></v>
</v>
</v>
<v t="ekr.20050126100405"><vh>4.3-a2</vh>
<v t="ekr.20050130112336.1"><vh>To do: Improve how Leo handles recent files</vh></v>
<v t="ekr.20050209141626.3"><vh>Bugs fixed...</vh>
<v t="ekr.20050209141626.4"><vh>Fixed very old bug in Undo Insert Node </vh></v>
<v t="ekr.20050209141626.8"><vh>Made sure to remove duplicates from recent files</vh></v>
<v t="ekr.20050209141626.12"><vh>Fixed indentation problems in leoTkinterFind.py</vh></v>
<v t="ekr.20050209141626.13"><vh>Changed leoConfig.txt to leoSettings.leo in Help menu, etc.</vh></v>
<v t="ekr.20050209141626.16"><vh>Investigated recent files problems</vh></v>
<v t="ekr.20050209141626.23"><vh>Improved queuing of log messages</vh></v>
<v t="ekr.20050209141626.42"><vh>Fixed crasher in Change All command</vh></v>
<v t="ekr.20050209141626.43"><vh>Fixed crasher in script button</vh></v>
<v t="ekr.20050209141626.46"><vh>Fixed print problems on the Mac</vh></v>
<v t="ekr.20050209141626.53"><vh>leoTest.runTests now makes copies of all positions</vh></v>
<v t="ekr.20050209141626.54"><vh>Fixed problems with unit test file paths</vh></v>
<v t="ekr.20050209141626.55"><vh>Made local config settings work again</vh></v>
<v t="ekr.20050209141626.91"><vh>Fix problems searching for nothing but whitespace</vh></v>
<v t="ekr.20050210101318"><vh>Fixed problems with typing return in the Find panel</vh></v>
<v t="ekr.20050209141626.101"><vh>Buttons no longer work in toolbars when settings dialog is open</vh></v>
<v t="ekr.20050209141626.102"><vh>Fixed bug in delayed focus logic</vh></v>
<v t="ekr.20050209141626.105"><vh>Made sure Leo asks for leoID at most once</vh></v>
<v t="ekr.20050209141626.113"><vh>Leo now prints unicode characters properly in the log pane</vh></v>
<v t="ekr.20050209141626.114"><vh>Fixed various problems with opening files with Unicode filenames</vh></v>
<v t="ekr.20050211095754"><vh>Fixed bug reading encoding field in derived files</vh></v>
<v t="ekr.20050212054743"><vh>Allow indented code blocks to be run using Execute Script command</vh></v>
<v t="ekr.20050212144116"><vh>Fixed problems found by pychecker</vh></v>
</v>
<v t="ekr.20050209141626.150"><vh>New features...</vh>
<v t="ekr.20050126100405.1"><vh>Added undo granularity</vh>
<v t="EKR.20040524104904.48"><vh>Undoing operations</vh></v>
</v>
<v t="ekr.20050209141626.185"><vh>Added support for top-level init function in plugins</vh></v>
<v t="ekr.20050209141626.190"><vh>Changed name of Paste Retaining Clones to Paste Node As Clone</vh></v>
<v t="ekr.20050209141626.193"><vh>Added leoPlugins.leo to Help menu</vh></v>
<v t="ekr.20050209141626.194"><vh>Script buttons can request to be removed</vh></v>
<v t="ekr.20050209141626.195"><vh>Improved documentation in several nodes in leoSettings.leo</vh></v>
<v t="ekr.20050209141626.196"><vh>Predefined c,g &amp; p in scripts, unit tests &amp; test routines</vh></v>
<v t="ekr.20050209141626.198"><vh>Changed name of Preferences command to Settings</vh></v>
</v>
</v>
<v t="ekr.20050122090311"><vh>4.3-a1</vh>
<v t="ekr.20050123112834"><vh>Defining features of 4.3</vh>
<v t="ekr.20050123110009"><vh>Using @settings trees and leoSettings.leo</vh>
<v t="ekr.20050122084954"><vh>Using leoSettings.leo and @settings trees</vh></v>
<v t="ekr.20050122091036"><vh>Unfinished configuration features</vh></v>
</v>
<v t="ekr.20050123092834.520"><vh>Rewrote Leo's read/write logic</vh></v>
<v t="ekr.20050123115804"><vh>Added Plugins Manager plugin</vh></v>
<v t="ekr.20050123115804.1"><vh>You can install third-party extensions in Leo's extensions directory</vh></v>
</v>
<v t="ekr.20050123092834.1"><vh>Fixed bugs...</vh>
<v t="ekr.20050123101208"><vh> Major bugs: these bugs corrupted derived files!</vh>
<v t="ekr.20050123092834.432"><vh>Fixed double doc part bug</vh></v>
<v t="ekr.20050123092834.497"><vh>Fixed bug in how Leo writes thin derived files</vh></v>
</v>
<v t="ekr.20050123092834.2"><vh>Commands</vh>
<v t="ekr.20050123092834.6"><vh>Fixed problems with spawnv option of openWith</vh></v>
<v t="ekr.20050123092834.19"><vh>Fixed bug in  Remove Sentinels command</vh></v>
<v t="ekr.20050123092834.27"><vh>Fixed bug re Paste Node As Clone</vh></v>
<v t="ekr.20050123092834.42"><vh>Fixed Pretty Print commands for Python 2.4</vh></v>
<v t="ekr.20050123092834.71"><vh>Fixed crasher in Import Derived Files command</vh></v>
<v t="ekr.20050123092834.510"><vh>Search commands are now restricted to hoisted area</vh></v>
</v>
<v t="ekr.20050123100706.1"><vh>Distribution</vh>
<v t="ekr.20050123092834.491"><vh>Fixed file association in leoDist.leo</vh></v>
</v>
<v t="ekr.20050123092834.165"><vh>Files</vh>
<v t="ekr.20050123092834.492"><vh>g.import wrappers return module if it is in sys.modules</vh></v>
<v t="ekr.20050123092834.166"><vh>Disabled changes to comment delims in @@language and @@comment sentinels</vh></v>
<v t="ekr.20050123092834.176"><vh>Made sure files that differ only in line ending get written if @lineending is in effect</vh></v>
<v t="ekr.20050123092834.196"><vh>Fixed bug:  @nosent wrote sentinels!</vh></v>
<v t="ekr.20050123092834.422"><vh>Fixed bug in replaceTargetFileIfDifferent</vh></v>
<v t="ekr.20050123092834.424"><vh>Made sure that @ignore forces writing of inner @thin trees</vh></v>
<v t="ekr.20050123092834.431"><vh>Fixed crasher when attempting to write a derived file to an invalid path</vh></v>
<v t="ekr.20050123092834.434"><vh>Fixed Python 2.4 deprecation warning when saving .leo files</vh></v>
<v t="ekr.20050123092834.499"><vh>Fixed crasher in getOutputNewline</vh></v>
<v t="ekr.20050123092834.544"><vh>Always use os.rename in utils_rename</vh></v>
<v t="ekr.20050123151338"><vh>Fixed bugs handling @language &amp; @comment in atFile.scanAllDirectives &amp; g.scanDirectives)</vh></v>
</v>
<v t="ekr.20050123103303"><vh>Gui</vh>
<v t="ekr.20050123092834.502"><vh>Put the scrollWheel workaround in createTkTreeCanvas</vh></v>
</v>
<v t="ekr.20050123100706.2"><vh>Menus</vh>
<v t="ekr.20050123092834.81"><vh>Fixed problems with Control-E</vh></v>
<v t="ekr.20050123092834.490"><vh>Better handling of duplicate menu shortcuts</vh></v>
</v>
<v t="ekr.20050123092834.159"><vh>Nodes</vh>
<v t="ekr.20050123092834.160"><vh>Fixed crash after cutting an imported node</vh></v>
<v t="ekr.20050123092834.163"><vh>Removed invalid assert in lastVisible</vh></v>
<v t="ekr.20050123093854.1"><vh>Fixed bugs in tnodes_iter and unique_tnodes_iter</vh></v>
</v>
<v t="ekr.20050123111723"><vh>Plugins</vh>
<v t="ekr.20050123092834.1047"><vh>Fixed two bugs in Plugins Manager plugin</vh></v>
<v t="ekr.20050123092834.1052"><vh>Fixed bug re referencing destroyed ivars</vh></v>
<v t="ekr.20050123092834.1057"><vh>Fixed bug in registerOneHandler</vh></v>
<v t="ekr.20050123092834.506"><vh>Fixed conflict between settings panel and chapters plugin</vh></v>
</v>
<v t="ekr.20050123092834.526"><vh>Pychecker</vh></v>
<v t="ekr.20050123092834.438"><vh>Scripting</vh>
<v t="ekr.20050123092834.439"><vh>Fixed unbounded recursion with --script and redirected output</vh></v>
<v t="ekr.20050123092834.474"><vh>Script buttons now execute the entire script</vh></v>
<v t="ekr.20050123092834.480"><vh>Fixed error reporting in executeScript when the error happens outside the script</vh></v>
</v>
<v t="ekr.20050123092834.486"><vh>Startup</vh>
<v t="ekr.20050123092834.487"><vh>Non-existent command-line file becomes name of new Leo wiindow</vh></v>
<v t="ekr.20050123092834.1011"><vh>computeHomeDir now handles references to other vars</vh></v>
</v>
</v>
<v t="ekr.20050123092834.896"><vh>New or improved features...</vh>
<v t="ekr.20050123110009"><vh>Using @settings trees and leoSettings.leo</vh>
<v t="ekr.20050122084954"><vh>Using leoSettings.leo and @settings trees</vh></v>
<v t="ekr.20050122091036"><vh>Unfinished configuration features</vh></v>
</v>
<v t="ekr.20050123103303.1"><vh>Code</vh>
<v t="ekr.20050123092834.520"><vh>Rewrote Leo's read/write logic</vh></v>
<v t="ekr.20050123092834.173"><vh>Added g.cantImport</vh></v>
<v t="ekr.20050123092834.901"><vh>Added g.fileLikeObject.readline</vh></v>
<v t="ekr.20050123092834.928"><vh>Added support for g.app.debugSwitch in es_exception</vh></v>
<v t="ekr.20050123092834.984"><vh>Restored drawing/event hooks</vh></v>
<v t="ekr.20050123092834.1004"><vh>Added p=p param to all hooks containing v=v</vh></v>
<v t="ekr.20050123092834.565"><vh>Implemented delayed focus scheme</vh></v>
</v>
<v t="ekr.20050123103521"><vh>Commands</vh>
<v t="ekr.20050123092834.897"><vh>Added 'Expand Or Go Right' and 'Contract or Go Left' commands</vh></v>
<v t="ekr.20050123092834.908"><vh>Added keyboard shortcuts to find panel</vh></v>
<v t="ekr.20050123092834.1005"><vh>Find panels are now associated with individual Leo windows</vh></v>
<v t="ekr.20050123105026"><vh>Find panels are now inited from @settings nodes</vh></v>
<v t="ekr.20050123092834.961"><vh>Improved Go To Line Number and Execute Script commands</vh></v>
<v t="ekr.20050123092834.1018"><vh>Improved support for relative path names</vh></v>
<v t="ekr.20050123092834.1043"><vh>Implemented 'Undo Clear Recent Files'</vh></v>
<v t="ekr.20050123092834.517"><vh>Removed old-style write commands</vh></v>
</v>
<v t="ekr.20050123092834.1044"><vh>Plugins &amp; extensions</vh>
<v t="ekr.20050123115804"><vh>Added Plugins Manager plugin</vh></v>
<v t="ekr.20050123115804.1"><vh>You can install third-party extensions in Leo's extensions directory</vh></v>
<v t="ekr.20050123112151"><vh>Improved doHandlersForTag</vh></v>
<v t="ekr.20050123092834.1013"><vh>Leo now associates modules with hook handlers</vh></v>
</v>
<v t="ekr.20050123103753"><vh>Syntax Coloring &amp; languages</vh>
<v t="ekr.20050123092834.903"><vh>Added support for Ada</vh></v>
<v t="ekr.20050123092834.929"><vh>Added support for Forth</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060206111717.1"><vh>4.4 minibuffer, keys</vh>
<v t="ekr.20051219150602"><vh>4.4 alpha 5</vh>
<v t="ekr.20051219150602.2"><vh>Fixed bugs</vh>
<v t="ekr.20051219150602.3"><vh>Made sure focus doesn't go to log during tab completion or after writes to log</vh></v>
<v t="ekr.20051219150602.7"><vh>Fixed problem with getScript in batch mode</vh></v>
<v t="ekr.20051219150602.10"><vh>Text box is now selected in goto-line-number command</vh></v>
<v t="ekr.20051219150602.13"><vh>Restored headkey  &amp; bodykey hooks</vh></v>
<v t="ekr.20051219150602.28"><vh>Fixed ancient bug in read error logic that hung Leo</vh></v>
<v t="ekr.20051219150602.75"><vh>Fixed many headline problems</vh></v>
<v t="ekr.20051219150602.81"><vh>Fixed problem in reformatParagraph</vh></v>
<v t="ekr.20051219150602.85"><vh>Installed LeoUsers patch </vh></v>
<v t="ekr.20060105182648.376"><vh>Improved Import Derived Files command.</vh></v>
<v t="ekr.20060105182648.377"><vh>Fixed crasher in backwardDeleteCharacter</vh></v>
<v t="ekr.20060105182648.378"><vh>Fixed recent bug: dialogs now get focus properly when first opened.</vh></v>
<v t="ekr.20060105182648.379"><vh>Made sure shortcuts are printed clearly by k.registerCommand</vh></v>
<v t="ekr.20060105182648.382"><vh>Suppressed crash undoing a clone followed by a drag</vh></v>
</v>
<v t="ekr.20051219150602.100"><vh>New features</vh>
<v t="ekr.20051219150602.101"><vh>created ut.leo, ut.py and ut.bat</vh></v>
<v t="ekr.20051219150602.102"><vh>Added modes/*.xml to distribution</vh></v>
<v t="ekr.20051219150602.105"><vh>Revised cursor movement commands and added selection-extension commands</vh></v>
<v t="ekr.20051219151926"><vh>Added classic key bindings in leoSettings.leo</vh></v>
<v t="ekr.20060105182648.432"><vh>Allow multiple key bindings to the same command</vh></v>
<v t="ekr.20060105182648.469"><vh>Settings command now opens leoSettings.leo</vh></v>
<v t="ekr.20060105214753"><vh>Input modes</vh></v>
</v>
</v>
<v t="ekr.20051028051444"><vh>4.4 alpha 4</vh>
<v t="ekr.20051028051444.1"><vh>Quick Start</vh></v>
<v t="ekr.20051028051444.2"><vh>The 'key' features of 4.4</vh>
<v t="ekr.20051101161405"><vh>Leo's minibuffer works like the Emacs mini-buffer</vh></v>
<v t="ekr.20051101161405.1"><vh>@shortcuts nodes in leoSettings.leo allow per-pane bindings</vh></v>
<v t="ekr.20051101161405.2"><vh>The scripting plugin allows key bindings</vh></v>
<v t="ekr.20051101161405.3"><vh>EKR shortcuts</vh></v>
<v t="ekr.20051101162123"><vh>Leo now ignores key bindings in menu tables</vh></v>
</v>
<v t="ekr.20051205091625"><vh>Status of minibuffer commands</vh></v>
<v t="ekr.20051028051616"><vh>New in alpha 1...</vh>
<v t="ekr.20051028051444.4"><vh>New options</vh>
<v t="ekr.20051028051444.5"><vh>The @bool useMinibuffer option</vh></v>
<v t="ekr.20051028051444.6"><vh>The @bool useCmdMenu option</vh></v>
<v t="ekr.20051028051444.7"><vh>Options for selected body text</vh></v>
</v>
<v t="ekr.20051028051444.8"><vh>New mini-buffer commands</vh></v>
<v t="ekr.20051028051444.9"><vh>New code-level features</vh>
<v t="ekr.20051028051444.10"><vh>Dictionaries of keys and commands</vh></v>
<v t="ekr.20051028051444.11"><vh>Functions that return the present key bindings</vh></v>
<v t="ekr.20051028051444.12"><vh>The registerCommand helper</vh></v>
</v>
<v t="ekr.20051028051444.13"><vh>Bugs fixed (in 4.3 code base)</vh>
<v t="ekr.20051028051444.14"><vh>Leo protects c.endUpdate with a 'finally' clause</vh></v>
<v t="ekr.20051028051444.15"><vh>Added kludge to solve infamous control-v problems</vh></v>
<v t="ekr.20051028051444.16"><vh>Fixed bug in Leo's read logic</vh></v>
<v t="ekr.20051028051444.17"><vh>Fixed bug in goto-last-node.</vh></v>
<v t="ekr.20051028051444.18"><vh>Leo now reads @settings trees when opening a .leo file from another outline.</vh></v>
<v t="ekr.20051028051444.19"><vh>Improved g.removeExtraLws</vh></v>
</v>
</v>
<v t="ekr.20051028051616.1"><vh>New in alpha 2</vh>
<v t="ekr.20051101162123.1"><vh>The tabbed log</vh>
<v t="ekr.20051028051616.172"><vh>Programming the tabbed log</vh></v>
</v>
<v t="ekr.20051028061322"><vh>New minibuffer commands</vh></v>
<v t="ekr.20051028051616.299"><vh>Optional generation of closing brackets</vh></v>
<v t="ekr.20051101182739"><vh>New settings in leoSettings.leo</vh></v>
<v t="ekr.20051101161949"><vh>Improved and retired plugins</vh>
<v t="ekr.20051028051616.160"><vh>Improved the scripting plugin</vh></v>
<v t="ekr.20051101162947"><vh>Retired the TabbedLog plugin</vh></v>
</v>
<v t="ekr.20051101163145"><vh>Many code-level improvements</vh></v>
<v t="ekr.20051101163404"><vh>Fixed minor bugs</vh></v>
</v>
<v t="ekr.20051109112610"><vh>New in alpha 3</vh>
<v t="ekr.20051109112826"><vh>The New and Newer World Orders</vh></v>
<v t="ekr.20051109141223"><vh>Bugs fixed...</vh>
<v t="ekr.20051109112826.217"><vh>Fix crasher in Open logic</vh></v>
<v t="ekr.20051109112826.227"><vh>(Undo ends editing</vh></v>
<v t="ekr.20051109112826.257"><vh>Disabled minibuffer when not in use</vh></v>
<v t="ekr.20051109112826.315"><vh>Fixed bug in Find Backward</vh></v>
<v t="ekr.20051109112826.265"><vh>Improved Spell tab</vh></v>
</v>
<v t="ekr.20051109141524"><vh>New features</vh>
<v t="ekr.20051109112826.222"><vh>Created scripts.leo and unitTest.leo</vh></v>
<v t="ekr.20051109112826.254"><vh>c.executeMinibufferCommand executes a minibuffer command by name</vh></v>
<v t="ekr.20051109112826.310"><vh>Improved perl entries in language dicts</vh></v>
</v>
<v t="ekr.20051109141524.1"><vh>Code-level changes</vh>
<v t="ekr.20051109112826.223"><vh>Changed  edit_text to edit_widget everywhere</vh></v>
<v t="ekr.20051109112826.224"><vh>Removed tree ivars</vh></v>
<v t="ekr.20051109142920"><vh>Removed frame.begin/endUpdate</vh></v>
</v>
</v>
<v t="ekr.20051128181229"><vh>New in alpha 4</vh>
<v t="ekr.20051128181351"><vh>Bugs fixed</vh>
<v t="ekr.20051128181302.148"><vh>Changed scripting plugin so files opened with buttons stay in front</vh></v>
<v t="ekr.20051128181302.183"><vh>Fixed undo/redo bugs</vh></v>
<v t="ekr.20051128181302.192"><vh>Fixed focus problem with tab completion</vh></v>
<v t="ekr.20051128181302.193"><vh>Fixed minor Save bug</vh></v>
<v t="ekr.20051128181302.231"><vh>Fixed long-standing problem with Plugins Manager plugin</vh></v>
<v t="ekr.20051128181302.244"><vh>Fixed 2 outline editing bugs</vh></v>
<v t="ekr.20051205090923.13"><vh>Fixed crasher in deleteNextChar</vh></v>
<v t="ekr.20051205090923.16"><vh>Fixed new headline bug</vh></v>
<v t="ekr.20051205090923.22"><vh>Fix problems applying settings</vh></v>
<v t="ekr.20051128181302.204"><vh>Fixed several bugs in rst3 plugin</vh></v>
</v>
<v t="ekr.20051128181651"><vh>Code changes</vh>
<v t="ekr.20051128181302.149"><vh>Removed later arg from c.frame.xWantsFocus</vh></v>
<v t="ekr.20051128181302.196"><vh>Created enableTclTraces</vh></v>
<v t="ekr.20051128181302.208"><vh>Eliminated w.update in g.app.gui.set_focus</vh></v>
</v>
<v t="ekr.20051128181651.1"><vh>New &amp; improved features and files</vh>
<v t="ekr.20051128181302.147"><vh>Moved all scripts into scripts.leo</vh></v>
<v t="ekr.20051128181302.150"><vh>Improved how the New Tab and Rename Tab commands work in the log pane</vh></v>
<v t="ekr.20051128181302.151"><vh>Improved the appearance of the Spell tab</vh></v>
<v t="ekr.20051128181302.156"><vh>Added Clone-find checkbox to the Find tab</vh></v>
<v t="ekr.20051128181302.171"><vh>Improved find tab</vh></v>
<v t="ekr.20051128181302.211"><vh>Improved formatting of shortcuts in print-commands and print-bindings</vh></v>
<v t="ekr.20051128181302.213"><vh>Added settings for vim plugin</vh></v>
<v t="ekr.20051128181302.214"><vh>Put up a dialog if can't import Pmw</vh></v>
<v t="ekr.20051128181302.229"><vh>Bound &lt;Return&gt; to end-edit-headline</vh></v>
</v>
</v>
</v>
<v t="ekr.20060116174906"><vh>4.4 beta 1</vh>
<v t="ekr.20060116174906.2"><vh>Bugs fixed</vh>
<v t="ekr.20060116174906.3"><vh>Fixed minor headline problems</vh></v>
<v t="ekr.20060116174906.63"><vh>Fixed undo problems</vh></v>
<v t="ekr.20060116174906.86"><vh>Improved word-export plugin</vh></v>
<v t="ekr.20060116174906.87"><vh>Removed a bad use of g.app.log in the find panel</vh></v>
<v t="ekr.20060116174906.88"><vh>Fix crash: tab in minibuffer</vh></v>
<v t="ekr.20060116174906.90"><vh>Installed patch for headline width</vh></v>
<v t="ekr.20060116174906.97"><vh>Redraw screen properly after Move To Next Dirty</vh></v>
<v t="ekr.20060116174906.100"><vh>Fixed focus bug</vh></v>
<v t="ekr.20060116174906.103"><vh>Made sure to bring proper window on top in settings.leo button</vh></v>
<v t="ekr.20060116174906.104"><vh>Arrow keys now clear the text selection</vh></v>
<v t="ekr.20060116174906.113"><vh>Fixed several minor bugs</vh></v>
<v t="ekr.20060116174906.118"><vh>Fixed problems with plugins</vh></v>
<v t="ekr.20060116174906.122"><vh>Fixed old file handling bug</vh></v>
<v t="ekr.20060116174906.125"><vh>Use shutil.move in g.utils_rename</vh></v>
<v t="ekr.20060116174906.130"><vh>Simplified k.copyBindingsToWidget and eliminated k.onTextWidgetKey</vh></v>
<v t="ekr.20060116174906.160"><vh>Made sure that focus stays in body during tab completion</vh></v>
<v t="ekr.20060116174906.163"><vh>Leo now puts focus in body pane after deleting a window</vh></v>
<v t="ekr.20060116174906.164"><vh>Fixed many binding problems</vh></v>
<v t="ekr.20060116174906.185"><vh>Fixed extend-selection problems</vh></v>
<v t="ekr.20060116174906.187"><vh>Fixed per-pane bindings!</vh></v>
<v t="ekr.20060116174906.194"><vh>Always redraw the screen after editing a label</vh></v>
</v>
<v t="ekr.20060116174906.195"><vh>Code level changes</vh>
<v t="ekr.20060116174906.198"><vh>Removed g.top from Leo's core and all plugins</vh></v>
<v t="ekr.20060116174906.199"><vh>Created c.exists ivar and related logic</vh></v>
<v t="ekr.20060116174906.213"><vh>Call c.setLog in all entries into code</vh></v>
<v t="ekr.20060116174906.255"><vh>Generalized doCommand</vh></v>
</v>
<v t="ekr.20060116174906.258"><vh>New features</vh>
<v t="ekr.20060116174906.259"><vh>Installed many standard bindings to leoSettings.leo</vh></v>
<v t="ekr.20060116174906.262"><vh>Added Check Bindings script in leoSettings.leo</vh></v>
<v t="ekr.20060116174906.263"><vh>Scripts now maintain original focus</vh></v>
<v t="ekr.20060116174906.267"><vh>Added scroll-up/down-extend-selection commands</vh></v>
<v t="ekr.20060116174906.272"><vh>Improved cursor move/extend commands</vh></v>
<v t="ekr.20060116174906.296"><vh>Added support for @mode nodes</vh></v>
<v t="ekr.20060116174906.306"><vh>keyboard-quit restores default input mode</vh></v>
</v>
<v t="ekr.20060116174906.257"><vh>Added discusion to FAQ about when deleting a node is 'dangerous'</vh>
<v t="ekr.20060111192108"><vh>When is deleting a node dangerous?</vh></v>
</v>
</v>
<v t="ekr.20060206111508"><vh>4.4 beta 2</vh>
<v t="ekr.20060206111508.2"><vh>Bugs</vh>
<v t="ekr.20060206111508.3"><vh>Fixed crasher in Save button</vh></v>
<v t="ekr.20060206111508.4"><vh>Fixed minor bugs &amp; made minor improvements</vh>
<v t="ekr.20060206111508.5"><vh>Fixed two annoying headline glitches</vh>
<v t="ekr.20060206111508.6"><vh>tree.set...LabelState</vh>
<v t="ekr.20060206111508.7"><vh>setEditLabelState</vh></v>
<v t="ekr.20060206111508.8"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20060206111508.9"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20060206111508.10"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20060206111508.11"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20060206111508.12"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20060206111508.13"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060206111508.14"><vh>Insert headline didn't redraw headline properly in vim mode</vh>
<v t="ekr.20060206111508.15"><vh>printBindings</vh></v>
<v t="ekr.20060206111508.16"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060206111508.17"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060206111508.18"><vh>callStateFunction</vh></v>
<v t="ekr.20060206111508.19"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060206111508.20"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060206111508.21"><vh>head key handlers</vh>
<v t="ekr.20060206111508.22"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060206111508.23"><vh>updateHead</vh></v>
<v t="ekr.20060206111508.24"><vh>onHeadChanged</vh>
<v t="ekr.20060206111508.25"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060206111508.26"><vh>Modes</vh>
<v t="ekr.20060206111508.27"><vh>badMode</vh></v>
<v t="ekr.20060206111508.28"><vh>createModeBindings</vh></v>
<v t="ekr.20060206111508.29"><vh>endMode</vh></v>
<v t="ekr.20060206111508.30"><vh>enterNamedMode</vh></v>
<v t="ekr.20060206111508.31"><vh>exitNamedMode</vh></v>
<v t="ekr.20060206111508.32"><vh>generalModeHandler</vh></v>
<v t="ekr.20060206111508.33"><vh>initMode</vh></v>
<v t="ekr.20060206111508.34"><vh>reinitMode</vh></v>
<v t="ekr.20060206111508.35"><vh>modeHelp</vh>
<v t="ekr.20060206111508.36"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060206111508.37"><vh>set-xxx-State</vh></v>
<v t="ekr.20060206111508.38"><vh>setInputState</vh></v>
<v t="ekr.20060206111508.39"><vh>showStateAndMode</vh></v>
</v>
</v>
<v t="ekr.20060206111508.40"><vh>Improved printBindings, printCommands &amp; modeHelp</vh>
<v t="ekr.20060206111508.41"><vh>Externally visible commands</vh>
<v t="ekr.20060206111508.42"><vh>digitArgument &amp; universalArgument</vh></v>
<v t="ekr.20060206111508.43"><vh>k.show/hide/toggleMinibuffer</vh></v>
<v t="ekr.20060206111508.44"><vh>negativeArgument (redo?)</vh></v>
<v t="ekr.20060206111508.45"><vh>numberCommand</vh></v>
<v t="ekr.20060206111508.15"><vh>printBindings</vh></v>
<v t="ekr.20060206111508.46"><vh>printCommands</vh></v>
<v t="ekr.20060206111508.47"><vh>repeatComplexCommand &amp; helper</vh></v>
</v>
<v t="ekr.20060206111508.15"><vh>printBindings</vh></v>
<v t="ekr.20060206111508.46"><vh>printCommands</vh></v>
<v t="ekr.20060206111508.36"><vh>modeHelpHelper</vh></v>
<v t="ekr.20060206111508.35"><vh>modeHelp</vh>
<v t="ekr.20060206111508.36"><vh>modeHelpHelper</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111508.48"><vh>Fixed crasher re BackSpace in log window</vh></v>
<v t="ekr.20060206111508.49"><vh>Fixed crashers in cut/copy/paste commands</vh>
<v t="ekr.20060206111508.50"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060206111508.51"><vh>copyText</vh></v>
<v t="ekr.20060206111508.52"><vh>cutText</vh></v>
<v t="ekr.20060206111508.53"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060206111508.54"><vh>Fixed crasher when clicking the close box during a long command</vh>
<v t="ekr.20060206111508.55"><vh>frame.OnCloseLeoEvent</vh></v>
<v t="ekr.20060206111508.56"><vh>app.closeLeoWindow</vh></v>
<v t="ekr.20060206111508.57"><vh> doCommand</vh></v>
</v>
<v t="ekr.20060206111508.58"><vh>cloneFindAll now honor present find settings</vh></v>
<v t="ekr.20060206111508.63"><vh>Double-click didn't work in the body pane.</vh></v>
<v t="ekr.20060206111508.74"><vh>Improved body.makeInsertPointVisible</vh></v>
<v t="ekr.20060206111508.75"><vh>Fixed cut/copy/paste from menu</vh></v>
<v t="ekr.20060206111508.553"><vh>Fixed major blunder: tree.onHeadChanged sets focus only if there was a real change</vh></v>
</v>
<v t="ekr.20060206112001"><vh>New commandes</vh>
<v t="ekr.20060206111508.545"><vh>Added free-text-widgets, dump-all-objects, dump-new-objects, verbose-dump-objects commands</vh></v>
<v t="ekr.20060206111508.546"><vh>Added gc_stats to print-stats command</vh></v>
</v>
<v t="ekr.20060206111853"><vh>New features</vh>
<v t="ekr.20060206111508.76"><vh>Made modes work</vh></v>
<v t="ekr.20060206111508.97"><vh>Disabled plain-key bindings in insert/overwrite modes</vh></v>
<v t="ekr.20060206111508.103"><vh>Disabled auto-scrolling in outline pane on clicks</vh></v>
<v t="ekr.20060206111508.136"><vh>move-outline and find commands force a screen scroll</vh></v>
<v t="ekr.20060206111508.517"><vh>(Improved gc stats)</vh></v>
<v t="ekr.20060206111508.138"><vh>(Limited undo)</vh></v>
</v>
<v t="ekr.20060206111508.547"><vh>Code issues</vh>
<v t="ekr.20060206111508.229"><vh>(Added event arg to all legacy commands)</vh></v>
<v t="ekr.20060206111508.548"><vh>Code cleanup</vh></v>
<v t="ekr.20060206111508.550"><vh>Removed code in c.begin/EndUpdate and c.endEditLabel that tried to save/restore focus</vh></v>
<v t="ekr.20060206111508.596"><vh>Improved tree allocation</vh></v>
</v>
<v t="ekr.20060206111508.620"><vh>What I did earlier</vh></v>
<v t="ekr.20060206111508.621"><vh>What I did: 2-4-06</vh></v>
<v t="ekr.20060206111508.622"><vh>What I did: 2-5-06</vh></v>
<v t="ekr.20060211104746.1"><vh>What I did: 2-6-05</vh></v>
<v t="ekr.20060211104746.2"><vh>Fixed undo problem in headlines</vh>
<v t="ekr.20060211104746.3"><vh>Notes</vh></v>
<v t="ekr.20060211104746.4"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20060211104746.5"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20060211104746.6"><vh>editLabel</vh></v>
<v t="ekr.20060211104746.7"><vh>onHeadChanged</vh>
<v t="ekr.20060211104746.8"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.9"><vh>undoNodeContents</vh></v>
<v t="ekr.20060211104746.10"><vh>redoNodeContents</vh></v>
<v t="ekr.20060211104746.11"><vh>tree.setHeadline (new in 4.4b2)</vh></v>
</v>
<v t="ekr.20060211104746.12"><vh>Created c.masterFocusHandler and made it work</vh>
<v t="ekr.20060211104746.13"><vh>What I did</vh></v>
<v t="ekr.20060211104746.14"><vh> Birth... (tkTree)</vh>
<v t="ekr.20060211104746.15"><vh>__init__ (tkTree)</vh>
<v t="ekr.20060211104746.16"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20060211104746.17"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20060211104746.18"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.19"><vh>tkTtree.setBindings</vh>
<v t="ekr.20060211104746.20"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
<v t="ekr.20060211104746.21"><vh>&lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.22"><vh>injectCallbacks</vh>
<v t="ekr.20060211104746.23"><vh>&lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;</vh>
<v t="ekr.20060211104746.24"><vh>OnHyperLinkControlClick</vh></v>
<v t="ekr.20060211104746.25"><vh>OnHyperLinkEnter</vh></v>
<v t="ekr.20060211104746.26"><vh>OnHyperLinkLeave</vh></v>
</v>
</v>
</v>
<v t="ekr.20060211104746.27"><vh>Event handlers (tkTree)</vh>
<v t="ekr.20060211104746.28"><vh>Helpers</vh>
<v t="ekr.20060211104746.29"><vh>checkWidgetList</vh></v>
<v t="ekr.20060211104746.30"><vh>dumpWidgetList</vh></v>
<v t="ekr.20060211104746.31"><vh>edit_widget</vh></v>
<v t="ekr.20060211104746.32"><vh>eventToPosition</vh></v>
<v t="ekr.20060211104746.33"><vh>findEditWidget</vh></v>
<v t="ekr.20060211104746.34"><vh>findVnodeWithIconId</vh></v>
</v>
<v t="ekr.20060211104746.35"><vh>Click Box...</vh>
<v t="ekr.20060211104746.36"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060211104746.37"><vh>Dragging</vh>
<v t="ekr.20060211104746.38"><vh>endDrag</vh>
<v t="ekr.20060211104746.39"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20060211104746.40"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.41"><vh>startDrag</vh></v>
<v t="ekr.20060211104746.42"><vh>onContinueDrag</vh>
<v t="ekr.20060211104746.43"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.44"><vh>onDrag</vh></v>
<v t="ekr.20060211104746.45"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20060211104746.46"><vh>head key handlers</vh>
<v t="ekr.20060211104746.47"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060211104746.48"><vh>updateHead</vh></v>
<v t="ekr.20060211104746.7"><vh>onHeadChanged</vh>
<v t="ekr.20060211104746.8"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060211104746.49"><vh>Icon Box...</vh>
<v t="ekr.20060211104746.50"><vh>onIconBoxClick</vh></v>
<v t="ekr.20060211104746.51"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20060211104746.52"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20060211104746.53"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20060211104746.54"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.55"><vh>Text Box...</vh>
<v t="ekr.20060211104746.56"><vh>configureTextState</vh></v>
<v t="ekr.20060211104746.57"><vh>onCtontrolT</vh></v>
<v t="ekr.20060211104746.58"><vh>onHeadlineClick</vh></v>
<v t="ekr.20060211104746.59"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20060211104746.60"><vh>tree.OnDeactivate</vh></v>
<v t="ekr.20060211104746.61"><vh>tree.OnPopup &amp; allies</vh>
<v t="ekr.20060211104746.62"><vh>OnPopupFocusLost</vh></v>
<v t="ekr.20060211104746.63"><vh>createPopupMenu</vh>
<v t="ekr.20060211104746.64"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.65"><vh>enablePopupMenuItems</vh>
<v t="ekr.20060211104746.66"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.67"><vh>showPopupMenu</vh></v>
</v>
<v t="ekr.20060211104746.68"><vh>onTreeClick</vh></v>
</v>
<v t="ekr.20060211104746.69"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060211104746.70"><vh>setInputState is messing with body focus</vh>
<v t="ekr.20060211104746.71"><vh>Tk bindings...</vh></v>
<v t="ekr.20060211104746.72"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060211104746.73"><vh>setInputState</vh></v>
<v t="ekr.20060211104746.74"><vh>showStateAndMode</vh></v>
</v>
<v t="ekr.20060211104746.75"><vh>Fixed focus-after-find bugs</vh>
<v t="ekr.20060211104746.76"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20060211104746.77"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20060211104746.78"><vh>c.bringToFront</vh></v>
<v t="ekr.20060211104746.72"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060211104746.79"><vh>c.invalidateFocus</vh></v>
<v t="ekr.20060211104746.80"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20060211104746.81"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20060211104746.82"><vh>c.recolor_now</vh></v>
<v t="ekr.20060211104746.83"><vh>c.redraw_now</vh></v>
<v t="ekr.20060211104746.84"><vh>c.restoreFocus</vh></v>
<v t="ekr.20060211104746.85"><vh>c.traceFocus</vh></v>
<v t="ekr.20060211104746.86"><vh>c.widget_name</vh></v>
<v t="ekr.20060211104746.87"><vh>c.xWantsFocus</vh></v>
<v t="ekr.20060211104746.88"><vh>c.xWantsFocusNow</vh></v>
</v>
<v t="ekr.20060211104746.89"><vh>Tab (TkLog)</vh>
<v t="ekr.20060211104746.90"><vh>clearTab</vh></v>
<v t="ekr.20060211104746.91"><vh>createTab</vh>
<v t="ekr.20060211104746.92"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.93"><vh>deleteTab</vh></v>
<v t="ekr.20060211104746.94"><vh>hideTab</vh></v>
<v t="ekr.20060211104746.95"><vh>getSelectedTab</vh></v>
<v t="ekr.20060211104746.96"><vh>lower/raiseTab</vh></v>
<v t="ekr.20060211104746.97"><vh>renameTab</vh></v>
<v t="ekr.20060211104746.98"><vh>selectTab</vh></v>
<v t="ekr.20060211104746.99"><vh>setTabBindings</vh></v>
<v t="ekr.20060211104746.100"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20060211104746.101"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20060211104746.102"><vh>newTabFromMenu</vh></v>
<v t="ekr.20060211104746.103"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20060211104746.104"><vh>getTabName</vh></v>
</v>
</v>
<v t="ekr.20060211104746.105"><vh>tree.select</vh>
<v t="ekr.20060211104746.106"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20060211104746.107"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20060211104746.108"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20060211104746.109"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20060211104746.110"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.69"><vh>set_focus (app.gui)</vh></v>
<v t="ekr.20060211104746.111"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20060211104746.112"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20060211104746.113"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20060211104746.114"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20060211104746.115"><vh>Dialog</vh>
<v t="ekr.20060211104746.116"><vh>get_window_info</vh></v>
<v t="ekr.20060211104746.117"><vh>center_dialog</vh></v>
<v t="ekr.20060211104746.118"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20060211104746.119"><vh>Focus</vh>
<v t="ekr.20060211104746.120"><vh>get_focus</vh></v>
<v t="ekr.20060211104746.69"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060211104746.121"><vh>Font</vh>
<v t="ekr.20060211104746.122"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20060211104746.123"><vh>Icons</vh>
<v t="ekr.20060211104746.124"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20060211104746.125"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20060211104746.126"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20060211104746.127"><vh>Idle Time</vh>
<v t="ekr.20060211104746.128"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20060211104746.129"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20060211104746.130"><vh>Indices (Tk)</vh>
<v t="ekr.20060211104746.131"><vh>firstIndex</vh></v>
<v t="ekr.20060211104746.132"><vh>lastIndex</vh></v>
<v t="ekr.20060211104746.133"><vh>moveIndexBackward</vh></v>
<v t="ekr.20060211104746.134"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20060211104746.135"><vh>compareIndices</vh></v>
<v t="ekr.20060211104746.136"><vh>getindex</vh></v>
</v>
<v t="ekr.20060211104746.137"><vh>Insert Point</vh>
<v t="ekr.20060211104746.138"><vh>getInsertPoint</vh></v>
<v t="ekr.20060211104746.139"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20060211104746.140"><vh>Selection</vh>
<v t="ekr.20060211104746.141"><vh>getSelectionRange</vh></v>
<v t="ekr.20060211104746.142"><vh>getSelectedText</vh></v>
<v t="ekr.20060211104746.143"><vh>getTextSelection</vh></v>
<v t="ekr.20060211104746.144"><vh>hasSelection</vh></v>
<v t="ekr.20060211104746.145"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20060211104746.146"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060211104746.147"><vh>Text</vh>
<v t="ekr.20060211104746.148"><vh>getAllText</vh></v>
<v t="ekr.20060211104746.149"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20060211104746.150"><vh>getCharAtIndex</vh></v>
<v t="ekr.20060211104746.151"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20060211104746.152"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20060211104746.153"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20060211104746.154"><vh>Visibility</vh>
<v t="ekr.20060211104746.155"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20060211104746.156"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060211104746.157"><vh>bringToFront</vh></v>
<v t="ekr.20060211104746.158"><vh>restore</vh></v>
<v t="ekr.20060211104746.159"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20060211104746.160"><vh>Fixed recent blunder so click in headline works</vh>
<v t="ekr.20060211104746.6"><vh>editLabel</vh></v>
<v t="ekr.20060211104746.161"><vh>setEditLabelState</vh></v>
<v t="ekr.20060211104746.53"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20060211104746.54"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.58"><vh>onHeadlineClick</vh></v>
</v>
<v t="ekr.20060211104746.162"><vh>Fixed tree icon bug</vh>
<v t="ekr.20060211104746.163"><vh>Notes</vh></v>
<v t="ekr.20060211104746.164"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20060211104746.165"><vh>removeTrailingNewlines</vh></v>
<v t="ekr.20060211104746.166"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20060211104746.167"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060211104746.168"><vh>Added unit tests for key dicts</vh></v>
<v t="ekr.20060211104746.169"><vh>Improved restore-focus logic when updating status line</vh>
<v t="ekr.20060211104746.170"><vh> doCommand</vh></v>
<v t="ekr.20060211104746.76"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20060211104746.77"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20060211104746.78"><vh>c.bringToFront</vh></v>
<v t="ekr.20060211104746.72"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060211104746.79"><vh>c.invalidateFocus</vh></v>
<v t="ekr.20060211104746.80"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20060211104746.81"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20060211104746.82"><vh>c.recolor_now</vh></v>
<v t="ekr.20060211104746.83"><vh>c.redraw_now</vh></v>
<v t="ekr.20060211104746.84"><vh>c.restoreFocus</vh></v>
<v t="ekr.20060211104746.85"><vh>c.traceFocus</vh></v>
<v t="ekr.20060211104746.86"><vh>c.widget_name</vh></v>
<v t="ekr.20060211104746.87"><vh>c.xWantsFocus</vh></v>
<v t="ekr.20060211104746.88"><vh>c.xWantsFocusNow</vh></v>
</v>
<v t="ekr.20060211104746.74"><vh>showStateAndMode</vh></v>
<v t="ekr.20060211104746.84"><vh>c.restoreFocus</vh></v>
</v>
<v t="ekr.20060211104746.171"><vh>Fixed problem with 'spelling' of menu bindings</vh>
<v t="ekr.20060211104746.172"><vh>k.prettyPrintKey</vh></v>
<v t="ekr.20060211104746.173"><vh>createMenuEntries</vh>
<v t="ekr.20060211104746.174"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20060211104746.175"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20060211104746.176"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060211104746.177"><vh>Set remembered column properly in prev-line and next-line</vh>
<v t="ekr.20060211104746.178"><vh>Report</vh></v>
<v t="ekr.20060211104746.179"><vh>masterClickHandler</vh></v>
<v t="ekr.20060211104746.180"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060211104746.181"><vh>moveToHelper</vh></v>
<v t="ekr.20060211104746.182"><vh>extendHelper</vh></v>
<v t="ekr.20060211104746.183"><vh>setMoveCol</vh></v>
<v t="ekr.20060211104746.184"><vh>move... (leoEditCommands)</vh>
<v t="ekr.20060211104746.185"><vh> helpers</vh>
<v t="ekr.20060211104746.182"><vh>extendHelper</vh></v>
<v t="ekr.20060211104746.180"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060211104746.181"><vh>moveToHelper</vh></v>
<v t="ekr.20060211104746.186"><vh>moveWordHelper</vh></v>
<v t="ekr.20060211104746.187"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060211104746.188"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060211104746.189"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060211104746.190"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060211104746.191"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20060211104746.183"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20060211104746.192"><vh>exchangePointMark</vh></v>
<v t="ekr.20060211104746.193"><vh>extendMode</vh></v>
<v t="ekr.20060211104746.194"><vh>buffers</vh></v>
<v t="ekr.20060211104746.195"><vh>characters</vh></v>
<v t="ekr.20060211104746.196"><vh>lines</vh></v>
<v t="ekr.20060211104746.197"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060211104746.198"><vh>paragraphs</vh></v>
<v t="ekr.20060211104746.199"><vh>sentences</vh></v>
<v t="ekr.20060211104746.200"><vh>words</vh></v>
</v>
</v>
<v t="ekr.20060211104746.201"><vh>Fixed bug in k.shortcutFromSetting</vh>
<v t="ekr.20060211104746.202"><vh>shortcutFromSetting</vh>
<v t="ekr.20060211104746.203"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20060211104746.204"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20060211104746.205"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20060211104746.206"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060211104746.207"><vh>Fixed vim plugin &amp; openWith</vh></v>
<v t="ekr.20060211104746.208"><vh>Fixed focus problems in spell tab</vh></v>
<v t="ekr.20060211104746.209"><vh>Don't abort the minibuffer if the command does not exist</vh>
<v t="ekr.20060211104746.210"><vh>callAltXFunction</vh></v>
<v t="ekr.20060211104746.211"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060211104746.210"><vh>callAltXFunction</vh></v>
</v>
</v>
<v t="ekr.20060211104746.212"><vh>Restored tree.onTreeClick</vh></v>
<v t="ekr.20060211104746.213"><vh>Added expand/contract/hide-pane/fully-expand commands</vh>
<v t="ekr.20060211104746.214"><vh>class editCommandsClass</vh>
<v t="ekr.20060211104746.215"><vh> birth</vh>
<v t="ekr.20060211104746.216"><vh> ctor (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.217"><vh> getPublicCommands (editCommandsClass)</vh></v>
</v>
<v t="ekr.20060211104746.218"><vh>capitalization &amp; case</vh>
<v t="ekr.20060211104746.219"><vh>capitalizeWord &amp; up/downCaseWord</vh></v>
<v t="ekr.20060211104746.220"><vh>changePreviousWord</vh></v>
<v t="ekr.20060211104746.221"><vh>capitalizeHelper</vh></v>
</v>
<v t="ekr.20060211104746.222" a="M"><vh>clicks and focus (editCommandsClass)</vh>
<v t="ekr.20060211104746.223"><vh>activate-x-menu &amp; activateMenu (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.224"><vh>cycleFocus</vh></v>
<v t="ekr.20060211104746.225"><vh>focusTo...</vh></v>
<v t="ekr.20060211104746.226"><vh>clicks in the headline</vh></v>
<v t="ekr.20060211104746.227"><vh>clicks in the icon box</vh></v>
<v t="ekr.20060211104746.228"><vh>clickClickBox</vh></v>
<v t="ekr.20060211104746.229"><vh>simulate...Drag</vh></v>
</v>
<v t="ekr.20060211104746.230"><vh>color &amp; font</vh>
<v t="ekr.20060211104746.231"><vh>show-colors</vh>
<v t="ekr.20060211104746.232"><vh>&lt;&lt; define colors &gt;&gt;</vh></v>
<v t="ekr.20060211104746.233"><vh>createColorPicker</vh>
<v t="ekr.20060211104746.234"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20060211104746.235"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060211104746.236"><vh>show-fonts &amp; helpers</vh>
<v t="ekr.20060211104746.237"><vh>createFontPicker</vh>
<v t="ekr.20060211104746.238"><vh>&lt;&lt; create the frames &gt;&gt;</vh></v>
<v t="ekr.20060211104746.239"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20060211104746.240"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20060211104746.241"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20060211104746.242"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20060211104746.243"><vh>&lt;&lt; create the sample text widget &gt;&gt;</vh></v>
<v t="ekr.20060211104746.244"><vh>&lt;&lt; create and bind the callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.245"><vh>getFont</vh></v>
<v t="ekr.20060211104746.246"><vh>setFont</vh></v>
</v>
</v>
<v t="ekr.20060211104746.247"><vh>comment column...</vh>
<v t="ekr.20060211104746.248"><vh>setCommentColumn</vh></v>
<v t="ekr.20060211104746.249"><vh>indentToCommentColumn</vh></v>
</v>
<v t="ekr.20060211104746.250"><vh>dynamic abbreviation...</vh>
<v t="ekr.20060211104746.251"><vh>dynamicExpansion</vh></v>
<v t="ekr.20060211104746.252"><vh>dynamicExpansion2</vh></v>
<v t="ekr.20060211104746.253"><vh>getDynamicList (helper)</vh></v>
</v>
<v t="ekr.20060211104746.254"><vh>esc methods for Python evaluation</vh>
<v t="ekr.20060211104746.255"><vh>watchEscape (Revise)</vh></v>
<v t="ekr.20060211104746.256"><vh>escEvaluate (Revise)</vh></v>
</v>
<v t="ekr.20060211104746.257"><vh>evalExpression</vh></v>
<v t="ekr.20060211104746.258"><vh>fill column and centering</vh>
<v t="ekr.20060211104746.259"><vh>centerLine</vh></v>
<v t="ekr.20060211104746.260"><vh>setFillColumn</vh></v>
<v t="ekr.20060211104746.261"><vh>centerRegion</vh></v>
<v t="ekr.20060211104746.262"><vh>setFillPrefix</vh></v>
<v t="ekr.20060211104746.263"><vh>_addPrefix</vh></v>
</v>
<v t="ekr.20060211104746.264"><vh>goto...</vh>
<v t="ekr.20060211104746.265"><vh>gotoCharacter</vh></v>
<v t="ekr.20060211104746.266"><vh>gotoLine</vh></v>
</v>
<v t="ekr.20060211104746.267"><vh>indent... (To do: undo)</vh>
<v t="ekr.20060211104746.268"><vh>backToIndentation</vh></v>
<v t="ekr.20060211104746.269"><vh>deleteIndentation</vh></v>
<v t="ekr.20060211104746.270"><vh>insertNewLineIndent</vh></v>
<v t="ekr.20060211104746.271"><vh>indentRelative</vh></v>
</v>
<v t="ekr.20060211104746.272"><vh>insert &amp; delete...</vh>
<v t="ekr.20060211104746.273"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20060211104746.274"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.275"><vh>deleteNextChar</vh></v>
<v t="ekr.20060211104746.276"><vh>deleteSpaces</vh></v>
<v t="ekr.20060211104746.277"><vh>removeBlankLines</vh></v>
<v t="ekr.20060211104746.278"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20060211104746.279"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20060211104746.280"><vh>insertParentheses</vh></v>
<v t="ekr.20060211104746.281"><vh>selfInsertCommand</vh>
<v t="ekr.20060211104746.282"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060211104746.283"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060211104746.284"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060211104746.285"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060211104746.286"><vh>info...</vh>
<v t="ekr.20060211104746.287"><vh>howMany</vh></v>
<v t="ekr.20060211104746.288"><vh>lineNumber</vh></v>
<v t="ekr.20060211104746.289"><vh>viewLossage</vh></v>
<v t="ekr.20060211104746.290"><vh>whatLine</vh></v>
</v>
<v t="ekr.20060211104746.291"><vh>line...</vh>
<v t="ekr.20060211104746.292"><vh>flushLines</vh></v>
<v t="ekr.20060211104746.293"><vh>keepLines</vh></v>
<v t="ekr.20060211104746.294"><vh>linesHelper</vh></v>
</v>
<v t="ekr.20060211104746.295"><vh>measure</vh></v>
<v t="ekr.20060211104746.184"><vh>move... (leoEditCommands)</vh>
<v t="ekr.20060211104746.185"><vh> helpers</vh>
<v t="ekr.20060211104746.182"><vh>extendHelper</vh></v>
<v t="ekr.20060211104746.180"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060211104746.181"><vh>moveToHelper</vh></v>
<v t="ekr.20060211104746.186"><vh>moveWordHelper</vh></v>
<v t="ekr.20060211104746.187"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060211104746.188"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060211104746.189"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060211104746.190"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060211104746.191"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20060211104746.183"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20060211104746.192"><vh>exchangePointMark</vh></v>
<v t="ekr.20060211104746.193"><vh>extendMode</vh></v>
<v t="ekr.20060211104746.194"><vh>buffers</vh></v>
<v t="ekr.20060211104746.195"><vh>characters</vh></v>
<v t="ekr.20060211104746.196"><vh>lines</vh></v>
<v t="ekr.20060211104746.197"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060211104746.198"><vh>paragraphs</vh></v>
<v t="ekr.20060211104746.199"><vh>sentences</vh></v>
<v t="ekr.20060211104746.200"><vh>words</vh></v>
</v>
<v t="ekr.20060211104746.296"><vh>paragraph...</vh>
<v t="ekr.20060211104746.297"><vh>backwardKillParagraph</vh></v>
<v t="ekr.20060211104746.298"><vh>fillParagraph</vh></v>
<v t="ekr.20060211104746.299"><vh>fillRegion</vh></v>
<v t="ekr.20060211104746.300"><vh>fillRegionAsParagraph</vh></v>
<v t="ekr.20060211104746.301"><vh>killParagraph (Test)</vh></v>
<v t="ekr.20060211104746.302"><vh>selectParagraph &amp; helper</vh>
<v t="ekr.20060211104746.303"><vh>selectParagraphHelper</vh></v>
</v>
</v>
<v t="ekr.20060211104746.304"><vh>region...</vh>
<v t="ekr.20060211104746.305"><vh>setRegion</vh>
<v t="ekr.20060211104746.306"><vh>down</vh></v>
<v t="ekr.20060211104746.307"><vh>extend</vh></v>
<v t="ekr.20060211104746.308"><vh>truncate</vh></v>
<v t="ekr.20060211104746.309"><vh>up</vh></v>
</v>
<v t="ekr.20060211104746.310"><vh>indentRegion</vh></v>
<v t="ekr.20060211104746.311"><vh>tabIndentRegion</vh></v>
<v t="ekr.20060211104746.312"><vh>countRegion</vh></v>
<v t="ekr.20060211104746.313"><vh>reverseRegion</vh></v>
<v t="ekr.20060211104746.314"><vh>up/downCaseRegion &amp; helper</vh></v>
</v>
<v t="ekr.20060211104746.315"><vh>scrollUp/Down/extendSelection</vh>
<v t="ekr.20060211104746.316"><vh>scrollHelper</vh></v>
</v>
<v t="ekr.20060211104746.317"><vh>sort...</vh>
<v t="ekr.20060211104746.318"><vh>sortLines</vh></v>
<v t="ekr.20060211104746.319"><vh>sortColumns</vh></v>
<v t="ekr.20060211104746.320"><vh>sortFields</vh></v>
</v>
<v t="ekr.20060211104746.321"><vh>swap/transpose...</vh>
<v t="ekr.20060211104746.322"><vh>transposeLines</vh></v>
<v t="ekr.20060211104746.323"><vh>swapWords &amp; transposeWords</vh></v>
<v t="ekr.20060211104746.324"><vh>swapCharacters &amp; transeposeCharacters</vh></v>
</v>
<v t="ekr.20060211104746.325"><vh>tabify &amp; untabify</vh></v>
</v>
<v t="ekr.20060211104746.76"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20060211104746.77"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20060211104746.78"><vh>c.bringToFront</vh></v>
<v t="ekr.20060211104746.72"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060211104746.79"><vh>c.invalidateFocus</vh></v>
<v t="ekr.20060211104746.80"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20060211104746.81"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20060211104746.82"><vh>c.recolor_now</vh></v>
<v t="ekr.20060211104746.83"><vh>c.redraw_now</vh></v>
<v t="ekr.20060211104746.84"><vh>c.restoreFocus</vh></v>
<v t="ekr.20060211104746.85"><vh>c.traceFocus</vh></v>
<v t="ekr.20060211104746.86"><vh>c.widget_name</vh></v>
<v t="ekr.20060211104746.87"><vh>c.xWantsFocus</vh></v>
<v t="ekr.20060211104746.88"><vh>c.xWantsFocusNow</vh></v>
</v>
<v t="ekr.20060211104746.326"><vh>Event handlers (tkFrame)</vh>
<v t="ekr.20060211104746.327"><vh>frame.OnCloseLeoEvent</vh></v>
<v t="ekr.20060211104746.328"><vh>frame.OnControlKeyUp/Down</vh></v>
<v t="ekr.20060211104746.329"><vh>OnActivateBody (tkFrame)</vh></v>
<v t="ekr.20060211104746.330"><vh>OnActivateLeoEvent, OnDeactivateLeoEvent</vh></v>
<v t="ekr.20060211104746.331"><vh>OnActivateTree</vh></v>
<v t="ekr.20060211104746.332"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="ekr.20060211104746.333"><vh>OnBodyDoubleClick (Events)</vh></v>
<v t="ekr.20060211104746.334"><vh>OnMouseWheel (Tomaz Ficko)</vh></v>
</v>
<v t="ekr.20060211104746.335"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20060211104746.336"><vh>Minibuffer commands... (tkFrame)</vh>
<v t="ekr.20060211104746.337"><vh>contractPane</vh></v>
<v t="ekr.20060211104746.338"><vh>expandPane</vh></v>
<v t="ekr.20060211104746.339"><vh>fullyExpandPane</vh></v>
<v t="ekr.20060211104746.340"><vh>hidePane</vh></v>
<v t="ekr.20060211104746.341"><vh>expand/contract/hide...Pane</vh></v>
<v t="ekr.20060211104746.342"><vh>fullyExpand/hide...Pane</vh></v>
</v>
<v t="ekr.20060211104746.179"><vh>masterClickHandler</vh></v>
</v>
<v t="ekr.20060211104746.343"><vh>clicks now clear selection</vh></v>
<v t="ekr.20060211104746.344"><vh>Special-cased select-all-text in headlines</vh>
<v t="ekr.20060211104746.345"><vh>selectAllText</vh></v>
</v>
<v t="ekr.20060211104746.346"><vh>Special-cased commands for minibuffer</vh>
<v t="ekr.20060211104746.347"><vh>getEditableTextRange</vh></v>
<v t="ekr.20060211104746.111"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20060211104746.112"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20060211104746.113"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20060211104746.114"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20060211104746.115"><vh>Dialog</vh>
<v t="ekr.20060211104746.116"><vh>get_window_info</vh></v>
<v t="ekr.20060211104746.117"><vh>center_dialog</vh></v>
<v t="ekr.20060211104746.118"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20060211104746.119"><vh>Focus</vh>
<v t="ekr.20060211104746.120"><vh>get_focus</vh></v>
<v t="ekr.20060211104746.69"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060211104746.121"><vh>Font</vh>
<v t="ekr.20060211104746.122"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20060211104746.123"><vh>Icons</vh>
<v t="ekr.20060211104746.124"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20060211104746.125"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20060211104746.126"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20060211104746.127"><vh>Idle Time</vh>
<v t="ekr.20060211104746.128"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20060211104746.129"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20060211104746.130"><vh>Indices (Tk)</vh>
<v t="ekr.20060211104746.131"><vh>firstIndex</vh></v>
<v t="ekr.20060211104746.132"><vh>lastIndex</vh></v>
<v t="ekr.20060211104746.133"><vh>moveIndexBackward</vh></v>
<v t="ekr.20060211104746.134"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20060211104746.135"><vh>compareIndices</vh></v>
<v t="ekr.20060211104746.136"><vh>getindex</vh></v>
</v>
<v t="ekr.20060211104746.137"><vh>Insert Point</vh>
<v t="ekr.20060211104746.138"><vh>getInsertPoint</vh></v>
<v t="ekr.20060211104746.139"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20060211104746.140"><vh>Selection</vh>
<v t="ekr.20060211104746.141"><vh>getSelectionRange</vh></v>
<v t="ekr.20060211104746.142"><vh>getSelectedText</vh></v>
<v t="ekr.20060211104746.143"><vh>getTextSelection</vh></v>
<v t="ekr.20060211104746.144"><vh>hasSelection</vh></v>
<v t="ekr.20060211104746.145"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20060211104746.146"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060211104746.147"><vh>Text</vh>
<v t="ekr.20060211104746.148"><vh>getAllText</vh></v>
<v t="ekr.20060211104746.149"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20060211104746.150"><vh>getCharAtIndex</vh></v>
<v t="ekr.20060211104746.151"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20060211104746.152"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20060211104746.153"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20060211104746.154"><vh>Visibility</vh>
<v t="ekr.20060211104746.155"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20060211104746.156"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060211104746.345"><vh>selectAllText</vh></v>
<v t="ekr.20060211104746.348"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060211104746.349"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20060211104746.181"><vh>moveToHelper</vh></v>
</v>
<v t="ekr.20060211104746.350"><vh>Copy find text into minibuffer for search commands</vh>
<v t="ekr.20060211104746.111"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20060211104746.112"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20060211104746.113"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20060211104746.114"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20060211104746.115"><vh>Dialog</vh>
<v t="ekr.20060211104746.116"><vh>get_window_info</vh></v>
<v t="ekr.20060211104746.117"><vh>center_dialog</vh></v>
<v t="ekr.20060211104746.118"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20060211104746.119"><vh>Focus</vh>
<v t="ekr.20060211104746.120"><vh>get_focus</vh></v>
<v t="ekr.20060211104746.69"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060211104746.121"><vh>Font</vh>
<v t="ekr.20060211104746.122"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20060211104746.123"><vh>Icons</vh>
<v t="ekr.20060211104746.124"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20060211104746.125"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20060211104746.126"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20060211104746.127"><vh>Idle Time</vh>
<v t="ekr.20060211104746.128"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20060211104746.129"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20060211104746.130"><vh>Indices (Tk)</vh>
<v t="ekr.20060211104746.131"><vh>firstIndex</vh></v>
<v t="ekr.20060211104746.132"><vh>lastIndex</vh></v>
<v t="ekr.20060211104746.133"><vh>moveIndexBackward</vh></v>
<v t="ekr.20060211104746.134"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20060211104746.135"><vh>compareIndices</vh></v>
<v t="ekr.20060211104746.136"><vh>getindex</vh></v>
</v>
<v t="ekr.20060211104746.137"><vh>Insert Point</vh>
<v t="ekr.20060211104746.138"><vh>getInsertPoint</vh></v>
<v t="ekr.20060211104746.139"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20060211104746.140"><vh>Selection</vh>
<v t="ekr.20060211104746.141"><vh>getSelectionRange</vh></v>
<v t="ekr.20060211104746.142"><vh>getSelectedText</vh></v>
<v t="ekr.20060211104746.143"><vh>getTextSelection</vh></v>
<v t="ekr.20060211104746.144"><vh>hasSelection</vh></v>
<v t="ekr.20060211104746.145"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20060211104746.146"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060211104746.147"><vh>Text</vh>
<v t="ekr.20060211104746.148"><vh>getAllText</vh></v>
<v t="ekr.20060211104746.149"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20060211104746.150"><vh>getCharAtIndex</vh></v>
<v t="ekr.20060211104746.151"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20060211104746.152"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20060211104746.153"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20060211104746.154"><vh>Visibility</vh>
<v t="ekr.20060211104746.155"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20060211104746.156"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060211104746.351"><vh>From keyHandler</vh>
<v t="ekr.20060211104746.348"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060211104746.349"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20060211104746.352"><vh>Label...</vh>
<v t="ekr.20060211104746.353"><vh>k.minibufferWantsFocus/Now</vh></v>
<v t="ekr.20060211104746.354"><vh>getLabel</vh></v>
<v t="ekr.20060211104746.355"><vh>protectLabel</vh></v>
<v t="ekr.20060211104746.356"><vh>resetLabel</vh></v>
<v t="ekr.20060211104746.357"><vh>setLabel</vh></v>
<v t="ekr.20060211104746.358"><vh>extendLabel</vh></v>
<v t="ekr.20060211104746.359"><vh>setLabelBlue</vh></v>
<v t="ekr.20060211104746.360"><vh>setLabelGrey</vh></v>
<v t="ekr.20060211104746.361"><vh>updateLabel</vh></v>
<v t="ekr.20060211104746.347"><vh>getEditableTextRange</vh></v>
</v>
<v t="ekr.20060211104746.347"><vh>getEditableTextRange</vh></v>
<v t="ekr.20060211104746.362"><vh>getArg</vh>
<v t="ekr.20060211104746.363"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.358"><vh>extendLabel</vh></v>
<v t="ekr.20060211104746.361"><vh>updateLabel</vh></v>
<v t="ekr.20060211104746.364"><vh>doBackSpace</vh></v>
<v t="ekr.20060211104746.365"><vh>doTabCompletion</vh></v>
</v>
<v t="ekr.20060211104746.366"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20060211104746.367"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20060211104746.368"><vh>Search classes</vh>
<v t="ekr.20060211104746.369"><vh>class minibufferFind (the findHandler)</vh>
<v t="ekr.20060211104746.370"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20060211104746.371"><vh> Options</vh>
<v t="ekr.20060211104746.372"><vh>setFindScope</vh></v>
<v t="ekr.20060211104746.373"><vh>setOption</vh></v>
<v t="ekr.20060211104746.374"><vh>getOption</vh></v>
<v t="ekr.20060211104746.375"><vh>showFindOptions</vh></v>
<v t="ekr.20060211104746.376"><vh>toggleOption</vh></v>
<v t="ekr.20060211104746.377"><vh>setupChangePattern</vh></v>
<v t="ekr.20060211104746.378"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20060211104746.367"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20060211104746.379"><vh>addChangeStringToLabel</vh></v>
<v t="ekr.20060211104746.380"><vh> setupArgs</vh></v>
<v t="ekr.20060211104746.381"><vh>findAll</vh></v>
<v t="ekr.20060211104746.382"><vh>cloneFindAll</vh></v>
<v t="ekr.20060211104746.383"><vh>findAgain</vh></v>
<v t="ekr.20060211104746.384"><vh>stateZeroHelper</vh></v>
<v t="ekr.20060211104746.385"><vh>lastStateHelper</vh></v>
<v t="ekr.20060211104746.386"><vh>generalChangeHelper</vh></v>
<v t="ekr.20060211104746.387"><vh>generalSearchHelper</vh></v>
<v t="ekr.20060211104746.388"><vh>replaceString</vh></v>
<v t="ekr.20060211104746.389"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20060211104746.390"><vh>seachForward/Backward</vh></v>
<v t="ekr.20060211104746.366"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20060211104746.391"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20060211104746.392"><vh>class findTab (leoFind.leoFind)</vh>
<v t="ekr.20060211104746.393"><vh>Birth &amp; death</vh>
<v t="ekr.20060211104746.394"><vh>__init__</vh>
<v t="ekr.20060211104746.395"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.396"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20060211104746.397"><vh>createFrame (findTab)</vh>
<v t="ekr.20060211104746.398"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20060211104746.399"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20060211104746.400"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.401"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20060211104746.402"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.403"><vh>find.init</vh>
<v t="ekr.20060211104746.404"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20060211104746.405"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060211104746.406"><vh>find.update_ivars</vh></v>
<v t="ekr.20060211104746.407"><vh>findButtonCallback</vh></v>
<v t="ekr.20060211104746.408"><vh> Top level</vh>
<v t="ekr.20060211104746.409"><vh>findAllCommand</vh></v>
<v t="ekr.20060211104746.410"><vh>findAgainCommand</vh></v>
<v t="ekr.20060211104746.411"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20060211104746.412"><vh>findNext/PrefCommand</vh></v>
<v t="ekr.20060211104746.413"><vh>change/ThenFindCommand</vh></v>
</v>
<v t="ekr.20060211104746.414"><vh>hideTab</vh></v>
<v t="ekr.20060211104746.415"><vh>bringToFront</vh></v>
<v t="ekr.20060211104746.416"><vh>selectAllFindText</vh></v>
<v t="ekr.20060211104746.417"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20060211104746.418"><vh>class underlinedTkButton</vh>
<v t="ekr.20060211104746.419"><vh>__init__</vh>
<v t="ekr.20060211104746.420"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.421"><vh>bindHotKey</vh></v>
<v t="ekr.20060211104746.422"><vh>buttonCallback</vh></v>
</v>
</v>
<v t="ekr.20060211104746.423"><vh>class searchCommandsClass</vh>
<v t="ekr.20060211104746.424"><vh> ctor</vh></v>
<v t="ekr.20060211104746.425"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20060211104746.426"><vh>Top-level methods</vh>
<v t="ekr.20060211104746.427"><vh>openFindTab</vh></v>
<v t="ekr.20060211104746.428"><vh>Find Tab commands</vh></v>
<v t="ekr.20060211104746.429"><vh>getHandler</vh></v>
<v t="ekr.20060211104746.430"><vh>Find options wrappers</vh></v>
<v t="ekr.20060211104746.431"><vh>Find wrappers</vh></v>
<v t="ekr.20060211104746.432"><vh>findAgain</vh></v>
</v>
<v t="ekr.20060211104746.433"><vh>incremental search...</vh>
<v t="ekr.20060211104746.434"><vh>startIncremental</vh></v>
<v t="ekr.20060211104746.435"><vh>iSearchStateHandler &amp; helper</vh></v>
<v t="ekr.20060211104746.436"><vh>scolorizer</vh></v>
<v t="ekr.20060211104746.437"><vh>iSearchHelper</vh></v>
<v t="ekr.20060211104746.438"><vh>endSearch</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060211104746.439"><vh>Added commands to simulate clicks</vh>
<v t="ekr.20060211104746.440"><vh>What I did</vh></v>
<v t="ekr.20060211104746.217"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.441"><vh>Tree event handlers that trigger hooks</vh>
<v t="ekr.20060211104746.49"><vh>Icon Box...</vh>
<v t="ekr.20060211104746.50"><vh>onIconBoxClick</vh></v>
<v t="ekr.20060211104746.51"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20060211104746.52"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20060211104746.36"><vh>onClickBoxClick</vh></v>
<v t="ekr.20060211104746.37"><vh>Dragging</vh>
<v t="ekr.20060211104746.38"><vh>endDrag</vh>
<v t="ekr.20060211104746.39"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20060211104746.40"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.41"><vh>startDrag</vh></v>
<v t="ekr.20060211104746.42"><vh>onContinueDrag</vh>
<v t="ekr.20060211104746.43"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.44"><vh>onDrag</vh></v>
<v t="ekr.20060211104746.45"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20060211104746.58"><vh>onHeadlineClick</vh></v>
<v t="ekr.20060211104746.59"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20060211104746.222" a="M"><vh>clicks and focus (editCommandsClass)</vh>
<v t="ekr.20060211104746.223"><vh>activate-x-menu &amp; activateMenu (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.224"><vh>cycleFocus</vh></v>
<v t="ekr.20060211104746.225"><vh>focusTo...</vh></v>
<v t="ekr.20060211104746.226"><vh>clicks in the headline</vh></v>
<v t="ekr.20060211104746.227"><vh>clicks in the icon box</vh></v>
<v t="ekr.20060211104746.228"><vh>clickClickBox</vh></v>
<v t="ekr.20060211104746.229"><vh>simulate...Drag</vh></v>
</v>
</v>
<v t="ekr.20060211104746.442"><vh>Clicks are now handled properly in the minibuffer</vh>
<v t="ekr.20060211104746.179"><vh>masterClickHandler</vh></v>
</v>
<v t="ekr.20060211104746.443"><vh>activate-xxx-menu commands</vh>
<v t="ekr.20060211104746.217"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.223"><vh>activate-x-menu &amp; activateMenu (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.444"><vh>tkMenu.activateMenu</vh></v>
<v t="ekr.20060211104746.445"><vh>tkMenu.computeMenuPositions</vh></v>
</v>
</v>
</v>
</v>
<v t="edream.110203163054.63"><vh>Latest version</vh>
<v t="ekr.20060206111508"><vh>4.4 beta 2</vh>
<v t="ekr.20060206111508.2"><vh>Bugs</vh>
<v t="ekr.20060206111508.3"><vh>Fixed crasher in Save button</vh></v>
<v t="ekr.20060206111508.4"><vh>Fixed minor bugs &amp; made minor improvements</vh>
<v t="ekr.20060206111508.5"><vh>Fixed two annoying headline glitches</vh>
<v t="ekr.20060206111508.6"><vh>tree.set...LabelState</vh>
<v t="ekr.20060206111508.7"><vh>setEditLabelState</vh></v>
<v t="ekr.20060206111508.8"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20060206111508.9"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20060206111508.10"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20060206111508.11"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20060206111508.12"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20060206111508.13"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060206111508.14"><vh>Insert headline didn't redraw headline properly in vim mode</vh>
<v t="ekr.20060206111508.15"><vh>printBindings</vh></v>
<v t="ekr.20060206111508.16"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060206111508.17"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060206111508.18"><vh>callStateFunction</vh></v>
<v t="ekr.20060206111508.19"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060206111508.20"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060206111508.21"><vh>head key handlers</vh>
<v t="ekr.20060206111508.22"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060206111508.23"><vh>updateHead</vh></v>
<v t="ekr.20060206111508.24"><vh>onHeadChanged</vh>
<v t="ekr.20060206111508.25"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060206111508.26"><vh>Modes</vh>
<v t="ekr.20060206111508.27"><vh>badMode</vh></v>
<v t="ekr.20060206111508.28"><vh>createModeBindings</vh></v>
<v t="ekr.20060206111508.29"><vh>endMode</vh></v>
<v t="ekr.20060206111508.30"><vh>enterNamedMode</vh></v>
<v t="ekr.20060206111508.31"><vh>exitNamedMode</vh></v>
<v t="ekr.20060206111508.32"><vh>generalModeHandler</vh></v>
<v t="ekr.20060206111508.33"><vh>initMode</vh></v>
<v t="ekr.20060206111508.34"><vh>reinitMode</vh></v>
<v t="ekr.20060206111508.35"><vh>modeHelp</vh>
<v t="ekr.20060206111508.36"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060206111508.37"><vh>set-xxx-State</vh></v>
<v t="ekr.20060206111508.38"><vh>setInputState</vh></v>
<v t="ekr.20060206111508.39"><vh>showStateAndMode</vh></v>
</v>
</v>
<v t="ekr.20060206111508.40"><vh>Improved printBindings, printCommands &amp; modeHelp</vh>
<v t="ekr.20060206111508.41"><vh>Externally visible commands</vh>
<v t="ekr.20060206111508.42"><vh>digitArgument &amp; universalArgument</vh></v>
<v t="ekr.20060206111508.43"><vh>k.show/hide/toggleMinibuffer</vh></v>
<v t="ekr.20060206111508.44"><vh>negativeArgument (redo?)</vh></v>
<v t="ekr.20060206111508.45"><vh>numberCommand</vh></v>
<v t="ekr.20060206111508.15"><vh>printBindings</vh></v>
<v t="ekr.20060206111508.46"><vh>printCommands</vh></v>
<v t="ekr.20060206111508.47"><vh>repeatComplexCommand &amp; helper</vh></v>
</v>
<v t="ekr.20060206111508.15"><vh>printBindings</vh></v>
<v t="ekr.20060206111508.46"><vh>printCommands</vh></v>
<v t="ekr.20060206111508.36"><vh>modeHelpHelper</vh></v>
<v t="ekr.20060206111508.35"><vh>modeHelp</vh>
<v t="ekr.20060206111508.36"><vh>modeHelpHelper</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111508.48"><vh>Fixed crasher re BackSpace in log window</vh></v>
<v t="ekr.20060206111508.49"><vh>Fixed crashers in cut/copy/paste commands</vh>
<v t="ekr.20060206111508.50"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060206111508.51"><vh>copyText</vh></v>
<v t="ekr.20060206111508.52"><vh>cutText</vh></v>
<v t="ekr.20060206111508.53"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060206111508.54"><vh>Fixed crasher when clicking the close box during a long command</vh>
<v t="ekr.20060206111508.55"><vh>frame.OnCloseLeoEvent</vh></v>
<v t="ekr.20060206111508.56"><vh>app.closeLeoWindow</vh></v>
<v t="ekr.20060206111508.57"><vh> doCommand</vh></v>
</v>
<v t="ekr.20060206111508.58"><vh>cloneFindAll now honor present find settings</vh></v>
<v t="ekr.20060206111508.63"><vh>Double-click didn't work in the body pane.</vh></v>
<v t="ekr.20060206111508.74"><vh>Improved body.makeInsertPointVisible</vh></v>
<v t="ekr.20060206111508.75"><vh>Fixed cut/copy/paste from menu</vh></v>
<v t="ekr.20060206111508.553"><vh>Fixed major blunder: tree.onHeadChanged sets focus only if there was a real change</vh></v>
</v>
<v t="ekr.20060206112001"><vh>New commandes</vh>
<v t="ekr.20060206111508.545"><vh>Added free-text-widgets, dump-all-objects, dump-new-objects, verbose-dump-objects commands</vh></v>
<v t="ekr.20060206111508.546"><vh>Added gc_stats to print-stats command</vh></v>
</v>
<v t="ekr.20060206111853"><vh>New features</vh>
<v t="ekr.20060206111508.76"><vh>Made modes work</vh></v>
<v t="ekr.20060206111508.97"><vh>Disabled plain-key bindings in insert/overwrite modes</vh></v>
<v t="ekr.20060206111508.103"><vh>Disabled auto-scrolling in outline pane on clicks</vh></v>
<v t="ekr.20060206111508.136"><vh>move-outline and find commands force a screen scroll</vh></v>
<v t="ekr.20060206111508.517"><vh>(Improved gc stats)</vh></v>
<v t="ekr.20060206111508.138"><vh>(Limited undo)</vh></v>
</v>
<v t="ekr.20060206111508.547"><vh>Code issues</vh>
<v t="ekr.20060206111508.229"><vh>(Added event arg to all legacy commands)</vh></v>
<v t="ekr.20060206111508.548"><vh>Code cleanup</vh></v>
<v t="ekr.20060206111508.550"><vh>Removed code in c.begin/EndUpdate and c.endEditLabel that tried to save/restore focus</vh></v>
<v t="ekr.20060206111508.596"><vh>Improved tree allocation</vh></v>
</v>
<v t="ekr.20060206111508.620"><vh>What I did earlier</vh></v>
<v t="ekr.20060206111508.621"><vh>What I did: 2-4-06</vh></v>
<v t="ekr.20060206111508.622"><vh>What I did: 2-5-06</vh></v>
<v t="ekr.20060211104746.1"><vh>What I did: 2-6-05</vh></v>
<v t="ekr.20060211104746.2"><vh>Fixed undo problem in headlines</vh>
<v t="ekr.20060211104746.3"><vh>Notes</vh></v>
<v t="ekr.20060211104746.4"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20060211104746.5"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20060211104746.6"><vh>editLabel</vh></v>
<v t="ekr.20060211104746.7"><vh>onHeadChanged</vh>
<v t="ekr.20060211104746.8"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.9"><vh>undoNodeContents</vh></v>
<v t="ekr.20060211104746.10"><vh>redoNodeContents</vh></v>
<v t="ekr.20060211104746.11"><vh>tree.setHeadline (new in 4.4b2)</vh></v>
</v>
<v t="ekr.20060211104746.12"><vh>Created c.masterFocusHandler and made it work</vh>
<v t="ekr.20060211104746.13"><vh>What I did</vh></v>
<v t="ekr.20060211104746.14"><vh> Birth... (tkTree)</vh>
<v t="ekr.20060211104746.15"><vh>__init__ (tkTree)</vh>
<v t="ekr.20060211104746.16"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20060211104746.17"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20060211104746.18"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.19"><vh>tkTtree.setBindings</vh>
<v t="ekr.20060211104746.20"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
<v t="ekr.20060211104746.21"><vh>&lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.22"><vh>injectCallbacks</vh>
<v t="ekr.20060211104746.23"><vh>&lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;</vh>
<v t="ekr.20060211104746.24"><vh>OnHyperLinkControlClick</vh></v>
<v t="ekr.20060211104746.25"><vh>OnHyperLinkEnter</vh></v>
<v t="ekr.20060211104746.26"><vh>OnHyperLinkLeave</vh></v>
</v>
</v>
</v>
<v t="ekr.20060211104746.27"><vh>Event handlers (tkTree)</vh>
<v t="ekr.20060211104746.28"><vh>Helpers</vh>
<v t="ekr.20060211104746.29"><vh>checkWidgetList</vh></v>
<v t="ekr.20060211104746.30"><vh>dumpWidgetList</vh></v>
<v t="ekr.20060211104746.31"><vh>edit_widget</vh></v>
<v t="ekr.20060211104746.32"><vh>eventToPosition</vh></v>
<v t="ekr.20060211104746.33"><vh>findEditWidget</vh></v>
<v t="ekr.20060211104746.34"><vh>findVnodeWithIconId</vh></v>
</v>
<v t="ekr.20060211104746.35"><vh>Click Box...</vh>
<v t="ekr.20060211104746.36"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060211104746.37"><vh>Dragging</vh>
<v t="ekr.20060211104746.38"><vh>endDrag</vh>
<v t="ekr.20060211104746.39"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20060211104746.40"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.41"><vh>startDrag</vh></v>
<v t="ekr.20060211104746.42"><vh>onContinueDrag</vh>
<v t="ekr.20060211104746.43"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.44"><vh>onDrag</vh></v>
<v t="ekr.20060211104746.45"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20060211104746.46"><vh>head key handlers</vh>
<v t="ekr.20060211104746.47"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060211104746.48"><vh>updateHead</vh></v>
<v t="ekr.20060211104746.7"><vh>onHeadChanged</vh>
<v t="ekr.20060211104746.8"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060211104746.49"><vh>Icon Box...</vh>
<v t="ekr.20060211104746.50"><vh>onIconBoxClick</vh></v>
<v t="ekr.20060211104746.51"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20060211104746.52"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20060211104746.53"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20060211104746.54"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.55"><vh>Text Box...</vh>
<v t="ekr.20060211104746.56"><vh>configureTextState</vh></v>
<v t="ekr.20060211104746.57"><vh>onCtontrolT</vh></v>
<v t="ekr.20060211104746.58"><vh>onHeadlineClick</vh></v>
<v t="ekr.20060211104746.59"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20060211104746.60"><vh>tree.OnDeactivate</vh></v>
<v t="ekr.20060211104746.61"><vh>tree.OnPopup &amp; allies</vh>
<v t="ekr.20060211104746.62"><vh>OnPopupFocusLost</vh></v>
<v t="ekr.20060211104746.63"><vh>createPopupMenu</vh>
<v t="ekr.20060211104746.64"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.65"><vh>enablePopupMenuItems</vh>
<v t="ekr.20060211104746.66"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.67"><vh>showPopupMenu</vh></v>
</v>
<v t="ekr.20060211104746.68"><vh>onTreeClick</vh></v>
</v>
<v t="ekr.20060211104746.69"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060211104746.70"><vh>setInputState is messing with body focus</vh>
<v t="ekr.20060211104746.71"><vh>Tk bindings...</vh></v>
<v t="ekr.20060211104746.72"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060211104746.73"><vh>setInputState</vh></v>
<v t="ekr.20060211104746.74"><vh>showStateAndMode</vh></v>
</v>
<v t="ekr.20060211104746.75"><vh>Fixed focus-after-find bugs</vh>
<v t="ekr.20060211104746.76"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20060211104746.77"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20060211104746.78"><vh>c.bringToFront</vh></v>
<v t="ekr.20060211104746.72"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060211104746.79"><vh>c.invalidateFocus</vh></v>
<v t="ekr.20060211104746.80"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20060211104746.81"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20060211104746.82"><vh>c.recolor_now</vh></v>
<v t="ekr.20060211104746.83"><vh>c.redraw_now</vh></v>
<v t="ekr.20060211104746.84"><vh>c.restoreFocus</vh></v>
<v t="ekr.20060211104746.85"><vh>c.traceFocus</vh></v>
<v t="ekr.20060211104746.86"><vh>c.widget_name</vh></v>
<v t="ekr.20060211104746.87"><vh>c.xWantsFocus</vh></v>
<v t="ekr.20060211104746.88"><vh>c.xWantsFocusNow</vh></v>
</v>
<v t="ekr.20060211104746.89"><vh>Tab (TkLog)</vh>
<v t="ekr.20060211104746.90"><vh>clearTab</vh></v>
<v t="ekr.20060211104746.91"><vh>createTab</vh>
<v t="ekr.20060211104746.92"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.93"><vh>deleteTab</vh></v>
<v t="ekr.20060211104746.94"><vh>hideTab</vh></v>
<v t="ekr.20060211104746.95"><vh>getSelectedTab</vh></v>
<v t="ekr.20060211104746.96"><vh>lower/raiseTab</vh></v>
<v t="ekr.20060211104746.97"><vh>renameTab</vh></v>
<v t="ekr.20060211104746.98"><vh>selectTab</vh></v>
<v t="ekr.20060211104746.99"><vh>setTabBindings</vh></v>
<v t="ekr.20060211104746.100"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20060211104746.101"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20060211104746.102"><vh>newTabFromMenu</vh></v>
<v t="ekr.20060211104746.103"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20060211104746.104"><vh>getTabName</vh></v>
</v>
</v>
<v t="ekr.20060211104746.105"><vh>tree.select</vh>
<v t="ekr.20060211104746.106"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20060211104746.107"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20060211104746.108"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20060211104746.109"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20060211104746.110"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.69"><vh>set_focus (app.gui)</vh></v>
<v t="ekr.20060211104746.111"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20060211104746.112"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20060211104746.113"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20060211104746.114"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20060211104746.115"><vh>Dialog</vh>
<v t="ekr.20060211104746.116"><vh>get_window_info</vh></v>
<v t="ekr.20060211104746.117"><vh>center_dialog</vh></v>
<v t="ekr.20060211104746.118"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20060211104746.119"><vh>Focus</vh>
<v t="ekr.20060211104746.120"><vh>get_focus</vh></v>
<v t="ekr.20060211104746.69"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060211104746.121"><vh>Font</vh>
<v t="ekr.20060211104746.122"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20060211104746.123"><vh>Icons</vh>
<v t="ekr.20060211104746.124"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20060211104746.125"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20060211104746.126"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20060211104746.127"><vh>Idle Time</vh>
<v t="ekr.20060211104746.128"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20060211104746.129"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20060211104746.130"><vh>Indices (Tk)</vh>
<v t="ekr.20060211104746.131"><vh>firstIndex</vh></v>
<v t="ekr.20060211104746.132"><vh>lastIndex</vh></v>
<v t="ekr.20060211104746.133"><vh>moveIndexBackward</vh></v>
<v t="ekr.20060211104746.134"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20060211104746.135"><vh>compareIndices</vh></v>
<v t="ekr.20060211104746.136"><vh>getindex</vh></v>
</v>
<v t="ekr.20060211104746.137"><vh>Insert Point</vh>
<v t="ekr.20060211104746.138"><vh>getInsertPoint</vh></v>
<v t="ekr.20060211104746.139"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20060211104746.140"><vh>Selection</vh>
<v t="ekr.20060211104746.141"><vh>getSelectionRange</vh></v>
<v t="ekr.20060211104746.142"><vh>getSelectedText</vh></v>
<v t="ekr.20060211104746.143"><vh>getTextSelection</vh></v>
<v t="ekr.20060211104746.144"><vh>hasSelection</vh></v>
<v t="ekr.20060211104746.145"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20060211104746.146"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060211104746.147"><vh>Text</vh>
<v t="ekr.20060211104746.148"><vh>getAllText</vh></v>
<v t="ekr.20060211104746.149"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20060211104746.150"><vh>getCharAtIndex</vh></v>
<v t="ekr.20060211104746.151"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20060211104746.152"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20060211104746.153"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20060211104746.154"><vh>Visibility</vh>
<v t="ekr.20060211104746.155"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20060211104746.156"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060211104746.157"><vh>bringToFront</vh></v>
<v t="ekr.20060211104746.158"><vh>restore</vh></v>
<v t="ekr.20060211104746.159"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20060211104746.160"><vh>Fixed recent blunder so click in headline works</vh>
<v t="ekr.20060211104746.6"><vh>editLabel</vh></v>
<v t="ekr.20060211104746.161"><vh>setEditLabelState</vh></v>
<v t="ekr.20060211104746.53"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20060211104746.54"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.58"><vh>onHeadlineClick</vh></v>
</v>
<v t="ekr.20060211104746.162"><vh>Fixed tree icon bug</vh>
<v t="ekr.20060211104746.163"><vh>Notes</vh></v>
<v t="ekr.20060211104746.164"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20060211104746.165"><vh>removeTrailingNewlines</vh></v>
<v t="ekr.20060211104746.166"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20060211104746.167"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060211104746.168"><vh>Added unit tests for key dicts</vh></v>
<v t="ekr.20060211104746.169"><vh>Improved restore-focus logic when updating status line</vh>
<v t="ekr.20060211104746.170"><vh> doCommand</vh></v>
<v t="ekr.20060211104746.76"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20060211104746.77"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20060211104746.78"><vh>c.bringToFront</vh></v>
<v t="ekr.20060211104746.72"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060211104746.79"><vh>c.invalidateFocus</vh></v>
<v t="ekr.20060211104746.80"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20060211104746.81"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20060211104746.82"><vh>c.recolor_now</vh></v>
<v t="ekr.20060211104746.83"><vh>c.redraw_now</vh></v>
<v t="ekr.20060211104746.84"><vh>c.restoreFocus</vh></v>
<v t="ekr.20060211104746.85"><vh>c.traceFocus</vh></v>
<v t="ekr.20060211104746.86"><vh>c.widget_name</vh></v>
<v t="ekr.20060211104746.87"><vh>c.xWantsFocus</vh></v>
<v t="ekr.20060211104746.88"><vh>c.xWantsFocusNow</vh></v>
</v>
<v t="ekr.20060211104746.74"><vh>showStateAndMode</vh></v>
<v t="ekr.20060211104746.84"><vh>c.restoreFocus</vh></v>
</v>
<v t="ekr.20060211104746.171"><vh>Fixed problem with 'spelling' of menu bindings</vh>
<v t="ekr.20060211104746.172"><vh>k.prettyPrintKey</vh></v>
<v t="ekr.20060211104746.173"><vh>createMenuEntries</vh>
<v t="ekr.20060211104746.174"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20060211104746.175"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20060211104746.176"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060211104746.177"><vh>Set remembered column properly in prev-line and next-line</vh>
<v t="ekr.20060211104746.178"><vh>Report</vh></v>
<v t="ekr.20060211104746.179"><vh>masterClickHandler</vh></v>
<v t="ekr.20060211104746.180"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060211104746.181"><vh>moveToHelper</vh></v>
<v t="ekr.20060211104746.182"><vh>extendHelper</vh></v>
<v t="ekr.20060211104746.183"><vh>setMoveCol</vh></v>
<v t="ekr.20060211104746.184"><vh>move... (leoEditCommands)</vh>
<v t="ekr.20060211104746.185"><vh> helpers</vh>
<v t="ekr.20060211104746.182"><vh>extendHelper</vh></v>
<v t="ekr.20060211104746.180"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060211104746.181"><vh>moveToHelper</vh></v>
<v t="ekr.20060211104746.186"><vh>moveWordHelper</vh></v>
<v t="ekr.20060211104746.187"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060211104746.188"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060211104746.189"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060211104746.190"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060211104746.191"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20060211104746.183"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20060211104746.192"><vh>exchangePointMark</vh></v>
<v t="ekr.20060211104746.193"><vh>extendMode</vh></v>
<v t="ekr.20060211104746.194"><vh>buffers</vh></v>
<v t="ekr.20060211104746.195"><vh>characters</vh></v>
<v t="ekr.20060211104746.196"><vh>lines</vh></v>
<v t="ekr.20060211104746.197"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060211104746.198"><vh>paragraphs</vh></v>
<v t="ekr.20060211104746.199"><vh>sentences</vh></v>
<v t="ekr.20060211104746.200"><vh>words</vh></v>
</v>
</v>
<v t="ekr.20060211104746.201"><vh>Fixed bug in k.shortcutFromSetting</vh>
<v t="ekr.20060211104746.202"><vh>shortcutFromSetting</vh>
<v t="ekr.20060211104746.203"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20060211104746.204"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20060211104746.205"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20060211104746.206"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060211104746.207"><vh>Fixed vim plugin &amp; openWith</vh></v>
<v t="ekr.20060211104746.208"><vh>Fixed focus problems in spell tab</vh></v>
<v t="ekr.20060211104746.209"><vh>Don't abort the minibuffer if the command does not exist</vh>
<v t="ekr.20060211104746.210"><vh>callAltXFunction</vh></v>
<v t="ekr.20060211104746.211"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060211104746.210"><vh>callAltXFunction</vh></v>
</v>
</v>
<v t="ekr.20060211104746.212"><vh>Restored tree.onTreeClick</vh></v>
<v t="ekr.20060211104746.213"><vh>Added expand/contract/hide-pane/fully-expand commands</vh>
<v t="ekr.20060211104746.214"><vh>class editCommandsClass</vh>
<v t="ekr.20060211104746.215"><vh> birth</vh>
<v t="ekr.20060211104746.216"><vh> ctor (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.217"><vh> getPublicCommands (editCommandsClass)</vh></v>
</v>
<v t="ekr.20060211104746.218"><vh>capitalization &amp; case</vh>
<v t="ekr.20060211104746.219"><vh>capitalizeWord &amp; up/downCaseWord</vh></v>
<v t="ekr.20060211104746.220"><vh>changePreviousWord</vh></v>
<v t="ekr.20060211104746.221"><vh>capitalizeHelper</vh></v>
</v>
<v t="ekr.20060211104746.222" a="M"><vh>clicks and focus (editCommandsClass)</vh>
<v t="ekr.20060211104746.223"><vh>activate-x-menu &amp; activateMenu (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.224"><vh>cycleFocus</vh></v>
<v t="ekr.20060211104746.225"><vh>focusTo...</vh></v>
<v t="ekr.20060211104746.226"><vh>clicks in the headline</vh></v>
<v t="ekr.20060211104746.227"><vh>clicks in the icon box</vh></v>
<v t="ekr.20060211104746.228"><vh>clickClickBox</vh></v>
<v t="ekr.20060211104746.229"><vh>simulate...Drag</vh></v>
</v>
<v t="ekr.20060211104746.230"><vh>color &amp; font</vh>
<v t="ekr.20060211104746.231"><vh>show-colors</vh>
<v t="ekr.20060211104746.232"><vh>&lt;&lt; define colors &gt;&gt;</vh></v>
<v t="ekr.20060211104746.233"><vh>createColorPicker</vh>
<v t="ekr.20060211104746.234"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20060211104746.235"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060211104746.236"><vh>show-fonts &amp; helpers</vh>
<v t="ekr.20060211104746.237"><vh>createFontPicker</vh>
<v t="ekr.20060211104746.238"><vh>&lt;&lt; create the frames &gt;&gt;</vh></v>
<v t="ekr.20060211104746.239"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20060211104746.240"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20060211104746.241"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20060211104746.242"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20060211104746.243"><vh>&lt;&lt; create the sample text widget &gt;&gt;</vh></v>
<v t="ekr.20060211104746.244"><vh>&lt;&lt; create and bind the callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.245"><vh>getFont</vh></v>
<v t="ekr.20060211104746.246"><vh>setFont</vh></v>
</v>
</v>
<v t="ekr.20060211104746.247"><vh>comment column...</vh>
<v t="ekr.20060211104746.248"><vh>setCommentColumn</vh></v>
<v t="ekr.20060211104746.249"><vh>indentToCommentColumn</vh></v>
</v>
<v t="ekr.20060211104746.250"><vh>dynamic abbreviation...</vh>
<v t="ekr.20060211104746.251"><vh>dynamicExpansion</vh></v>
<v t="ekr.20060211104746.252"><vh>dynamicExpansion2</vh></v>
<v t="ekr.20060211104746.253"><vh>getDynamicList (helper)</vh></v>
</v>
<v t="ekr.20060211104746.254"><vh>esc methods for Python evaluation</vh>
<v t="ekr.20060211104746.255"><vh>watchEscape (Revise)</vh></v>
<v t="ekr.20060211104746.256"><vh>escEvaluate (Revise)</vh></v>
</v>
<v t="ekr.20060211104746.257"><vh>evalExpression</vh></v>
<v t="ekr.20060211104746.258"><vh>fill column and centering</vh>
<v t="ekr.20060211104746.259"><vh>centerLine</vh></v>
<v t="ekr.20060211104746.260"><vh>setFillColumn</vh></v>
<v t="ekr.20060211104746.261"><vh>centerRegion</vh></v>
<v t="ekr.20060211104746.262"><vh>setFillPrefix</vh></v>
<v t="ekr.20060211104746.263"><vh>_addPrefix</vh></v>
</v>
<v t="ekr.20060211104746.264"><vh>goto...</vh>
<v t="ekr.20060211104746.265"><vh>gotoCharacter</vh></v>
<v t="ekr.20060211104746.266"><vh>gotoLine</vh></v>
</v>
<v t="ekr.20060211104746.267"><vh>indent... (To do: undo)</vh>
<v t="ekr.20060211104746.268"><vh>backToIndentation</vh></v>
<v t="ekr.20060211104746.269"><vh>deleteIndentation</vh></v>
<v t="ekr.20060211104746.270"><vh>insertNewLineIndent</vh></v>
<v t="ekr.20060211104746.271"><vh>indentRelative</vh></v>
</v>
<v t="ekr.20060211104746.272"><vh>insert &amp; delete...</vh>
<v t="ekr.20060211104746.273"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20060211104746.274"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.275"><vh>deleteNextChar</vh></v>
<v t="ekr.20060211104746.276"><vh>deleteSpaces</vh></v>
<v t="ekr.20060211104746.277"><vh>removeBlankLines</vh></v>
<v t="ekr.20060211104746.278"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20060211104746.279"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20060211104746.280"><vh>insertParentheses</vh></v>
<v t="ekr.20060211104746.281"><vh>selfInsertCommand</vh>
<v t="ekr.20060211104746.282"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060211104746.283"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060211104746.284"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060211104746.285"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060211104746.286"><vh>info...</vh>
<v t="ekr.20060211104746.287"><vh>howMany</vh></v>
<v t="ekr.20060211104746.288"><vh>lineNumber</vh></v>
<v t="ekr.20060211104746.289"><vh>viewLossage</vh></v>
<v t="ekr.20060211104746.290"><vh>whatLine</vh></v>
</v>
<v t="ekr.20060211104746.291"><vh>line...</vh>
<v t="ekr.20060211104746.292"><vh>flushLines</vh></v>
<v t="ekr.20060211104746.293"><vh>keepLines</vh></v>
<v t="ekr.20060211104746.294"><vh>linesHelper</vh></v>
</v>
<v t="ekr.20060211104746.295"><vh>measure</vh></v>
<v t="ekr.20060211104746.184"><vh>move... (leoEditCommands)</vh>
<v t="ekr.20060211104746.185"><vh> helpers</vh>
<v t="ekr.20060211104746.182"><vh>extendHelper</vh></v>
<v t="ekr.20060211104746.180"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060211104746.181"><vh>moveToHelper</vh></v>
<v t="ekr.20060211104746.186"><vh>moveWordHelper</vh></v>
<v t="ekr.20060211104746.187"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060211104746.188"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060211104746.189"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060211104746.190"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060211104746.191"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20060211104746.183"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20060211104746.192"><vh>exchangePointMark</vh></v>
<v t="ekr.20060211104746.193"><vh>extendMode</vh></v>
<v t="ekr.20060211104746.194"><vh>buffers</vh></v>
<v t="ekr.20060211104746.195"><vh>characters</vh></v>
<v t="ekr.20060211104746.196"><vh>lines</vh></v>
<v t="ekr.20060211104746.197"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060211104746.198"><vh>paragraphs</vh></v>
<v t="ekr.20060211104746.199"><vh>sentences</vh></v>
<v t="ekr.20060211104746.200"><vh>words</vh></v>
</v>
<v t="ekr.20060211104746.296"><vh>paragraph...</vh>
<v t="ekr.20060211104746.297"><vh>backwardKillParagraph</vh></v>
<v t="ekr.20060211104746.298"><vh>fillParagraph</vh></v>
<v t="ekr.20060211104746.299"><vh>fillRegion</vh></v>
<v t="ekr.20060211104746.300"><vh>fillRegionAsParagraph</vh></v>
<v t="ekr.20060211104746.301"><vh>killParagraph (Test)</vh></v>
<v t="ekr.20060211104746.302"><vh>selectParagraph &amp; helper</vh>
<v t="ekr.20060211104746.303"><vh>selectParagraphHelper</vh></v>
</v>
</v>
<v t="ekr.20060211104746.304"><vh>region...</vh>
<v t="ekr.20060211104746.305"><vh>setRegion</vh>
<v t="ekr.20060211104746.306"><vh>down</vh></v>
<v t="ekr.20060211104746.307"><vh>extend</vh></v>
<v t="ekr.20060211104746.308"><vh>truncate</vh></v>
<v t="ekr.20060211104746.309"><vh>up</vh></v>
</v>
<v t="ekr.20060211104746.310"><vh>indentRegion</vh></v>
<v t="ekr.20060211104746.311"><vh>tabIndentRegion</vh></v>
<v t="ekr.20060211104746.312"><vh>countRegion</vh></v>
<v t="ekr.20060211104746.313"><vh>reverseRegion</vh></v>
<v t="ekr.20060211104746.314"><vh>up/downCaseRegion &amp; helper</vh></v>
</v>
<v t="ekr.20060211104746.315"><vh>scrollUp/Down/extendSelection</vh>
<v t="ekr.20060211104746.316"><vh>scrollHelper</vh></v>
</v>
<v t="ekr.20060211104746.317"><vh>sort...</vh>
<v t="ekr.20060211104746.318"><vh>sortLines</vh></v>
<v t="ekr.20060211104746.319"><vh>sortColumns</vh></v>
<v t="ekr.20060211104746.320"><vh>sortFields</vh></v>
</v>
<v t="ekr.20060211104746.321"><vh>swap/transpose...</vh>
<v t="ekr.20060211104746.322"><vh>transposeLines</vh></v>
<v t="ekr.20060211104746.323"><vh>swapWords &amp; transposeWords</vh></v>
<v t="ekr.20060211104746.324"><vh>swapCharacters &amp; transeposeCharacters</vh></v>
</v>
<v t="ekr.20060211104746.325"><vh>tabify &amp; untabify</vh></v>
</v>
<v t="ekr.20060211104746.76"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20060211104746.77"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20060211104746.78"><vh>c.bringToFront</vh></v>
<v t="ekr.20060211104746.72"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060211104746.79"><vh>c.invalidateFocus</vh></v>
<v t="ekr.20060211104746.80"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20060211104746.81"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20060211104746.82"><vh>c.recolor_now</vh></v>
<v t="ekr.20060211104746.83"><vh>c.redraw_now</vh></v>
<v t="ekr.20060211104746.84"><vh>c.restoreFocus</vh></v>
<v t="ekr.20060211104746.85"><vh>c.traceFocus</vh></v>
<v t="ekr.20060211104746.86"><vh>c.widget_name</vh></v>
<v t="ekr.20060211104746.87"><vh>c.xWantsFocus</vh></v>
<v t="ekr.20060211104746.88"><vh>c.xWantsFocusNow</vh></v>
</v>
<v t="ekr.20060211104746.326"><vh>Event handlers (tkFrame)</vh>
<v t="ekr.20060211104746.327"><vh>frame.OnCloseLeoEvent</vh></v>
<v t="ekr.20060211104746.328"><vh>frame.OnControlKeyUp/Down</vh></v>
<v t="ekr.20060211104746.329"><vh>OnActivateBody (tkFrame)</vh></v>
<v t="ekr.20060211104746.330"><vh>OnActivateLeoEvent, OnDeactivateLeoEvent</vh></v>
<v t="ekr.20060211104746.331"><vh>OnActivateTree</vh></v>
<v t="ekr.20060211104746.332"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="ekr.20060211104746.333"><vh>OnBodyDoubleClick (Events)</vh></v>
<v t="ekr.20060211104746.334"><vh>OnMouseWheel (Tomaz Ficko)</vh></v>
</v>
<v t="ekr.20060211104746.335"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20060211104746.336"><vh>Minibuffer commands... (tkFrame)</vh>
<v t="ekr.20060211104746.337"><vh>contractPane</vh></v>
<v t="ekr.20060211104746.338"><vh>expandPane</vh></v>
<v t="ekr.20060211104746.339"><vh>fullyExpandPane</vh></v>
<v t="ekr.20060211104746.340"><vh>hidePane</vh></v>
<v t="ekr.20060211104746.341"><vh>expand/contract/hide...Pane</vh></v>
<v t="ekr.20060211104746.342"><vh>fullyExpand/hide...Pane</vh></v>
</v>
<v t="ekr.20060211104746.179"><vh>masterClickHandler</vh></v>
</v>
<v t="ekr.20060211104746.343"><vh>clicks now clear selection</vh></v>
<v t="ekr.20060211104746.344"><vh>Special-cased select-all-text in headlines</vh>
<v t="ekr.20060211104746.345"><vh>selectAllText</vh></v>
</v>
<v t="ekr.20060211104746.346"><vh>Special-cased commands for minibuffer</vh>
<v t="ekr.20060211104746.347"><vh>getEditableTextRange</vh></v>
<v t="ekr.20060211104746.111"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20060211104746.112"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20060211104746.113"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20060211104746.114"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20060211104746.115"><vh>Dialog</vh>
<v t="ekr.20060211104746.116"><vh>get_window_info</vh></v>
<v t="ekr.20060211104746.117"><vh>center_dialog</vh></v>
<v t="ekr.20060211104746.118"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20060211104746.119"><vh>Focus</vh>
<v t="ekr.20060211104746.120"><vh>get_focus</vh></v>
<v t="ekr.20060211104746.69"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060211104746.121"><vh>Font</vh>
<v t="ekr.20060211104746.122"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20060211104746.123"><vh>Icons</vh>
<v t="ekr.20060211104746.124"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20060211104746.125"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20060211104746.126"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20060211104746.127"><vh>Idle Time</vh>
<v t="ekr.20060211104746.128"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20060211104746.129"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20060211104746.130"><vh>Indices (Tk)</vh>
<v t="ekr.20060211104746.131"><vh>firstIndex</vh></v>
<v t="ekr.20060211104746.132"><vh>lastIndex</vh></v>
<v t="ekr.20060211104746.133"><vh>moveIndexBackward</vh></v>
<v t="ekr.20060211104746.134"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20060211104746.135"><vh>compareIndices</vh></v>
<v t="ekr.20060211104746.136"><vh>getindex</vh></v>
</v>
<v t="ekr.20060211104746.137"><vh>Insert Point</vh>
<v t="ekr.20060211104746.138"><vh>getInsertPoint</vh></v>
<v t="ekr.20060211104746.139"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20060211104746.140"><vh>Selection</vh>
<v t="ekr.20060211104746.141"><vh>getSelectionRange</vh></v>
<v t="ekr.20060211104746.142"><vh>getSelectedText</vh></v>
<v t="ekr.20060211104746.143"><vh>getTextSelection</vh></v>
<v t="ekr.20060211104746.144"><vh>hasSelection</vh></v>
<v t="ekr.20060211104746.145"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20060211104746.146"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060211104746.147"><vh>Text</vh>
<v t="ekr.20060211104746.148"><vh>getAllText</vh></v>
<v t="ekr.20060211104746.149"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20060211104746.150"><vh>getCharAtIndex</vh></v>
<v t="ekr.20060211104746.151"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20060211104746.152"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20060211104746.153"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20060211104746.154"><vh>Visibility</vh>
<v t="ekr.20060211104746.155"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20060211104746.156"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060211104746.345"><vh>selectAllText</vh></v>
<v t="ekr.20060211104746.348"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060211104746.349"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20060211104746.181"><vh>moveToHelper</vh></v>
</v>
<v t="ekr.20060211104746.350"><vh>Copy find text into minibuffer for search commands</vh>
<v t="ekr.20060211104746.111"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20060211104746.112"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20060211104746.113"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20060211104746.114"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20060211104746.115"><vh>Dialog</vh>
<v t="ekr.20060211104746.116"><vh>get_window_info</vh></v>
<v t="ekr.20060211104746.117"><vh>center_dialog</vh></v>
<v t="ekr.20060211104746.118"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20060211104746.119"><vh>Focus</vh>
<v t="ekr.20060211104746.120"><vh>get_focus</vh></v>
<v t="ekr.20060211104746.69"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060211104746.121"><vh>Font</vh>
<v t="ekr.20060211104746.122"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20060211104746.123"><vh>Icons</vh>
<v t="ekr.20060211104746.124"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20060211104746.125"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20060211104746.126"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20060211104746.127"><vh>Idle Time</vh>
<v t="ekr.20060211104746.128"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20060211104746.129"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20060211104746.130"><vh>Indices (Tk)</vh>
<v t="ekr.20060211104746.131"><vh>firstIndex</vh></v>
<v t="ekr.20060211104746.132"><vh>lastIndex</vh></v>
<v t="ekr.20060211104746.133"><vh>moveIndexBackward</vh></v>
<v t="ekr.20060211104746.134"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20060211104746.135"><vh>compareIndices</vh></v>
<v t="ekr.20060211104746.136"><vh>getindex</vh></v>
</v>
<v t="ekr.20060211104746.137"><vh>Insert Point</vh>
<v t="ekr.20060211104746.138"><vh>getInsertPoint</vh></v>
<v t="ekr.20060211104746.139"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20060211104746.140"><vh>Selection</vh>
<v t="ekr.20060211104746.141"><vh>getSelectionRange</vh></v>
<v t="ekr.20060211104746.142"><vh>getSelectedText</vh></v>
<v t="ekr.20060211104746.143"><vh>getTextSelection</vh></v>
<v t="ekr.20060211104746.144"><vh>hasSelection</vh></v>
<v t="ekr.20060211104746.145"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20060211104746.146"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060211104746.147"><vh>Text</vh>
<v t="ekr.20060211104746.148"><vh>getAllText</vh></v>
<v t="ekr.20060211104746.149"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20060211104746.150"><vh>getCharAtIndex</vh></v>
<v t="ekr.20060211104746.151"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20060211104746.152"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20060211104746.153"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20060211104746.154"><vh>Visibility</vh>
<v t="ekr.20060211104746.155"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20060211104746.156"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060211104746.351"><vh>From keyHandler</vh>
<v t="ekr.20060211104746.348"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060211104746.349"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20060211104746.352"><vh>Label...</vh>
<v t="ekr.20060211104746.353"><vh>k.minibufferWantsFocus/Now</vh></v>
<v t="ekr.20060211104746.354"><vh>getLabel</vh></v>
<v t="ekr.20060211104746.355"><vh>protectLabel</vh></v>
<v t="ekr.20060211104746.356"><vh>resetLabel</vh></v>
<v t="ekr.20060211104746.357"><vh>setLabel</vh></v>
<v t="ekr.20060211104746.358"><vh>extendLabel</vh></v>
<v t="ekr.20060211104746.359"><vh>setLabelBlue</vh></v>
<v t="ekr.20060211104746.360"><vh>setLabelGrey</vh></v>
<v t="ekr.20060211104746.361"><vh>updateLabel</vh></v>
<v t="ekr.20060211104746.347"><vh>getEditableTextRange</vh></v>
</v>
<v t="ekr.20060211104746.347"><vh>getEditableTextRange</vh></v>
<v t="ekr.20060211104746.362"><vh>getArg</vh>
<v t="ekr.20060211104746.363"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.358"><vh>extendLabel</vh></v>
<v t="ekr.20060211104746.361"><vh>updateLabel</vh></v>
<v t="ekr.20060211104746.364"><vh>doBackSpace</vh></v>
<v t="ekr.20060211104746.365"><vh>doTabCompletion</vh></v>
</v>
<v t="ekr.20060211104746.366"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20060211104746.367"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20060211104746.368"><vh>Search classes</vh>
<v t="ekr.20060211104746.369"><vh>class minibufferFind (the findHandler)</vh>
<v t="ekr.20060211104746.370"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20060211104746.371"><vh> Options</vh>
<v t="ekr.20060211104746.372"><vh>setFindScope</vh></v>
<v t="ekr.20060211104746.373"><vh>setOption</vh></v>
<v t="ekr.20060211104746.374"><vh>getOption</vh></v>
<v t="ekr.20060211104746.375"><vh>showFindOptions</vh></v>
<v t="ekr.20060211104746.376"><vh>toggleOption</vh></v>
<v t="ekr.20060211104746.377"><vh>setupChangePattern</vh></v>
<v t="ekr.20060211104746.378"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20060211104746.367"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20060211104746.379"><vh>addChangeStringToLabel</vh></v>
<v t="ekr.20060211104746.380"><vh> setupArgs</vh></v>
<v t="ekr.20060211104746.381"><vh>findAll</vh></v>
<v t="ekr.20060211104746.382"><vh>cloneFindAll</vh></v>
<v t="ekr.20060211104746.383"><vh>findAgain</vh></v>
<v t="ekr.20060211104746.384"><vh>stateZeroHelper</vh></v>
<v t="ekr.20060211104746.385"><vh>lastStateHelper</vh></v>
<v t="ekr.20060211104746.386"><vh>generalChangeHelper</vh></v>
<v t="ekr.20060211104746.387"><vh>generalSearchHelper</vh></v>
<v t="ekr.20060211104746.388"><vh>replaceString</vh></v>
<v t="ekr.20060211104746.389"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20060211104746.390"><vh>seachForward/Backward</vh></v>
<v t="ekr.20060211104746.366"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20060211104746.391"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20060211104746.392"><vh>class findTab (leoFind.leoFind)</vh>
<v t="ekr.20060211104746.393"><vh>Birth &amp; death</vh>
<v t="ekr.20060211104746.394"><vh>__init__</vh>
<v t="ekr.20060211104746.395"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.396"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20060211104746.397"><vh>createFrame (findTab)</vh>
<v t="ekr.20060211104746.398"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20060211104746.399"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20060211104746.400"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.401"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20060211104746.402"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.403"><vh>find.init</vh>
<v t="ekr.20060211104746.404"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20060211104746.405"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060211104746.406"><vh>find.update_ivars</vh></v>
<v t="ekr.20060211104746.407"><vh>findButtonCallback</vh></v>
<v t="ekr.20060211104746.408"><vh> Top level</vh>
<v t="ekr.20060211104746.409"><vh>findAllCommand</vh></v>
<v t="ekr.20060211104746.410"><vh>findAgainCommand</vh></v>
<v t="ekr.20060211104746.411"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20060211104746.412"><vh>findNext/PrefCommand</vh></v>
<v t="ekr.20060211104746.413"><vh>change/ThenFindCommand</vh></v>
</v>
<v t="ekr.20060211104746.414"><vh>hideTab</vh></v>
<v t="ekr.20060211104746.415"><vh>bringToFront</vh></v>
<v t="ekr.20060211104746.416"><vh>selectAllFindText</vh></v>
<v t="ekr.20060211104746.417"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20060211104746.418"><vh>class underlinedTkButton</vh>
<v t="ekr.20060211104746.419"><vh>__init__</vh>
<v t="ekr.20060211104746.420"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.421"><vh>bindHotKey</vh></v>
<v t="ekr.20060211104746.422"><vh>buttonCallback</vh></v>
</v>
</v>
<v t="ekr.20060211104746.423"><vh>class searchCommandsClass</vh>
<v t="ekr.20060211104746.424"><vh> ctor</vh></v>
<v t="ekr.20060211104746.425"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20060211104746.426"><vh>Top-level methods</vh>
<v t="ekr.20060211104746.427"><vh>openFindTab</vh></v>
<v t="ekr.20060211104746.428"><vh>Find Tab commands</vh></v>
<v t="ekr.20060211104746.429"><vh>getHandler</vh></v>
<v t="ekr.20060211104746.430"><vh>Find options wrappers</vh></v>
<v t="ekr.20060211104746.431"><vh>Find wrappers</vh></v>
<v t="ekr.20060211104746.432"><vh>findAgain</vh></v>
</v>
<v t="ekr.20060211104746.433"><vh>incremental search...</vh>
<v t="ekr.20060211104746.434"><vh>startIncremental</vh></v>
<v t="ekr.20060211104746.435"><vh>iSearchStateHandler &amp; helper</vh></v>
<v t="ekr.20060211104746.436"><vh>scolorizer</vh></v>
<v t="ekr.20060211104746.437"><vh>iSearchHelper</vh></v>
<v t="ekr.20060211104746.438"><vh>endSearch</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060211104746.439"><vh>Added commands to simulate clicks</vh>
<v t="ekr.20060211104746.440"><vh>What I did</vh></v>
<v t="ekr.20060211104746.217"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.441"><vh>Tree event handlers that trigger hooks</vh>
<v t="ekr.20060211104746.49"><vh>Icon Box...</vh>
<v t="ekr.20060211104746.50"><vh>onIconBoxClick</vh></v>
<v t="ekr.20060211104746.51"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20060211104746.52"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20060211104746.36"><vh>onClickBoxClick</vh></v>
<v t="ekr.20060211104746.37"><vh>Dragging</vh>
<v t="ekr.20060211104746.38"><vh>endDrag</vh>
<v t="ekr.20060211104746.39"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20060211104746.40"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.41"><vh>startDrag</vh></v>
<v t="ekr.20060211104746.42"><vh>onContinueDrag</vh>
<v t="ekr.20060211104746.43"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20060211104746.44"><vh>onDrag</vh></v>
<v t="ekr.20060211104746.45"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20060211104746.58"><vh>onHeadlineClick</vh></v>
<v t="ekr.20060211104746.59"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20060211104746.222" a="M"><vh>clicks and focus (editCommandsClass)</vh>
<v t="ekr.20060211104746.223"><vh>activate-x-menu &amp; activateMenu (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.224"><vh>cycleFocus</vh></v>
<v t="ekr.20060211104746.225"><vh>focusTo...</vh></v>
<v t="ekr.20060211104746.226"><vh>clicks in the headline</vh></v>
<v t="ekr.20060211104746.227"><vh>clicks in the icon box</vh></v>
<v t="ekr.20060211104746.228"><vh>clickClickBox</vh></v>
<v t="ekr.20060211104746.229"><vh>simulate...Drag</vh></v>
</v>
</v>
<v t="ekr.20060211104746.442"><vh>Clicks are now handled properly in the minibuffer</vh>
<v t="ekr.20060211104746.179"><vh>masterClickHandler</vh></v>
</v>
<v t="ekr.20060211104746.443"><vh>activate-xxx-menu commands</vh>
<v t="ekr.20060211104746.217"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.223"><vh>activate-x-menu &amp; activateMenu (editCommandsClass)</vh></v>
<v t="ekr.20060211104746.444"><vh>tkMenu.activateMenu</vh></v>
<v t="ekr.20060211104746.445"><vh>tkMenu.computeMenuPositions</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060212102459" a="E"><vh>What's new in Leo 4.4</vh>
<v t="ekr.20060212102459.4"><vh>Minibuffer-oriented find commands</vh></v>
<v t="ekr.20060212111040"><vh>Flexible key modes</vh>
<v t="ekr.20060212102459.11"><vh>How to design and use modes</vh></v>
<v t="ekr.20060212102459.6"><vh>Modes may inherit bindings</vh></v>
</v>
<v t="ekr.20060212102459.7"><vh>New commands not in legacy Leo</vh>
<v t="ekr.20060212102459.8"><vh>expand/contract/hide/fully-expand-pane</vh></v>
<v t="ekr.20060212102459.9"><vh>activate-xxx-menu (todo)</vh></v>
<v t="ekr.20060212102459.10"><vh>minibuffer find commands</vh></v>
</v>
<v t="ekr.20060212102459.2"><vh>Many new features  in leosettings.leo</vh></v>
<v t="ekr.20060212110830" a="V"><vh>coming in 4.4 b3</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040518070558">Leo 4.2 alpha 2           May 18, 2004

This is an important milestone in Leo's history; the two defining features of the 4.2 code base are complete:

1. This is the first stable version using the "shared nodes" code base.

Shared nodes dramatically improve the time needed to insert, delete, and move nodes.  Moreover, the new code base is code compatible with the old.  Indeed, much of Leo still uses the old code base.  See Chapter 7 for full details of how to script Leo with the 4.2 code base.

2. This is the first version to use @file-thin for most derived files.

@file-thin makes it possible to use Leo effectively in a cvs environment.  Indeed, cvs now contains only a "dummy" version of LeoPy.leo.  The idea is that:

- LeoPyRef.leo hardly ever changes.  Developers will download LeoPyRef.leo once from cvs, then rename LeoPyRef.leo to be LeoPy.leo.  LeoPy.leo is private to each developer.

- Developers will commit and update to cvs only thin derived files.  There is no longer any need to keep .leo files and the files derived from them "in synch".

- Similar remarks apply to LeoPlugins.leo.  Cvs contains only LeoPluginsRef.leo, and contributors will need only to submit thin derived files.

I have been using the new code base without incident for weeks now, and I am fairly confident that it is safe to use.  Nevertheless, I would suggest routine caution when dealing with this version until more people have tested it.

Known bugs

- Cutting and pasting an @file-thin node does not work properly.  This will be easy to fix, I think.

- The present algorithm for reading thin derived files probably does not handle properly the situation in which a named node is some kind of grand child of the referencing node rather than being an immediate child of the referencing node.  This is a rare situation, easily avoided, and it doesn't happen at all in LeoPy.leo.  Nevertheless, something must be done.

Other improvements:

- Fixed a number of problems with using Leo on MacOS X.  In particular, Leo now uses the clover key as is usual on the Mac.  More Mac and *nix specific improvements are coming.

Still to do:

- Perfect import and @import.
- Make the Go To Line Number command work with @file-thin files.
- Fix minor bugs and add new features
  See the "To Do: 4.2" node in the leoToDo.txt node in LeoPy.leo.</t>
<t tx="EKR.20040518070824"></t>
<t tx="EKR.20040518070824.1">- Moved call to assignFileIndices into write_Leo_file.
- Called assignFileIndices in writeAtFileNodes, writeDirtyAtFileNodes, writeMissingAtFileNodes</t>
<t tx="EKR.20040518070940"></t>
<t tx="EKR.20040518070940.5">What I did:

File format

Added -thin field to @+leo sentinel

Recognizers

- Added vnode recognizers for @file-thin option.
- Added position proxies for vnode recognizers.

Directives &amp; sentinels
- Added support for @all.

Writing

- Added top-level atFile code to write @file-thin tree.
- DO write @file-thin vnodes if there was an error writing the derived file.
	- No autosave for @file-thin.
 	- Leo writes @file nodes first, so this is not a problem.
	- putVnode checks orphan bit, which gets set if there was an error.
- Don't write vnodes (or related tnodes) for @file-thin trees. (fileCommands).
- Do write empty nodes in @thin trees.
- Don't generate close node sentinels until all children have been generated.

Reading

- Set at.thinFile when reading thin files.
- Suppressed changed message and related items for thin files.
- Modified scanText4 and allies to read thin derived files.
	- Don't look for tnodeList for thin files.
	- Initially, at.lastThinNode is at.root.v
	- readStartNode calls createThinChild
	- createThinChild makes a child of at.lastThinNode if needed and sets at.lastThinNode.
- Updated fc.tnodesDict in at.createThinChild.
	Otherwise clones existing only in two thin files won't be linked properly.</t>
<t tx="EKR.20040518070940.156">After a match, the find-next command searched only in the suboutline where the first match occurred.
To fix this, we call g.app.findFrame.handleUserClick in various Tk event handlers.</t>
<t tx="EKR.20040518070940.164">@nocolor


p.v.t.visitedBit was used for two purposes:

- To mark the nodes to be written.
- To mark nodes that are not orphan.

What I did:

- Added t.is/set/clearWriteBit.
- Call t.setWriteBit in putVnode unless we are in a thin node.
- putTnodes tests for t.writeBit rather than t.visitedBit.</t>
<t tx="EKR.20040518071415">Leo did not handle moving a node to the root position of the outline correctly.</t>
<t tx="EKR.20040518075457">Using @ignore with @file-thin is asking for trouble.
If you remove the @ignore and then save, you will lose data.

How to recover the data:
	- Read Outline.
	- Remove @ignore
	- Import derived file... </t>
<t tx="EKR.20040524104904.26"></t>
<t tx="EKR.20040524104904.27">A cloned node is a copy of a node that changes when the original changes. Not
only are changes maintained across all the the clones of a node, changes to its
offspring (children, grandchildren, etc). are simultaneously made to the
corresponding offspring of all of those clones. A small red arrow in the icon
box marks cloned nodes. There is no real distinction between the "original" node
and any of its clones. This makes it possible to update any of the clones and
the original node will change as well. A cloned nodes becomes a regular node
again when its penultimate clone is deleted. Clones are useful for making
alternate views of a program. See `Clones and views`_ for full details.</t>
<t tx="EKR.20040524104904.36">The ``Insert Node`` command inserts a new node into the outline. The
``Delete Node`` command deletes a node and all its children.
</t>
<t tx="EKR.20040524104904.37">The ``Cut Outline``, ``Paste Outline``, ``Copy Outline`` and ``Delete Outline``
commands work on nodes rather than text. For example, to delete a node,
select the node and choose the ``Cut Outline`` or ``Delete Outline``
command. The ``Cut Outline`` and ``Copy Outline`` commands copy a text
representation of the outline to the clipboard. This representation is the same
as Leo's .leo file format with some information deleted. You may copy this text
representation into a body pane (or into any other text editor) using the
``Edit:Paste`` command.

**Warning**: In practice, it is almost always wiser to move clones rather than
cutting or pasting them. Cutting and pasting outlines preserves clones, but the
links between clones only exist within the part of the outline that was pasted.
Therefore, if you are cutting and pasting an outline containing clones it is
best to cut and paste the *entire* outline. Alternatively, you can paste part of
an outline, then delete all clones.</t>
<t tx="EKR.20040524104904.38">You may drag an node (including all its descendants) from one place to another
in an outline. To start a drag, press the main (left) mouse button while the
cursor is over the icon for a node. The cursor will change to a hand icon. If
you release the mouse button while the hand cursor is above the icon for another
node, Leo will move the dragged node after that node. If you release the mouse
button when the hand cursor is not over an icon, Leo will leave the outline pane
as it is. Leo scrolls the outline pane as the result of mouse-moved events, so
to continue scrolling you must keep moving the mouse.</t>
<t tx="EKR.20040524104904.39">Leo auto indents unless ``@nocolor`` is in effect. Typing a newline
automatically inserts the same leading whitespace present on the previous line.
If Python is the present language, Leo inserts an additional tab if the previous
line ends with a colon.

The default features of Leo's body text derive from the Tk.Text widget,
described at: http://www.tcl.tk/man/tcl8.3/TkCmd/text.htm Not all these features
are found on all platforms.
The following features are derived from the Tk Text widget. Some default
behaviors have been changed because they conflict with other Leo features.

-   Clicking mouse button 1 positions the insertion cursor just before the character
    underneath the mouse cursor, sets the input focus to this widget, and clears any
    selection in the widget. Dragging with mouse button 1 strokes out a selection
    between the insertion cursor and the character under the mouse. 
    
-   Double-clicking mouse button 1 selects the word under the mouse and
    positions the insertion cursor at the end of the word.
    
-   The ends of the selection can be adjusted by dragging with mouse button 1 while
    the Shift key is down; this will adjust the end of the selection that was
    nearest to the mouse cursor when button 1 was pressed. 
    
-   Clicking mouse button 1 with the ``Control`` key down will reposition the insertion
    cursor without affecting the selection. 
    
-   Normal printing characters are inserted at the point of the insertion cursor. 
    
-   If the mouse is dragged out of the body pane while button 1 is pressed, the
    entry will automatically scroll to make more text visible.
    
-   ``Left Arrow`` and ``Right Arrow`` move the cursor one
    character to the left or right and clear any selection in the text.

-   ``Shift Left`` or ``Shift Right`` move the cursor and extend the selection.

-   ``Control-Left`` and ``Control-Right`` move the insertion cursor by words,
    and ``Control-Shift-Left`` and ``Control-Shift-Right`` move the insertion
    cursor by words and also extend the selection.
    
-   ``Up Arrow`` and ``Down Arrow`` move the insertion cursor one line up or down and
    clear any selection in the text. 

-   ``Shift Up`` and ``Shift Right`` move the cursor and extend the selection.

-   ``Control-Up`` and ``Control-Down`` move the insertion cursor by paragraphs.

-   ``Control-Shift-Up and ``Control-Shift-Down`` move the insertion cursor by
    paragraphs and extend the selection. ``Control-p`` and ``Control-n`` behave
    the same as ``Up`` and ``Down``, respectively. **Note**: by default, Leo
    binds ``Control-p`` and ``control-n`` to commands.
    
-   ``Next`` (``Page Down``) and ``Prior`` (``Page Up``) keys move the
    insertion cursor one screen and clear any text selection.

-   ``Shift Next`` and ``Shift Prior`` move the cursor one screen and extend the selection.
    
-   Line movement is by text lines terminated by hard returns (newlines), not by
    displayed lines; if a text line is long and wraps across more than one display
    line, then the ``Up`` and ``Down`` movement will skip the extra wrapped display lines.
    
-   ``Home`` moves the insertion cursor to the beginning of its line and clears any
    selection in the widget.

-   ``Shift-Home`` moves the insertion cursor to the beginning of the line and extends the selection. 
    
-   ``End`` moves the insertion cursor to the end of the line and clear any selection in
    the widget.

-   ``Shift-End moves`` the cursor to the end of the line and extends the selection. 
    
-   ``Control-Home`` moves the insertion cursor to the beginning of the text and clears
    any selection in the widget.

-   ``Control-Shift-Home`` moves the insertion cursor to the beginning of the text and extends the selection. 
    
-   ``Control-End`` moves the insertion cursor to the end of the text and clears any
    selection.

-   ``Control-Shift-End`` moves the cursor to the end of the text and extends the selection. 
    
-   ``Select`` and ``Control-Space`` set the selection anchor to the position of the
    insertion cursor. They don't affect the current selection.

-   ``Shift-Select`` and ``Control-Shift-Space`` adjust the selection to the current position of the
    insertion cursor, selecting from the anchor to the insertion cursor if there was
    no previous selection. 
    
-   ``Control-/`` selects the entire contents of the widget. 
    
-   ``Control-\`` clears any selection in the widget. 
    
-   ``F16``  (``Copy`` on many Sun workstations) or ``Control-c`` copies the
    selection in the widget to the clipboard, if there is a selection.
    
-   ``F20` (``Cut`` on many Sun workstations) or ``Control-x`` copies the
    selection in the widget to the clipboard and deletes the selection.
    These keys have no effect if no text is selected.
    
-   ``F18`` (``Paste`` on many Sun workstations) or ``Control-v`` inserts the
    contents of the clipboard at the position of the insertion cursor.
    
-   ``Delete`` deletes the text selection, or the character to the right of the cursor
    if there is no text selection.
    
-   ``Backspace`` deletes the selection, or character to the left of the cursor
    if there is no text selection.</t>
<t tx="EKR.20040524104904.40">You can expand or contract a node by clicking in the standard Windows Tree
View icon to the left of the status icon. Expanding a node shows its immediate
children; contracting a node hides all its children. The ``Expand All Subheads``
command expands all of a nodes offspring (children, grandchildren, etc.)</t>
<t tx="EKR.20040524104904.41">Leo auto indents body text following colons when ``@language Python`` is in
effect. When the ``smart_auto_indent`` setting is True, Leo uses Emacs-style
auto-indentation instead. This style of auto-indent aligns newly created lines
with unmatched ``(`` ``[`` or ``{`` brackets in the previous line.</t>
<t tx="EKR.20040524104904.43">You can mark nodes in several ways:

- With the ``Mark`` commands.

- With the ``Find`` or ``Change`` commands.

- With the ``Untangle`` command.

The ``Go To Next Marked`` command selects the next marked node, if any.
The ``Mark`` command unmarks the selected headline if it is already marked.</t>
<t tx="EKR.20040524104904.44">The ``Move Up``, ``Move Down``, ``Move Left`` and ``Move Right`` commands move the currently
selected node. The ``Promote`` command makes all the children of a node
siblings of the node. The ``Demote`` command makes all following siblings of a
node children of the node.

You can cut and paste any part of a tree. If a node contains selected text,
the cut, copy, clear or paste operation affects only the selected text.
Otherwise, the cut, copy, clear or paste operations acts on the node and all
nodes contained by it. For example, you can move a node by cutting it,
selecting another location in the outline and pasting the node in the new
location.

**Warning**: In practice, it is almost always wiser to move clones rather than
cutting or pasting them. Cutting and pasting outlines preserves clones, but the
links between clones only exist within the part of the outline that was pasted.
Therefore, if you are cutting and pasting an outline containing clones it is
best to cut and paste the _entire_ outline. Alternatively, you can paste part of
an outline, then delete all clones. 
</t>
<t tx="EKR.20040524104904.45">Double-clicking the icon box of a node whose headline has the form::

    @url &lt;any url&gt;

executes the url in your default web browser.

Leo checks that the url is valid before doing so. A valid url is:

-   3 or more lowercase alphas
-   followed by one ``:``
-   followed by one or more of:
-   ``$%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~``
-   followed by one of: ``$%&amp;'()*+/0-9:=?@A-Z_a-z}~``

Url's should contain no spaces: use ``%20`` to indicate spaces. You may use any
type of url that your browser supports: http, mailto, ftp, file, etc.</t>
<t tx="EKR.20040524104904.47">You can change the relative sizes of the outline and body panes by dragging the
splitter bar. The ``Equal Sized Panes`` command resizes the panes so that each
fills half of the main window.</t>
<t tx="EKR.20040524104904.48">Leo supports unlimited undo for all typing and all commands. The
'undo_granularity' setting controls the granularity of undo. There are four
possible values:

``node``
    Starts a new undo unit when typing moves to a new node.

``line`` (default)
    Starts a new undo unit when typing moves to new line.

``word``
    Starts a new undo unit when typing starts a new word.

``char`` (not recommended)
    Starts a new undo unit for each character typed.
    This wastes lots of computer memory.

``setUndoTypingParams`` calls ``recognizeStartOfTypingWord`` to recognize the
start of words. Plugins can modify ``recognizeStartOfTypingWord``. It should
return ``True`` if the typing indicated by the params starts a new 'word' for the
purposes of undo with 'word' granularity. ``setUndoTypingParams`` calls this
method only when the typing could possibly continue a previous word. In other
words, undo will work safely regardless of the value returned. See the actual
code for ``recognizeStartOfTypingWord`` for more details.</t>
<t tx="EKR.20040524104904.92">An @asis tree is a tree whose root headline starts with @asis &lt;filename&gt;.  Similarly, for @noref and @nosent trees.

New in 4.2:  The following terms are equivalent.  The first form is preferred in each case.

@asis, @file-asis, @silent
@nosent, @file-nosent and @nosentinelsfile
@noref, @file-noref and @rawfile

You can get any combination of sentinels/no sentinels and references/no references using @file, @nosent, @noref and @asis trees:

                 Derived files        Sections and 
Type of tree   contain sentinels?   @others expanded?
------------   ------------------   -----------------
       @asis   no                   no
       @file   yes                  yes
      @noref   yes                  no
     @nosent   no                   yes
     
       

Leo can not update the outline from changes made from derived files unless those files contain sentinels.  The primary source for @nosent and @asis trees are the outlines from which those files were derived.

Leo creates files derived from @noref and @asis trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. However, Leo recognizes the @ignore directive in the _ancestors_ of @noref or @asis nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

Notes:

1. When writing @noref trees, Leo writes only the @+leo, @-leo, @+node, @-node, @+body and @-body sentinels.

2. Within @asis trees only, if a headline starts with @@, Leo writes everything in the headline following the @@ just before the corresponding body text.

3. Files derived from @asis trees contain _nothing_ not contained in body text (or @@ headlines).  In particular, if body text does not end in a newline, the first line from the next node will concatenated to the last line of the preceding node.</t>
<t tx="EKR.20040524104904.99"></t>
<t tx="EKR.20040524104904.100"></t>
<t tx="EKR.20040524104904.101">-   The ``New`` command creates a new Leo main window.

-   The ``Open`` command opens an existing Leo file and shows it in a main window.

-   The ``Close`` command closes the topmost Leo window,
    giving you an opportunity to save your work if you haven't yet done so.

-   The ``Save``, ``Save As`` and ``Save To`` commands save the Leo window to a file.
    The ``Save As`` command changes the name of the outline being edited;
    the ``Save To`` command does not.

-   The ``Revert`` command reloads a file, discarding any changes made to the file since it was last saved.

-   The ``Recent Files`` command brings up a submenu containing a list of recently
    opened files. Choosing an item in this submenu opens the selected file or brings
    it to the front.

-   The ``Clear Recent Files`` command deletes all entries in the Recent
    Files submenu except the most recent file. The files themselves are not
    affected, just the menu entries.

The following commands are located in the ``Read/Write`` menu, part of the
``File`` menu.

-   The ``Read Outline Only`` command reads an outline using only the .leo file, not any files derived
    from ``@file`` nodes. This command is useful for reverting a project to a
    previously saved state.

-   The ``Read @file Nodes`` command updates all ``@file`` nodes in an outline.
    This ensures that the state of an outline matches all files derived
    from ``@file`` nodes. 

-   The ``Write Outline Only`` command saves an outline without writing any ``@file``
    trees. Useful for inserting an @file node into an outline without modifying a
    derived file with the same name.

-   The ``Write @file Nodes`` command forces an update of all @file trees.

-   The ``Write Dirty @file Nodes`` command writes all ``@file`` trees that have been changed.</t>
<t tx="EKR.20040524104904.102">The ``Open With`` command allows you to communicate with external editor. When
you select this command Leo creates a temporary file and invokes an external
program. Leo periodically checks whether this temporary file has changed; Leo
changes the corresponding node in the outline if so. You must create the entries
in the Open With submenu. This would typically be done in a hook routine, using
the createOpenWithMenuFromTable routine described in the child of this node. The
``@file mod_open_with.py`` node in ``LeoPlugins.leo`` gives a complete example
of handling the ``Open With`` menu.</t>
<t tx="EKR.20040524104904.105">The ``Tangle``, ``Tangle All`` and ``Tangle Marked`` commands create derived
files from portions of an outline. These commands indent and format the derived
files so that they are easy to read and so that it is clear what sections
produced the code. The .c file in the Examples folder shows the code produced by
the Tangle commands. The ``Tangle`` command tangles only the selected portion of
the outline, the ``Tangle All`` command tangles the entire outline, and the
``Tangle Marked`` command tangles only marked headlines.

The ``Tangle`` commands create a derived file, call it F, from each ``@root``
node. This process is like macro expansion. The contents of F are simply the
body text of the ``@root node``, with each section reference replaced by its
definition. Substitution continues until all references to sections are replaced
with their definitions. By default, ``Tangle`` commands look for section
definitions only in the suboutline containing the ``@root`` directive being
tangled. That is, all sections are assumed to be defined either in the body text
of the headline, say h, containing the
@root directive, or in the body texts of the descendants of h.
The ``@unit`` directive changes the default scope of the tangle command, while
the ``@ignore`` directive causes the tangle commands to ignore a subtree. For
more details, see: `Tangling @root trees with the Tangle commands`_</t>
<t tx="EKR.20040524104904.106">The ``Untangle``, ``Untangle All`` and ``Untangle Marked`` commands are the
reverse of the corresponding ``Tangle`` commands. They update an outline based
on changes made to one or more derived files. These are exceptionally useful
commands. For example, suppose you create a new part of the outline and
``Tangle`` it for the first time. When you compile the resulting derived files
for the first time, you are likely to get many syntax errors. You could fix
those errors in the outline and Tangle the outline again, but there is a much
easier way: you fix the errors in the derived files using the compiler's editor,
then run the untangle command on the part of the outline that created the
derived file. The ``Untangle`` command updates the selected outline to match the
changes in the derived files. It's as simple as that. The ``Untangle`` command
marks all the nodes in the outline that it updates; you can examine all such
nodes with the ``Go To Next Marked`` command in the Outline menu. You cannot use
``Untangle`` to update doc parts, or leading comments in code parts or "trivial"
whitespace in code parts. This is a limitation of the ``Untangle`` command that
cannot be fixed; ``Untangle`` has no way of knowing whether leading comments
came from doc parts or are just leading comments.

``Untangle`` never changes the structure of an outline; it never inserts,
deletes or moves nodes. Don't attempt to change the structure of an outline by
modifying derived files; it won't work. Also, never delete, move or alter the
sentinel lines in derived files written by the Tangle command. Such lines start
with ``///`` followed by a section name. If you change the section name in a
sentinel line ``Untangle`` will not update the code in the outline (with the old
name) that generated the renamed section. Untangle now warns about sections that
appear in a derived file but not in the outline. Untangle has no trouble with
changed section references in derived files; it is only changed sentinel lines
that cause problems. Cloned nodes that generate code in several files may cause
problems for ``Untangle`` if not all the code is changed the same way in derived
files. If ``Untangle`` is run separately on these derived files, Untangle will
update all cloned nodes each time it is run, so only the code in the last
``Untangle`` run will take effect. Therefore, the only reliable way to update
text in cloned nodes is to make the change in the .leo file rather than the
derived files.</t>
<t tx="EKR.20040524104904.108">The ``Import`` commands do not attempt to do perfect translations; they merely automate the bulk of the drudgery:

-   The ``Import to @file`` command creates an ``@file`` node from a file.

-   The ``Import to @root`` command creates an ``@root node`` from a file.

-   The ``Import CWEB Files`` command creates an @file node from a `CWEB`_ file.

-   The ``Import noweb Files`` command creates an @file node from a `noweb`_ file.

-   The Import Derived File command imports all the nodes in a derived file into the outline.
    Unlike the read commands, the command preserves no outline structure.

-   The ``Import Flattened Outline`` command converts plain text written in ``MORE`` format to an outline.

The ``Import Flattened Outline`` command brings up a dialog which will accept at
most one file. If that file contains MORE-format text it creates an outline
corresponding to that text. ``MORE`` is a now-defunct outliner program. ``MORE``
represents outlines as follows. Headlines are denoted by a leading ``+`` or
``-`` character, preceding by zero or more tabs that denote the level of the
headline. Body text follows its headline, with no indentation. The original
``MORE`` format did not escape lines in the body text that started with ``+`` or ``-``.
Leo escapes such characters by preceding ``+``, ``-`` or backslash with a
backslash.</t>
<t tx="EKR.20040524104904.109">-   The ``Outline To CWEB`` command creates a `CWEB`_ file from the selected outline.

-   The ``Outline TO noweb`` command creates a `noweb`_ file from the selected outline.

-   The ``Flatten Outline`` command creates a text file in ``MORE`` format from the selected outline.
    See the previous section for a discussion of ``MORE`` format.

-   The ``Remove Sentinels`` command removes all sentinel lines from a file derived from an ``@file`` node.

-   The ``Weave`` Command formats the selected text and writes it to a file.</t>
<t tx="EKR.20040524104904.110">The ``Quit`` command causes Leo to exit. You may also exit Leo by closing the
main window. You will be prompted to save any file that has been altered but not
saved.</t>
<t tx="EKR.20040524104904.111"></t>
<t tx="EKR.20040524104904.112">Leo supports unlimited undo and redo. Think of actions that may be undone or
redone as a string of beads. A "bead pointer" points to the present bead.
Performing an operation creates a new bead after the present bead and removes
all following beads. Undoing an operation moves the bead pointer backwards;
redoing an operation moves the bead pointer forwards. The ``Undo`` command is
disabled when the bead pointer moves in front of the first bead; the ``Redo``
command is disabled when the bead pointer points to the last bead.
</t>
<t tx="EKR.20040524104904.113">Leo supports the standard editing commands: ``Cut``, ``Copy``, ``Paste``,
``Clear`` and ``Select All``. These commands work with either headline or body
text.
</t>
<t tx="EKR.20040524104904.114">The ``Shift Left`` and ``Shift Right`` commands shift selected lines in the body
text left or right one tab position. These commands shift the entire line if any
characters in that line are selected.</t>
<t tx="EKR.20040524104904.115">The Extract, Extract Section and Extract Section Names commands create child nodes whose headline is the first line of the selected body text.

-   The ``Extract command`` creates a new node whose headline is the first line of selected body text and
    whose body is all other lines of selected text.
    Previously selected text is deleted from the original body text. 

-   The ``Extract Section command`` creates a new node whose headline is the first line of selected text and
    whose body is ``@code`` followed by all the other lines of selected text.
    All selected text lines except the first line are deleted from the original body text.
    This command is enabled only if the first line contains nothing but section name.

-   The ``Extract Section Names`` command creates one or more child nodes,
    one for each section name in the selected body text.
    The headline of each created node is the section name; the body text is ``@code`` followed by a newline.</t>
<t tx="EKR.20040524104904.116">-   The Convert Tabs command converts leading tabs to blanks in a single node.
-   The Convert Blanks command converts blanks to tabs in a single node.
-   The Convert All Tabs converts leading tabs to blanks throughout the selected tree.
-   The Convert All Blanks command converts leading blanks to tabs throughout the selected tree.

All these commands convert between tabs and blanks using the tab width presently in effect.</t>
<t tx="EKR.20040524104904.117">The ``Execute Script`` command executes body text as a Python script. Leo
execute the selected text, or the entire body text if no text is selected. The
``Execute Script`` command pre-defines the values ``c``, ``g`` and ``p`` as
follows:

- ``c`` is the commander of the outline containing the script.
- ``g`` is the leoGlobals modules.
- ``p`` is ``c.currentPosition()``.

**Important**: Body text may contain Leo directives and section references. You
can now use all of Leo's features to organize scripts that you execute
interactively. Section definitions must appear in the node containing the script
or in descendant nodes.

Leo preprocesses all scripts by simulating the writing of a derived file to a
string. The ``Execute Script`` command sets ``app.scriptDict["script1"]`` to the
value of the script before preprocessing, and sets ``app.scriptDict["script2"]``
to the value of the script after preprocessing. Scripts may examine and change
app.scriptDict as they please.</t>
<t tx="EKR.20040524104904.118">The following check boxes options appear in the search dialog and control the operations of the find and change commands.

Clone Find All
    When checked, the the Find All command creates a new root node called ``Found:`` *&lt;your search pattern&gt;*.
    This node contains clones of the nodes found by the Find All command.
    It is your responsibility to navigate to this new node and to clean it up when it's no longer needed.

Ignore Case
    When checked, the ``Find and Change`` commands ignore the case of alphabetic characters when determining matches.

Mark Changes
    When checked, the ``Change`` command marks all headlines whose headline or body text are changed by the command.

Mark Matches
    When checked, the ``Find and Change`` commands mark all headlines in which a match is found with the pattern.

Pattern Match
    When checked, the ``Find and Change`` commands treat several characters specially in the find pattern.
    
    - '*'  matches any sequence of zero or more characters.
    - '.'  matches any single character.
    - '^'  matches a newline at the start of a pattern.
    - '$'  matches a newline at the end of a pattern.

Examples::

    "^abc$" matches lines that only contain "abc".
    "^a" matches any line starting with "A".
    "a$" matches any line ending with "a".
    "^*$" matches any line at all.

Reverse
    When checked, the ``Find and Change`` commands search backward through the file.

Search Body Text
    When checked, the ``Find and Change`` commands search body text.

Search Headline Text
    When checked, the ``Find and Change`` commands search headline text.

Show Context
    When checked, the ``Find All`` command shows additional context information when printing matches.

Suboutline Only
    When checked, the ``Find and Change`` commands search only the currently selected headline and its offspring.

Whole Word
    When checked, the find pattern must match an entire word.
    Words consist of an alphabetic character or underscore, followed by zero or more
    alphabetic characters, numbers or underscores.

Wrap Around
    When checked, the ``Find and Change`` commands continues at the top of the file when
    the command reaches the bottom of the file.
    For reverse searches, the find or change command continues at the bottom of the file when
    the command reaches the top of the file.</t>
<t tx="EKR.20040524104904.134">The ``Go To Line Number`` command selects the locations in your outlines corresponding to a line in a derived file.
</t>
<t tx="EKR.20040524104904.136">The ``Insert Body Time/Date`` and ``Insert Headline Time/Date`` commands insert
formatted time and date into body or headline text. You must be editing a
headline to be able to insert the time/date into the headline.
The `` body_time_format_string`` and ``headline_time_format_string`` settings
specify the format of the inserted text. These settings are the format string
passed to time.strftime. For a complete list of the format options see
http://www.python.org/doc/current/lib/module-time.html
If the format specified by either of these two settings is erroneous the
``"%m/%d/%Y %H:%M:%S"`` format is used by default, resulting in a time/date
format like::

    1/30/2003 8:31:55</t>
<t tx="EKR.20040524104904.137">The Reformat Paragraph command rearranges the words in a text paragraph to fill
each line as full as possible, up to the ``@pagewidth`` setting. A paragraph is
delimited by blank lines, Leo directives, and (of course) start and end of text
in a node. The width of the line used by the reformatting operation is governed
by ``@pagewidth`` and the indentation that would be applied to the node when
tangled (as part of a ``@root``) or written (as part of a ``@file``).

The command operates on the paragraph containing the insert cursor. If the
insert cursor is on a blank line or directive, nothing happens. If the cursor is
on a line containing text, then the paragraph containing that text line is
reformatted and the insert cursor is moved to the next paragraph.

**Note**: Hanging indentation is preserved. This is most useful for bulleted or
numbered lists, such as::

  1. This is the first paragraph,
     and it has a hanging indentation.

  2. This is the second paragraph,
     and it too has a hanging indentation.</t>
<t tx="EKR.20040524104904.139">The ``Match Brackets`` command is enabled if the cursor is next to one of the
following characters in the body pane:

    ( ) [ ] { } &lt; &gt;

This command looks for the matching character, searching backwards through the
body text if the cursor is next to `)` `]` `}` or `&gt;` and searching forward through the
text otherwise. If the cursor is between two brackets the search is made for the
bracket matching the leftmost bracket. If a match is found, the entire range of
characters delimited by the brackets is highlighted and the cursor is placed
just to the left of the matching characters. Thus, executing this command twice
highlights the range of matched characters without changing the cursor.</t>
<t tx="EKR.20040524104904.140">Leo stores options in ``@settings`` trees, that is, outlines whose headline is
``@settings``. When opening a .leo file, Leo looks for ``@settings`` trees not only
in the outline being opened but also in various leoSettings.leo files.
The key design goal of ``@settings`` trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with ``@settings`` trees. Leo settings outlines
are, in fact, much more flexible and powerful than any scheme based on
flat text.

The ``Settings`` command opens the file leoSettings.leo.

Leo stores options in ``@settings`` trees, that is, parts of Leo outlines whose root
node has the headline ``@settings``. When opening a .leo file, Leo looks for
``@settings`` trees in the following places:

- The file ``leoSettings.leo`` in the leo/config directory.
- The file ``leoSettings.leo`` in the user's home directory.
- The file being loaded.

Settings that appear later in the above list override settings found earlier. For
example, any setting specified in an ``@settings`` tree in the file being loaded
overrides any setting seen in any ``leoSettings.leo`` file.

The format of nodes in ``@settings`` trees are as follows:

1. Leo ignores any subtree of an ``@settings`` tree whose headline starts with ``@ignore``.

2. "Simple settings nodes" have headlines of the form::

    @&lt;type&gt; name = val

set the value of ``name`` to ``val``, with the indicated type.

&lt;type&gt; may be one of the following:

=============== ================================================================================
&lt;type&gt;          Valid values
--------------- --------------------------------------------------------------------------------
\@bool           True, False, 0, 1
\@color          A Tk color name or value, such as 'red' or 'xf2fddff' (without the quotes)
\@directory      A path to a directory
\@float          A floating point number of the form nn.ff.
\@int            An integer
\@ints[list]     An integer (must be one of the ints in the list).
                 Example: @ints meaningOfLife[0,42,666]=42
\@path           A path to a directory or file
\@ratio          A floating point number between 0.0 and 1.0, inclusive.
\@shortcut       A valid shortcut specifier.
\@string         A string
\@strings[list]  A string (must be one of the strings in the list).
                 Example: @strings tk_relief['flat','groove','raised']='groove'
=============== ================================================================================

**Note**: For a list of Tk color specifiers see:

- http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm
- http://www.tcl.tk/man/tcl8.4/TkLib/GetColor.htm

**Important**: you can use the show-colors minibuffer command to guide you in making these settings.

3. "Complex settings nodes" have headlines of the form::

    @&lt;type&gt; description

The actual settings are specified in the body text.  At present, there are four such kinds of complex settings nodes:

- ``@font``

The body text contains a list of settings for a font.  For example::

    body_text_font_family = Courier New
    body_text_font_size = None
    body_text_font_slant = None
    body_text_font_weight = None

**Important**: you can use the show-fonts minibuffer command to guide you in making these settings.

- ``@mode`` *&lt;mode name&gt;*

The body text contains a list of shortcut specifiers.  ``@mode`` nodes work just like ``@shortcuts`` nodes, but in addition they have the side effect of creating the ``enter-&lt;mode name&gt;-mode`` command.

- ``@recentfiles``

The body text contains a list of paths of recently opened files, one path per line.
Leo writes the list of recent files to ``.leoRecentFiles.txt`` in Leo's ``config`` directory,
again one file per line.

- ``@shortcuts``

The body text contains a list of shortcut specifiers.</t>
<t tx="EKR.20040524104904.143"></t>
<t tx="EKR.20040524104904.144">-   The ``Check Outline`` command checks the outline for consistency.

-   The ``Check All Python Code`` and ``Check Python Code`` commands report any syntax errors or tabnanny errors.
    These commands mark erroneous nodes and ignore any nodes for which:

        - ``@ignore`` is in effect or
        - ``@language python`` is in not effect.

-   The ``Check Python Code`` and ``Pretty Print Python Code`` pretty print body text.
    You can customize this code by overriding the following methods of class ``prettyPrinter`` in ``leoCommands.py``::
    
        putOperator:      puts whitespace around operators.
        putNormalToken:   puts whitespace around everything else.</t>
<t tx="EKR.20040524104904.145">-   The ``Insert Headline`` command inserts a new headline after the presently selected headline,
    either as the next sibling or the first child of the presently selected headline
    if the presently selected headline has children and is expanded.

-   The ``Clone Node`` creates a clone of the selected node.
    See `Clones and views`_ for full details about clones.</t>
<t tx="EKR.20040524104904.146">-   The ``Cut Outline`` and ``Copy Outline`` commands copy a text
    representation of the outline to the clipboard. This representation is the same
    as the file format with some information deleted.

-   The ``Paste`` command (in the ``Edit`` menu) copies this representation into the *body* pane.

-   The ``Paste Node As Clone`` command pastes the node from the clipboard, retaining the
    identity of nodes.  Thus, if the pasted node already exists in the outline the newly
    pasted node will become of a clone of the already-existing node.

-   The ``Paste Outline`` command creates nodes with new identities (new gnx's).</t>
<t tx="EKR.20040524104904.147">-   The ``Expand`` command expands the currently selected node so that all its children are visible.
-   The ``Expand All Subheads`` command expands the currently selected node so that all its offspring are visible.
-   The ``Expand All`` command expands all the nodes of the entire tree.
-   The ``Contract Parent`` contracts the selected node's parent and selects the parent node.</t>
<t tx="EKR.20040524104904.148">-   The ``Hoist`` command redraws the screen so presently selected tree becomes the only visible part of the outline.
    Hoist commands may be nested.  

-   The De-hoist command restores the outline.</t>
<t tx="EKR.20040524104904.149">-   The ``Mark Headline`` command marks a headline with a red marker  near the leader characters.
-   The ``Unmark Headline`` command removes such a mark.
-   The ``Mark Subheads`` command marks all offspring of the currently selected node.
-   The ``Unmark All`` command removes the marks from the entire tree.
-   The ``Mark Changed Items`` command marks all headlines whose headline or
    body text has been changed since the file was last saved.
-   The ``Mark Changed Roots`` command marks all changed headlines whose body text contains the ``@root`` directive.
    This command is especially useful with the Tangle Marked command.</t>
<t tx="EKR.20040524104904.150">-   The ``Move Up``, ``Move Down``, ``Move Left`` and ``Move Right`` commands move the currently selected node.

-   The ``Promote command`` makes all the children of a node siblings of the node.

-   The ``Demote`` command makes all the siblings that follow a node children of the node.

-   The ``Sort Children`` command sorts all children of the present node in alphabetical order of their headlines.

-   The ``Sort Siblings`` command sorts all siblings of the present node in alphabetical order.</t>
<t tx="EKR.20040524104904.151">-   The ``Equal Sized Panes`` command adjusts the sizes of the outline and body
    panes so that they are the same height.
-   The ``Cascade`` command cleans up the screen by cascading all Leo windows.
-   The ``Minimize All`` command minimizes all Leo windows.
-   The ``Toggle Active Pane`` command toggles keyboard focus between the outline and body panes.
-   The ``Toggle Split Direction`` command switches between vertical and horizontal
    orientations of the Leo window. In the vertical orientation, the body pane
    appears below the pane containing the outline and log panes. In the horizontal
    orientation, the body pane appears to the left the pane containing the outline
    and log panes. By default, the ratio of pane outline pane to the body pane is
    0.5 in the vertical orientation and 0.3 in the horizontal orientation. These two
    ratios may be changed using settings.
-   The ``Open Compare Window`` command opens a dialog that allows you to compare
    two files, one containing sentinels and one not.
</t>
<t tx="EKR.20040524104904.157">-   The ``About Leo`` command puts up a dialog box showing the version of Leo.
-   The ``Online Home Page`` command opens Leo's home page at http://webpages.charter.net/edreamleo/front.html.
-   The Open Online Tutorial command opens Joe Orr's excellent ScreenBook tutorial at
    http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm.
-   The Open Offline Tutorial command opens the file sbooks.chm if it exists.
    Otherwise, you will be asked whether you want to download it from Leo's SourceForge web site.
    If you say yes, the page http://sourceforge.net/project/showfiles.php?group_id=3458 will open.
    You may then download sbooks.sbm to the folder containing leo.py.
-   The ``Open LeoDocs.leo`` command opens ``LeoDocs.leo``.
-   The ``Open LeoPlugins.leo`` command opens ``LeoPlugins.leo``.
-   The ``Open LeoSettings.leo`` command opens ``LeoSettings.leo``.

</t>
<t tx="EKR.20040524104904.161"></t>
<t tx="EKR.20040524104904.162">The following paragraphs discuss the main benefits of traditional `literate programming`_.
**Note**: none of these benefits depends on printed output.

**Design and coding happen at the highest possible level**.
The names of sections_ are constrained only by one's design skill, not by any
rules of language. You say what you mean, and that becomes both the design and
the code. You never have to simulate a concept because concepts become `section
names`_.

**The visual weight of code is separate from its actual length**.
The visual weight of a section_ is simply the length and complexity of the
`section name`_, regardless of how complex the actual definition of the section
is. The results of this separation are spectacular. No longer is one reluctant
to do extensive error handling (or any other kind of minutia) for fear that it
would obscure the essence of the program. Donald Knuth stresses this aspect of
literate programming and I fully agree.

**Sections show relations between snippets of code**.
Sections_ can show and enforce relationships between apparently unrelated pieces
of code. Comments, macros or functions are other ways to indicate such
relationships, but often sections are ideal. Indeed, a natural progression is to
create sections as a matter of course. I typically convert a section to a
function only when it becomes apparent that a function's greater generality
outweighs the inconvenience of having to declare and define the function.

**Complex section names invite improvements**.
A `section name`_ is complex when it implies unwholesome dependencies between the
caller (user) of the section and the section_ itself. Such section names tend to
be conspicuous, so that the programmer is lead to revise both the section name
and its purpose. Many times my attention has been drawn to a poorly conceived
section because I didn't like what its name implied. I have always been able to
revise the code to improve the design, either by splitting a section into parts
or be simplifying its relation to colleagues.

**Sections create a place for extensive comments**.
One of the most surprising thing about `literate programming`_ is how severely
traditional programming tends to limit comments. In a conventional program the
formatting of code must indicate structure, and comments obscure that
formatting. Sections_ in literate programming provide a place for lengthy
comments that do not clutter the code at the place the section is
referenced_.

**Section names eliminate mundane comments**.
The `section name`_ often says it all. The reference_ to the section says everything
that the user needs to know, and the section name at the point of definition
also eliminates the need for many comments.

**Sections create comments automatically**.
A typical `@root node`_ starts out with something like::

	&lt;&lt; includes for class x &gt;&gt;
	&lt;&lt; private data for class x &gt;&gt;
	&lt;&lt; private prototypes for class x &gt;&gt;
	&lt;&lt; functions of class x &gt;&gt;

In the derived file there is a comment that looks like this::

	/// &lt;&lt; includes for class x &gt;&gt;

It would be silly to write this comment by hand, though often programmers do
just that in order to have a place holder for a mark in the source file. With
`literate programming`_ the situation is different: the comment indicates that the
code came from a particular section_; that is, the comment servers a real
purpose.

**Literate programming clarifies the shape of code**.
These last several paragraphs have discussed comments in detail because the net
effect of "putting comments where they belong" is that comments don't clutter
the code. `Section references`_ hide irrelevant detail, so larger-scale patterns
within functions (or declarations) become more apparent. Often just recasting
code into web format has created Aha's about my own code, with no special
attention to recoding or redesign! Recasting a function as a web raises the real
and apparent level of abstraction.

**I spend less time formatting code**.
Formatting no longer has to indicate overall design; sections do that. I am less
obsessive about formatting code; it simply doesn't matter much whether different
sections are formatted consistently because the format of one section has no
effect on the look of other sections. Also, I don't worry about most line breaks
within `documentation parts`, or about adding comment delimiters.

**Literate programming creates a new design dimension**.
Sections_ add a new dimension to the design and coding process. Choices about
what sections do, what they are named, what order they appear in, are choices in
a design space different from "normal" programming. This an abstract concept, to
be sure. However, the previous paragraphs are really a manifestation of
working in this new design space.</t>
<t tx="EKR.20040524104904.173">Outlines_ add something brand new to traditional `literate programming`_, namely an
explicit mechanism for expressing structure at any level of detail, from largest
overall view to smallest detail. The following paragraphs elaborate on this theme.

**Outlines add context**.
There are too many sections_ in conventional `literate programming`. It becomes
difficult to understand the relationships between sections. Using an outline_ to
express a literate programming instantly solves this problem. The programmer is
always aware of how sections are related.

**Outlines provide scope for commands**.
Outlines_ provide a convenient way of expressing the intended scope of commands.
For example, the ``Tangle`` command operates only on the presently selected tree_.
The ``Extract Section`` command creates a new section_ as the last child_ of the
present node_.

**Clones create different views and focus attention**.
Clones_ can create different views of the outline. An outline_ can contain many such views.
`Clones &amp; views`_ discusses the implications of clones in detail.

**Outlines increase flexibility**.
`Organizer nodes`_ do not affect derived files in any way, but organizer nodes
often convey the most information about the structure and design of a large
system. Decoupling structure from content in this way is precisely what is
needed for flexibility: one can reorganize at will without worrying about
changing the meaning of the code.

**Outlines express hierarchy directly**.
Hierarchy is often implicit in programming: for example, the grouping of
functions into files, or the organization of a single file as a set of
functions, etc. An outline_ directly expresses hierarchy. Many of Leo's commands_
operate on the presently selected node. It is natural to apply operations on
selected node_ of the outline.

**reStructuredText is much easier to use than CWEB markup.**
Leo's `rst3 plugin`_ makes it easy to use reStructuredText_ (rST) instead of CWEB_
markup. For most purposes, rST suffices, and rST is much easier to use and less
intrusive than CWEB_.

**Outlines create new design dimensions**.
There are many ways to express a program as a Leo outline. Such choices are
important. They add clarity to the entire program. These are different *kind* of
choices. They simply can not be expressed at all in other editors. In other
words, such choices exist in a new design space. 

**Leo improves tangling and adds untangling**.
Tangling_ and untangling_ are fundamental operations of `literate programming`_.
Leo tangles and untangles files derived from `@file trees`_ automatically. This
is an important convenience.</t>
<t tx="EKR.20040524104904.181">Leo changes the theory and practice of literate programming as follows:

**Leo reduces the need for comments**.
In particular, bridge or transition phrases are almost always unnecessary in a
Leo outline_. One never needs to say something like, "having just finished
with topic x, we turn now to topic y." Leo's outlines tend to be far less
chatty than flat literate programs.

**Leo reduces the need for printed listings**.
Experience with the ``Weave`` command shows that an outline can easily become
unintelligible when printed, no matter how "beautiful" the typeset printout is.
No printed listing can be as clear as Leo's outline view.

**Leo reduces the need for indices and tables of contents**.
You could say the entire outline is a table of contents. Moreover, sections_
must always be defined in a descendant of the node_ containing the `section
reference`_, so there is very little need for an index. 

**Leo shows that outline structure is more powerful than narrative.**
Indeed, narrative style creates severe maintenance problems. The narrative is
soon forgotten, and when that happens it becomes difficult to find anything. The
few times I have tried narrative organization I soon regretted it: things just
weren't where I expected them to be.

**Leo shows that traditional literate programming encourages a too creative approach to programming.**
A dictionary is a better model for programs than a novel. Leo's outlines provide
a more regular organization, while providing space for the most lengthy
discussions when those discussions are required.</t>
<t tx="EKR.20040524104904.211"></t>
<t tx="EKR.20040524104904.224">Naively using plugins can expose you and your .leo files to malicious attacks.
The fundamental principles are::

    Scripts and plugins must never blindly execute code from untrusted sources.

and::

    .leo files obtained from other people may potentially contain hostile code.

Stephen Schaefer summarizes the danger this way::

    I foresee a future in which the majority of leo projects come from
    marginally trusted sources...a world of leo documents sent hither and yon -
    resumes, project proposals, textbooks, magazines, contracts - and as a race
    of Pandora's, we cannot resist wanting to see "What's in the box?" And are
    we going to fire up a text editor to make a detailed examination of the
    ASCII XML? Never! We're going to double click on the cute leo file icon, and
    leo will fire up in all its raging glory. Just like Word (and its macros) or
    Excel (and its macros).

In other words::

    When we share "our" .leo files we can NOT assume that
    we know what is in our "own" documents!

Not all environments are untrustworthy. Code in a commercial cvs repository is
probably trustworthy: employees might be terminated for posting malicious code.
Still, the potential for abuse exists anywhere.

In Python it is very easy to write a script that will blindly execute other scripts::

    # Warning: extremely dangerous code

    # Execute the body text of all nodes that start with `@script`.
    def onLoadFile():
        for p in c.allNodes_iter():
            h = p.headString().lower()
            if g.match_word(h,0,"@script"):
                s = p.bodyString()
                if s and len(s) &gt; 0:
                    try: # SECURITY BREACH: s may be malicious!
                        exec(s + '\n')
                    except:
                        es_exception()

Executing this kind of code is typically an intolerable security risk.
**Important**: rexec provides *no protection whatever*.
Leo is a repository of source code, so any text operation is potentially malicious.
For example, consider the following script, which is valid in rexec mode::

    badNode = c.currentPosition()
    for p in c.allNodes_iter():
        &lt;&lt; change `rexec` to `exec` in p's body &gt;&gt;
    &lt;&lt; delete badNode &gt;&gt;
    &lt;&lt; clear the undo stack &gt;&gt;

This script will introduce a security hole the .leo file without doing anything
prohibited by rexec, and without leaving any traces of the perpetrating script
behind. The damage will become permanent *outside* this script when the user
saves the .leo file.</t>
<t tx="EKR.20040524104904.231">The following methods exist for the convenience of plugins.

**g.enableIdleTimeHook(idleTimeDelay=100)**

Enables the "idle" hook. Afterwards, Leo will call the "idle" hook approximately every idleTimeDelay milliseconds.
Leo will continue to call the "idle" hook periodically until ``disableIdleTimeHook`` is called.

**g.disableIdleTimeHook()**

Disables the "idle" hook.

**c.frame.createMenuItemsFromTable (self,menuName,table,openWith=0)**

This method adds items to the menu whose name is menuName.
The table argument describes the entries to be created.
This table is a sequence of items of the form ``(name,shortcut,command)``:

- ``name`` is the command name.
- ``shortcut`` is the shortcut, or`` None`` to indicate no shortcut.
- ``command`` is the routine to execute when the menu item is selected.
- An entry of the form ``("-",None,None)`` creates a separator line between menu items.

For example::

    table =
        ("Toggle Active Pane","Ctrl-T",self.OnToggleActivePane),
        ("-",None,None),
        ("Toggle Split Direction",None,self.OnToggleSplitDirection))
    c.frame.createMenuItemsFromTable("Window",table)

If the ``openWith`` keyword argument is 1 the items are added to a submenu of the Open With menu.
However, it will be more convenient to use the ``createOpenWithMenuFromTable`` method to create the ``Open With`` menu.

**c.frame.createNewMenu (self,menuName,parentName="top")**

This method creates a new menu:

- menuName is the name of the menu to be created.
- parentName is the name of the parent menu, or "top" if the menu is to created in the menu bar.

This method returns the menu object that was created, or None if there was a problem.
Your code need not remember the value returned by this method.  Instead, your code will refer to menus by name.

**c.frame.createOpenWithMenuFromTable (self,table)**

This method adds items to submenu of the ``Open With`` menu item in the ``File`` menu.
The table argument describes the entries to be created.
This table is a sequence of items of the form ``(name,shortcut,data)``:

- name is the command name
- shortcut is the shortcut, or None to indicate no shortcut.
- data is a tuple of the form (command,arg,ext)
- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- arg is an argument to be passed to the given command.
- ext is a file extension or None.

When the user selects the ``Open With`` item corresponding to the table item Leo executes ``command(arg)``.
If ``ext`` is not ``None``, the temp file has the given extension.
Otherwise, Leo computes an extension based on what ``@language`` directive is in effect.
For example::

    table = (
        ("Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
        ("Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
        ("Wordpad","Alt+Shift+T",("os.startfile",None,".txt")))
    
    top().frame.createOpenWithMenuFromTable(table)

**c.frame.deleteMenu (self,menuName)**

Deletes the menu whose name is given, including all entries in the menu.

**c.frame.deleteMenuItem (self,itemName,menuName="top")**

Deletes the item whose name is itemName from the menu whose name is menuName.
To delete a menu in the menubar, specify ``menuName="top"``.

**c.frame.menu.setRealMenuNamesFromTable(table)**

Translates names of menus and menu items into another language.  For example::

    table = (
        ("Help", "&amp;Aide"),
        ("About Leo...", "Au &amp;sujet de Leo..."),
        ("Online Home Page", "&amp;Page d'Accueil en ligne"),
        ("Open Online Tutorial", "Ouvrir &amp;Tutoriel en ligne"),
        ("Open LeoDocs.leo", "Ouvrir Leo&amp;Docs.leo"),
        ("Open LeoConfig.leo", "Ouvrir Leo&amp;Config.leo"),
        ("Apply Settings", "Appliquer les &amp;Réglages"),
    )

    c.frame.menu.setRealMenuNamesFromTable(table)</t>
<t tx="EKR.20040524104904.240">The plugins test suite creates a new convention: if a plugin has a function at
the outer (module) level called ``unitTest``, Leo will call that function when
doing unit testing for plugins. So it would be good if writers of plugins would
create such a ``unitTest function``. To indicate a failure the ``unitTest`` just
throws an exception. Leo's plugins test suite takes care of the rest.</t>
<t tx="EKR.20040524104904.242">Leo reads and writes "foreign" attributes in ``&lt;v&gt;`` and ``&lt;t&gt;`` elements in .leo files as follows:

- When reading a .leo file, Leo will create ``t.unknownAttributes`` or ``v.unknownAttributes`` ivars for
  any ``tnode`` or ``vnode`` whose corresponding ``&lt;v&gt;`` or ``&lt;t&gt;`` element in the .leo file contains a foreign attribute.

- The ``unknownAttributes`` ivars are dictionaries whose keys are the attribute names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if a ``vnode`` or ``tnode`` contains an ``unknownAttributes`` ivar.

- The only native attribute of ``&lt;t&gt;`` elements is ``tx``.

- The native attributes of ``&lt;v&gt;`` elements are ``a``, ``t``, ``vtag`` and ``tnodeList``.

- The native attributes of ``&lt;v&gt;`` elements are ``marks``, ``expanded`` and ``descendentTnodeUnknownAttributes``.

- Non-native attributes are called **foreign** attributes.

- Leo performs the usual xml escapes on these strings when reading or writing the ``unknownAttributes`` ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching unknownAttributes ivars to a vnode or tnode.
Like this::

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes ["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

See the section called "Recommended conventions for plugins" for advice about
how to avoid potential conflicts in naming new attributes.

All members of these dictionaries should be "pickleable". That is, Leo uses
Python's Pickle module to encode all values in these dictionaries. Leo will
discard any attributes that can not be pickled. This should not be a major
problem to plugins. For example, instead of putting a tnode into these
dictionaries, a plugin could put the tnode's gnx (a string) in the dictionary.

Leo writes only ``t.unknownAttributes`` when writing ``@thin`` trees to the .leo
file. Leo puts (the encoding of) these elements into an attribute called
``descendentTnodeUnknownAttributes``. This attribute is part of the ``&lt;v&gt;``
element representing the ``@thin`` node. Leo does _not_ write
``v.unknownAttributes`` in ``@thin`` trees because *only tnodes have gnx's in
thin derived files*. In effect, vnodes are anonymous. We could attempt to get
around this by identifying vnodes by their corresponding tnodes, but that's not
a general solution and it is, in effect, equivalent to writing only
``t.unknownAttributes``. So it seems pointless to "pretend" to be writing
``v.unknownAttributes``.

The effect of this is to make all vnodes identical, as far as using
unknownAttributes is concerned. This won't work in all cases. For example, a
plugin that creates an arbitrary directed graph between vnodes must distinguish
between joined vnodes. In that case, the plugin should confine itself to @file
trees, or just vnodes in .leo files, for that matter.</t>
<t tx="EKR.20040524104904.245"></t>
<t tx="EKR.20040524104904.247">In May of 1999 I began work on the Borland version of Leo for Windows.  The Borland Delphi classes were a pleasure to use and free of bugs.  I redesigned Leo's file format for the Windows version of Leo;  the Yellow Box file format is a binary format that requires the Yellow Box runtime.  Fortunately, I choose to use XML for Leo's file format. I have Marc-Antoine Parent to thank for this decision; he urged me to use XML and patiently explained how to use XML properly.  However, there are two significant problems with the Borland version of Leo.  First, it works only on Windows.  Second, it can never be Open software, because it uses Borland's Delphi classes and a commercial syntax coloring component.

In October of 2001 I began work on the leo.py, an Open Software version of leo.py, a version of Leo written in Python and Tk.  At last I have found the proper platform for Leo.  leo.py naturally supports scripting in Python.  The combination of Python and Tk is incredibly powerful, very easy to use, and truly cross platform.  I rewrote Leo in Python in about two months!  For the first time in my career I no longer am anxious while programming; it simply isn't possible to create bad bugs in Python.</t>
<t tx="EKR.20040524104904.248">The following sections give a pseudo-chronological list of the major Aha's
involved in creating Leo2. These Aha's form the real design and theory of
operation of Leo. See the "Diary", "Notes" and "Letters to Speed Ream" sections
in LeoDocs.leo for a more accurate and less tidy history of Leo2.

I am writing these notes for several reasons. First, the initial design and
coding of Leo2, spanning a period of about 8 weeks, was some of the most
creative and rewarding work I have ever done. The result is elegant and simple.
I'm proud of it. Second, much of the design work is not reflected in the code,
because improved design often eliminated code entirely. The final code is so
elegant that it obscures the hard work that created it. Third, you must
understand this design in order to understand the implementation of @file trees
and their derived files. Someday someone else may take charge of Leo. That
person should know what really makes Leo2 work.</t>
<t tx="EKR.20040524104904.249">In the summer of 2001 I began work on a project that for a long time I had considered impossible.  I had long considered that "private" file formats such as .leo files were the only way to represent an outline properly and safely.  I'm not sure exactly what changed my mind, but I finally was willing to consider that information embedded in derived files might be useful.  This meant accepting the possibility that sentinel lines might be corrupted.  This was a crucial first step.  If we can trust the user not to corrupt sentinel lines than we can embed almost any kind of information into a derived file.

There were several motivations for this work.  I wanted to eliminate the need for explicit Tangle and Untangle commands. I thought of this as "Untangle on Read/Tangle on Write."  If tangling and untangling could be made automatic it would save the user a lot of work.  I also wanted to make derived files the primary sources files.  .leo files might be made much smaller derived files contained the primary source information. This hope turned out to be false.

The result of this design work was something I originally called Leo2, though I now usually prefer to talk about @file trees.  Initially most design issues were unresolved or unknown. I resolved to attempt a robust error-recovery scheme, not knowing in advance what that might involve. I also wanted to solve what I thought of as the "cross-file clone" problem: clones that point from a .leo outline into a derived file. With Leo1 cross-file clones do not exist; everything is in the same .leo file. It was clear that Leo2 would have to change some aspects of clones, but all details were fuzzy.
</t>
<t tx="EKR.20040524104904.250">The next step was also crucial.  I started to use Leo1 as a prototype to design what the new body pane would look like to the user. In retrospect, using Leo1 as a prototype for Leo2 was just as inspired as using MORE as a prototype for Leo1.  Both prototypes marked the true beginning of their respective projects.  The Leo2 prototype was a mockup in Python of the code for reading and writing derived files. The file LeoDocs.leo contain these first prototype nodes.

Writing the prototype got me thinking about improving noweb.  With my experience with Leo1, I was able to create a new markup language that took advantage of outline structure.  I called the new language  "simplified noweb", though that terminology is obsolete.  I created @file nodes to distinguish between the old and new ways of creating derived files.  In Leo1, the @code directive is simply an abbreviation for a section definition line.  Simplified noweb used @c as an abbreviation for @code.  More importantly, simplified noweb used @c to separate doc parts from code parts without necessarily specifying a section name.  It quickly became apparent that most nodes could be unnamed.  All I needed was the @others directive to specify the location for all such unnamed nodes.

From the start, simplified noweb was a joy to use. Indeed, the @others directive could replace all section definition lines.  Furthermore, I could make @doc directive optional if the body pane started in "code mode".  But this meant that plain body text could become a "literate" program! This was an amazing discovery.  These Aha's got me excited about Leo2. This was important, as it motivated me to do a lot of difficult design work.</t>
<t tx="EKR.20040524104904.251">In spite of this excitement, I was uneasy. After much "daydreaming" I realized that I was afraid that reading and writing derived files would be interrupted by a long series of alerts. I saw that designing the "user interaction" during reading and writing would be very important. The next Aha was that I could replace a long series of alerts with messages to the log window, followed by a single "summary" alert. Much later I saw how to eliminate alerts entirely.

At this time I thought there would be two kinds of "errors" while reading derived files. Warnings would alert the user that something non-serious had happened. True errors would alert the user that data might have been lost. Indeed, if Leo2 saves orphan and ignored nodes in a .leo file under an @file node, then read errors could endanger such nodes. Much later I saw that a robust error recovery scheme demands that @file nodes not contain orphan and @ignored nodes. (More on this subject later.) But if orphan and @ignored nodes are moved out of @file trees, there are no read errors that can cause data loss! So the distinction between warnings and errors finally went away.</t>
<t tx="EKR.20040524104904.252">I next turned my attention to writing @file nodes.  A huge Aha: I realized that sentinel lines must contain both a leading and a trailing newline.  The general principle is this: the write code must contain absolutely no "conditional" logic, because otherwise the read code could not figure out whether the condition should be true or false.  So derived files contain blank lines between sentinel lines. These "extra" newlines are very useful, because the read (untangle) code can now easily determine exactly where every blank, tab and newline of the derived file came from.  It would be hard to overstate how important this simplifying principle was in practice.

Much later, with urging from a customer, I realized that the write code could safely remove "extra" newlines between sentinels with a caching scheme in the low level atFile::os() routine. This scheme does not alter the body of the write code in any way: in effect, sentinels still contain leading and trailing "logical" newlines. The read code had to be modified to handle "missing" leading newlines, but this can always be done assuming that sentinels still contain logical leading and trailing newlines!

At about this time I designed a clever way of having the write code tell the read code which newlines were inserted in doc parts. (The whole point of doc parts is to have the write code format long comments by splitting long lines.) To quote from my diary:

"We can use the following convention to determine where putDocPart has inserted line breaks: A line in a doc part is followed by an inserted newline if and only if the newline is preceded by whitespace. This is a really elegant convention, and is essentially invisible to the user.
Tangle outputs words until the line would become too long, and then it inserts a newline. To preserve all whitespace, tangle always includes the whitespace that terminates a word on the same line as the word itself. Therefore, split lines always end in whitespace. To make this convention work, tangle only has to delete the trailing whitespace of all lines that are followed by a 'real' newline."

</t>
<t tx="EKR.20040524104904.253">After the write code was working I turned my attention to the read (untangle) code.  Leo's Untangle command  is the most complex and difficult code I have ever written. Imagine my surprise when I realized that the Leo2 read code is essentially trivial! Indeed, the Leo2 untangle code is like an assembler. The read code scans lines of a derived files looking for "opcodes", that is, sentinel lines, and executes some simple code for each separate opcode. The heart of this code is the scanText routine in atFile.cpp.

The read code was written and debugged in less than two days! It is the most elegant code I have ever written. While perfecting the read code I realized that sentinel lines should show the complete nesting structure found in the outline, even if this information seems redundant. For example, I was tempted to use a single sentinel to represent an @other directive, but finally abandoned this plan in favor of the @+other and @-other sentinels.

This redundancy greatly simplified the read code and made the structure of derived files absolutely clear. Moreover, it turned out that we need, in general, all the information created by the present sentinel lines. In short, sentinels are as simple as they can be, and no simpler.

The atFile::createNthChild method is a very important: it ensures that nodes will be correctly inserted into the outline. createNthChild must be bullet-proof if the Read code is to be robust. Note that the write code outputs @node sentinels, that is, section definitions, in the order in which sections are referenced in the outline, not the order in which sections appear in the outline. So createNthChild must insert the n'th node of parent p properly even if p contains fewer than n-1 children! The write code ensures that section references are properly nested: @node sentinels are enclosed in @node sentinels for all their ancestors in the @file tree. createNthChild creates dummy siblings as needed, then replaces the dummy siblings later when their actual definitions, that is, @node sentinels, are encountered.

At this point the fundamental read/write code was complete. I found three minor bugs in the code over the next week or so, but it was clear that the read/write code formed a rock-solid base from which to continue design and implementation. This was an entirely unexpected surprise.</t>
<t tx="EKR.20040524104904.254">At this point I could read and write derived files "by hand", using temporary Read and Write commands. The next step was to integrate the reading and writing of derived files with the loading and saving of .leo files.  From time to time I made minor changes to the drivers for the read/write code to accommodate the Load and Save code, but at no time did I significantly alter the read or write code itself.

The user interaction of the Load and Save commands drove the design and implementation of the load/store code. The most important questions were: "what do we tell the user?", and "what does the user do with the information?" It turns out that the user can't make any complex decision during error recovery because the user doesn't have nearly enough information to make an informed choice. In turn, this means that certain kinds of error recovery schemes are out of the question...</t>
<t tx="EKR.20040524104904.255">I now turned my attention to "attributes" of nodes.  Most attributes, like user marks, are non-essential. However, clone information is essential; we must never lose clone links. At this time I had a preliminary design for cross-file clones that involved a two part "pointer" consisting of a full path name and an immutable clone index within the derived file. Eventually such pointers completely disappeared, but the immutable clone indices remain.

My first thought was that it would be good to store all attributes in @node sentinels in the derived file, but experience showed that would be irritating. Indeed, one wants Leo2 to rewrite derived files only if something essential has changed. For example, one doesn't want to rewrite the derived file just because a different node as been selected.

At this point I had another Aha: we can use the .leo file to store all non-essential attributes. For example, this means that the .leo file, not the derived files, will change if we select a new node. In effect, the .leo file mirrors the derived file. The only reason to store nodes in the .leo file under an @file node is to carry these attributes, so Leo2 wrote dummy nodes that do not reference body text.  Much later I saw that dummy nodes were dangerous and that .leo files should contain all information found in derived files.</t>
<t tx="EKR.20040524104904.256">The concept of mirroring created a huge breakthrough with cross-file clones: Here is an excerpt of an email i sent to my brother Speed:

"I realized this morning that since a .leo file contains dummy vnodes for all nodes in a derived file, those dummy nodes can carry clone info! I changed one line to make sure that the write code always writes clone info in dummy vnodes and voila! Cross-file clones worked!"

All of Leo1's clone code could be used completely unchanged. Everything "just works".</t>
<t tx="EKR.20040524104904.257">At first I thought we could make sure that the .leo file always correctly mirrors all derived file, but disastrous experience showed that is a completely false hope. Indeed, backup .leo files will almost never mirror derived file correctly. So it became urgent to find a completely fool-proof error recovery scheme.

I had known for quite a while that error recovery should work "as if" the mirroring nodes were deleted, then recreated afresh. Several failed attempts at an error recovery scheme convinced me that error recovery would actually have to delete all dummy nodes and then do a complete reread. This is what Leo2 does.

But erasing dummy nodes would destroy any orphan and ignored nodes--by definition such nodes appear nowhere in the derived file. Therefore, I had to enforce the rule that @file nodes should contain no such nodes. Here is an email I wrote to my brother, Speed Ream discussing what turned out to be the penultimate error recovery scheme:

"The error recovery saga continues. After much pondering and some trial coding I have changed my mind about orphans and @ignored nodes. They simply should never appear as descendants of @file nodes. Fortunately, this simplifies all aspects of Leo2.
Leo2 will issue a warning (not an error) if an orphan or @ignored node appears as the descendant of an @file node when a .leo file is being saved. If any warnings occur while writing the derived file, Leo2 will write the "offending" @file tree to the .leo file instead of the derived file. This has several advantages:

1.	The user gets warned about orphan nodes. These are useful warnings! Orphan nodes arise from missing @others directives or missing section references.

2. The user doesn't have to change anything immediately in order to save an outline. This is very important. Besides warnings about orphans, Leo2 will also warn about undefined or unreferenced sections. User's shouldn't have to fix these warnings to do a Save!

3. No errors or alerts will occur during Reading or Writing, so the user's anxiety level goes way down. At worst, some informational message will be sent to the log. The user will never have to make important decisions during Loads or Saves. [At last the dubious distinction between errors and warnings disappears.]

4. Error recovery can be bullet-proof. Simple code will guarantee that after any read operation the structure of an @file node will match the structure of the derived file. Also, sentinels in derived files will now account for all children of an @file node. There are no more "missing nodes" that must be filled in using the .leo file. Finally, error recovery will never change the @file tree in any way: no more "recovered nodes" nodes.

5. The present read code can be used almost unchanged. The only addition is the posting of a warning if the structure of the .leo file does not match the structure of the derived file. We need a warning because non-essential attribute of nodes (like user marks) may be altered."

This ends the original history of Leo2. In fact, it took quite a while before Leo recovered properly from all errors. I finally saw that .leo files should duplicate all information in derived files. This allows a .leo file to be used a single backup file and allows maximal error recovery in all situations.  It took several months to stamp out several subtle bugs involving clones that caused spurious read errors. Such errors undermine confidence in Leo and can cause disastrous reversions. See my diary entries for January 2002 in leo.py for details.

</t>
<t tx="EKR.20040524104904.259">The more I look at Tk, the more convinced I am that Python + Tk (aka Tkinter)
is, by far, the best way to go with Leo. I now have Open Source code for tree
widgets and splitter windows, and have intensely studied how to modify that code
for use in Leo. It is clear, even at this early date, that this code will
provide a very pleasant base on which to build Leo.

The tree code is based on code in ``IDLE``, the Python IDE. This code is simple,
good and plenty fast enough. The tree code draws directly to a Tk canvas object.
The look and feel matches Windows exactly. It would be trivial to use Mac
triangle icons instead of the Windows plus and minus icons. It would also be
trivial to modify the look and feel for Linux.

The tree widget code solves several intractable problems with ``wxTreeCtrl``.
Moving nodes becomes trivial. Bugs in ``wxTreeCtrl`` involving editing and
redrawing disappear. Using Python/Tk code simplifies the vnode class, and having
access to the vnode class simplifies and speeds up the tree widget code. It will
now be possible to bind keystrokes properly; this simply can not be done in
``wxWindows``. The tree widget code shows just how trivial the Windows native
tree control is. The Tk canvas is a splendid example of higher-level code being
superior, in every way, to lower level code.

Another big win comes from using the Tk text widget. This widget is
extraordinarily powerful. The only text control that rivals it is the
``MacOS/Yellow Box`` text control. Indeed, the Tk text widget does everything that
Leo could possibly want. One can even embed images in text.

In short, using Tk for Leo will be fast enough and will greatly increase what is
possible in Leo while at the same time greatly simplifying Leo's code. I am
about to convert Leo from wxPython to Python + Tk.
Edward K. Ream, November 4, 2001</t>
<t tx="EKR.20040524104904.260">I've known for a while that Python was interesting; I attended a Python
conference last year and added Python support to Leo. But last week I got that
Python is something truly remarkable. I wanted to convert Leo from wxWindows to
wxPython, so I began work on c2py, a Python script that would help convert from
C++ syntax to Python. While doing so, I had an Aha experience. Python is more
than an incremental improvement over Smalltalk or C++ or objective-C; it is
"something completely different". The rest of this post tries to explain this
difference.
</t>
<t tx="EKR.20040524104904.261"></t>
<t tx="EKR.20040524104904.262">All versions of Leo are organized as a collection of classes. The general
organization of Leo has remained remarkably stable throughout all versions of
Leo, although the names of classes are different in different versions.
Smalltalk's Model/View/Controller terminology is a good way think about Leo's
classes. **Model classes** represent the fundamental data. The vnode and tnode
classes are Leo's primary model classes.

**View classes** draw the screen. The main view classes are leoFrame.py and
leoTree.py. The colorizer class in leoColor.py handles syntax coloring in the
body pane. Leo's view classes know about data stored in the vnode class. Most
events (keystrokes and mouse actions) in the outline and body pane are handled
in the leoTree class. The leoFrame class also creates the Leo window, including
menus, and dispatches the appropriate members of the controller classes in
response to menu commands.

**Controller classes** (aka commanders) control the application. In Leo,
controllers mostly handle menu commands. Commanders create subcommanders to
handle complex commands. The atFile class reads and writes files derived from
``@file`` trees. The LeoFind class handles the Find and Change commands. The
leoImportCommands class handles the Import and Export commands, the
tangleCommands class handles the Tangle and Untangle commands and the undoer
class handles the Undo command. Other classes could be considered controller
classes.

Each Leo window has its own commander and subcommanders. Subcommanders are not
subclasses of their commander. Instead, subcommanders know the commander that
created them, and call that commander as needed. Commanders and subcommanders
call the model and view classes as needed. For example, the Commands class
handles outline commands. To move a headline, the commander for the window calls
a vnode move routine to alter the data, then calls the view class to redraw the
screen based on the new data.

A singleton instance of the **LeoApp** class represents the application itself.
All code uses the app() global function to gain access to this singleton member.
The ivars of the LeoApp object are the equivalent of Leo's global variables.
leo.py uses no global Python variables, except the gApp variable returned by
app(). leoGlobals.py defines all application constants. Naturally, most
constants are local to the class that uses them.

Several classes combine aspects of model, view and controller. For example, the
**LeoPrefs** class represents user preferences (model), the Preference Panel
(view) and the Preferences menu command (controller). Similarly, the **LeoFind**
class represents find settings, the Find/Change dialog, and the Find/Change
commands.

We use the following convention throughout this documentation. Any variable
named ``c`` is a commander, i.e., an instance of the Commands class in
``leoCommands.py``. Variables named ``v`` and ``t`` are vnodes and tnodes respectively.
These classes are defined in ``leoNodes.py``.</t>
<t tx="EKR.20040524104904.263">The vnode and tnode classes represent most of the data contained in the outline.
These classes are Leo's fundamental Model classes. A **vnode** (visual node)
represents a headline at a particular location on the screen. When a headline is
cloned, vnodes must be copied. vnodes persist even if they are not drawn on the
screen. Commanders call vnode routines to insert, delete and move headlines.

The vnode contains data associated with a headline, except the body text data
which is contained in tnodes. A vnode contains headline text, a link to its
tnode and other information. Vnodes contain structure links: parent, firstChild,
next and back ivars. To insert, delete, move or clone a vnode the vnode class
just alters those links. The Commands class calls the **leoTree** class to redraw
the outline pane whenever it changes. The leoTree class knows about these
structure links; in effect, the leoTree and vnode classes work together.

A **tnode**, (text node) represents body text. All vnodes that are clones of
each other share the same tnode. In other words, tnodes are the unit of sharing
of body text. The tnode class is more private than the vnode class. Most
commanders deal only with vnodes, though there are exceptions.

Because Leo has unlimited Undo commands, Leo deletes vnodes and tnodes only when
a window closes. Leo deletes nodes indirectly using ``destroy`` methods. Several
classes, including the vnode, tnode, leoFrame and leoTree classes, have
``destroy`` methods. ``destroy`` methods merely clear links so that Python's and
Tkinter's reference counting mechanisms will eventually delete vnodes, tnodes
and other data when a window closes.

Leo's XML file format uses **tnode indices** to indicate which tnodes (t
elements) belong to which vnodes (v elements). Such indices are required. Even
if we duplicated the body text of shared tnodes within the file, the file format
would still need an unambiguous way to denote that tnodes are shared. Present
versions of Leo use **gnx's** (global node indices) as node indices. These indices
do not change once a node has created. This reduces cvs conflicts.</t>
<t tx="EKR.20040524104904.264">Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.
The main challenges are eliminating flicker and handling events properly.
These topics are interrelated.

**Eliminating flicker**. Leo must update the outline pane with minimum flicker.
Various versions of Leo have approached this problem in different ways. The
drawing code in leo.py is robust, flexible, relatively simple and should work in
almost any conceivable environment. Leo assumes that all code that changes the
outline pane will be enclosed in matching calls to the c.beginUpdate and
c.endUpdate methods of the Commands class. c.beginUpdate() inhibits drawing
until the matching c.endUpdate(). These calls may be nested; only the outermost
call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.

Code may call ``c.endUpdate(flag)`` instead of ``c.endUpdate()``. Leo redraws
the screen only if flag is true. This allows code to suppress redrawing entirely
when needed. For example, here is how the idle_body_key event handler in
leoTree.py conditionally redraws the outline pane::

	redraw_flag = false
  	c.beginUpdate()
	val = v.computeIcon()
	if val != v.iconVal:
		v.iconVal = val
		redraw_flag = true
	c.endUpdate(redraw_flag) # redraw only if necessary

The leoTree class redraws all icons automatically when ``c.redraw()`` is called.
This is a major simplification compared to previous versions of Leo. The entire
machinery of drawing icons in the vnode class has been eliminated. The
``v.computeIcon`` method tells what the icon should be. The ``v.iconVal`` ivar
tells what the present icon is. The event handler simply compares these two
values and sets ``redraw_flag`` if they don't match.

**Handling events.** Besides redrawing the screen, Leo must handle events or
commands that change the text in the outline or body panes. It is surprisingly
difficult to ensure that headline and body text corresponds to the vnode and
tnode corresponding to presently selected outline, and vice versa. For example,
when the user selects a new headline in the outline pane, we must ensure that 1)
the vnode and tnode of the previously selected node have up-to-date information
and 2) the body pane is loaded from the correct data in the corresponding tnode.
Early versions of Leo attempted to satisfy these conditions when the user
switched outline nodes. Such attempts never worked well; there were too many
special cases. Later versions of Leo, including leo.py, use a much more direct
approach. The event handlers make sure that the vnode and tnode corresponding to
the presently selected node are always kept up-to-date. In particular, every
keystroke in the body pane causes the presently selected tnode to be updated
immediately. There is no longer any need for the ``c.synchVnode`` method, though
that method still exists for compatibility with old scripts.

The leoTree class contains all the event handlers for the body and outline
panes. The actual work is done in the ``idle_head_key`` and ``idle_body_key`` methods.
These routines are surprisingly complex; they must handle all the tasks
mentioned above, as well as others. The ``idle_head_key`` and ``idle_body_key`` methods
should not be called outside the leoTree class. However, it often happens that
code that handles user commands must simulate an event. That is, the code needs
to indicate that headline or body text has changed so that the screen may be
redrawn properly. The leoTree class defines the following simplified event
handlers: ``onBodyChanged``, ``onBodyWillChange``, ``onBodyKey``, ``onHeadChanged`` and
``onHeadlineKey``. Commanders and subcommanders call these event handlers to
indicate that a command has changed, or will change, the headline or body text.
Calling event handlers rather than ``c.beginUpdate`` and ``c.endUpdate`` ensures that
the outline pane is redrawn only when needed.</t>
<t tx="EKR.20040524104904.265">Leo now represents clones by sharing tnodes. Cloned vnodes share the same tnode.
This shared tnode represents the entire shared subtree of both clones. Thus, the
``_firstChild`` link must reside in *tnodes*, not *vnodes*.

Because vnodes may be visited many times during a complete traversal of a tree,
a vnode no longer represents a unique location on the screen. As a result, the
**position** class had to be invented. ``c.rootVnode`` and ``c.currentVnode``
now return *positions* instead of vnodes. The position class was designed to
allow compatibility with old scripts. Old code can use positions just like they
used to use vnodes.
</t>
<t tx="EKR.20040524104904.266">The find and change commands are tricky; there are many details that must be
handled properly. The following principles govern the LeoFind class:

1.  Find and Change commands initialize themselves using only the state of the
    present Leo window. In particular, the Find class must not save internal
    state information from one invocation to the next. This means that when the
    user changes the nodes, or selects new text in headline or body text, those
    changes will affect the next invocation of any Find or Change command.
    Failure to follow this principle caused all kinds of problems in the Borland
    and Macintosh codes. There is one exception to this rule: we must remember
    where interactive wrapped searches start. This principle simplifies the code
    because most ivars do not persist. However, each command must ensure that
    the Leo window is left in a state suitable for restarting the incremental
    (interactive) Find and Change commands. Details of initialization are
    discussed below.

2.  The Find and Change commands must not change the state of the outline or body
    pane during execution. That would cause severe flashing and slow down the
    commands a great deal. In particular, the ``c.selectPosition`` and ``c.editPosition``
    methods must not be called while looking for matches.

3.  When incremental Find or Change commands succeed they must leave the Leo
    window in the proper state to execute another incremental command. We
    restore the Leo window as it was on entry whenever an incremental search
    fails and after any Find All and Change All command. Initialization involves
    setting the ``self.c``, ``self.v``, ``self.in_headline``, ``self.wrapping`` and
    ``self.s_text`` ivars.

Setting ``self.in_headline`` is tricky; we must be sure to retain the state of
the outline pane until initialization is complete. Initializing the Find All and
Change All commands is much easier because such initialization does not depend
on the state of the Leo window. Using Tk.Text widgets for both headlines and
body text results in a huge simplification of the code.

Indeed, the searching code does not know whether it is searching headline or
body text. The search code knows only that ``self.s_text`` is a Tk.Text widget that
contains the text to be searched or changed and the insert and sel Tk attributes
of self.search_text indicate the range of text to be searched. Searching
headline and body text simultaneously is complicated. The selectNextVnode()
method handles the many details involved by setting ``self.s_text`` and its insert
and sel attributes.</t>
<t tx="EKR.20040524104904.267">This section describes Leo's explicit ``Tangle`` and ``Untangle`` commands. Such
commands operate only on ``@root`` and ``@unit`` trees. The previous chapter discusses
the implicit Tangle on Write/Untangle on Read processes used to read and write
``@file`` trees.

The ``Tangle`` command translates the selected ``@root`` tree into one or more
well-formatted C source files. The outline should contain directives, sections
references and section definitions, as described in Chapter 4. The Untangle
command is essentially the reverse of the ``Tangle`` command. The Tangle command
creates a derived file from an ``@root`` tree; the Untangle command incorporates
changes made to derived files back into the ``@root`` tree.

The ``Tangle`` command operates in two passes. The first pass discovers the complete
definitions of all sections and places these definitions in a symbol table. The
first pass also makes a list of root sections. Definitions can appear in any
order, so we must scan the entire input file to know whether any particular
definition has been completed.

This second pass creates one file for each ``@root`` node. ``Tangle`` rescans each
section in the list of roots, copying the root text to the output and replacing
each section reference by the section's definition. This is a recursive process
because any definition may contain other references. We can not allow a section
to be defined in terms of itself, either directly or indirectly. We check for
such illegally recursive definitions in pass 2 using the section stack class.
``Tangle`` indicates where sections begin and end using comment lines called
sentinel lines. The this part of the appendix discusses the format of the
sentinels output by the ``Tangle`` command.

The key design principle of the ``Tangle`` command is this::

    Tangle must output newlines in a context-free manner.

That is, ``Tangle`` must never output conditional newlines, either directly or
indirectly. Without this rule ``Untangle`` could not determine whether to skip or
copy newlines.

The ``Tangle`` command increases the indentation level of a section expansion the
minimum necessary to align the section expansion with the surrounding code. In
essence, this scheme aligns all section expansions with the line of code in
which the reference to the section occurs. In some cases, several nested
sections expansions will have the same indentation level. This can occur, for
example, when a section reference in an outline occurs at the left margin of the
outline.

This scheme is probably better than more obvious schemes that indent more
"consistently." Such schemes would produce too much indentation for deeply
nested outlines. The present scheme is clear enough and avoids indentation
wherever possible, yet indents sections adequately. End sentinel lines make this
scheme work by making clear where the expansion of one section ends and the
expansion of a containing section resumes.

``Tangle`` increases indentation if the section reference does not start a line.
Untangle is aware of this hack and adjusts accordingly. This extra indentation
handles several common code idioms, which otherwise would create under-indented
code. In short, ``Tangle`` produces highly readable output, given the necessity
of preserving newlines for ``Untangle``.

``Untangle`` is inherently complex. It must do a perfect job of updating the
outline, especially whitespace, from expansions of section definitions created
by the Tangle command. Such expansions need not be identical because they may
have been generated at different levels of indentation. The ``Untangle`` command
can not assume that all expansions of a section will be identical in the derived
file; within the derived file, the programmer may have made incompatible changes
to two different expansions of the same section. ``Untangle`` must check to see
that all expansions of a section are "equivalent". As an added complication,
derived files do not contain all the information found in ``@root`` trees.
``@root`` trees may contain headlines that generate no code at all. Also, an
outline may define a section in several ways: with an ``@c`` or ``@code``
directive or with a section definition line. To be useful, Untangle must handle
all these complications flawlessly. The this part of the appendix discusses the
various conventions used in the sentinels output by the ``Tangle`` command.
These conventions allow the ``Untangle`` command to recreate whitespace
correctly.

``Untangle`` operates in two passes. The first pass finds definitions in the
derived file and enters them into the **Untangle Symbol Table**, or UST.
Definitions often include references to other sections, so definitions often
include nested definitions of referenced sections. The first pass uses a
definition stack to keep track of nested definitions. The top of the stack
represents the definition following the latest reference, except for the very
first entry pushed on the stack, which represents the code in the outline that
contains the ``@root`` directive. The stack never becomes empty because of the
entry for the ``@root`` section. All definitions of a section should
match--otherwise there is an inconsistent definition. This pass uses a forgiving
compare routine that ignores differences that do not affect the meaning of a
program.

The second pass of ``Untangle`` enters definitions from the outline into the
**Tangle Symbol Table**, or TST. The second pass simultaneously updates all
sections in the outline whose definition in the TST does not match the
definition in the UST. The central coding insight of the Untangle command is
this:  **the second pass of Untangle is almost identical to the first pass of
Tangle**. That is, ``Tangle`` and ``Untangle`` share key parts of code, namely the
``skip_body`` method and its allies. Just when ``skip_body`` enters a definition
into the symbol table, all the information is present that ``Untangle`` needs to
update that definition.</t>
<t tx="EKR.20040524104904.268">Leo uses unicode objects in vnodes and tnodes to denote headline and body text.
Note that unicode strings have no encoding; only plain strings have encodings.
This means that once an (encoded) plain string has been converted to a unicode
string it doesn't matter how the unicode string was created. This is the key
that makes Leo's new code robust: internally Leo never has to worry about
encodings. Encoding matter only when encoded strings are converted to and from
Unicode. This happens when Leo reads or writes files.

Python expressions that mix unicode strings u and plain strings s, like one of these::

	u + s
	u == s
	u[5] == s[2:]

are promoted to unicode objects using the "system encoding". This encoding
should never be changed, but we can't assume that we know what it is, so for
safety we should assume the most restrictive encoding, namely "ascii". With this
assumption, Leo's code can't throw an exception during these promotions provided
that: 

- All strings are converted to unicode when Leo reads files or gets text from Tk.Text widgets.

- All string literals in Leo's code have only ascii characters.</t>
<t tx="EKR.20040524104904.269">Unlimited undo is straightforward; it merely requires that all commands that
affect the outline or body text must be undoable. In other words, everything
that affects the outline or body text must be remembered. We may think of all
the actions that may be Undone or Redone as a string of beads (undo nodes).

Undoing an operation moves backwards to the next bead; redoing an operation moves
forwards to the next bead. A bead pointer points to the present bead. The bead
pointer points in front of the first bead when Undo is disabled. The bead
pointer points at the last bead when Redo is disabled. An undo node is a Python
dictionary containing all information needed to undo or redo the operation. The
Undo command uses the present bead to undo the action, then moves the bead
pointer backwards.

The Redo command uses the bead after the present bead to redo the action, then
moves the bead pointer forwards. All undoable operations call setUndoParams() to
create a new bead. The list of beads does not branch; all undoable operations
(except the Undo and Redo commands themselves) delete any beads following the
newly created bead. I did not invent this model of unlimited undo.
I first came across it in the documentation for Apple's Yellow Box classes.</t>
<t tx="EKR.20040524104904.274"></t>
<t tx="EKR.20040524104904.282">To convert an ``@root`` tree to an ``@file`` tree, choose the root of the tree to be converted,
then do the following in the Python window::

	import c2py
	c2py.leo1to2()

This script makes numerous changes throughout the tree.
It does not, however, change ``@root`` to ``@file``, or insert the needed ``@others`` directives.
You must do that by hand.

To convert ``@root`` trees to ``@file`` trees by hand:

1.  Change the ``@root`` node to an ``@file`` node.
    That is, delete the ``@root &lt;filename&gt;`` from the body text and insert ``@file &lt;filename&gt;`` in the headline.
    Typically, the root node contains a reference like ``&lt;&lt;methods of class x&gt;&gt;`` as the last body text.
    Replace this reference with the ``@others`` directive.
    The expansion of @others is all text that is not part of a section definition.

2.  Add ``@`` to the start of all doc parts.
    Leo starts syntax coloring in code mode rather than doc mode,
    so if a doc part starts body text it should start with ``@``

3.  Replace all section definition lines (like ``&lt;&lt;name&gt;&gt;=``) by ``@c``.
    This results in the node being added to the expansion of ``@others``.

4.  Remove all unused code from the ``@file`` tree.
    Leo does not write derived files whose ``@file`` trees contain orphan or ``@ignore`` nodes.

5.  Make sure that all nodes defining a section have a headline that starts with ``&lt;&lt;section&gt;&gt;``.
    This will typically be true when converting ``@root`` trees that use the ``@code`` directive.

6.  If a section is referenced in more than one node (a rare occurrence in my code),
    clone the defining node and move one clone under each referencing node.

7.  If a node contains the definitions of several sections,
    place each different definition in a different node.</t>
<t tx="EKR.20040524104904.307">The following error messages may be generated by the ``Tangle`` commands.

``Can not re-open temp file``
    A file error occurred while trying to reopen the temporary file used during tangling.

``Can not rename temporary file name``
    A file error occurred while trying to change the name of the temporary file used during tangling.

``@code expects the header: [text of header] to contain a section name``
    An @code directive appeared in body text whose header does not contain a section name.

``@directive not valid here``
    An @directive was seen somewhere other than the start of a line.

``Halting Tangle: too many errors``
    Tangle detected more than 20 errors.

``Invalid recursive reference of &lt;&lt; section name &gt;&gt;``
    A section was defined in terms of itself, either directly or indirectly.
    The trace shows the chain of section definitions that resulted in the illegal definition.

``This message is followed by a walkback of the section names that recursively reference the section.``
    The walkback looks like this::

        called from &lt;&lt; section name &gt;&gt;
        called from &lt;&lt; section name &gt;&gt;
        ...

``Multiple parts not allowed for &lt;&lt; section name &gt;&gt;``
    Sections can be defined in several parts in two ways:

    1.  Using ``&lt;&lt; section name &gt;&gt;=`` in several places with the same section name.
    
    2.  Using several ``@code`` directives within the same body text.
    
    As a precaution against mistakenly defining a section in more than one place,
    it is invalid to use @code in different nodes to define multiple parts for the same section.
    In particular, this error may arise when using cloned nodes.
    This error may always be eliminated by using ``&lt;&lt; section name &gt;&gt;=`` instead of ``@code``.

``No file written because of errors``
    Tangle did not write a file because errors were found.

``Run on comment``
    A C-language comment was not properly terminated.

``Run on file name in @root directive``
    The file name in an @root directive was not terminated with the proper delimiter.

``Run on section name``
    A section name was not properly terminated before the end of the line in which it started.

``Run on string``
    A C-language string or character constant was not properly terminated.

``Section definition not valid here.``
    Something that looks like a section definition was seen in the middle of a line.

``Sections nested too deeply``
    A section was defined using more than 100 levels of section definitions (!)
    You could easily create an outline containing every computer program ever written in less than 50 levels.

``The outline contains no roots``
    The selected outline contained no @root directive.

``Undefined section:  &lt;&lt;&lt; section name &gt;&gt;&gt;``
    A reference to an undefined section was encountered.

``Unexpected @directive while putting code``
    Tangle outputs 2-character WEB control code in a comment.
    This message is given if we find such comments in a code definition.

``Warning: possible duplicate definition of: &lt;&lt;&lt; section name &gt;&gt;&gt;``
    (The text of the duplicate definition follows.)
    The section may have been defined in more than one place.

``Warning: &lt;&lt;&lt; section name &gt;&gt;&gt; has been defined but not used``
    The indicated section appears in the outline but is never referenced.</t>
<t tx="EKR.20040524104904.327">The following error messages may be generated by the Untangle commands.

Incompatible definitions of &lt;&lt;&lt; section name &gt;&gt;&gt;
    Two expansions of ``&lt;&lt; section name &gt;&gt;`` were different in the derived file.
    This typically arises when the programmer changes one of the expansions but not the other.

Missing root part
    No end sentinel line was found for a part of the expansion of the code in the ``@root`` node.
    This is likely the result of adding, deleting or altering a sentinel line.

``Missing root section``
    No end sentinel line was found for the expansion of the code in the ``@root`` node.
    This is likely the result of adding, deleting or altering a sentinel line.

``Missing sentinel line for &lt;&lt;&lt; section name &gt;&gt;&gt;``
    The end sentinel name for ``&lt;&lt; section name &gt;&gt;`` was expected but not found.
    This is likely the result of adding, deleting or altering a sentinel line.

``Unterminated section: &lt;&lt;&lt; section name &gt;&gt;&gt;``
    The end of the file was reached before encountering the end sentinel line for ``&lt;&lt; section name &gt;&gt;``.
    This is likely the result of adding, deleting or altering a sentinel line.
</t>
<t tx="EKR.20040524104904.333">The following are all serious errors, meaning that the data in a derived file has been corrupted::

    Bad @+leosentinel in &lt;filename&gt;
    Bad @delims
    Bad attribute field in @+node
    Bad child index in @+node
    File may have damaged sentinels!
    Ignoring &lt;sentinel kind&gt; sentinel.  Expecting &lt;sentinel kind&gt;
    Ignoring unexpected @+leo sentinel
    Missing &lt;sentinel kind&gt; sentinel
    Missing @file in root @node sentinel
    Outline corrupted: different nodes have same clone index!
    Replacing body text of orphan &lt;node name&gt;
    Unexpected end of file. Expecting &lt;sentinel kind&gt; sentinel
    Unknown sentinel: &lt;sentinel line&gt;

You should restore the information from a backup .leo file using the ``Read Outline Only`` commands,
followed by a ``Write @file Nodes`` command</t>
<t tx="EKR.20040524104904.336">Errors while writing ``@file`` nodes are harmless.
No information is lost because all information is written to the .leo file rather than the derived file.

``bad @delims directive``
    A node contains an ill-formed ``@delims`` directive.

``@ignore node &lt;headline&gt;``
    The body text of *headline* contains an ``@ignore`` directive.

``orphan node: &lt;headline&gt;``
    The node is referenced by no ancestor node, and no ``@others`` directive applies to it.

``@others already expanded in: &lt;headline&gt;``
    The node contains more than one ``@others`` directive.

``Rename failed: no file created! (file may be read-only)``
    Leo's ``Save`` command writes derived files to a temporary file,
    and replaces the derived file by the temporary files only if the two files are different.
    A problem with the file system prevented the temporary file from being renamed.

``Path does not exist: &lt;filename&gt;``

``undefined section: &lt;section name&gt; referenced from: &lt;headline&gt;``
    The node given by *headline* contains a reference to *section name*
    but no section definition node for *section name* exists in the descendants of *headline*.</t>
<t tx="EKR.20040524104904.337">**Important**: Do not alter blank lines in front of, behind or between sentinels.
Doing so will corrupt the outline structure in older versions of Leo.
Leo suppresses blank lines between sentinels by default.
This is an upward compatible change in the format of derived files:
Leo v2.0 can read derived files from all previous versions of Leo,
but previous versions of Leo can not read derived files without blanks lines.

The following sections describe the comment lines embedded in derived files.

\@&lt;&lt;
    A sentinel of the form ``@&lt;&lt;section_name&gt;&gt;`` represents a section reference.
    If the reference does not end the line,
    the sentinel line ending the expansion is followed by the remainder of the reference line.
    This allows the Read code to recreate the reference line exactly.

\@@
    The ``@@`` sentinel represents any line starting with ``@`` in body text
    except ``@``*whitespace*, ``@doc`` and ``@others``.
    Examples::
    
      @@nocolor
      @@pagewidth 80
      @@tabwidth 4
      @@code

\@@delims
    The ``@delims`` sentinel inserts ``@@delims`` sentinels into the derived file.
    The new delimiter strings continue in effect until the next ``@@delims`` sentinel
    *in the derived file* or until the end of the derived file.
    Adding, deleting or changing ``@@delim`` *sentinels* will destroy Leo's ability to read the derived file.
    Mistakes in using the ``@delims`` *directives* have no effect on Leo,
    though such mistakes will thoroughly mess up a derived file as far as compilers, HTML renderers, etc. are concerned.

\@at and \@doc
    The ``@+doc`` and ``@-doc`` sentinels delimit doc parts within a node that starts with ``@doc``.
    These sentinels are nested within ``@body`` directives.
    Similarly, ``@+at`` and ``@-at`` sentinels delimit doc parts within a node that start with ``@`` *whitespace*.
    We use the following **trailing whitespace convention**
    to determine where putDocPart has inserted line breaks::
    
        A line in a doc part is followed by an inserted newline
        if and only if the newline if preceded by whitespace.
    
    To make this convention work,
    Leo's write code deletes the trailing whitespace of all lines that are followed by a "real" newline.

\@body
    If a node contains significant (non-whitespace) body text,
    the ``@+body`` and ``@-body`` sentinels surround the text.
    These sentinels are nested within ``@node`` directives.

\@leo
    A file produced by an ``@file`` node begins with an ``@+leo`` sentinel.
    The last lines of the file should be the matching ``@-leo`` sentinel.
    The ```@+leo`` sentinel line has the form::
    
        &lt;opening_delim&gt;@leo&lt;closing_delim&gt;
    
    The read code uses single-line comments if ``&lt;closing_delim&gt;`` is empty.
    The write code generates single-line comments if possible.

\@node
    Suppose the parent node of a node N is P and that P has n children.  The sentinel:: 

      @+node:&lt;child_index&gt;:&lt;status_fields&gt;:&lt;headline&gt;
    
    begins the expansion of node N.  The expansion continues until a matching::
    
      @-node::&lt;child_index&gt;:&lt;status_fields&gt;:&lt;headline&gt;
      
    sentinel.
    ``&lt;child_index&gt;`` is a number from 1 to n indicating the index of the node in the list of its parent's children.
    ``&lt;status_field&gt;`` is the cloneIndex field of the form: "C=nnn", where nnn is an immutable clone index.
    ``&lt;headline&gt;`` contains *headline* text, not reference text.
    
    The indentation of the expansion is increased by the extra indentation of preceding the reference.
    tree level never affects indentation level.

\@others
    The ``@+others`` sentinel indicates the start of the expansion of an ``@+others`` directive,
    which continues until the matching ``@-others`` sentinel.
    ``@others`` sentinels are nested within ``@body`` sentinels;
    the expansion of the ``@others`` directive always occurs within the body text of some node.

\@verbatim
    ``@verbatim`` indicates that the next line of the derived file is not a sentinel.
    This escape convention allows body text to contain lines that would otherwise be considered sentinel lines.
    
\@@verbatimAfterRef
    ``@verbatimAfterRef`` is generated when a comment following a section reference would otherwise be treated as a sentinel.
    In Python code, an example would be::
    
      &lt;&lt; ref &gt;&gt; #+others
    
    This sentinel is required only when blank lines are suppressed between sentinel lines.</t>
<t tx="EKR.20040524104904.349">The 4.0 file format meets the following goals:

- The minimum of sentinels needed to properly recreate the outline.

- A robust way of telling whether newlines belong to sentinels or not.

- A minimum of intrusion and ugliness.

Changes from the 3.0 file format:

-   The ``@+leo`` sentinel indicates whether the format is 3.x or 4.x.

-   ``@+node`` and ``@-node`` sentinels no longer contain child or clone indices.
    Therefore, such sentinels do not change when outline nodes are inserted, deleted or moved.
    This reduces cvs conflicts involving sentinel lines.

-   Leo generates ``@+node`` sentinels only for nodes containing body text.
    Leo no longer generates other ``@+node`` sentinels to indicate outline structure.
    As a result, there is no longer any need for ``@+body`` sentinels.

-   The ``@nl`` and ``@nonl`` sentinels adjust the contribution of *previous* sentinels.
    This greatly simplifies the read code.

-   The ``@+others`` and ``@&lt;&lt;`` sentinels indicate leading whitespace appearing before
    ``@others`` directives and section refs.

-   Leo writes the ``@afterref`` whenever any non-whitespace text appears after a section references.

-   The ``@+doc`` and ``@+at`` sentinels now contain the whitespace that follows
    the corresponding ``@doc`` or ``@`` directives.

New in 4.2:

-   Files derived from ``@thin`` use gnx's in ``@+-node`` sentinels.
    gnx's permanently and uniquely identify nodes.  Examples::

        id.yyyymmddhhmmss
        id.yyyymmddhhmmss.n

    The second form is used if two gnx's would otherwise be identical.

    - ``id`` is a string unique to a developer, e.g., a cvs id.

    - ``yyyymmddhhmmss`` is the node's creation date.

    - ``n`` is an integer.

-   The ``@+-all`` sentinel corresponds to the range of the ``@all`` directive.

-   The ``@+-middle`` sentinel indicates intermediate nodes between the node that
    references a section and the node that defines the section.
    Typically no such sentinels are needed: most sections are defined in a direct child of the referencing node.</t>
<t tx="EKR.20040524104904.351">The following bugs can not be fixed:

1.  The ``Untangle`` command has no way of updating a section whose name has been changed in the derived file.
    
    Because of the ``@unit`` directive, there is not even a way to issue a meaningful warning.

2.  The ``Tangle`` command treats ``@c`` like ``@code`` in ``CWEB`` mode.

    I recommend changing ``@c`` to ``@&lt; c @&gt;=`` throughout your ``CWEB`` sources
    and adding a reference to ``@&lt; c @&gt;`` in all roots of ``CWEB`` files.</t>
<t tx="EKR.20040524104904.354">Leo uses unicode internally for all strings.

1.  Leo converts headline and body text to unicode when reading .leo files and derived files.
    Both .leo files and derived files may specify their encoding.  The default is ``utf-8``.
    If the encoding used in a derived file is not "utf-8" it is represented in the ``@+leo`` sentinel line.
    For example::

        #@+leo-encoding=iso-8859-1.

    The ``utf-8`` encoding is a "lossless" encoding (it can represent all unicode code points),
    so converting to and from utf-8 plain strings will never cause a problem.
    When reading or writing a character not in a "lossy" encoding,
    Leo converts such characters to '?' and issues a warning. 

2.  When writing .leo files and derived files Leo uses the same encoding used to read the file,
    again with ``utf-8`` used as a default.

3.  leoSettings.leo contains the following Unicode settings, with the defaults as shown::

        default_derived_file_encoding = UTF-8 
        new_leo_file_encoding = UTF-8 

    These control the default encodings used when writing derived files and .leo files.
    Changing the ``new_leo_file_encoding`` setting is not recommended.
    See the comments in leoSettings.leo.
    You may set ``default_derived_file_encoding`` to anything that makes sense for you.

4.  The ``@encoding`` directive specifies the encoding used in a derived file.
    You can't mix encodings in a single derived file.</t>
<t tx="EKR.20040524104904.357">This technical information may be of use to those wanting to process Leo files with special-purpose filters.
Leo's uses XML for its file format.
The following sections describe this format in detail.
**Important**:
The actual read/write code in leoFileCommands.py is the authoritative guide.
When in doubt about what Leo actually writes, look at an actual .leo file in another editor.

Here are the elements that may appear in Leo files.
These elements must appear in this order.

``&lt;?xml&gt;``
    Leo files start with the following line::

        &lt;?xml version="1.0" encoding="UTF-8"?&gt;

``&lt;?xml-stylesheet&gt;``
    An xml-stylesheet line is option.  For example::
    
        &lt;?xml-stylesheet ekr_stylesheet?&gt;

``&lt;leo_file&gt;``
    The ``&lt;leo_file&gt;`` element opens an element that contains the entire file.
    ``&lt;/leo_file&gt;`` ends the file.

``&lt;leo_header&gt;`` 
    The ``&lt;leo_header&gt;`` element specifies version information and other information
    that affects how Leo parses the file.  For example::
    
        &lt;leo_header file_format="2" tnodes="0" max_tnode_index="5725" clone_windows="0"/&gt;
    
    The ``file_format`` attribute gives the 'major' format number.
    It is '2' for all 4.x versions of Leo.
    The ``tnodes`` and ``clone_windows`` attributes are no longer used.
    The ``max_tnode_index``	attribute is the largest tnode index.

``&lt;globals&gt;``
    The ``globals`` element specifies information relating to the entire file.
    For example::
    
        &lt;globals body_outline_ratio="0.50"&gt;
            &lt;global_window_position top="27" left="27" height="472" width="571"/&gt;
            &lt;global_log_window_position top="183" left="446" height="397" width="534"/&gt;
        &lt;/globals&gt;
    
    -   The ``body_outline_ratio attribute`` specifies the ratio of the height of the body pane to
        the total height of the Leo window.
        It initializes the position of the splitter separating the outline pane from the body pane.
    
    -   The ``global_window_position`` and ``global_log_window_position`` elements
        specify the position of the Leo window and Log window in global coordinates:

``&lt;preferences&gt;``
    This element is vestigial.
    Leo ignores the ``&lt;preferences&gt;`` element when reading.
    Leo writes an empty ``&lt;preferences&gt;`` element.

``&lt;find_panel_settings&gt;``
    This element is vestigial.
    Leo ignores the ``&lt;find_panel_settings&gt;`` element when reading.
    Leo writes an empty ``&lt;find_panel_settings&gt;`` element.

``&lt;clone_windows&gt;``
    This element is vestigial.
    Leo ignores the ``&lt;clone_windows&gt;`` element when reading.
    Leo no longer writes ``&lt;clone_windows&gt;`` elements.

``&lt;vnodes&gt;``
    A single ``&lt;vnodes&gt;`` element contains nested ``&lt;v&gt;`` elements.
    ``&lt;v&gt;`` elements correspond to vnodes.
    The nesting of ``&lt;v&gt;`` elements indicates outline structure in the obvious way.

``&lt;v&gt;``
    The ``&lt;v&gt;`` element represents a single vnode and has the following form::
    
        &lt;v...&gt;&lt;vh&gt;sss&lt;/vh&gt; (zero or more nested v elements) &lt;/v&gt;
    
    The ``&lt;vh&gt;`` element specifies the headline text.
    ``sss`` is the headline text encoded with the usual XML escapes.
    As shown above, a ``&lt;v&gt;`` element may contain nested ``&lt;v&gt;`` elements.
    This nesting indicates outline structure in the obvious way.
    Zero or more of the following attributes may appear in ``&lt;v&gt;`` elements::
    
        t=name.timestamp.n
        a="xxx"
    
    The ``t="Tnnn"`` attribute specifies the tnode associated with this vnode.
    The ``a="xxx"`` attribute specifies vnode attributes.
    The ``xxx`` denotes one or more upper-case letters whose meanings are as follows::
    
        C	The vnode is a clone. (Not used in 4.x)
        E	The vnode is expanded so its children are visible.
        M	The vnode is marked.
        T	The vnode is the top visible node.
        V	The vnode is the current vnode.
    
    For example, ``a="EM"``  specifies that the vnode is expanded and is marked.

    **New in 4.0**:
    
    -   ``&lt;v&gt;`` elements corresponding to ``@file`` nodes now contain ``tnodeList`` attributes.
        The ``tnodeList`` attribute allows Leo to recreate the order in which nodes should appear in the outline.
        The ``tnodeList`` attribute is a list of gnx's: global node indices.
        See ``Format of derived files (4.x)`` for the format of gnx's.
    
    -   Plugins and scripts may add attributes to ``&lt;v&gt;`` and ``&lt;t&gt;`` elements.
        See `Chapter 8: Customizing Leo`_ for details.

``&lt;tnodes&gt;``
    A single ``&lt;tnodes&gt;`` element contains a non-nested list of ``&lt;t&gt;`` elements.

``&lt;t&gt;``
    The ``&lt;t&gt;`` element represents a single tnode and has this form::
    
        &lt;t tx="Tnnn"&gt;&lt;tb&gt;sss&lt;/tb&gt;&lt;/t&gt;
    
    The ``tx`` attribute is required.
    The ``t`` attribute of ``&lt;v&gt;`` elements refer to this ``tx`` attribute.
    The ``&lt;tb&gt;`` element specifies the body text.
    ``sss`` is the headline text encoded with the usual XML escapes.

    **New in 4.0**:
    Plugins and scripts may add attributes to ``&lt;v&gt;`` and ``&lt;t&gt;`` elements.
    See `Chapter 8: Customizing Leo`_ for details.
</t>
<t tx="EKR.20040524104904.380">@killcolor</t>
<t tx="EKR.20040601084317">Leo 4.2 alpha 3           June 1, 2004

This version fixes completes the essential features of version 4.2.  All known incompletions and bugs involving shared nodes and Leo's new file format have been fixed.  BTW, this version of Leo completes Leaps 201 and 202.

It should be safe to use this version for collaboration between Leo's developers.  I hereby encourage people to start using cvs for collaboration.  Only by doing so will we discover any possible problems.

The only item that must be completed before releasing 4.2 beta is fixing the Go To Line Number command so it supports thin derived files.

There are many known bugs in this version: most are minor bugs that have been around for a long time.  All known bugs will be fixed by the first release candidate.  See the to-do list in LeoPy.leo for the complete list.

The highlights of this version:

- All features of @file-thin are now complete and appear to be stable.
	- All .leo files in the distribution use @thin files where possible.
	- Leo ignores all directives within the range of the @all directive.
	- The @+middle and @-middle sentinels allow sections to be defined in any descendant node.
	- The @clone sentinel marks duplicate cloned siblings.
- The beginnings of a new undo scheme are in place.
- @thin, @nosent, @noref and @asis are abbreviations for @file-thin, @file-nosent, @file-noref and @file-asis.
- Created new iterators that return lists of vnodes and tnodes, including iterators that remove all duplicates from those lists.</t>
<t tx="EKR.20040601084317.2"></t>
<t tx="EKR.20040601084317.99">This happened after write errors such as orphan nodes.</t>
<t tx="EKR.20040601084317.102">Added u.registerUndoHandlers.

This will become largely unnecessary in the new undo scheme.  It's good to have though.</t>
<t tx="EKR.20040601084317.142">When writing .leo files Leo now pickle's and hexlify's all data in the v.unknownAttribute and t.unknownAttribute dictionaries.  When reading .leo files Leo does the reverse.

Leo ignores all elements in these dictionaries if some element can not be pickled.</t>
<t tx="EKR.20040601084317.161">I have fallen madly in love with generators.  The following new iterators are defined with generators.

c.all_positions_iter
c.all_tnodes_iter
c.all_vnodes_iter
c.all_unique_tnodes_iter
c.all_unique_vnodes_iter

p.tnodes_iter
p.vnodes_iter
p.unique_tnodes_iter
p.unique_vnodes_iter

v.self_and__subtree_iter
v.self_and_unique_subtree_iter</t>
<t tx="EKR.20040601101118">If the copied node was an @thin or @file-thin node node only the root node was copied.</t>
<t tx="EKR.20040601101227"></t>
<t tx="EKR.20040601101227.1"></t>
<t tx="EKR.20040601101430">This bug exists in 4.1 final.  Leo did not properly show the found text in headlines.  The fix was in the code that redraws the screen, not in the find/change code itself.</t>
<t tx="EKR.20040601101430.1"></t>
<t tx="EKR.20040601101510"></t>
<t tx="EKR.20040601101547"></t>
<t tx="EKR.20040601102115"></t>
<t tx="EKR.20040601102703">The new scheme simply saves all information in one or more vnodes and their associated tnodes.  This is a general scheme that can be used by almost any command.

At present only the u.saveTree method exists.  Coming soon, u.saveNode, u.saveNodeAndChildren and u.saveListOfNodes.</t>
<t tx="EKR.20040601102808">See the to-do list in LeoPy.leo for a list of known bugs in this version.

None of these bugs is serious:  I consider this version to be suitable for day-to-day work.</t>
<t tx="EKR.20040628095213">Leo 4.2 beta 2           July 5, 2004
Leo 4.2 beta 1           June 30, 2004

The highlights of 4.2 beta 2:

- Leo now writes the entire contents of @ignore'd @thin trees to the .leo file.
This change ensures that users can create and remove @ignore directives without
any chance of losing data inadvertently.

- Leo now saves and restores marks and the expansion state of nodes in @thin trees.

- Leo marks @thin nodes as dirty whenever they become "newly unignored", i.e.,
when an @thin node no longer falls in the range of an @ignore directive.

Beta 1 completes all fundamental work in the 4.2 code base. All essential code
is complete. Dozens of bugs have been fixed since the Alpha 3 release about a
month ago.

Known bugs in 4.2 beta 2:

- Not all plugins work correctly.
- Some plugins leak memory very slightly.

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
derived files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

Other features of 4.2:

- Leo is now much more friendly to using spaces instead of tabs.
- The Execute Script command reports erroneous lines more clearly.
- The usual assortment of bug features and minor features.

Coming soon in 4.2:

- Perfect Import will guarantee that Leo imports file perfectly.
- @import will allow you to study files using Leo without changing those files.</t>
<t tx="EKR.20040628095213.3">@nocolor

- Leo calls g.enableIdleTimeHook at end of startup code.
	- This means that g.idleTimeHookHandler gets called periodically, even if no hooks have been defined.
	- g.enableIdleTime hook now calls g.app.gui.setIdleTimeHook at most once.

- app.forceShutdown now calls "end1" hook before calling app.finishQuit.
	- This ensures that the "end1" hook always gets called once.
	- app.finishQuit calls doHook("end1",...) only if it hasn't been called before.
		- This isn't necessary, but it makes traces in doHook less confusing.

- idleTimeHookHandler now calls the idle-time hook for all open windows.
	- So having multiple windows open should not affect idle-time hooks.

** Warning: new convention required to workaround apparent Tk problems.
	- "idle" hooks should return if g.app.killed is True.</t>
<t tx="EKR.20040628095213.23">@color

Added the following hooks:

tag argument                                               keys in keywords
(hook name)           overrides    when called           dictionary argument
---------             ---------    -----------           -------------------

"draw-outline-box"       yes   start of drawBox          tree,p,v,x,y (note 6)
"draw-outline-icon"      yes   start of tree.drawIcon    tree,p,v,x,y (note 6)
"draw-outline-node"      yes   start of tree.drawNode    tree,p,v,x,y (note 6)
"draw-outline-text-box"  yes   start of tree.drawText    tree,p,v,x,y (note 6)
"draw-sub-outline"       yes   start of tree.drawTree    tree,p,v,x,y,h,level,hoistFlag (note 6)</t>
<t tx="EKR.20040628095213.52"></t>
<t tx="EKR.20040628095213.56"></t>
<t tx="EKR.20040628095213.60">Added support for RapidQ, css, shell scripts and PHP.</t>
<t tx="EKR.20040628095213.109">http://sourceforge.net/forum/message.php?msg_id=2429098
By: nobody

The Leo icon can eliminate the need for the word Leo.

What I did:

- Eliminate Leo in name of Find panel.
- Derived leoTkinterPrefs from leoTkinterDialog: creates icon.
- Derived leoComparePanel from leoTkinterDialog: creates icon.
- Eliminated the -t option when opening Idle: the idle window is now called "Python Shell"</t>
<t tx="EKR.20040628095213.110">- Added @language html when importing ".htm" and ".html" files.
- Added @nocolor when importing ".txt" and ".text" files
</t>
<t tx="EKR.20040628095213.113">When in headline, the Select All command selected the body text.</t>
<t tx="EKR.20040628095213.121">- idle_body_key must call g.scanDirectives in order to support @tab_width.
	- This must be done for tabs and newlines.

- Fixed bug in g.scanDirectives that was rejecting negative tabwidth values.
	- This bug did not exist in the other versions of scanDirectives.

- With a negative tabwidth, a backspace now computes what spaces are equivalent to a tab and delete all of those.  This is easy to do!
</t>
<t tx="EKR.20040628095213.143"></t>
<t tx="EKR.20040628095213.160"></t>
<t tx="EKR.20040628095213.192"></t>
<t tx="EKR.20040628095213.197">doc\leoUsersGuide.txt
doc\leoFAQ.txt
doc\leoLeaps.txt</t>
<t tx="EKR.20040628095213.198">The old code used at c.tab_width.  It should also look for @tabwidth directives.

This was not good when @tabwidth -4 was in effect.</t>
<t tx="EKR.20040628095213.202">atFile.scanHeader was not handling -encoding fields properly.</t>
<t tx="EKR.20040628095213.213"></t>
<t tx="EKR.20040628095213.225"></t>
<t tx="EKR.20040628095213.246"># namespace not handled very well.</t>
<t tx="EKR.20040628095213.264"></t>
<t tx="EKR.20040628095213.269"></t>
<t tx="EKR.20040628095213.279">I inserted "import time", and while I was at it I improved the error checking.</t>
<t tx="EKR.20040628095213.282">- By default, finishPaste command reassigns all indices in copied nodes.
- Created pasteOutlineRetainingClones.
- Added reassignIndices arg to pasteOutline, getLeoOutline and finishPaste.
- Added &lt;&lt; recreate tnodesDict &gt;&gt; in getLeoOutline.
- Simplified getTnode slightly: the "if t" code is the same for both kinds of reads.</t>
<t tx="EKR.20040628095213.297">The code now limits what can be pasted to a maximum of one line or a about 250 characters.</t>
<t tx="EKR.20040628095213.308"></t>
<t tx="EKR.20040628095213.311">@nocolor

- Leo now uses True and False everywhere instead of true and false.

- All of Leo's code uses spaces instead of tabs for indentation.</t>
<t tx="EKR.20040628095213.312"></t>
<t tx="EKR.20040628095213.314"></t>
<t tx="EKR.20040628095213.324">- Set removeTrailing to True unless ch is a newline.

This allows Alt-f to work properly.

- Return "break" after the "final" text has been computed if nothing has changed.

This suppresses spurious newlines.

A new idea:  Make sure the text _does_ have a newline at all times.  I'm not sure this will work...

- ALWAYS set the text in select.  This prevents some weird problems with trailing newlines.</t>
<t tx="EKR.20040628095213.334">- The string passed to exec now includes sentinels.

goToLineNumber needs sentinels to work properly.

- es_exception now gets the error line number from the traceback.

- Added new keyword arguments to goToLineNumber.

- Created goToScriptLineNumber, which just calls goToLineNumber.</t>
<t tx="EKR.20040628095213.346">Hitting return in middle of a headline didn't work.</t>
<t tx="EKR.20040628095213.348"></t>
<t tx="EKR.20040628095213.354"></t>
<t tx="EKR.20040628095213.366"></t>
<t tx="EKR.20040628095213.368"></t>
<t tx="EKR.20040628095213.377">Changed getVnode so it checks for v = None after calling getExistingVnode.  Creating the node seems to work in this case: I wouldn't bet my life that it works in all cases.</t>
<t tx="EKR.20040628095213.391">- Added toString to most write methods.
- Retained scriptFile option for compatibility with plugins.</t>
<t tx="EKR.20040628095213.404"></t>
<t tx="EKR.20040628095213.407"></t>
<t tx="EKR.20040628095213.408"></t>
<t tx="EKR.20040628095213.412"></t>
<t tx="EKR.20040628095213.425"></t>
<t tx="EKR.20040628095213.442">This only happened after previous write error.

The fix was to init self.errors in openWriteFile.

The whole atFile logic is pretty gruesome.  It's got to be cleaned up.</t>
<t tx="EKR.20040628095213.444">- Allow indented @all.
    - Changed to g.is_special
    - Changed leoColor.doAtKeyword
    
- Fixed bug in is_special that broke p.isAtAllNode.</t>
<t tx="EKR.20040628095213.485">There was a small hole in the format of derived files.  Leo assumed that comment delimiters do not change within any particular derived file.  This assumption is not necessarily true in files like leoProjects.txt.

What I did:

- putDirective and readDirective now check for @langauge and @comment, and change comment delims appropriately.

This is slightly dubious: after all, an @langauge directive in the middle of most derived files will cause havoc.  However, one could say that this is the users problem :-)

BTW, this doesn't really solve all problems in @all trees: Leo can still get mightily confused about comment delims if the user doesn't put proper @language directives in @all trees.
</t>
<t tx="EKR.20040628095213.490">readEndNode uses the existing tempBodyString attribute to determine if the body text has changed.  If so, we mark the tnode dirty.  The code in 

top_df.read.&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;

propagates the dirty marks to all ancestor @file nodes.  This can't be done in readEndNode because no positions are available at that time.</t>
<t tx="EKR.20040628095213.493"></t>
<t tx="EKR.20040628095213.499"></t>
<t tx="EKR.20040628095213.501">Leo now writes t.unknownAttributes to the .leo file when writing the &lt;v&gt; element corresponding to the root of an @thin tree.  Leo will do this by writing a new xml attribute, descendentTnodeUnknownAttributes, in &lt;v&gt; element.

Leo will only write t.unknownAttributes, not v.unknownAttributes.  This is because only tnodes have gnx's in thin derived files.  In effect, vnodes are anonymous.  We could attempt to get around this by identifying vnodes by their corresponding tnodes, but that's not a general solution and it is, in effect, equivalent to writing only t.unknownAttributes.  This being so, it seems pointless to "pretend" to be writing v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using unknownAttributes is concerned.  As I've stated in the past, this won't do if, for example, a plugin is trying create an arbitrary directed graph between vnodes.  In that case, the plugin should confine itself to @file trees, or just vnodes in .leo files, for that matter.</t>
<t tx="EKR.20040628095213.512">The problem was setting endSentinelComment to None instead of "" in readDirective.

The code is pretty fragile; it should handle either None or "", but in fact it requires "".</t>
<t tx="EKR.20040628095213.513"></t>
<t tx="EKR.20040628100535">@killcolor</t>
<t tx="EKR.20040628100535.1"></t>
<t tx="edream.110203163054.46">@nocolor</t>
<t tx="edream.110203163054.48">@ @rst-options
code_mode=False
default_path = .
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|back| |leo| |next|

##########################################
Chapter 1: Installing Leo
##########################################

This chapter tells how to install and run_ Leo.

.. contents::</t>
<t tx="edream.110203163054.49">Leo will work on any platform that supports Python 2.2.1 or later and Tk 8.4 or later.

-   Download the latest version of Leo from:
    http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106

-   Download Python from: http://python.org/

-   Most installations of Python have Tk pre-installed.
    If your doesn't, you may download it from: http://tcl.activestate.com/software/tcltk/

-   Leo uses `Pmw`_ (Python Mega Widgets). Leo's extensions folder contains a copy
    of Pmw for use if needed. Leo first tries to import Pmw normally. If that
    fails, Leo will use the version of Pmw in the extensions folder.

See `How to install Leo on MacOS`_ for installation instructions
for MacOs X. Leo will not run on MacOs 9.</t>
<t tx="edream.110203163054.50">**Warning**: When building Tcl on Linux, do **not** specify::

    "--enable-threads"

Only use Tcl with the default "threads not enabled" case.

Leo is distributed as a single compressed folder. Simply uncompress this folder,
then `run Leo`_.</t>
<t tx="edream.110203163054.51">Leo is distributed either as an executable installer (.exe) file or as a .zip file.
**Note**: the present version of the installer does not work properly with Python 2.4.
You can install Leo from the .zip file as follows:

-   Unzip the .zip file and place the leo folder somewhere, say under the Python directory.

-   Copy your existing Leo shortcut then modify the original so that it points to
    pythonw.exe (in the python24 dir) and has the location of Leo within quotes.

-   Set the working directory wherever you want the leo files to reside, say ``\leo\usr``.

Now you are ready to `run Leo`_.</t>
<t tx="edream.110203163054.60">Leo will open .leo files automatically provided that you associate leo.py with .leo files.
Here is how to open Leo when double-clicking a .leo file on Windows 2K or XP:


-   In Windows 2K or XP, go to ``Start-&gt;Settings-&gt;Control panel``, open the ``Folder Options`` tab.
-   Select the ``file types`` tab. Press the ``New`` button.
-   Enter ``Leo`` into the ``Create New File Extension`` field. Press OK.
-   With ``Leo`` still highlighted in the ``Registered File Types`` list box, press the ``Advanced`` button.
-   Change the default file type field to something like ``Leo Literate Outline``.
-   Press the ``Icon`` button and browse to the ``LeoDoc`` icon in Leo's ``Icons`` folder.
-   Click OK. This gets the icons right and registers the description of the .leo file.

You now have to tell windows what to do to open the file properly:

-   Press the new button to open the ``New Action`` window.
-   In the ``Action`` field type ``Open``, then type **one** of the following lines::

    [python install dir]\pythonw.exe   [leo install dir]\leo.py %1
    [python install dir]\python.exe -i [leo install dir]\leo.py %1

The first  line opens Leo files with no console window.
The second line opens Leo files with a console window and leaves the window open after Leo exits.
You should now be able to double click on a leo file in explorer with Leo.</t>
<t tx="edream.110203163054.61">Leo will draw a Leo icon in all Leo windows without PIL or tkIcon.
For versions of Leo before 4.0 and for versions of Python before 2.3,
Leo will draw a Leo icon in Leo windows only if you have installed Fredrik Lundh's PIL and tkIcon packages.

-   Download PIL from http://www.pythonware.com/downloads/index.htm#pil

-   Download tkIcon from http://www.effbot.org/downloads/#tkIcon</t>
<t tx="edream.110203163054.63"></t>
<t tx="edream.110203163054.64">Leo 4.1 alpha 1                   November 3, 2003

*** Alpha quality code:  Please make full backups before playing with this code!

This release marks another significant milestone in Leo's history:

- Leo's 4.x file code is complete.  At present I have no plans to change the format of .leo files or derived files.  I am eating my own dog food: I do all my editing with the 4.1 code base.

- Leo uses immutable gnx's (id:timestamp:n) by default to associate tnodes with vnodes in .leo files.  This makes Leo as cvs friendly as possible.  From now on .leo files will be checked in to cvs with the -ko (text/keywords off) option.

- The use_gnx setting in leoConfig.txt determines whether uses gnx's (cvs friendly) or ints.  No version of Leo before 4.1 can read .leo files containing gnx.   Only gnx's are immutable.  Leo recomputes all non-gnx indices from scratch whenever writing a .leo file. It is possible to convert between 3.x and 4.1 file formats by changing the use_gnx setting.

- The 4.1 code base has been reorganized to support gui's other than tkinter.  Leo's src directory contains several new source files.

- The file test.leo in the test directory contains real regression tests for syntax coloring.   Regression testing scripts create regression tests dynamically from data in Leo's outline.  Very cool, very easy, very general.  In particular, regression tests may use temporary nodes in test.leo rather than creating separate Tk windows for testing.

Known bugs:

- The Extract commands eat one character too much.

- The __wx_gui.py plugin is only partly functional.</t>
<t tx="edream.110203163054.66">Leo 4.0.4                         October 29, 2003

- Fixed a problem with the titles in Font and Color panels.
- Worked around a Unicode assert failure in the colorizer.
- Fixed crasher in OnEndEditHeadline.
- Fixed import problems in leoPlugins.leo.
- @first and @last sentinels no longer contain corresponding text.
  This fixes a problem that affected PHP comment delimiters.

Leo 4.0.3                         October 25, 2003

- Fixes several problems with the auto_save and plugin menu plugins.
- Fixes a problem with the Go To Line Number command.

Note: This version does _not_ support Unicode file names or directory names.

Leo 4.0.2                         October 23, 2003

- Fixes a crasher in reportBadChars when a .leo file contains a character that
  can not be represented in the encoding specified in the first line of the
  .leo file.
- Leo now sends full tracebacks to the log window when Leo takes an unexpected
 exception.
- Leo now issues a more informative message when the @comment directive
  inhibits the Untangle command.

Leo 4.0.1                         October 22, 2003

- Fixes several crashers, one of which may prevent Leo from starting.
- Fixes indentation for section references that are preceded by something
  other than whitespace.
- Removes debugging traces when reading and writing unknown attributes.
- Removes some improperly cloned nodes from LeoDocs.leo.
- Adds the checkTopologyOfAllClones script.
- Fixes some problems with plugins.</t>
<t tx="edream.110203163054.67">Leo 4.0 final                     October 17, 2003

More than a year in the making, Leo 4.0 is finally here.

Highlights of 4.0 final:
-----------------------

** Improved and simplified format of derived files.
	- Eliminated child indices, extraneous blank lines and @body sentinels.
	- Eliminated @node sentinels that indicate outline structure.
	- New @nl and @nonl sentinels indicate where newlines are and aren't.
	- These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
	- Reading derived files _never_ alter outline structure or links.
	- Read errors leave the outline completely unchanged.
	- Broken clone links are gone forever.
	- As a result, 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
	- Leo 4.0 reads all derived files properly, regardless of version.
	- Leo writes new-format derived files by default, and this default may be changed.
	- New commands in the read/write menu allow you to explicitly specify the format of derived files.

* New commands:
	- Write 3.x Derived File and Write 4.x Derived File.
	- Import Derived File.
	- Clear Recent Files.

* Dozens of other improvements, including:
	- Better Unicode support.
	- New configuration settings.
	- Several new plugins.

See the notes for the various beta releases for full details.</t>
<t tx="edream.110203163054.68">Leo 4.0 beta 4                      October 13, 2003

This is the third public release of Leo 4.0. There are no known serious bugs in
this version of Leo.  This will be the last beta release before 4.0 final.

Changes made in 4.0 beta 4
--------------------------

- Changed all instances of string.letters to string.ascii_letters.
  string.letters can cause crashes in some locales (Unicode environments).
- Fixed several bugs that caused clone marks not to be set properly.</t>
<t tx="edream.110203163054.69">Leo 4.0 beta 3                      October 9, 2003

This is the third public release of Leo 4.0. There are no known serious bugs in
this version of Leo.

Highlights of 4.0 beta 3
------------------------

- Fixed problems with setting Leo's window icons.
- Plugins may now save their own information in &lt;v&gt; and &lt;t&gt; elements in .leo files.
- The usual assortment of bug fixes and minor improvements.

See the children of this node for full details.</t>
<t tx="edream.110203163054.70"></t>
<t tx="edream.110203163054.71">This was a long-standing bug.  It's effect was cosmetic, and it was important to fix.</t>
<t tx="edream.110203163054.72"></t>
<t tx="edream.110203163054.73">This could happen when the derived file was corrupted.</t>
<t tx="edream.110203163054.74"></t>
<t tx="edream.110203163054.75"></t>
<t tx="edream.110203163054.76">Leo can now read and write "foreign" attributes in &lt;v&gt; and &lt;t&gt; elements in .leo files:

- When reading a .leo file, Leo will create t.unknownAttributes or v.unknownAttributes ivars for any tnode and vnode object whose corresponding &lt;v&gt; or &lt;t&gt; element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are a dictionary whose keys are the attribute names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if  a vnode or tnode contains an unknownAttributes ivar.

- The only "native" attributes that Leo expects to find are the "tx" attribute in &lt;t&gt; elements and the "a", "t", "vtag" and "tnodeList" attributes of &lt;v&gt; elements.  Everything else is a foreign attribute.

- Leo performs the usual xml escapes on these strings when reading or writing the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching unknownAttributes ivars to a vnode or tnode.  For example:

	v.unknownAttributes = {"vnodeIcon" : pathToIcon}

It would be best not to delete other foreign attributes, so the following would be preferred:

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

Another way:

	try:
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	except AttributeError:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}</t>
<t tx="edream.110203163054.77"></t>
<t tx="edream.110203163054.78">Leo now warns if it can't find either the Icons directory or the LeoApp16.ico icon in that directory.</t>
<t tx="edream.110203163054.79">Leo 4.0 beta 2                      October 3, 2003

This is the second public release of Leo 4.0. There are no known serious bugs
in this version of Leo. Version 4.0 is the culmination of over a year of
collaborative design work and several months of actual implementation.

Highlights of 4.0 beta 2
------------------------
* Fixed several bugs:
  - Fixed several problems with reading and writing 4.0 derived files.
  - Fixed several Unicode-related bugs.
  - Fixed a crasher in the Go To Line Number command.
  - Fixed a problem with Importing Python files.
* Important improvements:
  - Added allow_clone_drags setting.  N.B. Allows Leo to be used with Aqua.
  - When running Python 2.3 Leo can now create window icons without third-party packages.
- The usual minor improvements and bug fixes.

See the children of this node for full details.

Highlights of 4.0 beta 1
------------------------
* Improved and simplified format of derived files.
* Greatly improved error handling.
* Full compatibility will previous versions of Leo.</t>
<t tx="edream.110203163054.80">- Fix undo/redo bug for all commands that change body text in multiple nodes without changing outline structure.
	- This is a long-standing bug that came to light when trying to make Read @file Nodes undoable.

- Make Read @file Nodes command undoable.

- Fix small bugs in the Go To Line Number command.</t>
<t tx="edream.110203163054.81"></t>
<t tx="edream.110203163054.82">The new code prints a warning if Leo's key internal strings are not Unicode.</t>
<t tx="edream.110203163054.83"></t>
<t tx="edream.110203163054.84">There were bugs involving saving the "Pattern Match" and "Subroutine Only" find settings.</t>
<t tx="edream.110203163054.85">@nocolor

Class level-code after the method definitions was dropped.  For example:

@color

class someclass:
	def __init__(self):
		pass

	# this code is dropped
	class_var = None

def some_proc():
	pass</t>
<t tx="edream.110203163054.86">The new code ensures that Leo creates and uses only Unicode strings internally.</t>
<t tx="edream.110203163054.87">Fixed Go To Outline command so it doesn't crash on 4.0 files.  More work is needed.</t>
<t tx="edream.110203163054.88">Under certain conditions the no sentinels at all were written when writing @rawfile trees.</t>
<t tx="edream.110203163054.89"></t>
<t tx="edream.110203163054.90"></t>
<t tx="edream.110203163054.91">This is much more natural and less cluttered.</t>
<t tx="edream.110203163054.92"></t>
<t tx="edream.110203163054.93"></t>
<t tx="edream.110203163054.94">Leo will create the Leo icon in Leo windows automatically when using Python 2.3.  The Python Imaging Library and the tkIcon package are only used when using previous versions of Python.</t>
<t tx="edream.110203163054.95">This is the foundation for "foreign" guis.</t>
<t tx="edream.110203163054.96"></t>
<t tx="edream.110203163054.97">allow_clone_drags

This is a workaround so that Leo may be used on Aqua.  When this setting is zero Leo always moves nodes when dragging.  The default is to enable clone-drags.

enable_drag_messages

Allows the user to suppress the message telling whether dragging nodes will move them or clone them.  The default is to enable those messages.</t>
<t tx="edream.110203163054.98">After the 4.0 beta 1 release I changed the default so that _new_ format derived files are written if leoConfig.txt does not exist.</t>
<t tx="edream.110203163054.99">leo.py 4.0 beta 1                      September 26, 2003

This is the first public release of Leo 4.0.  Version 4.0 is the culmination of over a year of collaborative design work and several months of actual implementation.

Please use caution when using this beta version of Leo.  It appears very solid and it has been tested by only a few people.

Highlights of 4.0:

** Improved and simplified format of derived files.
	- Eliminated child indices, extraneous blank lines and @body sentinels.
	- Eliminated @node sentinels that indicate outline structure.
	- New @nl and @nonl sentinels indicate where newlines are and aren't.
	- These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
	- Reading derived files _never_ alter outline structure or links.
	- Read errors leave the outline completely unchanged.
	- Broken clone links are gone forever.
	- As a result, using 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
	- Leo reads all derived files properly, regardless of version.
	- Leo writes new-format derived files by default, and this default may be changed.
	- New commands in the read/write menu allow you to explicitly specify the format of derived files.

* New commands:
	- Write 3.x Derived File.
	- Write 4.x Derived File.
	- Import Derived File.
	- Clear Recent Files.

- Several new plugins.
- Several minor bug fixes.

See the children of this node for full details.</t>
<t tx="edream.110203163054.100">The Synchronization Principle simplifies everything and at long last puts Leo on a firm theoretical foundation.  This principle states that the "smallest unit of meaning" of any Leo outline is the entire outline itself.  In particular, individual derived files have meaning only in the context of a particular outline.

The Synchronization Principle has the following happy consequences:

1. We may assume that all derived files are in synch with the outline that wrote them.  This assumption allows Leo to use "hidden machinery" in the outline to associate nodes in the derived file with nodes in the outline.  This "hidden" machinery consists of a list of tnodes associated with @file vnodes in the outline.  When writing a derived file Leo creates a list of tnodes in the order they were written to the derived file.  When reading the derived file, Leo uses this list to associate nodes in the derived file with nodes in the outline.

2. Derived files must get their structure from the .leo file that wrote them.  As we have seen, this is done using the hidden machinery in the .leo file.  Consequently, there is no further need to represent outline structure in derived files.  There is no need any longer either for child indices or for sentinels to represent outline structure.  As a result, we can eliminate @+body and @-body nodes entirely because all @+node sentinels are followed by body text.

3. All .leo files must contain full outline structure.  Even "thin" outline will contain the full representation of the outline as vnodes.

4. Reading _never_ alters outline structure in the outline.  No vnodes are ever created or destroyed and reading never alters clone links.  This is true whether or not read errors occur.  The read code sets a temporary attribute of tnodes while reading.  These attributes are copied to the permanent t.bodyString attribute only if no read errors were encountered.

4. Error recovery is now trivial:  Read errors indicate that the .leo files and one or more derived files are out-of-synch.  No error recovery is attempted: the @file tree in which the error occurred reverts back to its original state.

5. The new Import Derived File command is the _only_ way to recover data from mismatched derived file.</t>
<t tx="edream.110203163054.101"></t>
<t tx="edream.110203163054.102">The write_old_format_derived_files option in leoConfig.leo and leoConfig.txt determines which format of derived file Leo's Write and Save commands write by default.  If this option is 0 (recommended) Leo writes 4.x format derived files.  Otherwise Leo writes 3.x derived files.

Note that you can use the Write 3.x/4.x Derived Files commands in the File:Read/Write menu to write derived files in an explicitly specified format.</t>
<t tx="edream.110203163054.103">This command deletes all entries in the Recent Files submenu except the most recent file.  The files themselves are not affected, just the menu entries.</t>
<t tx="edream.110203163054.104">The Import Derived File command imports all the nodes in a derived file into the outline.  Unlike the read commands, no outline structure is preserved.  This command can import either 3.x or 4.x derived files.

This command is necessary in version 4.0 because there is no other way to read derived files that are out-of-synch with a .leo file.</t>
<t tx="edream.110203163054.105">The Write 4.x Derived Files command and Write 3.x Derived Files command work just like the Write @file Nodes command, except that they write the indicated format off derived file.  In contrast, the Write @file Nodes command writes 3.x format derived files if and only if the write_old_format_derived_files = 1 in leoConfig.txt.

All three of these commands automatically save the outline (the .leo file) if any derived file was actually written.  This is necessary so that information in the .leo file always remains in synch with all derived files.</t>
<t tx="edream.110203163054.106">Paul Paterson contributed the following new plugins:

mod_autosave.py

Autosaves the Leo document every so often.

mod_timestamp.py

Timestamps all save operations to show when they occur.

word_export.py

Exports an outline to a word document.  Clicking "plugins ... word export ... export" exports the selected outline to Word.  Word should be running with an open (empty) document before executing this command.</t>
<t tx="edream.110203163054.107"></t>
<t tx="edream.110203163054.108">Leo's read code now warns if any non-empty node is unvisited.  This check, and the check that headlines match pretty much guarantees that out-of-synch outlines will generate errors.  Thus, there is no need a gnx timestamp in @+leo sentinels!</t>
<t tx="edream.110203163054.109">Version 4.0 is a major advance in Leo's error handling.  Using 4.0 is much safer than all previous versions.  This new error handling applies to all derived files, both 3.x and 4.x format.  

Leo's read code never alters the structure of an outline, regardless of whether read errors are encountered. This means that clone links, marks, and all other information in the outline except body text remains completely unchanged during reads.  Broken clone links (the dreaded read errors) are gone forever.  
Also, the new read code makes no changes to any body text until it is known that no read errors have occured.  This ensures that absolutely no changes at all are made to the outline if there are read errors.

Leo's read code now writes a message to the log pane whenever it sees that the body text in the derived file does not match the body text in the outline.  These messages do not indicate errors, only that the body text has been changed outside of Leo, say in an external editor or by cvs.</t>
<t tx="edream.110203163054.110"></t>
<t tx="edream.110203163054.111"></t>
<t tx="edream.110203163054.112">Added encoding comments to leoGlobals.py and French plugins

This removes a warning new in Python 2.3.
</t>
<t tx="edream.110203163054.113">There is no need to recycle Python objects when the last outline window is being closed.</t>
<t tx="edream.110203163054.114">This is too annoying during testing.  The Read @file Nodes command will in fact be made undoable for the 4.0 final release.</t>
<t tx="edream.110203163054.115">This has been changed in Python 2.3 and it probably wasn't ever a good idea...</t>
<t tx="edream.110203163054.116">The read code has much simplified using look-behind rather than look-ahead.  Both the read and write code write the file line-by-line without recursion.</t>
<t tx="edream.110203163054.117"></t>
<t tx="edream.110203163054.118"></t>
<t tx="edream.110203163054.119">leo.py 3.12 Final                       July 17, 2003

Window sizes are now in pixels rather than grid units.
You will need to resize existing outlines (.leo files).  Don't panic!

Highlights of this version:

* Plugged a huge memory leak.
* Fixed a major bug involving undo.
* Added Icon &amp; Status areas to Leo window for use by plugins.
* Important new plugins:
  - The file leoPlugins.leo now contains all plugins.
  - add_directives.py allows plugins to define new directives.
  - color_markup.py supports wiki-styled markup.
  - mod_spelling.py checks spelling (requires aspell to be installed).
  - nav_buttons.py creates browser-style navigation plugins in the icon area.
  - plugins_menu.py creates a Plugins menu items for all loaded plugins.
  - scripts_menu.py creates a Scripts menu for all scripts in scripts folder.
  - spell
  - trace_gc traces all changes to memory at idle time.
* Other enhancements:
  - Redesigned the Find panel.   Non-functional options are dimmed.
  - Added @wrap and @nowrap directives.
  - Added Write Dirty @file Nodes command.
  - Added several new "stub hooks".
  - Hyperlinks are now enabled by default.
  - Leo now loads plugins in alphabetical order.
  - Leo now remembers the size and location of Leo windows.
  - Undo now restores the insert point or the selection range after most commands.
  - Added apply button to Font panel.
  - Improved the reporting of characters that do not exist in the present encoding.
* The usual assortment of bug fixes and minor improvements.
  - There are no known bugs in this version of Leo.

See the children of this node for full details.</t>
<t tx="edream.110203163054.120"></t>
<t tx="edream.110203163054.121">Undoing the following commands could corrupt outlines:

Convert All Blanks, Convert All Tabs, Extract, Extract Names, Extract Section.</t>
<t tx="edream.110203163054.122">v.nodeAfterTree was being called way too often when handling read errors.</t>
<t tx="edream.110203163054.123">- Leo wasn't properly recycling Tk widgets when redrawing the outline pane.  This was a _huge_ leak.

- Leo now recycles all objects used by a window when that window closes.

The app.destroyAllWindowObjects() routine calls o.__dict__.clear for all objects o in a window.

- Leo now longer needs destroy() methods in each major class.</t>
<t tx="edream.110203163054.124"></t>
<t tx="edream.110203163054.125">c:\prog\leoCVS\leo\src\leoNodes.py:1174: Parameter (encoding) not used

This may have been the cause of some "unicode" problems.</t>
<t tx="edream.110203163054.126">c:\prog\leoCVS\leo\src\leoFrame.py:976: No global (a) found

This may have been the cause of some problems with the log panel.</t>
<t tx="edream.110203163054.127">Leo didn't properly import .cxx files or files with upper case extensions.</t>
<t tx="edream.110203163054.128">The messages "reading: @file x" were not always showing up during Open commands.</t>
<t tx="edream.110203163054.129">Symptom: Sometimes the "reading" messages would not appear when reading an outline.

Cause: Several event handlers are called at unpredictable times during the load process.  These may try to reset the log.

Solution:
- create app.setLog, app.lockLog and app.unlocklog methods.
- call app.lockLog before opening an outline.</t>
<t tx="edream.110203163054.130"></t>
<t tx="edream.110203163054.131">The body_pane_wraps setting is now handled properly.
</t>
<t tx="edream.110203163054.132">The body keystroke handler wasn't handling the delete character properly.</t>
<t tx="edream.110203163054.133"></t>
<t tx="edream.110203163054.134">Methods with the same name confused this command.

The Go To Line Number command will be rewritten for 4.0.</t>
<t tx="edream.110203163054.135">The following was improperly indented in @nosentinel files.  The expansion of &lt;&lt; class shape declarations &gt;&gt; was indented twice.

class shape(object):
  	&lt;&lt; class shape declarations &gt;&gt;
  	# after decls</t>
<t tx="edream.110203163054.136">- Added code to check for errors in the table passed to createOpenWithMenuFromTable.

- Revised code that checks to see whether a temp file has already been created.  The old code didn't properly take into account of file extensions when checking for already opened temp files.</t>
<t tx="edream.110203163054.137">Leo now converts all tabs to blanks as you type, not just leading blanks.</t>
<t tx="edream.110203163054.138">- Moved the code into the app class.</t>
<t tx="edream.110203163054.139">This was due to a recent change in getTextSelection.</t>
<t tx="edream.110203163054.140"></t>
<t tx="edream.110203163054.141">- Several parts of the code looped on lists that were altered in the loop.
- Fixed several bugs in the code that handled shortcuts to Open With menu items.</t>
<t tx="edream.110203163054.142">- Leo's various sort commands did not work properly if two headlines were identical.

- Eliminated the unnecessary and buggy sortSequence routine.</t>
<t tx="edream.110203163054.143"></t>
<t tx="edream.110203163054.144">Recent changes interfered with dragging nodes.</t>
<t tx="edream.110203163054.145">Here are the results from running checkClones2Links script on this file:

multipleTargetsInDerivedFiles: 8

(fixed) class nodeIndices      (improperly duplicated in leoAtFile.py)
(fixed) frame.OpenWithFileName (improperly duplicated in Recent Files submenu)
(fixed) recentButtonCallback   (improperly duplicated in Mark/Goto submenu)

-- Used several times in same derived file.  Will this be valid in LeoN?

&lt;&lt; Append any unused text to the parent's body text &gt;&gt; (used several times in leoImport.py)
&lt;&lt; Check both parts for @ comment conventions &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Compare single characters &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Set the default directory &gt;&gt; (used several times in leoAtFile.py)

-- Used (properly) in two different derived files:

replacePatterns (used on purpose in setup.py and postSetup.py)

clonedAtFileNodes: 9

@file ../plugins/add_directives.py
@file ../plugins/french_fm.py
@file ../plugins/open_with.py
@file ../plugins/vim.py
@file ../plugins/xemacs.py
@file c:\prog\test\multiple.txt
@file-nosent nosentCloneTest.txt
@silentfile ../doc/PKG-INFO.TXT
@silentfile ../doc/README.TXT
</t>
<t tx="edream.110203163054.146">Fractions cause problems in some locales.  The height/width params weren't used anyway!
</t>
<t tx="edream.110203163054.147"></t>
<t tx="edream.110203163054.148"></t>
<t tx="edream.110203163054.149">- createTopologyList creates a list containing a description of a tree.  Used by several of the new scripts.

- importFromPath encapsulates a lot of details of custom importing, and makes it unnecessary to alter sys.path.

- funcToMethod allows users to add methods to any class.  Such methods immediately become available to all objects, including existing objects!

- Added do-nothing flush method to redirect class.  This routine was added to support LeoN.</t>
<t tx="edream.110203163054.150">- The checkForPossiblyBrokenLinks script does just what it says.

- The checkClones2Links script warns if nodes are used by several derived files.</t>
<t tx="edream.110203163054.151">The new code uses a common base class for all dialogs.</t>
<t tx="edream.110203163054.152">- The new code uses proper Python lists to represent join lists.  This greatly clarifies the relevant sections of code, and may even provide a performance boost.  

- tnodes now contain both headline and body text. This change creates an important invariant:  vnodes with the same vnx's always point to tnodes with the same tnx's.  This invariant is vital to resolving conflicts properly.

- rewrote joinList code and move joinLists to tnodes.</t>
<t tx="edream.110203163054.153">- There is now only a single entry point into Leo: the run() routine.

This routine uses an optional fileName arg.

- Created runMainLoop function in leo.py so the call to mainloop() is in a separate function.

This routine was added to support LeoN.</t>
<t tx="edream.110203163054.154"></t>
<t tx="edream.110203163054.155"></t>
<t tx="edream.110203163054.156">The body_pane_wraps setting is used if neither of these directives is in effect.
</t>
<t tx="edream.110203163054.157">This make the Font panel a bit less intimidating to use.</t>
<t tx="edream.110203163054.158">- Added an "icon area" at the top of each Leo frame.  Plugins may add buttons to the Icon area at the top of each Leo frame.  See the nav_buttons.py plugin for an example of how to use this area.

- Added a "status area" at the bottom of each Leo frame.  This area reports the line and column number of the cursor.  Plugins may send status messages to this this area.

- Added convenience routines for the icon and status areas to the LeoFrame class.  Plugins may use these convenience routines to create, update, manage and destroy fields in the icon and status areas.</t>
<t tx="edream.110203163054.159">These aren't quite ready for prime time.</t>
<t tx="edream.110203163054.160"></t>
<t tx="edream.110203163054.161"></t>
<t tx="edream.110203163054.162">Hypertext links now enabled by default.  Control-click any section reference to go to its definition.  I changed the colorer so that it does _not_ underline active hyperlinks in section reference.  If a section reference is underlined, it means the definition does _not_ exist.  Otherwise the section reference _does_ exist and control-clicking the reference takes you to the defining node in one of its descendants.</t>
<t tx="edream.110203163054.163">The new code is substantially more robust than the old.</t>
<t tx="edream.110203163054.164"></t>
<t tx="edream.110203163054.165"></t>
<t tx="edream.110203163054.166">Leo was not honoring the requested size of Leo windows.

As the result of this change Leo will open old .leo files much smaller than expected.  Do not panic!  Simply resize the Leo window and save it.  The next time you open the window all will be well.</t>
<t tx="edream.110203163054.167">I have found this command to be highly annoying and unwanted.</t>
<t tx="edream.110203163054.168">This is very important for the spell-checking plugin, and is quite useful in all other situations.</t>
<t tx="edream.110203163054.169"></t>
<t tx="edream.110203163054.170"></t>
<t tx="edream.110203163054.171">- Added the following stub hooks:

"after-create-leo-frame"
"close-frame"
"create-optional-menus"
"destroy-all-global-windows"
"init-color-markup"
"new"
"redraw-entire-outline"
"scan-directives"

See the section called "About hooks" for full details.

- Changed handleLeoHook to doHook.  This simplifies the code a bit.
</t>
<t tx="edream.110203163054.172">@nowrap

At startup time Leo looks all files of the form mod_*.py in the plugins
directory. Leo assumes that these files are "plugins" containing Python modules
that customizes Leo's operation. Leo attempts to import each file.

Each module should register routines that are called at various times during
execution. Such times are identified by strings known as "tags". The code in in
one or more plugins corresponding to each tag are known as the "hook" routines
for that tag. Leo catches exceptions (including syntax errors) in hook
routines, so it is safe to hack away on this code.

Leo passes two argument to all hook routines: the tag and a keywords dictionary
containing additional information. For example, keywords["label"] indicates the
kind of command for "command1" and "command2" hooks.

For some hooks, returning anything other than None "overrides" Leo's default
action. Hooks have full access to all of Leo's source code. Just import the
relevant file. For example, top() returns the commander for the topmost Leo
window.

The following table summarizes the arguments passed to hooks: ( Overrides is
"yes" if returning anything other than None overrides Leo's normal command or
event processing.)

tag argument                                              keys in keywords
(hook name)  overrides       when called                  dictionary argument
---------    ---------       -----------                  -------------------
"bodyclick1"   yes      before normal click in body       c,v,event
"bodyclick2"            after  normal click in body       c,v,event
"bodydclick1"  yes      before double click in body       c,v,event
"bodydclick2"           after  double click in body       c,v,event
"bodykey1"     yes      before body keystrokes            c,v,ch,oldSel,undoType
"bodykey2"              after  body keystrokes            c,v,ch,oldSel,undoType
"bodyrclick1"  yes      before right click in body        c,v,event
"bodyrclick2"           after  right click in body        c,v,event
"boxclick1"    yes      before click in +- box            c,v,event
"boxclick2"             after  click in +- box            c,v,event
"command1"     yes      before each command               c,v,label (note 2)
"command2"              after  each command               c,v,label (note 2)
"drag1"        yes      before start of drag              c,v,event
"drag2"                 after  start of drag              c,v,event
"dragging1"    yes      before continuing to drag         c,v,event
"dragging2"             after  continuing to drag         c,v,event
"end1"                  start of app.quit()
"enddrag1"     yes      before end of drag                c,v,event
"enddrag2"              after  end of drag                c,v,event
"headclick1"   yes      before normal click in headline   c,v,event
"headclick2"            after  normal click in headline   c,v,event
"headrclick1"  yes      before right click in headline    c,v,event
"headrclick2"           after  right click in headline    c,v,event
"headkey1"     yes      before headline keystrokes        c,v,ch
"headkey2"              after  headline keystrokes        c,v,ch
"hypercclick1" yes      before control click in hyperlink c,v,event
"hypercclick2"          after  control click in hyperlink c,v,event
"hyperenter1"  yes      before entering hyperlink         c,v,event
"hyperenter2"           after  entering hyperlink         c,v,event
"hyperleave1"  yes      before leaving  hyperlink         c,v,event
"hyperleave2"           after  leaving  hyperlink         c,v,event
"iconclick1"   yes      before single click in icon box   c,v,event
"iconclick2"            after  single click in icon box   c,v,event
"iconrclick1"  yes      before right click in icon box    c,v,event
"iconrclick2"           after  right click in icon box    c,v,event
"icondclick1"  yes      before double click in icon box   c,v,event
"icondclick2"           after  double click in icon box   c,v,event
"idle"                  periodically (at idle time)       c,v
"menu1"        yes      before creating menus             c,v        (note 3)
"menu2"        yes      before updating menus             c,v
"open1"        yes      before opening any file           old_c,new_c,fileName (note 4)
"open2"                 after  opening any file           old_c,new_c,fileName (note 4)
"openwith1"    yes      before Open With command          c,v,openType,arg,ext
"openwith2"             after  Open With command          c,v,openType,arg,ext
"recentfiles1" yes      before Recent Files command       c,v,fileName,closeFlag
"recentfiles2"          after  Recent Files command       c,v,fileName,closeFlag
"save1"        yes      before any Save command           c,v,fileName
"save2"                 after  any Save command           c,v,fileName
"select1"      yes      before selecting a vnode          c,new_v,new_v
"select2"               after  selecting a vnode          c,new_v,old_v
"select3"               after  selecting a vnode          c,new_v,old_v
"set-mark"     no       when a mark is set                c,v           (new)
"start1"       no       after app.finishCreate()
"start2"                after opening first Leo window    c,v,fileName
"unselect1"    yes      before unselecting a vnode        c,new_v,old_v
"unselect2"             after  unselecting a vnode        c,old_v,old_v
"@url1"        yes      before double-click @url node     c,v           (note 5)
"@url2"                 after  double-click @url node     c,v           (note 5)

Notes:

(1) "activate" and "deactivate" hooks: These have been removed because they do
not work as expected.

(2) "commands" hooks: The label entry in the keywords dict contains the
"canonicalized" form of the command, that is, the lowercase name of the command
with all non-alphabetic characters removed.

Commands hooks now set the label for undo and redo commands "undo" and "redo"
rather than "cantundo" and "cantredo".

(3) "menu1" hook: Setting app().realMenuNameDict in this hook is an easy way of
translating menu names to other languages. Note: the "new" names created this
way affect only the actual spelling of the menu items, they do _not_ affect how
you specify shortcuts in leoConfig.txt, nor do they affect the "official"
command names passed in app().commandName. For example, suppose you set
app().realMenuNameDict["Open..."] = "Ouvre".

(4) "open1" and "open2" hooks: These are called with a keywords dict containing
the following entries:

old_c: The commander of the previously open window.
new_c: The commander of the newly opened window.
fileName: The name of the file being opened.

You can use old_c.currentVnode() and new_c.currentVnode() to get the current
vnode in the old and new windows.

Leo calls the "open1" and "open2" hooks only if the file is already open. Leo
will also call the "open1" and "open2" hooks if: a) a file is opened using the
Recent Files menu and b) the file is not already open.

(5) "@url1" and "@url2" hooks are only executed if "icondclick1" hook returns None.


New in version 3.12:

The following hooks are a new breed of hook, called "stub hooks". Conceptually,
these hooks are like calls to stub routines that can be filled in by code in
plugins.

tag argument                                                       keys in keywords
(hook name)               overrides        when called           dictionary argument
---------                 ---------        -----------           -------------------
"after-create-leo-frame"     no   before calling f.finishCreate  c
"after-redraw-outline"       no        end of tree.redraw        c (note 6)
"before-create-leo-frame"    no    after calling f.finishCreate  c
"clear-mark"                 no        when mark is set          c,v
"close-frame"                no        in app.closeLeoWindow     c
"color-optional-markup"      yes *     (note 7)                  colorer,v (note 7)
"create-optional-menus"      no        (note 8)                  (note 8)
"create-popup-menu-items"    no        in tree.OnPopup           c,v,event (new)
"destroy-all-global-windows" no        (note 12)                 None
"draw-outline-box"           yes       start of drawBox          tree,p,v,x,y (note 6)
"draw-outline-icon"          yes       start of tree.drawIcon    tree,p,v,x,y (note 6)
"draw-outline-node"          yes       start of tree.drawNode    tree,p,v,x,y (note 6)
"draw-outline-text-box"      yes       start of tree.drawText    tree,p,v,x,y (note 6)
"draw-sub-outline"           yes       start of tree.drawTree    tree,p,v,x,y,h,level (note 6)
"enable-popup-menu-items"    no        in tree.OnPopup           c,v,event (new)
"init-color-markup"          no        (note 7)                  colorer,v,s,i,j,colortag (note 7)
"new"                        no        start of New command      old_c,new_c (note 9)
"redraw-entire-outline"      yes       start of tree.redraw      c (note 6)
"scan-directives"            no        in scanDirectives         c,v,s,old_dict,dict,pluginsList (note 10)
"set-mark"                   no        when mark is set          c,v
"show-popup-menu"            no        in tree.OnPopup           c,v,event

Notes:

(6) These hooks are useful for testing.

(7) These stub hooks allow plugins to parse and handle markup withing doc
parts, comments and Python """ strings. Note that these hooks are _not_ called
in Python ''' strings. See the color_markup plugin for a complete example of
how to use these hooks.

(8) The "create-optional-menus" stub hook is called when Leo is creating menus,
at the place at which creating new menus is appropriate. Therefore, this hook
need only create new menus in the correct order, without worrying about the
placement of the menus in the menu bar. See the plugins_menu and scripts_menu
plugins for examples of how to use this hook. Leo now executes hooks in
alphabetical order, so that the Plugins menu will be created before the Scripts
menu.

(9) The "new" stub hook is called at the beginning of the code that implements
the New command. This provides a much easier way of recognizing when Leo is
about to create a new Leo window.

(10) The "scan-directives" stub hooks is called inside the scanDirectives
global function. The dictionary returned by scanDirectives now contains an item
whose key is "pluginsList". The value of this item is a list of tuples
(d,v,s,k) where:

- d is the spelling of the @directive, without the leading @.
- v is the vnode containing the directive, _not_ the original vnode.
- s[k:] is a string containing whatever follows the @directive. k has already
been moved past any whitespace that follows the @directive.

See the add_directives plugins directive for a complete example of how to use
the "scan-directives" stub hook.

(11) The "close-frame" stub hook is called in app.closeLeoWindow just before
removing the window from app.windowList. The hook code may remove the window
from app.windowList to prevent app.closeLeoWindow from destroying the window.

(12) Leo calls the "destroy-all-global-windows" hook in app.destroyAllGlobalWindows().
This hook gives plugins the chance to clean up after themselves when Leo shuts down.</t>
<t tx="edream.110203163054.173">Leo now supports two new stub hooks: "clear-mark" and "set-mark".  Both fully update the marks window, so it is important that they not be called "too often", and they aren't.

As a side effect, it is no longer necessary to update the marks window after every command that affects marks, a nice simplification and generalization of the code.

While I was at it, I moved the two dialog classes used only by the nav_buttons plugin out of leoDialog.py and into nav_buttons.py where they belong.</t>
<t tx="edream.110203163054.174">Added the "create-popup-menu", "enable-popup-menu-items" and "show-popup-menu" hooks.</t>
<t tx="edream.110203163054.175">Added the "create-popup-menu", "enable-popup-menu-items" and "show-popup-menu" hooks.</t>
<t tx="edream.110203163054.176"></t>
<t tx="edream.110203163054.177">This plugin allows users to create new directives.

As an example, this plugin creates a new @markup wiki directive.</t>
<t tx="edream.110203163054.178">This plugin supports coloring for markup in doc parts and Python triple-double-quoted strings.

At present, this plugin supports wiki-style markup, and it would be easy to change the style of markup.</t>
<t tx="edream.110203163054.179">This plugin adds 4 new buttons to the icon area at the top of each Leo window:

- Back and Forward arrows that work like a typical web browser.  Clicking the back arrow button takes you to the last node in the tree you visited.  Clicking the forward arrow button moves you forward.  The forward arrow button is dimmed unless you have clicked the back arrow button recently.

- The Recent button opens a non-modal dialog showing all the nodes you have visited recently.  This dialog is updated cleanly by the tree.select method.  You will see this entries change dynamically.  There are buttons in this dialog for clearing individual entries or clearing all entries.  Double-clicking any entry in this dialog takes you to that node, as does clicking the Go button.

The entries in the Recent Nodes pane do _not_ correspond to the order implied by the Forward and Back arrows.  Rather, the most recently visited node is on top, followed by the next most recently visited node, and so on, with the additional feature that nodes appear only once in the list.

- The Marks button opens a non-modal dialog showing all marked nodes in the tree.  Marking or unmarking nodes in the tree adds or deletes entries from this dialog.  Double-clicking any entry in this dialog takes you to that node, as does clicking the Go button.</t>
<t tx="edream.110203163054.180">This creates a plugins menu describing each loaded plugin.</t>
<t tx="edream.110203163054.181">The scripts_menu.py plugin creates a Scripts menu for all scripts in scripts folder.</t>
<t tx="edream.110203163054.182">- Leo now scans all .py files in the plugins folder when looking for plugins.

Filenames need not start with mod_, and Leo scans only the plugins folder.

- Leo loads plugins in alphabetical order.

- Leo now prints only a brief summary of the number of files loaded &amp; examined to the log file.</t>
<t tx="edream.110203163054.183">1. Created config, doc, examples, plugins, scripts, src, test &amp; tools folders.

2. Removed the following files:

- nsi.leo file.  This was a duplicate of code in LeoPy.leo.  
- bdist.bat, go.bat, help.bat, sdist.bat.
- leo.rc and leo.res.  These were resource files used by the Delphi classes.</t>
<t tx="edream.110203163054.184">These were written by Frank Merenda.</t>
<t tx="edream.110203163054.185">leo.py 3.11.1                       May 1, 2003

This version fixes two bugs:
	
- Version 3.11 had startup problems on some Linux systems.

- Creating clones by control dragging did not always work.
  This bug has existed in Leo for a long time.</t>
<t tx="edream.110203163054.186">leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py will work on Linux, Windows and MacOs X Jaguar.

leo.py 3.11.1                       May 1, 2003

This version fixes the following bugs:

- Leo would crash on startup on some Linux systems due to a problem
  with Leo's local copy of getpreferredencoding.

- Leo sometimes did not set clone bits properly after creating a clone
  by control-dragging a node.  This bug has existed for about 6 months!

leo.py 3.11                         April 27, 2003

This version of Leo contains many important improvements since 3.10,
especially support for unicode and a new plugin architecture.

The Highlights of 3.11:

** Leo supports unicode.
	- New @encoding directives specifies encoding for derived files.
	- New settings specify default encodings for .leo and derived files.
	- Derived files specify encodings used to create them.
** A new plugin architecture for customizing Leo. (A major improvement.)
- New commands:
	- Toggle Angle Brackets.
	- Insert Time/Date (in headline or body text).
	- Go To First/Last Node, Parent, Next/Previous Sibling.
	- Write Missing @file Nodes.
	- Expand/Contract Node.
- Improved commands:
	- Fixed a huge performance bug that slowed moving nodes left.
	- Expand/Contract commands now operate on the selected tree.
	  ( A major improvement)
	- Sort Siblings command can now sort top-level nodes.
	- Leo now allows multiple writes of cloned nodes.
	  (Useful when different @path directives are in effect.)
- Other improvements:
	- New @lineending directive specifies line endings.
	- Improved syntax coloring for html and xml.
	- Leo scrolls partially visible headlines into full view.
	- Added "Replace tabs with spaces" checkbox in Prefs panel.
- New settings in leoConfig.leo/.txt.
	- Added "tk_encoding" setting and related logic.
	- Colors for Show Invisibles command and body_insertion_cursor
	- Settings affecting when control-drags start.
	- Defaults for unicode (see above).
- Many other bug fixes and improvements.

See the children of this node for full details.</t>
<t tx="edream.110203163054.187"></t>
<t tx="edream.110203163054.188"></t>
<t tx="edream.110203163054.189">This ensures that the outline is redrawn properly after the Read @file Nodes command.</t>
<t tx="edream.110203163054.190">Browsing the comp.lang.python yesterday I found that there are serious problems with Python's getdefaultlocale() routine.  Martin v. Löwis says "getdefaultlocale() is broken, and cannot be fixed", though he does suggest the following workaround:

leoGlobals.py uses locale.getpreferredencoding to define getpreferredencoding if locale.getpreferredencoding exists (it is new in Python 2.3alpha).  Otherwise, Leo uses the code copied from the 2.3a2 version of Python to define getpreferredencoding.  Either way, leoGlobals.py now defines getpreferredencoding and Leo uses getpreferredencoding rather than getdefaultlocale.</t>
<t tx="edream.110203163054.191">After opening the Python window the call to tkFont() threw a (caught) exception on every call to frame.setTabWidth.  The fix was to add the optional root param.</t>
<t tx="edream.110203163054.192">skip_long was throwing an exception if there were no valid digits following a + or - sign.</t>
<t tx="edream.110203163054.193"></t>
<t tx="edream.110203163054.194">- tangle.scanAllDirectives was not setting self.encoding when handling @encoding.
- tangle.scanAllDirectives wasn't scanning the @encoding line properly.
- fixed crashers in Tangle and Untangle logic.</t>
<t tx="edream.110203163054.195">Fixed bug in handleLinesFollowingSentinel:
c:\prog\LeoCVS\leo\leoAtFile.py:482: No global (i) found
Removed i arg from rfind.

Fixed bug in definition of BadLeoFile:
c:\prog\LeoCVS\leo\leoFileCommands.py:27: Base class (exceptions.Exception) __init__() not called
Added call to Exception.__init__(self,message)

Fixed bug in askYesNoCancel
c:\prog\LeoCVS\leo\leoDialog.py:283: Variable (no) used before being set.
Disabled defaultButton logic.  New code would have to be thoroughly tested.

Removing unused routine: setDefaultLoc.
c:\prog\LeoCVS\leo\leoNodes.py:2581: No class attribute (defaultLoc) found

Fixed bug in put: changed a to app()
c:\prog\leoCvs\leo\leoFrame.py:4973: No global (a) found
</t>
<t tx="edream.110203163054.196">I had completely misunderstood __del__ methods!  __del__ methods disable the gc's ability to collect circular garbage (!!) and so __del__ methods will _never_ be called (!!)

BTW, when deleting an entire Leo window Leo calls various destroy methods to unlink items.  This allows the garbage collector to collect all data structures.  Because of unlimited undo only these destroy methods have the potential for creating "real" garbage.</t>
<t tx="edream.110203163054.197"></t>
<t tx="edream.110203163054.198">This adds http:\\ to url's if needed.</t>
<t tx="edream.110203163054.199">New in version 3.11.  The @lineending directive allows you to specify the line endings for individual derived files.  This directive will override the output_newline setting in leoConfig.txt.  Note that @lineending _never_ affects the line endings in .leo files themselves:  we must have consistent line endings in .leo files!  See below for more details.

The valid forms of the new @lineending directive are:

@lineending nl       (the default, Linux)
@lineending cr       (Mac)
@lineending crlf     (Windows)
@lineending lf       (same as nl, not recommended)
@lineending platform (same as platform value for output_newline setting in leoConfig.txt)</t>
<t tx="edream.110203163054.200">This will have no effect until version 4.0.</t>
<t tx="edream.110203163054.201">Leo now uses unicode internally for most strings.  This solves a lot of problems.  The children of this node discuss all the details...</t>
<t tx="edream.110203163054.202">This fixes several bugs.</t>
<t tx="edream.110203163054.203">In particular, the locale returned by locale.getdefaultlocale()[1] need not be a valid unicode encoding.
</t>
<t tx="edream.110203163054.204">Leo now uses unicode internally for most strings.  The highlights:

1. Leo converts headline and body text to unicode when reading .leo files and derived files.  Both .leo files and derived files may specify their encoding, with "utf-8" being used by default.  If the encoding used in a derived file is not "utf-8" it is represented in the @+leo sentinel line.  For example:

#@+leo-encoding=iso-8859-1.

The "utf-8" encoding is a "lossless" encoding (it can represent all unicode code points), so encoding and decoding to and from utf-8 plain strings will never cause a problem.  When reading or writing a character not in a "lossy" encoding, Leo converts such characters to '?' and issues a warning. 

2. When writing .leo files and derived files Leo uses the same encoding used to read the file, again with "utf-8" used as a default.

3. leoConfig.py contains two settings used to specify the default encoding used for .leo and derived files:

default_derived_file_encoding = UTF-8 
new_leo_file_encoding = UTF-8 

I do not recommend changing new_leo_file_encoding (see the comments in leoConfig.leo) and you may set 
default_derived_file_encoding to anything that makes sense for you.

4. You may use the @encoding directive to specify the encoding used in a derived file.  You can't mix encodings in a single derived file.

This is all should need to know to use extended character sets on Leo.</t>
<t tx="edream.110203163054.205">leoConfig.py now contains two new settings, with the defaults shown below: 

default_derived_file_encoding = UTF-8 
new_leo_file_encoding = UTF-8 

These control the default encodings used when writing derived files and .leo files.

I do not recommend changing new_leo_file_encoding (see the comments in leoConfig.leo)

You may set default_derived_file_encoding to anything that makes sense for you.
</t>
<t tx="edream.110203163054.206">The following paragraphs discuss code-level details.  You should not need to read this section in order to use Leo.

1. Leo uses unicode objects in vnodes and tnodes to denote headline and body text.  Note that unicode strings have no encoding; only plain strings have encodings. This means that once an (encoded) plain string has been converted to a unicode string it doesn't matter how the unicode string was created.  This is the key that makes Leo's new code robust. 

So internally Leo never has to worry about encodings. The only times encoding matter is when encoded strings are converted to and from unicode when Leo reads or writes files (or when the passing strings to and from Tk.Text widgets, but the idea is the same).

2. Python expressions that mix unicode strings u and plain strings s, like:

	u + s 
or 
	u == s 
or 
	u[5] == s[2:]

are promoted to unicode objects using the "system encoding". This encoding should never be changed, but we can't assume that we know what it is, so for safety we should assume the most restrictive encoding, namely "ascii".  With this assumption, Leo's code can't throw an exception during these promotions provided that: 

- All strings are converted to unicode when Leo reads files or gets text from Tk.Text widgets. 
- All string literals in Leo's code have only ascii characters.</t>
<t tx="edream.110203163054.207"></t>
<t tx="edream.110203163054.208">It is now much easier to customize Leo.  The new scheme is based on plugins (files in the plugins directory) rather than modifying customizeLeo.py.  Many thanks to Paul Paterson for suggesting this scheme and for doing the first implementation.
</t>
<t tx="edream.110203163054.209">@nocolor

New in 3.11. Leo now looks in the plugins folder for files whose name matches
mod_*.py. Leo tries to import all such files at startup ("start2") time. 

The child of this node gives an example of the code that creates the Open With
menu. The following code, appearing at the end of mod_open_with.py, registers
two different hook functions. The on_idle function is the "idle" hook. The
create_open_with_menu is the "start2","open2" and "command2" hooks.
@color

if 1: # Register the handlers... 
	registerHandler("idle", on_idle) 
	registerHandler(("start2","open2","command2"), create_open_with_menu) 
	es("...open with")
	
@nocolor
Plugins may call registerHandler with a hook name like "idle" or a list of hook
names like ("start2","open2","command2"). Also, you can use the "all" hook name
to indicate that code will be called for all hooks. This is useful for tracing
hooks. Plugins may also call registerExclusiveHandler for hooks that should not
be redefined in other plugins.

mod_open_with.py also contains the on_idle and create_open_with functions that
actually handle the hook. Such functions have two arguments: tag and keywords.
You will find many examples of this in LeoPy.leo.

About distribution:

1. LeoPy.leo now contains all the plugins in @ignore'd @file nodes. This way
Leo won't complain when you open LeoPy.leo.

2. Most plugins actually are disabled: the code that registers the hooks is
contained in #if 0: blocks. So to create a pluging you have to remove the
@ignore and you have to change #if 0: to #if 1.

3. Most mod_*.py will never be part of Leo distributions, and the single-click
installer will create an plugins folder containing just mod_open_with.py.

4. There is no longer a need for a customizeLeo.py file.

About error checking:

At present Leo will disable all hooks if any hook throws an exception. In
practice this isn't a big deal, but obviously something better could be done. I
won't do anything until after 3.11b1 goes out.

How to send me your plugins:

It should now be _much_ easier to submit a plugin for inclusion in LeoPy.leo.
Just send me a .leo file containing @file mod_your_plugin.py. Please have this
@file node be @ignored: this is more convenient for me. Ideally, your .leo file
should contain _only_ your plugin code.</t>
<t tx="edream.110203163054.210">@color
@language python
@ignore

"""Open With handler"""

from customizeLeo import *
from leoGlobals import *

@others

if 1: # Register the handlers...
	registerHandler("idle", on_idle)
	registerHandler(("start2","open2","command2"), create_open_with_menu)
	es("...open with")</t>
<t tx="edream.110203163054.211"># frame.OnOpenWith creates the dict as follows:
# dict = {"c":c, "v":v, "f":f, "path":path, "time":time}

def on_idle (tag,keywords):

	import os
	a = app()
	for dict in a.openWithFiles:
		path = dict.get("path")
		c = dict.get("c")
		v = dict.get("v")
		if path and os.path.exists(path):
			try:
				time = os.path.getmtime(path)
				if time and time != dict.get("time"):
					dict["time"] = time
					&lt;&lt; update v's body text &gt;&gt;
			except: pass</t>
<t tx="edream.110203163054.212">&lt;&lt; set s to the new text &gt;&gt;
body = v.bodyString()
&lt;&lt; set conflict flag &gt;&gt;

if conflict:
	# Report the conflict &amp; set update.
	import leoDialog
	d = leoDialog.leoDialog()
	message = "Conflict in %s.\n\n" % (v.headString())
	message += "Replace outline with external changes?"
	update = d.askYesNo("Conflict!",message) == "yes"
else:
	update = s != body

if update:
	h = v.headString()
	es("changed:" + h)
	v.setBodyStringOrPane(s)
	c.selectVnode(v)
	v.OpenWithOldBody = s
</t>
<t tx="edream.110203163054.213">try:
	# Update v from the changed temp file.
	f=open(path)
	s=f.read()
	f.close()
except:
	es("can not open " + shortFileName(path))
	break
</t>
<t tx="edream.110203163054.214">try:
	# The OpenWithOldBody attribute does not normally exist in vnodes.
	old_body = v.OpenWithOldBody
	conflict = body != old_body and body != s
except:
	conflict = v.isDirty() and body != s
</t>
<t tx="edream.110203163054.215">def create_open_with_menu (tag,keywords):

	if  (tag in ("start2","open2") or
		(tag=="command2" and keywords.get("label")=="new")):
	
		&lt;&lt; create the Open With menu &gt;&gt;

		# Enable the idle-time hook so we can check temp files created by Open With.
		from leoGlobals import enableIdleTimeHook
		enableIdleTimeHook(idleTimeDelay=500)
</t>
<t tx="edream.110203163054.216">@ Entries in the following table are the tuple (commandName,shortcut,data).
data is the tuple (command,arg,ext).
command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the extension ext,
Otherwise, Leo computes an extension based on what @language directive is in effect.
@c

idle_arg = "c:/python22/tools/idle/idle.py -e "

if 1: # Default table.
 table = (
  ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
  ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
  ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
else: # David McNab's table.
 table = (
  ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)))

top().frame.createOpenWithMenuFromTable(table)
</t>
<t tx="edream.110203163054.217">Simplified and regularized hooks:

- replaced "event1" and "event2" hooks with 'regular' hooks.
	* Much easier to understand.
- added "iconrclick" hooks.
- added "bodyrclick" hooks.
- added "save1" and "save2" hooks
- added "dragging" hooks.
	* These are called when drag hook called while already dragging.
- added "hyperenter" and "hyperleave" hooks.
	* These only fire if use_hyperlinks = 1 in leoConfig.txt.
- removed "activate" and "deactivate" hooks.
	* These were not reliable.
- almost all hooks now have c,v arguments.
- "command" hooks now return "undo" and "redo" rather than "cantundo" and "cantredo"

Improved code:

- improved the tracing of hooks.
- the tracing code also checks to make sure that most hooks have c,v keywords.
- created es_event_exception().
- put all event handlers in try/except blocks that call es_event_exception on errors.</t>
<t tx="edream.110203163054.218">At startup time Leo looks all files of the form mod_*.py in the plugins
directory. Leo assumes that these files are "plugins" containing Python modules
that customizes Leo's operation. Leo attempts to import each file.

Each module should register routines that are called at various times during
execution. Such times are identified by strings known as "tags". The code in in
one or more plugins corresponding to each tag are known as the "hook" routines
for that tag. Leo catches exceptions (including syntax errors) in hook
routines, so it is safe to hack away on this code.

Leo passes two argument to all hook routines: the tag and a keywords dictionary
containing additional information. For example, keywords["label"] indicates the
kind of command for "command1" and "command2" hooks.

For some hooks, returning anything other than None "overrides" Leo's default
action. Hooks have full access to all of Leo's source code. Just import the
relevant file. For example, top() returns the commander for the topmost Leo
window.

The following table summarizes the arguments passed to hooks: ( Overrides is
"yes" if returning anything other than None overrides Leo's normal command or
event processing.)

tag argument                                              keys in keywords
(hook name)  overrides       when called                  dictionary argument
---------    ---------       -----------                  -------------------
"bodyclick1"   yes      before normal click in body       c,v,event (new)
"bodyclick2"            after  normal click in body       c,v,event (new)
"bodydclick1"  yes      before double click in body       c,v,event (new)
"bodydclick2"           after  double click in body       c,v,event (new)
"bodykey1"     yes      before body keystrokes            c,v,ch,oldSel,undoType
"bodykey2"              after  body keystrokes            c,v,ch,oldSel,undoType
"bodyrclick1"  yes      before right click in body        c,v,event (new)
"bodyrclick2"           after  right click in body        c,v,event (new)
"boxclick1"    yes      before click in +- box            c,v,event (new)
"boxclick2"             after  click in +- box            c,v,event (new)
"command1"     yes      before each command               c,v,label (note 2)
"command2"              after  each command               c,v,label (note 2)
"drag1"        yes      before start of drag              c,v,event (new)
"drag2"                 after  start of drag              c,v,event (new)
"dragging1"    yes      before continuing to drag         c,v,event (new)
"dragging2"             after  continuing to drag         c,v,event (new)
"end1"                  start of app.quit()
"enddrag1"     yes      before end of drag                c,v,event (new)
"enddrag2"              after  end of drag                c,v,event (new)
"headclick1"   yes      before normal click in headline   c,v,event (new)
"headclick2"            after  normal click in headline   c,v,event (new)
"headrclick1"  yes      before right click in headline    c,v,event (new)
"headrclick2"           after  right click in headline    c,v,event (new)
"headkey1"     yes      before headline keystrokes        c,v,ch
"headkey2"              after  headline keystrokes        c,v,ch
"hypercclick1" yes      before control click in hyperlink c,v,event (new)
"hypercclick2"          after  control click in hyperlink c,v,event (new)
"hyperenter1"  yes      before entering hyperlink         c,v,event (new)
"hyperenter2"           after  entering hyperlink         c,v,event (new)
"hyperleave1"  yes      before leaving  hyperlink         c,v,event (new)
"hyperleave2"           after  leaving  hyperlink         c,v,event (new)
"iconclick1"   yes      before single click in icon box   c,v,event (new)
"iconclick2"            after  single click in icon box   c,v,event (new)
"iconrclick1"  yes      before right click in icon box    c,v,event (new)
"iconrclick2"           after  right click in icon box    c,v,event (new)
"icondclick1"  yes      before double click in icon box   c,v,event (new)
"icondclick2"           after  double click in icon box   c,v,event (new)
"idle"                  periodically (at idle time)       c,v
"menu1"        yes      before creating menus             c,v (note 3)
"menu2"        yes      before updating menus             c,v
"open1"        yes      before opening any file           old_c,new_c,fileName (note 4)
"open2"                 after  opening any file           old_c,new_c,fileName (note 4)
"openwith1"    yes      before Open With command          c,v,openType,arg,ext
"openwith2"             after  Open With command          c,v,openType,arg,ext
"recentfiles1" yes      before Recent Files command       c,v,fileName,closeFlag
"recentfiles2"          after  Recent Files command       c,v,fileName,closeFlag
"save1"        yes      before any Save command           c,v,fileName
"save2"                 after  any Save command           c,v,fileName
"select1"      yes      before selecting a vnode          c,new_v,new_v
"select2"               after  selecting a vnode          c,new_v,old_v
"start1"       no       after app.finishCreate()
"start2"                after opening first Leo window    c,v,fileName
"unselect1"    yes      before unselecting a vnode        c,new_v,old_v (new)
"unselect2"             after  unselecting a vnode        c,old_v,old_v (new)
"@url1"        yes      before double-click @url node     c,v (note 5)
"@url2"                 after  double-click @url node     c,v (note 5)

Notes:

(1) "activate" and "deactivate" hooks: These have been removed because they do
not work as expected.

(2) "commands" hooks: The label entry in the keywords dict contains the
"canonicalized" form of the command, that is, the lowercase name of the command
with all non-alphabetic characters removed.

Commands hooks now set the label for undo and redo commands "undo" and "redo"
rather than "cantundo" and "cantredo".

(3) "menu1" hook: Setting app().realMenuNameDict in this hook is an easy way of
translating menu names to other languages. Note: the "new" names created this
way affect only the actual spelling of the menu items, they do _not_ affect how
you specify shortcuts in leoConfig.txt, nor do they affect the "official"
command names passed in app().commandName. For example, suppose you set
app().realMenuNameDict["Open..."] = "Ouvre".

(4) "open1" and "open2" hooks: These are called with a keywords dict containing
the following entries:

old_c: The commander of the previously open window.
new_c: The commander of the newly opened window.
fileName: The name of the file being opened.

You can use old_c.currentVnode() and new_c.currentVnode() to get the current
vnode in the old and new windows.

Leo calls the "open1" and "open2" hooks only if the file is already open.
Leo will also call the "open1" and "open2" hooks if:
a) a file is opened using the Recent Files menu and
b) the file is not already open.

(5) "@url1" and "@url2" hooks are only executed if "icondclick1" hook returns
None.</t>
<t tx="edream.110203163054.219">See the Code:Customizing Leo:Plugins folder in LeoPy.leo for full details of all plugins.

- Added disabled support for @folder.

- Demoted up/down arrow stuff to a disabled plugin for now.</t>
<t tx="edream.110203163054.220">The idle-time hook now checks for dirty @file nodes that have been modified in an external editor since the last check.  An alert is raised when such conflicting changes are found.

Improved sanitize_filename utility (in leoGlobals.py) so that it converts all characters used to denote filenames to underscores.</t>
<t tx="edream.110203163054.221">This allows output from registering hooks to appear in the log pane.</t>
<t tx="edream.110203163054.222"></t>
<t tx="edream.110203163054.223">The following new plugins are now in LeoPy.leo.

- mod_script_io_to_body.py
	Redirect output from scripts to end of body pane.

- mod_vim.py
	Adds support for VIM editor.

- mod_french_fm.py
	Full translation of all Leo's menus into French.</t>
<t tx="edream.110203163054.224">Added support for the following options:

show_invisibles_space_background_color
show_invisibles_tab_background_color
</t>
<t tx="edream.110203163054.225">This option controls when the control key is considered to start a control-drag.

If look_for_control_drag_on_mouse_down = 1 the the control key must be down when dragging starts.  Otherwise, the control key must be down when dragging ends.</t>
<t tx="edream.110203163054.226">This allows Leo to be used with a black background.</t>
<t tx="edream.110203163054.227">Two new settings in leoConfig.leo/.txt specify the format of the time/date
strings inserted by the Insert Body Time/Date and Insert Headline Time/Date
commands:

body_time_format_string
headline_time_format_string

These settings are really the format string passed to time.strftime(format).

See http://www.python.org/doc/current/lib/module-time.html for a complete list
of the format options. The "%m/%d/%Y %H:%M:%S" format is used by default,
resulting in a time/date format such as: 1/30/2003 8:31:55

</t>
<t tx="edream.110203163054.228"></t>
<t tx="edream.110203163054.229">- if the headline is bracketed (named) then the &lt;&lt; &gt;&gt; are removed.
- if the headline is not bracketed (unnamed) then the &lt;&lt; &gt;&gt; are inserted. 
</t>
<t tx="edream.110203163054.230">The Insert Body Time/Date and Insert Headline Time/Date commands are in the
Edit Body and Edit Headline menus respectively. They insert the formatted time
&amp; date into the body or headline text. You must be editing a headline to be
able to insert the time/date into the headline. If you aren't Leo will say:
"Edit headline to append date/time"

Two new settings in leoConfig.leo/.txt specify the time/date format:

body_time_format_string
headline_time_format_string

These settings are really the format string passed to time.strftime(format).

See http://www.python.org/doc/current/lib/module-time.html for a complete list
of the format options. The "%m/%d/%Y %H:%M:%S" format is used by default,
resulting in a time/date format such as: 1/30/2003 8:31:55</t>
<t tx="edream.110203163054.231">These commands select the first or last node of an outline and make that node visible.</t>
<t tx="edream.110203163054.232">This command selects the parent of the previously selected node and makes that node visible.</t>
<t tx="edream.110203163054.233">These commands select the previous or following sibling of a node and make the newly selected node visible.</t>
<t tx="edream.110203163054.234">This command writes any files (in the presently selected outline) that do not exist.</t>
<t tx="edream.110203163054.235"></t>
<t tx="edream.110203163054.236">This allows time to be expressed as local time or gmttime.</t>
<t tx="edream.110203163054.237"></t>
<t tx="edream.110203163054.238">The Expand To Level n commands now expand only the nodes in the presently selected outline.  This makes these commands much more useful.

With these changes there is no longer any need for the Expand Subheads command.</t>
<t tx="edream.110203163054.239">This can be useful when clones are in the range of different @path directives.</t>
<t tx="edream.110203163054.240"></t>
<t tx="edream.110203163054.241">1. Leo now longer warns when writing customizeLeo.py.

2. Inserted a lock that prevents customizeLeo.py from being written unless use_customize_leo_dot_py = 1 in leoConfig.txt.  Leo writes a message to the log if customizeLeo.py is dirty but was not written because of the setting in leoConfig.txt.
</t>
<t tx="edream.110203163054.242"></t>
<t tx="edream.110203163054.243"></t>
<t tx="edream.110203163054.244"></t>
<t tx="edream.110203163054.245">This makes the file name easier to see in the Windows task bar.
</t>
<t tx="edream.110203163054.246"></t>
<t tx="edream.110203163054.247">This allows Leo to syntax color comments with @language plain.
The @comment directive must follow the @langauge directive.</t>
<t tx="edream.110203163054.248">In other words, the Pressing the Enter key in the Find panel executes the Find Next command.
</t>
<t tx="edream.110203163054.249">The syntax colorer now colors all element tags.  See the example in the child of this node.</t>
<t tx="edream.110203163054.250">@language html
@color
@ignore
&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</t>
<t tx="edream.110203163054.251">- Added "Replace tabs with spaces" checkbox.

- The close button is equivalent to the "Cancel" button rather than the "Ok" button.</t>
<t tx="edream.110203163054.252">This was causing great confusion.</t>
<t tx="edream.110203163054.253"></t>
<t tx="edream.110203163054.254"></t>
<t tx="edream.110203163054.255">- There was a bug that prevented the command from working properly if the line number preceded the present line.

- The goto line number option only works on full path names in @file nodes. 
It does not work for relative paths or in combination with an @path directive.</t>
<t tx="edream.110203163054.256">This problem only arose with languages such as html that have no single-line comment delimiter.
</t>
<t tx="edream.110203163054.257"></t>
<t tx="edream.110203163054.258">Leo did not properly handle configuration settings containing the % character.
</t>
<t tx="edream.110203163054.259"></t>
<t tx="edream.110203163054.260">Double-clicking the icon box used to set the cursor to the hand.
</t>
<t tx="edream.110203163054.261">Every call to v.unjoinNode was calling c.clearAllVistied.

Fixing this bug will allow me not to use inodes &amp; locations for the foreseeable future.</t>
<t tx="edream.110203163054.262"></t>
<t tx="edream.110203163054.263"></t>
<t tx="edream.110203163054.264">In the unusual case that a language has no single-line comment delimiter, Leo will remove the block delimiters from the headline text in node sentinels.  createNthChild must take this into account by doing a second comparison of headlines if the normal comparison fails.  If the second comparison of headlines succeeds we assume that we should use the headline from the outline instead of the derived file.  I believe some kind of kludge like this will also be required for 4.0.</t>
<t tx="edream.110203163054.265">- Translating the "Tangle..." label differently from the "Tangle" one was 
impossible without modifying leo's source code (same thing for "Untangle..." 
and "Untangle").

- Couldn't translate either "Show Invisibles" and "Hide Invisibles". First 
toggle is OK then an error occurs after the second...</t>
<t tx="edream.110203163054.266">- changed copyPart so it returns on @code as well as @c.

- changed convertVnodeToWeb so that it takes account of the "at_root_bodies_start_in_doc_mode" setting.

- For the most part, directives other than @c, @code, @space, @doc, @others get written to the file as @@directive.  There are minor differences between how this is handled in @root and @file trees. This might be considered a bug, and I am not going to do anything unless someone complains loudly.
</t>
<t tx="edream.110203163054.267">Enabling or disabling @language or @comment now recolors entire text.</t>
<t tx="edream.110203163054.268"></t>
<t tx="edream.110203163054.269">I had forgotten to compile leo.nsi.</t>
<t tx="edream.110203163054.270"></t>
<t tx="edream.110203163054.271"></t>
<t tx="edream.110203163054.272">Python 2.3a1 contains a bug in the tkinter code.  This bug has been fixed on Python's cvs site.  Until this bug is fixed in an official Python release Leo must use:

true,false = 1,0

rather than:

true,false = True,False</t>
<t tx="edream.110203163054.273">leo.py 3.10                             December 14, 2002

This version of Leo corrects bugs, improves Leo's documentation and adds many new features:

- Rewrote the Scripting Chapter in Leo's Users Guide.
- Improved the Customization Chapter of the Users Guide.
- Adds several customizations contributed by Leo's users.
  Among these: @read-only nodes. Reading empty .leo files.
  Redirecting stderr and stdout to Leo's log pane.
- New Mark Clones and Go To Next Clone commands.
- New Export Headlines command.
- Control-dragging a node now clones it.
- New "Node Only checkbox in the Find/Change panel.
- @root-code trees start in code mode by default.
  This allows @root trees to work like @file trees.
- @root-doc  trees start in doc  mode by default.
- Converted leoConfig.py to use @root-code
- New at_root_bodies_start_in_doc_mode option in leoConfig.py.
  Specifies whether @root trees work like @root-code or @root-doc.
- New synonyms: @file-asis = @silentfile
  @file-nosent = @nosentinelsfile ; @file-noref = @rawfile.
- Leo now supports navigation of menus using underlined menus.
- Added an easy way to replace any Leo method by a function.
  The code in customizeLeo.py can now override any part of Leo's code!
- Added routines to redirect stderr and stdout to Leo's log pane.
  These routines can be called from customizeLeo.py.
- Added "event1" and "event2" hooks for customize event handling.
- Improved Leo's window icon, and improved how that icon is loaded.
- The usual assortment of bug fixes and minor improvements.
  Actually, this release fixes more than the usual number of bugs.

See the children of this node for full details.

The quote of the month:

I must say I am very impressed. I have been absolutely seduced by Leo over the
past few days. I tell you, I can not put it down. I feel like a kid with a
shiny new bike...I'm already bursting with new ways I'd like to use the tool in
the future -- Lyn Adams Headley</t>
<t tx="edream.110203163054.274"></t>
<t tx="edream.110203163054.275">The old code did not allow &lt;tag /&gt; in many cases.  The new code reads minimal.leo without complaint.  It is:

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="2" /&gt;
&lt;globals /&gt;
&lt;preferences /&gt;
&lt;find_panel_settings /&gt;
&lt;vnodes /&gt;
&lt;tnodes /&gt;
&lt;/leo_file&gt;
</t>
<t tx="edream.110203163054.276">Apparently the F4 shortcuts interferes with the Alt-F4 shortcut.</t>
<t tx="edream.110203163054.277">The content formerly on evisa.com, including the Leo tutorials is now on 3dtree.com.</t>
<t tx="edream.110203163054.278">Leo improperly added extra blank lines and tabs in @file-nosent trees.</t>
<t tx="edream.110203163054.279">Untangle was warning about a missing section if the section had only an @doc part.</t>
<t tx="edream.110203163054.280">Leo was not handling the class keyword properly.</t>
<t tx="edream.110203163054.281">When leo.py was launched from the command line specifying a non-existent file the message "file not found" was displayed but the outline pane was not drawn properly.</t>
<t tx="edream.110203163054.282">@nosentinelsfile nodes were not being marked dirty properly.

Also, the message in atFile.writeAll about "no @file node found"  did not include these nodes.  The message was generalized.</t>
<t tx="edream.110203163054.283">While scanning for the initial state we must make sure that i &lt; old_len and i &lt; new_len.

Leo was not handling Python ''' strings properly.</t>
<t tx="edream.110203163054.284">It is not correct to do:

	exec s in __builtins__

because that pollutes the namespaces of the __builtin__ module.  Correct is simply:

  exec s in {}</t>
<t tx="edream.110203163054.285">Previous versions of Leo did not properly recycle bindings in the outline pane.

This was reported by David LeBlanc and fixed with major hints from Chad Netzer.
</t>
<t tx="edream.110203163054.286"></t>
<t tx="edream.110203163054.287"></t>
<t tx="edream.110203163054.288">The lambda functions for callbacks were not working properly.</t>
<t tx="edream.110203163054.289">The fix was made to atFile.scanAllDirectives() and leoGlobals.scanDirectives()
tangle.scanAllDirectives() was not affected.

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):</t>
<t tx="edream.110203163054.290">This bug was created recently by the new underline/realMenuName logic.  We must not set the undo/redoRealMenuName ivars in clearUndoState: that should only be done when actually setting the menu names.</t>
<t tx="edream.110203163054.291"></t>
<t tx="edream.110203163054.292">Both command are enabled only if the presently selected node is a clone.  Mark Clones marks all nodes that are clones of the present node.  Go To Next Clone goes to the next node that is a clone of the present node. A little experimentation convinced me that this command should wrap.  So this command endlessly cycles among the nodes.  Trying to end the this endless cycling would not be easy, as my experience with the Find command shows.

These are straightforward (and surprisingly useful) commands.  Please report any problems immediately.</t>
<t tx="edream.110203163054.293">This works just like the Flatten Outline command except it writes only headlines.</t>
<t tx="edream.110203163054.294">How did I ever live without this.

Also improved messages and fixed a major performance bug: tree.numberOfVisibleNodes was being called repeatedly!</t>
<t tx="edream.110203163054.295">The Node Only checkbox takes precedence over Suboutline Only if they are both checked.</t>
<t tx="edream.110203163054.296">New in Leo 3.10:  Leo allows you to choose whether body text in @root trees will start in code mode or doc mode by default.

@root-doc filename and @root-code filename specify that body text is assumed to start in doc mode or code mode respectively.  The options (-doc and -code) must follow @root immediately with no intervening whitespace.  In effect, @root-code and @root-doc are two new directives.

These @root options override the new at_root_bodies_start_in_doc_mode option in leoConfig.py.  This option affects only @root trees without options.  Such "plain" @root trees are now deprecated, which only means that it is now better style to use either @root-code or @root-doc.  The reason is simple: the meaning of plain @root trees will depend on the at_root_bodies_start_in_doc_mode option, and that isn't good.

By default, at_root_bodies_start_in_doc_mode = 1 for compatibility for old @root trees.  I actually don't think this option is good for much; I created it before I created @root-doc and @root-code, and I decided it wouldn't hurt to leave it in.  Anyway, you now have complete flexibility about how @root works, and in particular you can make @root work just like @file.</t>
<t tx="edream.110203163054.297"></t>
<t tx="edream.110203163054.298">@file-asis is a synonym for @silentfile.
@file-nosent is a synonym for @nosentinelsfile.
@file-noref is a synonym for @norefsfile.</t>
<t tx="edream.110203163054.299">Completed a major revision of the menu handling code to handle underlined menus.  As is typical on Windows, you specify the underlined character by preceding it with an ampersand character.</t>
<t tx="edream.110203163054.300">Created a new icon and improved the code that loads it.</t>
<t tx="edream.110203163054.301">This is the funcToMethod function in customizeLeo.py.</t>
<t tx="edream.110203163054.302">See the relevant section of customizeLeo.py</t>
<t tx="edream.110203163054.303">"event1" and "event2" are generated for many Leo events. keywords.get("kind") returns one of the following for "event1" and "event2" hooks:

"activate",             activate window event   (not uniform across window managers).
"deactivate"            deactivate window event (not uniform across window managers).
"boxClick"              The +- box has been clicked.
"drag"                  Generated repeated while dragging nodes.
"endDrag"               mouseUp that ends a drag.
"headClick"             Left-click in a headline.
"headPopup"             Right-click in a headline.
"headKey"               A keypress in a headline.
"hyperLinkControlClick" Control-click on a hyperlink.
"hyperLinkEnter"        Mouse moves over a hyperlink.       Disabled at present.
"hyperLinkLeave"        Mouse moves away from a hyperlink.  Disabled at present.
"iconDoubleClick"       The icon box has been double-clicked.</t>
<t tx="edream.110203163054.304"></t>
<t tx="edream.110203163054.305"></t>
<t tx="edream.110203163054.306">The present code properly handles undo/redo for operations that copy trees, but copying trees itself causes problems for further undoes.  I've disabled further undos, as was done previously, but this is a pity.

To fix this, we may have to hack on the beads to indicated that a copy has been made.  No doubt about it: copying trees is tricky.</t>
<t tx="edream.110203163054.307">leo.py 3.9                               Nov 23, 2002

This is one of the most interesting versions of Leo ever released:

* Major performance improvements:
  - Incremental syntax coloring speeds response when typing.
  - Incremental undo drastically reduces memory used.

* Major improvements in customizing Leo:
  - Leo looks in the file customizeLeo.py for user-specific customizations.
  - Leo calls "hook routines" in customizeLeo.py for all commands and events.
    These hook routines can modify or replace any command or event.
  - New convenience routines simplify creating and modifying menus.
  - Easy translation of menus to other languages using customizeLeo.py.

* Better integration with other tools:
  - The Open With command allows you to communicate back and forth to other editors.
  - The Go To Line Number command converts lines numbers in derived files
    to locations in the outline.
  - Double-clicking the icon of a @url node launches any url in your web browser.
  - The Execute Script command executes Python code in any body pane.
    This is much more convenient than opening Leo's Idle window.
  - Much better support for cweb. At last, Leo has a power user of cweb.
    By default, @space, @* and @** sections are colored as latex text.
    Leo properly generates @q..@&gt; sentinels.
  - @nosentinelfile is like @file except Leo writes no sentinel lines.

* Other improvements:
  - Optional Emacs-style auto-indent.
  - Reformat Paragraph command.
  - Leo will optionally create nonexistent directories specified in
    @file, @root or @path, including all nonexistent parent directories.
  - Leo will place its own icon in Leo windows provided that you have
    installed Fredrik Lundh's PIL and tkIcon packages.
  - The usual assortment of bug fixes.

See the children of this node for full details.

P.S. Here is what Travers A. Hough recently said about Leo:

"When first I opened Leo, it was out of curiosity.  But having used it...I'LL NEVER GO BACK. THEY'LL HAVE TO PRY LEO OUT OF MY COLD, DEAD FINGERS! Seriously, it should be renamed "Crack Cocaine" because it's that addictive. I'm ready to start a 12-Step group."
</t>
<t tx="edream.110203163054.308"></t>
<t tx="edream.110203163054.309">The cweb prefs panel setting was overriding @language python (!)</t>
<t tx="edream.110203163054.310">@language pascal
@color

private
uses</t>
<t tx="edream.110203163054.311">app().log is now set correctly when there are multiple windows.  Previously, app().log depended on activate events, and was not reliable.  The following routines now set app().log:

- frame.doCommand
- frame.OnMenuClick

Thus, top() will be reliable after any command is executed.  Creating a new window and opening a .leo file also set app().log correctly, so it appears that all holes have now been plugged.

Note: The value of top() may change during a new or open command, which may change the routine used to execute the "command1" and "command2" hooks.  This is not a bug, and hook routines must be aware of this fact.
</t>
<t tx="edream.110203163054.312">Leo no longer massages comments when importing Java files.

There was a bug in massageBody that prevented text from being undented properly.  There was a bug in find_line_start (!!) that caused the start of the previous line to be found if s[i] was a newline.  It's amazing that these bugs were undiscovered for so long.

Treat interface like class.</t>
<t tx="edream.110203163054.313"></t>
<t tx="edream.110203163054.314">Version 3.9 contains many new features and commands.  The children of this node document them.</t>
<t tx="edream.110203163054.315"></t>
<t tx="edream.110203163054.316">Undo now uses incremental syntax coloring.  This speed up undo tremendously.</t>
<t tx="edream.110203163054.317">Previous versions of Leo stored the complete body text whenever any change was made to the body text.  The present version of undo stores only enough information to undo or redo the typing: typically two lines of text.  This results in about a 90% reduction in the memory used by undo.
</t>
<t tx="edream.110203163054.318">These are discussed in the child of this node.</t>
<t tx="edream.110203163054.319">@nocolor

You may customize Leo in several ways:

I.  Using leoSettings.leo

The following information discusses how Leo 4.3 and all later versions handle user configuration settings. For all previous versions, see the node called 'Obsolete: Using leoConfig.leo and leoConfig.txt'

Leo stores options in @settings trees, that is, parts of Leo outlines whose root node has the headline @settings.  When opening a .leo file, Leo looks for @settings trees in the following places:

- The file called leoSettings.leo in the leo/config directory.
- The file called leoSettings.leo in the users home directory.
- The file being loaded.

Settings that later in the above list override settings found earlier. For example, any setting specified in an @settings tree in the file being loaded overrides any setting seen in any leoSettings.leo file.

II. Using plugins and hooks

During startup, Leo looks for plugins, i.e., .py files in the plugins directory.  These plugins register functions called "hooks" to be called a various times during execution.  Full details are provided below.

Plugins provide the following advantages:

- Any time you see a nice hook handler that someone has written you can just copy it to a plugin file and it runs next time you start Leo.
- You don't have to keep updating a large and growing customizeLeo.py file.
- You can disable and enable hooks by renaming the relevant plugin file.
  (or by enabling or disabling the code in the plugin that registers hook functions).
- You don't have to merge code from hooks pertaining to the same Leo event.

When executing any command or handling any event, Leo calls hook routines registered from the plugin files.  The arguments to hooks are:

- "tag", a string telling the kind of command or event about to be executed, and
- "keywords", a Python dictionary whose keys depend on the specific command or event.

This is a very simple, powerful and general mechanism for customizing Leo as you see fit.  There are dozens of kinds of hooks, including the "command1" and "command2" hooks that are called before and after each of Leo's menu commands.  Leo will allow you to override most commands and event handling.  In many cases, if a hook returns any value except None Leo will assume that the hook has completely handled the command or event and will take no further action.  The details will be explained in full below.

Leo catches all exceptions raised in hook code, so you can modify hooks without worry.

SECURITY WARNINGS: Using hooks naively can create the potential for virus-like behavior.  Please read the section called SECURITY WARNINGS for full details.

III. Using convenience routines called from hooks.

Hook routines can import any file in Leo's source code and execute routines in that file.  Leo's contains a number of convenience routines designed to make common customization tasks easier.  Hooks can use these routines to create your own menus, to translate menus into other languages, and to create entries in the Open With menu.  These convenience routines are discussed in detail below.

IV. Setting app().realMenuNameDict inside hooks to translate menus into other languages.

This is discussed below.</t>
<t tx="edream.110203163054.320">@nocolor

Leo will override settings in .leo files if it finds a file called leoConfig.txt in the config subdirectory.  Leo works just as before if it does not find a leoConfig.txt file.

You should make changes to leoConfig.txt by changing leoConfig.leo and then executing the Tangle All command.  There are two advantages to changing leoConfig.txt in this manner.  First, it is just easier to change leoConfig.leo.  Second, all comments are lost in leoConfig.txt when Leo updates it, so using leoConfig.leo as the primary data file means you will always have the comments available.

Leo looks for leoConfig.txt first in the directory specified by the Python variable sys.leo_config_directory.  You would typically set this variable in Python's sitecustomize.py file.  If this variable does not exist, Leo looks in the directory from which Leo was loaded.

The child of this node contains an example of leoConfig.txt that shows all the options that may be set.

Settings in leoConfig.txt overrides preferences in .leo files, but only for those items actually in leoConfig.txt, so you can choose which settings you want to override.  Also, a Leo ignores any setting in leoConfig.txt whose value is "ignore" (without the quotes). For example:

[prefs panel options]
tab_width = ignore

If a setting is overridden, it is _not_ written to the .leo file when the outline is saved.  Note that this does not change the file format: all previous versions of Leo will be able to read such .leo files.

The preceding is probably all you need to know to use leoConfig.txt.  The following discuss some minor details: 

1. When reading a .leo file, if a setting is found neither in leoConfig.txt nor in the .leo file, Leo uses a default, hard-coded value.  In leo.py 3.0 and later these default settings are found in tables that appear in the section called:

	&lt;&lt; define default tables for settings &gt;&gt;

in the file leoConfig.py. So it is now convenient to change settings in leo.py itself as well as in leoConfig.txt.

2. Leo will update leoConfig.txt unless the read_only option is on in leoConfig.txt.  

WARNING: there are problems when Leo does write leoConfig.txt: all comments are lost and options and sections are written in a random order.  This is due to problems in Python's ConfigParser module and will not be changed any time soon.

3. Provided the read_only option is off, Leo updates leoConfig.txt whenever it saves a .leo file or whenever the Preferences panel is closed without being canceled.  When updating leoConfig.txt, Leo will write only existing settings whose value is not "ignore".

4. When Leo saves a .leo file, Leo will write a Preferences setting to the .leo file only if the setting will not be written when updating leoConfig.txt.  In particular, changes made in the Preferences Panel will become permanent immediately if Leo the read_only option is off.  Otherwise the change will become permanent when any .leo file is saved.</t>
<t tx="edream.110203163054.321">Beginning with version 3.11, you may use plugins to customize how Leo works.  You can

- override or modify any command
- add or customize menus or
- translate menus into any language.

Plugins have full access to all of Leo's source code.  In particular, several convenience methods have been added to make customizing menus and commands easier.

Plugins are permanent: they will not go away when Leo is updated.  You can take
advantage of the latest CVS updates _without_ having to throw away your modifications.

Important warning: plugins must avoid blindly executing scripts in .leo files.  Doing so could expose all parts of your computer to malicious Python code.  The section called "Security warnings and precautions" discusses how to customize Leo safely and how to avoid several pitfalls.</t>
<t tx="edream.110203163054.322">What is a plugin?

A plugin is a .py file that appears in Leo's plugin subdirectory. Leo tries to
import all such files while starting up. This is done at "start1" time, that
is, in the call to doHook("start1") in the run function in leo.py. Plugins
exist to define "hook code".

New in 3.11: Leo looks in the plugins folder for .py files. Leo tries to
import all such files at startup ("start2") time.

New in 4.1: Leo enables only plugins whose name appears in pluginsManager.txt.
Leo loads plugins in the order in which they appear in pluginsManager.txt. Leo
loads no plugins if pluginsManager.txt does not exist in the plugins directory.

What is hook code?

Leo automatically calls hook code at various times during Leo's execution.
Typical hooks are:

- "start2", called at the end of Leo's startup process,
- "command1", called before executing any of Leo's commands
- "idle", called at Tk's idle time, when nothing else is happening,

See the documentation for hooks in this file for full details.

N.B. Plugins can use "start2" hooks to override any of Leo's classes. See
"Overriding functions, methods &amp; classes" in leoPlugins.leo for several
examples of how to do this.

How do plugins work?

Plugins register themselves when Leo imports them using the following code,
which should appear as the outer level of the .py file:

@color

"""A description of this plugin"""

registerHandler("xxx", onXXX)
__version__ = "1.2"
plugin_signon(__name__)
	
@nocolor

Line by line:

1) """A description of this plugin"""

This is a Python doc string describing the plugin. This string becomes the
value of the __name__ attribute for the module (.py file).

2) registerHandler("xxx", onXXX)

This line registers a handler called onXXX for the hook called "xxx". See the
documentation for hooks for a complete list of hook names that you can use
instead of "xxx". onXXX is the name of a function or method, presumably defined
in the plugin file, that Leo will call at "xxx" time. For example:

registerHandler("idle",onIdle)

will cause Leo to call the onIdle function at "idle" time.

You can pass a list of hook names as the first argument to registerHandler. For
example:

registerHandler(("bodykey1","bodykey2","headkey1","headkey2"), onKey)

3) __version__ = "1.2"

This assigns a version attribute to module. At present this attribute is used
by the plugin code that creates Leo's Plugins menu.

4) plugin_signon(__name__)

This line increases the count of loaded modules. The present code for
plugin_signon does not actually print separate signons--it seems to verbose.

About hook handlers

See the "About hooks" section of leoPlugins.leo for full documentation about
how to write hook handler routines, like onXXX or onKey in the examples above.
Basically, each hook should have this pattern:
	
@color

def onXXX (tag,keywords):
	c = keywords.get("c")
	otherKeyword = keywords.get("otherKeyword")
	&lt;&lt; do something with c and otherKeyword, etc. &gt;&gt;
	
@nocolor

In other words, keywords is a Python dictionary containing the keyword
arguments passed to the hook handler. See the See the "About hooks" section of
leoPlugins.leo for a list of the keywords passed to each hook handler.

The tag is the name of the hook. For example, tag would one of
"bodykey1","bodykey2","headkey1","headkey2", for the onKey hook handler in the
example above.

What's next?

It's one thing to know how to create a plugin. It's another to know how to
actually change Leo. Obviously, some study is needed. The place to start your
study is LeoPy.leo. In particular, study very carefully the section called
"Overview of code". Leo is a highly modular program, and Python is ideally
suited to this style of programming.</t>
<t tx="edream.110203163054.323">@nocolor

New in 3.11: Leo looks in the plugins folder for .py files. Leo tries to
import all such files at startup ("start2") time.

New in 4.1: Leo enables only plugins whose name appears in pluginsManager.txt.
Leo loads no plugins if pluginsManager.txt does not exist in the plugins directory.

The child of this node gives an example of the code that creates the Open With
menu. The following code, appearing at the end of mod_open_with.py, registers
two different hook functions. The on_idle function is the "idle" hook. The
create_open_with_menu is the "start2","open2" and "command2" hooks.

@color

# Register the handlers... 
registerHandler("idle", on_idle) 
registerHandler(("start2","open2","command2"), create_open_with_menu) 
es("...open with")
	
@nocolor
Plugins may call registerHandler with a hook name like "idle" or a list of hook
names like ("start2","open2","command2"). Also, you can use the "all" hook name
to indicate that code will be called for all hooks. This is useful for tracing
hooks. Plugins may also call registerExclusiveHandler for hooks that should not
be redefined in other plugins.

mod_open_with.py also contains the on_idle and create_open_with functions that
actually handle the hook. Such functions have two arguments: tag and keywords.
You will find many examples of this in LeoPy.leo.

About error checking:

At present Leo will disable all hooks if any hook throws an exception. In
practice this isn't a big deal, but something better could be done.

How to send me your plugins:

It should now be _much_ easier to submit a plugin for inclusion in LeoPy.leo.
Just send me a .leo file containing @file mod_your_plugin.py. Please have this
@file node be @ignored: this is more convenient for me. Ideally, your .leo file
should contain _only_ your plugin code.</t>
<t tx="edream.110203163054.324">@color
@language python
@ignore

"""Open With handler"""

from customizeLeo import *
from leoGlobals import *

@others

if 1: # Register the handlers...
	registerHandler("idle", on_idle)
	registerHandler(("start2","open2","command2"), create_open_with_menu)
	es("...open with")</t>
<t tx="edream.110203163054.325"># frame.OnOpenWith creates the dict as follows:
# dict = {"c":c, "v":v, "f":f, "path":path, "time":time}

def on_idle (tag,keywords):

	import os
	a = app()
	for dict in a.openWithFiles:
		path = dict.get("path")
		c = dict.get("c")
		v = dict.get("v")
		if path and os.path.exists(path):
			try:
				time = os.path.getmtime(path)
				if time and time != dict.get("time"):
					dict["time"] = time
					&lt;&lt; update v's body text &gt;&gt;
			except: pass</t>
<t tx="edream.110203163054.326">&lt;&lt; set s to the new text &gt;&gt;
body = v.bodyString()
&lt;&lt; set conflict flag &gt;&gt;

if conflict:
	# Report the conflict &amp; set update.
	import leoDialog
	d = leoDialog.leoDialog()
	message = "Conflict in %s.\n\n" % (v.headString())
	message += "Replace outline with external changes?"
	update = d.askYesNo("Conflict!",message) == "yes"
else:
	update = s != body

if update:
	h = v.headString()
	es("changed:" + h)
	v.setBodyStringOrPane(s)
	c.selectVnode(v)
	v.OpenWithOldBody = s
</t>
<t tx="edream.110203163054.327">try:
	# Update v from the changed temp file.
	f=open(path)
	s=f.read()
	f.close()
except:
	es("can not open " + shortFileName(path))
	break
</t>
<t tx="edream.110203163054.328">try:
	# The OpenWithOldBody attribute does not normally exist in vnodes.
	old_body = v.OpenWithOldBody
	conflict = body != old_body and body != s
except:
	conflict = v.isDirty() and body != s
</t>
<t tx="edream.110203163054.329">def create_open_with_menu (tag,keywords):

	if  (tag in ("start2","open2") or
		(tag=="command2" and keywords.get("label")=="new")):
	
		&lt;&lt; create the Open With menu &gt;&gt;

		# Enable the idle-time hook so we can check temp files created by Open With.
		from leoGlobals import enableIdleTimeHook
		enableIdleTimeHook(idleTimeDelay=500)
</t>
<t tx="edream.110203163054.330">@ Entries in the following table are the tuple (commandName,shortcut,data).
data is the tuple (command,arg,ext).
command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the extension ext,
Otherwise, Leo computes an extension based on what @language directive is in effect.
@c

idle_arg = "c:/python22/tools/idle/idle.py -e "

if 1: # Default table.
 table = (
  ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
  ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
  ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
else: # David McNab's table.
 table = (
  ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)))

top().frame.createOpenWithMenuFromTable(table)
</t>
<t tx="edream.110203163054.331">Naively using hooks can expose you and your .leo files to malicious attacks.  You will be safe as long as you follow these basic principles:

1. Hooks should _never_ blindly execute Python scripts in .leo files. Blindly executing scripts in .leo files runs the extreme risk of executing malicious code if you ever share any .leo file with someone else.  Moreover, using rexec instead of exec WILL NOT PROTECT YOU.  See the children of this node for further discussion of this important topic.

2. Hooks can execute any code safely _provided_ that all code is contained entirely within the plugin file. If you have a nifty customization that you want to do on a particular .leo file, put that code into a plugin.

3. Use only authentic copies of Leo that come from Leo's SourceForge site.</t>
<t tx="edream.110203163054.332">I'd like to thank Stephen Schaefer for gently insisting that we must guard against malicious code in shared .leo files.  Here is a little story Stephen told on Leo's SourceForge site that makes clear what the danger is:

"I foresee a future in which the majority of leo projects come from marginally trusted sources...I see a world of leo documents sent hither and yon - resumes, project proposals, textbooks, magazines, contracts - and as a race of Pandora's, we cannot resist wanting to see "What's in the box?" And are we going to fire up a text editor to make a detailed examination of the ASCII XML? Never! We're going to double click on the cute leo file icon, and leo will fire up in all its raging glory. Just like Word (and its macros) or Excel (and its macros)."

This succinctly illustrates the fundamental problem: when we share "our" .leo files we can _not_ assume that we know what is our "own" documents.  So hooks that naively searches through .leo files looking for scripts to execute is looking for big trouble.

The following node contains an example of the kind of code that is extremely dangerous.</t>
<t tx="edream.110203163054.333">@color
@ WARNING ***** Using the following routine exposes you to malicious code in .leo files! *****

Do not EVER use code that blindly executes code in .leo files!
Someone could send you malicious code embedded in the .leo file.

WARNING 1: Changing "@onloadpythonscript" to something else will NOT protect
           you if you EVER share either your files with anyone else.

WARNING 2: Replacing exec by rexec below provides NO additional protection!
           A malicious rexec script could trash your .leo file in subtle ways.
@c
if 0: # WRONG: This blindly execute scripts found in an .leo file! NEVER DO THIS!
	def onLoadFile():
		v = top().rootVnode()
		while v:
			h = v.headString().lower()
			if match_word(h,0,"@onloadpythonscript"):
				s = v.bodyString()
				if s and len(s) &gt; 0:
					try: # SECURITY BREACH: s may be malicious!
						exec(s + '\n',__builtins__,__builtins__)
					except:
						es_exception()
			v = v.threadNext()
</t>
<t tx="edream.110203163054.334">@color
@ It would be most foolish to expect rexec to protect you against malicious code contained in .leo files.  Remember that Leo is a repository of source code, so any text operation is potentially malicious.

For example, consider the following script.  This script is valid in rexec mode:
@c

c = top()
thisNode = c.currentVnode()
v = c.rootVnode()
while v:
	&lt;&lt; change all instances of rexec to exec in v's body &gt;&gt;
	v = v.threadNext()
&lt;&lt; delete thisNode &gt;&gt;
&lt;&lt; clear the undo stack &gt;&gt;

@ This script will introduce a security hole the .leo file without doing anything prohibited by rexec, and without leaving any traces of the perpetrating script behind.  The damage will become permanent _outside_ this script when the user saves the .leo file.
</t>
<t tx="edream.110203163054.335">pass</t>
<t tx="edream.110203163054.336">pass</t>
<t tx="edream.110203163054.337">pass</t>
<t tx="edream.110203163054.338">Hooks have full access to all of Leo's source code simply by importing it.

Moreover, several convenience methods have been added to make customizing menus and commands easier.  The following paragraphs discuss these routines and how to use them.

</t>
<t tx="edream.110203163054.339">The following routines enable and disable "idle" hooks.  They are defined in leoGlobals.py.

enableIdleTimeHook(idleTimeDelay=100)

Enables the "idle" hook. After this routine is called Leo will call the "idle" hook approximately every idleTimeDelay milliseconds.  Leo will continue to call the "idle" hook periodically until disableIdleTimeHook() is called.

disableIdleTimeHook()

Disables the "idle" hook.</t>
<t tx="edream.110203163054.340">The following convenience routines make creating menus easier.

These are methods of the leoFrame class.  Use top().frame to get the frame object for the presently active Leo window.

The plugins node in LeoPy.leo gives examples of how to use these routines to create custom menus and to add items to the Open With menu.

These convenience methods all do complete error checking and write messages to the log pane and to the console if errors are encountered.</t>
<t tx="edream.110203163054.341">@nocolor
createMenuItemsFromTable (self,menuName,table,openWith=0)

This method adds items to the menu whose name is menuName.  The table argument describes the entries to be created.  This table is a sequence of items of the form (name,shortcut,command).

- name is the command name
- shortcut is the shortcut, or None to indicate no shortcut.
- command is the routine to execute when the menu item is selected.

An entry of the form ("-",None,None) indicates a separator line between menu items.

For example:
@color
table =
	("Toggle Active Pane","Ctrl-T",self.OnToggleActivePane),
	("-",None,None),
	("Toggle Split Direction",None,self.OnToggleSplitDirection))

top().frame.createMenuItemsFromTable("Window",table)
@nocolor

If the openWith keyword argument is 1 the items are added to a submenu of the Open With menu.  However, it will be more convenient to use the createOpenWithMenuFromTable method to create the Open With menu.
</t>
<t tx="edream.110203163054.342">createNewMenu (self,menuName,parentName="top")

This method creates a new menu:

- menuName is the name of the menu to be created.
- parentName is the name of the parent menu, or "top" if the menu is to created in the menu bar.

This method returns the menu object that was created, or None if there was a problem.  Your code need not remember the value returned by this method.  Instead, your code will refer to menus by name.
</t>
<t tx="edream.110203163054.343">createOpenWithMenuFromTable (self,table)

This method adds items to submenu of the Open With menu item in the File menu.

The table argument describes the entries to be created.  This table is a sequence of items of the form (name,shortcut,data).

- name is the command name
- shortcut is the shortcut, or None to indicate no shortcut.
- data is a tuple of the form (command,arg,ext)
- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- arg is an argument to be passed to the given command.
- ext is a file extension or None.

When the user selects the Open With item corresponding to the table item Leo executes command(arg).
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on what @language directive is in effect.

For example:

table = (
	("Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
	("Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
	("Wordpad","Alt+Shift+T",("os.startfile",None,".txt")))

top().frame.createOpenWithMenuFromTable(table)
	</t>
<t tx="edream.110203163054.344">deleteMenu (self,menuName)

Deletes the menu whose name is given, including all entries in the menu.</t>
<t tx="edream.110203163054.345">deleteMenuItem (self,itemName,menuName="top")

Deletes the item whose name is itemName from the menu whose name is menuName.  To delete a menu in the menubar, specify menuName="top".</t>
<t tx="edream.110203163054.346">@nocolor
The leoFrame class creates the Window menu as follows:
@color

windowMenu = self.createNewMenu("&amp;Window")

table = (
	("&amp;Equal Sized Panes","Ctrl-E",self.OnEqualSizedPanes),
	("Toggle &amp;Active Pane","Ctrl-T",self.OnToggleActivePane),
	("Toggle &amp;Split Direction",None,self.OnToggleSplitDirection),
	("-",None,None),
	("Casca&amp;de",None,self.OnCascade),
	("&amp;Minimize All",None,self.OnMinimizeAll),
	("-",None,None),
	("Open &amp;Compare Window",None,self.OnOpenCompareWindow),
	("Open &amp;Python Window","Alt+P",self.OnOpenPythonWindow))

self.createMenuEntries(windowMenu,table)
</t>
<t tx="edream.110203163054.347">@nocolor

It is easy for hooks to translate menus into another language.  For example, code similar to the following code would typically be found in the "start2" hook:

@color

table = (
	("Open...","&amp;Ouvre"),
	("OpenWith","O&amp;uvre Avec..."),
	("close","&amp;Ferme"),
	("Undo Typing","French &amp;Undo Typing"), # Shows you how much French I know ;-)
	("Redo Typing","French &amp;Redo Typing"),
	("Can't Undo", "French Can't Undo"),
	("Can't Redo", "French Can't Redo"))
# Call the convenience routine to do the work.
app().setRealMenuNamesFromTable(table)</t>
<t tx="edream.110203163054.348">New in 4.0: Leo can now read and write "foreign" attributes in &lt;v&gt; and &lt;t&gt; elements in .leo files:

- When reading a .leo file, Leo will create t.unknownAttributes or v.unknownAttributes ivars for any tnode and vnode object whose corresponding &lt;v&gt; or &lt;t&gt; element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are a dictionary whose keys are the attribute names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if  a vnode or tnode contains an unknownAttributes ivar.

- The only "native" attributes that Leo expects to find are the "tx" attribute in &lt;t&gt; elements and the "a", "t", "vtag" and "tnodeList" attributes of &lt;v&gt; elements.  Everything else is a foreign attribute.

- Leo performs the usual xml escapes on these strings when reading or writing the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching unknownAttributes ivars to a vnode or tnode.  For example:

	v.unknownAttributes = {"vnodeIcon" : pathToIcon}

It would be best not to delete other foreign attributes, so the following would be preferred:

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

Another way:

	try:
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	except AttributeError:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

See the section called "Recommended conventions for plugins" for advice about how to avoid potential conflicts in naming new attributes.</t>
<t tx="edream.110203163054.349">Leo creates nonexistent directories only if create_nonexistent_directories = 1 in leoConfig.txt.

Previous versions of Leo created a new directory only if its parent directory already existed.  Now, Leo will create all non-existing directories as required.

For example.  Suppose neither dir1 nor dir2 exists.  Leo will create both dir1 and dir1 when it writes the following @file \root\dir1\dir2\spam.py.</t>
<t tx="edream.110203163054.350"></t>
<t tx="edream.110203163054.351">Double-clicking the icon box of a node whose headline has the form:

@url &lt;any url&gt;

executes the url in your default web browser.

Leo checks that the url is valid before doing so. A valid url is:

-- 3 or more lowercase alphas,
-- followed by one ':',
-- followed by one or more of: $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
-- followed by one of:         $%&amp;'()*+/0-9:=?@A-Z_a-z}~

Url's should contain no spaces: use %20 to indicate spaces.

You may use any type of url that your browser supports: http,mailto,ftp,file,etc.
</t>
<t tx="edream.110203163054.352"></t>
<t tx="edream.110203163054.353">The present version should be quite usable for its main purpose: tracking
down lines corresponding to error messages. In particular, except for possible
pathological cases, Leo should always put the cursor in the node containing the
referenced line. Possible pathologies involve asking Leo to "go to" a sentinel
line. It won't always be clear what node contains the sentinel.

I am well aware that Leo may not put the cursor on the proper line within
the vnode, but human beings being the excellent pattern matchers that we are,
we should be easily be able to find a line within a node.

Notes in LeoPy.leo, in the node called (Go to line number), discuss a variety
of issues that may cause the cursor not to go to the "proper" line. It also
discusses a better way to position the cursor.

Internally, there are two main versions of this command: one for @silentfile
trees, and one for @rawfile and @file trees. In the first case, there are no
sentinels in the derived file, so Leo just steps through the outline. This is
the easy case, and should work well. In the second case (@rawfile and @file
trees), the derived file contains sentinels, and Leo uses those sentinels to
determine in what vnode the given line occurs.

In this second case, Leo can almost always position the cursor within the
proper node, because Leo just scans back in the derived file looking for the
proper @+node sentinel. However, in order to "count" lines in the derived file
(to place the cursor properly _within_ the body text) Leo must recreate exactly
the logic used by the atFile.read logic, and that isn't easy. Moreover, there
is _no_ guarantee that the derived file is unchanged from when it was written;
after all, if you get syntax errors you tend to want to fix them ;-)

Please do not report bugs in this command, unless the bug involves a
crash, which would be reported both in Leo's log pane and in the console
window. This command will probably be improved in 3.10.</t>
<t tx="edream.110203163054.354">At last Leo has a power user of cweb.  Cweb mode is now fully tested and fully functional.  The following improvements have been made to cweb mode:

1. Corrected sentinels used in cweb mode.

Leo must double _all_ @ signs following the @q@. For example, an @@color sentinel gets turned into @q@@@@@color@&gt;.

2. Leo colors cweb doc parts and C comments in LaTex mode by default.

In cweb mode Leo colors @space, @* and @** sections using LaTeX coloring by default.  The color_cweb_doc_parts_with_latex option in leoConfig.py/.txt affects this default.

Similarly, Leo colors C comments in cweb mode using LaTeX coloring by default. The color_cweb_comments_with_latex option in leoConfig.py/.txt affects this default.

3. Cweb mode works similarly in @file and @root trees.

See the child of this node for full details about cweb mode.
</t>
<t tx="edream.110203163054.355">Cweb mode refers to how Leo tangles an outline when @language cweb is in effect or the cweb option in the Settings Panel is in effect.

Leo treats _all_ cweb code in cweb mode as unevaluated text.  That is, Leo treats cweb control codes, including @&lt;...@&gt;, @&lt;...@&gt;=, @c, @space, @* and @** as "raw" text within cweb mode.  Leo does _not_ expand _cweb_ section references when writing derived files in cweb mode.  However, Leo _does_ expand _noweb_ section references, so you may use noweb sections to organize cweb files! You can create _noweb_ code and doc sections using the @code and @doc directives in place of @c and @space directives.

By default, cweb colors @space, @* and @** sections using the same syntax coloring as for LaTeX.  In addition, cweb colors C // and /*..*/ comments using LaTeX coloring by default.  You may change these defaults using the color_cweb_doc_parts_with_latex and color_cweb_comments_with_latex options in leoConfig.py.</t>
<t tx="edream.110203163054.356">The Open With command allows you to communicate with external editor.  When you select this command Leo creates a temporary file and invokes an external program.  Leo periodically checks whether this temporary file has changed; Leo changes the corresponding node in the outline if so.

You must create the entries in the Open With submenu. This would typically be done in a hook routine, using the createOpenWithMenuFromTable routine described in the child of this node.

The @file mod_open_with.py node in LeoPy.leo gives a complete example of handling the Open With menu.</t>
<t tx="edream.110203163054.357">Leo now supports optional Emacs-style auto-indent.  This style of auto-indent aligns newly created lines with unmatched ( [ or { brackets in the previous line. This feature is enabled only if smart_auto_indent = 1 in leoConfig.txt.

This code was contributed by David McNab, david@rebirthing.co.nz.</t>
<t tx="edream.110203163054.358">New in leo.py v3.9

Whether importing text from an outside source, typing in text, or modifying text, eventually you end up with a block of text in which some lines are too long and some are too short.  The Reformat Paragraph command will rearrange the words in a text paragraph to fill each line as full as possible, up to the @pagewidth setting.

A paragraph is delimited by blank lines, Leo directives, and (of course) start and end of text in a node.  The width of the line used by the reformatting operation is governed by @pagewidth and the indentation that would be applied to the node when tangled (as part of a @root) or written (as part of a @file).

The command operates on the paragraph containing the insert cursor.  If the insert cursor is on a blank line or directive, nothing happens.  If the cursor is on a line containing text, then the paragraph containing that text line is reformatted and the insert cursor is moved to the next paragraph.

Be careful that you don't do this on source code!  Of course, if you do reformat something that should have been left alone, then just Undo.

NOTE: Lines with hanging indentation are handled so that the hanging indentation is preserved.  This is most useful for bulleted or numbered lists, such as:

  1. This is the first paragraph, and
     it has a hanging indentation.

  2. This is the second paragraph, and
     it too has a hanging indentation.</t>
<t tx="edream.110203163054.359">An @rawfile tree is a tree whose root headline starts with @rawfile &lt;filename&gt;.  Similarly, for @silentfile and @nosentinelsfile trees.

Leo creates files derived from @file and @nosentinelsfile trees in exactly the same way.  The _only_ difference is that files derived from @file trees contain sentinels, while files derived from @nosentinelsfile trees do not.  Therefore, Leo can not update outlines from changed made from files derived from @nosentinelfile trees.

Leo creates files derived from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. However, Leo recognizes the @ignore directive in the _ancestors_ of @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:

1. Leo writes no sentinel lines when writing @silentfile trees.  When writing @rawfile trees, Leo writes only the @+leo, @-leo, @+node, @-node, @+body and @-body sentinels. Therefore, Leo can update @rawfile trees, but _not_ @silentfile trees from changes made in derived files. Unlike @file and @rawfile trees, the primary source of information for an @silentfile tree is the outline containing it.

2. Within @silentfile trees only, if a headline starts with @@, Leo writes everything in the headline following the @@ just before the corresponding body text.

3. Files derived from @silentfile trees contain _nothing_ not contained in body text (or @@ headlines).  In particular, if body text does not end in a newline, the first line from the next node will concatenated to the last line of the preceding node.

In short, you can get any combination of sentinels/no sentinels and references/no references using @file, @nosentinelsfile, @rawfile and @silentfile trees.  This is shown in the following table:

                     Derived files        Sections and 
    Type of tree   contain sentinels?   @others expanded?
    ------------   ------------------   -----------------
           @file   yes                  yes
@nosentinelsfile   no                   yes
        @rawfile   yes                  no
     @silentfile   no                   no

New in Leo 3.10:

@file-asis is a synonym for @silentfile.
@file-nosent is a synonym for @nosentinelsfile.
@file-noref is a synonym for @rawfile.
</t>
<t tx="edream.110203163054.360">leo.py 3.8                               October 29, 2002

Many major improvements have been made to Leo, all made as the result of user requests:

- New @rawfile and @silentfile trees complement @file trees.
  @rawfile and @silentfile trees create derived files without using sections.
  @rawfile files contain only those sentinels needed to automatically untangle them.
  @silentfile trees contain no sentinels at all.
- New @raw and @end_raw directives allow unformatted code within @file trees.
- Much better support for CWEB.  You may organize .w files using noweb!
- The @comment and @language directives may now apply simultaneously.
- Leo can now read, remember and write &lt;?xml-stylesheet...?&gt; lines,
  under control of the new stylesheet option.
- The new output_newline option specifies the line endings used when writing files.
- The new output_initial_comment option specifies the text to appear
  in an @comment sentinel at the start of each derived file.
- New commands in the help menu make it much easier to change configuration options.
- Dozens of minor improvements and bug fixes.

This month Dave Hein and I discovered how to uniquely and permanently identify nodes, regardless of where those nodes are located and regardless of how many people are working simultaneously on them.  This discovery will greatly improve Leo, and will simplify how people use Leo with CVS.  Leo 4.0, due out in a month or two, will be the first version of Leo to use this breakthrough.

See the children of this node for full details.
</t>
<t tx="edream.110203163054.361"></t>
<t tx="edream.110203163054.362"></t>
<t tx="edream.110203163054.363">The warning for "unknown language" had an unbound var.</t>
<t tx="edream.110203163054.366"></t>
<t tx="edream.110203163054.368">Leo now properly handles @delims directives in @file trees.</t>
<t tx="edream.110203163054.369">Leo now properly recognizes all sentinel lines when @language cweb is in effect.</t>
<t tx="edream.110203163054.370">Fixed a bug that caused Leo to say "methods" rather than "functions" when importing C code.

Leo now adds @root &lt;filename&gt; statement when importing to @root nodes.</t>
<t tx="edream.110203163054.371"></t>
<t tx="edream.110203163054.372"></t>
<t tx="edream.110203163054.373"></t>
<t tx="edream.110203163054.374"></t>
<t tx="edream.110203163054.375">Previously, Java only had block comments, and the ending delim wasn't being removed from doc parts.</t>
<t tx="edream.110203163054.376"></t>
<t tx="edream.110203163054.377">The present code explicitly eliminates control-T processing in headlines, which means that control-T does not switch panes when editing headline text.  Control-T _does_ switch panes in all other cases.

This appears to be another Tk bug.</t>
<t tx="edream.110203163054.378">Only shortcut pastes worked before.</t>
<t tx="edream.110203163054.379"></t>
<t tx="edream.110203163054.380">Leo 3.7 significantly offers you several new ways to create derived files.</t>
<t tx="edream.110203163054.381">@rawfile and @silentfile trees are important new additions to Leo.  They work like @file trees, but are simpler to use.  See the child of this node for full details.</t>
<t tx="edream.110203163054.382">The @raw and @end_raw directives delimit a region of "raw" text.  No section references are recognized within "raw" text, and no additional leading whitespace is generated within "raw" text when writing the derived file.

The @quiet directive is valid only within @root trees.  It suppresses all sentinels except the @+node sentinels used to mark headlines.

See the children of this node for full details.</t>
<t tx="edream.110203163054.383">The @raw and @end_raw directives are valid only within @file trees.  The @raw directive starts a section of "raw" text.  The @end_raw directive ends such a section, as does the end of body text. No section references are recognized within "raw" text, and no additional leading whitespace is generated within "raw" text when writing the derived file.
</t>
<t tx="edream.110203163054.384">The @verbose, @terse, @quiet and @silent directives determine how the Tangle command outputs comments in @root trees.  Comments written by the user in code sections are always output: these directives control only: a) the comments containing doc sections and b) sentinel comments that delimit the beginning and end of code sections.

When @verbose is in effect Tangle outputs all comments. When @terse is in effect, Tangle outputs only those comments necessary for Untangle to work. When @silent is in effect Tangle adds no additional comments.  The @quiet directive is like @silent except that it does output leading sentinels as comments. Like @silent, @quiet inhibits untangling. 

@verbose is the default. If more than one of these directives appear in the same body text the "most verbose" of these options will be in effect.</t>
<t tx="edream.110203163054.385">It is now possible to create CWEB (.w) files from @file trees.  When @language cweb is in effect the following happen:

1. Leo does not recognize @space and @c directives.

2. The colorizer now recognizes both cweb and noweb section definitions and references.

3. Leo uses @q@ and @&gt; for comment delimiters in files derived from @file or @rawfile trees, and Leo replaces @ by @@ within such comments.

4. Leo now properly warns about orphan nodes when @langauge cweb was in effect.

See the child of this node for the new documentation that applies to cweb mode.</t>
<t tx="edream.110203163054.386">It is now possible to have both the @comment and @language directives to be in effect at the same time.  To do this, both directives must appear in the same node, and the @comment directive must follow the @language directive.</t>
<t tx="edream.110203163054.387"></t>
<t tx="edream.110203163054.388">Leo preserves the &lt;?xml-stylesheet...?&gt; line if it is already present in the .leo file.

Otherwise, Leo writes a &lt;?xml-stylesheet...?&gt; line only if the stylesheet option is present in the configuration file.  The stylesheet option specifies s in &lt;?xml-stylesheet s?&gt;</t>
<t tx="edream.110203163054.389">The Open LeoConfig.leo command opens the configuration file.  The apply setting command applies any changes to settings made as the result of changing leoConfig.leo.</t>
<t tx="edream.110203163054.390">This option allows a comment to be inserted in derived files just after the initial @+leo line.  The comment will appear in an @comment sentinel.  See leoConfig.leo for full details.</t>
<t tx="edream.110203163054.391">This option allows you to specify the line endings to be used when writing derived files and when exporting files.  See leoConfig.leo for full details.</t>
<t tx="edream.110203163054.392">Changed the path_directive_creates_directories option in leoConfig.leo to create_nonexistent_directories.

The old name was too misleading.  Indeed, this option applies not just to @path directives, but to all situations in which the path name specified in @path directives or @root, @file, @rawfile or @silentfile nodes does not exist.

</t>
<t tx="edream.110203163054.393"></t>
<t tx="edream.110203163054.394"></t>
<t tx="edream.110203163054.395"></t>
<t tx="edream.110203163054.396">The new names are less cluttered than the old.</t>
<t tx="edream.110203163054.397">Leo now prints a summary of any exception taken to the log window, and a full traceback to the console window.</t>
<t tx="edream.110203163054.398">This is taken from Python Cookbook.

This may be of use to people developing Leo, though it's not clear how useful this is with Tk programs.</t>
<t tx="edream.110203163054.399">A small convenience that is actually quite nice to have.</t>
<t tx="edream.110203163054.400">Sentinel lines in Java files now start with //@.</t>
<t tx="edream.110203163054.401">It wasn't always completely clear when the command was complete.</t>
<t tx="edream.110203163054.402">Recently I have discovered a way of creating true, immutable global identifiers (called global tnode indices or gti's for short).  Version 4.0, due late this year or early next, will be the first version of Leo to take full advantage of the opportunities created by gti's.

Gti's will be a way of permanently and uniquely identifying every node (headline and body text) ever created by Leo, even when many people are working on the same .leo and derived files.  For the first time, Leo will be able reliably to associate nodes in .leo files with nodes in derived files.

No previous version of Leo, including 3.7, has this ability, although that may not be so apparent to the casual user.  As a work around in all previous versions of Leo, .leo files contain copies of all information in derived files.  This "mirroring scheme" is needed so that clones in .leo files can be associated with their cloned counterparts in derived files.

While the mirroring scheme usually works well, it has some significant problems:

1. .leo files are much larger than they need to be.

2. Read errors occur if the derived files get out-of-synch with the information in the .leo file.  All clone links get broken when read errors occur, which basically ruins the resulting .leo file.  The only real way to recover is to use the Read Outline Only command.

3. Because out-of-synch conditions are so serious, it becomes a dicey proposition to save .leo files as backups; to create a reliable backup one must save the leo file along with all derived files.

Gti's solve all these problems:

1. .leo files no longer need to save a copy of all information in all derived files.  Leo will write only the root node of @file trees to the outline, secure in the knowledge that it can reliably recreate the outline from the derived file.

2. The dreaded read errors will be impossible because there is no longer any data in the .leo file that can become out-of-synch with data in the derived files.

3. Because .leo files can never become out-of-synch with derived files, we can, for the first time, safely backup a project by creating a "fat" .leo file that contains all information in all derived files.  Most .leo files will be "thin."  Saving "fat" .leo files will only happen as the result of a new Save Backup
command. 

I am excited about Leo 4.0.  It promises to revolutionize how people use Leo.</t>
<t tx="edream.110203163054.403">leo.py 3.7                                 October 9, 2002

Many improvements have been made to Leo.  The highlights:

- Now works with Python 2.1.  Previous versions required Python 2.2.
- Many new user options, including user-definable shortcuts for all commands
  and colors for all parts of Leo's windows.
  As a result, it is now possible to use arrow keys as you desire.
- Minimal support for Unicode Latin-1 (iso-8859-1) encoding. Better support is coming.
- Improved handling of relative path names.
- The @first directive allows lines to precede the opening @+leo sentinel line.
- The @last  directive allows lines to follow  the closing @-leo sentinel line.
- Better support for Perl+pod.
- Leo now ends all lines with '\n' regardless of platform.
- Leo is now compatible with Python 2.1.
- Simplified sentinels reduce spurious CVS diffs.
- Many other minor improvements and bug fixes.

Warning: Leo expects that all characters in derived files and .leo files are contained in the encoding specified by the xml_version_string option in leoConfig.txt.  Characters will be garbled if this restriction is not followed.  This restriction will be removed in the next release.

See the children of this node for full details.</t>
<t tx="edream.110203163054.404"></t>
<t tx="edream.110203163054.405"></t>
<t tx="edream.110203163054.406">The old code did not handle @comment /* */ in C mode because the */ given in the comment improperly terminated the scanning.

Changed find to rfind when scanning @@ sentinels.</t>
<t tx="edream.110203163054.407"></t>
<t tx="edream.110203163054.408">Under certain circumstances # was not properly colored when coloring plain text.</t>
<t tx="edream.110203163054.409">single quote colorized text in plain text mode.  This was due to missing parentheses.</t>
<t tx="edream.110203163054.410">The old code did not properly set the text selection in all cases.

This bug affected the Indent, Unindent, Extract and Extract Section.</t>
<t tx="edream.110203163054.411"></t>
<t tx="edream.110203163054.412">Body text was being cleared in a node in an @file tree if the node contained a reference to a section defined in a grandchild.  This was the first serious bug ever reported in the @file read logic.

The problem: Body text was being updated as the result of @+node sentinels rather than @+body sentinels.
This was wrong, as extra @+node sentinels are often generated when no body text is generated. The result is
that the body text was being cleared. 

The fix: I simply moved the code that creates body text from the @+node logic to the @+body logic in
scanText.</t>
<t tx="edream.110203163054.413">The new code resets the error count when reading each derived file, so errors in one file do not cascade to following derived files.</t>
<t tx="edream.110203163054.414"></t>
<t tx="edream.110203163054.415"></t>
<t tx="edream.110203163054.416">st_enter was not returning part numbers, which would have affected the Untangle command.</t>
<t tx="edream.110203163054.417">The old code undid the changes to only one headline of a group of cloned nodes. This was a serious bug because it would destroy the assumed equality between all cloned headlines.</t>
<t tx="edream.110203163054.418">The Find Previous command would get stuck once it found a match.</t>
<t tx="edream.110203163054.419">The original bug report:

"If you set the @tabwidth to something other than the Preference value, you'll see the body displayed appropriately. However, if you do a Ctrl-s to save the leo file, the body is redisplayed using the Preferences setting--of course, clicking on another node and then back to the original node displays with the correct tab setting again."</t>
<t tx="edream.110203163054.420">The old code remembered the insertion point only if it were set as the result of a keystroke.
</t>
<t tx="edream.110203163054.421">This was too confusing to users.  setup.py is intended only to create official distributions.</t>
<t tx="edream.110203163054.422">These improvements are listed in the approximate order of importance.</t>
<t tx="edream.110203163054.423"></t>
<t tx="edream.110203163054.424"></t>
<t tx="edream.110203163054.425">path_directive_creates_directories

Specifies whether to create a directory mentioned in an @file, @root node or @path directive if it does not exist.</t>
<t tx="edream.110203163054.426">relative_path_base_directory 

The directory to be used as a prefix for &lt;filename&gt; in @path &lt;filename&gt; and @file &lt;filename&gt; and @root &lt;filename&gt; when &lt;filename&gt; is a relative path.

Valid values for this option:

"!" means relative to the location leo.py (the default).
"." means relative to the location of the .leo file in the top window.
An absolute path (in platform-dependent format).

Relative paths are not allowed: such paths would be dangerous because their meaning would depend on the changing value of the current working directory.</t>
<t tx="edream.110203163054.427">remove_sentinels_extension

Sets the string to be appended to file names resulting from the Remove Sentinels command.  If the value starts with . the extension is appended to the original file name. Otherwise, the extension is appended before the file extension.

Example 1:
	File name x.y
	remove_sentinels_extension = _ns
	Result: x_ns.y

Example 2:
	File name x.y
	remove_sentinels_extension = .txt
	Result: x.y.txt
</t>
<t tx="edream.110203163054.428">write_clone_indices 

Indicates whether derived files will contain clone indices.

Please specify no clone indices if you are going to submit files to Leo's CVS site.</t>
<t tx="edream.110203163054.429">The following options now exist in the &lt;&lt; Options for newly opened windows &gt;&gt; section of LeoConfig.leo.

initial_horizontal_secondary_ratio

Sets the ratio of outline pane size to log pane size when splitting the primary panes horizontally.
The primary panes are the body pane and the secondary pane.

initial_vertical_secondary_ratio

Sets the ratio of tree pane size to body pane size when splitting the primary panes vertically.
The primary panes are the body pane and the secondary pane.


</t>
<t tx="edream.110203163054.430">The following options now exist in the &lt;&lt; Window options &gt;&gt; section of LeoConfig.leo.

body_text_foreground_color
body_text_background_color

The foreground and background colors of body text.

body_cursor_foreground_color
body_cursor_background_color

The foreground and background colors for the cursor in body text.

headline_text_unselected_foreground_color
headline_text_unselected_background_color

The foreground and background colors of unselected headline text.
Both must be specified for either to take effect.

headline_text_selected_foreground_color 
headline_text_selected_background_color

The foreground and background colors of selected headline text that is not being edited.
Both must be specified for either to take effect.

headline_text_editing_foreground_color
headline_text_editing_background_color

The foreground and background colors of unselected headline text in a headline that is being edited.
Both must be specified for either to take effect.

headline_text_editing_selection_foreground_color
headline_text_editing_selection_background_color

The foreground and background colors of selected text headline text in a headline that is being edited.
Both must be specified for either to take effect.

outline_pane_background_color

The background color of outline pane itself.

log_text_foreground_color
log_text_background_color

The foreground and background colors of log text.</t>
<t tx="edream.110203163054.431">The &lt;&lt; Keyboard shortcuts settings &gt;&gt; section of leoConfig.leo allows the user to specify keyboard shortcuts for all commands.

Notes:

1. There is one option for every command in Leo's menus; they won't be listed separately here.

2. For full documentation, see the

&lt;&lt; Keyboard shortcuts settings &gt;&gt; and
&lt;&lt; About keyboard shortcuts &gt;&gt;

sections of leoConfig.leo.  The gist of this documentation is that you must use names known to Tk, and Leo also provides a few other names.

3. At most one shortcut may be associated with a command.  If one really wanted to have two shortcuts, one would have to use two different command names. In particular, there is now only one shortcut for the Find Next command.
</t>
<t tx="edream.110203163054.432">Leo checks all characters that are entered (via typing or via paste) into headline and body text to see whether they can be represented in the encoding specified by the xml_version_string setting in leoConfig.txt.  Leo issues a message and disallows the entry of the character if it can't be represented in that encoding.

This draconian behavior shouldn't be too much of a nuisance, at least temporarily. Note that _all_ characters are valid in the UTF-8 encoding, so the present version of Leo will allow you to specify all characters if you must. But the Latin-1 (iso-8859-1) encoding, being a one-byte encoding, limits you to at most 256 separate characters. 

In 3.8 I plan to allow you to use all Unicode characters, regardless of encoding, by using character references.  This will require some reorganization of the present code, and I don't want to delay 3.7 to handle them.

Warning: The present code does not handle well files (.leo or derived files) that contain characters outside the specified encoding.  At present, your best bet is to remove such characters for now.  Hopefully 3.8 will do a much better job handling characters "foreign" to the specified encoding.</t>
<t tx="edream.110203163054.433">Leo now writes only \n (Linux newlines) in derived files and .leo files.  This was done simply by opening derived files and .leo files in "wb" mode.</t>
<t tx="edream.110203163054.434"></t>
<t tx="edream.110203163054.435">1. Leo now supports relative_path_base_directory and path_directive_creates_directories user options.  See the discussion of those options in this document.

2. Leo now retains file modes when tangling and writing derived files.</t>
<t tx="edream.110203163054.436">Blank lines now precede and follow =pod and =cut.

Improvements made to @first and @last directives.</t>
<t tx="edream.110203163054.437">These were added so to resolve the debate about what the Esc key should do.  The user can now bind Esc to either of these commands.</t>
<t tx="edream.110203163054.438">Leo no longer gives an error message when reading or writing cloned @file nodes.</t>
<t tx="edream.110203163054.439"></t>
<t tx="edream.110203163054.440">Leo writes derived files a bit differently than before.  These changes are compatible with the Borland version of Leo, provided that xml_version_string = UTF-8 in leoConfig.txt.

The changes:

1. Eliminated writing clone indices in derived files.  This reduces the number of spurious changes reported by CVS.  Leo now relies solely on information in .leo files to recreate clone indices.  This is safe because read errors clear clone indices anyway.  You can force clone indices to be written using the write_clone_indices user option in leoConfig.txt.

2. Removed extra newline following @+leo directive.  This is part of an unfinished plan to eliminate all extra blank lines in derived files.  It's not clear whether this plan will ever succeed.</t>
<t tx="edream.110203163054.441">Leo enables the Tangle and Untangle items in popup menus if any descendant of the selected node contains an @root node.  Similarly, Leo enables the Read @file nodes and Write @file nodes items in popup menus if any descendant of the selected node contains an @file node.</t>
<t tx="edream.110203163054.442"></t>
<t tx="edream.110203163054.443">leo.py 3.6                                 September 11, 2002

Highlights:

- Fixed a large number of bugs, especially bugs that appear only on Linux.
- Leo now remembers the previous insertion point and location of the scrollbar when switching between nodes.
- Added Match Brackets command.
- Added support for MouseWheel (Linux only).
- Added support for LaTex and PHP.
- Improved all aspects of the Help menu.
- Discovered a minor bug involving the Python (Idle) window and documented a workaround.

See the children of this node for full details.</t>
<t tx="edream.110203163054.444">The following minor bug can not easily be fixed because it involves an interaction between Leo and Idle.

After opening Idle with the Open Python Window command, opening another Leo window shows both the Leo window and a blank, square window.  Closing either of the new windows may cause exceptions, either immediately or later.

The best workaround is simply not to open any new Leo windows after using the Open Python Window command.</t>
<t tx="edream.110203163054.445"></t>
<t tx="edream.110203163054.446"></t>
<t tx="edream.110203163054.447">os.rename can fail on some Linux systems.</t>
<t tx="edream.110203163054.448">When starting Leo with no arguments the 'NewHeadline' node was not displayed. </t>
<t tx="edream.110203163054.449">Changed:

bitmap_name = os.path.join(self.loadDir,"Icons\LeoApp.ico") 

to:

bitmap_name = os.path.join(self.loadDir,"Icons","LeoApp.ico") 
</t>
<t tx="edream.110203163054.450">There were problems handling relative path names in @root and @path directives.</t>
<t tx="edream.110203163054.451">With Tk/Tcl 8.4, the Preferences window is empty (no buttons, fields, labels). 

Tcl 8.4 complains about using "col" in the grid() calls.</t>
<t tx="edream.110203163054.452">This routine does a better job of checking the Tk version than the old code in leoApp.py</t>
<t tx="edream.110203163054.453"></t>
<t tx="edream.110203163054.454">Only the last directive was in effect in @root trees.  The new code allows node-by-node control.</t>
<t tx="edream.110203163054.455">This involved calling readlineForceUnixNewline instead of readline in the atFile:read logic.</t>
<t tx="edream.110203163054.456"></t>
<t tx="edream.110203163054.457">How did I ever live without this?</t>
<t tx="edream.110203163054.458"></t>
<t tx="edream.110203163054.459">The cursor now changes to an arrow when it moves over a link in the About Leo dialog.

The About Leo dialog now includes a build revision number.

Fixed problems with the Leo icon in the About Leo dialog.

Improved download dialog in Tutorial command.</t>
<t tx="edream.110203163054.460">CVS conflict files produce so many error messages that these errors are useless.</t>
<t tx="edream.110203163054.461"></t>
<t tx="edream.110203163054.462"></t>
<t tx="edream.110203163054.463"></t>
<t tx="edream.110203163054.464">The Match Brackets command is enabled if the cursor is next to one of the following characters in the body pane:

( ) [ ] { } &lt; &gt;

This command looks for the matching character, searching backwards through the body text if the cursor is next to ) ] } or &gt; and searching forward through the text otherwise.  If the cursor is between two brackets the search is made for the bracket matching the leftmost bracket.

If a match is found, the entire range of characters delimited by the brackets is highlighted and the cursor is placed just to the left of the matching characters.  Thus, executing this command twice highlights the range of matched characters without changing the cursor.</t>
<t tx="edream.110203163054.465">This code is due to Dave Hein.

Leo understands the following PHP keywords:

&lt;?php, ?&gt;, __CLASS__, __FILE__, __FUNCTION__, __LINE__, and,	as, break, case, cfunction, class, const, continue, declare, default, do, else, elseif,  enddeclare, endfor, endforeach, endif, endswitch, endwhile, eval,  extends, for, foreach, function, global, if, new, old_function, or, static, switch, unset(), use, var, while, xor,

Leo does not yet color the following keywords containing():

array(), die(), echo(), empty(), exit(), include(), include_once(), isset(), list(), print(), require(), require_once(), return()</t>
<t tx="edream.110203163054.466">This code is due to Marcus A. Martin.

Leo understands the following LaTex keywords: capitalization is significant.  For example, \vert produces a single vertical line and \Vert produces a double vertical line.

\@, \(, \), \{, \},

\acute, \addcontentsline, \addtocontents, \addtocounter, \address,
\addtolength, \addvspace, \AE, \ae, \aleph, \alph, \angle, \appendix, 
\approx,\arabic, \arccos, \arcsin, \arctan, \ast, \author,

\b, \backmatter, \backslash, \bar, \baselineskip, \baselinestretch,
\begin, \beta, \bezier, \bf, \bfseries, \bibitem, \bigcap, 
\bigcup, \bigodot, \bigoplus, \bigotimes, \bigskip, \biguplus, 
\bigvee, \bigwedge,\bmod, \boldmath, \Box, \breve, \bullet,

\c, \cal, \caption, \cdot, \cdots, \centering, \chapter, 
\check, \chi, \circ, \circle, \cite, \cleardoublepage, \clearpage, 
\cline,\closing, \clubsuit, \coprod, \copywright, \cos, \cosh, 
\cot, \coth,csc,

\d, \dag, \dashbox, \date, \ddag, \ddot, \ddots, \decl, 
\deg, \Delta, \delta, \depthits, \det, 
\DH, \dh, \Diamond, \diamondsuit, \dim, \div, \DJ, \dj, 
\documentclass, \documentstyle, \dot, \dotfil, \downarrow,

\ell, \em, \emph, \end, \enlargethispage, \ensuremath, 
\enumi, \enuii, \enumiii, \enuiv, \epsilon, \equation, \equiv,
\eta, \example, \exists, \exp,

\fbox, \figure, \flat, \flushbottom, \fnsymbol, \footnote, 
\footnotemark, \fotenotesize, 
\footnotetext, \forall, \frac, \frame, \framebox, \frenchspacing, 
\frontmatter,

\Gamma, \gamma, \gcd, \geq, \gg, \grave, \guillemotleft, 
\guillemotright,\guilsinglleft, \guilsinglright,

\H, \hat, \hbar, \heartsuit, \heightits, \hfill, \hline, \hom, \hrulefill,\hspace, \huge,\Huge,\hyphenation

\Im, \imath, \include, includeonly, indent, \index, \inf, \infty, \input, \int, \iota,\it, \item, \itshape,

\jmath, \Join,

\k, \kappa, \ker, \kill,

\label, \Lambda, \lambda, \langle, \large, \Large, \LARGE, 
\LaTeX, \LaTeXe, 
\ldots, \leadsto, \left, \Leftarrow, \leftarrow, \lefteqn, \leq,
\lg, \lhd, \lim, \liminf, \limsup, \line, \linebreak, 
\linethickness, \linewidth,\listfiles,
\ll, \ln, \location, \log, \Longleftarrow, \longleftarrow, 
\Longrightarrow,longrightarrow,

\mainmatter, \makebox, \makeglossary, \makeindex,\maketitle, \markboth, \markright,
\mathbf, \mathcal, \mathit, \mathnormal, \mathop,
\mathrm, \mathsf, \mathtt, \max, \mbox, \mdseries, \medskip,
\mho, \min, \mp, \mpfootnote, \mu, \multicolumn, \multiput,

\nabla, \natural, \nearrow, \neq, \newcommand, \newcounter, 
\newenvironment, \newfont,
\newlength,\newline, \newpage, \newsavebox, \newtheorem, \NG, \ng,
\nocite, \noindent, \nolinbreak, \nopagebreak, \normalsize,
\not, \nu, nwarrow,

\Omega, \omega, \onecolumn, \oint, \opening, \oval, 
\overbrace, \overline,

\P, \page, \pagebreak, \pagenumbering, \pageref, \pagestyle, 
\par, \parbox,\paragraph, \parindent, \parskip, \part, 
\partial, \per, \Phi, \phi,\Pi, \pi, \pm, 
\pmod, \pounds, \prime, \printindex, \prod, \propto, \protext, 
\providecomamnd, \Psi,\psi, \put,

\qbezier, \quoteblbase, \quotesinglbase,

\r, \raggedbottom, \raggedleft, \raggedright, \raisebox, \rangle, 
\Re, \ref, \renewcommand, \renewenvironment, \rhd, \rho, \right, 
\Rightarrow,\rightarrow, \rm, \rmfamily,
\Roman, \roman, \rule, 

\s, \samepage, \savebox, \sbox, \sc, \scriptsize, \scshape, 
\searrow, \sec, \section,
\setcounter, \setlength, \settowidth, \settodepth, \settoheight, 
\settowidth, \sf, \sffamily, \sharp, \shortstack, \Sigma, \sigma, 
\signature, \sim, \simeq, \sin, \sinh, \sl, \SLiTeX,
\slshape, \small, \smallskip, \spadesuit, \sqrt, \sqsubset,
\sqsupset, \SS,
\stackrel, \star, \subsection, \subset, 
\subsubsection, \sum, \sup, \supressfloats, \surd, \swarrow,

\t, \table, \tableofcontents, \tabularnewline, \tan, \tanh, 
\tau, \telephone,\TeX, \textbf,
\textbullet, \textcircled, \textcompworkmark,\textemdash, 
\textendash, \textexclamdown, \textheight, \textquestiondown, 
\textquoteblleft, \textquoteblright, \textquoteleft,
\textperiod, \textquotebl, \textquoteright, \textmd, \textit, \textrm, 
\textsc, \textsl, \textsf, \textsuperscript, \texttt, \textup,
\textvisiblespace, \textwidth, \TH, \th, \thanks, \thebibligraphy,
\Theta, theta, 
\tilde, \thinlines, 
\thispagestyle, \times, \tiny, \title,\today, \totalheightits, 
\triangle, \tt, 
\ttfamily, \twocoloumn, \typeout, \typein,

\u, \underbrace, \underline, \unitlength, \unlhd, \unrhd, \Uparrow,
\uparrow,\updownarrow, \upshape, \Upsilon, \upsilon, \usebox,
\usecounter, \usepackage, 

\v, \value, \varepsilon, \varphi, \varpi, \varrho, \varsigma, 
\vartheta, \vdots, \vec, \vector, \verb, \Vert, \vert, \vfill,
\vline, \vphantom, \vspace,

\widehat, \widetilde, \widthits, \wp,

\Xi, \xi,

\zeta</t>
<t tx="edream.110203163054.467">leo.py 3.5                                  August 14, 2002

Highlights:

- Added new entries in the help menu.
 (Including a link to Joe Orr's excellent ScreenBook tutorial).
- Added the importFiles script in leoImport.py.
- Added configuration options for horizontal scrollbars.
- Added better warnings for read-only files.
- Removed all '\r' when reading derived files.
- Fixed crasher in Read Outline Only command.
- Fixed crasher when leoConfig.txt did not exist.
- Many small improvements and bug fixes.</t>
<t tx="edream.110203163054.468"></t>
<t tx="edream.110203163054.469">This may be the cause of truncated leoConfig.txt files on Linux.</t>
<t tx="edream.110203163054.470"></t>
<t tx="edream.110203163054.471"></t>
<t tx="edream.110203163054.472">Removed '\r' characters when reading.  The write logic is unchanged.</t>
<t tx="edream.110203163054.473">Relative paths should not set the global default paths.  Instead, the relative path is concatenated to the global default path when the file is opened.</t>
<t tx="edream.110203163054.474"></t>
<t tx="edream.110203163054.475"></t>
<t tx="edream.110203163054.476">Added log_pane_wraps and outline_pane_scrolls_horizontally configuration settings.</t>
<t tx="edream.110203163054.477"></t>
<t tx="edream.110203163054.478">Note: b4 contains a fix to b3 in this area:  for writing, we must first test whether the file exists.  Otherwise we may get a false indication that the (non-existent) file is read-only.</t>
<t tx="edream.110203163054.479">Added the importFiles script in leoImport.py. Use this script as follows:

- Select the node under which you want the imported files to appear.
- Open the Python window within Leo.
- Type the following in the Python window:

import leoImport
dir = "c:/prog/test"  # or some other directory
type = ".py"  # Type of files you want to import.
leoImport.importFiles(dir,type)

If you want to import all files in a directory, replace the last line with:

leoImport.importFiles(dir)</t>
<t tx="edream.110203163054.480">leo.py 3.4                                     August 11, 2002

This release contains many small improvements and bug fixes.  The highlights:

- Fixed several crashers involving Unicode.
- The Show Invisibles command now makes blanks and tabs look much better.
- Created leoConfig.leo, from which leoConfig.txt is now derived.
- Added save_clears_undo_buffer configuration option.
- Fixed a large number of problems with the configuration code.
- The usual minor improvements and bug fixes.

See the children of this node for full details.</t>
<t tx="edream.110203163054.481"></t>
<t tx="edream.110203163054.482">The problem is that the ratio is saved in the .leo file and the split direction is not. So if leoConfig.txt is read-only you the Toggle Split Direction command will permanently change the body-outline ratio _without_ permanently changing the split direction itself.

This basically sucks, and here are my reasons: 

1. I do not want to be adding more options to .leo files; the whole idea of leoConfig.txt is to move in the opposite direction. 

2. You can make everything work more like you would expect by making leoConfig.txt read-write. 

3. Especially in the case of the split direction, I expect people to have strong preferences one way or the other, so even if leoConfig.txt is read-only it shouldn't be too odious to pick a split direction and live with it.</t>
<t tx="edream.110203163054.483">The undo buffer creates a lot of strings.  On some system this may be a problem.  If save_clears_undo_buffer = 1 the Save command (and only the Save command) will clear the undo buffer.</t>
<t tx="edream.110203163054.484">The new spelling is to limit_directory_search_extension.  Note that this affects the valid entries in leoConfig.txt.</t>
<t tx="edream.110203163054.485">This allows us to create leoConfig.txt more easily, and provides a safe place to permanently store comments when read-write mode is on.</t>
<t tx="edream.110203163054.486">If a setting was missing or "ignore" it could never be set!  This no doubt could have caused a wide variety of symptoms.  In particular, in the distributed leoConfig.txt file it meant that settings for "default" fonts and sizes were never updated!</t>
<t tx="edream.110203163054.487">The new code properly deletes previous entries regardless of case or path separators.</t>
<t tx="edream.110203163054.488">There were a couple of bugs here.

Note that the ratio (whichever the direction) is stored in the .leo file.  The initial_splitter_orientation setting in leoConfig.txt applies to _all_ files.  The initial_vertical_ratio and the corresponding initial_horizontal_ratio  apply only to new files, so are essentially useless.

Yes, this is pretty stupid; it's the result of not wanting to add more stuff to Leo's file format.</t>
<t tx="edream.110203163054.489"></t>
<t tx="edream.110203163054.490"></t>
<t tx="edream.110203163054.491"></t>
<t tx="edream.110203163054.492"></t>
<t tx="edream.110203163054.493">leo.py 3.1 contains Python code that may be of interest to some Python programmers.  All Python files are derived from LeoPy.leo.

See the children of this node for details.</t>
<t tx="edream.110203163054.494">This script does much of the grunt work of converting from C/C++ syntax to Python syntax.  It was surprisingly effective in converting Leo from C++ to Python.  These scripts don't need to be perfect to save a _lot_ of work.  And of course you can always add your own improvements...

As written, the script converts an entire Leo tree.  It would be easy to write an entry that would convert plain text files, but it's probably best to import the files to be converted into Leo first.  That way the slow algorithms in c2py.py will work on smaller pieces of text.</t>
<t tx="edream.110203163054.495">This code gathers and prints static statistics about Python bytecode.</t>
<t tx="edream.110203163054.496">The file leoUtils.py contains some small Tkinter utilities:

w,h,x,y = get_window_info(top) returns the width, height, x and y positions of the Tkinter window top.

center_dialog(top) centers the Tkinter window top on the screen.

w,f = create_labeled_frame(parent...) creates a labeled Tkinter window as a child of parent.  The caller packs widgets into f to create the frame.

leoUtils.py contains many other routines including an Python version of the Sherlock tracing package.</t>
<t tx="edream.110203163054.497">leoFontPanel.py puts up a Font dialog.  This dialog dispenses with the typical "sample" pane and instead changes text immediately directly on the screen.  Comes with Ok, Cancel and Revert buttons.  IMO, this dialog is much better than the sample Tk/Tkinter font dialogs available on the web.</t>
<t tx="edream.110203163054.498">leoColor.py contains code to syntax color Tk.Text widgets for a variety of languages.  Supporting a new language here is mostly a matter of adding another table of keywords.</t>
<t tx="edream.110203163054.499">Leo supports powerful outlining features, including clones.  Clones are challenging to implement, to say the least.  The vnode and tnode classes, defined in leoNodes.py, represent the underlying data.  vnodes represent nodes on the screen.  vnodes may share text, the tnode class is the "unit of sharing" of such text.  The leoTree class draws the tree and handles events, including dragging nodes around the screen.  The Commands class calls the vnode, tnode and leoTree classes to handle menu commands.  In Smalltalk's model/view/controller terminology, the vnode and tnode classes are model class, the leoTree class is a view class, and the Commands class is a controller class.</t>
<t tx="edream.110203163054.500"></t>
<t tx="edream.110203163054.501">Now at last it is clear why Leo hasn't been writing derived files affected by clones.  It's not enough to mark v dirty.  We must mark all the cloned nodes of v's tree dirty as well.

However, we only need do this when a node is deleted, and we definitely do _not_ want to do this otherwise, for that would mark far too many nodes dirty.  To get around this, we leave v.setDirty() as it was, and use the new code only in v.setDirtyDeleted.

Note that the undo and redo cases handle this automatically because they call c.doDelete.

So now we can state a rule that should not ever be broken: after doing a Save command, a Write @file Nodes command should always report "unchanged" for all files.</t>
<t tx="edream.110203163054.502"></t>
<t tx="edream.110203163054.503">Added setRevertVars to update revert settings.  This is called from __init__ and onOk.</t>
<t tx="edream.110203163054.504">Changed idle_body_key and idle_head_key, leoTangle::os and tnode::setTnodeText.

We must remove backticks from messages that might contain unicode characters so they will print properly.  There were only a few instances, and they are all error messages that hardly ever get executed, so I hope I was careful putting them in.  I should be able to find them all by looking for '"'.</t>
<t tx="edream.110203163054.505">Repeated double-clicking (without intervening single-click) caused the selection to move to the left.</t>
<t tx="edream.110203163054.506"></t>
<t tx="edream.110203163054.507"></t>
<t tx="edream.110203163054.508">This is consistent with what the Import commands do for the other file types.  It's also much safer.</t>
<t tx="edream.110203163054.509"></t>
<t tx="edream.110203163054.510">This makes selected text look much better and makes Show Invisibles look much better as well.  

This was not easy to do.  Apparently tag settings interfere with the Tk.Text settings.  I have not found a way to specify the selectbackground color for tags.  The only way I could get things to work is define whitespace tags only when in showInvisibles mode.</t>
<t tx="edream.110203163054.511">.tmp files disappear On Windows XP after Leo exits!</t>
<t tx="edream.110203163054.512">leo.py 3.3                                     August 3, 2002

This version of Leo:

- Added support for Unicode.
- Improved the Import commands.
- Fixed numerous bugs related to configuration settings.
- Fixed the "Javadoc" bug and several latent bugs related to it.

See the children of this node for details.

Edward K. Ream</t>
<t tx="edream.110203163054.513">It is now possible to use non-Ascii characters in Leo!

Leo uses the xml_version_string setting to encode Unicode characters in .leo files.  This will be UTF-8 by default.  I've also very briefly tested ISO-8859-1.

I am a complete Unicode ignoramus.  It seemed trivial to add Unicode support to Leo, and if there are any fine points that should have been considered I no doubt did not consider them...</t>
<t tx="edream.110203163054.514">The Import command now does a better job of removing excess leading whitespace.

When importing .java files, Leo now preserves newlines in leading block comments.  This makes the typical weird Java comments look better.  For example,

/**  This is a typical,
  * brain-dead,
  * Java comment.
  */

Now gets rendered as

@ * This is a typical
 * brain-dead,
 * Java comment.
@c

The comment will be reconstituted properly when rewritten.
</t>
<t tx="edream.110203163054.515">This never happened before because all languages had either 1 or 3 delims.  But Java now has only 2 delims to force block comments.</t>
<t tx="edream.110203163054.516">Leo should now handle negative tab widths properly.</t>
<t tx="edream.110203163054.517">- Negative tab widths are now honored properly.

- Made 'additional_body_text_border' setting functional.

- Made 'body_pane_wraps' setting functional.

- There was a bug that made the following non-functional.

	"read_only"
	"xml_version_string"
	"limit_count"
	"body_pane_wraps"

That is, only the default settings in leoConfig.py were used, not the settings in leoConfig.txt.

- The old code did not use the "page_width" and "tab_width" settings from leoConfig.txt.</t>
<t tx="edream.110203163054.518">leo.py 3.2                                     July 30, 2002

This version generalizes the @others directive, improves the Import command and fixes several bugs.  See the children of this node for full details.

The highlights:

- Nested @others directives are now valid, an important improvement.
  This simplifies files that define more than one class.
- Improved the Import command and squashed several bugs lurking there.
- Made the various Go commands in the Outline-Move/Select menu functional
  by reassigning keyboard shorts
- Fixed a crasher in the Prefs Panel.
- Fixed numerous bugs in the Set Colors command.
- Fixed syntax coloring of C strings that span multiple lines.
- The usual minor improvements and bug fixes.

Edward K. Ream</t>
<t tx="edream.110203163054.519">Nested @others directives are now valid, even when no named node intervenes.  This is a significant enhancement to Leo because it is now easier to define multiple classes in a single file.  The leoNode.py file also uses nested @others directives.

The outline shown in the child of this node shows the general idea.

The Import command uses nested @others to great effect in Python files containing many classes.  For example, try importing the file Python/Lib/Compiler/ast.py.</t>
<t tx="edream.110203163054.520">@color
@ignore

# This is the "outer" @others
@others
</t>
<t tx="edream.110203163054.521">class a:
	# This is an "inner" @others.  No named node intervenes.
	@others</t>
<t tx="edream.110203163054.522">def one():
	pass</t>
<t tx="edream.110203163054.523">def two():
	pass</t>
<t tx="edream.110203163054.524">class b:
	# This is an "inner" @others.  No named node intervenes.
	@others</t>
<t tx="edream.110203163054.525">def one():
	pass</t>
<t tx="edream.110203163054.526">def two():
	pass</t>
<t tx="edream.110203163054.527">The Import command creates nested @others directives when parsing Python classes.

Fixed two bugs in the Import command:

1. The Import command now properly places the first @others directive of Python files.  Previously the @others directive was placed before section references, so code could be rearranged.

2. The Import command now properly handles all C preprocessor directives.  Previously there were problems handling the #ifndef directive which could ruin imports.

Two other minor improvements:

1. This is reasonable: we don't wan't people generating files from imported files unless they take some positive action.

2. The Import command now checks that different branches of #if, #else, #endif directives have the same net number of braces, and warns if they do not.  This logic was inserted while trying to fix bug #2 above.</t>
<t tx="edream.110203163054.528">It's too confusing to have arrow keys mean different things in different panes.

For one thing, we want to leave the focus in the body pane after the first click in the outline pane, but that means that the arrow keys must still be functional in the body pane!

Alas, all the various combinations of key bindings of arrow keys appear to do something; there are none left to use for moving around in the outline pane.  So we are stuck with poor shortcuts.</t>
<t tx="edream.110203163054.529">Leo could sometimes crash when the user selected Cancel in the Preferences panel.</t>
<t tx="edream.110203163054.530"></t>
<t tx="edream.110203163054.531">There were too many problems in the old color panel.

- Completely revised the Revert logic in the main Color panel.
- The color name picker now reverts properly.
- Color names and color swatches are now properly updated in all cases,
  so there is no need to write color values to the log window.
- Eliminate quotation marks around color names and values.
- The color picker now shows the value of the present color, not the revert color.
- Increased the width of name buttons to handle long color names.
</t>
<t tx="edream.110203163054.532">Thanks to Thomas Guettler for suggesting this.</t>
<t tx="edream.110203163054.533">This script uses the dis module to print static statistics about Python bytecode.  Of no use to anyone but me.</t>
<t tx="edream.110203163054.534">leo.py 3.1                                     July 20, 2002

This version fixes a blunder that affects only leo.py 3.0.  I recommend that all users of 3.0 upgrade to this version.

With this release Leo's to-do list is now empty! I shall fix bugs as they are reported. I'll add new features only if convinced that they contribute significantly to Leo.

The highlights:

- Fixed a blunder: Leo 3.0 did nothing when it was opened directly from leo.py.
  (Opening leo using openLeo.py did work.)
- Created a compare panel to control scripts in leoCompare.py.
- Added many new settings in leoConfig.txt to initialize the compare panel.
- The FAQ tells how to add support for new languages.
  (These instructions also appear in the "Notes/How To" section in LeoPy.leo)
- The usual minor improvements and bug fixes.

Edward K. Ream</t>
<t tx="edream.110203163054.535">The file comparison window helps people verify that imported files are, in fact, precisely equivalent to the original files.</t>
<t tx="edream.110203163054.536">Here are the new settings in leoCompare.txt:

# Initial settings of the Compare panel.
# 	These correspond to the keyword parameters of the leoCompare constructor.
# 	Exception: there are no keywords for compare file names in the constructor.

[compare options]

# ----- Options specifying files for the Compare panel.

compare_file_1 = c:/prog/test/compareTest1/file1.txt
#	Path to the first file or directory to be compared.
#	Directory compares ignore a filename part of the path, if present.
#	E.g., c:/directory1/spam.py is valid for directory compares.

compare_file_2 = c:/prog/test/compareTest2/file2.txt
#	Path to the second file or directory to be compared.
#	Directory compares ignore a filename part of the path, if present.
#	E.g., c:/directory2/spam.py is valid for directory compares

output_file = c:/prog/test/compareResults.txt
#	Path to the output file.
#	Leo will silently write to this file, regardless of whether it already exists.
#	Leo will write to the log pane if this path is empty or invalid.

append_output_to_output_file = 0
#	0: Replace output file with results of compare.
#	1: Append output to output file.

# ----- Options related to directory compares.
#	These options has no effect when comparing files.

limit_directory_search_extenstion = .py
#	Limit directory searches to files with the given file extension.
# 	Examples:
#		None	Compare all files when comparing directories.
#		.py  	Compare .py files when comparing directories.

# ----- Options related to file compares.
#	These options have no effect when comparing directories.

ignore_blank_lines = 1
#	1: Ignore blanks lines when comparing files.

ignore_first_line_of_file_1 = 0
#	1: Ignore the first line of compare_file_1 when comparing files.

ignore_first_line_of_file_2 = 0
#	1: Ignore the first line of compare_file_2 when comparing files.

ignore_interior_whitespace = 0
#	1: Ignore whitespace after the leading whitespace of a line when comparing files.

ignore_leading_whitespace = 0
#	1: Ignore leading whitespace of each line when comparing files.
#	Not recommended when comparing .py files.

ignore_sentinel_lines = 0
#	1: Ignore sentinel lines when comparing files.
#	Leo sets sentinel comment delimiters from the first line of each file.
#	This option has no effect if the first line is not a @+leo line.

# ----- Options affecting how Leo shows the results of file compares.
#	(Leo gathers statistics regardless of these options.)

limit_count = 9
#	0: Show lines regardless of the number of mismatches.
#	n: Stop showing lines after n mismatches.

make_whitespace_visible = 0
#	1: Show blanks as [ ] and tabs as [t]

print_both_lines_for_matches = 0
#	0: Print only the line of compare_file_1 when showing matching lines.
#	1: Print lines of both files when showing matching lines.

print_matching_lines = 0
#	1: Print lines that match using the print_both_lines_for_matches option.

print_mismatching_lines = 1
#	1: Print lines that do not compare equal to each other.

print_trailing_lines = 1
#	1: Print lines all lines in one file after an end-of-file is seen on the other file.</t>
<t tx="edream.110203163054.537">The new rules allow leo.py 3.1 to read and write .leo files more like leo.py 2.x when there is no leoConfig.txt file.  The scheme used in leo.py 3.0 meant that preferences were _never_ written to .leo files.  It's advantage was that all defaults were specified in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

I think the present scheme is more natural, but we shall see...

In effect, Leo sets and gets various options in the following order of precedence:

1. Use explicit settings in leoConfig.txt if they exist.

2. Use defaults for leoConfig.txt, but only if leoConfig.txt exists.  These defaults are found in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

3. Use settings in .leo files if leoConfig.txt does not exist.

4. If leoConfig.txt does not exist, and the .leo file does not specify a setting, use hard-coded settings in the various classes, just as leo.py 2.x did.</t>
<t tx="edream.110203163054.538">The @pagewidth, @tabwidth and @language directives could not have worked while tangling. Apparently nobody has every used these directives in @root trees!</t>
<t tx="edream.110203163054.539">The Flatten Outline command must use an escape convention so that it can distinguish between the "+" and "-" characters that denote a headline and any "+" and "-" characters that start a line of body text.

The old version of Flatten Outline inserted a backspace before _all_ "+", "-" and backspace characters.  The new version of Flatten Outline inserts a backspace before such characters only if they are the first non-whitespace character of a line.

This change affects the "file format" used by the Import Flattened Outline command.  If you import a file flattened with the old version of Flatten Outline, the new Import Flattened Outline will remove the inserted backspace only if it is the first non-whitespace character of the line.  In practice, this is unlikely to be a problem: you could just manually convert "\\", "\+" and "\-" to "\", "+" and "-" throughout the imported file.</t>
<t tx="edream.110203163054.540">The Open Python Window command now attempts to add IDLE's location to sys.path if import idle fails.

Bernhard Mulder contributed the code that made this improvement possible.

</t>
<t tx="edream.110203163054.541"></t>
<t tx="edream.110203163054.542">leo.py 3.0                                     July 16, 2002

This version is called 3.0 because it can optionally produce files that can NOT be read by the leo.py 2.x or the Borland version of Leo.  However, by default, leo.py 3.0 DOES produce files that all previous versions of Leo can read.

See the children of this node for full details.  The highlights:

- Support for many user options stored in leoConfig.txt, including, among others,
  fonts in all panes, colors for syntax coloring and default window size and position.
- Support for .leo files with XML types like "ISO-8859-1", controlled by a user option.
  Note: by default, Leo writes files compatible with previous versions of Leo.
- Powerful new Color and Font pickers, fully connected to user options.
- Added Toggle Split Direction command, under control of user options.
- Added autoscrolling in the outline pane.
- Windows open at the position in which they were saved.
- The size and position of new windows can be controlled with user options.
- Eliminated drawing problems while opening files.
- Improved syntax coloring for @comment plain.
- The Convert All Blanks and Convert All Tabs commands are now undoable.
- Leo warns and aborts if Python 2.2 or above is not running.
- The usual bug fixes.

At least one more version of leo.py is planned.</t>
<t tx="edream.110203163054.543">You now have a choice: you can configure Leo to please previous versions of Leo or to please XML parsers:

Leo now uses the xml_version_string configuration setting, if present, to override the UTF-8 setting used in all previous versions of Leo.  The default value of this setting is UTF-8, so by default leo.py will write files that may be read by any previous version of leo.py or the Borland version of Leo.

However, xml_version_string = ISO-8859-1 will produce .leo files that are more acceptable to XML parsers when those .leo files contain Unicode characters that are not found in the UTF-8 (Ascii) character set.  In any event, the choice of whether to please previous versions of Leo or XML parser is completely up to you. 

If the setting does not exist, whatever value is present in the .leo file will be written when the .leo file is written.  For new files, a value of UTF-8 will be used when this setting is not present.

Notice that this also affects what is written to the clipboard.</t>
<t tx="edream.110203163054.544"></t>
<t tx="edream.110203163054.545">This version supports many more options than before.  See leoConfig.txt for the full list.

Leo looks for leoConfig.txt in the same places as in leo.py 2.5.  If Leo does not find leoConfig.txt, This version will use defaults specified in tables defined in the section
	&lt;&lt; define default tables for settings &gt;&gt;
in leoConfig.py.  So it is now convenient to change settings in leo.py itself as well as in leoConfig.txt.</t>
<t tx="edream.110203163054.546">Including the split direction and split ration.

Leo now uses all configuration settings from leoConfig.txt.</t>
<t tx="edream.110203163054.547">If you drag a headline above or below the outline pane the outline pane will scroll automatically.  As before, Leo will cancel the drag if you release a headline anywhere but over another headline's icon.</t>
<t tx="edream.110203163054.548">You can specify colors for each syntax coloring construct using a color wheel or by choosing one of the standard Tk color names.  When a color becomes active Leo writes its value or color name to the log pane for your reference.  This is useful when setting coloring options in leoConfig.txt.</t>
<t tx="edream.110203163054.549">Using this panel should be self-explanatory (what you see is what you get) with the following exceptions:

1.  When a font becomes "active", the new font appears in the panes whose check boxes are selected.  A font becomes active when you double-click its name, or check or uncheck any checkbox.

It would be much better to have a font become active if you just select its name.  Alas, that is not possible due to a well-known gap in the Tk.Listbox class.

2. Font sizes must be greater than 0 and less than 100 for them to become in effect.

3. Choosing very _small_ values for font sizes may cause Leo's window to _expand_ its width.

4. When you choose OK or Cancel Leo writes the fonts presently active in each pane to the log pane for your reference.  This is useful when setting font options in leoConfig.txt.</t>
<t tx="edream.110203163054.550">This was a supremely irritating bug.</t>
<t tx="edream.110203163054.551">This command switches between vertical and horizontal orientations of the Leo window.  In the vertical orientation, the body pane appears below the pane containing the outline and log panes.  In the horizontal orientation, the body pane appears to the left the pane containing the outline and log panes.

leoConfig.txt specifies the default direction.  If leoConfig.txt does not exist, or does not specify the direction, the "vertical" orientation is used, just as in previous versions.

By default, the ratio of pane outline pane to the body pane is 0.5 in the vertical orientation and 0.3 in the horizontal orientation.  These two ratios may be changed using leoConfig.txt.</t>
<t tx="edream.110203163054.552">The @comment directive no longer suppresses syntax coloring.  Leo directives (but not doc parts) are colored when @language plain is in effect.  The user can, as always, suppress all coloring by using @nocolor.  The new rules are much more natural than the old, and much less confusing.</t>
<t tx="edream.110203163054.553"></t>
<t tx="edream.110203163054.554"></t>
<t tx="edream.110203163054.555">The old colorer colored all Leo directives blue, the same color as keywords in whatever language is current. I think the distinction between Leo directives and language keywords is useful.  Of course, you can control syntax coloring yourself by altering leoConfig.txt.</t>
<t tx="edream.110203163054.556">This message is printed to the console, not the log pane.  On windows, this may not always be visible.</t>
<t tx="edream.110203163054.557">Leo will convert underscores in the @comment directives to significant spaces.  For example,

@comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).</t>
<t tx="edream.110203163054.558"></t>
<t tx="edream.110203163054.559">This happened sometimes when using @comment.</t>
<t tx="edream.110203163054.560">Leo directives were mostly being colored using the colors for keywords.  This didn't show up because both were colored blue.</t>
<t tx="edream.110203163054.561">Only one window now appears when opening a .leo file, and the window is completely drawn before anything gets written to the log pane.</t>
<t tx="edream.110203163054.562">Added new code for Convert All Blanks and Convert All Tabs.

Fixed a bug that resulted in Convert Tabs being undoable.</t>
<t tx="edream.110203163054.563">This makes the panel much more convenient to use.</t>
<t tx="edream.110203163054.564"></t>
<t tx="edream.110203163054.565">leo.py version 2.5.1                            July 7, 2002

2.5.1 This version corrects crashers that affect undo/redo move commands.
Version 2.5 has been withdrawn.
Anyone using 2.5 should use 2.5.1 instead.

This is a major step forward to completing leo.py.  It adds significant new features and corrects many bugs.  Full details are found in the children of this node.  Here are the highlights, in approximate order of importance:

1. Leo supports tab widths properly, and negative tab widths cause Leo to convert tabs to blanks as you type.  Three new commands appear in the Edit Body menu: Convert Tabs, Convert All Tabs and Convert All Blanks.  Convert All Tabs and Convert All Spaces convert the entire selected tree.

2. Leo now allows you to override selected preferences using a configuration file called leoConfig.txt. Leo acts as before if this file does not exist.  An option in leoConfig.txt specifies whether leoConfig.txt is read-only.

3. The Preferences panel is now a modal dialog containing Ok, Cancel and Revert buttons.  This makes it clear what preferences are being set.

4. At long last, cut and paste work properly in all situations.  You can cut and paste between Leo and other applications, or between two different copies of Leo.

5. Added the Recent Files submenu to the File menu.  Very nice to have.

6. Fixed a number of bugs, including several crashers.  Fixed several bugs in the Import commands.  Leo will no longer abort reading if it detects an invalid directory name in the Default Tangle Directory in the Preferences panel.

leo.py is almost complete.  The only remaining tasks on my list are:

1. Make the Set Font... and Set Colors... commands functional.  This will be easy now that leoConfig.txt exists.
2. Fix the Javadoc bug.</t>
<t tx="edream.110203163054.566">The following are listed in the approximate order of their importance.  The marked nodes are particularly important.</t>
<t tx="edream.110203163054.567">Gary Herron suggested this changes.</t>
<t tx="edream.110203163054.568">These commands convert an entire tree.</t>
<t tx="edream.110203163054.569">This command converts leading tabs to blanks in a single node.</t>
<t tx="edream.110203163054.570">Previous versions of Leo ignored the tab width field!  This field is now fully functional.  </t>
<t tx="edream.110203163054.571">Leo converts tabs to blanks as you type when a negative tab width is specified.</t>
<t tx="edream.110203163054.572">The Preferences panel is now a modal dialog.  This solves a number of problems, both for the implementation and for the user.  It is now completely clear which preferences are being set, viz., the preferences for the window on top.  In addition, the Prefs panel now shows the name of the window whose preferences are to be set.

The Prefs panel now contains OK, Cancel and Revert buttons.  These are useful, and they are possible only because we have a modal dialog.</t>
<t tx="edream.110203163054.573">You may now cut and paste between Leo and other apps, or between two different copies of Leo.</t>
<t tx="edream.110203163054.574">The elements of this submenu are saved in leoConfig.txt, if present.

Leo adds files to this submenu even if leoConfig.txt is missing or read-only, but those additions will not be remembered unless leoConfig.txt is present and writable.</t>
<t tx="edream.110203163054.575"></t>
<t tx="edream.110203163054.576"></t>
<t tx="edream.110203163054.577"></t>
<t tx="edream.110203163054.578">1. Importing the following script

class C:
    def __init__(self):
        pass

created an outline with class C appearing in two nodes.

2. Importing the following file created orphan nodes for declaration.

import sys # This line becomes an orphaned node
class C:
    xyz = 'xyz' # This line becomes an orphaned node
    def __init__(self):
        pass

3. Importing a Python file containing classes without methods resulted in nested classes. There is still a minor problem:  The following

class A:
	pass

puts the "pass" in a section called &lt;&lt; class A declarations &gt;&gt;.  This is not easy to fix: you will have to correct it by hand.

4. Improved the Import to @root command.  Added @root &lt;filename&gt; to the body text of the root of tree and eliminated @language and @others directives.</t>
<t tx="edream.110203163054.579">This is important, because it means that invalid entries in, say, the Default Tangle Directory preference will no longer abort an attempted read.</t>
<t tx="edream.110203163054.580"></t>
<t tx="edream.110203163054.581">This would happen if the Default Tangle Directory did not exist in the Prefs panel.</t>
<t tx="edream.110203163054.582">This command always crashed, perhaps due to a reversion.</t>
<t tx="edream.110203163054.583">The crash happened if the Import command was executed in a new, unsaved file.

The fix was to the directory logic in import.scanAllDirectives.</t>
<t tx="edream.110203163054.584"></t>
<t tx="edream.110203163054.585"></t>
<t tx="edream.110203163054.586">The bug involves only the clone mark itself: nodes have always been properly joined.</t>
<t tx="edream.110203163054.587">Gary Herron reported this bug and told me how to fix it. This change is to the default file extension field of file dialogs.  It seems to have no effect on Windows. Apparently this makes a difference in Linux...</t>
<t tx="edream.110203163054.588">These commands no longer change the file name associated with a window if the user cancels the Save or Save As dialog.</t>
<t tx="edream.110203163054.589">This involved changing the documentation for the Demote, Insert Headline, Extract Headline, Syntax Coloring... and Font... commands.  Removed documentation for the Open/Close Log Window command.</t>
<t tx="edream.110203163054.590"></t>
<t tx="edream.110203163054.591">leo.py version 2.4                             June 20, 2002

This version fixes some annoying bugs and adds some nice features.  The children of this node contain full details.

1. Leo now properly highlights the headline of a newly created node.  Similarly, the Edit Headline command (control-H) now works.  Double-clicking in a headline now does what you would expect: it selects the word under the cursor.  Similarly, triple-clicking now selects the entire headline.  Also fixes several other minor bugs.

2. Drag and drop.  You can now reorganize outlines by dragging nodes around.  You must drag from a node's headline and release on another node's headline.  See a child of this node for complete details.

3. You can now open .leo files in leo.py by double clicking on .leo files.  You must associate leo.py with .leo files.  See a child of this node for detailed instructions about how to do this.

4. Improves error recovery when there are errors writing .leo files.

5. Updates this file to match the documentation of Leo's web site.  At long last, Leo's documentation is complete.</t>
<t tx="edream.110203163054.592">1. Fixed a bug in app.finishCreate that caused Leo to take an exception on MacOS X.

2. Leo now properly highlights the headline of a newly created node.  Similarly, the Edit Headline command (control-H) now works properly.

3. Removed a useless assert in st_enter_root_name that could fail under unusual circumstances.</t>
<t tx="edream.110203163054.593">When writing a .leo file, say f.leo, Leo now attempts to create a backup file called f.leo.back.  If there is an error while writing f.leo, Leo will restore f.leo from f.leo.back.  Note that Leo will write derived files correctly even when there is an error writing the .leo file.</t>
<t tx="edream.110203163054.594">New in leo.py v2.4: You may drag an node (including all its descendents) from one place to another in an outline.  To start a drag, press the main (left) mouse button while the cursor is over the icon for a node.  The cursor will change to a hand icon. If you release the mouse button while the hand cursor is above the icon for another node, Leo will move the dragged node after that node.  If you release the mouse button when the hand cursor is not over an icon, Leo will print "not moved" and leave the outline pane as it is.  This can result in the dragged node not being visible on the screen, but it seems less alarming not to force the current node to become visible as that would undo any scrolling that has just been done.

New in leo.py 3.0: If you drag outside the outline pane, the outline pane will scroll automatically.

Leo scrolls the outline pane as the result of mouse-moved events, so to continue scrolling you must keep moving the mouse.  I experimented with scrolling the outline pane whenever the cursor is dragged outside it, but the results were not good.  There was a noticeable delay between releasing the cursors and halting the scrolling.  The present code is simpler and more likely to work on all platforms.

Leo only allows dragging from one icon to another.  In particular, you can't move a node to the first child of another node unless that node is already expanded.   I experimented with automatically open nodes when the cursor moves over an unexpanded node with children.  However, this was confusing and alarming.  It seems best to expand and contract nodes explicitly.</t>
<t tx="edream.110203163054.595">leo.py version 2.3                             June 5, 2002

This version fixes a minor problem with Leo.

1.  The code that reads and writes @file nodes now uses the directory containing the .leo file as a default when the Default Tangle Directory setting is empty in the Preferences panel.  This is a reasonable default because derived files are most often created in the same directory as the .leo file.  BTW, the Tangle and Untangle commands have used this convention for a long time.

Note: This default allows us to distribute LeoPy.leo without specifying a directory in the Preferences Panel.</t>
<t tx="edream.110203163054.596">leo.py version 2.2                             June 1, 2002

The version fixes two bugs that happen rarely and can cause loss of data when they do happen.

1.  In certain circumstances leo.py v2.1 would delete most of an outline when a node was moved in front of the previous root node!

2.  All previous versions of leo.py will crash when saving body text containing unicode characters.  This could occur as the result of cutting and pasting text from another application into the body pane.  Leo.py now writes body text containing unicode characters using Python's u-prefixed notation.  That is, the body text is written as: u'escaped_text'  where escaped text replaces unicode characters not in the ascii character set by escape sequences of the form \uxxxx.  The result contains nothing but ascii characters, so leo.py will have no problem reading it.  Naturally, compilers and other tools may not understand Python's notation, so you may have to convert escaped text to something that your tools can understand.

3.  This file, LeoDocs.leo, now more closely matches the documentation on Leo's web site.</t>
<t tx="edream.110203163054.597">leo.py version 2.1                             May 16, 2002

This version of Leo adds Import and Export commands and fixes several bugs:

1. All Import and Export commands now work. Several of these commands are found only in Leo.py.  Some of these commands may be of beta quality.

I use Import commands mainly for studying other people's code.  Be wary of generating source files from trees generated by the Import commands.

2. Fixed a bug that caused Leo to crash when a node was moved up in front of the previous root node.

3. Fixed several bugs in the syntax colorer.  One of these bugs caused Leo to crash when handling CWEB.

4. Leo now colors strings green.</t>
<t tx="edream.110203163054.598">I use Import commands mainly for studying other people's code.  Be wary of generating source files from trees generated by the Import commands.

The Remove Sentinels command can "clean" files for publication or walk-throughs.  You can also use the Remove Sentinels command to prepare files for comparisons.  For example, one could study a file, say f.py, as follows:

1. Use the Import Files command to create an @file tree, say @file f2.py, for study.  Changing the name to f2.py ensures that saving the .leo file won't destroy the original file.

2. Use the Remove Sentinels command to create a file f3.py.  Use a file comparison program to ensure that f1.py is identical to f3.py.</t>
<t tx="edream.110203163054.599">Fixed several bugs that caused Leo to hang when moving an outline up before the previous root node.</t>
<t tx="edream.110203163054.600">Fixed a bug that caused Leo to hang when syntax coloring noweb code with the CWEB syntax colorer.

The syntax colorizer now handles Python triple strings and C preprocessor directives properly.

Leo now colors strings with the same green used by IDLE.  I think this color looks very good.

Improved the syntax coloring for CWEB.</t>
<t tx="edream.110203163054.601">leo.py version 2.0                             March 4, 2002

leo.py v2.0 and Borland Leo v2.6 are being released simultaneously.  I urge all users of Leo to upgrade to one or both of these versions.  Note: the Untangle commands of both v2.0 and v2.6 should be considered beta quality.  Please report any problems with Untangle ASAP.

This is an important milestone in Leo's history, for several reasons:

1. For the first time, leo.py (v2.0) and the Borland Leo (v2.6) are functionally identical.  In particular, their respective Tangle commands produce identical output.

2. All "mission critical" aspects of leo.py are now complete: only the Import commands remain unfinished. leo.py v2.0 adds unlimited Undo/Redo, Untangle and full syntax coloring.  Unlimited Undo/Redo are reason enough to upgrade to v2.0.

3. leo.py v2.0 and Borland Leo v2.6 introduce an optimized format for derived files: both versions remove blank lines from between sentinel lines.  This is an upward compatible change in the format of derived files: leo.py v2.0 and Borland Leo v2.6 can read derived files from all previous versions of Leo, but previous versions of Leo can not read derived files without blanks lines between sentinels.

See the children of this node for full details.</t>
<t tx="edream.110203163054.602">leo.py v2.0 optionally can remove blanks from between sentinel lines in derived files.  This is an upward compatible change in the format of derived files: leo.py v2.0 can read derived files from all previous versions of Leo, but previous versions of Leo can not read derived files without blanks lines.

Removing blank lines requires a new kind of sentinel, the "verbatimAfterRef" sentinel.  This allows Leo to handle comments following section references that would otherwise be treated as sentinels themselves.  For example:
   
   &lt;&lt; section &gt;&gt; #+others
   
Leo removes blanks lines between sentinels by default.  To cause Leo not to remove blank lines do the following.  In the section called &lt;&lt; initialize atFile ivars &gt;&gt; in leoAtFile.py, change:

	self.suppress_newlines = true
to
	self.suppress_newlines = false

Note: leo.py v2.0 can read derived files without blank lines between sentinels regardless of the setting of self.suppress_newlines.
</t>
<t tx="edream.110203163054.603">leo.py supports unlimited Undo and Redo.  All outline operations and all typing operations may be undone and redone.  Undo state persists even after Saves.  Even the Change All command is undoable.  Only the "Read @file Nodes" command is undoable; it clears the entire undo state. This command raises a dialog to allow the user to cancel.

Think of the actions that may be Undone or Redone as a string of beads.  A "bead pointer" points to the present bead.  Performing an operation creates a new bead after the present bead and removes all following beads.  Undoing an operation moves the bead pointer backwards; redoing an operation moves the bead pointer forwards.  The Undo command is disabled when the bead pointer moves in front of the first bead; the Redo command is disabled when the bead pointer points to the last bead.

</t>
<t tx="edream.110203163054.604"></t>
<t tx="edream.110203163054.605">leo.py syntax colors all languages mentioned in the Preferences Panel.</t>
<t tx="edream.110203163054.606">1. Show Invisibles command works in @nocolor mode.

2. @unit, @root, @nocolor and @color now terminate doc parts.

3. Three characters were colored blue at the start of a section def in:

  &lt;&lt;name&gt;&gt;=
  
This didn't show up if there is a space after the &lt;&lt;.</t>
<t tx="edream.110203163054.607">Leo adds extra space at the end of headlines so that headlines now have enough room to show all text.  This works around an apparent Tk bug.</t>
<t tx="edream.110203163054.608"></t>
<t tx="edream.110203163054.609">The Untangle command is beta quality. Please make backups before untangling.</t>
<t tx="edream.110203163054.610">leo.py v2.0 fixes two bugs present in Borland v2.5 and fixed in Borland v2.6:

1. Untangle did not work properly for languages like Perl and Python that do not have block comments. 

2. Untangle did not recognize @ on a line by itself as the start of a doc part.</t>
<t tx="edream.110203163054.611">@c now works the same as @code.  This makes the syntax colorers agree with what the Tangle commands actually do.  Previously, the syntax colorers indicated that everything following an @c was code, while the Tangle commands placed everything following an @c in the doc part!</t>
<t tx="edream.110203163054.612">Previous versions of untangle silently trimmed trailing lines from all nodes, which seems rude.</t>
<t tx="edream.110203163054.613">The font size for code text is now 12 on Linux.

Changed code so that the path to the Icons folder is computed correctly on all platforms.</t>
<t tx="edream.110203163054.614">leo.py version 1.0                             February 10, 2002

Version 1.0 adds many new features and fixes several bugs.  I recommend that all users of leo.py upgrade to this version.  This version deserves the number 1.0; it has no known bugs.

Here are the highlights of this release.  See the children of this node for details.

1. Fixed bugs: the Tangle All and Tangle Marked commands didn't work at all. Fixed several bugs in the Find and Change commands.  The "Suboutline Only" option now applies to the Search All and Change All commands.  Settings in the Preferences Panel now "stick" properly to the currently selected window.  Fixed many minor bugs.

2. leo.py now re-marks @file trees as dirty if errors are found while writing those trees.  This makes it difficult to write derived files that will be out-of-synch when read again.

3. New commands and features:  Added the Revert, Select All, Delete, Sort Children, Sort Siblings, Contract Parent (very useful!) and Toggle Active Pane commands, and all commands in the Edit Body menu, and all the Go To commands in the Move/Select menu. The Show Invisibles commands is ugly, and useful nonetheless.

The Edit Body commands work much more reliably than the similar commands in the Borland version of Leo.  You may now specify Python scripts rather than .bat files in the Preferences panel. Added a way, albeit clumsy, to cut and paste nodes between Borland Leo and leo.py.  When syntax coloring Python text, leo.py increments the auto-indentation by one tab after a trailing colon.  This provides a subtle reminder to add such colons.

4. leo.py handles events and shortcuts properly.  The shortcut for the Insert Node command is now Control-I, as it is in the Borland version of Leo.  Worked around a TK bug that prevented double-clicks from properly selecting words.  leo.py enables and disables all menu items properly.</t>
<t tx="edream.110203163054.615">Removed the Print and Page setup commands because Tk provides no support for printing.  This is not significant: we can use the export commands to create text files.  These text files can then be formatted and printed as desired.

The following commands remain unfinished.  They will be finished in this order:

1. Untangle commands. 
	
2. Import/Export commands.

3. Unlimited Undo and Redo.

4. Toggle Split Direction, Cascade and Recent Windows commands.

5. Font Panel and Syntax Coloring commands.</t>
<t tx="edream.110203163054.616">It should be possible to cut a node or tree in Borland Leo and paste it using the Copy Node command in leo.py.  At present, cutting and pasting trees between applications can only be done indirectly.  Do this:

1. Copy the tree in Borland Leo using the Copy Node or Cut Node command.
2. Paste the tree into empty body text of leo.py using the Paste command from the Edit menu, _not_ the Paste Node command from the Outline menu.
3. Select all the body text and choose Copy or Cut from the Edit menu.
4. Move to the tree view, and choose Paste Node.

I hope to make this unpleasantness go away soon.</t>
<t tx="edream.110203163054.617">1. Fixed the Tangle All and Tangle Marked commands.  They always crashed.

2. The Change command did not work in headlines because of a reversion in how headline text is selected.

3. All event handlers now return "break".  This prevents further event handling and allows leo.py to handle events properly.  This cleared up the last major mystery in leo.py.

4. Settings in the Prefs Panel now "stick" to windows.  That is, they change when the user selects a new Leo window.  In particular, the Default Tangle Directory is restored properly.  This is important, as otherwise the Tangle commands might write files to the wrong place.

5. Removed calls to trace during shutdown.  In general, it is not possible to call app() during shutdown because the app object may no longer exist.

6. @others was not syntax colored properly if it was indented.</t>
<t tx="edream.110203163054.618">1. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this bug because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.

2. Cutting and pasting between applications can only be done indirectly.  See the node called
"How to copy an outline from Borland Leo to Leo.py".</t>
<t tx="edream.110203163054.619">leo.py version 0.08                             February 3, 2002

Version 0.08 adds important new features and fixes several bugs.  All users of version 0.07 should upgrade to this version.  This code seems solid, and significant bugs may remain.  Note: this code has been tested only on Windows XP.  Please report any problems with Linux or Macintosh.

This is the first version of Leo to feel as smooth as the Borland v2.5. leo.py is now less buggy than v2.5; the Borland version will soon be upgraded to match leo.py.

Here is a summary of new features.  See the children of this node for full details.

1. The Find and Change commands are fully functional.  These commands support Tk's "advanced regular expressions" when the "pattern match" option is checked.  Tk's regular expressions are documented at:

  http://tcl.activestate.com/man/tcl8.4/TclCmd/regexp.htm

2. The Tangle commands work; leo.py now supports @root trees.  The next release will support the Untangle commands.  Converting the Untangle code to Python is almost complete.

3. Leo now ensures that the currently selected headline is always visible, scrolling the outline pane as needed.

4. Improved Leo's memory management and eliminated several serious bugs.  One bug caused errors while reading @file trees.  Eliminating this is a huge step forward.  This bug exists in the Borland version of Leo and will be fixed soon.

5. Leo now underlines undefined section references.  Added support for hyperlinking, but disabled hyperlinking because it is not very useful without browser navigation buttons.</t>
<t tx="edream.110203163054.620">leo.py handles Find and Change commands much more smoothly than does the Borland version of Leo.  Indeed, I plan to rewrite the Borland code to match the code in leo.py.

In general, leo.py handles the Find and Change commands more smoothly than does the Borland version of Leo.  Note: the node that "anchors" wrapped searches is the current node when any change is made to the Find panel.  The anchor is recomputed after a wrapped search fails.

Changed the meaning of a Find panel setting from "batch" to "context".  This will be changed in a future Borland version.  In the meantime, setting the "context" option in leo.py will set the "batch" option in the Borland version.

The "context" option affects only the "Find All" and "Change All" commands.  When this option is in effect, more context information is printed when matches are found.

The "reverse" option affects all Searches and Changes, both those initiated from the Find Panel itself, and those initiated from menu commands.  In particular, F3 will find the previous search if the "reverse" option is in effect.</t>
<t tx="edream.110203163054.621">The Tangle command has passed significant tests, and bugs may remain.  Be warned.

leo.py's Tangle command produces output that is slightly different from Leo v2.5. The differences are insignificant; here is the complete list:

1. The header line, i.e., the first comment line of the tangled file: leo.py produces forward slashes in the path name, Leo v2.5 produces back slashes.

2. Leading whitespace: leo.py produces "optimized" leading whitespace.  leo.py removes blanks if they do not affect the visual appearance of whitespace; this depends on the tab width specified in the Preferences Panel.  Leo v2.5 copies leading whitespace exactly.  The leo.py way is preferable; it will produce output acceptable to Python's tabnanny regardless of tab width used while running Python.

3. Trailing blanks lines in body text: leo.py removes all trailing whitespace.  Leo v2.5 does not.  Conceivably, leo.py might have to change to make the Untangle command work properly.  More likely the leo.py way is just better.</t>
<t tx="edream.110203163054.622">Underlining "live" links clutters the screen too much, and hyperlinks from section references to section definitions isn't very useful without the standard "back" and "forward" buttons typically found in web browsers.  For these reasons, I have disabled hyperlinking.

To enable hyperlinking, just set:

	self.use_hyperlinks = true
	
in color.__init__ in the @file leoColor.py tree.</t>
<t tx="edream.110203163054.623">1. Fixed several bugs involving cloned headlines.  One bug caused cloned headlines not to be updated in synch.  Another bug caused @file trees not to be marked as dirty under certain conditions.

Both bugs could have caused read errors while reading @file trees, so fixing these bugs is a big step forward.  I have experienced no read errors since fixing these bugs.  A huge step forward.  This bug exists in the Borland versions of Leo and should be fixed ASAP.

2. There was a big performance bug lurking in the tree code that became apparent during testing of the Find and Change commands.  Closing a window could take almost a minute if the tree had been redrawn many times.  Old widgets were never deleted until the window was closed.  This may be a problem with tkinter, and the workaround was straightforward.

3. Fixed a bug in the "Save To" command.  After doing a Save To, a following Save command used the Save To file name!  This explains why some saves "didn't take".

4. Fixed a bug in the Save commands.  Cancelling a Save dialog did not work: instead it wrote a file called ".leo".  I am not sure whether this bug occurred in previous releases. 

5. All Save commands now always recompute file indices.  This old logic accomplished very little, and introduced needless differences between the various kinds of Save commands.

6. Made file and path name processing more portable.  Removed all calls to os.chdir().

7. Fixed a bug that caused a control-d to delete a character in the body pane when the Move Down command didn't do anything, i.e., when the presently selected node was the bottom node on the screen.</t>
<t tx="edream.110203163054.624">1. Used Tk.Text widgets in headlines rather than Tk.Entry widgets.  This allows the Find/Change commands to search headlines.  Control-k no longer deletes text following the cursor in headlines.

2. Improved the performance of screen updates and markedly reduced flicker in the body pane.

3. Found a way to handle keystrokes without knowing the status of the control and alt keys.  The idle event handlers now ignore the actual keystrokes in most cases, and take action solely based on whether the headline or body text has actually changed as the result of those keystrokes.  If not, we can assume that a command has been entered and we do not set the dirty or changed bits.

4. Replaced es_newline global with app().log.es_newline, i.e., frame.es_newline.  This is better than before because each log stream now has its own newline count.

5. Reduced width of the log pane to give more space to the tree pane.

6. The LeoPy folder now contains a dummy file called __init__.py.  This file marks the LeoPy folder as a potential package.

7. Added several new functions to the file leo.py.  These are useful for invoking leo.py from a Python interpreter.  See the section "How to Install &amp; Run Leo" for details.</t>
<t tx="edream.110203163054.625">Previous version of leo.py did not release memory when windows close.  This version does.

Memory management is remarkably easy in Python/Tk.  Added __del__ routines and corresponding destroy routines to the frame, vnode and tree classes.  The destroy routines eliminate circular references between objects. The __del__ routines do nothing except print debugging traces; we know that all references to an object have been removed when its __del__ routine is called.

Added app.deleteOnClose ivar to control memory management.  When true, Leo deletes all frame objects when a frame closes.  This is always true at present.

Fixed a memory botch: previously a dummy vnode was allocated for every vnode created while reading files.</t>
<t tx="edream.110203163054.626">Starting with this release, you will see trace statements throughout the code.  The trace function is defined in leoUtils.py; trace implements much of the functionality of my Sherlock tracing package.  Traces are more convenient than print statements for two reasons: 1) you don't need explicit trace names and 2) you can disable them without recompiling.

In the following examples, suppose that the call to trace appears in function f.

trace(string) prints string if tracing for f has been enabled.  For example, the following statement prints from s[i] to the end of the line if tracing for f has been enabled.

	j = skip_line(s,i) ; trace(s[i:j])

trace(function) executes the function if tracing for f has been enabled.  For example,

	trace(self.f2)

You enable and disable tracing by calling init_trace(args).  Examples:

	init_trace("+*")         # enable all traces
	init_trace("+a","+b")    # enable traces for a and b
	init_trace(("+a","+b"))  # enable traces for a and b
	init_trace("-a")         # disable tracing for a
	traces = init_trace("?") # return the list of enabled traces

If two arguments are supplied to trace, the first argument is the "tracepoint name" and the second argument is the "tracepoint action" as shown in the examples above.  If tracing for the tracepoint name is enabled, the tracepoint action is printed (if it is a string) or executed (if it is a function name).

"*" will not match an explicit tracepoint name that starts with a minus sign.  For example,

	trace("-nocolor", self.disable_color)</t>
<t tx="edream.110203163054.627">Rewrote the code that computes file names.  This should have two beneficial effects:

Note:  This code has only been tested on Windows XP.

1. The code should be more portable.  I've used os.path.join throughout to concatenate parts of filenames, and this should handle differences involving path separators on different platforms.

2. The code no longer calls os.chdir().  The "current application directory" changes only as the result of completing file open and save dialogs.  In particular, @path, @root and @file do not change the current application directory.

3. Used leo.__file__ to get the directory from which leo.py was loaded.  This seems to be reliable, though it has only been tested on Windows XP.</t>
<t tx="edream.110203163054.628">The following features of leo.py will be incorporated into the Borland version 2.6 of Leo:

1. Improve leading whitespace handling in Tangle.

2. Fix clone bugs (rewrite vnode::setDirty).  These bugs can cause errors while reading @file nodes.

3. Improve Find/Change commands. Change "batch" to "context".  This will make the Preferences Panel work identically in both programs.

4. Always recompute file indices and compute file indices.  This will make derived files produced by v2.6 identical to the files produced by leo.py.

5. Make sure all file names end in .leo.</t>
<t tx="edream.110203163054.629">I urge anyone using leo.py upgrade to this version.  This is the first version of leo.py that has been thoroughly tested.

See the children of this node details about this release.  Here are the highlights:

1. Fixed many bugs, including a bug that can cause body text to be lost when creating a new headline.

2. The Python window now works. You can now run Python scripts from within leo.py!

3. Added a script to convert Leo files from Leo 1 to Leo 2 format.

4. @nocolor and @color are now inherited properly from ancestor nodes.

5. Added Leo Documentation to Help menu.  This command opens LeoDocs.leo.
	
6. Added auto indent to body pane.

For even more details, see the diary entries for January 6-9 in LeoPy.leo.

See the To Do lists in LeoPy.leo for a list of unfinished features.  The primary unfinished features are the Find/Change commands, preferences settings and the Tangle/Untangle commands.</t>
<t tx="edream.110203163054.630">This is the first version of leo.py that has been heavily tested.  About 70 percent of my work on leo.py has been done using leo.py itself.   I know of no remaining bugs that can cause data to be lost.</t>
<t tx="edream.110203163054.631">I have concentrated on removing all significant irritations encountered while using leo.py.  Far fewer still remain than before.  Among the remaining irritations:

1. Syntax coloring happens at "idle time", that is, after all events have been handled.  This means that characters are initially colored black, then changed to another couple after an obvious delay.  The obvious event-handling code does not work.  Perhaps using a "virtual event" may work.

2. Keystrokes that should initiate commands _also_ get passed to widgets.  I am hoping to find a way around this, and it may take a bit of work.  The two biggest offender:  Control-k while editing a headline deletes from the cursor to the end of the headline (in addition to creating a new node!)  Control-i gets passed to the body pane as a tab.

3. The border around the tree pane gets over-written by headlines.  I'm not sure how to fix this: it is certainly a Tk bug.</t>
<t tx="edream.110203163054.632">Fixed a bug that can cause body text to be lost when creating a new node.</t>
<t tx="edream.110203163054.633">Choosing Open Python Window brings up IDLE, the standard Python IDE, from which scripts may be run and debugged.

Note: The path to idle.py must exist in sys.paths.  For Python2.1 on windows, this path will typically be \Python21\Tools\idle  If this path does not exist, a message will be sent to the log pane.  The usual way to add a path to sys.paths is to modify the sitecustomize.py file.

Changed names of several vnode and commands methods to make them compatible with the scripting documentation on Leo's web site.   You may now run any script that runs on Borland Leo on leo.py.

When running scripts from leo.py, you may refer to any method or instance variable (attribute) in the code for leo.py.  If you want to run those scripts on Borland Leo you should restrict yourself to the methods documented in the Scripting chapter of Leo's online documentation.</t>
<t tx="edream.110203163054.634">To convert an @root tree to an @file tree, choose the root of the tree to be converted, then do the following in the Python window:

	import c2py
	c2py.leo1to2()
	
This script makes numerous changes throughout the tree.  It does not, however, change @root to @file, or insert the needed @others directives.  You must do that by hand.</t>
<t tx="edream.110203163054.635">At long last it is possible to open this file, LeoDocs.leo, from the help menu.

This command will work only if LeoDocs.leo is located in the directory in which leo.py exists.</t>
<t tx="edream.110203163054.636">The body pane now has auto-indent on at all times.</t>
<t tx="edream.110203163054.637">leo.py version 0.06 (alpha)                     December 20, 2001

This version fixes several minor problems that prevented leo.py from running on Linux.  There is no need to upgrade to this version if leo.py works on your system.  This version is neither more nor less stable than version 0.05.  This file, LeoDocs.leo, has also been improved substantially.

There still may be problems running leo.py on Linux.  You may be able to fix those problems yourself after reading this file... I'll be on vacation until about January 8.  I may be able to answer questions on Leo's SourceForge site, and I'll make no code changes until then.

Problems fixed:

1.  Removed call to print_stack() in es() logic.  If there are problems during initialization this logic printed "Null log" and then printed a stack dump.  This dump was more confusing than helpful.

2.  Changed "darkblue" to "DarkBlue".  The standard colors known to Tk are listed at
	http://tcl.activestate.com/man/tcl8.4/TkCmd/colors.htm
	
If you have more problems with unknown colors, please use a color listed above.

3.  Eliminated some accelerators (Linux only).  You may take an exception in createAccelerators() in leoFrame.py if Linux does not support the accelerators defined in one of the following sections:

  &lt;&lt; control key bindings &gt;&gt;
  &lt;&lt; alt key bindings &gt;&gt;
  
Just comment out the relevant entry.  Please let me know which accelerators don't work.  I can add platform-specific code to deal with them.

4.  Added loaddir code to leo.py.  Leo tries to guess where leo.py was loaded from.  If this doesn't work leo may take an exception in leo.py.

As a temporary hack, please set loaddir correctly in the following code at the start of leo.py:

  # loaddir should be the directory that contains leo.py
  if sys.platform=="win32":
    loaddir = "c:\\prog\\LeoPy\\"
  else:
    loaddir = "LeoPy"
	
5. Removed bullet 0x95 characters from this file. They don't show up well on Linux.

6. In leoTree.py, changed the filenames from x.gif to x.GIF.  Linux is more picky about case in filenames than Windows.

Edward K. Ream
December 20, 2001</t>
<t tx="edream.110203163054.638">leo.py version 0.05 (alpha)                      December 17, 2001

This version of Leo marks a major milestone in Leo's history.  leo.py is the first functional version of Leo written completely in Python and Tkinter, Python's interface to the tcl/Tk system.

leo.py is quite useable. leo.py should work on any machine with recent Python and tcl/Tk interpreters.  This version of Leo was created using Windows XP, Python 2.1 and tcl/Tk 8.3.

Warning: This version is alpha quality.  Use extreme caution: please save your work often and make full backups of all .leo files and derived files.

Please read this node's children before sending bug reports or feature requests.  Send all bug reports to Leo's SourceForge web site at: http://sourceforge.net/projects/leo/

Edward K. Ream</t>
<t tx="edream.110203163054.639">I have been happily using leo.py to develop itself for the last three days without serious problems.  leo.py reads and writes all its source files exactly as does the Borland version.  This is an important test, and significant errors may remain.

Performance on a 1.2 Ghz Pentium is good to excellent.  Drawing the screen happens quickly, smoothly and without flicker.  Expanding and contracting nodes is usually excellent, and slows when a many nodes have been expanded.  Syntax coloring appears instantaneous, even with an unsophisticated algorithm.  Loading LeoPy.leo files takes about 3 seconds. This could be improved by using Python's XML classes.</t>
<t tx="edream.110203163054.640">You must have recent versions of Python and tcl/Tk installed on your machine.
Download Python from http://python.org/
Download tcl/Tk from http://tcl.activestate.com/software/tcltk/

After installing Python and Tk, run Leo double clicking the file leo.py in the LeoPy folder.  On Windows this will bring up a Leo window and a black Python interpreter window.

The LeoPy folder contains all files in this distribution.  leo.py is the main source file; run Leo by double clicking leo.py.  The Python interpreter will create corresponding .pyc files as .py files are imported by leo.py.

LeoPy.leo is the master source code file; all .py files were derived from LeoPy.leo.  c2py.py and leoCompare.py are tools that should be run from a Python interpreter.
</t>
<t tx="edream.110203163054.641"></t>
<t tx="edream.110203163054.642">Functional Commands and Features

    Open, Save, Save As, Save To commands.
    Read @file Nodes command.
    Read Outline Only command.
    Write Outline Only command. Warning: this has not been tested thoroughly.
    Insert Node, Delete Node and Clone commands.
    Move Node Right/Left/Up/Down commands.
    Cut Node, Copy Node, Paste Node commands.
    Syntax coloring for Python only.
    The @color and @nocolor directives, but these are not inherited yet.</t>
<t tx="edream.110203163054.643">Unfinished Commands and Features:

	Revert.
	All Tangle and Untangle commands.
	All Import commands.
	All Find and Change commands.
	Sort Children command.
	Toggle Split Direction, Toggle Active Pane and Cascade commands.
	Auto indent in the body pane.
	The Preferences panel is semi-functional: see note one below.
	The Find panel is non-functional.
	The Python scripting window is non-functional.
	Syntax Coloring Options and Font Options windows are not ready yet.
	@color and @nocolor directives are not inherited yet.

Notes:

1. The Preferences panel is partly functional.  The default target language option has no effect: syntax coloring is for Python only.  Tab width can not be changed; tabs are 8 characters wide.

2. Menu items are not yet dynamically dimmed and undimmed.  Some non-functional commands have undimmed menus.  Keyboard accelerators work even for dimmed menus.

3. Scripting Leo is not possible yet.  You can't control Leo from the Python interpreter because control passes to the Tk event loop.

4. Leo's Save commands do not yet save the information about which node was visible at the top of the tree.

5. The Save/SaveAs/SaveTo dialogs don't handle shortcuts to folders properly; they try to replace the shortcut with the .leo file.

6. Initialization code in leo.py computes the directory from which Leo was loaded using argv[0].  I am not sure this is proper, though I have had no problems recently.  Tree icons will not load properly if argv[0] does not specify this directory.  If the path is invalid Leo will print: os.chdir failed: `dir`

7. The tree class does not automatically ensure that the current node is visible after an outline operation.

8. The font used in the body pane is not great.  I hope to improve it.

9. Headline text is sometimes obscured.
</t>
<t tx="edream.110203163054.644">leo.py already feels less buggy than the wxWindows versions of Leo.  Rewriting Leo in Python and Tkinter has greatly improved the code. Further improvements are possible.  BTW, work began in earnest on this version of Leo in late October, 2001.  It's been a great month.

The following problems have resisted my initial attempts at solving them.  Any help from Tk experts would be appreciated:

1. Window icons are the Tk icon, not the nifty Leo icon.  Really, there _must_ be a way to do this!

2. Can variable-width tabs can be done in Tk?  If not, Leo may have to convert tabs to blanks as specified by the preferences panel.

3. Cut, copy and paste work in the log and body panes using Control-X, Control-C and Control-V keys.  However, there are no Cut, Copy or Paste menu items in the Edit menu.  Is it possible to send simulated keystrokes to a text widget?

4. Some menu accelerators do not seem to be available in Tk.  In particular, many of the items in the submenus of the Outline menu have no accelerators yet.  These commands are useful only if they can be chosen from the keyboard rather than the menu.

5. The border of the tree control is gray.  It can be overwritten by large headlines.  This appears to be a Tk or Tkinter bug; I haven't found any way to eliminate the border or color it white.

6. There doesn't seem to be a way to select all the headline text when editing starts.  The click that starts editing always clears the selection.

7. Changing the type of leo.py to .pyw doesn't seem to work.

8. A message flash briefly on the screen when leo.py exits, too fast to read. These messages do not appear when invoking leo.py from the Python interpreter.  They probably would be visible in a Linux window.</t>
<t tx="edream.110203163054.645">It will be much easier to make such improvements to leo.py than to previous versions of Leo. Here is my list of new things to do:

1. Create "hyperlinks" from section references to section definitions.  This will happen in the next release.

2. Add automatic "tab nanny" checking and full syntax checking of Python body text.

3. Build a file/directory comparison window using code in leoCompare.py.

4. Build a Python debugger into Leo.  Python provides excellent hooks for debugging and tracing.  Python's stand-alone IDLE debugger doesn't seem to work well with the Tk command loop.

5. Expand Leo's file format to take advantage of the power of Tk text widgets.
</t>
<t tx="edream.110203163054.646"></t>
<t tx="edream.110203163054.647">Leo Borland version 2.6                             May 15, 2002

This version fixes a bug that can cause errors while reading derived files.  Earlier versions do not ensure that clone indices in derived files are distinct.

I recommend that all users of the Windows version of Leo upgrade to this version.</t>
<t tx="edream.110203163054.648">Leo Borland version 2.6                             March 4, 2002

leo.py v2.0 and Borland Leo v2.6 are being released simultaneously.  I urge all users of Leo to upgrade to one or both of these versions.  This is an important milestone in Leo's history,  For the first time, leo.py (v2.0) and the Borland Leo (v2.6) are functionally identical.  In particular, their respective Tangle commands produce identical output.

Borland version 2.6 fixes major problems and contains numerous changes to make it fully compatible with leo.py v2.0.  Highlights of Borland v2.6:

1. Fixes bugs that caused spurious errors while reading @file trees.  Such errors can destroy clone links.

2. Supports an improved format for derived files.  This format is used by leo.py 2.0.  This is an upward compatible change: previous versions of Leo can not read the new format, and this version of Leo can read all previous derived files.

3. Fixes two long-standing bugs in the Untangle command.

4. As mentioned above, the Tangle commands are byte-for-byte compatible with leo.py v2.0.  Also, @c is now equivalent to @code.

5. Adds two very useful commands: Sort Siblings and Contract Parent.

See the Children of this node for full details.</t>
<t tx="edream.110203163054.649">This version of Leo removes blanks from between sentinel lines in derived files.  This version of Leo is fully compatible with leo.py v2.0 in this regard.

This is an upward compatible change in the format of derived files: Borland Leo v2.6 can read derived files from all previous versions of Leo, but previous versions of Leo can not read derived files without blanks lines.

Removing blank lines requires a new kind of sentinel, the "verbatimAfterRef" sentinel.  This allows Leo to handle comments following section references that would otherwise be treated as sentinels themselves.  For example:
   
   &lt;&lt; section &gt;&gt; #+others</t>
<t tx="edream.110203163054.650">Whenever a node changes, Leo now ensures that all nodes cloned to it, and all ancestor @file nodes are marked dirty.  This is the cause of spurious read errors.

As a side effect, nodes now become dirty when they move.

This change was made in leo.py v0.8.

It is also vital that @file nodes remain dirty until they are written without errors.  Otherwise, a Save command will succeed without warning, and a later read may cause the dreaded "clones have been cleared" message.

This change was made in leo.py v1.0.</t>
<t tx="edream.110203163054.651">@c now works the same as @code.  This makes the syntax colorers agree with what the Tangle commands actually do.  Previously, the syntax colorers indicated that everything following an @c was code, while the Tangle commands placed everything following an @c in the doc part!</t>
<t tx="edream.110203163054.652">This version fixes two long-standing bugs:

1. Untangle did not work properly for languages like Perl and Python that do not have block comments. 

2. Untangle did not recognize @ on a line by itself as the start of a doc part.</t>
<t tx="edream.110203163054.653">The Tangle commands are now byte-for-byte compatible with leo.py 2.0.  Tangle outputs "optimized" leading whitespace just as leo.py does.  This can be important in Python programs.

All the Save commands now recompute clone indices just as in leo.py 2.0.</t>
<t tx="edream.110203163054.654">The "Show Context" checkbox in the Find Panel is presently non-functional.  (In leo.py it affects the messages produced by the Find All and Change All commands.)</t>
<t tx="edream.110203163054.655">Unlike leo.py, the Borland version of Leo can not ensure that saved outlines have .leo extensions.

There are two problems:

1.  The ensureExtension routine is called after the dialog closes.  If this routine changes the file name we could overwrite an existing file!

2.  There appears to be problems with the Borland DefaultExt field.  Setting this field causes crashes.</t>
<t tx="edream.110203163054.656">This version fixes several serious bugs.  All users of Leo2 should upgrade to version 2.5 immediately.

1. Eliminated the ill-fated automatic updating feature.  This turns out to be very dangerous and disconcerting.  If one makes changes to the .leo file and does not save those changes, a later update could erase those unsaved changes!

2. Removing automatic updating also fixed another bug:  The current outline node was not being selected properly when a .leo file was read, so that in some cases the body text did not correspond to the selected outline node.  This never caused loss of data, and was disconcerting.

3. Fixed a bug that caused Find/Change settings to be saved to a file only if a find or change command was actually executed.

4. Restored several parts of Leo2(cb).leo that were inadvertently erased due to earlier bugs.  In particular, the outlines for xbuf.c and xbuf.h have now been restored.

One bug remains.  On Windows XP, the cursor is obscured in the Find/Change dialog when it is at the far left of the Find or Change text areas.  This may be a botch in the XP text control itself.  The solution would be to create a border in the text areas, and there is no obvious way to do this using the Borland classes.</t>
<t tx="edream.110203163054.657">Version 2.4 is a major improvement in Leo2.  I urge all users of Leo2 to upgrade to this version.  See the children of this node for full details.

The "old" Leo2 tried to save space by not writing all information in @file trees.  This was a serious mistake.  The "new" Leo2 saves all information in an outline to the .leo file, including all information in @file trees.
Once again you may back up a project merely by backing up the project's .leo file.  There is no Archive command, and no need for one.  All .leo files are now safe archives.

As the result of the change in file formats, Leo 2.4 may clear clone links when loading derived files created with previous versions of Leo.  Leo 2.4 will issue detailed messages when that happens.

The new Leo2 is much safer and more convenient to use than the old Leo2.  Error messages and error recovery have been improved.

Leo2 updates @file trees automatically when Leo2 is activated.  For example, suppose you change a derived file in another editor, say in an IDE.  Leo2 will update the @file tree when you switch to Leo, provided that you have saved the file in the IDE.  Warning: due to several apparent bugs in the Delphi code, this feature only works if the main Leo window is at least partially visible on the screen (!)
</t>
<t tx="edream.110203163054.658">Version 2.4 fixes several bugs involving clones.

1. Version 2.4 rewrites clone indices when writing derived filed, so node sentinels accurately reflect the clone status of the node.  The node sentinel for the root node no longer contains the maximum clone index.  Leo2 clears the root's clone index on reading and writing so that the root node is not mistakenly joined so another node!

2. Version 2.4 takes more care to recreate clone links properly when reading derived files.  A derived file can be read into a .leo file different from the .leo that wrote the derived file, so Leo2 makes sure that clone links are proper in the .leo file being opened.  A minor drawback: .leo files now are "big", so reading them is a little slower.

Note: Clone links into @file trees work only if the .leo file is "in synch" with the files derived from the @file trees.  Clone links will break if the .leo file and derived files are not in synch.  Typically "backup" .leo files will be out-of-synch with present derived files, so it's best to use "backup" .leo files only in emergencies, for example to revert a project to a previous state.</t>
<t tx="edream.110203163054.659">The "old" Leo2 tried to save space by not writing all information in @file trees.  This was a serious mistake.  The "new" Leo2 saves all information in an outline to the .leo file, including all information in @file trees.  It is once again possible to back up a project merely by backing up the project's .leo file.</t>
<t tx="edream.110203163054.660">The archive command was a backup disaster waiting to happen.  It has been replaced by the following four file commands are located in the File:Read/Write submenu.

Read Outline Only: reads an outline using only the .leo file, not any files derived from @file nodes.  This command is useful for reverting a project to a previously saved state.

Read @file Nodes: updates all @file nodes in an outline.  This ensures that the state of an outline matches all files derived from @file nodes.  Included for completeness.  This happens automatically when a .leo file is first read, and it also happens automatically when Leo2 is reactivated.

Write Outline Only: saves an outline without writing any @file trees.  Useful for inserting an @file node into an outline without modifying a derived file with the same name.

Write @file Nodes: forces an update of all @file trees.  Surprisingly useful.</t>
<t tx="edream.110203163054.661">Leo2 updates @file trees automatically when Leo2 is activated.  For example, suppose you change a derived file in another editor, say in an IDE.  Leo2 will update the @file tree when you switch to Leo, provided that you have saved the file in the IDE.

Warning: due to several apparent bugs in the Delphi code, this feature only works if the main Leo window is at least partially visible on the screen (!)</t>
<t tx="edream.110203163054.662">Revised for version 2.4

Loading and saving .leo files usually keeps the .leo file and derived files "in synch".  However, if you create backup .leo files, it can easily happen that the structure of @file nodes in the backup .leo files no longer matches that structure in the derive files.  Leo2 will detect this condition the next time you next open the old .leo file.  When that happens, Leo2 discards the entire out-of-synch @file tree, and recreates it solely using the derived file.  In the process all marks and clone links from outside the file are lost. Leo2 issues the messages:

	Error reading @file &lt;filename&gt;
	-- Rereading file.  Clone links into this file will be lost.

to remind you that the .leo file you are using is out-of-date.  Saving the .leo file will bring it up to date.

If one or more sentinel lines in a derived file have been corrupted in some way, by inserting, deleting, altering or moving a sentinel, Leo issues these messages:

	Error reading @file &lt;filename&gt;
	&lt;An error message about a bad sentinel&gt;
	-- Rereading file.  Clone links into this file will be lost.
	&lt;An error message about a bad sentinel&gt; (again)
	----- File may have damaged sentinels!

Data may not actually be lost, and the outline structure will be seriously damaged.  The most sensible thing to do is to restore the derived file from a .leo file using the Read Outline Only command.

No error recovery is attempted when automatically updating @file trees.  If an error is found the update is canceled (leaving the outline unchanged) and the following message is given:

    -- Update canceled due to structure errors
	
We don't attempt error recovery because error recovery would clear clone links.  For example, suppose we are editing a .leo file, and for some reason we also edit a derived file _without_ saving the .leo file.  Now the files could be out of synch!  So it is best not to press on with an automatic update.
	</t>
<t tx="edream.110203163054.663">Revised for version 2.4

If Leo2 detects orphan or ignored nodes while writing an @file node it saves all information in the @file tree in the outline (.leo) file.  No information is lost.  When the .leo file is read again Leo2 will load the information in the @file tree from the .leo file, not the derived file.

As a reminder, Leo2 marks the erroneous @file node as dirty so that saving the .leo file will attempt to rewrite the @file node.  Version 2.4 no longer marks the @file node as "stuck on dirty".  If you save the .leo file the dirty mark will be cleared.  However, the @file node will be dirty every time the file is read until all errors are corrected.
</t>
<t tx="edream.110203163054.664">@file trees are less flexible than @root trees:

1.  You can not use section definitions in more than one file.  For example, you can't define declarations in one file to be used in another file.  If you need all the features of noweb you must use @root trees.

2. @file trees use no escape conventions whatever.  A code part in an @file tree contains a section reference if &lt;&lt; precedes &gt;&gt; on the line, regardless of whether &lt;&lt; or &gt;&gt; are contained in strings or comments.  In practice, such "false references" occur infrequently, and the workaround is simply to split the offending line.  Moreover, noweb's escape conventions (@&lt;&lt; and @&gt;&gt;) cause problems in @root trees, so this "drawback" is very minor.

3. Clone links into @file trees work only if the .leo file is "in synch" with the files derived from the @file trees.  In particular, backup .leo files will usually be out of synch with derived files.  Clone links will break otherwise.  To recover from such errors, simply use the "Read Outline Only" command.</t>
<t tx="edream.110203163054.665">Note: 10/19/01: I recommend that all users upgrade to version 2.4.  There are some serious problems with version 2.3.

This version of Leo contains some significant improvements.  See the children of this node for details:

1. The new @first directive allows you to place lines at the very start of files derived from @file nodes. For example, @first #!/usr/bin/env python

2. The log window is now part of the Leo window.  Very handy.

3. Fixed several bugs involving the Find command.

4. A new Archive command saves an entire outline (including all @file trees) to a .leo file.  Use this command with caution.  Loading and then saving a .leo file created with the Archive command will revert an entire project to the state it had when the archived .leo file was created.</t>
<t tx="edream.110203163054.666">The @first directive allows you to place lines at the very start of files derived from @file nodes. For example, the body text of @file spam.py might be:

@first #! /usr/bin/env python

The body text of @file foo.perl might be:

@first #/usr/bin/perl

@first directives are recognized only at the start of the body text of @file nodes.  No text may precede @first directives.  More than one @first directive may exist, like this:

@first #! /usr/bin/env python
@first # more comments.</t>
<t tx="edream.110203163054.667">The Archive command writes all nodes of an outline to a .leo file, including all parts of @file trees.  All @file trees are marked in such a way that when the archived .leo file is read 1) all @file trees will be restored from the archived outline rather from derived files and 2) all @file trees will be marked dirty so that when the archived .leo file is written all @file nodes will be updated.

Use the Archive command (and the files written by it) with caution: loading and then saving an archived .leo file will back up an entire project to its state when the archive was originally written!</t>
<t tx="edream.110203163054.668">Added support for @c in syntax colorers for Python, Pascal, Perl, Java and HTML.</t>
<t tx="edream.110203163054.669">Fixed a bug in the Change, Then Find command.  The Change, Then Find command would rescan the newly changed text if the "change text" contained the "find text" preceded by other text of length greater or equal to the length of the original "find text".

For example, changing "blah" to "const blah" would result in rescanning the newly inserted "blah".  This would cause the "Change All" command to hang.

The old code advanced the search point by the length of the "find text."  The new code advances the insertion point by the length of the "change text".

Fixed the Find/Change panel: some captions were cut off.</t>
<t tx="edream.110203163054.670">@file nodes are now marked dirty whenever any change is made in the @file tree, including changes made as the result of changing cloned nodes outside the @file tree.</t>
<t tx="edream.110203163054.671">Made the log window part of the Leo window.  Having the log be part of the leo window is very convenient.</t>
<t tx="edream.110203163054.672">Leo2 readme file
Borland version 2.2, 9/16/01

This version fixes several bugs in Leo2:

1. Fixed a bug that causes all data in an @file tree to be lost under the following conditions:

A. The @file tree was erroneous, i.e., it contained orphan or ignored nodes.
B. The .leo file containing the erroneous tree was saved twice.

Leo2 now marks an erroneous @file node as "stuck on dirty" until the tree is fixed.  Recall that dirty nodes have icons with a black border rather than a gray border.  Whenever a file Save operation occurs, Leo2 will attempt to write all dirty @file trees, thereby reminding you that errors remain.  However, the .leo file itself is not "stuck on unsaved", so you won't be prompted to save the .leo file endlessly.

While fixing this bug I also improved error and warning messages relating to reading and writing @file nodes.  This should make it clear that a) data in erroneous @file trees is saved to the .leo file and b) data is recovered from the .leo file when reading erroneous @file nodes.

2. Fixed a bug relating to clones that could cause loss of data.  Leo2 now marks all clones dirty when any clone changes, and makes sure to mark @file nodes dirty that contain changed clones.

3.  Changed the code that writes @file trees to end lines with "\r\n" rather than "\n".  I hope this will improve matters, though I have my doubts.  Please report any problems with the new scheme immediately.

4. Added Write @file Nodes command.  The command writes all @file nodes in the selected tree, regardless of whether they have been changed.

5. Made the commands in the Main Leo2 window functional.</t>
<t tx="edream.110203163054.673">Version 2.1 is the first public release of Leo2.  This version appears stable, and should be used with caution.

The major feature of Leo2 is that tangling and untangling happen automatically for all code derived from @file nodes.  

Remember to back up all files derived from @file nodes; such files are original source files!  It is no longer possible to back up an entire project by backing up a single .leo file.</t>
<t tx="edream.110203163054.674"></t>
<t tx="edream.110203163054.675">Version 1.15 can read @file trees.  Leo warns when reading @file files, and changing @file trees in Leo v1.15 is not recommended.</t>
<t tx="edream.110203163054.676">This version corrects a problem with double-clicking Leo icons under Windows Me.  You may now launch Leo by double-click the icon for any .leo file and you may open any .leo file by double-clicking on it.</t>
<t tx="edream.110203163054.677">This version of Leo corrects a problem with how whitespace was handled in @silent mode.</t>
<t tx="edream.110203163054.678">Barring serious bugs, version 1.12 is likely to be the last Borland/Windows version of Leo for a while.  The wxWindows versions of Leo are usable enough to justify putting all further work into them.

There are several important improvements in version 1.12:

1. Added the Sort command to the Outline menu.  This command sorts all the children of a node into alphabetical order.

2. A major improvement to Tangle.  In @silent mode, Tangle now outputs derived files with "verbatim" whitespace, that is, without any extra blanks, tabs and newlines.  This makes Tangle much more useful for Python, and in other applications.  For example, it is now possible to do the following in Python:

if &lt;&lt;condition1&gt;&gt; &amp;&amp; &lt;&lt;condition2&gt;&gt;:
	print &lt;&lt;list of vars&gt;&gt;

In the derived file, expansions of the sections will be placed on the lines in which the reference appears.  This works in Python as long as the expansions themselves appear on a single logical line.

This "verbatim" expansion only happens in @silent mode, so these kinds of derived files can not be Untangled.

3. Tangle now reports errors more fully and less redundantly.  Errors involving missing or erroneous path names (specified in @root directives, @path directives or the Preferences Panel) are more specific.  These errors are reported only once per Tangle command, and these errors terminate the Tangle command immediately.  This is wise; we don't want to write files to the wrong directory!  Finally, Tangle no longer prints the actual text of a section when giving the "possibly duplicate section definition" error.  This should be helpful: no longer are huge error messages generated.  It should be easy enough to find the relevant section definitions using Leo's find command.</t>
<t tx="edream.110203163054.679">This version corrects a problem that can cause the Import CWEB Files command to hang in an endless loop.

This file also contains improved documentation (see the children of this node) in two sections:

1.  Added an explanation of the following error message given by the Tangle command: "Multiple parts not allowed for &lt;&lt; section name &gt;&gt;"

2.  Added a warning about using Untangle to update cloned nodes.
(See the last paragraph of the node.)</t>
<t tx="edream.110203163054.680">Sections can be defined in several parts in two ways:

1.  Using &lt;&lt; section name &gt;&gt;= in several places with the same section name.

2.  Using several @code directives within the _same_ body text.

As a precaution against mistakenly defining a section in more than one place, it is invalid to use @code in different nodes to define multiple parts for the same section.  In particular, this error may arise when using cloned nodes.

This error may always be eliminated by using &lt;&lt; section name &gt;&gt;= instead of @code.
	
</t>
<t tx="edream.110203163054.681">The Untangle, Untangle All and Untangle Marked commands are the reverse of the corresponding Tangle commands.  They update an outline based on changes made to one or more derived files.  These are exceptionally useful commands.

For example, suppose you create a new part of the outline and Tangle it for the first time.  When you compile the resulting derived files for the first time, you are likely to get many syntax errors.  You could fix those errors in the outline and Tangle the outline again, but there is a much easier way:  you fix the errors in the derived files using the compiler's editor, then run the untangle command on the part of the outline that created the derived file.  The Untangle command updates the selected outline to match the changes in the derived files.  It's as simple as that.  By the way, the Untangle command marks all the nodes in the outline that it updates, and you can examine all such nodes with the Go To Next Marked command in the Outline menu.

You cannot use Untangle to update doc parts, or leading comments in code parts or "trivial" whitespace in code parts.  This is a limitation of the Untangle command that cannot be fixed; Untangle has no way of knowing whether leading comments came from doc parts or are just leading comments.

Untangle never changes the structure of an outline;  it never inserts, deletes or moves nodes.  Don't attempt to change the structure of an outline by modifying derived files; it won't work.  Also, never delete, move or alter the sentinel lines in derived files written by the Tangle command.  Such lines start with /// followed by a section name.

If you change the section name in a sentinel line Untangle will not update the code in the outline (with the old name) that generated the renamed section.  Untangle now warns about sections that appear in a derived file but not in the outline.  Untangle has no trouble with changed section references in derived files; it is only changed sentinel lines that cause problems.

Cloned nodes that generate code in several files may cause problems for Untangle if not all the code is changed the same way in derived files.  If Untangle is run separately on these derived files, Untangle will update all cloned nodes each time it is run, so only the code in the last Untangle run will take effect.  Therefore, the only reliable way to update text in cloned nodes is to make the change in the .leo file rather than the derived files.</t>
<t tx="edream.110203163054.682">Version 1.10 incorporates the following changes:

1. The Untangle command no longer updates @doc chunks under any circumstances.  This makes Untangle safe to use when the "Tangle outputs doc chunks" preferences is not selected.  In previous versions the Untangle command would delete all @doc chunks in the outline when a derived file had been Tangled without "Tangle outputs doc chunks".

The new version of Untangle is experimental; only one line of code has been added.  I welcome any comments about this change.  This change also fixes (or rather bypasses) a crasher reported in Untangle.

2. The shortcut for the Execute Script command has been changed from Alt-E to Shift-Alt-E to avoid conflicting with the shortcut that brings up the edit menu.

</t>
<t tx="edream.110203163054.683">Version 1.9 contains several improvements that make Leo more Python-friendly:

1. The Execute Script command (Alt-E) in the Edit menu allows you to execute Python scripts directly from body text.

2. Several small changes make the Python window significantly easier to use.

Also, considerable reference (study-only) code has been removed from leo(CB).leo.</t>
<t tx="edream.110203163054.684">It is now possible to execute any Python script directly from any body text.  Just select the script in the body text (including a trailing newline) and use the Execute Script (Alt-E) command from the edit menu.  The script is copied to the Python window and executed as usual.
</t>
<t tx="edream.110203163054.685">Several small changes make the Python window significantly easier to use:

1. The paste command now works in the Python window whenever the Python window is visible.  This fixes a bug that required a mouse click in either pane before paste would work.

2. It is now possible to execute scripts multi-line scripts pasted into the input pane.  Other changes make it easier (or possible) to terminate continued code.</t>
<t tx="edream.110203163054.686">Fixed a crasher that makes it impossible to tangle outlines containing doc parts in languages like HTML that have no single-line comment delimiter.</t>
<t tx="edream.110203163054.687">Leo v 1.7 accepts a slightly more general file format so that it can read XML generated from external XML tools.  Leo v 1.7 can read all previous .leo files.  Leo's Save commands remain unchanged.

Leo still only understands Leo files.  However, Leo now understands a slightly generalized form of Leo files. Specifically:

1.  Attributes may now appear in any order.  (Leo writes attributes in a fixed order, but some XSLT tools rewrite Leo files with attributes in a different order.)

2.  Leo will now accept &lt;tag/&gt; instead of &lt;tag&gt;stuff&lt;/tag&gt; when "stuff" is empty.
</t>
<t tx="edream.110203163054.688">This version corrects a small bug: the wrong text is selected when the syntax colorer changes.  This is a cosmetic bug only; the selected text will not be replaced when further typing occurs.

Unless major bugs are found, this will be the last version of Leo for several months.  I want to freeze the code so that I can work on the wxWindows version.</t>
<t tx="edream.110203163054.689">This version is a major milestone in Leo's code.  Improvements were made throughout Leo's code in an attempt to correct an extremely hard-to-find bug that can cause data in body panes to be lost.  Only time will tell if the bug has, in fact, finally been eradicated.

This version also corrects a minor bug; icons in a newly cloned tree were not always drawn properly.  Also, the currently selected headline no longer changes if you click on the + or - icons that expand and contract headlines.  This new behavior is a result of simplifying the event handlers; I won't consider changing this behavior until it is clear that the data loss bug has finally been fixed.

Use this version of Leo with caution until the new code has been thoroughly tested.  New asserts will guard against silent data loss and other unexpected events.  I don't expect these asserts to fail, but then one never does...

The following lists the changes that were made the code.  You don't need to read the following details; they are provided only for completeness.

1.  Greatly simplified the event handlers.  This should have been done long ago.

The event handlers now handle _all_ aspects of switching tree nodes and updating data structures when the body pane changes.  In particular, this guarantees that tnodes are "synched" when the body pane changes.  This is a major simplification and a major improvement: it should no longer be possible to lose data once it appears in the body pane.

The reverse is not true: the code must still take care that the body pane is updated if tnodes are changed "by hand."  (This is typically done when new nodes are being created.  Such nodes are never the current node and so are not shown in the body pane.)  I re-checked all code to make sure this constraint is satisfied.

Removed synchVnodes and updateBodyPane methods.  These have always been the most error-prone methods in Leo.  Removing them was made possible because the global constraint that tnodes are up-to-date is now guaranteed by the event handlers.

Created a new updateSyntaxColorer routine, which is called when moving a node or changing its text might affect syntax coloring.  This routine can never affect tnodes.

2.  Removed reference counting from tnodes.  The new code deletes tnodes only during the read process.  After that, tnodes are never deleted.  This could be called a memory leak, but it ensures that tnodes can never be deleted out from under a vnode.  I don't this was ever the problem with losing data, and the new code makes sure that it can't be.

3.  Improved how icons are redrawn.  Event handlers now set the dirty bit when text changes, which simplifies matters.

4.  Added asserts to guard against silent data loss, unexpected calls to event handlers, and mismatches between vnodes and their commanders.

6.  Added the mCommands data member to vnodes.  This member ensures that the correct commander is returned by vnode::commands().  The old code got the commander by looking for the current window.  Conceivably this could have caused the wrong commander to be used in some cases.</t>
<t tx="edream.110203163054.690">This version adds the following features:

1. Outline to noweb command.
2. Python scripts for finding and changing text in Leo outlines.
3. A Python method of the vnode class returning the commander corresponding to a vnode.
4. Documentation for Leo's import/export commands.

This may be the last version of Leo for a while; I am about to start work on a cross-platform wxWindows version of Leo.  However, bug reports and requests for new features are always welcome.

Edward K. Ream
September 19, 2000
</t>
<t tx="edream.110203163054.691">The "Outline To Noweb" command converts the selected outline to a flat file containing noweb text.  The name of the root section is taken from the @root directive.  &lt;&lt;*&gt;&gt; is used if the @root directive is not followed by any file name.</t>
<t tx="edream.110203163054.692">Leo's Python scripting does not support Leo's Find and Replace commands directly because these commands are interactive.  Calling these commands from a Python script would be clumsy.

Instead you can use the new find and change scripts to search and replace text.  These scripts use Python's powerful re module.</t>
<t tx="edream.110203163054.693">The commands() method has been added to the Python vnode class.

c=v.commands()

This method returns the commander for the window containing v.  This method can be used to avoid passing commanders as arguments to vnode methods.  For example, given just v, we can call either of the following:

	v.commands().synchNode()
	v.commands().Repaint()</t>
<t tx="edream.110203163054.694">This version corrects a problem with the Save As command;  it worked only once!  That is, after the Save As command was executed the window's title would change, but a later Save command would change the file specified before the Save As command was executed.</t>
<t tx="edream.110203163054.695">This version of Leo introduces Python scripting.  This is a major new addition to Leo.  See the new Chapter 7 of this documentation.  Python support still has rough edges; the next release will be cleaner.  Any suggestions for improvements to Leo's support for Python would be appreciated.

Alt-V now toggles the "View All Characters" option.  This is especially useful when editing Python code.

Besides Python support, a number of minor bug fixes have been made:

Added syntax coloring for try and catch to the C parsers.

Control-K, I now indents blocks of text uniformly, regardless of the language being syntax colored, and regardless of @nocolor and @color directives.  Similarly, Control-K, U now undents blocks of text.  The old keys, control-[ and control-] only worked when the current language was C and syntax coloring was enabled.

Removed the menu items that had the enter key as a shortcut.  The only way to create a new node now is with Control-I.  Using the enter key for a shortcut is not a good idea: it causes problems throughout the code.

Fixed a bug in forgiving compare.  The code that was calling compare_comments wasn't handling mismatched whitespace properly.

Got the Import command for Python working.  I found a bug in Tangle: in @silent mode we must always output a newline in the place of the function name.  Otherwise the Python indentation will be wrong.

The Untangle is now disabled when in @silent mode.  Nothing good can happen in that case!

Fixed a minor problem with the @path directive:  ff a _new_ file has not been saved we issue a warning, not an error if no path has been specified.  We can't really test the @root command for a path because the @root command may be found much later.  Fortunately, this warning will happen very rarely.  It's important, however, to warn that the file may be written to the standard directory if no path is specified in the @root command.  Otherwise, Leo's behavior would be quite confusing.</t>
<t tx="edream.110203163054.696">This version corrects an oversight in the Flatten Outline command.  In order to recreate the outline structure it is not enough to know whether each node has children; you must also know how many children each node has.

The new version of the Flatten Outline command represents the outline the same way the Export MORE Text does:  a child headline is indented one tab more than its parent headline.</t>
<t tx="edream.110203163054.697">The Tangle commands now examine all nodes, including cloned nodes that have previously been visited.  Previously, such nodes were skipped during tangling.  The new logic allows clones to represent code common to more than one unit. You can always insert an @ignore directive in an ancestor of a cloned node to prevent the node from being processed during tangling.
</t>
<t tx="edream.110203163054.698">Version 0.19 fixes some bugs and eliminates some problematic features of Leo.  Also, the role of CWEB mode has been documented more thoroughly.

The PC version of PC is feature complete.  I will release version 1.0 after people have played with this version for a while.

As always, I'll be happy to fix bugs or add urgently needed features.
</t>
<t tx="edream.110203163054.699">Fixed a bug that could result in Tangle outputting derived files in the wrong directory.

Tangle and Untangle now set the current directory using @path directive if it exists, otherwise the directory specified in the Preferences panel if it exists, otherwise the directory set by the Load or Save commands if it exists.  (The Save As and Save To never alter this directory.) Finally, a check to see if the @root directive specifies a full path.  If so, the current directory is not changed.

If none of these directories exists an error is raised so that no Tangling or Untangling is done.  This error can only occur if Tangling or Untangling a file that has just been created by the New command and never saved with the Save command.</t>
<t tx="edream.110203163054.700">Added the @language html, @language perl and @language perlpod directives, and added HTML, Perl and Perl + POD items in the Preferences panel.

The HTML script is rudimentary at present.  Suggestions for improvement are welcome.</t>
<t tx="edream.110203163054.701">The @cweb and @noweb commands are no longer functional.  The new @language cweb directive replaces @cweb, and the other @language directives effectively replace @noweb.  There is an new CWEB option in the Preference panel.
</t>
<t tx="edream.110203163054.702">Leo now parses the @language directive as you type, so if you change the language specified by the @language directive you will see the effect immediately.

There is no longer a limit of 6 languages that can be syntax colored. Let me know if you would like Leo to support another language.</t>
<t tx="edream.110203163054.703">The Print command is now much more flexible and convenient: it will print any node and all its descendents, whether or not the node contains @unit, @root or @ignore directives.  
</t>
<t tx="edream.110203163054.704">Modified massage_block_comment so that it converts the first of a series of newlines to a blank and deletes the rest; Untangle no longer mangles modified @doc sections.

A more complete solution would be for Tangle to insert a flag for inserted newlines ( say backslash newline) so that Untangle could know which newlines to remove.  I'd like to wait until all Tangle/Untangle code is converted to C++ before doing a more thorough job.
</t>
<t tx="edream.110203163054.705">Leo no longer supports clone _windows_.  Cloned outlines, however, will remain with Leo forever.  

Clone windows were never very useful and were buggy.  Eliminating clone windows has made it possible to handle events more smoothly and powerfully.</t>
<t tx="edream.110203163054.706">The Extended Noweb Syntax option in the Preferences panel is gone.  This option has always been deprecated.</t>
<t tx="edream.110203163054.707"></t>
<t tx="edream.110203163054.708">Version 0.18 changes the file format in an upward compatible way.  That is, version 0.18 can read all previous versions of Leo files, but you must have version 0.18 of Leo to read files written by version 0.18.</t>
<t tx="edream.110203163054.709">Fixed a bug that caused @doc section not to be output properly for those languages like Fortran and Perl that do not have block comments.</t>
<t tx="edream.110203163054.710">The @noheader directive suppresses the header line normal written by Tangle at the start of each derived file.  The @noheader directive is especially useful in Perl.  Also added the corresponding "Tangle outputs header line" checkbox in the preferences panel.  This checkbox sets the default which may be over-ridden by the @header or @noheader directives.</t>
<t tx="edream.110203163054.711">@language fortran specifies that comments start with C.
@language fortran90 specifies that comments start with !.</t>
<t tx="edream.110203163054.712">@language perlpod specifies the Perl language with block comments being delimited by =pod and =cut</t>
<t tx="edream.110203163054.713">Version 0.17 fixes some bugs and puts some finishing touches on Leo.

The Borland C++ Builder version of Leo is now feature complete; there are no further items on the to-do list.  Yes, I'll be happy to fix bugs or add urgently needed features.
</t>
<t tx="edream.110203163054.714">Tangle and Untangle now treat &lt;&lt;*&gt;&gt;= as a synonym for @root filename if the _headline_ starts with text of the form @root filename.  This convention allows full compatibility with noweb.
</t>
<t tx="edream.110203163054.715">The @path, @tabwidth and @pagewidth directives are new.

These directives allow the user to override the defaults specified in the Prefs panel on a file-by-file basis.   For the first time, every option in the Preferences panel may be overridden by a directive.</t>
<t tx="edream.110203163054.716">I fixed several severe bugs involving CWEB mode.  It is now possible to tangle and untangle files when in CWEB mode, though CWEB mode has still not been tested thoroughly.</t>
<t tx="edream.110203163054.717">Reduced the default size of Leo windows so that they can be more easily resized on a small screen.</t>
<t tx="edream.110203163054.718">Version 0.16 is a significant new release of Leo.  All users of the PC version of Leo should upgrade to version 0.16.

Significant changes have been made to Tangle and Untangle:  these commands should now be able to handle code in almost any language.  The new @language directive specifies the comment and string conventions used when Tangling and Untangling.

The @verbose, @terse and @silent directives are new:  they control how Tangle outputs comments.

The Import Files command now handles Pascal, Python and Java files in addition to C and C++ files.

Besides the major changes a number of bug fixes and other minor features have been added.

Acknowledgements:  Thanks to Zak Greant for numerous suggestions and bug fixes, and to Garold Johnson for improving this file.</t>
<t tx="edream.110203163054.719">Version 0.16 fixes all bugs mentioned on the SourceForge site as of April 27, 2000.  These bugs involved problems with

@comment &lt;empty&gt;
@comment 2 delims
Not inheriting @comment properly
non-delimited filenames in @root directives
Crashes while Tangling
Problems with Untangle with languages other than C.

Later sections discuss some of these in more detail.</t>
<t tx="edream.110203163054.720">Version 0.16 fixes a crasher related to changing windows.

This _may_ have been the source of crashes when cutting and pasting outlines, but don't count on it!  Make sure you back up files _before_ cutting and pasting outlines!</t>
<t tx="edream.110203163054.721">The @language directive is new.  The @language directive actually specifies the comment delimiters and string types used by the Tangle and Untangle.

The form of this directive is

@language x

where x is one of the following: c,c++,html,java,objective-c,pascal,perl,python and shell.  Shell files have comments that start with #.  Case is ignored in the language specifiers, but not in the @language itself.  Thus, the following are equivalent:

@language html
@language HTML
@language hTmL

but the following is invalid:

@LANGUAGE html

The @comment directive is now officially deprecated: you should use the @language directive whenever possible.  At present Untangle will not process an @root or @unit node if an @comment directive is in effect.  Why?  Because Untangle can't be sure of properly parsing a derived file if the language of the derived file isn't known.  It might be possible to assume some defaults in this case, but that is not done at present and is not a high priority.</t>
<t tx="edream.110203163054.722">Scanning for @directives is now much faster.  As a result, the @language and @comment directives will be recognized anywhere in an outline.  This means

1) child nodes will "inherit" @language or @comment directives from ancestors unless over-ridden in the child node and

2) @language and @comment directives need not be placed in @unit or @root nodes.  This is a much more intuitive and powerful way of handling these directives.</t>
<t tx="edream.110203163054.723">Key parts of the untangle logic have been generalized so that they can handle essentially any computer language. The following routines no longer have any C-specific code and have essentially been completely rewritten:

scan_derived_file (formerly scan_c_file)
forgiving_compare (formerly c_compare)

Tangle now will properly output comments using the present comment delimiters as specified by either the @language directive or the @comment directive.  As mentioned before, you should use @language instead of @comment wherever possible.</t>
<t tx="edream.110203163054.724">As a side effect of the Untangle command, Leo now removes trailing blank lines from the body text of all nodes being untangled.  This finally crushes a long-standing bug.  If the body text ends with one or more blank lines, the altered body text contains exactly one trailing newline.

Nodes that are altered in this way are not marked, nor is the file-changed mark set.  This seems to be the most appropriate action to take:  it would be confusing to prompt the user to save a changed file if the only changes involve trailing whitespace.</t>
<t tx="edream.110203163054.725">The @verbose, @terse and @silent directives determine how Tangle outputs comments.  When @verbose is in effect Tangle outputs all comments.  When @terse is in effect, Tangle outputs only those comments necessary for Untangle to work.  When @silent is in effect Tangle no additional comments.  Note: comments written by the user in code sections are always output: these directives control only:

1.  The comments containing doc chunks and
2.  Sentinel comments that delimit the beginning and end of code chunks.

@verbose is the default.  If more than one of these directives appear in the same body text the "most verbose" of these options will be in effect.</t>
<t tx="edream.110203163054.726">At long last Leo has a useful notion of default directory.  By default, the default directory is the directory containing the .leo file.  This may be over-ridden using the "Tangle Default Directory" option in the Preferences panel.

The default directory is used whenever a file name in an @root directive contains no path component.
</t>
<t tx="edream.110203163054.727">The Import Files command looks at the file extension to see how it should handle files.

Extension	Language
.c			C
.cpp		C++
.java		Java
.pas		Pascal
.py			Python

If the extension is not one of the above the Import files commands merely puts the entire file into the body text of a single node.

The Import Files command probably needs quite a bit of work.</t>
<t tx="edream.110203163054.728">Control-T now changes the pane that is currently active.  If the outline pane was active, the body pane becomes active, and vice versa.  This command makes it possible to switch between panes without using the mouse.</t>
<t tx="edream.110203163054.729">In previous versions of leo.leo I used slash instead of backslash as path delimiters.  This should never have worked, but somehow it did.  The present code uses the correct backslash in all @root directives.</t>
<t tx="edream.110203163054.730">Many improvements were made to the code.  See the diary section of leo.leo if you are interested.  In particular, I created args.h and args.c to define arguments.  This cleans up the code quite a bit.</t>
<t tx="edream.110203163054.731">Changed Tangle and Untangle so that empty section names like &lt;&lt; &gt;&gt; and &lt;&lt; &gt;&gt;= are treated as ordinary characters.  No warning is issued, which is debatable.</t>
<t tx="edream.110203163054.732">As mentioned in the main documentation, you must not change sentinel lines in derived files in any way.  In particular, if you change the section name in a sentinel line Untangle will not update the code in the outline (with the old name) that generated the renamed section.  Untangle now warns about sections that appear in a derived file but not in the outline.  Untangle has no trouble with changed section references in derived files; it is only changed sentinel lines that cause problems.
</t>
<t tx="edream.110203163054.733">Leo is being used to develop HTML files for web sites.  In this context it is natural to define sections that are shared between files.  Don't expect Untangle to update such sections if you make changes to them in derived files.  The natural place to change sections shared by several roots is in the outline, not in the files derived from the outline.

If you do change code in a derived file that appears in several derived files, and try to use Untangle to update the code in the outline one of two things will happen:

1) You untangle an @root node.  Untangle will never compare examine the common section of code for changes, as the common section appear under a @unit node, not the @root node. Untangle will complain about an orphan node.
 
2) You untangle an @unit node.  Untangle will examine each @root node under the @unit node.  Unless the change is made in the last root examined, Untangle will propagate the change when it first sees it, then go right ahead and undo the change when it sees the next expansion of the node in a derived file.
 
Untangle tests for inconsistent expansions of a section only within a single derived file.  Such tests are not done between different derived files because we do not want disallow sections with the same names in different roots.</t>
<t tx="edream.110203163054.734">Known bugs and limitations in all versions of Leo.

1. Untangle has no way of updating a section(chunk) whose name has been changed in the derived file.  Because of the @unit directive, there is not even a way to issue a meaningful warning.

2. Tangle treats @c like @code when in CWEB mode.
I recommend changing @c to @&lt; c @&gt;= throughout your CWEB sources and adding a reference
to @&lt; c @&gt; in all roots of CWEB files.

Known bugs and limitations of the PC version of Leo.

Syntax coloring options are not saved to the file.

The Log window has a limited capacity. This mainly affects debugging traces but could affect the output from the Tangle or Untangle commands if you tangled or untangled a large number of files.
</t>
<t tx="edream.110203163054.833">The Execute Script command executes body text as a Python script.  Leo execute the selected text, or the entire body text if no text is selected.

Scripts are executed in a "pristine" environment, that is, with __builtins__ as both the local and global environments.

New in version 4.1:  Body text may now contain @directives and section references. This is a major step forward: you can now use all of Leo's features to organize scripts that you execute interactively.

Section definitions must appear in the node containing the script or in descendant nodes.  Leo "preprocesses" all scripts by simulating the writing of a derived file to a string.

The Execute Script command sets app.scriptDict["script1"] to the value of the script before preprocessing, and sets app.scriptDict["script2"] to the value of the script after preprocessing.  Scripts may examine and change app.scriptDict as they please.</t>
<t tx="edream.110203163054.1653">@killcolor</t>
<t tx="edream.110203163054.1654">100 Series: Leaps that apply to the Leap process itself. 

Leap 101: How to administer Leaps. 

- Assigned to nobody. 
- No formality needed yet. </t>
<t tx="edream.110203163054.1655">- Assigned to nobody. 
- Create, plan, promote &amp; administer a gathering of Leo enthusiasts. 
- Part of the planning would be to create a date and setting for the conferences. </t>
<t tx="edream.110203163054.1656"></t>
<t tx="edream.110203163054.1657">Project finished in Leo 4.2.

- Cloned vnodes share the same tnode.  That tnode forms the root of a shared tree of vnodes.

- Code must use positions to traverse the tree.

- c.rootVnode and c.currentPosition return positions, not vnodes.

- Positions are proxies for vnodes.

For more details, see leoNodes.py in LeoPy.leo.
</t>
<t tx="edream.110203163054.1658">Project finished in Leo 4.2.

The new file format uses gnx's (global node indices) to represent nodes uniquely.</t>
<t tx="edream.110203163054.1659">Leo's core will use plain Tk so that Leo will run without Pmw.  Moreover there are problems with the Pmw.PanedWidget class that make it less attractive as a base for Leo's main window.

However, Pmw is welcome within plugins.  Plugins or scripts should use g.importExtension('Pmw') to attempt to import Pmw.</t>
<t tx="edream.110203163054.1661"></t>
<t tx="edream.110203163054.1662">Produce a plugin (with related design) that allows people to share all or part of .leo files via a
central server. 

- Assigned to nobody. 
- This plugin need _not_ address itself to issues raised in Leap 302: it is a prototype for experimentation. The
initial aim of this Leap would be to produce a starting point design that would be incorporated into this Leap
for review. 

</t>
<t tx="edream.110203163054.1663">This is less important than I once thought, for the following reasons:

1. CVS conflicts are actually fairly rare.  Moreover, people typically must discuss how to resolve such conflicts; in general completely automated solutions are not possible.

2. Leo handle's conflicts in most code just as any editor would:  Leo body pane shows the conflict delimited as usual.

3. Leo can read @thin files with conflicts that span sentinels.  This affects the outline structure, but not as severely as one might think.  Such conflicts would typically result from two developers changing the headline of a node in conflicting ways.  This will happen rarely, and the workarounds are straightforward.</t>
<t tx="edream.110203163054.1664">Open Discussion

 RE: Status report: ten breakthroughs
2003-05-30 12:50  
About merging / CVS etc: 

Perhaps it helps to think about the big picture a bit, I mean about what do we really want / is practical. 

CVS is a de facto standard on the internet for collaboration, so being compatible is highly desirable. Unfortunately CVS has a series of shortcomings, particularly for Leo. 

CVS merges on a line-by-line basis, so interdependencies of code are ignored (I think all other tools I know of do the same). Now, I believe this is ok for large sets of files, where multiple changes to the same function or file are rare. Using CVS to merge only single Leo nodes (body text) would be rather silly though: Mostly these texts are short (a page or so) and one single function (or less). Multiple changes in such a code snippet are likely to be interdependent, and I would rather like to look at the different texts rather than have them merged automatically. 

On the other hand, I don't mind if the versioning or merging tool at hand allows me to update any nodes I did not touch myself. So rather than CVS-like merging, I would like to see which nodes are being affected by the change, then have it done automatically for those nodes I don't worry about, but by hand (or interactively) for those I changed myself too, or for those I worry about, because they are related to my own changes. 

In other words, I would like to see a merge tool, that understands versions, can tell me which nodes in a Leo file have changed, remembers which changes I made myself, and gives me the choice, tree branch by tree branch, to automatically accept the changes, or screen them interactively. 

I think Leo should have such a tool built-in. 

- Josef</t>
<t tx="edream.110303182253.3">Leo does an auto-save only if something has actually been changed.</t>
<t tx="edream.110303182253.39"></t>
<t tx="edream.110303182719">The config_encoding setting controls the encoding of non-ascii characters in leoConfig.txt.

The use_gnx setting in leoConfig.txt determines whether uses gnx's (cvs friendly) or ints.  No version of Leo before 4.1 can read .leo files containing gnx.   Only gnx's are immutable.  Leo recomputes all non-gnx indices from scratch whenever writing a .leo file. It is possible to convert between 3.x and 4.1 file formats by changing the use_gnx setting.
</t>
<t tx="edream.110603185805">Leo 4.1 beta 5                   December 5, 2003

This is the fifth release of the reorganized 4.1 code base.

For the first time in months there are no serious bugs outstanding.

Warning: By default Leo 4.1 creates .leo files that can not be read by older versions of Leo.

Warning: Use the __wx_gui.py plugin with extreme caution until further notice:
bugs in this plugin could cause body text to be cleared improperly when changing nodes.

Beta 5:
  * Leo runs in batch mode when invoked with --script aScriptFile.py
    - Created "null gui" classes that do not use any gui code.
  * Leo supports Unicode characters (e.g. Chinese) in path and file names.
  * Fixed several long-standing bugs:
    - Fixed several minor problems with the Extract Section and Import commands.
    - Fixed problem that prevent the Find panel from working on the Mac.
    - Improved @url handling so that @url file:\\path\x.leo works properly.
    - Improved support for @lineending platform.
    - Leo honors outline/body pane ratio when opening .leo files.
    - Leo now ensures that newly-opened windows fit entirely on the screen.
    - Fixed a crasher when Undoing a Change All command when searching headlines.
  - Fixed other bugs resulting from the 4.1 reorg:
    - Fixed problem loading plugins on Linux.
    - Fixed crashers in the Extract Section and Extract commands.
    - Fixed a crasher when writing a file containing an undefined section.
    - Removed duplicate bindings in popup menus.
    - Made sure to show Leo's windows in wx gui plugin.

Beta 4:
  - Fixed several "reorg" bugs, some of which affected plugins.
  - Allow @directives and section references when executing scripts!
  - More than one section reference may now appear on the same line.
  - Use "utf-8" encoding for filenames under MacOS (Darwin)
  - Allow command or cmnd prefix for menu shortcuts under Darwin.
	  
Beta 3:
  - Completed the reorg, making many changes to the code base.
  - Fixed a LaTeX coloring bug

Beta 2:
  - Fixed a startup problem on Linux: the "mbcs" text encoding is not valid on Linux.

Beta 1:
  * Script-based find/change commands.
  - Hoist &amp; DeHoist commands for viewing parts of an outline.
  - Check Outline command finds user clone mistakes.
  * New configuration settings:
    - use_gnx specifies whether .leo files use integers as indices:
      use_gnx = 0 makes .leo files compatible with previous versions of Leo.
      use_gnx = 1 makes .leo files cvs-friendly
    - config_encoding specifies the encoding of leoConfig.txt.
  * Several significant code-level changes:
    - The 4.1 code base has been reorganized to support gui plugins.
    - An example wx_gui plugin is partly functional.
    - Created a flexible framework for creating &amp; running regression tests.
    - app.forceShutdown now works when called from plugins.</t>
<t tx="edream.110603190125.1">Leo 4.1 uses immutable gnx's (id:timestamp:n) by default to associate tnodes with vnodes in .leo files.  This makes Leo as cvs friendly as possible.  From now on .leo files will be checked in to cvs with the -ko (text/keywords off) option.</t>
<t tx="edream.110603190125.3">The file test.leo in the test directory contains real regression tests for syntax coloring.   Regression testing scripts create regression tests dynamically from data in Leo's outline.  Very cool, very easy, very general.  In particular, regression tests may use temporary nodes in test.leo rather than creating separate Tk windows for testing.</t>
<t tx="edream.110603190125.4">The 4.1 code base has been reorganized to support gui's other than tkinter.  Leo's src directory contains several new source files.

This reorg affects almost all plugins.  Considerably more work and testing will be done before 4.1 final.

The __wx_gui.py plugin is uses the newly reorganized code.  It is functional except for gui-dependent commands like Toggle-Split Direction.  WARNING: treat the this plugin with extreme caution until further notice.  The possibility exists that bugs in the code could cause body text to be cleared improperly when changing nodes.</t>
<t tx="edream.110603190234.1"></t>
<t tx="edream.110603190322.3">This involved fixing a bug in idle_body_key so that the oldText param is honored if present.</t>
<t tx="edream.110603190322.6">@nocolor

New in 4.1: Leo now supports scripts in Leo's Find/Change dialog.

Leo's find panel now contains the Script Search radio button and the Script
Change checkbox. When the Script Search radio button is selected Leo treats the
contents of the Search Text as a script to execute whenever any kind of Find
command is executed. Similarly, when the Script Change checkbox is selected Leo
treats the context of the Change Text as a script to execute whenever any kind
of Change command is executed. See below for just how this works.

Script-based find-change is extremely powerful. In effect, Leo's Find/Change
panel becomes a new platform for running scripts interactively. Leo now has all
the find/change capability of pattern matching languages like Snobol and Icon,
just by using the capabilities of the plain Python language. Moreover, Leo can
deliver these capabilities interactively or not depending which buttons you push
in Leo's Find/Change panel.

Script-based find/change frees the user from having to control script-based
searches interactively. Rather than forcing find/change scripts to implement
their own interactive controls, it is much easier to use what Leo already has.</t>
<t tx="edream.110603190322.8">Undoing Change All cleared the body pane or the headline pane.

The fix was simple: call setUndoParams instead of setUndoTypingParams in batchChange.</t>
<t tx="edream.110603190322.9"></t>
<t tx="edream.110603190322.10"></t>
<t tx="edream.110603190322.11">The node-only option wasn't working due to a bug in createFrame.

There still may be a problem with the interaction between Node-only,Change All and Undo.</t>
<t tx="edream.110603190322.13">The fix was to open files with 'rb' instead of 'r'.  This probably should be done in more places.</t>
<t tx="edream.110603190322.14">This command checks for unused tnodeLists and checks the topology of all clones.</t>
<t tx="edream.110603190322.15">The Hoist command redraws the screen so presently selected tree becomes the only visible part of the outline.  Leo prevents the you from moving nodes outside the hoisted outline.  The De-hoist command restores the outline.  Hoist commands may be nested.</t>
<t tx="edream.110603190404"></t>
<t tx="edream.110603192009"></t>
<t tx="edream.110603192009.1"></t>
<t tx="edream.111803060152"></t>
<t tx="edream.111803060152.1">Leo dedicates a Python dictionary called app.searchDict for communication
between Leo and the search and change scripts. The search and change scripts may
also use app.searchDict for communication between themselves. Leo sets
app.searchDict["type"] to "find", "change", "findAll" or "changeAll" to indicate
the kind of command being executed. Scripts may use all other entries in
app.searchDict as they please.

Leo executes the find script once when you press the Find button (or the Change
then Find button) in Leo's Find/Change dialog. Typically, the find script would
traversing the tree and highlight the found text or otherwise indicate to the
user that the find operation has succeeded. However, the script can do anything
it pleases.

Leo executes the the find script repeatedly when you press the Find All button.
Leo keeps executing the find script until app.searchDict["continue"] evaluates
to false. Initially there is no entry for app.searchDict["continue"], so the
find script must set app.searchDict["continue"] = true if it wants Leo to keep
executing it.

Leo executes the change script once when you press the Change button. Typically,
the change script would change the selected text. Usually the change script will
compute the new value of body text and call v.setBodyStringOrPane(newText) to
make that change permanent. 

The change script also may handle undo, typically by calling
c.frame.onBodyChanged(v,"Change",oldText=oldText). Leo does not handle undo
automatically. Indeed, Leo makes no assumptions whatever about what the change
script really does.

Leo executes the the change script repeatedly when you press the Change All
button. Just as with the Find All command, Leo keeps executing the change script
until app.searchDict["continue"] evaluates to false.

Most find and change scripts will ignore settings in the Find Panel like "whole
word", "pattern match", and "reverse". However, these settings are available to
the scripts via ivars such as c.whole_word_flag, etc. if desired.</t>
<t tx="edream.111803060152.2">@nocolor

Some ideas for using scripts:
	
Either the find and change scripts may use Python's re module.  For
example, the find script could set app.searchDict["m"] to the match object
returned by re's match method.  The change script would then compute the
result, change the text and set the undo info as usual.

There is no reason to confine find/change scripts to operate on data only
within a Leo outline. These scripts could as easily traverse your file system
as the Leo outline. But notice: scripts could pull data from the file system
into the outline so that you can see the effects of changes as the scripts
operate. Again, this can all happen interactively if you like.</t>
<t tx="edream.111803060643"></t>
<t tx="edream.111803062437"></t>
<t tx="edream.112303173638">@color
@  New in version 4.1: On startup, Leo looks for two arguments of the form --script scriptFile.  If found, Leo enters batch mode.

In batch mode Leo does not show any windows.  Leo assumes the scriptFile contains a Python script and executes the contents of that file using Leo's Execute Script command.  By default, Leo sends all output to Leo's log pane to the console window.  Scripts in the scriptFile may disable or enable this output by calling app.log.disable() or app.log.enable()

Scripts in the scriptFile may execute any of Leo's commands except the Edit Body and Edit Headline commands.  Those commands require interaction with the user.

For example, the following batch script reads a Leo file and prints all the headlines in that file.
@c

import leoGlobals as g

path = r"c:\prog\leoCVS\leo\test\test.leo"

g.app.log.disable() # disable reading messages while opening the file
flag,newFrame = g.openWithFileName(path,None)
g.app.log.enable() # re-enable the log.

for p in newFrame.c.allNodes_iter():
	g.es(g.toEncodedString(p.headString(),"utf-8"))</t>
<t tx="edream.120403174147"></t>
<t tx="edream.120403174147.30">Another 4.1 reorg bug.</t>
<t tx="edream.120403174147.33">This was due to a missing activate event.</t>
<t tx="edream.120403174147.36">Continuation lines caused the import command to terminate functions, methods and classes prematurely.</t>
<t tx="edream.120403174147.56"></t>
<t tx="edream.120403174147.61">This was causing Leo not to load plugins properly on Linux.  The problem was that the imp module does not handle Unicode file names properly.</t>
<t tx="edream.120403174147.63">This was a reorg bug.</t>
<t tx="edream.120403174147.65">Another bug caused by the 4.1 reorg.</t>
<t tx="edream.120403174147.94">- Leo now properly enables and disables the Extract Section menu item.
- Leo no longer removes leading forward slashes in section names in headlines.
- Corrected the documentation for the Extract Section command.</t>
<t tx="edream.120403174147.102">Another 4.1 reorg bug.</t>
<t tx="edream.120403174147.105">This bug has been around for a long time.</t>
<t tx="edream.120403174147.109">The new code attempts to use bitmap files only on Windows.</t>
<t tx="edream.120403174147.112">Leo makes sure that opened files or newly-created outlines fit entirely on the screen.  The Cascade commands leaves the sizes of windows unchanged: it merely ensures that the top left corner of a window is visible on the screen.</t>
<t tx="edream.120403174147.119"></t>
<t tx="edream.120403174147.128">@ A problem: the new window gets put behind the old.  This is probably because Tk thinks that the mouse-down event should select then new window...</t>
<t tx="edream.120403174241"></t>
<t tx="edream.120403180443"></t>
<t tx="edream.120403180443.1"></t>
<t tx="edream.120703073611">Plugins may create (or add to) v.tempAttributes (for vnodes) or t.tempAttributes (for tnodes).  These will work just like the corresponding unknownAttributes dicts except that Leo will _not_ read or write these dictionaries when reading or writing files.  Note: nothing needs to change in Leo to support this convention.</t>
<t tx="edream.120703073611.1">@nocolor

We wish to avoid the possibility that two plugins might unwittingly choose the same name for attributes in the unknownAttributes or tempAttributes dictionaries.  The following convention eliminates that possibility.

Each plugin should create its own dictionary _inside_ any tempAttributes or unknownAttributes dictionaries that it intends to create or modify.  Something like this:

@color

# Create the tempAttributes dict for this vnode.
if not v.hasattr("tempAttributes"):
	v.tempAttributes = {}

# Create a subdictionary for the private use of my plugin.
d = v.tempAttributes.get("myPluginName")
if d is None:
	v.tempAttributes["myPluginName"] = d = {}

@nocolor

Now the plugin can set and get fields in d.  Similar code would be used for the t.tempAttributes, v.unknownAttributes and t.unknownAttributes dictionaries.</t>
<t tx="edream.121403160546">Leo 4.1 Release Candidate 3              December 19, 2003

This release fixes a serious bug in the logic that reads old-style derived files.

There are no known bugs in this version of Leo.

The highlights of this release:

- Leo runs in batch mode when invoked with --script aScriptFile.py
- Leo supports Unicode characters (e.g. Chinese) in path and file names.
- @directives and section references are now valid when executing scripts.
- @ignored and orphan nodes now valid in @file-nosent trees.
- Script-based find/change commands.
- Check Outline command.
- Hoist &amp; DeHoist commands.
- A new gui-agnostic architecture: useful for batch mode and unit tests.
- Several new configuration settings.
- Many new unit tests.
- A host of bug fixes.</t>
<t tx="edream.121403161017">See previous release notes for more details:

- Fixed several minor problems with the Extract Section and Import commands.
- Fixed problem that prevent the Find panel from working on the Mac.
- Improved @url handling so that @url file:\\path\x.leo works properly.
- Improved support for @lineending platform.
- Leo honors outline/body pane ratio when opening .leo files.
- Leo now ensures that newly-opened windows fit entirely on the screen.
- Fixed a crasher when Undoing a Change All command when searching headlines.
- Fixed other bugs resulting from the 4.1 reorg:
- Fixed problem loading plugins on Linux.
- Fixed crashers in the Extract Section and Extract commands.
- Fixed a crasher when writing a file containing an undefined section.
- Removed duplicate bindings in popup menus.
- Made sure to show Leo's windows in wx gui plugin.
- More than one section reference may now appear on the same line.
- Use "utf-8" encoding for filenames under MacOS (Darwin)
- Allow command or cmnd prefix for menu shortcuts under Darwin.
- Fixed a LaTeX coloring bug
</t>
<t tx="edream.121403161017.1">- The 4.1 code base has been reorganized to support gui plugins.
- Created a flexible framework for creating &amp; running regression tests.
- app.forceShutdown now works when called from plugins.
- Created app.unitTestDict for communication between tests and between tests and code.

- An example wx_gui plugin is partly functional.

	Warning: Use the __wx_gui.py plugin with extreme caution until further notice:
	bugs in this plugin could cause body text to be cleared improperly when changing nodes.
</t>
<t tx="edream.121403161017.2">- use_gnx specifies whether .leo files use integers as indices:
  
	use_gnx = 0 makes .leo files compatible with previous versions of Leo.
	use_gnx = 1 makes .leo files cvs-friendly

- config_encoding specifies the encoding of leoConfig.txt.</t>
<t tx="edream.121403161340">- Import Derived File command now uses a file dialog.

	This is much more natural than using @file nodes.

- Leo now loads all plugins listed in pluginsManager.text.

	It is no longer necessary to edit plugin files to enable or disable plugins.</t>
<t tx="edream.121403162622">New in 4.1: The plugins test suite creates a new convention: if a plugin has a
function at the outer (module) level called unitTest, Leo will call that
function when doing unit testing for plugins. So it would be good if writers of
plugins would create such a unitTest funcion. The unitTest function should run
some tests. All unitTest needs to do to indicate failure is throw an exception
or cause an assert to fail. Leo's plugins test suite takes care of the rest.</t>
<t tx="edream.121403165221">- Corrected counts when replacing tabs/blanks.
- Don't write tnodeList when executing scripts.
- Fixed long-standing clone-drag bug.
- Fixed inconsistency between how 4.x and 3.x handle @others.
  The code now works as it did in all 3.x versions, namely
  @others does not terminate doc parts.
- Leo now properly sets clone marks when when cutting and pasting nodes.
- Only double-quotes delimit strings in html files.
  This bug prevented Leo from untangling some valid html/xml files.
- Leo now puts class docstrings in class nodes when importing .py files.
- Fixed several reorg bugs.</t>
<t tx="ekr.20040131040356">Leo 4.1 Release Candidate 4              February 3, 2004

This release fixes numerous bugs reported since 4.1 rc3 and makes several other
minor improvements, including several nifty new plugins.

The highlights of Leo 4.1:

- Leo runs in batch mode when invoked with --script aScriptFile.py
- Leo supports Unicode characters (e.g. Chinese) in path and file names.
- @directives and section references are now valid when executing scripts.
- @ignored and orphan nodes now valid in @file-nosent trees.
- Script-based find/change commands.
- Check Outline command.
- Hoist &amp; DeHoist commands.
- A new gui-agnostic architecture: useful for batch mode and unit tests.
- Several new configuration settings.
- Many new unit tests.
- Excellent new plugins.
- A host of bug fixes.</t>
<t tx="ekr.20040131040356.1"></t>
<t tx="ekr.20040131040356.2">See previous release notes for more details:

4.1 rc3:

- Corrected counts when replacing tabs/blanks.
- Don't write tnodeList when executing scripts.
- Fixed long-standing clone-drag bug.
- Fixed inconsistency between how 4.x and 3.x handle @others.
  The code now works as it did in all 3.x versions, namely
  @others does not terminate doc parts.
- Leo now properly sets clone marks when when cutting and pasting nodes.
- Only double-quotes delimit strings in html files.
  This bug prevented Leo from untangling some valid html/xml files.
- Leo now puts class docstrings in class nodes when importing .py files.
- Fixed several reorg bugs.

4.1 rc2, rc1, betas, alphas:

- Fixed several minor problems with the Extract Section and Import commands.
- Fixed problem that prevent the Find panel from working on the Mac.
- Improved @url handling so that @url file:\\path\x.leo works properly.
- Improved support for @lineending platform.
- Leo honors outline/body pane ratio when opening .leo files.
- Leo now ensures that newly-opened windows fit entirely on the screen.
- Fixed a crasher when Undoing a Change All command when searching headlines.
- Fixed other bugs resulting from the 4.1 reorg:
- Fixed problem loading plugins on Linux.
- Fixed crashers in the Extract Section and Extract commands.
- Fixed a crasher when writing a file containing an undefined section.
- Removed duplicate bindings in popup menus.
- Made sure to show Leo's windows in wx gui plugin.
- More than one section reference may now appear on the same line.
- Use "utf-8" encoding for filenames under MacOS (Darwin)
- Allow command or cmnd prefix for menu shortcuts under Darwin.
- Fixed a LaTeX coloring bug
</t>
<t tx="ekr.20040131040356.3">- The 4.1 code base has been reorganized to support gui plugins.
- Created a flexible framework for creating &amp; running regression tests.
- app.forceShutdown now works when called from plugins.
- Created app.unitTestDict for communication between tests and between tests and code.

- An example wx_gui plugin is partly functional.

	Warning: Use the __wx_gui.py plugin with extreme caution until further notice:
	bugs in this plugin could cause body text to be cleared improperly when changing nodes.
</t>
<t tx="ekr.20040131040356.4">- use_gnx specifies whether .leo files use integers as indices:
  
	use_gnx = 0 makes .leo files compatible with previous versions of Leo.
	use_gnx = 1 makes .leo files cvs-friendly

- config_encoding specifies the encoding of leoConfig.txt.</t>
<t tx="ekr.20040131040356.5">- Import Derived File command now uses a file dialog.

	This is much more natural than using @file nodes.

- Leo now loads all plugins listed in pluginsManager.text.

	It is no longer necessary to edit plugin files to enable or disable plugins.</t>
<t tx="ekr.20040131040544.2"></t>
<t tx="ekr.20040131040544.5"></t>
<t tx="ekr.20040131040544.10">This allows plugins to draw the status area in the icon area.</t>
<t tx="ekr.20040131040544.18">The old code was concatenating strings; the new code uses list.append.</t>
<t tx="ekr.20040131040544.21">- ESC closes the Find panel.

- Hitting the Return key is now equivalent to hitting the Find button.</t>
<t tx="ekr.20040131040544.32"></t>
<t tx="ekr.20040131040544.55">Leo now reports the parent of the orphan node.</t>
<t tx="ekr.20040131040544.73">This bug happened when a move up command would cause a node to become the sibling of (a clone of) itself.  In such cases, Leo simply selects the other cloned copy of the moved node.</t>
<t tx="ekr.20040131040544.81">The bug was causing Leo not to remember the comment delimiters in the @+leo sentinel.  As a result, Leo was recognizing no sentinels and the command complained about missing @-leo sentinels.</t>
<t tx="ekr.20040131040544.146">- Leo now does a better job of checking and reporting read-only violations.

- Leo now clears the file-dirty mark only if the file was successfully saved.

</t>
<t tx="ekr.20040131040544.169"></t>
<t tx="ekr.20040131040544.178">Leo sets only ancestor @file nodes dirty (not nodes themselves) when altering outline structure, i.e., when moving, inserting, deleting, cloning and sorting nodes.</t>
<t tx="ekr.20040131040544.222">That is, when preprocessing the script (expanding section references, etc.) Leo now ensures that child nodes effectively end in a newline.  This prevents unintended concatenation of lines.</t>
<t tx="ekr.20040131040544.227">A contained a space before a tab in the leading whitespace of the line.</t>
<t tx="ekr.20040131040544.228">- These commands did not properly count the number of changed nodes.
- These commands now mark only changed nodes as dirty.</t>
<t tx="ekr.20040131040544.258"></t>
<t tx="ekr.20040131040754">Fixed crashers in:

- Insert Headline Time/Date commands.
- Change headline command.
- Write Dirty/Missing @file Nodes commands.
- Batch mode.</t>
<t tx="ekr.20040131041015"></t>
<t tx="ekr.20040131044136">- Fixed a bug that caused cut and paste operations in headlines to revert when those commands were chosen from the Edit menu.

- Extended control-v bug fix to "darwin","freebsd4","freebsd5"

- Cut and paste are now always enabled when not editing the body pane.  This isn't perfect, and is an improvement.</t>
<t tx="ekr.20040131044727">1. Fixed a bug that caused improper indentation of sections.

The bug happened in some cases when a section reference occurred following non-whitespace.

2. Leo ensures that leading whitespace is not added when writing empty lines.

This might fix the "Zope Sprint" bug: "blank" lines in the expansion of @others got leading whitespace.</t>
<t tx="ekr.20040131100557">Previously, if you hoist a node with no children and then insert a node (CTRL-I)
then the child is created as a sibling of the hoisted node and consequently is
not displayed.

Leo now creates the new node as the first child of the hoisted node. 

Also, Leo disables the Clone command when the presently selected node is the root of a hoist.</t>
<t tx="ekr.20040201061329">This creates a status area at the bottom of the Leo Window.  Plugins may write to this area using the status area convenience routines in leoTkinterFrame.py.</t>
<t tx="ekr.20040201113232">@nocolor

The Scripts node in LeoPy.leo contains a script called initScriptFind.  This script makes it easy to set up script based searches as follows:

1. Put the following code in the root of a tree that will contain your script search:

@color
# Initialize Leo's find panel using the named children of this node.
from leoGlobals import *
initScriptFind("Find script","Change script") # Second argument is optional.
# Start searching at the top.
top().selectVnode(c.rootVnode())
@nocolor

2. Put the search script in a child node called "Find script" (no quotes).

3. (Optional) Put the change script in a child node called "Change script"

4.  Execute the code above.  Leo does the following:

- Puts the body of the "Find script" into the find text of Leo's Find/Change dialog.
- Puts the body of the "Change script" into the change text of Leo's Find/Change dialog.
- Selects the Script Find radio button.
- Selects the Script Change checkbox if the change script exists.
- Selects the root of the entire outline.

Presto!  Leo is ready for a script search.</t>
<t tx="ekr.20040201114855"></t>
<t tx="ekr.20040201114855.3">This plugin uses Leo and docutils to mix program code and reST documentation.

The Python docutils package must be installed.http://docutils.sourceforge.net

If SilverCity is installed (http://silvercity.sourceforge.net) the plugin
produces HTML output that is syntax colored.

The basic approach is that any Leo node that contains program code that needs
documentation (in an ideal world it would be every node) has an associated child
node whose headline is simply '@rst', that contains reST-style documentation.
While this means that a typical program may have dozens (if not hundreds) of
these @rst nodes, it produces documentation that I think is as close as I have
ever seen to useful, easy-to-read documentation that is easy to create at the
same time as an application is being coded.

There are several interrelated aspects to this work:

- The reST plugin (renamed rst2) was hacked to manage Leo outlines that were a
combination of normal code nodes and reSt nodes.

- The plugin now recognizes a @rst directive (that has no associated file name)
in the headline of a node.

- When it encounters such a @rst Headline node, it writes the contents of the
body of the @rst node's *parent* (which generally contains program code) to the
reST output file (HTML) and then adds the reST content that is contained in the
body of the @rst documentation node to the output HTML file,

- These @rst nodes are used in @file-nosent trees and the @rst nodes have an 
@ignore directive (plus @nocolor directive and @wrap directives) so that 
when the @file is updated the application code does not contain the reST-style
documentation contained in the body of the @rst nodes. (This was the reason I
had asked you in the Leo Forum to allow @file-nosent trees to work appropriately
with @ignore nodes - Thank you for doing this right away.) There is no reason
that the reST content couldn't be written to the 
@file as documentation other than I personally believe in a volume of 
documentation (including musings, failed ideas, questions, etc.) that is 
probably best kept separate from the actual *.py files.

- When you double-click on a plain rst node (no associated filename) Leo opens
both the @rst documentation node and the parent node containing code in an
external editor *simultaneously*. I happen to use Textpad and so the code is
opened with python syntax coloring in one Textpad window and right next to it is
the reST documentation. This makes it much much easier to code and do
documentation at the same time. (Note that the plugin assumes that the python
extension is '.tp' since that is what I use with TextPad.)

So why is this a big deal?

For the first time in my experience the documentation process:

1) is completely in sync with the process of code development.

2) allows the programmer to write as much documentation as he/she wants without
the programming code becoming unreadable because of what would be considered
excessive or intrusive documentation. (This applies whether documentation is
intended for external consumption or just so a solo programmer can remember what
he/she was thinking...)

My conclusion is that Leo + reST/docutils provides the perfect platform for
optimal documentation. I have never completely understood what is meant by
Literate Programming but in my mind this is practical Literate Programming.

Frankly, I think this is all a minor miracle but maybe I've lost perspective.

Steve Zatz</t>
<t tx="ekr.20040201114855.13">Adds a quick search to the toolbar in Leo.

A search box which behaves like a web site search is added, along with a "GO"
button to do quick searches right from the main Leo window. All the current
search options are retained except that "search body text" is explicitly set -
mainly because this is by far the most common use case.

Pressing &lt;CR&gt; while editing the text automatically does a search. Repeated
searches can be done by clicking the "GO" button.

The combo box also stores a list of previous searches, which can be selected to
quickly repeat a search. When activating a previous search the original search
mode is used.

Still to do:

- incremental search
- reverse search
- persist recent searches across Leo sessions
- use INI file to set options for list size, etc.</t>
<t tx="ekr.20040201114855.29">Adds a node navigator to the toolbar. The navigator allows quick access to
marked nodes. You can either go to the marked node or hoist the marked node.</t>
<t tx="ekr.20040201114855.36">Adds row/column indicators to the toolbar at the top of Leo Windows.</t>
<t tx="ekr.20040201114855.42">A minimal http plugin for LEO, based on AsyncHttpServer.py.

Use this plugin is as follows:

1. Start Leo with the plugin enabled. You will see a purple message that says
something like: "http serving enabled on port 8080, version 0.9"

2. Start a web browser, and enter the following url: http://localhost:8080/
You will see a a "top" level page containing one link for every open .leo file.
Start clicking :-)

You can use the browser's refresh button to update the top-level view in the
browser after you have opened or closed files.</t>
<t tx="ekr.20040201114855.91">Automatically add nodes for common tasks. This can be used to generate boiler
plate code to quickly build an outline.</t>
<t tx="ekr.20040201114855.105"></t>
<t tx="ekr.20040201114855.106"></t>
<t tx="ekr.20040201114855.107">This bug happened when executing the initScriptFind script.  This bug could cause Leo not to be able to save files.</t>
<t tx="ekr.20040201120903">Adds a status line to the bottom of Leo windows.</t>
<t tx="ekr.20040203084228">The Change All command was looping when the find pattern was '\n'.</t>
<t tx="ekr.20040216151748">Leo 4.1 Final              February 20, 2004

Leo 4.1 Final is the culmination of four months of work. No significant bugs
have been reported since 4.1 rc4. Several people have contributed nifty plugins
recently. See leoPlugins.leo for full details.

The highlights of Leo 4.1:

- Leo runs in batch mode when invoked with --script aScriptFile.py
- Leo supports Unicode characters (e.g. Chinese) in path and file names.
- @directives and section references are now valid when executing scripts.
- @ignored and orphan nodes now valid in @file-nosent trees.
- Script-based find/change commands.
- Check Outline command.
- Hoist &amp; DeHoist commands.
- A new gui-agnostic architecture: useful for batch mode and unit tests.
- Several new configuration settings.
- Many new unit tests.
- Excellent new plugins.
- A host of bug fixes.</t>
<t tx="ekr.20040216152948"></t>
<t tx="ekr.20040216153725">Changed Undo/Redo messages:

- Insert Outline to Insert Node.
- Delete Outline to Delete Node.
- Clone to Clone Node.

This is a real code change: it affects the undo/redo logic.</t>
<t tx="ekr.20040217075627">Clone bits could be improperly set in some cases.  This bug would not have caused serious long-term problems.

Steps to reproduce:

1. Create a parent node (named 'cloned').
2. Create two children nodes (one named 'dummy' and another named 'bottom') under the parent node 'cloned'.
3. Move the 'bottom' node below the 'dummy' node.
4. Clone node 'cloned'.
5. Copy node 'dummy'.
6. Paste node 'dummy' in between 'dummy' and 'bottom'.
7. After pasting you'll see that 'bottom' is now marked as a cloned node.</t>
<t tx="ekr.20040217085036">See leoPlugins.leo for full details.</t>
<t tx="ekr.20040217085036.1">Here is the bug report I submitted to Python:

The documentation for encoding lines at

C:\Python23\Doc\Python-Docs-2.3.1\whatsnew\section-encodings.html

states:

"Encodings are declared by including a specially formatted comment in the
first or second line of the source file."

In fact, contrary to the implication, the Python 2.3 parser does not look
for lines of the form:

# -*- coding: &lt;encoding&gt; -*-

For example, Python improperly scans the following line for an encoding

#@+leo-ver=4-encoding=iso-8859-1.

and reports that iso-8859-1. (note trailing dot) is an invalid encoding!

The workaround for my app is to precede this line with the following line:

# -*- coding: iso-8859-1 -*-

This makes Python 2.3 happy.

To make myself perfectly clear: Python has absolutely no right to complain
about comment lines that do not have the form:

# -*- coding: &lt;encoding&gt; -*-</t>
<t tx="ekr.20040219100738">By Randall Voth:
Leo works reliably only on MacOS X 10.3 (Panther) and above.
To run Leo on Macintosh OS X 10:

1.  Download and install ``MacPython 2.3 for Panther addons``.
    Python is already included in OS X 10.3 so only the addons are necessary at
    http://www.cwi.nl/~jack/macpython.html

2.  Download and install TclTkAqua from http://tcltkaqua.sourceforge.net/

3.  Run the PackageManager found in ``/Applications/MacPython-2.3`` and  
    install ``_tkinter-2.3-binary`` by clicking on the package in the list  
    and clicking the [Install:] button with ``Install dependencies`` checked.

4.  Download Leo (platform independent source.zip) from http://leo.sourceforge.net/

5.  Unzip the contents into a directory by double-clicking the downloaded file.
    Typically you would put the Leo folder into the ``Applications`` directory.

6.  Control-click on ``/path_to_unzipped_dir/leo/src/leo.py`` and open with ``PythonLauncher``.

7.  It is a good idea to set ``PythonLauncher`` as the default program to  
    open python scripts by clicking on ``leo.py``, choosing Get Info from the  
    Finder's File menu, and selecting "PythonLauncher" as the default  
    program to ``Open With:``
    By clicking the ``Change All...`` button, all python scripts will be  
    opened with ``PythonLauncher``.
    
8.  Download ``Pmw`` from http://pmw.sourceforge.net/
    ``Pmw`` must be installed in order to use the Settings panel.
    Drag the downloaded gzip file into
    ``/System/Library/Frameworks/Python.framework/Versions/2.3/lib/python2.3/site-packages``
    Double click on it to unzip and untar the file into a folder to make it available to Python</t>
<t tx="ekr.20040403171740">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
..
.. A very cool option: doc parts will be rendered properly,
.. but will be ignored by the Execute script command.
..
show_doc_parts_as_paragraphs = True
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|back| |leo| |next|

####################################
Chapter 7: Scripting Leo with Python
####################################

This chapter describes only the most useful functions, classes and methods in
``leo.py``. Keep in mind that *your scripts have complete access to all of Leo's
source code*, that is, all the code in ``LeoPy.leo``. Your scripts can use Leo's
code in whatever ways are convenient. You are *not* limited by what you see in
this chapter.

.. contents::</t>
<t tx="ekr.20040403173920.3">The g.es method prints its arguments to the Log tab of the log pane::

    g.es("Hello world")

g.es converts non-string arguments using repr::

    g.es(c)

g.es prints multiple arguments separated by commas::

    g.es("Hello","world")

To create a tab named 'Test' or make it visible if it already exists::
 
    c.frame.log.selectTab('Test')

When first created, a tab contains a Tk.Text widget.
To write to this widget, add the tabName argument to g.es::

    g.es('Test',color='blue',tabName='Test')</t>
<t tx="ekr.20040403173920.5">``leoGlobals.py`` defines 6 convenience methods for redirecting stdout and stderr::

    g.redirectStderr() # Redirect stderr to the current log pane.
    g.redirectStdout() # Redirect stdout to the current log pane.
    g.restoreStderr()  # Restores stderr so it prints to the console window.
    g.restoreStdout()  # Restores stdout so it prints to the console window.
    g.stdErrIsRedirected() # Returns True if the stderr stream is redirected to the log pane.
    g.stdOutIsRedirected() # Returns True if the stdout stream is redirected to the log pane.

Calls need *not* be paired. Redundant calls are ignored and the last call made
controls where output for each stream goes.
**Note**: you must execute Leo in a console window to see non-redirected output from the print statement::

    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()

    g.redirectStderr()
    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()

    g.redirectStdout()
    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()

    g.restoreStderr()
    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()

    g.restoreStdout()
    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()</t>
<t tx="ekr.20040403173920.6">Here is how to access the data of a Leo window::

    g.es(p) # p is already defined.
    p = c.currentPosition() # get the current position.
    g.es(p)
    g.es("head:",p.headString())
    g.es("body:",p.bodyString())

Here is how to access data at position ``p``.
**Note**: these methods work whether or not ``p`` is the current position::

    body = p.bodyString()
    head = p.headString()
    p.setBodyStringOrPane(body)     # set body text of p to body.
    p.setHeadStringOrHeadline(head) # set headline text of p to head.</t>
<t tx="ekr.20040403173920.9">The proper way to traverse an outline is with an iterator.
Iterators are defined only by the position class;
vnodes can not have iterators because vnodes may appear in multiple places in an outline.
</t>
<t tx="ekr.20040403173920.10">The ``c.allNodes_iter`` iterator returns a list of all positions in the outline.
This script makes a list of all the nodes in an outline::

    nodes = [p for p in c.allNodes_iter()]
    g.es("This outline contains %d nodes" % len(nodes))

Here is one way to count the nodes of an outline::

    count = 0
    for p in c.allNodes_iter():
        count += 1
    g.es("This outline contains %d nodes" % count)

Here is a way to count the *distinct* vnodes of an outline::

    positions = 0 ; tnodes = {}
    for p in c.allNodes_iter():
        positions += 1
        if not tnodes.get(p.v.t):
            tnodes[p.v.t] = p.v.t
    g.es("%8s positions" % positions)
    g.es("%8s vnodes" % len(tnodes.keys()))</t>
<t tx="ekr.20040403173920.13">The ``p.children_iter`` iterator returns a list of all children of position ``p``::

    parent = p.parent()
    g.es("children of %s" % parent.headString(),color="purple")
    for p in parent.children_iter():
        g.es(p.headString())</t>
<t tx="ekr.20040403173920.14">The ``p.parents_iter`` iterator returns a list of all parents of position ``p``, excluding ``p``::

    current = p.copy()
    g.es("inclusive parents of %s" % current.headString(),color="purple")
    for p in current.self_and_parents_iter():
        g.es(p.headString())

The ``p.self_and_parents_iter`` iterator returns a list of all parents of position ``p``, including ``p``::

    current = p.copy()
    g.es("exclusive of %s" % current.headString(),color="purple")
    for p in current.parents_iter():
        g.es(p.headString())</t>
<t tx="ekr.20040403173920.15">The ``p.siblings_iter`` iterator returns a list of all siblings of position ``p``::

    current = c.currentPosition()
    g.es("all siblings of %s" % current.headString(),color="purple")
    for p in current.self_and_siblings_iter():
        g.es(p.headString())

The ``p.following_siblings_iter`` iterator returns a list of all siblings that follow position ``p``::

    current = c.currentPosition()
    g.es("following siblings of %s" % current.headString(),color="purple")
    for p in current.following_siblings_iter():
        g.es(p.headString())</t>
<t tx="ekr.20040403173920.16">The p.subtree_iter iterator returns a list of all positions in ``p``'s subtree, excluding ``p``::

    parent = p.parent()
    g.es("inclusive subtree of %s" % parent.headString(),color="purple")
    for p in parent.self_and_subtree_iter():
        g.es(p.headString())

The p.self_and_subtree_iter iterator returns a list of all positions in ``p``'s subtree, including ``p``::

    parent = p.parent()
    g.es("exclusive subtree of %s" % parent.headString(),color="purple")
    for p in parent.subtree_iter():
        g.es(p.headString())
</t>
<t tx="ekr.20040403173920.17">You can use ``c.redraw_now`` to redraw the entire screen immediately::

    c.redraw_now()

However, Leo's code redraws the screen using the following pattern::
    
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()

This suppresses redraws inside &lt;&lt;whatever&gt;&gt; that would otherwise be caused by
``c.endUpdate``. ``c.endUpdate`` takes an optional argument::

    c.endUpdate(flag)

redraws the screen only if flag is True. This is an important pattern. Leo uses
``c.beginUpdate`` and ``c.endUpdate`` almost everywhere to redraw the screen, so
provided that &lt;&lt; whatever &gt;&gt; contains no calls to ``c.redraw_now`` this pattern
insures that at most one redraw occurs.</t>
<t tx="ekr.20040403173920.18">Leo dispatches commands using c.doCommand,
which calls the "command1" and "command2" hook routines for the given label.
c.doCommand catches all exceptions thrown by the command::

    c.doCommand(c.markHeadline,label="markheadline")

You can also call command handlers directly so that hooks will not be called::

    c.markHeadline()

You can invoke minibuffer commands by name.  For example::

    c.executeMinibufferCommand('open-outline')

c.keyHandler.funcReturn contains the value returned from the command.
In many cases, as above, this value is simply 'break'.</t>
<t tx="ekr.20040403173920.19">Each commander maintains its own preferences.
Your scripts can get the following ivars::

    ivars = (
        'output_doc_flag',
        'page_width',
        'page_width',
        'tab_width',
        'tangle_batch_flag',
        'tangle_directory',
        'target_language',
        'untangle_batch_flag',
        'use_header_flag',
    )
    
    g.es("Prefs ivars...\n",color="purple")
    for ivar in ivars:
        g.es(getattr(c,ivar))

If your script sets ``c.tab_width`` your script may call ``f.setTabWidth`` to redraw the screen::

    c.tab_width = -4    # Change this and see what happens.
    c.frame.setTabWidth(c.tab_width)</t>
<t tx="ekr.20040403173920.21">The file ``leoFindScript.py`` contains functions for finding and changing text
from within scripts.  See ``leoFindScript.py`` in ``LeoPy.leo`` for full details.

The findall function returns a list of tuples ``(v,pos)`` describing matches in
``c``'s entire tree::

    import leoFindScript

    pattern="import leoGlobals as g"
    result = leoFindScript.findAll(c,pattern,bodyFlag=1)
    
    g.es("%-3d instances of: '%s'...\n" % (len(result),pattern),color="purple")
    
    for v,pos in result:
        body = v.bodyString()
        g.es('\n%-4d %s' % (pos,v.headString()))
        g.es(g.get_line_after(body,pos))

The ``reFindall`` function returns a list of tuples ``(v,mo,pos)``, where ``mo``
is a ``MatchObject``. The ``reFlags`` argument are flags to ``re.search``::

    import leoFindScript

    pattern="from .* import"
    result = leoFindScript.reFindAll(c,pattern,bodyFlag=1,reFlags=None)

    g.es("%-3d instances of: '%s'...\n" % (len(result),pattern),color="purple")
    for v,mo,pos in result:
        body = v.bodyString()
        g.es('\n%-4d %s' % (pos,v.headString()))
        g.es(g.get_line_after(body,pos))</t>
<t tx="ekr.20040403173920.24">On startup, Leo looks for two arguments of the form::

    --script scriptFile

If found, Leo enters batch mode. In batch mode Leo does not show any windows.
Leo assumes the scriptFile contains a Python script and executes the contents of
that file using Leo's ``Execute Script`` command. By default, Leo sends all
output to the console window. Scripts in the scriptFile may disable or enable
this output by calling ``app.log.disable`` or ``app.log.enable``

Scripts in the scriptFile may execute any of Leo's commands except the ``Edit Body``
and ``Edit Headline`` commands. Those commands require interaction with the user.
For example, the following batch script reads a Leo file and prints all the
headlines in that file::

    path = r"c:\prog\leoCVS\leo\test\test.leo"
   
    g.app.log.disable() # disable reading messages while opening the file
    flag,newFrame = g.openWithFileName(path,None)
    g.app.log.enable() # re-enable the log.
    
    for p in newFrame.c.allNodes_iter():
        g.es(g.toEncodedString(p.headString(),"utf-8"))
</t>
<t tx="ekr.20040403173920.25">``leoGlobals.py`` contains many utility functions and constants.
The following script prints all the names defined in ``leoGlobals.py``::

    g.es("Names defined in leoGlobals.py",color="purple")
    names = g.__dict__.keys()
    names.sort()
    for name in names:
        g.es(name)</t>
<t tx="ekr.20040403173920.26">Most scripts will use methods of the position class to access information in an
outline. The following sections summarizes the most useful methods that your
scripts can use. For a complete list, see the ``leoNodes.py`` in of ``LeoPy.leo``.
</t>
<t tx="ekr.20040403173920.27">``p.c`` is an 'official' ivar of the ``position`` class.  ``p.c`` is ``p``'s commander.


Here are the most useful getters of the ``vnode`` and ``position`` classes.
    
Returning strings::

    p.bodyString() # the body string of p.
    p.headString() # the headline string of p.
    
Returning ints::

    p.childIndex()
    p.numberOfChildren()
    p.level()
    
Returning bools representing property bits::

    p.hasChildren()
    p.isAncestorOf(v2) # True if v2 is a child, grandchild, etc. of p.
    p.isCloned()
    p.isDirty()
    p.isExpanded()
    p.isMarked()
    p.isVisible()
    p.isVisited()</t>
<t tx="ekr.20040403173920.28">Here are the most useful setters of the ``Commands`` and ``position`` classes.
The following setters of the ``position`` class regardless of whether
``p`` is the presently selected position::

    p.setBodyString(s)  # Sets the body text of p.
    p.setHeadStringOrHeadline(s)  # Sets the headline text of p.

Moving nodes::

    p.moveAfter(v2)           # move p after v2
    p.moveToNthChildOf(v2,n)  # move p to the n'th child of v2
    p.moveToRoot(oldRoot)     # make p the root position.
                              # oldRoot must be the old root position if it exists.

The "visited" bit may be used by commands or scripts for any purpose.
Many commands use this bits for tree traversal, so these bits do not persist::

    c.clearAllVisited() # Clears all visited bits in c's tree.
    p.clearVisited()
    p.setVisited()</t>
<t tx="ekr.20040403175157.1">The windowlist attribute of the application instance contains the list of the
frames of all open windows. The commands ivar of the frame gives the commander
for that frame::

    windows = g.app.windowList # get the list of all open frames.
    g.es("windows...")
    for f in windows:
        c = f.c # c is f's commander
        g.es(f)
        g.es(f.shortFileName())
        g.es(c)
        g.es(c.rootPosition())</t>
<t tx="ekr.20040403183229">Leo's source code is a collection of classes, along with utility functions in
``leoGlobals.py``. Here are Leo's most important classes and objects:

**The Execute Script command predefines c, g and p**
    Leo's ``Execute Script`` command predefines ``c`` to be the commander of the
    outline containing the script. ``g`` and ``p`` are predefined as follows::

        import leoGlobals as g
        p = c.currentPosition()

**g.app**
    The **application object** representing the entire Leo application.
    The ivars (instance variables) of ``g.app`` represent Leo's global variables.

**commander**
    An instance of the ``Commands`` class in ``leoCommands.py``.
    Commanders represent commands for a *particular* window.
    Each open Leo window has its own commander.
    By convention, any variable named ``c`` is a commander.

**frame**
    An instance of the base ``leoFrame`` class in ``leoFrame.py``.
    Frames contains all the internal data needed to manage a Leo window.
    Given a commander ``c``, ``c.frame`` is commanders frame.
    Given a frame ``f``, ``f.c`` is the frame's commander.

**position**
    An instance of the ``position`` class in ``leoNodes.py``.
    A position object represents the location of a particular node *in a tree traversal*.
    By convention, variables named ``p``, ``p1`` or ``p2`` are positions.
    For any ``position`` ``p``, ``p.v`` is the vnode at that position and ``p.v.t`` is the tnode at that position.
    **Positions are the primary way to access data.**
    ``c.currentPosition`` and ``c.rootPosition`` return positions.
    From those starting point, it is possible to access the data in any node.

    **Important**:
    Positions can become *invalid* when the structure of the outline changes.
    Therefore, plugins and scripts must *not* store positions for use at a later time if the outline
    could have changed in the meantime.

    **Important**:
    For compatibility with old (pre-4.2) scripts, ``c.currentVnode`` and
    ``c.rootVnode`` methods return *positions* not vnodes. Old scripts appear to
    be using vnodes; in fact they are using positions. I call such scripts
    **confused** scripts. Confused scripts work because the ``position`` class
    is designed to make them work. We'll see how this works in detail in `About
    copying positions`_.  This section is **supremely important**.

**vnode**
    An instance of the ``vnode`` class in ``leoNodes.py``.
    vnodes represent an outline node.
    Normally, scripts access vnodes via the ``position`` class described below. 
    By convention, variables named ``v``, ``v1`` or ``v2`` refer to vnodes.
    **Important**: scripts normally should use positions, not vnodes.

**tnode**
    An instance of the ``tnode`` class in ``leoNodes.py``.
    tnodes represent the actual data in a vnode, including headline and body text.
    Cloned *vnodes* share the tnode *of their first child*.
    For any vnode ``v``, ``v.t`` is v's tnode.
    **Important**: If ``p`` is a ``position``, ``p.v.t`` is the tnode associated with that position.
    Many positions may share the same tnode.

</t>
<t tx="ekr.20040411151245">Iterators exist only in the position class::

	c.allNodes_iter            # returns all positions in c's outline.
	p.children_iter            # returns all children of p.
	p.parents_iter             # returns all parents of p.
	p.self_and_parents_iter    # returns p and all parents of p.
	p.siblings_iter            # returns all siblings of p, including p.
	p.following_siblings_iter  # returns all siblings following p.
	p.subtree_iter             # returns all positions in p's subtree, excluding p.
	p.self_and_subtree_iter    # returns all positions in p's subtree, including p.</t>
<t tx="ekr.20040414161647">@nocolor

These are the sources for the html version of Leo's users guide,
as well as the documentation for the rst3 plugin used to create the actual html files.

These sources contain reStructuredText_ (rST) markup that is easy to read.
See http://docutils.sourceforge.net/docs/user/rst/quickstart.html for an introduction to rST.

To create the html files, choose one of the @rst nodes and run the rst3 plugin
by clicking on the blue 'rst' button in the icon area.

**Important**:
The following @ignore is needed so that discussions of @file, @root, etc. do not create derived files!

@ignore
@tabwidth -4</t>
<t tx="ekr.20040414162124">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

.. August 28, 2005

|blank| |leo| |next|

###################
Leo's Users Guide
###################</t>
<t tx="ekr.20040414163815">`Front Matter`_

`What people are saying about Leo`_

`FAQ`_

`Chapter 1: Installing Leo`_

`Chapter 2: A Tutorial Introduction to Leo`_

`Chapter 3: Using Leo's Outlines`_

`Chapter 4: Writing Programs in Leo`_

`Chapter 5: Using Leo's Commands`_

`Chapter 6: Leo and Literate Programming`_

`Chapter 7: Scripting Leo with Python`_

`Chapter 8: Customizing Leo`_

`Chapter 9: History of Leo`_

`Chapter 10: Theory of Operation`_

`Chapter 11: White Papers`_

`Chapter 12: Plugins`_

Appendices_

Glossary_</t>
<t tx="ekr.20040414172212">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|prev| |leo| |next|

############
Front Matter
############

.. contents::

</t>
<t tx="ekr.20040414172218.2">Leo_ has thousands of users_. Like me, many of them would never willingly be without Leo again.
Here are Leo's essential features:

1.  Leo outlines_ show you the big picture at all times,
    while providing unlimited space for details.

2.  Leo outlines_ can organize any kind of data:
    computer programs, web sites, documentation, pictures, whatever.

3.  Clones_ allow multiple views of the data within a *single* outline_.
    You don't have to choose the 'correct' view; you can see data in many ways.

4.  Plugins_ allow Leo's users to add new features to Leo.
    Many of Leo's most successful features started life this way.

5.  Leo is a superb scripting_ environment for Python.
    Scripts contained in a Leo outline_ have easy access to all the outline's data.
    It is natural to organize Leo outlines to make life easier for scripts.

6.  Leo is `Open Software`_, written in 100% pure Python_.
    Leo runs wherever Python does.

Leo has a strong and active community of users on `SourceForge`_.
Working with this community has been a constant source of joy and inspiration.
Suggestions and plugins from users continue to drive Leo in excellent new directions.
Who knows what the next plugin will bring? -- Edward K. Ream, September, 2005</t>
<t tx="ekr.20040414172218.4">Leo owes much of its visual design to ``MORE``, possibly the most elegant computer program ever written.
Leo's clone nodes are inspired by ``MORE``.

The following people have made generous donations to the Leo project:
Robert Low, Nic Cave-Lynch.

The following people reported bugs, answered questions, and made suggestions for improving Leo: Alex Abacus, Shakeeb Alireze, Bruce Arnold, Chris Barker, Eric Brown, Darius Clarke, Bill Drissel, Wenshan Du, Allen Edwards, Chris Elliot, Mark Engleberg, Dethe Elza, Stephen Ferg, Tom Fetherston, Tomaz Ficko, Niklas Frykholm, Fred Gansevles, Jonathan M. Gilligan, Thomas Guettler, Zak Greant, Thomas Guettler, Romain Guy, Dave Hein, Tiago Castro Henriques, Gary Herron, Steve Holden, Klass Holwerda, Matthias Huening, Robert Hustead, John Jacob, Paul Jaros, Christopher P. Jobling, Eric S. Johansson, Garold Johnson, James Kerwin, Nicola Larosa, David LeBlanc, Chris Liechti, Steve Litt, Martin v. Loewis, Robert Low, Fredrik Lundh, Alex Martelli,  Marcus A. Martin, Gidion May, David McNab, Chad Netzer, Naud Olivier, Joe Orr, Marc-Antoine Parent, Paul Paterson, Davide Salomoni, Sean Shaleh Perry, Tim Peters, Scott Powell, Bruce Rafnel, Walter H. Rauser, David Speed Ream, Rich Ries, Aharon Robbins, Guido van Rossum, David Rowe, Steven Schaefer, Wolfram Schwenzer, Gil Shwartz, Paul Snively, Phil Straus, Jurjen Stellingwerff,  Jeffrey Thompson, Gabriel Valiente, Tom van Vleck, Jim Vickroy, Tony Vignaux, Ying-Chao Wang, Cliff Wells, Dan Wharton, Wim Wijnders, Vadim Zeitlin.</t>
<t tx="ekr.20040414172218.5">All parts of Leo are distributed under the following copyright. This is intended
to be the same as the Python license, namely that Leo is absolutely free, even
for commercial use, including resale. There is no GNU-like "copyleft"
restriction. This license is compatible with the GPL.
	
Copyright 1997-2006 by Edward K. Ream. All Rights Reserved. Permission to use,
copy, modify, and distribute this software and its documentation for any purpose
and without fee is hereby granted, provided that the above copyright notice
appears in all copies and that both that copyright notice and this permission
notice appear in supporting documentation, and that the names of Edward K. Ream
or Leo may not be used in advertising or publicity pertaining to distribution of
the software without specific, written prior permission from Edward K. Ream.</t>
<t tx="ekr.20040414174439">**EDWARD K. REAM (REAM) SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESSED OR IMPLIED, WITH RESPECT TO THIS COMPUTER SOFTWARE, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL REAM BE LIABLE FOR ANY LOSS OF PROFIT OR ANY COMMERCIAL DAMAGE, INCLUDING BUT NOT LIMITED TO SPECIAL, INCIDENTAL, CONSEQUENTIAL OR OTHER DAMAGES.**
</t>
<t tx="ekr.20040416075437">The following have contributed plugins to Leo: Felix Breuer, Josef Dalcolmo,
Timo Honkasalo, Andrea Galimberti, Frédéric Momméja Bernhard Mulder, Paul
Paterson, Davide Salomoni, Ed Taekema, Steve Zatz.
</t>
<t tx="ekr.20040416080538">The following deserve special mention:
David Brock wrote TSyntaxMemo.
The late Bob Fitzwater kept me focused on design. Donald Knuth invented literate programming and the CWEB language.
Jonathan M. Gilligan showed how to put the Leo icon in Leo's windows.
Joe Orr created XSLT stylesheets for Leo; see http://www.jserv.com/jk_orr/xml/leo.htm.
Joe Orr also created an outstanding set of tutorials for Leo; see http://www.evisa.com/e/sb.htm.
Bernhard Mulder proposed a new way of untangling derived files.
John K. Ousterhout created tcl/Tk. Neal Norwitz wrote PyChecker.
Marc-Antoine Parent urged me to use XML for Leo's file format and helped improve it.
Paul Paterson suggested the plugin architecture,
suggested an approach to spell checking and has contributed many excellent plugins.
Norman Ramsey created noweb and gave permission to quote from the noweb web documentation.
Rich Ries has contributed a huge number of suggestions.
Steven P. Schaefer pointed out major security problems lurking in hooks.
Gil Shwartz helped with unicode support.
Phil Straus has been a great friend and constant support.
Guido van Rossum created Python, Tkinter and the Python License.
Dave Winer created ``MORE``.
Dan Winkler helped support Leo on the Mac.

Special thanks to my family.
My brother, David Speed Ream, tested Leo and made many useful suggestions.
Rebecca, James and Linda make it all worthwhile.
It was during a conversation with Rebecca that I realized that ``MORE`` could be used as a prototype for Leo.
That was a crucial first step.</t>
<t tx="ekr.20040705111716"></t>
<t tx="ekr.20040705111716.1">Leo will write only t.unknownAttributes to the .leo file when writing the &lt;v&gt; element corresponding to the root of an @thin tree.  Leo will do this by writing a new xml attribute, say descendentTnodeUnknownAttributes, in &lt;v&gt; element.

The reason that Leo will only write t.unknownAttributes and not v.unknownAttributes is that only tnodes have gnx's in thin derived files.  In effect, vnodes are anonymous.  We could attempt to get around this by identifying vnodes by their corresponding tnodes, but that's not a general solution and it is, in effect, equivalent to writing only t.unknownAttributes.  This being so, it seems pointless to "pretend" to be writing v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using unknownAttributes is concerned.  As I've stated in the past, this won't do if, for example, a plugin is trying create an arbitrary directed graph between vnodes.  In that case, the plugin should confine itself to @file trees, or just vnodes in .leo files, for that matter.

7/1/04:

- Leo now writes "marks" and "expanded" attributes in the root &lt;v&gt; element for @thin trees.

- VERY IMPORTANT.  Leo now writes entire tree of @ignored @thin nodes.  This fixes a major bug.</t>
<t tx="ekr.20040705111716.45">Leo marks as dirty all @file nodes when they become "newly unignored".</t>
<t tx="ekr.20040705111716.126"></t>
<t tx="ekr.20040705112148"></t>
<t tx="ekr.20040705150130">Leo now generates no warnings with all significant tests enabled.  Some tests have been disabled in bases classes, and in a few cases pychecker gives erroneous warnings that have been suppressed directly in the source code using the __pychecker__ = arg syntax.</t>
<t tx="ekr.20040713110718">Leo 4.2 beta 3           August 10, 2004

This version of Leo is feature complete.  Leo's core code has been stable for several months.

To do: most plugins work with the new code base, but other plugins need some more work.

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
derived files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

- A new mod_scripting plugin is a big advance in scripting and testing.
test.leo now uses @test and @script nodes to define unit tests without
explicitly creating subclasses of unittest.TestCase. Converting scripts to unit
tests now takes a few seconds!

- A much faster and more robust spell checker plugin. (requires Python 2.3)

- Leo is now much more friendly to using spaces instead of tabs.

- The Execute Script command reports erroneous lines more clearly.

- The Perfect Import feature guarantee that Leo imports file exactly.</t>
<t tx="ekr.20040804164600.16">Leo now vetoes the shutdown logic if saving a dirty file fails.

Leo prints in red the warning about not being able save the read-only file. The
user can use the Save To command to save the file. The Save To command does not
clear the file's dirty bit, so Leo will prompt again to save the file. The user
will have to ignore this prompt in order to exit. This is correct: the
_original_ file has not been saved.</t>
<t tx="ekr.20040804164600.36">- g.getScript implicitly assumed that p == c.currentPosition.
  I removed that assumption.

- The scriptButton callback in the scripting.py plugin no longer calls c.executeScript.
  It's simpler and easier to call exec directly.

- Improved c.checkOutline:
    - Added full keyword arg.
    - Print more if verbose is on.</t>
<t tx="ekr.20040804164600.56"></t>
<t tx="ekr.20040804164600.98"></t>
<t tx="ekr.20040804164600.102">Spurious entries in a tnodeList for @thin trees wiped out all the headlines in the @thin tree.</t>
<t tx="ekr.20040804164600.265"></t>
<t tx="ekr.20040804164600.275"># The new code only writes tnodes for the current tree when pasting to the clipboard.</t>
<t tx="ekr.20040804164600.377">There was a big performance bug in the nodenavigator plugin.</t>
<t tx="ekr.20040804164600.394">@nocolor

As a result, the minimal .leo file is:

@color
@language html

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;

@nocolor

The empty_leo_file plugin now uses this code. The minimal .leo file that Leo
might actually write is more like this:

@color

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings&gt;
    &lt;find_string/&gt;
    &lt;change_string/&gt;
&lt;/find_panel_settings&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;</t>
<t tx="ekr.20040804164600.406"></t>
<t tx="ekr.20040804164600.419"></t>
<t tx="ekr.20040804164600.421">This is required to make @thin work properly.</t>
<t tx="ekr.20040804164600.424">This makes the command more useful.</t>
<t tx="ekr.20040804164600.470"></t>
<t tx="ekr.20040804164600.471">A major change: putVnode doesn't put tnodeLists for @thin nodes.

Instead it issues an informational message and deletes the tnodeList.</t>
<t tx="ekr.20040804164600.515">Leo used to allocate more positions than necessary.  This unnecessarily stressed the garbage collector.</t>
<t tx="ekr.20040804165258.1"></t>
<t tx="ekr.20040804165258.2"></t>
<t tx="ekr.20040804165258.3">Leo now allows you to select multiple files in the dialogs for all Import
commands. This fixes a major annoyance. However, you must be running Python 2.3
or above to get this feature.
</t>
<t tx="ekr.20040804165258.4">Added the Check submenu of the Outline menu. This contains the Check Outline and
Dump Outline commands, as well as four new commands:

The Check All Python Code and Check Python Code commands report any syntax errors or tabnanny errors.  These commands mark erroneous nodes.  These commands work on the selected Node and its descendants.  These commands ignore any nodes for which a) @ignore is in effect or b) @language python is in not effect.

The Check Python Code and Pretty Print Python Code commands replace nodes with their pretty-printed alternative.  No doubt everyone will have their own favorite style.  You could implement alternate pretty printers in a plugin merely by overriding the following methods of class prettyPrinter in leoCommands.py:
    
---- putOperator:      puts whitespace around operators.
---- putNormalToken:   puts whitespace around everything else.</t>
<t tx="ekr.20040804170531"></t>
<t tx="ekr.20040804170657">Leo now reuses all widgets used to draw the outline pane.  This improves performance and ends leaks of bindings and widgets.</t>
<t tx="ekr.20040804170846">@thin bad-directory caused excessive and confusing tracebacks.</t>
<t tx="ekr.20040804171818"></t>
<t tx="ekr.20040804172113"></t>
<t tx="ekr.20040804172113.1"></t>
<t tx="ekr.20040903100514">The tests::

    if p:       # Right
    if not p:   # Right

are the **only** correct ways to test whether a position ``p`` is valid.
In particular, the following **will not work**::


    if p is None:       # Wrong
    if p is not None:   # Wrong</t>
<t tx="ekr.20040914103359">Leo 4.2 release candidate 1        September 14, 2004

This version fixes a number of minor bugs reported since the last release. See
the children of this node for details.

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
derived files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

- A new mod_scripting plugin is a big advance in scripting and testing.
test.leo now uses @test and @script nodes to define unit tests without
explicitly creating subclasses of unittest.TestCase. Converting scripts to unit
tests now takes a few seconds!

- A much faster and more robust spell checker plugin. (requires Python 2.3)

- Leo is now much more friendly to using spaces instead of tabs.

- The Execute Script command reports erroneous lines more clearly.

- The Perfect Import feature guarantee that Leo imports file exactly.</t>
<t tx="ekr.20040914103359.2"></t>
<t tx="ekr.20040914103359.4"></t>
<t tx="ekr.20040914103359.7">With TclTkAqua on the Mac (but *not* with tcltk installed via Fink), the tab
problem doesn't exist there), the tab, return, and backspace keys did not generate
ASCII codes, i.e. event.char is an empty string. So when I press the tab key,
Tk inserts a tab character and Leo isn't even aware of it.</t>
<t tx="ekr.20040914103359.12">If only one file was specified Leo gave an error for every character of the file name!
</t>
<t tx="ekr.20040914103359.15"></t>
<t tx="ekr.20040914103359.19"></t>
<t tx="ekr.20040914103359.20">@killcolor

From Dan Winkler:

On a couple of occasions, I tried to paste in a long @url node and got 
this message:

	Truncating headline to 250 characters

I wonder if the 250 character limit on headline length should be 
rethought in light of the @url directive and long web addresses.</t>
<t tx="ekr.20040914103359.21">def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c

    if not p or not p.isCurrentPosition():
        return "break"
        
    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    &lt;&lt; set head to vnode text &gt;&gt;
    done = ch in ('\r','\n')
    if done:
        &lt;&lt; set the widget text to head &gt;&gt;
    &lt;&lt; set s to the widget text &gt;&gt;
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        &lt;&lt; update p &gt;&gt;
    if done or changed:
        &lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;
        &lt;&lt; update the screen &gt;&gt;

    g.doHook("headkey2",c=c,p=p,ch=ch)
    return "break"</t>
<t tx="ekr.20040914103359.22">head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")</t>
<t tx="ekr.20040914103359.23">self.setText(edit_text,head,tag="idle_head_key")
edit_text.mark_set("insert",index)</t>
<t tx="ekr.20040914103359.24">s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i &gt; -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) &gt; limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')</t>
<t tx="ekr.20040914103359.25">c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    # Bug fix 8/2/04: must call p.setDirty even if p is dirty!
    p.setDirty()
    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s,tag="idle_head_key2")
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.</t>
<t tx="ekr.20040914103359.26"># Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))</t>
<t tx="ekr.20040914103359.27">if done:
    # g.trace("done")
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.</t>
<t tx="ekr.20040914103359.28"></t>
<t tx="ekr.20040914103359.31"></t>
<t tx="ekr.20040914103359.37"></t>
<t tx="ekr.20040914103359.47">There were too many problems with this feature.  In the future Leo will have a Check Import command.</t>
<t tx="ekr.20040914103359.110"></t>
<t tx="ekr.20040914103359.127">Leo wasn't always traversing the outline correctly when looking for @root nodes.</t>
<t tx="ekr.20040914103359.129">http://sourceforge.net/forum/message.php?msg_id=2742238
By: hinsen

The shortcut definitions in Leo are quite inconvenient on the Mac, as those
using the Alt key don't work. Alt is used for entry of additional characters.
On the other hand, ctrl is available for shortcuts but not used in Leo, since
the ctrl-based shortcuts are shifted to the command key (following standard
Mac practice).

The patch at the end of this message simply shifts all Alt-shortcuts to Ctrl
on the Mac.

That leaves one minor clash: Command-` is used for CloneNode in Leo, although
it canonical MacOS function (switching between the windows of an application)
would be very useful in Leo as well. Removing the CloneNode binding is easy
enough, but it seems that I must implement a window switching function myself.
Not today :-)

Konrad.
</t>
<t tx="ekr.20040914103359.137"></t>
<t tx="ekr.20040914103743"></t>
<t tx="ekr.20040914103743.1"></t>
<t tx="ekr.20040922074200">Leo 4.2 Final       September 20, 2004

The highlights of Leo 4.2:

- @thin trees make Leo much more friendly to cvs. Files derived from @thin can
be committed to cvs and updated from cvs without having to commit or update the
corresponding .leo file. There is no longer any need to keep .leo files and
derived files in synch.

- Leo's data structures have been reorganized. As a result, all outline
operations are much faster. To support this organization, scripts that traverse
Leo's data structures must now use a positions rather than vnodes. Old scripts
that appear to use vnodes will still work because methods like c.currentVnode
that appear to return vnodes actually return positions.

- A new mod_scripting plugin is a big advance in scripting and testing.
test.leo now uses @test and @script nodes to define unit tests without
explicitly creating subclasses of unittest.TestCase. Converting scripts to unit
tests now takes a few seconds!

- A much faster and more robust spell checker plugin. (requires Python 2.3)

- Leo is now much more friendly to using spaces instead of tabs.

- The Execute Script command reports erroneous lines more clearly.</t>
<t tx="ekr.20041226081019">c.spellCommands.openSpellTab()</t>
<t tx="ekr.20050122084954">Leo stores options in @settings trees, that is, parts of Leo outlines whose root node has the headline @settings.  When opening a .leo file, Leo looks for @settings trees in the following places:

- The file called leoSettings.leo in the leo/config directory.
- The file called leoSettings.leo in the users home directory.
- The file being loaded.

Settings that later in the above list override settings found earlier. For example, any setting specified in an @settings tree in the file being loaded overrides any setting seen in any leoSettings.leo file.

The Settings command temporarily replaces the outline pane with an outline showing all the @settings trees in effect. The Settings command also replaces the body pane with a "settings dialog" pane. This settings dialog pane
allows you to change the settings selected in the outline pane using standard gui widgets.

The format of nodes in @settings trees are as follows:

1. "Simple settings nodes" have headlines of the form:

@&lt;type&gt; name = val

set the value of name to val, with the indicated type.

&lt;type&gt; may be one of the following, with valid values shown:

&lt;type&gt;          Valid values
-----           ------------
\@bool           True, False, 0, 1
\@color          A Tk color name or value, such as 'red' or 'xf2fddff' (without the quotes)

For a list of Tk color specifiers see:

- http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm
- http://www.tcl.tk/man/tcl8.4/TkLib/GetColor.htm

\@directory      A path to a directory
\@float          A floating point number of the form nn.ff.
\@int            An integer
\@ints[list]     An integer (must be one of the ints in the list).
                 Example: @ints meaningOfLife[0,42,666]=42
\@path           A path to a directory or file
\@ratio          A floating point number between 0.0 and 1.0, inclusive.
\@shortcut       A valid shortcut specifier.
\@string         A string
\@strings[list]  A string (must be one of the strings in the list).
                 Example: @strings tk_relief['flat','groove','raised']='groove'

2. "Complex settings nodes" have headlines of the form:

\@&lt;type&gt; description

The actual settings are specified in the body text.  At present, there are two such kinds of complex settings nodes:

- @font

The body text contains a list of settings for a font.  For example:

body_text_font_family = Courier New
body_text_font_size = None
body_text_font_slant = None
body_text_font_weight = None

- @recentFiles

The body text contains a list of paths of recently opened files, one path per line.

Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.

3. "Page nodes" have headlines of the form @page &lt;description&gt;

Such nodes have the effect of gathering all descendant settings nodes into a single settings page.

4.  All other nodes are "Organizer" nodes.  Such nodes have no effect on the settings shown in the dialog.  You may use them as you please to organize settings.

Notes:

A.  At present, you can not change @settings trees while executing the Settings command.  You can, however, change any @settings tree normally when not executing the Settings command.

B. Other kinds of settings nodes are planned for future releases.</t>
<t tx="ekr.20050122090311">Leo 4.3 alpha 1                 January 24, 2005

Leo 4.3 is the culmination of more than four months of work. 

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. You never have to mess with
pluginsManager.txt again! This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail.</t>
<t tx="ekr.20050122091036">The essential features of @settings trees and the settings dialog appear to be stable.  However, many improvements can be imagined, including the following:

- Allow searching for nodes while in the settings dialog.

- Allow adding, deleting, rearranging nodes while in the settings dialog.

- Allow adding, deleting, rearranging recent files while in the settings dialog.

These will be added as time permits and people request.</t>
<t tx="ekr.20050123092834.1"></t>
<t tx="ekr.20050123092834.2"></t>
<t tx="ekr.20050123092834.6">The Open With logic in createOpenWithMenuFromTable for the 'spawnv' case  now actually calls os.spawnv (rather than spawnl) and it allows a variable length list of parameters.</t>
<t tx="ekr.20050123092834.19">The old code wasn't handling single file selections properly.  The new code works around an apparent bug in Tk.askopenfilename.</t>
<t tx="ekr.20050123092834.27">The new code forbids Paste Node As Clone if the paste would result in a node being a clone of itself.</t>
<t tx="ekr.20050123092834.42">The '@' sign is an operator in Python 2.4, not an error token.</t>
<t tx="ekr.20050123092834.71">What I did:
    
- Created a new top-level method: scanHeaderForThin.

This sets self.encoding temporarily. The actual value of self.encoding does not
really matter: no errors will be given by readLine and its helpers even if there
are unicode encoding errors.

- We must _not_ set self.encoding in scanHeader: that would interfere with
normal initialization.</t>
<t tx="ekr.20050123092834.81">- Restored non Pmw code in resizePanesToRatio.  This code got deleted by mistake.  The Equal Sized Panes works again.

- Added many do-nothing methods to nullMenu class.

This should prevent the startup logic from messing with shortcuts in any way.  It's also the right thing to do.

- Added an entry for EqualSizedPanes to leoSettings.leo.  This overrides the default (Ctrl-E) and thereby prevents the default from overriding the entry for ExecuteScript!

- Re-enabled code in createMenuEntries that warns when shortcuts have been redefined.  Not sure if this is a wise idea, or indeed if it actually does anything :-)

I am tempted to remove all the default entries entirely.  This would simplify error reporting, but then Leo would hardly work at all if leoSettings.leo were not present.</t>
<t tx="ekr.20050123092834.159"></t>
<t tx="ekr.20050123092834.160">p.moveToParent now just returns if p is a null position.</t>
<t tx="ekr.20050123092834.163"># Leo looped after this assert failed.</t>
<t tx="ekr.20050123092834.165"></t>
<t tx="ekr.20050123092834.166">he readDirective method was changing the comment delimiters as the result of
seeing the sentinels corresponding to @language or @comment directives. But in
general this makes no sense! Comment delimiters should be set once and for all
in the @+leo sentinel: there is no compiler in the world that tolerates mixed
comment delimiters.

BTW, the way to set javascript "inner" comments is to use @delims, not @comment.
N.B. The @language and @comment delimiters _will_ have an effect, and that
effect is in the _write_ logic, not the read logic. The effect is to set the
comment delims in the @+leo sentinel.

The quick fix is to comment out code in readDirective.</t>
<t tx="ekr.20050123092834.173"></t>
<t tx="ekr.20050123092834.176">The old code did not honor the @lineending directive if the two files would otherwise be identical.

What I did:

- Added self.explicitLineEnding to remember whether an explicit @lineending directive is in effect.

- Make sure the user knows why an otherwise identical file was written.

- Changed name of compareFilesIgnoringNewlines to compareFiles.

- Added ignoreLineEndings arg to compareFiles.</t>
<t tx="ekr.20050123092834.196">The fix was to add nosentinels=nosentinels in the call to initWriteIvars in atFile.write.</t>
<t tx="ekr.20050123092834.422">This method now does nothing if at.toString is True.</t>
<t tx="ekr.20050123092834.424"></t>
<t tx="ekr.20050123092834.431"></t>
<t tx="ekr.20050123092834.432">Leo did not correctly write adjacent @doc parts in @file trees.  Leo could not read the resulting derived files!

The bug happened if any node in an @file tree contains adjacent @doc parts, like this:

@  first doc part
...
@ second doc part
...

Leo failed to write the closing #@-at sentinel that would finish the first @doc part.</t>
<t tx="ekr.20050123092834.434">The new code uses protocol=1 instead of the deprecated bin argument to Pickler.</t>
<t tx="ekr.20050123092834.438"></t>
<t tx="ekr.20050123092834.439">The problem was that nullLog.write calls print, and if print is redirected the
code ends up calling nullLog.write again.

What I did:

- g.redirectClass.redirect does nothing if g.app.batchMode is True.
- added g.rawPrint.
- Changed self.old.write(s) to self.old.write(s+'\n') throughout.</t>
<t tx="ekr.20050123092834.474">It makes no sense to use only the selected text.</t>
<t tx="ekr.20050123092834.480">The old code assumed that the error is always in the script itself. Not true!
The error could happen in methods called by the script.

This code works with Python 2.3.4 and Python 2.4.  It may be version dependent.</t>
<t tx="ekr.20050123092834.486"></t>
<t tx="ekr.20050123092834.487">Leo now sets the name of the frame to the requested file name on the command line even if the file name does not exist.</t>
<t tx="ekr.20050123092834.490">The code now clears previous shortcut, and tells what the previous entry was.</t>
<t tx="ekr.20050123092834.491">Changed the open command associated with .leo files on Windows from:

pythonw.exe "&lt;leodir&gt;\src\leo.py" %1

to:

"pythonw.exe" "&lt;leodir&gt;\src\leo.py" "%1"

The difference is in quotes.  Especially quotes around "%1" seem to matter.</t>
<t tx="ekr.20050123092834.492">This is an important difference. imp.load_module is equivalent to a reload, so
we must not call this if the module already exists!</t>
<t tx="ekr.20050123092834.497">Leo did not properly write derived files that contained section references to grand-children.

For example:

&lt;&lt; current level&gt;&gt;
  reference to &lt;&lt; 3. level&gt;&gt;
    &lt;&lt; 1.level&gt;&gt;
        &lt;&lt; 2.level &gt;&gt;
            &lt;&lt; 3.level&gt;&gt;

The fix was simply to reverse the order in which putRefAt puts +middle and -middle sentinels.</t>
<t tx="ekr.20050123092834.499">In some cases g.app.config.output_newline was None.  The new code sets the default to '', and then assigns a valid default to ''.</t>
<t tx="ekr.20050123092834.502">This binds scroll-wheel events to Button-4 and Button-5
</t>
<t tx="ekr.20050123092834.506">chapters.py requires that the canvas have a name ivar.

Added treeCanvas.name = '1' in:
    
&lt;&lt; replace tree pane with settings tree &gt;&gt;</t>
<t tx="ekr.20050123092834.510"></t>
<t tx="ekr.20050123092834.517">Leo can still read such files, but old-style file formats are now deprecated</t>
<t tx="ekr.20050123092834.520">The new code greatly simplifies the class structure. The intention is to allow plugins to override methods of this file more easily.

The highlights:

- Plugins may now override methods in this file much more easily.
    - All code is now in a single class.
    - Resolved the few name conflicts by renaming x to x3 or x4.
    - The new code generally uses methods instead of sections.
    - Initialiation is now simple and sane, and is done in dedicated methods.
    - All constants are class constants: no more module-level constants.

- All top-level methods support toString or fromString arguments.</t>
<t tx="ekr.20050123092834.526">Fixed shawdow warnings.  The following are all Python global functions:

cmp -&gt; compare
dict -&gt; theDict
dir -&gt; theDir
file -&gt; theFile
id -&gt; theId
type -&gt; theType
input  (suppressed the warning)
iter -&gt; theIter</t>
<t tx="ekr.20050123092834.544">Apparently distutils.file_util is not present in all Python distributions!

New approaches:
    - Fall back on code in distutils.file_util if import fails.
    - Make sure the src and dst volumes are the same (so Linux os.rename will always work)
    - Simplify replaceTargetFileIfDifferent by creating new routines.

What I did:
    - Rewrote replaceTargetFileIfDifferent in terms of atFile.rename, atFile.remove, etc.
    - Rewrote update_file_if_changed in terms of g.utils_rename, g.utils_remove, etc.</t>
<t tx="ekr.20050123092834.565">Leo's code now contains an important simplification to Leo's gui code. This
arose because of a problem in the UNL plugin. The window that opened when double
clicking an @url UNL node wasn't staying on top.

It turns out that this was essentially impossible to fix with the old code. The
proximate cause of the original problem button-1 was bound to OnActivateTree,
which called g.app.gui.set_focus after the new window was visible, thereby
bringing the old tree to the front.

Further investigation revealed other problems. For example, the idle-time code
in the status line logic was also messing with the focus. It turns out that
repeatedly calling g.app.gui.set_focus is a very bad idea, for lots of reasons
which I won't go into in detail here.

The old code called g.app.gui.set_focus explicitly whenever it wanted focus to
change. But there is a much better way, namely to have routines that _indicate_
where they want the focus to be "after the dust settles", that is, when all gui
calls have been completed. I call this a "delayed focus" scheme.

So I rewrote all the code that sets the focus. The new code replaces direct
calls to g.app.gui.set_focus with calls to the following methods in
leoTkinterFrame class: bodyWantsFocus, statusLineWantsFocus, treeWantsFocus and
logWantsFocus. Actually, these xWantsFocus methods all do the same thing, but
using different methods improves traces.

This is an excellent pattern. Again, rather than setting the focus directly,
these xWantsFocus methods merely signal their intension to set the focus. This
allows very complex logic to be hidden in leoTkinterFrame.set_focus.

leoTkinterFrame.set_focus is indeed complex. It took me several hours this
morning to get it just right. It queues up a 'one-shot' callback. That is, at
most one copy of the callback is ever waiting to be executed. Furthermore, the
callback is only queued for execution at the result of a call to xWantsFocus; it
is never run automatically at idle time. Finally, even when executed, the
callback does nothing if the last requested commander (in the new ivar,
g.app.wantedFocus) does not match the commander to which the callback was bound.

These checks allow the UNL plugin to open a window properly and keep it topmost.

This is a big step forward for Leo, for the following reasons:

- Delayed focus ensures that the body pane always has focus unless the code has
a specific, positive reason for the focus to be elsewhere. This was difficult
(or rather impossible) to do with the old code: there are _many_ Tk calls that
can affect the focus.

- Delayed focus minimizes calls to g.app.gui.set_focus. Unlike the old code,
many seconds may elapse between calls. The stress on Tk is much less, and I
believe this may cure some flakiness in how focus changes, especially in
headlines.

- There are some cases where focus must change immediately. The xWantsFocus
methods all support a 'later' keyword argument. By default it is True, but when
it is False leoTkinterFrame.set_focus calls g.app.gui.set_focus immediately.

- The xWantsFocus methods all support a 'tag' keyword argument that tells what
routine the method is called from. It is a big help in making sense of traces.
BTW, extensive traces are the _only_ possible way of tracking down
focus/selection problems.</t>
<t tx="ekr.20050123092834.896"></t>
<t tx="ekr.20050123092834.897">These commands work as do the similar commands in Windows Explorer. How did we
ever live without them?</t>
<t tx="ekr.20050123092834.901">This supports the fromString option in read commands.</t>
<t tx="ekr.20050123092834.903">Thanks to Bernhard Mulder for the new code.</t>
<t tx="ekr.20050123092834.908">- Tab toggles between the Search to the Replace areas.

- Control-Tab inserts a tab.

- Added hot keys for all settings.  Use Alt-x to activate hot key x.
  The Enter key activates the Find button.

- As usual, Alt-F4 dismisses the Find panel.</t>
<t tx="ekr.20050123092834.928">It's not clear that this support is so useful for debugging scripts.

If g.app.debugSwitch is True es_exception gives a full traceback.</t>
<t tx="ekr.20050123092834.929">Thanks to David McNab &lt;david@freenet.org.nz&gt; for this work.</t>
<t tx="ekr.20050123092834.961">- Go To Line Number command now assumes the presently selected node is a script if there is no ancestor @file node.

- Execute Script command uses this new logic to select the proper node and line in a script if there is an error.

How did we ever live without these features?</t>
<t tx="ekr.20050123092834.984">Restored the following hooks:
    
"boxclick1"     before click in +- box            c,p,v,event
"boxclick2"     after  click in +- box            c,p,v,event
"drag1"         before start of drag              c,p,v,event
"drag2"         after  start of drag              c,p,v,event
"dragging1"     before continuing to drag         c,p,v,event
"dragging2"     after  continuing to drag         c,p,v,event
"enddrag1"      before end of drag                c,p,v,event
"enddrag2"      after  end of drag                c,p,v,event

The following already existed.  I added v=p keyword params:

"iconclick1"    before single click in icon box   c,p,v,event
"iconclick2"    after  single click in icon box   c,p,v,event
"iconrclick1"   before right click in icon box    c,p,v,event
"iconrclick2"   after  right click in icon box    c,p,v,event
"icondclick1"   before double click in icon box   c,p,v,event
"icondclick2"   after  double click in icon box   c,p,v,event</t>
<t tx="ekr.20050123092834.1004">Changed these hooks:

"bodyclick1", "bodyclick2",
"bodydclick1", "bodydclick2",
"bodyrclick1", "bodyrclick2",
"bodykey1", "bodykey2",
"command1", "command2",
"headclick1", "headclick2",
"headrclick1", "headrclick2",
"headkey1", "headkey2", 
"hyperclick1", "hyperclick2",
"hyperenter1", "hyperenter2",
"hyperleave1", "hyperleave2", 
"openwith1", "openwith2",
"menu1", "menu2", 
"recentfiles1", "recentfiles2",
"save1", "save2",
"select1", "select2", "select3",
"start2",
"unselect1", "unselect2",
"url1", "url2", 

"clear-mark", "set-mark", 
"color-optional-markup",
"create-popup-menu", 
"draw-outline-icon",
"draw-outline-node",
"draw-outline-text-box",
"draw-sub-outline", 
"init-color-markup",
"scan-directives", 
"draw-outline-box",
"enable-popup-menu-items",
"show-popup-menu",</t>
<t tx="ekr.20050123092834.1005">Leo no loner has any global windows!

- Each commander has its own find window.
    - It's title tells to what commander it applies.
</t>
<t tx="ekr.20050123092834.1011">computeHomeDir() now test the first retrieval of the %HOME% var and grab it's
results if it is in fact another environment variable.</t>
<t tx="ekr.20050123092834.1013"></t>
<t tx="ekr.20050123092834.1018">Actually, support already existed for them in getBaseDirectly!

What I did.

- Added a c keyword to getBaseDirectory.
- Added similar logic to os_path_join.

- Changed some stupid code in g.openWithFileName (called by @url logic):
    changed: fileName = g.os_path_join(os.getcwd(),fileName)
    to:      fileName = g.os_path_abspath(fileName)

MAYBE g.os_path_abspath should force '.' to mean c.openDir, but I kinda doubt
it. This could be asking for trouble.

OTOH, the various flavors of scanAllDirectives already do this.  Hmmmmmm.</t>
<t tx="ekr.20050123092834.1043"></t>
<t tx="ekr.20050123092834.1044"></t>
<t tx="ekr.20050123092834.1047">- This plugin now handles both kinds of triple-quotes correctly so that both
kinds of docstrings are recognized.

- This plugin now is controlled by the first reference to a plugin in
pluginsManager.txt. All other references are ignored.</t>
<t tx="ekr.20050123092834.1052">Created callTagHandler. This checks 'idle' hooks to make sure that any commander
referenced by the 'c','new_c' or 'old_c' keywords still exists.</t>
<t tx="ekr.20050123092834.1057">leoPlugins.registerOneHandler wasn't working properly at all. In effect, only
the last registered hook was ever being remembered!</t>
<t tx="ekr.20050123093854.1">tnodes_iter and unique_tnodes_iter were returning vnodes, not tnodes!</t>
<t tx="ekr.20050123100706.1"></t>
<t tx="ekr.20050123100706.2"></t>
<t tx="ekr.20050123101208"></t>
<t tx="ekr.20050123103303"></t>
<t tx="ekr.20050123103303.1"></t>
<t tx="ekr.20050123103521"></t>
<t tx="ekr.20050123103753"></t>
<t tx="ekr.20050123105026">- Leo now ignores all find settings in .leo files.  Instead, Leo inits find settings from @settings entries.

- Removed all c ivars corresponding to leoFind ivars.
    - This eliminates the ugliest code in Leo.
    - Inits all leoFind ivars from @settings in init, a helper of the ctor.
    - Updates all the leoFind ivars in update_ivars, called just before doing any find.

- Removed the _flag suffix from leoFind ivars.
    - Another major mess cleaned up.

- Renamed find/change_text to find/change_ctrl to avoid name conflict.</t>
<t tx="ekr.20050123110009">Leo now stores options in @settings trees, that is, outlines whose headline is '@settings'. When opening a .leo file, Leo looks for @settings trees not only in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be infinitely flexible. That goal has been accomplished. Indeed, users can create arbitrarily complex user options with @settings trees. Leo settings outlines are, in fact, infinitely more flexible and powerful than any scheme based on flat text.

The Settings command temporarily replaces the outline pane with an outline showing all the @settings trees in effect. The Settings command also replaces the body pane with a "settings pane". This settings pane allows you to change the settings selected in the outline pane using standard gui widgets. The settings pane is dynamically created from nodes in the settings tree; it is as extensible as the @settings tree itself.

For full details, see the children of this node.</t>
<t tx="ekr.20050123111723"></t>
<t tx="ekr.20050123112151">- leoPlugins.doHandlersForTag now executes the list of hook handlers for a
particular tag (hook name) until one of the handlers returns a non-None result.
doHandersForTag no longer tries to "sort" handlers, so the order that the
handlers are executed is the order in which they were registered.

I finally understand the concerns people have raised several times about hooks
interfering with each other. If two handlers try to return a non-None result
only one of them will ever execute. doHandlersForTag can't do much about this: a
better solution would require more conceptual framework. Not now...</t>
<t tx="ekr.20050123112834"></t>
<t tx="ekr.20050123115804">Leo now boasts a wonderful new Plugins Manager plugin.  This plugin enables and disables plugins automatically.  You never have to mess with pluginsManager.txt again!  This plugin also tells you everything you need to know about each plugin.  Finally, this plugin also lets you download plugins from Leo's cvs site!  Many thanks to Paul Patterson for this excellent work.

Note.  The Plugins Manager plugin requires Pmw.  You can install Pmw in Leo's extensions directory if you like.</t>
<t tx="ekr.20050123115804.1">You can can import any extension to Leo by putting the extension in the 'extensions' directory and using g.importExtension to import it.

- created the 'extensions' directory and g.app.extensionsDir

- created g.importModule and g.importExtension</t>
<t tx="ekr.20050123151338">Changed scanDirectives and atFile.scanDirectives so they work like tangle.scanAllDirectives.  Also added a few clarifying words in LeoDocs.leo.

This should have worked, but didn't:

+ Code 
  @language python 
  + @file sql_create.sql 
    @comment -- 
 
So I rearranged the outline (probably more logical anyway) to  
+Code 
  + Python 
  ... 
+ SQL 
  ... </t>
<t tx="ekr.20050126100405">Leo 4.3 alpha 2                 February 14, 2005

Leo 4.3 is the culmination of more than four months of work. This alpha 2
release corrects various bugs and distribution problems.

a2 also adds several new features:

- Adds 'word', 'line' and 'node' undo granularities.
- Predefines 'c','g', and 'p' in scripts and unit tests.
- Added support for top-level init functions in plugins.
- Buttons can remove themselves when their scripts fail.

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. You never have to mess with
pluginsManager.txt again! This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail.  Leo is distributed with Pmw (Python Mega Widgets) in this directory.</t>
<t tx="ekr.20050126100405.1"></t>
<t tx="ekr.20050130112336.1">Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.</t>
<t tx="ekr.20050209141626.3"></t>
<t tx="ekr.20050209141626.4">http://sourceforge.net/forum/message.php?msg_id=2795653

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. There is no longer a node selected in the tree so keyboard tree navigation etc commands don't work until you click on something with the mouse

-----

http://sourceforge.net/forum/message.php?msg_id=2795656

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. Hit Hoist before clicking on anything

Now you are hoisted on the recently removed node! The node is dead but his memory lives on ...</t>
<t tx="ekr.20050209141626.8"></t>
<t tx="ekr.20050209141626.12"></t>
<t tx="ekr.20050209141626.13"></t>
<t tx="ekr.20050209141626.16">http://sourceforge.net/forum/message.php?msg_id=2966541

---- Report:

"Recent Files"  is not remembering files after one closes all open leo sessions.

But it does update the "Recent Files" list while leo is open in the same session.
If one opens more files it adds them to the list. But close all files and Leo
forgets them all.

---- Added to @recentfile documentation: 

Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.</t>
<t tx="ekr.20050209141626.23">http://sourceforge.net/forum/message.php?msg_id=2960328

Symptom

Can not import messages were not being sent to the console, even though there is a call to es in g.cantImport.

What I did

- The code in g.es now checks for nullLog as well as log == None when deciding when to queue messages.

- g.openWithFileName now calls g.app.writeWaitingLog immediately after enabling the new log.

This writes the queued log messages in the proper order: a major advance in clarity.

- Added silent param to two methods.

This allows the 'reading settings from' message to be sent to the log instead of the default 'reading' message.</t>
<t tx="ekr.20050209141626.42"></t>
<t tx="ekr.20050209141626.43">The new code no longer requires that the present node have a tnodeList.

File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3830, in putOpenNodeSentinel
    at.root.v.t.tnodeList.append(p.v.t)
    
AttributeError: 'tnode' object has no attribute 'tnodeList'</t>
<t tx="ekr.20050209141626.46">The message 'command for widget 5' was a message from Tk saying in effect that no command was bound to the button.

Indeed, this was so: a recent botch in a change in mod_scripting.py prevented the binding.

Moreover, there were some extra print statments in the g.es logic for the Mac.</t>
<t tx="ekr.20050209141626.53">This makes the test more robust in case of failure.</t>
<t tx="ekr.20050209141626.54">Changed the setup code for the import/export test cases so that it uses os.path.sep when it sees \\ in the test nodes.

With this change all unit tests pass on the Mac as well as on XP.</t>
<t tx="ekr.20050209141626.55">*None* of the local settings were working(!!)

The old init code in the configSettings class had no chance of working. We must
use the full g.app.config.get logic.

Added some very simple unit tests to make sure the basics will never break
again so easily.</t>
<t tx="ekr.20050209141626.91">There were problems searching for whitespace.

Note: it just ran slowly &amp; silently.</t>
<t tx="ekr.20050209141626.101"></t>
<t tx="ekr.20050209141626.102">http://sourceforge.net/forum/message.php?msg_id=2958470

I opened a new .leo file, and the cursor was flashing in the text box. I started
typing "@language", and found that the first character is in the text box, and
the rest is in the headline!

What I did:

This was the result of a race condition in the new scheme for setting focus. I
rewrote set_focus so the delayed callback always sets the last requested focus.
The new code also takes care to clear the last request after fulfilling it.</t>
<t tx="ekr.20050209141626.105">http://sourceforge.net/forum/message.php?msg_id=2958470

All changes were to g.app.leoID():

- Fixed bug:  set g.app.leoID in &lt;&lt; put up a dialog requiring a valid id &gt;&gt;.
- Improved signon message.
- Better error handling and reporting. </t>
<t tx="ekr.20050209141626.113">This now works: g.es('ﺻﺱ',color='red')

g.es must send the original unicode string to the log pane widget, NOT an encoded string.</t>
<t tx="ekr.20050209141626.114">http://sourceforge.net/forum/message.php?msg_id=2983923

- Replaced string.+ with string.% in numerous places.
- Simplified g.openWithFileName and corrected problems in error-reporting logic.</t>
<t tx="ekr.20050209141626.150"></t>
<t tx="ekr.20050209141626.185">When loading plugins, the Leo checks to see if the plugin has an init function
at the top level (the module level). If so, Leo calls the init function. This
function should return True (or equivalent) if the module loaded correctly.

If the top-level init function does not exist, Leo assumes the module loaded
correctly.</t>
<t tx="ekr.20050209141626.190"></t>
<t tx="ekr.20050209141626.193"></t>
<t tx="ekr.20050209141626.194">A script in an @button node or script node can now request to be removed by
setting g.app.scriptDict['removeMe'] = True. Leo checks this value after
executing the script in the button.</t>
<t tx="ekr.20050209141626.195"></t>
<t tx="ekr.20050209141626.196">@nocolor

Added define_p keyword arg in executeScript. When True (the default), the script
or unit test is run in an environment in which ``c``, ``p`` and ``g`` are all defined.
``c`` is the commander for the outline in which the script appears.
``p`` is the same as ``c.currentPosition`` and ``g`` is the leoGlobals module.

Therefore, the following lines need never appear in scripts or unit tests!

@color

import leoGlobals as g
p = c.currentPosition()</t>
<t tx="ekr.20050209141626.198"></t>
<t tx="ekr.20050210101318">Typing return now correctly invokes the Find button, without adding a newline in the find string.</t>
<t tx="ekr.20050210102150"></t>
<t tx="ekr.20050210102150.1"></t>
<t tx="ekr.20050210102358"></t>
<t tx="ekr.20050211095754">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2990951
Milan Melena

I think, I found two bugs:

1) leoAtFile.py:
&lt;&lt; read optional encoding param &gt;&gt;
changed first instance of i = j + 1 to i = j + 2

2) leoGlobals.py
g.getScript now returns with

if at.output_newline == 'crlf':
    return script.replace("\r\n","\n")
else:
    return script</t>
<t tx="ekr.20050212054743">At present, such indented blocks may not contain Leo directives or section references.  This will be fixed in 4.3a3.</t>
<t tx="ekr.20050212144116">1. (fixed) C:\prog\leoCVS\leo\src\leoCommands.py:4539: No global (loadDir) found
    # Would cause leoSettings.leo in Window menu to crash.
    
2. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:3426: No global (local) found
    
    # Local --&gt; locale
    # Might cause getpreferredencoding to fail on *nix.
    
3. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:4152: No global (testing) found
    # Should be self.testing.
    
4. (fixed) mu problems:
    - Changed x to self.x:
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3795: No global (removeSentinelsFromLines) found
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3838: No global (getSentinelsFromLines) found
    - Changed self.x to g.x:
        C:\prog\leoCVS\leo\src\leoGlobals.py:3854: No class attribute (comment_delims_from_extension) found
    - pull_source has been renamed, I don not know to what.
        C:\prog\leoCVS\leo\src\leoGlobals.py:4170: Object (mu) has no attribute (pull_source)
        (commented out the code that contains this)
        
5. (removed code) from &lt;&lt; create a node p for  kind &amp; root2 &gt;&gt;
    - last_p is None at first, so last_p.insertAfter does not make sense.</t>
<t tx="ekr.20050219093156">@nocolor

c.frame.menu.createMenuItemsFromTable will append items to the end of an existing menu.  For example, the following script will add a new item at the end of the 'File' menu. 
@color

def callback(*args,**keys):
    g.trace()

table = (("Test1",None,callback),)

c.frame.menu.createMenuItemsFromTable('File',table)

@nocolor
Plugins can do anything that can be done with Tk using the menu returned by c.frame.menu.getMenu.  For example, here is a script that adds a Test menu item after the 'Open With' menu item in the File menu.
@color

def callback(*args,**keys):
    g.trace()

fileMenu = c.frame.menu.getMenu('File')

# 3 is the position in the menu.  Other kinds of indices are possible.
fileMenu.insert(3,'command',label='Test2',command=callback)</t>
<t tx="ekr.20050219093156.1"></t>
<t tx="ekr.20050219093156.2">The authoritative source for information.</t>
<t tx="ekr.20050221104844">Leo 4.3 alpha 3                 February 24, 2005

Leo 4.3 is the culmination of more than five months of work. This alpha 3
release corrects various bugs in Leo's core and in plugins. This is the first
release that include an installer for MacOSX.

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. You never have to mess with
pluginsManager.txt again! This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.</t>
<t tx="ekr.20050221104844.2"></t>
<t tx="ekr.20050221104844.3">http://sourceforge.net/forum/message.php?msg_id=2998446
By: djsg

g.create_temp_name() calls tempfile.mktemp or mkstemp(), but these return different values!

mktemp returns the filename(a string); mkstemp returns a tuple (handle,filename)

What I did:

- Changed g.create_temp_name to g.create_temp_file.
- Removed the file open logic in tangle.put_all_roots (now done in g.create_temp_file)
- Rewrote g.create_temp_file so it works in both cases.
- Create test routine for g.create_temp_file
- Created very simple unit tests in test.leo for tangle and untangle.</t>
<t tx="ekr.20050221104844.12">http://sourceforge.net/forum/message.php?msg_id=2999651

I was pleasantly surprised to discover the reST2 plug-in working under 4.3a2
(this is one the first thing I try as I'd like to use Leo as an editor
for that).

As mentioned in early threads, it still needs @rst for each node to be included
in the reST rendering process. So I put @rst test.html and then a child with
@rst and some reST code and it worked !!

Then I tried to to get a simple rst file using @rst test but the plugin complained:

[snip]

  File "C:\dn_apps\Leo\plugins\rst2.py", line 164, in onIconDoubleClick
    writeTreeAsRst(rstFile,fname,p,c)
TypeError: writeTreeAsRst() takes exactly 5 arguments (4 given)

So I looked at the rst2.py and found a way to get it working but I would need
someone to verify it :

line 164, replaced   writeTreeAsRst(rstFile,fname,p,c)  by

syntax = False
writeTreeAsRst(rstFile,fname,p,c,syntax)

And it worked!
</t>
<t tx="ekr.20050221104844.14"></t>
<t tx="ekr.20050221104844.27">http://sourceforge.net/forum/message.php?msg_id=3005140
By: ktenney

- perform a search which marks a number of nodes
- select "Outline -&gt; Mark/Unmark -&gt; Unmark All"
- Several marks are still listed in in the nodenavigator "Marks" list.
  (They are not marked in the outline.)

What I did:

- The p.set/clearMark methods now call the hook _after_ changing the marked status.
  This fixes the apparent bug in nodenavigator.py.
- Rewrote nav_buttons.py.  The old code was a mess; the new code is clean.
- Changed the vnodeList ivar in leoTkinterDialog to positionList.
- Rewrote c.unmarkAll to make clear that it is using positions.
    - Added test_c_unmark_all test routine.</t>
<t tx="ekr.20050221104844.45">http://sourceforge.net/forum/message.php?msg_id=2958470
From: Rich

Leo 4.3 alpha 1, build  1.208 , January 24, 2005
Python 2.3.4, Tk 8.4.3, win32

Opened a new .leo file. It asked for an ID, and said it saved it. Closed the
new leo file &amp; tried opening "Leo\config\leoSettings.leo". _It_ is asking for
a leoID!

What I did

All changes were to g.app.leoID():
    - Fixed bug:  set g.app.leoID in &lt;&lt; put up a dialog requiring a valid id &gt;&gt;.
    - Improved signon message.
    - Better error handling and reporting. </t>
<t tx="ekr.20050221104844.54">g.pdb wasn't working because pdb wasn't imported inside the function.</t>
<t tx="ekr.20050221104844.57"></t>
<t tx="ekr.20050221104844.58">This allows plugins such as plugin_manager.py to work on Python 2.2.x.</t>
<t tx="ekr.20050221104844.59">g.es does nothing if color=='suppress'.  This can be useful in unit tests.</t>
<t tx="ekr.20050222100936">http://sourceforge.net/forum/message.php?msg_id=3008045

Leo crashed when executing a script if the script was selected text in a new window.

What I did:

- g.getScript now calls g.getOutputNewline(c=c) rather than look at atFile.output_newline.

atFile.output_newline may not exist if a) the file is new and b) g.getScript
doesn't call atfile.write.

- Set scripting=scriptWrite in call to atFile.scanAllDirectives in atFile.write.

This suppresses the following irrelevant message when executing scripts:

    "No absolute directory specified anywhere."</t>
<t tx="ekr.20050225070247">This documents how I used Platypus 3.0 to create MacLeo, the MacOS X launcher
for Leo. You don't need Platypus to _use_ MacLeo, but you do need Platypus to
*create* MacLeo. You may download Platypus 3.0 from http://sveinbjorn.vefsyn.is/platypus
Platypus creates something called an "application bundle," essentially a wrapper
for the shell script called openLeoScript.sh.

At present this script contains just::

    #!/bin/sh
    # $2 only works if .leo is one of the extensions.
    /usr/bin/pythonw ~/leo/src/leo.py $2

In detail, here is how I created MacLeo:

1.  Open Platypus.

2.  Set the Platypus settings::

	- Name: MacLeo
	- Script type: shell
	- Icon: Python Icon
		- Using the standard Leo outline doesn't work, but one could be created…
	- Script Path: /Users/edream/dist/Platypus 3.0/openLeoScript.sh
	- Is droppable checkbox (checked)
		- Edit Types:  .leo only, not *, not folders.
		- N.B.  There MUST be a period in front of .leo!  Otherwise $2 will be empty in the script.
	- Output: None (progress bar and text window appear to be essentially useless)

3.  Hit the create button to create MacLeo.</t>
<t tx="ekr.20050225070247.1">This tells how I created ``leo-4-3-a3.pkg`` using ``PackageMaker``.

``PackageMaker`` is included in the ``Xtools`` disk that comes with MacOS X. Installing
``PackageMaker`` was easy, but I don't remember the details.

1.  Make sure ``~/dist/make-leo-dist`` contains a folder called ``leo-(version)``.
    The ``~/dist/make-leo-dist/leo-(version)`` folder should contain a *folder* called just ``leo``.
    This is the folder that should have the files to be distributed.
    I got this folder by downloading ``leo-4-3-a3.zip``, the official a3 distribution.

2.  Open ``PackageMaker`` by double-clicking the file ``~/dist/LeoPackage.pmsp``
    I originally created this .pmsp file in ``PackageMaker``.
    It will be included in the next official release.  I'll also add it to cvs.
    ``LeoPackage.pmsp`` contains most of the information needed to create the .pkg file,
    but even without the .pmsp file using ``PackageMaker`` is pretty self-explanatory

3.  Update the description in the ``PackageMaker`` dialog.
    This should be similar to the readme file.

4. Browse to ``~/dist/make-leo-dist/leo-(version)`` in the ``Files`` tab in the ``PackageMaker`` dialog.

5.  Choose ``Make Package`` from the ``PackageMaker File`` menu.
    If necessary, set the file name to ``Leo.pkg``.  This will create ``Leo.pkg``.

6.  Quit ``PackageMaker``.  Choose 'yes' when prompted to save ``LeoPackage.pmsp``.</t>
<t tx="ekr.20050306090601">Leo's .leo file format is extensible. The basis for extending .leo files are the
``t.unknownAttributes`` and ``v.unknownAttributes`` ivars of tnodes and vnodes,
or uA's for short. Leo translates between uA's and xml attributes in the
corresponding ``&lt;v&gt;`` and ``&lt;t&gt;`` elements in .leo files. Plugins may also use
``v.tempAttributes`` or ``t.tempAttributes`` ivars to hold temporary information
that will *not* be written to the .leo file.

Collectively, these four kinds of ivars are called **attribute ivars**.
Attribute ivars must be Python dictionaries, whose keys are names of plugins and
whose values are *other* dictionaries, called **inner dictionaries**, for
exclusive use of each plugin. For example, a plugin named 'xyzzy' would set
``t.unknownAttributes`` as follows::

    # Create the uA if necessary.
    if not p.v.t.hasattr('unknownAttributes'):
        p.v.t.unknownAttributes = {}
    
    # Get the inner dictionary for the 'xyzzy' plugin, creating it if necessary.
    d = p.v.t.unknownAttributes.get('xyzzy',{})

    # Set some values. These values must be picklable.
    d ['key1'] = someValue
    d ['key2'] = anotherValue

    # Update the uA.
    p.v.t.unknownAttributes ['xyzzy'] = d

Plugins would use similar code to create ``v.unknownAttributes``,
``t.tempAttributes``, and ``v.tempAttributes`` ivars.

**Important**: All members of inner dictionaries should be picklable: Leo
uses Python's Pickle module to encode all values in these dictionaries. Leo will
discard any attributes that can not be pickled. This should not be a major
problem to plugins. For example, instead of putting a tnode into these
dictionaries, a plugin could put the tnode's gnx (a string) in the dictionary.

**Important**: Plugins must *not* use ``v.unknownAttributes`` inside ``@thin``
trees. Indeed Leo uses **hidden machinery** to write ``t.unknownAttributes``.
Leo does *not* write ``t.unknownAttributes`` to thin derived files. Instead Leo
writes a representation of all ``t.unknownAttributes`` contained in the
``@thin`` tree to a special xml attribute called
``descendentTnodeUnknownAttributes`` in the ``&lt;v&gt;`` element corresponding to the
``@thin`` node. Yes, this is complicated, but it works. Leo can *not* write
``v.unknownAttributes`` in ``@thin`` trees because **only tnodes have gnx's in
thin derived files**. In effect, vnodes are anonymous.

Plugins that must associate attributes with vnodes should support only ``@file``
trees. A completely different alternative would be for the plugin to extend how
Leo reads and writes ``&lt;v&gt;`` elements in .leo files, but that would be much more
complicated than using ``t.unknownAttributes``

Here are the details about how Leo associates uA's with ``&lt;v&gt;`` and ``&lt;t&gt;`` elements in .leo files:

- **Native xml attributes** are the attributes of ``&lt;v&gt;`` and ``&lt;t&gt;`` elements that are
  known (treated specially) by Leo's read/write code.
  The only native attribute of ``&lt;t&gt;`` elements is ``tx``.
  The native attributes of ``&lt;v&gt;`` elements are ``a``, ``t``, ``vtag``, ``tnodeList``,
  ``marks``, ``expanded`` and ``descendentTnodeUnknownAttributes``.
  All other attributes of ``&lt;v&gt;`` and ``&lt;t&gt;`` elements are **foreign xml attributes**.

- When reading a .leo file, Leo will create ``t.unknownAttributes`` or ``v.unknownAttributes`` ivars for
  any ``tnode`` or ``vnode`` whose corresponding ``&lt;v&gt;`` or ``&lt;t&gt;`` element contains a foreign xml attribute.
 
- When writing a file, Leo will write foreign xml attributes in ``&lt;v&gt;`` or ``&lt;t&gt;`` elements
  if the corresponding  vnode or tnode contains an ``unknownAttributes`` ivar.

- Leo performs the usual xml escapes on these strings when reading or writing the ``unknownAttributes`` ivars.</t>
<t tx="ekr.20050313101229">Leo 4.3 alpha 4                 March 15, 2005

Leo 4.3 is the culmination of more than five months of work. This alpha 4
focuses on plugins: all known plugins are now in leoPlugins.leo. Most plugins
now work with the 4.3 code base. Warning: not all plugins have been tested
thorougly.

This alpha 4 release also adds the requently-requested Add Comments and Delete
Comments commands to Leo's Edit Body menu.

The defining features of Leo 4.3:

1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

4. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. You never have to mess with
pluginsManager.txt again! This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

5. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.</t>
<t tx="ekr.20050313101229.2"></t>
<t tx="ekr.20050313101229.69">Nodes containing the @root directive did not honor @nocolor directives.</t>
<t tx="ekr.20050313101229.74">http://sourceforge.net/forum/message.php?msg_id=3035471

Leo was not inserting a visible horizontal scrollbar when @nowrap was in effect.</t>
<t tx="ekr.20050313101229.77">http://sourceforge.net/forum/message.php?msg_id=3042593

Leo now properly redraws the screen after a Change All command.</t>
<t tx="ekr.20050313101229.94">Several hooks use the 'new_c' key in the keywords dictionary. Plugin writers had
to remember whether to get the commander using keywords.get('c') or
keywords.get('new_c') or both. This was needlessly confusing.

All hooks that use the 'new_c' key now use also include the 'c' key. The 'new_c'
key is deprectated; plugins should use the 'c' key instead. 

None of the plugins presently in leoPlugins.leo use the 'new_c' key, but the
'new_c' key still exists for compatibility.

The following plugins were affected by this change:

ConceptualSort.py
URLloader.py
UASearch.py
arrows.py
autocompleter.py
base64Packager.py
cleo.py
dyna_menu.py
macros.py
mod_read_dir_outline.py
mod_scripting.py
multifile.py
nodebar.py
nodenavigator.py
open_with.py
scheduler.py
read_only_nodes.py
templates.py</t>
<t tx="ekr.20050313101229.95">The Add Comments command puts comments around a block of code. This command uses
single-line comments if the language in effect for the node supports single-line
comments.

The Delete Comments command deletes the comments specified by the Add Comments command.</t>
<t tx="ekr.20050313101229.100">Fixed problems in the following plugins. See the &lt;&lt; version history &gt;&gt; section
in each plugin for details.

autocompleter.py
cleo.py
mod_scripting.py
mod_tempfname.py
templates.py
vim.py
xemacs.py

Replaced the 'new_c' key by the 'c' key in the following plugins:

ConceptualSort.py
URLloader.py
UASearch.py
arrows.py
autocompleter.py
base64Packager.py
cleo.py
dyna_menu.py
macros.py
mod_read_dir_outline.py
mod_scripting.py
multifile.py
nodebar.py
nodenavigator.py
open_with.py
scheduler.py
read_only_nodes.py
templates.py

Replaced the 'start2' hook by the 'new' hook in the following plugins: (This was
made possible now that 'new' is called when opening a new window if the
'open1/2' hooks are not called.

URLloader.py
UASearch.py
at_produce.py
autocompleter.py
color_markup.py
fastGotoNode.py
groupOperations.py
import_cisco_config.py
multifile.py
nodebar.py
open_with.py
read_only_nodes.py
scheduler.py
table.py
usetemacs.py
xsltWithNodes.py</t>
<t tx="ekr.20050313101229.101">atFile.copyAllTempBodyStringsToTnodes calls:

    c.mod_label_controller.add_label(p,"before change:",old_body)</t>
<t tx="ekr.20050313102319">-   The ``Add Comments`` command puts comments around a block of code.
    This command uses single-line comments if possible.

-   The ``Delete Comments`` command deletes the comments specified by the ``Add Comments`` command.</t>
<t tx="ekr.20050313103448"></t>
<t tx="ekr.20050313103448.1">Leo calls the 'before-create-leo-frame' hook just before calling frame.onCreate.
Similarly, Leo calls the 'after-create-leo-frame' just after calling
frame.onCreate.</t>
<t tx="ekr.20050404094627"></t>
<t tx="ekr.20050407144342"> 
        
        
        </t>
<t tx="ekr.20050407144342.1"></t>
<t tx="ekr.20050407144342.2"></t>
<t tx="ekr.20050407144342.3"></t>
<t tx="ekr.20050407144417"></t>
<t tx="ekr.20050417072710.1">Client code should call ``u.beforeX`` and ``u.afterX`` methods to create a bead
describing the operation that is being performed. **Note**: ``u`` is shorthand for
``c.undoer``. Most ``u.beforeX`` methods return ``undoData`` that the client
code merely passes to the corresponding ``u.afterX`` method. This data contains
the 'before' snapshot. The ``u.afterX`` methods then create a bead containing
both the 'before' and 'after' snapshots.

``u.beforeChangeGroup`` and ``u.afterChangeGroup`` allow multiple calls to
``u.beforeX`` and ``u.afterX`` methods to be treated as a single undoable entry.
See the code for the ``Change All``, ``Sort``, ``Promote`` and ``Demote``
commands for examples. The ``u.beforeChangeGroup`` and ``u.afterChangeGroup``
methods substantially reduce the number of ``u.beforeX`` and ``afterX`` methods
needed.

Plugins may define their own ``u.beforeX`` and ``afterX`` methods. Indeed,
``u.afterX`` merely needs to set the ``bunch.undoHelper`` and
``bunch.redoHelper`` ivars to the methods used to undo and redo the operation.
See the code for the various ``u.beforeX`` and ``afterX`` methods for guidance.

``p.setDirty`` and ``p.setAllAncestorAtFileNodesDirty`` now return a
``dirtyVnodeList`` that all vnodes that became dirty as the result of an
operation. More than one list may be generated: client code is responsible for
merging lists using the pattern ``dirtyVnodeList.extend(dirtyVnodeList2)``

See the section ``&lt;&lt; How Leo implements unlimited undo &gt;&gt;`` in ``leoUndo.py``
for more details. In general, the best way to see how to implement undo is to
see how Leo's core calls the ``u.beforeX`` and ``afterX`` methods.</t>
<t tx="ekr.20050429094215">Leo 4.3 beta 1                 April 30, 2005

Leo 4.3 beta 1 completes all major features of Leo 4.3. There are no known
significant bugs remaining.

The defining features of Leo 4.3:
---------------------------------
1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo now stores recent files information in .leoRecentFiles.txt files.

4. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

5. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. You never have to mess with
pluginsManager.txt again! This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

6. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.</t>
<t tx="ekr.20050429094215.2"></t>
<t tx="ekr.20050429094215.3">The initial bug report:

http://sourceforge.net/forum/message.php?msg_id=3048149

The problem arose from a misguided attempt to eliminate non-useful information
from traces. Alas, the baby got thrown out with the bath water.

Here are the changes I made:

 - c.executeScript now calls g.es_exception(full=True) to ensure that a full
 stack trace always gets produced. This is especially important when the
 exception happens in a module (file) called by the script.

- c.executeScript now always executes the section &lt; &lt; dump the lines near the
error &gt; &gt;, regardless of context. The lines are printed (in black) in the log.
This is useful information in almost all cases.

- After much experimentation, g.es_exception is basically unchanged. Note: If
the error occurs in your script itself (as contrasted with an exception thrown
from a file called by your script) Leo always has properly put the cursor on the
offending line. I made no changes in this logic.

BTW, calling pdb.set_trace() in your scripts may cause more problems than it is
worth. Indeed.pdb.set_trace() uses only the information on the stack, and that
may not be enough information to be useful. I usually use g.trace to find out
what is happening. This works well.</t>
<t tx="ekr.20050429094215.22">Initial bug report:

http://sourceforge.net/forum/message.php?msg_id=3053699

There were three similar bugs, all arising from the fact that g.os_path_abs and
g.os_path_join return the _working_ directory if the initial path is None!

I removed my HOME directory for testing. This was essential.

- Compute home directory must return None, rather than the working directory if
the HOME variable is None.

- app.setLeoId must be careful (in two sections) to do nothing if any of
(homeDir,globalConfigDir,loadDir) is None.</t>
<t tx="ekr.20050429094215.31">The problem is that newButtons must use @nosent, so any changes to newButtons
must be accompanied by a change to LeoPluginsRef.py. There is nothing more that
needs to be done.</t>
<t tx="ekr.20050429094215.41">The De-hoist command conflicted with the Expand/Contract submenu.

The Paste Node As Clone conflicted with the Mark submenu.</t>
<t tx="ekr.20050429094215.113">The status bits weren't being passed to v.initStatus!</t>
<t tx="ekr.20050429094215.116">Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 174, in doCommand
    command()
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 863, in importDerivedFile
    c.importCommands.importDerivedFiles(v,names)
  File "C:\prog\leoCVS\leo\src\leoImport.py", line 137, in importDerivedFiles
    isThin = at.scanHeaderForThin(theFile,fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 570, in scanHeaderForThin
    junk,junk,isThin = at.scanHeader(theFile,fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2616, in scanHeader
    at.error("Bad @+leo sentinel in: %s" % fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4500, in error
    self.printError(message)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4509, in printError
    if self.errors == 0:
AttributeError: atFile instance has no attribute 'errors'
</t>
<t tx="ekr.20050429094215.120">Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1409, in idle_scrollTo
    h1 = self.yoffset(p)
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1488, in yoffset
    h, flag = self.yoffsetTree(root,v1)
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1506, in yoffsetTree
    h2, flag = self.yoffsetTree(child,p1)
  
# Maximum recursion depth exceeded.

It is still not completely clear why this happened.</t>
<t tx="ekr.20050429094215.130"></t>
<t tx="ekr.20050429094215.131">- Moved computeGlobalConfigDir, computeHomeDir, computeLoadDir and startupEncoding from leo.py to leoGlobals.py.

- Created g.computeStandardDirectories and used it in leo.py.

- Created g.createStandAloneApp using the above functions.  This function was based on the 'Standalone Operation' classed in the plugin_manager plugin.  g.createStandAloneApp doesn't actually use any of these classes because the nullGui class is basically a clumsier version of the BlackHole class.

- Added a do-nothing attachLeoIcon method to nullGui class to suppress a warning.  As I said, the nullGui class is not as elegant as Paul's BlackHole class.

- Added &lt;&lt;importLeoGlobals&gt;&gt; button to newButtons plugin.  This creates a node named
  &lt;&lt; define importLeoGlobals &gt;&gt; whose body text defines an importLeoGlobals function.

The idea is that importing leoGlobals from a stand-alone plugin is a bit tricky.  The importLeoGlobals handles these details.  Note that we don't want to define importLeoGlobals in a node included by @others, because this function must be available to the code in the &lt;&lt; imports &gt;&gt; section.  So we use a named section and reference it in before referencing the &lt;&lt; imports &gt;&gt; section.  See the plugin_manager plugin for an example.

- Changed the plugin_manager plugin as follows:
    - Used the newButtons plugin to add an &lt;&lt; define importLeoGlobals &gt;&gt; section.
    - Simplified the import logic using importLeoGlobals function.
    - Commented out the Standalone Operation classes.
    - Called g.createStandAloneApp in the '__name__ == "__main__"' code.</t>
<t tx="ekr.20050429094215.139">- config.openSettingsFile returns None if there is a read error.

- leoFileCommand.open gives no BadLeoFile message if silent is True.</t>
<t tx="ekr.20050429094215.141"></t>
<t tx="ekr.20050429094215.142">def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c</t>
<t tx="ekr.20050429094215.143">def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                if d:
                    d['_hash'] = theHash = c.hash()
                    if localFlag:
                        self.localOptionsDict[theHash] = d
                    else:
                        self.localOptionsList.insert(0,d)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)</t>
<t tx="ekr.20050429094215.144"># Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d</t>
<t tx="ekr.20050429094215.145">- Simplified write_Leo_file using new leoFileCommand.deleteFileWithMessage and g.utils_rename.

- Eliminated outputList var.
    - The code that writes to a clipboard sets self.outputFile to g.fileLikeObject.

- Speeded up put routine: it always writes to self.outputFile.

- self.outputFile is now a cStringIo object.  However, the heart of the put routine is:

    s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
    self.outputFile.write(s)

and it appears that the call to g.toEncodedString is the limiting factor.</t>
<t tx="ekr.20050429094215.161">def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        theActualFile = None
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        theActualFile = open(fileName, 'wb')
        &lt;&lt; put the .leo file &gt;&gt;
        theActualFile.write(self.outputFile.getvalue())
        theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete backup file &gt;&gt;
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete fileName &gt;&gt;
        &lt;&lt; rename backupName to fileName &gt;&gt;
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20050429094215.162">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False</t>
<t tx="ekr.20050429094215.163"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.</t>
<t tx="ekr.20050429094215.164"># rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None</t>
<t tx="ekr.20050429094215.165">self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()</t>
<t tx="ekr.20050429094215.166">if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20050429094215.167">if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)</t>
<t tx="ekr.20050429094215.168">if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')</t>
<t tx="ekr.20050429094215.173">- Use g.Bunch to simplify code.
- Added 'before' &amp; 'after' methods
- Added entries to optionalIvars dynamically in bead methods.
- Eliminated 'case-itis' by making it unnessesary ever to add more cases.
- Removed 'v' key in undoer:  replaced it with 'p'.
- Replaced u.v by u.p and v by p in find code (It's too confusing).
- p.setDirty and p.setAllAncestorAtFileNodesDirty  return list of nodes that were marked dirty.
- Create new top-level before/after methods &amp; helpers:
- Changed setUndoTypingParams to use new dispatch method.
- Removed makeBeadDict.
- Removed updateSetChangedFlag.
- Added new methods to nullUndoer class.
- Moved undo methods from leoNodes.py to leoUndo.py
- Added dirtyVnodeList param to afterChangeNodeContents.</t>
<t tx="ekr.20050429094215.286"></t>
<t tx="ekr.20050429094215.316">The only changes concern how Leo encodes and decodes items in
t.unknownAttributes and v.unknownAttributes.

Without changing the file format, the only way to tell Leo how to write
attributes is to use naming conventions. When writing attributes, Leo now does
the following:

- Do nothing except apply xml escapes if the attribute name (in
t.unknownAttributes or v.unknownAttributes) starts with str_ and the attribute
is, in fact, a string. If the string is a Unicode string Leo converts the
Unicode string to an encoded string.

- Use the present pickling/hexlifying scheming otherwise. In particular, issue a
warning and ignore the attribute if the attribute can not be pickled. BTW, there
is no need for separate base64 support: hexlifying guarantees that the result is
valid in any xml environment.

Leo now does the reverse when reading.

BTW, plugins could add their own naming conventions in an emergency. Indeed, the
conventions will be confined to code in atFile.putUa and atFile.getUa, so a
plugin would only need to override these two methods.</t>
<t tx="ekr.20050429094215.347">Removed inAtOthers  param from putOpen/CloseNodeSentinel.
Removed inAtAll param from putCloseNodeSentinel.
Removed putCloseSentinel param from putAtAllBody
Removed putCloseSentinel param from putBody

Removed toString param from openFileForWritingHelper
Removed toString param from v.putUnknownAttributes

Note: most(all?) top-level atFile.write methods pass toString to initWriteIvars.</t>
<t tx="ekr.20050429094215.349">def clearRecentFiles (self):
    
    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer
    
    bunch = u.beforeClearRecentFiles()
    
    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))
    
    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.fileName())
    
    g.app.config.appendToRecentFiles(c.recentFiles)
    
    u.afterClearRecentFiles(bunch)</t>
<t tx="ekr.20050429094215.350">def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)</t>
<t tx="ekr.20050429094215.353">Leo stores recent files information as follows.

1. Leo stores recent files info in files called .leoRecentFiles.txt. These will
be a plain text files with one line per recent files entry. An Easter egg: if
the file starts with read-only, read_only, readonly, etc. Leo will never update
the file and will not remember changes to the Recent Files menu.

2. On startup, Leo searches for the .leoRecentFiles.txt files in the user's home
directory, if it exists. Leo looks in Leo's config directory next, but only if
the home directory does not exist, or does not contain a .leoRecentFiles.txt
file. In other words, Leo will use at most one .leoRecentFiles.txt file on
startup.

3. When opening a .leo file, Leo looks for .leoRecentFiles.txt in the directory
containing the file.

4. At no time after installation does Leo create any .leoRecentFiles.txt file.
This will allow users (or their managers) to set policy regarding where to store
this information (if anywhere).

5. Leo writes at most one .leoRecentFiles.txt file when saving a .leo file,
namely the file read in item 3 if it exists, or the file read in item 2
otherwise.

This is a flexible scheme that should meet most needs without having to resolve
thorny questions about exactly where recent files info belongs.</t>
<t tx="ekr.20050429094215.354">@killcolor

- Properly implemented undo/redo Clear Recent Files.

- readSettingsFiles now reads @recentfiles nodes from all settings files.

- Created @settings nodes and @recent-files nodes if they do not exist.</t>
<t tx="ekr.20050429094215.355">@killcolor

You all have convinced me that storing recent files data in .leo files is a dubious idea. My new plan is as follows:

1. Leo will store recent files info in files called .leoRecentFiles.txt.  These will be a plain text files with one line per recent files entry.  These will be local files, so problems concerning directory structure and path specifications should go away.

2.  On startup, Leo will search for the .leoRecentFiles.txt files in the user's home directory, if it exists.  Leo will look in Leo's config directory next, but only if the home directory does not exist, or does not contain a .leoRecentFiles.txt file.  In other words, Leo will use at most one .leoRecentFiles.txt file on startup.

3.  When opening a .leo file, Leo will look for .leoRecentFiles.txt in the directory containing the file.

4.  At no time after installation will Leo create any .leoRecentFiles.txt file.  This will allow users (or their managers) to set policy regarding where to store this information (if anywhere).

5.  Leo will write at most one .leoRecentFiles.txt file when saving a .leo file, namely the file read in item 3 if it exists, or the file read in item 2 otherwise.

6.  Leo will have settings to tell which .leoRecentFiles.txt files may be written.

7. Leo will never create @settings nodes or @recent-files nodes automatically.  Moreover, I shall remove the @recent-files panel from the settings dialog and the corresponding @recent-files code from the config classes.

I believe this will address everyone's concerns without the need for resolving thorny questions about exactly where recent files info belongs.

</t>
<t tx="ekr.20050429094215.356">def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)</t>
<t tx="ekr.20050429094215.357"></t>
<t tx="ekr.20050429094215.358">def readRecentFilesFile (self,path):
    
    # Set the kind of file for later.
    for path2,kind in (
        (self.globalConfigFile,'global'),
        (self.homeFile,'home'),
    ):
        if path2 and path2 == path: break
    else:
        kind = 'local'

    path,junk = g.os_path_split(path)
    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    
    if not g.os_path_exists(fileName):
        # g.trace('----- no file',kind,fileName)
        return

    for bunch in self.recentFilesFiles:
        if bunch.fileName == fileName:
            # g.trace('-----already read',kind,fileName)
            return
            
    # g.trace('-----',kind,fileName)
    self.recentFilesFiles.append(
        g.Bunch(fileName=fileName,kind=kind))

    lines = file(fileName).readlines()
    if lines and self.munge(lines[0])=='readonly':
        lines = lines[1:]
    if lines:
        self.appendToRecentFiles(lines)</t>
<t tx="ekr.20050429094215.359">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    localFileName = c.fileName()
    if not localFileName:
        g.trace('----no file name')
        return
        
    # Create a list of bunches to control the comparison below.
    files = []
    for fileName,kind in (
        (localFileName,'local'),
        (self.homeFile,'home'),
        (self.globalConfigFile,'global'),
    ):
        if fileName:
            path,junk = g.os_path_split(fileName)
            files.append(g.Bunch(
                fileName=g.os_path_join(path,tag),kind=kind))

    # Search local file first, then home and global files.                
    for kind in ('local','home','global'):
        for bunch in files:
            for bunch2 in self.recentFilesFiles:
                if bunch.kind == bunch2.kind:
                    # g.trace('----- comparing',bunch.kind,bunch.fileName)
                    if bunch.fileName == bunch2.fileName:
                        self.writeRecentFilesFileHelper(bunch.fileName)
                        return
                    
    # g.trace('----- not found:',localFileName)</t>
<t tx="ekr.20050429094215.360">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        theFile = file(fileName,'w')
        if self.recentFiles:
            theFile.write('\n'.join(self.recentFiles))

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()</t>
<t tx="ekr.20050429095849">- Saved expansion state of @settings trees when the user hits the OK button.

- Added support for UNL's in the status line when the settings dialog is active.

- Debugged @if-platform, @if-gui, @ints &amp; @strings.

- Reloaded settings files when opening the settings dialog.

- Removed support for @recent-files nodes.  This is now handled by .leoRecentFiles.txt files.</t>
<t tx="ekr.20050513141852">Leo 4.3 beta 2                 May 15, 2005

Leo 4.3 beta 2 completes all major features of Leo 4.3 and fixes all bugs
reported since the beta 1 release.

The defining features of Leo 4.3:
---------------------------------
1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo now stores recent files information in .leoRecentFiles.txt files.

4. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

5. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. You never have to mess with
pluginsManager.txt again! This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

6. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.</t>
<t tx="ekr.20050513141913.1"></t>
<t tx="ekr.20050513141913.16">http://sourceforge.net/forum/message.php?msg_id=3133917

'Recent' and 'Marked' button now appear in new windows.</t>
<t tx="ekr.20050513141913.17">http://sourceforge.net/forum/message.php?msg_id=3133915

The colorizer now correctly handles the following:
    
\@, \(, \), \{, \}

And also constructs like \documentclass{report}.</t>
<t tx="ekr.20050513141913.22">http://sourceforge.net/forum/message.php?msg_id=3051870</t>
<t tx="ekr.20050513141913.30">http://sourceforge.net/forum/message.php?msg_id=3138608

The nav_buttons plugin was using self.c rather than keywords.get('c') in a hook
handler. The general rule is that hook handlers should do nothing if self.c !-
keywords.get('c').  This was an old bug, arising from the rewrite of the plugin.

I added a warning to that effect in the plugin template.

It would perhaps be better to specify an optional commander in registerHandler
and only call the handler if the commander matches. However, this isn't so easy
or clean to do.I

http://sourceforge.net/forum/forum.php?thread_id=1282631&amp;forum_id=10226
 
The plugin was failing to set the positionList ivar (in the base
tkinterListBoxDialog class). This was a fairly recent blunder: I saw that
positionList wasn't used in the plugin directly, so I 'improved' the code by
using a local var instead of self.positionList. This illustrates a hazard of
using subclassing.</t>
<t tx="ekr.20050513141913.57">This happened when creating a new chapter with chapters.py enabled.</t>
<t tx="ekr.20050513141913.60">http://sourceforge.net/forum/forum.php?thread_id=1281868&amp;forum_id=10226

The fix was to recompute newSel in &lt;&lt; handle backspace with negative tab_width &gt;&gt; in idle_body_key.</t>
<t tx="ekr.20050513141913.82">- The section name lost its indentation.
- The created section had extra indentation.
- Undoing did not remove the inserted section node.

The unit tests now properly test indentation.</t>
<t tx="ekr.20050513141913.91">http://sourceforge.net/forum/message.php?msg_id=3143895

The Edit-&gt;Delete command did nothing when the selected text was in a headline.</t>
<t tx="ekr.20050513141913.97">The following methods changed:

- markAllAtFileNodesDirty
- markAtFileNodesDirty
- markClones
- markHeadline
- markSubheads

I also rewrote the code using explicit positions.</t>
<t tx="ekr.20050513141913.127">http://sourceforge.net/forum/forum.php?thread_id=1281868&amp;forum_id=10226

doStrings now accepts either:

@strings[values]name=value
@strings name[values]=value

Similarly, doInts accepts:

@ints[values]name=value
@ints name[values]=value</t>
<t tx="ekr.20050513141913.140">http://sourceforge.net/forum/message.php?msg_id=3149604

Changed c.hoistStack[-1].current to c.hoistStack[-1].p in c.insertHeadline.</t>
<t tx="ekr.20050513141913.145">http://sourceforge.net/forum/forum.php?thread_id=1281868&amp;forum_id=10226

The code now calls frame.resizePanesToRatio in createFrame in Leo.

Not only does this fix this bug, it honors the following settings:

- initial_horizontal_ratio
- initial_horizontal_secondary_ratio
- initial_vertical_ratio
- initial_vertical_secondary_ratio</t>
<t tx="ekr.20050513141913.149">http://sourceforge.net/forum/message.php?msg_id=3138608

Replaced individual shortcuts widget with a single text widget. This allows the
user to add or delete shortcuts.</t>
<t tx="ekr.20050513141913.187"></t>
<t tx="ekr.20050513141913.188">http://sourceforge.net/forum/message.php?msg_id=3135170</t>
<t tx="ekr.20050513141913.194">For a test of this, see the script in test.leo at:
    
Scripts--&gt;Script to execute @test, @suite or file

Read the documentation in that node before running the script.</t>
<t tx="ekr.20050513141913.197">g.getScript now fully processes all scripts, regardless of where they came from.

- Changed g.getScript:
    - p arg is now required.
    - Removed unused script arg.
    - Added forcePythonSentinels arg (default is True).
    - g.getScript no longer temporarily alters any body text.
        - atFile.writeFromString gets the initial text using the fromString arg.
    - g.getScript now always calls atFile.writeFromString to handle all Leo directives.

- Added forcePythonSentinels to atFile.initWriteIvars and atFile.scanAllDirectives.
    - Default is None, in which case the code sets forcePythonSentinels to the scriptWrite arg.

- Added forcePythonSentinels to atFile.scanAllDirectives.
    - Default is False.

- Created atFile.putAtFirstLines and atFile.putAtLastLines.
    - These replace the corresonding sections in writeOpenFile.
    - It was not actually necessary to define these, but it cleans up the code.

- Created atFile.writeFromString.
    - This handles all the details of simulating a write _from_ a string _to_ a string.

- atFile.initWriteIvars and atFile.openFileForWriting now allow root to be None.
    - This is not used at present: root is always defined.

- Added fromString arg to atFile.writeOpenFile and atFile.putBody.</t>
<t tx="ekr.20050513141913.233">http://sourceforge.net/forum/forum.php?thread_id=1281640&amp;forum_id=10228

The default is ''.  It define_name exists c.executeScript executes the script in an environment containing
__name__ = define_name.</t>
<t tx="ekr.20050523092026">Leo 4.3 final                 May 23, 2005

Leo 4.3 is here after almost five months of work.

The defining features of Leo 4.3:
---------------------------------
1. Leo now stores options in @settings trees, that is, outlines whose headline
is '@settings'. When opening a .leo file, Leo looks for @settings trees not only
in the outline being opened but also in various leoSettings.leo files.

The key design goal of @settings trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with @settings trees. Leo settings outlines
are, in fact, infinitely more flexible and powerful than any scheme based on
flat text.  Readers of Python's configParser shootout take note!

2. The Settings command temporarily replaces the outline pane with an outline
showing all the @settings trees in effect. The Settings command also replaces
the body pane with a "settings pane". This settings pane allows you to change
the settings selected in the outline pane using standard gui widgets. The
settings pane is dynamically created from nodes in the settings tree; it is as
extensible as the @settings tree itself.

3. Leo now stores recent files information in .leoRecentFiles.txt files.

4. Leo's read/write code in leoAtFile.py has been rewritten to support user-
defined tangling and untangling.  This is a major cleanup of Leo's core.

5. Leo now boasts a wonderful new Plugins Manager plugin. This plugin enables
and disables plugins automatically. You never have to mess with
pluginsManager.txt again! This plugin also tells you everything you need to know
about each plugin. Finally, this plugin also lets you download plugins from
Leo's cvs site! Many thanks to Paul Patterson for this excellent work.

6. You can install third-party extensions in Leo's extensions directory. Leo
will attempt to import such extensions from the extensions directory if normal
imports fail. Leo is distributed with Pmw (Python Mega Widgets), path.py and
sets.py in this directory.</t>
<t tx="ekr.20050523092056.1">http://sourceforge.net/forum/message.php?msg_id=3155657

Enabling the Pie Menu plug-in caused Leo to quit when opening .leo files.</t>
<t tx="ekr.20050523092056.4">This fixed a recent bug.
The crash happened if not section text was specified.
Added new checks and new error messages.</t>
<t tx="ekr.20050620144052">Leo 4.3.1                    June 20, 2005

- Added support for Tk resource files.
- Added support for coloring the PL/SQL language.
- All Mark commands are now undoable.
- Improved Resize To Screen command.
- The usual assortment of minor bug fixes.</t>
<t tx="ekr.20050620144052.2"></t>
<t tx="ekr.20050620144052.3">http://sourceforge.net/forum/message.php?msg_id=3166883
By: rogererens

I swear I didn't wait for the release to be the first to report a bug! I just
didn't try this in the alfa/beta versions:

Leo 4.3 final, build  1.262 , May 23, 2005
Python 2.4.1, Tk 8.4.7, win32

Changing
Global settings: C:\Leo\config\leoSettings.leo--&gt;Window options--&gt;@page Options
for new windows--&gt;@ratio initial_horizontal_ratio = 0.3
or any of the other ratios, does not save them to leoSettings.leo. So after
restarting I still have the old settings in use.
</t>
<t tx="ekr.20050620144052.6">http://sourceforge.net/forum/message.php?msg_id=3167166

The fix was to add the following line to the init function:

    global click_registry, coloured_nodes</t>
<t tx="ekr.20050620144052.8">Modifying outlines can invalidate existing positions!  This rarely happens.  At present it affects the atFile.read logic when reading an outline whose initial current position is a clone outside an @thin tree with another clone inside the @thin tree.  So the read logic computes the expected current position before reading all derived files, and this expected current position becomes invalid.

What I did:

1.  Moved &lt;&lt; set current and top positions &gt;&gt; from getVnodes to end of getLeoFile.
This ensures that the outline won't change after computing the position.

2. Unit tests will have to be revised to make sure that only valid positions get used.</t>
<t tx="ekr.20050620144052.48">- Fixed bugs in convertAllBlanks and convertAllTabs.

These must always call afterChangeGroup to match beforeChangeGroup, even if
nothing has changed.

- Added u.getMark and u.rollbackToMark.

These allow unit tests to cut the undo stack back to an initial position in the
tearDown method. This should be done for all tests that use u.undo and u.redo
methods. The bug was probably the result of changing the outline in the tearDown
method.

Both the Reformat Paragraph and Edit Body unit tests now roll back the undo stack.

- Added traces for unexpected conditions in u.undo, u.redo and tree.select.

- Call u.setUndoTypes() in u.setUndoTypingParams when returning early.

- Corrected Edit Body unit tests.

These tests should not call undo/redo when nothing is expected to change. Doing
so may trigger the new 'cant undo' traces in u.undo.

- doTest in leoTest.py now makes copies of both p and p1.

It's not clear that this is needed, it can't hurt, and it may have been important.</t>
<t tx="ekr.20050620144052.112">The problem was that leo.__file__ returns a randomly upper or lower cased drive letter.</t>
<t tx="ekr.20050620144052.114"># The About Leo dialog was not getting focus.</t>
<t tx="ekr.20050620144052.116"></t>
<t tx="ekr.20050620144052.119">http://sourceforge.net/forum/message.php?msg_id=3176499

5) am I missing text in the Settings panels?  the outline shows that certain
nodes have text (e.g., "About keyboard shortcuts" has the blue rectangle), yet
the body pane is empty; heck, even the title suggests that something should
be there...
</t>
<t tx="ekr.20050620144052.154">http://sourceforge.net/forum/message.php?msg_id=3190593

As luck would have it, I need to put an @ character at the beginning of a line
in source code (windows registry file format) and can't figure out how to do
it. 
</t>
<t tx="ekr.20050620144052.166"></t>
<t tx="ekr.20050620144052.182">http://sourceforge.net/forum/message.php?msg_id=3186385

I just tried 4.3-final, and it seems it does not work with Chinese LC_CTYPE:</t>
<t tx="ekr.20050620144052.185">http://sourceforge.net/forum/message.php?msg_id=3175553

When I set default_target_language to plain in 4.2., no words in any body text
is colored. This behavior seems to have changed in 4.3. Is it right, that I
now have to write @nocolor on top of *every* body text to get rid of randomly
colored words?
 
What I did:

- Added entries for target_language to ivarsDic and defaultsDict in leoConfig.py.
- Added @language target_language = Python to leoSettings.leo.
- Convert c.target_language to lowercase in several places.</t>
<t tx="ekr.20050620144052.207"></t>
<t tx="ekr.20050620144052.208">idle_body_key now calls doAutoIndent and convertBlanksToTabs.  The idea is that plugins could override these methods if desired.</t>
<t tx="ekr.20050620144052.210"># I also fixed a bug: the Mark Clones command did not work!</t>
<t tx="ekr.20050620144052.222">Some non-standard distributions don't include the profile and pstats modules.</t>
<t tx="ekr.20050620144052.231">Leo will now look for a file called .leo_xresources in the users home directory.
If found, Leo will pass that file to Tk's option_readfile method for the top
widget. This allows users to set Tk options.</t>
<t tx="ekr.20050620144425"></t>
<t tx="ekr.20050620144602"></t>
<t tx="ekr.20050620150517">Leo looks for a file called ``.leo_xresources`` in the users home directory. If
found, Leo will pass that file to Tk's ``option_readfile`` method for the top
widget. This allows users to set Tk options.</t>
<t tx="ekr.20050812090111">import leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        controller.processTopTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20050812123002"></t>
<t tx="ekr.20050812123002.1"></t>
<t tx="ekr.20050812123002.2">Deletes p.v.rst2_http_attributename from all nodes after writing.

Deletes p.v.unknownAttributes if it then becomes empty.</t>
<t tx="ekr.20050812123002.3"></t>
<t tx="ekr.20050812123002.4">@nocolor

If False, add_node_marker and http_support_main  do nothing.  Otherwise add_node_marker does the following:
    
1. add_node_marker writes a string using generate_node_marker.

Generates 'http-node-marker-'+str(number), where number is config.node_counter
(incremented each time add_node_marker is called.

2. Enables the following code in :
@color

    if config.tag == 'open2':
        http_map = self.http_map
    else:
        http_map = {}
        config.anchormap = {}
        # maps v nodes to markers.
        config.node_counter = 0
    # [snip] code to write the tree
    if config.rst2_http_server_support:
        self.http_map = http_map</t>
<t tx="ekr.20050812123002.5"></t>
<t tx="ekr.20050812123002.6">True: call body_filter to massage text.

Removes @ignore, @nocolor, @wrap directives.
</t>
<t tx="ekr.20050812123002.7">Used differently.  See rst2_pure_document.</t>
<t tx="ekr.20050812123002.8"></t>
<t tx="ekr.20050812125502">----------------

|prev| |leo| |next|</t>
<t tx="ekr.20050812134441">.. External links...

.. .. _`CWEB`:          http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`Open Software`:    http://www.opensource.org/
.. _Python:             http://www.python.org/
.. _`SourceForge`:      http://sourceforge.net/projects/leo/

.. Relative links...

.. _clones:             intro.html#clones-views
.. _leo:                front.html
.. _outline:            intro.html#introduction
.. _outlines:           intro.html#introduction
.. _plugins:            intro.html#plugins-settings
.. _scripting:          intro.html#scripting-leo
.. _users:              http://sourceforge.net/projects/leo/

.. WARNING: image targets may not have upper case letters!

.. _home:           front.html
.. _toc:            leo_TOC.html
.. _quotes:         testimonials.html

.. |leo|  image:: leo.gif
	:target: home_

.. |prev| image:: arrow_lt.gif
	:target: toc_

.. |next| image:: arrow_rt.gif
    :target: quotes_</t>
<t tx="ekr.20050812134441.1">.. Links used in this document.

.. _front:      front.html
.. _chapter6:   design.html
.. _chapter8:   customizing.html

.. WARNING: image targets may not have upper case letters!

.. _back:   design.html
.. _home:   front.html
.. _next:   customizing.html

.. |back| image:: arrow_lt.gif
	:target: back_

.. |leo|   image:: leo.gif
	:target: home_

.. |next| image:: arrow_rt.gif
	:target: next_</t>
<t tx="ekr.20050812134441.3">------------

|leo| |next|</t>
<t tx="ekr.20050813102008.1">###########################
|leo| Using the rst3 plugin
###########################

.. August 14, 2005

@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

.. contents::</t>
<t tx="ekr.20050813102008.2">.. Links used in this document...

.. _LaTeX:                http://www.latex-project.org/
.. _reStructuredText:     http://docutils.sourceforge.net/rst.html
.. _docutils:             http://docutils.sourceforge.net
.. _ListManagerDocs.html: http://webpages.charter.net/edreamleo/ListManagerDocs.html
.. _wxListManager.leo:    http://webpages.charter.net/edreamleo/wxListManager.leo
.. _SilverCity:           http://silvercity.sourceforge.net
.. _front:                http://webpages.charter.net/edreamleo/front.html
.. _home:                 http://webpages.charter.net/edreamleo/front.html

.. |blank| image:: blank.gif
.. |leo|   image:: leo.gif
    :target: front_</t>
<t tx="ekr.20050813102008.3">The rst3 plugin creates output files from Leo outlines containing
reStructuredText_ (rST) ReStructuredText is a simple and powerful text
formatting markup language. Outlines are a natural way to organize rST (or any
text).

.. The line @rst &lt;xyzzy&gt; causes problems.

This plugin adds the Write Restructured Text command to Leo's Edit menu. The Write
Restructured Text command searches the selected outline looking for **rst root nodes**
whose headline have the form @rst xyzzy. The plugin then creates
the named file in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically relieves you from one of the most
tedious chores in creating rST markup.

.. .. [1] See footnote 1.

.. .. [2] See footnote 2.

To use this plugin effectively, Python's docutils_ module must be installed. The
rst3 plugin will use the SilverCity_ syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.
.. .. See `Required cascading style sheets`_ for more details.
See Required cascading style sheets for more details.</t>
<t tx="ekr.20050813102008.4">The rst3 plugin provides several important benefits compared to previous rst plugins:

1. This plugin allows much more flexible control over its operations using **rst3 options**. You can
set options in @settings trees, in headlines and in body text. Nodes inherit most rst3 options from
ancestor nodes much like nodes inherit Leo directives.  See `Options`_.

The most important option is the code_mode option. This option specifies whether to process the
body text of a node as rst markup (rst mode) or source code that is to be converted to rST
markup (code mode). Unlike previous versions of this plugin, any node can be processed in any
mode.

2. Headlines can set any option. This turns out to be very convenient. See `Headline commands`_ for
details.  Nodes whose headlines start with @rst-options are treated specially. The body text of such **rst
options nodes** should contain nothing but lines of the form::

    &lt;option&gt;=&lt;value&gt;

3. You can set any rst3 options in the *body text* of any node
using doc parts of the form::

    @ @rst-option
    list of rst3 options, one per line
    @c

Such **option doc parts** allows you to specify rst3 options even with source code files.

4. You can embed rST markup in the body text
of any node using doc parts of the form::

    @ @rst-markup
    any rST markup
    @c

Such **markup doc parts** allow you to fine-tune the formatting of your source files.
See `Using doc parts`_ for full details.

All these features create a wonderful environment for using rST.
There is complete integration of Leo outlines with rST markup.
You can embed both rst3 options and rST markup in any node, even node in derived files.</t>
<t tx="ekr.20050813102008.5">You can set any option in any node, so you have complete control over how this plugin processes each
node.  The following is a list of options that control how the rst3 plugin formats each particular node.

code_mode
    True: process nodes in code mode.  False: process nodes in rst mode.
    In code mode, the rst3 plugin automatically creates rST markup to display the body text as an
    rst code-block. In rst mode the rst3 simply copies the body text of the node to the output. That
    is, the plugin assumes that body text is already valid rST markup.

default_path
    The path to be prepended to filenames given in root nodes.  The default is an empty string.
    
generate_rst
    A master switch.
    True: generate rST markup for rST sections and rST code-blocks.
    False: don't generate rST markup and ignore @ @rst-markup doc parts.

number_code_lines
    Controls whether to number code lines in code mode.
    This option has no effect in rst mode.

show_doc_parts_as_paragraphs
    True: Move doc parts outside of the code-block directive in code mode.
    This option has no effect in rst mode.

    **Cool**: Any rST markup in doc parts included as the result of this option will be rendered properly.

show_headlines
    True: automatically generate rST sections from headlines.
    Applies to both code mode and rst mode.

    The level of the node in the outline determines the level of the section
    underling in the rST markup. Higher-level headlines in the outline
    correspond to higher-level section headings; lower-level headlines in the
    outline correspond to lower-level section headings.

show_leo_directives
    True: include Leo directives in code mode.
    This option has no effect in rst mode.

show_markup_doc_parts
    True: include markup doc parts in code mode.
    This option has no effect in rst mode.

show_options_doc_parts
    True: include options doc parts in code mode.
    This option has no effect in rst mode.

show_options_nodes
    True: show @rst-options nodes.

show_organizer_nodes
    True: generate rST sections for nodes that do not contain body text.
    This option has no effect unless the rST section would otherwise be written.

stylesheet_name
    The name of the stylesheet passed to docutils.  The default is 'default.css'

stylesheet_path
    The directory containing the stylesheet passed to docutils.  The default is an empty string.

underline_characters
    The underlining characters to be used to specify rST sections.  
    The default value is \'\'\'#=+*^~"'\`-:&gt;&lt;\_\'\'\'.
    The first character is reserved so you can specify the top-level section explicitly.

verbose
    True: write informational messages.

write_intermediate_file
    True: writes intermediate files before sending them to docutils.
    This option only applies to .htm, .html and .tex files.
    The name of the intermediate file has the name of the output file with .txt appended.
    This option has effect only if the generate_rst option is True.</t>
<t tx="ekr.20050813102008.6">It is often convenient to set options in headlines.  This is done with the following **headline commands**:

.. changed &lt;text&gt; to TEXT to avoid problems.

@rst TEXT
    Enter rst mode.  Create a section called TEXT provided the show_headlines option is set.

@rst-code TEXT
    Enter code mode.  Create a section called TEXT provided the show_headlines option is set.

@rst-ignore-node TEXT
    Suppress all output from a single node. TEXT is ignored.
    Has *no* effect on descendant nodes and does **not** change any rst3 option. 

@rst-ignore-tree TEXT
    Suppress all output from the node and its descendants.  TEXT is ignored.
    Does **not** change any rst3 formatting option.

@rst-no-head TEXT
    Suppress the generation of an rST section for this node only.  Does not affect descendant nodes.
    Has *no* effect on descendant nodes and does **not** change any rst3 option. 

@rst-no-headlines TEXT
    Set the show_headlines option to False.  As a result, TEXT is ignored.

@rst-option OPTION = VALUE
    Set a single option to the given value.  The default value is True.

@rst-options TEXT
    Set zero or more options from the body text of the node.  TEXT is ignored.
    The entire body text is treated as if it were in an @ @rst-options doc part.

**Notes**:

- Several of these commands affect only the node in which they appear.  Such commands set internal settings variables only: they have no effect on the visible rst3 options.

- If a headline generates an rST section, the section name does not include the headline command.  Furthermore, no rST section is generated if the TEXT is empty.</t>
<t tx="ekr.20050813102008.7">Recall that in Leo a doc part starts with the '@' directive and continues until the end of body text or until the '@c' directive is seen.  For example::

    @ This is a comment in a doc part.
    Doc parts can span multiple lines.
    The next line ends the doc part
    @c

Leo converts doc parts into comments using whatever comment delimiters are in effect.

**Option doc parts** are doc parts that start with @ @rst-options. All other
lines of such doc parts should be of the form name=value. (rST comments lines
starting with '..' are allowed). For example::

    @ @rst-options
    .. This comment line is ignored.
    show_headlines=False
    show_leo_directives=False
    verbose=True
    @c

The rst3 plugin sets options from option doc parts, even in code mode.

**Markup doc parts** are doc parts that start with @ @rst-markup.  For example::

    @ @rst-markup
    .. contents::

The rst3 plugin replaces markup doc parts by the markup they contain, even in code mode.

Option and markup doc parts are especially useful in code mode. They allow you
to specify options or insert rST markup directly from with derived files. This
makes your source files self contained: there is no need to add other nodes to
make the rst3 plugin happy.

A cool feature: In code mode, rST markup in *ordinary* doc parts will be
rendered properly when the show_doc_parts_as_paragraphs option is in effect.
*Important*: Regardless of the show_doc_parts_as_paragraphs option, doc parts
have no special significance in rst mode. That is, the entire `doc part` from
the opening '@' to the closing '@c and everything in between are treated normal
rST markup.</t>
<t tx="ekr.20050813102008.9">You can set the defaults for any rst3 option in several ways:

\1.  By setting options in the root node using @ @rst-options doc parts.
For example, the root of the file that generated this documentation contains::

    @ @rst-options
    code_mode=False
    generate_rst=True
    show_organizer_nodes=True
    show_headlines=True
    show_leo_directives=True
    verbose=True
    @c

\2. By setting options in @settings trees.  To do this, you must prefix the option name shown in this documentation with the prefix 'rst3\_'.  For example::

    @settings
        @page rst3 options
            @bool rst3_write_intermediate_file = True
</t>
<t tx="ekr.20050813102008.10">This plugin defines a code-block rST directive.  The primary purpose of this directive is to show formatted source code.

In rst mode you can insert the code-block directive like any other rST markup.  The rst3 plugin generates code-block directives when handling nodes in code mode.

This directive takes one argument, a language name.  Like this::

    .. code-block:: Python

        import leoPlugins
        import leoGlobals as g

This directive syntax colors the code in the indented code block that follows the directive.
The result looks like this if the SilverCity syntax coloring module has been installed.

.. code-block:: Python
    
    import leoPlugins
    import leoGlobals as g

Otherwise, the output looks like this::

    import leoPlugins
    import leoGlobals as g

See the tree called "Scripting chapter using the rst plugin" in LeoDocs.leo for many examples of how to use code-blocks.
</t>
<t tx="ekr.20050813102008.11">HTML files generated by the rst3 plugin assume that three .css (cascading style sheet) files exist
in the same directory. For the HTML output to look good the following .css
files should exist:

- default.css is the default style sheet that docutils expects to exist.

- leo_rst.css contains some style improvements based on Gunnar Schwant's DocFactory.

- silver_city.css is the style sheet that controls the syntax highlighting generated by SilverCity.

The latter two style sheets are imported at the end of the default.css.

**Important:** You can use cascading style sheets to do things that otherwise
wouldn't be possible with "plain" rST. For instance, the background color of
this page was specified in a body style.</t>
<t tx="ekr.20050813102008.12">The plugin reserves the '#' character for your own use so that you can
specify an rST headline explicitly. For example,::

    #####
    Title
    #####

You would typically put such a title in the rst root node. Otherwise, you should
let the rst3 plugin automatically generate rST sections from headlines.

To create a table of contents (TOC) put::

    .. contents:: Table of Contents

on its own line wherever you want the TOC to appear.  This line can appear in body text in rst mode,
or in an @ @rst-markup doc part in code mode.</t>
<t tx="ekr.20050813102008.13"></t>
<t tx="ekr.20050813102008.14">The file ListManagerDocs.html_ is an impressive example of the kind of output
that can be generated relatively easily using this plugin.

The source for ListManagerDocs.html is wxListManager.leo_.
**Important**: wxListManager.leo was written for the rst2 plugin; it
could be greatly simplified if adapted for the rst3 plugin.

The files in LeoDocs.leo under the node 'Leo's HTML Users Guide' contain
examples of using the rst3 plugin.

This documentation was created using the rst3 plugin. The source code for this
documentation is in LeoDocs.leo. The source code for all the rst plugins is in
LeoPlugins.leo.</t>
<t tx="ekr.20050813102008.15">Josef Dalcolmo wrote the initial rst plugin.  Timo Honkasalo, Bernhard Mulder, Paul Paterson, Kent Tenney and Steve Zatz made contributions to the rst and rst2 plugins.  Edward K. Ream designed and wrote the rst3 plugin.</t>
<t tx="ekr.20050813102008.16">-------------

|leo|</t>
<t tx="ekr.20050814093016">The following options are for the use of Bernhard Mulder's http plugin.  The http plugin creates an http server running on a local port, typically 8080.  When the http plugin is running you will see a purple message in the log window that looks something like this::

    http serving enabled on port 8080, version 0.91

To use the http plugin, start a web browser and enter this url::

    http://localhost:8080/

You will see a a top level page containing one link for every open .leo file.  Clicking on link will cause the http server to pass a new page to the browser.  You can use the browser's refresh button to update the top-level view in the browser after you have opened or closed files.

**Important**: See the docstring for the http plugin for information on configuring the plugin.
Some of the following rst3 settings must match values of settings for the http plugin. 
Here are the rst3 options that support the http plugin:

http_server_support
    A master switch: none of the following options have any effect unless this option is True.
    If True, the rst3 plugin does the following:

    - Writes **node markers** in the rst output for use by the http plugin. Node markers are rst named hyperlink targets.  By default they look like::
    
            .. _http-node-marker-N
    
      where N is a unique node number.

    - Adds additional information to all nodes of the tree being formatted using Leo's
      unknownAttributes mechanism.

http_attributename
    The name of the attribute name written to the unknownAttributes attribute of
    each each outline node in the rst root tree.
    The default is 'rst_http_attribute';
    it should match the following setting of the *http* plugin::

        @string rst_http_attributename = 'rst_http_attribute'
    
    This option has no effect unless the http_server_support option is True.

clear_http_attributes
    If True the rst3 plugin initially clears the fields specified by `http_attributename`.  
    This option has no effect unless the http_server_support option is True.

node_begin_marker
    The string used for node markers. The default is 'http-node-marker-'.
    This option has no effect unless the http_server_support option is True.</t>
<t tx="ekr.20050814144727">The code for the rst3 plugin is more complex than usual.  Fortunately, the overall organization is straightforward.

defaultOptionsDict
    This dictionary represents each rst3 option.
    To add another option, just add another entry to this dictionary.
    Keys are the option name, including the `rst3_` prefix.
    Values are the default value of the option.
    The hard values in the dictionary may be changed as the result of @settings entries.

processTree
    processTree is the top-level code that handles one rst root node.
    It calls preprocessTree to create the **tnodeOptionDict** ivar.
    processTree then calls either writeNormalTree or writeSpecialTree
    depending on whether text will be sent to docutils for further processing.
    These two methods handle mundane details of opening an closing files.
    Both writeNormalTree and writeSpecialTree call **writeTree** to do the actual work.

tnodeOptionDict
    The entries in this dictionary represents the options that are set in one particular node.
    The keys of tnodeOptionDict are tnodes, the values are anonymous dictionaries.
    These anonymous inner dictionaries contain the options that are explicitly set at each tnode
    (and thus each position).
    Preprocessing the tree this way ensures that each node (headline and body text) is parsed exactly once.

writeTree
    writeTree first calls **scanAllOptions**, which has the effect of
    initializing all options. writeTree then calls **writeNode** for each node
    that will be processed by the rst3 plugin. Options may cause the plugin to
    skip a node or an entire subtree.

writeNode
    writeNode first calls **scanAllOptions** to compute the options that are in
    effect for that *single* node. Once options have computed, processing the
    node is straightforward. writeNode calls writeBody and writeHeadline
    to do the real work. These methods generate or skip text based on various
    options.

scanAllOptions
    scanAllOptions recreates the optionsDict ivar to represent *all* the options
    in effect for *for the particular node being processed by writeNode*. Client
    code gets these options by calling the getOption method.

    scanAllOptions first inits all options from settings,
    then updates those options using the anonymous
    dictionaries contained in the tnodeOptionsDict.
    scanAllOptions works like g.scanAllDirectives, but the code is much simpler.</t>
<t tx="ekr.20050816051911">The following options specify the 'spelling' of headline commands.  The option_prefix and option_prefixes command also define the spelling of special doc parts.

You can change these to make them shorter or to avoid conflicts with headlines in your Leo files.  The list below merely gives the default value for each setting.

.. escape the '@' signs so they don't become email addresses.

`code_prefix`: '\@rst-code'

`ignore_headline_prefix`: '\@rst-no-head'

`ignore_headlines_prefix`: '\@rst-no-headlines'

`ignore_node_prefix`: '\@rst-ignore-node'

`ignore_tree_prefix`: '\@rst-ignore-tree'

`option_prefix`: '\@rst-option'

`options_prefix`: '\@rst-options'

`rst_prefix`: '\@rst'

`show_headline_prefix`: '\@rst-head'</t>
<t tx="ekr.20050816073412">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|back| |leo| |next|

##########################################
Chapter 2: A Tutorial Introduction to Leo
##########################################

This tutorial shows you Leo's basic features.
These features are simple to use, yet they interact with each other in powerful ways.
All Leo's features relate in some way to outlines_.
Indeed, `outline structure is significant everywhere`_.

`Quick start for programmers`_ contains the heart of this chapter.
It briefly describes everything a Python programmer needs to know in order to understand Leo's source code.
`Good style and bad`_ answers common question about when to use the features described in the quickstart_.
The section `Scripting Leo`_ is an introduction to scripting Leo with Python.
For full details, see `Chapter 7: Scripting Leo with Python`_.

.. contents::</t>
<t tx="ekr.20050816073412.1">**Important**: please `install Leo`_ before reading this tutorial,
If you have any problem, please do ask for help on `Leo's help forum`_.

Now that you have Leo installed, please `launch Leo`_.
You should see Leo's main window, something like this:
**Note**: the actual contents of the icon area at the top depends on what plugins are active.

|leoMainWinow|
</t>
<t tx="ekr.20050816073814">.. Links used in this document...

.. ----- External references.

.. _`Leo's help forum`:         http://sourceforge.net/forum/forum.php?forum_id=10227
.. _`Literate Programming`:     http://www.literateprogramming.com/
.. _`noweb`:                    http://www.eecs.harvard.edu/~nr/noweb/

.. ----- Relative links....

.. _directive:              `Leo directives`_
.. _directives:             `Leo directives`_
.. _`derived file`:         `Derived files`_
.. _glossary:               glossary.html
.. _`Good style and bad`:   `Good style and bad:  sections vs. @others`_
.. _outline:                `Leo's main window`_
.. _outlines:               `Leo's main window`_
.. _plugin:                 `Plugins &amp; settings`_
.. _plugins:                `Plugins &amp; settings`_
.. _quickstart:             `Quick start for programmers`_
.. _scripts:                `Scripting Leo`_
.. _settings:               `Plugins &amp; settings`_

.. ----- References to other chapters.

.. _command:                                    commands.html
.. _commands:                                   commands.html
.. _`editing commands`:                         commands.html#the-edit-menu
.. _front:                                      front.html
.. _`install Leo`:                              install.html
.. _`launch Leo`:                               install.html#running-leo
.. _`Leo's Users Guide`:                        leo_TOC.html
.. _`Chapter 4: Writing Programs in Leo`:       directives.html
.. _`Chapter 6: Leo and Literate Programming`:  design.html
.. _`Chapter 7: Scripting Leo with Python`:     scripting.html
.. _`Chapter 8: Customizing Leo`:               customizing.html

.. ----- References to the glossary

.. _`@file`:                    glossary.html#file
.. _`@nosent`:                  glossary.html#nosent
.. _`@others`:                  glossary.html#others
.. _`@thin`:                    glossary.html#thin
.. _`@thin trees`:              glossary.html#thin-trees
.. _`body text`:                glossary.html#body-text
.. _ancestor:                   glossary.html#ancestor
.. _children:                   glossary.html#child
.. _clone:                      glossary.html#clone
.. _cloned:                     glossary.html#cloned
.. _cloning:                    glossary.html#clone
.. _clones:                     glossary.html#clones
.. _`code part`:                glossary.html#code-part
.. _`doc part`:                 glossary.html#doc-part
.. _descendant:                 glossary.html#descendant
.. _descendants:                glossary.html#descendants
.. _`doc part`:                 glossary.html#doc-part
.. _grandchildren:              glossary.html#grandchildren
.. _headline:                   glossary.html#headline
.. _headlines:                  glossary.html#headlines
.. _`organizer node`:           glossary.html#organizer-node
.. _`organizer nodes`:          glossary.html#organizer-nodes
.. _`outline order`:            glossary.html#outline-order
.. _node:                       glossary.html#node
.. _nodes:                      glossary.html#nodes
.. _reference:                  glossary.html#reference
.. _references:                 glossary.html#references
.. _root:                       glossary.html#root
.. _`root node`:   	            glossary.html#root
.. _section:                    glossary.html#section
.. _sections:                   glossary.html#section
.. _`section definition`:       glossary.html#section-definition
.. _`section definitions`:      glossary.html#section-definitions
.. _`section definition nodes`: glossary.html#section-definition-nodes
.. _`section name`:             glossary.html#section-name
.. _`section names`:            glossary.html#section-names
.. _`section reference`:        glossary.html#section-reference
.. _`section references`:       glossary.html#section-references
.. _siblings:                   glossary.html#siblings

.. WARNING: image targets may not have upper case letters!

.. _back: install.html
.. _home: front.html
.. _next: outlines.html

.. |leoMainWinow| image:: PCWindow.gif

.. |back| image:: arrow_lt.gif
    :target: back_

.. |next| image:: arrow_rt.gif
    :target: next_

.. |leo|   image:: leo.gif
    :target: home_</t>
<t tx="ekr.20050816073824">-------------

|back| |leo| |next|</t>
<t tx="ekr.20050818163826">.. August 14, 2005

@ @rst-options
code_mode=False
default_path =
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

###########################
|leo| Using the rst3 plugin
###########################

.. contents::
</t>
<t tx="ekr.20050818163826.1">.. rST links used in this document...

.. External links...

.. _docutils:             http://docutils.sourceforge.net
.. _LaTeX:                http://www.latex-project.org/
.. _reStructuredText:     http://docutils.sourceforge.net/rst.html
.. _SilverCity:           http://silvercity.sourceforge.net

.. Hard links to Leo's web site...

.. _ListManagerDocs.html: http://webpages.charter.net/edreamleo/ListManagerDocs.html
.. _wxListManager.leo:    http://webpages.charter.net/edreamleo/wxListManager.leo

.. WARNING: image targets may not have upper case letters!

.. _front:  front.html
.. _home:   front.html

.. |blank| image:: blank.gif
.. |leo|   image:: leo.gif
    :target: front_</t>
<t tx="ekr.20050818163826.2">The rst3 plugin creates output files from Leo outlines containing
reStructuredText_ (rST) ReStructuredText is a simple and powerful text
formatting markup language. Outlines are a natural way to organize rST (or any
text).

This plugin adds the Write Restructured Text command to Leo's Edit menu. The Write
Restructured Text command searches the selected outline looking for **rst root nodes**
whose headline have the form @rst &lt;filename&gt;. The plugin then creates
the named file in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically relieves you from one of the most
tedious chores in creating rST markup.

To use this plugin effectively, Python's docutils_ module must be installed. The
rst3 plugin will use the SilverCity_ syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.
See `Required cascading style sheets`_ for more details.</t>
<t tx="ekr.20050818163826.3">The rst3 plugin provides several important benefits compared to previous rst plugins:

1. This plugin allows much more flexible control over its operations using **rst3 options**. You can
set options in @settings trees, in headlines and in body text. Nodes inherit most rst3 options from
ancestor nodes much like nodes inherit Leo directives.  See `Options`_.

The most important option is the code_mode option. This option specifies whether to process the
body text of a node as rst markup (rst mode) or source code that is to be converted to rST
markup (code mode). Unlike previous versions of this plugin, any node can be processed in any
mode.

2. Headlines can set any option. This turns out to be very convenient. See `Headline commands`_ for
details.  Nodes whose headlines start with @rst-options are treated specially. The body text of such **rst
options nodes** should contain nothing but lines of the form::

    &lt;option&gt;=&lt;value&gt;

3. You can set any rst3 options in the *body text* of any node
using doc parts of the form::

    @ @rst-option
    list of rst3 options, one per line
    @c

Such **option doc parts** allows you to specify rst3 options even with source code files.

4. You can embed rST markup in the body text
of any node using doc parts of the form::

    @ @rst-markup
    any rST markup
    @c

Such **markup doc parts** allow you to fine-tune the formatting of your source files.
See `Using doc parts`_ for full details.

All these features create a wonderful environment for using rST.
There is complete integration of Leo outlines with rST markup.
You can embed both rst3 options and rST markup in any node, even node in derived files.</t>
<t tx="ekr.20050818163826.4">You can set any option in any node, so you have complete control over how this plugin processes each
node.  The following is a list of options that control how the rst3 plugin formats each particular node.

code_mode (default: False)
    True: process nodes in code mode.  False: process nodes in rst mode.
    In code mode, the rst3 plugin automatically creates rST markup to display the body text as an
    rst code-block. In rst mode the rst3 simply copies the body text of the node to the output. That
    is, the plugin assumes that body text is already valid rST markup.

default_path (default: '')
    The path to be prepended to filenames given in root nodes.
    
generate_rst (default: True)
    A master switch.
    True: generate rST markup for rST sections and rST code-blocks.
    False: don't generate rST markup and ignore @ @rst-markup doc parts.

number_code_lines (default: True)
    Controls whether to number code lines in code mode.
    This option has no effect in rst mode.

show_doc_parts_as_paragraphs (default: False)
    True: Move doc parts outside of the code-block directive in code mode.
    This option has no effect in rst mode.
    **Cool**: Any rST markup in doc parts included as the result of this option will be rendered properly.

show_headlines (default: True)
    True: automatically generate rST sections from headlines.
    Applies to both code mode and rst mode.
    The level of the node in the outline determines the level of the section
    underling in the rST markup. Higher-level headlines in the outline
    correspond to higher-level section headings; lower-level headlines in the
    outline correspond to lower-level section headings.

show_leo_directives (default: True)
    True: include Leo directives in code mode.
    This option has no effect in rst mode.

show_markup_doc_parts (default: False)
    True: include markup doc parts in code mode.
    This option has no effect in rst mode.

show_options_doc_parts (default: False)
    True: include options doc parts in code mode.
    This option has no effect in rst mode.

show_options_nodes (default: False)
    True: show @rst-options nodes.

show_organizer_nodes (default: True)
    True: generate rST sections for nodes that do not contain body text.
    This option has no effect unless the rST section would otherwise be written.

stylesheet_name (default: 'default.css')
    The name of the stylesheet passed to docutils.

stylesheet_path (default: '')
    The directory containing the stylesheet passed to docutils.

underline_characters (default: \'\'\'#=+*^~"'\`-:&gt;&lt;\_\'\'\')
    The underlining characters to be used to specify rST sections.
    The first character is reserved so you can specify the top-level section explicitly.

verbose (default: True)
    True: write informational messages.

write_intermediate_file (default: False)
    True: writes intermediate files before sending them to docutils.
    This option only applies to .htm, .html and .tex files.
    The name of the intermediate file has the name of the output file with .txt appended.
    This option has effect only if the generate_rst option is True.</t>
<t tx="ekr.20050818163826.5">The following options are for the use of Bernhard Mulder's http plugin.  The http plugin creates an http server running on a local port, typically 8080.  When the http plugin is running you will see a purple message in the log window that looks something like this::

    http serving enabled on port 8080, version 0.91

To use the http plugin, start a web browser and enter this url::

    http://localhost:8080/

You will see a a top level page containing one link for every open .leo file.  Clicking on link will cause the http server to pass a new page to the browser.  You can use the browser's refresh button to update the top-level view in the browser after you have opened or closed files.

**Important**: See the docstring for the http plugin for information on configuring the plugin.
Some of the following rst3 settings must match values of settings for the http plugin. 
Here are the rst3 options that support the http plugin:

http_server_support (default: False)
    A master switch: none of the following options have any effect unless this option is True.
    If True, the rst3 plugin does the following:

    - Writes **node markers** in the rst output for use by the http plugin. Node markers are rst named hyperlink targets.  By default they look like::
    
            .. _http-node-marker-N
    
      where N is a unique node number.

    - Adds additional information to all nodes of the tree being formatted using Leo's
      unknownAttributes mechanism.

http_attributename (default: 'rst_http_attribute')
    The name of the attribute name written to the unknownAttributes attribute of
    each each outline node in the rst root tree.
    The default is 'rst_http_attribute';
    it should match the following setting of the *http* plugin::

        @string rst_http_attributename = 'rst_http_attribute'
    
    This option has no effect unless the http_server_support option is True.

clear_http_attributes (default: False)
    If True the rst3 plugin initially clears the fields specified by `http_attributename`.  
    This option has no effect unless the http_server_support option is True.

node_begin_marker (default: 'http-node-marker-')
    The string used for node markers.
    This option has no effect unless the http_server_support option is True.</t>
<t tx="ekr.20050818163826.6">The following options specify the 'spelling' of headline commands.  The option_prefix and option_prefixes command also define the spelling of special doc parts.

You can change these to make them shorter or to avoid conflicts with headlines in your Leo files.  The list below merely gives the default value for each setting.

`code_prefix`: '\@rst-code'

`ignore_headline_prefix`: '\@rst-no-head'

`ignore_headlines_prefix`: '\@rst-no-headlines'

`ignore_prefix_tree`: '\@rst-ignore'

`ignore_node_prefix`: '\@rst-ignore-node'

`ignore_tree_prefix`: '\@rst-ignore-tree'

`option_prefix`: '\@rst-option'

`options_prefix`: '\@rst-options'

`rst_prefix`: '\@rst'

`show_headline_prefix`: '\@rst-head'</t>
<t tx="ekr.20050818163826.7">It is often convenient to set options in headlines.  This is done with the following **headline commands**:

@rst TEXT
    Enter rst mode.  Create a section called TEXT provided the show_headlines option is set.

@rst-code TEXT
    Enter code mode.  Create a section called TEXT provided the show_headlines option is set.

@rst-ignore-node TEXT
    Suppress all output from a single node. TEXT is ignored.
    Has *no* effect on descendant nodes and does **not** change any rst3 option. 

@rst-ignore-tree TEXT and @rst-ignore TEXT
    Suppress all output from the node and its descendants.  TEXT is ignored.
    Does **not** change any rst3 formatting option.

@rst-no-head TEXT
    Suppress the generation of an rST section for this node only.  Does not affect descendant nodes.
    Has *no* effect on descendant nodes and does **not** change any rst3 option. 

@rst-no-headlines TEXT
    Set the show_headlines option to False.  As a result, TEXT is ignored.

@rst-option &lt;option&gt; = &lt;value&gt;
    Set a single option to the given value.  The default value is True.

@rst-options TEXT
    Set zero or more options from the body text of the node.  TEXT is ignored.
    The entire body text is treated as if it were in an @ @rst-options doc part.

**Notes**:

- Several of these commands affect only the node in which they appear.  Such commands set internal settings variables only: they have no effect on the visible rst3 options.

- If a headline generates an rST section, the section name does not include the headline command.  Furthermore, no rST section is generated if the TEXT is empty.</t>
<t tx="ekr.20050818163826.8">Recall that in Leo a doc part starts with the '@' directive and continues until the end of body text or until the '@c' directive is seen.  For example::

    @ This is a comment in a doc part.
    Doc parts can span multiple lines.
    The next line ends the doc part
    @c

Leo converts doc parts into comments using whatever comment delimiters are in effect.

**Option doc parts** are doc parts that start with @ @rst-options. All other
lines of such doc parts should be of the form name=value. (rST comments lines
starting with '..' are allowed). For example::

    @ @rst-options
    .. This comment line is ignored.
    show_headlines=False
    show_leo_directives=False
    verbose=True
    @c

The rst3 plugin sets options from option doc parts, even in code mode.

**Markup doc parts** are doc parts that start with @ @rst-markup.  For example::

    @ @rst-markup
    .. contents::

The rst3 plugin replaces markup doc parts by the markup they contain, even in code mode.

Option and markup doc parts are especially useful in code mode. They allow you
to specify options or insert rST markup directly from with derived files. This
makes your source files self contained: there is no need to add other nodes to
make the rst3 plugin happy.

A cool feature: In code mode, rST markup in *ordinary* doc parts will be
rendered properly when the show_doc_parts_as_paragraphs option is in effect.
*Important*: Regardless of the show_doc_parts_as_paragraphs option, doc parts
have no special significance in rst mode. That is, the entire `doc part` from
the opening '@' to the closing '@c and everything in between are treated normal
rST markup.</t>
<t tx="ekr.20050818163826.9">You can set the defaults for any rst3 option in several ways:

\1.  By setting options in the root node using @ @rst-options doc parts.
For example, the root of the file that generated this documentation contains::

    @ @rst-options
    code_mode=False
    generate_rst=True
    show_organizer_nodes=True
    show_headlines=True
    show_leo_directives=True
    verbose=True
    @c

\2. By setting options in @settings trees.  To do this, you must prefix the option name shown in this documentation with the prefix 'rst3\_'.  For example::

    @settings
        @page rst3 options
            @bool rst3_write_intermediate_file = True
</t>
<t tx="ekr.20050818163826.10">This plugin defines a code-block rST directive.  The primary purpose of this directive is to show formatted source code.

In rst mode you can insert the code-block directive like any other rST markup.  The rst3 plugin generates code-block directives when handling nodes in code mode.

This directive takes one argument, a language name.  Like this::

    .. code-block:: Python

        import leoPlugins
        import leoGlobals as g

This directive syntax colors the code in the indented code block that follows the directive.
The result looks like this if the SilverCity syntax coloring module has been installed.

.. code-block:: Python
    
    import leoPlugins
    import leoGlobals as g

Otherwise, the output looks like this::

    import leoPlugins
    import leoGlobals as g

See the tree called "Scripting chapter using the rst plugin" in LeoDocs.leo for many examples of how to use code-blocks.
</t>
<t tx="ekr.20050818163826.11">HTML files generated by the rst3 plugin assume that three .css (cascading style sheet) files exist
in the same directory. For the HTML output to look good the following .css
files should exist:

- default.css is the default style sheet that docutils expects to exist.

- leo_rst.css contains some style improvements based on Gunnar Schwant's DocFactory.

- silver_city.css is the style sheet that controls the syntax highlighting generated by SilverCity.

The latter two style sheets are imported at the end of the default.css.

**Important:** You can use cascading style sheets to do things that otherwise
wouldn't be possible with "plain" rST. For instance, the background color of
this page was specified in a body style.</t>
<t tx="ekr.20050818163826.12">The plugin reserves the '#' character for your own use so that you can
specify an rST headline explicitly. For example,::

    #####
    Title
    #####

You would typically put such a title in the rst root node. Otherwise, you should
let the rst3 plugin automatically generate rST sections from headlines.

To create a table of contents (TOC) put::

    .. contents:: Table of Contents

on its own line wherever you want the TOC to appear.  This line can appear in body text in rst mode,
or in an @ @rst-markup doc part in code mode.</t>
<t tx="ekr.20050818163826.13">The file ListManagerDocs.html_ is an impressive example of the kind of output
that can be generated relatively easily using this plugin.

The source for ListManagerDocs.html is wxListManager.leo_.
**Important**: wxListManager.leo was written for the rst2 plugin; it
could be greatly simplified if adapted for the rst3 plugin.

The files in LeoDocs.leo under the node 'Leo's HTML Users Guide' contain
examples of using the rst3 plugin.

This documentation was created using the rst3 plugin. The source code for this
documentation is in LeoDocs.leo. The source code for all the rst plugins is in
LeoPlugins.leo.</t>
<t tx="ekr.20050818163826.14">The code for the rst3 plugin is more complex than usual.  Fortunately, the overall organization is straightforward.

defaultOptionsDict
    This dictionary represents each rst3 option.
    To add another option, just add another entry to this dictionary.
    Keys are the option name, including the `rst3_` prefix.
    Values are the default value of the option.
    The hard values in the dictionary may be changed as the result of @settings entries.

processTree
    processTree is the top-level code that handles one rst root node.
    It calls preprocessTree to create the **tnodeOptionDict** ivar.
    processTree then calls either writeNormalTree or writeSpecialTree
    depending on whether text will be sent to docutils for further processing.
    These two methods handle mundane details of opening an closing files.
    Both writeNormalTree and writeSpecialTree call **writeTree** to do the actual work.

tnodeOptionDict
    The entries in this dictionary represents the options that are set in one particular node.
    The keys of tnodeOptionDict are tnodes, the values are anonymous dictionaries.
    These anonymous inner dictionaries contain the options that are explicitly set at each tnode
    (and thus each position).
    Preprocessing the tree this way ensures that each node (headline and body text) is parsed exactly once.

writeTree
    writeTree first calls **scanAllOptions**, which has the effect of
    initializing all options. writeTree then calls **writeNode** for each node
    that will be processed by the rst3 plugin. Options may cause the plugin to
    skip a node or an entire subtree.

writeNode
    writeNode first calls **scanAllOptions** to compute the options that are in
    effect for that *single* node. Once options have computed, processing the
    node is straightforward. writeNode calls writeBody and writeHeadline
    to do the real work. These methods generate or skip text based on various
    options.

scanAllOptions
    scanAllOptions recreates the optionsDict ivar to represent *all* the options
    in effect for *for the particular node being processed by writeNode*. Client
    code gets these options by calling the getOption method.

    scanAllOptions first inits all options from settings,
    then updates those options using the anonymous
    dictionaries contained in the tnodeOptionsDict.
    scanAllOptions works like g.scanAllDirectives, but the code is much simpler.</t>
<t tx="ekr.20050818163826.16">Josef Dalcolmo wrote the initial rst plugin.
Timo Honkasalo, Bernhard Mulder, Paul Paterson, Kent Tenney and
Steve Zatz made contributions to the rst and rst2 plugins.
Edward K. Ream designed and wrote the rst3 plugin.</t>
<t tx="ekr.20050818163826.17">-------------

|leo|</t>
<t tx="ekr.20050822081728">.. This was used only for testing.

[1]_ Footnote 1.

[2]_ Footnote 2.
</t>
<t tx="ekr.20050822173420">The main window represents an entire project and is stored in a single **Leo file**,
a file with a .leo extension.
As you can see, the main window contains three panes:
the **outline pane** at the top left,
the **log pane** at the top right, and the **body pane** at the bottom.
The window also contains an **icon area** at the very top and a **status area** at the very bottom.

Outline pane &amp; nodes
    The outline pane shows your project as an outline.
    The outline contains all your project's data.
    An outline consists of **nodes**.
    Nodes have two parts, a **headline** and **body text**.
    The outline pane shows headlines.
    **Selecting a headline selects the entire node**; the node's body text appears in the body pane.
    The **icon box** is a small icon directly to the left of the headline text.
    If a node contains children, a smaller icon appears to the left of the icon box.
    This icon contains a ``+`` or ``-`` symbol.
    Clicking this **expansion box** expands or contracts the node.

Body pane
    The body pane contains the body text of the node selected in the outline pane.
    You can control how Leo shows body text using `Leo directives`_ and settings_.
    For example, directives specify whether to syntax color the body text and whether to wrap the text.

Log pane
    The log pane contains informational messages from Leo.
    Scripts_ and plugins_ may also write message to the log pane.

Icon area
    Depending on what plugins are enabled,
    the icon area may contain buttons and other widgets that extend what Leo can do.
    The scripting plugin makes it easy to add buttons to the icon area.

Status area
    The status area shows the line and column containing the body text's cursor.
    Other information may follow.
    Usually this is the **UNL** (Uniform Node Location) that describes the path in the outline
    to the selected node.
    Please select nodes at several levels of the outline to see how the UNL changes.

Now that we are familiar with Leo's main window,
let's see how to use Leo as a simple outliner.</t>
<t tx="ekr.20050822173420.1">You don't have to store all outline data in Leo (.leo) files.
Leo allows you to store outline data in external files called **derived files**.
This is useful for creating programming files, documentation files such as LaTeX files, and web pages.

**Important**:
You can edit `derived files`_ outside of Leo.
Leo will update the outline to reflect those changes when Leo next opens the outline_.

It is easy to create derived files; just put ``@thin`` *filename* in a headline_.
That creates an **@thin node**.
The **@thin tree** (the ``@thin`` node and all its descendants) corresponds to the derived file *filename*.
Leo writes a `derived file`_ corresponding to the ``@thin`` tree to your hard drive when Leo saves your outline (.leo file).
When opening a .leo file, Leo reads all the `derived files`_ corresponding to ``@thin`` nodes in the outline_.

**Note**: you can ``@file`` instead of ``@thin`` to create derived files.
``@thin`` is more friendly to CVS and other Source Code Control Systems.
This tutorial only discusses `@thin`_ nodes_.
A good rule of thumb is to use `@thin`_ nodes_ unless you have a specific reason to do otherwise.
See `Chapter 4: Writing Programs in Leo`_ for a full discussions of the various ways of creating `derived files`_.

**Important**:
You must tell Leo the order in which to write data from the ``@thin`` tree to the `derived file`_.
The simplest way to specify the contents of a derived file is to insert::

    @all

in the body text of the `@thin`_ node_.
``@all`` is a Leo `directive`_.

When writing a `derived file`_, Leo writes the `body text`_ of the `@thin`_ node_,
replacing the ``@all`` directive by the `body text`_ of all the descendant_ nodes_ in **outline order**,
the order that nodes appear on the screen when all nodes are expanded.
`Leo for Programmers`_ discusses other, more flexible, ways of creating derived files from `@thin`_ trees.
**Note**: Leo copies headlines to the derived file as comments.
This means that headlines_ do not affect the meaning of `derived files`_ and
you can use headlines_ to contain whatever data you wish.
Usually, headlines_ describe what's in the node.</t>
<t tx="ekr.20050822173420.2">A **cloned node** is a copy of a node_ that changes when the original changes.
Changes to the children_, grandchildren_, etc. of a node are simultaneously made
to the corresponding nodes contained in all cloned nodes. A small red arrow in
icon boxes marks clones.

Please take a few moments to experiment with clones. Start with a single node,
say a node_ whose headline_ is A. Clone node A using the ``Clone Node`` command_
in Leo's Outline menu. Both clones are identical; there is no distinction
between the original node and any of its clones.

Type some text into the body of either node A. The same text appears in the
bodies of all other clones_ of A. Now insert a node, say B, as a child of any of
the A nodes. All the A nodes now have a B child. See what happens if you clone
B. See what happens if you insert, delete or move nodes that are children_ of A.
Verify that when the second-to-last cloned node is deleted the last cloned node
becomes a regular node again.

Clones are much more than a cute feature. **Clones allow multiple views of data
to exist within a single outline**. The ability to create multiple views of data
is crucial; you don't have to try to decide what is the 'correct' view of data.
You can create as many views as you like, each tailored exactly to the task at hand.

To create a new view of the data, just create any *ordinary* node. This node
will *represent* the new view. Let us call it a **view node.** Now just put any
nodes that are related to the view as descendant nodes of your view node. Let us
call the descendants of the view nodes the **components** of the view. Component
nodes are typically clones of other nodes in the outline. This is what gives the
view its power: a view can contain nodes gathered from all over the outline.
However, it is also sometimes useful to add non-cloned nodes as components of
views.

For example, when I begin to fix a bug I first create a view node to represent
the bug. I then create a component node (not cloned) that contains the original
bug report. I may also create other non-cloned nodes to contain notes and
documentation. Next, I go looking throughout Leo's code for nodes that relate in
some way to the bug. When I find such a node I clone it and move one of the
clones so it becomes a component of the view node for the bug. **Note**: I can
organize the components of the view node as I please. In particular, I can
create **organizer nodes** whose only purpose is to contain groups of component
nodes. In other words, the full power of Leo outlines is available within view
nodes.

**Important**: Once I have created the view of the bug, I can concentrate *only*
on that view. In particular, I can fix code by changing *component* nodes.
Because the code nodes are cloned, any changes I make to a component node also
get made to the other cloned nodes throughout the outline. In effect, my view
node for the bug lets me work only on the nodes of the outline that are directly
related to the bug. In other words, the view nodes lets me focus *only* on the
task at hand, and lets me ignore all other details.

Clones are the basis for Leo's project management capabilities. Indeed, the
ability to create multiple views of a project is most helpful.</t>
<t tx="ekr.20050822173420.3">Leo directives control such things as syntax coloring, line wrapping within the body pane and the width of tabs.
Leo directives start with '@' in the leftmost column, followed by the name of the directive.  Some examples::

    @language python
    @tabwidth -4
    @wrap
    @nowrap
    @color
    @nocolor
    @killcolor

The following directives are useful for non-programmers;
`Directives for programming`_ lists the directives used for computer programming.

- **\@color**, **\@nocolor** and **\@killcolor** control syntax coloring.
 
- **\@language** sets the language used for syntax coloring.

- **\@tabwidth** sets the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces
  (highly recommended for Python programming.)

- **\@wrap** and **\@nowrap** enable or disable line wrapping the Leo's body pane.

**Note**:
You can mix ``@nocolor`` and ``@color`` directives in a single node_,
but these directives apply to descendant_ nodes only if they are **unambiguous**, that is,
only if the ancestor node contains exactly one ``@color`` or ``@nocolor`` directive.</t>
<t tx="ekr.20050822173420.5">Leo is fully scriptable using the Python language.
**Leo can execute any body text as a Python script**.
To run the entire body text as a script, simply choose the node and execute the ``Execute Script`` command_.
If text is selected, the ``Execute Script`` command_ will run just the selected text as the script.

The ``Execute Script`` command_ **preprocesses** the script before executing it.
Leo preprocesses scripts in exactly the same way that Leo writes derived files.
That is,
**Leo expands section references and processes @others directives** before executing the script.
This allows you to use all of Leo's normal capabilities to organize your scripts.
**Note**: ``test.leo`` contains dozens of examples of using Leo outline structure to organize stand-alone scripts.

Your Python scripts can easily access data in an outline.  For example, the following script will print all the headlines in an outline::

    for p in c.allNodes_iter():
        print ' '*p.level(),p.headString()

Your scripts can use outline structure to avoid having to parse data.
With a little forethought you can arrange outlines to make scripts easier to write.
The example above is only the beginning of what scripts can do.
See `Chapter 7: Scripting Leo with Python`_ for a complete discussion of scripting.</t>
<t tx="ekr.20050823081317.1">**Plugins** are Python modules that change how Leo works, yet are not part of Leo's core code. 
Leo's user have contributed dozens of plugins that have extended Leo's capabilities in many new directions.
The file ``leoPlugins.leo`` contains all plugins that are included in Leo distributions.

Plugins and other parts of Leo can get options from **@settings** trees,
outlines whose headline is ``@settings``. When opening a .leo file, Leo looks
for ``@settings`` trees in the outline being opened and also in various
``leoSettings.leo`` files. ``@settings`` trees allow plugins to get options without
any further support from Leo's core code. For a full discussion plugins and
``@settings`` trees, see `Chapter 8: Customizing Leo`_.</t>
<t tx="ekr.20050823082517">You can use Leo as fairly typical outliner. Play around with some of the
commands from the Outline menu:

- Click the expansion box of nodes_ to show and hide their children.

- The ``Insert Node`` command_ inserts a new headline into the outline.

- The ``Delete Node`` command_ deletes a headline and all its children.

- The ``Move Up``, ``Move Down``, ``Move Left`` and ``Move Right`` commands_ move the currently selected node,
  along with all its descendants. 

- The ``Promote`` command_ makes all the children_ of a headline siblings of the headline.
  The ``Demote`` command_ makes all following siblings_ of a headline children of the headline.

- You can cut, copy and paste entire nodes_ (including their descendants) with
  the Cut Node, Copy Node and Paste Node commands_.

- We'll discuss the ``Clone Node`` command_ in the next section.

You enter `body text`_ for any node by selecting the node's headline in the
outline pane and then typing in the body pane. Leo has a full range of `editing
commands`_ that apply to the body pane.
</t>
<t tx="ekr.20050824151926">So far we have discussed features that Leo shares with other editors and outliners.
The following sections explain what makes Leo unique.</t>
<t tx="ekr.20050827055403">So far we have been focusing on Leo's outline pane: creating and cloning_ nodes_.
In fact, *outline structure affects all aspects of Leo*.
For example:

-   As mentioned earlier, body text can contain `Leo directives`_ that control how Leo works.
    By default, a Leo directive applies to a node and all its descendants_,
    but a Leo directive in a descendant node can **override** a directive in an ancestor_ node.

-   Programs in `body text`_ can contain optional markup consisting of sections_ and section references_.
    (See `Quick start for programmers`_ for details.)
    Leo outlines limits the visibility of such sections:
    sections_ must be defined in a node descending from the node containing the `section reference`_.

-   You can organize scripts and programs using outlines, and scripts can use
    outline structure to access data. Plugins_ and scripts_ often confine their
    effects to the presently selected outline.</t>
<t tx="ekr.20050827061847">**Doc parts** are blocks of text that Leo treats as comments.
Leo syntax colors doc parts as comments,
and Leo converts doc parts into comments in derived files.
Doc parts start with an ``@`` directive and continue until
an ``@c`` directive or the end of the body text.
For example::

    @ This is a comment in a doc part.
    Doc parts can span multiple lines.
    The next line ends the doc part
    @c

Doc parts are entirely optional;
you could simply use comments in the language specified by the ``@language`` directive_.
Using doc parts for lengthy comments is convenient, however.
Not only do you not need to specify comment delimiters,
but Leo breaks doc parts into lines automatically.
The ``@pagewidth`` directive specifies the width of those lines.

**Notes**:

- In body text, everything not in a doc part is in a **code part**.
  If a node does not contain a doc part, the entire body text is a code part.

- ``@doc`` is a synonym for ``@`` and ``@code`` is a synonym for ``@c``.
  However, ``@`` and ``@c`` are preferred.

- A doc part of the form::
	
    @ %def identifiers

declares that the preceding code part contains the list of identifiers.
Whitespace separate the identifiers; everything else is taken to be the
identifiers. This construct is a convention of the noweb_ language, and will be
of use *only* for those who want to create .nw output files for use with the
official noweb_ system.</t>
<t tx="ekr.20050827090532">`@thin trees`_ create `derived files`_ containing your program.
Within ``@thin trees`` you can write *functional pseudo-code*, like this::

    &lt;&lt; imports &gt;&gt;  (in body text)

This is a **reference** to a **section** called ``&lt;&lt; imports &gt;&gt;``.
When writing a `derived file`_,
Leo replaces all section references by their definition.
You define sections with **section definition nodes**.
A section definition node is a node_ whose headline_ starts with a `section name`_::

    &lt;&lt; imports &gt;&gt;   (in a headline)

The `body text`_ of this node_ is its definition.  For example::

    import leoGlobals as g
    import sys

As you can see, `section definitions`_ can be *fragments* of code;
they don't have to be complete functions or methods.

**Notes**:

-   `Section definition nodes`_ must be descendants_ of the node_ containing the `section reference`_.
    Leo's syntax colorer underlines undefined `section references`_.

-   `Section definitions`_ may contain references to other sections_.

-   The **@others** directive_ is a special kind of `section reference`_.
    Leo replaces the ``@others`` directive by the body text of all descendant_ nodes_
    *except* `section definition nodes`_.
    That's how ``@others`` got its name.
    For example, the `root node`_ of Python `derived files`_ typically is something like this::

        &lt;&lt; docstring &gt;&gt;
        &lt;&lt; imports &gt;&gt;
        @others

    The `derived file`_ will contain the docstring, followed by the imports, followed by the
    the body text of all other nodes in the ``@file`` tree, in `outline order`_.
    
- A `derived file`_ may contain multiple ``@others`` directives_: Each
  ``@others`` directive expands to the body text of all descendant_ nodes_,
  excluding any nodes (and *their* descendants) that contain other ``@others``
  directives_. In practice, using ``@others`` is easy.

- You may precede `section references`_ (including the ``@others`` directive_)
  with whitespace. When expanding the section references, Leo inserts the
  preceding whitespace before every expanded line. For example, the following
  will work properly in Python::

    if path:
        &lt;&lt; create or recreate temp file as needed &gt;&gt;

*You now know enough to understand Leo's source code*.  Hurray!
The following sections discuss some relatively minor details.
However, I recommend reading `Good style and bad`_;
you might save yourself some extra work.</t>
<t tx="ekr.20050827090802">``LeoPy.leo`` (in the src subdirectory of the leo folder) contains almost all of Leo's source code.
It provides hundreds of examples of everything discussed here.
This file will repay close study.
For full details on all aspects of Leo see ``LeoDocs.leo`` or `Leo's Users Guide`_.</t>
<t tx="ekr.20050827094813">Newcomers to Leo frequently ask when to use the `@others`_ directive_ and when
to use sections_. It is good style to use `section references`_ only when the
order of text within a `derived file`_ matters. For example, Python programmers
put docstrings and imports at the start of files. So the `body text`_ of
`@file`_ nodes typically look something like this::

    &lt;&lt; docstring &gt;&gt;
    @language python
    @tabwidth -4
    &lt;&lt; imports &gt;&gt;
    @others

This ensures that the docstring is first in the file, followed by imports,
followed by everything else. Note that the order in which functions are defined
in a file, or methods defined within a class, typically does *not* matter. Thus,
it is good style to define classes like this::

  class myClass:
        &lt;&lt; class attributes &gt;&gt;
        @others

It would be bad style to define a class like this::

  class myClass:
        &lt;&lt; class attributes &gt;&gt;
        &lt;&lt; method 1 &gt;&gt;
        &lt;&lt; method 2 &gt;&gt;
        ...

Not only does this over-specify the order in which methods are defined, but it
requires lots of extra typing. Not only must you add a line for each method, but
headlines must contain section names such as &lt;&lt; method 1 &gt;&gt;, &lt;&lt;method 2&gt;&gt;, etc.
When using ``@others`` it is good style simply to put the name of each method in
the headline.

A few more words about style:

- It is good style to **put each class, function or method in its own node**.
  This makes it easy to see the shape of your code.

- It is good style to use `organizer nodes`_ to group related functions or methods.
  An organizer node has no content except maybe for comments.
  Like this::

    + myClass
        + birth and death
            + __init__
            etc.
        + getters
            etc.
        + setters
            etc.
        + misc methods
            etc.

  (In this notation, '+' denotes a headline.)
  This organization is far superior to using hideous comments like::

    ###########
    # Getters #
    ###########

- It is bad style to use `@others`_ in `organizer nodes`_.
  There is no need to do so.

- It is bad style to use `@others`_ when order does matter.
  The reason is that it is very easy to move nodes in a tree by mistake,
  say by alphabetizing nodes.
  One wants to make the meaning of a derived file immune from such movements.

One last word about style. The world won't end if you happen to use bad style by
mistake: you just might cause a bit more work for yourself than was strictly
necessary. Feel free to invent your own style of using Leo. Still, it would be
wise to "know the rules before you break them."
</t>
<t tx="ekr.20050827102655">The previous sections have discussed the basics of Leo.
*Non-programmers can stop reading this tutorial now*!

The following sections tell how to create derived files that contain computer
programs. Yes, you could create program files using the ``@all`` directive, but
the following section explain how you can take advantage of **power-user**
features designed specifically for computer programmers. Even if you don't read
manuals, please read the following short `Quick start for programmers`_ section.</t>
<t tx="ekr.20050827155902">A section name has the form::

    &lt;&lt; any text &gt;&gt;

`Any text` is just that: *any* sequence of text not containing '&gt;&gt;'.  For example::

    &lt;&lt; initialize ivars &gt;&gt;

Leo ignores case and whitespace in section names, so the following are all equivalent::

    &lt;&lt; Peanut Butter &amp; Jelly &gt;&gt;
    &lt;&lt; peanut butter&amp;jelly &gt;&gt;
    &lt;&lt;peanut butter &amp; jelly&gt;&gt;
    &lt;&lt;peanutbutter&amp;jelly&gt;&gt;
    &lt;&lt;PEANUTBUTTER&amp;JELLY&gt;&gt;

When ``&lt;&lt;`` and ``&gt;&gt;`` are not paired on a line,
they are treated as ordinary ``&lt;&lt;`` and ``&gt;&gt;`` characters.
Leo has *no* escape mechanism for section names.
That is, paired ``&lt;&lt;`` and ``&gt;&gt;`` characters on the same line always denote a section name,
*even within comments and strings*.
This means that ``&lt;&lt;`` and ``&gt;&gt;`` characters that do not delimit a section name must be placed on separate lines.
In practice, this requirement seldom causes problems.

The syntax of section names is based on Norman Ramsey's `noweb`_ markup language,
but without noweb's escape conventions.
Eliminating these escape conventions may seem odd,
but it has turned out to be one of the best design decisions I ever made.</t>
<t tx="ekr.20050827162537">Leo can support a style of programming similar to `Literate Programming`_ (LP).
LP has a bad reputation in some quarters. That's too bad; Leo fixes all the
problems with traditional LP. See `Chapter 6: Leo and Literate Programming`_ in
`Leo's Users Guide`_ for more details. *Please* don't let the words 'Literate
Programming' get in the way of your using Leo effectively. That would be *your*
mistake, and a big one.</t>
<t tx="ekr.20050828061213">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

.. August 28, 2005

|back| |leo| |next|

#####################################
Chapter 4: Writing Programs in Leo
#####################################
</t>
<t tx="ekr.20050828061501.1">This chapter is a *reference guide* to computer programming with Leo.
This chapter does *not* teach you how to use Leo:
for that you should read `Leo's tutorial`_.
This chapter assumes you are thoroughly familiar with the terminology introduced in the tutorial.
**Note**: Are you *sure* you want to read this chapter?
It contains many details that are no interest to the average user of Leo.
I recommend using Leo for two weeks, or longer, before attempting this chapter.

.. contents::</t>
<t tx="ekr.20050828061501.30">The following sections give full details about each directive.
</t>
<t tx="ekr.20050828061501.31">The ``@all`` directive is valid only in ``@thin`` trees.
The ``@all`` directive is similar to ``@others``, but it is less restrictive:
it dumps *all* nodes to the derived file, including ``@ignore`` nodes and nodes that
in an ``@others`` tree would be considered to be orphan nodes.

The ``@all`` directive is required for files such as ``@thin leoProjects.txt`` in ``LeoPy.leo``.
``leoProjects.txt`` contains so-called project nodes.
It doesn't have any meaning as a program file: it is simply a collection of unrelated data.
``@others`` would not work at all: it would complain about lots of orphan nodes.</t>
<t tx="ekr.20050828061501.32">Syntax coloring is on by default in all body text.
Leo formats comments and documentation parts in red,
directives and C keywords in blue,
strings and character constants in gray and all other text in code parts in black.
The ``@nocolor`` directive disables syntax coloring for the body text in which it appears.
No syntax coloring is done until an ``@color`` directive re-enables syntax coloring.

If a node contains neither the ``@color`` nor the ``@nocolor`` directive
it may inherit the syntax coloring attribute from an ancestor.
The nearest ancestor that contains exactly one of the ``@color`` or ``@nocolor`` directives
will control the syntax coloring.
**Ambiguous nodes**, nodes containing both the ``@color`` and ``@nocolor`` directives,
never affect the coloring of their offspring.

The ``@killcolor`` directive completely disables the colorizer for that node.
The result much faster syntax coloring of large body text.
As usual ``@killcolor`` may itself be overridden in descendant nodes.
The differences between ``@killcolor`` and ``@nocolor``:

- ``@nocolor`` suppresses coloring only until the next ``@color`` directive.

- ``@killcolor`` overrides ``@nocolor`` and ``@color`` directives.
  Any node containing @killcolor is unambiguously a ``@killcolor`` node regardless of
  whether that node also contains ``@color`` or ``@nocolor`` directives.

**Note**:
the ``@color``, ``@nocolor`` and ``@killcolor`` directives do not affect the ``Tangle`` commands in any way.
In particular, the ``Tangle`` commands will recognize section definitions as usual even
after an ``@nocolor`` directive is seen.</t>
<t tx="ekr.20050828061501.33">**Note**:
the ``@comment`` directive is deprecated:
you should use the ``@language`` directive whenever possible.
However, sometimes using both ``@language`` and ``@comment`` is useful.
For this to be effective the ``@comment`` directive should appear after the ``@language`` directive (in outline order).

The ``Untangle`` command will not process an ``@root`` or ``@unit`` node if
an ``@comment`` directive is in effect because
``Untangle`` can't be sure of properly parsing a derived file if the language of the derived file isn't known.
It might be possible to assume some defaults in this case,
but that is not done at present and is not a high priority.
By default, the ``Tangle`` commands produces C-language comments.
Single-line comments generated during tangling start with ``///``,
while documentation parts are surrounded by ``/*`` and ``*/``.
The ``@comment`` directive allows you to use ``Tangle`` to produce shell and make files,
as well as source code for other programming languages.

The ``@comment`` directive may be followed by zero to three delimiters, separated by whitespace.
This directive sets the single-line comment delimiter and the opening and closing block comment delimiters as follows:

====================== =====================================================================
\@comment              no args\: restores the defaults to ///, /\* and \*/
---------------------- ---------------------------------------------------------------------
\@comment ///          \1 arg\: sets the single-line comment and clears the other delims.
---------------------- ---------------------------------------------------------------------
\@comment /\* \*/      \2 args\: sets the block comment delims; clears the single-line delim.
---------------------- ---------------------------------------------------------------------
\@comment /// /\* \*/  \3 args\: sets all three delimiters.
====================== =====================================================================

If only one delimiter is given, Leo does not write any documentation parts while tangling.
If two delimiters are given, block-style comments are used instead of single-line comments.
For example, the ``@comment { }`` directive could be used to tangle Pascal files.

The ``@comment`` directive is only recognized in ``@root``, ``@unit`` or ``@file`` nodes,
and the ``@comment`` directive must precede the first section name or ``@code`` directive.
An ``@comment`` directive in the body text of an ``@unit`` directive specifies the current global defaults.
An ``@comment`` directive in the body text of an ``@root`` directive affects comments generated for one root only.
Comments in all other roots are governed by the global defaults.

Leo will convert underscores in the ``@comment`` directives to significant spaces.  For example::

    @comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).</t>
<t tx="ekr.20050828061501.34">The ``@delims`` directive changes the comment strings used to mark sentinel lines.
This directive is often used to place Javascript text inside XML or HTML files.
The ``delims`` directive is not valid in ``@root`` or ``@unit`` trees.

The ``@delims`` directive contains one or two delimiters, separated by whitespace.
If only one delim is present it delimits single-line comments.
If two delims are present they delimit block comments.
The ``@delims`` directive can not be used to change the comment strings at the start of the derived file,
that is, the comment strings for the ``@+leo`` sentinel and the initial ``@+body`` and ``@+node`` sentinels.

The ``@delims`` directive inserts ``@@delims`` sentinels into the derived file.
The new delimiter strings continue in effect until the next ``@@delims`` sentinel in the derived file or
the end of the derived file.

**Note**: Leo can not revert to previous delimiters automatically;
you must change back to previous delimiters using another ``@delims`` directive. For example::

    @delims /* */
    Javascript stuff
    @delims &lt;-- --&gt;
    HTML stuff

Adding, deleting or changing ``@@delims`` sentinels will destroy Leo's ability to read the derived file.
Mistakes using the ``@delims`` directive have no effect on Leo,
though such mistakes will thoroughly mess up a derived file as far as compilers,
HTML renderers, etc. are concerned.</t>
<t tx="ekr.20050828061501.35">You may use the ``@encoding`` directive to specify the encoding used in a derived file.
You can't mix encodings in a single derived file.  For example::

    @encoding iso-8859-1

If the encoding used in a derived file is not "utf-8" it is represented in the @+leo sentinel line, like this::

    #@+leo-encoding=iso-8859-1.

The ``utf-8`` encoding is used by default.
The ``utf-8`` encoding is a "lossless" encoding (it can represent all unicode code points),
so encoding and decoding to and from ``utf-8`` plain strings will never cause a problem.
When reading or writing a character not in a "lossy" encoding (such as ``iso-8859-1``),
Leo converts such characters to ``'?'`` and issues a warning. </t>
<t tx="ekr.20050828061501.36">The ``@first`` directive allows you to place lines at the very start of files derived from ``@file`` nodes.
For example, the body text of ``@file spam.py`` might be::

	@first #! /usr/bin/env python

The body text of ``@file foo.perl`` might be::

	@first #/usr/bin/perl

``@first`` directives are recognized only at the start of the body text of ``@file`` nodes.
No text may precede ``@first`` directives.
More than one ``@first`` directive may exist, like this::

	@first #! /usr/bin/env python
	@first # more comments.

The ``@first`` directive is not valid in ``@root`` or ``@unit`` trees.</t>
<t tx="ekr.20050828061501.37">The ``@language`` directive specifies the comment delimiters and string types used by the
``Tangle`` and ``Untangle`` commands.
This directive over-rides the default specified in the settings dialog.
Here are the valid ``@language`` directives::

    @language actionscript
    @language c
    @language c++
    @language cweb
    @language elisp
    @language html
    @language java
    @language latex
    @language objective-c
    @language pascal
    @language perl
    @language perlpod
    @language plain
    @language python
    @language rebol
    @language shell
    @language tcltk

Shell files have comments that start with `#`.
Case is ignored in the language specifiers, but not in the ``@language`` itself.
Thus, the following are equivalent::

    @language html
    @language HTML
    @language hTmL

but the following is invalid::

    @LANGUAGE html</t>
<t tx="ekr.20050828061501.38">The ``@lineending`` directive sets the line endings for individual derived files.
This directive will override the ``output_newline`` setting.
The ``@lineending`` *never* affects the line endings in .leo files themselves:
.leo files must have consistent line endings!

The valid forms of the ``@lineending`` directive are:

======================= ======================================================
\@lineending nl         The default, Linux.
----------------------- ------------------------------------------------------
\@lineending cr         Mac
----------------------- ------------------------------------------------------
\@lineending crlf       Windows
----------------------- ------------------------------------------------------
\@lineending lf         Same as 'nl', not recommended
----------------------- ------------------------------------------------------
\@lineending platform   Same as platform value for ``output_newline`` setting.
======================= ======================================================</t>
<t tx="ekr.20050828061501.39">The ``@path`` directives override the deprecated ``default_tangle_directory`` setting.

The form of the @path directive is ``@path`` *filename*,
where *filename* is taken to be everything following @path to the end of the line.

If *filename* is an absolute filename the location of the derived file is specified only by the filename.
Otherwise, if *filename* is a relative filename, the location of the derived file is relative to:
	
1. the directory specified the applicable ``@path`` directive, or
2. the "Default Tangle Directory" in the Settings dialog if no ``@path`` directive is in effect, or
3. the directory in which the .leo file resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules,
or if *filename* does not exist.</t>
<t tx="ekr.20050828061501.40">The ``@raw`` and ``@end_raw`` directives are valid only within ``@file`` trees.
The ``@raw`` directive starts a section of "raw" text.
The ``@end_raw`` directive ends such a section, as does the end of body text.
No section references are recognized within raw text,
and no additional leading whitespace is generated within raw text when writing the derived file.
</t>
<t tx="ekr.20050828061501.41">Leo allows you to choose whether body text in ``@root`` trees will start in code mode or doc mode by default.
``@root-doc`` *filename* and ``@root-code`` *filename* directives
specify that body text is assumed to start in doc mode or code mode respectively.
The options (``-doc`` and ``-code``) must follow ``@root`` immediately with no intervening whitespace.
In effect, ``@root-code`` and ``@root-doc`` are two new directives.

These ``@root`` options override the ``at_root_bodies_start_in_doc_mode`` setting.
This setting affects only @root trees without options.
Such "plain" ``@root`` trees are now deprecated,
which only means that it is better style to use either ``@root-code`` or ``@root-doc``.
The reason is simple:
the meaning of plain ``@root`` trees will depend on the ``at_root_bodies_start_in_doc_mode`` setting.
It's better to be explicit.
By default, ``at_root_bodies_start_in_doc_mode = 1`` for compatibility for old ``@root`` trees.
I actually don't think this option is good for much;
I created it before I created ``@root-doc`` and ``@root-code`` settings,
and I decided it wouldn't hurt to leave it in.
Anyway, you now have complete flexibility about how ``@root`` works,
and in particular you can make ``@root`` work just like ``@file``.</t>
<t tx="ekr.20050828061501.42">By default, the ``body_pane_wraps`` setting controls whether body text wraps.
You may override this setting for a particular tree using the ``@wrap`` and ``@nowrap`` directives.
Only the first ``@wrap`` or ``@nowrap`` directive in a node has any effect.</t>
<t tx="ekr.20050828061501.43">See `CWEB`_ for a discussion of the CWEB language.
CWEB mode refers to how Leo tangles an outline when ``@language cweb`` is in effect or
the ``cweb`` setting is in effect.
Leo treats *all* cweb code in cweb mode as unevaluated text.
That is, Leo treats cweb control codes, including
``@&lt;...@&gt;``, ``@&lt;..@&gt;=``, ``@c``, ``@``, ``@*`` and ``@**`` as "raw" text within cweb mode.
Leo does *not* expand *cweb* section references when writing derived files in cweb mode.
However, Leo *does* expand *noweb* section references,
so you may use noweb sections to organize cweb files!
You can create *noweb* code and doc sections using the ``@code`` and ``@doc`` directives
in place of ``@c`` and ``@`` directives.

By default, cweb colors ``@``, ``@*`` and ``@**`` sections using the same syntax coloring as for ``LaTeX``.
In addition, cweb colors ``C`` ``//`` and ``/*..*/`` comments using ``LaTeX`` coloring by default.
You may change these defaults using the
``color_cweb_doc_parts_with_latex`` and ``color_cweb_comments_with_latex`` settings.</t>
<t tx="ekr.20050828061501.45">This section discusses all aspects of ``@root`` trees.
You should carefully consider whether the extra flexibility afforded by
``@root`` trees is worth the extra bother.
Indeed, ``@file`` trees are much easier to use than ``@root`` trees:

- ``@file`` trees use less markup than ``@root`` trees.
  In particular, the @others directive is valid only within ``@file`` trees.

- You must explicitly tangle and untangle ``@root`` trees using the ``Tangle`` and ``Untangle`` commands.

However, ``@root`` trees are more flexible than ``@file`` trees:

- Sections may be defined anywhere within ``@root`` trees.
  Moreover, the ``@unit`` directive expands the scope of section definitions in ``@root`` trees
  so that a section may be referenced in several ``@root`` trees.

- The meaning of section definitions in ``@root`` trees are independent of their position within the tree.</t>
<t tx="ekr.20050828061501.47">Just as with ``@file`` trees, ``@root`` trees may contain code parts and doc parts.
Code parts start with section definition lines (see below) or the ``@c`` directive.
Doc parts start with ``@`` directive.
Doc parts continue until the end of body text or until the next ``@c`` or ``@`` directive.

Body text in ``@root`` trees contain zero or more code and doc parts in any order.
The ``@c`` directive starts a named code section if the node's headline starts with ``&lt;&lt;section name&gt;&gt;``.
Otherwise, the ``@c`` directive is invalid.

**Section definition lines** are lines of the form::

	&lt;&lt; section name&gt;&gt;=

(note the equal sign).
Such lines also start named code parts.
Named code parts in ``@root`` trees may be defined in several places.
The definition of a named code part is the concatenation of all code parts with the same name.
Body text that defines no code part is ignored.
At least one non-blank line must follow the section definition line;
empty sections are not allowed. 

As in ``@file`` trees, paired ``&lt;&lt;`` and ``&gt;&gt;`` characters on the same line always denote a section name,
even within comments and strings.
Thus, ``&lt;&lt;`` and ``&gt;&gt;`` characters that do not delimit a section name must be placed on separate lines.
If ``&lt;&lt;`` and ``&gt;&gt;`` are not paired on a line, they are treated as ordinary ``&lt;&lt;`` and ``&gt;&gt;`` characters.

Here is a typical example of body text within an @root tree::

    @ This method puts an open node sentinel for node v.
    &lt;&lt;atFile methods&gt;&gt;=
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            &lt;&lt; issue an error message &gt;&gt;
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

Provided that the node's headline starts with &lt;&lt;atFile methods&gt;&gt;,
the example above is equivalent to::

    @ This method puts an open node sentinel for node v.
    @c
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            &lt;&lt; issue an error message &gt;&gt;
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

We may not eliminate @c directives in @root trees.
If we convert the doc part to a comment we are left with::

    @c
    # This method puts an open node sentinel for node v.
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            &lt;&lt; issue an error message &gt;&gt;
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)
    
The following escape convention applies only in ``@root`` trees.
Within a code part ``@@`` in the first column (and only in the first column) stands for a single ``@`` sign.</t>
<t tx="ekr.20050828061501.48">Each ``@root`` tree represents a single derived file.
**Tangling** is the process of creating derived files from ``@file`` or ``@root`` trees.
Leo tangles ``@file`` trees automatically whenever an outline is saved.
The user must tangle ``@root`` trees explicitly using one of the ``Tangle`` commands.

Leo creates derived files by expanding all section references in an ``@root`` node.
Leo expands a section reference by substituting the code section itself for the section reference.
This is a recursive process:
the substituted code section may contain other code references which are themselves expanded, and so on.

The outline provides a natural way of organizing an sections as follows::

	Place the definition of a section S in a child of
	the node containing the reference to S.

If a section is referenced in more than one node,
I usually place its definition in a node containing all the nodes that refer to it.
Using this rule of thumb creates an outline whose structure mirrors the intrinsic organization of a program.

The ``Tangle`` command creates derived files from ``@root`` node.
The ``@root`` directive indicates which sections constitute an output file.
The text following a @root directive forms the entire content of the file,
that is, after section references are expanded.
An outline can contain arbitrarily many ``@root`` directives:
Leo's ``Tangle`` commands will create one output file for each.
The process of creating derived files is called "tangling" because
the code from the outline is rearranged to create the derived files.

For example, the following ``@root`` section shows a typical way of specifying a header file ``xx.h``::

    @root xx.h
    #ifndef xx_defined
    #define xx_defined
    &lt;&lt; declarations of public constants of the xx class &gt;&gt;
    &lt;&lt; declarations of public types of the xx class &gt;&gt;
    &lt;&lt; declarations of public variables of the xx class &gt;&gt;
    &lt;&lt; public prototypes of the xx class &gt;&gt;
    #endif

The ``Tangle`` commands will create the file ``xx.h`` from this body text by expanding all the section references.
Incidentally, the introductory documentation will be included in the header file:
any text preceding the ``@root`` directive is treated just like the doc part of a section definition.

As another example, the following shows a typical way of specifying the corresponding ``xx.c`` file::

    @root xx.c
    &lt;&lt; public variables of the xx class &gt;&gt;
    &lt;&lt; private types of the xx class &gt;&gt;
    &lt;&lt; private variables of the xx class &gt;&gt;
    &lt;&lt; private function prototypes of the xx class &gt;&gt;
    &lt;&lt; methods of the xx class &gt;&gt;

There are three menu commands that tangle an outline: ``Tangle``, ``Tangle All`` and ``Tangle Marked``.
These commands are identical except for how much of the outline is tangled.
The ``Tangle`` command tangles only the selected portion of the outline,
the ``Tangle All`` command tangles the entire outline,
and the ``Tangle Marked`` command tangles only marked headlines.

The ``@root`` directive has three forms.
All three forms mean exactly the same thing::

    @root filename
    @root "filename"
    @root &lt;filename&gt;

If *filename* is an absolute filename the location of the derived file is specified only by the filename.
Otherwise, if the ``@root`` node contains a relative filename, the location of the derived file is relative to:
	
1. the directory specified by an ``@path`` directive, or

2. the ``default_tangle_directory`` setting if no ``@path`` directive is in effect, or

3. the directory in which the .leo resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules,
or if the filename or directory does not exist.

The scope of a definition is the tree in which the definition is known.
By default, ``Tangle`` commands look for section definitions only
in the suboutline of the ``@root`` node being tangled.
That is, all sections are assumed to be defined either in the body text of the headline,
say h, containing the ``@root`` directive, or in the body texts of the descendants of h.
The ``@unit`` directive explicitly indicates the scope of section definitions.
When a ``Tangle`` command encounters the ``@unit`` directive it treats the suboutline containing
the ``@unit`` command as the scope for all enclosed roots.
This ensures that the group of roots in the subtree use the same section definitions.

For example, suppose we have a tree organized as follows::

	+ @unit
		+ @root A
		    sections in A
		+ @root B
		    sections in B
		
The ``@unit`` directive insures that
only sections defined in the unit can affect files A and B and
that all sections definitions in A and B are compatible with each other.

The ``Tangle`` commands ignore any tree containing an ``@ignore`` directive.
This ensures that trees that contain cloned nodes or other subsidiary information
do not cause the tangle commands to issue spurious error messages.
It also ensures that a tree can never contribute a section definition to another part of the outline by mistake.</t>
<t tx="ekr.20050828061501.49">The ``Untangle``, ``Untangle All`` and ``Untangle Marked`` commands are the
reverse of the corresponding ``Tangle`` commands.
They update one or more ``@root`` nodes based on changes made to the corresponding derived files.

For example, suppose you create a new part of the outline and tangle it for the first time.
When you compile derived files for the first you are likely to get many syntax errors.
You could fix those errors in the outline and tangle the outline again, but there is a much easier way:
you fix the errors in the derived files using the compiler's editor,
then run the untangle command on the part of the outline that created the derived file.
The ``Untangle`` command updates the selected outline to match the changes in the derived files.
It's as simple as that.
By the way, the ``Untangle`` command marks all the nodes in the outline that it updates,
and you can examine all such nodes with the ``Go To Next Marked`` command in the ``Outline`` menu.

You cannot use ``Untangle`` to update doc parts, or leading comments in code parts or
"trivial" whitespace in code parts.
This is a limitation of the ``Untangle`` command that cannot be fixed;
``Untangle`` has no way of knowing whether leading comments came from doc parts or are just leading comments.

``Untangle`` never changes the structure of an outline;
it never inserts, deletes or moves nodes.
Don't attempt to change the structure of an outline by modifying derived files; it won't work.
Also, never delete, move or alter the sentinel lines in derived files written by the ``Tangle`` command.
Such lines start with the comment delimiter followed by a section name.

If you change the section name in a sentinel line ``Untangle`` will not update the code in the outline
(with the old name) that generated the renamed section.
``Untangle`` warns about sections that appear in a derived file but not in the outline.
``Untangle`` has no trouble with changed section references in derived files;
it is only changed sentinel lines that cause problems.

Cloned nodes that generate code in several files may cause problems for ``Untangle``.
If ``Untangle`` is run separately on these derived files,
``Untangle`` will update all cloned nodes each time it is run,
so only the code in the last Untangle run will take effect.
Therefore, the safe way to update text in cloned nodes is to make the change in the .leo file rather than the derived files.</t>
<t tx="ekr.20050828061501.50">The ``@verbose``, ``@terse``, ``@quiet`` and ``@silent`` directives determine
how the ``Tangle`` command outputs comments in ``@root`` trees.
Comments written by the user in code sections are always output.
These directives control only:
a) the comments containing doc sections and
b) sentinel comments that delimit the beginning and end of code sections.

When ``@verbose`` is in effect ``Tangle`` outputs all comments.
When ``@terse`` is in effect, ``Tangle`` outputs only those comments necessary for ``Untangle`` to work.
When ``@silent`` is in effect Tangle adds no additional comments.
The ``@quiet`` directive is like @silent except that it does output leading sentinels as comments.
Like ``@silent``, ``@quiet`` inhibits untangling. 
``@verbose`` is the default.
If more than one of these directives appear in the same body text the "most verbose" of these options will be in effect.</t>
<t tx="ekr.20050828061501.51">In most respects ``@thin`` works just like ``@file``.
In fact, you can convert from ``@file`` to ``@thin`` simply by opening an outline,
changing ``@file`` to ``@thin``, and saving the outline.

Here are the differences between ``@file`` and ``@thin``:

- Leo does not save the information contained in the ``@thin`` tree in the .leo file.  

- Files derived from ``@thin`` ("thin" derived files) contain all information needed to
  recreate the ``@thin`` tree in the outline.
  In particular, ``@+node`` and ``@-node`` sentinels use timestamps to uniquely identify nodes.

- The ``@all`` directive is valid only in ``@thin`` trees.

- Thin derived files are much more friendly to cvs than files derived from ``@file`` trees.
  Developers only need to commit thin derived files to cvs.

  The cvs repository contains **reference** .leo files.
  These reference files should containing nothing but ``@thin`` nodes.
  Reference files will change only when new derived files get added to the project.

  Developers will use local copies of reference files for their own work.
  For example, instead of using LeoPyRef.leo directly, I use a copy called ``LeoPy.leo``.
  My local copy can contain nodes other than ``@thin`` nodes.</t>
<t tx="ekr.20050828062751">In the following table all terms in each row are equivalent.
The spelling in the first column is preferred:

=========== =============== =================
\@asis      \@file-asis     \@silent
----------- --------------- -----------------
\@nosent    \@file-nosent   \@nosentinelsfile
----------- --------------- -----------------
\@noref     \@file-noref    \@rawfile
=========== =============== =================

You can get any combination of sentinels/no sentinels and references/no references using
``@file``, ``@nosent``, ``@noref`` and ``@asis`` trees:

+---------+------------+-------------------+
|         |            | Sections and      |
| Type    | Sentinels? | @others expanded? |
+---------+------------+-------------------+
| @asis   | no         | no                |
+---------+------------+-------------------+
| @file   | yes        | yes               |
+---------+------------+-------------------+
| @noref  | yes        | no                |
+---------+------------+-------------------+
| @nosent | no         | yes               |
+---------+------------+-------------------+

Leo can not update the outline from changes made from derived files unless those files contain sentinels.
The primary source for ``@nosent`` and ``@asis`` trees are the outlines from which those files were derived.</t>
<t tx="ekr.20050828064254">The ``@others`` directive refers to the body text of all nodes *except* section definition nodes.
The ``@others`` directive places the body text of section definition nodes in the derived file in outline order.

An ``@file`` tree may contain more than one ``@others`` directive.
``@others`` directives that descend from other ``@others`` directives refer only to unnamed nodes that descend from them.
The ``@others`` directive that occurs highest in the ``@file`` tree refers to all other unnamed nodes.

**Notes**:

- No node may contain more than one ``@others`` directive.

- No section definition node may intervene between an non-section definition node containing body text and
  an ``@others`` node.
  In practice this is never a problem.

- The ``@others`` directive is not valid in ``@root`` or ``@unit`` trees.</t>
<t tx="ekr.20050828065955">* Spell check.</t>
<t tx="ekr.20050828065955.3">The ``@ignore`` directive is valid *only* in the root node of ``@file`` trees.
The ``@ignore`` directive has several uses:

- In the root node of an ``@file`` tree, ``@ignore`` prevents Leo from writing the derived file.

- In ``@root`` trees, ``@ignore`` excludes the ``@ignore`` tree from the derived file.

- Outside of ``@file`` and ``@root`` trees, ``@ignore`` can be used by scripts.</t>
<t tx="ekr.20050828103319">When writing `derived files`_, Leo stores information about the outline
structure in special comments called **sentinel lines**. Sentinel lines are
comment lines with '@' following the comment delimiter. For example, here are
some actual sentinel line for the derived file containing Python code::

    #@+leo-ver=4-thin
    #@+node:ekr.20031218072017.2794:@thin leoColor.py
    #@@language python
    #@@tabwidth -4
    #@@pagewidth 80
    #@-node:ekr.20031218072017.2794:@thin leoColor.py
    #@-leo

**You must not change sentinel lines** when editing a `derived file`_ in another
editor! Doing so will corrupt the derived file and make it impossible for Leo to
read it normally. If you do accidentally alter a sentinel line, don't panic!
Leo's ``Import Derived File`` command_ can recover information from corrupted
derived files.

The main difference between `@file`_ trees, `@thin`_ trees (and other kinds of trees that create derived files)
is the kind of sentinel lines that Leo writes:

- Sentinels in files derived from `@thin`_ reduce spurious cvs conflicts by
  marking each node with unique, unchanging **timestamp** as shown above.

- Sentinels in files derived from `@file`_ are as friendly as possible for human readers.

- Files derived from `@nosent`_ have no sentinels at all.
  **Important**: without sentinels Leo can not automatically update
  ``@nosent`` trees from changes made in external editors.

`Chapter 4: Writing Programs in Leo`_ discusses the various ways of creating derived files.
This is a highly complex subject: you should ignore these details at first.
Just use ``@thin`` to create your `derived files`_.</t>
<t tx="ekr.20050828112159">.. _`Front Matter`:                                 frontMatter.html
.. _`What people are saying about Leo`:             testimonials.html
.. _`FAQ`:                                          FAQ.html
.. _`Chapter 1\: Installing Leo`:                   install.html
.. _`Chapter 2\: A Tutorial Introduction to Leo`:   intro.html
.. _`Chapter 3\: Using Leo's Outlines`:             outlines.html
.. _`Chapter 4\: Writing Programs in Leo`:          directives.html
.. _`Chapter 5\: Using Leo's Commands`:             commands.html
.. _`Chapter 6\: Leo and Literate Programming`:     design.html
.. _`Chapter 7\: Scripting Leo with Python`:        scripting.html
.. _`Chapter 8\: Customizing Leo`:                  customizing.html
.. _`Chapter 9\: History of Leo`:                   history.html
.. _`Chapter 10\: Theory of Operation`:             theory.html
.. _`Chapter 11\: White Papers`:                    whitepapers.html
.. _`Chapter 12\: Plugins`:                         plugins.html
.. _`Appendices`:                                   appendices.html
.. _`Glossary`:                                     glossary.html

.. WARNING: image targets may not have upper case letters!

.. |leo|  image:: leo.gif
    :target: front.html

.. |next| image:: arrow_rt.gif
    :target: frontMatter.html

.. |blank| image:: Blank.gif</t>
<t tx="ekr.20050828115003">------------------

|back| |leo| |next|</t>
<t tx="ekr.20050828160132">.. External links...

.. _`CWEB`:     http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`noweb`:    http://www.eecs.harvard.edu/~nr/noweb/

.. Relative links...

.. _front:      front.html
.. _`Leo's tutorial`:       intro.html

.. WARNING: image targets may not have upper case letters!

.. _back:   outlines.html
.. _home:   front.html
.. _next:   commands.html

.. |back| image:: arrow_lt.gif
    :target: back_

.. |next| image:: arrow_rt.gif
    :target: next_

.. |blank| image:: blank.gif

.. |leo|   image:: leo.gif
    :target: home_</t>
<t tx="ekr.20050828161117">An **orphan node** is a descendant of an `@thin`_ node_ that will not be copied
to the `derived file`_. Orphan nodes can arise because an `@thin`_ tree has no
``@others`` or ``@all`` directives. Sections that are defined but not used also
create orphan nodes. Leo issues a warning when attempting to write an `@thin`_
tree containing orphan nodes, and does not save the derived file. Instead Leo
saves the information in the `@thin`_ tree in the .leo file. No information is
lost; Leo will load the `@thin`_ tree from the .leo file the next time Leo
opens the .leo file.

</t>
<t tx="ekr.20050828163557">You can create derived files using six kinds of directives.
The first five,
``@file-thin``, ``@file``, ``@file-nosent``, ``@file-noref``, ``@file-asis``,
are collectively known as ``@file`` trees.
The abbreviated forms are most common:
``@thin``, ``@file``, ``@nosent``, ``@noref`` and ``@asis``.
There is also a sixth directive: ``@root``.

**Important**: You create the ``@file`` trees by putting
``@thin``, ``@file``, ``@nosent``, ``@noref`` or ``@asis`` (or the long forms) in a *headline*.
In contrast, you create ``@root`` trees by putting the ``root`` directive in *body text*.
The term 'directive' usually refers to a construct in Leo's body text.
In this chapter *I'll stretch the term* to include all 10 ``@file`` forms,
as well as the true ``@root`` directive.
Here are the six ways of creating derived files:

\@thin
  Use this unless you have a good reason not to.
  It is the 'state-of-the-art' in derived files.
  This form is easy to use and is cvs friendly.
  Using ``@thin`` reduces the size of .leo files,
  and saves all essential information in the derived file.
  ``@all`` directives are valid only in ``@thin`` trees.

\@file
  This was the old 'state-of-the-art' directive.
  There is not much reason to use it now,
  except that its sentinels are more readable than ``@thin`` sentinels.
  However, ``@file`` is not nearly as cvs friendly as ``@thin``;
  avoid ``@file`` in cooperative environments.

\@nosent
  Use this directive only if you absolutely can not tolerate any sentinels in derived files.
  Without sentinels, Leo can not update ``@nosent`` trees from changes made to the derived files.
  *Consider using @thin even if you must produce derived files without sentinels*.
  You can use ``@thin`` for most work, then change ``@thin`` to ``@nosent``
  when showing your derived files to the world.

\@noref
  This directive produces derived files with minimal sentinels.
  Section references are not allowed.
  This is the least often used way of producing derived files.
  Don't use this unless you are sure you must.

\@asis
  This directive copies body text verbatim,
  without even ensuring that newlines terminate each node.
  Use this directive only when you must have complete control over every character of the derived file.

\@root
  This directive is the most flexible, and the most difficult to use.
  **Note**: ``@root`` is a true directive: you put ``@root`` in body text.
  Historically, this was the first directive that created derived files.
  It comes closest in spirit to traditional literate programming tools.
  However, it is seldom necessary to suffer the drawbacks of using ``@root``.
  It is certainly never necessary when programming in Python.
  My advice is to avoid using ``@root`` unless you have a compelling reason.

To complicate matters further,
you can use `CWEB`_ markup instead of `noweb`_ markup.
See the section called `CWEB mode`_ for the details.
The choice between CWEB and noweb is independent of the directive is used to create derived files.</t>
<t tx="ekr.20050828173234">The ``@`` directive starts a doc part.
Doc parts continue until an ``@c`` directive or the end of the body text.
For example::

    @ This is a comment in a doc part.
    Doc parts can span multiple lines.
    The next line ends the doc part
    @c

``@doc`` is a synonym for ``@``, but ``@`` is preferred.</t>
<t tx="ekr.20050828173234.1">The ``@c`` directive ends a doc part and begins a code part.
``@code`` is a synonym for ``@c``, but ``@c`` is preferred.

In ``@root`` and ``@unit`` trees, the headline must contain a valid section name.</t>
<t tx="ekr.20050828174453.1">Leo writes ``@nosent`` trees just as for ``@thin`` trees,
but Leo writes no sentinels at all.</t>
<t tx="ekr.20050828174453.2">The only difference between ``@asis`` and ``@noref`` trees is that files derived from
``@noref`` contain sentinels while files derived from ``@asis`` do not.

Leo creates files derived from ``@noref`` and ``@asis`` trees by
writing the body text of all nodes of the tree in outline order.
Leo writes the body text *as is*, without recognizing section definitions,
without expanding section references, and without treating directives specially in any way.
In particular, Leo copies all directives,
including ``@`` or ``@c`` directives, to the derived file as text.

Leo does recognize the ``@ignore`` directive in the *ancestors* of ``@noref`` or ``@asis`` nodes,
so you may use the ``@ignore`` directive as usual to prevent Leo from writing ``@noref`` or ``@asis`` trees.

**Notes**:

- When writing ``@noref`` trees,
  Leo writes only the ``@+leo``, ``@-leo``, ``@+node``, ``@-node``, ``@+body`` and ``@-body`` sentinels.

- Within ``@asis`` trees only, if a headline starts with ``@@``,
  Leo writes everything in the headline following the ``@@`` just before the corresponding body text.

- Files derived from ``@asis`` trees contain *nothing* not contained in body text (or ``@@`` headlines).
  In particular, if body text does not end in a newline,
  the first line from the next node will concatenated to the last line of the preceding node.</t>
<t tx="ekr.20050828205054">The following directives are commonly used by Leo programmers.
See `Chapter 4: Writing Programs in Leo`_ for full details.

- **@** Starts doc parts (and ends code parts).

- **@all** Copies *all* descendant nodes to the derived file.

- **@c** Starts code parts (and ends doc parts).

- **@encoding** Sets the Unicode encoding used in derived files.

- **@first** Forces lines to appear before the first sentinel of a derived file.
   
- **@language** Sets the language used for syntax coloring **and** sets the comment delimiters 
  used in sentinel lines and in doc parts.

- **@last** Forces lines to appear after the last sentinel of a derived file.

- **@lineending** Specifies the line ending to be used in derived files.

- **@others** Copies all nodes *except section definition nodes* to the derived file.

- **@pagewidth** Sets the page width used to break doc parts into lines.

- **@path** Sets the path to be prepended to filenames in descendant ``@file`` nodes.</t>
<t tx="ekr.20050828210721">The ``@last`` directive allows you to place lines at the very end of files derived from ``@file`` nodes.
The ``@last`` directive is recognized only at the end of body text of ``@file`` nodes.
No text may follow ``@last`` directives.
More than one ``@last`` directive may exist.
For example, here is how a PHP file might be set up::

	@first &lt;?php
	...
	@last ?&gt;</t>
<t tx="ekr.20050828210721.1">The ``@pagewidth`` directive overrides the ``page_width`` setting.
The form of the ``@pagewidth`` directive is ``@pagewidth`` *n*,
where n is a positive integer that indicates the width of tangled pages in columns.
For example::

    @pagewidth 100

This setting only affects how Leo reformats doc parts, and how the ``Tangle`` command outputs block comments.

</t>
<t tx="ekr.20050828210721.2">The ``@tabwidth`` directive overrides the ``tab_width`` setting.
The form of the ``@tabwidth`` directive is ``@tabwidth`` *n*,
where n is a positive integer that indicates the width of tabs in spaces.
For example::

    @tabwidth -4

Negative values cause Leo to convert tabs to blanks.</t>
<t tx="ekr.20050828211507">Here is a brief summary of each directive:

- **\@**
  Starts a doc part. ``@doc`` is a deprecated synonym.

- **\@all**
  Copies *all* descendant nodes to the derived file.
  Not valid in ``@root`` trees.

- **\@c**
  Starts a code part. ``@code`` is a deprecated synonym.

- **\@color**, **\@nocolor** and **\@killcolor**
  Control syntax coloring.

- **\@comment**
  Sets comment delimiters in ``@root`` and ``@unit`` trees.

- **\@delims**
  Sets comment delimiters in ``@file`` trees.

- **\@encoding**
  Sets the Unicode encoding used in derived files.

- **\@first**
  Forces lines to appear before the first sentinel of a derived file.

- **\@ignore**
  Causes Leo to ignore all or part of a derived file.
  Works differently in ``@file`` and ``@root`` trees.

- **\@language**
  Sets the language used for syntax coloring **and**
  sets the comment delimiters used in sentinel lines and in doc parts.

- **\@last**
  Forces lines to appear after the last sentinel of a derived file.

- **\@lineending**
  Sets the line ending to be used in derived files.

- **\@others**
  Copies all nodes *except* section definition nodes to the derived file.

- **\@pagewidth**
  Sets the page width used to break doc parts into lines.

- **\@path**
  Set the path to be appended to filenames.

- **\@raw** and **\@end_raw**
  Delimit a section of 'raw' text.
  Not valid in ``@root`` or ``@unit`` trees.

- **\@root**, **\@root-code** and **\@root-code**
  Start an ``@root`` tree.
  The last two forms set the starting mode for body text.

- **\@tabwidth**
  Sets the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces.

- **@verbose**, **@terse**, **@quiet** and **@silent**
  Set the verbosity of sentinels in files derived from ``@root``.

- **\@wrap** and **\@nowrap**
  Enable or disable line wrapping the Leo's body pane.</t>
<t tx="ekr.20050829081318">This section covers all the details of programming with Leo that beginners are likely to need.
`Chapter 4: Writing Programs in Leo`_ is the full reference guide.
I recommend avoiding that chapter until you have been programming with Leo for some time.
</t>
<t tx="ekr.20050829083129">Here is a brief summary of each directive:

\@
    Starts a doc part. ``@doc`` is a deprecated synonym.

\@all
    Copies *all* descendant nodes to the derived file.
    Not valid in ``@root`` trees.

\@c
    Starts a code part. ``@code`` is a deprecated synonym.

\@color, \@nocolor and \@killcolor
    Control syntax coloring.

\@comment
    Sets comment delimiters in ``@root`` and ``@unit`` trees.

\@delims
    Sets comment delimiters in ``@file`` trees.

\@encoding
    Sets the Unicode encoding used in derived files.

\@first
    Forces lines to appear before the first sentinel of a derived file.

\@ignore
    Causes Leo to ignore all or part of a derived file.
    In ``@file`` trees, only valid in the actual ``@file`` node itself.
    May appear anywhere in ``@root`` trees.

\@language
    Sets the language used for syntax coloring and
    sets the comment delimiters used in sentinel lines and in doc parts.

\@last
    Forces lines to appear after the last sentinel of a derived file.

\@lineending
    Sets the line ending to be used in derived files.

\@others
    Copies all nodes *except* section definition nodes to the derived file.

\@pagewidth
    Sets the page width used to break doc parts into lines.

\@path
    Set the path to be appended to filenames in descendant ``@file`` nodes.

\@raw and \@end_raw
    Delimits a section of 'raw' text.
    Not valid in ``@root`` or ``@unit`` trees.

\@root, \@root-code and \@root-code
    Start an ``@root`` tree.
    ``@root-code`` and ``root-doc`` specify whether body text starts in code or doc mode by default.

\@tabwidth
    Sets the width of tabs.
    Negative tab widths cause Leo to convert tabs to spaces.

\@wrap and \@nowrap
    Enable or disable line wrapping the Leo's body pane.
    Only the first ``@wrap`` or ``@nowrap`` directive in a node has any effect.</t>
<t tx="ekr.20050829134901">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

.. August 28, 2005

|back| |leo| |next|

#####################################
Chapter 4: Writing Programs in Leo
#####################################
</t>
<t tx="ekr.20050829134901.1">.. _front:      http://webpages.charter.net/edreamleo/front.html
.. _home:       http://webpages.charter.net/edreamleo/front.html
.. _back:       http://webpages.charter.net/edreamleo/outlines.html
.. _next:       http://webpages.charter.net/edreamleo/commands.html

.. _`CWEB`:     http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`noweb`:    http://www.eecs.harvard.edu/~nr/noweb/

.. |back| image:: arrow_lt.gif
    :target: back_

.. |next| image:: arrow_rt.gif
    :target: next_

.. |blank| image:: blank.gif

.. |leo|   image:: leo.gif
    :target: front_

.. _`Leo's tutorial`:       http://webpages.charter.net/edreamleo/intro.html
</t>
<t tx="ekr.20050829134901.2">** Use active verbs!

* Spell check.</t>
<t tx="ekr.20050829134901.3">This chapter is a *reference guide* to computer programming with Leo.
This chapter does *not* teach you how to use Leo:
for that you should read `Leo's tutorial`_.
This chapter assumes you are thoroughly familiar with the terminology introduced in the tutorial.
**Note**: Are you *sure* you want to read this chapter?
It contains many details that are no interest to the average user of Leo.
I recommend using Leo for two weeks, or longer, before attempting this chapter.

.. contents::</t>
<t tx="ekr.20050829134901.4">You can create derived files using six kinds of directives.
The first five,
``@file-thin``, ``@file``, ``@file-nosent``, ``@file-noref``, ``@file-asis``,
are collectively known as ``@file`` trees.
The abbreviated forms are most common:
``@thin``, ``@file``, ``@nosent``, ``@noref`` and ``@asis``.
There is also a sixth directive: ``@root``.

**Important**: You create the ``@file`` trees by putting
``@thin``, ``@file``, ``@nosent``, ``@noref`` or ``@asis`` (or the long forms) in a *headline*.
In contrast, you create ``@root`` trees by putting the ``root`` directive in *body text*.
The term 'directive' usually refers to a construct in Leo's body text.
In this chapter *I'll stretch the term* to include all 10 ``@file`` forms,
as well as the true ``@root`` directive.
Here are the six ways of creating derived files:

\@thin
  Use this unless you have a good reason not to.
  It is the 'state-of-the-art' in derived files.
  This form is easy to use and is cvs friendly.
  Using ``@thin`` reduces the size of .leo files,
  and saves all essential information in the derived file.
  ``@all`` directives are valid only in ``@thin`` trees.

\@file
  This was the old 'state-of-the-art' directive.
  There is not much reason to use it now,
  except that its sentinels are more readable than ``@thin`` sentinels.
  However, ``@file`` is not nearly as cvs friendly as ``@thin``;
  avoid ``@file`` in cooperative environments.

\@nosent
  Use this directive only if you absolutely can not tolerate any sentinels in derived files.
  Without sentinels, Leo can not update ``@nosent`` trees from changes made to the derived files.
  *Consider using @thin even if you must produce derived files without sentinels*.
  You can use ``@thin`` for most work, then change ``@thin`` to ``@nosent``
  when showing your derived files to the world.

\@noref
  This directive produces derived files with minimal sentinels.
  Section references are not allowed.
  This is the least often used way of producing derived files.
  Don't use this unless you are sure you must.

\@asis
  This directive copies body text verbatim,
  without even ensuring that newlines terminate each node.
  Use this directive only when you must have complete control over every character of the derived file.

\@root
  This directive is the most flexible, and the most difficult to use.
  **Note**: ``@root`` is a true directive: you put ``@root`` in body text.
  Historically, this was the first directive that created derived files.
  It comes closest in spirit to traditional literate programming tools.
  However, it is seldom necessary to suffer the drawbacks of using ``@root``.
  It is certainly never necessary when programming in Python.
  My advice is to avoid using ``@root`` unless you have a compelling reason.

To complicate matters further,
you can use `CWEB`_ markup instead of `noweb`_ markup.
See the section called `CWEB mode`_ for the details.
The choice between CWEB and noweb is independent of the directive is used to create derived files.</t>
<t tx="ekr.20050829134901.5">Here is a brief summary of each directive:

- **\@**
  Starts a doc part. ``@doc`` is a deprecated synonym.

- **\@all**
  Copies *all* descendant nodes to the derived file.
  Not valid in ``@root`` trees.

- **\@c**
  Starts a code part. ``@code`` is a deprecated synonym.

- **\@color**, **\@nocolor** and **\@killcolor**
  Control syntax coloring.

- **\@comment**
  Sets comment delimiters in ``@root`` and ``@unit`` trees.

- **\@delims**
  Sets comment delimiters in ``@file`` trees.

- **\@encoding**
  Sets the Unicode encoding used in derived files.

- **\@first**
  Forces lines to appear before the first sentinel of a derived file.

- **\@ignore**
  Causes Leo to ignore all or part of a derived file.
  Works differently in ``@file`` and ``@root`` trees.

- **\@language**
  Sets the language used for syntax coloring **and**
  sets the comment delimiters used in sentinel lines and in doc parts.

- **\@last**
  Forces lines to appear after the last sentinel of a derived file.

- **\@lineending**
  Sets the line ending to be used in derived files.

- **\@others**
  Copies all nodes *except* section definition nodes to the derived file.

- **\@pagewidth**
  Sets the page width used to break doc parts into lines.

- **\@path**
  Set the path to be appended to filenames.

- **\@raw** and **\@end_raw**
  Delimit a section of 'raw' text.
  Not valid in ``@root`` or ``@unit`` trees.

- **\@root**, **\@root-code** and **\@root-code**
  Start an ``@root`` tree.
  The last two forms set the starting mode for body text.

- **\@tabwidth**
  Sets the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces.

- **@verbose**, **@terse**, **@quiet** and **@silent**
  Set the verbosity of sentinels in files derived from ``@root``.

- **\@wrap** and **\@nowrap**
  Enable or disable line wrapping the Leo's body pane.</t>
<t tx="ekr.20050829134901.6">Here is a brief summary of each directive:

\@
    Starts a doc part. ``@doc`` is a deprecated synonym.

\@all
    Copies *all* descendant nodes to the derived file.
    Not valid in ``@root`` trees.

\@c
    Starts a code part. ``@code`` is a deprecated synonym.

\@color, \@nocolor and \@killcolor
    Control syntax coloring.

\@comment
    Sets comment delimiters in ``@root`` and ``@unit`` trees.

\@delims
    Sets comment delimiters in ``@file`` trees.

\@encoding
    Sets the Unicode encoding used in derived files.

\@first
    Forces lines to appear before the first sentinel of a derived file.

\@ignore
    Causes Leo to ignore all or part of a derived file.
    In ``@file`` trees, only valid in the actual ``@file`` node itself.
    May appear anywhere in ``@root`` trees.

\@language
    Sets the language used for syntax coloring and
    sets the comment delimiters used in sentinel lines and in doc parts.

\@last
    Forces lines to appear after the last sentinel of a derived file.

\@lineending
    Sets the line ending to be used in derived files.

\@others
    Copies all nodes *except* section definition nodes to the derived file.

\@pagewidth
    Sets the page width used to break doc parts into lines.

\@path
    Set the path to be appended to filenames in descendant ``@file`` nodes.

\@raw and \@end_raw
    Delimits a section of 'raw' text.
    Not valid in ``@root`` or ``@unit`` trees.

\@root, \@root-code and \@root-code
    Start an ``@root`` tree.
    ``@root-code`` and ``root-doc`` specify whether body text starts in code or doc mode by default.

\@tabwidth
    Sets the width of tabs.
    Negative tab widths cause Leo to convert tabs to spaces.

\@wrap and \@nowrap
    Enable or disable line wrapping the Leo's body pane.
    Only the first ``@wrap`` or ``@nowrap`` directive in a node has any effect.</t>
<t tx="ekr.20050829134901.7">The following sections give full details about each directive.
</t>
<t tx="ekr.20050829134901.8">The ``@`` directive starts a doc part.
Doc parts continue until an ``@c`` directive or the end of the body text.
For example::

    @ This is a comment in a doc part.
    Doc parts can span multiple lines.
    The next line ends the doc part
    @c

``@doc`` is a synonym for ``@``, but ``@`` is preferred.</t>
<t tx="ekr.20050829134901.9">The ``@all`` directive is valid only in ``@thin`` trees.
The ``@all`` directive is similar to ``@others``, but it is less restrictive:
it dumps *all* nodes to the derived file, including ``@ignore`` nodes and nodes that
in an ``@others`` tree would be considered to be orphan nodes.

The ``@all`` directive is required for files such as ``@thin leoProjects.txt`` in ``LeoPy.leo``.
``leoProjects.txt`` contains so-called project nodes.
It doesn't have any meaning as a program file: it is simply a collection of unrelated data.
``@others`` would not work at all: it would complain about lots of orphan nodes.</t>
<t tx="ekr.20050829134901.10">The ``@c`` directive ends a doc part and begins a code part.
``@code`` is a synonym for ``@c``, but ``@c`` is preferred.</t>
<t tx="ekr.20050829134901.11">Syntax coloring is on by default in all body text.
Leo formats comments and documentation parts in red,
directives and C keywords in blue,
strings and character constants in gray and all other text in code parts in black.
The ``@nocolor`` directive disables syntax coloring for the body text in which it appears.
No syntax coloring is done until an ``@color`` directive re-enables syntax coloring.

If a node contains neither the ``@color`` nor the ``@nocolor`` directive
it may inherit the syntax coloring attribute from an ancestor.
The nearest ancestor that contains exactly one of the ``@color`` or ``@nocolor`` directives
will control the syntax coloring.
**Ambiguous nodes**, nodes containing both the ``@color`` and ``@nocolor`` directives,
never affect the coloring of their offspring.

The ``@killcolor`` directive completely disables the colorizer for that node.
The result much faster syntax coloring of large body text.
As usual ``@killcolor`` may itself be overridden in descendant nodes.
The differences between ``@killcolor`` and ``@nocolor``:

- ``@nocolor`` suppresses coloring only until the next ``@color`` directive.

- ``@killcolor`` overrides ``@nocolor`` and ``@color`` directives.
  Any node containing @killcolor is unambiguously a ``@killcolor`` node regardless of
  whether that node also contains ``@color`` or ``@nocolor`` directives.

**Note**:
the ``@color``, ``@nocolor`` and ``@killcolor`` directives do not affect the ``Tangle`` commands in any way.
In particular, the ``Tangle`` commands will recognize section definitions as usual even
after an ``@nocolor`` directive is seen.</t>
<t tx="ekr.20050829134901.12">**Note**:
the ``@comment`` directive is deprecated:
you should use the ``@language`` directive whenever possible.
However, sometimes using both ``@language`` and ``@comment`` is useful.
For this to be effective the ``@comment`` directive should appear after the ``@language`` directive (in outline order).

The ``Untangle`` command will not process an ``@root`` or ``@unit`` node if
an ``@comment`` directive is in effect because
``Untangle`` can't be sure of properly parsing a derived file if the language of the derived file isn't known.
It might be possible to assume some defaults in this case,
but that is not done at present and is not a high priority.
By default, the ``Tangle`` commands produces C-language comments.
Single-line comments generated during tangling start with ``///``,
while documentation parts are surrounded by ``/*`` and ``*/``.
The ``@comment`` directive allows you to use ``Tangle`` to produce shell and make files,
as well as source code for other programming languages.

The ``@comment`` directive may be followed by zero to three delimiters, separated by whitespace.
This directive sets the single-line comment delimiter and the opening and closing block comment delimiters as follows:

====================== =====================================================================
\@comment              no args\: restores the defaults to ///, /\* and \*/
---------------------- ---------------------------------------------------------------------
\@comment ///          \1 arg\: sets the single-line comment and clears the other delims.
---------------------- ---------------------------------------------------------------------
\@comment /\* \*/      \2 args\: sets the block comment delims; clears the single-line delim.
---------------------- ---------------------------------------------------------------------
\@comment /// /\* \*/  \3 args\: sets all three delimiters.
====================== =====================================================================

If only one delimiter is given, Leo does not write any documentation parts while tangling.
If two delimiters are given, block-style comments are used instead of single-line comments.
For example, the ``@comment { }`` directive could be used to tangle Pascal files.

The ``@comment`` directive is only recognized in ``@root``, ``@unit`` or ``@file`` nodes,
and the ``@comment`` directive must precede the first section name or ``@code`` directive.
An ``@comment`` directive in the body text of an ``@unit`` directive specifies the current global defaults.
An ``@comment`` directive in the body text of an ``@root`` directive affects comments generated for one root only.
Comments in all other roots are governed by the global defaults.

Leo will convert underscores in the ``@comment`` directives to significant spaces.  For example::

    @comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).</t>
<t tx="ekr.20050829134901.13">The ``@delims`` directive changes the comment strings used to mark sentinel lines.
This directive is often used to place Javascript text inside XML or HTML files.

The ``@delims`` directive contains one or two delimiters, separated by whitespace.
If only one delim is present it delimits single-line comments.
If two delims are present they delimit block comments.
The ``@delims`` directive can not be used to change the comment strings at the start of the derived file,
that is, the comment strings for the ``@+leo`` sentinel and the initial ``@+body`` and ``@+node`` sentinels.

The ``@delims`` directive inserts ``@@delims`` sentinels into the derived file.
The new delimiter strings continue in effect until the next ``@@delims`` sentinel in the derived file or
the end of the derived file.

**Note**: Leo can not revert to previous delimiters automatically;
you must change back to previous delimiters using another ``@delims`` directive. For example::

    @delims /* */
    Javascript stuff
    @delims &lt;-- --&gt;
    HTML stuff

Adding, deleting or changing ``@@delims`` sentinels will destroy Leo's ability to read the derived file.
Mistakes using the ``@delims`` directive have no effect on Leo,
though such mistakes will thoroughly mess up a derived file as far as compilers,
HTML renderers, etc. are concerned.</t>
<t tx="ekr.20050829134901.14">You may use the ``@encoding`` directive to specify the encoding used in a derived file.
You can't mix encodings in a single derived file.  For example::

    @encoding iso-8859-1

If the encoding used in a derived file is not "utf-8" it is represented in the @+leo sentinel line, like this::

    #@+leo-encoding=iso-8859-1.

The ``utf-8`` encoding is used by default.
The ``utf-8`` encoding is a "lossless" encoding (it can represent all unicode code points),
so encoding and decoding to and from ``utf-8`` plain strings will never cause a problem.
When reading or writing a character not in a "lossy" encoding (such as ``iso-8859-1``),
Leo converts such characters to ``'?'`` and issues a warning. </t>
<t tx="ekr.20050829134901.15">The ``@first`` directive allows you to place lines at the very start of files derived from ``@file`` nodes.
For example, the body text of ``@file spam.py`` might be::

	@first #! /usr/bin/env python

The body text of ``@file foo.perl`` might be::

	@first #/usr/bin/perl

``@first`` directives are recognized only at the start of the body text of ``@file`` nodes.
No text may precede ``@first`` directives.
More than one ``@first`` directive may exist, like this::

	@first #! /usr/bin/env python
	@first # more comments.</t>
<t tx="ekr.20050829134901.16">The ``@ignore`` directive is valid *only* in the root node of ``@file`` trees.
The ``@ignore`` directive has several uses:

- In the root node of an ``@file`` tree, ``@ignore`` prevents Leo from writing the derived file.

- In ``@root`` trees, ``@ignore`` excludes the ``@ignore`` tree from the derived file.

- Outside of ``@file`` and ``@root`` trees, ``@ignore`` can be used by scripts.</t>
<t tx="ekr.20050829134901.17">The ``@language`` directive specifies the comment delimiters and string types used by the
``Tangle`` and ``Untangle`` commands.
This directive over-rides the default specified in the settings dialog.
Here are the valid ``@language`` directives::

    @language actionscript
    @language c
    @language c++
    @language cweb
    @language elisp
    @language html
    @language java
    @language latex
    @language objective-c
    @language pascal
    @language perl
    @language perlpod
    @language plain
    @language python
    @language rebol
    @language shell
    @language tcltk

Shell files have comments that start with `#`.
Case is ignored in the language specifiers, but not in the ``@language`` itself.
Thus, the following are equivalent::

    @language html
    @language HTML
    @language hTmL

but the following is invalid::

    @LANGUAGE html</t>
<t tx="ekr.20050829134901.18">The ``@last`` directive allows you to place lines at the very end of files derived from ``@file`` nodes.
The ``@last`` directive is recognized only at the end of body text of ``@file`` nodes.
No text may follow ``@last`` directives.
More than one ``@last`` directive may exist.
For example, here is how a PHP file might be set up::

	@first &lt;?php
	...
	@last ?&gt;</t>
<t tx="ekr.20050829134901.19">The ``@lineending`` directive sets the line endings for individual derived files.
This directive will override the ``output_newline`` setting.
The ``@lineending`` *never* affects the line endings in .leo files themselves:
.leo files must have consistent line endings!

The valid forms of the ``@lineending`` directive are:

======================= ======================================================
\@lineending nl         The default, Linux.
----------------------- ------------------------------------------------------
\@lineending cr         Mac
----------------------- ------------------------------------------------------
\@lineending crlf       Windows
----------------------- ------------------------------------------------------
\@lineending lf         Same as 'nl', not recommended
----------------------- ------------------------------------------------------
\@lineending platform   Same as platform value for ``output_newline`` setting.
======================= ======================================================</t>
<t tx="ekr.20050829134901.20">The ``@others`` directive refers to the body text of all nodes *except* section definition nodes.
The ``@others`` directive places the body text of section definition nodes in the derived file in outline order.

An ``@file`` tree may contain more than one ``@others`` directive.
``@others`` directives that descend from other ``@others`` directives refer only to unnamed nodes that descend from them.
The ``@others`` directive that occurs highest in the ``@file`` tree refers to all other unnamed nodes.

**Notes**:

- No node may contain more than one ``@others`` directive.

- No section definition node may intervene between an non-section definition node containing body text and
  an ``@others`` node.
  In practice this is never a problem.</t>
<t tx="ekr.20050829134901.21">The ``@path`` directives override the deprecated ``default_tangle_directory`` setting.

The form of the @path directive is ``@path`` *filename*,
where *filename* is taken to be everything following @path to the end of the line.

If *filename* is an absolute filename the location of the derived file is specified only by the filename.
Otherwise, if *filename* is a relative filename, the location of the derived file is relative to:
	
1. the directory specified the applicable ``@path`` directive, or
2. the "Default Tangle Directory" in the Settings dialog if no ``@path`` directive is in effect, or
3. the directory in which the .leo resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules,
or if *filename* does not exist.</t>
<t tx="ekr.20050829134901.22">The ``@pagewidth`` directive overrides the ``page_width`` setting.
The form of the ``@pagewidth`` directive is ``@pagewidth`` *n*,
where n is a positive integer that indicates the width of tangled pages in columns.
For example::

    @pagewidth 100

This setting only affects how Leo reformats doc parts, and how the ``Tangle`` command outputs block comments.

</t>
<t tx="ekr.20050829134901.23">The ``@tabwidth`` directive overrides the ``tab_width`` setting.
The form of the ``@tabwidth`` directive is ``@tabwidth`` *n*,
where n is a positive integer that indicates the width of tabs in spaces.
For example::

    @tabwidth -4

Negative values cause Leo to convert tabs to blanks.</t>
<t tx="ekr.20050829134901.24">The ``@raw`` and ``@end_raw`` directives are valid only within ``@file`` trees.
The ``@raw`` directive starts a section of "raw" text.
The ``@end_raw`` directive ends such a section, as does the end of body text.
No section references are recognized within raw text,
and no additional leading whitespace is generated within raw text when writing the derived file.
</t>
<t tx="ekr.20050829134901.25">Leo allows you to choose whether body text in ``@root`` trees will start in code mode or doc mode by default.
``@root-doc`` *filename* and ``@root-code`` *filename* directives
specify that body text is assumed to start in doc mode or code mode respectively.
The options (``-doc`` and ``-code``) must follow ``@root`` immediately with no intervening whitespace.
In effect, ``@root-code`` and ``@root-doc`` are two new directives.

These ``@root`` options override the ``at_root_bodies_start_in_doc_mode`` setting.
This setting affects only @root trees without options.
Such "plain" ``@root`` trees are now deprecated,
which only means that it is better style to use either ``@root-code`` or ``@root-doc``.
The reason is simple:
the meaning of plain ``@root`` trees will depend on the ``at_root_bodies_start_in_doc_mode`` setting.
It's better to be explicit.
By default, ``at_root_bodies_start_in_doc_mode = 1`` for compatibility for old ``@root`` trees.
I actually don't think this option is good for much;
I created it before I created ``@root-doc`` and ``@root-code`` settings,
and I decided it wouldn't hurt to leave it in.
Anyway, you now have complete flexibility about how ``@root`` works,
and in particular you can make ``@root`` work just like ``@file``.</t>
<t tx="ekr.20050829134901.26">The ``@verbose``, ``@terse``, ``@quiet`` and ``@silent`` directives determine
how the ``Tangle`` command outputs comments in ``@root`` trees.
Comments written by the user in code sections are always output.
These directives control only:
a) the comments containing doc sections and
b) sentinel comments that delimit the beginning and end of code sections.

When ``@verbose`` is in effect ``Tangle`` outputs all comments.
When ``@terse`` is in effect, ``Tangle`` outputs only those comments necessary for ``Untangle`` to work.
When ``@silent`` is in effect Tangle adds no additional comments.
The ``@quiet`` directive is like @silent except that it does output leading sentinels as comments.
Like ``@silent``, ``@quiet`` inhibits untangling. 
``@verbose`` is the default.
If more than one of these directives appear in the same body text the "most verbose" of these options will be in effect.</t>
<t tx="ekr.20050829134901.27">By default, the ``body_pane_wraps`` setting controls whether body text wraps.
You may override this setting for a particular tree using the ``@wrap`` and ``@nowrap`` directives.
Only the first ``@wrap`` or ``@nowrap`` directive in a node has any effect.</t>
<t tx="ekr.20050829134901.28">In the following table all terms in each row are equivalent.
The spelling in the first column is preferred:

=========== =============== =================
\@asis      \@file-asis     \@silent
----------- --------------- -----------------
\@nosent    \@file-nosent   \@nosentinelsfile
----------- --------------- -----------------
\@noref     \@file-noref    \@rawfile
=========== =============== =================

You can get any combination of sentinels/no sentinels and references/no references using
``@file``, ``@nosent``, ``@noref`` and ``@asis`` trees:

+---------+------------+-------------------+
|         |            | Sections and      |
| Type    | Sentinels? | @others expanded? |
+---------+------------+-------------------+
| @asis   | no         | no                |
+---------+------------+-------------------+
| @file   | yes        | yes               |
+---------+------------+-------------------+
| @noref  | yes        | no                |
+---------+------------+-------------------+
| @nosent | no         | yes               |
+---------+------------+-------------------+

Leo can not update the outline from changes made from derived files unless those files contain sentinels.
The primary source for ``@nosent`` and ``@asis`` trees are the outlines from which those files were derived.</t>
<t tx="ekr.20050829134901.29">In most respects ``@thin`` works just like ``@file``.
In fact, you can convert from ``@file`` to ``@thin`` simply by opening an outline,
changing ``@file`` to ``@thin``, and saving the outline.

Here are the differences between ``@file`` and ``@thin``:

- Leo does not save the information contained in the ``@thin`` tree in the .leo file.  

- Files derived from ``@thin`` ("thin" derived files) contain all information needed to
  recreate the ``@thin`` tree in the outline.
  In particular, ``@+node`` and ``@-node`` sentinels use timestamps to uniquely identify nodes.

- The ``@all`` directive is valid only in ``@thin`` trees.

- Thin derived files are much more friendly to cvs than files derived from ``@file`` trees.
  Developers only need to commit thin derived files to cvs.

  The cvs repository contains **reference** .leo files.
  These reference files should containing nothing but ``@thin`` nodes.
  Reference files will change only when new derived files get added to the project.

  Developers will use local copies of reference files for their own work.
  For example, instead of using LeoPyRef.leo directly, I use a copy called ``LeoPy.leo``.
  My local copy can contain nodes other than ``@thin`` nodes.</t>
<t tx="ekr.20050829134901.30">Leo writes ``@nosent`` trees just as for ``@thin`` trees,
but Leo writes no sentinels at all.</t>
<t tx="ekr.20050829134901.31">The only difference between ``@asis`` and ``@noref`` trees is that files derived from
``@noref`` contain sentinels while files derived from ``@asis`` do not.

Leo creates files derived from ``@noref`` and ``@asis`` trees by
writing the body text of all nodes of the tree in outline order.
Leo writes the body text *as is*, without recognizing section definitions,
without expanding section references, and without treating directives specially in any way.
In particular, Leo copies all directives,
including ``@`` or ``@c`` directives, to the derived file as text.

Leo does recognize the ``@ignore`` directive in the *ancestors* of ``@noref`` or ``@asis`` nodes,
so you may use the ``@ignore`` directive as usual to prevent Leo from writing ``@noref`` or ``@asis`` trees.

**Notes**:

- When writing ``@noref`` trees,
  Leo writes only the ``@+leo``, ``@-leo``, ``@+node``, ``@-node``, ``@+body`` and ``@-body`` sentinels.

- Within ``@asis`` trees only, if a headline starts with ``@@``,
  Leo writes everything in the headline following the ``@@`` just before the corresponding body text.

- Files derived from ``@asis`` trees contain *nothing* not contained in body text (or ``@@`` headlines).
  In particular, if body text does not end in a newline,
  the first line from the next node will concatenated to the last line of the preceding node.</t>
<t tx="ekr.20050829134901.32">This section discusses all aspects of ``@root`` trees.
You should carefully consider whether the extra flexibility afforded by
``@root`` trees is worth the extra bother.
Indeed, ``@file`` trees are much easier to use than ``@root`` trees:

- ``@file`` trees use less markup than ``@root`` trees.
  In particular, the @others directive is valid only within ``@file`` trees.

- You must explicitly tangle and untangle ``@root`` trees using the ``Tangle`` and ``Untangle`` commands.

However, ``@root`` trees are more flexible than ``@file`` trees:

- Sections may be defined anywhere within ``@root`` trees.
  Moreover, the ``@unit`` directive expands the scope of section definitions in ``@root`` trees
  so that a section may be referenced in several ``@root`` trees.

- The meaning of section definitions in ``@root`` trees are independent of their position within the tree.</t>
<t tx="ekr.20050829134901.33">Just as with ``@file`` trees, ``@root`` trees may contain code parts and doc parts.
Code parts start with section definition lines (see below) or the ``@c`` directive.
Doc parts start with ``@`` directive.
Doc parts continue until the end of body text or until the next ``@c`` or ``@`` directive.

Body text in ``@root`` trees contain zero or more code and doc parts in any order.
The ``@c`` directive starts a named code section if the node's headline starts with::

    &lt;&lt; section name &gt;&gt;

Otherwise, the ``@c`` directive is invalid.

**Section definition lines** are lines of the form::

	&lt;&lt; section name &gt;&gt;=

(note the equal sign).
Such lines also start named code parts.
Named code parts in ``@root`` trees may be defined in several places.
The definition of a named code part is the concatenation of all code parts with the same name.
Body text that defines no code part is ignored.
At least one non-blank line must follow the section definition line;
empty sections are not allowed.

**Note for pdf version**:
due to a bug in docutils the phrase 'double-angle-bracket characters' below stands for::

    &lt;&lt; and &gt;&gt;

As in ``@file`` trees, paired double-angle-bracket characters on the same line always denote a section name,
even within comments are strings.
Thus,double-angle-bracket characters that do not delimit a section name must be placed on separate lines.
If double-angle-bracket are not paired on a line, they are treated as ordinary double-angle-bracket characters.

Here is a typical example of body text within an @root tree::

    @ This method puts an open node sentinel for node v.
    &lt;&lt;atFile methods&gt;&gt;=
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            &lt;&lt; issue an error message &gt;&gt;
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

Provided that the node's headline starts with::

    &lt;&lt; atFile methods &gt;&gt;

the example above is equivalent to::

    @ This method puts an open node sentinel for node v.
    @c
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            &lt;&lt; issue an error message &gt;&gt;
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

We may not eliminate @c directives in @root trees.
If we convert the doc part to a comment we are left with::

    @c
    # This method puts an open node sentinel for node v.
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            &lt;&lt; issue an error message &gt;&gt;
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)
    
The following escape convention applies only in ``@root`` trees.
Within a code parts ``@@`` in the first column (and only in the first column) stands for a single ``@`` sign.</t>
<t tx="ekr.20050829134901.34">Each ``@root`` tree represents a single derived file.
**Tangling** is the process of creating derived files from ``@file`` or ``@root`` trees.
Leo tangles ``@file`` trees automatically whenever an outline is saved.
The user must tangle ``@root`` trees explicitly using one of the ``Tangle`` commands.

Leo creates derived files by expanding all section references in an ``@root`` node.
Leo expands a section reference by substituting the code section itself for the section reference.
This is a recursive process:
the substituted code section may contain other code references which are themselves expanded, and so on.

It is unusual and bad style for the meaning of an ``@root`` tree to depend on the position of nodes within it.
The meaning of a section definition in an ``@root`` tree usually does not depend on is position,
and we may place sections wherever we want.
The outline provides a natural way of organizing an sections as follows::

	Place the definition of a section S in a child of
	the node containing the reference to S.

If a section is referenced in more than one node,
I usually place its definition in a node containing all the nodes that refer to it.
Using this rule of thumb creates an outline whose structure mirrors the intrinsic organization of a program.

The ``Tangle`` command creates derived files from ``@root`` node.
The ``@root`` directive indicates which sections constitute an output file.
The text following a @root directive forms the entire content of the file,
that is, after section references are expanded.
An outline can contain arbitrarily many ``@root`` directives:
Leo's ``Tangle`` commands will create one output file for each.
The process of creating derived files is called "tangling" because
the code from the outline is rearrange to create the derived files.

For example, the following ``@root`` section shows a typical way of specifying a header file ``xx.h``::

    @root xx.h
    #ifndef xx_defined
    #define xx_defined
    &lt;&lt; declarations of public constants of the xx class &gt;&gt;
    &lt;&lt; declarations of public types of the xx class &gt;&gt;
    &lt;&lt; declarations of public variables of the xx class &gt;&gt;
    &lt;&lt; public prototypes of the xx class &gt;&gt;
    #endif

The ``Tangle`` commands will create the file ``xx.h`` from this body text by expanding all the section references.
Incidentally, the introductory documentation will be included in the header file:
any text preceding the ``@root`` directive is treated just like the documentation part of an section definition.

As another example, the following shows a typical way of specifying the corresponding ``xx.c`` file::

    @root xx.c
    &lt;&lt; public variables of the xx class &gt;&gt;
    &lt;&lt; private types of the xx class &gt;&gt;
    &lt;&lt; private variables of the xx class &gt;&gt;
    &lt;&lt; private function prototypes of the xx class &gt;&gt;
    &lt;&lt; methods of the xx class &gt;&gt;

There are three menu commands that tangle an outline: ``Tangle``, ``Tangle All`` and ``Tangle Marked``.
These commands are identical except for how much of the outline is tangled.
The ``Tangle`` command tangles only the selected portion of the outline,
the ``Tangle All`` command tangles the entire outline,
and the ``Tangle Marked`` command tangles only marked headlines.

The ``@root`` directive has three forms.
All three forms mean exactly the same thing::

    @root filename
    @root "filename"
    @root &lt;filename&gt;

If *filename* is an absolute filename the location of the derived file is specified only by the filename.
Otherwise, if the ``@root`` node contains a relative filename, the location of the derived file is relative to:
	
1. the directory specified by an ``@path`` directive, or

2. the ``default_tangle_directory`` setting if no ``@path`` directive is in effect, or

3. the directory in which the .leo resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules,
or if the filename or directory does not exist.

The scope of a definition is the tree in which the definition is known.
By default, ``Tangle`` commands look for section definitions only
in the suboutline of the ``@root`` node being tangled.
That is, all sections are assumed to be defined either in the body text of the headline,
say h, containing the ``@root`` directive, or in the body texts of the descendants of h.
The ``@unit`` directive explicitly indicates the scope of section definitions.
When a ``Tangle`` command encounters the ``@unit`` directive it treats the suboutline containing
the ``@unit`` command as the scope for all enclosed roots.
This ensures that the group of roots in the subtree use the same section definitions.

For example, suppose we have a tree organized as follows::

	+ @unit
		+ @root A
		    sections in A
		+ @root B
		    sections in B
		
The ``@unit`` directive insures that
only sections defined in the unit can effect files A and B and
that all sections definitions in A and B are compatible with each other.

The ``Tangle`` commands ignore any tree containing an ``@ignore`` directive.
This ensures that trees that contain cloned nodes or other subsidiary information
do not cause the tangle commands to issue spurious error messages.
It also ensures that a tree can never contribute a section definition to another part of the outline by mistake.</t>
<t tx="ekr.20050829134901.35">The ``Untangle``, ``Untangle All`` and ``Untangle Marked`` commands are the
reverse of the corresponding ``Tangle`` commands.
They update one or more ``@root`` nodes based on changes made to the corresponding derived files.

For example, suppose you create a new part of the outline and tangle it for the first time.
When you compile derived files for the first you are likely to get many syntax errors.
You could fix those errors in the outline and tangle the outline again, but there is a much easier way:
you fix the errors in the derived files using the compiler's editor,
then run the untangle command on the part of the outline that created the derived file.
The ``Untangle`` command updates the selected outline to match the changes in the derived files.
It's as simple as that.
By the way, the ``Untangle`` command marks all the nodes in the outline that it updates,
and you can examine all such nodes with the ``Go To Next Marked`` command in the ``Outline`` menu.

You cannot use ``Untangle`` to update doc parts, or leading comments in code parts or
"trivial" whitespace in code parts.
This is a limitation of the ``Untangle`` command that cannot be fixed;
``Untangle`` has no way of knowing whether leading comments came from doc parts or are just leading comments.

``Untangle`` never changes the structure of an outline;
it never inserts, deletes or moves nodes.
Don't attempt to change the structure of an outline by modifying derived files; it won't work.
Also, never delete, move or alter the sentinel lines in derived files written by the ``Tangle`` command.
Such lines start with the comment delimiter followed by a section name.

If you change the section name in a sentinel line ``Untangle`` will not update the code in the outline
(with the old name) that generated the renamed section.
``Untangle`` warns about sections that appear in a derived file but not in the outline.
``Untangle`` has no trouble with changed section references in derived files;
it is only changed sentinel lines that cause problems.

Cloned nodes that generate code in several files may cause problems for ``Untangle``.
If ``Untangle`` is run separately on these derived files,
``Untangle`` will update all cloned nodes each time it is run,
so only the code in the last Untangle run will take effect.
Therefore, the safe way to update text in cloned nodes is to make the change in the .leo file rather than the derived files.</t>
<t tx="ekr.20050829134901.36">Cweb mode refers to how Leo tangles an outline when ``@language cweb`` is in effect or
the ``cweb`` setting is in effect.
Leo treats *all* cweb code in cweb mode as unevaluated text.
That is, Leo treats cweb control codes, including::

    @&lt;...@&gt;
    @&lt;..@&gt;=
    @c
    @
    @*
    @

as "raw" text within cweb mode.

Leo does *not* expand *cweb* section references when writing derived files in cweb mode.
However, Leo *does* expand *noweb* section references,
so you may use noweb sections to organize cweb files!
You can create *noweb* code and doc sections using the ``@code`` and ``@doc`` directives
in place of ``@c`` and ``@`` directives.

By default, cweb colors ``@``, ``@*`` and ``@**`` sections using the same syntax coloring as for ``LaTeX``.
In addition, cweb colors ``C`` ``//`` and ``/*..*/`` comments using ``LaTeX`` coloring by default.
You may change these defaults using the
``color_cweb_doc_parts_with_latex`` and ``color_cweb_comments_with_latex`` settings.</t>
<t tx="ekr.20050829134901.37">------------------

|back| |leo| |next|</t>
<t tx="ekr.20050829140911">Cweb mode refers to how Leo tangles an outline when ``@language cweb`` is in effect or
the ``cweb`` setting is in effect.
Leo treats *all* cweb code in cweb mode as unevaluated text.
That is, Leo treats cweb control codes, including:
``@&lt;...@&gt;``, ``@&lt;..@&gt;=``, ``@c``, ``@``, ``@*`` and ``@**`` as "raw" text within cweb mode.
Leo does *not* expand *cweb* section references when writing derived files in cweb mode.
However, Leo *does* expand *noweb* section references,
so you may use noweb sections to organize cweb files!
You can create *noweb* code and doc sections using the ``@code`` and ``@doc`` directives
in place of ``@c`` and ``@`` directives.

By default, cweb colors ``@``, ``@*`` and ``@**`` sections using the same syntax coloring as for ``LaTeX``.
In addition, cweb colors ``C`` ``//`` and ``/*..*/`` comments using ``LaTeX`` coloring by default.
You may change these defaults using the
``color_cweb_doc_parts_with_latex`` and ``color_cweb_comments_with_latex`` settings.</t>
<t tx="ekr.20050830074716">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|prev| |leo| |next|

###################################
What People Are Saying About Leo
###################################

.. contents::
</t>
<t tx="ekr.20050830074815.1">"I am using Leo since a few weeks and I brim over with enthusiasm for it.
I think it is the most amazing software since the invention of the spreadsheet."

"We who use Leo know that it is a breakthrough tool and a whole new way of writing code." -- Joe Orr

"I am a huge fan of Leo.
I think it's quite possibly the most revolutionary programming tool I have ever used and it (along with the Python language) has utterly changed my view of programming (indeed of writing) forever." -- Shakeeb Alireza

"Thank you very much for Leo.
I think my way of working with data will change forever...
I am certain [Leo] will be a revolution.
The revolution is as important as the change from sequential linear organization of a book into
a web-like hyperlinked pages.
The main concept that impress me is that the source listing isn't the main focus any more.
You focus on the non-linear, hierarchical, collapsible outline of the source code." -- Korakot Chaovavanich

"Leo is a quantum leap for me in terms of how many projects I can manage and
how much information I can find and organize and store in a useful way." -- Dan Winkler

"Wow, wow, and wow...I finally understand how to use clones and I realized that this is exactly how I want to organize my information.
Multiple views on my data, fully interlinkable just like my thoughts." -- Anon

"Edward... you've come up with perhaps the most powerful new concept
in code manipulation since VI and Emacs. -- David McNab

"Leo is...a revolutionary step in the right direction for programming." -- Brian Takita</t>
<t tx="ekr.20050830074815.2">"A few years back I would have said Zope was #1 Python showcase,
but I agree 100% that Leo is tops now." -- Jason Cunliffe

"Leo is the most interesting Python project I know of...I see lots of stuff posted on the Daily Python page, but I usually yawn and come over to this forum to see what's cooking." -- Anon

"Leo is the best Tkinter application ever written.
It convinces me that Tkinter can really *do something*, and do [it] well." - Anon

"What an original synthesis of different ideas,
why can't other Open Source projects change the way I think?" -- Anon</t>
<t tx="ekr.20050830074815.3">"When first I opened Leo, it was out of curiosity. But having used it...I'll never go back.  They'll have to pry Leo out of my cold, dead fingers!  Seriously, it should be renamed 'Crack Cocaine' because it's that addictive. I'm ready to start a 12-Step group." -- Travers A. Hough

"I feel addicted to programming again...in fact [Leo] has resurrected a dead project of mine :) The Outline has proven most liberating in terms of testing ideas out." -- Anon

"I have been absolutely seduced by Leo over the past few days. I tell you, I can not put it down. I feel like a kid with a shiny new bike...I'm already bursting with new ways I'd like to use the tool in the future." -- Lyn Adams Headley

Thanks for the great work--I love Leo!!! -- Josef Dalcolmo

Leo has simplified updating and creating new scripts and .bats keeping similar information in the same place. there is almost an addictive withdrawal effect when I can complete an operation in so much less time with Leo &amp; python than I had become used to. -- Anon</t>
<t tx="ekr.20050830074815.4">"[Leo] should either replace or greatly augment the development tools that I use." -- Zak Greant

"Leo is a marriage of outlining and literate programming. Pure genius. The main reason I am impressed with this tool is that it doesn't affect your choice of tools. You can use whatever IDE for whatever language and switch back and forth between Leo and it." -- Austin King

"Leo is the best IDE that I have had the pleasure to use. I have been using it now for about 2--3 months. It has totally changed not only the way that I program, but also the way that I store and organize all of the information that I need for the job that I do." -- Ian Mulvany

"I only have one week of Leo experience but I already know it will be my default IDE/project manager...people complain about the lack of a project manager for the free/standard Python IDE's like Idle. Leo clearly solves that problem and in a way that commercial tools can't touch." -- Marshall Parsons

"I have been using Leo for about 3 weeks and I hardly use my other programming editor anymore...I find it easy and enjoyable to use. I plan to adopt it as my presentation tool for code reviews." -- Jim Vickroy

"I'm absolutely astounded by the power of such a simple idea! It works great and I can immediately see the benefits of using Leo in place of the standard flat file editor." -- Tom Lee

I think you're really showing what open source can do and your current trajectory puts you on track to kick Emacs into the dustbin of computing history. -- Dan Winkler
</t>
<t tx="ekr.20050830074815.5">"Word outlines are very useful. But Leo makes Word look like a clunky toy."
--Joe Orr

"Leo is an interactive editor for organizing text fragments hierarchically and
sequentially into one or more files and hierarchical folders, without arbitrary
limits on the number and size of text fragments and the depth of the
hierarchy...Tangle is a tool for combining hierarchically and sequentially
organized text fragments into text files, hierarchically grouped into folders,
with hierarchical or sequential organization of text within the files, and
without arbitrary limits on the size and number of files and the depth of the
hierarchy of folders and text nesting within the files." -- Alex Abacus

"Leo reminds me a great deal of things I loved when I used Userland's Frontier
(an outlining cms with a native oodb) - but Frontier wasn't hackable enough for
me, and it wasn't oriented towards coding and literate programming, and you
couldn't round-trip rendered pages (big Leo win). This is really a super tool -
in a matter of days I've started to use it on all my projects and I still
haven't figured out how I lived without it." -- John Sequeira

"Leo is EXACTLY the kind of outliner I was looking for--fantastic job!"
-- Steve Allen

"If you are like me, you have a kind of knowledge base with infos gathered over
time. And you have projects, where you use some of those infos. Now, with
conventional outliners you begin to double these infos, because you want to have
the infos needed for the project with your project. With Leo you can do this
too, but if you change text in one place IT IS UPDATED IN THE OTHER PLACE TOO!
This is a feature I did not see with any other outliner (and I tried a few).
Amazing! Leo directly supports the way I work!" -- F. Geiger
</t>
<t tx="ekr.20050830074815.6">"Another day, another breakthrough using Leo--now I realize Leo is the best URL bookmark manager there is. No more bookmarks menus or favorites lists inside the browser for me. With the @url directive I can just double click on the URL to open it in my browser. Leo lets me arrange the URLs in a hierarchy (or multiple hierarchies), attach notes to them, save clippings of things I read on the sites. It's sooo much better than anything the browsers have built in and it lets me easily use different browsers on different platforms and different machines (try that with the browsers' built-in bookmark managers)." -- Dan Winkler

"I am an amateur photographer. I use plain old 35mm. film for my pictures. Over the weekend, I used Leo to organize my lists of pictures. It is quite helpful--I can have separate nodes for pictures I have enlarged, as well as pictures I have submitted to our local camera club. Thanks!" -- Rich Reis

"Cloning is pure genius!... Leo's cloning facility, allows me to create several views on the CFA course material. My main view follows the prescribed study guide. Another view is organized like the textbooks. Yet another gives me a glossary of terms. And when I'm done, I'll have some nice libraries...I can re-use later in other projects." -- Michael Manti</t>
<t tx="ekr.20050830074815.7">"I've tried Literate Programming tools off and on for more than 10 years, mainly because the promise was so great. I've abandoned them every time because working with the various Cweb-like tools was so awkward. Leo changes all that. The most important benefits promised by Literate Programming are realized by using Leo, without the awkwardness of the other tools." -- Dave Hein

"[Leo] has enabled me to use Literate Programming in production for the first time. When I figured out I could do it in plain text and export to DocBook for automated typesetting, I was on my way. Because I only do business and utility software, I don't need the sophistication of LaTeX markup. Writing the documentation and the code in the same outline at the same time improves the whole product. Being able to automatically export both with just two key presses (tangle and export-to-DocBook) is a real luxury." -- Michael Dawson

I wanted to thank you for the effort you've put into Leo.  It looks fantastic.  I've always though that Literate Programming was a good idea, but the tools were completely un-workable. -- Bob Hustead</t>
<t tx="ekr.20050830074815.8">"I've written documentation in WordPerfert, Ventura, Word, PageMaker, and FrameMaker and even though they create wonderfully looking and useful documents, they've never been able to do what I've been looking for. HTML, compiled help files, and later PDF came closer, but still not there...I think I've found it in LEO, a way to make a "living" document. A document built out of discrete parts that can be re-organized on the fly to meet the needs of a varying audience...I've already started converting the IT Procedures manual from Open Office to LEO because I know it's going to be much more useful to me and anyone else...just the possibility of keeping system maintenance scripts in the IT manual is mind boggling." -- David Nichols

"With the help of the rst2 plugin, [Leo is] the best outliner I have yet encountered for writing the early stages of academic papers."

"A Leo file is an ideal documentation tool, collecting the assorted readme.txt files, the comments from the source files...as well as the config files themselves." -- Kent Tenney</t>
<t tx="ekr.20050830074815.9">"Just as structured programming reveals and disciplines the flow control of a program, [Leo] allows the designer to reveal and discipline structure at many layers simultaneously: data structures, object structure, entity-relationship structure, client-server structure, design pattern structure, temporal structure, project management structure, and any other structure relevant to the system." -- Steven P. Schaefer

"A funny observation with Leo is that when I 'Leo-ise' other people's code, Leo makes the code's structure so transparent that design faults become very quickly apparent. For example, maintenance pain caused by lack of factorization." -- David McNab

"Leo is a powerful tool for organizing text into tree structures, and for just generally attacking a number of problems from a tree-based perspective." -- Joe Orr

"I found this blog entry by someone (a talented former coworker of mine actually) complaining about some poorly written code she had to maintain:
http://www.ceejbot.com/blog/space/2003-01-29#the_news_at_10
She said: 'You'd need a bulldozer to start refactoring it.' That was my cue to write a long message explaining that there is indeed such a bulldozer and it's called Leo. (You can see my message there as a reply to her original posting.) I gave her my recipe for how to get someone else's messy, scary code into Leo and how to break it down into manageable chunks." -- Dan Winkler

"Ed, you continue to push the envelope. The amazing thing is that the footprint isn't doubling every few months like it would be in another designer's hands. Adding features by removing constraints, hot refactoring while adding unit tests. Forget the book. I would pay to see the movie."</t>
<t tx="ekr.20050830074815.10">"I am extremely impressed at how stable and useful Leo appears to be." -- Marcus A. Martin

"Leo is amazingly stable. Docs are often weak with Open Source Software. Not so Leo: Leo is unusually well documented." -- F. Geiger

"Leo is unimaginably useful and I always find new things it already knows(!) how to do. Indeed I am amazed by the never-ending resources and patience Edward is putting into it and its users community. Excellent." -- Gil Shwartz

"I feel strongly that Ed Ream, our ever-patient, ever-productive Leo architect deserves a nomination [ for the ActiveState OpenSource Award] Among other reasons, for:

- Delivering the first usable visual literate programming tool.
- Adding a vast abundance of new features.
- Making possible a previously unimaginable amount of leverage in code editing.
- Eliminating vast amounts of menial programming labour.
- Tirelessly and patiently supporting users, and catering to a wide range of feature requests."  -- David McNab
</t>
<t tx="ekr.20050830074815.11"></t>
<t tx="ekr.20050830074815.12">September 3, 2002

Hello, my full name is David Speed Ream. I am known as Speed to friends and enemies alike, but I gladly answer to David or most any other handle. I am an unabashed and biased fan of Leo, the fact that it was written by my brother Edward only slightly coloring my already colored glasses. I have been testing and using Leo in software production for over 4 years. My company currently has over 50,000 lines of code in over 100 source files that are written using Leo.

My comments are from two points of view, the first being software project manager for a complicated, multi-module software product, and the second being as a production line coder. For me, Leo’s greatest and only real drawback is the learning curve. This learning curve can be shallow is if all that is required is that someone code using Leo. However, in our company we allocate 40 to 80 hours *on top* of the normal coding load for someone to come up to speed on Leo. The ROI (return on investment) is calculated by me to be on the order of 3 months. So if I hire a consultant for less than 3 months, I don’t teach him Leo, even though all source code in our company must reside in Leo files for the reasons I won’t go into now.

I consider that my coders are 15 to 30 percent more efficient in their daily operations than my competition’s people. This indefensible claim of mine is based on the changes in my productivity as Leo grew from a test document production tool to the primary production method for all our assembly, c and cpp source code.

Personally, I hate to deal with documentation when I write code, except:

1) When I am first sitting down to solve a new problem.
   Then the documentation becomes quite long-winded and pontificatory,
   as if I were the only one on earth smart enough to solve the problem - or
2) When I come back to code I or someone else has written and find the documentation insufficient to
   understand the code without study (seems to be most of the time).

So I do not require my engineers or myself to do a great job of documentation, nor do I use Leo for that purpose. Rather, it is Leo’s outlining and organizing ability, and Leo’s ability to create source files from within the outline that give me what I think is a tremendous competitive advantage. Each of my company’s products run on all versions of windows from Win 3.1 to XP. In our flagship software piece, there are ten main modules, and each module is maintained by one single Leo file. In the CODEC module, one Leo file named compress.leo organizes and creates seven .asm files, forty-four .c files, twenty .h files, two .def files, four .mak files, etc. etc. etc. This one file can be checked out from source code control and given to an engineer for the addition of a new feature.

In it are contained all the known issues for the CODEC, each issue arranged in its own clone section. One clone section groups together every routine, variable or type definition that must change between different versions of Windows. These sections could be from six different c source files, two assembly files, and eight .h files. Another clone section groups together those sections relating to memory problems, which change according to the memory configuration and TSR configuration (or lack thereof) on the target machine. Another clone section groups sections that fail (or don’t fail) if the routine in question was accidentally run during the dreaded ‘interrupt time’. Another clone section is a section containing clones, each of which is named after the major bug that was fixed when the engineer who fixed the bug grouped a bunch of routines, definitions, etc. together to fix the bug.

None of the above clone sections was ‘designed’ into the document. Just the opposite happens. When the codec was first written, there was just a single Leo file with a bunch of sections for each c routine or assembly module. As the product grew and was tested on various platforms, each failure of the module was organized into clones each time a failure was fixed. This is what I call “SELF DOCUMENTING CODE”. This has nothing to do with me sitting and documenting anything. Its just that the STRUCTURE of a bug fix (or product enhancement) lives on long after the coding is done, as long as no one is foolish enough to delete the cloned sections that ‘DOCUMENT’ what happened.

In actual practice, this organizational ‘history’ is so powerful that I can’t begin to describe it. A ‘REVERSE LEARNING CURVE’ happens when an engineer gets a Leo file that already has the ‘interrupt time sensitive’ routines grouped together by the last unfortunate soul who had to work on them. There may not be any more written documentation, but the knowledge contained in the structure can be breathtaking. It is certainly time saving. I find this particularly true in my own case. Often I’ll look at some code that seems totally unfamiliar and think ‘what idiot wrote this crap’. Then I’ll look at the version control comments and realize that I wrote the crap. Then for sure I know the documentation is non-existent, but the clones I used to develop it are still there, and they always serve to refresh my memory in an indescribable way.

Enough of this commentary, I just looked at the clock. Best wishes to anyone willing to try Leo for a week. I hope you will be glad you did.</t>
<t tx="ekr.20050830074815.13">The Word outlines are very useful. But Leo makes Word look like a clunky toy.

#1 Reason would probably be clone nodes. One node can point to another. Another
way of putting this is is that a leaf can be on more than one tree. For
example, suppose you have a list of recipes. You simultaneously put a single
recipe under multiple categories or even multiple hierarchies. You could put "3
bean enchilada" simultaneously under Recipes-Mexican and Food-Gas. Another
example would be, if you are a biologist trying to decide under which genus to
put a new species, you could put the species under two simultaneously. In
effect, you can build a 3-D tree. For a further illustration see
http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm

#2 Reason would probably be that Leo outlines can be embedded in external text
files. So, a Leo outline is more than an outline, it is a meta-structure that
can be added to another text without changing that text, but rather providing
an external road map to the text. Microsoft Word has a text (xml) version with a
commenting convention, so Leo can even be used to add outlines into Word docs,
altho it isn't set up to do that now. For example, see
http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm In this case, the upper
window of Leo is the meta-structure, and the bottom window is the file to which
the meta-structure is being applied, viewed one node at a time.

I may not have made #2 very clear, but it is actually a very useful feature. It
takes some getting used to before one sees all of the possibilities tho. One
way to think of it is that Leo allows you to throw external documents into your
outline, and yet the external document remains independent and can still be
edited separately.

Some other cool things about Leo which Word doesn't feature:
1. Pure xml output that is easy to transform into other formats (next
version of Word will have true XML format, but not as easy to work with).
One consequence of this is that Leo files can be transformed pretty easily
to web pages with their outlining capability intact.
2. Easy to add features since is programmed in Tk and open source. Maybe
your average user can't start hacking on it, but a surprising amount can be
tacked on by flipping through the Tk manual.
3. Free, opensource, multi-platform
4. Leo is scriptable with Python. It should be possible to build a Tickler
into Leo using Python scripting, for example.</t>
<t tx="ekr.20050830074815.14">First of all, kudos to you for the excellent progress you've been making with Leo.  I upgraded today after about three months of using and older version and I was thrilled to see all the great improvements that have happened so fast.  I especially love the ability to go to next clone.  I think you're really showing what open source can do and your current trajectory puts you on track to kick Emacs into the dustbin of computing history.

So today I copied all my data (personal information manager and project management stuff) out of my old outliner (ThoughtManager, which syncs with and runs on the Palm) and put it into Leo.  It took me hours to do it and then to rearrange it the way I really wanted it.  But having the ability to make clones and have different ways to view my data is, as you know, fabulous.  In my case, for personal information and project management things, I used the flexibility of clones to allow me to see my data in several different views: 1) by project, the logical hierarchical breakdown by topic, 2) by person, so whenever I'm talking to someone I can easily see all the pending items related to them which may be spread over multiple projects, 3) by priority, so I can see what needs to get done sooner and what can wait for later and, 4) a special case of priority called "Today" for the things I'm going to focus on in the coming hours.

Now here's why I don't miss the ability of my old outliner to synch the entire outline with the Palm.  It turns out the main thing I really want in the Palm is the top category "Today" so all I have to do is have Leo flatten that one heading into a text file (and it kindly remembers the name and directory of the file I used last time) and then I'm done because I've told the Palm Hotsync manager that that file should be sent to Palm memo pad every time I synch.  The Palm Hotsync manager does a nice job of sending a text file to the Palm memo pad and even breaks the file up into multiple memo records if it's too big to fit in just one.  So that gives me enough to be able to browse (or full text search) the small amount of data that I really want right inside my Palm (which is also my cell phone).  Quick and dirty but it works.

For times when I want my whole outline with me, Leo wins again because thanks to its cross platform nature I can take my whole outline with me on my Mac iBook, even though I usually edit it on a Windows PC (which is the only kind of machine my old outliner would run on).  Quite frankly, although my old outliner was able to shoehorn the whole thing into my palm/cellphone, it was a pain to access it on the small screen and slow processor.  Now when I anticipate I'll need the whole thing, for example when I'm going to a meeting, I can put it on my Mac iBook (under X and Fink for now until Python can do it native under Aqua) and have real, full access to it all.

I think now in addition to being great for programming Leo is also a great PIM.  Being able to flatten a strategically chosen portion of the outline into a known file name that the Palm synch manager has been told to send to the Palm on every synch does the trick for me.  I wonder if you would consider something like an @flatten directive so I can have that done automatically for me every time I save my outline?  For now it's up to me to flatten the node I want manually, although once I've done that the transfer to the Palm is automatic.

You're my hero!  Thank you so much.</t>
<t tx="ekr.20050830074815.15">Another day, another breakthrough using Leo -- now I realize Leo is the 
best URL bookmark manager there is.  No more bookmarks menus or 
favorites lists inside the browser for me.  With the @url directive I 
can just double click on the URL to open it in my browser.  Leo lets me 
arrange the URLs in a hierarchy (or multiple hierarchies), attach notes 
to them, save clippings of things I read on the sites.  It's sooo much 
better than anything the browsers have built in and it lets me easily 
use different browsers on different platforms and different machines 
(try that with the browsers' built-in bookmark managers).  

When using Leo as a project manager and personal information manager as 
I do I can heavily annotate every task and project with helpful and 
relevant URLs.  And since URLs can be of the ``file://`` form, they're not 
just for web pages or HTML documents;  I can link to any file on my disk 
of any type to be opened by any program.

Leo is a quantum leap for me in terms of how many projects I can manage 
and how much information I can find and organize and store in a useful 
way.  I'm a data-mining army of one now and the web is my playground. 
Every time I find a web page that has interesting links to others, 
those links get stored in my Leo outline too, right where I can find 
them and make practical use of them.  I can easily accept dozens of 
valuable links every day and integrate them into what I'm doing in a way 
that I'm confidant they won't get lost or forgotten.  Before I always 
used to get bogged down by the difficulty of managing bookmarks inside 
the browser.  But now I'm no longer the victim of information overload 
buried in the knowledge landslide of the Internet;  instead I'm the 
professional strip miner with the world's biggest bulldozer.  I eagerly 
plunge into mountains of data and emerge with all the valuable 
information nuggets neatly stored and organized.  And my storehouse of 
knowledge is a flexible thing where I can reorganize and prioritize and 
massage the data to my heart's content as I learn more about it and 
decide to use it in different ways for different purposes.  It's the 
difference between the pick axe and the steam shovel for me.
</t>
<t tx="ekr.20050830074815.16">This year my accountant is getting a beautiful printout generated by 
LaTeX and Leo.  I have a complicated tax situation this year, but I got 
it all laid out and organized in Leo.  Then I had each of the nodes that 
had something my accountant needs to see write the data out to a file in 
the form a LaTeX table.

Sometimes a row of a table would have a result that was calculated by 
adding up a list of numbers.  For that I used the modern day equivalent 
of an adding machine paper tape -- I stored a lisp s-expression in a Leo 
comment.  I like s-expressions for this because once I put the opening 
"(+" on one line and the closing ")" on another line, I can fill in 
additional numbers just by typing them and can even annotate them with 
comments.  So in the middle of generating a LaTeX file I might have 
something like this::

    @
    (+
    1165.26 1823.70 ; May 2002
    123.38 ; June 2002
    13.50 ; July 2002
    13.21 ; October 2002
    55.25 ; November 2002
    )
    @c

That's an annotated record of how I arrived at the number the accountant 
will actually see.  I can just paste it into any lisp or scheme 
interpreter and get the total.  Adding additional numbers is easy.

For next year, I think I might  take this a step further.  What I did 
this year is good for adding up numbers to get a total for one row of a 
LaTeX table.  But it turns out I'd also like some more processing done 
on those tables (which I had to do by hand this time) -- I'd like the 
rows sorted in reverse order by magnitude (so that the big numbers jump 
out at you from the start of the tables) and I'd like a total of all the 
rows in the table. So I think next year, instead of having an 
s-expression that computes the total of one row for me, I think I'll use 
s-expressions that generate whole tables, formatted for LaTex, from the 
underlying data.  So I'm thinking next year my s-expressions might look 
more like this::

    @
    (table "Widget Related Expenses"
        ("widget insurance" (+
                        1165.26 1823.70 ; May 2002
                        123.38 ; June 2002
                        13.50 ; July 2002
                        13.21 ; October 2002
                        55.25 ; November 2002
                      ))
         ("widget shipping" (+
                        472.15 651.94 ; May 2002
                        54 ; June 2002
                       ))
         ("widget cleaning" (+
                        165.26 183.70 ; May 2002
                        123.38 ; June 2002
                        13.50 ; July 2002
                        13.21 ; October 2002
                        55.25 ; November 2002
                       ))
    )
    @c

The job of that "table" function would be to return the LaTeX code 
needed to display a table with the category names and values, sorted 
descending by magnitude, with the total displayed.  It's sort of a poor 
man's way of doing a spreadsheet inside Leo and then making it look 
great using LaTeX.  The idea would be as I wanted to add more data, I'd 
add it to the s-expression and then reevaluate the whole thing by 
pasting it into a lisp interpreter and then copying the result back into 
the same Leo node for LaTeX to process.

-- Dan</t>
<t tx="ekr.20050830075229">.. Relative links...

.. _faq:            FAQ.html
.. _frontmatter:    frontMatter.html
.. _home:           front.html
.. _quotes:         testimonials.html
.. _toc:            leo_TOC.html

.. WARNING: image targets may not have upper case letters!

.. |leo|  image:: leo.gif
	:target: home_

.. |prev| image:: arrow_lt.gif
	:target: frontmatter_

.. |next| image:: arrow_rt.gif
    :target: faq_</t>
<t tx="ekr.20050830080545">--------------------

|prev| |leo| |next|</t>
<t tx="ekr.20050830115714">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

.. August 30, 2005

|back| |leo| |next|

####
FAQ
####

This is Leo's Frequently Asked Questions document.

.. contents::
</t>
<t tx="ekr.20050830115714.1"></t>
<t tx="ekr.20050830115714.2">First, read the tutorial_. This will be enough to get you started if you just
want to use Leo as an outliner_. If you intend to use Leo for programming, read
the `Quick start for programmers`_, then look at Leo's source code in the file ``LeoPy.leo``.
Spend 5 or 10 minutes browsing through the outline. Don't worry about details;
just look for the following common usage patterns:

-   The (Projects) tree shows how to use clones to represent tasks.

-   Study ``@file leoNodes.py``.
    It shows how to define more than one class in single file.

-   Most other files show how to use a single ``@others`` directive to define one class.

-   Most methods are defined using ``@others``, *not* section definition nodes.</t>
<t tx="ekr.20050830115714.4">.. _`Clones &amp; views`:   intro.html#clones-views

You will lose much of Leo's power if you don't use clones.
See `Clones &amp; views`_ for full details.</t>
<t tx="ekr.20050830115714.5">Use `@file`_ trees (including ``@thin`` trees) unless you are *sure* you must
have the extra flexibility of `@root`_ trees.
Indeed, `@file`_ trees are much easier to use than `@root`_ trees:

- `@file`_ trees use less markup than `@root`_ trees.
  In particular, the `@others directive`_ is valid only within `@file`_ trees.

- You must explicitly tangle_ and untangle_ `@root`_ trees using the `Tangle and Untangle`_ commands.

However, `@root`_ trees are more flexible than `@file`_ trees:

- Sections_ may be defined anywhere within `@root`_ trees.
  Moreover, the `@unit`_ directive_ expands the scope of section definitions in `@root`_ trees
  so that a section may be referenced in several `@root`_ trees.

- The meaning of section definitions in `@root`_ trees are independent of their position within the tree.</t>
<t tx="ekr.20050830115714.7">Use methods for any code that is used (called or referenced) more than once.

Sections_ are convenient in the following circumstances:

-   When you want to refer to snippets of code the can not be turned into methods.
    For example, many plugins start with the code like this::

    &lt;&lt; docstring &gt;&gt;
    &lt;&lt; imports &gt;&gt;
    &lt;&lt; version history &gt;&gt;
    &lt;&lt; globals &gt;&gt;

    None of these sections could be replaced by methods.

-   When you want to refer to a snippet of code that shares local variables with the enclosing code.
    This is surprisingly easy and safe to do, *provided* the section is used only in one place.
    `Section names`_ in such contexts can be clearer than method names.  For example::

    &lt;&lt; init ivars for writing &gt;&gt;

In short, I create sections when convenient,
and convert them to functions or methods if they need to be used in several places.</t>
<t tx="ekr.20050830115714.9">Internally, Leo represents all strings as unicode. Leo translates from a
particular encoding to Unicode_ when reading .leo files or `derived files`_. Leo
translates from Unicode_ to a particular encoding when writing `derived files`_. You
may see strange looking characters if your text editor is expecting a different
encoding. The encoding used in any `derived file`_ is shown in the ``#@+leo`` `sentinel line`_
like this::

    #@+leo-encoding=iso-8859-1.

**Exception**: the encoding is ``UTF-8`` if no ``-encoding=`` field exists.
You can also use the ``@encoding`` directive_ to set the encoding for individual `derived files`_.
If no ``@encoding`` directive_ is in effect,
Leo uses the following settings_ to translate to and from unicode:

default_derived_file_encoding
    The encoding used for derived files if no ``@encoding`` directive_ is in effect.
    This setting also controls the encoding of files created by the ``Tangle`` commands.
    The default is ``UTF-8`` (case not important).

new_leo_file_encoding
    The encoding specified in the following line of new .leo files::

        &lt;?xml version="1.0" encoding="UTF-8"&gt;

    The default is ``UTF-8`` (upper case for compatibility for old versions of Leo).
    **Important**: once a .leo file is created the ``&lt;?xml..."&gt;`` line can only be changed by hand.
    This may cause unicode errors the next time the .leo file is loaded,
    so you should change the ``&lt;?xml..."&gt;`` line by hand only when first creating a .leo file.
    
tk_encoding
    The encoding that Leo uses to communicate with Tk text widgets.
    You would typically use this setting only in an emergency.
    The section called::

        &lt;&lt; set app.tkEncoding &gt;&gt;

    in app.finishCreate sets this encoding as follows:
    
    a) using the ``tk_encoding`` setting if it exists,
    b) using ``locale.getpreferredencoding`` if it exists,
       or the equivalent code in pre-python 2.3 versions,
    c) using ``sys.getdefaultencoding``
    d) defaulting to ``"utf-8"``
    
    Neither b nor c are guaranteed to give a valid encoding in all systems,
    and Leo will ignore invalid encodings returned from b or c.
    Therefore, setting the ``tk_encoding`` setting may be needed.</t>
<t tx="ekr.20050830115714.10">The encoding used in the file being imported doesn't match the encoding in effect for Leo.
You have two options:

- Use the ``@encoding`` directive_ in an ancestor of the node_ selected when
  doing the ``Import`` command_ to specify the encoding of file to be imported.

- Set the ``tk_encoding`` setting_ (see the previous answer) to the encoding you normally use.</t>
<t tx="ekr.20050830115714.12">Using `@thin`_ trees can eliminate most problems with using Leo in cvs environments:

-   Developers should use `@thin`_ trees to create derived files in any kind of cooperative environment.

-   The cvs repository contains "reference" .leo files.
    These reference files should containing nothing but ``@thin`` nodes.
    Reference files will change only when new derived files get added to the project.

    **Important**:
    Leo's `cvs repository`_ contains the *reference* versions of the following .leo files:
    ``LeoPyRef.leo`` and ``LeoPluginsRef.leo``.
    However,  Leo's distributions contain the *non-reference* versions of those files:
    ``LeoPy.leo`` and ``LeoPlugins.leo``.
    These two files have many ``@thin`` nodes.
    There is no reference file for ``test.leo`` even though it contains ``@thin leoTest.py``.
    It would be clumsy to use testRef.leo, and there is less need to do so.
    
-   Developers will use local copies of reference files for their own work.
    For example, instead of using ``LeoPyRef.leo`` directly,
    I use a copy called ``LeoPy.leo``.
    My local copy can contain nodes other than ``@thin`` nodes.</t>
<t tx="ekr.20050830115714.13"></t>
<t tx="ekr.20050830115714.14">You have two options, depending on whether you want to be able to use sections
or not.

-   Use `@nosent`_ trees.
    Files derived from ``@nosent`` trees contain no sentinels_.
    However, Leo create the `derived file`_ just as in `@file`_ trees.
    In particular, Leo expands section references and understands the ``@others`` directive.

-   Use `@asis`_ trees.
    Files derived from ``@asis`` trees contain no sentinels_.
    Moreover, Leo does not expand section references in ``asis`` trees.
    In other words, Leo creates the `derived file` simply by writing all body text in outline order.
    Leo can't update the outline unless the derived file contains sentinels,
    so Leo does not update ``@nosent`` trees or ``@asis`` trees automatically when
    you change the derived file in an external editor.</t>
<t tx="ekr.20050830115714.16">You have two options, depending on whether you want sentinel lines in your
derived file or not.

-   Use `@noref`_ trees.
    Leo creates files derived from ``@noref`` trees by writing all the nodes of the
    tree to the derived file in outline order.
    The derived file *does* contain some sentinels,
    so you *can* update ``@noref`` trees from changes made to derived files.

-   Use `@asis`_ trees.
    Files derived from ``@asis`` trees contain no sentinels.
    Leo creates the derived file simply by writing all body text in outline order.
    Leo can't update the outline unless the derived file contains sentinels,
    so Leo does not update ``@asis`` trees automatically when you change the derived file in an external editor.</t>
<t tx="ekr.20050830115714.17">The import commands insert ``@ignore`` directives_ in the top-level node_.
Leo does this so that you won't accidentally overwrite your files after importing them.
Change the filename following ``@file`` or ``@root`` as desired,
then remove the ``@ignore`` directive_.
Saving the outline will then create the `derived file`_.</t>
<t tx="ekr.20050830115714.18">**Question**: I'm writing a Windows Script Component, which is an XML file with
a CData section containing javascript. I can get the XML as I want it by using
``@language html``, but how can I get the tangling comments inside the CData
section to be java-style comments rather than html ones?

**Answer**: In `@file`_ trees you use the ``@delims`` directive_ to change comment delimiters.
For example::

    @delims /* */ 
    Javascript stuff 
    @delims &lt;-- --&gt; 
    HTML stuff

**Important**: Leo can not revert to previous delimiters automatically;
you must change back to previous delimiters using another ``@delims`` directive_.

In `@root`_ trees you can work around this problem using the ``@silent`` directive_.</t>
<t tx="ekr.20050830115714.19">By Zvi Boshernitzan:
I was having trouble disabling ``&lt;?php`` with comments (and couldn't override the
comment character for the start of the page).
Finally, I found a solution that worked, using php's heredoc string syntax::

    @first &lt;?php
    @first $comment = &lt;&lt;&lt;EOD
    EOD;
    
    // php code goes here.
    echo "boogie";
    
    $comment2 = &lt;&lt;&lt;EOD
    @last EOD;
    @last ?&gt;

or::

    @first &lt;?php
    @first /*
    */
    
    echo "hi";
    
    @delims /* */
    @last ?&gt;</t>
<t tx="ekr.20050830115714.20">Here is a posting which might be helpful:
http://sourceforge.net/forum/message.php?msg_id=2300457 The ``@first``
directive_ is the key to output usable code in unsupported languages. For
example, to use Leo with the Basic language, use the following::

    @first $IFDEF LEOHEADER
    @delims '
    @c
    $ENDIF

So this would enable a basic compiler to "jump" over the "true" LEO-header-lines.
Like this::

    $IFDEF LEOHEADER &lt;-conditional compilation directive 
    #@+leo-ver=4 &lt;-these lines not compiled
    #@+node:@file QParser005.INC
    #@@first
    #@delims ' 
    '@@c
    $ENDIF &lt;-... Until here!
    &lt;rest of derived code file ... &gt;

This changes the comment symbol the apostrophe,
making comments parseable by a BASIC (or other language.)</t>
<t tx="ekr.20050830115714.21">Use the @first directive_ in `@file`_ trees or `@nosent`_ trees.
Use the @silent directive in `@root`_ trees.

The ``@first`` directive puts lines at the very start of files derived from ``@file``.
For example, the body text of ``@file spam.py`` might be::

    @first #! /usr/bin/env python

The body text of ``@file foo.perl`` might be::

    @first #/usr/bin/perl

Leo recognizes the ``@first`` directive_ only at the start of the body text of `@file`_ nodes.
No text may precede ``@first`` directives_.
More than one ``@first`` directive may exist, like this::

    @first #! /usr/bin/env python
    @first # more comments.</t>
<t tx="ekr.20050830115714.22">Leo has good support for `CWEB`_.
`@file`_ trees can organize any part of CWEB code using *noweb* sections.
You can also use `@asis`_, `@noref`_ or `@nosent`_ trees to create cweb files.
See `CWEB mode`_ for full details.
</t>
<t tx="ekr.20050830115714.24">No.  Everything in an `@file`_ trees must be part of the derived file: orphan and
``@ignore`` nodes are invalid in ``@file`` trees. This restriction should not be
troublesome. For example, you can organize your outline like this::

    + myClass
    ..+ ignored stuff
    ..+ @file myClass

(As usual, + denotes a headline.)
So you simply create a new node_, called myClass, that holds your `@file`_ trees and stuff you don't want in the `@file`_ trees.</t>
<t tx="ekr.20050830115714.25">By Rich Ries.
Some older C compilers don't understand the "//" comment symbol, so using ``@language C`` won't work.
Moreover, the following does not always work either::

    @comment /* */

This generates the following sentinel line::

    /*@@comment /* */*/"

in the output file, and not all C compilers allow nested comments, so the last ``*\/`` generates an error.
The solution is to use::

    #if 0
    @comment /* */
    #endif

Leo is happy: it recognizes the ``@comment`` directive_.
The C compiler is happy: the C preprocessor strips out the offending line before the C
compiler gets it.</t>
<t tx="ekr.20050830115714.26"></t>
<t tx="ekr.20050830115714.29">See the instructions are in ``LeoPy.leo`` in::

    ``Notes:How To:How to add support for a new language section.

This section contains clones of all relevant parts of Leo that you will change.
Coming in Leo 4.4: Leo will use ``JEdit``'s language description files to drive the syntax colorer.
To add support for a new language, just add another such description file.</t>
<t tx="ekr.20050830115714.30">You have two options: 
 
-   Get cvs write access, and add the `@thin`_ file to the plugins directory.

-   Just send the `@thin`_ file to me at edreamleo@charter.net.
    That's all you need to do.  In particular that there is no need to change ``leoPlugins.leo``.</t>
<t tx="ekr.20050830115714.74">The Import Files dialog allows you to select multiple files provided you are running Python 2.3 or above.
There is also an importFiles script in ``LeoPy.leo``.  You can use that script as follows::

    import leoImport
    leoImport.importFiles(aDirectory, ".py")

This will import all .py files from aDirectory, which should be a full path to a particular directory.
You could use ".c" to import all .c files, etc.</t>
<t tx="ekr.20050830115714.75">From: http://sourceforge.net/forum/message.php?msg_id=1685399

When building Tcl on Linux, do not specify "--enable-threads"
Only use Tcl with the default "threads not enabled" case.

Here is how to build Tk without thread support:

- Go to www.tcl.tk, and download the sources for Tcl and Tk.
- Build those two pack's as is told in the "How to Compile Tcl Source Releases"
- Go to www.python.org and download your favorite Python (2.3.5 for me).
- Build it as is told on the download page.
- Enjoy using Leo on Linux.
</t>
<t tx="ekr.20050830115714.76"></t>
<t tx="ekr.20050830115714.77">Just run Leo in a console window. At the point you want to drop into the
debugger, execute this line::

    g.pdb()

All output from pdb goes to stdout, which is the console window. It would be
good to create a subclass of pdb.Pdb that uses Leo's log pane rather than a
console window, but I haven't done that. It could be done easily enough in a
plugin...

**Important**: I recommend using g.trace instead of pdb.  For example::

    g.trace(x)

prints the name of the function or method containing the trace, and the value of
x. g.callers is often very useful in combination with g.trace. g.callers(5)
returns the last 5 entries of the call stack. For example::

    g.trace(x,g.callers(5))

Used this way, g.trace shows you patterns that will be invisible using pdb.</t>
<t tx="ekr.20050830115714.113">**Question**:
It would be nice if Leo could open empty files. I tend to be "document oriented"
rather than "application oriented" in my thinking and prefer "create empty file
at location -&gt; open it with program" to "start program -&gt; create new file -&gt;
save it at location".

**Answer** by Paul Paterson:
If you are on Windows 98/2000/XP then the procedure is as follows...

1. Start Leo
2. Click New
3. Click Save as...
4. Save the file as "c:\windows\shellnew\leofile.leo" (or c:\winnt for 2000/XP)
5. Open regedit "start...run...regedit"
6. Open HKEY_CLASSES_ROOT and find the ".leo" extension type
7. Go New ... Key from the context menu 
8. Call the new key ShellNew 
9. Select the new key, right-click, choose New...String Value from the context menu
10. Call it FileName 
11. Double-click on the string, and modify it to be the filename of the leofile.leo file you created,
    including the extension
12. Exit the registry editor and restart Windows Explorer (you may need to reboot on Windows 98)

Now you should have a New:Leo File option in Explorer. This creates a duplicate
of the file you saved. This can be useful because you could make a template Leo
file containing some standard nodes_ that you always have and then save this.</t>
<t tx="ekr.20050830115714.114">By Dave Hein: The cause of the keymapping problem is a issue with the X11
keyboard mapping, not with Tk. If you have this problem on your system, issue
the command::

    xmodmap -pke 

and look in the results for the line for keycode 22. I'll bet it shows something like::

    keycode 22 = BackSpace Terminate_Server

That second token ("Terminate_Server") is what is supposed to be mapped to
Shift-Backspace. You want this second token to be either not present or to be
BackSpace. To fix this, create a file (e.g. .Xmodmap) and give it the content::

    keycode 22 = BackSpace

then run the command::

    xmodmap .Xmodmap

This fixes the problem. On my system this also disables the ability to terminate
the X server using Ctrl-Alt-BackSpace. This is because of some conflict with xdb
(xdb is the newer keyboard mapping facility in XFree86; xmodmap is the old
original X11 keyboard mapping facility). I'm still working on that. I'm also not
able to get xmodmap to make this change during X11 startup (again because of
conflicts with xdb). But I'm working on that as well.</t>
<t tx="ekr.20050830115714.115">For the most part, docutils_ does a good job of reporting errors. docutils_ prints
a message to the console and inserts an unmistakable error message in the
generated .html file. **Important**: On Windows it is helpful to `Run Leo from a
console window`_.

However, in some cases, docutils_ crashes instead of properly reporting the
problem. There are several workarounds:

1.  The crashes I have seen arise from the following bug in docutils.
    **Hyperlinks in image:: markup must be lower case**.  This will work::

        .. |back| image:: arrow_lt.gif
            :target: faq_

    This will **crash**::

        .. |back| image:: arrow_lt.gif
            :target: FAQ_

    So avoid this crash by making sure to use lower case targets in ``:target:`` markup.

2.  You can change the docutils_ source slightly so that it prints a traceback when it
    crashes. (The rst3 plugin should be able to do this, but I haven't figured
    out how yet.) It's easy enough to do this:

    - Find the file ``core.py`` in top-level ``docutils`` folder.
      Typically this folder will be in Python's ``site-packages`` folder.

    - Open ``core.py`` in some editor other than Leo.

    - Find the method called ``report_Exceptions``.

    - Insert the following lines at the very start of this method::

        print 'EKR: added traceback'
        import traceback ; traceback.print_exc()

    This will cause a traceback whenever docutils_ crashes. I have found that
    such tracebacks are generally enough to locate the general area of the
    problem. **Note**: These tracebacks go to the console window, so you should
    `Run Leo from a console window`_.

3.  As a last resort, you can isolate syntax errors by reducing your input files
    until they work again, then adding sections until you get a crash. This is
    easy enough to do (when using the `rst3 plugin`_) by change a headline ``x`` to
    ``@rst-ignore-tree x``.</t>
<t tx="ekr.20050830115714.116">From: http://sourceforge.net/forum/message.php?msg_id=3240374
Using Leo's ``File-Export-Flatten Outline`` commands creates a ``MORE`` style outline which places
all Leo body sections on the left margin.
The headlines_ are indented with tabs which Excel will read as a tab delimited format.
Once inside Excel there are benefits.

1.  The most obvious benefit inside Excel is that the body sections (Excel first
    column) can be selected easily and highlighted with a different font color.
    This makes the ``MORE`` format very readable. Save a copy of your sheet as HTML
    and now you have a web page with the body sections highlighted.

2.  It is possible to hide columns in Excel.
    Hiding the first column leaves just the headlines showing.

3.  Formulas based on searching for a string can do calculations in Excel.
    For example if a heading ``"Current Assets"`` appears on level 4 then the body formula::

        =INDEX(A:A,MATCH("Current Assets",D:D,0)+1)

    will retrieve it.
    The +1 after match looks down one row below the matched headline.
    The trick is to place all your headlines in quotes because Excel will see ``+ "Current Assets"``
    from the ``MORE`` outline.
    When Excel tries without the quotes it thinks it is a range name and
    displays a ``#N/A`` error instead of the headline.
    Also you must place a child node_ below to get the + sign instead of a - sign which would give a
    ``MORE`` headline of  ``-"Current assets"`` , also is an error.

I think there is some interesting possibility here because of the enforcement of
Leo `body text`_ being always in the first column. The Leo outline provides
additional reference to organizing the problem not typical of spreadsheet
models. Beyond scripting in Python, Excel is good at doing interrelated
calculations and detecting problems like circular references. In Excel
Tools-Options-General is a setting for r1c1 format which then shows numbers
instead of letters for column references. Using this would allow entries like
this in the leo body::

    1000
    3500
    =R[-1]C+R[-2]C

In Excel you would see 4500 below those two numbers. This is completely
independent of where the block of three cells exists on the sheet.</t>
<t tx="ekr.20050830115714.117">Python's decorator_ syntax is ill-conceived.
This syntax file hack works well enough anyway to work with Leo ``@`` markup::

    syn region leoComment start="^@\s*" end="^@c\s*$"
    syn match   pythonDecorator	"@\S\S+" display nextgroup=pythonFunction skipwhite</t>
<t tx="ekr.20050830115714.118"></t>
<t tx="ekr.20050830115714.119">By Rich Ries.
I often rework C code that's already been "Leo-ized"--the first pass was quick
and dirty to get it going. When I do subsequent passes, I wind up with subnodes
that are out of order with the sequence found in the main node_. It's not a big
deal, but I like 'em ordered. With just one editor pane, clicking on the node_ to
move would switch focus to that node_. I'd then need to re-focus on the main
node_. A minor nuisance, but it does slow you down.

My solution is to open a second editor with its focus on the main node_. Switch
to the other editor, and, referring to the first editor pane, move the nodes as
you like. The second editor's pane will change focus to the node_ you're moving,
but the first editor will stay focused on the main node_. It's a lot easier to
do than to describe!
</t>
<t tx="ekr.20050830115714.120">One way is to link directly to the media file from a Leo node_ (with ``@url``)
and write a scriptbutton to wrap all URL-nodes under the current node_ in a
single HTML page (using the HTML browser trick at
http://sourceforge.net/forum/forum.php?thread_id=1201579&amp;forum_id=10226).

Then, you can view your media in two ways:

-   Individually. You can directly click on the ``@url`` link to display the media
    in the browser (assuming you have your MIME/filetype associations set up
    correctly for your browser).

-   In a group. You can click on a script button (you have to code this yourself,
    very simple) which should collect all ``@url`` nodes_ under the current node_
    and dynamically generate a HTML page displaying either links to or embedded
    versions of the media (using the HTML trick described above to invoke the
    browser). This way, you can create collections of ``@url`` nodes under a
    single node_ (like a bookmark folder), and press a single button to view the
    ``@url`` collection as a single entity in the browser (with all browser
    capabilities like displaying the media).
    
You could probably generalize this idea of "collect all ``@url`` nodes under current
node_ and display as HTML in browser" into a general-purpose plugin. However,
the plugin would have to be somewhat smart in mapping a link to its corresponding
HTML code (e.g. an image link gets mapped to an &lt;img&gt; HTML tag, a link to a
Flash file gets mapped to an &lt;embed&gt; tag, etc).</t>
<t tx="ekr.20050830120007">.. Links used in this document...

.. ----- External links.

.. _`cvs repository`:   http://sourceforge.net/cvs/?group_id=3458
.. _decorator:          http://www.python.org/peps/pep-0318.html
.. _docutils:           http://docutils.sourceforge.net/
.. _unicode:            http://www.unicode.org/

.. ----- Relative links into Leo's documentation.

.. _`Associating Leo with .leo Files`:  install.html#how-to-associate-leo-with-leo-files-on-windows

.. _`CWEB mode`:                    directives.html#cweb-mode
.. _command:                        commands.html
.. _commands:                       commands.html
.. _`quick start for programmers`:  intro.html#quick-start-for-programmers
.. _`rst3 plugin`:                  rstplugin3.html
.. _`Run Leo from a console window`: `How can I run Leo from a console window?`_
.. _`Tangle and Untangle`:          commands.html#tangling-an-outline-producing-derived-files
.. _tutorial:                       intro.html

.. ----- References to the glossary: the glossary now contains references to the tutorial.
.. _`@asis`:                glossary.html#asis-trees
.. _`@file`:                glossary.html#file-trees
.. _`@others directive`:    glossary.html#others
.. _`@noref`:               glossary.html#noref
.. _`@nosent`:              glossary.html#nosent
.. _`@root`:                glossary.html#root
.. _`@thin`:                glossary.html#thin-trees
.. _`@unit`:                glossary.html#unit
.. _`body text`:            glossary.html#body-text
.. _cweb:                   glossary.html#cweb
.. _directive:              glossary.html#directive
.. _directives:             glossary.html#directives
.. _`derived file`:         glossary.html#derived-file
.. _`derived files`:        glossary.html#derived-files
.. _headline:               glossary.html#headline
.. _headlines:              glossary.html#headlines
.. _node:                   glossary.html#node
.. _nodes:                  glossary.html#nodes
.. _outliner:               glossary.html#outliner
.. _sections:               glossary.html#sections
.. _`section names`:        glossary.html#section-names
.. _sentinels:              glossary.html#sentinels
.. _`sentinel line`:        glossary.html#sentinel
.. _`sentinel lines`:       glossary.html#sentinel
.. _setting:                glossary.html#setting
.. _settings:               glossary.html#settings
.. _tangle:                 glossary.html#tangle
.. _untangle:               glossary.html#untangle

.. WARNING: image targets may not have upper case letters!

.. _quotes:     testimonials.html
.. _home:       front.html
.. _install:    install.html

.. |back| image:: arrow_lt.gif
	:target: quotes_

.. |leo|  image:: leo.gif
	:target: home_

.. |next| image:: arrow_rt.gif
    :target: install_</t>
<t tx="ekr.20050830120844">``c.frame.menu.createMenuItemsFromTable`` will append items to the end of an existing menu.
For example, the following script will add a new item at the end of the 'File' menu::

    def callback(*args,**keys):
        g.trace()
    
    table = (("Test1",None,callback),)
    
    c.frame.menu.createMenuItemsFromTable('File',table)

Plugins can do anything that can be done with ``Tk`` using the menu returned by ``c.frame.menu.getMenu``.
For example, here is a script that adds a Test menu item after the 'Open With' menu item in the File menu::

    def callback(*args,**keys):
        g.trace()
    
    fileMenu = c.frame.menu.getMenu('File')

    # 3 is the position in the menu.  Other kinds of indices are possible.
    fileMenu.insert(3,'command',label='Test2',command=callback)</t>
<t tx="ekr.20050830120857">The trick is to create a workflow that separates editing from testing. Putting
test code in ``LeoPy.leo`` would waste a lot of time. To run tests you would
have to exit Leo and reload ``LeoPy.leo``. A much quicker way is to put all test
code in a ``test.leo`` file. So to change and test code, do the following:

1. Save ``LeoPy.leo`` but do **not** exit Leo. 

2. Quit the copy of Leo running test.leo, then reload test.leo.

3. Run test scripts from test.leo.

That's all. Python will recompile any changed .py files in the new copy of Leo.
**Note**: I create a batch file called t.bat that runs test.leo, so to the
"edit-reload-test" cycle is just:

1. Control-S (in ``LeoPy.leo``: saves the .leo file)
2. t         (in a console window: runs test.leo, compiling all changed .py files as a side effect)
3. Control-E (in test.leo: runs the test script)

The benefits of the new workflow:

- test.leo loads  _much_ more quickly than ``LeoPy.leo`` does.
  This new approach can increase the speed of the edit-reload-test cycle by more than a factor of 10.
  Hitting Control-S, t, Control-E takes about 5 seconds.

- ``LeoPy.leo`` runs with the *old* code,
  so it is much easier to fix syntax errors or exceptions in the *new* code:
  just fix the problem and save ``LeoPy.leo`` *without* closing ``LeoPy.leo``,
  then restart test.leo.
  You run your tests on the new code, but you edit the new code with the old, stable code.

- test.leo is the perfect place to develop test.
  I can create and organize those tests and when I am done, ''test.leo'' is a log of my work.</t>
<t tx="ekr.20050831184021.1"></t>
<t tx="ekr.20050831184021.2"></t>
<t tx="ekr.20050831184021.3"></t>
<t tx="ekr.20050831184021.4"></t>
<t tx="ekr.20050831184021.5"></t>
<t tx="ekr.20050831195331.1"></t>
<t tx="ekr.20050831195331.2"></t>
<t tx="ekr.20050831195331.3"></t>
<t tx="ekr.20050831195331.4"></t>
<t tx="ekr.20050831195449">@nocolor

For instruction about installing Leo see:
http://webpages.charter.net/edreamleo/install.html

For everything a beginner needs to know about Leo see:
http://webpages.charter.net/edreamleo/intro.html

For help installing or using Leo please ask questions at:
http://sourceforge.net/forum/?group_id=3458</t>
<t tx="ekr.20050831231852">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

.. August 30, 2005

|back| |leo| |next|

############
Appendices
############

.. contents::
</t>
<t tx="ekr.20050831232205">.. Relative links.

.. _`Chapter 8: Customizing Leo`:   customizing.html

.. WARNING: image targets may not have upper case letters!

.. |back| image:: arrow_lt.gif
	:target: plugins.html

.. |next| image:: arrow_rt.gif
	:target: glossary.html

.. |leo|   image:: leo.gif
	:target: front.html</t>
<t tx="ekr.20050901054622">c.save()</t>
<t tx="ekr.20050901055150">@color
# Script to promote headlines and body text

root = p.copy()
body = [root.bodyString()+'\n']
for p in root.subtree_iter():
    body.append(p.headString())
    body.append(p.bodyString().rstrip()+'\n')

body = '\n'.join(body)
root.setBodyString(body)
</t>
<t tx="ekr.20050901060119">@color

# Converts text selection to def list.

@others

createDefList(c,p)</t>
<t tx="ekr.20050901061220">def createDefList(c,p):
    
    undoType = 'Create Def List'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not lines: return
    
    result = ['``%s``\n' % lines[0].strip()]
    
    for line in lines[1:]:
        result.append('    %s' % line.lstrip()+'\n')
    lines = ''.join(result).rstrip()

    c.updateBodyPane(head,lines,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20050901071041">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

.. August 30, 2005

|prev| |leo| |next|

############
Glossary
############
</t>
<t tx="ekr.20050901071300">.. Links used in this document.

.. ----- External links.

.. _`CWEB language`:                http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`literate programming web page`:    http://www.literateprogramming.com/
.. _`noweb language`:                   http://www.eecs.harvard.edu/~nr/noweb/
.. _`rST primer`:                       http://docutils.sourceforge.net/docs/user/rst/quickstart.html

.. ----- Relative links.

.. _`Chapter 8: Customizing Leo`:   customizing.html
.. _`Writing plugins and hooks`:    customizing.html#writing-plugins-and-hooks

.. _`programming reference`:    directives.html
.. _`@asis`:                    directives.html#asis-and-noref
.. _`@file`:                    directives.html#file-and-thin
.. _`@noref`:                   directives.html#asis-and-noref
.. _`@nosent`:                  directives.html#nosent
.. _`@root`:                    directives.html#root
.. _`@thin`:                    directives.html#file-and-thin
.. _`@unit documentation`:      directives.html#root
.. _`tangling @root trees`:     directives.html#tangling-root-trees-with-the-tangle-commands
.. _`untangling @root trees`:   directives.html#untangling-root-trees-with-the-untangle-commands

.. ----- References to the tutorial.
.. _`clones &amp; views`:               intro.html#clones-views
.. _`leo's tutorial`:               intro.html
.. _`derived files section`:        intro.html#derived-files
.. _`directives for programming`:   intro.html#directives-for-programming
.. _`leo directives`:               intro.html#leo-directives
.. _`quick start for programmers`:  intro.html#quick-start-for-programmers
.. _`sentinels lines`:              intro.html#sentinel-lines

.. WARNING: image targets may not have upper case letters!

.. _appendices: appendices.html
.. _home:       front.html

.. |prev| image:: arrow_lt.gif
	:target: appendices_

.. |leo|  image:: leo.gif
	:target: home_

.. |next| image:: Blank.gif</t>
<t tx="ekr.20050901071613">----------------------

|back| |leo| |next|</t>
<t tx="ekr.20050901073048">**Important**: We often refer to outline_ nodes_ by the directives_ they contain.
For example, an `@root node`_ is a node containing an @root directive_, etc.
**Exception**: An `@file node`_ is a node whose *headline* starts with ``@file``.

.. _`@file node`:
.. _`@thin node`:
.. _`@root node`:
.. _`@file nodes`:
.. _`@thin nodes`:
.. _`@root nodes`:

``@file node``
    An ``@file`` node_ is a node whose *headline* starts with ``@file``.
    **Important**: Headlines_ that start with ``@file-asis``, ``@file-noref``, ``@file-nosent``
    (and their abbreviations ``@asis``, ``@noref``, ``@nosent``) are collectively called ``@file`` nodes.

.. _`@file tree`:
.. _`@thin tree`:
.. _`@root tree`:
.. _`@file trees`:
.. _`@thin trees`:
.. _`@root trees`:

``@file tree, @others tree, @root tree, etc.``
    An @file tree_ is a tree whose root_ is an @file node, etc.

``@asis, @file, @noref, @nosent, @thin``
    Headlines_ that start with one of these create (correspond to) `derived files`_.
    The following synonyms exist::

        @asis, @file-asis
        @noref, @file-noref
        @nosent, @file-nosent

    For more information, see the documentation for `@asis`_, `@file`_, `@noref`_, `@nosent`_ and `@thin`_
    in Leo's `programming reference`_ chapter.

.. _`@all`:
.. _`@all directive`:

``@all``
    A directive_ that copies the `body text`_ of all nodes_ in an `@thin` tree to the corresponding `derived file`_.
    For more information, see `directives for programming`_ in `Leo's tutorial`_.

.. _`@others`:
.. _`@others directive`:

``@others``
    A directive_ that copies the `body text`_ of all nodes_ *except* `section definition nodes`_
    in an `@thin` tree to the corresponding `derived file`_.
    For more information, see `directives for programming`_ in `Leo's tutorial`_.

.. _`@unit`:
.. _`@unit directive`:

``@unit``
    A directive_ that expands the scope_ of definitions in `@root` trees.
    For more information, see the `@unit documentation` in Leo's `programming reference`_.

.. _`body pane`:

``Body pane``
    The pane containing the `body text`_ of the currently selected headline_ in the `outline pane`_.

.. _`body text`:

``Body text``
    The text in the `body pane`_.  Body text is always associated with a particular node_.

.. _`body text box`:

``Body text box``
    A small blue box in the `icon box`_ indicating that the node_ contains `body text`_.

.. _`child`:
.. _`children`:

``Child``
    A node_ directly contained by a node.

.. _`chunk`:
.. _`chunks`:

``Chunk``
    A section_ (noweb_ terminology).

.. _`clone`:
.. _`clones`:
.. _`cloned`:

``Clone``
    A copy of a tree_ that changes whenever the original changes.
    The original and all clones are treated equally:
    no special status is given to the "original" node_.

.. _`clone arrow`:
.. _`clone arrows`:

``Clone Arrow``
    A small red arrow in the `icon box`_ indicating that the node_ is a clone_.

.. _`code part`:
.. _`code parts`:

``Code part``
    A part of a `section definition`_ that contains code. 
    Code parts start with ``@c`` or ``@code`` directives_ and continue until the next `doc part`_

.. _contract:
.. _contracts:
.. _contracted:

``Contract``:
    To hide all descendants_ of a node_.

.. _`cweb`:

``CWEB``
    A `literate programming`_ language invented by Donald Knuth and Silvio Levy.
    The `CWEB language`_ produces derived files for the C language.

.. _`demote`:

``Demote``
    To move all siblings_ that follow a node_ so that they become children_ of the node.

.. _`derived file`:
.. _`derived files`:

``Derived file``
    The file created as the result of tangling_ a node containing an ``@root`` directive_.
    The file consists of the expansion of the text following the ``@root`` directive_.
    For more information, see the `derived files section`_ of `Leo's tutorial`_.

.. _`descendant`:
.. _`descendants`:

``Descendant``
    An offspring_ of a node_.  That is, a child_, grandchild_, etc. of a node.

.. _`directive`:
.. _`directives`:

``Directive``
    A keyword, preceded by an '@' sign, in `body text`_ that controls Leo's operation.
    The keyword is empty for the ``@`` directive.
    For more information, set the `Leo directives`_ section of `Leo's tutorial`_.

.. _`doc part`:
.. _`doc parts`:

``Doc part, @doc part, document part, etc.``
    A part_ of a `section definition`_ that contains comments.
    Doc parts start with ``@`` and continue until the ``@c`` directive_ or the end of the `body text`_.
    In `@root trees`_, doc parts are associated with the immediately following `code part`_, if any.

.. _`escape convention`:
.. _`escape conventions`:

``Escape convention``
    A convention for representing sequences of characters that would otherwise have special meaning.
    Leo has only one such convention:
    in `@root trees`_, ``@@`` in the leftmost column of a `code part`_ stands for a single ``@`` character.
    **Important**:
    Leo does not support `noweb's`_ ``@&lt;&lt;`` and ``@&gt;&gt;`` escape conventions.
    Any line containing matched ``&lt;&lt;`` and ``&gt;&gt;`` is a `section reference`_, regardless of context.
    To use ``&lt;&lt;`` and ``&gt;&gt;`` as ordinary characters, place them on separate lines.

.. _expand:
.. _expands:
.. _expanded:

``expand``
    To make the children_ of a node_ visible.

.. _`grandchild`:
.. _`grandchildren`:

``Grandchild``
    The child_ of a child of a node_.

.. _`headline`:
.. _`headlines`:
.. _`headline text`:

``Headline``
    The headline text of a node_.  The part of the node visible in the `outline pane`_

.. _`hoist`:
.. _`hoisted`:
.. _`dehoist`:

``Hoist &amp; dehoist``
    Hoisting a node_ redraws the screen that node and its descendants_ becomes the only visible part of the outline_.
    Leo prevents the you from moving nodes outside the hoisted outline.  Dehoisting a node restores the outline.
    Multiple hoists may be in effect: each dehoist undoes the effect of the immediately preceding hoist.

.. _`icon box`:
.. _`icon boxes`:

.. _`LaTex`:

``LaTex``
    A markup language often used in `literate programming` environments.
    See: http://www.latex-project.org/

``Icon box``
    An icon just to the left of `headline text`_ of a node_ indicating whether the node is cloned, marked or dirty,
    and indicating whether the node contains `body text`_.

.. _`Leo1`:
.. _`Leo2`:

``Leo1 and Leo2``
    **Leo1** denotes all versions of Leo that write version 1 .leo files, that is,
    all Windows version of Leo prior to version 2.0.
    The last version of Leo1, version 1.15, understands enough about Leo2 to issue a warning when opening version 2 files.
    
    **Leo2** denotes all versions of Leo that write version 2 .leo files, that is,
    all versions of leo.py and all Windows versions with version number 2.0 and above.
    Only Leo2 can generate `derived files`_ from `@file trees`_.

.. _`literate programming`:

``Literate programming``
    A style of programming that aims at producing the highest quality program listings.
    Literate programming languages apply two fundamental operations to text: weaving_ and tangling_.
    Leo supports two literate programming languages, `CWEB`_ and `noweb`_.
    For more links see the `literate programming web page`_.

.. _`mark`:
.. _`marks`:

``Mark``
    A red vertical line in the `icon box`_ of a node_.

.. _node:
.. _nodes:

``Node``
    The organizational unit of an outline_. The combination of `headline text`_ and `body text`_.
    Sometimes used as a synonym for tree_.

.. _`noweb`:
.. _`noweb's`:

``noweb``
    A literate programming language invented by Norman Ramsey.
    The `noweb language`_ can produce `derived files`_ for any text-based programming language.

.. _`offspring`:

``Offspring``
    The children_, grandchildren_, etc. of a node_.

.. _`organizing node`:
.. _`organizing nodes`:
.. _`organizer node`:
.. _`organizer nodes`:

``Organizing node``, ``organizer node``
    A node_ containing no `body text`_.
    Organizing nodes may appear anywhere in an `@file tree`_; they do not affect the derived file in any way.
    In particular, organizing nodes do not affect indentation in `derived files`_.

.. _`orphan`:
.. _`orphan node`:
.. _`orphan nodes`:

``Orphan node``
    A node_ that would not be copied to a `derived file`_.
    Orphan nodes can arise because an `@thin tree`_ has no ``@others`` or ``@all`` directives_.
    Sections_ that are defined but not used also create orphan nodes.

    Leo issues a warning when attempting to write an `@thin tree`_ containing orphan nodes,
    and does not save the `derived file`_.
    No information is lost; Leo saves the information in the `@thin tree`_ in the .leo file.
    Leo will load the `@thin tree`_ from the .leo file the next time Leo opens the .leo file.

.. _`outline`:
.. _`outliner`:
.. _`outlines`:

``Outline``
    - A node_ and its descendants_.
    - A tree_
    - All the nodes_ of a .leo file.

.. _`outline order`:

``Outline Order``
    The order that nodes_ appear on the screen when all nodes_ are expanded.

.. _`outline pane`:

``Outline pane``
    The pane containing a visual representation of the entire outline_, or a part of the outline_ if the outline is hoisted_.

.. _parent:
.. _parents:

``Parent``
    The node_ that directly contains a node.

.. _`part`:
.. _`parts`:

``Part``
    A synonym for section_.  See also `code part`_ and `doc part`_.

.. _`pdf file`:
.. _`.pdf file`:

``pdf file``
    A file that can be read by Adobe Acrobat.

.. _`plugin`:
.. _`plugins`:

``Plugin``
    - A Python file in Leo's ``plugins`` folder.
    - A way to modify and extend Leo without changing Leo's core code.
      ``leoPlugins.leo`` contains all of Leo's official plugins.

    See `Writing plugins and hooks`.

.. _`promote`:

``Promote``
    To move all children_ of a node_ in an outline so that they become siblings_ of the node.

.. _reStructuredText:
.. _rST:

``reStructuredText (rST)``
    A simple, yet powerful markup language for creating .html, or LaTeX output files.
    See the `rST primer`_.

.. _`root`:
.. _`root node`:

``Root``
    - The first node_ of a .leo file.
    - The first node of an `@root`_ tree or `@file`_ tree.

.. _`rst3 plugin`:

``rST plugin``
    A plugin_ that supports reStructuredText_.
    Unlike previous rst plugins, the rst3 plugin supports per-node options.

.. _`scope`:

``Scope``
    The portion of the outline_ in which a `section definition`_ is known.

.. _`section`:
.. _`sections`:

``Section``
    A fragment of text that can be incorporated into `derived files`_.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section definition`:
.. _`section definitions`:

``Section definition``:
    The `body text`_ of a `section definition node`_.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section definition node`:
.. _`section definition nodes`:

``Section definition node``
    A node_ whose headline_ starts with a `section name`_ and whose body text defines a section_.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section name`:
.. _`section names`:

``Section name``
    A name enclosed in ``&lt;&lt;`` and ``&gt;&gt;``.
    Section names may contain any characters except newlines and "&gt;&gt;".
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section reference`:
.. _`section references`:
.. _`reference`:
.. _`references`:
.. _`referenced`:

``Section reference``
    A `section name`_ appearing in a `code part`_.
    Tangling_ replaces all references by their definitions.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`sentinel`:
.. _`sentinels`:
.. _`sentinel lines`:

``Sentinels, sentinel lines``
    Comment lines in files derived from `@file nodes`_.
    Such lines start with an ``@`` following the opening comment delimiter.
    Sentinels embed outline structure into `derived files`_.
    **Do not alter sentinel lines**.  Doing so can corrupt the outline structure.
    For more information see `Sentinel lines`_ in `Leo's tutorial`_.

.. _`@settings`:
.. _`setting`:
.. _`settings`:

``Setting``:
    Plugins_ and other parts of Leo can get options from ``@settings`` trees,
    outlines_ whose headline_ is ``@settings``. When opening a .leo file, Leo looks
    for ``@settings`` trees in the outline being opened and also in various
    ``leoSettings.leo files``. ``@settings`` trees allow plugins_ to get options without
    any further support from Leo's core code. For a full discussion plugins and
    @settings trees, see `Chapter 8: Customizing Leo`_.

.. _`sibling`:
.. _`siblings`:

``Sibling``
    Two nodes_ are siblings if they have the same parent_.  Siblings of the root_ have no parent.

.. _`tangle`:
.. _`tangles`:
.. _`tangling`:

``Tangling``
    The process of creating `derived files`_ from `@root trees`_ or `@file trees`_.
    Leo tangles `@file trees`_ automatically when writing a .leo file.
    You must explicitly tangle_ `@root trees`_ using the ``Tangle`` command.
    Tangling expands all `section references` in an `@root node`_ or `@file node`_.
    For more information, see `Tangling @root trees`_ in Leo's `programming reference`_.

.. _`target language`:

``Target language``
    The language used to syntax color text.
    This determines the default comment delimiters used during tangling_ and untangling_.

.. _`tree`:
.. _`trees`:

``Tree``
    An outline_.
    A node_ and its descendants_.

.. _`untangle`:
.. _`untangles`:
.. _`untangling`:

``Untangling``
    Updating an outline_ based on changes to `derived files`_.
    Untangling allows changes to be propagated from derived files back to the outline.
    Especially useful when fixing syntax errors outside Leo.
    For more information, see `Untangling @root trees`_ in Leo's `programming reference`_.

.. _`weave`:
.. _`weaves`:
.. _`weaving`:

.. _`view node`:
.. _`view nodes`:

``View node``
    A `node`_ that represents a view of an `outline`_.
    View nodes are typically ordinary, non-`cloned`_ nodes that contain cloned `descendant`_ nodes.
    The cloned descendant nodes comprise most of the data of the view.
    Other non-cloned nodes may add additional information to the view.
    See `clones &amp; views`_ in the `Leo's tutorial`_ for more information.

``Weaving``
    The process of creating typeset documentation from a noweb_ or CWEB_ source file.
    Weaving creates documentation. Tangling_ creates `derived files`_.
    Leo does not support weaving directly.
    To weave a file you can create noweb_ or CWEB_ files using Leo's ``Export`` commands,
    then use the noweb_ or CWEB_ systems to weave those files.</t>
<t tx="ekr.20050901083017">-----------------------

|prev| |leo| |next|</t>
<t tx="ekr.20050901084134"></t>
<t tx="ekr.20050901092232">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

.. August 30, 2005

|back| |leo| |next|

##########################
Chapter 11: White Papers
##########################

The following are some papers I wrote just after discovering Python.
The conclusions in these papers have remained largely unchanged.

.. contents::
</t>
<t tx="ekr.20050901092232.1">.. External links...

.. _pychecker:      http://pychecker.sourceforge.net/

.. Relative links...

.. _chapter10:      theory.html
.. _appendices:     appendices.html

.. WARNING: image targets may not have upper case letters!

.. _back:   theory.html
.. _home:   front.html
.. _next:   plugins.html

.. |back| image:: arrow_lt.gif
    :target: back_

.. |leo|  image:: leo.gif
    :target: home_

.. |next| image:: arrow_rt.gif
    :target: next_
</t>
<t tx="ekr.20050901092232.2">What struck me first as I converted C++ code to Python is how much less blah,
blah, blah there is in Python. No braces, no stupid semicolons and most
importantly, *no declarations*. No more pointless distinctions between
``const``, ``char *``, ``char const *``, ``char *`` and ``wxString``.
No more wondering whether a variable should be ``signed``, ``unsigned``, ``short`` or ``long``.

Declarations add clutter, declarations are never obviously right and
declarations don't prevent memory allocation tragedies. Declarations also hinder
prototyping. In C++, if I change the type of something I must change all related
declarations; this can be a huge and dangerous task. With Python, I can change
the type of an object without changing the code at all! It's no accident that
Leo's new log pane was created first in Python.

Functions returning tuples are a "minor" feature with a huge impact on code
clarity. No more passing pointers to data, no more defining (and allocating and
deallocating) temporary structs to hold multiple values.

Python can't check declarations because there aren't any. However, there is a
really nifty tool called Pychecker that does many of the checks typically done
by compilers. See `pychecker`_ for details.</t>
<t tx="ekr.20050901092232.3">Python is much more powerful than C++, not because Python has more features, but
because Python needs *less* features. Some examples:

-   Python does everything that the C++ Standard Template Library (STL) does,
    without any of the blah, blah, blah needed by STL.
    No fuss, no muss, no code bloat.

-   Python's slicing mechanism is very powerful and applies to any sequence (string, list or tuple).
    Python's string library does more with far less functions because slices replace many functions
    typically found in other string libraries.

-   Writing dict = {} creates a dictionary (hash table).
    Hash tables can contain anything, including lists and other hash tables.

-   Python's special functions,  ``__init__``, ``__del__``, ``__repr__``, ``__cmp__``, etc.
    are an elegant way to handle any special need that might arise.</t>
<t tx="ekr.20050901092232.4">Before using Python I never fully realized how difficult and dangerous memory allocation is in C++.
Try doing::

        aList[i:j] = list(aString)

in C.  You will write about 20 lines of C code.
Any error in this code will create a memory allocation crash or leak.

Python is fundamentally safe. C++ is fundamentally unsafe. When I am using
Python I am free from worry and anxiety. When I am using C++ I must be
constantly "on guard." A momentary lapse can create a hard-to-find pointer bug.
With Python, almost nothing serious can ever go wrong, so I can work late at
night, or after a beer. The Python debugger is always available. If an exception
occurs, the debugger/interpreter tells me just what went wrong. I don't have to
plan a debugging strategy! Finally, Python recovers from exceptions, so Leo can
keep right on going even after a crash!</t>
<t tx="ekr.20050901092232.5">Python has almost all the speed of C. Other interpretive environments such as
icon and Smalltalk have clarity, power and safety similar to Python. What makes
Python unique is its seamless way of making C code look like Python code.
Python executes at essentially the speed of C code because most Python modules
are written in C. The overhead in calling such modules is negligible. Moreover,
if code is too slow, one can always create a C module to do the job.

In fact, Python encourages optimization by moving to higher levels of
expression. For example, Leo's Open command reads an XML file. If this command
is too slow I can use Python's XML parser module. This will speed up Leo while
at the same time raising the level of the code.</t>
<t tx="ekr.20050901092232.6">Little of Python is completely new. What stands out is the superb engineering
judgment evident in Python's design. Python is extremely powerful, yet small,
simple and elegant. Python allows me to express my intentions clearly and at the
highest possible level.

The only hope of making Leo all it can be is to use the best possible tools. I
believe Python (possibly with Tkinter) will allow me to add, at long last, the
new features that Leo should have.

Edward K. Ream, October 25, 2001.  P.S., September, 2005:

Four years of experience have only added to my admiration for Python. Leo could
not possible be what it is today without Python.</t>
<t tx="ekr.20050901092232.7">-----------------------

|back| |leo| |next|</t>
<t tx="ekr.20050901101608">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|back| |leo| |next|

##########################################
Chapter 3: Using Outlines
##########################################

This chapter tells how to use Leo's outlines.

.. contents::</t>
<t tx="ekr.20050901101608.1">.. _`Chapter 2\: A Tutorial Introduction to Leo`:   intro.html
.. _`Chapter 4\: Writing Programs in Leo`:          directives.html
.. _`Clones and views`:                             intro.html#clones-views

.. WARNING: image targets may not have upper case letters!

.. _back:   intro.html
.. _home:   front.html
.. _next:   directives.html

.. |back| image:: arrow_lt.gif
    :target: back_

.. |leo|  image:: leo.gif
    :target: home_

.. |next| image:: arrow_rt.gif
    :target: next_

</t>
<t tx="ekr.20050901101608.2">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|back| |leo| |next|

##########################################
Chapter 5: Using Leo's Commands
##########################################

This chapter is discusses all of Leo's menu commands.

.. contents::</t>
<t tx="ekr.20050901101608.3">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|back| |leo| |next|

##########################################
Chapter 6: Leo and Literate Programming
##########################################

This chapter discusses Leo's relationship with traditional `literate programming`_.

.. contents::</t>
<t tx="ekr.20050901101608.4">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|back| |leo| |next|

##########################################
Chapter 8: Customizing Leo
##########################################

This chapter discusses how to customize Leo using the plugins and other means.
See `Specifying settings`_ for a description of how to change Leo's settings.
The scripting plugin (``mod_scripting.py``) deserves special mention. This
plugin lets you create **script buttons** in a matter of seconds. See `Creating
script buttons`_. Script buttons are extraordinarily useful. Try them, you'll be
instantly hooked.

.. contents::</t>
<t tx="ekr.20050901101608.5">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|back| |leo| |next|

##########################################
Chapter 9: History of Leo
##########################################

This chapter discusses the history of Leo and tells the essential features of each version.
Here are the most important dates in Leo's history:

</t>
<t tx="ekr.20050901101608.6">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

|back| |leo| |next|

##########################################
Chapter 10: Theory of Operation
##########################################

This chapter discusses how Leo's code works,
paying particular attention to topics that have caused difficulties in design or implementation.
This chapter will be of use primarily to those wanting to change Leo's code.

.. contents::</t>
<t tx="ekr.20050901101852">.. External links...

.. _CWEB:       http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _noweb:      http://www.eecs.harvard.edu/~nr/noweb/

.. Relative links...

.. _`Chapter 4\: Writing Programs in Leo`:              directives.html
.. _`Chapter 6\: Leo and Literate Programming`:         design.html
.. _`Clones and views`:                                 intro.html#clones-views
.. _`Creating script buttons`:                          customizing.html#creating-script-buttons
.. _`Tangling @root trees with the Tangle commands`:    directives.html#tangling-root-trees-with-the-tangle-commands

.. WARNING: image targets may not have upper case letters!

.. _back:   directives.html
.. _home:   front.html
.. _next:   design.html

.. |back| image:: arrow_lt.gif
    :target: back_

.. |leo|  image:: leo.gif
    :target: home_

.. |next| image:: arrow_rt.gif
    :target: next_</t>
<t tx="ekr.20050901101949">.. Relative links...

.. _`Chapter 5\: Using Leo's Commands`:             commands.html
.. _`Chapter 7\: Scripting Leo with Python`:        scripting.html
.. _`Clones &amp; views`:                               intro.html#clones-views
.. _`Organizer nodes`:                              intro.html#good-style-and-bad-sections-vs-others

.. _`@file trees`:          glossary.html#file-trees
.. _`@root node`:           glossary.html#root-node
.. _child:                  glossary.html#child
.. _clones:                 glossary.html#clones
.. _commands:               `Chapter 5\: Using Leo's Commands`_
.. _cweb:                   glossary.html#cweb
.. _`literate programming`: glossary.html#literate-programming
.. _node:                   glossary.html#node
.. _outline:                glossary.html#outline
.. _outlines:               glossary.html#outlines
.. _`reference`:            glossary.html#reference
.. _`referenced`:           glossary.html#referenced
.. _reStructuredText:       glossary.html#restructuredtext
.. _`rst3 plugin`:          glossary.html#rst3-plugin
.. _section:                glossary.html#section
.. _sections:               glossary.html#sections
.. _`section name`:         glossary.html#section-name
.. _`section names`:        glossary.html#section-names
.. _`section reference`:    glossary.html#section-reference
.. _`section references`:   glossary.html#section-references
.. _tangling:               glossary.html#tangling
.. _tree:                   glossary.html#tree
.. _untangling:             glossary.html#untangling

.. WARNING: image targets may not have upper case letters!

.. _back:   commands.html
.. _home:   front.html
.. _next:   scripting.html

.. |back| image:: arrow_lt.gif
    :target: back_

.. |leo|  image:: leo.gif
    :target: home_

.. |next| image:: arrow_rt.gif
    :target: next_</t>
<t tx="ekr.20050901102055">.. _`Chapter 7\: Scripting Leo with Python`:    scripting.html
.. _`Chapter 9\: History of Leo`:               history.html
.. _`rst3 plugin`:                              glossary.html#rst3-plugin
.. _`Specifying settings`:                      commands.html#specifying-settings

.. WARNING: image targets may not have upper case letters!

.. _back:   scripting.html
.. _home:   front.html
.. _next:   history.html

.. |back| image:: arrow_lt.gif
    :target: back_

.. |leo|  image:: leo.gif
    :target: home_

.. |next| image:: arrow_rt.gif
    :target: next_</t>
<t tx="ekr.20050901102147">.. Relative links...

.. _`Chapter 7\: Scripting Leo with Python`:    scripting.html
.. _`Chapter 8\: Customizing Leo`:              customizing.html
.. _`Chapter 10\: Theory of Operation`:         theory.html

.. WARNING: image targets may not have upper case letters!

.. _back:   customizing.html
.. _home:   front.html
.. _next:   theory.html

.. |back| image:: arrow_lt.gif
    :target: back_

.. |leo|  image:: leo.gif
    :target: home_

.. |next| image:: arrow_rt.gif
    :target: next_</t>
<t tx="ekr.20050901102300">.. _`Chapter 9\: History of Leo`:   history.html
.. _`Chapter 11\: White Papers`:    whitepapers.html

.. WARNING: image targets may not have upper case letters!

.. _back:   history.html
.. _home:   front.html
.. _next:   whitepapers.html

.. |back| image:: arrow_lt.gif
    :target: back_

.. |leo|  image:: leo.gif
    :target: home_

.. |next| image:: arrow_rt.gif
    :target: next_</t>
<t tx="ekr.20050901102400">-------------

|back| |leo| |next|</t>
<t tx="ekr.20050901102400.1">-------------

|back| |leo| |next|</t>
<t tx="ekr.20050901102400.2">-------------

|back| |leo| |next|</t>
<t tx="ekr.20050901102400.3">-------------

|back| |leo| |next|</t>
<t tx="ekr.20050901102400.4">-------------

|back| |leo| |next|</t>
<t tx="ekr.20050901102400.5">-------------

|back| |leo| |next|</t>
<t tx="ekr.20050901102400.6">-------------

|back| |leo| |next|</t>
<t tx="ekr.20050901110110">.. Links used in this document...

.. _`Pmw`:      http://pmw.sourceforge.net/
.. _run:        `Running Leo`_
.. _`run Leo`:  `Running Leo`_

.. _`associated .leo files with Leo`:           `How to associate Leo with .leo files on Windows`_

.. WARNING: image targets may not have upper case letters!

.. _back: FAQ.html
.. _home: front.html
.. _next: intro.html

.. |back| image:: arrow_lt.gif
    :target: back_

.. |leo|   image:: leo.gif
    :target: home_

.. |next| image:: arrow_rt.gif
    :target: next_</t>
<t tx="ekr.20050901121617">@color

# Puts each sentence on a separate line
# Not as useful as I had hoped.  The Reformat Paragraph command is better.

@others

splitSentences(c,p)</t>
<t tx="ekr.20050901121617.1">def splitSentences(c,p):
    
    undoType = 'Split Sentences'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    s = p.bodyString()
    if not s.strip(): return
    
    i = 0 ; line = [] ; result = [] ; nl = False
    while i &lt; len(s):
        ch = s[i] ; i += 1 ; ch2 = '.'
        if i &lt; len(s): ch2 = s[i]
        if ch in ('.',';') and ch2 in (' ','\t','\n'):
            line.append(ch)
            r = ''.join(line)+'\n'
            if nl and ch == '.': r = r + '\n'
            result.append(r)
            line = [] ; nl = False
            while i &lt; len(s):
                ch2 = s[i]
                if ch2 == '\n' and ch == '.':
                    nl = True
                if ch2 in (' ','\t','\n'):
                    i += 1
                else:
                    break
        else: line.append(ch)

    result.append(''.join(line)+'\n') # Add the last line.
    result = ''.join(result)
    c.updateBodyPane('',result,'',undoType,oldSel,oldYview)</t>
<t tx="ekr.20050901134017">**All this is obsolete**.  Leo now shares tnodes, so there are no more 'dependent' nodes.

**Definition 1**. The following is a definition of clones from the user's point of view::

    A clone node is a copy of a node that changes when the original changes.

Changes to the children, grandchildren, etc.
of a node are simultaneously made to the corresponding nodes contained in all cloned nodes.
Clones are marked by a small clone arrow by its leader character.
As we shall see, this definition glosses over a number of complications.

Note that all cloned nodes (including the original node) are equivalent.
There is no such thing as a "master" node from which all clones are derived.
When the penultimate cloned node is deleted, the remaining node becomes an ordinary node again.
Internally, the clone arrow is represented by a clone bit in the status field of the vnode.

The Clone Node command sets the clone bits of the original and cloned vnodes when it creates the clone.
Setting and clearing clone bits properly when nodes are inserted, deleted or moved, is non-trivial.
We need the following machinery to do the job properly.
Two vnodes are joined if:

- they share the same tnode (body text) and

- changes to any subtree of either joined vnodes are made to the corresponding nodes in all joined nodes.

For example, Definition 1 defines clones as joined nodes that are marked with a clone arrow.
Leo links all vnodes joined to each other in a circular list, called the join list.
For any vnode n, let J(n) denote the join list of n, that is, the set of all vnodes joined to n.
Again, maintaining the join lists in an outline is non-trivial.
The concept of structurally similar nodes provides an effective way of determining when two joined nodes should also have their cloned bit set.

Two joined nodes are structurally similar if:

- their parents are distinct but joined and

- they are both the nth child of their (distinct) parents.

**Definition 2**. We can define cloned nodes using the concept of structurally similar nodes as follows::

    Clones are joined vnodes such that at least two of the vnodes of J(n) are
    not structurally similar to each other. Non-cloned vnodes are vnodes such
    that all of the vnodes of J(n) are structurally similar. In particular, n is
    a non-cloned vnode if J(n) is empty.

**Leo ensures that definitions 1 and 2 are consistent**. Definition 1 says that
changes to the children, grandchildren, etc. of a node are simultaneously made
to the corresponding nodes contained in all cloned nodes. Making "corresponding
changes" to the non-cloned descendants of all cloned nodes insures that the
non-cloned joined nodes will be structurally similar.
On the other hand, cloned nodes are never structurally similar. They are created
as siblings, so they have the same parent with different "child indices. " To
see how this works in practice, let's look at some examples.

Example 1::

    + root
        + a' (1)
        + a' (2)

This example shows the simplest possible clone. A prime (') indicates a cloned
node. Node a in position (1) has just been cloned to produce a' in position (2).
Clearly, these two cloned nodes are not structurally similar because their
parents are not distinct and they occupy different positions relative to their
common parent.

Example 2. If we add a node b to either a' node we get the following tree::

    + root
        + a'
            + b
        + a'
            + b

The b nodes are structurally similar because the a' nodes are joined and each b
node is the first child of its parent.

Example 3.  If we now clone either b, we will get::

    + root
        + a'
            + b' (1)
            + b' (2)
        + a'
            + b' (1)
            + b' (2)

All b' nodes must be clones because the nodes marked (1) are not structurally
similar to the nodes marked (2).

Dependent nodes are nodes created or destroyed when corresponding linked nodes
are created or destroyed in another tree. For example, going from example 1 to
example 2 above, adding node b to either node a' causes another (dependent) node
to be created as the ancestor of the other node a'. Similarly, going from
example 2 to example 1, deleting node b from either node a' causes the other
(dependent) node b to be deleted from the other node a'. Cloned nodes may also
be dependent nodes. In Example 3, all the b' nodes are dependent on any of the
other b' nodes. We can now give simple rules for inserting and deleting
dependent vnodes when other vnodes are created, moved or destroyed.

For the purposes of this discussion, moving a node is handled exactly like
deleting the node then inserting the node; we need not consider moving nodes
further. We insert a new node n as the nth child of a parent node p as follows.
We insert n, then for every node pi linked to p, we insert a dependent node ni
as the nth child of pi. Each ni is linked to n. Clearly, each ni is structurally
similar to n. Similarly, it is easy to delete a node n that is the nth child of
a parent node p. We delete each dependent node ni that is the nth child of any
node pi linked to p. We then delete n. When inserting or deleting any vnode n we
must update its join list, J(n). Updating the join list is easy because the join
list is circular: the entire list is accessible from any of its members.
Inserting or deleting nodes can cause the clone bits of all joined nodes to
change in non-trivial ways.

To see the problems that can arise, consider deleting any of the b' nodes from
Example 3. We would be left with the tree in Example 2. There are two remaining
b nodes, each with the clone bit set. Unless we know that both b nodes are
structurally similar, there would be no way to conclude that we should clear the
clone bits in each node. In order to update clone links properly we could
examine many special cases, but there is an easier way. Because of definition 2,
we can define a shouldBeCloned function that checks J(n) to see whether all
nodes of J(n) are structurally similar. Leo's XML file format does not contain
join lists.

This makes it easy to change a Leo file "by hand". If join lists were a part of
the file, as they are in the Mac version of Leo, corrupting a join list would
corrupt the entire file. It is easy to recreate the join lists when reading a
file using a dedicated field in the tnode. This field is the head of a list of
all vnodes that points to the tnode. After reading all nodes, Leo creates this
list with one pass through the vnodes. Leo then convert each list to a circular
list with one additional pass through the tnodes.</t>
<t tx="ekr.20050901174937">You can run Leo from a Python interpreter as follows::

	import leo
	leo.run() # runs Leo, opening a new outline.
	leo.go() # runs Leo after reloading all modules.
	leo.leoOpen(fileName) # runs Leo, reloads all modules, and opens fileName.

Here are some tips that may make running Leo easier:

**Linux**
    The following shell script will allow you to open foo.leo files by typing leo foo::
    
        #!/bin/sh 
        python &lt;leopath&gt;/leo.py $1
    
    where &lt;leopath&gt; is replaced with the path to the leo directory. 

**Windows**
    If you have `associated .leo files with Leo`_ you may run Leo by double-clicking any .leo file.
    You can also use a batch file.
    Put the following .bat file in c:\\Windows::

        cd c:\prog\LeoCVS\leo
        c:\python22\python c:\prog\LeoCVS\leo\leo.py %1
    
    This opens the file specified by the first argument (%1).

The first time you start Leo, a dialog will ask you for a unique identifier. If
you are use cvs, use your cvs login name. Otherwise your initials will do. Leo
stores this identifier in the file ``.leoID.txt``. Leo attempts to create
``leoID.txt`` in your home directory, then in Leo's config directory, and
finally in Leo's src directory. You can change this identifier at any time by
editing ``.leoID.txt``.</t>
<t tx="ekr.20050901184158">You can execute all the code in this file. Just select the code you want to
execute and run the Execute Script command.

**Important**: Python is finicky about indentation, so you must be careful to
select the leading whitespace of the first line.</t>
<t tx="ekr.20050902073404">Understanding this section is **supremely important** for anyone who wants to
script Leo properly.

By default, all iterators discussed below use a **single** position to move
through the outline. This is a vital optimization; otherwise Leo would generate
one or more position object for each node of a tree traversal. However, it means
that it is **useless** to try to capture a position with::

    p2 = p  # Wrong.  p2 will change after this assignment.

Instead, scripts and plugins should use ``p.copy()`` to 'capture' the value of a position::

    p2 = p.copy()   # Correct: p2 will not change when p changes later.

Another way to solve this problem is to set ``copy=True`` when using an iterator::

    d = {}
    for p in c.allNodes_iter(copy=True):
        d[p.v.t] = p

This creates a dictionary of (unchanging!) positions, indexed via tnode.
**Warning** The positions in this dictionary will become invalid when the
outline's structure changes. It would be wrong to save a dictionary like this
for use between commands.

Setting the ``copy=True`` argument to iterators is an acceptable strategy for
infrequently used scripts; it is not acceptable for heavily used code in Leo's
core: it would create huge numbers of positions that would immediately be
candidates for garbage collection.

**Important**: 'Confused' scripts work because the ``position`` methods that
simulate the old ``vnode`` methods automatically create copies of positions when
'moving' through an outline. Thus, confused scripts generate many more positions
than would the equivalent script that uses ``position`` iterators. Such is the
price of compatibility.</t>
<t tx="ekr.20050902080416"># Start at the top.
b = c.frame.body.bodyCtrl
b.mark_set('insert','1.0')
b.tag_remove('sel','1.0','end')
b.tag_add('sel','1.0','1.0')
b.update_idletasks()

# Format until the end.
count = 0 # Guard against loops.
while count &lt; 100:
    count += 1
    s = p.bodyString()
    if not s.strip():
        break
    c.reformatParagraph()
    s2 = p.bodyString()
    
    index = b.index('insert')
    if b.compare(index,'&gt;=','end-1c'):
        break</t>
<t tx="ekr.20050902100834">This following information may be of interest to historians. It is not of
general enough interest to put in Leo's Users Guide on the web. I am including
this mass of detail here to indicate the complexities that were involved in
designing Leo's simple-looking mechanisms.</t>
<t tx="ekr.20050902105852">Leo grew out of my efforts to use Donald Knuth's "CWEB system of Structured
documentation." I had known of literate programming since the mid 1980's, but I
never understood how to make it work for me. In November 1995 I started thinking
about literate programming in earnest. Over the holidays I mused about making
literate programs more understandable. In January 1996 the fog of confusion
suddenly cleared. I summarized my thinking with the phrase, **web are outlines
in disguise**. I suspected that outline views were the key to literate
programming, but many details remained obscure.
</t>
<t tx="ekr.20050902105852.1">March 5, 1996, is the most important date in Leo's history. While returning from
a day of skiing, I discussed my thoughts with Rebecca. During that conversation
I realized that I could use the ``MORE`` outliner as a prototype for a "literate
outliner." I immediately started work on my first literate outline. It quickly
became apparent that outlines work: all my old problems with literate
programming vanished. The ``@others`` directive dates from this day. I realized
that ``MORE``'s outlines could form the basis for Leo's screen design. Rather
than opening body text within the outline, as ``MORE`` does, I decided to use a
separate body pane.

I hacked a translator called ``M2C`` which allowed me to use ``MORE`` to write
real code. I would write code in ``MORE``, copy the text to the clipboard in
``MORE`` format, then run ``M2C``, which would tangle the outline into C code.
This process was useful, if clumsy. I called the language used in the outline
``SWEB``, for simplified ``CWEB``. Much later Leo started supporting the noweb
language.</t>
<t tx="ekr.20050902105852.2">Throughout 1996 I created a version of Leo on the Macintosh in plain C and the
native Mac Toolbox. This was a poor choice; I wasted a huge amount of time
programming with these primitive tools. However, this effort convinced me that
Leo was a great way to program.

Late in 1997 I wrote a ``Print`` command to typeset an outline. Printing (Weaving)
is supposedly a key feature of literate programming. Imagine my surprise when I
realized that such a "beautiful" program listing was almost unintelligible; all
the structure inherent in the outline was lost! I saw clearly that typesetting,
no matter how well done, is no substitute for explicit structure.

In 1998 I created a version of Leo using Apple's YellowBox environment. Alas,
Apple broke its promises to Apple developers. I had to start again.</t>
<t tx="ekr.20050902105852.3">I rewrote Leo for Borland C++ starting in May 1999. Borland C++ was much better
than CodeWarrior C, but it was still C++. This version of Leo was the first
version to use xml as the format of .leo files. The last version of Borland Leo,
3.12 Final went out the door July 17, 2003.</t>
<t tx="ekr.20050902105852.4">I attended the Python conference in early 2001. In May of 2000 I began work on
an wxWindows version of Leo. This did not work out, but something good did come
from this effort. I spent a lot of time adding Python scripting to the wxWindows
code and I became familiar with Python and its internals.

I really started to 'get' Python in September 2001. I wrote the white papers at
about this time. Python solved *all* my programming problems. I rewrote Leo in
Python in about two months! For the first time in my career I was no longer
anxious while programming; it simply isn't possible to create bad bugs in
Python. The Python version of Leo the first officially OpenSoftware version of
Leo. The first function version of Leo in Python was 0.05 alpha, December 17,
2001.</t>
<t tx="ekr.20050902105852.5">I registered the Leo project on SourceForge on March 10, 2003. It is certainly
no accident that Leo started a new life shortly thereafter. Prior to SourceForge
my interest in Leo had been waning.</t>
<t tx="ekr.20050902105852.6">In the summer of 2001 I began to consider using sentinel lines in derived files.
Previously I had thought that outline structure must be 'protected' by remaining
inside .leo files. Accepting the possibility that sentinels might be corrupted
opened vast new design possibilities. In retrospect, problems with sentinel
almost never happen, but that wasn't obvious at the time! The result of this
design was known at first as ``Leo2``. That terminology is extinct. I think of
this version as the first version to support ``@file`` and automatic tangling
and untangling.</t>
<t tx="ekr.20050902105852.7">The biggest surprise in Leo's history was the realization it is **much** easier
to untangle files derived from ``@file``. Indeed, ``@root`` creates all sorts of
problems that just disappear when using ``@file``. The new Python version of Leo
became fully operational in early 2002. It was probably about this time that I chose
noweb as Leo's preferred markup language. My decision not to support noweb's
escape sequences made Leo's read code much more robust.
</t>
<t tx="ekr.20050902105852.8">I spent 2002 taking advantages of Python's tremendous power and safety.
Many improvements were at last easy enough to do:

- Nested ``@others`` directives appeared in 3.2.
- Unicode support started in 3.3.
- @first and @last appeared in 3.7
- @asis and @nosent appeared in 3.8.
- Incremental syntax coloring and incremental undo appeared in 3.9.
- 3.12 fixed a huge memory leak.
- 3.12 Final, the last 3.x version, appeared July 17, 2003.
</t>
<t tx="ekr.20050902105852.9">In late 2002 and throughout 2003 I worked on an entirely new file format.
4.0 final went out the door October 17, 2003 after almost a year intense
design work trying to improve error recovery scheme used while reading
derived files. In the summer of 2003 I realized that orphan and ``@ignore``'d
nodes must be prohibited in ``@file`` trees. With this restriction, Leo
could finally recreate ``@file`` trees in outlines using **only** the
information in derived files. This made the read code much more robust, and
eliminated all the previous unworkable error recovery schemes. At last Leo
was on a completely firm foundation.
</t>
<t tx="ekr.20050902105852.10">Leo first used gnx's (global node indices) as a foolproof way of associated
nodes in .leo files with nodes in derived files. At the time, there was
still intense discussions about protecting the logical consistency of
outlines. ``@thin`` was later to solve all those problems, but nobody knew
that then.
</t>
<t tx="ekr.20050902105852.11">Leo 4.2 Final went out the door September 20, 2004.
This surely is one of the most significant dates in Leo's history:

-   This marked the end worries about consistency of outlines and derived files:
    Leo recreates all essential information from thin derived files,
    so *there is nothing left in the .leo file to get out of synch*.

-   Thin derived files use gnx's extensively.  This simplifies the file format and makes thin derived files
    more cvs friendly.

-   A sensational scripting plugin showed how to create script buttons.
    This has lead to improvements in the Execute Script command and
    other significant improvements in Unit testing.

-   As if this were not enough, 4.2 marked the 'great divide' in Leo's internal
    data structures. Before 4.2, Leo every node in the outline had its own
    ``vnode``. This was a big performance problem: clone operations had to
    traverse the entire outline! 4.2 represents clones by sharing subtrees.
    Changing Leo's fundamental data structures while retaining compatibility
    with old scripts was engineering work of which the entire Leo community can
    be proud. `Chapter 7: Scripting Leo with Python`_ tells how the position
    class makes this happen.
    This was a cooperative effort. Kent Tenney and Bernhard Mulder made
    absolutely crucial contributions. Kent pointed out that it is a ``tnode``,
    not a ``vnode`` that must form the root of the shared data. Bernhard showed
    that iterators are the way to avoid creating huge numbers of positions.

Leo 4.2 marked so many significant changes. I often find it hard to remember
what life with Leo was like before it.</t>
<t tx="ekr.20050902105852.12">Leo 4.3 corrected many problems with ``leoConfig.txt``. Instead, Leo gets
settings from one or more ``leoSettings.leo files``. This version also
introduced a way to changed settings using a settings dialog.</t>
<t tx="ekr.20050902160924">**Important**: Script buttons are easier to use than the script-oriented
find/change commands described next. I recommend using script buttons whenever
possible. See `Creating script buttons`_.
You are not likely to need all the firepower that script-orient find/change commands,
but it could save you lots of time for complex jobs.

Leo's find panel contains the ``Script Search`` radio button and the ``Script
Change`` checkbox. When the ``Script Search`` radio button is selected Leo treats the
contents of the ``Search Text`` as a script to execute whenever any kind of Find
command is executed. Similarly, when the ``Script Change`` checkbox is selected Leo
treats the context of the ``Change Text`` as a script to execute whenever any kind
of Change command is executed.

Script-based find-change turns Leo's Find/Change panel into a platform for
running scripts interactively. The script writer need not write code to control
interactive searches.

Here's how it works. Leo dedicates ``g.app.searchDict`` for
communication between Leo and the search and change scripts. The search and
change scripts may also use ``g.app.searchDict`` for communication between themselves.
Leo sets ``g.app.searchDict["type"]`` to "find", "change", "findAll" or "changeAll" to
indicate the kind of command being executed. Scripts may use all other entries
in ``g.app.searchDict`` as they please.

Here is what Leo does when the user presses buttons with ``Script Search`` enable:

``Find and Change, then Find`` buttons
    Leo executes the find script once. Typically, the find script would traverse
    the tree and highlight the found text or otherwise indicate to the user that
    the find operation has succeeded. However, the script can do anything it
    pleases.

``Find All`` button
    Leo executes the find script repeatedly until ``g.app.searchDict["continue"]`` evaluates
    to ``False``. Initially there is no entry for ``g.app.searchDict["continue"]``, so the
    find script must set ``g.app.searchDict["continue"] = True`` if it wants Leo call it again.

``Change`` button
    Leo executes the change script once. Typically, the change script would change
    the selected text. Usually the change script will compute the new value of body
    text and call ``p.setBodyStringOrPane(newText)`` to make that change permanent. 
    To handle undo, the change script can call
    ``c.frame.onBodyChanged(v,"Change",oldText=oldText)``.

``Change All`` button
    Leo executes the change script repeatedly
    until g.app.searchDict["continue"] evaluates to false.

Most find and change scripts will ignore settings in the Find Panel like "whole
word", "pattern match", and "reverse". However, these settings are available to
the scripts via ivars such as ``c.whole_word_flag``, etc. if desired.

The ``initScriptFind`` script in ``LeoPy.leo`` makes it easy to set up script based searches:

1. Put the following code in the root of a tree that will contain your script search::

    # Initialize Leo's find panel using the named children of this node.
    import leoGlobals as g.
    g.initScriptFind("Find script","Change script") # Second argument is optional.
    # Start searching at the top.
    c.selectPosition(c.rootPosition())

2. Put the search script in a child node called "Find script" (no quotes).

3. (Optional) Put the change script in a child node called "Change script"

4.  Execute the code above.  Leo does the following:

- Puts the body of the "Find script" into the find text of Leo's Find/Change dialog.
- Puts the body of the "Change script" into the change text of Leo's Find/Change dialog.
- Selects the Script Find radio button.
- Selects the Script Change checkbox if the change script exists.
- Selects the root of the entire outline.

Presto! Leo is ready for a script search. **Note**: you could also consider creating a
script button to set up complex find/change scripts.

Here are some ideas for using script find/change.
	
-   Find and change scripts may use Python's re module.  For
    example, the find script could set ``g.app.searchDict["m"]`` to the match object
    returned by re's match method.  The change script would then compute the
    result, change the text and set the undo info as usual.
    
-   Find and change scripts may operate on data outside any Leo outline.
    For example, script-find scripts could traverse your file system.
    Scripts could even pull data from the file system
    into the outline so that you can see the effects of changes as the scripts
    operate.</t>
<t tx="ekr.20050903074833">``leoPlugins.leo`` contains all of Leo's official hooks. Studying this file is
the best way to learn how to write plugins.  This section discusses just a few details.

Leo attempts to import all enabled plugins at startup time.
Plugins register hooks with code such as::

    leoPlugins.registerHandler("after-create-leo-frame",onCreate)
    leoPlugins.registerHandler("idle", on_idle) 
    leoPlugins.registerHandler(("start2","open2","command2"), create_open_with_menu) 

As shown above, a plugin may register one or more hooks with a single call to
``leoPlugins.registerHandler``. Once a hook is registered, Leo will call the
registered function' at the named **hook time**. For example::

    leoPlugins.registerHandler("idle", on_idle)

causes Leo to call ``on_idle`` at "idle" time.

Hook functions must have the following signature::

    def myHook (tag, keywords):
        whatever

-   ``tag`` is the name of the hook (a string).
-   ``keywords`` is a Python dictionary containing additional information.
    The following section describes the contents of the ``keywords`` dictionary in detail.

**Important**: hooks should get the proper commander this way::

    c = keywords.get('c')</t>
<t tx="ekr.20050903074833.1">Leo's core defines hook times using in many places. The following table tell all
about each hook: its name, when it is called, and the additional arguments
passed to the hook in the ``keywords`` dictionary. For some kind of hooks, Leo
will skip its own normal processing if the hook returns anything *other* than
None. The table indicates such hooks with 'yes' in the 'Stop?' column.

**Important**: Ever since Leo 4.2, the ``v``, ``old_v`` and ``new_v`` keys in
the keyword dictionary contain *positions*, not vnodes. These keys are
deprecated. The ``new_c`` key is also deprecated. Plugins should use the ``c`` key instead.

============================= ======== =================================== =============================
Hook name (tag argument)      Stop?    When called                         Keys in keywords dict
============================= ======== =================================== =============================
'after-create-leo-frame'               after creating any frame            c
'after-redraw-outline'                 end of tree.redraw                  c (note 6)
'before-create-leo-frame'              before frame.finishCreate           c
'bodyclick1'                   yes     before normal click in body         c,p,v,event
'bodyclick2'                           after normal click in body          c,p,v,event
'bodydclick1'                  yes     before double click in body         c,p,v,event
'bodydclick2'                          after  double click in body         c,p,v,event
'bodykey1'                     yes     before body keystrokes              c,p,v,ch,oldSel,undoType
'bodykey2'                             after  body keystrokes              c,p,v,ch,oldSel,undoType
'bodyrclick1'                  yes     before right click in body          c,p,v,event
'bodyrclick2'                          after  right click in body          c,p,v,event
'boxclick1'                    yes     before click in +- box              c,p,v,event
'boxclick2'                            after  click in +- box              c,p,v,event
'clear-mark'                           when mark is set                    c,p,v
'close-frame'                          in app.closeLeoWindow               c
'color-optional-markup'        yes *   (note 7)                            colorer,p,v,s,i,j,colortag (note 7)
'command1'                     yes     before each command                 c,p,v,label (note 2)
'command2'                             after  each command                 c,p,v,label (note 2)
'create-optional-menus'                (note 8)                            c (note 8)
'create-popup-menu-items'              in tree.OnPopup                     c,p,v,event (new)
'destroy-all-global-windows'           (note 12)                           None
'draw-outline-box'             yes     when drawing +- box                 tree,p,v,x,y
'draw-outline-icon'            yes     when drawing icon                   tree,p,v,x,y
'draw-outline-node'            yes     when drawing node                   tree,p,v,x,y
'draw-outline-text-box'        yes     when drawing headline               tree,p,v,x,y
'drag1'                        yes     before start of drag                c,p,v,event
'drag2'                                after  start of drag                c,p,v,event
'dragging1'                    yes     before continuing to drag           c,p,v,event
'dragging2'                            after  continuing to drag           c,p,v,event
'enable-popup-menu-items'              in tree.OnPopup                     c,p,v,event
'end1'                                 start of app.quit()                 None
'enddrag1'                     yes     before end of drag                  c,p,v,event
'enddrag2'                             after  end of drag                  c,p,v,event
'headclick1'                   yes     before normal click in headline     c,p,v,event
'headclick2'                           after  normal click in headline     c,p,v,event
'headrclick1'                  yes     before right click in headline      c,p,v,event
'headrclick2'                          after  right click in headline      c,p,v,event
'headkey1'                     yes     before headline keystrokes          c,p,v,ch (note 13)
'headkey2'                             after  headline keystrokes          c,p,v,ch (note 13)
'hypercclick1'                 yes     before control click in hyperlink   c,p,v,event
'hypercclick2'                         after  control click in hyperlink   c,p,v,event
'hyperenter1'                  yes     before entering hyperlink           c,p,v,event
'hyperenter2'                          after  entering hyperlink           c,p,v,event
'hyperleave1'                  yes     before leaving  hyperlink           c,p,v,event
'hyperleave2'                          after  leaving  hyperlink           c,p,v,event
'iconclick1'                   yes     before single click in icon box     c,p,v,event
'iconclick2'                           after  single click in icon box     c,p,v,event
'iconrclick1'                  yes     before right click in icon box      c,p,v,event
'iconrclick2'                          after  right click in icon box      c,p,v,event
'icondclick1'                  yes     before double click in icon box     c,p,v,event
'icondclick2'                          after  double click in icon box     c,p,v,event
'idle'                                 periodically (at idle time)         c
'init-color-markup'                    (note 7)                            colorer,p,v (note 7)
'menu1'                        yes     before creating menus               c,p,v (note 3)
'menu2'                        yes     before updating menus               c,p,v
'new'                                  start of New command                c,old_c,new_c (note 9)
'open1'                        yes     before opening any file             c,old_c,new_c,fileName (note 4)
'open2'                                after  opening any file             c,old_c,new_c,fileName (note 4)
'openwith1'                    yes     before Open With command            c,p,v,openType,arg,ext
'openwith2'                            after  Open With command            c,p,v,openType,arg,ext
'recentfiles1'                 yes     before Recent Files command         c,p,v,fileName,closeFlag
'recentfiles2'                         after  Recent Files command         c,p,v,fileName,closeFlag
'redraw-entire-outline'        yes     start of tree.redraw                c (note 6)
'save1'                        yes     before any Save command             c,p,v,fileName
'save2'                                after  any Save command             c,p,v,fileName
'scan-directives'                      in scanDirectives                   c,p,v,s,old_dict,dict,pluginsList (note 10)
'select1'                      yes     before selecting a position         c,new_p,old_p,new_v,new_v
'select2'                              after  selecting a position         c,new_p,old_p,new_v,old_v
'select3'                              after  selecting a position         c,new_p,old_p,new_v,old_v
'set-mark'                             when a mark is set                  c,p,v
'show-popup-menu'                      in tree.OnPopup                     c,p,v,event
'start1'                               after app.finishCreate()            None
'start2'                               after opening first Leo window      c,p,v,fileName
'unselect1'                    yes     before unselecting a vnode          c,new_p,old_p,new_v,old_v
'unselect2'                            after  unselecting a vnode          c,new_p,old_p,old_v,old_v
'\@url1'                        yes     before double-click @url node       c,p,v,url (note 5)
'\@url2'                                after  double-click @url node       c,p,v(note 5)
============================= ======== =================================== =============================

**Notes**:

1.  'activate' and 'deactivate' hooks have been removed because they do not work as expected.

2.  'commands' hooks: The label entry in the keywords dict contains the
    'canonicalized' form of the command, that is, the lowercase name of the command
    with all non-alphabetic characters removed.
    Commands hooks now set the label for undo and redo commands 'undo' and 'redo'
    rather than 'cantundo' and 'cantredo'.

3.  'menu1' hook: Setting ``g.app.realMenuNameDict`` in this hook is an easy way of
    translating menu names to other languages. **Note**: the 'new' names created this
    way affect only the actual spelling of the menu items, they do *not* affect how
    you specify shortcuts settings, nor do they affect the 'official'
    command names passed in ``g.app.commandName``. For example::

        app().realMenuNameDict['Open...'] = 'Ouvre'.

4.  'open1' and 'open2' hooks: These are called with a keywords dict containing the following entries:

    - c:          The commander of the newly opened window.
    - old_c:      The commander of the previously open window.
    - new_c:      (deprecated: use 'c' instead) The commander of the newly opened window.
    - fileName:   The name of the file being opened.

    You can use ``old_c.currentPosition()`` and ``c.currentPosition()`` to get the current
    position in the old and new windows.
    Leo calls the 'open1' and 'open2' hooks only if the file is not already open. Leo
    will also call the 'open1' and 'open2' hooks if: a) a file is opened using the
    Recent Files menu and b) the file is not already open.

5.  '\@url1' and '\@url2' hooks are only executed if the 'icondclick1' hook returns None.

6.  These hooks are useful for testing.

7.  These hooks allow plugins to parse and handle markup within doc parts,
    comments and Python ``'''`` strings. Note that these hooks are *not* called in
    Python ``'''`` strings. See the color_markup plugin for a complete example of how to
    use these hooks.

8.  Leo calls the 'create-optional-menus' hook when creating menus. This hook need
    only create new menus in the correct order, without worrying about the placement
    of the menus in the menu bar. See the plugins_menu and scripts_menu plugins for
    examples of how to use this hook.

9.  The ``New`` command calls 'new'.
    The 'new_c' key is deprecated.  Use the 'c' key instead.

10. ``g.scanDirectives`` calls 'scan-directives' hook.
    ``g.scanDirectives`` returns a dictionary, say d.
    d.get('pluginsList') is an a list of tuples ``(d,v,s,k)`` where:

    - d is the spelling of the @directive, without the leading @.
    - v is the vnode containing the directive, _not_ the original vnode.
    - s[k:] is a string containing whatever follows the @directive.
      k has already been moved past any whitespace that follows the @directive.

    See the add_directives plugins directive for a complete example of how to use
    the 'scan-directives' hook.

11. ``g.app.closeLeoWindow`` calls the 'close-frame' hook just before
    removing the window from ``g.app.windowList``. The hook code may remove the window
    from ``app.windowList`` to prevent ``g.app.closeLeoWindow`` from destroying the window.

12. ``g.app.destroyAllGlobalWindows`` calls the 'destroy-all-global-windows' hook.
    This hook gives plugins the chance to clean up after themselves when Leo shuts down.

13. New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user completes
    the editing of a headling, and ch is always '\r', regardless of platform.</t>
<t tx="ekr.20050903075144">A **plugin** is a Python file that appears in Leo's plugin directory. Plugins
are a powerful way of enhancing and customizing Leo. The file
``pluginsManager.txt`` in the plugins directory controls tells which plugins are
enabled. Midway during startup, Leo imports all enabled plugins. Plugins can
register functions called **hooks** that are to be run at specified times.
Plugins can:

- add new commands
- modify how existing commands work
- add new menus or customize existing menus.
- override any of Leo's core code&gt;

Here are some important features of plugins:

-   Plugins can use any of Leo's source code for their own use.
    Doing so is easy: after importing one of Leo's modules the plugin can call any routine in that module.
    This documentation describes **convenience methods** in Leo's core that were created the use of plugins.

-   Plugins are permanent: they will not go away when Leo is updated.

-   Leo loads plugins in the order in which they appear in ``pluginsManager.txt.``
    Leo disables all plugins if ``pluginsManager.txt`` does not exist in the plugins directory.</t>
<t tx="ekr.20050903161843">Creating a script button should be your first thought whenever you want to
automate any task. The scripting plugin, ``mod_scripting.py``, puts two buttons
in the icon menu, a pink ``Run Script`` button and a yellow ``Script Button``
button. The ``Run Script`` button does the same thing as the ``Execute Script``
command. The ``Script Button`` button is the interesting one. It creates a
button, confusingly called a **script button** in the icon area. A script button
executes a script when you push it.

Suppose node N is selected. When you press the ``Script Button`` button a new
(pink) script button is created. The name of the new button is N's headline
text. The script associated with the new button is N's body text. Now whenever
you press the new button, N's script is executed on the **presently** selected
node. Script buttons are extraordinarily useful. In effect, each script button
defines an instant command! For example, sometimes my fingers get tired of
saving a file. I simply put ``Save`` in a node's headline and ``c.save()`` in
the body text. I hit the ``Script Button`` button and I get a new button called
``Save`` that will save the outline when I press it.

Here's a more interesting example. The following script searches the present node
and its ancestors looking for an ``@rst`` node. When such a node is found the
script calls the `rst3 plugin`_ to format it. I don't have to select the actual
``@rst`` node; I can select any of its children::

    import leoPlugins
    rst3 = leoPlugins.getPluginModule('rst3')
    if rst3: # already loaded.
        controller = rst3.controllers.get(c)
        if controller:
            for p in p.self_and_parents_iter():
                if p.headString().startswith('@rst '):
                    controller.processTree(p)
                    break
    else: # Just load the plugin.
        rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
        if rst3:
            g.es('rst3 loaded')
            rst3.onCreate('tag',{'c':c})
        else:
            # Ask to be removed.
            g.app.scriptDict['removeMe'] = True

**Notes**:

-   The scripting plugin pre-defines the ``c``, ``g`` and ``p`` symbols
    just as the ``Execute Script`` command does.

-   By default a script button executes the **present** body text of the node that original created the script button.
    This is very handy: you can modify a script button's script at any time without having to recreate the script button.

-   You can delete any script button by right-clicking on it.

-   On startup, the scripting plugin scans the entire .leo file and creates a script button
    for every node whose headline starts with ``@button scriptName``.
    **Warning**: this is indeed a security risk of the kind discussed later.
    This feature can be disabled by setting ``atButtonNodes = True`` at the start of ``mod_scripting.py``.</t>
<t tx="ekr.20050903174637">There are many problems with pdf at present.

@ignore</t>
<t tx="ekr.20050906090012">Leo (and other programs) often send more detailed error messages to ``stderr``,
the output stream that goes to the console window. In Linux and MacOS
environments, python programs normally execute with the console window visible.
On Windows, can run Leo with the console window visible by associating .leo
files with ``python.exe`` *not* ``pythonw.exe``. For full instructions about how
to do this, see `Associating Leo with .leo Files`_.</t>
<t tx="ekr.20050906104918">Leo 4.3.2 beta 1                  September 10, 2005

To learn about Leo, see: http://webpages.charter.net/edreamleo/intro.html

The highlights of 4.3.2:
-----------------------

- Improved Leo's documentation:
    - A tutorial introduction to Leo:
      http://webpages.charter.net/edreamleo/intro.html
    - A 5-minute guide to programming with Leo:
      http://webpages.charter.net/edreamleo/intro.html#quick-start-for-programmers

- The new rst3 plugin creates .html and .tex files from reStructuredText
  embedded in Leo files. Any node of the source outline may contain options for
  the rst3 plugin, which makes this plugin much more useful and flexible than
  the previous rst plugins. All of Leo's documentation was created using this
  plugin from sources in LeoDocs.leo. For full documentation for rst3 see:
  http://webpages.charter.net/edreamleo/rstplugin3.html.

- The spellpyx (spell checking) plugin is now much easier to use.

- The vim and openWith plugins now use Python's subprocess module if it is present.
 
- Improved the Pretty Printing command.

- The usual assortment of bug fixes.</t>
<t tx="ekr.20050906104918.1">Here is a summary of the changes:

- General:  All chapters created with rst3 plugin.  This ensures a uniform look.  The source is in LeoDocs.leo.  Removed all references to older versions of Leo, except when discussing old file formats in the Appendices.  Corrected all text so it discusses present version.

- rst3 plugin itself:  Correct bug that caused chapters to be formatted differently when processing multiple @rst trees.  

- rst3 button in LeoDocs.leo:  The script first looks *up* the tree, looking for an @rst node.  If found, it processes just that tree.  If not found, it processes all @rst nodes *below* the originally selected node.  The button is now much more convenient to use.

- Preface: Shorter, no history.  No longer a dead end.

- What People are Saying About Leo: No longer a dead end.

- FAQ: Reorganized, simplified, revised.  Added entries for running Leo in a console window and debugging docutils.  Improved entry for using cvs.

- Chapter 1: Installation: Now the first chapter.  Revised.

- Chapter 2: Tutorial: Completely rewritten.  Like Python's tutorial, this chapter contains everything a beginner needs to understand and use Leo.  The `Quickstart for programmers` section is the heart of this chapter.  All terms used have links either to their definition in the tutorial or in the Glossary.  Newbies should be able to digest this chapter easily.  This chapter should make Leo comprehensible to many more people.

- Chapter 3: Using Outlines: Revised per general remarks above.

- Chapter 4: Writing Programs in Leo.  Completely rewritten.  The old chapter was an embarrassment. The new chapter is a reference guide, properly organized as such.  The introduction warns newbies away.

- Chapter 5: Using Leo's Commands.  'Minor' revisions and corrections create a substantially better result.

- Chapter 6: Leo and literate programming: Reformatting helps.  New words about rST markup and other improvements over traditional LP.

- Chapter 7: Scripting Leo with Python: Rewritten, simplified, updated and corrected.  The sources in LeoDocs.leo are directly executable.  rST sources use literal blocks instead of code-blocks so that the sources are simplified. (Important when executing examples).  Properly discusses positions, including 'supremely important' section on copying positions.

- Chapter 8: Customizing Leo.  Heavily revised.  Discusses leoSettings.leo, not leoConfig.txt.  Security warnings are more reasonable.  Section on script buttons. Rewrote section on uA's (Adding extensible attributes to nodes and .leo files).

- Chapter 9: History of Leo.  Rewritten.  Much shorter and more useful.  Discusses the major milestones, concentrating on explaining the major differences between versions.  Gone are details of how discoveries came to be.  They are in LeoPostings.leo, which will be included in the distribution.

- Chapter 10: Theory of Operation.  Largely rewritten.  Discusses positions properly.  Omits discussion of how clones were implemented before 4.2.

- Chapter 11: White Papers.  A new chapter.  This is a slightly-edited version of writing that had been buried in the appendices.

- Appendices.  Heavily revised and reformatted.  Rewrote sections on file formats.

- Glossary: A separate chapter.  All terms have links to their definition.  All definitions are rST targets so other chapters may refer to them.  Added several new entries.
</t>
<t tx="ekr.20050906104931.1"></t>
<t tx="ekr.20050906104931.15">http://sourceforge.net/forum/message.php?msg_id=3218558</t>
<t tx="ekr.20050906104931.38">The fix was to add an entry of 'unknown' state to state_dict. This fixes the
crash by brute force, but may not be strictly correct. However, this is pretty
much moot: we shall soon be moving to the new colorizer.</t>
<t tx="ekr.20050906104931.42">The code gets c = keywords.get('c') in several places.
The protection is to return if c is None.
This affects the following files: plugins_menu.py, pluginsTest.py, plugin_manager.py</t>
<t tx="ekr.20050906104931.43">http://sourceforge.net/forum/message.php?msg_id=3231597

test.leo had some non-@ignore'd @thin nodes for files not in the distribution.

- Only files used by unit tests should be on cvs and the distribution.
    - test\unittest\batchTest.py and test\unittest\errorTest.py were already on cvs.
    - Added these files to the distribution.

- Other test files should be distributed in @ignore nodes.

- Leo's distribution checklist now has an item to check that the distributed test.leo can be opened without errors.</t>
<t tx="ekr.20050906104931.48"></t>
<t tx="ekr.20050906104931.49">Calling print directly is dangerous: it will fail for unicode characters.</t>
<t tx="ekr.20050906104931.56">The new Pretty Print code has the following improvements:

- Strip trailing blanks in get.
- Many improvement to doOp.
- Improved DoMultiline:
    - Added special case logic to ensure '#' is preceded by space except at start of line.
    - Added blank after multi-line string if needed.
- Added lastName token for special-case handling depending on previous token.
- No change to put, putArray or doName.</t>
<t tx="ekr.20050906105335">-------------

|back| |leo| |next|</t>
<t tx="ekr.20050906105946">-------------

|back| |leo| |next|</t>
<t tx="ekr.20050907094633">Any .leo file may contain an ``@settings`` tree, so settings may be different for each commander.
Plugins and other scripts can get the value of settings as follows::

    format_headlines = c.config.getBool('rst3_format_headlines')
    g.es('format_headlines',format_headlines)

The ``c.config`` class has the following getters.
See the ``configSettings`` in ``leoCommands.py`` for details::

    getBool
    getColor
    getDirectory
    getFloat
    getInt
    getLanguage
    getRatio
    getShortcut
    getString

You can set any *existing* item in an ``@settings`` tree with ``c.config.set(p,setting,val)``.
For example::

    for val in (False,True):
        c.config.set(p,'rst3_format_headlines',val)
        format_headlines = c.config.getBool('rst3_format_headlines')
        g.es('format_headlines',format_headlines)

``c.config.set`` does not change the ``@settings`` tree; it simply changes the values returned by the getters.</t>
<t tx="ekr.20050907101918">``@test`` and ``@suite`` nodes are a major advance in unit testing. Such nodes
have headlines that start with ``@test`` or ``@suite``. The file ``test.leo``
contains many examples of ``@test`` and ``@suite`` nodes. ``@test`` and
``@suite`` nodes are a direct outgrowth of script buttons. The ``unit test``
script button in ``test.leo`` scans the selected outline, creating one unit test
for each ``test`` node and zero or more unit tests for each ``@suite`` node. The
``unit test`` script then runs all the selected unit tests.

``@test`` nodes
    ``@test`` nodes create a single unit test from the script in its body
    **without having to create a subclass of unittest.TestCase**.
    For example, here is a complete unit test.  The headline is::

        @test p.t == p.v.t

    The body text is::

        # NOTE: p.__getattr__ must be enabled for this test to work.
        root = c.rootPosition()
        for p in root.allNodes_iter():
            assert(p.t == p.v.t)

    **That's all!** The headline marks the node as containing a unit test.
    The body text contains the meat of the test.  No cruft at all!

    **Notes**: The unit tests created from ``@test`` nodes define ``setUp`` and
    ``tearDown`` methods. These methods ensure that the script being executed is
    the presently selected node. The scripts in ``@test`` nodes can not override
    the ``setUp`` and ``tearDown`` methods. In practice, this is not a problem
    because the scripts in ``@test`` nodes are typically very simple. Such
    scripts can use try/finally if they need to clean up after themselves.
    Scripts in ``@test`` nodes often assume that descendant nodes hold test
    data. Scripts in ``@test`` nodes can generally define and use sections, but
    scripts may not use the ``@others`` directive if descendant nodes hold
    data.
    
``@suite`` nodes
    ``@suite`` are an easy way to run legacy unit tests. The ``Unit Test``
    button assumes that the body text of an ``@suite`` node is a script that
    creates a test suite and leaves the result in ``g.app.scriptDict['suite']``.
    ``test.leo`` several examples of ``@suite nodes``.
    Here is an ``@suite`` node that executes all doctests in Leo's sources.
    The headline is::

        @suite run all doctests

    The body text is::

        import unittest
        import leoTest
        import sys
        
        # DocTestSuite exists in Python 2.3 and above.
        if g.CheckVersion(sys.version, "2.3"):
            path = g.os_path_join(g.app.loadDir,"..","src")
            modules = leoTest.importAllModulesInPath(path)
            suite = leoTest.createUnitTestsFromDoctests(modules)                     
            if suite:
                g.app.scriptDict['suite'] = suite
        else:
            # Create an empty suite to suppress a warning.
            g.app.scriptDict['suite'] = unittest.TestSuite()
            print "Can't create unit tests from doctests"
            print "doctest.DocTestSuite requires Python 2.3 or above."

    The real work of creating the test suites is done by
    ``leoTest.createUnitTestsFromDoctests``.
    **Important**: if the suite was created successfully, the script must pass the suite
    to script in the ``unit test`` script button by as follows::

            g.app.scriptDict['suite'] = suite

``@button unit test``
    The script in the ``Unit Test`` script button in ``test.leo`` is just::

        import leoTest
        leoTest.doTests(all=False)

    ``test.leo`` defines the ``leoTest`` module. The ``doTests`` function is the
    code that supports ``@test`` and ``@suite`` nodes. **Important**: you could
    customize how ``@test`` and ``@suite`` nodes work by using your own script
    in the ``@button unit test`` node.</t>
<t tx="ekr.20050908113904">This is a known bug in Tk that prevents this on Windows. The obvious Tk code
causes a hard crash in the Python dll: it's the only time Leo has taken such a
hard crash. The ``UniversalScrolling`` plugin is an attempt at a workaround.

Scrolling with the mouse wheel may be possible on Linux. See the code in
createTkTreeCanvas in leoTkinterFrame.py
</t>
<t tx="ekr.20050908164150"></t>
<t tx="ekr.20050908164150.1">See http://webpages.charter.net/edreamleo/rstplugin3.html for full documentation
of this plugin.

The rst3 plugin creates output files from Leo outlines containing
reStructuredText (rST) ReStructuredText is a simple and powerful text formatting
markup language. Outlines are a natural way to organize rST (or any text).

This plugin adds the Write Restructured Text command to Leo's Edit menu. The
Write Restructured Text command searches the selected outline looking for rst
root nodes whose headline have the form @rst &lt;filename&gt;. The plugin then creates
the named file in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically relieves you from one of the most
tedious chores in creating rST markup.

To use this plugin effectively, Python's docutils module must be installed. The
rst3 plugin will use the SilverCity syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.</t>
<t tx="ekr.20050908164150.2">This plugin now allows quotes within words, but strips quotes and other cruft
from the beginning and end of words. As a result, using the spellpyx spell
checker is much easier than before.

Leo's extensions folder now contains aspell23.pyd and aspell24.pyd. These are
Python dll's compiled for Python 2.3 and 2.4 respectively. You must rename one
of these files to be aspell.pyd and move aspell.pyd to the aspell folder. For
more details, see the installation nodes in the docstring for the spellpyx
plugin.</t>
<t tx="ekr.20050909082711">- Fixed bug with non-unicode characters in file name

    http://sourceforge.net/forum/message.php?msg_id=3224635
    
    Leo crashed try to read .leo files whose name contained non-ascii characters.

- Fixed bug with non-unicode characters in settings value

    http://sourceforge.net/forum/message.php?msg_id=3222750
    
    Leo crashed try to write settings whose values contained non-ascii characters.

- Fixed bug tangling sections with non-unicode characters.

    http://sourceforge.net/forum/message.php?msg_id=3307318</t>
<t tx="ekr.20050910143326">These plugins now use Python's subprocess module if it is present. The
subprocess module comes standard with Python 2.4. For Linux systems, Leo will
use subprocess.py in Leo's extensions folder if necessary.

For Windows systems you can install Python's subprocess module in Python 2.2 or
2.3 as follows:
    
    - Go to http://www.effbot.org/downloads/#subprocess

    - Download and execute one of the following installers, depending on your version of Python:
        subprocess-0.1-20041012.win32-py2.3.exe 
        subprocess-0.1-20041012.win32-py2.2.exe
        
This installer installs the subprocess sources and also _subprocess.pyd in Python's site-packages folder.
</t>
<t tx="ekr.20050912125144"></t>
<t tx="ekr.20050912125144.1">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

.. August 30, 2005

|back| |leo| |next|

##########################
Chapter 12: Plugins
##########################

This chapter discusses the plugins contained in leoPlugins.leo.
These plugins are part of Leo's official distribution.
`Chapter 8: Customizing Leo`_ tells how to write plugins.

.. contents::
</t>
<t tx="ekr.20050912125735">.. External links...

.. _docutils:             http://docutils.sourceforge.net
.. _LaTeX:                http://www.latex-project.org/
.. _reStructuredText:     http://docutils.sourceforge.net/rst.html
.. _SilverCity:           http://silvercity.sourceforge.net

.. Relative links...

.. _`Chapter 8\: Customizing Leo`:  customizing.html

.. WARNING: image targets may not have upper case letters!

.. _back:   whitepapers.html
.. _home:   front.html
.. _next:   appendices.html

.. |back| image:: arrow_lt.gif
    :target: back_

.. |leo|  image:: leo.gif
    :target: home_

.. |next| image:: arrow_rt.gif
    :target: next_</t>
<t tx="ekr.20050912125735.26"></t>
<t tx="ekr.20050912125735.28">This plugin adds a menu item under the File-&gt;Import menu to import
Cisco configuration files.
The plugin will:

1)  Create a new node, under the current node, where the configuration will be
    written. This node will typically have references to several sections (see below).

2)  Create sections (child nodes) for the indented blocks present in the original
    config file. These child nodes will have sub-nodes grouping similar blocks (e.g.
    there will be an 'interface' child node, with as many sub-nodes as there are real
    interfaces in the configuration file).

3)  Create sections for the custom keywords specified in the customBlocks[] list in
    importCiscoConfig(). You can modify this list to specify different keywords. DO
    NOT put keywords that are followed by indented blocks (these are taken care of by
    point 2 above). The negated form of the keywords (for example, if the keyword is
    'service', the negated form is 'no service') is also included in the sections.
    
    
4)  Not display consecutive empty comment lines (lines with only a '!').

All created sections are alphabetically ordered.</t>
<t tx="ekr.20050912125735.82">Supports new Leo directives.</t>
<t tx="ekr.20050912125735.85">This plugin manages BibTeX files with Leo. Create a bibliographic database by
putting ``@bibtex filename`` in a headline. Entries are added as nodes, with
``@entrytype key`` as the headline, and the contents of the entry in body text.
The plugin will automatically insert a template for the entry in the body pane
when a new entry is created (hooked to pressing enter when typing the headline
text). The templates are defined in dictionary ``templates`` in the \&lt;\&lt;globals\&gt;\&gt;
section, by default containing all required fields for every entry.

The file is written by double-clicking the node. Thus the following outline::

    -@bibtex biblio.bib
     +@book key
      author = {A. Uthor},
      year = 1999

will be written in the file 'biblio.bib' as::

    @book{key,
    author = {A. Uthor},
    year= 1999}

Strings are defined in ``@string`` nodes and they can contain multiple entries.
All ``@string`` nodes are written at the start of the file. Thus the following
outline::

    -@bibtext biblio.bib
     +@string
      j1 = {Journal}
     +@article AUj1
      author = {A. Uthor},
      journal = j1
     +@string
      j2 = {Journal2}
      j3 = {Journal3}
    
Will be written as::

    @string{j1 = {Journal1}}
    @string{j2 = {Journal2}}
    @string{j3 = {Journal3}}
    
    @article{AUj1,
    author = {A. Uthor},
    journal = j1}

No error checking is made on the syntax. The entries can be organised under
nodes--if the headline doesn't start with '@', the headline and body text are
ignored, but the child nodes are parsed as usual. BibTeX files can be imported
by creating an empty node with ``@bibtex filename`` in the headline.
Double-clicking it will read the file ``filename`` and parse it into a
``@bibtex`` tree. No syntax checking is made, ``filename`` is expected to be a
valid BibTeX file.</t>
<t tx="ekr.20050912125735.98">This plugin is enhances the EditAttributes.py plugin. It puts a command in
Outline called ConceptualSort. This will prompt you for a concept to sort by.
This gives the user some more flexibility in how they want to arrange their
nodes. Nodes without the attribute in question go to the bottom of the sort.
The user can:

- Select which attribute he wants to sort on by clicking on the Attribute box.

- Select the type of sort he wants by clicking on the radio buttons:

    -   Normal.
    -   Reversed. Like normal but the results are reversed.
    -   Used defined. For advanced users. The text box is where a user can type in
        their own python code to sort the nodes-attributes. There is no need for a
        def. That gets appended to the beginning of the code. It prototype looks
        like::

            def( a, b, att ):

where a and b are nodes and att is dictionary of the nodes and the respective
value of the selected attribute. There is no need to indent on the first level
since indentation is added at compile time.</t>
<t tx="ekr.20050912125735.113">Leo plugin that permits the definition of actions for double-clicking on file
nodes. Double-clicking in a ``@file`` node writes out the file if changes have
been made since the last save, and then runs a script on it, which is retrieved
from the outline. Scripts are located in a node whose headline is FileActions.
This node can be anywhere in the outline. If there is more than one such node,
the first one in outline order is used. The children of that node are expected
to contain a file pattern in the headline and the script to be executed in the
body. The file name is matched against the patterns (which are Unix-style shell
patterns), and the first matching node is selected. If the filename is a path,
only the last item is matched. Execution of the scripts is similar to the
``Execute Script`` command in Leo. The main difference is that the namespace in
which the scripts are run contains two elements:

-   ``filename``, which contains the filename from the ``@file`` directive.

-   ``shellScriptInWindow``, a utility function that runs
    a shell script in an external windows, thus permitting
    programs to be called that require user interaction

File actions are implemented for ``@file`` nodes and all its variants
(``@file-nosent``, ``@thin``, etc.). There is also a new node type
``@file-ref`` for referring to files purely for the purpose of
file actions, Leo does not do anything with or to such files.</t>
<t tx="ekr.20050912125735.129">A Leo Plugin that adds Group commands functionality.  Restrictions currently apply to using Leo with a Tk front end.
There are several commands in this plugin:

-   Mark Node: marks a node for further operations such as copying, cloning and moving.

-   Mark Spot: marks a node as the place where group operations are to target.

-   Operate On Marked: moves lassoed nodes to the spot where the roundup node is
    placed. Clones are maintained.

-   Clear Marked: unmarks all marked nodes and removes the roundup node.

-   Transfer Lassoed Nodes: this is a menu for inter-window communication.
    The windows must all be spawned from the same Leo instance. 
    It allows the user to move all node marked for copying and moving from another window to this one.</t>
<t tx="ekr.20050912125735.164">Creates new nodes containing parameterized section references.
</t>
<t tx="ekr.20050912125735.172">This plugin allows Leo to read a complete directory's outline into a Leo's
Outline. Directories are converted into headlines and files names are listed
into the bodies.</t>
<t tx="ekr.20050912125735.184">Timestamp all save operations to show when they occur.</t>
<t tx="ekr.20050912125735.186">Modify the way exported outlines are displayed.</t>
<t tx="ekr.20050912125735.188">A plugin that helps customize pretty printing. It creates a do-nothing subclass
of the default pretty printer. To customize, simply override in this file the
methods of the base prettyPrinter class in leoCommands.py. You would typically
want to override putNormalToken or its allies. Templates for these methods have
been provided. You may, however, override any methods you like. You could even
define your own class entirely, provided you implement the prettyPrintNode
method.
</t>
<t tx="ekr.20050912125735.204">A plugin to schedule commands for later execution. It's provides the ability to
issue commands at a future time and to write messages that will be displayed at
a later time. To record commands You goto Schedule and choose begin recording.
Then you jump to the nodes and select the commands you want issued on them. This
process is ended with the end recording option. A dialog pops up. You can then
click on the individual commands and set the time for execution. To set the
execution time for all, enter a value and hit set_all. All times must be in the
form hh:mm. For example I want to issue a save command for 5:00 PM. I would do
so by using the value 17:00. The Schedule Message is simple. There is a Text box
to enter the message and a Entry to place the time. View Queue will summon a
view of The Queue. This dialog will show the commands that have been enqueued.
There is also the option to Cancel out any scheduled commands/messages.</t>
<t tx="ekr.20050912125735.225">This plugin lets you add customizable templates to an outline. Templates are
like any other node except that the plugin replaces %s in the body text by
values that you specify when using template. Templates may have section
references; this plugin uses Leo's ``@nosent`` write machinery to create one
string out of possibly many nodes. This plugin requires the simplified atFile
write code that is new in 4.2.1.

This plugin creates two buttons in Leo's icon area:

- The '%s' button marks or unmarks a node as a template. A %s symbol will appear to
  the left of the node when it is marked as a template.

- The '----&gt; %s' button brings up a dialog that shows you the template text and
  asks you to specify the value for all %s instances. Dismissing this dialog
  inserts the template as the first child of the node, and creates a section
  reference in the node that references the template.

If a template does not have a '%s' in it, then the templates plugin just adds
the text as a node. Templates once marked are stored across sessions. Do not put
a template in a thin file, as your template mark will be erased between
sessions.

</t>
<t tx="ekr.20050912125735.245">This plugin adds **date nodes** (nodes with dates as their headlines) to the
current outline. Date nodes may be added one at a time, a month's-worth at a
time, or a year's-worth at a time. The format of the headlines is
configurable in the ini file.</t>
<t tx="ekr.20050912125735.273">A plugin to store Leo trees in anydbm files. Note: there isn't such a thing as an
anydbm file: it's whatever the anydbm module uses.
Under Outline, there is an option called ``Library``. This will open a
dialog with a list of the trees that you have saved. You can insert trees stored
in the library, remove them and add trees to the library. Be aware of unicode,
any characters outside of the ascii set gets turned into a ?. I found this
problem in storing some trees from Edward's Leo outline. Id like it to be able to
store unicode, but that may require a more specific db background, than anydbm.
Also note, that your library files may not be OS independent. If your python
distribution does not have the backing db on another machine, it will not be
able to open your library.
This should help people develop templates that they want to reuse between Leo
projects.  For example, Id like a template of many Java interfaces to be easily
accessible.</t>
<t tx="ekr.20050912125735.314">Autosave the Leo document every so often. The time between saves is given in
seconds in autosave.ini.</t>
<t tx="ekr.20050912125735.318">This plugin puts the View Table command in the Outline menu. This command checks
the current node using the csv (comma separated values) mods Sniffer. It tries
to determine the format that is in the nodes data. If you had excel data in it,
it should be able to determine its excel data. It then creates a dialog with the
data presented as in a table for the user to see it. Requires Pmw and the
tktable widget at http://sourceforge.net/projects/tktable.
</t>
<t tx="ekr.20050912125735.334"></t>
<t tx="ekr.20050912125735.335">A plugin to test import problems.</t>
<t tx="ekr.20050912125735.336">Dump Python globals at startup.</t>
<t tx="ekr.20050912125735.338">Enable debugging and tracing for Python's garbage collector.</t>
<t tx="ekr.20050912125735.341">Trace changes to Leo's objects at idle time.</t>
<t tx="ekr.20050912125735.344">Trace keystrokes in the outline and body panes.</t>
<t tx="ekr.20050912125735.346">Trace the most common hooks, but not key, drag or idle hooks.</t>
<t tx="ekr.20050912125735.363">The dyna_menu plugin is a remarkable body of work by 'e'.
This plugin creates a dyna_menu menu from which you can execute commands.
You may download the latest version at: http://rclick.netfirms.com/dyna_menu.py.html</t>
<t tx="ekr.20050912125735.525"></t>
<t tx="ekr.20050912125735.526">Synchronizes ``@folder`` nodes with folders. If a node is named ``@folder
path_to_folder``, the content (filenames) of the folder and the children of that
node will be sync. Whenever a new file is put there, a new node will appear on
top of the children list (with mark). So that I can put my description (i.e.,
annotation) as the content of that node. In this way, I can find any files much
easier from leo. Moreover, I add another feature to allow you to group files(in
leo) into children of another group. This will help when there are many files in
that folder. You can logically group it in leo (or even clone it to many
groups), while keep every files in a flat/single directory on your computer.
</t>
<t tx="ekr.20050912125735.529">Executes commands in nodes whose body text starts with ``@produce``.
To use, put in the body text of a node::

    @produce javac -verbose Test.java

To execute, you goto Outline and look at Produce. Choose Execute All Produce or
Execute Tree Produce. The Tree does the current Tree, All does the whole
Outline. Executing will fire javac, or whatever your using. ``@produce`` functions
as a directive. After executing, a log file/node is created at the top of the
Outline. Any output, even error messages, should be there. It executes in a
hierarchal manner. Nodes that come before that contain ``@produce`` go first. I'm
hoping that this orthogonal to ``@run`` nodes and anything like that. Its not
intended as a replacement for make or Ant, but as a simple substitute when that
machinery is overkill. **Warning**: trying to execute a non-existent command
will hang Leo.</t>
<t tx="ekr.20050912125735.540">A plugin that supports ``@clip``, ``@view`` and ``@strip`` nodes.

-   Selecting a headline containing ``@clip`` appends the contents of the clipboard to
    the end of the body pane.

-   Double clicking the icon box of a node whose headline contains ``@view &lt;path-to-file&gt;``
    places the contents of the file in the body pane.

-   Double clicking the icon box of a node whose headline contains ``@strip &lt;path-to-file&gt;``
    places the contents of the file in the body pane, with all sentinels removed.

This plugin also accumulates the effect of all ``@path`` nodes.</t>
<t tx="ekr.20050912125735.556">This plugin allows the user to import binary data and store it in Leo as a
base64 string. This plugin adds ``Import base64`` and ``Export base64`` commands
to the Import menu and adds the 'View base64' command to the outline menu. The
Import base64 command creates a new node with the headline::

    @base64 &lt;filename&gt;

The body of this node will kill the colorizer, add some info on the original
file and create a section reference to the payload node, which contains the
data. The Export base64 command asks for a location to place the file. The
plugin checks that the structure of the base64 node is what it expected,
basically what an import operation creates. If Ok, it will write the file to the
selected directory. The View base64 command brings up a Pmw Dialog that displays
the data as a PhotoImage. This currently only supports formats recognized by the
PhotoImage class. This would be the .gif format. This functionality may be
enhanced in the future by PIL to support more image types. Depending on the size
of the image, you may have to scroll around to see it. For example, a leo clone
icon will require scrolling to find. Id like to change this in the future.</t>
<t tx="ekr.20050912125735.565">A Leo plugin that adds quick utility commands through a pop-up menu.
To summon Menu, type control-space.
To unsummon, Right Click.
    
1. Movement. If a node has ancestors,siblings or children a menu option will
appear offering the user the ability to jump to the node from the current node.
This is an improvement over moving one node at a time with the keyboard
commands.

2. Inserting text. These menus offer the current language keywords, the
directives the body recognizes and any ``@file`` type headline directives. It offers
the new user easy access to the different directives and ways to write a file.

3. Moving Nodes(experimental). You can quickly move a node to its
parent's parent or after a sibling, if they exist.</t>
<t tx="ekr.20050912125735.597">This plugin allows you to associate information with nodes. This information is
organized around "labels", which is are just strings and freely chosen by the
user. The plugin allows you to create such a label quickly for each marked node,
and to mark all nodes which have a certain label. Labels can be converted to
subnodes, and vice versa. This facility allows you to add additional information
for each label. You can create clones for each node which has a label. These
clones are created as children of the current node. This last facility can be
used to create clones for each node which has been found or changed by the
standard search/replace dialog:

- Delete all marks.
- Do a "find all" / "change all".
- Convert the marks to a label.
- Run the "Clone label subnodes" command.

Finally, if you read a derived file, and the content of a node changes, the
previous content is available under the label "before change:"</t>
<t tx="ekr.20050912125735.647">A plugin to create and update ``@read-only`` nodes. I wanted to have the ability to
import files in "read-only" mode, that is, in a mode where files could only be
read by leo (not tangled), and also kept in sync with the content on the drive.
The reason for this is for example that I have external programs that generate
resource files. I want these files to be part of a leo outline, but I don't want
leo to tangle or in any way modify them. At the same time, I want them to be
up-to-date in the leo outline. This plugin has the following characteristics:

- It reads the specified file and puts it into the node content.

- If the ``@read-only`` directive was in the leo outline already, and the file content
  on disk has changed from what is stored in the outline, it marks the node as
  changed and prints a "changed" message to the log window; if, on the other hand,
  the file content has *not* changed, the file is simply read and the node is
  not marked as changed.

- When you write a ``@read-only`` directive, the file content is added to the node
  immediately, i.e. as soon as you press Enter (no need to call a menu
  entry to import the content).

- If you want to refresh/update the content of the file, just edit the headline
  and press Enter. The file is reloaded, and if in the meantime it has changed,
  a "change" message is sent to the log window.

- The body text of a ``@read-only`` file cannot be modified in leo.

The syntax to access files in ``@read-only`` via ftp/http is the following::

    @read-only http://www.ietf.org/rfc/rfc0791.txt
    @read-only ftp://ftp.someserver.org/filepath

If FTP authentication (username/password) is required, it can be specified as follows::

    @read-only ftp://username:password@ftp.someserver.org/filepath</t>
<t tx="ekr.20050912125735.674">Runs a program and interface Leo through its input/output/error streams.
Double clicking the icon box whose headlines are ``@run 'cmd args'`` will execute
the command. There are several other features, including ``@arg`` and ``@input`` nodes.

The run_nodes.py plugin introduce two new nodes that transform leo into a
terminal. It was mostly intended to run compilers and debuggers while having the
possibility to send messages to the program.

- Double clicking on the icon of an node whose headline is::

    @run &lt;command&gt; &lt;args&gt;

will launch &lt;command&gt; with the given arguments. It will also mark the node. #
Terminates the argument list. ``@run # &lt;comment&gt;`` is also valid.

- ``@in`` nodes are used to send input to the running process. Double clicking
  on the icon of an ``@in &lt;message&gt;`` node will append a "\n" to &lt;message&gt; and
  write it to the program, no matter where the node is placed. If no ``@run`` node is
  active, nothing happens.

- The body text of every child, in which the headlines do not begin with ``@run``
  or ``@in``, will be appended to &lt;command&gt;, allowing you to add an infinite number
  of arguments to &lt;command&gt;.

- The output of the program is written in the log pane (Error outputted in red).
  When the program exit the node is set unmarked and the return value is
  displayed...When the enter key is pressed in the body pane of an active ``@run``
  node the content of it body pane is written to the program and then emptied
  ready for another line of input. If the node have ``@run`` nodes in its descendants,
  they will be launched successively (unless one returned an exit code other
  than 0, then it will stop there).</t>
<t tx="ekr.20050912125735.694">Launches (starts) a file given by a headline when double-clicking the icon.
Ignores headlines starting with an '@'. Uses the ``@folder`` path if the headline
is under an ``@folder`` headline. Otherwise the path is relative to the Leo file.
</t>
<t tx="ekr.20050912125735.699">The AutoTrees plugin is a helper plugin designed to make it very easy to write
"handler" plugins to manage dynamic content in Leo outlines. AutoTrees provides:

- Convenient handler base classes which can be specialized for particular uses.
- A manager to turn handlers on and off.
- A set of example handlers to show the kinds of things that are possible.

AutoTrees doesn't do anything that you cannot do in other ways, but it does
provide a consistent way of adding dynamic content. This means that individual
plugin writers don't have to rewrite all the same kinds of code each time and
also makes it easier to maintain Leo, since it standardizes the way that certain
classes of plugin interact with the Leo core. Why use this? I'm a plugin writer
and I want to write a plugin to display dynamic content, i.e., content not
directly contained in the .leo or derived files, e.g.,

- email messages 
- news feeds
- news groups
- documentation
- remote files
- statistics
- file system data
- data base records

You can do this as a standard plugin, but as an AutoTrees handler you,

- don't need to write code that interacts with the tree (this is done for you)
- get centralized management
- can still do everything else you could as a normal plugin
</t>
<t tx="ekr.20050912125735.868"></t>
<t tx="ekr.20050912125735.869">Rebinds up/down arrow keys.</t>
<t tx="ekr.20050912125735.874">Handles images in body text. Based on work by Gil Shwartz. Brent Burley provided
many important insights. See:
http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52264</t>
<t tx="ekr.20050912125735.880">Create a context menu when right-clicking in the body pane.</t>
<t tx="ekr.20050912125735.904">Autocompletion and calltips plugin.

- ``.`` summons the autocompletion.
- ``(`` summons the calltips
- ``Escape`` closes either box.
- ``Ctrl`` selects an item.
- ``alt-up_arrow``, ``alt-down_arrow`` move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocompleter.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesn't find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleter's runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.</t>
<t tx="ekr.20050912125735.942">Handle coloring for markup in doc parts and Python triple-double-quoted strings.

**Important**:

- This plugin requires that the ``add_directives`` plugin is enabled.

- To color a text with wiki markup the text must be in the range of an ``@markup wiki`` directive.

The currently supported markups are::

    ''text''                    # write text in italics
    __text__                    # write text in bold
    ~~&lt;color&gt;:text~~            # write text in the color specified by &lt;color&gt; (e.g. blue, grey, etc)
    {picture file=&lt;filename&gt;}   # load the picture indicated by &lt;filename&gt;
    http://url                  # URL support: double clicking on the url will open it in the default browser.
    https://url                 # URL support: double clicking on the url will open it in the default browser.
    
-   Note 1: italics and bold markups can be nested, e.g.,::

        ''__text__''            # write text in italics and bold

    Just remember to terminate the tags in the order they were opened.

- Note 2: URLs must be terminated by a space.

By default, once the text has been markup up, the actual tags (e.g. ``__`` for
bold) are not displayed anymore. You can choose to display them selecting "Show
Invisibles" from the Edit menu.</t>
<t tx="ekr.20050912125735.974">Send output from the Execute Script command to the end of the body pane.</t>
<t tx="ekr.20050912125735.980"></t>
<t tx="ekr.20050912125735.981">Adds navigation buttons to icon bar.</t>
<t tx="ekr.20050912125735.1008">Automatically add nodes for common tasks.</t>
<t tx="ekr.20050912125735.1041">Add Hoist/De-Hoist buttons to the toolbar.
</t>
<t tx="ekr.20050912125735.1050">Adds "Recent" and "Marks" pulldown buttons to the toolbar.</t>
<t tx="ekr.20050912125735.1072">Adds a quick search to Leo's toolbar, along with a "GO" button to do quick
searches right from the main Leo window. All the current search options are
retained except that "search body text" is explicitly set - mainly because this
is by far the most common use case. Pressing &lt;CR&gt; while editing the text
automatically does a search. Repeated searches can be done by clicking the "GO"
button. The combo box also stores a list of previous searches, which can be
selected to quickly repeat a search. When activating a previous search the
original search mode is used.
</t>
<t tx="ekr.20050912125735.1092">This plugin supports Uniform Node Locators (UNL's). UNL's specify nodes within
Leo files. UNL's are not limited to nodes within the present Leo file; you can
use them to create cross-Leo-file links. This plugin consists of two parts:

1) Selecting a node shows the UNL in the status line at the bottom of the Leo
   window. You can copy from the status line and paste it into headlines, emails,
   whatever. 

2) Double-clicking ``@url`` nodes containing UNL's select the node specified in the
   UNL. If the UNL species in another Leo file, the other file will be opened.

UNL's referring to nodes within the present outline have the form::

    headline1--&gt;headline2--&gt;...--&gt;headlineN

where headline1 is the headline of a top-level node, and each successive headline is
the headline of a child node.  UNL's of the form::

    file:&lt;path&gt;#headline1--&gt;...--&gt;headlineN

refer to a node specified in &lt;path&gt; For example, double clicking the following
headline will take you to Chapter 8 of Leo's Users Guide::

    @url file:c:/prog/leoCvs/leo/doc/leoDocs.leo#Users Guide--&gt;Chapter 8: Customizing Leo
    
For example, suppose you want to email someone with comments about a Leo file.
Create a comments.leo file containing ``@url UNL`` nodes. That is, headlines are
``@url`` followed by a UNL. The body text contains your comments about the nodes in
the _other_ Leo file! Send the comments.leo to your friend, who can use the
comments.leo file to quickly navigate to the various nodes you are talking
about. As another example, you can copy UNL's into emails. The recipient can
navigate to the nodes 'by hand' by following the arrows in the UNL.

**Notes**:

- At present, UNL's refer to nodes by their position in the outline. Moving a
  node will break the link.

- Don't refer to nodes that contain UNL's in the headline. Instead, refer to the
  parent or child of such nodes.

- You don't have to replace spaces in URL's or UNL's by '%20'.</t>
<t tx="ekr.20050912125735.1105"></t>
<t tx="ekr.20050912125735.1135">Cleo allows you to annotate or colour leo outlines based on priority, code
archetype, node types or some arbitrary criteria. The annotations and colour
coding can play a similar role like that of syntax highlighting. Right-click on
the icon area to popup its menu to play with it.</t>
<t tx="ekr.20050912125735.1187">A plugin to leave footprints! This colours the Leo nodes so that the ones you
have visited most and most recently will stand out.</t>
<t tx="ekr.20050912125735.1205">This plugin creates separate outlines called "chapters" within a single .leo
file. Clones work between Chapters. **Warning**: This plugin must be considered
**buggy** and **unsafe**. Use with extreme caution.

Numbered tabs at the top of the body pane represent each chapter. Right clicking
the tab will show a popup menu containing commands. These commands allow you
to:
    
- insert and delete chapters.
- add names to chapters.
- split the body pane to create multiple "editors".
- create a "trash barrel that hold all deleted nodes.
- import and export outlines and chapters.
- create a pdf file from your chapters (requires reportlab toolkit at http://www.reportlab.org).
- and more...
 
**Warnings**:

- This plugin must be considered **buggy** and **unsafe**. Use with extreme caution.
- This plugin makes substantial changes to Leo's core.
- Outlines containing multiple chapters are stored as a zipped file that can only be read when this plugin has been enabled.</t>
<t tx="ekr.20050912125735.1285">A plugin that lets the user to associate text with a specific node.
Summon it by pressing button-2 or button-3 on an icon Box in the outline. This
will create an attribute editor where the user can add, remove and edit
attributes. Since attributes use the underlying tnode, clones will share the
attributes of one another.</t>
<t tx="ekr.20050912125735.1299">Maximizes all new windows.</t>
<t tx="ekr.20050912125735.1301">The nodebar plugin adds buttons at the bottom of the tree canvas. The buttons
correspond to commands found in the Outline commands. It is intended to speed up
a new users ability to use the outline. Experienced users may find value in
being able to quickly execute commands they do not use very often.</t>
<t tx="ekr.20050912125735.1316">Send all output to the log pane.</t>
<t tx="ekr.20050912125735.1317">Turns the log into a tabbed component.  Other plugins may add tabs.
To get a new tab in TabbedLog::

    import TabbedLog
    pane = TabbedLog.getPane(name,c)

- ``pane`` is the pane returned for you to work with.
- ``name`` is the name of the tab you want for the pane.
- ``c`` is the commander for the leoFrame.</t>
<t tx="ekr.20050912125735.1323">A plugin for searching unknownAttributes (uA's).</t>
<t tx="ekr.20050912125735.1333">A plugin that enables the user to scroll down with a left mouse click and hold,
and to scroll up with a right mouse click and hold. Scrolling continues until
the user releases the mouse. Originally designed as a workaround for various
bugs in Tkinter scrolling, this may actually be superior to wheel scrolling, in
that there is little work a user has to do to scroll except to press a button.</t>
<t tx="ekr.20050912125735.1342">This plugin uses Python's urllib module to download files and import them into Leo.
It requires the TabbedLog plugin.
</t>
<t tx="ekr.20050912125735.2712"></t>
<t tx="ekr.20050912125735.2713">Replaces ``Commands.openWithTempFilePath`` so Leo opens temporary
files with a filename that begins with the headline text, and
located in a ``username_Leo`` subdirectory of the temporary
directory. The ``LeoTemp`` prefix is omitted.  This makes it easier to
see which temporary file is related to which outline node.</t>
<t tx="ekr.20050912125735.2716">Creates an 'extensions' menu with commands to open either an xterm on Linux
or a cmd windows/explorer window on win32 in the directory of the current ``@file`` node.
This allows quick navigation to facilitate testing and navigating large systems
with complex directories.</t>
<t tx="ekr.20050912125735.2726">Create menu for Open With command and handle the resulting commands.
This code will take advantage of Python's new subprocess module if it is
present. This module comes standard with Python 2.4. For Linux systems, Leo will
use subprocess.py in Leo's extensions folder if necessary.</t>
<t tx="ekr.20050912125735.2736">A plugin that communicates with VIM:
    
- Double clicking on a node's icon opens that node in VIM. You can open nodes in
  VIM with a single-click if you set useDoubleClick = False. However, that
  interferes with Leo's dragging logic.

- Leo will update the node in the outline when you save the file in VIM.</t>
<t tx="ekr.20050912125735.2743">This plugin allows you to edit nodes in emacs/xemacs.
Depending on your preference, selecting or double-clicking a node will pass the
body text of that node to emacs. You may edit the node in the emacs buffer and
changes will appear in Leo.</t>
<t tx="ekr.20050912125735.2749">Use commands in the ``Plugins:Word Export:Export`` menu to formats and export
the selected outline to a Word document, starting Word if necessary.</t>
<t tx="ekr.20050912125735.2759"></t>
<t tx="ekr.20050912125735.2760">Opens any empty file as a minimal .leo file.</t>
<t tx="ekr.20050912125735.2763">Adds #line directives in perl and perlpod programs.
Currently supports only perl and perlpod.</t>
<t tx="ekr.20050912125735.2768">Multipath enables the ability to write a file to multiple locations. It acts as
a post-write mechanism, a file must be written to the file system for it to work.
At this point it is not a replacement for ``@path`` or an absolute path, it works in
tandem with them. To use, place ``@multipath`` at the start of a line in the root
node or an ancestor of the node. The format is (On Unix systems)::
    
    @multipath /machine/unit/:/machine/robot/:/machine/
    
It will place a copy of the written file in each of these directories.

There is an additional directive that simplifies common paths, it is called
``@multiprefix``. By typing ``@multiprefix`` with a path following it, before a
``@multipath`` directive you set the beginning of the paths in the
``@multipath`` directive. For example::

    @multiprefix /leo #@multipath /plugins 

or::

    @multiprefix /leo/
    @multipath plugins: fungus : drain

copies a file to /leo/plugins /leo/fungus /leo/drain.

The ``@multiprefix`` stays in effect for the entire tree until reset with
another ``@multiprefix`` directive. ``@multipath`` is cumulative, in that for
each ``@multipath`` in an ancestor a copy of the file is created. These
directives must at the beginning of the line and by themselves.</t>
<t tx="ekr.20050912125735.2779">Preprocess ``@file-nosent`` nodes: make sure each subnode ends
with exactly one newline, replace all tabs with spaces, and
add a newline before class and functions in the derived file.
</t>
<t tx="ekr.20050912125735.2786">LeoN is Leo over the Network. LeoN is Collaborative Leo. This is an important
project for Leo's long-term development. See leo/doc/LeoN for important research
papers that form the basis of this project.</t>
<t tx="ekr.20050912125735.2826"></t>
<t tx="ekr.20050912125735.2828">Translate a few menu items into Simplified Chinese
本插件将部分Leo菜单翻译成简体中文
By Zhang Le &lt;ejoy@xinhuanet.com&gt;</t>
<t tx="ekr.20050912125735.2836">Traduit les menus en Français.</t>
<t tx="ekr.20050912125735.2844">Adds pie menus.  See http://www.piemenus.com/</t>
<t tx="ekr.20050912125735.2867"></t>
<t tx="ekr.20050912125735.2869">Create a Plugins menu and adds an item to the plugin menu for each active
plugin. Selecting this menu item will bring up a short About dialog with the
details of the plugin. Plugins can create additional menu items by defining
functions named ``cmd_XZY``. These will appear in a submenu. If the plugin
requires an INI file then a configure menu item will be created which will show
an INI file editor. The plugin can define an ``applyConfiguration`` function,
which will be called when the configuration changes. Plugins can also define a
top level function to be called instead of the default "About" dialog by
defining a "topLevelMenu" function in the plugin. This function will be called
when the user clicks on the plugin name in the plugins menu, but only if the
plugin was loaded properly and registered with ``g.plugin_signon``.

Plugins can define their name by setting the ``__plugin_name__`` property.
Plugins can also attempt to select the order they will appear in the menu by
defining a ``__plugin_prioriy__``. The menu will be created with the highest
priority items first. This behaviour is not guaranteed since other plugins can
define any priority. This priority does not affect the order of calling
handlers. To change the order select a number outside the range 0-200 since this
range is used internally for sorting alphabetically.</t>
<t tx="ekr.20050912125735.2918">A plugin to manage Leo's Plugins:

- Enables and disables plugins.
- Shows plugin details.
- Checks for conflicting hook handlers.
- Checks for and updates plugins from the web.
</t>
<t tx="ekr.20050912125735.3040">A plugin to automatically update Leo from the current CVS version
of the code stored on the SourceForge site. You can view individual
files and update your entire Leo installation directly without needing
a CVS client.</t>
<t tx="ekr.20050912125735.3056"></t>
<t tx="ekr.20050912125735.3057">A plugin to create script buttons and ``@button``, ``@plugin`` and ``@script`` nodes.
This plugin puts two buttons in the icon area: a button called ``run Script`` and
a button called ``script Button``. The ``run Script`` button is simply another way
of doing the Execute Script command: it executes the selected text of the
presently selected node, or the entire text if no text is selected. The 'script
Button' button creates another button in the icon area every time you push it.
The name of the button is the headline of the presently selected node. Hitting
this _new_ button executes the button's script.

For example, to run a script on any part of an outline do the following:

1.  Select the node containing the script.
2.  Press the scriptButton button.  This will create a new button, call it X.
3.  Select the node on which you want to run the script.
4.  Push button X.

That's all.  You can delete a script button by right-clicking on it.
This plugin optionally scans for ``@button`` nodes, ``@plugin`` nodes and ``@script`` nodes
whenever a .leo file is opened.

- ``@button`` nodes create script buttons.
- ``@plugin`` nodes cause plugins to be loaded.
- ``@script`` nodes cause a script to be executed when opening a .leo file.

Such nodes may be security risks. This plugin scans for such nodes only if the
corresponding atButtonNodes, atPluginNodes, and atScriptNodes constants are set
to True in this plugin.</t>
<t tx="ekr.20050912125735.3077"></t>
<t tx="ekr.20050912125735.3078">A minimal http plugin for LEO, based on AsyncHttpServer.py.
Use this plugin is as follows:

1. Start Leo with the plugin enabled.  You will see a purple message that says something like::

    http serving enabled on port 8080, version 0.91

2. Start a web browser, and enter the following url: http://localhost:8080/ You
   will see a a "top" level page containing one link for every open .leo
   file.  Start clicking :-)

You can use the browser's refresh button to update the top-level view in the browser after you have opened or closed files.

To enable this plugin put this into your file::

    @settings
        @page http plugin
        @bool http_active = True
        @int  port = 8080
        @string rst_http_attributename = 'rst_http_attribute'</t>
<t tx="ekr.20050912125735.3136"></t>
<t tx="ekr.20050912125735.3138">aspell.pyx: Leo's new spell checking plugin that uses aspell.exe. It is much
faster than the old mod_spelling plugin, but requires Python 2.3 or above and a
recent version of Aspell. When properly installed and enabled, this plugin adds
a Check Spelling command to Leo's Edit menu. This command brings up a spell
checking dialog. You can set options by changing entries in spellpyx.ini in
Leo's plugins menu. One of these settings is the name of the dictionary,
spellpyx.txt by default. **Warning**: do not create spellpyx.txt with an ``@asis``
tree in leoPlugins.leo: only the plugin code should typically change
spellpyx.txt. You **can** edit ``spellpyx.txt`` yourself in an external editor: just
make sure that Leo isn't running when you do this. You can bring up the spell
checker without enabling the spellpyx plugin by using an ``@button Check
Spelling...`` script button. LeoDocs.leo contains such a script button.</t>
<t tx="ekr.20050912125735.3209">``temacs`` is a binding module for the Tkinter Text widget.
``usetemacs`` is a Leo plugin that patches the temacs modules Emacs emulation
into the standard Leo Tkinter Text editor.</t>
<t tx="ekr.20050912125735.3559"></t>
<t tx="ekr.20050912125735.3621">Adds XSLT-Node Command submenu item to the Outline menu.
This menu contains the following items:
    
``Set StyleSheet Node``
    Selects the current node as the xsl stylesheet the plugin will use.

``Process Node with Stylesheet Node``
    Processes the current node as an xml document,
    resolving section references and Leo directives,
    and creates a sibling containing the results.

Requires 4Suite 1.0a3 or better, downloadable from http://4Suite.org.</t>
<t tx="ekr.20050912125735.3642">Leo2AsciiDoc is a small Python program which has been built to be used as a
plugin module for the Leo outlining editor.
For more information see:  http://www.marshallresearch.com/michael-dawson/os/leo.html
I am still using Leo version 4.1 (rc3, build 1.62), as I've been unable to keep
up with the speed of Edward's Leo development. He has made such significant
changes to Leo since 4.1 that I doubt that Leo2AsciiDoc will work with any
version later than 4.1. I do intend to rewrite Leo2AsciiDoc for the new Leo, but
there is no schedule set. 

Leo2AscDoc enables the contents of plain text Leo outlines to be published to HTML
or PDF via the AsciiDoc program and the DocBook set of publishing tools. Plain
text from the Leo outline can be transformed into a final result that has
typeset body text, in which bulleted and numbered lists, variable lists, page
numbers, URLs, index terms,and bold and italic text are automatically
recognized. typeset Headings a Table of Contents an Index containing any items
marked by the user, and any Python classes or functions. To produce HTML and
PDF, you'll need to have the AsciiDoc program installed (a trivial task) and a
DocBook tool chain installed, which is not a trivial task. And, of course,
Python and Leo. In sum, this little program is an easy install for people who
are already using Leo and DocBook. As noted later, Leo2AsciiDoc has only been
tested on Linux</t>
<t tx="ekr.20050912125735.3832">The rst3 plugin creates output files from Leo outlines containing rST
(reStructuredText_) markup. rst3 options control most aspects of this plugin's
operations. You can set options in ``@settings`` trees, in headlines and in body
text. There are too many options to describe here. See:
http://webpages.charter.net/edreamleo/rstplugin3.html for full documentation. To
use this plugin effectively, Python's docutils_ module must be installed. The
rst3 plugin will use the SilverCity_ syntax coloring package if it installed.

The rst3 plugin adds the ``Write Restructured Text`` command to Leo's Edit menu.
This command searches the selected outline looking for **rst root nodes** whose
headline have the form::

    @rst &lt;filename&gt;

The plugin then creates the named file in various ways depending which rst3
options are in effect. By default, the rst3 plugin creates rST headings
automatically from outlines, so the higher-level nodes in the outline correspond
to higher-level sections in the output. Creating rST headings automatically
eliminates one of the most tedious chores associated with rST markup.
This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.</t>
<t tx="ekr.20050912125735.3944"></t>
<t tx="ekr.20050912125735.3945">An experimental plugin that stores all Leo outline data in a single zodb
database. This plugin replaces the Open, Save and Revert commands with methods
that access the zodb database.</t>
<t tx="ekr.20050912133515">-----------------------

|back| |leo| |next|</t>
<t tx="ekr.20050913131848">Leo 4.3.2 final                 September 16, 2005

To learn about Leo, see: http://webpages.charter.net/edreamleo/intro.html

The highlights of 4.3.2:
-----------------------

- Improved Leo's documentation:
    - A tutorial introduction to Leo:
      http://webpages.charter.net/edreamleo/intro.html
    - A 5-minute guide to programming with Leo:
      http://webpages.charter.net/edreamleo/intro.html#quick-start-for-programmers

- The new rst3 plugin creates .html and .tex files from reStructuredText
  embedded in Leo files. Any node of the source outline may contain options for
  the rst3 plugin, which makes this plugin much more useful and flexible than
  the previous rst plugins. All of Leo's documentation was created using this
  plugin from sources in LeoDocs.leo. For full documentation for rst3 see:
  http://webpages.charter.net/edreamleo/rstplugin3.html.

- The spellpyx (spell checking) plugin is now much easier to use.

- The vim and openWith plugins now use Python's subprocess module if it is present.
 
- Improved the Pretty Printing command.

- The usual assortment of bug fixes.</t>
<t tx="ekr.20050914132220"></t>
<t tx="ekr.20050916065715">@killcolor
https://sourceforge.net/forum/message.php?msg_id=3341105
By: rogererens

Here would be a nice place to insert 2 screenshots that illustrate the points
discussed: one of a very small @thin tree in Leo, and one of the contents of
the file that's derived from that node, as seen in vim or jEdit or notepad.

Also the paragraph on clones might benefit from a screen shot or two, especially
since the tutorial contains a lot of text and ideas to grasp. Pictures in between
give the opportunity to ponder on the meaning of all that for a while while
staring at them...</t>
<t tx="ekr.20050916184158">This is the rST version of the Tech Report handed out at EuroPython in 2005.

**Important**: Leo's tutorial is now a clearer explanation of the basics.
This tech report should be rewritten.

@nocolor
@tabwidth -4</t>
<t tx="ekr.20050916184158.1">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

##########################################
The Essentials of Leo
##########################################

.. contents::</t>
<t tx="ekr.20050916184158.2">Leo organizes all data into nodes containing a **headline**, an expandable page of
**body text** and a (possibly empty) subtree of **descendant nodes**. The **contents** of a
node are its headline and body text. Leo’s main window contains an **outline** pane
at the top left, a **log pane** at the top right, and a **body pane** at the bottom. The
outline pane shows headlines; the body pane shows the body text of the selected
headline. The log pane displays messages from Leo.

Small red arrows mark **cloned nodes** (clones). Clones share the same content and
descendants. All clones of the same node are equivalent, so changing the
contents of one node (call it node N) changes the contents of all clones of N.
Furthermore, inserting, deleting or changing any descendant of node N causes the
corresponding insertion, deletion or change in all other clones of N.</t>
<t tx="ekr.20050916184158.3">Clones allow you to organize data in multiple ways within the same outline. You
do not have to choose a single ‘correct’ organization: you can organize your
data in as many ways as you like.

You can use **organizer nodes** to create explicit relations (relationships) among
the data in your outline. The headline of the organizer node is the
relationship’s name. Now make clones of nodes from other parts of the outline
that participate in the relation. Drag the newly created clones so they become
children of the organizer node. You may want to create other (non-cloned)
children of the organizer node that contain data found nowhere else in the
outline. Voilà: you have just created the set of all nodes that pertain to the
relationship. The organizer node is the relation; the terms relation,
relationship and organizer node are interchangeable.

Three kinds of relations deserve special mention. A **view** is a relation (an
organizer node) containing all nodes related to a desired view (or slice) of the
data in the outline. Similarly, a **task** is an organizer node containing all nodes
related to a task. Relations are not limited to tasks or views: the notion of
relationship is completely general. Headlines naturally describe the data in
body text. That is, nodes relate **metadata** (descriptions of data) to data.
Separating data from metadata is useful for humans. It is even more valuable for
scripts: scripts can access data and metadata without complex parsing.
</t>
<t tx="ekr.20050916184158.4">Plugins are Python (.py) files contained in Leo’s plugins folder. Users can
write plugins to change how Leo works and to add new features without changing
Leo’s core code. We’ll discuss plugins in more detail later.
</t>
<t tx="ekr.20050916184158.5">Leo can generate many external files called **derived files** from an outline. Leo
outlines can organize files throughout your computer’s file system. Nodes whose
headlines start with ‘@’ are special nodes. Several **special nodes** indicate the
root of a tree that generates a derived file::

    @asis filename    Creates a derived file. Ignores all markup in body text.
    @file filename    Creates a derived file. Duplicates outline structure in .leo file.
    @noref filename   Creates a derived file. Ignores all section references.
    @nosent filename  Creates a derived file without sentinels.
    @thin filename    (Recommended) Like @file, but thin derived files contain all outline structure.

Leo recognizes several other special nodes::

    @settings   Defines settings local to the .leo file.
    @url url    Double-clicking the node’s icon opens the url in Leo or in a browser.

The scripting plugin scans for the following nodes when opening an outline::

    @button         Creates a button in the **icon area** at the top of the Leo window.
    @plugin plugin  Enables a plugin if the plugin has not already been enabled.
    @script         Executes a script when opening the outline. This is a security risk: it is disabled by default.

Plugins, @button nodes and @script nodes can create other kinds of special nodes::

    @suite       Creates a suite of unit tests from script in body. Requires scripting plugin.
    @test        Creates a unit text from script in body. Requires scripting plugin.
    @rst         Outputs a tree containing markup for reStructuredText. Requires rst2 plugin.
    @run command Double clicking the node’s icon executes the command.  Requires run_nodes plugin.</t>
<t tx="ekr.20050916184158.6">Leo’s Execute Script command **preprocesses** the script to be executed by scanning
a node N and its descendents looking for markup. **Markup** is special syntax that
controls this preprocessing. If node N contains no markup, the resulting script
is just N’s body text. Otherwise, the preprocessed script will include text from
descendent nodes as described below. The main kinds of markup are **section
references**, **directives** and **doc parts**.

1.  **Section references** have the form::

        &lt;&lt;section name&gt;&gt;

    The ``&lt;&lt;`` and ``&gt;&gt;`` must appear on the same line. Conversely, any line
    containing ``&lt;&lt;`` and ``&gt;&gt;`` is a section reference, regardless of context. However,
    section references are not recognized in doc parts. Any characters may appear
    between ``&lt;&lt;`` and ``&gt;&gt;``.
    
    Section references are functional pseudo-code: while preprocessing a script, Leo
    replaces section references by the actual text of the section’s definition.
    Sections are defined in **section definition nodes**, whose headlines start with a
    section reference and whose body text defines the section. Each section
    definition node must descend from the node containing the section reference.

2.  **Directives** start with ‘@’ in the leftmost column of body text. Directives
    specify options and control Leo’s operation. The ``@others`` directive is the
    minimal markup needed to organize scripts. ``@others`` tells Leo to insert the
    preprocessed text of all descendant nodes (except section definition nodes) at
    the spot at which the ``@others`` directive occurs. Nodes are inserted in **outline
    order**, the order in which nodes appear in the outline. **Important**: Leo adds the
    whitespace preceding the ``@others`` directive to the indentation of all
    preprocessed text.
    
    Using ``@others`` is more convenient than using section references. Use ``@others`` when
    the order of included text does not matter::
    
        class myClass:
	        @others # Include the methods of the class. Order doesn’t matter.

    Use section references when the order of included text does matter. In the following script, for example,
    &lt;&lt; imports &gt;&gt; ensures that imports come first. The ``@others`` directive then includes the body text of all other
    descendant nodes::
    
        @language python
        &lt;&lt; imports&gt;&gt;
        @others # Define classes &amp; functions in child nodes.
        main()

    Here is a list of all of Leo’s standard directives::
    
        @whitespace (or @doc)   Starts a doc part &amp; ends code part.
        @all                    Like @others, but includes all descendent nodes.
        @c, @code               Starts a code part and ends a doc part.
        @color                  Enables syntax coloring.
        @delims                 Temporarily changes comment delims.
        @nocolor, @killcolor    Disables syntax coloring.
        @comment                Sets comment delimiters in external (derived) files.
        @language languagename  Sets language for syntax coloring and comments.
        @lineending lineending  Sets ending of lines in derived files.
        @others                 Inserts body text of all descendents except definition nodes. 
        @pagewidth n            Sets page width for justifying comments in doc parts.
        @path path              Sets prefix to use in relative file names in @file nodes, etc.
        @root filename          Marks the root of a tree that creates an external file.
        @raw, @end_raw          Inhibits sections references in a range of text. (@file only.)
        @tabwidth n             Sets width of tabs (negative widths convert tabs to spaces.)
        @wrap, @nowrap          Controls wrapping of text in body pane.
    
3.  Doc parts start with the ‘@’ directive and continue until the end of the body text or until the ‘@c’ directive.
    Body text not in a doc part is in a code part. Here is an example of a doc part::

        @ This is a doc part. Doc parts may span many lines. Leo converts doc parts to comments.
        Leo reformats the doc part by justifying lines so they are no longer than the page width.
        @c

    Leo reformats doc parts by justifying the text into comment lines.
    The ``@pagewidth`` directive controls the length of these comment lines.
    The ``@language`` and ``@comment`` directives specify the comment delimiters used in doc parts.</t>
<t tx="ekr.20050916184158.7">The ``Execute Script`` command preprocesses the selected text of the presently
selected outline node, or the entire text of the node if there is no selected
text. See the section called ``Markup for Scripts`` for a discussion of how Leo
preprocesses scripts. That section also discusses how Leo organizes scripts
using outlines. Conversely, scripts can use outlines to organize their data. To
write such scripts you must understand at least the basics of Leo’s modules and
classes...
</t>
<t tx="ekr.20050916184158.8">Leo’s source code is organized as a collection of modules. The following
paragraphs describe five of the most important modules. See ``LeoPy.leo`` (Leo’s
full source code) for more details: scripts have full access to all of Leo’s
classes and data.

1.  The **leoGlobals** module contains utility functions.
    By convention, in Leo’s code ``g`` is always the ``leoGlobals`` module.

2.  The **leoApp** module defines a class representing the entire Leo application.
    **g.app** is the singleton object of this class: the application object.
    The instance variables (ivars) of the application object are Leo’s global variables.
 
3.  The leoCommands module defines the Commands class.
    A commander is an instance of this class.
    Commanders contain the operations that can be performed on a particular outline.
    Each open Leo outline has its own commander.
    By convention, in Leo’s code **c** is always a commander.

4.  The leoFrame module defines the base leoFrame class for objects that create and manage
    the visual appearance of Leo’s windows and panes.
    The **leoTkinterFrame** and **leoTkinterTree** modules contain subclasses of the base classes in the leoFrame module.
    A frame (an instance of the leoFrame class, or a subclass)
    contains all the internal data needed to manage a Leo window.
    **c.frame** is the frame associated with commander c.
    If **f** is a frame, **f.c** is the frame’s commander, **f.body** is the frame’s body pane,
    **f.tree** is the frame’s outline pane, and **f.log** is the frame’s log pane.

5.  The leoNodes module defines several classes that implement Leo’s fundamental data structures.
    These classes are complex.
    Happily, scripts can and should ignore these complications by accessing nodes using
    high-level methods of the position class.

A **position** (an instance of the position class) is the state of some traversal of an outline. Equivalently, a position is a particular visual place in an outline. Cloned nodes may appear many times in an outline. Non-cloned nodes may also appear in many places: consider a non-cloned descendant of a cloned node. By convention, in Leo’s source code p is a position.
</t>
<t tx="ekr.20050916184158.9">When executing scripts Leo predefines the following three symbols:
**c** is the commander of the outline in which the script is defined,
**g** is the leoGlobals module and
**p** is the position of the selected node in c’s outline, i.e., ``c.currentPosition()``.
</t>
<t tx="ekr.20050916184158.10">Scripts should get and set data using high-level access methods. Here are some important getters::

    g.app                The application object. Its ivars are Leo’s global variables.
    g.app.windowList     The list of all open frames.
    c.currentPosition()  The position of the selected node.
    c.rootPosition()     The position of the first node in the outline.
    p.headString()       The headline of position p.
    p.bodyString()       The body text of position p.
    p.childIndex()       The number of siblings that precede p.
    p.numberOfChildren() The number of p’s children.
    p.level()            The number of p’s ancestors.
    p.hasChildren()      True if p has children.
    p.isAncestorOf(p2)   True if p2 is a child, grandchild, etc. of p.
    p.isCloned()         True if p is a clone.
    p.isDirty()          True if p’s contents have been changed.
    p.isExpanded()       True if p has children and p’s outline is expanded.
    p.isMarked()         True if p’s headline is marked.
    p.isVisible()        True if all of p’s ancestors are expanded.

And here are some important setters::

    p.setBodyStringOrPane(s) Set body text of p to s.
    p.setHeadString(s)       Set headline of p to s.</t>
<t tx="ekr.20050916184158.11">Scripts can visit some or all of the nodes of a Leo outline using the following iterators::

    c.allNodes_iter             # All positions in the outline, in outline order.
    p.children_iter()           # All children of p.
    p.parents_iter()            # All parents of p.
    p.siblings_iter()           # All siblings of p, including p.
    p.following_siblings_iter() # All siblings following p, not including p.

For example, the following prints all the nodes of an outline, properly indented::

    for p in c.allNodes_iter():
        print ' '*p.level(), p.headString()</t>
<t tx="ekr.20050916184158.12">Scripts may open other Leo outlines, or execute any of Leo’s commands.  Here are some examples::

    ok,frame = g.openWithFileName(path,c)	# Opens the .leo file found at path.
    c.deleteOutline()   # Deletes the selected node.
    c.insertHeadline()  # Inserts a new node after present position.

For more examples, see ``Chapter 7: Scripting Leo with Python``, in ``Leo’s Users Guide``.</t>
<t tx="ekr.20050916184158.13">The scripting plugin creates two buttons in the icon area at the top of the Leo
window. The ``Run Script`` button executes the script in the selected node just
like the ``Execute Script`` command. The ``Script Button`` button creates a new
button whose headline is the headline of the presently selected node, call it
node N. Pressing this button executes the script in node N with p predefined as
``c.currentPosition()`` at the time the script is executed. This clever trick
brings the script to the data in the selected outline.
</t>
<t tx="ekr.20050916184158.14">``test.leo`` contains all of Leo’s unit tests. An ``@button node`` in test.leo
creates a blue ``Unit Test`` button in the icon area. This button is an
excellent example of bringing scripts to data. The ``Unit Test`` button executes
all the unit tests specified by ``@test`` and ``@suite`` nodes in the selected
outline. **Important**: ``@button``, ``@test`` and ``@suite`` nodes require the
scripting plugin to be enabled.

``@test`` nodes greatly simplify unit testing. The ``Unit Test`` button creates
a unit test from the body text of each ``@test`` node. In effect, the ``Unit
Test`` button automatically creates an instance of ``unittest.TestCase`` whose
run method is the body text of the @test node. There is no need to create
``TestCase`` objects explicitly!

``@suite`` nodes support legacy unit tests. When the ``Unit Test`` script button
finds an ``@suite node`` it executes the script in its body text. This script
should create a suite of unit tests and set::

    g.app.scriptDict['suite'] = suite

where suite is the created suite. The ``Unit Test`` button then runs that
created suite of unit tests.</t>
<t tx="ekr.20050916184158.15">Plugins are Python (.py) files in Leo’s plugin subdirectory. It is easy to
create new plugins: Leo’s users have contributed dozens of plugins that extend
Leo’s capabilities in new ways. Leo imports all enabled plugins during startup.
The file pluginsManager.txt lists all enabled plugins. You can use the plugin
manager plugin to control plugins without updating ``pluginsManager.txt`` by hand.

Plugins can override any class, method or function in Leo’s core, the files in
Leo’s src subdirectory (the files derived from LeoPy.leo). Besides altering
Leo’s core, plugins can register functions called hooks that Leo calls at
various times during Leo’s execution. Events that trigger hooks include key
pressed events, screen drawing events, node selection events and many others.
When importing a plugin, Leo will call the top-level init() function if it
exists. This function should register the plugin’s hooks by calling
leoPlugins.registerHandler.

For full details about hooks and events see ``Chapter 8: Customizing Leo``, in
``Leo’s Users Guide``. The file ``leoPlugins.leo`` contains all plugins that are
presently distributed with Leo; studying these plugins is a good way of learning
to write your own plugins.</t>
<t tx="ekr.20050916184158.16">- Leo’s home page:  google edreamleo or http://webpages.charter.net/edreamleo/front.html

- Edward K. Ream:  edreamleo@charter.net, 166 N. Prospect Ave., Madison WI 53726, (608) 231-0766</t>
<t tx="ekr.20050917092557">Leo 4.3.3 final                 September 17, 2005

Leo 4.3.3 fixes several bugs reported in Leo 4.3.2 final in the last several days.

To learn about Leo, see: http://webpages.charter.net/edreamleo/intro.html

The highlights of 4.3.3 (and 4.3.2)
-----------------------------------

- Improved Leo's documentation:
    - A tutorial introduction to Leo:
      http://webpages.charter.net/edreamleo/intro.html
    - A 5-minute guide to programming with Leo:
      http://webpages.charter.net/edreamleo/intro.html#quick-start-for-programmers

- The new rst3 plugin creates .html and .tex files from reStructuredText
  embedded in Leo files. Any node of the source outline may contain options for
  the rst3 plugin, which makes this plugin much more useful and flexible than
  the previous rst plugins. All of Leo's documentation was created using this
  plugin from sources in LeoDocs.leo. For full documentation for rst3 see:
  http://webpages.charter.net/edreamleo/rstplugin3.html.

- The spellpyx (spell checking) plugin is now much easier to use.

- The vim and openWith plugins now use Python's subprocess module if it is present.
 
- Improved the Pretty Printing command.

- The usual assortment of bug fixes.</t>
<t tx="ekr.20050917092557.1">Here is a summary of the changes:

- General:  All chapters created with rst3 plugin.  This ensures a uniform look.  The source is in LeoDocs.leo.  Removed all references to older versions of Leo, except when discussing old file formats in the Appendices.  Corrected all text so it discusses present version.

- rst3 plugin itself:  Correct bug that caused chapters to be formatted differently when processing multiple @rst trees.  

- rst3 button in LeoDocs.leo:  The script first looks *up* the tree, looking for an @rst node.  If found, it processes just that tree.  If not found, it processes all @rst nodes *below* the originally selected node.  The button is now much more convenient to use.

- Preface: Shorter, no history.  No longer a dead end.

- What People are Saying About Leo: No longer a dead end.

- FAQ: Reorganized, simplified, revised.  Added entries for running Leo in a console window and debugging docutils.  Improved entry for using cvs.

- Chapter 1: Installation: Now the first chapter.  Revised.

- Chapter 2: Tutorial: Completely rewritten.  Like Python's tutorial, this chapter contains everything a beginner needs to understand and use Leo.  The `Quickstart for programmers` section is the heart of this chapter.  All terms used have links either to their definition in the tutorial or in the Glossary.  Newbies should be able to digest this chapter easily.  This chapter should make Leo comprehensible to many more people.

- Chapter 3: Using Outlines: Revised per general remarks above.

- Chapter 4: Writing Programs in Leo.  Completely rewritten.  The old chapter was an embarrassment. The new chapter is a reference guide, properly organized as such.  The introduction warns newbies away.

- Chapter 5: Using Leo's Commands.  'Minor' revisions and corrections create a substantially better result.

- Chapter 6: Leo and literate programming: Reformatting helps.  New words about rST markup and other improvements over traditional LP.

- Chapter 7: Scripting Leo with Python: Rewritten, simplified, updated and corrected.  The sources in LeoDocs.leo are directly executable.  rST sources use literal blocks instead of code-blocks so that the sources are simplified. (Important when executing examples).  Properly discusses positions, including 'supremely important' section on copying positions.

- Chapter 8: Customizing Leo.  Heavily revised.  Discusses leoSettings.leo, not leoConfig.txt.  Security warnings are more reasonable.  Section on script buttons. Rewrote section on uA's (Adding extensible attributes to nodes and .leo files).

- Chapter 9: History of Leo.  Rewritten.  Much shorter and more useful.  Discusses the major milestones, concentrating on explaining the major differences between versions.  Gone are details of how discoveries came to be.  They are in LeoPostings.leo, which will be included in the distribution.

- Chapter 10: Theory of Operation.  Largely rewritten.  Discusses positions properly.  Omits discussion of how clones were implemented before 4.2.

- Chapter 11: White Papers.  A new chapter.  This is a slightly-edited version of writing that had been buried in the appendices.

- Appendices.  Heavily revised and reformatted.  Rewrote sections on file formats.

- Glossary: A separate chapter.  All terms have links to their definition.  All definitions are rST targets so other chapters may refer to them.  Added several new entries.
</t>
<t tx="ekr.20050917092557.2"></t>
<t tx="ekr.20050917092557.3">- Fixed bug with non-unicode characters in file name

    http://sourceforge.net/forum/message.php?msg_id=3224635
    
    Leo crashed try to read .leo files whose name contained non-ascii characters.

- Fixed bug with non-unicode characters in settings value

    http://sourceforge.net/forum/message.php?msg_id=3222750
    
    Leo crashed try to write settings whose values contained non-ascii characters.

- Fixed bug tangling sections with non-unicode characters.

    http://sourceforge.net/forum/message.php?msg_id=3307318</t>
<t tx="ekr.20050917092557.4">http://sourceforge.net/forum/message.php?msg_id=3218558</t>
<t tx="ekr.20050917092557.5">The fix was to add an entry of 'unknown' state to state_dict. This fixes the
crash by brute force, but may not be strictly correct. However, this is pretty
much moot: we shall soon be moving to the new colorizer.</t>
<t tx="ekr.20050917092557.6">The code gets c = keywords.get('c') in several places.
The protection is to return if c is None.
This affects the following files: plugins_menu.py, pluginsTest.py, plugin_manager.py</t>
<t tx="ekr.20050917092557.7">http://sourceforge.net/forum/message.php?msg_id=3231597

test.leo had some non-@ignore'd @thin nodes for files not in the distribution.

- Only files used by unit tests should be on cvs and the distribution.
    - test\unittest\batchTest.py and test\unittest\errorTest.py were already on cvs.
    - Added these files to the distribution.

- Other test files should be distributed in @ignore nodes.

- Leo's distribution checklist now has an item to check that the distributed test.leo can be opened without errors.</t>
<t tx="ekr.20050917092557.8"></t>
<t tx="ekr.20050917092557.9">See http://webpages.charter.net/edreamleo/rstplugin3.html for full documentation
of this plugin.

The rst3 plugin creates output files from Leo outlines containing
reStructuredText (rST) ReStructuredText is a simple and powerful text formatting
markup language. Outlines are a natural way to organize rST (or any text).

This plugin adds the Write Restructured Text command to Leo's Edit menu. The
Write Restructured Text command searches the selected outline looking for rst
root nodes whose headline have the form @rst &lt;filename&gt;. The plugin then creates
the named file in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically relieves you from one of the most
tedious chores in creating rST markup.

To use this plugin effectively, Python's docutils module must be installed. The
rst3 plugin will use the SilverCity syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.</t>
<t tx="ekr.20050917092557.10">This plugin now allows quotes within words, but strips quotes and other cruft
from the beginning and end of words. As a result, using the spellpyx spell
checker is much easier than before.

Leo's extensions folder now contains aspell23.pyd and aspell24.pyd. These are
Python dll's compiled for Python 2.3 and 2.4 respectively. You must rename one
of these files to be aspell.pyd and move aspell.pyd to the aspell folder. For
more details, see the installation nodes in the docstring for the spellpyx
plugin.</t>
<t tx="ekr.20050917092557.11">These plugins now use Python's subprocess module if it is present. The
subprocess module comes standard with Python 2.4. For Linux systems, Leo will
use subprocess.py in Leo's extensions folder if necessary.

For Windows systems you can install Python's subprocess module in Python 2.2 or
2.3 as follows:
    
    - Go to http://www.effbot.org/downloads/#subprocess

    - Download and execute one of the following installers, depending on your version of Python:
        subprocess-0.1-20041012.win32-py2.3.exe 
        subprocess-0.1-20041012.win32-py2.2.exe
        
This installer installs the subprocess sources and also _subprocess.pyd in Python's site-packages folder.
</t>
<t tx="ekr.20050917092557.12"></t>
<t tx="ekr.20050917092557.13">Calling print directly is dangerous: it will fail for unicode characters.</t>
<t tx="ekr.20050917092557.14">The new Pretty Print code has the following improvements:

- Strip trailing blanks in get.
- Many improvement to doOp.
- Improved DoMultiline:
    - Added special case logic to ensure '#' is preceded by space except at start of line.
    - Added blank after multi-line string if needed.
- Added lastName token for special-case handling depending on previous token.
- No change to put, putArray or doName.</t>
<t tx="ekr.20050917105646">- Fixed bug that caused the Open With command to crash if the subprocess module was not installed.

- Fixed problems in the niceNocent and fastGotoNode plugins.</t>
<t tx="ekr.20051028051444">Leo 4.4 alpha 4                                         December 5, 2005

Leo 4.4 a4 introduces the 'Newer World Order' for redrawing the screen,
corrects numerous bugs in the 4.4 code base, and introduces several new features.

You should be able to use this version safely. There are no known serious bugs,
but several minibuffer commands are not ready for primve time. All the major
features of 4.4 are in place.

To learn about Leo, see: http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
----------------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name. Support for tab completion.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Support for almost all commands in the Emacs Cmds menu, including cursor
and screen movement, basic character, word and paragraph manipulation, and
commands to manipulate buffers, the kill ring, regions and rectangles.

- Per-pane key bindings. You can bind shortcuts to multiple commands depending
on which of Leo's panes presently has focus. For example, you can use arrow keys
to move nodes in the outline pane, while retaining their defaults in Leo's body
pane. Per-pane key bindings are essential for mouseless Leo.

- @command nodes create minibuffer commands. You can bind key shortcuts to
@button and @command nodes.

- A rewrite of Leo's keystroke handling. In particular, Leo handles key events
immediately rather than queuing them for idle time.

- Leo recovers from crashes much more reliably than in any prevsios version.

- Leo updates the screen immediately rather than waiting for idle time.
This 'Newer World Order' simplifies the code and improves performance.

Known bugs in Leo 4.4a4
-----------------------
- Several minibuffer commands do not work.  See the release notes for details.

Coming in later releases of Leo 4.4:
------------------------------------
- An auto-complete command that shows class members in the Completion tab.

- More support for mouseless Leo. There will be commands to manipulate all
aspects of Leo using commands, so your fingers will never have to leave the
keyboard.

- Support for Vim and other 'plain-key' input modes.</t>
<t tx="ekr.20051028051444.1">Here are the default bindings relating to the minibuffer. Any of
these may be changed by changing the @shortcut node in leoSettings.leo.

Alt-x: Just like Emacs: starts minibuffer. The prompt is 'full-command' Type a
full command name, then hit &lt;Return&gt; to execute the command. Tab completion
works, but not for file names.

Alt-c: Like Emacs Control-C: (Ctrl-C conflicts with XP cut). starts minibuffer.
The prompt is 'quick-command'. This mode is not completed, but stuff like
`Ctrl-C r` and `Ctrl r r` do work.

Alt-u: Like Emacs Ctrl-u: (Ctrl-u conflicts with move-outline-up). Add a repeat
count for later command. Ctrl-u 999 a adds 999 a's, but many features remain
unfinished.

Ctrl-g: Just like Emacs Ctrl-g: Closes the mini-buffer.

The @bool useMinibuffer setting in leoSettings.leo just controls whether the
minibuffer is visible. The minibuffer exists (and you can type into it) even if
it isn't visible! You can use the show-mini-buffer, hide-mini-buffer and
toggle-mini-buffer commands to show or hide the minibuffer.</t>
<t tx="ekr.20051028051444.2">The most important new features of Leo 4.4 have to do with key bindings.

See the children of this node for details.


</t>
<t tx="ekr.20051028051444.4"></t>
<t tx="ekr.20051028051444.5">1. The minibuffer exists regardless of this setting, but will not be shown
   initially if it is False.

2. Hiding the minibuffer does not change any bindings or the operation of Leo in
   any other way. Therefore, if you do hide the minibuffer initially, and never
   want to use it, you should not bind shortcuts to any commands that use the
   minibuffer.

3. You can execute the show-mini-buffer, hide-mini-buffer and toggle-mini-buffer
   commands (or any other minibuffer command!) if the minibuffer is hidden.
   Indeed, the following will work even if the minibuffer is hidden.

       &lt;alt-x&gt;show-mini-buffer&lt;return&gt;</t>
<t tx="ekr.20051028051444.6">This options controls whether Leo creates a Cmds menu.

This menu is not ready yet, though nothing bad happens if this option is True.</t>
<t tx="ekr.20051028051444.7">http://sourceforge.net/forum/message.php?msg_id=3355954

'body_text_selection_background_color'  Default is 'Gray80'
'body_text_selection_foreground_color'  Default is 'white'</t>
<t tx="ekr.20051028051444.8">- The contract-and-go-right command moves to the parent node and collapses the
parent node.

- The goto-first-sibling and goto-last-sibling commands allow rapid movement
through an ouline without collapsing nodes.

- The print-bindings and print-commands show what commands exist and what keys
are bound to them.

- The help command gives a brief quick start introduction to Leo's Emacs-like
features.</t>
<t tx="ekr.20051028051444.9"></t>
<t tx="ekr.20051028051444.10">Leo maintains the following dictionaries.  As usual, k refers to c.keyHandler:

- c.keyHandler.registerCommand can be called from scripts to register new alt-x
  commands. It probably won't work from plugins yet.

New dictionaries and methods make it easier to customize and extend Leo:

- c.commandsDict describes all commands. Keys are full Emacs command names;
values are functions f.

- k.inverseCommandsDict: keys are f.__name__, values are emacs command names.

- k.leoCallbackDict: keys are leoCallback functions, values are called
functions.

- k.bindingsDict: keys are shortcuts, values are g.bunches with the following
    members: func, name, warningGiven, fromMenu.</t>
<t tx="ekr.20051028051444.11">The following helper functions make it easy to discover the binding presently in
effect for a command:

- k.getShortcutForCommandName(self,commandName) returns the shortcut given
  f.__name__.

- k.getShortcutForCommand(self,f) returns the shortcut for f.</t>
<t tx="ekr.20051028051444.12">@nocolor

c.keyHandlerregisterCommand (self,commandName,shortcut,func)

This function make the func available as a minibuffer command, and optionally
binds a shortcut to func. You can wrap any method in a function, so the
restriction to functions is not significant.

Here is an example take from an @button node::

@color

k = c.keyHandler

def f (event):
    g.es_print('Hello',color='purple')

k.registerCommand('print-hello','Alt-Ctrl-Shift-p',f)
k.registerCommand('print-hello2',None,f)</t>
<t tx="ekr.20051028051444.13">The following bugs exist in 4.3 final.</t>
<t tx="ekr.20051028051444.14">This makes it much harder to hang Leo after taking an exception. Leo 4.4a1 is
*much* more robust than Leo 4.3 final in this regard.</t>
<t tx="ekr.20051028051444.15">Added big kludge to menu.createMenuEntries so that f.OnCut/Copy/PasteFromMenu get called
**only** when explicitly selected from the menu (rather than from a shortcut).
This allows the code in cut/copy/paste-text to be different as needed.

Users can override the shortcut by assigning shortcuts to cut/copy/paste-text commands.
The shortcut will appear in the menu, but does **not** get bound to c.frame.menu.

This is an essential step in solving the infamous Control-V problem.
The code appears to work properly on XP.  Not tested other places.

This is the last best hope to solve this problem: the code interacts as little as possible with Tk.</t>
<t tx="ekr.20051028051444.16">http://sourceforge.net/forum/message.php?msg_id=3351985

Leo did not read empty tnodes like &lt;t/&gt; properly.</t>
<t tx="ekr.20051028051444.17"></t>
<t tx="ekr.20051028051444.18">http://sourceforge.net/forum/message.php?msg_id=3376527</t>
<t tx="ekr.20051028051444.19">It now computes the minimum leading whitespace of all non-blank lines. The old
code computed the leading whitespace of the *first* non-blank line. This would
give the wrong results if the first line were indented.</t>
<t tx="ekr.20051028051616"></t>
<t tx="ekr.20051028051616.1"></t>
<t tx="ekr.20051028051616.160">@nocolor

The scripting plugin has been improved as follows:

1. You can bind shortcuts in @button nodes.  Like this:

@button name @key=shortcut

This binds the shortcut to the script in the script button.  The button's name is 'name', but you can see the full headline in the status line when you move the mouse over the button.  This is a clean and simple way of discovering the shortcut.

2. You can create your own minibuffer commands with @command nodes.

A node whose headline has the form:

@command command-name

a new minibuffer command whose name is 'command-name'.

A node whose headline has the form:

@command command-name @key=shortcut

creates new minibuffer command and binds shortcut to it.

3.  The scripting plugin no longer contains the 'bindLate' code-level option.  The scripts for all @button or @command nodes are computed 'dynamically', that is, when the button is pushed or the command is executed from the minibuffer.  This is the most useful way, and the most intuitive.

Previously, scripts for @button nodes were never dynamic, while scripts in @button nodes created by the 'Script button' button were dynamic only if bindLate was True.  You could call this a bug: it was unhelpful, annoying and confusing.

4. The scripting plugin no longer prints an 'end of script' message.  This allows scripts to select tabs in the log pane</t>
<t tx="ekr.20051028051616.172">@color

# Plugins and scripts can easily create new tabs in the log panel.
# Important: you can run any of these examples using the 'Run Script' button.

# To create a tab named "Test" or make it visible if it already exists:
 
c.frame.log.selectTab('Test')

# When first created, a tab contains a text widget.
# To write to this widget, add the tabName argument to g.es:

g.es('Test',color='blue',tabName='Test')

# Plugins and scripts can easily replace the default Text widget with other Tk widgets.
# c.frame.log.tabFrame contains the Tk.Frame that contains all the other widgets of the frame.
# c.frame.log.logCtrl contains the Tk.Text widget that is initially the only widget in this frame.
# So to remove this text widget just do:
    
c.frame.log.logCtrl.pack_forget()

# Now you can pack any other widgets into c.frame.log.tabFrame.

import Tkinter as Tk ; log = c.frame.log
log.selectTab('Test')
log.logCtrl.pack_forget()
f = Tk.Frame(log.tabFrame,bg='red',height='1inch',width='2inch')
f.pack(side='left',expand=0,fill='none')</t>
<t tx="ekr.20051028051616.299">Leo can optionally generate matching brackets depending on the setting:

@bool autocomplete-brackets = TrueOrFalse

If True, Leo will immediately type the corresponding closing bracket whenever
you type a '(', '[' or '{' character. You can use the forward-char command to
move past the closing bracket, and Leo will move past any closing bracket if you
type the closing bracket with the cursor just to the left of a closing bracket.</t>
<t tx="ekr.20051028061322">**Important**: The print-bindings and print-commands commands (new in a1) show
what commands exist and what keys are bound to them.

- The help command tells how to use the minibuffer.

- The show-minibuffer, hide-minibuffer and toggle-mini-buffer commands show and hide the minibuffer.

It *is* possible to execute these command even if the minibuffer isn't presently
visible. For example, typing 

&lt;alt-x&gt;toggle-mini-buffer&lt;return&gt;

should always work.

- The open-find-tab command opens the Find tab. The Find tab replaces the old
Find panel. The Find panel is deprecated.

- The open-spell-tab command opens the Spell-checking tab.

- The show-colors command creates the 'Colors' tab in the log pane. This tab allows you to
experiment with picking fonts.

- The show-fonts command creates the 'Fonts' tab in the log pane. This tab allows you to
experiment with picking colors.</t>
<t tx="ekr.20051101161405">At the bottom of Leo's window you will now see an area labelled the mini-buffer.
You can't type in it directly, you activate the buffer by typing Alt-x or Alt-c.
Typing Alt-x takes you to 'full-command' mode. Type the full name of a command,
followed by a 'return'. 

- To get help, type Alt-x help.
- For a list of commands, type Alt-x print-commands.
- For a list of present key bindings, type Alt-x print-bindings.
- To leave the mini-buffer at any time type Ctrl-g.

Note: you can redefine any of these keys as you wish.

Important: you can execute any of Leo's 'legacy' commands from the mini-buffer.
For example, Alt-x about-leo or Alt-x open-find-dialog. Note: Leo's Find
*dialog* is deprecated. You will find it much more convenient to use Leo's new
Find *tab*. Use the open-find-tab command.

You can use tab-completion in the minibuffer to cycle through the list of
commands that start with what is in the buffer. Typing backspace takes you back
to the what you previously typed (less on character.) The 'Completion' tab shows
all possible completions. This tab appears automatically when you type a tab in
the minibuffer.

The mini-buffer reduces the need for shortcuts dramatically. For example, none
of Leo's import commands need a shortcut because it is easy enough to execute
them from the minibuffer. In particular, executing commands from the minibuffer
is much easier than executing commands by hand from a menu. </t>
<t tx="ekr.20051101161405.1">leoSettings.leo contains one functional @shortcuts node and one disabled
@@shortcuts node. These node contain entries for every command.

You can assign key shortcuts to any command, as discussed in the comments in
that file. You can leave the nodes as they are, use them as base for
modifications, or roll your own. You should define a binding for every function,
even if that binding is 'None'. If you don't, Leo will issue a warning.

Leo now supports per-pane bindings.  Bindings of the form:

command-name ! pane = shortcut

bind the shortcut to the command only withing a single pane. The possible values
for 'pane' are:

pane    affected panes
----    --------------
all     body,log,tree
body    body
log     log
mini    minibuffer
text    body,log
tree    tree</t>
<t tx="ekr.20051101161405.2">The scripting plugin has been improved in two ways:

1. You can specify key bindings in @button nodes as follows:

@button name @key=shortcut

This binds the shortcut to the script in the script button. The button's name is
'name', but you can see the full headline in the status line when you move the
mouse over the button.

2. You can create new minibuffer commands with @command nodes:

@command name @key=shortcut

This creates a new minibuffer command and binds shortcut to it.</t>
<t tx="ekr.20051101161405.3">Abbreviations may not work at present. A new kind of abbreviation is presently
hard coded in add_ekr_altx_commands in leoKeys.py. For example, one ekr-shortcut
is: 'f', which is bound to leo-find-panel. Typing Alt-x f Return executes
leo-find-panel. These may be quicker than Emacs abbreviations, or not.</t>
<t tx="ekr.20051101161949"></t>
<t tx="ekr.20051101162123">These 'hard-coded' bindings are no longer needed and interfere with per-pane bindings.</t>
<t tx="ekr.20051101162123.1">- The open-find-tab command opens the Find tab.

- The open-spell-tab command opens the Spell-checking tab.

The Find and Spell *tabs* replace the corresponding legacy *dialogs*. Using tabs
eliminates previous problems with dialogs obscuring Leo's main window.

Two essential components of the settings dialog now are implemented in the tabbed log:

- The show-colors command creates the 'Colors' tab in the log pane.

- The show-fonts command creates the 'Fonts' tab in the log pane.

These two tabs allow you to pick color or font names without using the @settings dialog.

Important: scripts and plugins can easily create new tabs in the Log pane. See
Chapter 7 of the Users Guide for details.</t>
<t tx="ekr.20051101162947">Leo's core now supports tabs in the log pane.</t>
<t tx="ekr.20051101163145">Leo 4.4a2 contains a large number of code-level improvements--some very
significant. For full details, see the (Projects) section of LeoPy.leo.</t>
<t tx="ekr.20051101163404">The following bugs existed in the 4.4a1 code base and have now been fixed:

- Removed warnings from compare dialog.</t>
<t tx="ekr.20051101171734">**New in Leo 4.4a2**: Plugins and scripts can create new tabs in the log panel.
The following creates a tab named test or make it visible if it already exists::
 
    c.frame.log.selectTab('Test')

When first created, a tab contains a text widget.
The c.frame.log class contains the following 'official' ivars:

- c.frame.log.tabName is the name of the active tab.
- c.frame.log.tabFrame is the Tk.Frame containing all the other widgets of the tab.
- c.frame.log.logCtrl is the initial Tk.Text widget.

The following line removes the initial text widget::
    
    c.frame.log.logCtrl.pack_forget()

To make the text widget visible again:

    c.frame.log.logCtrl.pack(side='top',expand=1,fill='both')

Plugins and scripts can pack any other widgets into c.frame.log.tabFrame.
For example, the following replaces the default text widget with a red box::

    import Tkinter as Tk ; log = c.frame.log
    log.selectTab('Test')
    log.logCtrl.pack_forget()
    f = Tk.Frame(log.tabFrame,bg='red',height='1inch',width='2inch')
    f.pack(side='left',expand=0,fill='none')

Notes:

- g.es, g.enl, g.ecnl, g.ecnls write to the log tab specified by the optional
  tabName argument. The default for tabName is 'Log', so existing code works as
  before.

- The put and putnl methods of the tkinterLog class also take an optional
  tabName argument which defaults to 'Log'.</t>
<t tx="ekr.20051101182739">- The node::

    @shortcuts traditional Leo shortcuts with important emacs bindings

contains Leo key bindings.

- The settings in @page Spell tab replace the settings in spellpyx.ini.

- You can specify the background of tabs using the following pattern::

    @color log_pane_XXX_tab_background_color = aColor

For example::

    @color log_pane_Find_tab_background_color = #d6c7d3

- The @bool autocomplete-brackets setting controls whether Leo types a matching
closing bracket immediately when you type '(', '[' or '{'.</t>
<t tx="ekr.20051109112610"></t>
<t tx="ekr.20051109112826">@nocolor

The New World Order means that drawing happens immediately, not at idle time.

The Newer World Order means that c.endUpdate is equivalent to c.redraw_now.</t>
<t tx="ekr.20051109112826.217">http://sourceforge.net/forum/message.php?msg_id=3411030

The fix was to add guards so the code does not assume w._name exists for all widgets w.</t>
<t tx="ekr.20051109112826.222">Scripts.leo contains general-purpose scripts.

unitTest.leo contains all of Leo's unit tests.

test.leo is now for recent tests.  Its small size speeds up my workflow.</t>
<t tx="ekr.20051109112826.223">Changed the following plugins:

cleo.py, footprints.py,__wx_gui.py, zodb.py</t>
<t tx="ekr.20051109112826.224">Removed tree.redrawScheduled, tree.updateCount and tree.disableRedraw

Three major complications are gone.</t>
<t tx="ekr.20051109112826.227"></t>
<t tx="ekr.20051109112826.254">http://sourceforge.net/forum/message.php?msg_id=3412644

You can invoke minibuffer commands by name.  For example:

c.executeMinibufferCommand('open-outline')

Note: c.keyHandler.funcReturn contains the value returned from the command. In
many cases, as above, this value is simply 'break'.</t>
<t tx="ekr.20051109112826.257">For now, I just set c.useTextMinibuffer = False,
so Leo uses a Tk.Label rather than a Tk.Text widget.

This will cause less confusion than always having the minibuffer enabled.</t>
<t tx="ekr.20051109112826.265">http://sourceforge.net/forum/message.php?msg_id=3415021

The code now uses the settings in @page Spell tab in leoSettings.leo.</t>
<t tx="ekr.20051109112826.310">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3414639

The entries for Perl and Perlpod are now as follows:

@color

self.language_extension_dict = {
    "perl" : "pl",
    "perlpod" : "pod",
}

self.extension_dict = {
    "pl"    : "perl",
    "pod"   : "perlpod",
}</t>
<t tx="ekr.20051109112826.315">http://sourceforge.net/forum/message.php?msg_id=3418304

Fixed an edge effect when backward searching for a match that occurs at the very
end of body text. In the process I removed an ancient hack.</t>
<t tx="ekr.20051109141223"></t>
<t tx="ekr.20051109141524"></t>
<t tx="ekr.20051109141524.1"></t>
<t tx="ekr.20051109142920">This code should never have existed.  It was used only in the macro plugin.</t>
<t tx="ekr.20051128181229"></t>
<t tx="ekr.20051128181302.147"></t>
<t tx="ekr.20051128181302.148">The plugin can not call bodyWantsFocus.</t>
<t tx="ekr.20051128181302.149">Later may never come in the Newer World Order, so everything must happen immediately.</t>
<t tx="ekr.20051128181302.150">This ensures that the widget is always visible.</t>
<t tx="ekr.20051128181302.151"></t>
<t tx="ekr.20051128181302.156">http://sourceforge.net/forum/message.php?msg_id=3425070

This code was contributed by Roger Erens.

When the Clone Find All checkbox is checked, the Find All command creates a new
root node called Found: &lt;your search pattern&gt;

This node contains clones of the nodes found by the Find All command. It is your
own responsibility to navigate to this new node and to clean it up when it's no
longer needed.</t>
<t tx="ekr.20051128181302.171">The tab now scrolls properly.</t>
<t tx="ekr.20051128181302.183">http://sourceforge.net/forum/message.php?msg_id=3434727

- Added calls to c.frame.body.onBodyChanged in cut/paste handlers.

- Added call to c.selectPosition(c.currentPosition()) in undo/redo.
    This is essential because previous calls to c.selectPosition may have had redraw_flag = False.</t>
<t tx="ekr.20051128181302.192"></t>
<t tx="ekr.20051128181302.193">http://sourceforge.net/forum/message.php?msg_id=3425967

When creating a new Leo outline (no leo file created yet), the Save As command
created the file Test4.leo instead of the expected Test4.3.leo</t>
<t tx="ekr.20051128181302.196"></t>
<t tx="ekr.20051128181302.204">http://sourceforge.net/forum/message.php?msg_id=3427809

Allowed relative path to stylesheets.

http://sourceforge.net/forum/message.php?msg_id=3433717

The rst3 plugin now traverses the tree as was done previously in the @button rst3 nodes.

http://sourceforge.net/forum/message.php?msg_id=3456419

The rst3 plugin now looks up and down the tree for settings doc parts.

The rst3 plugin now supports the default_path option.</t>
<t tx="ekr.20051128181302.208">@nocolor

- The focusIn/Out trace is a great tool.

- doTabCompletion now calls w.update before calling bodyWantsFocus.

- Eliminated w.update from g.app.gui.set_focus.  It is now called only in
those places where it is truly essential, such as in k.doTabCompletion and
wherever else it might be required.

- Pmw.Notebook does a *lot* when it switches panes (e.g., the _layout method)
and potentially any of the things it does could result in focus shifting to
widget. Rather than trying to make sense of it all, Leo will simply call
w.update as necessary to force completion of the Pmw.Notebook work before trying
to set focus.</t>
<t tx="ekr.20051128181302.211"></t>
<t tx="ekr.20051128181302.213">http://sourceforge.net/forum/message.php?msg_id=3440420

Added @string vim_cmd and @string vim_exe settings. The defaults now correspond
to default installations of vim.</t>
<t tx="ekr.20051128181302.214">http://sourceforge.net/forum/message.php?msg_id=3436726

The dialog warns about the extensions folder not containing Pmw. This can happen
when getting files from cvs.</t>
<t tx="ekr.20051128181302.229">http://sourceforge.net/forum/message.php?msg_id=3437089

The new default binding causes focus to move to the body pane when the user hits
&lt;Return&gt; to end editing in a headline.</t>
<t tx="ekr.20051128181302.231">http://sourceforge.net/forum/message.php?msg_id=3442064

This was not, in fact, a problem with the plugins manager plugin.

The bug was in &lt;&lt; put up a dialog requiring a valid id &gt;&gt; in app.setLeoID.
The code set g.app.gui to None after calling g.app.gui.runAskLeoIDDialog the code set!

While I was at it, Leo's core now always inits Pmw when creating Tk.Tk. This
removes the necessity for Plugins to do this.</t>
<t tx="ekr.20051128181302.244">1: Outline not marked dirty during editing

https://sourceforge.net/forum/message.php?msg_id=3447570

2: Inserting a headline didn't save previous edits of headlines</t>
<t tx="ekr.20051128181351"></t>
<t tx="ekr.20051128181651">Leo 4.4a4 completes the transition to the 'Newer World Order'.</t>
<t tx="ekr.20051128181651.1"></t>
<t tx="ekr.20051202072010"></t>
<t tx="ekr.20051203084745"></t>
<t tx="ekr.20051203084850">.. December 3, 2005

@ @rst-options
code_mode=False
default_path =
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

###########################
|leo| Using JythonShell
###########################

This chapter describes how to use the Jython Shell created by LeoUser.

.. contents::</t>
<t tx="ekr.20051203084850.1">.. rST links used in this document...

.. External links...

.. Hard links to Leo's web site...

.. WARNING: image targets may not have upper case letters!

.. _front:  front.html
.. _home:   front.html

.. |blank| image:: blank.gif
.. |leo|   image:: leo.gif
    :target: front_
</t>
<t tx="ekr.20051203084850.16">-------------

|leo|</t>
<t tx="ekr.20051203085709">



</t>
<t tx="ekr.20051203085709.1">- Up-Down Arrow moves the selection up or down.
- Tab inserts the current selection.

The completion list shows the best prefix entered after the '.'
Any other key withdraws the autocompleter.</t>
<t tx="ekr.20051203085709.2">Enter
    Processes the current line from the prompt to the end,
    regardless of where the cursor is.

Ctrl Enter
    This keystroke has two meanings:

    1. process the current line with a ':' appended to the end of it,
       regardless of where the cursor is.
       This is the behavior if there is character data on the line.

    2. If the line is pure whitespace, then the line is interpreted as a '' string with a length of 0.</t>
<t tx="ekr.20051203085709.3">Executing will dynamically expand a prefix to matching
words already entered within the interpreter.  For example:
cactus
cac( keystroke ) will expand cac to cactus.
This will cycle through all matches to cac within the buffer upon repeated execution.

Ctrl A 
    Moves current position to the end of the prompt.

Ctrl E
    Moves current position to the end of the line.

Ctrl K
    Removes all text from current position to end of the line.

Ctrl N
    Start typing, and then use this keystroke to search downwards only through
    the history items that match what you ve typed so far. If you use this
    keystroke at a blank prompt, they just behave like normal arrow keys.

Ctrl P
    Start typing, and then use this keystroke to search upwards through only the
    history items that match what you ve typed so far. If you use this keystroke
    at a blank prompt, they just behave like normal arrow keys.

Ctrl R
    Opens a search prompt. Begin typing and the system searches your history for
    lines that contain what you ve typed so far, completing as much as it can.

Ctrl T
    Places triple quotes around the text on the current line.

Ctrl Z
    Suppresses the current output for the duration of the execution statement.
    This is useful in cases where there is a tremendous amount of output
    occuring and the user decides that he no longer wishes to see all of it. For
    gigantic outputs, this can be a shell saver.

Delete
    Removes all text from the prompt to the end of the line.

Down
    Moves the current line down one item in the history.
    By moving, this means the current line is replaced with history item.

Up
    Moves the current line up one item in the history
    By moving, this means the current line is replaced with history item.</t>
<t tx="ekr.20051203085709.4">Typing a reference name followed by a ? will create a object view which gives
the user a variety of information about the Object in question. Example::

    a = 'meoooowwww'
    a? # Upon Enter, a panel will appear below showing Object information.</t>
<t tx="ekr.20051203090220">Typing ! at the command prompt followed by the system command you wish to
execute will start the command as a process and return a JPID for the process
that can be manipulated by the magic command set.</t>
<t tx="ekr.20051203090220.1">Entering one of the following commands will cause its
corresponding command to execute:</t>
<t tx="ekr.20051203090220.2">JPIDs are not PIDs of the OS. They are a system by which the JythonShell can
keep track of Processes created by it, and means by which the user can
manipulate those Processes.

The CWD does not indicate what the process is working in. It is intended to
function with the Magic Commands. This system does not interoperate with
java.io.File or Jython open. To achieve interopability the user should use the
magic command of the form::

    %cwd reference

This will place a java.io.File in the reference. The File instance is a copy of
the CWD File and will allow the user to open, write, create, close streams and
such in the JythonShell's CWD</t>
<t tx="ekr.20051203094826">``%alias`` *anAlias* defines alias name as an alias for cmd.
Afterwards, typing alias name params will execute the system command cmd params (from your
underlying operating system).
Aliases have lower precedence than magic functions and Python normal variables,
so if foo is both a Python variable and an alias, the alias can not be executed until you remove the Python using ``del foo``.</t>
<t tx="ekr.20051203094826.1">Toggles autocalling off and on.
Autocalling is the ability to do something like::

    dir a

instead of dir( a ).</t>
<t tx="ekr.20051203094826.2">Toggles autoindenting off and on.</t>
<t tx="ekr.20051203095113">Runs a method/function in a background thread.
For example::

    %bg doit()

This executes doit in a thread.
The status of the operation can be seen by looking at the jobs object::

    jobs.status()  #Prints the status of the jobs.

Alternatively you can access the status like so::

    jobs[jobnumber].result

jobnumber is printed out when the method/function is about to execute.
The result will be the return value of the method/function or it will tell you the job isn't finished yet.</t>
<t tx="ekr.20051203095113.1">Changes the current working directory of the Jython Shell.
``..`` signifies the parent directory.
Absolute and relative paths are allowed.</t>
<t tx="ekr.20051203095113.2">Destroys all JPIDs.</t>
<t tx="ekr.20051203095113.3">Clears the shell of all text and starts over with a fresh prompt.</t>
<t tx="ekr.20051203095113.4">Shows the current working directory of the Jython Shell.</t>
<t tx="ekr.20051203095113.5">Sets the reference to a java.io.File instance representing the current directory.</t>
<t tx="ekr.20051203095437">Deserialize an Object stored on disk into the reference.</t>
<t tx="ekr.20051203095437.1">Same as %edit.

</t>
<t tx="ekr.20051203095437.2">Brings up the Jython Shell editor and executes the resulting code.

This command allows you to conveniently edit multi-line code right in your JythonShell session.
If called without arguments,
``%edit`` opens up an empty editor with a temporary file and will execute the contents of this file when you close it
(don t forget to save it!).
Options:

-p
    Calls the editor with the same data as the previous time it was used,
    regardless of how long ago (in your current session) it was.

-x
    Suppresses execution of the edited code upon exit.
    This is mainly useful if you are editing programs which need to be called with command line arguments,
    which you can then do using %run.

If args are given, the following possibilites exist:

- The arguments are numbers or pairs of colon-separated numbers, e.g., ``1 4:8 9``.
  These are interpreted as lines of previous input to be loaded into the editor.
  The syntax is the same of the %macro command.

- If the argument doesn't start with a number,
  it is evaluated as a variable and its contents loaded into the editor.
  You can thus edit any string which contains python code (including the result of previous edits).</t>
<t tx="ekr.20051203095437.3">Prints all environment variables.</t>
<t tx="ekr.20051203095437.4">Prints all or part of the history.
If given, the ``-n`` argument signifies that line numbers should not be printed out.

%hist [ -n ] 
    Prints the total history or the last 40 items in it.

%hist [ -n ] n1
    Prints the last n1 items in the history.

%hist [ -n ] n1 n2
    Prints the items from index n1 to index n2.</t>
<t tx="ekr.20051203095437.5">Destroys JPID n.</t>
<t tx="ekr.20051203095437.6">Shows the contents of the current working directory.</t>
<t tx="ekr.20051203095437.7">Shows a java array of File instances.  For example::

    %ls a # a now holds a java array of File instances</t>
<t tx="ekr.20051203100230">Returns the current available set of magic commands.</t>
<t tx="ekr.20051203100230.1">Defines a macro that can be executed by using the name given.  For example::

    %macro macex 9:10 11 12:13 4

creates a macro called macex and puts line 9-10, 11 12-13 and 4 from the history into it
Hence entering macex and typing enter will cause those lines to rexecute.

To see the contents of the macro type: ``print macroname``.
To remove a macro type: ``del macroname``.</t>
<t tx="ekr.20051203100230.2">%magic
    Prints out the description of the magic commands.

%magic %magiccommandname
    Prints the usuage/description of the given magic command.</t>
<t tx="ekr.20051203100230.3">Same as 'print'.</t>
<t tx="ekr.20051203100230.4">%pdb
    Starts the Pdb debugger.

%pdb filename

    Runs the file under Pdb in the shell.

%pdb [on|1|off|0 ]
    Toggles automatic startup of Pdb on an exception.  Examples::

        %pdb on  --&gt; now on
        %pdb off --&gt; now off
        %pdb 1 --&gt; now on
        %pdb 0 --&gt; now off</t>
<t tx="ekr.20051203100230.5">Prints out the doc string of the passed in object if one can be found, otherwise does nothing.

The object may be a module, a method, an object, etc.</t>
<t tx="ekr.20051203100230.6">Attempts to locate the source file of the passed in object
and displays the contents of the source in the shell.</t>
<t tx="ekr.20051203100230.7">An alias for the ? object viewer syntax.
If the references is valid, a widget containing info on the reference will appear.</t>
<t tx="ekr.20051203100230.8">Executes a statement entered on the same line in the profile module.</t>
<t tx="ekr.20051203100230.9">%ps
    Prints out all JPID's the JythonShell has collected.

%ps aReference
    Puts a java Set of Processes in the reference.  For exampe:

        %ps a #a now holds a Set of Processes.</t>
<t tx="ekr.20051203100230.10">Repeats the last input.</t>
<t tx="ekr.20051203100930.1">%rehash
    Updates the alias table with all entries in $PATH.
    This command does **not** check execute permissions or whether the contents of $PATH are truly files
    (instead of directories or something else).

%rehashx
    Updates the alias table with all executable files in $PATH.
    This command **does** explicitly check that every entry in $PATH is a file, so it is slower than %rehash.</t>
<t tx="ekr.20051203100930.2">Resets the namespace by removing all names defined by the user.
Input/Output history remain in case you need them.</t>
<t tx="ekr.20051203100930.3">Runs the named file inside IPython as a program. Options:

-n:
    Suppresses setting ``__name__`` to ``__main__``.
    Instead, sets ``__name__`` to the file's name without
    extension (as Python does under import).

    This allows running scripts and reloading the definitions in them without calling code protected by::

        if __name__ == __main__:

-i:
    Runs the file in JythonShell's namespace instead of an empty one.
    This is useful if you are experimenting with code written in a text editor which
    depends on variables defined interactively.

-t:
    Prints timing information at the end of the run.

-N n:
    If -t is given this option indicates how many times you want the script to run.
    ``n`` must be an integer.
    The final timing report will include total and per run results.</t>
<t tx="ekr.20051203100930.4">This command uses the same syntax as %macro for line extraction, but instead
of creating a macro it saves the resulting string to file whose name is
given. It ensures the filename ends with a .py extension, and it asks for
confirmation before overwriting existing files.</t>
<t tx="ekr.20051203100930.6">Runs the given command using ``command.getoutput()``
and updates the user's interactive namespace with a variable called varname
containing the value of the call.
Your command can contain shell wildcards, pipes, etc.
The ``=`` is mandatory, and the variable name must be a valid Python identifier.
Options:

-l:
    List output. Splits the output on newlines into a list before
    assigning it to the given variable. By default the output is stored as a
    single string.

-v:
    Verbose. Prints the contents of the variable.</t>
<t tx="ekr.20051203100930.7">%see n
    Shows any output JPID n has collected.

%see n aReference
    Places any output JPID n has collected in the reference.</t>
<t tx="ekr.20051203101658">Sends the reference as input to JPID n.</t>
<t tx="ekr.20051203101658.1">Saves the object referenced by reference as a serialized Object.</t>
<t tx="ekr.20051203101658.2">Places the reference into the editor if the reference is a JComponent subclass.
Useful for quick gazing of what a Swing component looks like.</t>
<t tx="ekr.20051203101658.3">Runs the given command using commands.getoutput(), and returns the result formatted as a list (split on).
The output is stored in ipython's regular output cache Out[N] and in the N automatic variables.</t>
<t tx="ekr.20051203101828">Shows the threads running and the state they are in.
Selecting a thread shows the thread's stack.</t>
<t tx="ekr.20051203101828.1">Removes the given alias.</t>
<t tx="ekr.20051203101828.2">Loads data from a url into a reference.  For example::

    %url a http://python.org

take the data at ``http://python.org`` and places it in ref.</t>
<t tx="ekr.20051203101828.3">Suspends the JythonShell until JPID n has finished.</t>
<t tx="ekr.20051203101828.4">Prints the list of identifiers that have been defined interactively.</t>
<t tx="ekr.20051203101828.5">Returns a sorted list of all interactive variables.
If arguments are given, only variables of types matching these arguments are returned.
Examples::

    %who_ls
    %who_ls str int  #this prints out variables whose type is str and int</t>
<t tx="ekr.20051203101828.6">Prints a table of identifiers that have been defined interactively.</t>
<t tx="ekr.20051203101828.7">Transforms reference ref2 with the stylesheet in ref1 putting the result in ref3.</t>
<t tx="ekr.20051205090923.13"></t>
<t tx="ekr.20051205090923.16">http://sourceforge.net/forum/message.php?msg_id=3450435</t>
<t tx="ekr.20051205090923.22">http://sourceforge.net/forum/message.php?msg_id=3389810</t>
<t tx="ekr.20051205091625">- The abbreviation and buffer commands are not ready yet.

- repeat-complex-command does not work.

- Moving the cursor when the 'mark' has been defined does not expand the visibly
selected text.

- Yanking and killing have not been well tested.

- C-u 5 &lt;return&gt; works but is not undone properly. Also, the kill-line command
does not work as in Emacs.

- Many new commands must be generalized to handle the more complex environment
Leo offers. For example, search commands must be told whether to limit the
search a single node, or a node or and its descendants, or the entire outline.
We need a set-variable command that sets a (Python) variable using an
emacs-style variable name.

- The notion of the 'point' must be expanded so it indicates a node as well as
text location.
    
- New commands are needed to support 'mouseless-Leo'. The user must be able to
drive all dialogs from the keyboard, or to get the same effect without using a
dialog at all. Examples: dismiss-top-dialog, scroll-outline-up/down. We also
need commands to change focus and to manage menus. Examples: focus-in-body,
focus-in-tree, etc, activate-edit-menu, etc.</t>
<t tx="ekr.20051219150602">Leo 4.4 alpha 5                                             January 6, 2006

This release completes the last major features of Leo 4.4:

- User-specified key-binding modes.
- Support for multiple key-bindings for individual minibuffer commands.

This will be the last alpha version of Leo 4.4. Beta 1 is coming in about a
week. You should be able to use this version safely; there are no known serious
bugs.

To learn about Leo, see: http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
----------------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name. Support for tab completion.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Support for most commands in the Emacs Cmds menu, including cursor and screen
movement, basic character, word and paragraph manipulation, and commands to
manipulate buffers, the kill ring, regions and rectangles.

- Per-pane key bindings. You can bind shortcuts to multiple commands depending
on which of Leo's panes presently has focus. For example, you can use arrow keys
to move nodes in the outline pane, while retaining their defaults in Leo's body
pane.

- User-specified key-binding modes. This feature makes it possible to emulate all
aspects of Emacs and Vim as far as key bindings are concerned.

- @command nodes create minibuffer commands. You can bind key shortcuts to
@button and @command nodes.

- Leo recovers from crashes much more reliably than in any previous version.

- Leo handles keystrokes and updates the screen immediately rather than waiting
for idle time.</t>
<t tx="ekr.20051219150602.2"></t>
<t tx="ekr.20051219150602.3"></t>
<t tx="ekr.20051219150602.7"></t>
<t tx="ekr.20051219150602.10">http://sourceforge.net/forum/message.php?msg_id=3464874</t>
<t tx="ekr.20051219150602.13">http://sourceforge.net/forum/message.php?msg_id=3466412

New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user
completes the editing of a headline, and ch is always '\r', regardless of
platform.

http://sourceforge.net/forum/message.php?msg_id=3462294</t>
<t tx="ekr.20051219150602.28">http://sourceforge.net/forum/message.php?msg_id=3467558

What I did:

- atFile.readError deletes root's entire subtree.
- atFile.read only warns about unvisited node if there is no error.
</t>
<t tx="ekr.20051219150602.75">http://sourceforge.net/forum/message.php?msg_id=3461068

And a recent bug: clicking in the expand/contract box didn't save the headline.</t>
<t tx="ekr.20051219150602.81">The problem was caused by the recent change to g.app.gui.setTextSelection.

The default for the new 'insert' keyword must be sel.end for compatibility with old code.</t>
<t tx="ekr.20051219150602.85">Read @file Nodes and Import Derived File commands no longer create copies of the root node.</t>
<t tx="ekr.20051219150602.100"></t>
<t tx="ekr.20051219150602.101">The provide batch-mode unit testing.</t>
<t tx="ekr.20051219150602.102"></t>
<t tx="ekr.20051219150602.105">Leo now supports the following commands, shown below with their present bindings:

back-char ! text = LtArrow
back-char-extend-selection ! text = Shift-LtArrow
back-paragraph ! text = Alt-braceleft 
back-paragraph-extend-selection ! text = Alt-Shift-braceleft
back-sentence ! text = Alt-a 
back-sentence-extend-selection  = None
back-word ! text = Alt-b  # No conflict   
back-word-extend-selection  ! text = Alt-Shift-b
beginning-of-buffer ! text = Alt-less # Note: same as Alt-Shift-less
beginning-of-buffer-extend-selection  = None
beginning-of-line ! text = Ctrl-a
beginning-of-line-extend-selection = None
exchange-point-mark = None
forward-char ! text = RtArrow
forward-char-extend-selection ! text = Shift-RtArrow
forward-paragraph ! text = Alt-braceright
forward-paragraph-extend-selection ! text = Alt-Shift-braceright
forward-sentence ! text = Alt-e
forward-sentence-extend-selection ! text = Alt-Shift-e
forward-word ! text = Alt-f
forward-word-extend-selection ! text = Alt-Shift-f
next-line ! text = DnArrow
next-line-extend-selection  ! text = Shift-DnArrow
previous-line ! text = Uparrow
previous-line-extend-selection ! text = Shift-UpArrow

The -extend-selection variants move the cursor and also extend the selection
from the insert point in the indicated direction. As usual exchange-point-mark
switches the insert point from one side of the selection to the other: which
side of the selection the insert point is on does make a difference.

I also added three commands that implement so-called 'extend mode':

clear-extend-mode = None
set-extend-mode = None
toggle-extend-mode = None

When extend mode is on (it is off at first), all cursor movement commands listed
above extend the selection. Very handy. Thanks to Brian for this suggestion.

This is the start of mouseless Leo. For the first time all the common Emacs
cursor-movement commands exist. These commands should work in any text widget.</t>
<t tx="ekr.20051219151926">leoSettings.leo now contains a node called:

@@shortcuts traditional Leo bindings

This node contains the 'classic' Leo key bindings that appeared in Leo 4.3. I
have proofed these settings carefully, but some errors may remain. Please report
any errors or any other suggestions for these settings.</t>
<t tx="ekr.20060105145125">You must install the Aspell package if you want to use Leo's Spell tab.

1.  Download and install the Aspell package from http://aspell.sourceforge.net/

Typically this will create a directory called Aspell/bin

2.  Leo's extensions folder comes with two dll's: aspell23.pyd and aspell24.pyd, for Python 2.3 and 2.4 respectively.  Make a copy of the appropriate dll, and **rename it** to be aspell.pyd.

3. Copy aspell.pyd to aspell\bin.

4. Specify the aspell_dir and aspell_bin_dir settings in leoSettings.leo.</t>
<t tx="ekr.20060105182648.376">Leo no longer creates a duplicate root node when importing derived files.

The code is due to LeoUser.</t>
<t tx="ekr.20060105182648.377"></t>
<t tx="ekr.20060105182648.378"></t>
<t tx="ekr.20060105182648.379"></t>
<t tx="ekr.20060105182648.382">The reason for this assert is unclear.</t>
<t tx="ekr.20060105182648.432"></t>
<t tx="ekr.20060105182648.469">This is the end of the ill-fated settings dialog.

Important: you can use the show-colors and show-fonts commands to help set
colors and fonts in leoSettings.leo.</t>
<t tx="ekr.20060105214753">Leo now allows you to specify input modes. You enter mode ``x`` with the
``enter-x-mode`` command. The purpose of a mode is to create different bindings
for keys within a mode. Often plain keys are useful in input modes.

You can specify modes with ``@mode`` nodes in leoSettings.leo. ``@mode`` nodes work
just like ``@shortcuts`` nodes, but in addition they have the side effect of
creating the ``enter-&lt;mode name&gt;-mode`` command.

Notes:

- You can exit any mode using the ``keyboard-quit`` (Control-g) command. This is the
  **only** binding that is automatically created in each mode. All other bindings
  must be specified in the ``@mode`` node. In particular, the bindings specified in
  @shortcut nodes are **not** in effect in mode (again, except for the
  keyboard-quit binding).

- Leo supports something akin to tab completion within modes: if you type a key
  that isn't bound in a mode a 'Mode' tab will appear in the log pane. This tab
  shows all the keys that you can type and the commands to which they are bound.
  The mode-help command does the same thing.

- ``@shortcuts`` nodes specify the bindings for what might be called the 'top-level'
  mode. These are the bindings in effect when no internal state is present, for
  example, just after executing the keyboard-quit command.

- The ``top_level_unbound_key_action`` setting determines what happens to
  unbound keys in the top-level mode. Leo ignores unbound keys in all other modes.
  The possibilities are 'insert', 'replace' and 'ignore'.

- The ``set-insert-mode``, ``set-overwrite-mode`` and ``set-ignore-mode``
  commands alter what happens to unbound keys in the top-level mode.

With all these options it should be possible to emulate the keyboard behavior of any other editor.</t>
<t tx="ekr.20060111192108">A **dangerous** delete is a deletion of a node so that all the data in the node is deleted *everywhere* in an outline.  The data is gone, to be retrieved only via undo or via backups.  It may not be obvious which deletes are dangerous in an outline containing clones.  Happily, there is a very simple rule of thumb::

    Deleting a non-cloned node is *always* dangerous.
    Deleting a cloned node is *never* dangerous.

We could also consider a delete to be dangerous **if it results in a node being omitted from a derived file.**  This can happen as follows.  Suppose we have the following outline (As usual, A' indicates that A is marked with a clone mark)::

    - @thin spam.py
        - A'
            - B
    - Projects
        - A'
            - B

Now suppose we clone B, and move the clone so the tree looks like this::

    - @thin spam.py
        - A'
            - B'
    - Projects
        - A'
            - B'
        - B'

If (maybe much later), we eliminate B' as a child of A will get::

    - @thin spam.py
        - A'
    - Projects
        - A'
        - B

B has not been destroyed, but B is gone from @thin spam.py! So in this sense deleting a clone node can also be called dangerous.</t>
<t tx="ekr.20060116174906">Leo 4.4 beta 1                                             January 17, 2006

The code is stable; there are no known serious bugs. Some features are
incomplete.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060116174906.2"></t>
<t tx="ekr.20060116174906.3">A 'backward' delete at the start of a headline deletes the first character.
delete-char did not work in headlines.</t>
<t tx="ekr.20060116174906.63">http://sourceforge.net/forum/message.php?msg_id=3465251</t>
<t tx="ekr.20060116174906.86">http://sourceforge.net/forum/message.php?msg_id=3495741

The plugin now uses sys.getdefaultencoding() to set the encoding.</t>
<t tx="ekr.20060116174906.87">This could have been the source of weird find behavior.</t>
<t tx="ekr.20060116174906.88">The fix was to have x.getSelectedText return '' instead of None.</t>
<t tx="ekr.20060116174906.90">http://sourceforge.net/forum/message.php?msg_id=3510983</t>
<t tx="ekr.20060116174906.97"></t>
<t tx="ekr.20060116174906.100">https://sourceforge.net/forum/message.php?msg_id=3514627

c.endUpdate now restores the previous focus by default.</t>
<t tx="ekr.20060116174906.103"></t>
<t tx="ekr.20060116174906.104">http://sourceforge.net/forum/message.php?msg_id=3514755
</t>
<t tx="ekr.20060116174906.113">http://sourceforge.net/forum/message.php?msg_id=3515341</t>
<t tx="ekr.20060116174906.118">http://sourceforge.net/forum/message.php?msg_id=3509141

Problems with cleo.  Installed patch: http://sourceforge.net/forum/message.php?msg_id=3517080

https://sourceforge.net/forum/message.php?msg_id=3515025

Problems with fastgotonode and and groupOperations.</t>
<t tx="ekr.20060116174906.122">http://sourceforge.net/forum/message.php?msg_id=3518722

To generate HTML file I entered the outline header "@file bbb.xml" under which
I put the following body text:

//////////////// beginning of excerpt
@first &lt;?xml version="1.0" encoding="windows-1250" ?&gt;
@language html
@
comment line
@c
@others
//////////////// end of excerpt

This works OK.
But, if I put a space after the sole @ above "comment line",  save and close
the .leo file and then open it, Leo protests in log pane on the right:

//////////////// beginning of excerpt
----- error reading @file: bbb.xml
Missing open block comment
//////////////// end of excerpt</t>
<t tx="ekr.20060116174906.125">This corrects a problem that shows up as 'Invalid cross-device link' messages on Linux.

http://sourceforge.net/forum/message.php?msg_id=3519803</t>
<t tx="ekr.20060116174906.130">These should be considered bug fixes.

- copyBindingsToWidget now binds keys in priority order. This also simplifies
and clarifies the code.

- Removed k.onTextWidgetKey.  Added a callback that invokes k.masterCommand.</t>
<t tx="ekr.20060116174906.160">Hitting Backspace immediately put the focus in the log. Another backspace put
the focus in the body pane.

The problem was in log.clearTab.  It must do call t.update().</t>
<t tx="ekr.20060116174906.163"></t>
<t tx="ekr.20060116174906.164"></t>
<t tx="ekr.20060116174906.185">extensionHelper resets movePoint any time there is no selection.</t>
<t tx="ekr.20060116174906.187"></t>
<t tx="ekr.20060116174906.194">The fix was to call endUpdate() rather than endUpdate(changed) in onHeadChanged.</t>
<t tx="ekr.20060116174906.195"></t>
<t tx="ekr.20060116174906.198">g.top and the associated g.app.log logic is inherently unreliable.</t>
<t tx="ekr.20060116174906.199">This allows code to determine in a standard way whether a window is in the process of being destroyed.</t>
<t tx="ekr.20060116174906.213">This includes k.masterCommand and all event handlers.
</t>
<t tx="ekr.20060116174906.255">Leo now calls doCommand on all commands, so the 'command' hooks and error
processing always get done.</t>
<t tx="ekr.20060116174906.257"></t>
<t tx="ekr.20060116174906.258"></t>
<t tx="ekr.20060116174906.259">@nocolor</t>
<t tx="ekr.20060116174906.262"></t>
<t tx="ekr.20060116174906.263">http://sourceforge.net/forum/message.php?msg_id=3518792

EKR: The change in focus happened in c.endEditing in at.writeFromString.

I added a new restoreFocus keyword arg to c.endEditing.</t>
<t tx="ekr.20060116174906.267"></t>
<t tx="ekr.20060116174906.272">http://sourceforge.net/forum/message.php?msg_id=3515616

Could we have a visible-line-up and visible-line-down command? (I.e. to move
the cursor up or down by a visible rather than a logical line).  With these
commands, the arrows plugin could be permanently retired!

What I did:

- next-line and prev-line now work as requested.  This obsoletes the arrow plugin.
    - Removed the redundant tree.OnUpKey and tree.OnDownKey
    - Retired the arrows plugin.

- Created the extendHelper method.
    This creates and maintains the moveSpot, moveCol an moveSpotNode ivars,
    and is responsible for extending the selection range.</t>
<t tx="ekr.20060116174906.296">Still to do:

Specify what mode to enter after each command:

- command-name -&gt; mode-name = binding

will specify what mode to enter after each command.
At present, all commands exit to the top-level mode.

- Add @string active-keyset setting?</t>
<t tx="ekr.20060116174906.306"></t>
<t tx="ekr.20060206111508">Leo 4.4 beta 2                                          February 10, 2006

The code is stable; there are no known serious bugs. Some features are
incomplete.

Leo is a text editor, data organizer, project manager and much more. See:
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.4b2:
----------------------------
- Integrated minibuffer search commands into the framework of Leo's legacy find commands.
- User modes fully functional.
- New master key and click handlers.
- Fixed a long-standing bug that affected all aspects of Leo's screen handling.
- Rewrote the code that allocates widgets in the tree.  Fixes an important memory leak.

The highlights of Leo 4.4:
--------------------------
- An Emacs-like mini-buffer: you can now execute any command by typing its long
name, with tab completion.

- Many new commands, including cursor and screen movement, basic character, word
and paragraph manipulation, and commands to manipulate buffers, the kill ring,
regions and rectangles. You can use Leo without using a mouse.

- Flexible key bindings and input modes. You can emulate the operation of Emacs,
Vim, or any other editor.

- A tabbed log pane. The Find and Spell Check commands now use tabs instead of
dialogs, making those commands much easier to use. Plugins or scripts can easily
create new tabs. The Completion tab shows possible typing completions.

- Dozens of other new features and bug fixes since Leo 4.3.3.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html</t>
<t tx="ekr.20060206111508.2"></t>
<t tx="ekr.20060206111508.3">@nocolor

Must check for c.exists in c.executeScript after executing the script.</t>
<t tx="ekr.20060206111508.4">@nocolor

- keyboard-quit now ends editing.

- print-bindings shows plain keys only in 'ignore' mode.

- Removed k.add_ekr_altx_commands and k.makeHardBindings.

- Added binding to vim plain shortcuts: mode-help = h

- Print the initial mode when first creating a window.
  The change had to be made in g.openWithFileName because of the UNL plugin.

- Improved print-bindings &amp; mode help.

- endMode retains the widget on entry, so e.g., inserting a new node retaings the headline editing state.

@color
</t>
<t tx="ekr.20060206111508.5">@nocolor

- Added initialClickExpandsOrContractsNode settings.  Clicking an node expands or contracts the node if this setting is True.  EKR much prefers False. 

- Selecting a headline should not select text in it.

@color
</t>
<t tx="ekr.20060206111508.6"></t>
<t tx="ekr.20060206111508.7">def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.widgetWantsFocus(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.</t>
<t tx="ekr.20060206111508.8">def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20060206111508.9">def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)</t>
<t tx="ekr.20060206111508.10">def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060206111508.11">def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color") or 'white'
    selbg = c.config.getColor("headline_text_editing_selection_background_color") or 'black'
    
    try: # Use system defaults for selection foreground/background
        w.configure(state="normal",highlightthickness=1,
        fg=fg,bg=bg,selectforeground=selfg,selectbackground=selbg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060206111508.12">def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060206111508.13">def onClickBoxClick (self,event):
    
    c = self.c ; p1 = c.currentPosition()
    c.setLog()
    p = self.eventToPosition(event)

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing()
            self.active = True
            if p == p1 or c.config.getBool('initialClickExpandsOrContractsNode'):
                if p.isExpanded(): p.contract()
                else:              p.expand()
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111508.14">@nocolor

What I did:
    
- endMode must not change focus.

- modeHelp calls c.endEditing(retainFocus=True)

@color</t>
<t tx="ekr.20060206111508.15">def printBindings (self,event,brief=False):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)

    data = [] ; n1 = 4 ; n2 = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            if not brief or k.isPlainKey(key):
                pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
                s1 = pane
                s2 = k.prettyPrintKey(key)
                s3 = b.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)
    # This isn't perfect in variable-width fonts.
    for s1,s2,s3 in data:
        g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
                   
    state = k.unboundKeyAction 
    k.showStateAndMode()</t>
<t tx="ekr.20060206111508.16">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None
    
    if trace and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    elif k.inState():
        return 'break' # New in 4.4b2: ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20060206111508.17"># Don't add multiple special characters to history.
k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20060206111508.18">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20060206111508.19">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20060206111508.20">def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20060206111508.21"></t>
<t tx="ekr.20060206111508.22">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''
    
    # g.trace(g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20060206111508.23">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    # g.trace(repr(ch))
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20060206111508.24"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; u = c.undoer ; w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
        if changed:
            # g.trace('changed: old',repr(oldRevert),'new',repr(s))
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
        else:
            pass # g.trace('not changed')
    finally:
        c.endUpdate()
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)</t>
<t tx="ekr.20060206111508.25"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20060206111508.26"></t>
<t tx="ekr.20060206111508.27">def badMode(self,modeName):
    
    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)</t>
<t tx="ekr.20060206111508.28">def createModeBindings (self,modeName,d):
    
    k = self ; c = k.c

    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if not func:
            g.trace('No such command: %s' % commandName) ; continue
        bunchList = d.get(commandName,[])
        for bunch in bunchList:
            stroke = bunch.val
            # Important: bunch.val is a stroke returned from k.strokeFromSetting.
            # Do not call k.strokeFromSetting again here!
            if stroke and stroke not in ('None','none',None):
                if 0:
                    g.trace(
                        modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        bunch.nextMode)
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.Bunch(
                    commandName=commandName,
                    func=func,
                    nextMode=bunch.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2</t>
<t tx="ekr.20060206111508.29">def endMode(self,event):
    
    k = self ; c = k.c ; w = c.get_focus()

    c.frame.log.deleteTab('Mode')

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()

    # k.setLabelGrey('top-level mode')
    
    # Do *not* change the focus: the command may have changed it.
    c.widgetWantsFocus(w)</t>
<t tx="ekr.20060206111508.30">def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName=modeName)
</t>
<t tx="ekr.20060206111508.31">def exitNamedMode (self,event):
    
    k = self

    if k.inState():
        k.endMode(event)
    
    k.showStateAndMode()
</t>
<t tx="ekr.20060206111508.32">def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c ;  w = c.get_focus()
    state = k.getState(modeName)
    trace = c.config.getBool('trace_modes')
    
    if trace: g.trace(modeName,state)
   
    if state == 0:
        self.initMode(event,modeName)
        k.inputModeName = modeName
        k.setState(modeName,1,handler=k.generalModeHandler)
        if c.config.getBool('showHelpWhenEnteringModes'):
            k.modeHelp(event)
        else:
            c.frame.log.hideTab('Mode')
        if k.useTextWidget:
            c.minibufferWantsFocus()
        else:
            c.widgetWantsFocus(w)
    elif not func:
        g.trace('No func: improper key binding')
        return 'break'
    else:
        if trace: g.trace(modeName,state,commandName)
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            # nextMode = bunch.nextMode
            self.endMode(event)
            if c.config.getBool('trace_doCommand'):
                g.trace(func.__name__)
            func(event)
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                self.reinitMode(modeName) # Re-enter this mode.
                k.setState(modeName,1,handler=k.generalModeHandler)
            else:
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'</t>
<t tx="ekr.20060206111508.33">def initMode (self,event,modeName):

    k = self ; c = k.c

    if not modeName:
        g.trace('oops: no modeName')
        return

    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return
    else:
        k.modeBindingsDict = d
        
    k.inputModeName = modeName
    k.modeWidget = c.get_focus()
    
    if k.masterBindingsDict.get(modeName) is None:
        k.createModeBindings(modeName,d)
   
    k.setLabelBlue(modeName+': ',protect=True)
    k.showStateAndMode()
    if k.useTextWidget:
        c.minibufferWantsFocus()
    else:
        pass # Do *not* change the focus here!</t>
<t tx="ekr.20060206111508.34">def reinitMode (self,modeName):
    
    k = self ; c = k.c

    d = k.modeBindingsDict
    
    k.inputModeName = modeName
    k.createModeBindings(modeName,d)
    
    # Do not set the status line here.
    k.setLabelBlue(modeName+': ',protect=True)

    if k.useTextWidget:
        c.minibufferWantsFocus()
    else:
        pass # Do *not* change the focus here!</t>
<t tx="ekr.20060206111508.35">def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''
    
    k = self ; c = k.c

    c.endEditing()
    
    g.trace(k.inputModeName)
    
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)
        
    if k.useTextWidget:
        c.minibufferWantsFocus()

    return 'break'</t>
<t tx="ekr.20060206111508.36">def modeHelpHelper (self,d):
    
    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    keys = d.keys() ; keys.sort()

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                s1 = key ; s2 = k.prettyPrintKey(shortcut)
                n = max(n,len(s1))
                data.append((s1,s2),)
                
    data.sort()
    
    # g.es('%s\n\n' % (k.inputModeName),tabName=tabName)
        
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s %s' % (n,s1,s2),tabName=tabName)</t>
<t tx="ekr.20060206111508.37">def setIgnoreState (self,event):

    self.setInputState('ignore',showState=True)

def setInsertState (self,event):

    self.setInputState('insert',showState=True)

def setOverwriteState (self,event):

    self.setInputState('overwrite',showState=True)

</t>
<t tx="ekr.20060206111508.38">def setInputState (self,state,showState=False):

    k = self ; c = k.c ; w = c.get_focus()

    k.unboundKeyAction = state
    if state != 'insert' or showState:
        k.showStateAndMode()
   
    # These commands never change focus.
    w and c.widgetWantsFocus(w)</t>
<t tx="ekr.20060206111508.39">def showStateAndMode(self):
    
    k = self ; frame = k.c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind()
   
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        put = frame.putStatusLine
        if state != 'insert':
            put('state: ',color='blue')
            put(state)
        if mode:
            put(' mode: ',color='blue')
            put(mode)
</t>
<t tx="ekr.20060206111508.40"></t>
<t tx="ekr.20060206111508.41"></t>
<t tx="ekr.20060206111508.42">def universalArgument (self,event):
    
    '''Begin a numeric argument for the following command.'''
    
    k = self
    k.setLabelBlue('Universal Argument: ',protect=True)
    k.universalDispatcher(event)
    
def digitArgument (self,event):

    k = self
    k.setLabelBlue('Digit Argument: ',protect=True)
    k.universalDispatcher(event)</t>
<t tx="ekr.20060206111508.43">def hideMinibuffer (self,event):
    
    k = self ; c = k.c
    
    c.frame.hideMinibuffer()
    
    g.es('Minibuffer hidden',color='red')

    for commandName in ('show-mini-buffer','toggle-mini-buffer'):
        shortcut = k.getShortcutForCommandName(commandName)
        if shortcut:
            g.es('%s is bound to: %s' % (commandName,shortcut))
    
    
def showMinibuffer (self,event):
    
    k = self ; c = k.c
    
    c.frame.showMinibuffer()
    
def toggleMinibuffer (self,event):
    
    k = self ; c = k.c
    
    if c.frame.minibufferVisible:
        k.hideMinibuffer(event)
    else:
        k.showMinibuffer(event)</t>
<t tx="ekr.20060206111508.44">def negativeArgument (self,event):

    k = self ; state = k.getState('neg-arg')

    if state == 0:
        k.setLabelBlue('Negative Argument: ',protect=True)
        k.setState('neg-arg',1,k.negativeArgument)
    else:
        k.clearState()
        k.resetLabel()
        func = k.negArgFunctions.get(k.stroke)
        if func:
            func(event)

    return 'break'</t>
<t tx="ekr.20060206111508.45">def numberCommand (self,event,stroke,number):

    k = self ; k.stroke = stroke ; w = event.widget

    k.universalDispatcher(event)
    w.event_generate('&lt;Key&gt;',keysym=number)

    return 'break'

def numberCommand0 (self,event): return self.numberCommand (event,None,0)
def numberCommand1 (self,event): return self.numberCommand (event,None,1)
def numberCommand2 (self,event): return self.numberCommand (event,None,2)
def numberCommand3 (self,event): return self.numberCommand (event,None,3)
def numberCommand4 (self,event): return self.numberCommand (event,None,4)
def numberCommand5 (self,event): return self.numberCommand (event,None,5)
def numberCommand6 (self,event): return self.numberCommand (event,None,6)
def numberCommand7 (self,event): return self.numberCommand (event,None,7)
def numberCommand8 (self,event): return self.numberCommand (event,None,8)
def numberCommand9 (self,event): return self.numberCommand (event,None,9)</t>
<t tx="ekr.20060206111508.46">def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'
    
    c.frame.log.clearTab(tabName)
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    data = [] ; n1 = 4 ; n2 = 20
    for commandName in commandNames:
        dataList = inverseBindingDict.get(commandName,[('',''),])
        for z in dataList:
            pane, key = z
            s1 = pane
            s2 = k.prettyPrintKey(key)
            s3 = commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)
                
    # This isn't perfect in variable-width fonts.
    for s1,s2,s3 in data:
        g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
</t>
<t tx="ekr.20060206111508.47">def repeatComplexCommand (self,event):

    k = self

    if k.mb_history:
        k.setState('last-full-command',1,handler=k.doLastAltX)
        k.setLabelBlue("Redo: %s" % k.mb_history[0])
    return 'break'
    
def doLastAltX (self,event):
    
    k = self ; c = k.c

    if event.keysym == 'Return' and k.mb_history:
        last = k.mb_history [0]
        c.commandsDict [last](event)
        return 'break'
    else:
        return k.keyboardQuit(event)</t>
<t tx="ekr.20060206111508.48">
</t>
<t tx="ekr.20060206111508.49">Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 250, in doCommand
    val = command() # Call legacy command

  File "C:\prog\leoCVS\leo\src\leoTkinterFrame.py", line 1777, in cutText
    oldText = w.get('1.0','end')

AttributeError: Canvas instance has no attribute 'get'</t>
<t tx="ekr.20060206111508.50"></t>
<t tx="ekr.20060206111508.51">def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText</t>
<t tx="ekr.20060206111508.52">def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText</t>
<t tx="ekr.20060206111508.53">def pasteText (self,event=None):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    # g.trace(name)
    
    singleLine = name.startswith('head') or name.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif singleLine:
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        if name.startswith('head'):
            # The headline is not officially changed yet.
            # p.initHeadString(s)
            w.configure(width=f.tree.headWidth(s=s))
    else:
        pass
    
OnPasteFromMenu = pasteText</t>
<t tx="ekr.20060206111508.54"></t>
<t tx="ekr.20060206111508.55"># Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):
    
    f = self ; c = f.c
    
    if c.inCommand:
        g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)</t>
<t tx="ekr.20060206111508.56">def closeLeoWindow (self,frame):
    
    """Attempt to close a Leo window.
    
    Return False if the user veto's the close."""
    
    c = frame.c
    
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False
        
    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.
    
    g.doHook("close-frame",c=c) # This may remove frame from the window list.
    
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
    
    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        w = g.app.windowList[0]
        w.deiconify()
        w.lift()
        w.c.setLog()
        w.c.bodyWantsFocus()
    else:
        g.app.finishQuit()

    return True # The window has been closed.</t>
<t tx="ekr.20060206111508.57">command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self ; p = c.currentPosition()
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and (
        c.config.getBool('trace_doCommand') or
        c.config.getBool('trace_gc') and (self.command_count % 10) == 0
    ):
        commandName = command and command.__name__
        if (self.command_count % 10) == 0:
            w = c.get_focus() ; wname = c.widget_name(w)
            g.printGcSummary('doCommand: %s %s' % (commandName,wname),trace=True)
        else:
            g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            c.inCommand = False
            if c and c.exists: # Be careful: the command could destroy c.
                c.k.funcReturn = val
        except:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es("exception executing command")
                print "exception executing command"
                g.es_exception(c=c)
                if c and c.exists and hasattr(c,'frame'):
                    c.redraw_now()
                    
        if c and c.exists and c.requestCloseWindow:
            g.trace('Closing window after command')
            c.requestCloseWindow = False
            g.app.closeLeoWindow(c.frame)

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)
            
    return "break" # Inhibit all other handlers.</t>
<t tx="ekr.20060206111508.58"></t>
<t tx="ekr.20060206111508.63"></t>
<t tx="ekr.20060206111508.74">Call w.see('insert'), not w.see('insert-5L')</t>
<t tx="ekr.20060206111508.75"></t>
<t tx="ekr.20060206111508.76"></t>
<t tx="ekr.20060206111508.97"></t>
<t tx="ekr.20060206111508.103">The outline jumps around too much when expanding/contracting nodes
</t>
<t tx="ekr.20060206111508.136"># This is required now that scrolling is disabled by default.</t>
<t tx="ekr.20060206111508.138"># Added max_undo_stack_size setting.</t>
<t tx="ekr.20060206111508.229"></t>
<t tx="ekr.20060206111508.517"></t>
<t tx="ekr.20060206111508.545"></t>
<t tx="ekr.20060206111508.546"></t>
<t tx="ekr.20060206111508.547"></t>
<t tx="ekr.20060206111508.548">@nocolor

- Replaced k.tkBindingFromSetting by k.shortcutFromSetting.
- Replaced k.canonicalizeShortcut by k.shortcutFromSetting.
- Replaced k.bindShortcut with bindKey.
- k.makeBindingsFromCommandsDict does not call k.bindKey for mode bindings.</t>
<t tx="ekr.20060206111508.550">@nocolor

This is logically and practically dubious.
True, a screen redraw shouldn't mess with the focus,
but there are the following problems:

1. c.endUpdate can happen anytime, and it could interfere with other efforts to set focus.
2. g.app.get_focus might get the 'wrong' or a 'bad' focus.</t>
<t tx="ekr.20060206111508.553"></t>
<t tx="ekr.20060206111508.596">A *major* improvement to the tree allocation code:

1.  Use p.key() to as keys to tree.visibleText.
 This greatly speeds up tree.findEditWidget

2. Eliminated the brain-dead requirement that previously-allocated widgets must match the position.
   - The allocation code just gets *any* previously allocated widget.
     This eliminates an n**2 search!
   - The ancient problem was that theId refers to the *window* not its Text widget:
     the *window* must be moved to the right spot.

3. recycleWidgets is simpler and a bit faster.

4. destroyWidgets now works: (the bug was not clearing tree.ids).</t>
<t tx="ekr.20060206111508.620">@nocolor

- Mode help should show commands first, not bindings.
- Fixed-space font looks much better in log.
- All log panes now use proper font setting.
- Eliminated clone-find-all, selection-only, show-context checkboxes in the Find tab.
- Eliminated toggle-find-clone-find-all-option command</t>
<t tx="ekr.20060206111508.621">@nocolor

- Fixed bug in strokeFromEvent.

- Replaced some calls to g.app.gui.get_focus: This is unreliable.  More should be removed.

- Fixed masterMenuHandler.

- Removed master click handlers: not needed.
    - Added FocusIn, FocusOut bindings. (Moved code from masterClickHandler).

- Made many changes so that modes work again with k.masterKeyHandler.

- Minibuffer finds now work.
    - New search-again command: it reverts to find-with-present-options if there is no search pattern.
    - Added support for minibufferSearchesShowFindTab option.

- Revised @find mode.  It is now usable and is bound to Ctrl-F.

- Made toggle-find-regex-options work.</t>
<t tx="ekr.20060206111508.622">@nocolor

- Special keys now work in all modes uniformly.

The Aha was to honor 'mini' bindings first in k.masterKeyHandler.

- Added gc traces every 100 keystrokes, every command, every 10 redraws.

- There is no doubt about it: the focus is being ripped into the headline sometimes.

*** This is *totally weird*: tkFrame.set_focus was setting c to a tkFrame(!!)
    - How did the call to c.config ever work???????????????????

- Changed calling sequence of g.app.gui.get_focus so it takes a commander, not a frame.
    - This makes gui.get_focus use the same calling sequence as g.set_focus.

- Added traces that report weird focus issues.

- k.setLabel now restores the focus.

- Changed find keystrokes:
    - Bound Ctrl-F to search-with-present-options.
    - Eliminate Find mode: I never used it.
    - Bound Shift-Ctrl-F to find-options mode.

- Added c.gui ivar and c.set_focus and c.get_focus methods.  Useful abbreviations.

- Fixed bug in createModeBindings: it must not call k.strokeFromSetting again.

- Revised replace-string command so it sets up arguments for Tab find.
    - This is different from the normal Emacs replace-string command, but it works well in Leo.

- Added smaller Find/Change text in Find Tab when show_only_find_tab_options is True.
  It is often helpful to see this state.

- Enable minibufferSearchesShowFindTab.  This turns out to be quite useful and natural.

- Replaced frame.xWantsFocus with c.xWantsFocus.

- Restored masterClickHandlers.  FocusOut can not do the job.

* Giant breakthrough:  The problem with focus 'sticking' in the Pmw.Notebook was due to a call to bringToFront.  Apparently, the side effect was to assign a focus to the widget that had it previously.  This makes sense, and can not be considered a Tk bug.

- With this breakthrough, I have been able to remove almost all calls to w.update in Leo.

* Also, I can not dispense with the calls to w.after that were used to draw the status line.  The master key and click handlers now call the update method directly.  This may ease a major stress on Tk.</t>
<t tx="ekr.20060206111600"></t>
<t tx="ekr.20060206111717"></t>
<t tx="ekr.20060206111717.1"></t>
<t tx="ekr.20060206111853"></t>
<t tx="ekr.20060206112001"></t>
<t tx="ekr.20060210070421">Leo's extensions folder contains Pmw in official distributions, but not in the
Cvs repository, so you won't be able to use a Leo in a sandbox unless you copy
Pmw to the extensions folder or have Pmw otherwise availble on Python's path.</t>
<t tx="ekr.20060211104746.1">@nocolor

- Ran Leo with Python23 to test memory allocation.

- Call update_idletasks when writing to the log.

- Fixed several tree bugs.

- Updated selection point immediately in masterKeyHandler.
  Otherwise, updateStatusLine would be one click behind.</t>
<t tx="ekr.20060211104746.2"></t>
<t tx="ekr.20060211104746.3">@nocolor

In the new drawing scheme, tree.redraw_now always calls c.endEditing, which
calls tree.onHeadChanged. The effect of this was to reverse the action of
undo/redoNodeContents.

The solution was to change the edit widget directly before calling
tree.redraw_now. To do this, I created the new tree.setHeadline method.</t>
<t tx="ekr.20060211104746.4"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.trace_gc:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            g.trace(self.redrawCount,g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20060211104746.5">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20060211104746.6">def editLabel (self,p):
    
    """Start editing p's headline."""
    
    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p
    
    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget'))

    if p and p.edit_widget():
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.</t>
<t tx="ekr.20060211104746.7"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; u = c.undoer ; w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        if self.trace_edit and not g.app.unitTesting:
            if changed:
                g.trace('changed: old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
</t>
<t tx="ekr.20060211104746.8"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20060211104746.9">def undoNodeContents (self):
    
    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''
    
    u = self ; c = u.c
    
    u.p.setTnodeText(u.oldBody)
    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead) # New in 4.4b2.

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setTextSelection(u.oldSel)
    
    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()</t>
<t tx="ekr.20060211104746.10">def redoNodeContents (self):
    
    u = self ; c = u.c
    
    u.p.setTnodeText(u.newBody)
    u.p.initHeadString(u.newHead)
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.
    
    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)
    
    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setTextSelection(u.newSel)
    
    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()</t>
<t tx="ekr.20060211104746.11">def setHeadline (self,p,s):
    
    '''Set the actual text of the headline widget.
    
    This is called from the undo/redo logic to change the text before redrawing.'''
    
    w = self.edit_widget(p)
    if w:
        w.configure(state='normal')
        w.delete('1.0','end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert('1.0',s)
        self.revertHeadline = s
        # g.trace(repr(s),w.get('1.0','end'))
    else:
        g.trace('-'*20,'oops')</t>
<t tx="ekr.20060211104746.12"></t>
<t tx="ekr.20060211104746.13">@nocolor

* Found the reason why focus was *still* sticking in the outline pane:
    - The click handlers must return 'break', not continue.
    - However, OnActivateHeadline must return 'continue' when the headline is active
      so that Tk will handle the click properly.

- UNL does not seem to be causing problems.

- No need to save/restore focus in status line.

- Added several new traces to tkTree class.

* tree.redraw_now now ends editing properly. This fixes lots of bugs. In
particular, it avoid any chance that p.edit_widget won't correspond to the
present position.

- k.masterClickHandler calls tree.OnDeactivate() if there is no callback function.
  This solves most headline focus problems, provided that all panes bind clicks to k.masterClickHandler.

- toggle-active-pane now ends editing properly.

- insert-headline now calls c.editPosition after calling c.endUpdate().</t>
<t tx="ekr.20060211104746.14"></t>
<t tx="ekr.20060211104746.15">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)
    
    # Configuration and debugging settings.
    self.stayInTree             = c.config.getBool('stayInTreeAfterSelect')
    self.expanded_click_area    = c.config.getBool("expanded_click_area")
    
    self.trace                  = c.config.getBool('trace_tree')
    self.trace_alloc            = c.config.getBool('trace_tree_alloc')
    self.trace_edit             = c.config.getBool('trace_tree_edit')
    self.trace_gc               = c.config.getBool('trace_gc')
    self.trace_redraw_now       = c.config.getBool('trace_redraw_now')
    self.trace_select           = c.config.getBool('trace_select')
    self.trace_stats            = c.config.getBool('show_tree_stats')
 
    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    
    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets
   
    self.freeUserIcons = []</t>
<t tx="ekr.20060211104746.16">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20060211104746.17"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)</t>
<t tx="ekr.20060211104746.18"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20060211104746.19">def setBindings (self):
    
    '''Create master bindings for all headlines.'''
    
    tree = self ; k = self.c.k
    
    &lt;&lt; make bindings for a common binding widget &gt;&gt;

    self.canvas.bind('&lt;Key&gt;',k.masterKeyHandler)
    self.canvas.bind('&lt;Button-1&gt;',self.onTreeClick)

    &lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</t>
<t tx="ekr.20060211104746.20">self.bindingWidget = t = Tk.Text(self.canvas,name='bindingWidget')

t.bind('&lt;Key&gt;',k.masterKeyHandler)

table = (
    ('&lt;Button-1&gt;',       k.masterClickHandler,          tree.onHeadlineClick),
    ('&lt;Button-3&gt;',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('&lt;Double-Button-1&gt;',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('&lt;Double-Button-3&gt;',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        return handler(event,func)
    t.bind(a,treeBindingCallback)
    
self.textBindings = t.bindtags()</t>
<t tx="ekr.20060211104746.21">where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '&lt;Button-1&gt;',self.onClickBoxClick),
    ('iconBox','&lt;Button-1&gt;',self.onIconBoxClick),
    ('iconBox','&lt;Double-1&gt;',self.onIconBoxDoubleClick),
    ('iconBox','&lt;Button-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;Double-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;B1-Motion&gt;',self.onDrag),
    ('iconBox','&lt;Any-ButtonRelease-1&gt;',self.onEndDrag),
)
for tag,event,callback in table:
    self.canvas.tag_bind(tag,event,callback)</t>
<t tx="ekr.20060211104746.22">def injectCallbacks(self):
    
    &lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):
        
        g.funcToMethod(f,leoNodes.position)</t>
<t tx="ekr.20060211104746.23"># N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others

</t>
<t tx="ekr.20060211104746.24">def OnHyperLinkControlClick (self,event):
    
    """Callback injected into position class."""
    
    p = self ; c = p.c
    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")</t>
<t tx="ekr.20060211104746.25">def OnHyperLinkEnter (self,event=None):
    
    """Callback injected into position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")</t>
<t tx="ekr.20060211104746.26">def OnHyperLinkLeave (self,event=None):
    
    """Callback injected into position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")</t>
<t tx="ekr.20060211104746.27"></t>
<t tx="ekr.20060211104746.28"></t>
<t tx="ekr.20060211104746.29">def checkWidgetList (self,tag):
    
    return True # This will fail when the headline actually changes!
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
            
            if h != s:
                self.dumpWidgetList(tag)
                return False
        else:
            self.dumpWidgetList(tag)
            return False
            
    return True</t>
<t tx="ekr.20060211104746.30">def dumpWidgetList (self,tag):
    
    print
    print "checkWidgetList: %s" % tag
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
    
            addr = self.textAddr(t)
            print "p:",addr,h
            if h != s:
                print "t:",'*' * len(addr),s
        else:
            print "t.leo_position == None",t</t>
<t tx="ekr.20060211104746.31">def edit_widget (self,p):
    
    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
    
edit_text = edit_widget # For compatibility.</t>
<t tx="ekr.20060211104746.32">def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)
    
    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId:
            g.es_print('oops: eventToPosition failed')
            return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)
    
    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.headString())
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)
        
    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None</t>
<t tx="ekr.20060211104746.33">def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c

    if p and c:
        aTuple = self.visibleText.get(p.key())
        if aTuple:
            t,theId = aTuple
            # if self.trace: g.trace('%4d' % (theId),self.textAddr(t),p.headString())
            return t
        else:
            # g.trace('oops: not found',p)
            return None

    # g.trace(not found',p.headString())
    return None</t>
<t tx="ekr.20060211104746.34">def findPositionWithIconId (self,theId):
    
    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.headString())
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None</t>
<t tx="ekr.20060211104746.35"></t>
<t tx="ekr.20060211104746.36">def onClickBoxClick (self,event,p=None):
    
    c = self.c ; p1 = c.currentPosition()
    
    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing()
            self.active = True
            if p == p1 or c.config.getBool('initialClickExpandsOrContractsNode'):
                if p.isExpanded(): p.contract()
                else:              p.expand()
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060211104746.37"></t>
<t tx="ekr.20060211104746.38">def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        if c.config.getBool("allow_clone_drags"):
            if not c.config.getBool("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown
    
        if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
            &lt;&lt; drag p to vdrag &gt;&gt;
        elif self.trace and self.verbose:
            g.trace("Cancel drag")
        
        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.</t>
<t tx="ekr.20060211104746.39">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="ekr.20060211104746.40"># g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)</t>
<t tx="ekr.20060211104746.41"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    
    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"</t>
<t tx="ekr.20060211104746.42">def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")</t>
<t tx="ekr.20060211104746.43"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y &lt; 0 or y &gt; h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.</t>
<t tx="ekr.20060211104746.44">def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20060211104746.45">def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20060211104746.46"></t>
<t tx="ekr.20060211104746.47">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''
    
    # g.trace(g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20060211104746.48">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    # g.trace(repr(ch))
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20060211104746.49"></t>
<t tx="ekr.20060211104746.50">def onIconBoxClick (self,event,p=None):
    
    c = self.c ; tree = self
    
    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20060211104746.51">def onIconBoxRightClick (self,event,p=None):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return 'break'
</t>
<t tx="ekr.20060211104746.52">def onIconBoxDoubleClick (self,event,p=None):
    
    c = self.c

    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20060211104746.53">def OnActivateHeadline (self,p,event=None):
    
    '''Handle common process when any part of a headline is clicked.'''
    
    # g.trace(p.headString())
    
    returnVal = 'break' # Default: do nothing more.

    try:
        c = self.c
        c.setLog()
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")
        
    return returnVal</t>
<t tx="ekr.20060211104746.54">if p == c.currentPosition():
    # g.trace("is current")
    # The *second* click in the headline starts editing.
    if self.active:
        self.editLabel(p)
        returnVal = 'continue'
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.treeWantsFocusNow()
        returnVal = 'break'
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    returnVal = 'break'

# The next click *in the same headline* will start editing.
self.active = True</t>
<t tx="ekr.20060211104746.55"></t>
<t tx="ekr.20060211104746.56">def configureTextState (self,p):
    
    if not p: return
    
    if p.isCurrentPosition():
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected</t>
<t tx="ekr.20060211104746.57"># This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"</t>
<t tx="ekr.20060211104746.58">def onHeadlineClick (self,event,p=None):
    
    c = self.c ; w = event.widget
    
    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'
        
    # g.trace(p.headString())
    
    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal</t>
<t tx="ekr.20060211104746.59">def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        g.trace('*'*20,'oops')
        return 'break'
        
    c.setLog()

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    # 'continue' *is* correct here.
    # 'break' would make it impossible to unselect the headline text.
    return 'continue'
</t>
<t tx="ekr.20060211104746.60">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
    
    # g.trace(g.callers())
   
    c.beginUpdate()
    try:
        tree.endEditLabel()
        tree.dimEditLabel()
    finally:
        c.endUpdate(False)</t>
<t tx="ekr.20060211104746.61">def OnPopup (self,p,event):
    
    """Handle right-clicks in the outline.
    
    This is *not* an event handler: it is called from other event handlers."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        c.setLog()

        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"</t>
<t tx="ekr.20060211104746.62">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.popupMenu.unpost()</t>
<t tx="ekr.20060211104746.63">def createPopupMenu (self,event):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)
        
    &lt;&lt; Create the menu table &gt;&gt;
    
    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)</t>
<t tx="ekr.20060211104746.64">table = (
    ("&amp;Read @file Nodes",c.readAtFileNodes),
    ("&amp;Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&amp;Tangle",c.tangle),
    ("&amp;Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &amp;Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&amp;Paste Node",c.pasteOutline),
    ("&amp;Delete Node",c.deleteOutline),
    ("-",None),
    ("&amp;Insert Node",c.insertHeadline),
    ("&amp;Clone Node",c.clone),
    ("Sort C&amp;hildren",c.sortChildren),
    ("&amp;Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)</t>
<t tx="ekr.20060211104746.65">def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; menu = self.popupMenu

    &lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)
    
    enable = self.frame.menu.enableMenu
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())</t>
<t tx="ekr.20060211104746.66">isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True
        
    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True</t>
<t tx="ekr.20060211104746.67">def showPopupMenu (self,event):
    
    """Show a popup menu."""
    
    c = self.c ; menu = self.popupMenu

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Set the focus immediately so we know when we lose it.
    c.widgetWantsFocus(menu)</t>
<t tx="ekr.20060211104746.68">def onTreeClick (self,event=None):
    
    '''Handle an event in the tree canvas, outside of any tree widget.'''
    
    c = self.c

    c.treeWantsFocusNow()
    
    return 'break'</t>
<t tx="ekr.20060211104746.69">set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False</t>
<t tx="ekr.20060211104746.70"></t>
<t tx="ekr.20060211104746.71">def bringToFront (self):
    self.top.deiconify()
    self.top.lift()

def getFocus(self):
    """Returns the widget that has focus, or body if None."""
    try:
        # This method is unreliable while focus is changing.
        # The call to update_idletasks may help.  Or not.
        self.top.update_idletasks()
        f = self.top.focus_displayof()
    except Exception:
        f = None
    if f:
        return f
    else:
        return self.bodyCtrl
        
def getTitle (self):
    return self.top.title()
    
def setTitle (self,title):
    return self.top.title(title)
    
def get_window_info(self):
    return g.app.gui.get_window_info(self.top)
    
def iconify(self):
    self.top.iconify()

def deiconify (self):
    self.top.deiconify()
    
def lift (self):
    self.top.lift()
    
def update (self):
    self.top.update()</t>
<t tx="ekr.20060211104746.72">def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w):
    
    c = self
    
    if 1: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
    
    else: # Safer, perhaps.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)</t>
<t tx="ekr.20060211104746.73">def setInputState (self,state,showState=False):

    k = self ; c = k.c

    k.unboundKeyAction = state
    if state != 'insert' or showState:
        k.showStateAndMode()</t>
<t tx="ekr.20060211104746.74">def showStateAndMode(self):
    
    k = self ; c = k.c ; frame = c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind()
   
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        put = frame.putStatusLine
        if state != 'insert':
            put('state: ',color='blue')
            put(state)
        if mode:
            put(' mode: ',color='blue')
            put(mode)
            
        # Restore the focus.
        c.restoreFocus()</t>
<t tx="ekr.20060211104746.75"></t>
<t tx="ekr.20060211104746.76"></t>
<t tx="ekr.20060211104746.77">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self,flag=True,scroll=False):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20060211104746.78">def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="ekr.20060211104746.79">def invalidateFocus (self):
    
    '''Indicate that the focus is in an invalid location, or is unknown.'''
    
    c = self
    c.requestedFocusWidget = None
    c.hasFocusWidget = None
    
</t>
<t tx="ekr.20060211104746.80">def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget:
        if trace: g.trace('no change.')
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        g.trace('*'*20,'oops: moving to body pane.')
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler</t>
<t tx="ekr.20060211104746.81">def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True</t>
<t tx="ekr.20060211104746.82">def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)</t>
<t tx="ekr.20060211104746.83">def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now</t>
<t tx="ekr.20060211104746.84">def restoreFocus (self):
    
    '''Ensure that the focus eventually gets restored.'''
    
    c =self
    trace = not g.app.unitTesting and c.config.getBool('trace_focus')

    if c.requestedFocusWidget:
        c.hasFocusWidget = None # Force an update
    elif c.hasFocusWidget:
        c.requestedFocusWidget = c.hasFocusWidget
        c.hasFocusWidget = None # Force an update
    else:
        # Should not happen, except during unit testing.
        # c.masterFocusHandler sets c.hasFocusWidget,
        # so if it is not set here it is because this method cleared it.
        if not g.app.unitTesting: g.trace('oops: no requested or present widget.')
        c.bodyWantsFocusNow()
    
    if c.inCommand:
        if trace: g.trace('expecting later call to c.masterFocusHandler')
        pass # A call to c.masterFocusHandler will surely happen.
    else:
        c.masterFocusHandler() # Do it now.</t>
<t tx="ekr.20060211104746.85">trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        g.trace('%4d' % (c.trace_focus_count),
            c.widget_name(w),g.callers(8))</t>
<t tx="ekr.20060211104746.86">def widget_name (self,widget):
    
    c = self
    
    return c.gui.widget_name(widget)</t>
<t tx="ekr.20060211104746.87">def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
    
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and p.edit_widget())
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)</t>
<t tx="ekr.20060211104746.88">def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    c.set_focus(body and body.bodyCtrl)
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and p.edit_widget())
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w)
</t>
<t tx="ekr.20060211104746.89"></t>
<t tx="ekr.20060211104746.90">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t and t.delete('1.0','end')</t>
<t tx="ekr.20060211104746.91">def createTab (self,tabName):
    
    c = self.c ; k = c.k
    tabFrame = self.nb.add(tabName)
    self.menu = self.makeTabMenu(tabName)
    &lt;&lt; Create the tab's text widget &gt;&gt;

    if tabName != 'Log':
        # c.k doesn't exist when the log pane is created.
        # k.makeAllBindings will call setTabBindings('Log')
        self.setTabBindings(tabName)</t>
<t tx="ekr.20060211104746.92">t = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: t.configure(bg=bg)
except Exception: pass # Could be a user error.

self.SetWidgetFontFromConfig(logCtrl=t)

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = t

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]

self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags</t>
<t tx="ekr.20060211104746.93">def deleteTab (self,tabName):
    
    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell'):
        self.selectTab('Log')
    
    elif tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
        
    # New in Leo 4.4b1.
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
    </t>
<t tx="ekr.20060211104746.94">def hideTab (self,tabName):
    
    __pychecker__ = '--no-argsused' # tabName
    
    self.selectTab('Log')</t>
<t tx="ekr.20060211104746.95">def getSelectedTab (self):
    
    return self.tabName</t>
<t tx="ekr.20060211104746.96">def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()</t>
<t tx="ekr.20060211104746.97">def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)</t>
<t tx="ekr.20060211104746.98">def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    return tabFrame</t>
<t tx="ekr.20060211104746.99">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    text = self.textDict.get(tabName)
    
    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClick3Handler),
    ):
        text.bind(kind,handler)
    
    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        g.trace()
        self.onRightClick(event,menu)
        
    def tabMenuClickCallback(event,tabName=tabName):
        g.trace()
        self.onClick(event,tabName)
    
    tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
    tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)</t>
<t tx="ekr.20060211104746.100"></t>
<t tx="ekr.20060211104746.101">def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)</t>
<t tx="ekr.20060211104746.102">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)</t>
<t tx="ekr.20060211104746.103">def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)</t>
<t tx="ekr.20060211104746.104">def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('&lt;Return&gt;',getNameCallback)</t>
<t tx="ekr.20060211104746.105">#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.</t>
<t tx="ekr.20060211104746.106"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20060211104746.107"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20060211104746.108"># c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20060211104746.109"># The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!</t>
<t tx="ekr.20060211104746.110">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()</t>
<t tx="ekr.20060211104746.111"></t>
<t tx="ekr.20060211104746.112">@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.</t>
<t tx="ekr.20060211104746.113">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)</t>
<t tx="ekr.20060211104746.114">def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None</t>
<t tx="ekr.20060211104746.115"></t>
<t tx="ekr.20060211104746.116"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20060211104746.117">def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20060211104746.118"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) &gt; 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f</t>
<t tx="ekr.20060211104746.119"></t>
<t tx="ekr.20060211104746.120">def get_focus(self,c):
    
    """Returns the widget that has focus, or body if None."""

    return c.frame.top.focus_displayof()</t>
<t tx="ekr.20060211104746.121"></t>
<t tx="ekr.20060211104746.122">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20060211104746.123"></t>
<t tx="ekr.20060211104746.124">def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            &lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None</t>
<t tx="ekr.20060211104746.125">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="ekr.20060211104746.126"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None</t>
<t tx="ekr.20060211104746.127"></t>
<t tx="ekr.20060211104746.128">def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)</t>
<t tx="ekr.20060211104746.129">def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)</t>
<t tx="ekr.20060211104746.130"></t>
<t tx="ekr.20060211104746.131">def firstIndex (self):

    return "1.0"</t>
<t tx="ekr.20060211104746.132">def lastIndex (self):

    return "end"</t>
<t tx="ekr.20060211104746.133">def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
</t>
<t tx="ekr.20060211104746.134">def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20060211104746.135">def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False</t>
<t tx="ekr.20060211104746.136">def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="ekr.20060211104746.137"></t>
<t tx="ekr.20060211104746.138">def getInsertPoint(self,t):
    
    try:
        return t.index("insert")
    except Exception:
        return '1.0'</t>
<t tx="ekr.20060211104746.139">def setInsertPoint (self,t,pos):

    try:
        t.mark_set("insert",pos)
    except Exception:
        pass</t>
<t tx="ekr.20060211104746.140"></t>
<t tx="ekr.20060211104746.141">def getSelectionRange (self,t):
    
    try:
        # Warning: this can return None.
        return t.tag_ranges("sel")
    except Exception:
        return 0,0</t>
<t tx="ekr.20060211104746.142">def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""</t>
<t tx="ekr.20060211104746.143">def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, "&gt;", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert</t>
<t tx="ekr.20060211104746.144">def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j</t>
<t tx="ekr.20060211104746.145">def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))</t>
<t tx="ekr.20060211104746.146">def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return
        
    try:
        if t.compare(start, "&gt;", end):
            start,end = end,start
            
        t.tag_remove("sel","1.0",start)
        t.tag_add("sel",start,end)
        t.tag_remove("sel",end,"end")
        
        # New in 4.4a5: this logic ensures compatibility with previous code.
        if insert == 'sel.end':
            g.app.gui.setInsertPoint(t,end)
        elif insert is not None:
            g.app.gui.setInsertPoint(t,insert)
    except Exception:
        pass
    
setSelectionRange = setTextSelection</t>
<t tx="ekr.20060211104746.147"></t>
<t tx="ekr.20060211104746.148">def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20060211104746.149">def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c","&gt;=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060211104746.150">def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060211104746.151">def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060211104746.152">def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)</t>
<t tx="ekr.20060211104746.153">def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)</t>
<t tx="ekr.20060211104746.154"></t>
<t tx="ekr.20060211104746.155">def makeIndexVisible(self,t,index):

    return t.see(index)</t>
<t tx="ekr.20060211104746.156">def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) </t>
<t tx="ekr.20060211104746.157">def bringToFront (self):
    
    """Bring the tkinter Find Panel to the front."""
    
    c = self.c ; t = self.find_ctrl ; gui = g.app.gui
            
    self.top.withdraw() # Helps bring the window to the front.
    self.top.deiconify()
    self.top.lift()
    c.widgetWantsFocusNow(t)
    
    # Apparently, the text can not be adjusted unless the widget has focus...
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # New in 4.3: don't highlight the stupid added trailing newline!
    gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.</t>
<t tx="ekr.20060211104746.158"># Restores the screen after a search fails

def restore (self,data):

    c = self.c ; gui = g.app.gui
    in_headline,p,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)
    
    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        gui.setSelectionRange(t,insert,insert)
        gui.setInsertPoint(t,insert)
        gui.makeIndexVisible(t,insert)
    
    #g.trace(c.widget_name(t))
    
    if 1: # I prefer always putting the focus in the body.
        c.bodyWantsFocusNow()
    else:
        c.widgetWantsFocusNow(t)</t>
<t tx="ekr.20060211104746.159">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    gui.setSelectionRange(t,pos,newpos,insert=insert)
    c.widgetWantsFocusNow(t)
    gui.makeIndexVisible(t,insert)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20060211104746.160"></t>
<t tx="ekr.20060211104746.161">def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.</t>
<t tx="ekr.20060211104746.162"></t>
<t tx="ekr.20060211104746.163">@nocolor

Backspace in empty body text sometimes moved focus to canvas, and sometimes
improperly drew icon.

Made several fixes to onBodyChanged. There was no test for unchanged text! This
could have created all sorts of problems for undo.</t>
<t tx="ekr.20060211104746.164"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    # ch = bodyCtrl.get('insert-1c')
    newText = bodyCtrl.get('1.0','end')
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    changed = oldText != newText
    if 0:
        g.trace('removeTrailing',removeTrailing,'changed',changed,
            'ch',repr(ch),'newText',repr(newText),'oldText',repr(oldText),
            g.callers())
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        &lt;&lt; recolor the body &gt;&gt;
        if not c.changed: c.setChanged(True)
        &lt;&lt; redraw the screen if necessary &gt;&gt;</t>
<t tx="ekr.20060211104746.165">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True</t>
<t tx="ekr.20060211104746.166">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False</t>
<t tx="ekr.20060211104746.167">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)</t>
<t tx="ekr.20060211104746.168">@ This revealed several problems:
    
- Most find dialog commands do not actually exist. All find commands except
open-find-dialog actuall refer to the find tab.

- Severl other minor shortcut problems.</t>
<t tx="ekr.20060211104746.169"></t>
<t tx="ekr.20060211104746.170">command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self ; p = c.currentPosition()
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and (
        c.config.getBool('trace_doCommand') or
        c.config.getBool('trace_gc') and (self.command_count % 10) == 0
    ):
        commandName = command and command.__name__
        g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            c.inCommand = False
            if c and c.exists: # Be careful: the command could destroy c.
                c.k.funcReturn = val
        except:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es("exception executing command")
                print "exception executing command"
                g.es_exception(c=c)
                if c and c.exists and hasattr(c,'frame'):
                    c.redraw_now()
                    
        if c and c.exists and c.requestCloseWindow:
            g.trace('Closing window after command')
            c.requestCloseWindow = False
            g.app.closeLeoWindow(c.frame)

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)
            
    return "break" # Inhibit all other handlers.</t>
<t tx="ekr.20060211104746.171"></t>
<t tx="ekr.20060211104746.172">def prettyPrintKey (self,stroke):
    
    s = stroke and stroke.strip().lstrip('&lt;').rstrip('&gt;')
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]

    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()

    return '&lt;%s&gt;' % s</t>
<t tx="ekr.20060211104746.173">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and k.prettyPrintKey(accelerator).lstrip('&lt;').rstrip('&gt;')
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)</t>
<t tx="ekr.20060211104746.174">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20060211104746.175"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20060211104746.176">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20060211104746.177"></t>
<t tx="ekr.20060211104746.178">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3549737

for extend selection,
with binding to arrow keys,
if you switch from up to dn arrow,
the selection restarts again.
this should just change extend direction
while still using the same selection.
</t>
<t tx="ekr.20060211104746.179">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)

    if c.config.getBool('trace_masterClickHandler'):
        g.trace(wname,func and func.__name__)

    if k.inState('full-command') and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        g.es_print('Ignoring click outside active minibuffer',color='blue')
        c.minibufferWantsFocus()
        return 'break'

    # Update the selection point immediately for updateStatusLine.
    if wname.startswith('body'):
        i = w.index('@%s,%s' % (event.x,event.y))
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(w,i)
        c.frame.updateStatusLine()
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol &lt;= xcol &lt;= jcol)
        if icol &lt;= xcol &lt;= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else: return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler</t>
<t tx="ekr.20060211104746.180">def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    # Make the insertion cursor visible so bbox won't return an empty list.
    w.see('insert')
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y &lt;= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y &gt;= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col &gt;= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.see('insert')
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)</t>
<t tx="ekr.20060211104746.181">def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocusNow(w)

    wname = c.widget_name(w)
    if wname.startswith('mini'):
        # Put the request in the proper range.
        i, j = k.getEditableTextRange()
        ins1 = w.index('insert')
        spot = w.index(spot)
        if w.compare(spot,'&lt;',i):
            spot = i
        elif w.compare(spot,'&gt;',j):
            spot = j
        w.mark_set('insert',spot)
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see(spot)
    else:
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')

        # Move to the spot.
        w.mark_set('insert',spot)
        spot = w.index('insert')

        # Handle the selection.
        self.extendHelper(w,extend,ins1,spot,setSpot=True)
        w.see(spot)</t>
<t tx="ekr.20060211104746.182">def extendHelper (self,w,extend,ins1,spot,setSpot=True):

    '''Handle the details of extending the selection.
    
    extend: Clear the selection unless this is True.
    ins1:   The *previous* insert point.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    moveSpot = self.moveSpot
    if extend or self.extendMode:
        i, j = g.app.gui.getTextSelection(w)
        if (
            not moveSpot or p.v.t != self.moveSpotNode or
            i == j or # A cute trick
            (not w.compare(moveSpot,'==',i) and
             not w.compare(moveSpot,'==',j))
        ):
            self.moveSpotNode = p.v.t
            self.moveSpot = w.index(ins1)
            self.moveCol = int(ins1.split('.')[1])
            # g.trace('reset moveSpot',self.moveSpot)
        moveSpot = self.moveSpot
        # g.trace(spot,moveSpot)
        if w.compare(spot,'&lt;',moveSpot):
            g.app.gui.setTextSelection(w,spot,moveSpot,insert=None)
        else:
            g.app.gui.setTextSelection(w,moveSpot,spot,insert=None)
    else:
        # Don't change the moveCol while extending: that would mess up the selection.
        if setSpot or not moveSpot:
            self.setMoveCol(w,spot)
        g.app.gui.setTextSelection(w,spot,spot,insert=None)</t>
<t tx="ekr.20060211104746.183">def setMoveCol (self,w,spot):
    
    self.moveSpot = spot
    self.moveCol = int(spot.split('.')[1])

    # g.trace('spot',self.moveSpot,'col',self.moveCol)</t>
<t tx="ekr.20060211104746.184"></t>
<t tx="ekr.20060211104746.185"></t>
<t tx="ekr.20060211104746.186">def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)</t>
<t tx="ekr.20060211104746.187">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'&lt;',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'&gt;',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060211104746.188">def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060211104746.189">def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    ins = w.index('insert')
    # sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060211104746.190">def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060211104746.191">def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060211104746.192">def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)</t>
<t tx="ekr.20060211104746.193">def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)</t>
<t tx="ekr.20060211104746.194">def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
</t>
<t tx="ekr.20060211104746.195">def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
</t>
<t tx="ekr.20060211104746.196">def beginningOfLine (self,event):
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    self.moveUpOrDownHelper(event,'down',extend=False)
    
def nextLineExtendSelection (self,event):
    self.moveUpOrDownHelper(event,'down',extend=True)
    
def prevLine (self,event):
    self.moveUpOrDownHelper(event,'up',extend=False)
    
def prevLineExtendSelection (self,event):
    self.moveUpOrDownHelper(event,'up',extend=True)</t>
<t tx="ekr.20060211104746.197">def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)</t>
<t tx="ekr.20060211104746.198">def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)</t>
<t tx="ekr.20060211104746.199">def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)</t>
<t tx="ekr.20060211104746.200">def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20060211104746.201"># Made sure bindings can end in '+' and '-'</t>
<t tx="ekr.20060211104746.202">def shortcutFromSetting (self,setting):

    if not setting:
        return None

    s = setting.strip()
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting</t>
<t tx="ekr.20060211104746.203">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0

if sys.platform == "darwin":
    if ctrl and not cmd:
        cmd = True ; ctrl = False
    if alt and not ctrl:
        ctrl = True ; alt = False</t>
<t tx="ekr.20060211104746.204"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')</t>
<t tx="ekr.20060211104746.205">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    if shift:
        last = last.upper()
        shift = False
    else:
        last = last.lower()
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)</t>
<t tx="ekr.20060211104746.206">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Cmnd+'),
    (shift,'Shift+'),
    (True,last),
)
    
shortcut = ''.join([val for flag,val in table if flag])</t>
<t tx="ekr.20060211104746.207"></t>
<t tx="ekr.20060211104746.208"></t>
<t tx="ekr.20060211104746.209"></t>
<t tx="ekr.20060211104746.210">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()</t>
<t tx="ekr.20060211104746.211">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('full-command')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    trace = c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = c.get_focus()
        k.setState('full-command',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        c.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20060211104746.212"># Not having it is confusing.</t>
<t tx="ekr.20060211104746.213"></t>
<t tx="ekr.20060211104746.214">class editCommandsClass (baseEditCommandsClass):
    
    '''Contains editing commands with little or no state.'''

    @others</t>
<t tx="ekr.20060211104746.215"></t>
<t tx="ekr.20060211104746.216">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.widget = None # For use by state handlers.</t>
<t tx="ekr.20060211104746.217">def getPublicCommands (self):        

    c = self.c ; k = self.k

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,        
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20060211104746.218"></t>
<t tx="ekr.20060211104746.219">def capitalizeWord (self,event):
    self.capitalizeHelper(event,'cap')

def downCaseWord (self,event):
    self.capitalizeHelper(event,'low')

def upCaseWord (self,event):
    self.capitalizeHelper(event,'up')</t>
<t tx="ekr.20060211104746.220">def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke ; w = event.widget
    i = w.index('insert')

    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '&lt;Alt-c&gt;':
        self.capitalizeWord(event)
    elif stroke == '&lt;Alt-u&gt;':
         self.upCaseWord(event)
    elif stroke == '&lt;Alt-l&gt;':
        self.downCaseWord(event)

    w.mark_set('insert',i)</t>
<t tx="ekr.20060211104746.221">def capitalizeHelper (self,event,which):

    w = event.widget
    text = w.get('insert wordstart','insert wordend')
    i = w.index('insert')
    if text == ' ': return
    w.delete('insert wordstart','insert wordend')
    if which == 'cap':
        text = text.capitalize()
    if which == 'low':
        text = text.lower()
    if which == 'up':
        text = text.upper()
    w.insert('insert',text)
    w.mark_set('insert',i)
    
</t>
<t tx="ekr.20060211104746.222"></t>
<t tx="ekr.20060211104746.223">def activateCmdsMenu    (self,event=None): self.activateMenu('Cmds')
def activateEditMenu    (self,event=None): self.activateMenu('Edit')
def activateFileMenu    (self,event=None): self.activateMenu('File')
def activateHelpMenu    (self,event=None): self.activateMenu('Help')
def activateOutlineMenu (self,event=None): self.activateMenu('Outline')
def activatePluginsMenu (self,event=None): self.activateMenu('Plugins')
def activateWindowMenu  (self,event=None): self.activateMenu('Window')

def activateMenu (self,menuName):
    c = self.c
    c.frame.menu.activateMenu(menuName)</t>
<t tx="ekr.20060211104746.224">def cycleFocus (self,event):

    c = self.c
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i &gt;= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    c.set_focus(pane)</t>
<t tx="ekr.20060211104746.225">def focusToBody (self,event):
    
    self.c.bodyWantsFocus()

def focusToLog (self,event):

    self.c.logWantsFocus()
    
def focusToMinibuffer (self,event):
    
    self.c.minibufferWantsFocus()

def focusToTree (self,event):
    
    self.c.treeWantsFocus()</t>
<t tx="ekr.20060211104746.226"># These call the actual event handlers so as to trigger hooks.

def clickHeadline (self,event=None):

    '''Simulate a click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineClick(event,p=p)
    
def doubleClickHeadline (self,event=None):
    return self.clickHeadline(event)

def rightClickHeadline (self,event=None):

    '''Simulate a double-click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineRightClick(event,p=p)</t>
<t tx="ekr.20060211104746.227"># These call the actual event handlers so as to trigger hooks.

def clickIconBox (self,event=None):

    '''Simulate a click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxClick(event,p=p)

def doubleClickIconBox (self,event=None):

    '''Simulate a double-click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxDoubleClick(event,p=p)

def rightClickIconBox (self,event=None):

    '''Simulate a right click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxRightClick(event,p=p)</t>
<t tx="ekr.20060211104746.228"># Call the actual event handlers so as to trigger hooks.

def clickClickBox (self,event=None):

    '''Simulate a click in the click box (+- box) of the presently selected headline.'''

    c = self.c ; p = c.currentPosition()
    c.frame.tree.onClickBoxClick(event,p=p)</t>
<t tx="ekr.20060211104746.229"># These call the drag setup methods which in turn trigger hooks.

def simulateBeginDrag (self,event=None):

    '''Simulate the start of a drag in the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.startDrag(event,p=p)

def simulateEndDrag (self,event=None):

    '''Simulate the end of a drag in the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    
    # Note: this assumes that tree.startDrag has already been called.
    c.frame.tree.endDrag(event)</t>
<t tx="ekr.20060211104746.230"></t>
<t tx="ekr.20060211104746.231">def showColors (self,event):
    
    c = self.c ; log = c.frame.log ; tabName = 'Colors'
    
    &lt;&lt; define colors &gt;&gt;
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        f = log.frameDict.get(tabName)
        self.createColorPicker(f,colors)
</t>
<t tx="ekr.20060211104746.232">colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )</t>
<t tx="ekr.20060211104746.233">def createColorPicker (self,parent,colors):
    
    colors = list(colors)
    bg = parent.cget('background')
    
    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)
    
    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')
    
    label = Tk.Text(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    &lt;&lt; create optionMenu and callback &gt;&gt;
    &lt;&lt; create picker button and callback &gt;&gt;</t>
<t tx="ekr.20060211104746.234">colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)</t>
<t tx="ekr.20060211104746.235">def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)</t>
<t tx="ekr.20060211104746.236">def showFonts (self,event):

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.createFontPicker(f)</t>
<t tx="ekr.20060211104746.237">def createFontPicker (self,parent):

    bg = parent.cget('background')
    font = self.getFont()
    &lt;&lt; create the frames &gt;&gt;
    &lt;&lt; create the family combo box &gt;&gt;
    &lt;&lt; create the size entry &gt;&gt;
    &lt;&lt; create the weight combo box &gt;&gt;
    &lt;&lt; create the slant combo box &gt;&gt;
    &lt;&lt; create the sample text widget &gt;&gt;
    &lt;&lt; create and bind the callbacks &gt;&gt;</t>
<t tx="ekr.20060211104746.238">f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')</t>
<t tx="ekr.20060211104746.239">names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'&lt;None&gt;')

familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060211104746.240">Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4) ##,textvariable=sv)
sizeEntry.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20060211104746.241">weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['&lt;None&gt;','normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060211104746.242">slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['&lt;None&gt;','roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060211104746.243">sample = Tk.Text(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert('1.0',s)</t>
<t tx="ekr.20060211104746.244">def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('&lt;Return&gt;',fontCallback)</t>
<t tx="ekr.20060211104746.245">def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20060211104746.246">def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','&lt;none&gt;',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)</t>
<t tx="ekr.20060211104746.247"></t>
<t tx="ekr.20060211104746.248">def setCommentColumn (self,event):

    cc = event.widget.index('insert')
    cc1, cc2 = cc.split('.')
    self.ccolumn = cc2</t>
<t tx="ekr.20060211104746.249">def indentToCommentColumn (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert lineend')
    i1, i2 = i.split('.')
    i2 = int(i2)
    c1 = int(self.ccolumn)

    if i2 &lt; c1:
        wsn = c1- i2
        w.insert('insert lineend',' '*wsn)
    if i2 &gt;= c1:
        w.insert('insert lineend',' ')
    w.mark_set('insert','insert lineend')</t>
<t tx="ekr.20060211104746.250"></t>
<t tx="ekr.20060211104746.251">def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k ; w = event.widget
    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
</t>
<t tx="ekr.20060211104746.252">def dynamicExpansion2 (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)</t>
<t tx="ekr.20060211104746.253">def getDynamicList (self,w,txt,rlist):

     ttext = w.get('1.0','end')
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)</t>
<t tx="ekr.20060211104746.254"></t>
<t tx="ekr.20060211104746.255">def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        hi1 = k.keysymHistory [0]
        hi2 = k.keysymHistory [1]
        if state == 'esc esc' and event.keysym == 'colon':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        elif hi1 == hi2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)</t>
<t tx="ekr.20060211104746.256">def escEvaluate (self,event):

    k = self.k ; w = event.widget

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)</t>
<t tx="ekr.20060211104746.257">def evalExpression (self,event):

    k = self.k ; state = k.getState('eval-expression')
    
    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -&gt; %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)</t>
<t tx="ekr.20060211104746.258">@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap
after an center-region command via Alt-x.


@c


@others</t>
<t tx="ekr.20060211104746.259">def centerLine (self,event):

    '''Centers line within current fillColumn'''

    k = self.k ; w = event.widget

    ind = w.index('insert linestart')
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    if len(txt) &gt;= self.fillColumn: return

    amount = (self.fillColumn-len(txt)) / 2
    ws = ' ' * amount
    col, nind = ind.split('.')
    ind = w.search('\w','insert linestart',regexp=True,stopindex='insert lineend')
    if ind:
        w.delete('insert linestart','%s' % ind)
        w.insert('insert linestart',ws)</t>
<t tx="ekr.20060211104746.260">def setFillColumn (self,event):

    k = self.k ; state = k.getState('set-fill-column')
    
    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()</t>
<t tx="ekr.20060211104746.261">def centerRegion( self, event ):

    '''This method centers the current region within the fill column'''

    k = self.k ; w = event.widget
    start = w.index( 'sel.first linestart' )
    sindex , x = start.split( '.' )
    sindex = int( sindex )
    end = w.index( 'sel.last linestart' )
    eindex , x = end.split( '.' )
    eindex = int( eindex )
    while sindex &lt;= eindex:
        txt = w.get( '%s.0 linestart' % sindex , '%s.0 lineend' % sindex )
        txt = txt.strip()
        if len( txt ) &gt;= self.fillColumn:
            sindex = sindex + 1
            continue
        amount = ( self.fillColumn - len( txt ) ) / 2
        ws = ' ' * amount
        ind = w.search( '\w', '%s.0' % sindex, regexp = True, stopindex = '%s.0 lineend' % sindex )
        if not ind: 
            sindex = sindex + 1
            continue
        w.delete( '%s.0' % sindex , '%s' % ind )
        w.insert( '%s.0' % sindex , ws )
        sindex = sindex + 1</t>
<t tx="ekr.20060211104746.262">def setFillPrefix( self, event ):

    w = event.widget
    txt = w.get( 'insert linestart', 'insert' )
    self.fillPrefix = txt</t>
<t tx="ekr.20060211104746.263">def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt</t>
<t tx="ekr.20060211104746.264"></t>
<t tx="ekr.20060211104746.265">def gotoCharacter (self,event):
    
    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto character: ')
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.widget
        if n.isdigit():
            w.mark_set('insert','1.0 +%sc' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()</t>
<t tx="ekr.20060211104746.266">def gotoLine (self,event):
    
    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.widget
        if n.isdigit():
            w.mark_set('insert','%s.0' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()</t>
<t tx="ekr.20060211104746.267"></t>
<t tx="ekr.20060211104746.268">def backToIndentation (self,event):
    
    '''The back-to-indentation command, given anywhere on a line,
    positions the point at the first non-blank character on the line.'''

    w = event.widget
    i = w.index('insert linestart')
    i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    w.mark_set('insert',i2)</t>
<t tx="ekr.20060211104746.269">def deleteIndentation (self,event):

    k = self.k ; w = event.widget

    txt = w.get('insert linestart','insert lineend')
    txt = ' %s' % txt.lstrip()
    w.delete('insert linestart','insert lineend +1c')
    i = w.index('insert - 1c')
    w.insert('insert -1c',txt)
    w.mark_set('insert',i)</t>
<t tx="ekr.20060211104746.270">def insertNewLineIndent (self,event):

    w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = self.getWSString(txt)
    i = w.index('insert')
    w.insert(i,txt)
    w.mark_set('insert',i)
    self.insertNewLine(event)
</t>
<t tx="ekr.20060211104746.271">def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'Indent Relative'
    
    k = self.k ; w = event.widget
    i = w.index('insert')
    oldSel = (i,i)
    line, col = i.split('.')
    c2 = int(col)
    l2 = int(line) -1
    if l2 &lt; 1: return
    txt = w.get('%s.%s' % (l2,c2),'%s.0 lineend' % l2)
    if len(txt) &lt;= len(w.get('insert','insert lineend')):
        w.insert('insert','\t')
    else:
        reg = re.compile('(\s+)')
        ntxt = reg.split(txt)
        replace_word = re.compile('\w')
        for z in ntxt:
            if z.isspace():
                w.insert('insert',z)
                break
            else:
                z = replace_word.subn(' ',z)
                w.insert('insert',z[0])
                
    i = w.index('insert')
    result = w.get('1.0','end')
    head = tail = oldYview = None
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
    w.mark_set('insert',i)</t>
<t tx="ekr.20060211104746.272"></t>
<t tx="ekr.20060211104746.273">def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget
    if not g.app.gui.isTextWidget(w):
        g.trace('*'*40,'Not a text widget',c.widget_name(w))
        return
    
    wname = c.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    # g.trace(wname,i,j)

    if wname.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width &gt; 0:
            w.delete('insert-1c')
        else:
            &lt;&lt; backspace with negative tab_width &gt;&gt;
        self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')</t>
<t tx="ekr.20060211104746.274">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20060211104746.275">def deleteNextChar (self,event):

    c = self.c ; w = event and event.widget
    if not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    end = w.index('end-1c')
    # g.trace(i,j,'end',w.index('end-1c'))
    
    if name.startswith('body'):
        self.beginCommand()

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    if name.startswith('body'):
        self.endCommand(changed=changed,setLabel=False)</t>
<t tx="ekr.20060211104746.276">def deleteSpaces (self,event,insertspace=False):

    c = self.c ; w = event and event.widget
    if not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    if name.startswith('body'):
        oldText = w.get('1.0','end')
        oldSel = g.app.gui.getTextSelection(w)
        i = w.index('insert')
        wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
        wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
        if '' in (wf,wb): return
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')
        
        c.frame.body.onBodyChanged(undoType='delete-spaces',
            oldSel=oldSel,oldText=oldText,oldYview=None)</t>
<t tx="ekr.20060211104746.277">def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'Remove Blank Lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20060211104746.278">def insertNewLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    w.insert('insert','\n')
    w.mark_set('insert',i)

insertNewline = insertNewLine
</t>
<t tx="ekr.20060211104746.279">def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    k = self.k ; w = event.widget
    self.insertNewLine(event)
    i = w.index('insert +1c')
    w.insert(i,'\t')
    w.mark_set('insert','%s lineend' % i)</t>
<t tx="ekr.20060211104746.280">def insertParentheses (self,event):

    k = self.k ; w = event.widget
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')</t>
<t tx="ekr.20060211104746.281">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20060211104746.282">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)</t>
<t tx="ekr.20060211104746.283">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20060211104746.284"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20060211104746.285">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20060211104746.286"></t>
<t tx="ekr.20060211104746.287">def howMany (self,event):
    
    k = self.k ; w = event.widget ; state = k.getState('how-many')
    
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.get('1.0','end')
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))</t>
<t tx="ekr.20060211104746.288">def lineNumber (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert')
    i1, i2 = i.split('.')
    c = w.get('insert','insert + 1c')
    txt = w.get('1.0','end')
    txt2 = w.get('1.0','insert')
    perc = len(txt) * .01
    perc = int(len(txt2)/perc)
    k.setLabelGrey('Char: %s point %s of %s(%s%s)  Column %s' % (c,len(txt2),len(txt),perc,'%',i1))</t>
<t tx="ekr.20060211104746.289">def viewLossage (self,event):

    k = self.k
    loss = ''.join(leoKeys.keyHandlerClass.lossage)
    k.setLabel(loss)</t>
<t tx="ekr.20060211104746.290">def whatLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    k.keyboardQuit(event)
    k.setLabel("Line %s" % i1)</t>
<t tx="ekr.20060211104746.291"></t>
<t tx="ekr.20060211104746.292">def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')
    
    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg</t>
<t tx="ekr.20060211104746.293">def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')
    
    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg</t>
<t tx="ekr.20060211104746.294">def linesHelper (self,event,pattern,which):

    k = self.k ; w = event.widget
   
    if w.tag_ranges('sel'):
        i = w.index('sel.first') ; end = w.index('sel.last')
    else:
         i = w.index('insert') ; end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.mark_set('insert',i)</t>
<t tx="ekr.20060211104746.295">def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart &lt; 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom</t>
<t tx="ekr.20060211104746.296">@others</t>
<t tx="ekr.20060211104746.297">def backwardKillParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    i2 = i
    txt = w.get('insert linestart','insert lineend')
    if not txt.rstrip().lstrip():
        self.backwardParagraph(event)
        i2 = w.index('insert')
    self.selectParagraph(event)
    i3 = w.index('sel.first')
    c.killBufferCommands.kill(event,i3,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20060211104746.298">def fillParagraph( self, event ):
    k = self.k ; w = event.widget
    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.lstrip().rstrip()
    if txt:
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == '1.0':
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.lstrip().rstrip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.lstrip().rstrip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )</t>
<t tx="ekr.20060211104746.299">def fillRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == '1.0':
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.compare('insert','&gt;',s2):
            break
        self.fillParagraph(event)</t>
<t tx="ekr.20060211104746.300">def fillRegionAsParagraph (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)</t>
<t tx="ekr.20060211104746.301">def killParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    txt = w.get('insert linestart','insert lineend')

    if not txt.rstrip().lstrip():
        i = w.search(r'\w',i,regexp=True,stopindex='end')

    self.selectParagraphHelper(w,i)
    i2 = w.index('insert')
    c.killBufferCommands.kill(event,i,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20060211104746.302">def selectParagraph (self,event):

    k = self.k ; w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = txt.lstrip().rstrip()
    i = w.index('insert')

    if not txt:
        while 1:
            i = w.index('%s + 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if txt:
                self.selectParagraphHelper(w,i) ; break
            if w.index('%s lineend' % i) == w.index('end'):
                return

    if txt:
        while 1:
            i = w.index('%s - 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if not txt or w.index('%s linestart' % i) == w.index('1.0'):
                if not txt: i = w.index('%s + 1 lines' % i)
                self.selectParagraphHelper(w,i)
                break</t>
<t tx="ekr.20060211104746.303">def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.lstrip().rstrip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)</t>
<t tx="ekr.20060211104746.304">@others</t>
<t tx="ekr.20060211104746.305">def setRegion (self,event):

    mrk = 'sel'
    w = event.widget

    @others

    extend(event)
    w.bind('&lt;Right&gt;',extend,'+')
    w.bind('&lt;Left&gt;',truncate,'+')
    w.bind('&lt;Up&gt;',up,'+')
    w.bind('&lt;Down&gt;',down,'+')

    return 'break'</t>
<t tx="ekr.20060211104746.306">def down (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert','insert lineend')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)+1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert linestart -1c','insert')
        if self.inRange(w,mrk,l='-1c',r='+1c'):
            w.tag_remove(mrk,'1.0','insert')

    return 'break'</t>
<t tx="ekr.20060211104746.307">def extend (event):

    w = event.widget
    w.mark_set('insert','insert + 1c')

    if self.inRange(w,mrk):
        w.tag_remove(mrk,'insert -1c')
    else:
        w.tag_add(mrk,'insert -1c')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'

</t>
<t tx="ekr.20060211104746.308">def truncate (event):

    w = event.widget
    w.mark_set('insert','insert -1c')

    if self.inRange(w,mrk):
        self.testinrange(w)
        w.tag_remove(mrk,'insert')
    else:
        w.tag_add(mrk,'insert')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'</t>
<t tx="ekr.20060211104746.309">def up (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert linestart','insert')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)-1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert','insert lineend + 1c')
        if self.inRange(w,mrk,l='-1c',r='+1c') and w.index('insert') != '1.0':
            w.tag_remove(mrk,'insert','end')

    return 'break'</t>
<t tx="ekr.20060211104746.310">def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('&lt;Key&gt;')
        ### w.update_idletasks()
    self.removeRKeys(w)</t>
<t tx="ekr.20060211104746.311">def tabIndentRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)</t>
<t tx="ekr.20060211104746.312">def countRegion (self,event):

    k = self.k ; w = event.widget

    txt = w.get('sel.first','sel.last')
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))</t>
<t tx="ekr.20060211104746.313">def reverseRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()</t>
<t tx="ekr.20060211104746.314">def downCaseRegion (self,event):
    self.caseHelper(event,'low')

def upCaseRegion (self,event):
    self.caseHelper(event,'up')

def caseHelper (self,event,way):

    w = event.widget ; trange = w.tag_ranges('sel')

    if len(trange) != 0:
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)

    self.removeRKeys(w)</t>
<t tx="ekr.20060211104746.315">def scrollDown (self,event):
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    self.scrollHelper(event,'up',extend=True)</t>
<t tx="ekr.20060211104746.316">def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)

    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    row, col = ins1.split('.') ; row = int(row) ; col = int(col)

    # Compute the spot.
    chng = self.measure(w) ; delta = chng [0]
    row1 = g.choose(direction=='down',row+delta,row-delta)
    spot = w.index('%d.%d' % (row1,col))
    w.mark_set('insert',spot)

    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
    w.see('insert')</t>
<t tx="ekr.20060211104746.317">'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
</t>
<t tx="ekr.20060211104746.318">def sortLines (self,event,which=None): # event IS used.

    k = self.k ; w = event.widget
    if not self._chckSel(event):
        return
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060211104746.319">def sortColumns (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i &lt;= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060211104746.320">def sortFields (self,event,which=None):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) &lt; i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060211104746.321"></t>
<t tx="ekr.20060211104746.322">def transposeLines (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = str(int(i1)-1)

    if i1 != '0':
        l2 = w.get('insert linestart','insert lineend')
        w.delete('insert linestart-1c','insert lineend')
        w.insert(i1+'.0',l2+'\n')
    else:
        l2 = w.get('2.0','2.0 lineend')
        w.delete('2.0','2.0 lineend')
        w.insert('1.0',l2+'\n')</t>
<t tx="ekr.20060211104746.323">def swapWords (self,event,swapspots):

    w = event.widget
    txt = w.get('insert wordstart','insert wordend')
    if txt == ' ': return
    i = w.index('insert wordstart')
    if len(swapspots) != 0:
        if w.compare(i,'&gt;',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'&lt;',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

def transposeWords (self,event):
    self.swapWords(event,self.swapSpots)

def swapHelper (self,w,find,ftext,lind,ltext):
    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
</t>
<t tx="ekr.20060211104746.324">def swapCharacters (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    c1 = w.get('insert','insert +1c')
    c2 = w.get('insert -1c','insert')
    w.delete('insert -1c','insert')
    w.insert('insert',c1)
    w.delete('insert','insert +1c')
    w.insert('insert',c2)
    w.mark_set('insert',i)

transposeCharacters = swapCharacters</t>
<t tx="ekr.20060211104746.325">def tabify (self,event):
    self.tabifyHelper (event,which='tabify')
    
def untabify (self,event):
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = event.widget
    if w.tag_ranges('sel'):
        i = w.index('sel.first')
        end = w.index('sel.last')
        txt = w.get(i,end)
        if which == 'tabify':
            pattern = re.compile(' {4,4}') # Huh?
            ntxt = pattern.sub('\t',txt)
        else:
            pattern = re.compile('\t')
            ntxt = pattern.sub('    ',txt)
        w.delete(i,end)
        w.insert(i,ntxt)</t>
<t tx="ekr.20060211104746.326"></t>
<t tx="ekr.20060211104746.327"># Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):
    
    f = self ; c = f.c
    
    if c.inCommand:
        g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)</t>
<t tx="ekr.20060211104746.328">def OnControlKeyDown (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    self.controlKeyIsDown = True
    
def OnControlKeyUp (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.controlKeyIsDown = False</t>
<t tx="ekr.20060211104746.329">def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.setLog()
        w = c.get_focus()
        if w != c.frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        c.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")
        
    return 'break'</t>
<t tx="ekr.20060211104746.330">def OnActivateLeoEvent(self,event=None):
    
    '''Handle a click anywhere in the Leo window.'''
    
    __pychecker__ = '--no-argsused' # event.

    self.c.setLog()

def OnDeactivateLeoEvent(self,event=None):
    
    pass # This causes problems on the Mac.</t>
<t tx="ekr.20060211104746.331">def OnActivateTree (self,event=None):

    try:
        frame = self ; c = frame.c
        c.setLog()

        if 0: # Do NOT do this here!
            # OnActivateTree can get called when the tree gets DE-activated!!
            c.bodyWantsFocus()
            
    except:
        g.es_event_exception("activate tree")</t>
<t tx="ekr.20060211104746.332">def OnBodyClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
            self.OnActivateBody(event=event)
        g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):
    
    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
            pass # By default Leo does nothing.
        g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")</t>
<t tx="ekr.20060211104746.333">def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
            if event: # Prevent wandering insertion point.
                index = "@%d,%d" % (event.x, event.y) # Find where we clicked.
                w = self.bodyCtrl
                start = w.index(index + " wordstart")
                end   = w.index(index + " wordend")
                self.body.setTextSelection(start,end)
        g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodydclick")
        
    return "break" # Restore this to handle proper double-click logic.</t>
<t tx="ekr.20060211104746.334"># Contributed by Tomaz Ficko.  This works on some systems.
# On XP it causes a crash in tcl83.dll.  Clearly a Tk bug.

def OnMouseWheel(self, event=None):

    try:
        if event.delta &lt; 1:
            self.canvas.yview(Tk.SCROLL, 1, Tk.UNITS)
        else:
            self.canvas.yview(Tk.SCROLL, -1, Tk.UNITS)
    except:
        g.es_event_exception("scroll wheel")

    return "break"</t>
<t tx="ekr.20060211104746.335"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="ekr.20060211104746.336">
</t>
<t tx="ekr.20060211104746.337">def contractPane (self,event=None):
    
    f = self ; c = f.c
    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return
    
    if wname.startswith('body'):
        f.contractBodyPane()
    elif wname.startswith('log'):
        f.contractLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.contractOutlinePane()</t>
<t tx="ekr.20060211104746.338">def expandPane (self,event=None):

    f = self ; c = f.c
        
    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return
    
    if wname.startswith('body'):
        f.expandBodyPane()
    elif wname.startswith('log'):
        f.expandLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.expandOutlinePane()</t>
<t tx="ekr.20060211104746.339">def fullyExpandPane (self,event=None):

    f = self ; c = f.c
        
    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return
    
    if wname.startswith('body'):
        f.fullyExpandBodyPane()
    elif wname.startswith('log'):
        f.fullyExpandLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.fullyExpandOutlinePane()</t>
<t tx="ekr.20060211104746.340">def hidePane (self,event=None):

    f = self ; c = f.c
        
    w = c.get_requested_focus()
    wname = c.widget_name(w)

    g.trace(wname)
    if not w: return
    
    if wname.startswith('body'):
        f.hideBodyPane()
        c.treeWantsFocusNow()
    elif wname.startswith('log'):
        f.hideLogPane()
        c.bodyWantsFocusNow()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.hideOutlinePane()
        c.bodyWantsFocusNow()</t>
<t tx="ekr.20060211104746.341">@ The first arg to divideLeoSplitter means the following:

    f.splitVerticalFlag: use the primary   (tree/body) ratio.
not f.splitVerticalFlag: use the secondary (tree/log) ratio.
@c

def contractBodyPane (self,event=None):
    f = self ; r = min(1.0,f.ratio+0.1)
    f.divideLeoSplitter(f.splitVerticalFlag,r)

def contractLogPane (self,event=None):
    f = self ; r = min(1.0,f.ratio+0.1)
    f.divideLeoSplitter(not f.splitVerticalFlag,r)

def contractOutlinePane (self,event=None):
    f = self ; r = max(0.0,f.ratio-0.1)
    f.divideLeoSplitter(f.splitVerticalFlag,r)
    
def expandBodyPane (self,event=None):
    self.contractOutlinePane()

def expandLogPane(self,event=None):
    f = self ; r = max(0.0,f.ratio-0.1)
    f.divideLeoSplitter(not f.splitVerticalFlag,r)
    
def expandOutlinePane (self,event=None):
    self.contractBodyPane()</t>
<t tx="ekr.20060211104746.342">def fullyExpandBodyPane (self,event=None):
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,0.0)

def fullyExpandLogPane (self,event=None):
    f = self ; f.divideLeoSplitter(not f.splitVerticalFlag,0.0)

def fullyExpandOutlinePane (self,event=None):
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,1.0)
    
def hideBodyPane (self,event=None):
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,1.0)

def hideLogPane (self,event=None):
    f = self ; f.divideLeoSplitter(not f.splitVerticalFlag,1.0)

def hideOutlinePane (self,event=None):
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,0.0)</t>
<t tx="ekr.20060211104746.343"></t>
<t tx="ekr.20060211104746.344"></t>
<t tx="ekr.20060211104746.345">def selectAllText (self,event=None):
    
    c = self.c ; k = c.k

    try:
        w = c.get_focus() ; wname = c.widget_name(w)
        n = 0
        if wname.startswith('head'):
            s = w.get('1.0','end')
            while s.endswith('\n') or s.endswith('\r'):
                s = s[:-1] ; n += 1
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
        elif wname.startswith('mini'):
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j)
        else:
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
    except:
        # g.es_exception()
        pass</t>
<t tx="ekr.20060211104746.346">@nocolor

(done) select-all-text.
(done) move back/forward char.
(done) move back/forward char.
(done) start-of-line, end-of-line.
    
It turned out that the only special case is in moveToHelper, which means the solution is general.

@color</t>
<t tx="ekr.20060211104746.347">def getEditableTextRange (self):
    
    k = self ; w = self.widget ; n = 0
    
    s = w.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1] ; n += 1
        
    i = w.index('1.%d' % len(k.mb_prefix))
    j = w.index('end -%dc' % n)
    
    # g.trace(i,j)
    return i,j
</t>
<t tx="ekr.20060211104746.348">master_key_count = 0

def masterKeyHandler (self,event):
    
    '''In the new binding scheme, there is only one key binding.
    
    This is the handler for that binding.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val</t>
<t tx="ekr.20060211104746.349">def masterKeyHandlerHelper (self,event):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    keysym = event.keysym or ''
    if keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_gc'):
        if (self.master_key_count % 100) == 0:
            g.printGcSummary(trace=True)

    stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings.
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            # if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state == 'full-command':
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
            else:
                # Do the default state action.
                k.callStateFunction(event) # Calls end-command.
                return 'break'
        # Third, pass keys to the general mode handler.
        d =  k.masterBindingsDict.get(state)
        if d:
            # A typical state
            b = d.get(stroke)
            g.trace(d.keys())
            if b:
                return k.generalModeHandler (event,
                    commandName=b.commandName,func=b.func,
                    modeName=state,nextMode=b.nextMode)
            else:
                return k.modeHelp(event)
        else:
            g.trace('No state dictionary for %s' % state)
            return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1:
        if trace: g.trace('ignoring unbound special key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)</t>
<t tx="ekr.20060211104746.350"># To do: getArg must handle completion = False differently.</t>
<t tx="ekr.20060211104746.351"></t>
<t tx="ekr.20060211104746.352">@ There is something dubious about tracking states separately for separate commands.
In fact, there is only one mini-buffer, and it has only one state.
OTOH, maintaining separate states makes it impossible for one command to influence another.</t>
<t tx="ekr.20060211104746.353">def minibufferWantsFocus(self):
    
    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocus(c.miniBufferWidget)
    else:
        c.bodyWantsFocus()

def minibufferWantsFocusNow(self):
    
    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocusNow(c.miniBufferWidget)
    else:
        c.bodyWantsFocusNow()</t>
<t tx="ekr.20060211104746.354">def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    if not w: return ''
    
    if self.useTextWidget:
        w.update_idletasks()
        s = w and w.get('1.0','end')
        # Remove the cursed Tk newline.
        while s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        # g.trace(repr(s))
    else:
        s = k.svar and k.svar.get()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''

</t>
<t tx="ekr.20060211104746.355">def protectLabel (self):
    
    k = self ; w = self.widget
    if not w: return

    if self.useTextWidget:
        w.update_idletasks()
        k.mb_prefix = w.get('1.0','end')
    else:
        if k.svar:
            k.mb_prefix = k.svar.get()</t>
<t tx="ekr.20060211104746.356">def resetLabel (self):
    
    k = self
    k.setLabelGrey('')
    k.mb_prefix = ''</t>
<t tx="ekr.20060211104746.357">def setLabel (self,s,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return

    # g.trace(repr(s))

    if self.useTextWidget:
        w.delete('1.0','end')
        w.insert('1.0',s)
        c.masterFocusHandler() # Restore to the previously requested focus.
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s</t>
<t tx="ekr.20060211104746.358">def extendLabel(self,s,select=False,protect=False):
    
    k = self ; c = k.c ; w = self.widget
    if not w: return

    if self.useTextWidget:
        c.widgetWantsFocusNow(w)
        w.insert('end',s)
        if select:
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j,insert=j)
        if protect:
            k.protectLabel()
</t>
<t tx="ekr.20060211104746.359">def setLabelBlue (self,label=None,protect=False):
    
    k = self ; w = k.widget
    if not w: return
    
    w.configure(background='lightblue')

    if label is not None:
        k.setLabel(label,protect)</t>
<t tx="ekr.20060211104746.360">def setLabelGrey (self,label=None):

    k = self ; w = self.widget
    if not w: return
    
    w.configure(background='lightgrey')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey</t>
<t tx="ekr.20060211104746.361">def updateLabel (self,event,suppressControlChars=True):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    # g.trace(ch,keysym,k.stroke)
    
    if ch == '\b': # Handle backspace.
        # Don't backspace over the prompt.
        if len(s) &lt;= k.mb_prefix:
            return 
        elif len(s) == 1: s = ''
        else: s = s [0:-1]
    elif suppressControlChars and ch not in string.printable:
        return
    elif ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            i = w.index('insert')
            w.insert(i,ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
</t>
<t tx="ekr.20060211104746.362">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=None,completion=True):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = c.config.getBool('trace_modes')
    if trace: g.trace('state',state,'keysym',keysym,'completion',completion)
    if state == 0:
        k.arg = '' ; k.arg_completion = completion
        if tabList: k.argTabList = tabList[:]
        else:       k.argTabList = []
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if k.useTextWidget: c.minibufferWantsFocus()
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()

    return 'break'
</t>
<t tx="ekr.20060211104746.363"># Clear the list, any other character besides tab indicates that a new prefix is in effect.
k.mb_tabList = []

if prefix:
    k.mb_tabListPrefix = prefix
    k.mb_prefix = prefix
    k.mb_prompt = prefix
else:
    k.mb_tabListPrefix = k.mb_prefix = k.getLabel()
    k.mb_prompt = ''</t>
<t tx="ekr.20060211104746.364"># Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c
    
    # g.trace('completion',completion)
    
    if completion:
        if len(k.mb_tabListPrefix) &gt; len(k.mb_prefix):
            k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
            k.setLabel(k.mb_tabListPrefix)
            k.computeCompletionList(defaultCompletionList,backspace=True)
    else:
        s = k.getLabel(ignorePrompt=False)
        # g.trace(repr(s),repr(k.mb_prefix))
        if s and len(s) &gt; len(k.mb_prefix):
            k.setLabel(s[:-1])</t>
<t tx="ekr.20060211104746.365"># Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True):
    
    '''Handle tab completion when the user hits a tab.'''
    
    k = self ; c = k.c ; s = k.getLabel().strip()
    
    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex &gt;= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            k.computeCompletionList(defaultTabList,backspace=False)

    c.bodyWantsFocus()
</t>
<t tx="ekr.20060211104746.366">def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(event,tag,'Search: ',self.searchWithPresentOptions)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060211104746.367">def addFindStringToLabel (self):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.find_ctrl

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=True)</t>
<t tx="ekr.20060211104746.368"></t>
<t tx="ekr.20060211104746.369">class minibufferFind:

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others</t>
<t tx="ekr.20060211104746.370">def __init__(self,c,finder):

    self.c = c
    self.k = c.k
    self.finder = finder
</t>
<t tx="ekr.20060211104746.371"></t>
<t tx="ekr.20060211104746.372">def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.dict['radio-search-scope'].get()
        if var:
            h.dict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)</t>
<t tx="ekr.20060211104746.373">def setOption (self, ivar, val):
    
    h = self.finder

    if ivar in h.intKeys:
        if val is not None:
            var = h.dict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)</t>
<t tx="ekr.20060211104746.374">def getOption (self,ivar,verbose=False):
    
    h = self.finder
    
    var = h.dict.get(ivar)
    if var:
        val = var.get()
        if verbose:
             g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None</t>
<t tx="ekr.20060211104746.375">def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))</t>
<t tx="ekr.20060211104746.376">def toggleOption (self, ivar):
    
    h = self.finder

    if ivar in h.intKeys:
        var = h.dict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)</t>
<t tx="ekr.20060211104746.377">def setupChangePattern (self,pattern):
    
    h = self.finder ; t = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()</t>
<t tx="ekr.20060211104746.378">def setupSearchPattern (self,pattern):
    
    h = self.finder ; t = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()</t>
<t tx="ekr.20060211104746.379">def addChangeStringToLabel (self):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.change_ctrl

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=True)</t>
<t tx="ekr.20060211104746.380">def setupArgs (self,forward=False,regexp=False,word=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()</t>
<t tx="ekr.20060211104746.381">def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)</t>
<t tx="ekr.20060211104746.382">def cloneFindAll (self,event):

    k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)</t>
<t tx="ekr.20060211104746.383">def findAgain (self,event):

    f = self.finder
    
    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
        </t>
<t tx="ekr.20060211104746.384">def stateZeroHelper (self,event,tag,prefix,handler):

    k = self.k
    self.w = event and event.widget
    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel()
    k.getArg(event,tag,1,handler,completion=False,prefix=prefix)</t>
<t tx="ekr.20060211104746.385">def lastStateHelper (self):
    
    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()</t>
<t tx="ekr.20060211104746.386">def generalChangeHelper (self,find_pattern,change_pattern):
    
    # g.trace(repr(change_pattern))
    
    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()</t>
<t tx="ekr.20060211104746.387">def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):
    
    self.setupSearchPattern(pattern)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()</t>
<t tx="ekr.20060211104746.388">def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)</t>
<t tx="ekr.20060211104746.389">def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(event,tag,'Regexp Search Backward:',self.reSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(event,tag,'Regexp Search:',self.reSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060211104746.390">def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(event,tag,'Search Backward: ',self.searchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(event,tag,'Search: ',self.searchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060211104746.391">def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060211104746.392">class findTab (leoFind.leoFind):
    
    '''An adapter class that implements Leo's Find tab.'''

    @others</t>
<t tx="ekr.20060211104746.393"></t>
<t tx="ekr.20060211104746.394">def __init__(self,c,parentFrame):
    
    # g.trace('findTab')

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None
    
    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    self.optionsOnly = c.config.getBool('show_only_find_tab_options')
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20060211104746.395">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20060211104746.396">def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        k.masterKeyHandler(event)

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       resetWrapCallback),
        ('&lt;Return&gt;',    self.findButtonCallback),
        ("&lt;Escape&gt;",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)</t>
<t tx="ekr.20060211104746.397">def createFrame (self,parentFrame):
    
    c = self.c
    
    # g.trace('findTab')
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    
    if  self.optionsOnly:
        buttons = []
    else:
        &lt;&lt; Create two columns of buttons &gt;&gt;
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
    
    if 0: # These dont work in the new binding scheme.  Use shortcuts or mode bindings instead.
        for w in buttons:
            w.bindHotKey(ftxt)
            w.bindHotKey(ctxt)</t>
<t tx="ekr.20060211104746.398">configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)</t>
<t tx="ekr.20060211104746.399">fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")
        
if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")</t>
<t tx="ekr.20060211104746.400">def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20060211104746.401">columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&amp;t Change",self.dict["script_change"]),
    ("Whole &amp;Word", self.dict["whole_word"]),
    ("&amp;Ignore Case",self.dict["ignore_case"]),
    ("Wrap &amp;Around",self.dict["wrap"]),
    ("&amp;Reverse",    self.dict["reverse"]),
    ('Rege&amp;xp',     self.dict['pattern_match']),
    ("Mark &amp;Finds", self.dict["mark_finds"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&amp;Entire Outline","entire-outline"),
    (self.dict["radio-search-scope"],"&amp;Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&amp;Node Only","node-only"),
]

checkLists[1] = [
    ("Search &amp;Headline", self.dict["search_headline"]),
    ("Search &amp;Body",     self.dict["search_body"]),
    ("Mark &amp;Changes",    self.dict["mark_changes"]),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;Button-1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;Button-1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20060211104746.402"># Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    # ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20060211104746.403">def init (self,c):
    
    # g.trace('Find Tab')

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20060211104746.404">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20060211104746.405">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outline")</t>
<t tx="ekr.20060211104746.406">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val)
        # g.trace(key,val)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)

    # The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20060211104746.407">def findButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'

    self.findButton()
    return 'break'</t>
<t tx="ekr.20060211104746.408"></t>
<t tx="ekr.20060211104746.409">def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()</t>
<t tx="ekr.20060211104746.410">def findAgainCommand (self):
    
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s.endswith('\n'): s = s[:-1]
    
    if s and s != '&lt;find pattern here&gt;':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
</t>
<t tx="ekr.20060211104746.411">def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
</t>
<t tx="ekr.20060211104746.412">def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse</t>
<t tx="ekr.20060211104746.413">def changeCommand (self,event=None):

    self.setup_command()
    self.change()
    
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    self.setup_command()
    self.changeThenFind()</t>
<t tx="ekr.20060211104746.414">def hideTab (self,event=None):
    
    c = self.c
    
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()</t>
<t tx="ekr.20060211104746.415">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.widgetWantsFocus(t)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.widgetWantsFocus(t)</t>
<t tx="ekr.20060211104746.416">def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"</t>
<t tx="ekr.20060211104746.417">def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t</t>
<t tx="ekr.20060211104746.418">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20060211104746.419">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20060211104746.420">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20060211104746.421">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)</t>
<t tx="ekr.20060211104746.422"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20060211104746.423">class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others</t>
<t tx="ekr.20060211104746.424">def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    self.minibufferFindHandler = None
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None</t>
<t tx="ekr.20060211104746.425">def getPublicCommands (self):
    
    return {
        'clone-find-all':                       self.cloneFindAll,
        'find-tab-find-all':                    self.findAll,
        
        # Thin wrappers on Find tab
        'find-tab-find':                        self.findTabFindNext,
        'find-tab-find-prev':                   self.findTabFindPrev,
        'find-tab-change':                      self.findTabChange,
        'find-tab-change-all':                  self.findTabChangeAll,
        'find-tab-change-then-find':            self.findTabChangeThenFind,
                    
        'hide-find-tab':                        self.hideFindTab,
            
        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
                    
        'open-find-tab':                        self.openFindTab,
    
        'replace-string':                       self.replaceString,
                    
        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.
        
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,
        
        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,
        
        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }</t>
<t tx="ekr.20060211104746.426"></t>
<t tx="ekr.20060211104746.427">def openFindTab (self,event=None,show=True):

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = log.frameDict.get(tabName)

    if wasOpen:
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)</t>
<t tx="ekr.20060211104746.428"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()
        
def findTabChangeAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeAllCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()
        
def findTabFindAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')</t>
<t tx="ekr.20060211104746.429">def getHandler(self,show=False):
    
    '''Return the minibuffer handler, creating it if necessary.'''
    
    c = self.c
    
    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.
    
    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler</t>
<t tx="ekr.20060211104746.430">def setFindScopeEveryWhere     (self, event): return self.setFindScope('entire-outline')
def setFindScopeNodeOnly       (self, event): return self.setFindScope('node-only')
def setFindScopeSuboutlineOnly (self, event): return self.setFindScope('suboutline-only')

def setFindScope (self, where): self.getHandler().setFindScope(where)

def showFindOptions      (self,event): self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event): return self.toggleOption('ignore_case')
def toggleMarkChangesOption    (self, event): return self.toggleOption('mark_changes')
def toggleMarkFindsOption      (self, event): return self.toggleOption('mark_finds')
def toggleRegexOption          (self, event): return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event): return self.toggleOption('reverse')
def toggleSearchBodyOption     (self, event): return self.toggleOption('search_body')
def toggleSearchHeadlineOption (self, event): return self.toggleOption('search_headline')
def toggleWholeWordOption      (self, event): return self.toggleOption('whole_word')
def toggleWrapSearchOption     (self, event): return self.toggleOption('wrap')

def toggleOption (self, ivar): self.getHandler().toggleOption(ivar)</t>
<t tx="ekr.20060211104746.431">def cloneFindAll       (self,event): self.getHandler().cloneFindAll(event)
def findAll            (self,event): self.getHandler().findAll(event)

def replaceString      (self,event): self.getHandler().replaceString(event)
def reSearchBackward   (self,event): self.getHandler().reSearchBackward(event)
def reSearchForward    (self,event): self.getHandler().reSearchForward(event)
def searchBackward     (self,event): self.getHandler().searchBackward(event)
def searchForward      (self,event): self.getHandler().searchForward(event)
def wordSearchBackward (self,event): self.getHandler().wordSearchBackward(event)
def wordSearchForward  (self,event): self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    self.getHandler().searchWithPresentOptions(event)</t>
<t tx="ekr.20060211104746.432">def findAgain (self,event):
    
    h = self.getHandler()
    
    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to find-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)</t>
<t tx="ekr.20060211104746.433">def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)</t>
<t tx="ekr.20060211104746.434">def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocus()</t>
<t tx="ekr.20060211104746.435"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocus()
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '&lt;Control-s&gt;':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '&lt;Control-r&gt;':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        s = self.searchString
        i = w.index('insert')
        j = w.index('insert +%sc' % len(s))
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
        return

    if ch == '\b':
        g.trace('backspace not handled yet')
        return
    
    if ch:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        i = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if i:
            self.searchString = s
        else:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)</t>
<t tx="ekr.20060211104746.436">def scolorizer (self,event):

    k = self.k ; w = self.w

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')</t>
<t tx="ekr.20060211104746.437">def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = self.w
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    
    self.searchString = pattern
    self.incremental = True
    self.forward = forward
    self.regexp = regexp
   
    try:
        i = None
        if forward:
            i = w.search(pattern,"insert + 1c",stopindex='end',regexp=regexp)
            if 0: # Not so useful when searches can cross buffer boundaries.
                if not i: # Start again at the top of the buffer.
                    i = w.search(pattern,'1.0',stopindex='insert',regexp=regexp)
        else:
            i = w.search(pattern,'insert',backwards=True,stopindex='1.0',regexp=regexp)
            if 0: # Not so useful when searches can cross buffer boundaries.
                if not i: # Start again at the bottom of the buffer.
                    i = w.search(pattern,'end',backwards=True,stopindex='insert',regexp=regexp)
    except: pass
        
    # Don't call endSearch here.  We'll do that when the user hits return.
    if i and not i.isspace():
        w.mark_set('insert',i)
        w.see('insert')</t>
<t tx="ekr.20060211104746.438">def endSearch (self,i,j):

    g.app.gui.setTextSelection (self.w,i,j,insert='sel.end')
    self.k.keyboardQuit(event=None)</t>
<t tx="ekr.20060211104746.439"></t>
<t tx="ekr.20060211104746.440">@nocolor

# http://sourceforge.net/forum/message.php?msg_id=3487424

Leo now supports the following 7 commands that simulate clicks in various places:
click-click-box, click-headline, click-icon-box, double-click-headline,
double-click-icon-box, simulate-begin-drag, simulate-end-drag.

These commands are useful because they trigger event hooks. In particular,
double-click-icon-box will invoke the vim or xemacs plugins if they are
enabled.

Notes:

- These commands have been very lightly tested, if at all.

- Most clicks are equivalent to other commands. There is no need to simulate those clicks here.

- The simulateDrag methods have not been tested.  It's not clear that they can be useful, but what the heck...</t>
<t tx="ekr.20060211104746.441"></t>
<t tx="ekr.20060211104746.442"></t>
<t tx="ekr.20060211104746.443"></t>
<t tx="ekr.20060211104746.444">def activateMenu (self,menuName):
    
    c = self.c ;  top = c.frame.top
    topx,topy = top.winfo_rootx(),top.winfo_rooty()
    menu = c.frame.menu.getMenu(menuName)

    if menu:
        d = self.computeMenuPositions()
        x = d.get(menuName)
        if x is None:
             x = 0 ; g.trace('oops, no menu offset: %s' % menuName)
        menu.post(topx+d.get(menuName,0),topy)
    else:
        g.trace('oops, no menu: %s' % menuName)</t>
<t tx="ekr.20060211104746.445">def computeMenuPositions (self):
    
    # A hack.  It would be better to set this when creating the menus.
    menus = ('File','Edit','Outline','Plugins','Cmds','Window','Help')
    
    # Compute the *approximate* x offsets of each menu.
    d = {}
    n = 0
    for z in menus:
        menu = self.getMenu(z)
        fontName = menu.cget('font')
        font = tkFont.Font(font=fontName)
        # print '%8s' % (z),menu.winfo_reqwidth(),menu.master,menu.winfo_x()
        d [z] = n
        # A total hack: sorta works on windows.
        n += font.measure(z+' '*4)+1
        
    return d</t>
<t tx="ekr.20060212102459">@nocolor

Refer to 4.4b3 to do first list.

@color</t>
<t tx="ekr.20060212102459.2"></t>
<t tx="ekr.20060212102459.4">@nocolor

Important: all minibuffer search commands, with the exception of the isearch (incremental) commands, simply provide a minibuffer interface to Leo's legacy find commands.  This means that all the powerful features of Leo's legacy commands are available to the minibuffer search commands.

Note: all bindings shown are the default bindings for these commands.  You may change any of these bindings using @shortcut nodes in leoSettings.leo.

Settings

leoSettings.leo now contains several settings related to the Find tab:

- @bool show_only_find_tab_options = True

When True (recommended), the Find tab does not show the 'Find', 'Change', 'Change, Then Find', 'Find All' and 'Change All' buttons.

- @bool minibufferSearchesShowFindTab = True

When True, Leo shows the Find tab when executing most of the commands discussed below.  It's not necessary for it to be visible, but I think it provides good feedback about what search-with-present-options does.  YMMY.  When True, the sequence Control-F, Control-G is one way to show the Find Tab.

Basic find commands

- The open-find-tab command makes the Find tab visible.  The Find tab does **not** need to be visible to execute any search command discussed below.

- The hide-find-tab commands hides the Find tab, but retains all the present settings.

- The search-with-present-options command (Control-F) prompts for a search string.  Typing the &lt;Return&gt; key puts the search string in the Find tab and executes a search based on all the settings in the Find tab.   This command is my 'workhorse' search command.

Coming in 4.4b3: the search-with-present-options will copy the present value of the 'find' string in the Find tab to the minibuffer.  This will make Control-f &lt;Return&gt; equivalent to F3 (find-tab-find).

- The show-search-options command shows the present search options in the status line.  At present, this command also shows the Find tab.

Search again commands

- The find-tab-find command (F3) is the same as the search-with-present-options command, except that it uses the search string in the find-tab.  This is what I use as my default 'search again' command.

- Similarly, the find-tab-find-previous command (F2) repeats the command specified by the Find tab, but in reverse.

- The find-again command a combination of the search-with-present-options and find-tab-find command.  It is the same as the find-tab-find command if a search pattern other than '&lt;find pattern here&gt;' exists in the Find tab.  Otherwise, the find-again is the same as the search-with-present-options command.

Setting find options

- Several minibuffer commands toggle the checkboxes and radio buttons in the Find tab, and thus affect the operation of the search-with-present-options command. Some may want to bind these commands to keys. Others, will prefer to toggle options in a mode.


Here are the commands that toggle checkboxes: toggle-find-ignore-case-option, toggle-find-in-body-option, toggle-find-in-headline-option, toggle-find-mark-changes-option, toggle-find-mark-finds-option, toggle-find-regex-option, toggle-find-reverse-option, toggle-find-word-option, and toggle-find-wrap-around-option.

Here are the commands that set radio buttons: set-find-everywhere, set-find-node-only, and set-find-suboutline-only.

- The enter-find-options-mode (Ctrl-Shift-F) enters a mode in which you may change all checkboxes and radio buttons in the Find tab with plain keys.  As always, you can use the mode-help (Tab) command to see a list of key bindings in effect for the mode.

Search commands that set options as a side effect

The following commands set an option in the Find tab, then work exactly like the search-with-present-options command.

- The search-backward and search-forward commands set the 'Whole Word' checkbox to False.

- The word-search-backward and word-search-forward set the 'Whole Word' checkbox to True.

- The re-search-forward and re-search-backward set the 'Regexp' checkbox to True.

Find all commands

- The find-all command prints all matches in the log pane.

- The clone-find-all command replaces the previous 'Clone Find' checkbox.  It prints all matches in the log pane, and creates a node at the beginning of the outline containing clones of all nodes containing the 'find' string.  Only one clone is made of each node, regardless of how many clones the node has, or of how many matches are found in each node.

Note: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by the find-all and clone-find-all commands.

Search and replace commands

The replace-string prompts for a search string.  Type &lt;Return&gt; to end the search string.  The command will then prompt for the replacement string.  Typing a second &lt;Return&gt; key will place both strings in the Find tab and executes a **find** command, that is, the search-with-present-options command.

So the only difference between the replace-string and search-with-present-options commands is that the replace-string command has the side effect of setting 'change' string in the Find tab.  However, this is an extremely useful side effect, because of the following commands...

- The find-tab-change command (Ctrl-=) replaces the selected text with the 'change' text in the Find tab.

- The find-tab-change-then-find (Ctrl--) replaces the selected text with the 'change' text in the Find tab, then executes the find command again.

The find-tab-find, find-tab-change and find-tab-change-then-find commands can simulate any kind of query-replace command.  **Important**: Leo presently has separate query-replace and query-replace-regex commands, but they are buggy and 'under-powered'.  Fixing these commands has low priority.

- The find-tab-change-all command changes all occurrences of the 'find' text with the 'change' text.  Important: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by this command.

Incremental search commands

Leo's incremental search commands are completely separate from Leo's legacy search commands.  At present, incremental search commands do not cross node boundaries: they work only in the body text of single node.

Coming in Leo 4.4b3: the incremental commands will maintain a list of previous matches.  This allows for

a) support for backspace and
b) an incremental-search-again command.

Furthermore, this list makes it easy to detect the end of a wrapped incremental search.

Here is the list of incremental find commands: isearch-backward, isearch-backward-regexp, isearch-forward and
isearch-forward-regexp.'''</t>
<t tx="ekr.20060212102459.6">All key bindings specified with !mini pane specifier apply to all modes.</t>
<t tx="ekr.20060212102459.7">Mouseless Leo has arrived.  Cvs now contains code to support the following commands, with the default bindings as shown:

</t>
<t tx="ekr.20060212102459.8">contract-log-pane       = Alt-Ctrl-RtArrow 
expand-body-pane        = Alt-Ctrl-UpArrow  
expand-log-pane         = Alt-Ctrl-LtArrow
expand-outline-pane     = Alt-Ctrl-DnArrow

contract-outline-pane   = None
contract-body-pane      = None

contract-pane           = Alt-Ctrl--
expand-pane             = Alt-Ctrl-+

hide-body-pane          = None
hide-log-pane           = None
hide-pane               = Alt-Ctrl--
hide-outline-pane       = None

fully-expand-body-pane      = None
fully-expand-log-pane       = None
fully-expand-pane           = Alt-Ctrl-+
fully-expand-outline-pane   = None

Notes:

- The expand commands increase or decrease the ratio between panes by 0.1.  The hide commands set the ratio to 0.0 or 1.0 as appropriate.

- The expand-pane and contract-pane commands expand or contract whatever pane has focus.

- There is a small asymmetry: expanding the outline pane contracts the *body* pane, not the log pane.  This asymmetry is a bit more noticable in the expand-pane and contract-pane commands.

- There are no bindings for the contract-body-pane and contract-outline-pane commands because these are equivalent to expand-outline_pane and expand-body-pane commands.

- For the 'split horizontally' orientation, it would be natural to change the bindings as follows:

contract-log-pane       = Alt-Ctrl-DnArrow
expand-body-pane        = Alt-Ctrl-LtArrow 
expand-log-pane         = Alt-Ctrl-UpArrow 
expand-outline-pane     = Alt-Ctrl-RtArrow
</t>
<t tx="ekr.20060212102459.9"></t>
<t tx="ekr.20060212102459.10"></t>
<t tx="ekr.20060212102459.11"></t>
<t tx="ekr.20060212110830">- Chapters plugin.
- Autocompleter Tab.
- Improved incremental searches.</t>
<t tx="ekr.20060212111040"></t>
</tnodes>
</leo_file>
