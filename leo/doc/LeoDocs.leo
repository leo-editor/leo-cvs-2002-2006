<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2934" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="64" left="365" height="836" width="833"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="edream.110203163054"><vh>Short summary</vh></v>
<v t="edream.110203163054.1"><vh>About Leo's panes and icons (for newbies)</vh>
<v t="edream.110203163054.2"><vh>This node contains text</vh></v>
<v t="edream.110203163054.3" a="M"><vh>This headline is marked</vh></v>
<v t="edream.110203163054.4" a=""><vh>This is a cloned headline</vh></v>
<v t="edream.110203163054.4" a=""><vh>This is a cloned headline</vh></v>
<v t="edream.110203163054.5"><vh>This node contains no text</vh></v>
</v>
<v t="edream.110203163054.6"><vh>Please use SourceForge to ask questions and make comments</vh></v>
<v t="edream.110203163054.7" a=""><vh>Acknowledgements</vh></v>
<v t="edream.110203163054.8"><vh>What people are saying about Leo</vh>
<v t="edream.110203163054.9" a="M"><vh>Quote of the Month</vh>
<v t="edream.110203163054.10"><vh>From David Nichols</vh></v>
<v t="edream.110203163054.11"><vh>From William A. Stapp</vh></v>
<v t="edream.110203163054.12"><vh>From Dan Winkler</vh></v>
</v>
<v t="edream.110203163054.13"><vh>Annonymous</vh></v>
<v t="edream.110203163054.14"><vh> Speed Ream's slashdot article (Why Leo is interesting)</vh></v>
<v t="edream.110203163054.15"><vh> Open Software award nominations</vh></v>
<v t="edream.110203163054.16"><vh>Alex Abacus</vh></v>
<v t="edream.110203163054.17"><vh>Steve Allen</vh></v>
<v t="edream.110203163054.18"><vh>Shakeeb Alireza</vh></v>
<v t="edream.110203163054.19"><vh>Bruce M. Bolden</vh></v>
<v t="edream.110203163054.20"><vh>Serge Brisson</vh></v>
<v t="edream.110203163054.21"><vh>Korakot Chaovavanich </vh></v>
<v t="edream.110203163054.22"><vh>F. Geiger</vh></v>
<v t="edream.110203163054.23"><vh>Zak Greant</vh></v>
<v t="edream.110203163054.24"><vh>Lyn Adams Headley</vh></v>
<v t="edream.110203163054.25"><vh>Dave Hein</vh></v>
<v t="edream.110203163054.26"><vh>Travers A. Hough</vh></v>
<v t="edream.110203163054.27"><vh>Bob Hustead</vh></v>
<v t="edream.110203163054.28"><vh>Austin King</vh></v>
<v t="edream.110203163054.29"><vh>Nicola Larosa</vh></v>
<v t="edream.110203163054.30"><vh>Tom Lee</vh></v>
<v t="edream.110203163054.31"><vh>Michael Manti</vh></v>
<v t="edream.110203163054.32"><vh>Marcus A. Martin</vh></v>
<v t="edream.110203163054.33"><vh>David McNab</vh></v>
<v t="edream.110203163054.34"><vh>Joe Orr</vh></v>
<v t="edream.110203163054.35"><vh>Joe Orr 2</vh></v>
<v t="edream.110203163054.36" a="M"><vh>Marshall Parsons</vh></v>
<v t="edream.110203163054.37"><vh>Bruce Rafnel</vh></v>
<v t="edream.110203163054.38"><vh>Rich Reis</vh></v>
<v t="edream.110203163054.39"><vh>Steven P. Schaefer</vh></v>
<v t="edream.110203163054.40"><vh>John Sequeira</vh></v>
<v t="edream.110203163054.41"><vh>Brian Takita</vh></v>
<v t="edream.110203163054.42"><vh>Kent Tenney</vh></v>
<v t="edream.110203163054.43"><vh>Jim Vickroy</vh></v>
<v t="edream.110203163054.44"><vh>Dan Winkler 1</vh></v>
<v t="edream.110203163054.45"><vh>Dan Winkler 2</vh></v>
</v>
<v t="edream.110203163054.46" a="E"><vh>Release Notes</vh>
<v t="edream.110203163054.47"><vh>Warnings</vh></v>
<v t="edream.110203163054.48"><vh>Installation notes</vh>
<v t="edream.110203163054.49" a=""><vh>System requirements</vh></v>
<v t="edream.110203163054.50"><vh>How to install leo.py on Linux</vh></v>
<v t="edream.110203163054.51" a=""><vh>How to install leo.py on Windows</vh></v>
<v t="edream.110203163054.52"><vh>How to install leo.py on MacOS X Jaguar</vh>
<v t="edream.110203163054.53"><vh>From Joe Grace 2/17/03</vh></v>
<v t="edream.110203163054.54"><vh>From Bruce Bolden 1</vh></v>
<v t="edream.110203163054.55"><vh>From Bruce Bolden 2</vh></v>
</v>
<v t="edream.110203163054.56"><vh>How to install leo.py on MacOS X Jaguar &amp; Aqua</vh>
<v t="edream.110203163054.57"><vh>Installing Leo under Aqua</vh></v>
<v t="edream.110203163054.58"><vh>Making .leo documents open with Leo</vh></v>
</v>
<v t="edream.110203163054.59"><vh>How to install the Borland version of Leo on Windows</vh></v>
<v t="edream.110203163054.60" a=""><vh>How to associate leo.py with .leo files on Windows</vh></v>
<v t="edream.110203163054.61" a=""><vh>Putting the Leo icon in Leo windows</vh></v>
<v t="edream.110203163054.62" a=""><vh>Quick start</vh></v>
</v>
<v t="edream.110203163054.63" a="E"><vh>Latest version</vh>
<v t="edream.110603185805" a="V"><vh>4.1 beta 2</vh>
<v t="edream.110603190404"><vh>Fixed bugs</vh>
<v t="edream.110603190322.8"><vh>Fixed Serious Undo Change All bug</vh></v>
<v t="edream.110603190322.13"><vh>Fixed bug involving 0x1a characters in body text.</vh></v>
<v t="edream.110603190322.11"><vh>Fixed first node-only find bug</vh></v>
<v t="edream.110603190322.3"><vh>Fixed bug in idle_body_key</vh></v>
</v>
<v t="edream.110603192009"><vh>Improved format of .leo files</vh>
<v t="edream.110603190322.9"><vh>Leo now ignores unknown prefs and find prefs</vh></v>
<v t="edream.110603190322.10"><vh>Leo now writes node_only find prefs</vh></v>
<v t="edream.110603190125.1"><vh>.leo files are now cvs-friendly</vh></v>
</v>
<v t="edream.110603192009.1"><vh>New &amp; improved commands</vh>
<v t="edream.110603190322.14"><vh>Added Check Outline command</vh></v>
<v t="edream.110603190322.15"><vh>Added Hoist/De-Hoist commands</vh></v>
<v t="edream.110603190322.6"><vh>Added script search/change</vh></v>
<v t="edream.110303182253.3"><vh>Leo now does an auto-save only if files have actually been changed.</vh></v>
</v>
<v t="edream.110303182719"><vh>New config settings</vh></v>
<v t="edream.110603190234.1"><vh>New scripts &amp; code-level features</vh>
<v t="edream.110603190322.2"><vh>Create initScriptFind</vh></v>
<v t="edream.110603190125.3"><vh>Regression tests started</vh></v>
<v t="edream.110603190125.4"><vh>Code reorganized to support other guis</vh></v>
<v t="edream.110303182253.39"><vh>Made app.forceShutdown work in "idle" hook</vh></v>
</v>
</v>
<v t="edream.110203163054.66" a=""><vh>4.0.1, 4.0.2, 4.0.3 &amp; 4.0.4</vh></v>
</v>
<v t="edream.110203163054.117"><vh>leo.py versions</vh>
<v t="edream.110603185805" a=""><vh>4.1 beta 2</vh>
<v t="edream.110603190404"><vh>Fixed bugs</vh>
<v t="edream.110603190322.8"><vh>Fixed Serious Undo Change All bug</vh></v>
<v t="edream.110603190322.13"><vh>Fixed bug involving 0x1a characters in body text.</vh></v>
<v t="edream.110603190322.11"><vh>Fixed first node-only find bug</vh></v>
<v t="edream.110603190322.3"><vh>Fixed bug in idle_body_key</vh></v>
</v>
<v t="edream.110603192009"><vh>Improved format of .leo files</vh>
<v t="edream.110603190322.9"><vh>Leo now ignores unknown prefs and find prefs</vh></v>
<v t="edream.110603190322.10"><vh>Leo now writes node_only find prefs</vh></v>
<v t="edream.110603190125.1"><vh>.leo files are now cvs-friendly</vh></v>
</v>
<v t="edream.110603192009.1"><vh>New &amp; improved commands</vh>
<v t="edream.110603190322.14"><vh>Added Check Outline command</vh></v>
<v t="edream.110603190322.15"><vh>Added Hoist/De-Hoist commands</vh></v>
<v t="edream.110603190322.6"><vh>Added script search/change</vh></v>
<v t="edream.110303182253.3"><vh>Leo now does an auto-save only if files have actually been changed.</vh></v>
</v>
<v t="edream.110303182719"><vh>New config settings</vh></v>
<v t="edream.110603190234.1"><vh>New scripts &amp; code-level features</vh>
<v t="edream.110603190322.2"><vh>Create initScriptFind</vh></v>
<v t="edream.110603190125.3"><vh>Regression tests started</vh></v>
<v t="edream.110603190125.4"><vh>Code reorganized to support other guis</vh></v>
<v t="edream.110303182253.39"><vh>Made app.forceShutdown work in "idle" hook</vh></v>
</v>
</v>
<v t="edream.110203163054.64"><vh>4.1 alpha 1</vh></v>
<v t="edream.110203163054.66" a=""><vh>4.0.1, 4.0.2, 4.0.3 &amp; 4.0.4</vh></v>
<v t="edream.110203163054.67"><vh>4.0 final</vh>
<v t="edream.110203163054.68"><vh>4.0 beta 4</vh></v>
<v t="edream.110203163054.69"><vh>4.0 beta 3</vh>
<v t="edream.110203163054.70"><vh>Fixed bugs</vh>
<v t="edream.110203163054.71"><vh>Fixed bug that caused some clones not to be marked as clones</vh></v>
<v t="edream.110203163054.72"><vh>Corrected problems with setting icons on Linux</vh></v>
<v t="edream.110203163054.73"><vh>Fixed crasher in sentinelName</vh></v>
<v t="edream.110203163054.74"><vh>Reenabled orphans &amp; ignored test in new write logic</vh></v>
</v>
<v t="edream.110203163054.75"><vh>New features</vh>
<v t="edream.110203163054.76"><vh>Added support for unknown tnode and vnode attributes</vh></v>
<v t="edream.110203163054.77"><vh>Added build number to signon</vh></v>
<v t="edream.110203163054.78"><vh>Added better error message in setDefaultIcon</vh></v>
</v>
</v>
<v t="edream.110203163054.79"><vh>4.0 beta 2</vh>
<v t="edream.110203163054.80"><vh>To-do for 4.0 final</vh></v>
<v t="edream.110203163054.81"><vh>Fixed Bugs</vh>
<v t="edream.110203163054.82"><vh>Added crucial defensive checks in v.headString() and v.bodySting()</vh></v>
<v t="edream.110203163054.83"><vh>Ensured newlines before all sentinels in @rawfile</vh></v>
<v t="edream.110203163054.84"><vh>Fixed bugs involving find params</vh></v>
<v t="edream.110203163054.85"><vh>Fixed Python Import bug</vh></v>
<v t="edream.110203163054.86"><vh>Fixed several more unicode bugs</vh></v>
<v t="edream.110203163054.87"><vh>Fixed crasher in Go To Outline command.</vh></v>
<v t="edream.110203163054.88"><vh>Fixed @rawfile write problem</vh></v>
</v>
<v t="edream.110203163054.89"><vh>Improved commands</vh>
<v t="edream.110203163054.90"><vh>Finished Import Derived File command and made it undoable</vh></v>
<v t="edream.110203163054.91"><vh>Moved Clear Recent Files menu item into Recent Files menu</vh></v>
<v t="edream.110203163054.92"><vh>Added better log message for Convert All Tabs/Blanks commands</vh></v>
<v t="edream.110203163054.93"><vh>Marked changed nodes &amp; make the @file node and the outline dirty.</vh></v>
<v t="edream.110203163054.94"><vh>Rewrote icon code so it doesn't use PIL or tkIcon in Python 2.3</vh></v>
<v t="edream.110203163054.95"><vh>Created leoGui base class for tkinterGui class</vh></v>
</v>
<v t="edream.110203163054.96"><vh>New and improved settings</vh>
<v t="edream.110203163054.97"><vh>Added support for two new settings affecting drags</vh></v>
<v t="edream.110203163054.98"><vh>changed default for config.write_old_format_derived_files</vh></v>
</v>
</v>
<v t="edream.110203163054.99"><vh>4.0 beta 1</vh>
<v t="edream.110203163054.100" a=""><vh>4.0 Theory of operation</vh></v>
<v t="edream.110203163054.101"><vh>New commands &amp; options</vh>
<v t="edream.110203163054.102"><vh>New write_old_format_derived_files option</vh></v>
<v t="edream.110203163054.103"><vh>New Clear Recent Files command</vh></v>
<v t="edream.110203163054.104"><vh>New Import Derived File command</vh></v>
<v t="edream.110203163054.105"><vh>New Write 3.x/4.x Derived Files &amp; autosave</vh></v>
</v>
<v t="edream.110203163054.106"><vh>New plugins</vh></v>
<v t="edream.110203163054.107"><vh>New read logic and greatly inproved error recovery</vh>
<v t="edream.110203163054.108"><vh>Added test for unvisited nodes in read logic</vh></v>
<v t="edream.110203163054.109"><vh>Error recovery is _much_ better than before</vh></v>
</v>
<v t="edream.110203163054.110"><vh>Improvements &amp; bug fixes</vh>
<v t="edream.110203163054.111"><vh>Added horizontal scrollbar in body pane when @nowrap in effect</vh></v>
<v t="edream.110203163054.112"><vh>Added support for Python 2.3</vh></v>
<v t="edream.110203163054.113"><vh>Leo recycles window objects only if more than one window open</vh></v>
<v t="edream.110203163054.114"><vh>Removed "not undoable" message from Read @file Nodes command</vh></v>
<v t="edream.110203163054.115"><vh>Removed Open Python Window command</vh></v>
<v t="edream.110203163054.116"><vh>Simplified read and write code</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.118"><vh>3.x releases</vh>
<v t="edream.110203163054.119"><vh>3.12 final</vh>
<v t="edream.110203163054.120"><vh>Bug fixes (major)</vh>
<v t="edream.110203163054.121"><vh>Fixed major undo bug</vh></v>
<v t="edream.110203163054.122"><vh>Fixed huge performance bug when handling read errors</vh></v>
<v t="edream.110203163054.123"><vh>Fixed memory leaks: one minor, one huge</vh></v>
</v>
<v t="edream.110203163054.124"><vh>Bug fixes (minor)</vh>
<v t="edream.110203163054.125"><vh>Fixed bug affecting encoding in headlines</vh></v>
<v t="edream.110203163054.126"><vh>Fixed bug affecting log pane</vh></v>
<v t="edream.110203163054.127"><vh>Fixed bug importing files with upper case extensions</vh></v>
<v t="edream.110203163054.128"><vh>Fixed bug involving log messages during Open commands</vh></v>
<v t="edream.110203163054.129"><vh>Fixed bug that caused some log messages to disappear</vh></v>
<v t="edream.110203163054.130"><vh>Fixed bug that disabled double-clicking when when windows were first opened</vh></v>
<v t="edream.110203163054.131"><vh>Fixed bug that forced body_pane_wraps setting to 1</vh></v>
<v t="edream.110203163054.132"><vh>Fixed bug when deleting trailing newlines in the body pane</vh></v>
<v t="edream.110203163054.133"><vh>Fixed colorizer exception when undoing paste</vh></v>
<v t="edream.110203163054.134"><vh>Fixed Go To Line Number bug</vh></v>
<v t="edream.110203163054.135"><vh>Fixed line-break bug with @nosent files</vh></v>
<v t="edream.110203163054.136"><vh>Fixed new Open With problems</vh></v>
<v t="edream.110203163054.137"><vh>Fixed problems with Convert tabs to blanks preference panel setting</vh></v>
<v t="edream.110203163054.138"><vh>Fixed problems with the code that destroys Leo windows</vh></v>
<v t="edream.110203163054.139"><vh>Fixed recent bug in the Reformat Paragraph command</vh></v>
<v t="edream.110203163054.140"><vh>Fixed refresh problem after Read @file Node command</vh></v>
<v t="edream.110203163054.141"><vh>Fixed several problems with the Open With command</vh></v>
<v t="edream.110203163054.142"><vh>Fixed Sort bug</vh></v>
<v t="edream.110203163054.143"><vh>Leo now updates ow/col numbers when plugins not enabled</vh></v>
<v t="edream.110203163054.144"><vh>Made dragging nodes more robust</vh></v>
<v t="edream.110203163054.145"><vh>Removed improper clones from LeoPy.leo</vh></v>
<v t="edream.110203163054.146"><vh>Removed unused fractional widths from leoFind code</vh></v>
<v t="edream.110203163054.147"><vh>updateRecentFiles now handles Null filenames properly</vh></v>
</v>
<v t="edream.110203163054.148"><vh>Code improvements</vh>
<v t="edream.110203163054.149"><vh>New functions in leoGlobals.py</vh></v>
<v t="edream.110203163054.150"><vh>New scripts</vh></v>
<v t="edream.110203163054.151"><vh>Rewrote dialog code</vh></v>
<v t="edream.110203163054.152"><vh>Reorganized vnodes and tnodes</vh></v>
<v t="edream.110203163054.153"><vh>Simplified startup code</vh></v>
<v t="edream.110203163054.154"><vh>Replaced exec with getattr/setattr throughout the code</vh></v>
</v>
<v t="edream.110203163054.155"><vh>Features</vh>
<v t="edream.110203163054.156"><vh>Added @wrap and @nowrap directives</vh></v>
<v t="edream.110203163054.157"><vh>Added apply button to Font panel</vh></v>
<v t="edream.110203163054.158"><vh>Added Icon &amp; Status areas to Leo window</vh></v>
<v t="edream.110203163054.159"><vh>Added minimal support for Rebol and activescript languages</vh></v>
<v t="edream.110203163054.160"><vh>Added Write Dirty @file Nodes command</vh></v>
<v t="edream.110203163054.161"><vh>Changed OnIconDoubleClick to allow @url url comments</vh></v>
<v t="edream.110203163054.162"><vh>Hyperlinks are now enabled by default</vh></v>
<v t="edream.110203163054.163"><vh>Improved how headlines are highlighted</vh></v>
<v t="edream.110203163054.164"><vh>Improved startup logic so only one frame ever gets opened</vh></v>
<v t="edream.110203163054.165"><vh>Improved the reporting of characters that do not exist in the present encoding</vh></v>
<v t="edream.110203163054.166"><vh>Leo now correctly remembers the sizes of windows</vh></v>
<v t="edream.110203163054.167"><vh>Removed toggle &lt;&lt; &gt;&gt; command</vh></v>
<v t="edream.110203163054.168"><vh>Undo now restores cursor</vh></v>
<v t="edream.110203163054.169"><vh>Updated Marks window in Mark Find and Mark Changes commands</vh></v>
<v t="edream.110203163054.170"><vh>Use "file in directory" format for entries in Recent Files list</vh></v>
</v>
<v t="edream.110203163054.171"><vh>Hooks</vh>
<v t="edream.110203163054.172" a=""><vh>About hooks</vh></v>
<v t="edream.110203163054.173"><vh>Added "clear-mark" and "set-mark" hooks</vh></v>
<v t="edream.110203163054.174"><vh>Added hooks to customize popup menus</vh></v>
<v t="edream.110203163054.175"><vh>Added new hooks so that plugins may extend popup menus </vh></v>
</v>
<v t="edream.110203163054.176"><vh>Plugins</vh>
<v t="edream.110203163054.177"><vh>Added add_directives.py plugin</vh></v>
<v t="edream.110203163054.178"><vh>Added color_markup.py plugin</vh></v>
<v t="edream.110203163054.179"><vh>Added nav_buttons.py plugin</vh></v>
<v t="edream.110203163054.180"><vh>Added plugins_menu.py plugin</vh></v>
<v t="edream.110203163054.181"><vh>Added scripts_menu.py plugin</vh></v>
<v t="edream.110203163054.182"><vh>Improved how Leo loads plugins</vh></v>
</v>
<v t="edream.110203163054.183"><vh>Reorganized Leo folder: big change to cvs</vh>
<v t="edream.110203163054.184"><vh>Added scripts for Linux</vh></v>
</v>
</v>
<v t="edream.110203163054.185"><vh>3.11.1</vh></v>
<v t="edream.110203163054.186"><vh>3.11</vh>
<v t="edream.110203163054.187"><vh>New in 3.11 final</vh>
<v t="edream.110203163054.188"><vh>Bug fixes</vh>
<v t="edream.110203163054.189"><vh>Added call to c.redraw() in fileCommands.readAtFileNodes</vh></v>
<v t="edream.110203163054.190"><vh>Added getpreferredencoding to leoGlobals.py</vh></v>
<v t="edream.110203163054.191"><vh>Eliminated caught exception in frame.setTabWidth</vh></v>
<v t="edream.110203163054.192"><vh>Fixed bug in skip_long</vh></v>
<v t="edream.110203163054.193"><vh>Fixed bug that prevented email line in About Leo from working</vh></v>
<v t="edream.110203163054.194"><vh>Fixed unicode bugs when Tangling and Untangling</vh></v>
<v t="edream.110203163054.195"><vh>Fixed various bugs reported by Pychecker</vh></v>
<v t="edream.110203163054.196"><vh>Removed all __del__ methods</vh></v>
</v>
<v t="edream.110203163054.197"><vh>New and improved features and commands</vh>
<v t="edream.110203163054.198"><vh>Added patch by Davide Salomoni to OnIconDoubleClick</vh></v>
<v t="edream.110203163054.199" a=""><vh>@lineending directive specifies line endings</vh></v>
<v t="edream.110203163054.200"><vh>Added thin_at_file_trees &amp; load_derived_files_immediately options</vh></v>
</v>
</v>
<v t="edream.110203163054.201"><vh>** Leo now uses unicode internally</vh>
<v t="edream.110203163054.202"><vh>Added calls to toEncodedString before all calls to write</vh></v>
<v t="edream.110203163054.203"><vh>Check for valid encoding when setting app().tkEncoding</vh></v>
<v t="edream.110203163054.204"><vh>How Leo handles unicode</vh></v>
<v t="edream.110203163054.205" a=""><vh>Unicode settings</vh></v>
<v t="edream.110203163054.206"><vh>Unicode theory of operation</vh></v>
<v t="edream.110203163054.207"><vh>Use app().tkEncoding when writing to log pane</vh></v>
</v>
<v t="edream.110203163054.208"><vh>** Improved hooks &amp; a new plugin architecture</vh>
<v t="edream.110203163054.209"><vh>New plugin architecture</vh>
<v t="edream.110203163054.210"><vh>@file plugins/mod_open_with.py</vh>
<v t="edream.110203163054.211"><vh>on_idle</vh>
<v t="edream.110203163054.212"><vh>&lt;&lt; update v's body text &gt;&gt;</vh>
<v t="edream.110203163054.213"><vh>&lt;&lt; set s to the new text &gt;&gt;</vh></v>
<v t="edream.110203163054.214"><vh>&lt;&lt; set conflict flag &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.215"><vh>create_open_with_menu</vh>
<v t="edream.110203163054.216"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.217"><vh>Major reorganization of hooks</vh>
<v t="edream.110203163054.218"><vh>About hooks</vh></v>
</v>
<v t="edream.110203163054.219"><vh>Added several new plugins</vh></v>
<v t="edream.110203163054.220"><vh>Improved Open With plugin</vh></v>
<v t="edream.110203163054.221"><vh>Added logic to retain log output until a log exists</vh></v>
</v>
<v t="edream.110203163054.222"><vh>New configuration options &amp; plugins</vh>
<v t="edream.110203163054.223"><vh>Plugins</vh></v>
<v t="edream.110203163054.205" a=""><vh>Unicode settings</vh></v>
<v t="edream.110203163054.224"><vh>Colors for Show Invisibibles command</vh></v>
<v t="edream.110203163054.225"><vh>look_for_control_drag_on_mouse_down option</vh></v>
<v t="edream.110203163054.226"><vh>body_insertion_cursor_color setting</vh></v>
<v t="edream.110203163054.227"><vh>time/date settings</vh></v>
</v>
<v t="edream.110203163054.228"><vh>New commands</vh>
<v t="edream.110203163054.229"><vh>Toggle Angle Brackets</vh></v>
<v t="edream.110203163054.230"><vh>Insert Body/Headline Time/Date</vh></v>
<v t="edream.110203163054.231"><vh>Go To First/last Node</vh></v>
<v t="edream.110203163054.232"><vh>Go To Parent</vh></v>
<v t="edream.110203163054.233"><vh>Go To Next/Previous Sibling</vh></v>
<v t="edream.110203163054.234"><vh>Write Missing @file Nodes</vh></v>
</v>
<v t="edream.110203163054.235"><vh>Improved commands</vh>
<v t="edream.110203163054.236"><vh>Added support for body/headline_gmt_time settings</vh></v>
<v t="edream.110203163054.237"><vh>Tangle now supports output_newline option</vh></v>
<v t="edream.110203163054.238"><vh>Major improvements to expand/contract commands</vh></v>
<v t="edream.110203163054.239"><vh>Leo now allows multiple writes of cloned nodes</vh></v>
<v t="edream.110203163054.240"><vh>The Sort Siblings command can now sort top-level nodes</vh></v>
<v t="edream.110203163054.241"><vh>Changed locks on customizeLeo.py</vh></v>
</v>
<v t="edream.110203163054.242"><vh>Other improvements</vh>
<v t="edream.110203163054.243"><vh>Allow color param when queuing messages to log pane</vh></v>
<v t="edream.110203163054.244"><vh>Improved scrolling when moving right</vh></v>
<v t="edream.110203163054.245"><vh>Put file name first in window title</vh></v>
<v t="edream.110203163054.246"><vh>Leo scrolls partially visible headlines into full view</vh></v>
<v t="edream.110203163054.247"><vh>Allowed @comment with @language plain</vh></v>
<v t="edream.110203163054.248"><vh>The Find button is now default button in the Find panel</vh></v>
<v t="edream.110203163054.249"><vh>Improved syntax coloring for html and xml</vh>
<v t="edream.110203163054.250"><vh>example of syntax coloring for html</vh></v>
</v>
<v t="edream.110203163054.251"><vh>Improved Prefs panel</vh></v>
<v t="edream.110203163054.252"><vh>Removed setup.py from distributed files</vh></v>
</v>
<v t="edream.110203163054.253"><vh>Bug fixes</vh>
<v t="edream.110203163054.254"><vh>Eliminated potential hang in Open With command</vh></v>
<v t="edream.110203163054.255"><vh>Fixed 2 line number bugs</vh></v>
<v t="edream.110203163054.256"><vh>Fixed bug involving nested comments in sentinel lines</vh></v>
<v t="edream.110203163054.257"><vh>Fixed bugs in promote/demote</vh></v>
<v t="edream.110203163054.258"><vh>Fixed configuration bug.</vh></v>
<v t="edream.110203163054.259"><vh>Fixed crasher in undo logic</vh></v>
<v t="edream.110203163054.260"><vh>Fixed drag problem</vh></v>
<v t="edream.110203163054.261"><vh>Fixed huge performance bug in v.unjoinNode</vh></v>
<v t="edream.110203163054.262"><vh>Fixed long-standing control-v bug on Linux</vh></v>
<v t="edream.110203163054.263"><vh>Fixed minor import bugs</vh></v>
<v t="edream.110203163054.264"><vh>Fixed problem with block comments</vh></v>
<v t="edream.110203163054.265"><vh>Fixed several problems revealed by French plugin</vh></v>
<v t="edream.110203163054.266"><vh>Fixed several problems with noweb mode</vh></v>
<v t="edream.110203163054.267"><vh>Fixed syntax coloring bugs</vh></v>
<v t="edream.110203163054.268"><vh>Full recolor after paste</vh></v>
<v t="edream.110203163054.269"><vh>Installer now creates plugins directory</vh></v>
<v t="edream.110203163054.270"><vh>Removed duplicate redraws when renaming nodes</vh></v>
<v t="edream.110203163054.271"><vh>Udated recent files menu when saving a new .leo file</vh></v>
<v t="edream.110203163054.272"><vh>Worked around bugs in Python 2.3 a1</vh></v>
</v>
</v>
<v t="edream.110203163054.273"><vh>3.10</vh>
<v t="edream.110203163054.274"><vh>Fixed bugs</vh>
<v t="edream.110203163054.275"><vh>Allowed abbreviated xml tags.</vh></v>
<v t="edream.110203163054.276"><vh>Changed shortcut to Find Previous so Alt - F4 closes Leo</vh></v>
<v t="edream.110203163054.277"><vh>Changed url of help file</vh></v>
<v t="edream.110203163054.278"><vh>Fixed @nsf bug reported by Travers A. Hough</vh></v>
<v t="edream.110203163054.279"><vh>Fixed a bug in Untangle</vh></v>
<v t="edream.110203163054.280"><vh>Fixed bug in Python importer</vh></v>
<v t="edream.110203163054.281"><vh>Fixed bug involving redrawing screen initially</vh></v>
<v t="edream.110203163054.282"><vh>Fixed bugs involving @nosentinelsfile</vh></v>
<v t="edream.110203163054.283"><vh>Fixed crashers in colorizeAnyLanguage</vh></v>
<v t="edream.110203163054.284"><vh>Fixed environment bug in Execute Script command</vh></v>
<v t="edream.110203163054.285"><vh>Fixed major memory leak</vh></v>
<v t="edream.110203163054.286"><vh>Fixed path problem in paths passed to tangle_done.py</vh></v>
<v t="edream.110203163054.287"><vh>Fixed problems with Open With code in customizeLeo.py</vh></v>
<v t="edream.110203163054.288"><vh>Fixed Recent Files command</vh></v>
<v t="edream.110203163054.289"><vh>Fixed reversion involving @comment &amp; @language together</vh></v>
<v t="edream.110203163054.290"><vh>Fixed undo bug</vh></v>
</v>
<v t="edream.110203163054.291"><vh>Added features</vh>
<v t="edream.110203163054.292"><vh>New Mark Clones and Go To Next Clone commands.</vh></v>
<v t="edream.110203163054.293"><vh>New Export Headlines command</vh></v>
<v t="edream.110203163054.294"><vh>Control-dragging a node now clones it</vh></v>
<v t="edream.110203163054.295"><vh>New "Node Only checkbox in the Find/Change panel</vh></v>
<v t="edream.110203163054.296"><vh>@root options</vh></v>
<v t="edream.110203163054.297"><vh>Converted leoConfig.py to use @root-code</vh></v>
<v t="edream.110203163054.298"><vh>Added @file options</vh></v>
<v t="edream.110203163054.299"><vh>Added support for underlined menu items</vh></v>
<v t="edream.110203163054.300"><vh>Improved Leo's window icon</vh></v>
<v t="edream.110203163054.301"><vh>Added easy way of replacing any Leo code</vh></v>
<v t="edream.110203163054.302"><vh>Added convenience routines to redirect stderr and stdout</vh></v>
<v t="edream.110203163054.303"><vh>Added "event1" and "event2" hooks</vh></v>
<v t="edream.110203163054.304"><vh>Added  contributed code to support @read-only nodes</vh></v>
</v>
<v t="edream.110203163054.305"><vh>Known bugs</vh>
<v t="edream.110203163054.306"><vh>Bugs in undoReplace logic</vh></v>
</v>
</v>
<v t="edream.110203163054.307"><vh>leo.py 3.9</vh>
<v t="edream.110203163054.308"><vh>Fixed bugs</vh>
<v t="edream.110203163054.309"><vh>Fixed bug involving @language</vh></v>
<v t="edream.110203163054.310"><vh>Correctly colors Pascal's "private" and "uses" keywords</vh></v>
<v t="edream.110203163054.311"><vh>Fixed a major bug in top()</vh></v>
<v t="edream.110203163054.312"><vh>Fixed bugs when importing Java files.</vh></v>
<v t="edream.110203163054.313"><vh>Convert All Blanks/Tabs  commands honor @tabwidth directives</vh></v>
</v>
<v t="edream.110203163054.314"><vh>New documentation for leo.py 3.9</vh>
<v t="edream.110203163054.315"><vh>Major performance improvements</vh>
<v t="edream.110203163054.316"><vh>Incremental syntax coloring speeds redraws</vh></v>
<v t="edream.110203163054.317"><vh>Incremental undo reduces memory usages significantly</vh></v>
</v>
<v t="edream.110203163054.318"><vh>Major configuration improvements</vh>
<v t="edream.110203163054.319" a=""><vh>Chapter 8: Customizing Leo</vh>
<v t="edream.110203163054.320" a=""><vh>Using leoConfig.leo and leoConfig.txt</vh></v>
<v t="edream.110203163054.321"><vh>Using plugins and hooks</vh>
<v t="edream.110203163054.322" a=""><vh>Overview of plugins and hooks</vh></v>
<v t="edream.110203163054.323"><vh>New plugin architecture</vh>
<v t="edream.110203163054.324"><vh>@file plugins/mod_open_with.py</vh>
<v t="edream.110203163054.325"><vh>on_idle</vh>
<v t="edream.110203163054.326"><vh>&lt;&lt; update v's body text &gt;&gt;</vh>
<v t="edream.110203163054.327"><vh>&lt;&lt; set s to the new text &gt;&gt;</vh></v>
<v t="edream.110203163054.328"><vh>&lt;&lt; set conflict flag &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.329"><vh>create_open_with_menu</vh>
<v t="edream.110203163054.330"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.172" a=""><vh>About hooks</vh></v>
<v t="edream.110203163054.331"><vh>SECURITY WARNINGS</vh>
<v t="edream.110203163054.332"><vh>The danger of trusting code in shared .leo files</vh></v>
<v t="edream.110203163054.333"><vh>NEVER use this kind of code in a hook!!</vh></v>
<v t="edream.110203163054.334"><vh>Don't use rexec !!</vh>
<v t="edream.110203163054.335"><vh>&lt;&lt; change all instances of rexec to exec in v's body &gt;&gt;</vh></v>
<v t="edream.110203163054.336"><vh>&lt;&lt; delete thisNode &gt;&gt;</vh></v>
<v t="edream.110203163054.337"><vh>&lt;&lt; clear the undo stack &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.338"><vh>Convenience routines for plugins</vh>
<v t="edream.110203163054.339"><vh>Convenience functions to enable and disable the "idle" hook</vh></v>
<v t="edream.110203163054.340"><vh>Convenience methods to create, destroy and modify menus</vh>
<v t="edream.110203163054.341"><vh>createMenuItemsFromTable</vh></v>
<v t="edream.110203163054.342"><vh>createNewMenu</vh></v>
<v t="edream.110203163054.343" a=""><vh>createOpenWithMenuFromTable</vh></v>
<v t="edream.110203163054.344"><vh>deleteMenu</vh></v>
<v t="edream.110203163054.345"><vh>deleteMenuItem</vh></v>
<v t="edream.110203163054.346"><vh>Example: how to create a menu</vh></v>
</v>
</v>
<v t="edream.110203163054.347"><vh>Translating menus into other languages</vh></v>
</v>
<v t="edream.110203163054.61" a=""><vh>Putting the Leo icon in Leo windows</vh></v>
<v t="edream.110203163054.348"><vh>Extending the format of .leo files</vh></v>
</v>
<v t="edream.110203163054.349" a=""><vh>More flexible creation of non-existent directories</vh></v>
</v>
<v t="edream.110203163054.350"><vh>New commands &amp; features</vh>
<v t="edream.110203163054.351" a=""><vh>@url</vh></v>
<v t="edream.110203163054.352"><vh>Execute Script command</vh></v>
<v t="edream.110203163054.353" a=""><vh>Go To Line Number command</vh></v>
<v t="edream.110203163054.349" a=""><vh>More flexible creation of non-existent directories</vh></v>
<v t="edream.110203163054.354"><vh>Much better support for cweb</vh>
<v t="edream.110203163054.355" a=""><vh>About cweb mode </vh></v>
</v>
<v t="edream.110203163054.356" a=""><vh>Open With command</vh>
<v t="edream.110203163054.343" a=""><vh>createOpenWithMenuFromTable</vh></v>
</v>
<v t="edream.110203163054.357" a=""><vh>Optional Emacs-style auto-indent</vh></v>
<v t="edream.110203163054.61" a=""><vh>Putting the Leo icon in Leo windows</vh></v>
<v t="edream.110203163054.358" a=""><vh>Reformat Paragraph command</vh></v>
</v>
<v t="edream.110203163054.359" a=""><vh>Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees</vh></v>
</v>
</v>
<v t="edream.110203163054.360"><vh>leo.py 3.8</vh>
<v t="edream.110203163054.361"><vh>Fixed bugs</vh>
<v t="edream.110203163054.362"><vh>Crashers</vh>
<v t="edream.110203163054.363"><vh>Fixed another crasher in scanAllDirectives</vh></v>
</v>
<v t="edream.110203163054.366"><vh>Bugs involving paths &amp; derived files</vh>
<v t="edream.110203163054.368"><vh>Fixed @delims "round trip" bug</vh></v>
<v t="edream.110203163054.369"><vh>Fixed cweb sentinel bug</vh></v>
<v t="edream.110203163054.370"><vh>Fixed import to @root problems</vh></v>
<v t="edream.110203163054.371"><vh>Leo generates @@ sentinels only for real Leo directives</vh></v>
</v>
<v t="edream.110203163054.372"><vh>Minor syntax coloring bugs</vh>
<v t="edream.110203163054.373"><vh>Colorizer now recognizes comments after preprocessor directives</vh></v>
<v t="edream.110203163054.374"><vh>Syntax color perl's alarm function</vh></v>
<v t="edream.110203163054.375"><vh>Fixed block-comment bug in Java and HTML</vh></v>
</v>
<v t="edream.110203163054.376"><vh>Minor user interface bugs</vh>
<v t="edream.110203163054.377"><vh>Worked around Control-T bug</vh></v>
<v t="edream.110203163054.378"><vh>Fixed bug involving menu pastes in headlines</vh></v>
</v>
<v t="edream.110203163054.379"><vh>fixed Unicode bug in setBodyStringOrPane</vh></v>
</v>
<v t="edream.110203163054.380"><vh>New &amp; changed features</vh>
<v t="edream.110203163054.381"><vh>New @rawfile &amp; @silentfile trees</vh>
<v t="edream.110203163054.359" a=""><vh>Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees</vh></v>
</v>
<v t="edream.110203163054.382"><vh>New @raw, @end_raw and @quiet directives</vh>
<v t="edream.110203163054.383" a=""><vh>@raw and @end_raw directives delimit raw text</vh></v>
<v t="edream.110203163054.384" a=""><vh>@verbose, @terse, @quiet and @silent directives control comments in @root trees</vh></v>
</v>
<v t="edream.110203163054.385"><vh>Much better support for CWEB</vh>
<v t="edream.110203163054.355" a=""><vh>About cweb mode </vh></v>
</v>
<v t="edream.110203163054.386"><vh>Allow @comment and @language to coexist</vh></v>
<v t="edream.110203163054.387"><vh>Configuration settings and commands</vh>
<v t="edream.110203163054.388"><vh>Added stylesheet option to support &lt;?xml-stylesheet...?&gt; line</vh></v>
<v t="edream.110203163054.389"><vh>Added Configuration Commands to help menu</vh></v>
<v t="edream.110203163054.390"><vh>Added output_initial_comment option</vh></v>
<v t="edream.110203163054.391"><vh>Added output_newline option</vh></v>
<v t="edream.110203163054.392"><vh>Changed path_directive_creates_directories to create_nonexistent_directories</vh></v>
</v>
<v t="edream.110203163054.393"><vh>Minor changes</vh>
<v t="edream.110203163054.394"><vh>Added support for forth language comments</vh></v>
<v t="edream.110203163054.395"><vh>All export commands now use output_newline option</vh></v>
<v t="edream.110203163054.396"><vh>Changed names of commands in help menu and corresponding entries in leoConfig.leo</vh></v>
<v t="edream.110203163054.397"><vh>Created es_exception</vh></v>
<v t="edream.110203163054.398"><vh>Created reloadAll in leoGlobals.py</vh></v>
<v t="edream.110203163054.399"><vh>Forced focus to body pane after ending headline edit</vh></v>
<v t="edream.110203163054.400"><vh>Use // as single-line comment in Java</vh></v>
<v t="edream.110203163054.401"><vh>wrote "finished" after write @file nodes command</vh></v>
</v>
</v>
<v t="edream.110203163054.402"><vh>Coming soon: Leo 4.0, a major improvement</vh></v>
</v>
<v t="edream.110203163054.403"><vh>leo.py 3.7</vh>
<v t="edream.110203163054.404"><vh>Fixed Bugs</vh>
<v t="edream.110203163054.405"><vh>Language and syntax coloring bugs</vh>
<v t="edream.110203163054.406" a=""><vh>Fixed @comment bug</vh></v>
<v t="edream.110203163054.407"><vh>Fixed colorizing for "while" in C</vh></v>
<v t="edream.110203163054.408"><vh>Fixed @language plain # bug</vh></v>
<v t="edream.110203163054.409"><vh>Fixed @language plain single-quote bug</vh></v>
</v>
<v t="edream.110203163054.410"><vh>Bugs in Edit body commands</vh></v>
<v t="edream.110203163054.411"><vh>Bugs relating to tangling and derived files</vh>
<v t="edream.110203163054.412"><vh>Fixed major bug in @file read code</vh></v>
<v t="edream.110203163054.413"><vh>Fixed minor read bug</vh></v>
<v t="edream.110203163054.406" a=""><vh>Fixed @comment bug</vh></v>
<v t="edream.110203163054.414"><vh>Fixed a bug that affected wrapping in doc parts</vh></v>
</v>
<v t="edream.110203163054.415"><vh>Other bugs</vh>
<v t="edream.110203163054.416"><vh>Fixed reversion in Tangle/Untangle code</vh></v>
<v t="edream.110203163054.417"><vh>Fixed undo cloned headline bug</vh></v>
<v t="edream.110203163054.418"><vh>Fixed Find previous bug</vh></v>
<v t="edream.110203163054.419"><vh>Fixed tab problems</vh></v>
<v t="edream.110203163054.420"><vh>Leo now remembers insert point always</vh></v>
<v t="edream.110203163054.421"><vh>Removed setup.py from binary distribution</vh></v>
</v>
</v>
<v t="edream.110203163054.422"><vh>Improvements</vh>
<v t="edream.110203163054.423"><vh>Many new user options</vh>
<v t="edream.110203163054.424"><vh>General configuration options</vh>
<v t="edream.110203163054.425"><vh>path_directive_creates_directories</vh></v>
<v t="edream.110203163054.426"><vh>relative_path_base_directory</vh></v>
<v t="edream.110203163054.427"><vh>remove_sentinels_extension</vh></v>
<v t="edream.110203163054.428"><vh>write_clone_indices</vh></v>
</v>
<v t="edream.110203163054.429"><vh>Secondary pane ratios</vh></v>
<v t="edream.110203163054.430"><vh>User-configurable colors</vh></v>
<v t="edream.110203163054.431"><vh>User-configurable shortcuts for commands</vh></v>
</v>
<v t="edream.110203163054.432"><vh>Improved support for Unicode</vh></v>
<v t="edream.110203163054.433"><vh>End of cursed newlines</vh></v>
<v t="edream.110203163054.434"><vh>Code is now compatible with Python 2.1</vh></v>
<v t="edream.110203163054.435"><vh>Better file and path handling</vh></v>
<v t="edream.110203163054.436"><vh>Better support for Perl+pod</vh></v>
<v t="edream.110203163054.437"><vh>New End Edit Headline and Abort Edit Headline commands</vh></v>
<v t="edream.110203163054.438"><vh>Allow reads and writes of cloned @file nodes</vh></v>
<v t="edream.110203163054.439"><vh>Leo now closes an empty window when opening a recent file</vh></v>
<v t="edream.110203163054.440"><vh>Improved derived files</vh></v>
<v t="edream.110203163054.441"><vh>Improved enabling of menu items in popup menus</vh></v>
<v t="edream.110203163054.442"><vh>About Leo dialog is now non-modal</vh></v>
</v>
</v>
<v t="edream.110203163054.443"><vh>leo.py 3.6</vh>
<v t="edream.110203163054.444"><vh>Known bug: problems with Python window</vh></v>
<v t="edream.110203163054.445"><vh>Bug fixes</vh>
<v t="edream.110203163054.446"><vh>Fixed problems with opening and writing leoConfig.txt on Linux</vh></v>
<v t="edream.110203163054.447"><vh>Fixed problems renaming files on Linux</vh></v>
<v t="edream.110203163054.448"><vh>Fixed missing headline bug on startup</vh></v>
<v t="edream.110203163054.449"><vh>Improved call to os.path.join in leoApp.finishCreate</vh></v>
<v t="edream.110203163054.450"><vh>Improved how directories are handled in @root trees</vh></v>
<v t="edream.110203163054.451"><vh>Dave Hein: fixed Tk 8.4 problem in Prefs Panel</vh></v>
<v t="edream.110203163054.452"><vh>Dave Hein: added CheckVersion to leoUtils.py</vh></v>
<v t="edream.110203163054.453"><vh>Dave Hein: the Python window now works on Linux.</vh></v>
<v t="edream.110203163054.454"><vh>Steven P. Schaefer: Improved handling of directives in @root trees</vh></v>
<v t="edream.110203163054.455"><vh>Steven P. Schaefer: Fixed cursed newline bug for Linux</vh></v>
</v>
<v t="edream.110203163054.456"><vh>Improvements to existing features</vh>
<v t="edream.110203163054.457"><vh>Leo now remembers scrollbar position and insert point of previously visited nodes</vh></v>
<v t="edream.110203163054.458"><vh>Body pane now gets focus after Go Back/Next</vh></v>
<v t="edream.110203163054.459"><vh>Improved all commands in Help menu</vh></v>
<v t="edream.110203163054.460"><vh>Removed most error messages in atFile::read logic</vh></v>
<v t="edream.110203163054.461"><vh>Added shortcuts for Read/Write @file Nodes commands</vh></v>
<v t="edream.110203163054.462"><vh>Tomaz Ficko: Added support for MouseWheel (Linux only)</vh></v>
</v>
<v t="edream.110203163054.463"><vh>New features</vh>
<v t="edream.110203163054.464"><vh>Added Match Brackets command</vh></v>
<v t="edream.110203163054.465"><vh>Added PHP support</vh></v>
<v t="edream.110203163054.466"><vh>Added LaTex support</vh></v>
</v>
</v>
<v t="edream.110203163054.467"><vh>leo.py 3.5</vh>
<v t="edream.110203163054.468"><vh>Bug fixes</vh>
<v t="edream.110203163054.469"><vh>Called cf.flush in leoConfig.update</vh></v>
<v t="edream.110203163054.470"><vh>Fixed crasher in leoFileCommands.readOutlineOnly</vh></v>
<v t="edream.110203163054.471"><vh>Fixed crasher when leoConfig.txt did not exist</vh></v>
<v t="edream.110203163054.472"><vh>Fixed cursed newline bug in leoAtFile</vh></v>
<v t="edream.110203163054.473"><vh>Rewrote scanAllDirectives routines to handle relative paths</vh></v>
<v t="edream.110203163054.474"><vh>Suppressed erroneous tangle warning about relative paths</vh></v>
</v>
<v t="edream.110203163054.475"><vh>Improvements</vh>
<v t="edream.110203163054.476"><vh>Added configuration settings for horizontal scrollbars</vh></v>
<v t="edream.110203163054.477"><vh>Added commands to the help menu</vh></v>
<v t="edream.110203163054.478"><vh>Added logic to test for read-only files</vh></v>
<v t="edream.110203163054.479"><vh>Added importFiles script</vh></v>
</v>
</v>
<v t="edream.110203163054.480"><vh>leo.py 3.4</vh>
<v t="edream.110203163054.481"><vh>Configuration settings and leoConfig.leo</vh>
<v t="edream.110203163054.482"><vh>Added comments to leoConfig.txt about split direction and ratio</vh></v>
<v t="edream.110203163054.483"><vh>Added save_clears_undo_buffer config option</vh></v>
<v t="edream.110203163054.484"><vh>Corrected spelling of limit_directory_search_extenstion </vh></v>
<v t="edream.110203163054.485"><vh>Created leoConfig.leo</vh></v>
<v t="edream.110203163054.486"><vh>Fixed a major config bug. This fixes font problems</vh></v>
<v t="edream.110203163054.487"><vh>Improved Recent Files menu</vh></v>
<v t="edream.110203163054.488"><vh>Leo honors pane ratio stored in .leo files</vh></v>
<v t="edream.110203163054.489"><vh>Leo writes prefs if leoConfig.txt is read-only</vh></v>
<v t="edream.110203163054.490"><vh>Made leoConfig.txt be read/write by default</vh></v>
<v t="edream.110203163054.491"><vh>Toggle Split Direction now updates leoConfig.txt</vh></v>
</v>
<v t="edream.110203163054.492"><vh>Documentation for code in leo.py that may be of wider interest</vh>
<v t="edream.110203163054.493" a=""><vh>Code hidden in leo.py</vh>
<v t="edream.110203163054.494"><vh>c2py.py</vh></v>
<v t="edream.110203163054.495"><vh>disStats.py</vh></v>
<v t="edream.110203163054.496"><vh>Tkinter utilities</vh></v>
<v t="edream.110203163054.497"><vh>Font dialog</vh></v>
<v t="edream.110203163054.498"><vh>Syntax coloring code</vh></v>
<v t="edream.110203163054.499"><vh>Tree code</vh></v>
</v>
</v>
<v t="edream.110203163054.500"><vh>Fixed bugs</vh>
<v t="edream.110203163054.501"><vh>Fixed another clone bug: created setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="edream.110203163054.502"><vh>Fixed bugs that delayed writing of find and prefs panels</vh></v>
<v t="edream.110203163054.503"><vh>Fixed revert problems in font panel</vh></v>
<v t="edream.110203163054.504"><vh>Fixed several unicode bugs</vh></v>
<v t="edream.110203163054.505"><vh>Fixed wandering insertion point bug</vh></v>
</v>
<v t="edream.110203163054.506"><vh>Minor improvements</vh>
<v t="edream.110203163054.507"><vh>Syntax colorer now honors @comment</vh></v>
<v t="edream.110203163054.508"><vh>Added @ignore to "raw" imported files</vh></v>
<v t="edream.110203163054.509"><vh>Added log message for Remove Sentinels command</vh></v>
<v t="edream.110203163054.510"><vh>Improved highlighting of whitespace</vh></v>
<v t="edream.110203163054.511"><vh>Remove Sentinels command now uses .txt extension instead of .tmp</vh></v>
</v>
</v>
<v t="edream.110203163054.512"><vh>leo.py 3.3</vh>
<v t="edream.110203163054.513"><vh>Added support for Unicode</vh></v>
<v t="edream.110203163054.514"><vh>Improved the Import commands &amp; fixed Javadoc problem</vh></v>
<v t="edream.110203163054.515"><vh>Fixed crasher when Tangling</vh></v>
<v t="edream.110203163054.516"><vh>Fixed problems with negative tab widths</vh></v>
<v t="edream.110203163054.517"><vh>Fixed numerous problems related to configuration settings</vh></v>
</v>
<v t="edream.110203163054.518"><vh>leo.py 3.2</vh>
<v t="edream.110203163054.519"><vh>Nested @others directives now valid</vh>
<v t="edream.110203163054.520"><vh>@file test.txt</vh>
<v t="edream.110203163054.521"><vh>class a</vh>
<v t="edream.110203163054.522"><vh>a::one</vh></v>
<v t="edream.110203163054.523"><vh>a:two</vh></v>
</v>
<v t="edream.110203163054.524"><vh>class b</vh>
<v t="edream.110203163054.525"><vh>b::one</vh></v>
<v t="edream.110203163054.526"><vh>b:two</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.527"><vh>Improved Import command</vh></v>
<v t="edream.110203163054.528"><vh>Reassigned shortcuts in the Outline-Move/Select menu</vh></v>
<v t="edream.110203163054.529"><vh>Fixed crasher in the Preferences Panel</vh></v>
<v t="edream.110203163054.530"><vh>Improved syntax coloring of continued C strings</vh></v>
<v t="edream.110203163054.531"><vh>Made many changes to Color Panel</vh></v>
<v t="edream.110203163054.532"><vh>Added email address &amp; URL to About Leo dialog</vh></v>
<v t="edream.110203163054.533"><vh>added disStats.py</vh></v>
</v>
<v t="edream.110203163054.534"><vh>leo.py 3.1</vh>
<v t="edream.110203163054.535"><vh>Added compare panel</vh></v>
<v t="edream.110203163054.536"><vh>Added new settings to leoConfig.txt</vh></v>
<v t="edream.110203163054.537"><vh>Changed precedence scheme for preferences</vh></v>
<v t="edream.110203163054.538"><vh>Fixed @tabwidth, @pagewidth and @language directives</vh></v>
<v t="edream.110203163054.539"><vh>Flatten Outline now escapes only the first non-blank character of each line.</vh></v>
<v t="edream.110203163054.540"><vh>Open Python Window command adds path to IDLE automatically</vh></v>
<v t="edream.110203163054.541"><vh>Python 2.2 required dialog tells where to download Python 2.2 and Tk 8.3</vh></v>
</v>
<v t="edream.110203163054.542"><vh>leo.py 3.0</vh>
<v t="edream.110203163054.543"><vh>Optional new file format</vh></v>
<v t="edream.110203163054.544"><vh>New features (in approximate order of importance)</vh>
<v t="edream.110203163054.545"><vh>Added many settings to leoConfig.txt file</vh>
<v t="edream.110203163054.546"><vh>New windows now open using config params.</vh></v>
</v>
<v t="edream.110203163054.547"><vh>Added autoscrolling in the outline pane</vh></v>
<v t="edream.110203163054.548"><vh>Color panel</vh></v>
<v t="edream.110203163054.549"><vh>Font panel</vh></v>
<v t="edream.110203163054.550"><vh>Leo now opens windows at the position in which they were saved</vh></v>
<v t="edream.110203163054.551"><vh>Added Toggle Split Direction</vh></v>
<v t="edream.110203163054.552"><vh>Improved syntax coloring for @comment directives</vh></v>
<v t="edream.110203163054.553"><vh>Leo warns and aborts if not Python 2.2 or above</vh></v>
<v t="edream.110203163054.554"><vh>All panels now have labeled frames and grooved borders</vh></v>
<v t="edream.110203163054.555"><vh>Leo directives are now colored green by default</vh></v>
<v t="edream.110203163054.556"><vh>Print a traceback message for all serious exceptions</vh></v>
<v t="edream.110203163054.557"><vh>@comment supports comments starting with REM</vh></v>
</v>
<v t="edream.110203163054.558"><vh>Fixed bugs (one crasher)</vh>
<v t="edream.110203163054.559"><vh>Fixed crasher in atFile.scanAllDirectives</vh></v>
<v t="edream.110203163054.560"><vh>Fixed syntax coloring bug involving Leo directives</vh></v>
<v t="edream.110203163054.561"><vh>Windows now open without visual problems</vh></v>
<v t="edream.110203163054.562"><vh>Made Convert Tabs, Convert All Blanks and Convert All Tabs undoable</vh></v>
<v t="edream.110203163054.563"><vh>Made Prefs panel non-modal</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.564"><vh>2.x releases</vh>
<v t="edream.110203163054.565"><vh>leo.py 2.5.1 Many improvements</vh>
<v t="edream.110203163054.566"><vh>New &amp; improved commands</vh>
<v t="edream.110203163054.567"><vh>Tabs and spaces</vh>
<v t="edream.110203163054.568"><vh>Added Convert All Blanks and Convert All Tabs commands</vh></v>
<v t="edream.110203163054.569"><vh>Added Convert Tabs command</vh></v>
<v t="edream.110203163054.570"><vh>Tab widths work</vh></v>
<v t="edream.110203163054.571"><vh>Negative tab width converts tabs to spaces</vh></v>
</v>
<v t="edream.110203163054.572"><vh>Improved Preferences panel</vh></v>
<v t="edream.110203163054.320" a=""><vh>Using leoConfig.leo and leoConfig.txt</vh></v>
<v t="edream.110203163054.573"><vh>Cut and Paste now works properly in all situations</vh></v>
<v t="edream.110203163054.574"><vh>Added Recent Files menu</vh></v>
<v t="edream.110203163054.575"><vh>All Extract and Import commands are now undoable</vh></v>
<v t="edream.110203163054.576"><vh>Made Cascade and Minimize All commands functional</vh></v>
</v>
<v t="edream.110203163054.577"><vh>Significant bug fixes</vh>
<v t="edream.110203163054.578"><vh>Fixed several bugs in the Import commands</vh></v>
<v t="edream.110203163054.579"><vh>Invalid directories no longer cause read errors</vh></v>
</v>
<v t="edream.110203163054.580"><vh>Fixed crashers</vh>
<v t="edream.110203163054.581"><vh>Fixed crasher when saving a new file</vh></v>
<v t="edream.110203163054.582"><vh>Fixed crashers in Remove Sentinels command</vh></v>
<v t="edream.110203163054.583"><vh>Fixed crasher in Import commands</vh></v>
</v>
<v t="edream.110203163054.584"><vh>Fixed minor bugs &amp; improvements</vh>
<v t="edream.110203163054.585"><vh>Recolored body text after extract commands</vh></v>
<v t="edream.110203163054.586"><vh>Fixed bug involving missing clone mark after Move Right command</vh></v>
<v t="edream.110203163054.587"><vh>Changed defaultextension from "x" to ".x" in dialogs.</vh></v>
<v t="edream.110203163054.588"><vh>Fixed minor bug in Save and Save As commands</vh></v>
<v t="edream.110203163054.589"><vh>Fixed minor problems with documentation</vh></v>
<v t="edream.110203163054.590"><vh>Renamed Font to Set Font... and Syntax Coloring... to Set Colors...</vh></v>
</v>
</v>
<v t="edream.110203163054.591"><vh>leo.py 2.4</vh>
<v t="edream.110203163054.592"><vh>Fixed several bugs</vh></v>
<v t="edream.110203163054.593"><vh>Added better error recovery when writing .leo files</vh></v>
<v t="edream.110203163054.594" a=""><vh>Dragging headlines</vh></v>
<v t="edream.110203163054.60" a=""><vh>How to associate leo.py with .leo files on Windows</vh></v>
</v>
<v t="edream.110203163054.595"><vh>leo.py 2.3</vh></v>
<v t="edream.110203163054.596"><vh>leo.py 2.2 Bug fixes and documentation revised</vh></v>
<v t="edream.110203163054.597"><vh>2.1 Import &amp; Export commands</vh>
<v t="edream.110203163054.598"><vh>Import and Export commands</vh></v>
<v t="edream.110203163054.599"><vh>Fixed moves up to root position</vh></v>
<v t="edream.110203163054.600"><vh>Improved the syntax colorer</vh></v>
</v>
<v t="edream.110203163054.601"><vh>2.0 Untangle, Unlimited Undo/Redo, Syntax Coloring, etc.</vh>
<v t="edream.110203163054.602"><vh>Format change: no blank lines between sentinels in derived files</vh></v>
<v t="edream.110203163054.603"><vh>Unlimited Undo and Redo</vh></v>
<v t="edream.110203163054.604"><vh>Drawing and syntax coloring</vh>
<v t="edream.110203163054.605"><vh>Syntax coloring works for all languages</vh></v>
<v t="edream.110203163054.606"><vh>Fixed minor syntax coloring bugs</vh></v>
<v t="edream.110203163054.607"><vh>Headlines given more space</vh></v>
<v t="edream.110203163054.608"><vh>Suppressed auto-indent for Python in @nocolor mode</vh></v>
</v>
<v t="edream.110203163054.609"><vh>Tangle/Untangle</vh>
<v t="edream.110203163054.610"><vh>Fixed old bugs in Untangle</vh></v>
<v t="edream.110203163054.611"><vh>@c now is the same as @code</vh></v>
<v t="edream.110203163054.612"><vh>Untangle only trims trailing lines from updated nodes</vh></v>
</v>
<v t="edream.110203163054.613"><vh>Fixed Linux-specific bugs</vh></v>
</v>
<v t="edream.110203163054.614"><vh>1.0 New commands and bug fixes</vh>
<v t="edream.110203163054.615"><vh>Unfinished commands</vh></v>
<v t="edream.110203163054.616"><vh>How to copy an outline from Borland Leo to Leo.py</vh></v>
<v t="edream.110203163054.617"><vh>Fixed bugs</vh></v>
<v t="edream.110203163054.618"><vh>Remaining minor problems</vh></v>
</v>
<v t="edream.110203163054.619"><vh>0.08 Find, Change and Tangle commands &amp; major bugs fixed</vh>
<v t="edream.110203163054.620"><vh>About the Find and Change commands</vh></v>
<v t="edream.110203163054.621"><vh>About the Tangle command</vh></v>
<v t="edream.110203163054.622"><vh>About hyperlinking</vh></v>
<v t="edream.110203163054.623"><vh>Fixed significant bugs</vh></v>
<v t="edream.110203163054.624"><vh>Other improvements</vh></v>
<v t="edream.110203163054.625"><vh>Improved memory management</vh></v>
<v t="edream.110203163054.626"><vh>The trace function (Sherlock tracing)</vh></v>
<v t="edream.110203163054.627"><vh>Improved directory and file name handling</vh></v>
<v t="edream.110203163054.628"><vh>Improvements that will be propagated back to LeoCB</vh></v>
</v>
<v t="edream.110203163054.629"><vh>0.07 Stability and scripting</vh>
<v t="edream.110203163054.630"><vh>Thorough testing</vh></v>
<v t="edream.110203163054.631"><vh>Removed many irritations.  Some remain</vh></v>
<v t="edream.110203163054.632"><vh>Fixed bug that can drop data</vh></v>
<v t="edream.110203163054.633"><vh>Added Python window and scripting support</vh></v>
<v t="edream.110203163054.634"><vh>Added Script to convert from Leo 1 to Leo 2</vh></v>
<v t="edream.110203163054.635"><vh>Added Leo Documentation command</vh></v>
<v t="edream.110203163054.636"><vh>Added Auto indent</vh></v>
</v>
<v t="edream.110203163054.637"><vh>0.06 Minor changes for Linux</vh></v>
<v t="edream.110203163054.638"><vh>0.05 The first functional version</vh>
<v t="edream.110203163054.639"><vh>Testing &amp; Performance</vh></v>
<v t="edream.110203163054.640"><vh>Installing and Running leo.py</vh></v>
<v t="edream.110203163054.641"><vh>Files &amp; Folders</vh></v>
<v t="edream.110203163054.642"><vh>Functional Commands and Features</vh></v>
<v t="edream.110203163054.643"><vh>Non-Functional Commands and Features</vh></v>
<v t="edream.110203163054.644"><vh>Bugs, Problems and Code Quality</vh></v>
<v t="edream.110203163054.645"><vh>New Things To Do</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.646"><vh>Borland PC versions</vh>
<v t="edream.110203163054.647"><vh>Borland 2.7 Major bug fix: please upgrade</vh></v>
<v t="edream.110203163054.648"><vh>Borland 2.6 Major changes: please upgrade</vh>
<v t="edream.110203163054.649"><vh>Format change: no blank lines between sentinels in derived files</vh></v>
<v t="edream.110203163054.650"><vh>Eliminated spurious read errors</vh></v>
<v t="edream.110203163054.651"><vh>@c now is the same as @code</vh></v>
<v t="edream.110203163054.652"><vh>Fixed old bugs in Untangle</vh></v>
<v t="edream.110203163054.653"><vh>Compatibility with leo.py v2.0</vh></v>
<v t="edream.110203163054.654"><vh>Changed "Batch" check box to "Show Context"</vh></v>
<v t="edream.110203163054.655"><vh>Can not ensure .leo extension</vh></v>
</v>
<v t="edream.110203163054.656"><vh>version 2.5: Fixed several serious bugs</vh></v>
<v t="edream.110203163054.657"><vh>version 2.4: The new Leo2 (Do not use this version)</vh>
<v t="edream.110203163054.658"><vh>Fixed clone bugs</vh></v>
<v t="edream.110203163054.659"><vh>.leo files now contain all data</vh></v>
<v t="edream.110203163054.660"><vh>Replaced archive command</vh></v>
<v t="edream.110203163054.661"><vh>Automatic update of @file trees</vh></v>
<v t="edream.110203163054.662"><vh>Errors while reading</vh></v>
<v t="edream.110203163054.663"><vh>Errors while writing</vh></v>
<v t="edream.110203163054.664"><vh>Drawbacks of @file trees</vh></v>
</v>
<v t="edream.110203163054.665"><vh>version 2.3: Do not use this version</vh>
<v t="edream.110203163054.666"><vh>@first directive</vh></v>
<v t="edream.110203163054.667"><vh>Archive Entire Outline command</vh></v>
<v t="edream.110203163054.668"><vh>Fixed @c syntax coloring</vh></v>
<v t="edream.110203163054.669"><vh>Fixed bugs in the find command</vh></v>
<v t="edream.110203163054.670"><vh>Fixed bug involving @file dirty bits</vh></v>
<v t="edream.110203163054.671"><vh>The Log window is now part of the Leo window</vh></v>
</v>
<v t="edream.110203163054.672"><vh>version 2.2 (beta)</vh></v>
<v t="edream.110203163054.673"><vh>version 2.1 (beta)</vh></v>
<v t="edream.110203163054.674"><vh>1.x versions</vh>
<v t="edream.110203163054.675"><vh>Changes made in version 1.15</vh></v>
<v t="edream.110203163054.676"><vh>Changes made in version 1.14</vh></v>
<v t="edream.110203163054.677"><vh>Changes made in version 1.13</vh></v>
<v t="edream.110203163054.678"><vh>Changes made in version 1.12</vh></v>
<v t="edream.110203163054.679"><vh>Changes made in version 1.11</vh>
<v t="edream.110203163054.680" a=""><vh>Multiple parts not allowed for &lt;&lt; section name &gt;&gt;</vh></v>
<v t="edream.110203163054.681" a=""><vh>Untangling: updating an outline</vh></v>
</v>
<v t="edream.110203163054.682"><vh>Changes made in version 1.10</vh></v>
<v t="edream.110203163054.683"><vh>Changes made in version 1.9</vh>
<v t="edream.110203163054.684"><vh>New Execute Script command</vh></v>
<v t="edream.110203163054.685"><vh>Python window improved</vh></v>
</v>
<v t="edream.110203163054.686"><vh>Changes made in version 1.8</vh></v>
<v t="edream.110203163054.687"><vh>Changes made in version 1.7</vh></v>
<v t="edream.110203163054.688"><vh>Changes made in version 1.6</vh></v>
<v t="edream.110203163054.689"><vh>Changes made in version 1.5</vh></v>
<v t="edream.110203163054.690"><vh>Changes made in version 1.4</vh>
<v t="edream.110203163054.691"><vh>Outline To Noweb command</vh></v>
<v t="edream.110203163054.692"><vh>find/change Python scripts</vh></v>
<v t="edream.110203163054.693"><vh>v.commands() Python method</vh></v>
</v>
<v t="edream.110203163054.694"><vh>Changes made in version 1.3</vh></v>
<v t="edream.110203163054.695"><vh>Changes made in version 1.2</vh></v>
<v t="edream.110203163054.696"><vh>Changes made in version 1.1</vh></v>
<v t="edream.110203163054.697"><vh>Changes made in version 1.0</vh></v>
<v t="edream.110203163054.698"><vh>Changes made in version 0.19</vh>
<v t="edream.110203163054.699"><vh>Fixed directory bug</vh></v>
<v t="edream.110203163054.700"><vh>Added @language HTML, perl and perlpod</vh></v>
<v t="edream.110203163054.701"><vh>Eliminated @noweb &amp; replaced @cweb with @language cweb</vh></v>
<v t="edream.110203163054.355" a=""><vh>About cweb mode </vh></v>
<v t="edream.110203163054.702"><vh>Improved syntax coloring</vh></v>
<v t="edream.110203163054.703"><vh>Improved Print command</vh></v>
<v t="edream.110203163054.704"><vh>Improved how Untangle handles block comments</vh></v>
<v t="edream.110203163054.705"><vh>Eliminated clone windows (but not clone nodes!)</vh></v>
<v t="edream.110203163054.706"><vh>Eliminated Extended noweb Syntax</vh></v>
</v>
<v t="edream.110203163054.707"><vh>Changes made in version 0.18</vh>
<v t="edream.110203163054.708"><vh>File format extended</vh></v>
<v t="edream.110203163054.709"><vh>Fixed bug in languages without block comments</vh></v>
<v t="edream.110203163054.710"><vh>Added @header and @noheader directives</vh></v>
<v t="edream.110203163054.711"><vh>Added @language fortran90</vh></v>
<v t="edream.110203163054.712"><vh>Added @language perlpod</vh></v>
</v>
<v t="edream.110203163054.713"><vh>Changes made in version 0.17</vh>
<v t="edream.110203163054.714"><vh>Support for noweb &lt;&lt;*&gt;&gt; convention</vh></v>
<v t="edream.110203163054.715"><vh>new @cweb, @noweb, @path, @tabwidth and @pagewidth directives</vh></v>
<v t="edream.110203163054.716"><vh>CWEB mode now has a chance of working</vh></v>
<v t="edream.110203163054.717"><vh>Reduced default screen size</vh></v>
</v>
<v t="edream.110203163054.718"><vh>Changes made in version 0.16</vh>
<v t="edream.110203163054.719"><vh>Bug fixes</vh></v>
<v t="edream.110203163054.720"><vh>Fixed crasher involving switching windows</vh></v>
<v t="edream.110203163054.721"><vh>new @language directive</vh></v>
<v t="edream.110203163054.722"><vh>@language and @comment directives can be inherited</vh></v>
<v t="edream.110203163054.723"><vh>Untangle can now handle non-C files</vh></v>
<v t="edream.110203163054.724"><vh>Untangle now removes trailing blank lines</vh></v>
<v t="edream.110203163054.725"><vh>new @verbose, @terse and @silent directives</vh></v>
<v t="edream.110203163054.726"><vh>Default directories</vh></v>
<v t="edream.110203163054.727"><vh>Import Files command now handles Pascal , Python and Java files.</vh></v>
<v t="edream.110203163054.728"><vh>Toggle Active Pane command</vh></v>
<v t="edream.110203163054.729"><vh>Path delimiters are now '\' instead of '/'</vh></v>
<v t="edream.110203163054.730"><vh>Cleaned up code</vh></v>
<v t="edream.110203163054.731"><vh>Fixed crasher involving empty section names</vh></v>
<v t="edream.110203163054.732"><vh>Untangle warns about sections not in the outline</vh></v>
<v t="edream.110203163054.733"><vh>A limitations involving Untangle</vh></v>
</v>
<v t="edream.110203163054.734" a=""><vh>Known Bugs &amp; Limitations</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.735"><vh>Users Guide</vh>
<v t="edream.110203163054.736"><vh>An overview of Leo</vh></v>
<v t="edream.110203163054.737"><vh>Front material</vh>
<v t="edream.110203163054.738"><vh>Title Page &amp; Summary</vh></v>
<v t="edream.110203163054.739"><vh>Preface</vh></v>
<v t="edream.110203163054.740"><vh>Leo's Design Goals</vh></v>
<v t="edream.110203163054.7" a=""><vh>Acknowledgements</vh></v>
<v t="edream.110203163054.741"><vh>Legal Notices: Leo uses the Python license</vh></v>
</v>
<v t="edream.110203163054.742"><vh>Chapter 1: Introducing Leo</vh>
<v t="edream.110203163054.743"><vh>Overview</vh></v>
<v t="edream.110203163054.744"><vh>Leo's main window</vh></v>
<v t="edream.110203163054.745"><vh>Body text and sections</vh></v>
<v t="edream.110203163054.746"><vh>Outlines organize sections</vh>
<v t="edream.110203163054.747"><vh>removeSentinelsCommand</vh>
<v t="edream.110203163054.748"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="edream.110203163054.749"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="edream.110203163054.750"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.751"><vh>Clones manage tasks</vh></v>
<v t="edream.110203163054.752"><vh>Outlines generate derived files</vh></v>
</v>
<v t="edream.110203163054.753"><vh>Chapter 2: Installing Leo</vh>
<v t="edream.110203163054.49" a=""><vh>System requirements</vh></v>
<v t="edream.110203163054.51" a=""><vh>How to install leo.py on Windows</vh></v>
<v t="edream.110203163054.60" a=""><vh>How to associate leo.py with .leo files on Windows</vh></v>
<v t="edream.110203163054.62" a=""><vh>Quick start</vh></v>
</v>
<v t="edream.110203163054.754"><vh>Chapter 3: Using Outlines &amp; Body text</vh>
<v t="edream.110203163054.755" a=""><vh>Cloning headlines</vh>
<v t="edream.110203163054.756"><vh>read me</vh></v>
<v t="edream.110203163054.757" a=""><vh>a</vh>
<v t="edream.110203163054.758" a=""><vh>b</vh>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
</v>
<v t="edream.110203163054.762"><vh>g</vh></v>
<v t="edream.110203163054.758" a=""><vh>b</vh>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.757" a=""><vh>a</vh>
<v t="edream.110203163054.758" a=""><vh>b</vh>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
</v>
<v t="edream.110203163054.762"><vh>g</vh></v>
<v t="edream.110203163054.758" a=""><vh>b</vh>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.763"><vh>f</vh></v>
</v>
<v t="edream.110203163054.764"><vh>Creating and destroying headlines</vh></v>
<v t="edream.110203163054.765"><vh>Cutting, pasting and deleting headlines</vh></v>
<v t="edream.110203163054.594" a=""><vh>Dragging headlines</vh></v>
<v t="edream.110203163054.766"><vh>Editing body text</vh></v>
<v t="edream.110203163054.767"><vh>Expanding &amp; contracting headlines</vh></v>
<v t="edream.110203163054.768"><vh>Indenting body text automatically</vh>
<v t="edream.110203163054.357" a=""><vh>Optional Emacs-style auto-indent</vh></v>
</v>
<v t="edream.110203163054.769"><vh>Marking headlines</vh></v>
<v t="edream.110203163054.770"><vh>Moving &amp; Reorganizing headlines</vh></v>
<v t="edream.110203163054.771"><vh>Opening URL's automatically</vh>
<v t="edream.110203163054.351" a=""><vh>@url</vh></v>
</v>
<v t="edream.110203163054.772"><vh>Resizing panes</vh></v>
<v t="edream.110203163054.773"><vh>Undoing operations</vh></v>
</v>
<v t="edream.110203163054.774"><vh>Chapter 4: Writing Programs in Leo</vh>
<v t="edream.110203163054.775"><vh>Overview</vh></v>
<v t="edream.110203163054.776"><vh>Sections and section references</vh></v>
<v t="edream.110203163054.777"><vh>Organizing @file trees.</vh>
<v t="edream.110203163054.778"><vh>Examples</vh>
<v t="edream.110203163054.779"><vh>@file f.c</vh>
<v t="edream.110203163054.780"><vh>&lt;&lt; constants &gt;&gt;</vh></v>
<v t="edream.110203163054.781"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="edream.110203163054.782"><vh>function 1</vh></v>
<v t="edream.110203163054.783"><vh>function 2</vh></v>
</v>
<v t="edream.110203163054.784"><vh>@file classX.py</vh>
<v t="edream.110203163054.785"><vh>&lt;&lt; imports for classX &gt;&gt;</vh></v>
<v t="edream.110203163054.786"><vh>Getters</vh>
<v t="edream.110203163054.787"><vh>getter 1</vh></v>
<v t="edream.110203163054.788"><vh>getter 2</vh></v>
</v>
<v t="edream.110203163054.789"><vh>Setters</vh>
<v t="edream.110203163054.790"><vh>setter 1</vh></v>
<v t="edream.110203163054.791"><vh>setter 2</vh></v>
</v>
</v>
<v t="edream.110203163054.792"><vh>@file mainClass.py</vh>
<v t="edream.110203163054.793"><vh>&lt;&lt;mainClass imports &gt;&gt;</vh></v>
<v t="edream.110203163054.794"><vh>&lt;&lt;class mainClass&gt;&gt;</vh>
<v t="edream.110203163054.795"><vh>method 1</vh></v>
<v t="edream.110203163054.796"><vh>method 2</vh></v>
</v>
<v t="edream.110203163054.797"><vh>&lt;&lt;class helperClass&gt;&gt;</vh>
<v t="edream.110203163054.798"><vh>method 1</vh></v>
<v t="edream.110203163054.799"><vh>method 2</vh></v>
</v>
</v>
<v t="edream.110203163054.800"><vh>@file bad</vh>
<v t="edream.110203163054.801"><vh>Methods</vh>
<v t="edream.110203163054.802"><vh>&lt;&lt; section 1 &gt;&gt;</vh>
<v t="edream.110203163054.803"><vh>A</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="edream.110203163054.804"><vh>More about directives</vh>
<v t="edream.110203163054.805"><vh>@color and @nocolor control syntax coloring</vh></v>
<v t="edream.110203163054.806"><vh>@comment sets comment delimiters in @root and @unit trees</vh></v>
<v t="edream.110203163054.807"><vh>@delims directive specifies comment delimiters in @file trees</vh></v>
<v t="edream.110203163054.808"><vh>@encoding directive specifies encoding of text</vh></v>
<v t="edream.110203163054.809"><vh>@first and @last directives allow leading and trailing lines in @file trees</vh></v>
<v t="edream.110203163054.810"><vh>@language specifying the target language</vh></v>
<v t="edream.110203163054.199" a=""><vh>@lineending directive specifies line endings</vh></v>
<v t="edream.110203163054.811"><vh>@path, @pagewidth and @tabwidth directives set preferences</vh></v>
<v t="edream.110203163054.383" a=""><vh>@raw and @end_raw directives delimit raw text</vh></v>
<v t="edream.110203163054.812"><vh>@wrap and @nowrap directives control line wrapping in the body pane</vh></v>
</v>
<v t="edream.110203163054.355" a=""><vh>About cweb mode </vh></v>
<v t="edream.110203163054.359" a=""><vh>Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees</vh></v>
<v t="edream.110203163054.813"><vh>Appendix 2 to Chapter 4: Using the @root directive, Tangling and Untangling</vh>
<v t="edream.110203163054.814"><vh>@root vs. @file trees</vh></v>
<v t="edream.110203163054.815"><vh>Sections and section definitions</vh></v>
<v t="edream.110203163054.816"><vh>Tangling @root trees with the Tangle commands</vh></v>
<v t="edream.110203163054.817"><vh>Untangling @root trees with the Untangle commands</vh></v>
<v t="edream.110203163054.384" a=""><vh>@verbose, @terse, @quiet and @silent directives control comments in @root trees</vh></v>
</v>
</v>
<v t="edream.110203163054.818"><vh>Chapter 5: Using Leo's Commands</vh>
<v t="edream.110203163054.819"><vh> The File Menu</vh>
<v t="edream.110203163054.820" a="M"><vh>Loading, Saving and Reverting Files</vh></v>
<v t="edream.110203163054.821"><vh>Communicating with external editors</vh>
<v t="edream.110203163054.356" a=""><vh>Open With command</vh>
<v t="edream.110203163054.343" a=""><vh>createOpenWithMenuFromTable</vh></v>
</v>
</v>
<v t="edream.110203163054.822"><vh>Tangling an outline: Producing Derived Files</vh></v>
<v t="edream.110203163054.681" a=""><vh>Untangling: updating an outline</vh></v>
<v t="edream.110203163054.823"><vh>Tangling and Untangling: the Interface with the IDE</vh></v>
<v t="edream.110203163054.824" a="M"><vh>Importing Files into Leo Outlines</vh></v>
<v t="edream.110203163054.825"><vh>Exporting Files from Leo Outlines</vh></v>
<v t="edream.110203163054.826"><vh>Quitting Leo</vh></v>
</v>
<v t="edream.110203163054.827"><vh> The Edit Menu</vh>
<v t="edream.110203163054.828"><vh>Undoing changes</vh></v>
<v t="edream.110203163054.829"><vh>Cutting, pasting and selecting text</vh></v>
<v t="edream.110203163054.830"><vh>Shifting body text</vh></v>
<v t="edream.110203163054.831"><vh>Creating nodes from body text</vh></v>
<v t="edream.110203163054.832"><vh>Converting leading blanks and tabs in body text</vh></v>
<v t="edream.110203163054.833"><vh>Executing Python scripts in body text</vh></v>
<v t="edream.110203163054.834"><vh>Finding and changing text</vh>
<v t="edream.110203163054.835"><vh>Batch</vh></v>
<v t="edream.110203163054.836"><vh>Ignore Case</vh></v>
<v t="edream.110203163054.837"><vh>Mark Changes</vh></v>
<v t="edream.110203163054.838"><vh>Mark Matches</vh></v>
<v t="edream.110203163054.839"><vh>Pattern Match</vh></v>
<v t="edream.110203163054.840"><vh>Reverse</vh></v>
<v t="edream.110203163054.841"><vh>Search Body Text</vh></v>
<v t="edream.110203163054.842"><vh>Search Headline Text</vh></v>
<v t="edream.110203163054.843"><vh>Suboutline Only</vh></v>
<v t="edream.110203163054.844"><vh>Whole Word</vh></v>
<v t="edream.110203163054.845"><vh>Wrap Around</vh></v>
</v>
<v t="edream.110203163054.846"><vh>Finding locations in outlines corresponding to line in derived files</vh>
<v t="edream.110203163054.353" a=""><vh>Go To Line Number command</vh></v>
</v>
<v t="edream.110203163054.847"><vh>Inserting the date and time</vh></v>
<v t="edream.110203163054.848"><vh>Reformatting paragraphs in body text</vh>
<v t="edream.110203163054.358" a=""><vh>Reformat Paragraph command</vh></v>
</v>
<v t="edream.110203163054.849"><vh>Matching brackets and parenthesis</vh></v>
<v t="edream.110203163054.850"><vh>Setting Preferences</vh>
<v t="edream.110203163054.851"><vh>PHP keywords</vh></v>
<v t="edream.110203163054.852"><vh>LaTex keywords</vh></v>
</v>
</v>
<v t="edream.110203163054.853"><vh> The Outline Menu</vh>
<v t="edream.110703093314"><vh> Checking outlines</vh></v>
<v t="edream.110203163054.854"><vh> Creating and deleting headlines</vh></v>
<v t="edream.110203163054.855"><vh> Cutting, pasting and deleting headlines</vh></v>
<v t="edream.110203163054.856"><vh> Expanding and contracting headlines</vh></v>
<v t="edream.110703093314.1"><vh> Hoisting &amp; De-hoisting headlines</vh></v>
<v t="edream.110203163054.858"><vh> Marking headlines</vh></v>
<v t="edream.110203163054.857"><vh> Moving, sorting and reorganizing headlines</vh></v>
<v t="edream.110203163054.755" a=""><vh>Cloning headlines</vh>
<v t="edream.110203163054.756"><vh>read me</vh></v>
<v t="edream.110203163054.757" a=""><vh>a</vh>
<v t="edream.110203163054.758" a=""><vh>b</vh>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
</v>
<v t="edream.110203163054.762"><vh>g</vh></v>
<v t="edream.110203163054.758" a=""><vh>b</vh>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.757" a=""><vh>a</vh>
<v t="edream.110203163054.758" a=""><vh>b</vh>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
</v>
<v t="edream.110203163054.762"><vh>g</vh></v>
<v t="edream.110203163054.758" a=""><vh>b</vh>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
<v t="edream.110203163054.759" a=""><vh>c</vh>
<v t="edream.110203163054.760"><vh>d</vh></v>
<v t="edream.110203163054.761"><vh>e</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.763"><vh>f</vh></v>
</v>
</v>
<v t="edream.110203163054.859"><vh> The Window Menu</vh>
<v t="edream.110203163054.860"><vh> Resizing panes</vh></v>
<v t="edream.110203163054.861"><vh> Cascading &amp; minimizing windows</vh></v>
<v t="edream.110203163054.862"><vh>Toggling the active pane</vh></v>
<v t="edream.110203163054.863"><vh>Toggling the orientation of the Leo window</vh></v>
<v t="edream.110203163054.864"><vh>Comparing files</vh></v>
</v>
<v t="edream.110203163054.865"><vh>The Help Menu</vh>
<v t="edream.110203163054.866"><vh>Getting Leo's version</vh></v>
<v t="edream.110203163054.867"><vh>Reading documentation</vh></v>
<v t="edream.110203163054.868"><vh>Configuring Leo</vh></v>
</v>
</v>
<v t="edream.110203163054.869"><vh>Chapter 6: Leo and Literate Programming</vh>
<v t="edream.110203163054.870"><vh>Why I like Literate Programming</vh>
<v t="edream.110203163054.871"><vh>Literate programming creates a new design dimension</vh></v>
<v t="edream.110203163054.872"><vh>Design and coding happen at the highest possible level</vh></v>
<v t="edream.110203163054.873"><vh>The visual weight of code is separate from its actual length</vh></v>
<v t="edream.110203163054.874"><vh>Sections show relations between snippets of code</vh></v>
<v t="edream.110203163054.875"><vh>Complex section names invite improvements</vh></v>
<v t="edream.110203163054.876"><vh>Sections create a place for extensive comments</vh></v>
<v t="edream.110203163054.877"><vh>Section names eliminate mundane comments</vh></v>
<v t="edream.110203163054.878"><vh>Sections create comments automatically</vh></v>
<v t="edream.110203163054.879"><vh>Literate programming clarifies the shape of functions</vh></v>
<v t="edream.110203163054.880"><vh>I spend less time formatting code</vh></v>
</v>
<v t="edream.110203163054.881"><vh>How Leo Improves Literate Programming</vh>
<v t="edream.110203163054.882"><vh>Outlines add context</vh></v>
<v t="edream.110203163054.883"><vh>Outlines provide scope for commands</vh></v>
<v t="edream.110203163054.884"><vh>Clones create different views and focus attention</vh></v>
<v t="edream.110203163054.885"><vh>Outlines increase flexibility</vh></v>
<v t="edream.110203163054.886"><vh>Outlines express hierarchy directly</vh></v>
<v t="edream.110203163054.887"><vh>Outlines create new design dimensions</vh></v>
<v t="edream.110203163054.888"><vh>Leo improves tangling and adds untangling</vh></v>
</v>
<v t="edream.110203163054.889"><vh>How Leo Changes the Notion of Literate Programming</vh></v>
</v>
<v t="edream.110203163054.890"><vh>Chapter 7: Scripting Leo with Python</vh>
<v t="edream.110203163054.891"><vh>Overview</vh></v>
<v t="edream.110203163054.892"><vh>Basic scripts</vh>
<v t="edream.110203163054.893"><vh>Getting commanders and frames</vh></v>
<v t="edream.110203163054.894"><vh>Redirecting output from scripts</vh></v>
<v t="edream.110203163054.895"><vh>Getting the headline and body text of the presently selected node</vh></v>
<v t="edream.110203163054.896"><vh>Setting the headline and body text of the presently selected node</vh></v>
<v t="edream.110203163054.897"><vh>Traversing outlines</vh></v>
<v t="edream.110203163054.898"><vh>Updating the screen</vh></v>
</v>
<v t="edream.110203163054.899"><vh>Invoking commands from scripts</vh></v>
<v t="edream.110203163054.900"><vh>Getting preferences</vh></v>
<v t="edream.110203163054.901"><vh>Setting preferences</vh></v>
<v t="edream.110203163054.902"><vh>Functions for finding and changing text from scripts</vh>
<v t="edream.110203163054.903"><vh>Example 1: the findAll function</vh></v>
<v t="edream.110203163054.904"><vh>Example 2: the reFindAll function</vh></v>
</v>
<v t="edream.110203163054.905"><vh>Summary of the vnode class</vh>
<v t="edream.110203163054.906"><vh>Getters</vh></v>
<v t="edream.110203163054.907"><vh>Setters</vh></v>
<v t="edream.110203163054.908"><vh>An example script: children(v)</vh></v>
</v>
<v t="edream.110203163054.909"><vh>Functions defined in leoGlobals.py</vh></v>
<v t="edream.110203163054.910"><vh>Appendix to Chapter 7: Scripting the Borland version of Leo</vh>
<v t="edream.110203163054.911"><vh>Installing Python</vh></v>
<v t="edream.110203163054.912"><vh>Leo's Python Window</vh></v>
<v t="edream.110203163054.913"><vh>Functions</vh>
<v t="edream.110203163054.914"><vh>topCommand</vh></v>
<v t="edream.110203163054.915"><vh>getCommands</vh></v>
<v t="edream.110203163054.916"><vh>getLeoPyWindow</vh></v>
</v>
<v t="edream.110203163054.917"><vh>The Commands class</vh>
<v t="edream.110203163054.918"><vh>Updating the screen</vh></v>
<v t="edream.110203163054.919"><vh>File menu commands</vh></v>
<v t="edream.110203163054.920"><vh>Edit menu commands</vh></v>
<v t="edream.110203163054.921"><vh>Outline menu commands</vh></v>
<v t="edream.110203163054.922"><vh>Window menu commands</vh></v>
<v t="edream.110203163054.923"><vh>Menu enablers</vh></v>
<v t="edream.110203163054.924"><vh>Commands Utilities</vh></v>
</v>
<v t="edream.110203163054.925"><vh>The LeoPyWindow class</vh></v>
<v t="edream.110203163054.926"><vh>The Preferences class</vh></v>
<v t="edream.110203163054.927"><vh>The vnode class</vh>
<v t="edream.110203163054.928"><vh>Getters</vh></v>
<v t="edream.110203163054.929"><vh>Setters</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.319" a=""><vh>Chapter 8: Customizing Leo</vh>
<v t="edream.110203163054.320" a=""><vh>Using leoConfig.leo and leoConfig.txt</vh></v>
<v t="edream.110203163054.321"><vh>Using plugins and hooks</vh>
<v t="edream.110203163054.322" a=""><vh>Overview of plugins and hooks</vh></v>
<v t="edream.110203163054.323"><vh>New plugin architecture</vh>
<v t="edream.110203163054.324"><vh>@file plugins/mod_open_with.py</vh>
<v t="edream.110203163054.325"><vh>on_idle</vh>
<v t="edream.110203163054.326"><vh>&lt;&lt; update v's body text &gt;&gt;</vh>
<v t="edream.110203163054.327"><vh>&lt;&lt; set s to the new text &gt;&gt;</vh></v>
<v t="edream.110203163054.328"><vh>&lt;&lt; set conflict flag &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.329"><vh>create_open_with_menu</vh>
<v t="edream.110203163054.330"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.172" a=""><vh>About hooks</vh></v>
<v t="edream.110203163054.331"><vh>SECURITY WARNINGS</vh>
<v t="edream.110203163054.332"><vh>The danger of trusting code in shared .leo files</vh></v>
<v t="edream.110203163054.333"><vh>NEVER use this kind of code in a hook!!</vh></v>
<v t="edream.110203163054.334"><vh>Don't use rexec !!</vh>
<v t="edream.110203163054.335"><vh>&lt;&lt; change all instances of rexec to exec in v's body &gt;&gt;</vh></v>
<v t="edream.110203163054.336"><vh>&lt;&lt; delete thisNode &gt;&gt;</vh></v>
<v t="edream.110203163054.337"><vh>&lt;&lt; clear the undo stack &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.338"><vh>Convenience routines for plugins</vh>
<v t="edream.110203163054.339"><vh>Convenience functions to enable and disable the "idle" hook</vh></v>
<v t="edream.110203163054.340"><vh>Convenience methods to create, destroy and modify menus</vh>
<v t="edream.110203163054.341"><vh>createMenuItemsFromTable</vh></v>
<v t="edream.110203163054.342"><vh>createNewMenu</vh></v>
<v t="edream.110203163054.343" a=""><vh>createOpenWithMenuFromTable</vh></v>
<v t="edream.110203163054.344"><vh>deleteMenu</vh></v>
<v t="edream.110203163054.345"><vh>deleteMenuItem</vh></v>
<v t="edream.110203163054.346"><vh>Example: how to create a menu</vh></v>
</v>
</v>
<v t="edream.110203163054.347"><vh>Translating menus into other languages</vh></v>
</v>
<v t="edream.110203163054.61" a=""><vh>Putting the Leo icon in Leo windows</vh></v>
<v t="edream.110203163054.348"><vh>Extending the format of .leo files</vh></v>
</v>
<v t="edream.110203163054.930"><vh>Chapter 9: History of Leo</vh>
<v t="edream.110203163054.931"><vh>Beginnings</vh></v>
<v t="edream.110203163054.932"><vh>Versions, and more versions</vh></v>
<v t="edream.110203163054.933"><vh>Designing @file trees</vh>
<v t="edream.110203163054.934"><vh>Deciding to do Leo2</vh></v>
<v t="edream.110203163054.935"><vh>A prototype</vh></v>
<v t="edream.110203163054.936"><vh>User interaction</vh></v>
<v t="edream.110203163054.937"><vh>The write code</vh></v>
<v t="edream.110203163054.938"><vh>The read code</vh></v>
<v t="edream.110203163054.939"><vh>The load/save code</vh></v>
<v t="edream.110203163054.940"><vh>Attributes, mirroring and dummy nodes</vh></v>
<v t="edream.110203163054.941"><vh>Clones</vh></v>
<v t="edream.110203163054.942"><vh>Error recovery, at last</vh></v>
</v>
</v>
<v t="edream.110203163054.943"><vh>Chapter 10: Theory of Operation</vh>
<v t="edream.110203163054.944"><vh>Overview</vh></v>
<v t="edream.110203163054.945"><vh>Nodes</vh></v>
<v t="edream.110203163054.946"><vh>Drawing and events</vh></v>
<v t="edream.110203163054.947"><vh>Clones</vh></v>
<v t="edream.110203163054.948"><vh>Find and change commands</vh></v>
<v t="edream.110203163054.949"><vh>Tangle and Untangle commands</vh></v>
<v t="edream.110203163054.950"><vh>Unicode theory of operation</vh></v>
<v t="edream.110203163054.951"><vh>Unlimited undo</vh></v>
<v t="edream.110203163054.364"><vh>Other representations of trees</vh>
<v t="edream.110203163054.365"><vh>Part 1</vh></v>
<v t="edream.110203163054.367"><vh>Part 2</vh></v>
</v>
<v t="edream.110203163054.100" a=""><vh>4.0 Theory of operation</vh></v>
</v>
<v t="edream.110203163054.952"><vh>Appendices</vh>
<v t="edream.110203163054.493" a=""><vh>Code hidden in leo.py</vh>
<v t="edream.110203163054.494"><vh>c2py.py</vh></v>
<v t="edream.110203163054.495"><vh>disStats.py</vh></v>
<v t="edream.110203163054.496"><vh>Tkinter utilities</vh></v>
<v t="edream.110203163054.497"><vh>Font dialog</vh></v>
<v t="edream.110203163054.498"><vh>Syntax coloring code</vh></v>
<v t="edream.110203163054.499"><vh>Tree code</vh></v>
</v>
<v t="edream.110203163054.953"><vh>Converting @root trees to @file trees</vh></v>
<v t="edream.110203163054.954"><vh>Directives</vh>
<v t="edream.110203163054.955"><vh>@c and @code</vh></v>
<v t="edream.110203163054.956"><vh>@chapter (Macintosh only)</vh></v>
<v t="edream.110203163054.957"><vh>@color</vh></v>
<v t="edream.110203163054.958"><vh>@comment</vh></v>
<v t="edream.110203163054.959"><vh>@delims (not valid in @root or @unit trees)</vh></v>
<v t="edream.110203163054.960"><vh>@doc and @(space)</vh></v>
<v t="edream.110203163054.961"><vh>@file (not valid in @root or @unit trees)</vh></v>
<v t="edream.110203163054.962"><vh>@first (not valid in @root or @unit trees)</vh></v>
<v t="edream.110203163054.963"><vh>@ignore  (not valid in @file trees)</vh></v>
<v t="edream.110203163054.964"><vh>@language</vh></v>
<v t="edream.110203163054.965"><vh>@nocolor</vh></v>
<v t="edream.110203163054.966"><vh>@others (valid only in @file trees)</vh></v>
<v t="edream.110203163054.967"><vh>@pagewidth</vh></v>
<v t="edream.110203163054.968"><vh>@path</vh></v>
<v t="edream.110203163054.969"><vh>@root  (not valid in @file trees)</vh></v>
<v t="edream.110203163054.970"><vh>@section (Macintosh only)</vh></v>
<v t="edream.110203163054.971"><vh>@silent (not valid in @file trees)</vh></v>
<v t="edream.110203163054.972"><vh>@tabwidth</vh></v>
<v t="edream.110203163054.973"><vh>@terse  (not valid in @file trees)</vh></v>
<v t="edream.110203163054.974"><vh>@unit   (not valid in @file trees)</vh></v>
<v t="edream.110203163054.975"><vh>@verbose, @terse and @silent directives</vh></v>
</v>
<v t="edream.110203163054.976"><vh>Error Messages</vh>
<v t="edream.110203163054.977"><vh>Errors while tangling</vh>
<v t="edream.110203163054.978"><vh>Can not re-open temp file</vh></v>
<v t="edream.110203163054.979"><vh>Can not rename temporary file name</vh></v>
<v t="edream.110203163054.980"><vh>@code expects the header: [text of header] to contain a section name</vh></v>
<v t="edream.110203163054.981"><vh>@directive not valid here</vh></v>
<v t="edream.110203163054.982"><vh>Halting Tangle: too many errors</vh></v>
<v t="edream.110203163054.983"><vh>Invalid recursive reference of &lt;&lt; section name &gt;&gt;</vh></v>
<v t="edream.110203163054.680" a=""><vh>Multiple parts not allowed for &lt;&lt; section name &gt;&gt;</vh></v>
<v t="edream.110203163054.984"><vh>No file written because of errors</vh></v>
<v t="edream.110203163054.985"><vh>Run on comment</vh></v>
<v t="edream.110203163054.986"><vh>Run on file name in @root directive</vh></v>
<v t="edream.110203163054.987"><vh>Run on section name</vh></v>
<v t="edream.110203163054.988"><vh>Run on string</vh></v>
<v t="edream.110203163054.989"><vh>Section definition not valid here.</vh></v>
<v t="edream.110203163054.990"><vh>Sections nested too deeply</vh></v>
<v t="edream.110203163054.991"><vh>The outline contains no roots</vh></v>
<v t="edream.110203163054.992"><vh>Undefined section:  &lt;&lt;&lt; section name &gt;&gt;&gt;</vh></v>
<v t="edream.110203163054.993"><vh>Unexpected @directive while putting code</vh></v>
<v t="edream.110203163054.994"><vh>Warning: possible duplicate definition of: &lt;&lt;&lt; section name &gt;&gt;&gt;</vh></v>
<v t="edream.110203163054.995"><vh>Warning: &lt;&lt;&lt; section name &gt;&gt;&gt; has been defined but not used</vh></v>
</v>
<v t="edream.110203163054.996"><vh>Errors while untangling</vh>
<v t="edream.110203163054.997"><vh>Incompatible definitions of &lt;&lt;&lt; section name &gt;&gt;&gt;</vh></v>
<v t="edream.110203163054.998"><vh>Missing root part</vh></v>
<v t="edream.110203163054.999"><vh>Missing root section</vh></v>
<v t="edream.110203163054.1000"><vh>Missing sentinel line for &lt;&lt;&lt; section name &gt;&gt;&gt;</vh></v>
<v t="edream.110203163054.1001"><vh>Unterminated section: &lt;&lt;&lt; section name &gt;&gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1002"><vh>Errors while reading @file nodes</vh>
<v t="edream.110203163054.1003"><vh>Minor errors</vh></v>
<v t="edream.110203163054.1004"><vh>Serious errors</vh></v>
</v>
<v t="edream.110203163054.1005"><vh>Errors while writing @file nodes</vh></v>
</v>
<v t="edream.110203163054.1006"><vh>Format of derived files (3.x)</vh>
<v t="edream.110203163054.1007"><vh>Sentinels in derived files</vh>
<v t="edream.110203163054.1008"><vh>The @delims directive </vh></v>
<v t="edream.110203163054.1009"><vh>@leo &amp; comment delimiters</vh></v>
<v t="edream.110203163054.1010"><vh>@node</vh></v>
<v t="edream.110203163054.1011"><vh>@body</vh></v>
<v t="edream.110203163054.1012"><vh>@at and @doc &amp; the trailing whitespace convention</vh></v>
<v t="edream.110203163054.1013"><vh>@others</vh></v>
<v t="edream.110203163054.1014"><vh>@@delims</vh></v>
<v t="edream.110203163054.1015"><vh>@@&lt;text&gt;</vh></v>
<v t="edream.110203163054.1016"><vh>@verbatim and @verbatimAfterRef</vh></v>
<v t="edream.110203163054.1017"><vh>@&lt;&lt;section name&gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.1018"><vh>Format of derived files (4.x)</vh></v>
<v t="edream.110203163054.1019"><vh>Future Features</vh></v>
<v t="edream.110203163054.734" a=""><vh>Known Bugs &amp; Limitations</vh></v>
<v t="edream.110203163054.1020"><vh>Reference for @file trees</vh></v>
<v t="edream.110203163054.1021"><vh>Macintosh Notes</vh>
<v t="edream.110203163054.1022"><vh>Differences Between the PC and Mac Versions</vh></v>
<v t="edream.110203163054.1023"><vh>Transferring Files</vh></v>
</v>
<v t="edream.110203163054.1024"><vh>Sherlock</vh></v>
<v t="edream.110203163054.1025"><vh>Unicode</vh>
<v t="edream.110203163054.1026"><vh>How Leo handles unicode</vh></v>
<v t="edream.110203163054.1027"><vh>Unicode settings</vh></v>
</v>
<v t="edream.110203163054.1028"><vh>XML file format</vh>
<v t="edream.110203163054.1029"><vh>&lt;?xml ... ?&gt;</vh></v>
<v t="edream.110203163054.1030"><vh>&lt;leo_file&gt; ... &lt;/leo_file&gt;</vh>
<v t="edream.110203163054.1031"><vh>&lt;leo_header ... /&gt;</vh></v>
<v t="edream.110203163054.1032"><vh>&lt;globals ... &gt; ... &lt;/globals&gt;</vh></v>
<v t="edream.110203163054.1033"><vh>&lt;preferences ... &gt; ... &lt;/preferences&gt;</vh></v>
<v t="edream.110203163054.1034"><vh>&lt;find_panel_settings ... &gt; ... &lt;/find_panel_settings&gt;</vh></v>
<v t="edream.110203163054.1035"><vh>&lt;vnodes&gt;...&lt;/vnodes&gt;</vh>
<v t="edream.110203163054.1036"><vh>&lt;v...&gt; ... &lt;/v&gt;</vh></v>
</v>
<v t="edream.110203163054.1037"><vh>&lt;tnodes&gt; ... &lt;/tnodes&gt;</vh>
<v t="edream.110203163054.1038"><vh>&lt;t...&gt; ... &lt;/t&gt;</vh></v>
</v>
<v t="edream.110203163054.1039"><vh>&lt;clone_windows&gt; ... &lt;/clone_windows&gt;</vh>
<v t="edream.110203163054.1040"><vh>&lt;clone_window ...&gt; ... &lt;/clone_window&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.1041"><vh>DTD for Leo's File Format</vh></v>
<v t="edream.110203163054.1042"><vh>An example file</vh>
<v t="edream.110203163054.1043"><vh>The file itself</vh></v>
<v t="edream.110203163054.1044"><vh>The outline  from which the example file was created</vh>
<v t="edream.110203163054.1045"><vh>Headline 1</vh>
<v t="edream.110203163054.1046"><vh>Headline 2</vh>
<v t="edream.110203163054.1047"><vh>Headline 3 ( No body text)</vh></v>
</v>
</v>
<v t="edream.110203163054.1048" a=""><vh>Headline 4 ( a clone )</vh>
<v t="edream.110203163054.1049"><vh>Headline 5</vh></v>
</v>
<v t="edream.110203163054.1048" a=""><vh>Headline 4 ( a clone )</vh>
<v t="edream.110203163054.1049"><vh>Headline 5</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="edream.110203163054.1050"><vh>FAQ</vh>
<v t="edream.110203163054.1051"><vh>Learning about Leo</vh>
<v t="edream.110203163054.1052"><vh>What's the best way to learn to use Leo?</vh></v>
<v t="edream.110203163054.1053"><vh>Where are the simple examples?</vh></v>
<v t="edream.110203163054.1054"><vh>Why should I use clones?</vh></v>
<v t="edream.110203163054.1055"><vh>Which should I use: @root trees or @file trees?</vh></v>
</v>
<v t="edream.110203163054.1056"><vh>Unicode and special characters</vh>
<v t="edream.110203163054.1057"><vh>Some characters in derived files look funny. What can I do?</vh></v>
<v t="edream.110203163054.1058"><vh>Some characters are garbled when importing files. What can I do?</vh></v>
</v>
<v t="edream.110203163054.1059"><vh>Using derived files</vh>
<v t="edream.110203163054.1060"><vh>How do I prevent Leo from inserting sentinels in derived files?</vh>
<v t="edream.110203163054.359" a=""><vh>Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees</vh></v>
</v>
<v t="edream.110203163054.1061"><vh>How do I prevent Leo from expanding sections?</vh>
<v t="edream.110203163054.359" a=""><vh>Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees</vh></v>
</v>
<v t="edream.110203163054.1062"><vh>How do I generate files after using the Import commands?</vh></v>
<v t="edream.110203163054.1063"><vh>How can I create Javascript comments?</vh></v>
<v t="edream.110203163054.1064"><vh>How can I disable PHP comments?</vh></v>
<v t="edream.110203163054.1065"><vh>How do I make derived files start with a shebang line?</vh></v>
<v t="edream.110203163054.1066"><vh>How do I use Leo to create cweb files?</vh>
<v t="edream.110203163054.355" a=""><vh>About cweb mode </vh></v>
</v>
<v t="edream.110203163054.1067"><vh>Can @file trees contain material not in the derived file?</vh></v>
</v>
<v t="edream.110203163054.1068"><vh>Customizing Leo</vh>
<v t="edream.110203163054.322" a=""><vh>Overview of plugins and hooks</vh></v>
<v t="edream.110203163054.1069"><vh>I'm having trouble getting plugins to work.  What should I do?</vh></v>
<v t="edream.110203163054.1070"><vh>How can I add support for a new language? </vh></v>
<v t="edream.110203163054.319" a=""><vh>Chapter 8: Customizing Leo</vh>
<v t="edream.110203163054.320" a=""><vh>Using leoConfig.leo and leoConfig.txt</vh></v>
<v t="edream.110203163054.321"><vh>Using plugins and hooks</vh>
<v t="edream.110203163054.322" a=""><vh>Overview of plugins and hooks</vh></v>
<v t="edream.110203163054.323"><vh>New plugin architecture</vh>
<v t="edream.110203163054.324"><vh>@file plugins/mod_open_with.py</vh>
<v t="edream.110203163054.325"><vh>on_idle</vh>
<v t="edream.110203163054.326"><vh>&lt;&lt; update v's body text &gt;&gt;</vh>
<v t="edream.110203163054.327"><vh>&lt;&lt; set s to the new text &gt;&gt;</vh></v>
<v t="edream.110203163054.328"><vh>&lt;&lt; set conflict flag &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.329"><vh>create_open_with_menu</vh>
<v t="edream.110203163054.330"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.172" a=""><vh>About hooks</vh></v>
<v t="edream.110203163054.331"><vh>SECURITY WARNINGS</vh>
<v t="edream.110203163054.332"><vh>The danger of trusting code in shared .leo files</vh></v>
<v t="edream.110203163054.333"><vh>NEVER use this kind of code in a hook!!</vh></v>
<v t="edream.110203163054.334"><vh>Don't use rexec !!</vh>
<v t="edream.110203163054.335"><vh>&lt;&lt; change all instances of rexec to exec in v's body &gt;&gt;</vh></v>
<v t="edream.110203163054.336"><vh>&lt;&lt; delete thisNode &gt;&gt;</vh></v>
<v t="edream.110203163054.337"><vh>&lt;&lt; clear the undo stack &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.338"><vh>Convenience routines for plugins</vh>
<v t="edream.110203163054.339"><vh>Convenience functions to enable and disable the "idle" hook</vh></v>
<v t="edream.110203163054.340"><vh>Convenience methods to create, destroy and modify menus</vh>
<v t="edream.110203163054.341"><vh>createMenuItemsFromTable</vh></v>
<v t="edream.110203163054.342"><vh>createNewMenu</vh></v>
<v t="edream.110203163054.343" a=""><vh>createOpenWithMenuFromTable</vh></v>
<v t="edream.110203163054.344"><vh>deleteMenu</vh></v>
<v t="edream.110203163054.345"><vh>deleteMenuItem</vh></v>
<v t="edream.110203163054.346"><vh>Example: how to create a menu</vh></v>
</v>
</v>
<v t="edream.110203163054.347"><vh>Translating menus into other languages</vh></v>
</v>
<v t="edream.110203163054.61" a=""><vh>Putting the Leo icon in Leo windows</vh></v>
<v t="edream.110203163054.348"><vh>Extending the format of .leo files</vh></v>
</v>
</v>
<v t="edream.110203163054.1071"><vh>Other topics</vh>
<v t="edream.110203163054.1072"><vh>How can I cut and paste nodes between different copies of Leo</vh></v>
<v t="edream.110203163054.1073"><vh>How can I add support in Leo for a new language?</vh>
<v t="edream.110203163054.1074"><vh>code</vh>
<v t="edream.110203163054.1075"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="edream.110203163054.1076"><vh>&lt;&lt; Create the Target Language frame &gt;&gt;</vh></v>
<v t="edream.110203163054.1077"><vh>&lt;&lt; define colorizer keywords &gt;&gt;</vh></v>
<v t="edream.110203163054.1078" a=""><vh>&lt;&lt; configure language-specific settings &gt;&gt;</vh></v>
<v t="edream.110203163054.1079" a=""><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt;</vh></v>
<v t="edream.110203163054.1080"><vh>&lt;&lt; initialize constant ivars &gt;&gt;</vh></v>
<v t="edream.110203163054.1081"><vh>set_delims_from_language</vh></v>
<v t="edream.110203163054.1082"><vh>set_language</vh></v>
<v t="edream.110203163054.1083"><vh>colorizeAnyLanguage</vh>
<v t="edream.110203163054.1084"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="edream.110203163054.1078" a=""><vh>&lt;&lt; configure language-specific settings &gt;&gt;</vh></v>
<v t="edream.110203163054.1085"><vh>Multiline State Handlers</vh>
<v t="edream.110203163054.1086"><vh>&lt;&lt; continue doc part &gt;&gt;</vh>
<v t="edream.110203163054.1087"><vh>&lt;&lt; handle cweb doc part &gt;&gt;</vh></v>
<v t="edream.110203163054.1088"><vh>&lt;&lt; handle noweb doc part &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1089"><vh>&lt;&lt; continue python triple string &gt;&gt;</vh></v>
<v t="edream.110203163054.1090"><vh>&lt;&lt; continue block comment &gt;&gt;</vh></v>
<v t="edream.110203163054.1091"><vh>&lt;&lt; continue nocolor state &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1092"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="edream.110203163054.1093"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="edream.110203163054.1094"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="edream.110203163054.1095"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="edream.110203163054.1096"><vh>&lt;&lt; handle possible section ref or def &gt;&gt;</vh>
<v t="edream.110203163054.1097"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1098"><vh>&lt;&lt; handle possible @keyword &gt;&gt;</vh>
<v t="edream.110203163054.1099"><vh>&lt;&lt; Handle all cweb control codes &gt;&gt;</vh></v>
<v t="edream.110203163054.1100"><vh>&lt;&lt; Handle non-cweb @keywords &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1101"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh></v>
<v t="edream.110203163054.1102"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="edream.110203163054.1103"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="edream.110203163054.1104"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1105"><vh>getPrefs</vh>
<v t="edream.110203163054.1079" a=""><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.1106"><vh>@root tcl/tk test</vh>
<v t="edream.110203163054.1107"><vh>&lt;&lt; stuff &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.1108"><vh>How can I create a template .leo file?</vh></v>
</v>
</v>
<v t="edream.110203163054.1109"><vh>Glossary</vh>
<v t="edream.110203163054.1110"><vh>@file node, @others node, @root node, etc.</vh></v>
<v t="edream.110203163054.1111"><vh>@file tree, @others tree, @root tree, etc.</vh></v>
<v t="edream.110203163054.1112"><vh>Body pane</vh></v>
<v t="edream.110203163054.1113"><vh>Body text</vh></v>
<v t="edream.110203163054.1114"><vh>Body text box</vh></v>
<v t="edream.110203163054.1115"><vh>Child</vh></v>
<v t="edream.110203163054.1116"><vh>Chunk</vh></v>
<v t="edream.110203163054.1117"><vh>Clone</vh></v>
<v t="edream.110203163054.1118"><vh>Clone Arrow</vh></v>
<v t="edream.110203163054.1119"><vh>Code section</vh></v>
<v t="edream.110203163054.1120"><vh>CWEB</vh></v>
<v t="edream.110203163054.1121"><vh>Demote</vh></v>
<v t="edream.110203163054.1122"><vh>Derived file</vh></v>
<v t="edream.110203163054.1123"><vh>Descendent</vh></v>
<v t="edream.110203163054.1124"><vh>Directive</vh></v>
<v t="edream.110203163054.1125"><vh>Doc section</vh></v>
<v t="edream.110203163054.1126"><vh>Escape convention</vh></v>
<v t="edream.110203163054.1127"><vh>Grandchild</vh></v>
<v t="edream.110203163054.1128"><vh>Headline</vh></v>
<v t="edream.110203163054.1129"><vh>Leo, Leo1 and Leo2</vh></v>
<v t="edream.110203163054.1130"><vh>Literate programming</vh></v>
<v t="edream.110203163054.1131"><vh>Marking</vh></v>
<v t="edream.110203163054.1132"><vh>Named nodes</vh></v>
<v t="edream.110203163054.1133"><vh>Node</vh></v>
<v t="edream.110203163054.1134"><vh>noweb</vh></v>
<v t="edream.110203163054.1135"><vh>Offspring</vh></v>
<v t="edream.110203163054.1136"><vh>Organizing node</vh></v>
<v t="edream.110203163054.1137"><vh>Orphan node</vh></v>
<v t="edream.110203163054.1138"><vh>Outline</vh></v>
<v t="edream.110203163054.1139"><vh>Outline pane</vh></v>
<v t="edream.110203163054.1140"><vh>Parent</vh></v>
<v t="edream.110203163054.1141"><vh>Part</vh></v>
<v t="edream.110203163054.1142"><vh>pdf file</vh></v>
<v t="edream.110203163054.1143"><vh>Promote</vh></v>
<v t="edream.110203163054.1144"><vh>Root</vh></v>
<v t="edream.110203163054.1145"><vh>Scope</vh></v>
<v t="edream.110203163054.1146"><vh>Section</vh></v>
<v t="edream.110203163054.1147"><vh>Section name</vh></v>
<v t="edream.110203163054.1148"><vh>Section reference</vh></v>
<v t="edream.110203163054.1149"><vh>Sentinels, sentinel lines</vh></v>
<v t="edream.110203163054.1150"><vh>Sibling</vh></v>
<v t="edream.110203163054.1151"><vh>Status Icon</vh></v>
<v t="edream.110203163054.1152"><vh>Tangling</vh></v>
<v t="edream.110203163054.1153"><vh>Target language</vh></v>
<v t="edream.110203163054.1154"><vh>Tree</vh></v>
<v t="edream.110203163054.1155"><vh>Unnamed node</vh></v>
<v t="edream.110203163054.1156"><vh>Untangling</vh></v>
<v t="edream.110203163054.1157"><vh>Weaving</vh></v>
</v>
<v t="edream.110203163054.1158"><vh>Sample Code</vh>
<v t="edream.110203163054.1159"><vh>Hello World using @root</vh>
<v t="edream.110203163054.1160"><vh>&lt;&lt; includes &gt;&gt;</vh></v>
<v t="edream.110203163054.1161"><vh>&lt;&lt; methods &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1162"><vh>Hello World using @file</vh>
<v t="edream.110203163054.1163"><vh>@file sampleHello.c</vh>
<v t="edream.110203163054.1164"><vh>&lt;&lt; includes &gt;&gt;</vh></v>
<v t="edream.110203163054.1165"><vh>main</vh></v>
</v>
</v>
<v t="edream.110203163054.1166"><vh>Examples of using @root trees</vh>
<v t="edream.110203163054.1167"><vh>Nodes</vh>
<v t="edream.110203163054.1168"><vh>tnode</vh>
<v t="edream.110203163054.1169"><vh>tnode.h</vh>
<v t="edream.110203163054.1170"><vh>&lt;&lt; tnode data members &gt;&gt;</vh></v>
<v t="edream.110203163054.1171"><vh>&lt;&lt; tnode constructors &amp; destructors &gt;&gt;</vh></v>
<v t="edream.110203163054.1172"><vh>&lt;&lt; tnode debugging &gt;&gt;</vh></v>
<v t="edream.110203163054.1173"><vh>&lt;&lt; tnode getters &gt;&gt;</vh></v>
<v t="edream.110203163054.1174"><vh>&lt;&lt; tnode setters &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1175"><vh>tnode.cpp</vh>
<v t="edream.110203163054.1176"><vh>&lt;&lt; tnode includes &gt;&gt;</vh></v>
<v t="edream.110203163054.1177"><vh>&lt;&lt; tnode abbreviations &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1178"><vh>Birth &amp; Death</vh></v>
<v t="edream.110203163054.1179"><vh>Debugging</vh>
<v t="edream.110203163054.1180"><vh>edump</vh></v>
</v>
<v t="edream.110203163054.1181"><vh>Getters</vh>
<v t="edream.110203163054.1182"><vh>Getting body text and selection</vh>
<v t="edream.110203163054.1183"><vh>bodyRTF</vh></v>
<v t="edream.110203163054.1184"><vh>bodyCString</vh></v>
<v t="edream.110203163054.1185"><vh>bodyCStringLength</vh></v>
<v t="edream.110203163054.1186"><vh>bodyString (tnode)</vh></v>
<v t="edream.110203163054.1187"><vh>loadBodyPaneFromTnode</vh></v>
<v t="edream.110203163054.1188"><vh>selectionLength</vh></v>
<v t="edream.110203163054.1189"><vh>selectionStart</vh></v>
</v>
<v t="edream.110203163054.1190"><vh>Status bits</vh>
<v t="edream.110203163054.1191"><vh>isDirty</vh></v>
<v t="edream.110203163054.1192"><vh>isRichTextBit</vh></v>
<v t="edream.110203163054.1193"><vh>isVisited</vh></v>
</v>
<v t="edream.110203163054.1194"><vh>cloneIndex</vh></v>
<v t="edream.110203163054.1195"><vh>fileIndex</vh></v>
<v t="edream.110203163054.1196"><vh>hasBody</vh></v>
<v t="edream.110203163054.1197"><vh>joinHead</vh></v>
</v>
<v t="edream.110203163054.1198"><vh>Setters</vh>
<v t="edream.110203163054.1199"><vh>Setting body text</vh>
<v t="edream.110203163054.1200"><vh>saveBodyPaneToTnode</vh></v>
<v t="edream.110203163054.1201"><vh>setTnodeRTF</vh></v>
<v t="edream.110203163054.1202"><vh>setTnodeText</vh></v>
<v t="edream.110203163054.1203"><vh>setSelection </vh></v>
</v>
<v t="edream.110203163054.1204"><vh>Status bits</vh>
<v t="edream.110203163054.1205"><vh>clearDirty</vh></v>
<v t="edream.110203163054.1206"><vh>clearRichTextBit</vh></v>
<v t="edream.110203163054.1207"><vh>clearVisited</vh></v>
<v t="edream.110203163054.1208"><vh>setDirty</vh></v>
<v t="edream.110203163054.1209"><vh>setRichTextBit</vh></v>
<v t="edream.110203163054.1210"><vh>setVisited</vh></v>
</v>
<v t="edream.110203163054.1211"><vh>setCloneIndex</vh></v>
<v t="edream.110203163054.1212"><vh>setFileIndex</vh></v>
<v t="edream.110203163054.1213"><vh>setJoinHead</vh></v>
</v>
</v>
<v t="edream.110203163054.1214"><vh>vnode</vh>
<v t="edream.110203163054.1215"><vh>vnode.h</vh>
<v t="edream.110203163054.1216"><vh>&lt;&lt; dvnode data members &gt;&gt;</vh></v>
<v t="edream.110203163054.1217"><vh>&lt;&lt; vnode access methods &gt;&gt;</vh></v>
<v t="edream.110203163054.1218"><vh>&lt;&lt; vnode comparisons &gt;&gt;</vh></v>
<v t="edream.110203163054.1219"><vh>&lt;&lt; vnode constructors &amp; destructors &gt;&gt;</vh></v>
<v t="edream.110203163054.1220"><vh>&lt;&lt; vnode data members &gt;&gt;</vh></v>
<v t="edream.110203163054.1221"><vh>&lt;&lt; vnode debugging &gt;&gt;</vh></v>
<v t="edream.110203163054.1222"><vh>&lt;&lt; vnode file methods &gt;&gt;</vh></v>
<v t="edream.110203163054.1223"><vh>&lt;&lt; vnode getters &gt;&gt;</vh></v>
<v t="edream.110203163054.1224"><vh>&lt;&lt; vnode private methods &gt;&gt;</vh></v>
<v t="edream.110203163054.1225"><vh>&lt;&lt; vnode setters &gt;&gt;</vh></v>
<v t="edream.110203163054.1226"><vh>&lt;&lt; vnode tree methods &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1227"><vh>vnode.cpp</vh>
<v t="edream.110203163054.1228"><vh>&lt;&lt; vnode includes &gt;&gt;</vh></v>
<v t="edream.110203163054.1229"><vh>&lt;&lt; vnode abbreviations &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1230"><vh>Birth &amp; Death</vh></v>
<v t="edream.110203163054.1231"><vh>Comparisons</vh>
<v t="edream.110203163054.1232"><vh>atFileNodeName</vh></v>
<v t="edream.110203163054.1233"><vh>isAtFileNode</vh></v>
<v t="edream.110203163054.1234"><vh>isAtIgnoreNode</vh></v>
<v t="edream.110203163054.1235"><vh>isAtOthersNode</vh></v>
<v t="edream.110203163054.1236"><vh>matchHeadline</vh></v>
</v>
<v t="edream.110203163054.1237"><vh>Dumping</vh>
<v t="edream.110203163054.1238"><vh>edump</vh></v>
<v t="edream.110203163054.1239"><vh>description</vh></v>
</v>
<v t="edream.110203163054.1240"><vh>File Conversion</vh>
<v t="edream.110203163054.1241"><vh>convertTreeToString</vh></v>
<v t="edream.110203163054.1242"><vh>moreHead</vh></v>
<v t="edream.110203163054.1243"><vh>moreBody</vh></v>
</v>
<v t="edream.110203163054.1244"><vh>Getters</vh>
<v t="edream.110203163054.1245"><vh>Children</vh>
<v t="edream.110203163054.1246"><vh>childIndex</vh></v>
<v t="edream.110203163054.1247"><vh>firstChild</vh></v>
<v t="edream.110203163054.1248"><vh>hasChildren</vh></v>
<v t="edream.110203163054.1249"><vh>lastChild</vh></v>
<v t="edream.110203163054.1250"><vh>nthChild</vh></v>
<v t="edream.110203163054.1251"><vh>numberOfChildren</vh></v>
</v>
<v t="edream.110203163054.1252"><vh>Cross-file clones</vh>
<v t="edream.110203163054.1253"><vh>xCloneName</vh></v>
<v t="edream.110203163054.1254"><vh>xCloneIndex</vh></v>
</v>
<v t="edream.110203163054.1255"><vh>Structure Links</vh>
<v t="edream.110203163054.1256"><vh>back</vh></v>
<v t="edream.110203163054.1257"><vh>lastNode</vh></v>
<v t="edream.110203163054.1258"><vh>level</vh></v>
<v t="edream.110203163054.1259"><vh>next</vh></v>
<v t="edream.110203163054.1260"><vh>parent</vh></v>
<v t="edream.110203163054.1261"><vh>nodeAfterTree</vh></v>
<v t="edream.110203163054.1262"><vh>threadBack</vh></v>
<v t="edream.110203163054.1263"><vh>threadNext</vh></v>
<v t="edream.110203163054.1264"><vh>visBack</vh></v>
<v t="edream.110203163054.1265"><vh>visNext</vh></v>
</v>
<v t="edream.110203163054.1266"><vh>Head &amp; Body Strings</vh>
<v t="edream.110203163054.1267"><vh>bodyCString</vh></v>
<v t="edream.110203163054.1268"><vh>bodyCStringLength</vh></v>
<v t="edream.110203163054.1269"><vh>bodyRTF</vh></v>
<v t="edream.110203163054.1270"><vh>bodyString</vh></v>
<v t="edream.110203163054.1271"><vh>headCString</vh></v>
<v t="edream.110203163054.1272"><vh>headCStringLength</vh></v>
<v t="edream.110203163054.1273"><vh>headString</vh></v>
</v>
<v t="edream.110203163054.1274"><vh>Status Bits</vh>
<v t="edream.110203163054.1275"><vh>isCloned</vh></v>
<v t="edream.110203163054.1276"><vh>isDirty</vh></v>
<v t="edream.110203163054.1277"><vh>isDummy</vh></v>
<v t="edream.110203163054.1278"><vh>isExpanded</vh></v>
<v t="edream.110203163054.1279"><vh>isExpandedBitSet</vh></v>
<v t="edream.110203163054.1280"><vh>isMarked</vh></v>
<v t="edream.110203163054.1281"><vh>isOrphan</vh></v>
<v t="edream.110203163054.1282"><vh>isSelectedBitSet</vh></v>
<v t="edream.110203163054.1283"><vh>isTopBitSet</vh></v>
<v t="edream.110203163054.1284"><vh>isVisible</vh></v>
<v t="edream.110203163054.1285"><vh>isVisited</vh></v>
<v t="edream.110203163054.1286"><vh>status</vh></v>
</v>
<v t="edream.110203163054.1287"><vh>VCL classes (vnode)</vh>
<v t="edream.110203163054.1288"><vh>findRoot</vh></v>
<v t="edream.110203163054.1289"><vh>commands</vh></v>
<v t="edream.110203163054.1290"><vh>leoForm</vh></v>
<v t="edream.110203163054.1291"><vh>treeNode</vh></v>
<v t="edream.110203163054.1292"><vh>treeNodes</vh></v>
<v t="edream.110203163054.1293"><vh>treeView</vh></v>
</v>
<v t="edream.110203163054.1294"><vh>currentVnode (vnode)</vh></v>
<v t="edream.110203163054.1295"><vh>iconVal</vh></v>
<v t="edream.110203163054.1296"><vh>isAncestorOf </vh></v>
<v t="edream.110203163054.1297"><vh>isRoot</vh></v>
<v t="edream.110203163054.1298"><vh>joinList</vh></v>
<v t="edream.110203163054.1299"><vh>selectionStart</vh></v>
<v t="edream.110203163054.1300"><vh>selectionLength</vh></v>
<v t="edream.110203163054.1301"><vh>t</vh></v>
</v>
<v t="edream.110203163054.1302"><vh>Setters</vh>
<v t="edream.110203163054.1303"><vh>cross-file clones</vh>
<v t="edream.110203163054.1304"><vh>setXCloneIndex</vh></v>
<v t="edream.110203163054.1305"><vh>setXCloneName</vh></v>
</v>
<v t="edream.110203163054.1306"><vh>headline and body text</vh>
<v t="edream.110203163054.1307"><vh>appendStringToBody</vh></v>
<v t="edream.110203163054.1308"><vh>setBodyStringOrPane (new for SWIG)</vh></v>
<v t="edream.110203163054.1309"><vh>setHeadString &amp; initHeadString</vh></v>
<v t="edream.110203163054.1310"><vh>setHeadStringOrHeadline (new for SWIG)</vh></v>
<v t="edream.110203163054.1311"><vh>trimTrailingLines</vh></v>
</v>
<v t="edream.110203163054.1312"><vh>icons</vh>
<v t="edream.110203163054.1313"><vh>computeIcon</vh></v>
<v t="edream.110203163054.1314"><vh>setIcon</vh></v>
<v t="edream.110203163054.1315"><vh>setIconVal</vh></v>
<v t="edream.110203163054.1316"><vh>setIconWithVal</vh></v>
</v>
<v t="edream.110203163054.1317"><vh>setJoinList</vh></v>
<v t="edream.110203163054.1318"><vh>setSelection</vh></v>
<v t="edream.110203163054.1319"><vh>setT</vh></v>
<v t="edream.110203163054.1320"><vh>setTreeNode</vh></v>
<v t="edream.110203163054.1321"><vh>status bits</vh>
<v t="edream.110203163054.1322"><vh>clearClonedBit</vh></v>
<v t="edream.110203163054.1323"><vh>clearDirty &amp; clearDirtyJoined</vh></v>
<v t="edream.110203163054.1324"><vh>clearDummy</vh></v>
<v t="edream.110203163054.1325"><vh>clearMarked</vh></v>
<v t="edream.110203163054.1326"><vh>clearOrphan</vh></v>
<v t="edream.110203163054.1327"><vh>clearVisited</vh></v>
<v t="edream.110203163054.1328"><vh>initClonedBit</vh></v>
<v t="edream.110203163054.1329"><vh>initDirtyBit</vh></v>
<v t="edream.110203163054.1330"><vh>initExpandedBit (new)</vh></v>
<v t="edream.110203163054.1331"><vh>initMarkedBit</vh></v>
<v t="edream.110203163054.1332"><vh>initSelectedBit (new)</vh></v>
<v t="edream.110203163054.1333"><vh>initTopBit (new)</vh></v>
<v t="edream.110203163054.1334"><vh>initStatus</vh></v>
<v t="edream.110203163054.1335"><vh>setAncestorAtFileNodeDirty</vh></v>
<v t="edream.110203163054.1336"><vh>setClonedBit</vh></v>
<v t="edream.110203163054.1337"><vh>setDirty &amp; setDirtyJoined</vh></v>
<v t="edream.110203163054.1338"><vh>setDummy</vh></v>
<v t="edream.110203163054.1339"><vh>setOrphan</vh></v>
<v t="edream.110203163054.1340"><vh>setVisited</vh></v>
<v t="edream.110203163054.1341"><vh>setMarked</vh></v>
</v>
</v>
<v t="edream.110203163054.1342"><vh>Moving, Inserting, Deleting, Cloning</vh>
<v t="edream.110203163054.1343"><vh>Entry Points (vnode)</vh>
<v t="edream.110203163054.1344"><vh>clone (vnode)</vh></v>
<v t="edream.110203163054.1345"><vh>createDependents</vh></v>
<v t="edream.110203163054.1346"><vh>doDelete</vh>
<v t="edream.110203163054.1347"><vh>&lt;&lt; dump the dv list &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1348"><vh>freeDVNodes</vh></v>
<v t="edream.110203163054.1349"><vh>insertAfter</vh></v>
<v t="edream.110203163054.1350"><vh>insertAsLastChild</vh></v>
<v t="edream.110203163054.1351"><vh>insertAsNthChild</vh></v>
<v t="edream.110203163054.1352"><vh>moveAfter</vh></v>
<v t="edream.110203163054.1353"><vh>moveToRoot</vh></v>
<v t="edream.110203163054.1354"><vh>moveToNthChildOf</vh></v>
<v t="edream.110203163054.1355"><vh>restoreOutlineFromDVnodes</vh>
<v t="edream.110203163054.1356"><vh>&lt;&lt; Insert v into the outline &gt;&gt;</vh></v>
<v t="edream.110203163054.1357"><vh>&lt;&lt; Set back and parent fields for the new vnode &gt;&gt;</vh></v>
<v t="edream.110203163054.1358"><vh>&lt;&lt; set icons for all vnodes of the result tree &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.1359"><vh>cloneTree</vh></v>
<v t="edream.110203163054.1360"><vh>copyCloneBitsTo</vh></v>
<v t="edream.110203163054.1361"><vh>copyTree</vh></v>
<v t="edream.110203163054.1362"><vh>destroyDependents</vh></v>
<v t="edream.110203163054.1363"><vh>destroyTree</vh></v>
<v t="edream.110203163054.1364"><vh>invalidOutline</vh></v>
<v t="edream.110203163054.1365"><vh>isJoinedTo</vh></v>
<v t="edream.110203163054.1366"><vh>isOnJoinListOf</vh></v>
<v t="edream.110203163054.1367"><vh>joinNodeTo</vh></v>
<v t="edream.110203163054.1368"><vh>joinTreeTo</vh></v>
<v t="edream.110203163054.1369"><vh>saveOutlineWithLevel</vh>
<v t="edream.110203163054.1370"><vh>&lt;&lt; Set the data fields of dv &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1371"><vh>shouldBeClone</vh></v>
<v t="edream.110203163054.1372"><vh>unjoinNode</vh>
<v t="edream.110203163054.1373"><vh>&lt;&lt; Set prev to the node that points to this &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1374"><vh>unjoinTree</vh></v>
<v t="edream.110203163054.1375"><vh>validateOutlineWithParent</vh>
<v t="edream.110203163054.1376"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="edream.110203163054.1377"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="edream.110203163054.1378"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="edream.110203163054.1379"><vh>Examples of using @file trees</vh>
<v t="edream.110203163054.1380"><vh>atFile</vh>
<v t="edream.110203163054.1381"><vh>@file sampleAtFile.h</vh>
<v t="edream.110203163054.1382"><vh>&lt;&lt; declare public utility functions &gt;&gt;</vh></v>
<v t="edream.110203163054.1383"><vh>&lt;&lt; private atFile data &gt;&gt;</vh></v>
<v t="edream.110203163054.1384"><vh>&lt;&lt; private read methods &gt;&gt;</vh></v>
<v t="edream.110203163054.1385"><vh>&lt;&lt; private sentinel methods &gt;&gt;</vh></v>
<v t="edream.110203163054.1386"><vh>&lt;&lt; private utilities &gt;&gt;</vh></v>
<v t="edream.110203163054.1387"><vh>&lt;&lt; private write methods &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1388"><vh>@file sampleAtFile.cpp</vh>
<v t="edream.110203163054.1389"><vh>Declarations</vh>
<v t="edream.110203163054.1390"><vh>&lt;&lt; atFile includes &gt;&gt;</vh></v>
<v t="edream.110203163054.1391"><vh>&lt;&lt; atFile abbreviations &gt;&gt;</vh></v>
<v t="edream.110203163054.1392"><vh>&lt;&lt; atFile constants &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1393"><vh>Commands methods</vh>
<v t="edream.110203163054.1394"><vh>Commands::readAtFile</vh></v>
<v t="edream.110203163054.1395"><vh>Commands::writeAtFile</vh></v>
</v>
<v t="edream.110203163054.1396"><vh>atFile ctor</vh></v>
<v t="edream.110203163054.1397"><vh>Reading</vh>
<v t="edream.110203163054.1398"><vh>createNthChild</vh></v>
<v t="edream.110203163054.1399"><vh>joinTrees</vh></v>
<v t="edream.110203163054.1400"><vh>read</vh>
<v t="edream.110203163054.1401"><vh>&lt;&lt; Declare read vars &gt;&gt;</vh></v>
<v t="edream.110203163054.1402"><vh>&lt;&lt; read the entire file into fileData &gt;&gt;</vh></v>
<v t="edream.110203163054.1403"><vh>&lt;&lt; Scan the file buffer  &gt;&gt;</vh></v>
<v t="edream.110203163054.1404"><vh>&lt;&lt; Issue structure error message &gt;&gt;</vh></v>
<v t="edream.110203163054.1405"><vh>&lt;&lt; Delete root's tree and body text &gt;&gt;</vh></v>
<v t="edream.110203163054.1406"><vh>&lt;&lt; Handle clone bits &gt;&gt;</vh></v>
<v t="edream.110203163054.1407"><vh>&lt;&lt; Join cloned trees &gt;&gt;</vh></v>
<v t="edream.110203163054.1408"><vh>&lt;&lt; Handle all status bits &gt;&gt;</vh></v>
<v t="edream.110203163054.1409"><vh>&lt;&lt; Issue serious error message &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1410"><vh>readAll</vh></v>
<v t="edream.110203163054.1411"><vh>scanDoc</vh>
<v t="edream.110203163054.1412"><vh>&lt;&lt; Skip the opening sentinel &gt;&gt;</vh></v>
<v t="edream.110203163054.1413"><vh>&lt;&lt; Skip an opening block delim &gt;&gt;</vh></v>
<v t="edream.110203163054.1414"><vh>&lt;&lt; Append the next comment line to v's body &gt;&gt;</vh></v>
<v t="edream.110203163054.1415"><vh>&lt;&lt; Skip the closing sentinel &gt;&gt;</vh></v>
<v t="edream.110203163054.1416"><vh>&lt;&lt; Remove a closing block delim from v's body &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1417"><vh>scanHeader</vh></v>
<v t="edream.110203163054.1418"><vh>scanText</vh>
<v t="edream.110203163054.1419"><vh>&lt;&lt; Set lineIndent and linep &gt;&gt;</vh></v>
<v t="edream.110203163054.1420"><vh>&lt;&lt; remove indent and append line &gt;&gt;</vh></v>
<v t="edream.110203163054.1421"><vh>&lt;&lt; handle an ending sentinel &gt;&gt;</vh></v>
<v t="edream.110203163054.1422"><vh>&lt;&lt; handle unexpected end of text &gt;&gt;</vh></v>
<v t="edream.110203163054.1423"><vh>start sentinels</vh>
<v t="edream.110203163054.1424"><vh>&lt;&lt; scan @+at &gt;&gt;</vh></v>
<v t="edream.110203163054.1425"><vh>&lt;&lt; scan @+body &gt;&gt;</vh></v>
<v t="edream.110203163054.1426"><vh>&lt;&lt; scan @+doc &gt;&gt;</vh></v>
<v t="edream.110203163054.1427"><vh>&lt;&lt; scan @+leo &gt;&gt;</vh></v>
<v t="edream.110203163054.1428"><vh>&lt;&lt; scan @+node &gt;&gt;</vh>
<v t="edream.110203163054.1429"><vh>&lt;&lt; skip the node sentinel, setting headline, ref and n &gt;&gt;</vh>
<v t="edream.110203163054.1430"><vh>&lt;&lt; Set status bits in dummy vnode &gt;&gt;</vh>
<v t="edream.110203163054.1431"><vh>&lt;&lt; set index from the C=nnn, field &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.1432"><vh>&lt;&lt; copy new_ms to child's body &gt;&gt;</vh></v>
<v t="edream.110203163054.1433"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1434"><vh>&lt;&lt; scan @+others &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1435"><vh>unpaired sentinels</vh>
<v t="edream.110203163054.1436"><vh>&lt;&lt; scan @ref &gt;&gt;</vh></v>
<v t="edream.110203163054.1437"><vh>&lt;&lt; scan @verbatim &gt;&gt;</vh></v>
<v t="edream.110203163054.1438"><vh>&lt;&lt; scan @@ &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1439"><vh>&lt;&lt; warn about unknown sentinel &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.1440"><vh>Writing</vh>
<v t="edream.110203163054.1441"><vh>putBody</vh></v>
<v t="edream.110203163054.1442"><vh>putBodyPart (removes trailing lines)</vh>
<v t="edream.110203163054.1443"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1444"><vh>putCodePart &amp; allies</vh>
<v t="edream.110203163054.1445"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="edream.110203163054.1446"><vh>&lt;&lt; compute delta, the width of the whitespace &gt;&gt;</vh></v>
<v t="edream.110203163054.1447"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="edream.110203163054.1448"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1449"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="edream.110203163054.1450"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1451"><vh>findReference</vh></v>
<v t="edream.110203163054.1452"><vh>inAtOthers</vh></v>
<v t="edream.110203163054.1453"><vh>putAtOthers</vh></v>
<v t="edream.110203163054.1454"><vh>putAtOthersChild</vh></v>
</v>
<v t="edream.110203163054.1455"><vh>putDirective</vh></v>
<v t="edream.110203163054.1456"><vh>putDoc</vh>
<v t="edream.110203163054.1457"><vh>&lt;&lt; skip the @&lt;space&gt; or @doc &gt;&gt;</vh></v>
<v t="edream.110203163054.1458"><vh>&lt;&lt; set limit to the end of the doc part &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1459"><vh>putDocPart</vh>
<v t="edream.110203163054.1460"><vh>&lt;&lt; copy words, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1461"><vh>write</vh>
<v t="edream.110203163054.1462"><vh>&lt;&lt; Open files.  Set orphan flag and return on errors &gt;&gt;</vh>
<v t="edream.110203163054.1463"><vh>&lt;&lt; setOrphan and return if mTargetFileName is bad &gt;&gt;</vh></v>
<v t="edream.110203163054.1464"><vh>&lt;&lt; Open a temp file and set mOutputFileName &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1465"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="edream.110203163054.1466"><vh>&lt;&lt; Issue final write error message &gt;&gt;</vh></v>
<v t="edream.110203163054.1467"><vh>&lt;&lt; Replace the target with the temp file if different &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1468"><vh>writeAll</vh>
<v t="edream.110203163054.1469"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1470"><vh>Output</vh>
<v t="edream.110203163054.1471"><vh>putBlanks</vh></v>
<v t="edream.110203163054.1472"><vh>putChar</vh></v>
<v t="edream.110203163054.1473"><vh>putIndent</vh></v>
<v t="edream.110203163054.1474"><vh>putInt</vh></v>
<v t="edream.110203163054.1475"><vh>putString</vh></v>
<v t="edream.110203163054.1476"><vh>putTabs</vh></v>
</v>
</v>
<v t="edream.110203163054.1477"><vh>Sentinels</vh>
<v t="edream.110203163054.1478"><vh>nodeSentinelText</vh>
<v t="edream.110203163054.1479"><vh>&lt;&lt; append the status-bit characters to s &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1480"><vh>putCloseNodeSentinel</vh></v>
<v t="edream.110203163054.1481"><vh>putCloseSentinels</vh></v>
<v t="edream.110203163054.1482"><vh>putOpenLeoSentinel</vh></v>
<v t="edream.110203163054.1483"><vh>putOpenNodeSentinel</vh></v>
<v t="edream.110203163054.1484"><vh>putOpenSentinels</vh></v>
<v t="edream.110203163054.1485"><vh>putSentinel</vh></v>
<v t="edream.110203163054.1486"><vh>sentinelKind</vh></v>
<v t="edream.110203163054.1487"><vh>sentinelName</vh></v>
<v t="edream.110203163054.1488"><vh>skipSentinelStart</vh></v>
</v>
<v t="edream.110203163054.1489"><vh>Utility functions</vh>
<v t="edream.110203163054.1490"><vh>compareFiles</vh></v>
<v t="edream.110203163054.1491"><vh>directiveKind</vh></v>
<v t="edream.110203163054.1492"><vh>isSectionName</vh></v>
<v t="edream.110203163054.1493"><vh>setAncestorAtFileNodeDirty</vh></v>
</v>
<v t="edream.110203163054.1494"><vh>Utilites</vh>
<v t="edream.110203163054.1495"><vh>appendToBody</vh></v>
<v t="edream.110203163054.1496"><vh>atFile::scanAllDirectives</vh>
<v t="edream.110203163054.1497"><vh>&lt;&lt; Set global arguments to default values &gt;&gt;</vh></v>
<v t="edream.110203163054.1498"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="edream.110203163054.1499"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="edream.110203163054.1500"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="edream.110203163054.1501"><vh>&lt;&lt; Remove leading and trailing delims if they exist &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1502"><vh>&lt;&lt; Test for @pagewidth and @tabwidth &gt;&gt;</vh></v>
<v t="edream.110203163054.1503"><vh>&lt;&lt; Set current directory if possible &gt;&gt;</vh></v>
<v t="edream.110203163054.1504"><vh>&lt;&lt; Set comment Strings from global vars &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1505"><vh>error</vh></v>
<v t="edream.110203163054.1506"><vh>skipIndent</vh></v>
<v t="edream.110203163054.1507"><vh>updateCloneIndices</vh></v>
<v t="edream.110203163054.1508"><vh>writeError</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.1509"><vh>FileCommands</vh>
<v t="edream.110203163054.1510"><vh>@file sampleFileCommands.cpp</vh>
<v t="edream.110203163054.1511"><vh>Declaratons</vh>
<v t="edream.110203163054.1512"><vh>&lt;&lt; File commands includes &gt;&gt;</vh></v>
<v t="edream.110203163054.1513"><vh>&lt;&lt; Declare File commands private functions &gt;&gt;</vh></v>
<v t="edream.110203163054.1514"><vh>&lt;&lt; Declare the EBadLeoFile class &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1515"><vh>Tag List routines</vh>
<v t="edream.110203163054.1516"><vh>deleteTagList</vh></v>
<v t="edream.110203163054.1517"><vh>getVtag</vh></v>
<v t="edream.110203163054.1518"><vh>newVtag</vh></v>
</v>
<v t="edream.110203163054.1519"><vh>Export</vh>
<v t="edream.110203163054.1520"><vh>exportMoreText</vh></v>
<v t="edream.110203163054.1521"><vh>flattenOutline</vh></v>
<v t="edream.110203163054.1522"><vh>flattenOutlineWithFilename</vh></v>
<v t="edream.110203163054.1523"><vh>outlineToNoweb</vh></v>
<v t="edream.110203163054.1524"><vh>convertToNoweb</vh></v>
<v t="edream.110203163054.1525"><vh>convertCodePartToNoweb</vh>
<v t="edream.110203163054.1526"><vh>&lt;&lt; Output the section reference &gt;&gt;</vh>
<v t="edream.110203163054.1527"><vh>&lt;&lt; Set name to the file name p2..p &gt;&gt;</vh></v>
<v t="edream.110203163054.1528"><vh>&lt;&lt; point p1 and p2 at section name in v's headline &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.1529"><vh>convertDocPartToNoweb</vh></v>
<v t="edream.110203163054.1530"><vh>copyPart</vh>
<v t="edream.110203163054.1531"><vh>&lt;&lt; return p if this is a section definition &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.1532"><vh>Import</vh>
<v t="edream.110203163054.1533"><vh>convertMoreStringsToOutlineAfter</vh>
<v t="edream.110203163054.1534"><vh>&lt;&lt; Declare the vars for convertMoreStringsToOutlineAfter &gt;&gt;</vh></v>
<v t="edream.110203163054.1535"><vh>&lt;&lt; Link a new vnode v into the outline &gt;&gt;</vh></v>
<v t="edream.110203163054.1536"><vh>&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;</vh></v>
<v t="edream.110203163054.1537"><vh>&lt;&lt; Count the number of following body lines &gt;&gt;</vh></v>
<v t="edream.110203163054.1538"><vh>&lt;&lt; Add the lines to the body text of v &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1539"><vh>importMoreText</vh>
<v t="edream.110203163054.1540"><vh>&lt;&lt; Read the file into strings &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1541"><vh>moreHeadlineLevel</vh></v>
<v t="edream.110203163054.1542"><vh>stringsAreValidMoreFile</vh></v>
</v>
<v t="edream.110203163054.1543"><vh>Reading</vh>
<v t="edream.110203163054.1544"><vh>fileInfo class</vh>
<v t="edream.110203163054.1545"><vh>&lt;&lt; Declare the fileInfo class &gt;&gt;</vh></v>
<v t="edream.110203163054.1546"><vh>Birth &amp; Death</vh></v>
<v t="edream.110203163054.1547"><vh>createVnode</vh>
<v t="edream.110203163054.1548"><vh>&lt;&lt; Create a root vnode &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1549"><vh>finishOutline (alert)</vh>
<v t="edream.110203163054.1550"><vh>&lt;&lt; Set attributes and icons for all nodes &gt;&gt;</vh></v>
<v t="edream.110203163054.1551"><vh>&lt;&lt; Create join lists of all vnodes &gt;&gt;</vh></v>
<v t="edream.110203163054.1552"><vh>&lt;&lt; Set the current node &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1553"><vh>finishPaste (creating join lists could be a problem)</vh>
<v t="edream.110203163054.1554"><vh>&lt;&lt; Check number of created tnodes &gt;&gt;</vh></v>
<v t="edream.110203163054.1555"><vh>&lt;&lt; Set attributes and icons for all pasted nodes &gt;&gt;</vh></v>
<v t="edream.110203163054.1556"><vh>&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;</vh></v>
<v t="edream.110203163054.1557"><vh>&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1558"><vh>getT</vh></v>
<v t="edream.110203163054.1559"><vh>newCloneWindow</vh></v>
<v t="edream.110203163054.1560"><vh>newTnode (alert)</vh></v>
<v t="edream.110203163054.1561"><vh>setMaxTnodeIndex</vh></v>
<v t="edream.110203163054.1562"><vh>setNumberOfTnodes</vh></v>
</v>
<v t="edream.110203163054.1563"><vh>get routines</vh>
<v t="edream.110203163054.1564"><vh>get (basic)</vh></v>
<v t="edream.110203163054.1565"><vh>getClipboardHeader</vh></v>
<v t="edream.110203163054.1566"><vh>getCloneWindows</vh></v>
<v t="edream.110203163054.1567"><vh>getEscapedString (uses large buffer)</vh>
<v t="edream.110203163054.1568"><vh>&lt;&lt; allocate mTextBuf &gt;&gt;</vh></v>
<v t="edream.110203163054.1569"><vh>&lt;&lt; increase the size of mTextBuf &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1570"><vh>getFindPanelSettings</vh>
<v t="edream.110203163054.1571"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1572"><vh>getGlobals</vh>
<v t="edream.110203163054.1573"><vh>&lt;&lt; set the window position &gt;&gt;</vh></v>
<v t="edream.110203163054.1574"><vh>&lt;&lt; set the log window position &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1575"><vh>getLeoFile (reads all @file nodes)</vh></v>
<v t="edream.110203163054.1576"><vh>getLeoHeader</vh></v>
<v t="edream.110203163054.1577"><vh>getLeoOutline</vh></v>
<v t="edream.110203163054.1578"><vh>getPosition</vh></v>
<v t="edream.110203163054.1579"><vh>getPrefs</vh>
<v t="edream.110203163054.1580"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt;</vh></v>
<v t="edream.110203163054.1581"><vh>&lt;&lt; Set the default directory preference &gt;&gt;</vh></v>
<v t="edream.110203163054.1582"><vh>&lt;&lt; Set the TSyntaxMemo options &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1583"><vh>getSize</vh></v>
<v t="edream.110203163054.1584"><vh>getTnodes</vh></v>
<v t="edream.110203163054.1585"><vh>getTnode (alert)</vh></v>
<v t="edream.110203163054.1586"><vh>getVnodes</vh></v>
<v t="edream.110203163054.1587"><vh>getVnode</vh>
<v t="edream.110203163054.1588"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1589"><vh>skipWs</vh></v>
<v t="edream.110203163054.1590"><vh>skipWsAndNl</vh></v>
</v>
<v t="edream.110203163054.1591"><vh>open</vh>
<v t="edream.110203163054.1592"><vh>&lt;&lt; Create the TFileStream and the file buffer &gt;&gt;</vh></v>
<v t="edream.110203163054.1593"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
<v t="edream.110203163054.1594"><vh>&lt;&lt; Delete the TFileStream and the file buffer &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1595"><vh>readLine</vh>
<v t="edream.110203163054.1596"><vh>&lt;&lt; reallocate mLineBuf &gt;&gt;</vh></v>
<v t="edream.110203163054.1597"><vh>&lt;&lt; fill mFileBuf or set mFileEmptyFlag &gt;&gt;</vh></v>
<v t="edream.110203163054.1598"><vh>&lt;&lt; return the last line, if any &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1599"><vh>xmlUnescape</vh></v>
</v>
<v t="edream.110203163054.1600"><vh>Writing</vh>
<v t="edream.110203163054.1601"><vh>assignFileIndices</vh></v>
<v t="edream.110203163054.1602"><vh>compactFileIndices</vh></v>
<v t="edream.110203163054.1603"><vh>shouldCompactOnSave</vh>
<v t="edream.110203163054.1604"><vh>&lt;&lt; Compute the number of tnodes used &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1605"><vh>put routines</vh>
<v t="edream.110203163054.1606"><vh>put (basic)</vh>
<v t="edream.110203163054.1607"><vh>&lt;&lt; put s to the mMemoryStream &gt;&gt;</vh></v>
<v t="edream.110203163054.1608"><vh>&lt;&lt; put s to mFileStream &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1609"><vh>putClipboardHeader</vh>
<v t="edream.110203163054.1610"><vh>&lt;&lt; count the number of tnodes &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1611"><vh>putCloneWindows</vh>
<v t="edream.110203163054.1612"><vh>&lt;&lt; put position of clone window &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1613"><vh>putEscapedString</vh></v>
<v t="edream.110203163054.1614"><vh>putFindSettings</vh></v>
<v t="edream.110203163054.1615"><vh>putGlobals</vh>
<v t="edream.110203163054.1616"><vh>&lt;&lt; put the body/outline ratio &gt;&gt;</vh></v>
<v t="edream.110203163054.1617"><vh>&lt;&lt; put the position of this form &gt;&gt;</vh></v>
<v t="edream.110203163054.1618"><vh>&lt;&lt; put the position of the log window &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1619"><vh>putHeader</vh>
<v t="edream.110203163054.1620"><vh>&lt;&lt; count the number of tnodes and clone windows &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1621"><vh>putLeoOutline (writes to clipboard)</vh></v>
<v t="edream.110203163054.1622"><vh>putPrefs</vh>
<v t="edream.110203163054.1623"><vh>&lt;&lt; put syntax coloring prefs &gt;&gt;</vh></v>
<v t="edream.110203163054.1624"><vh>&lt;&lt; put default directory &gt;&gt;</vh></v>
</v>
<v t="edream.110203163054.1625"><vh>putProlog</vh></v>
<v t="edream.110203163054.1626"><vh>putPostlog</vh></v>
<v t="edream.110203163054.1627"><vh>putTnodes</vh></v>
<v t="edream.110203163054.1628"><vh>put ( tnode * )</vh></v>
<v t="edream.110203163054.1629"><vh>putVnodes</vh></v>
<v t="edream.110203163054.1630"><vh>put ( vnode * )</vh>
<v t="edream.110203163054.1631"><vh>&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;</vh></v>
<v t="edream.110203163054.1632"><vh>&lt;&lt; Put a vnode tag if this vnode has a clone window &gt;&gt;</vh></v>
<v t="edream.110203163054.1633"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="edream.110203163054.1634"><vh>&lt;&lt; write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="edream.110203163054.1635"><vh>save</vh></v>
<v t="edream.110203163054.1636"><vh>saveAs</vh></v>
<v t="edream.110203163054.1637"><vh>saveACopyAs</vh></v>
<v t="edream.110203163054.1638"><vh>saveOutlineOnlyTo</vh></v>
<v t="edream.110203163054.1639"><vh>xmlEscape</vh></v>
<v t="edream.110203163054.1640"><vh>write_LEO_file</vh>
<v t="edream.110203163054.1641"><vh>&lt;&lt; Open fileName and buffer it &gt;&gt;</vh></v>
<v t="edream.110203163054.1642"><vh>&lt;&lt; Close the file &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="edream.110203163054.1643"><vh>White papers</vh>
<v t="edream.110203163054.1644"><vh>Recovering from Read Errors</vh></v>
<v t="edream.110203163054.1645"><vh>CVS postings</vh>
<v t="edream.110203163054.1646"><vh>How to use Leo with CVS</vh></v>
<v t="edream.110203163054.1647"><vh>Leo can't mend clone links</vh></v>
<v t="edream.110203163054.1648"><vh>Problems</vh></v>
<v t="edream.110203163054.1649"><vh>.cvs.leo format</vh></v>
<v t="edream.110203163054.1650"><vh>@cvs</vh></v>
</v>
<v t="edream.110203163054.1651"><vh>tk is the future of Leo</vh></v>
<v t="edream.110203163054.1652"><vh>Why I like Python</vh></v>
</v>
<v t="edream.110203163054.1653"><vh>Leaps (Leo Enhancement and Advancement Proposals)</vh>
<v t="edream.110203163054.1654"><vh>100's administering Leaps (and LeoCon)</vh>
<v t="edream.110203163054.1655"><vh>Leap 102: LeoCon 1</vh></v>
</v>
<v t="edream.110203163054.1656"><vh>200's single-user Leo</vh>
<v t="edream.110203163054.1657"><vh>Leap 201. (abandoned) Prototype link nodes and vxnodes</vh></v>
<v t="edream.110203163054.1658"><vh>Leap 202. (abandoned) Create cvs-friendly file format for derived files</vh></v>
<v t="edream.110203163054.1659"><vh>Leap 203. Use Python Mega Widgets</vh></v>
<v t="edream.110203163054.1660"><vh>Leap 204: (In 3.12) Add spell-checker</vh></v>
</v>
<v t="edream.110203163054.1661"><vh>300's LeoN and beyond</vh>
<v t="edream.110203163054.1662"><vh>Leap 301: Use central server</vh></v>
<v t="edream.110203163054.1663"><vh>Leap 302: Produce a plugin for a Resolve CVS Conflicts command</vh>
<v t="edream.110203163054.1664"><vh>Comments by Josef</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.1665"><vh>Diary entries</vh>
<v t="edream.110203163054.1666"><vh>2003</vh>
<v t="edream.110203163054.1667"><vh>August 2003</vh>
<v t="edream.110203163054.1668"><vh>8/30 Added horizontal scrollbar in body pane when @nowrap in effect</vh></v>
<v t="edream.110203163054.1669"><vh>8/29 Removed Open Python Window command</vh></v>
<v t="edream.110203163054.1670"><vh>8/28</vh>
<v t="edream.110203163054.1671"><vh>Added encoding comments to leoGlobals.py and french plugins</vh></v>
<v t="edream.110203163054.1672"><vh>Tested with Python 2.3</vh></v>
</v>
<v t="edream.110203163054.1673"><vh>8/27 Recycle window objects only if more than one window open</vh></v>
</v>
<v t="edream.110203163054.1674"><vh>July 2003</vh>
<v t="edream.110203163054.1675"><vh>7/25 Improved Leo's FAQ</vh></v>
<v t="edream.110203163054.1676"><vh>7/24</vh>
<v t="edream.110203163054.1677"><vh>Fixed Linux install scripts</vh></v>
<v t="edream.110203163054.1678"><vh>Changed default new window size in leoConfig.py to match leoConfig.txt</vh></v>
<v t="edream.110203163054.1679"><vh>Added Help Wanted section to the main todo list</vh></v>
</v>
<v t="edream.110203163054.1680"><vh>7/22</vh>
<v t="edream.110203163054.1681"><vh>Called setDefaultDirectoryForNewFiles from all variants of the Save command</vh></v>
<v t="edream.110203163054.1682"><vh>Added new hook for LeoN in the startup code</vh></v>
</v>
<v t="edream.110203163054.1683"><vh>7/19 Fixed shortcut bug</vh></v>
<v t="edream.110203163054.1684"><vh>7/18: Released 3.12 final</vh></v>
<v t="edream.110203163054.1685"><vh>7/18:  Added preliminary wxWindows project</vh></v>
<v t="edream.110203163054.1686"><vh>7/16</vh>
<v t="edream.110203163054.1687"><vh>Finished unit testing of colorizer</vh></v>
<v t="edream.110203163054.1688"><vh>Allow minus signs in rebol keywords</vh></v>
</v>
<v t="edream.110203163054.1689"><vh>7/13</vh>
<v t="edream.110203163054.1690"><vh>Fixed double-click bug on startup</vh></v>
<v t="edream.110203163054.1691"><vh>Simplified startup logic</vh></v>
<v t="edream.110203163054.1692"><vh>Created new screen shot on Leo's web site</vh></v>
</v>
<v t="edream.110203163054.1693"><vh>7/11</vh>
<v t="edream.110203163054.1694"><vh>Fixed reporting bug in convertAllTabs/Blanks</vh></v>
<v t="edream.110203163054.1695"><vh>Removed c.copyTree and v.copyNode and rewrote v.copyTree</vh></v>
<v t="edream.110203163054.1696"><vh>Fixed bugs involving undoing entire trees.</vh></v>
</v>
<v t="edream.110203163054.1697"><vh>7/10</vh>
<v t="edream.110203163054.1698"><vh>Improved (I hope) dragging code</vh></v>
<v t="edream.110203163054.1699"><vh>Added support for actionscript and rebol</vh></v>
</v>
<v t="edream.110203163054.1700"><vh>7/7</vh>
<v t="edream.110203163054.1701"><vh>Improved how headlines are edited</vh></v>
<v t="edream.110203163054.1702"><vh>Created separate leoPlugins.leo</vh></v>
<v t="edream.110203163054.1703"><vh>(Checked all code involving getTextSelection)</vh></v>
</v>
<v t="edream.110203163054.1704"><vh>Undo/redo now restore selection and insert point</vh></v>
<v t="edream.110203163054.1705"><vh>Fixed still more Open With problems</vh></v>
</v>
<v t="edream.110203163054.1706"><vh>June 2003</vh>
<v t="edream.110203163054.1707"><vh>6/30</vh>
<v t="edream.110203163054.1708"><vh>lift dialogs when they are deiconified</vh></v>
<v t="edream.110203163054.1709"><vh>Fixed another bug in createOpenWithTempFile</vh></v>
<v t="edream.110203163054.1710"><vh>Fixed missing log messages bug</vh></v>
<v t="edream.110203163054.1711"><vh>Changed destroyOpenWithFilesForFrame and createOpenWithTempFile</vh></v>
</v>
<v t="edream.110203163054.1712"><vh>6/29</vh>
<v t="edream.110203163054.1713"><vh>Added doc strings for most classes.</vh></v>
<v t="edream.110203163054.1714"><vh>Redefined all major classes so they can be overridden by plugins</vh></v>
<v t="edream.110203163054.1715"><vh>Improved spell-check plugin</vh></v>
</v>
<v t="edream.110203163054.1716"><vh>6/28 3.12 beta 1 released</vh>
<v t="edream.110203163054.1717"><vh>Rewrote distribution scripts to handle new directory organization</vh></v>
<v t="edream.110203163054.1718"><vh>Fixed three bugs reported by pychecker</vh></v>
</v>
<v t="edream.110203163054.1719"><vh>6/27 Rewrote callbacks in createMenuEntries</vh></v>
<v t="edream.110203163054.1720"><vh>6/24 Added @wrap and @nowrap directives</vh></v>
<v t="edream.110203163054.1721"><vh>6/22</vh>
<v t="edream.110203163054.1722"><vh>Investigated new Open With problem</vh></v>
<v t="edream.110203163054.1723"><vh>Added special case to idle_body_key to handle delete key</vh></v>
<v t="edream.110203163054.1724"><vh>atFile.scanText no longer strips leading whitespace from headlines</vh></v>
<v t="edream.110203163054.1725"><vh>Made window bigger when opening Leo from leo.py</vh></v>
</v>
<v t="edream.110203163054.1726"><vh>6/21 Completed all gc cleanup tasks</vh></v>
<v t="edream.110203163054.1727"><vh>6/19</vh>
<v t="edream.110203163054.1728"><vh>Moved all window closing code into app class</vh></v>
<v t="edream.110203163054.1729"><vh>Removed all destroy routines</vh></v>
<v t="edream.110203163054.1730"><vh>Removed all 4.0 debris</vh></v>
</v>
<v t="edream.110203163054.1731"><vh>6/18</vh>
<v t="edream.110203163054.1732"><vh>Scanned for fractional height/width params.  None remain.</vh></v>
<v t="edream.110203163054.1733"><vh>Removed unused fractional widths from leoFind ctor</vh></v>
<v t="edream.110203163054.1734"><vh>Set initial_window_width to 150 in leoConfig</vh></v>
</v>
<v t="edream.110203163054.1735"><vh>6/16 Fixed _huge_ leak in Tk.Canvas</vh></v>
<v t="edream.110203163054.1736"><vh>6/10 Implemented incremental redrawing</vh></v>
<v t="edream.110203163054.1737"><vh>6/8 Resolved copying issue</vh></v>
<v t="edream.110203163054.1738"><vh>6/1 Removed improper clones</vh></v>
</v>
<v t="edream.110203163054.1739"><vh>May 2003</vh>
<v t="edream.110203163054.1740"><vh>5/31</vh>
<v t="edream.110203163054.1741"><vh>Disabled cut/paste of outlines</vh></v>
</v>
<v t="edream.110203163054.1742"><vh>5/23</vh>
<v t="edream.110203163054.1743"><vh>Added "close-frame" &amp; "destroy-all-global-windows" hook code to destroy nav windows</vh></v>
<v t="edream.110203163054.1744"><vh>Added titles to Recent and Marks dialogs.</vh></v>
<v t="edream.110203163054.1745"><vh>Added "close-frame" and "destroy-all-global-windows" hooks</vh></v>
</v>
<v t="edream.110203163054.1746"><vh>5/22</vh>
<v t="edream.110203163054.1747"><vh>Rewrote the nav_buttons plugin using classes</vh></v>
<v t="edream.110203163054.1748"><vh>Completed nav_buttons plugin</vh></v>
</v>
<v t="edream.110203163054.1749"><vh>5/22 ** nav_buttons plugin!</vh>
<v t="edream.110203163054.1750"><vh>Created nav_buttons plugin</vh></v>
<v t="edream.110203163054.1751"><vh>use string.zfill instead of aString.zfill in color_markup plugin</vh></v>
</v>
<v t="edream.110203163054.1752"><vh>5/21</vh>
<v t="edream.110203163054.1753"><vh>Experiments with startup scripts</vh></v>
</v>
<v t="edream.110203163054.1754"><vh>5/20 ** Added Icon &amp; Status areas</vh>
<v t="edream.110203163054.1755"><vh>Added idle handler to update the row/col indicator in the status area</vh></v>
<v t="edream.110203163054.1756"><vh>Added convenience routines for icon &amp; status areas</vh></v>
<v t="edream.110203163054.1757"><vh>Disable non-functional parts of Find panel</vh></v>
<v t="edream.110203163054.1758"><vh>Selected find text on entry to find panel</vh></v>
<v t="edream.110203163054.1759"><vh>Added icon/status areas.  REMOVED MAJOR KLUDGE</vh></v>
</v>
<v t="edream.110203163054.1760"><vh>5/19</vh>
<v t="edream.110203163054.1761"><vh>Partially cleaned up leoFind class</vh></v>
<v t="edream.110203163054.1762"><vh>TO DO: Convenience routines</vh></v>
<v t="edream.110203163054.1763"><vh>Removed checkForLeoCustomize &amp; related logic</vh></v>
<v t="edream.110203163054.1764"><vh>Documented new stub hooks</vh></v>
</v>
<v t="edream.110203163054.1765"><vh>5/18</vh>
<v t="edream.110203163054.1766"><vh>Added support for bolditalic and italicbold</vh></v>
<v t="edream.110203163054.1767"><vh>Rewrote logic involving images.</vh></v>
</v>
<v t="edream.110203163054.1768"><vh>5/17</vh>
<v t="edream.110203163054.1769"><vh>Simplified startup code</vh></v>
<v t="edream.110203163054.1770"><vh>Created the add_directives plugin</vh></v>
<v t="edream.110203163054.1771"><vh>Created "scan-directives" hook in scanDirectives</vh></v>
<v t="edream.110203163054.1772"><vh>Created "init-color-markup" hook</vh></v>
<v t="edream.110203163054.1773"><vh>Fixed recent bug in colorizer</vh></v>
</v>
<v t="edream.110203163054.1774"><vh>5/16</vh>
<v t="edream.110203163054.1775"><vh>Improved how Leo loads plugins</vh></v>
<v t="edream.110203163054.1776"><vh>Cleaned up some hooks</vh></v>
<v t="edream.110203163054.1777"><vh>Created plugin to handle markup in body pane</vh></v>
<v t="edream.110203163054.1778"><vh>Added stub hooks for cutomizing the drawing of the outline</vh></v>
<v t="edream.110203163054.1779"><vh>Removed toggle &lt;&lt; &gt;&gt; command</vh></v>
</v>
<v t="edream.110203163054.1780"><vh>5/15 stub hooks</vh>
<v t="edream.110203163054.1781"><vh>Created the plugin and script menu plugins</vh></v>
<v t="edream.110203163054.1782"><vh>Breakthough: stub hooks &amp; alphabetical order</vh></v>
</v>
<v t="edream.110203163054.1783"><vh>5/13</vh>
<v t="edream.110203163054.1784"><vh>Progress report 5/13/03: please read</vh></v>
<v t="edream.110203163054.1785"><vh>Merged devel folder into main cvs folder</vh></v>
<v t="edream.110203163054.1786"><vh>Updated version number to 4.0 alpha 1</vh></v>
<v t="edream.110203163054.1787"><vh>Removed __init__ from files managed by LeoPy.leo</vh></v>
<v t="edream.110203163054.1788"><vh>Use @ignore for all scripts</vh></v>
</v>
<v t="edream.110203163054.1789"><vh>5/12</vh>
<v t="edream.110203163054.1790"><vh>Reorganized Leo folder: big change to cvs</vh></v>
<v t="edream.110203163054.1791"><vh>Investigated strange behavior of log pane during Open commands</vh></v>
</v>
<v t="edream.110203163054.1792"><vh>5/4</vh>
<v t="edream.110203163054.1793"><vh>Gathered statistics for threadNext</vh></v>
<v t="edream.110203163054.1794"><vh>defined funcToMethod in leoGlobals.py</vh></v>
<v t="edream.110203163054.1795"><vh>Experimented with precomputing threadNext and threadBack when linking nodes</vh></v>
<v t="edream.110203163054.1796"><vh>Experimented with using v.mChildren to represent children</vh></v>
<v t="edream.110203163054.1797"><vh>Changed OnIconDoubleClick to allow @url url comments</vh></v>
<v t="edream.110203163054.1798"><vh>atFile code now use _permanent_ fileCommands.tnodesDict</vh></v>
<v t="edream.110203163054.1799"><vh>Improved and tested checkForPossiblyBrokenLinks</vh></v>
<v t="edream.110203163054.1800"><vh>Cleaned up atFile.read code</vh></v>
<v t="edream.110203163054.1801"><vh>Cleaned up getVnode code</vh></v>
<v t="edream.110203163054.1802"><vh>Added headString arg to tnode ctor</vh></v>
<v t="edream.110203163054.1803"><vh>Moved createTopologyList to leoGlobals.py</vh></v>
</v>
<v t="edream.110203163054.1804"><vh>5/3</vh>
<v t="edream.110203163054.1805"><vh>Many changes to file reading code</vh></v>
<v t="edream.110203163054.1806"><vh>Created scripts to check outline for clone &amp; joinList errors</vh></v>
<v t="edream.110203163054.1807"><vh>Moved headlines into tnodes</vh></v>
<v t="edream.110203163054.1808"><vh>Second rewrite of v.joinNodeTo</vh></v>
</v>
<v t="edream.110203163054.1809"><vh>5/2</vh>
<v t="edream.110203163054.1810"><vh>updateRecentFiles does nothing on Null filenames</vh></v>
<v t="edream.110203163054.1811"><vh>Major change: rewrote joinList code and move joinLists to tnodes</vh></v>
</v>
<v t="edream.110203163054.1812"><vh>5/1</vh>
<v t="edream.110203163054.1813"><vh>Fixed bug when userID != defaultID</vh></v>
<v t="edream.110203163054.1814"><vh>Made lines following @+t and @+v look like sentinels</vh></v>
<v t="edream.110203163054.1815"><vh>Checked that Leo 3.11 can read new .leo files</vh></v>
<v t="edream.110203163054.1816"><vh>Made sure leo works without leoID.txt when use_gnx is false</vh></v>
<v t="edream.110203163054.1817"><vh>Optimized how Leo allocates t.gnx</vh></v>
</v>
</v>
<v t="edream.110203163054.1818"><vh>April 2003</vh>
<v t="edream.110203163054.1819"><vh>4/20</vh>
<v t="edream.110203163054.1820"><vh>Removed vnx fields from vnodes and +v sentinels</vh></v>
<v t="edream.110203163054.1821"><vh>Put getpreferredencoding code in try: except blocks</vh></v>
<v t="edream.110203163054.1822"><vh>Made sure that code works on old files when a.use_gnx is true</vh></v>
<v t="edream.110203163054.1823"><vh>Replaced fileCommands.getT by self.tnodesDict.get</vh></v>
</v>
<v t="edream.110203163054.1824"><vh>4/29 Transition to 4.0 .leo files</vh>
<v t="edream.110203163054.1825"><vh>Allocate gnx's only when needed (when writing files)</vh></v>
<v t="edream.110203163054.1826"><vh>4.0 code writes tnodes even if they have no body text</vh></v>
<v t="edream.110203163054.1827"><vh>4.0 code writes tnx="tnx" instead of t="index" in vnodes and tnodes</vh></v>
<v t="edream.110203163054.1828"><vh>Write vnx and tnx instead of gnx in vnodes and tnodes</vh></v>
<v t="edream.110203163054.1829"><vh>Made use_pre_4pt0_file_formats setting functional</vh></v>
</v>
<v t="edream.110203163054.1830"><vh>4/28</vh>
<v t="edream.110203163054.1831"><vh>Use tuples instead of dicts in nodeIndices class</vh></v>
<v t="edream.110203163054.1832"><vh>Added code to remove gnx id if it matches default_gnx_id</vh></v>
<v t="edream.110203163054.1833"><vh>Added code to read/write default_gnx_id field in globals section</vh></v>
<v t="edream.110203163054.1834"><vh>Added code to write gnx attribute of tnodes and vnodes</vh></v>
<v t="edream.110203163054.1835"><vh>Added code to read gnx attribute of tnodes and vnodes</vh></v>
<v t="edream.110203163054.1836"><vh>Added old and new to list of valid @file options</vh></v>
<v t="edream.110203163054.1837"><vh>Added use_pre_4pt0_file_formats config option</vh></v>
<v t="edream.110203163054.1838"><vh>Added Write Old Format Outline command to Export menu</vh></v>
</v>
<v t="edream.110203163054.1839"><vh>4/27</vh>
<v t="edream.110203163054.1840"><vh>Made read-only messages red</vh></v>
<v t="edream.110203163054.1841"><vh>4.x code always writes @+t sentinels even for empty nodes</vh></v>
<v t="edream.110203163054.1842"><vh>Created gnx's in vnode and tnode ctors</vh></v>
</v>
<v t="edream.110203163054.1843"><vh>4/27 3.11 final released</vh></v>
<v t="edream.110203163054.1844"><vh>4/26</vh>
<v t="edream.110203163054.1845"><vh>Greatly simplified Plugins menu code using list comprehensions</vh></v>
<v t="edream.110203163054.1846"><vh>Added 4.0 code to atFile.read that deletes all children of root</vh></v>
<v t="edream.110203163054.1847"><vh>Fixed bug that prevented email line in About Leo from working</vh></v>
<v t="edream.110203163054.1848"><vh>Prepared for 3.11 final: updated dates and urls</vh></v>
<v t="edream.110203163054.1849"><vh>Fixed various bugs reported by Pychecker</vh></v>
</v>
<v t="edream.110203163054.1850"><vh>4/24</vh>
<v t="edream.110203163054.1851"><vh>Added support for @lineending directive</vh></v>
<v t="edream.110203163054.1852"><vh>Created utility routines for scanAllDirectives and scanDirectives</vh></v>
<v t="edream.110203163054.1853"><vh>Fixed bug in skip_long</vh></v>
</v>
<v t="edream.110203163054.1854"><vh>4/23 Improved dialog that gets id for leoID.txt</vh></v>
<v t="edream.110203163054.1855"><vh>4/22 Added getpreferredencoding to leoGlobals.py</vh></v>
<v t="edream.110203163054.1856"><vh>4/21 Added patch by Davide Salomoni to OnIconDoubleClick</vh></v>
<v t="edream.110203163054.1857"><vh>4/20 Removed all __del__ methods</vh></v>
<v t="edream.110203163054.1858"><vh>4/5 Removed write_clone_indices &amp; use_relative_node_indices config ivars</vh></v>
<v t="edream.110203163054.1859"><vh>4/5 Added thin_at_file_trees &amp; load_derived_files_immediately options</vh></v>
<v t="edream.110203163054.1860"><vh>4/4 Added call to c.redraw() in fileCommands.readAtFileNodes</vh></v>
<v t="edream.110203163054.1861"><vh>4/4 Fixed unicode bugs when Tangling and Untangling</vh></v>
<v t="edream.110203163054.1862"><vh>4/3 Eliminated caught exception in frame.setTabWidth</vh></v>
</v>
<v t="edream.110203163054.1863"><vh>March 2003</vh>
<v t="edream.110203163054.1864"><vh>3/30 Don't write gnx for ending sentinels</vh></v>
<v t="edream.110203163054.1865"><vh>3/30 Added code to handle afterref sentinels</vh></v>
<v t="edream.110203163054.1866"><vh>3/29 New read logic passes its first test</vh></v>
<v t="edream.110203163054.1867"><vh>3/28 Use scanText as a base for 4.0 read logic</vh></v>
<v t="edream.110203163054.1868"><vh>3/26</vh>
<v t="edream.110203163054.1869"><vh>Installer now creates plugins directory</vh></v>
<v t="edream.110203163054.1870"><vh>Improved scrolling when moving right</vh>
<v t="edream.110203163054.1871"><vh>Test</vh>
<v t="edream.110203163054.1872"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1873"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1874"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1875"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1876"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1877"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1878"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1879"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1880"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1881"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1882"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1883"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1884"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1885"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1886"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1887"><vh>NewHeadline</vh></v>
<v t="edream.110203163054.1888"><vh>NewHeadline</vh></v>
</v>
</v>
<v t="edream.110203163054.1889"><vh>3/26 Removed duplicate redraws when renaming nodes</vh></v>
</v>
<v t="edream.110203163054.1890"><vh>3/25 Created frame.setWindowTitle and associated logic</vh></v>
<v t="edream.110203163054.1891"><vh>3/22</vh>
<v t="edream.110203163054.1892"><vh>3/22 Added support for body/headline_gmt_time settings</vh></v>
<v t="edream.110203163054.1893"><vh>3/22 Allow color param when queuing messages to log pane</vh></v>
<v t="edream.110203163054.1894"><vh>3/22 Check for valid encoding when setting app().tkEncoding</vh></v>
</v>
<v t="edream.110203163054.1895"><vh>3/18</vh>
<v t="edream.110203163054.1896"><vh>3/18 Use app().tkEncoding to convert to unicode in log pane</vh></v>
<v t="edream.110203163054.1897"><vh>3/18 Tangle now supports output_newline option</vh></v>
</v>
<v t="edream.110203163054.1898"><vh>3/17 Fixed bugs in promote/demote</vh></v>
<v t="edream.110203163054.1899"><vh>3/8</vh>
<v t="edream.110203163054.1900"><vh>3/8 Full recolor after paste</vh></v>
<v t="edream.110203163054.1901"><vh>3/8 Put file name first in window title</vh></v>
<v t="edream.110203163054.1902"><vh>3/8 Added calls to toEncodedString before many calls to write</vh></v>
</v>
<v t="edream.110203163054.1903"><vh>3/7</vh>
<v t="edream.110203163054.1904"><vh>3/7 Fixed huge performance bug in v.unjoinNode</vh></v>
<v t="edream.110203163054.1905"><vh>3/7 Added statistics gathering routines to leoGlobals.py</vh></v>
</v>
</v>
<v t="edream.110203163054.1906"><vh>Feb 2003</vh>
<v t="edream.110203163054.1907"><vh>2/26 3.11b3 released</vh></v>
<v t="edream.110203163054.1908"><vh>2/20 Reinstated Expand All command</vh></v>
<v t="edream.110203163054.1909"><vh>2/18 Fixed auto-indent for python</vh></v>
<v t="edream.110203163054.1910"><vh>2/17 Fixed minor Import @root bugs</vh></v>
<v t="edream.110203163054.1911"><vh>02/17 3.11b1 released</vh></v>
<v t="edream.110203163054.1912"><vh>02/11</vh>
<v t="edream.110203163054.1913"><vh>Fixed crasher in canFindMatchingBracket</vh></v>
<v t="edream.110203163054.1914"><vh>Removed odious locks on customizeLeo.py</vh></v>
<v t="edream.110203163054.1915"><vh>Fixed control-V bug for Linux</vh></v>
</v>
<v t="edream.110203163054.1916"><vh>02/08</vh>
<v t="edream.110203163054.1917"><vh>Major reorganization of hooks</vh></v>
<v t="edream.110203163054.1918"><vh>Fixed bug: double-clicking icon set the cursor to the hand</vh></v>
<v t="edream.110203163054.1919"><vh>Fixed bug: v.OnEndDrag fires event only if dragging</vh></v>
</v>
<v t="edream.110203163054.1920"><vh>02/07</vh>
<v t="edream.110203163054.1921"><vh>replaced c.contractVnode and c.expandVnode</vh></v>
</v>
<v t="edream.110203163054.1922"><vh>02/04</vh>
<v t="edream.110203163054.1923"><vh>Fixed "% (greenOgre)" config bug</vh></v>
</v>
<v t="edream.110203163054.1924"><vh>02/02</vh>
<v t="edream.110203163054.1925"><vh>Added code to scroll partially visible headlines when they are selected</vh></v>
</v>
<v t="edream.110203163054.1926"><vh>02/01</vh>
<v t="edream.110203163054.1927"><vh>Added code to allow sorting of top-level nodes</vh></v>
<v t="edream.110203163054.1928"><vh>Hacked atFile.writeAll to allow multiple writes of cloned nodes</vh></v>
<v t="edream.110203163054.1929"><vh>Removed redundant code from v.set/clearDirty routines</vh></v>
</v>
</v>
<v t="edream.110203163054.1930"><vh>Jan 2003</vh>
<v t="edream.110203163054.1931"><vh>01/31</vh>
<v t="edream.110203163054.1932"><vh>Udated recent files menu when saving a new .leo file</vh></v>
<v t="edream.110203163054.1933"><vh>Prefs dialog close button equivalent to cancel</vh></v>
<v t="edream.110203163054.1934"><vh>Fixed about hooks typo</vh></v>
<v t="edream.110203163054.1935"><vh>New Go To First/Last/Parent/Prev Sibling/Next Sibling commands</vh></v>
<v t="edream.110203163054.1936"><vh>Major improvements to expand/contract commands</vh></v>
</v>
<v t="edream.110203163054.1937"><vh>1/30</vh>
<v t="edream.110203163054.1938"><vh>Create Toggle Angle Brackets command</vh></v>
<v t="edream.110203163054.1939"><vh>Created Insert Body/Headline Time/Date routines</vh></v>
<v t="edream.110203163054.1940"><vh>Added "Replace tabs with spaces" checkbox in Prefs panel</vh></v>
<v t="edream.110203163054.1941"><vh>Made Find button the default button in the Find panel</vh></v>
<v t="edream.110203163054.1942"><vh>Allowed @comment with @language plain</vh></v>
</v>
<v t="edream.110203163054.1943"><vh>1/29</vh>
<v t="edream.110203163054.1944"><vh>Added "save1" and "save2" hooks</vh></v>
<v t="edream.110203163054.1945"><vh>Added disabled support for @folder to customizeLeo.py</vh></v>
<v t="edream.110203163054.1946"><vh>Added support for Show Invisible color options</vh></v>
<v t="edream.110203163054.1947"><vh>Added support for look_for_control_drag_on_mouse_down option</vh></v>
</v>
<v t="edream.110203163054.1948"><vh>1/25</vh>
<v t="edream.110203163054.1949"><vh>Fixed problem with block comments</vh>
<v t="edream.110203163054.1950"><vh>Report</vh></v>
<v t="edream.110203163054.1951"><vh>Reply</vh></v>
</v>
</v>
<v t="edream.110203163054.1952"><vh>1/24</vh>
<v t="edream.110203163054.1953"><vh>Fixed problem with cutting &amp; pasting nodes</vh></v>
<v t="edream.110203163054.1954"><vh>Removed potential hang in frame.OnOpenWith</vh></v>
<v t="edream.110203163054.1955"><vh>Added support for body_insertion_cursor_color setting</vh></v>
<v t="edream.110203163054.1956"><vh>Fixed unicode in Tangle logic</vh></v>
</v>
<v t="edream.110203163054.1957"><vh>1/23 Completed transition to unicode</vh></v>
<v t="edream.110203163054.1958"><vh>1/21 Encode find/change strings as utf-8 in leoConfig.txt</vh></v>
<v t="edream.110203163054.1959"><vh>1/20 Began conversion to unicode internally</vh></v>
<v t="edream.110203163054.1960"><vh>1/18</vh>
<v t="edream.110203163054.1961"><vh>Worked around True/False problems in Python 2.3 a1</vh></v>
</v>
<v t="edream.110203163054.1962"><vh>1/7</vh>
<v t="edream.110203163054.1963"><vh>Added colon to list of bad characters removed by sanitize_filename</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.1964"><vh>2002</vh>
<v t="edream.110203163054.1965"><vh>Dec 2002</vh>
<v t="edream.110203163054.1966"><vh>12/18</vh>
<v t="edream.110203163054.1967"><vh>Added event=event to handleLeoHook</vh></v>
<v t="edream.110203163054.1968"><vh>Demoted up/down arrow stuff to a disabled hook for now.</vh></v>
</v>
<v t="edream.110203163054.1969"><vh>12/17</vh>
<v t="edream.110203163054.1970"><vh>Created tree.moveUpDown</vh></v>
</v>
<v t="edream.110203163054.1971"><vh>112/16</vh>
<v t="edream.110203163054.1972"><vh>Replaced string.x(s...) by s.x(...)</vh></v>
<v t="edream.110203163054.1973"><vh>Improved es and trace, added trace_tag</vh></v>
<v t="edream.110203163054.1974"><vh>Fixed crasher in undo logic</vh></v>
<v t="edream.110203163054.1975"><vh>Reset the canvas cursor by brute force</vh></v>
<v t="edream.110203163054.1976"><vh>Tried to prevent "stuck" drag cursor</vh></v>
<v t="edream.110203163054.1977"><vh>Reviewed all calls to handleLeoHook </vh></v>
<v t="edream.110203163054.1978"><vh>Fixed pychecker problems</vh></v>
</v>
<v t="edream.110203163054.1979"><vh>12/14/02 3.10 released</vh></v>
<v t="edream.110203163054.1980"><vh>12/12</vh>
<v t="edream.110203163054.1981"><vh>Added "missing" event hooks</vh></v>
</v>
<v t="edream.110203163054.1982"><vh>12/11</vh>
<v t="edream.110203163054.1983"><vh>Fixed major bug in Execute Script command</vh></v>
</v>
<v t="edream.110203163054.1984"><vh>12/10</vh>
<v t="edream.110203163054.1985"><vh>Added convenience routines to redirect stderr and stdout</vh></v>
</v>
<v t="edream.110203163054.1986"><vh>12/8</vh>
<v t="edream.110203163054.1987"><vh>wrote redirectPrintToLog &amp; restorePrintFromLog</vh></v>
<v t="edream.110203163054.1988"><vh>Fixed @nsf bug reported by Travers A. Hough</vh></v>
<v t="edream.110203163054.1989"><vh>Discovered bugs in undoReplace logic</vh></v>
</v>
<v t="edream.110203163054.1990"><vh>12/7</vh>
<v t="edream.110203163054.1991"><vh>Fixed undo bug</vh></v>
</v>
<v t="edream.110203163054.1992"><vh>12/6</vh>
<v t="edream.110203163054.1993"><vh>Fixed reversion involving @comment &amp; @language together</vh></v>
<v t="edream.110203163054.1994"><vh>major revision of the menu code</vh></v>
</v>
<v t="edream.110203163054.1995"><vh>12/4</vh>
<v t="edream.110203163054.1996"><vh>Fixed path problem in paths passed to tangle_done.py</vh></v>
<v t="edream.110203163054.1997"><vh>Fixed Recent Files command</vh></v>
<v t="edream.110203163054.1998"><vh>Fixed problems with Open With code in customizeLeo.py</vh></v>
<v t="edream.110203163054.1999"><vh>Fixed crasher in colorizeAnyLanguage</vh></v>
<v t="edream.110203163054.2000"><vh>Fixed major memory leak</vh></v>
<v t="edream.110203163054.2001"><vh>Changed shortcut to Find Previous so Alt - F4 closes Leo</vh></v>
<v t="edream.110203163054.2002"><vh>Changed url of help file</vh></v>
<v t="edream.110203163054.2003"><vh>Removed backquotes from most print statements</vh></v>
<v t="edream.110203163054.2004"><vh>Removed synonyms from leoImport.py and leoTangle.py</vh></v>
</v>
<v t="edream.110203163054.2005"><vh>12/3</vh>
<v t="edream.110203163054.2006"><vh>Converted leoConfig.py to use @root-code</vh></v>
<v t="edream.110203163054.2007"><vh>Added @file &amp; @root options</vh></v>
<v t="edream.110203163054.2008"><vh>Fixed a bug in Untangle</vh></v>
<v t="edream.110203163054.2009"><vh>Decided not to do utils_normpath</vh></v>
</v>
</v>
<v t="edream.110203163054.2010"><vh>Nov 2002</vh>
<v t="edream.110203163054.2011"><vh>11/25</vh>
<v t="edream.110203163054.2012"><vh>Improved Leo's window icon</vh></v>
<v t="edream.110203163054.2013"><vh>cleaned up config code relating to find settings</vh></v>
<v t="edream.110203163054.2014"><vh>Added Node only option to find menu</vh></v>
<v t="edream.110203163054.2015"><vh>Added Export Headlines command</vh></v>
</v>
<v t="edream.110203163054.2036"><vh>11/21</vh>
<v t="edream.110203163054.2037"><vh>Fixed bug in colorizeAnyLine</vh></v>
<v t="edream.110203163054.2038"><vh>Improved undo for Edit Body commands</vh></v>
</v>
<v t="edream.110203163054.2039"><vh>11/20</vh>
<v t="edream.110203163054.2040"><vh>Fixed unicode bugs</vh></v>
</v>
<v t="edream.110203163054.2041"><vh>11/19</vh>
<v t="edream.110203163054.2042"><vh>Changed use_configureLeo_dot_py to use_customizeLeo_dot_py</vh></v>
<v t="edream.110203163054.2043"><vh>Create all non-existent directories using makeAllNonExistentDirectories</vh></v>
<v t="edream.110203163054.2044"><vh>Made sure all open calls are in try blocks.</vh></v>
<v t="edream.110203163054.2045"><vh>Recolor entire pane if @color or @nocolor change</vh></v>
<v t="edream.110203163054.2046"><vh>Changed the lamda used to define the Recent Files callback</vh></v>
<v t="edream.110203163054.2047"><vh>Added "openwith", "recentfiles" and "@url" hooks</vh></v>
<v t="edream.110203163054.2048"><vh>Fixed big leak in undo</vh></v>
<v t="edream.110203163054.2049"><vh>Properly save and restore selection range for undo.</vh></v>
<v t="edream.110203163054.2050"><vh>Fixed bug that caused a backspace in an empty body text to insert a newline.</vh></v>
<v t="edream.110203163054.2051"><vh>Made Undo bulletproof</vh></v>
<v t="edream.110203163054.2052"><vh>Removed code in tree.select that removed trailing newlines</vh></v>
</v>
<v t="edream.110203163054.2053"><vh>11/18</vh>
<v t="edream.110203163054.2054"><vh>Added Open with entries to popup menus</vh></v>
<v t="edream.110203163054.2055"><vh>Added David McNab's auto-indent patch (smart_auto_indent option)</vh></v>
</v>
<v t="edream.110203163054.2056"><vh>11/17</vh>
<v t="edream.110203163054.2057"><vh>Added "headkey1" and "headkey2" hooks</vh></v>
</v>
<v t="edream.110203163054.2058"><vh>11/16</vh>
<v t="edream.110203163054.2059"><vh>added enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
<v t="edream.110203163054.2060"><vh>Completed first draft of Go To Line Number command</vh></v>
</v>
<v t="edream.110203163054.2061"><vh>11/15</vh>
<v t="edream.110203163054.2062"><vh>Added Go To Line Number command</vh></v>
<v t="edream.110203163054.2063"><vh>Rewrote syntax coloring for cweb</vh></v>
</v>
<v t="edream.110203163054.2064"><vh>11/14</vh>
<v t="edream.110203163054.2065"><vh>Fixed bug in atFile.scanAllDirectives involving @language</vh></v>
</v>
<v t="edream.110203163054.2066"><vh>11/13</vh>
<v t="edream.110203163054.2067"><vh>Added keywords parameter to customizeLeo</vh></v>
<v t="edream.110203163054.2068"><vh>Implemented the use_configureLeo_dot_py option</vh></v>
<v t="edream.110203163054.2069"><vh>Released first public draft of incremental undo</vh></v>
</v>
<v t="edream.110203163054.2070"><vh>11/10</vh>
<v t="edream.110203163054.2071"><vh>Correctly colors Pascal's "private" and "uses" keywords</vh></v>
</v>
<v t="edream.110203163054.2072"><vh>11/9</vh>
<v t="edream.110203163054.2073"><vh>Fixed blunder in undo/redraw code</vh></v>
<v t="edream.110203163054.2074"><vh>Fixed Dave Hein's @language issue</vh></v>
<v t="edream.110203163054.2075"><vh>Completed incremental syntax coloring</vh></v>
</v>
<v t="edream.110203163054.2076"><vh>11/8</vh>
<v t="edream.110203163054.2077"><vh>Worked on incremental syntax coloring</vh></v>
<v t="edream.110203163054.2078"><vh>Changed leoCustomize.py to customizeLeo.py to make distribution easier.</vh></v>
<v t="edream.110203163054.2079"><vh>Warn if @node leoCustomize.py is not @ignored</vh></v>
<v t="edream.110203163054.2080"><vh>Execute script no longer supports @pythonscript</vh></v>
<v t="edream.110203163054.2081"><vh>Added example of how to customize individual .leo files safely in leoCustomize.py</vh></v>
<v t="edream.110203163054.2082"><vh>Added frame.longFileName and shortFileName methods</vh></v>
</v>
<v t="edream.110203163054.2083"><vh>11/7</vh>
<v t="edream.110203163054.2084"><vh>Prompt when writing leoCustomize.py</vh></v>
<v t="edream.110203163054.2085"><vh>Disabled the "virus-word" in leCustomize.py</vh></v>
</v>
<v t="edream.110203163054.2086"><vh>11/6</vh>
<v t="edream.110203163054.2087"><vh>Fixed a major bug in top()</vh>
<v t="edream.110203163054.2088"><vh>top</vh></v>
</v>
<v t="edream.110203163054.2089"><vh>Implemented per-window hook scheme</vh></v>
</v>
<v t="edream.110203163054.2090"><vh>11/5</vh>
<v t="edream.110203163054.2091"><vh>Fixed bug in cweb coloring, made latex work more like cweb</vh></v>
<v t="edream.110203163054.2092"><vh>Added app().realMenuName logic</vh></v>
<v t="edream.110203163054.2093"><vh>Added "open1", "open2", "menu1" and "menu2" hooks</vh></v>
<v t="edream.110203163054.2094"><vh>Completed generalization of menu code</vh></v>
</v>
<v t="edream.110203163054.2095"><vh>11/4</vh>
<v t="edream.110203163054.2096"><vh>Replaced all frame menu ivars with frame.menus dict</vh></v>
<v t="edream.110203163054.2097"><vh>Generalized how commands are called</vh></v>
<v t="edream.110203163054.2098"><vh>Added general-purpose hook handling</vh></v>
<v t="edream.110203163054.2099"><vh>Use original leading whitespace when reformatting paragraphs</vh></v>
<v t="edream.110203163054.2100"><vh>Use scanDirectives in Convert All Blanks/Tabs commands</vh></v>
<v t="edream.110203163054.2101"><vh>Incorporated Dave Hein's recent changes</vh></v>
</v>
<v t="edream.110203163054.2102"><vh>11/3</vh>
<v t="edream.110203163054.2103"><vh>Implemented @pythonscript and Execute Script</vh></v>
</v>
<v t="edream.110203163054.2104"><vh>11/2</vh>
<v t="edream.110203163054.2105"><vh>Fixed bugs when importing Java files.</vh></v>
<v t="edream.110203163054.2106"><vh>Fixed important bug in find_line_start</vh></v>
</v>
<v t="edream.110203163054.2107"><vh>1/11</vh>
<v t="edream.110203163054.2108"><vh>Fixed cweb hack using Jonathon Gilligan's patches</vh></v>
</v>
<v t="edream.110203163054.2109"><vh>(reducing name polution)</vh></v>
</v>
<v t="edream.110203163054.2110"><vh>Oct 2002</vh>
<v t="edream.110203163054.2111"><vh>10/30</vh>
<v t="edream.110203163054.2112"><vh>Applied cweb hack to all sentinels</vh></v>
<v t="edream.110203163054.2113"><vh>raw cweb mode in @root trees</vh></v>
<v t="edream.110203163054.2114"><vh>simplified Reformat Paragraph command</vh></v>
</v>
<v t="edream.110203163054.2115"><vh>10/29 Released 3.8</vh>
<v t="edream.110203163054.2116"><vh>10/28</vh>
<v t="edream.110203163054.2117"><vh>Don't recognize @*, @&lt; or @( in cweb mode</vh></v>
<v t="edream.110203163054.2118"><vh>Completed documentation for 3.8</vh></v>
</v>
<v t="edream.110203163054.2119"><vh>10/27</vh>
<v t="edream.110203163054.2120"><vh>Fixed problems report by Pychecker</vh></v>
<v t="edream.110203163054.2121"><vh>Fixed path bugs in tangle.scanAllDirectives</vh></v>
<v t="edream.110203163054.2122"><vh>Changed path_directive_creates_directories to create_nonexistent_directories</vh></v>
</v>
<v t="edream.110203163054.2123"><vh>10/26</vh>
<v t="edream.110203163054.2124"><vh>Fixed foo.leo bug</vh></v>
<v t="edream.110203163054.2125"><vh>Worked around Control-T bug</vh></v>
<v t="edream.110203163054.2126"><vh>Reset hand cursor after failed drag</vh></v>
</v>
<v t="edream.110203163054.2127"><vh>10/25</vh>
<v t="edream.110203163054.2128"><vh>Used dicts to speed up checkMoveWithParentWithWarning</vh></v>
<v t="edream.110203163054.2129"><vh>Created reloadAll in leoGlobals.py</vh></v>
<v t="edream.110203163054.2130"><vh>Allow noweb section refs in @file cweb code</vh></v>
<v t="edream.110203163054.2131"><vh>Added support for &lt;?xml-stylesheet...?&gt; line</vh></v>
<v t="edream.110203163054.2132"><vh>Documented @rawfile and @silentfile</vh></v>
</v>
<v t="edream.110203163054.2133"><vh>10/24</vh>
<v t="edream.110203163054.2134"><vh>Fixed cweb sentinel bug</vh></v>
</v>
<v t="edream.110203163054.2135"><vh>10/23</vh>
<v t="edream.110203163054.2136"><vh>Completed first draft of new @rawfile and @silentfile</vh></v>
<v t="edream.110203163054.2137"><vh>Discovered that gti's _are_ possible</vh></v>
<v t="edream.110203163054.2138"><vh>Finished cweb hack</vh></v>
<v t="edream.110203163054.2139"><vh>Fixed @delims "round trip" bug</vh></v>
<v t="edream.110203163054.2140"><vh>Fixed bug involving menu pastes in headlines</vh></v>
</v>
<v t="edream.110203163054.2141"><vh>10/19</vh>
<v t="edream.110203163054.2142"><vh>Fixed import to @root problems</vh></v>
</v>
<v t="edream.110203163054.2143"><vh>10/18</vh>
<v t="edream.110203163054.2144"><vh>Completed handling of output_initial_comment option</vh></v>
<v t="edream.110203163054.2145"><vh>Fixed block-comment bug in Java and HTML</vh></v>
<v t="edream.110203163054.2146"><vh>Use // as single-line comment in Java</vh></v>
</v>
<v t="edream.110203163054.2147"><vh>10/17</vh>
<v t="edream.110203163054.2148"><vh>Allow @comment and @language to coexist</vh></v>
<v t="edream.110203163054.2149"><vh>Match routines all return false if pattern is None or empty</vh></v>
<v t="edream.110203163054.2150"><vh>Colorizer now recognizes comments after preprocessor directives</vh></v>
<v t="edream.110203163054.2151"><vh>Corrected reversion in set_delims_from_string</vh></v>
</v>
<v t="edream.110203163054.2152"><vh>10/16</vh>
<v t="edream.110203163054.2153"><vh>Added support for forth language comments</vh></v>
<v t="edream.110203163054.2154"><vh>Fixed another crasher in scanAllDirectives</vh></v>
<v t="edream.110203163054.2155"><vh>Fixed assert failure in putBodyPart</vh></v>
<v t="edream.110203163054.2156"><vh>Fixed crasher in scanAllDirectives</vh></v>
</v>
<v t="edream.110203163054.2157"><vh>10/15</vh>
<v t="edream.110203163054.2158"><vh>Added @raw support</vh></v>
<v t="edream.110203163054.2159"><vh>Changed names of commands in help menu and corresponding entries in leoConfig.leo</vh></v>
<v t="edream.110203163054.2160"><vh>Updated docs for recent features</vh></v>
</v>
<v t="edream.110203163054.2161"><vh>10/14</vh>
<v t="edream.110203163054.2162"><vh>All export commands now use output_newline option</vh></v>
<v t="edream.110203163054.2163"><vh>Forced focus to body pane after ending headline edit</vh></v>
<v t="edream.110203163054.2164"><vh>wrote "finished" after write @file nodes command</vh></v>
<v t="edream.110203163054.2165"><vh>Use @@ sentinels only for real Leo directives</vh></v>
</v>
<v t="edream.110203163054.2166"><vh>10/13 Rewrote colorizer using dispatch dict</vh></v>
<v t="edream.110203163054.2167"><vh>10/12</vh>
<v t="edream.110203163054.2168"><vh>Added Configuration Options item to help menu</vh></v>
</v>
<v t="edream.110203163054.2169"><vh>10/11</vh>
<v t="edream.110203163054.2170"><vh>added code to support output_newline option</vh></v>
<v t="edream.110203163054.2171"><vh>Fixed reversion in file write code</vh></v>
<v t="edream.110203163054.2172"><vh>Greatly simplified leoConfig.py</vh></v>
<v t="edream.110203163054.2173"><vh>Completed support for @quiet</vh></v>
<v t="edream.110203163054.2174"><vh>Syntax color perl's alarm function</vh></v>
</v>
<v t="edream.110203163054.2175"><vh>10/10</vh>
<v t="edream.110203163054.2176"><vh>Removed language bits</vh></v>
<v t="edream.110203163054.2177"><vh>Removed directive bits</vh></v>
<v t="edream.110203163054.2178"><vh>Used @q and @&gt; as sentinels in cweb mode</vh></v>
</v>
<v t="edream.110203163054.2179"><vh>10/9 (after 3.7 released)</vh>
<v t="edream.110203163054.2180"><vh>fixed Unicode bug in setBodyStringOrPane</vh></v>
<v t="edream.110203163054.2181"><vh>Created es_exception</vh></v>
<v t="edream.110203163054.2182"><vh>Added support for @rawfile (fixed bug in endEditLabel)</vh></v>
</v>
</v>
<v t="edream.110203163054.2183"><vh>10/09 Released 3.7</vh>
<v t="edream.110203163054.2184"><vh>10/8 Ran pychecker</vh></v>
<v t="edream.110203163054.2185"><vh>10/7 Improved error messages for Unicode errors</vh></v>
<v t="edream.110203163054.2186"><vh>10/6 leoOpen sets file name if it doesn't exist</vh></v>
<v t="edream.110203163054.2187"><vh>10/5 Leo now closes an empty window when opening a recent file</vh></v>
<v t="edream.110203163054.2188"><vh>10/4</vh>
<v t="edream.110203163054.2189"><vh>Improved handling of Latin-1 encoding</vh></v>
<v t="edream.110203163054.2190"><vh>Initialize all "config" section params to valid values</vh></v>
</v>
<v t="edream.110203163054.2191"><vh>10/3</vh>
<v t="edream.110203163054.2192"><vh>Removed all calls to decode</vh></v>
<v t="edream.110203163054.2193"><vh>Got information about encode/decode</vh>
<v t="edream.110203163054.2194"><vh>From  Martin v. Lwis (use unicode to interface with tk)</vh></v>
</v>
<v t="edream.110203163054.2195"><vh>Fixed Find previous bug</vh></v>
<v t="edream.110203163054.2196"><vh>Retained file modes when tangling and writing derived files</vh></v>
<v t="edream.110203163054.2197"><vh>Added remove_sentinels_extension option</vh></v>
</v>
<v t="edream.110203163054.2198"><vh>10/2 Changed find to findr when scanning @@ sentinels</vh></v>
</v>
</v>
<v t="edream.110203163054.2199"><vh>Sept 2002</vh>
<v t="edream.110203163054.2200"><vh>9/27</vh>
<v t="edream.110203163054.2201"><vh>Removed extra newline following @+leo directive</vh></v>
</v>
<v t="edream.110203163054.2202"><vh>9/26</vh>
<v t="edream.110203163054.2203"><vh>"Relative" node indices aren't</vh></v>
<v t="edream.110203163054.2204"><vh>Eliminated writing clone indices!</vh></v>
<v t="edream.110203163054.2205"><vh>Allowed reads and writes of cloned @file nodes</vh></v>
</v>
<v t="edream.110203163054.2206"><vh>9/25</vh>
<v t="edream.110203163054.2207"><vh>Added perlpod hack</vh></v>
<v t="edream.110203163054.2208"><vh>Added getBaseDirectory and used it to resolve relative paths</vh></v>
<v t="edream.110203163054.2209"><vh>Removed bodyKeepsFocus logic in leoTree.py</vh></v>
<v t="edream.110203163054.2210"><vh>Added code to various scanAllDirectives routines to create paths</vh></v>
<v t="edream.110203163054.2211"><vh>Created "path_directive_creates_directories" option</vh></v>
</v>
<v t="edream.110203163054.2212"><vh>9/24</vh>
<v t="edream.110203163054.2213"><vh>"Mysterious" changes to files were due to setting Page Width = 80</vh></v>
<v t="edream.110203163054.2214"><vh>Added code to configure headline colors</vh></v>
<v t="edream.110203163054.2215"><vh>Made the About Leo dialog non-modal</vh></v>
<v t="edream.110203163054.2216"><vh>Fixed bug that disabled all shortcuts</vh></v>
<v t="edream.110203163054.2217"><vh>Added support for Esc in shortcuts</vh></v>
<v t="edream.110203163054.2218"><vh>Added End Edit Headline and Abort Edit Headline commands</vh></v>
<v t="edream.110203163054.2219"><vh>Fixed undo cloned headline bug</vh></v>
</v>
<v t="edream.110203163054.2220"><vh>9/23 Finished user-configurable shortcuts</vh></v>
<v t="edream.110203163054.2221"><vh>9/21</vh>
<v t="edream.110203163054.2222"><vh>Fixed colorizing for "while" in C</vh></v>
<v t="edream.110203163054.2223"><vh>Leo now remembers insert point always</vh></v>
</v>
<v t="edream.110203163054.2224"><vh>9/20 Fixed tab problems</vh></v>
<v t="edream.110203163054.2225"><vh>9/19 Removed setup.py from binary distribution</vh></v>
<v t="edream.110203163054.2226"><vh>9/18 New file code: end of cursed newlines.</vh>
<v t="edream.110203163054.2227"><vh>Write only \n (Linux newlines) in derived files and .leo files</vh></v>
<v t="edream.110203163054.2228"><vh>Major change to atFile::read code</vh></v>
</v>
<v t="edream.110203163054.2229"><vh>9/15</vh>
<v t="edream.110203163054.2230"><vh>Added self=self to lambda definitions to keep Python 2.1 happy</vh></v>
<v t="edream.110203163054.2231"><vh>Folded all CVS changes into this file</vh></v>
</v>
<v t="edream.110203163054.2232"><vh>9/14 Added secondary pane ratios to leoConfig.txt</vh></v>
<v t="edream.110203163054.2233"><vh>9/13</vh>
<v t="edream.110203163054.2234"><vh>Folded Steven P. Schaefer's @first in @root code.</vh></v>
<v t="edream.110203163054.2235"><vh>Fixed "Unselected Ctrl-[ four times" bug</vh></v>
<v t="edream.110203163054.2236"><vh>Investigated reported font settings bug: works for me</vh></v>
<v t="edream.110203163054.2237"><vh>Incorporated Dave Heins code into getBodyLines</vh></v>
</v>
<v t="edream.110203163054.2238"><vh>9/12</vh>
<v t="edream.110203163054.2239"><vh>Fixed bug in updateBodyPane affecting Edit Body commands</vh></v>
<v t="edream.110203163054.2240"><vh>Suggested ISO-8859-15 instead of ISO-8859-1 in leoConfig.leo</vh></v>
<v t="edream.110203163054.2241"><vh>Generated PKG-INFO in Version Stuff section</vh></v>
<v t="edream.110203163054.2242"><vh>Fixed @language plain # bug.</vh></v>
<v t="edream.110203163054.2243"><vh>Improved enabling of menu items in popup menus</vh></v>
<v t="edream.110203163054.2244"><vh>Fixed @language plain single-quote bug</vh></v>
<v t="edream.110203163054.2245"><vh>Incorporated Dave Hein's "wrapping in doc part" bug fix</vh></v>
<v t="edream.110203163054.2246"><vh>Changed accelerator of Go To Next Changed to Alt-D</vh></v>
</v>
<v t="edream.110203163054.2247"><vh>9/11 Released 3.6</vh>
<v t="edream.110203163054.2248"><vh>9/11 Hacked colorizeAnyLanguage to support all PHP constructs</vh></v>
<v t="edream.110203163054.2249"><vh>9/11 Implemented @last</vh></v>
</v>
<v t="edream.110203163054.2250"><vh>9/9</vh>
<v t="edream.110203163054.2251"><vh>Removed most error messages in atFile::read logic</vh></v>
<v t="edream.110203163054.2252"><vh>Integrated changes in PHP changes into this file</vh></v>
</v>
<v t="edream.110203163054.2253"><vh>9/7</vh>
<v t="edream.110203163054.2254"><vh>9/7 and later: started to design the "Resolve CVS Conflicts command"</vh></v>
<v t="edream.110203163054.2255"><vh>Dave Hein: added new code to make Python window work on Linux.</vh></v>
</v>
<v t="edream.110203163054.2256"><vh>9/5 Fixed bugs in @path logic in tangle.scanAllDirectives</vh></v>
<v t="edream.110203163054.2257"><vh>9/4</vh>
<v t="edream.110203163054.2258"><vh>Tomaz Ficko: Added support for MouseWheel (Linux only)</vh></v>
<v t="edream.110203163054.2259"><vh>Steven P. Schaefer: Fixed cursed newline bug for Linux</vh></v>
</v>
<v t="edream.110203163054.2260"><vh>9/3</vh>
<v t="edream.110203163054.2261"><vh>Experimented with CVS Revision keyword in About box.</vh></v>
<v t="edream.110203163054.2262"><vh>Added Match Brackets command</vh></v>
<v t="edream.110203163054.2263"><vh>Added shortcuts for Read/Write @file Nodes commands</vh></v>
</v>
<v t="edream.110203163054.2264"><vh>9/2</vh>
<v t="edream.110203163054.2265"><vh>Steven P. Schaefer: Improved handling of directives in @root trees</vh></v>
<v t="edream.110203163054.2266"><vh>Dave Hein: added CheckVersion to leoUtils.py</vh></v>
<v t="edream.110203163054.2267"><vh>Dave Hein: fixed Tk 8.4 problem in Prefs Panel</vh></v>
<v t="edream.110203163054.2268"><vh>Body pane now gets focus after Go Back/Next</vh></v>
<v t="edream.110203163054.2269"><vh>Changed leoTangle.scanAllDirectives</vh></v>
<v t="edream.110203163054.2270"><vh>Leo now remembers scrollbar positions</vh></v>
<v t="edream.110203163054.2271"><vh>Removed windows newlines in leoConfig.update</vh></v>
<v t="edream.110203163054.2272"><vh>Improved call to os.path.join in leoApp.finishCreate</vh></v>
</v>
<v t="edream.110203163054.2273"><vh>9/1</vh>
<v t="edream.110203163054.2274"><vh>Saved edit position of tnodes</vh></v>
<v t="edream.110203163054.2275"><vh>Investigated @language for @root trees</vh></v>
<v t="edream.110203163054.2276"><vh>Fixed missing headline bug on startup</vh></v>
<v t="edream.110203163054.2277"><vh>Changed all os.rename to utils_rename</vh></v>
<v t="edream.110203163054.2278"><vh>Changed mode in leoConfig::update</vh></v>
</v>
</v>
<v t="edream.110203163054.2279"><vh>Aug 2002</vh>
<v t="edream.110203163054.2280"><vh>8/24</vh>
<v t="edream.110203163054.2281"><vh>Added version to url for online tutorial</vh></v>
<v t="edream.110203163054.2282"><vh>Improved About Leo dialog</vh></v>
<v t="edream.110203163054.2283"><vh>Improved dowloading of sbooks.chm</vh></v>
</v>
<v t="edream.110203163054.2284"><vh>8/15</vh>
<v t="edream.110203163054.2285"><vh>prototyped window icons in Tk</vh></v>
<v t="edream.110203163054.2286"><vh>Attempted to make mouse wheel functional in tree pane</vh></v>
<v t="edream.110203163054.2287"><vh>Rewrote About Leo dialog with icon &amp; hyperlinks</vh></v>
<v t="edream.110203163054.2288"><vh>Improved download dialog in Help-Tutorial command</vh></v>
</v>
<v t="edream.110203163054.2289"><vh>8/14 Released 3.5</vh>
<v t="edream.110203163054.2290"><vh>Corrected wrapping in log window when horizontal scrollbar is present</vh></v>
<v t="edream.110203163054.2291"><vh>Released 3.5</vh></v>
<v t="edream.110203163054.2292"><vh>Added log_pane_wraps and outline_pane_scrolls_horizontally params</vh></v>
<v t="edream.110203163054.2293"><vh>Fixed Tangle logic</vh></v>
</v>
<v t="edream.110203163054.2294"><vh>8/13 Bugs, bugs, bugs</vh>
<v t="edream.110203163054.2295"><vh>called cf.flush in leoConfig.update</vh></v>
<v t="edream.110203163054.2296"><vh>Open url's from help menu</vh></v>
<v t="edream.110203163054.2297"><vh>Rewrote path logic</vh></v>
<v t="edream.110203163054.2298"><vh>Warn on read-only files</vh></v>
<v t="edream.110203163054.2299"><vh>Hacked on leoAtFile.scanAllDirectives to fix directory problem</vh></v>
<v t="edream.110203163054.2300"><vh>Fixed (?) cursed newline bug in leoAtFile</vh></v>
</v>
<v t="edream.110203163054.2301"><vh>8/11 Released 3.4</vh>
<v t="edream.110203163054.2302"><vh>Fixed crasher when leoConfig.txt does not exist</vh></v>
<v t="edream.110203163054.2303"><vh>Fixed bug in leoFileCommands.readOutlineOnly</vh></v>
<v t="edream.110203163054.2304"><vh>Wrote importFiles script in leoImport.leo</vh></v>
<v t="edream.110203163054.2305"><vh>Released 3.4</vh></v>
<v t="edream.110203163054.2306"><vh>Syntax colorer now honors @comment</vh></v>
</v>
<v t="edream.110203163054.2307"><vh>8/10</vh>
<v t="edream.110203163054.2308"><vh>Added save_clears_undo_buffer configuration option</vh></v>
<v t="edream.110203163054.2309"><vh>Improved Recent Files menu</vh></v>
</v>
<v t="edream.110203163054.2310"><vh>8/9 Fixed Unicode Bugs</vh></v>
<v t="edream.110203163054.2311"><vh>8/6</vh>
<v t="edream.110203163054.2312"><vh>Corrected problems with find/prefs settings</vh></v>
<v t="edream.110203163054.2313"><vh>created leoConfig.leo</vh></v>
<v t="edream.110203163054.2314"><vh>Fixed a bug in config.setDict (!) (This fixes font problems)</vh></v>
<v t="edream.110203163054.2315"><vh>Leo writes split direction to leoConfig.txt</vh></v>
<v t="edream.110203163054.2316"><vh>Leo writes prefs if leoConfig.txt is read-only</vh></v>
</v>
<v t="edream.110203163054.2317"><vh>8/5 Leo honors pane ratio stored in .leo files</vh></v>
<v t="edream.110203163054.2318"><vh>8/4</vh>
<v t="edream.110203163054.2319"><vh>Improved highlighting of whitespace</vh></v>
<v t="edream.110203163054.2320"><vh>Fixed revert problems in font panel</vh></v>
<v t="edream.110203163054.2321"><vh>Added @ignore to "raw" imported files</vh></v>
<v t="edream.110203163054.2322"><vh>Remove Sentinels command now uses .txt extension instead of .tmp</vh></v>
<v t="edream.110203163054.2323"><vh>Added log message for Remove Sentinels command</vh></v>
<v t="edream.110203163054.2324"><vh>Corrected spelling of limit_directory_search_extenstion </vh></v>
<v t="edream.110203163054.2325"><vh>Fixed wandering insertion point bug</vh></v>
</v>
<v t="edream.110203163054.2326"><vh>8/3</vh>
<v t="edream.110203163054.2327"><vh>looked for backticks</vh></v>
<v t="edream.110203163054.2328"><vh>Cleaned up files using nested compares</vh></v>
<v t="edream.110203163054.2329"><vh>Fixed another clone bug: created setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="edream.110203163054.2330"><vh>Released 3.3</vh></v>
</v>
<v t="edream.110203163054.2331"><vh>8/2</vh>
<v t="edream.110203163054.2332"><vh>Leo supports Unicode !!</vh></v>
<v t="edream.110203163054.2333"><vh>changed skip_long to handle negative values</vh></v>
<v t="edream.110203163054.2334"><vh>initialized atFile.default_directory to None</vh></v>
<v t="edream.110203163054.2335"><vh>eliminated both presentLanguage and targetLanguage ivars from leoAtFile</vh></v>
<v t="edream.110203163054.2336"><vh>Removed default param from set_language</vh></v>
</v>
<v t="edream.110203163054.2337"><vh>8/1</vh>
<v t="edream.110203163054.2338"><vh>Fixed crasher in leoTangle.putDoc</vh></v>
<v t="edream.110203163054.2339"><vh>Fixed problems with negative tab widths</vh></v>
<v t="edream.110203163054.2340"><vh>Fixed the "delims botch"</vh></v>
<v t="edream.110203163054.2341"><vh>Made 'additional_body_text_border' setting functional</vh></v>
<v t="edream.110203163054.2342"><vh>Made 'body_pane_wraps' setting functional</vh></v>
<v t="edream.110203163054.2343"><vh>Fixed config tables</vh></v>
<v t="edream.110203163054.2344"><vh>Initialized leoAtFile properly</vh></v>
</v>
</v>
<v t="edream.110203163054.2345"><vh>July 2002</vh>
<v t="edream.110203163054.2346"><vh>7/30 Fixed many bugs in Color panel</vh></v>
<v t="edream.110203163054.2347"><vh>7/30 Proved that Leo handles nested @others directives properly</vh>
<v t="edream.110203163054.2348"><vh>Proof that nested @others directives are valid</vh></v>
</v>
<v t="edream.110203163054.2349"><vh>7/29</vh>
<v t="edream.110203163054.2350"><vh>7/29 Fixed bug in skip_pp_if and added skip_pp_part</vh></v>
<v t="edream.110203163054.2351"><vh>7/29 Added @ignore to the root of all imported trees</vh></v>
<v t="edream.110203163054.2352"><vh>7/29 Fixed bug in scanPythonDef.&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="edream.110203163054.2353"><vh>7/29 Improved import of classes</vh></v>
<v t="edream.110203163054.2354"><vh>7/29 Relaxed the rules for @others: allowed @others within @others tree</vh></v>
<v t="edream.110203163054.2355"><vh>7/29 Added glossary entries</vh></v>
<v t="edream.110203163054.2356"><vh>7/29 Fixed crasher in Prefs onCancel</vh></v>
<v t="edream.110203163054.2357"><vh>7/29 Fixed problems with Outline/Move/Select Go commands</vh></v>
<v t="edream.110203163054.2358"><vh>7/29 Added email address &amp; URL to About Leo dialog</vh></v>
<v t="edream.110203163054.2359"><vh>7/29 Fixed import bug</vh></v>
</v>
<v t="edream.110203163054.2360"><vh>7/27 Continued comments for lines ending in \</vh></v>
<v t="edream.110203163054.2361"><vh>7/24 Added @file disStats.py</vh></v>
<v t="edream.110203163054.2362"><vh>7/24 Added leo.profile()</vh></v>
<v t="edream.110203163054.2363"><vh>7/20 Released 3.1</vh>
<v t="edream.110203163054.2364"><vh>7/20 Finished Compare panel code, including using leoConfig.txt params</vh></v>
</v>
<v t="edream.110203163054.2365"><vh>7/19</vh>
<v t="edream.110203163054.2366"><vh>7/19 Leo now adds path to Idle automatically</vh></v>
<v t="edream.110203163054.2367"><vh>7/19 Fixed bug that caused leo.py not to run</vh></v>
<v t="edream.110203163054.2368"><vh>7/19 Completed the visual design of the Compare panel</vh></v>
</v>
<v t="edream.110203163054.2369"><vh>7/18</vh>
<v t="edream.110203163054.2370"><vh>7/18 Revised leoCompare.py</vh></v>
<v t="edream.110203163054.2371"><vh>7/18 Changed precedence scheme for preferences</vh></v>
<v t="edream.110203163054.2372"><vh>7/18 Added support for @language tcl/tk</vh></v>
<v t="edream.110203163054.2373"><vh>7/18 Fixed major bugs in skip_long &amp; tangle.scanAllDirectives!</vh></v>
</v>
<v t="edream.110203163054.2374"><vh>7/17</vh>
<v t="edream.110203163054.2375"><vh>7/17 v.moreBody now only escapes first non-blank character on a line</vh></v>
<v t="edream.110203163054.2376"><vh>7/17 Told where to download Python 2.2 and Tk 8.3 In 2.2 required dialog</vh>
<v t="edream.110203163054.2377"><vh>7/17 Added optional text param to leoDialog.askOk</vh></v>
<v t="edream.110203163054.2378"><vh>7/17 Tried closing Leo window during a long write</vh></v>
<v t="edream.110203163054.2379"><vh>7/17 The compare window is important!</vh></v>
</v>
</v>
<v t="edream.110203163054.2380"><vh>7/16 Released 3.0</vh>
<v t="edream.110203163054.2381"><vh>7/16 Added leoConfig.txt to manifest</vh></v>
<v t="edream.110203163054.2382"><vh>7/16 Did spellcheck on LeoDocs.leo using MS Word</vh></v>
<v t="edream.110203163054.2383"><vh>7/16 Fixed autoscrolling so it can stop</vh></v>
<v t="edream.110203163054.2384"><vh>7/16 Ran pychecker</vh></v>
<v t="edream.110203163054.2385"><vh>7/16 Called traceback.print_exc for all serious exceptions</vh></v>
</v>
<v t="edream.110203163054.2386"><vh>7/15 Leo code complete</vh>
<v t="edream.110203163054.2387"><vh>7/15 Adjusted tree to handle larger font size</vh></v>
<v t="edream.110203163054.2388"><vh>7/15 Make Convert All Blanks and Convert All Tabs undoable</vh></v>
<v t="edream.110203163054.2389"><vh>7/15 ** Speeded up autoscrolling enough to be useful</vh></v>
<v t="edream.110203163054.2390"><vh>7/15 New windows now open using config params.</vh></v>
<v t="edream.110203163054.2391"><vh>7/15 Cleaned up how windows are opened</vh></v>
<v t="edream.110203163054.2392"><vh>7/15 Fixed bug that disabled window positioning!</vh></v>
<v t="edream.110203163054.2393"><vh>7/15 Changed config getters to get from defaults</vh></v>
<v t="edream.110203163054.2394"><vh>7/15 Added code to support font prefs.</vh></v>
<v t="edream.110203163054.2395"><vh>7/15 Added frame code to support non-modal panes</vh></v>
</v>
<v t="edream.110203163054.2396"><vh>Earlier</vh>
<v t="edream.110203163054.2397"><vh>7/14</vh>
<v t="edream.110203163054.2398"><vh>7/13 Added default tables to config module</vh></v>
<v t="edream.110203163054.2399"><vh>7/13 Added name picker to color panel</vh></v>
<v t="edream.110203163054.2400"><vh>7/13 Finished handlers for Font frame</vh></v>
</v>
<v t="edream.110203163054.2401"><vh>7/12</vh>
<v t="edream.110203163054.2402"><vh>7/12 Font &amp; color panels need not be modal !</vh></v>
<v t="edream.110203163054.2403"><vh>7/12 Finished Tk work on Font frame</vh></v>
</v>
<v t="edream.110203163054.2404"><vh>7/11</vh>
<v t="edream.110203163054.2405"><vh>7/11 Fixed syntax coloring bug</vh></v>
<v t="edream.110203163054.2406"><vh>7/11 Lots of work on preferences and color panel</vh></v>
</v>
<v t="edream.110203163054.2407"><vh>7/10 File (and clipboard) format changed!</vh>
<v t="edream.110203163054.2408"><vh>7/10 Allowed "ISO-8859-1" specification</vh></v>
<v t="edream.110203163054.2409"><vh>7/10 Warn and abort if not Python 2.2 or above</vh></v>
<v t="edream.110203163054.2410"><vh>7/10 app.finishCreate checks for Python 2.2 or higher</vh></v>
<v t="edream.110203163054.2411"><vh>7/10 Cleaned up Recent Files menu code</vh></v>
<v t="edream.110203163054.2412"><vh>7/10 All panels now have labeled frames and grooved borders</vh></v>
<v t="edream.110203163054.2413"><vh>7/10 Created leoFontPanel.py and added leoColorPanel class to leoColor.py</vh></v>
</v>
<v t="edream.110203163054.2414"><vh>7/9 Created create_labeled_frame and Font and Colors panels</vh></v>
<v t="edream.110203163054.2415"><vh>7/8</vh>
<v t="edream.110203163054.2416"><vh>7/8 Improved syntax coloring</vh></v>
<v t="edream.110203163054.2417"><vh>7/8 The REM hack &amp; fixed crasher</vh></v>
<v t="edream.110203163054.2418"><vh>7/8 Fixed crasher in atFile.scanAllDirectives</vh></v>
<v t="edream.110203163054.2419"><vh>7/8 Finished Toggle Split Direction</vh></v>
</v>
</v>
<v t="edream.110203163054.2420"><vh>leo.py 2.5 and earlier</vh>
<v t="edream.110203163054.2421"><vh>7/7</vh>
<v t="edream.110203163054.2422"><vh>7/7 Fixed crashers when undoing or redoing moves</vh></v>
<v t="edream.110203163054.2423"><vh>7/7 Updated LeoDocs.leo and Leo's web site</vh></v>
<v t="edream.110203163054.2424"><vh>7/7 Released 2.5 and updated CVS</vh></v>
</v>
<v t="edream.110203163054.2425"><vh>7/6 version 2.5 is now code complete</vh>
<v t="edream.110203163054.2426"><vh>7/6 Improved Import to @root</vh></v>
<v t="edream.110203163054.2427"><vh>7/6 Fixed Import bug: empty classes and nested classes</vh></v>
<v t="edream.110203163054.2428"><vh>7/6 Fixed Import bug that caused orphan nodes</vh></v>
<v t="edream.110203163054.2429"><vh>7/6 Fixed Import bug that caused duplicate class lines.</vh></v>
<v t="edream.110203163054.2430"><vh>7/6 Renamed Font to Set Font... and Syntax Coloring... to Set Colors...</vh></v>
<v t="edream.110203163054.2431"><vh>7/6 Created c.initJoinedCloneBits</vh></v>
<v t="edream.110203163054.2432"><vh>7/6 Verified that undo works</vh></v>
</v>
<v t="edream.110203163054.2433"><vh>7/5</vh>
<v t="edream.110203163054.2434"><vh>7/5 Made extract commands undoable &amp; simplified undo.</vh></v>
<v t="edream.110203163054.2435"><vh>7/5 Made import commands undoable.</vh></v>
<v t="edream.110203163054.2436"><vh>7/5 Discovered traceback module</vh></v>
<v t="edream.110203163054.2437"><vh>7/5 Made Cascade command functional</vh></v>
<v t="edream.110203163054.2438"><vh>7/5 Enabled Minimize All command</vh></v>
<v t="edream.110203163054.2439"><vh>7/5 Forced syntax coloring after extract commands</vh></v>
</v>
<v t="edream.110203163054.2440"><vh>7/4</vh>
<v t="edream.110203163054.2441"><vh>7/4 Find/Change settings can be overridden by leoConfig.txt</vh></v>
<v t="edream.110203163054.2442"><vh>7/4 Invalid directories are no longer errors in leoAtFiles.scanAllDirectives</vh></v>
<v t="edream.110203163054.2443"><vh>7/4 Prefs now can be overridden by leoConfig.txt</vh></v>
</v>
<v t="edream.110203163054.2444"><vh>7/3</vh>
<v t="edream.110203163054.2445"><vh>7/3 Added Convert All Blanks and Convert All Tabs commands</vh></v>
<v t="edream.110203163054.2446"><vh>7/3 Added Convert Tabs command</vh></v>
<v t="edream.110203163054.2447"><vh>7/3 Changed tabs to blanks when tab width is negative</vh></v>
<v t="edream.110203163054.2448"><vh>7/3 Changed c.tab/page_width to self.tab/page_width in leoAtFile.py</vh></v>
<v t="edream.110203163054.2449"><vh>7/3 Added OK, Cancel, Revert buttons to Prefs panel</vh></v>
<v t="edream.110203163054.2450"><vh>7/3 Added window name to Prefs title</vh></v>
<v t="edream.110203163054.2451"><vh>7/3 Added @language python to all @file nodes</vh></v>
</v>
<v t="edream.110203163054.2452"><vh>7/2</vh>
<v t="edream.110203163054.2453"><vh>7/2 Changed defaultextension from "x" to ".x"</vh></v>
<v t="edream.110203163054.2454"><vh>7/2 Made prefs a modal dialog</vh></v>
<v t="edream.110203163054.2455"><vh>7/2 About c.defaultDirectory</vh></v>
<v t="edream.110203163054.2456"><vh>7/2 Changed Save and Save As...</vh></v>
<v t="edream.110203163054.2457"><vh>7/2 Fixed crashers in Remove Sentinels command</vh></v>
<v t="edream.110203163054.2458"><vh>7/2 Fixed crasher in import.scanAllDirectives)</vh></v>
<v t="edream.110203163054.2459"><vh>7/2 Hacked code so tab width works</vh></v>
<v t="edream.110203163054.2460"><vh>7/2 Fixed doc problems</vh>
<v t="edream.110203163054.2461"><vh>Demote docs</vh></v>
<v t="edream.110203163054.2462"><vh>Open/Close log window docs</vh></v>
<v t="edream.110203163054.2463"><vh>Insert Headline docs</vh></v>
<v t="edream.110203163054.2464"><vh>Extract Section docs</vh></v>
<v t="edream.110203163054.2465"><vh>Syntax Coloring... &amp; Font...</vh></v>
</v>
</v>
<v t="edream.110203163054.2466"><vh>7/1 Cut/Paste now works properly</vh></v>
</v>
</v>
<v t="edream.110203163054.2467"><vh>June 2002	</vh>
<v t="edream.110203163054.2468"><vh>06/22 Implemented Recent Files menu &amp; leoConfig.py</vh></v>
<v t="edream.110203163054.2469"><vh>06/19 Removed assert from st_enter_root_name</vh></v>
<v t="edream.110203163054.2470"><vh>06/18 Improved error recovery when writing .leo files</vh></v>
<v t="edream.110203163054.2471"><vh>06/16 Changed leo.py so Leo can open files when files are double-clicked</vh></v>
<v t="edream.110203163054.2472"><vh>06/16 Finished updating LeoDocs.leo to match Leo's web site</vh></v>
<v t="edream.110203163054.2473"><vh>06/15 Fixed the control-I and control-H bugs</vh></v>
<v t="edream.110203163054.2474"><vh>06/15 Double clicking in a headline now selects a word</vh></v>
<v t="edream.110203163054.2475"><vh>06/15 Implemented Drag and Drop</vh></v>
<v t="edream.110203163054.2476"><vh>06/04 Changed atFile.scanAllDirectives to use c.openDirectory as default</vh></v>
<v t="edream.110203163054.2477"><vh>06/03 Changed cursor to double arrow when cursor is over splitter bars</vh></v>
<v t="edream.110203163054.2478"><vh>06/02 Bug fix in es in leoGlobals</vh></v>
<v t="edream.110203163054.2479"><vh>06/02 Tried and failed to call wm_iconbitmap</vh></v>
</v>
<v t="edream.110203163054.2480"><vh>May 2002</vh>
<v t="edream.110203163054.2481"><vh>5/30/02 Move theory of operation sections back into this outline</vh></v>
<v t="edream.110203163054.2482"><vh>5/27/02 Undo move down doesn't always work</vh></v>
<v t="edream.110203163054.2483"><vh>5/27/02 Fixed bugs involving changing roots</vh></v>
<v t="edream.110203163054.2484"><vh>5/27/02 Handled unicode error in leoFileCommands::put</vh></v>
<v t="edream.110203163054.2485"><vh>5/13/02 LeoPy.leo corrupted</vh></v>
</v>
<v t="edream.110203163054.2486"><vh>April 2002</vh>
<v t="edream.110203163054.2487"><vh>4/27/02 Started Remove Sentinels command</vh></v>
<v t="edream.110203163054.2488"><vh>4/27/02 Changes to Export Noweb command</vh></v>
<v t="edream.110203163054.2489"><vh>4/25/02 Added code to os()</vh></v>
<v t="edream.110203163054.2490"><vh>4/7/02 Added frame.outlineToNowebDefaultFileName ivar</vh></v>
<v t="edream.110203163054.2491"><vh>4/7/02 Replaced &lt;&lt;*&gt;&gt;= with &lt;&lt;fileName&gt;&gt;= whenever possible</vh></v>
<v t="edream.110203163054.2492"><vh>4/7/02 Added code to make @ defs not start a doc part</vh></v>
<v t="edream.110203163054.2493"><vh>4/7/02 Added warnings for all non-undoable import commands</vh></v>
</v>
<v t="edream.110203163054.2494"><vh>March 2002</vh>
<v t="edream.110203163054.2495"><vh>3/16 Fixed moves up to root postion</vh></v>
<v t="edream.110203163054.2496"><vh>3/16 Simplified syntax colorer for docState</vh></v>
<v t="edream.110203163054.2497"><vh>3/10 Rewrote skipLeadingComments</vh></v>
<v t="edream.110203163054.2498"><vh>3/08 Modified colorer for CWEB</vh></v>
<v t="edream.110203163054.2499"><vh>3/07 Color strings green</vh></v>
<v t="edream.110203163054.2500"><vh>3/07 Rewrote importWebCommand and its allies</vh></v>
<v t="edream.110203163054.2501"><vh>3/06 Import/Export commands</vh>
<v t="edream.110203163054.2502"><vh>3/06 Outline To Noweb works (as well as it is going to)</vh></v>
<v t="edream.110203163054.2503"><vh>3/06 Flatten Outline and Import Flattened Outline work</vh></v>
<v t="edream.110203163054.2504"><vh>3/06 Python, C, Java and Pascal Imports now work</vh></v>
</v>
<v t="edream.110203163054.2505"><vh>3/05 Import commands, colorizer, clear IDLE breakpoints</vh>
<v t="edream.110203163054.2506"><vh>3/05 Import commands, colorizer</vh></v>
<v t="edream.110203163054.2507"><vh>3/05 Added ability to clear breakpoints in IDLE</vh></v>
</v>
<v t="edream.110203163054.2508"><vh>3/04 Released leo.py 2.0 and Borland v2.6</vh>
<v t="edream.110203163054.2509"><vh>3/04 Improved read error messages.</vh></v>
<v t="edream.110203163054.2510"><vh>3/04 Untangle calls v.trimTrailingLines only for changed nodes</vh></v>
<v t="edream.110203163054.2511"><vh>3/04 changed v.setBodyStringOrPane</vh></v>
<v t="edream.110203163054.2512"><vh>3/04 Added finished messages for Tangle/Untangle</vh></v>
</v>
<v t="edream.110203163054.2513"><vh>3/03 Fixed Untangle, </vh>
<v t="edream.110203163054.2514"><vh>3/03 Created readme files</vh></v>
<v t="edream.110203163054.2515"><vh>3/03 Fixed Untangle bug</vh></v>
</v>
<v t="edream.110203163054.2516"><vh>3/02 Finished Undo, Preparing for release</vh>
<v t="edream.110203163054.2517"><vh>3/02 Created distutils files to distribute Borland Leo</vh></v>
<v t="edream.110203163054.2518"><vh>3/02 Created release notes for Borland v2.6</vh></v>
<v t="edream.110203163054.2519"><vh>3/02 Documented new commands and features</vh></v>
<v t="edream.110203163054.2520"><vh>3/02 Fixed all pychecker complaints against leoImport.py</vh></v>
<v t="edream.110203163054.2521"><vh>3/02 Added @space to Utils &amp; Tangle/Untangle code in LeoCB</vh></v>
<v t="edream.110203163054.2522"><vh>3/02 Completed Undo Change All</vh></v>
</v>
<v t="edream.110203163054.2523"><vh>3/01 Finished Tangle, Finished v2.6, etc.</vh>
<v t="edream.110203163054.2524"><vh>3/01 Completely supress all auto-indent in @nocolor mode</vh></v>
<v t="edream.110203163054.2525"><vh>3/01 Tangle now works exactly like LeoCB Tangle</vh></v>
<v t="edream.110203163054.2526"><vh>3/01 Finished Borland version 2.6</vh></v>
</v>
</v>
<v t="edream.110203163054.2527"><vh>Feb 2002</vh>
<v t="edream.110203163054.2528"><vh>2/28 Small fixes</vh>
<v t="edream.110203163054.2529"><vh>Tangle now treats @c like @code</vh></v>
<v t="edream.110203163054.2530"><vh>Changed is_special_bits</vh></v>
<v t="edream.110203163054.2531"><vh>Installed Johansson patches</vh></v>
</v>
<v t="edream.110203163054.2532"><vh>2/27 pychecker(!), colorizer bug</vh>
<v t="edream.110203163054.2533"><vh>2/27 Fixed bug in colorizer</vh></v>
<v t="edream.110203163054.2534"><vh>2/27 Discovered pychecker (several bug fixes)</vh>
<v t="edream.110203163054.2535"><vh>Fixed bug in Mark Changed Roots</vh></v>
<v t="edream.110203163054.2536"><vh>Fixed bug in scanText related to @delims sentinel</vh></v>
<v t="edream.110203163054.2537"><vh>Fixed bug in write</vh></v>
<v t="edream.110203163054.2538"><vh>Fixed bugs in leoFileCommands</vh></v>
<v t="edream.110203163054.2539"><vh>Fixed bugs in leoNodes</vh></v>
<v t="edream.110203163054.2540"><vh>Fixed bugs in leoTangle</vh></v>
</v>
</v>
<v t="edream.110203163054.2541"><vh>2/26 LeoCB can read compressed derived files</vh></v>
<v t="edream.110203163054.2542"><vh>2/25 Fixed IDLE, added verbatimAfterRef sentinel</vh>
<v t="edream.110203163054.2543"><vh>2/25 Fixed breakpoints in IDLE</vh></v>
<v t="edream.110203163054.2544"><vh>2/25 Added verbatimAfterRef sentinel</vh></v>
</v>
<v t="edream.110203163054.2545"><vh>2/24 suppressing newlines</vh></v>
<v t="edream.110203163054.2546"><vh>2/23 Untangle, colorizer bug</vh>
<v t="edream.110203163054.2547"><vh>2/23 Debugging untangle: fixed leading single-comments bug</vh></v>
<v t="edream.110203163054.2548"><vh>2/23 Fixed small colorizing bug</vh></v>
</v>
<v t="edream.110203163054.2549"><vh>2/22 askOKCancel dialog, suppressing auto-indent.</vh>
<v t="edream.110203163054.2550"><vh>2/22 Created askOkCancel dialog for Read @file Nodes</vh></v>
<v t="edream.110203163054.2551"><vh>2/22 Supressed auto-indent in @nocolor mode.</vh></v>
</v>
<v t="edream.110203163054.2552"><vh>2/20 and 2/21 Debugged Untangle</vh></v>
<v t="edream.110203163054.2553"><vh>2/19 Improved Unlimited Undo</vh></v>
<v t="edream.110203163054.2554"><vh>2/18 Unlimited Undo works</vh></v>
<v t="edream.110203163054.2555"><vh>2/16 Syntax coloring</vh>
<v t="edream.110203163054.2556"><vh>2/16 Fixed bugs in colorAnyLanguage</vh></v>
<v t="edream.110203163054.2557"><vh>2/16 Finished adding keywords for colorAnyLanguage</vh></v>
</v>
<v t="edream.110203163054.2558"><vh>2/15 Syntax coloring, undo, @space bug</vh>
<v t="edream.110203163054.2559"><vh>02/15 Created colorAnyLanguage</vh></v>
<v t="edream.110203163054.2560"><vh>02/15 Fixed @space bug</vh></v>
<v t="edream.110203163054.2561"><vh>02/15 Bug fix: section definition lines now end coloring for doc parts</vh></v>
<v t="edream.110203163054.2562"><vh>02/15 Finished Limited undo.</vh></v>
<v t="edream.110203163054.2563"><vh>02/15 Added files to manifest</vh></v>
</v>
<v t="edream.110203163054.2564"><vh>02/14 CVS</vh>
<v t="edream.110203163054.2565"><vh>02/14 Fixed Undo problems</vh></v>
<v t="edream.110203163054.2566"><vh>02/14 Checked out Leo from CVS</vh></v>
<v t="edream.110203163054.2567"><vh>02/14 Cant mend clones, How to use CVS</vh>
<v t="edream.110203163054.2568"><vh>CVS: Making a virtue out of necessity</vh></v>
<v t="edream.110203163054.2569"><vh>Ooops: Leo can't mend clone links!</vh></v>
<v t="edream.110203163054.2570"><vh>Completed Mending dialog</vh></v>
</v>
</v>
<v t="edream.110203163054.2571"><vh>02/13 Mending clone links, undo</vh>
<v t="edream.110203163054.2572"><vh>Made the undo class partly functional</vh></v>
<v t="edream.110203163054.2573"><vh>Created menu utilities</vh></v>
<v t="edream.110203163054.2574"><vh>Fixed bug in Extract and Extract Section commands</vh></v>
</v>
<v t="edream.110203163054.2575"><vh>02/12 Minor fixes</vh>
<v t="edream.110203163054.2576"><vh>Studied the DnD code</vh></v>
<v t="edream.110203163054.2577"><vh>Cleared tab and space tags in colorizePython</vh></v>
<v t="edream.110203163054.2578"><vh>Made headlines longer</vh></v>
<v t="edream.110203163054.2579"><vh>Cleaned code</vh></v>
</v>
<v t="edream.110203163054.2580"><vh>02/11 experiments</vh>
<v t="edream.110203163054.2581"><vh>created sortSequence utility</vh></v>
<v t="edream.110203163054.2582"><vh>experimented with inspect</vh></v>
</v>
<v t="edream.110203163054.2583"><vh>02/10 1.0 released</vh>
<v t="edream.110203163054.2584"><vh>Removed "from x import *" from reload_all() and OnOpenPythonWindow'</vh></v>
<v t="edream.110203163054.2585"><vh>Released 1.0</vh></v>
<v t="edream.110203163054.2586"><vh>Added Contract Parent (Alt-0)</vh></v>
<v t="edream.110203163054.2587"><vh>Fixed bugs in Prefs panel</vh></v>
</v>
<v t="edream.110203163054.2588"><vh>02/09 Preparing for release</vh>
<v t="edream.110203163054.2589"><vh>02/09 Got clean import of leoImport.py</vh></v>
<v t="edream.110203163054.2590"><vh>02/09 Created do-nothing leoUndo.py</vh></v>
<v t="edream.110203163054.2591"><vh>02/09 Updated current language properly in Prefs panel</vh></v>
<v t="edream.110203163054.2592"><vh>02/09 Re-marked @file nodes dirty on write errors</vh></v>
<v t="edream.110203163054.2593"><vh>02/09 Prefs Panel stick to current window</vh></v>
<v t="edream.110203163054.2594"><vh>02/09 Tangle passes full regression test</vh></v>
<v t="edream.110203163054.2595"><vh>02/09 Added Sort Siblings</vh></v>
</v>
<v t="edream.110203163054.2596"><vh>02/08 Regression testing</vh>
<v t="edream.110203163054.2597"><vh>02/08 Found Tangle problem</vh></v>
<v t="edream.110203163054.2598"><vh>02/08 Cleaned up leoCompare.py</vh></v>
<v t="edream.110203163054.2599"><vh>02/08 @c in Tangled files</vh></v>
<v t="edream.110203163054.2600"><vh>02/08 Testing wiped out files!</vh></v>
</v>
<v t="edream.110203163054.2601"><vh>02/07 New commands and bug fixes</vh>
<v t="edream.110203163054.2602"><vh>02/07 Possible reversion</vh></v>
<v t="edream.110203163054.2603"><vh>02/07 Converted Import Files code</vh></v>
<v t="edream.110203163054.2604"><vh>02/07 Search suboutline only now applies to Search/ChangeAll</vh></v>
<v t="edream.110203163054.2605"><vh>02/07 Fixed bug in search()</vh></v>
<v t="edream.110203163054.2606"><vh>02/07 Fixed bug: @others wasn't colored unless at left margin.</vh></v>
<v t="edream.110203163054.2607"><vh>02/07 * Added indent and undent commands</vh></v>
<v t="edream.110203163054.2608"><vh>02/07 * Improved idle_body_key</vh></v>
</v>
<v t="edream.110203163054.2609"><vh>02/06 Finished commands</vh>
<v t="edream.110203163054.2610"><vh>02/06 Rewrote and tested all Edit Body commands</vh></v>
<v t="edream.110203163054.2611"><vh>02/06 Rewrote and tested Convert Blanks command</vh></v>
<v t="edream.110203163054.2612"><vh>02/06 Removed Print and Page Setup commands</vh></v>
<v t="edream.110203163054.2613"><vh>02/06 * Implemented View All Characters</vh></v>
<v t="edream.110203163054.2614"><vh>02/06 Got the arrow binding right</vh></v>
<v t="edream.110203163054.2615"><vh>02/06 finished Delete command</vh></v>
<v t="edream.110203163054.2616"><vh>02/06 created tree.onBodyChanged</vh></v>
<v t="edream.110203163054.2617"><vh>02/06 rewrote and tested Revert</vh></v>
<v t="edream.110203163054.2618"><vh>02/06 created leoDialog.yesNo</vh></v>
</v>
<v t="edream.110203163054.2619"><vh>2/05 More bug fixes</vh>
<v t="edream.110203163054.2620"><vh>02/05 * Extended Sherlock</vh></v>
<v t="edream.110203163054.2621"><vh>02/05 * Properly enabled and disabled all menu items</vh></v>
<v t="edream.110203163054.2622"><vh>02/05 Got special accelerator keys working</vh></v>
<v t="edream.110203163054.2623"><vh>02/05 GoTo commands now working</vh></v>
<v t="edream.110203163054.2624"><vh>02/05 Got Alt-keys working</vh></v>
<v t="edream.110203163054.2625"><vh>02/05 Made es and trace safer during quit</vh></v>
<v t="edream.110203163054.2626"><vh>02/05 Fixed bugs in Search Headline and Find, Then Change</vh></v>
<v t="edream.110203163054.2627"><vh>02/05 Do not eliminate begin/endUpdate!</vh></v>
</v>
<v t="edream.110203163054.2628"><vh>02/04 Many bug fixes &amp; some big improvements</vh>
<v t="edream.110203163054.2629"><vh>02/04 Fixed Change command in headline</vh></v>
<v t="edream.110203163054.2630"><vh>02/04 A kludgy way to cut &amp; paste between Leo &amp; Leo.py</vh></v>
<v t="edream.110203163054.2631"><vh>02/04 Ended all event handlers with return "break"</vh></v>
<v t="edream.110203163054.2632"><vh>02/04 Changed Insert Node accelerator from Control-K to Control-I</vh></v>
<v t="edream.110203163054.2633"><vh>02/04 Implemented Toggle Active Pane</vh></v>
<v t="edream.110203163054.2634"><vh>02/04 ** Overrode default text keys</vh></v>
<v t="edream.110203163054.2635"><vh>02/04 Documented control characters used in the body pane.</vh></v>
<v t="edream.110203163054.2636"><vh>02/04 ** Breakthrough regarding events and accelerators</vh></v>
<v t="edream.110203163054.2637"><vh>02/04 Implemented Select All command</vh></v>
<v t="edream.110203163054.2638"><vh>02/04 created OnBodyDoubleClick and allies</vh></v>
<v t="edream.110203163054.2639"><vh>02/04 create setTextSelelection utility</vh></v>
<v t="edream.110203163054.2640"><vh>02/04 Created Sort command</vh></v>
<v t="edream.110203163054.2641"><vh>02/04 Fixed Tangle Marked and Tangle All commands</vh></v>
</v>
<v t="edream.110203163054.2642"><vh>02/03 Created shortcuts for opening LeoPy.leo</vh></v>
<v t="edream.110203163054.2643"><vh>02/03 Released 0.08</vh></v>
<v t="edream.110203163054.2644"><vh>02/02 Fixing Bugs</vh>
<v t="edream.110203163054.2645"><vh>02/02 Fixed bugs in outline-only and whole-word searches &amp; is_c_id</vh></v>
<v t="edream.110203163054.2646"><vh>02/02 ** Drawing breakthroughs</vh></v>
<v t="edream.110203163054.2647"><vh>02/02 Fixed control-d bug</vh></v>
<v t="edream.110203163054.2648"><vh>02/02 ** About redrawing</vh></v>
</v>
<v t="edream.110203163054.2649"><vh>02/01 Fixing bugs</vh>
<v t="edream.110203163054.2650"><vh>02/01 Test tangle path errors</vh></v>
<v t="edream.110203163054.2651"><vh>02/01 ** started tree.makeVisible &amp; tree.scrollTo</vh></v>
<v t="edream.110203163054.2652"><vh>02/01 ** used distutils</vh></v>
</v>
</v>
<v t="edream.110203163054.2653"><vh>Jan 2002</vh>
<v t="edream.110203163054.2654"><vh>01/31 Preparing for release...</vh>
<v t="edream.110203163054.2655"><vh>** 01/31 leo.py now tangles better than LeoCB</vh></v>
<v t="edream.110203163054.2656"><vh>01/31 Created open script in leo.py</vh></v>
<v t="edream.110203163054.2657"><vh>01/31 Fixed suboutline only logic</vh></v>
<v t="edream.110203163054.2658"><vh>01/31 Tested directory logic</vh></v>
<v t="edream.110203163054.2659"><vh>01/31 replaced frame.defaultDirectory by c.tangle_directory</vh></v>
</v>
<v t="edream.110203163054.2660"><vh>01/30 Major improvements...</vh>
<v t="edream.110203163054.2661"><vh>01/30 ** May have solved the load path problem</vh></v>
<v t="edream.110203163054.2662"><vh>01/30 ** Rewrote path logic: removed all calls to os.chdir</vh></v>
<v t="edream.110203163054.2663"><vh>01/30 ** Fixed major bug causing @file read errors</vh></v>
<v t="edream.110203163054.2664"><vh>01/30 ** Changed how directories are handled</vh></v>
</v>
<v t="edream.110203163054.2665"><vh>01/29 Improved Paste Node command</vh></v>
<v t="edream.110203163054.2666"><vh>01/28 Generalized trace to allow function args</vh></v>
<v t="edream.110203163054.2667"><vh>01/28 Found source of Find performance bug</vh></v>
<v t="edream.110203163054.2668"><vh>01/25 Found one source of misreads</vh></v>
<v t="edream.110203163054.2669"><vh>01/24 Implemented Sherlock: init_trace and trace</vh></v>
<v t="edream.110203163054.2670"><vh>01/22 More work on leoTangle.py</vh></v>
<v t="edream.110203163054.2671"><vh>01/21 Started workon leoTangle.py</vh></v>
<v t="edream.110203163054.2672"><vh>01/20</vh>
<v t="edream.110203163054.2673"><vh>01/20 Lost clones into leoColor.py</vh></v>
<v t="edream.110203163054.2674"><vh>01/20 Implemented hyperlinks</vh></v>
</v>
<v t="edream.110203163054.2675"><vh>01/18 Completed Change all command</vh></v>
<v t="edream.110203163054.2676"><vh>01/17</vh>
<v t="edream.110203163054.2677"><vh>01/17 Breakthrough: tree.redraw_now</vh></v>
<v t="edream.110203163054.2678"><vh>01/17 much work on Find class</vh></v>
<v t="edream.110203163054.2679"><vh>01/17 v.edit_text defined only if v is visible</vh></v>
</v>
<v t="edream.110203163054.2680"><vh>01/16</vh>
<v t="edream.110203163054.2681"><vh>01/16 Fixed idle_headline logic</vh></v>
<v t="edream.110203163054.2682"><vh>01/16 Lost data in outline (not derived files)</vh></v>
<v t="edream.110203163054.2683"><vh>01/16 Fixed minor find/change bugs and removed batch checkbox</vh></v>
<v t="edream.110203163054.2684"><vh>01/16 Breakthrough re event handlers!</vh></v>
</v>
<v t="edream.110203163054.2685"><vh>01/15 Find/Change</vh>
<v t="edream.110203163054.2686"><vh>01/15 ** Completed find/change commands</vh></v>
<v t="edream.110203163054.2687"><vh>01/15 Converted headline from Tk.Entry to Tk.Text</vh></v>
</v>
<v t="edream.110203163054.2688"><vh>01/14</vh>
<v t="edream.110203163054.2689"><vh>01/14 Fixed bug: cancelling dialog wrote .leo</vh></v>
<v t="edream.110203163054.2690"><vh>01/14 Got basic Find commands to work</vh></v>
<v t="edream.110203163054.2691"><vh>01/14 Fixed Save To bug</vh></v>
<v t="edream.110203163054.2692"><vh>01/14 Added log messages for saves</vh></v>
<v t="edream.110203163054.2693"><vh>01/14 Always recompute file indices on saves</vh></v>
<v t="edream.110203163054.2694"><vh>01/14 Reduced width of log window</vh></v>
</v>
<v t="edream.110203163054.2695"><vh>01/13</vh>
<v t="edream.110203163054.2696"><vh>01/13 exec statement simplifies code</vh></v>
<v t="edream.110203163054.2697"><vh>01/13 Prefs/Find settings now functional</vh></v>
</v>
<v t="edream.110203163054.2698"><vh>01/11</vh>
<v t="edream.110203163054.2699"><vh>01/11 Replaced globals with app() ivars</vh></v>
<v t="edream.110203163054.2700"><vh>01/11 New memory management: created c/v/tree/frame destroy routines</vh></v>
<v t="edream.110203163054.2701"><vh>01/11 About destroy routines: eliminating circular references</vh></v>
<v t="edream.110203163054.2702"><vh>01/11 disabled c.setChanged while loading</vh></v>
<v t="edream.110203163054.2703"><vh>01/11 Eliminated ?? error message on exit</vh></v>
<v t="edream.110203163054.2704"><vh>01/11 created leoFrame.__del__</vh></v>
</v>
<v t="edream.110203163054.2705"><vh>01/10</vh>
<v t="edream.110203163054.2706"><vh>01/10 Worked on Quit error messages</vh></v>
<v t="edream.110203163054.2707"><vh>01/10 Released v 0.07</vh></v>
<v t="edream.110203163054.2708"><vh>01/10 Tested c2py on Borland</vh></v>
</v>
<v t="edream.110203163054.2709"><vh>01/09</vh>
<v t="edream.110203163054.2710"><vh>01/09 Wrote and debugged leo1to2 scripts !</vh></v>
<v t="edream.110203163054.2711"><vh>01/09 Made Python window functional !</vh></v>
<v t="edream.110203163054.2712"><vh>01/09 Added auto indent</vh></v>
</v>
<v t="edream.110203163054.2713"><vh>01/08</vh>
<v t="edream.110203163054.2714"><vh>01/08 bodyKeepsFocus logic</vh></v>
<v t="edream.110203163054.2715"><vh>01/08 Fixed bug: no doesn't abort a Quit command</vh></v>
<v t="edream.110203163054.2716"><vh>01/08 Fixed bug: changing clones didn't mark joined dirty.</vh></v>
<v t="edream.110203163054.2717"><vh>01/08 Got cut/copy/paste working</vh></v>
<v t="edream.110203163054.2718"><vh>01/08 Fixed reooloring problem</vh></v>
<v t="edream.110203163054.2719"><vh>01/08 Added Help-Leo Documentation command</vh></v>
<v t="edream.110203163054.2720"><vh>01/08 Save commands now ensure .leo extension</vh></v>
<v t="edream.110203163054.2721"><vh>01/08 Still no joy with canvas border</vh></v>
<v t="edream.110203163054.2722"><vh>01/08 Expermented with window icons</vh></v>
<v t="edream.110203163054.2723"><vh>01/08 Increased size of open windows</vh></v>
<v t="edream.110203163054.2724"><vh>01/08 Improved look of prefs panel</vh></v>
<v t="edream.110203163054.2725"><vh>01/08 Made progress towards "Show invisibles"</vh></v>
<v t="edream.110203163054.2726"><vh>01/08 @ignore now colored properly</vh></v>
<v t="edream.110203163054.2727"><vh>01/08 @color and @nocolor are now inherited</vh></v>
</v>
<v t="edream.110203163054.2728"><vh>01/07</vh>
<v t="edream.110203163054.2729"><vh>01/07 Fixed some bugs in Move Up and Move Down commands</vh></v>
<v t="edream.110203163054.2730"><vh>01/07 Fixed loss-of-data on insert command</vh></v>
<v t="edream.110203163054.2731"><vh>01/07 tab width</vh></v>
</v>
<v t="edream.110203163054.2732"><vh>01/06</vh>
<v t="edream.110203163054.2733"><vh>01/06 borders again</vh></v>
<v t="edream.110203163054.2734"><vh>01/06 editing and selecting</vh></v>
</v>
</v>
</v>
<v t="edream.110203163054.2735"><vh>2001</vh>
<v t="edream.110203163054.2736"><vh>Dec 2001</vh>
<v t="edream.110203163054.2737"><vh>12/20/01 Fixed Linux problems</vh></v>
<v t="edream.110203163054.2738"><vh>12/19/01 Improved LeoDocs.leo</vh></v>
<v t="edream.110203163054.2739"><vh>12/18/01 Improved Leo2 documentation</vh></v>
<v t="edream.110203163054.2740"><vh>12/17/01 ** Leo 0.05 released</vh></v>
<v t="edream.110203163054.2741"><vh>12/16/01 Found the source of the file mismatches</vh></v>
<v t="edream.110203163054.2742"><vh>12/16/01 Created directory compare routines</vh></v>
<v t="edream.110203163054.2743"><vh>12/15/01 Leo is operational</vh></v>
<v t="edream.110203163054.2744"><vh>12/15/01 Fixed bug in scanText</vh></v>
<v t="edream.110203163054.2745"><vh>12/15/01 Fixed bug in putBodyPart</vh></v>
<v t="edream.110203163054.2746"><vh>12/15/01 Fixed lookahead code in scanText, scanDoc</vh></v>
<v t="edream.110203163054.2747"><vh>12/14/01 Created leoCompare.py</vh></v>
<v t="edream.110203163054.2748"><vh>12/14/01 Create leoDialog.py</vh></v>
<v t="edream.110203163054.2749"><vh>12/14/01 Fixed minor problems</vh></v>
<v t="edream.110203163054.2750"><vh>12/13/01 Fixed several clone bugs</vh></v>
<v t="edream.110203163054.2751"><vh>12/13/01 Aha: we can eliminate v.setIcon !</vh></v>
<v t="edream.110203163054.2752"><vh>12/13/01 ** Fixed bottleneck with endupdate(flag)</vh></v>
<v t="edream.110203163054.2753"><vh>12/13/01 ** Syntax coloring now works</vh></v>
<v t="edream.110203163054.2754"><vh>12/12/01 Cut/copy/paste of nodes now done using internal clipboard</vh></v>
<v t="edream.110203163054.2755"><vh>12/12/01 Fixed insert, move, clone and delete commands</vh></v>
<v t="edream.110203163054.2756"><vh>12/12/01 Looked into Tk &amp; Python clipboard commands</vh></v>
<v t="edream.110203163054.2757"><vh>12/11/01 Menu accelerators</vh></v>
<v t="edream.110203163054.2758"><vh>12/11/01 Properly initialized the file in getLeoFile</vh></v>
<v t="edream.110203163054.2759"><vh>12/10/01 Got accellerators working</vh></v>
<v t="edream.110203163054.2760"><vh>12/10/01 Simplified icon handling, tree.redraw</vh></v>
<v t="edream.110203163054.2761"><vh>12/10/01 Used idle-time handler to work around event problems</vh></v>
<v t="edream.110203163054.2762"><vh>12/09/01 Problems with canvas border</vh></v>
<v t="edream.110203163054.2763"><vh>12/09/01 Tree now drawn properly</vh></v>
<v t="edream.110203163054.2764"><vh>12/08/01 Progress with selection</vh></v>
<v t="edream.110203163054.2765"><vh>12/07/01 Small improvements</vh></v>
<v t="edream.110203163054.2766"><vh>12/07/01 Tree now contains labels for editing</vh></v>
<v t="edream.110203163054.2767"><vh>12/06/01 Open/Close events now handled properly</vh></v>
<v t="edream.110203163054.2768"><vh>12/06/01 Tree drawn correctly, slowly</vh></v>
<v t="edream.110203163054.2769"><vh>12/04/01 Create .gif icons</vh></v>
<v t="edream.110203163054.2770"><vh>12/04/01 replaced dvnodes with vnodes!</vh></v>
<v t="edream.110203163054.2771"><vh>12/04/01 read code is now fast enough!</vh></v>
<v t="edream.110203163054.2772"><vh>12/04/01 tree starts to work</vh></v>
<v t="edream.110203163054.2773"><vh>12/01/01</vh></v>
</v>
<v t="edream.110203163054.2774"><vh>Nov 2001</vh>
<v t="edream.110203163054.2775"><vh>11/15/01 Created do-nothing tk app using Tkinter</vh></v>
<v t="edream.110203163054.2776"><vh>11/15/01 added -padx to log window</vh></v>
<v t="edream.110203163054.2777"><vh>11/13/01 Speeding up reads</vh></v>
<v t="edream.110203163054.2778"><vh>11/11/01 Design of tree class</vh></v>
<v t="edream.110203163054.2779"><vh>11/10/01 began conversion to tk</vh></v>
<v t="edream.110203163054.2780"><vh>11/10/01 es outputs newline</vh></v>
<v t="edream.110203163054.2781"><vh>11/10/01 fixed bug in putDocPart</vh></v>
<v t="edream.110203163054.2782"><vh>11/10/01 added code for @delims</vh></v>
<v t="edream.110203163054.2783"><vh>11/10/01 got @first working</vh></v>
<v t="edream.110203163054.2784"><vh>11/09/01 moved all globals into class</vh></v>
<v t="edream.110203163054.2785"><vh>11/09/01 fixed bugs in write logic</vh></v>
<v t="edream.110203163054.2786"><vh>11/09/01 fixed bugs read logic</vh></v>
<v t="edream.110203163054.2787"><vh>11/06/01 created Leo window using Tk</vh></v>
</v>
<v t="edream.110203163054.2788"><vh>Oct 2001</vh>
<v t="edream.110203163054.2789"><vh>11/01/01 Write code works except for comments</vh></v>
<v t="edream.110203163054.2790"><vh>10/31/01 Added Read/write submenu</vh></v>
<v t="edream.110203163054.2791"><vh>10/31/01 Fixed write code</vh></v>
<v t="edream.110203163054.2792"><vh>10/26/01 Read code is slow</vh></v>
<v t="edream.110203163054.2793"><vh>10/26/01 Read/write code now works</vh></v>
<v t="edream.110203163054.2794"><vh>10/11/01 Outline commands now work</vh></v>
<v t="edream.110203163054.2795"><vh>10/11/01 Removed redundant getters</vh></v>
<v t="edream.110203163054.2796"><vh>10/10/01 Debugged Commands, nodes, fileCommands</vh></v>
<v t="edream.110203163054.2797"><vh>10/08/01 design of leoFileCommands</vh></v>
<v t="edream.110203163054.2798"><vh>10/07/01 removed info and tagList classes</vh></v>
<v t="edream.110203163054.2799"><vh>10/05/01 c2py fixes, speedTest</vh></v>
<v t="edream.110203163054.2800"><vh>10/02/01 through 1/10/4</vh></v>
<v t="edream.110203163054.2801"><vh>10/01/01 fxed bugs in c2py</vh></v>
<v t="edream.110203163054.2802"><vh>10/01/01 c2py in leo</vh></v>
</v>
<v t="edream.110203163054.2803"><vh>Sept 2001</vh>
<v t="edream.110203163054.2804"><vh>9/30/01 documented c2py</vh></v>
<v t="edream.110203163054.2805"><vh>9/29/01 c2py.py</vh></v>
<v t="edream.110203163054.2806"><vh>9/25/01 Idle has trees &amp; syntax coloring</vh></v>
<v t="edream.110203163054.2807"><vh>9/14/01</vh></v>
</v>
</v>
</v>
<v t="edream.110803170826"><vh>Count pages</vh></v>
</vnodes>
<tnodes>
<t tx="edream.110203163054">@nocolor

Leo is:

- A programmer's editor, an outlining editor and a flexible browser.
- A literate programming tool, compatible with noweb and CWEB.
- A data organizer and project manager.
  Leo provides multiple views of a project within a single outline.
- Fully scriptable using Python and saves its files in XML format.
- Portable. Leo.py is 100% pure Python.
  leo.py requires Python 2.2 and tcl/tk 8.3 or above.
- Open Software, distributed under the Python License.</t>
<t tx="edream.110203163054.1">@nocolor

* Leo's main window contains two panes, an outline pane on top and a body pane below.

* The outline pane works like Windows Explorer:   Headlines expand and contract when you click the + or - icon.

* The other icon shows the status of the headline.  See the subheadlines of this headline for details.

* You can change the relative sizes of the panes by dragging the splitter area between the two panes.
</t>
<t tx="edream.110203163054.2">This is the body text of this node.  Nodes containing body text are marked with a small blue box in the status icon.</t>
<t tx="edream.110203163054.3">You can mark headlines in several ways: with the various Outline:Mark commands, with the Find or Change commands, or with the Untangle command.  The "Go To Next Marked" command will go to the next marked node, if any.</t>
<t tx="edream.110203163054.4">Cloned nodes share the same body text.  Also, the headlines of all cloned headlines change whenever a change is made to any of them.</t>
<t tx="edream.110203163054.5"></t>
<t tx="edream.110203163054.6">@nocolor

Please use Leo's SourceForge forums at

http://sourceforge.net/forum/?group_id=3458

to ask questions or suggest improvements.  That way other people can share in the discussions.</t>
<t tx="edream.110203163054.7">@nocolor

Leo owes much of its visual design to MORE, possibly the most elegant computer program ever written. Leo's clone nodes are inspired by MORE.

The following people reported bugs, answered questions, and made suggestions for improving Leo: Alex Abacus, Shakeeb Alireze, Bruce Arnold, Chris Barker, Eric Brown, Darius Clarke, Bill Drissel, Wenshan Du, Allen Edwards, Chris Elliot, Mark Engleberg, Dethe Elza, Stephen Ferg, Tom Fetherston, Tomaz Ficko, Niklas Frykholm, Fred Gansevles, Jonathan M. Gilligan, Thomas Guettler, Zak Greant, Thomas Guettler, Romain Guy, Dave Hein, Tiago Castro Henriques, Gary Herron, Steve Holden, Klass Holwerda, Matthias Huening, Robert Hustead, John Jacob, Christopher P. Jobling, Eric S. Johansson, Garold Johnson, James Kerwin, Nicola Larosa, David LeBlanc, Chris Liechti, Steve Litt, Martin v. Loewis, Robert Low, Fredrik Lundh, Alex Martelli,  Marcus A. Martin, Gidion May, David McNab, Chad Netzer, Naud Olivier, Joe Orr, Marc-Antoine Parent, Paul Paterson, Davide Salomoni, Sean Shaleh Perry, Tim Peters, Scott Powell, Bruce Rafnel, Walter H. Rauser, David Speed Ream, Rich Ries, Aharon Robbins, Guido van Rossum, David Rowe, Steven Schaefer, Wolfram Schwenzer, Gil Shwartz, Paul Snively, Phil Straus, Jurjen Stellingwerff,  Jeffrey Thompson, Gabriel Valiente, Tom van Vleck, Jim Vickroy, Tony Vignaux, Ying-Chao Wang, Cliff Wells, Dan Wharton, Wim Wijnders, Vadim Zeitlin.

The following people have written code for Leo: Dave Hein wrote code to support PHP, to handle Tk version numbers properly and to open the Python window properly on Linux.  Marcus A. Martin wrote code to support LaTex. Paul Paterson wrote the first implementation of plugins and the spell checking plugin.  Steven P. Schaefer eliminated problems with end-of-line on Linux and fixed bugs in how directives were handled in @root trees.

The following deserve special mention: David Brock wrote TSyntaxMemo.  The late Bob Fitzwater kept me focused on design. Donald Knuth invented literate programming and the CWEB language. Joe Orr created Leo stylesheets for Leo; see http://www.jserv.com/jk_orr/xml/leo.htm. Joe Orr also created an outstanding set of tutorials for Leo; see http://www.evisa.com/e/sb.htm. John K. Ousterhout created tcl/Tk. Neal Norwitz wrote PyChecker.  Marc-Antoine Parent urged me to use XML for Leo's file format and helped improve it. Paul Paterson suggested the plugin architecture and suggested an approach to spell checking.  Norman Ramsey created noweb and gave permission to quote from the noweb web documentation. Rich Ries has contributed a huge number of suggestions. Steven P. Schaefer pointed out major security problems lurking in hooks.  Gil Shwartz helped with unicode support.  Phil Straus has been a great friend and constant support. Guido van Rossum created Python, Tkinter and the Python License. Dave Winer created MORE. Dan Winkler helped support Leo on the Mac.

Special thanks to my family. My brother, David Speed Ream, tested Leo and made many useful suggestions. Rebecca, James and Linda make it all worthwhile. It was during a conversation with Rebecca that I realized that MORE could be used as a prototype for Leo. That was a crucial first step.</t>
<t tx="edream.110203163054.8">@nocolor
Here is what people are saying about Leo:</t>
<t tx="edream.110203163054.9"></t>
<t tx="edream.110203163054.10">I've written documentation in WordPerfert, Ventura, Word, PageMaker, and
FrameMaker and even though they create wonderfully looking and useful
documents, they've never been able to do what I've been looking for. HTML,
compiled help files, and later PDF came closer, but still not there. I thing
I've found it in LEO, a way to make a "living" document. A document built out
of discrete parts that can be re-organized on the fly to meet the needs of a
varying audience.

I'll be honest is saying that it will be a long road to convince management to
release LEO files as public documentation, but for all internal projects,
nothing but LEO from here on out. I've already started converting the IT
Procedures manual from Open Office to LEO because I know it's going to be much
more useful to me and anyone else. Being a convert for less than a day I've
still got a lot to learn, but just the possibility of keeping system
maintenance scripts in the IT manual is mind boggling.</t>
<t tx="edream.110203163054.11">wstapp@earthlink.net

I've just perused your program, manual and tutorials and though I have thus far
only an incomplete idea of its capabilities, it contains some of the most
clever features I've ever seen: clones of nodes for example. This program must
have cost you a great deal of effort, not at all diminished I'm sure, by the
"clearsightedness" that unfailingly shows through. I am sure that all who have
examined your program admire it and that all who use it do so with a sense of
gratitude. I know I do. My fields are linguistics and literature and what
programming I do does not go beyond these areas, but I have programmed in C,
C++, Java and Visual Basic and used a number of editors, most of which lag far
behind the programming language. Thank you for making it available.</t>
<t tx="edream.110203163054.12">From Dan Winkler, heydan@post.harvard.edu

This year my accountant is getting a beautiful printout generated by 
LaTeX and Leo.  I have a complicated tax situation this year, but I got 
it all laid out and organized in Leo.  Then I had each of the nodes that 
had something my accountant needs to see write the data out to a file in 
the form a LaTeX table.

Sometimes a row of a table would have a result that was calculated by 
adding up a list of numbers.  For that I used the modern day equivalent 
of an adding machine paper tape -- I stored a lisp s-expression in a Leo 
comment.  I like s-expressions for this because once I put the opening 
"(+" on one line and the closing ")" on another line, I can fill in 
additional numbers just by typing them and can even annotate them with 
comments.  So in the middle of generating a LaTeX file I might have 
something like this:

@
(+
1165.26 1823.70 ; May 2002
123.38 ; June 2002
13.50 ; July 2002
13.21 ; October 2002
55.25 ; November 2002
)
@c

That's an annoted record of how I arrived at the number the accountant 
will actually see.  I can just paste it into any lisp or scheme 
interpreter and get the total.  Adding additional numbers is easy.

For next year, I think I might  take this a step further.  What I did 
this year is good for adding up numbers to get a total for one row of a 
LaTeX table.  But it turns out I'd also like some more processing done 
on those tables (which I had to do by hand this time) -- I'd like the 
rows sorted in reverse order by magnitude (so that the big numbers jump 
out at you from the start of the tables) and I'd like a total of all the 
rows in the table. So I think next year, instead of having an 
s-expression that computes the total of one row for me, I think I'll use 
s-expressions that generate whole tables, formatted for LaTex, from the 
underlying data.  So I'm thinking next year my s-expressions might look 
more like this:

@
(table "Widget Related Expenses"
    ("widget insurance" (+
                    1165.26 1823.70 ; May 2002
                    123.38 ; June 2002
                    13.50 ; July 2002
                    13.21 ; October 2002
                    55.25 ; November 2002
                  ))
     ("widget shipping" (+
                    472.15 651.94 ; May 2002
                    54 ; June 2002
                   ))
     ("widget cleaning" (+
                    165.26 183.70 ; May 2002
                    123.38 ; June 2002
                    13.50 ; July 2002
                    13.21 ; October 2002
                    55.25 ; November 2002
                   ))
)
@c

The job of that "table" function would be to return the LaTeX code 
needed to display a table with the category names and values, sorted 
descending by magnitude, with the total displayed.  It's sort of a poor 
man's way of doing a spreadsheet inside Leo and then making it look 
great using LaTeX.  The idea would be as I wanted to add more data, I'd 
add it to the s-expression and then reevaluate the whole thing by 
pasting it into a lisp interpreter and then copying the result back into 
the same Leo node for LaTeX to process.

-- Dan</t>
<t tx="edream.110203163054.13">Leo has simplifyed updating and creating new scripts and .bats keeping similar
information in the same place. there is almost an addictive withdrawl effect
when I can complete an operation in so much less time with leo &amp; python than I
had become used to.
</t>
<t tx="edream.110203163054.14">@nocolor
September 3, 2002

Hello, my full name is David Speed Ream. I am known as Speed to friends and enemies alike, but I gladly answer to David or most any other handle. I am an unabashed and biased fan of Leo, the fact that it was written by my brother Edward only slightly coloring my already colored glasses. I have been testing and using Leo in software production for over 4 years. My company currently has over 50,000 lines of code in over 100 source files that are written using Leo.

My comments are from two points of view, the first being software project manager for a complicated, multi-module software product, and the second being as a production line coder. For me, Leos greatest and only real drawback is the learning curve. This learning curve can be shallow is if all that is required is that someone code using Leo. However, in our company we allocate 40 to 80 hours _on top_ of the normal coding load for someone to come up to speed on Leo. The ROI (return on investment) is calculated by me to be on the order of 3 months. So if I hire a consultant for less than 3 months, I dont teach him Leo, even though all source code in our company must reside in Leo files for the reasons I wont go into now.

I consider that my coders are 15 to 30 percent more efficient in their daily operations than my competitions people. This indefensible claim of mine is based on the changes in my productivity as Leo grew from a test document production tool to the primary production method for all our assembly, c and cpp source code.

Personally, I hate to deal with documentation when I write code, except: 1) When I am first sitting down to solve a new problem. Then the documentation becomes quite long-winded and pontificatory, as if I were the only one on earth smart enough to solve the problem - or 2) When I come back to code I or someone else has written and find the documentation insufficient to understand the code without study (seems to be most of the time).

So I do not require my engineers or myself to do a great job of documentation, nor do I use Leo for that purpose. Rather, it is Leos outlining and organizing ability, and Leos ability to create source files from within the outline that give me what I think is a tremendous competitive advantage. Each of my companys products run on all versions of windows from Win 3.1 to XP. In our flagship software piece, there are ten main modules, and each module is maintained by one single Leo file. In the CODEC module, one Leo file named compress.leo organizes and creates seven .asm files, forty-four .c files, twenty .h files, two .def files, four .mak files, etc. etc. etc. This one file can be checked out from source code control and given to an engineer for the addition of a new feature.

In it are contained all the known issues for the CODEC, each issue arranged in its own clone section. One clone section groups together every routine, variable or type definition that must change between different versions of Windows. These sections could be from six different c source files, two assembly files, and eight .h files. Another clone section groups together those sections relating to memory problems, which change according to the memory configuration and TSR configuration (or lack thereof) on the target machine. Another clone section groups sections that fail (or dont fail) if the routine in question was accidentally run during the dreaded interrupt time. Another clone section is a section containing clones, each of which is named after the major bug that was fixed when the engineer who fixed the bug grouped a bunch of routines, definitions, etc. together to fix the bug.

None of the above clone sections was designed into the document. Just the opposite happens. When the codec was first written, there was just a single Leo file with a bunch of sections for each c routine or assembly module. As the product grew and was tested on various platforms, each failure of the module was organized into clones each time a failure was fixed. This is what I call SELF DOCUMENTING CODE. This has nothing to do with me sitting and documenting anything. Its just that the STRUCTURE of a bug fix (or product enhancement) lives on long after the coding is done, as long as no one is foolish enough to delete the cloned sections that DOCUMENT what happened.

In actual practice, this organizational history is so powerful that I cant begin to describe it. A REVERSE LEARNING CURVE happens when an engineer gets a Leo file that already has the interrupt time sensitive routines grouped together by the last unfortunate soul who had to work on them. There may not be any more written documentation, but the knowledge contained in the structure can be breathtaking. It is certainly timesaving. I find this particularly true in my own case. Often Ill look at some code that seems totally unfamiliar and think what idiot wrote this crap. Then Ill look at the version control comments and realize that I wrote the crap. Then for sure I know the documentation is non-existent, but the clones I used to develop it are still there, and they always serve to refresh my memory in an indescribable way.

Enough of this commentary, I just looked at the clock. Best wishes to anyone willing to try Leo for a week. I hope you will be glad you did.</t>
<t tx="edream.110203163054.15">By David McNab:

(Ed, don't read this - go away) 

Does anyone know of any Open Source developer awards that accept public nominations? 

I feel strongly that Ed Ream, our ever-patient, ever-productive Leo architect deserves a nomination. 

Amongst other reasons, for: 
* Delivering the first usable visual literate programming tool. 
* Adding a vast abundance of new features. 
* Making possible a previously unimaginable amount of leverage in code editing.
* Eliminating vast amounts of menial programming labour.
* Tirelessly and patiently supporting users, and catering to a wide range of feature requests.

By Gil Shwartz:

I do not know of such award, but I will definitely back the nomination. Leo is unimaginably useful and I always find new things it already knows(!) how to do. Indeed I am amazed by the never-ending resources and patience Edward is putting into it and its users community. Excellent.</t>
<t tx="edream.110203163054.16">Leo is an interactive editor for organizing text fragments hierarchically and sequentially into one or more files and hierarchical folders, without arbitrary limits on the number and size of text fragments and the depth of the hierarchy.

Tangle is a tool for combining hierarchically and sequentially organized text fragments into text files, hierarchically grouped into folders, with hierarchical or sequential organization of text within the files, and without arbitrary limits on the size and number of files and the depth of the hierarchy of folders and text nesting within the files.</t>
<t tx="edream.110203163054.17">Leo is EXACTLY the kind of outliner I was looking for--fantastic job!</t>
<t tx="edream.110203163054.18">I am a huge fan of Leo. I think it's quite possibly the most revolutionary programming tool I have ever used and it (along with the Python language) has utterly changed my view of programming (indeed of writing) forever.</t>
<t tx="edream.110203163054.19">Just a quick note to thank you for your work on Leo. It is a really nice piece of work!

It makes "literate programming" much easier. [I've been playing around from time to time, but it was tedious, so I continued with my usual way of working.]

Again, this is a great tool!
</t>
<t tx="edream.110203163054.20">I want first to thank you for Leo. This is a very useful and interesting tool. </t>
<t tx="edream.110203163054.21">Thank you very much for leo. I think my way of working with data will change forever.

I have just tried leo for 2-3 days, yet I am certain this will be a revolution. The revolution is as important as the change from sequencial linear organization of a book into a web-like hyperlinked pages.

The main concept that impress me is that the source listing isn't the main focus any more. You focus on the "non-linear", hierarchical, collapsible outline of the source code. </t>
<t tx="edream.110203163054.22">Leo is amazingly stable. Docs are often weak with Open Source Software. Not so
Leo: Leo is unusually well documented.

I gave Leo a try a while ago, but did not recognize its strengths as an
outliner. In April 2003 a gave it another try. And when I saw in the online
help mentiontioning clones almost in passing (you got to emphasis this much
more!), I knew: This is it.

If you are like me, you have a kind of knowledge base with infos gathered over
time. And you have projects, where you use some of those infos. Now, with
conventional outliners you begin to double these infos, because you want to
have the infos needed for the project with your project. With Leo you can do
this too, but if you change text in one place IT IS UPDATED IN THE OTHER PLACE
TOO! This is a feature I did not see with any other outliner (and I tried a
few). Amazing! Leo directly supports the way I work!

And when I saw, how easily I can script it with one of my favorite
programming languages (i.e. Python), I fell in love with Leo. Sounds silly,
perhaps. But with a script written and tested in about 20 minutes I extract
time expenses out of my diaries as easily as it can be. Yet I did not
discover all of Leo, but if there's anything Leo cannot do yet, I'm pretty
sure that I can script it.

Not yet convinced? Then think of this final but VERY IMPORTANT point: With Leo
YOUR DATA ARE YOURS! Leo is Open Source, Leo is written in Python, thus Leo is
platform-independent, Leo stores your infos in ASCII format (XML). This means,
that you are not locked into a company if you use Leo. YOUR DATA ARE YOURS!
Think of this if you again are working with your favorite PIM.

Edward, keep up this extraordinary good work!

fgeiger@datec.at
</t>
<t tx="edream.110203163054.23">I have been playing around with Leo and am really very impressed! It should either replace or greatly augment the development tools that I use."</t>
<t tx="edream.110203163054.24">I must say I am very impressed. I have been absolutely seduced by Leo over the
past few days. I tell you, I can not put it down. I feel like a kid with a
shiny new bike. Hopefully I can get you guys some code one of these days. I'm
already bursting with new ways I'd like to use the tool in the future.
</t>
<t tx="edream.110203163054.25">I've tried Literate Programming tools off and on for more than 10 years, mainly because the promise was so great.  I've abandoned them every time because working with the various CWeb-like tools was so awkward.

Leo changes all that.  The most important benefits promised by Literate Programming are realized by using Leo, without the awkwardness of the other tools.
</t>
<t tx="edream.110203163054.26">When first I opened Leo, it was out of curiosity.  But having used it...

I'LL NEVER GO BACK.
THEY'LL HAVE TO PRY LEO OUT OF MY COLD, DEAD FINGERS!

Seriously, it should be renamed "Crack Cocaine" because it's that addictive.
I'm ready to start a 12-Step group.
</t>
<t tx="edream.110203163054.27">I wanted to thank you for the effort you've put into Leo.  It looks fantastic.  I've always though that Literate Programming was a good idea, but the tools were completely un-workable. </t>
<t tx="edream.110203163054.28">I was turned on too a very cool tool written in Python. Leo is a marrage of outlining and literate programming. Pure genious. The main reason I am impressed with this tool is that it doesn't affect your choice of tools. You can use whatever IDE for whatever language and switch back and forth between leo and it. </t>
<t tx="edream.110203163054.29">And yes, I've been using Leo a few hours every day for more than a week, now. :^) Actually, it's become my main development platform, and I do this for a living. </t>
<t tx="edream.110203163054.30">&lt;tomlee@bigpond.net.au&gt;

I came across Leo the other day while reading through Dr. Dobbs' Journal,
and after all of five minutes I must say I'm absolutely astounded by the
power of such a simple idea! It works great and I can immediately see the
benefits of using Leo in place of the standard flat file editor.

I know this is short and sweet, but thanks very much for such an interesting
piece of software.
</t>
<t tx="edream.110203163054.31">Cloning is pure genius! I'm studying for the Chartered Financial Analyst exams, and I use Leo to take notes on the voluminous course material. Along the way, I'm developing little utility functions in the array programming language J (http://www.jsoftware.com) for working the examples and the exercises in the textbooks. J is vanishingly terse, so the literate programming facilities in Leo aid comprehension of code immensely. Even more useful than the traditional lit prog for my purpose, though, is Leo's cloning facility, which allows me to create several views on the CFA course material. My main view follows the prescribed study guide. Another view is organized like the textbooks. Yet another gives me a glossary of terms. And when I'm done, I'll have some nice libraries of J functions that I can re-use later in other projects. Also, a little exporting from Leo and post-processing with noweave should give me some printable docs.

Thanks for hunting down these bugs, and thanks for producing such a cool tool. Wanting to customize and script Leo has me itching to dust the Python books off this weekend.
</t>
<t tx="edream.110203163054.32">I just discovred Leo today. I am one of the many droves of people that came stampeeding by due to you being Slashdotted. I will say that I am extemely impressed at how stable and useful Leo appears to be. As soon as I ran though the slide presentations of how Leo works, it struck me that I have always been looking for this in an editor.

I am very impressed that you developed this app single handedly. It looks like a very impressive piece of work.
</t>
<t tx="edream.110203163054.33">Hey, Edward, please bear with us. I know you're overwhelmed, but you've come up with perhaps the most powerful new concept in code manipulation since VI and Emacs.

I'm blown away with how Leo can slice'n'dice C and Python files into their component parts.

Leo absolutely ROCKS! :) It's exactly the tool I've been wanting for years but have never got around to writing. 

One thing I really like is the ability to create functions in any order I please, and not think about what files to put them into till later. This ability alone has freed up a lot of my thought processes with coding.

---

For me, I'm so grateful I saw the Leo write-up on Slashdot, otherwise I would
probably never have come into contact with it.

A funny observation with Leo is that when I 'Leo-ise' other people's code, Leo
makes the code's structure so transparent that design faults become very quickly
apparent - eg maintenance pain caused by lack of factorisation.

Thanks again for a wonderful (I won't say 'editor' because the word doesn't
do Leo justice) code structuring system.
</t>
<t tx="edream.110203163054.34">We who use Leo know that it is a breakthrough tool and a whole new way of writing code.

Leo is a powerful tool for organizing text into tree structures, and for just generally attacking a number of problems from a tree-based perspective.

&lt;opinion&gt;
There has been a lot of hype about XML and all the uses to which it can be put. But, to my mind, the greatest benefit of XML is that it allows people to easily work with tree structures. All the benefits of XML really flow from that. Leo is the best application I've seen for conceiving and planning the trees that are then put into action via various XML technologies.
&lt;/opinion&gt;"

Outlining Editors have existed for a while (e.g. PC-Outline, MORE) but Leo takes a major leap beyond previous tools for three reasons:

1. You can embed a simple macro language inside of a Leo document to instruct Leo to assemble pieces of the Leo document into another file. This facilitates, among other things, one type of Literate Programming.

2. Leo saves its files in XML format. This means that you can easily import and export Leo documents to any number of programs that can understand XML. For example, you can use an XSLT stylesheet to export a Leo file to HTML. And you can import any XML file into Leo using another XSLT stylesheet.

3. Leo is fully scriptable via Python."</t>
<t tx="edream.110203163054.35">The Word outlines are very useful. But Leo makes Word look like a clunky toy.

#1 Reason would probably be clone nodes. One node can point to another. Another
way of putting this is is that a leaf can be on more than one tree. For
example, suppose you have a list of recipes. You simultaneously put a single
recipe under multiple categories or even multiple hierarchies. You could put "3
bean enchilada" simultaneously under Recipes-Mexican and Food-Gas. Another
example would be, if you are a biologist trying to decide under which genus to
put a new species, you could put the species under two simultaneously. In
effect, you can build a 3-D tree. For a further illustration see
http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm

#2 Reason would probably be that Leo outlines can be embedded in external text
files. So, a Leo outline is more than an outline, it is a meta-structure that
can be added to another text without changing that text, but rather providing
an external roadmap to the text. Microsoft Word has a text (xml) version with a
commenting convention, so Leo can even be used to add outlines into Word docs,
altho it isn't set up to do that now. For example, see
http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm In this case, the upper
window of Leo is the metastructure, and the bottom window is the file to which
the metastructure is being applied, viewed one node at a time.

I may not have made #2 very clear, but it is actually a very useful feature. It
takes some getting used to before one sees all of the possibilities tho. One
way to think of it is that Leo allows you to throw external documents into your
outline, and yet the external document remains independent and can still be
edited separately.

Some other cool things about Leo which Word doesn't feature:
1. Pure xml output that is easy to transform into other formats (next
version of Word will have true XML format, but not as easy to work with).
One consequence of this is that Leo files can be transformed pretty easily
to web pages with their outlining capability intact.
2. Easy to add features since is programmed in Tkl and open source. Maybe
your average user can't start hacking on it, but a surprising amount can be
tacked on by flipping thru the Tkl manual.
3. Free, opensource, multiplatform
4. Leo is scriptable with Python. It should be possible to build a Tickler
into Leo using Python scripting, for example.</t>
<t tx="edream.110203163054.36">@nocolor

I only have one week of Leo experience but I already know it will be my default
IDE/project manager.  I have seen several old threads on c.l.python  where people
complain about the lack of a project manager for the free/standard Python IDE's
like Idle.  Leo clearly solves that problem and in a way that commercial tools
can't touch.  I suggest we reply to future such postings with that gentle nudge.
</t>
<t tx="edream.110203163054.37">Hi, I have been interested in creation of a heirarchal text-editor for a while and I just came across Leo, which I found to be almost exactly what I had in mind, which is fantastic because I don't have to code anything!</t>
<t tx="edream.110203163054.38">I am an amateur photographer. I use plain old 35mm. film for my pictures. Over the weekend, I used LEO to organize my lists of pictures. It is quite helpful -- I can have separate nodes for pictures I have enlarged, as well as pictures I have submitted to our local camera club. Thanks!</t>
<t tx="edream.110203163054.39">Just as structured programming reveals and disciplines the flow control of a program, [Leo] allows the designer to reveal and discipline structure at many layers simultaneously: data structures, object structure, entity-relationship structure, client-server structure, design pattern structure, temporal structure, project management structure, and any other structure relevant to the system. </t>
<t tx="edream.110203163054.40">LEO reminds me a great deal of things I loved when I used Userland's Frontier
(an outlining CMS with a native OODB) - but Frontier wasn't hackable enough
for me,  and it wasn't oriented towards coding and literate programming, and
you couldn't round-trip rendered pages (big LEO win).  This is really a super
tool - in a matter of days I've started to use it on all my projects and I still
haven't figured out how I lived without it.

Thanks again.
</t>
<t tx="edream.110203163054.41">Leo is a very good concept and is a revolutionary step in the right direction for programming. I appreciate your work. </t>
<t tx="edream.110203163054.42">Leo files are so wonderful at organizing information, it'd be powerful if we could share them on the web with minimal effort.

A Leo file is an ideal documentation tool, collecting the assorted readme.txt files, the comments from the source files...as well as the config files themselves.</t>
<t tx="edream.110203163054.43">I have been using Leo for about 3 weeks and I hardly use my other programming editor anymore...I find it easy and enjoyable to use. I plan to adopt it as my presentation tool for code reviews.
</t>
<t tx="edream.110203163054.44">First of all, kudos to you for the excellent progress you've been making with Leo.  I upgraded today after about three months of using and older version and I was thrilled to see all the great improvements that have happened so fast.  I especially love the ability to go to next clone.  I think you're really showing what open source can do and your current trajectory puts you on track to kick Emacs into the dustbin of computing history.

So today I copied all my data (personal information manager and project management stuff) out of my old outliner (ThoughtManager, which synchs with and runs on the Palm) and put it into Leo.  It took me hours to do it and then to rearrange it the way I really wanted it.  But having the ability to make clones and have different ways to view my data is, as you know, fabulous.  In my case, for personal information and project management things, I used the flexibility of clones to allow me to see my data in several different views: 1) by project, the logical hierarchical breakdown by topic, 2) by person, so whenever I'm talking to someone I can easily see all the pending items related to them which may be spread over multiple projects, 3) by priority, so I can see what needs to get done sooner and what can wait for later and, 4) a special case of priority called "Today" for the things I'm going to focus on in the coming hours.

Now here's why I don't miss the ability of my old outliner to synch the entire outline with the Palm.  It turns out the main thing I really want in the Palm is the top category "Today" so all I have to do is have Leo flatten that one heading into a text file (and it kindly remembers the name and directory of the file I used last time) and then I'm done because I've told the Palm Hotsync manager that that file should be sent to Palm memo pad every time I synch.  The Palm Hotsync manager does a nice job of sending a text file to the Palm memo pad and even breaks the file up into multiple memo records if it's too big to fit in just one.  So that gives me enough to be able to browse (or full text search) the small amount of data that I really want right inside my Palm (which is also my cell phone).  Quick and dirty but it works.

For times when I want my whole outline with me, Leo wins again because thanks to its cross platform nature I can take my whole outline with me on my Mac iBook, even though I usually edit it on a Windows PC (which is the only kind of machine my old outliner would run on).  Quite frankly, although my old outliner was able to shoehorn the whole thing into my palm/cellphone, it was a pain to access it on the small screen and slow processor.  Now when I anticipate I'll need the whole thing, for example when I'm going to a meeting, I can put it on my Mac iBook (under X and Fink for now until Python can do it native under Aqua) and have real, full access to it all.

I think now in addition to being great for programming Leo is also a great PIM.  Being able to flatten a strategically chosen portion of the outline into a known file name that the Palm synch manager has been told to send to the Palm on every synch does the trick for me.  I wonder if you would consider something like an @flatten directive so I can have that done automatically for me every time I save my outline?  For now it's up to me to flatten the node I want manually, although once I've done that the transfer to the Palm is automatic.

You're my hero!  Thank you so much.

-- Dan

-----

Another day, another breakthrough using Leo -- now I realize Leo is the 
best URL bookmark manager there is.  No more bookmarks menus or 
favorites lists inside the browser for me.  With the @url directive I 
can just double click on the URL to open it in my browser.  Leo lets me 
arrange the URLs in a hierarchy (or multiple hierarchies), attach notes 
to them, save clippings of things I read on the sites.  It's sooo much 
better than anything the browsers have built in and it lets me easily 
use different browsers on different platforms and different machines 
(try that with the browsers' built-in bookmark managers).  

When using Leo as a project manager and personal information manager as 
I do I can heavily annotate every task and project with helpful and 
relevant URLs.  And since URLs can be of the file:// form, they're not 
just for web pages or HTML documents;  I can link to any file on my disk 
of any type to be opened by any program.

Leo is a quantum leap for me in terms of how many projects I can manage 
and how much information I can find and organize and store in a useful 
way.  I'm a data-mining army of one now and the web is my playground. 
 Every time I find a web page that has interesting links to others, 
those links get stored in my Leo outline too, right where I can find 
them and make practical use of them.  I can easily accept dozens of 
valuable links every day and integrate them into what I'm doing in a way 
that I'm confidant they won't get lost or forgotten.  Before I always 
used to get bogged down by the difficulty of managing bookmarks inside 
the browser.  But now I'm no longer the victim of information overload 
buried in the knowledge landslide of the Internet;  instead I'm the 
professional strip miner with the world's biggest bulldozer.  I eagerly 
plunge into mountains of data and emerge with all the valuable 
information nuggets neatly stored and organized.  And my storehouse of 
knowledge is a flexible thing where I can reorganize and prioritize and 
massage the data to my heart's content as I learn more about it and 
decide to use it in different ways for different purposes.  It's the 
difference between the pick axe and the steam shovel for me.
</t>
<t tx="edream.110203163054.45">I found this blog entry by someone (a talented former coworker of mine
actually) complaining about some poorly written code she had to maintain:

http://www.ceejbot.com/blog/space/2003-01-29#the_news_at_10

She said: "You'd need a bulldozer to start refactoring it. " That was my cue to
write a long message explaining that there is indeed such a bulldozer and it's
called Leo. (You can see my message there as a reply to her original posting.)
I gave her my recipe for how to get someone else's messy, scary code into Leo
and how to break it down into manageable chunks.
</t>
<t tx="edream.110203163054.46">@nocolor</t>
<t tx="edream.110203163054.47">Please be aware of the following problems with leo:

1. leo.py v3.0 and Borland v2.6 create derived files that can not be read by older versions of Leo!  leo.py v2.0 and Borland v2.6 can read all previous derived files.

2. Leo will report read errors when opening a .leo file that is not "in synch" with derived files.  This can happen when opening a backup copy of a .leo file.  When such errors happen you have two choice:

Choice 1: Use the "Read Outline Only" command to recover the outline using only the .leo file.  This is the recommend way because it preserves all clone links.

Choice 2: Use one or move "Read @file Nodes" commands to update the outline from derived files.  This way is will break any clone links from the outline into the </t>
<t tx="edream.110203163054.48">This node duplicates the information in Chapter 2: Installing Leo.

New in version 4.1:  The first time you start Leo, Leo will ask you for a unique identifier.  If you are using cvs, use your cvs login name.  Otherwise your initials will do.

Leo stores this identifier in leoID.txt, so you can change this identifier at any time by chaning leoID.txt.</t>
<t tx="edream.110203163054.49">leo.py is Leo2 written in Python and Tk.  It should work on any platform that supports Python 2.2 or later and Tk 8.3 or later.

Download Python from http://python.org/
Download tcl/Tk from http://tcl.activestate.com/software/tcltk/

The section called "How to Install Leo on MacOS X" contains special instructions for the Mac.  Leo will not run on MacOs 9.</t>
<t tx="edream.110203163054.50">@nocolor

leo.py requires Python 2.1 and tcl/tk 8.3 or above.

	Download Python from http://python.org/ 
	Download tcl/Tk from http://tcl.activestate.com/software/tcltk/
	
Warning: When building Tcl on Linux, do not specify "--enable-threads" .. only use Tcl
with the default "threads not enabled" case.

Leo is distributed as a single compressed folder.  Simply uncompress this folder and run leo.py.  You can run leo.py by double-clicking leo.py.  You can also run leo.py from a Python interpreter as follows:

@color

	import leo
	leo.run() # runs leo.py, opening a new outline.
	leo.go() # runs leo.py after reloading all modules.
	leo.leoOpen(fileName) # runs leo.py, reloads all modules, and opens fileName.
	
@nocolor

On Linux, the following shell script will allow you to open foo.leo files by typing leo foo

#!/bin/sh 
python &lt;leopath&gt;/leo.py $1

where &lt;leopath&gt; is replaced with the path to the leo directory. </t>
<t tx="edream.110203163054.51">@nocolor

leo.py requires Python 2.1 and tcl/tk 8.3 or above.

	Download Python from http://python.org/ 
	Download tcl/Tk from http://tcl.activestate.com/software/tcltk/

Leo is distributed as a single compressed folder.  Simply uncompress this folder and run leo.py.  You can run leo.py by double-clicking leo.py.  You can also run leo.py from a Python interpreter as follows:

@color

	import leo
	leo.run() # runs leo.py, opening a new outline.
	leo.go() # runs leo.py after reloading all modules.
	leo.leoOpen(fileName) # runs leo.py, reloads all modules, and opens fileName.
	
@nocolor

Another way to open files would be to create a batch file.  On Windows, I put the following .bat file in c:\Windows

cd c:\prog\LeoCVS\leo
c:\python22\python c:\prog\LeoCVS\leo\leo.py %1

This opens the file specified by the first argument (%1).</t>
<t tx="edream.110203163054.52">The following nodes discuss installing leo.py on MaxOS X Jaguar.

Apparently the process is getting easier and easier.</t>
<t tx="edream.110203163054.53">Leo on MaxOS Jaguar

Fortunately, this has gotten much easier this year (2003).  I did it recently
and here's what I remember.

You will need:

  the latest Leo2.py (I used Leo 3.10 (ignore "leo(Macintosh)")
        http://prdownloads.sourceforge.net/leo/leo-3.10.zip?download

  the latest TclTkAqua (I used 8.4.1)
        http://sourceforge.net/project/showfiles.php?group_id=10894&amp;release_id=117868

  the latest X11 beta from Apple (I used Public Beta v0.2.1)
        http://www.apple.com/downloads/macosx/apple/x11formacosx.html


Install X11 to get an OS X native X11 window server, the TclTkAqua to get the
Tcl and Tk toolkits (which run on X11) to support Leo's GUI, and install Leo.

Once these are installed, treat leo as a typical UNIX installation running with
an X11 server (unrelated to OS X).  leo never needs to know that it's running
on OS X (thanks to Apple releasing their aqua native X11 server!).

To run it, make sure to run the X11 server first.  Then run leo from the command
line (as usual).  If the X11 server isn't running, leo won't have a way to display
windows or GUI.

Good luck!</t>
<t tx="edream.110203163054.54">Bruce M. Bolden, bruceb@cs.uidaho.edu, is using Leo on MaxOS X.  Here is his description of how to get Leo working there:

I installed: 
- Latest OS X Developer tools
- latest (as of about two weeks ago) tk/tcl
         MacOSXTk8.4a4-2.tar.gz
- the machopython distribution
http://prdownloads.sourceforge.net/wxpython/MachoPython-2.2.1.dmg

For OS X 10.1, I followed the directions at:
    http://tony.lownds.com/macosx/tkinter.html

That worked fine for 10.1, but didn't work for 10.2.  It
took awhile to find a Python distribution that worked
correctly with tk/tcl.

I was just getting into Leo about a week before 10.2 was released and thought about---what if it breaks....  10.2 broke it, but I was able to find a solution as described above.</t>
<t tx="edream.110203163054.55">I just finished building tk successfully!  The magic step was the execution of the command

cp ../generic/prolog.ps to ../library/prolog.ps

AFTER 

cd ../../tk/macosx

in the instructions on "Steps to build Tcl/Tk 8.4.0 on MacOS X":

http://mini.net/tcl/4052

I found this solution while looking at the tcl-mac mailing list archive.  The earlier (current?) tar ball on SourceForge did not have the file prolog.ps in the library directory:

http://sourceforge.net/mailarchive/forum.php?thread_id=1060496&amp;forum_id=3853

Copy and Paste seem to work just fine now in Leo!  This was my original question for you.

I also noticed that someone else built everything on OS X 10.2 (Jaguar), but they did it under X.  Since, the new version of Tk appears to support the OS X interface quite well, I'm not going to bother installing X (for now).

So, Leo works two different ways on OS X 10.2.</t>
<t tx="edream.110203163054.56">Installing Leo under MacOS X 10.2
=================================

MacOS X 10.2 comes with a built-in python interpreter, but unfortunately the
built in interpreter has no support for Tkinter (the library Leo uses to
display its graphics), so if you try to run Leo using the built-in python you
will get an error message saying that Tkinter cannot be imported.

This document describes the steps you must take to get Leo to run under MacOS X.

There are two ways of running Leo under Mac OS X. Leo can either be run
natively in its own Aqua window or it can be run under an X11 server. Native
running is usually more elegant, since it gives Leo the standard Mac OS look
and feel. Running it under X11 might be a good option if you aldready use a lot
of X11 programs. This document only describes the installation procedure for
Aqua.

See the children of this node for details.</t>
<t tx="edream.110203163054.57">1. Install the TclTkAqua package.

   Download and install the file ``TclTkAqua-8.4.1-Jaguar.dmg`` from
   http://sourceforge.net/project/showfiles.php?group_id=10894&amp;release_id=117868.
   
   Note that you probably do not want to install the 8.4.2 version. The TclTk
   project uses odd numbers for stable versions and even numbers for unstable
   development releases.
   
   There is also a *BI* version of TclTkAqua. *BI* stands for *Batteries
   Included*. This distrubiton includes many of the commonly used extensions
   to Tk, in addition to Tk itself. It is not needed for running Leo.
   
2. Install the Python interpreter

   A python interpreter compiled to run with AquaTk is available at
   https://sourceforge.net/project/showfiles.php?group_id=10718.
   Download the file::
   
       MacPython-OSX-2.3a2-2.dmg?download
	   
   or any newer version of the interpreter and install it.
   
   At least some versions of this installer has a bug that appears when you try
   to install it on a system with a single disk. The installer will erroneously
   report that the program cannot be installed on the disk. To fix the problem
   just *Go Back* and press *Continue* again. You will then be able to continue
   the installation.
   
3. Download and install the source code version of Leo from Leo's project page.

4. Rename the ``leo.py`` file to ``leo.pyw``. 

   This tells MacPython that ``leo.pyw`` is a GUI script that should run in its
   own GUI window.
   
You should now be able to run Leo by double clicking on the ``leo.pyw`` file. You
can create an alias of the file in some convenient location to have easy access
to the program.

To run Leo from the command line, type:

    /usr/local/bin/pythonw leo.pyw
	
This should start Leo. (``pythonw`` is a small wrapper script that is needed to
work around a bug in AquaTk which prevents windows from being brought to
front).</t>
<t tx="edream.110203163054.58">To get .leo documents to open with Leo, you must first create an AppleScript that
can launch Leo. Start up the script editor and enter the following text::

  on open filelist
    repeat with i in filelist
      do shell script "/usr/local/bin/pythonw /Src/Leo/leo.pyw " &amp; POSIX path of i &amp; " &gt; /dev/null 2&gt;&amp;1 &amp;"
    end repeat
  end open
  
  on run
    do shell script "/usr/local/bin/pythonw /Src/Leo/leo.pyw &gt; /dev/null 2&gt;&amp;1 &amp;"
  end run

You should replace ``/Src/Leo/leo.pyw`` with the path to wherever you have
installed Leo.

Save this script as *Application* at some suitable location. Name it "Leo" or
something similar. You can now launch Leo by double-clicking the script icon.
You can also open Leo files by dropping them on the script icon.

Double click any ``.leo`` file. In the dialog box that appears select *Choose
Application...* and choose the script application you just created.</t>
<t tx="edream.110203163054.59">The Icons folder contains two Icons, called LeoApp and LeoDoc, that represent the Leo application and Leo documents respectively.

In Windows, to associate LeoDoc with .leo files, open the Setting:Folder Options:File Type panel, create an entry for .leo files.  Then choose Change Icon and select the LeoDoc icon.  Associate leo.py as the application to open .leo files.</t>
<t tx="edream.110203163054.60">leo.py 2.4 and above will open .leo files automatically provided that you associate leo.py with .leo files.  Here is how to open leo.py when double-clicking a .leo file on Windows 2K or XP.  I'm not sure it will work for Windows 95/98/Me.

In Windows 2K or XP, Go to Start-&gt;Settings-&gt;Control panel, open the "Folder Options" applet.
Select the "file types" tab from the Folder Options window. Press the "new" button.
Enter LEO into the "Create New Extension" File Extension text field. Press OK.

With LEO still highlighted in the Registered File Types list box, press the Advanced button.
Change the default file type field to something like "Leo Literate Outline".
Press the Icon button and browse to the LeoDoc icon in your [leo install dir]\leo-2.3\Icons folder.
Click OK. This gets the icons right and registers the description of the .leo file.

You now have to tell windows what to do to open the file properly.
Press the new button to open the "New Action" window.
In the Action field type Open.
In the "Action used to perform action" type _one_ of the following lines:

[python install dir]\pythonw.exe   [leo install dir]\leo.py %1
[python install dir]\python.exe -i [leo install dir]\leo.py %1

The first  line opens Leo files with no console window.
The second line opens Leo files with a console window and leaves the window open after Leo exits.

You should now be able to double click on a leo file in explorer with leo.py.</t>
<t tx="edream.110203163054.61">New in Leo 4.0 and Python 2.3: Leo will draw a Leo icon in all Leo windows.  There is no need to install PIL or tkIcon.

Otherwise (for versions of Leo before 4.0 and for versions of Python before 2.3) Leo will draw a Leo icon in Leo windows only if you have installed Fredrik Lundh's PIL and tkIcon packages.

Download PIL from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.</t>
<t tx="edream.110203163054.62">@nocolor

Quick start

This is the minimum you need to use Leo effectively.

1. Write body text using the noweb languages. See Using noweb, CWEB and Directives.

2. Create source files (derived files) using the Tangle command. Only @root directives under the currently selected headline are tangled by the Tangle command. Warning: The Tangle command will overwrite files specified in @root directives if they exist.

3. Use the Untangle command to propagate changes made to derived files back into the outline Untangle is useful only for making small syntactic changes. Don't attempt to change the structure of an outline by modifying derived files; it won't work.

4. Many command key abbreviations are specified in the Syntax Coloring panel.

See the Appendices for a concise summary of information about Leo.</t>
<t tx="edream.110203163054.63"></t>
<t tx="edream.110203163054.64">Leo 4.1 alpha 1                   November 3, 2003

*** Alpha quality code:  Please make full backups before playing with this code!

This release marks another significant milestone in Leo's history:

- Leo's 4.x file code is complete.  At present I have no plans to change the format of .leo files or derived files.  I am eating my own dog food: I do all my editing with the 4.1 code base.

- Leo uses immutable gnx's (id:timestamp:n) by default to associate tnodes with vnodes in .leo files.  This makes Leo as cvs friendly as possible.  From now on .leo files will be checked in to cvs with the -ko (text/keywords off) option.

- The use_gnx setting in leoConfig.txt determines whether uses gnx's (cvs friendly) or ints.  No version of Leo before 4.1 can read .leo files containing gnx.   Only gnx's are immutable.  Leo recomputes all non-gnx indices from scratch whenever writing a .leo file. It is possible to convert between 3.x and 4.1 file formats by changing the use_gnx setting.

- The 4.1 code base has been reorganized to support gui's other than tkinter.  Leo's src directory contains several new source files.

- The file test.leo in the test directory contains real regression tests for syntax coloring.   Regression testing scripts create regression tests dynamically from data in Leo's outline.  Very cool, very easy, very general.  In particular, regression tests may use temporary nodes in test.leo rather than creating separate Tk windows for testing.

Known bugs:

- The Extract commands eat one character too much.

- The __wx_gui.py plugin is only partly functional.</t>
<t tx="edream.110203163054.66">Leo 4.0.4                         October 29, 2003

- Fixed a problem with the titles in Font and Color panels.
- Worked around a Unicode assert failure in the colorizer.
- Fixed crasher in OnEndEditHeadline.
- Fixed import problems in leoPlugins.leo.
- @first and @last sentinels no longer contain corresponding text.
  This fixes a problem that affected PHP comment delimiters.

Leo 4.0.3                         October 25, 2003

- Fixes several problems with the auto_save and plugin menu plugins.
- Fixes a problem with the Go To Line Number command.

Note: This version does _not_ support Unicode file names or directory names.

Leo 4.0.2                         October 23, 2003

- Fixes a crasher in reportBadChars when a .leo file contains a character that
  can not be represented in the encoding specified in the first line of the
  .leo file.
- Leo now sends full tracebacks to the log window when Leo takes an unexpected
 exception.
- Leo now issues a more informative message when the @comment directive
  inhibits the Untangle command.

Leo 4.0.1                         October 22, 2003

- Fixes several crashers, one of which may prevent Leo from starting.
- Fixes indentation for section references that are preceded by something
  other than whitespace.
- Removes debugging traces when reading and writing unknown attributes.
- Removes some improperly cloned nodes from LeoDocs.leo.
- Adds the checkTopologyOfAllClones script.
- Fixes some problems with plugins.</t>
<t tx="edream.110203163054.67">Leo 4.0 final                     October 17, 2003

More than a year in the making, Leo 4.0 is finally here.

Highlights of 4.0 final:
-----------------------

** Improved and simplified format of derived files.
	- Eliminated child indices, extraneous blank lines and @body sentinels.
	- Eliminated @node sentinels that indicate outline structure.
	- New @nl and @nonl sentinels indicate where newlines are and aren't.
	- These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
	- Reading derived files _never_ alter outline structure or links.
	- Read errors leave the outline completely unchanged.
	- Broken clone links are gone forever.
	- As a result, 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
	- Leo 4.0 reads all derived files properly, regardless of version.
	- Leo writes new-format derived files by default, and this default may be changed.
	- New commands in the read/write menu allow you to explicitly specify the format of derived files.

* New commands:
	- Write 3.x Derived File and Write 4.x Derived File.
	- Import Derived File.
	- Clear Recent Files.

* Dozens of other improvements, including:
	- Better Unicode support.
	- New configuration settings.
	- Several new plugins.

See the notes for the various beta releases for full details.</t>
<t tx="edream.110203163054.68">Leo 4.0 beta 4                      October 13, 2003

This is the third public release of Leo 4.0. There are no known serious bugs in
this version of Leo.  This will be the last beta release before 4.0 final.

Changes made in 4.0 beta 4
--------------------------

- Changed all instances of string.letters to string.ascii_letters.
  string.letters can cause crashes in some locales (Unicode environments).
- Fixed several bugs that caused clone marks not to be set properly.</t>
<t tx="edream.110203163054.69">Leo 4.0 beta 3                      October 9, 2003

This is the third public release of Leo 4.0. There are no known serious bugs in
this version of Leo.

Highlights of 4.0 beta 3
------------------------

- Fixed problems with setting Leo's window icons.
- Plugins may now save their own information in &lt;v&gt; and &lt;t&gt; elements in .leo files.
- The usual assortment of bug fixes and minor improvements.

See the children of this node for full details.</t>
<t tx="edream.110203163054.70"></t>
<t tx="edream.110203163054.71">This was a long-standing bug.  It's effect was cosmetic, and it was important to fix.</t>
<t tx="edream.110203163054.72"></t>
<t tx="edream.110203163054.73">This could happen when the derived file was corrupted.</t>
<t tx="edream.110203163054.74"></t>
<t tx="edream.110203163054.75"></t>
<t tx="edream.110203163054.76">Leo can now read and write "foreign" attributes in &lt;v&gt; and &lt;t&gt; elements in .leo files:

- When reading a .leo file, Leo will create t.unknownAttributes or v.unknownAttributes ivars for any tnode and vnode object whose corresponding &lt;v&gt; or &lt;t&gt; element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are a dictionary whose keys are the attribute names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if  a vnode or tnode contains an unknownAttributes ivar.

- The only "native" attributes that Leo expects to find are the "tx" attribute in &lt;t&gt; elements and the "a", "t", "vtag" and "tnodeList" attributes of &lt;v&gt; elements.  Everything else is a foreign attribute.

- Leo performs the usual xml escapes on these strings when reading or writing the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching unknownAttributes ivars to a vnode or tnode.  For example:

	v.unknownAttributes = {"vnodeIcon" : pathToIcon}

It would be best not to delete other foreign attributes, so the following would be preferred:

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

Another way:

	try:
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	except AttributeError:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}</t>
<t tx="edream.110203163054.77"></t>
<t tx="edream.110203163054.78">Leo now warns if it can't find either the Icons directory or the LeoApp16.ico icon in that directory.</t>
<t tx="edream.110203163054.79">Leo 4.0 beta 2                      October 3, 2003

This is the second public release of Leo 4.0. There are no known serious bugs
in this version of Leo. Version 4.0 is the culmination of over a year of
collaborative design work and several months of actual implementation.

Highlights of 4.0 beta 2
------------------------
* Fixed several bugs:
  - Fixed several problems with reading and writing 4.0 derived files.
  - Fixed several Unicode-related bugs.
  - Fixed a crasher in the Go To Line Number command.
  - Fixed a problem with Importing Python files.
* Important improvements:
  - Added allow_clone_drags setting.  N.B. Allows Leo to be used with Aqua.
  - When running Python 2.3 Leo can now create window icons without third-party packages.
- The usual minor improvements and bug fixes.

See the children of this node for full details.

Highlights of 4.0 beta 1
------------------------
* Improved and simplified format of derived files.
* Greatly improved error handling.
* Full compatibility will previous versions of Leo.</t>
<t tx="edream.110203163054.80">- Fix undo/redo bug for all commands that change body text in multiple nodes without changing outline structure.
	- This is a long-standing bug that came to light when trying to make Read @file Nodes undoable.

- Make Read @file Nodes command undoable.

- Fix small bugs in the Go To Line Number command.</t>
<t tx="edream.110203163054.81"></t>
<t tx="edream.110203163054.82">The new code prints a warning if Leo's key internal strings are not Unicode.</t>
<t tx="edream.110203163054.83"></t>
<t tx="edream.110203163054.84">There were bugs involving saving the "Pattern Match" and "Subroutine Only" find settings.</t>
<t tx="edream.110203163054.85">@nocolor

Class level-code after the method definitions was dropped.  For example:

@color

class someclass:
	def __init__(self):
		pass

	# this code is dropped
	class_var = None

def some_proc():
	pass</t>
<t tx="edream.110203163054.86">The new code ensures that Leo creates and uses only Unicode strings internally.</t>
<t tx="edream.110203163054.87">Fixed Go To Outline command so it doesn't crash on 4.0 files.  More work is needed.</t>
<t tx="edream.110203163054.88">Under certain conditions the no sentinels at all were written when writing @rawfile trees.</t>
<t tx="edream.110203163054.89"></t>
<t tx="edream.110203163054.90"></t>
<t tx="edream.110203163054.91">This is much more natural and less cluttered.</t>
<t tx="edream.110203163054.92"></t>
<t tx="edream.110203163054.93"></t>
<t tx="edream.110203163054.94">Leo will create the Leo icon in Leo windows automatically when using Python 2.3.  The Python Imaging Library and the tkIcon package are only used when using previous versions of Python.</t>
<t tx="edream.110203163054.95">This is the foundation for "foreign" guis.</t>
<t tx="edream.110203163054.96"></t>
<t tx="edream.110203163054.97">allow_clone_drags

This is a workaround so that Leo may be used on Aqua.  When this setting is zero Leo always moves nodes when dragging.  The default is to enable clone-drags.

enable_drag_messages

Allows the user to suppress the message telling whether dragging nodes will move them or clone them.  The default is to enable those messages.</t>
<t tx="edream.110203163054.98">After the 4.0 beta 1 release I changed the default so that _new_ format derived files are written if leoConfig.txt does not exist.</t>
<t tx="edream.110203163054.99">leo.py 4.0 beta 1                      September 26, 2003

This is the first public release of Leo 4.0.  Version 4.0 is the culmination of over a year of collaborative design work and several months of actual implementation.

Please use caution when using this beta version of Leo.  It appears very solid and it has been tested by only a few people.

Highlights of 4.0:

** Improved and simplified format of derived files.
	- Eliminated child indices, extraneous blank lines and @body sentinels.
	- Eliminated @node sentinels that indicate outline structure.
	- New @nl and @nonl sentinels indicate where newlines are and aren't.
	- These changes will largely eliminate unwanted cvs conflicts.

** Greatly improved error handling.
	- Reading derived files _never_ alter outline structure or links.
	- Read errors leave the outline completely unchanged.
	- Broken clone links are gone forever.
	- As a result, using 4.0 is much safer than all previous versions.

** Full compatibility will previous versions of Leo.
	- Leo reads all derived files properly, regardless of version.
	- Leo writes new-format derived files by default, and this default may be changed.
	- New commands in the read/write menu allow you to explicitly specify the format of derived files.

* New commands:
	- Write 3.x Derived File.
	- Write 4.x Derived File.
	- Import Derived File.
	- Clear Recent Files.

- Several new plugins.
- Several minor bug fixes.

See the children of this node for full details.</t>
<t tx="edream.110203163054.100">The Synchronization Principle simplifies everything and at long last puts Leo on a firm theoretical foundation.  This principle states that the "smallest unit of meaning" of any Leo outline is the entire outline itself.  In particular, individual derived files have meaning only in the context of a particular outline.

The Synchronization Principle has the following happy consequences:

1. We may assume that all derived files are in synch with the outline that wrote them.  This assumption allows Leo to use "hidden machinery" in the outline to associate nodes in the derived file with nodes in the outline.  This "hidden" machinery consists of a list of tnodes associated with @file vnodes in the outline.  When writing a derived file Leo creates a list of tnodes in the order they were written to the derived file.  When reading the derived file, Leo uses this list to associate nodes in the derived file with nodes in the outline.

2. Derived files must get their structure from the .leo file that wrote them.  As we have seen, this is done using the hidden machinery in the .leo file.  Consequently, there is no further need to represent outline structure in derived files.  There is no need any longer either for child indices or for sentinels to represent outline structure.  As a result, we can eliminate @+body and @-body nodes entirely because all @+node sentinels are followed by body text.

3. All .leo files must contain full outline structure.  Even "thin" outline will contain the full representation of the outline as vnodes.

4. Reading _never_ alters outline structure in the outline.  No vnodes are ever created or destroyed and reading never alters clone links.  This is true whether or not read errors occur.  The read code sets a temporary attribute of tnodes while reading.  These attributes are copied to the permanent t.bodyString attribute only if no read errors were encountered.

4. Error recovery is now trivial:  Read errors indicate that the .leo files and one or more derived files are out-of-synch.  No error recovery is attempted: the @file tree in which the error occured reverts back to its original state.

5. The new Import Derived File command is the _only_ way to recover data from mismatched derived file.</t>
<t tx="edream.110203163054.101"></t>
<t tx="edream.110203163054.102">The write_old_format_derived_files option in leoConfig.leo and leoConfig.txt determines which format of derived file Leo's Write and Save commands write by default.  If this option is 0 (recommended) Leo writes 4.x format derived files.  Otherwise Leo writes 3.x derived files.

Note that you can use the Write 3.x/4.x Derived Files commands in the File:Read/Write menu to write derived files in an explicitly specified format.</t>
<t tx="edream.110203163054.103">This command deletes all entries in the Recent Files submenu except the most recent file.  The files themselves are not affected, just the menu entries.</t>
<t tx="edream.110203163054.104">The Import Derived File command imports all the nodes in a derived file into the outline.  Unlike the read commands, no outline structure is preserved.  This command can import either 3.x or 4.x derived files.

This command is necessary in version 4.0 because there is no other way to read derived files that are out-of-synch with a .leo file.</t>
<t tx="edream.110203163054.105">The Write 4.x Derived Files command and Write 3.x Derived Files command work just like the Write @file Nodes command, except that they write the indicated format off derived file.  In contrast, the Write @file Nodes command writes 3.x format derived files if and only if the write_old_format_derived_files = 1 in leoConfig.txt.

All three of these commands automatically save the outline (the .leo file) if any derived file was actually written.  This is necessary so that information in the .leo file always remains in synch with all derived files.</t>
<t tx="edream.110203163054.106">Paul Paterson contributed the following new plugins:

mod_autosave.py

Autosaves the Leo document every so often.

mod_timestamp.py

Timestamps all save operations to show when they occur.

word_export.py

Exports an outline to a word document.  Clicking "plugins ... word export ... export" exports the selected outline to Word.  Word should be running with an open (empty) document before executing this command.</t>
<t tx="edream.110203163054.107"></t>
<t tx="edream.110203163054.108">Leo's read code now warns if any non-empty node is unvisited.  This check, and the check that headlines match pretty much guarantees that out-of-synch outlines will generate errors.  Thus, there is no need a gnx timestamp in @+leo sentinels!</t>
<t tx="edream.110203163054.109">Version 4.0 is a major advance in Leo's error handling.  Using 4.0 is much safer than all previous versions.  This new error handling applies to all derived files, both 3.x and 4.x format.  

Leo's read code never alters the structure of an outline, regardless of whether read errors are encountered. This means that clone links, marks, and all other information in the outline except body text remains completely unchanged during reads.  Broken clone links (the dreaded read errors) are gone forever.  
Also, the new read code makes no changes to any body text until it is known that no read errors have occured.  This ensures that absolutely no changes at all are made to the outline if there are read errors.

Leo's read code now writes a message to the log pane whenever it sees that the body text in the derived file does not match the body text in the outline.  These messages do not indicate errors, only that the body text has been changed outside of Leo, say in an external editor or by cvs.</t>
<t tx="edream.110203163054.110"></t>
<t tx="edream.110203163054.111"></t>
<t tx="edream.110203163054.112">Added encoding comments to leoGlobals.py and french plugins

This removes a warning new in Python 2.3.
</t>
<t tx="edream.110203163054.113">There is no need to recycle Python objects when the last outline window is being closed.</t>
<t tx="edream.110203163054.114">This is too annoying during testing.  The Read @file Nodes command will in fact be made undoable for the 4.0 final release.</t>
<t tx="edream.110203163054.115">This has been changed in Python 2.3 and it probably wasn't ever a good idea...</t>
<t tx="edream.110203163054.116">The read code has much simplified using look-behind rather than look-ahead.  Both the read and write code write the file line-by-line without recursion.</t>
<t tx="edream.110203163054.117"></t>
<t tx="edream.110203163054.118"></t>
<t tx="edream.110203163054.119">leo.py 3.12 Final                       July 17, 2003

Window sizes are now in pixels rather than grid units.
You will need to resize existing outlines (.leo files).  Don't panic!

Highlights of this version:

* Plugged a huge memory leak.
* Fixed a major bug involving undo.
* Added Icon &amp; Status areas to Leo window for use by plugins.
* Important new plugins:
  - The file leoPlugins.leo now contains all plugins.
  - add_directives.py allows plugins to define new directives.
  - color_markup.py supports wiki-styled markup.
  - mod_spelling.py checks spelling (requires aspell to be installed).
  - nav_buttons.py creates browser-style navigation plugins in the icon area.
  - plugins_menu.py creates a Plugins menu items for all loaded plugins.
  - scripts_menu.py creates a Scripts menu for all scripts in scripts folder.
  - spell
  - trace_gc traces all changes to memory at idle time.
* Other enhancements:
  - Redesigned the Find panel.   Non-functional options are dimmed.
  - Added @wrap and @nowrap directives.
  - Added Write Dirty @file Nodes command.
  - Added several new "stub hooks".
  - Hyperlinks are now enabled by default.
  - Leo now loads plugins in alphabetical order.
  - Leo now remembers the size and location of Leo windows.
  - Undo now restores the insert point or the selection range after most commands.
  - Added apply button to Font panel.
  - Improved the reporting of characters that do not exist in the present encoding.
* The usual assortment of bug fixes and minor improvements.
  - There are no known bugs in this version of Leo.

See the children of this node for full details.</t>
<t tx="edream.110203163054.120"></t>
<t tx="edream.110203163054.121">Undoing the following commands could corrupt outlines:

Convert All Blanks, Convert All Tabs, Extract, Extract Names, Extract Section.</t>
<t tx="edream.110203163054.122">v.nodeAfterTree was being called way too often when handling read errors.</t>
<t tx="edream.110203163054.123">- Leo wasn't properly recycling Tk widgets when redrawing the outline pane.  This was a _huge_ leak.

- Leo now recycles all objects used by a window when that window closes.

The app.destroyAllWindowObjects() routine calls o.__dict__.clear for all objects o in a window.

- Leo now longer needs destroy() methods in each major class.</t>
<t tx="edream.110203163054.124"></t>
<t tx="edream.110203163054.125">c:\prog\leoCVS\leo\src\leoNodes.py:1174: Parameter (encoding) not used

This may have been the cause of some "unicode" problems.</t>
<t tx="edream.110203163054.126">c:\prog\leoCVS\leo\src\leoFrame.py:976: No global (a) found

This may have been the cause of some problems with the log panel.</t>
<t tx="edream.110203163054.127">Leo didn't properly import .cxx files or files with upper case extensions.</t>
<t tx="edream.110203163054.128">The messages "reading: @file x" were not always showing up during Open commands.</t>
<t tx="edream.110203163054.129">Symptom: Sometimes the "reading" messages would not appear when reading an outline.

Cause: Several event handlers are called at unpredictable times during the load process.  These may try to reset the log.

Solution:
- create app.setLog, app.lockLog and app.unlocklog methods.
- call app.lockLog before opening an outline.</t>
<t tx="edream.110203163054.130"></t>
<t tx="edream.110203163054.131">The body_pane_wraps setting is now handled properly.
</t>
<t tx="edream.110203163054.132">The body keystroke handler wasn't handling the delete character properly.</t>
<t tx="edream.110203163054.133"></t>
<t tx="edream.110203163054.134">Methods with the same name confused this command.

The Go To Line Number command will be rewritten for 4.0.</t>
<t tx="edream.110203163054.135">The following was improperly indented in @nosentinel files.  The expansion of &lt;&lt; class shape declarations &gt;&gt; was indented twice.

class shape(object):
  	&lt;&lt; class shape declarations &gt;&gt;
  	# after decls</t>
<t tx="edream.110203163054.136">- Added code to check for errors in the table passed to createOpenWithMenuFromTable.

- Revised code that checks to see whether a temp file has already been created.  The old code didn't properly take into account of file extensions when checking for already opened temp files.</t>
<t tx="edream.110203163054.137">Leo now converts all tabs to blanks as you type, not just leading blanks.</t>
<t tx="edream.110203163054.138">- Moved the code into the app class.</t>
<t tx="edream.110203163054.139">This was due to a recent change in getTextSelection.</t>
<t tx="edream.110203163054.140"></t>
<t tx="edream.110203163054.141">- Several parts of the code looped on lists that were altered in the loop.
- Fixed several bugs in the code that handled shortcuts to Open With menu items.</t>
<t tx="edream.110203163054.142">- Leo's various sort commands did not work properly if two headlines were identical.

- Eliminated the unnecessary and buggy sortSequence routine.</t>
<t tx="edream.110203163054.143"></t>
<t tx="edream.110203163054.144">Recent changes intefered with dragging nodes.</t>
<t tx="edream.110203163054.145">Here are the results from running checkClones2Links script on this file:

multipleTargetsInDerivedFiles: 8

(fixed) class nodeIndices      (improperly duplicated in leoAtFile.py)
(fixed) frame.OpenWithFileName (improperly duplicated in Recent Files submenu)
(fixed) recentButtonCallback   (improperly duplicated in Mark/Goto submenu)

-- Used several times in same derived file.  Will this be valid in LeoN?

&lt;&lt; Append any unused text to the parent's body text &gt;&gt; (used several times in leoImport.py)
&lt;&lt; Check both parts for @ comment conventions &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Compare single characters &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Set the default directory &gt;&gt; (used several times in leoAtFile.py)

-- Used (properly) in two different derived files:

replacePatterns (used on purpose in setup.py and postSetup.py)

clonedAtFileNodes: 9

@file ../plugins/add_directives.py
@file ../plugins/french_fm.py
@file ../plugins/open_with.py
@file ../plugins/vim.py
@file ../plugins/xemacs.py
@file c:\prog\test\multiple.txt
@file-nosent nosentCloneTest.txt
@silentfile ../doc/PKG-INFO.TXT
@silentfile ../doc/README.TXT
</t>
<t tx="edream.110203163054.146">Fractions cause problems in some locales.  The height/width params weren't used anyway!
</t>
<t tx="edream.110203163054.147"></t>
<t tx="edream.110203163054.148"></t>
<t tx="edream.110203163054.149">- createTopologyList creates a list containing a description of a tree.  Used by several of the new scripts.

- importFromPath encapsulates a lot of details of custom importing, and makes it unnecessary to alter sys.path.

- funcToMethod allows users to add methods to any class.  Such methods immediately become available to all objects, including existing objects!

- Added do-nothing flush method to redirect class.  This routine was added to support LeoN.</t>
<t tx="edream.110203163054.150">- The checkForPossiblyBrokenLinks script does just what it says.

- The checkClones2Links script warns if nodes are used by several derived files.</t>
<t tx="edream.110203163054.151">The new code uses a common base class for all dialogs.</t>
<t tx="edream.110203163054.152">- The new code uses proper Python lists to represent join lists.  This greatly clarifies the relevant sections of code, and may even provide a performance boost.  

- tnodes now contain both headline and body text. This change creates an important invariant:  vnodes with the same vnx's always point to tnodes with the same tnx's.  This invariant is vital to resolving conflicts properly.

- rewrote joinList code and move joinLists to tnodes.</t>
<t tx="edream.110203163054.153">- There is now only a single entry point into Leo: the run() routine.

This routine uses an optional fileName arg.

- Created runMainLoop function in leo.py so the call to mainloop() is in a separate function.

This routine was added to support LeoN.</t>
<t tx="edream.110203163054.154"></t>
<t tx="edream.110203163054.155"></t>
<t tx="edream.110203163054.156">The body_pane_wraps setting is used if neither of these directives is in effect.
</t>
<t tx="edream.110203163054.157">This make the Font panel a bit less intimidating to use.</t>
<t tx="edream.110203163054.158">- Added an "icon area" at the top of each Leo frame.  Plugins may add buttons to the Icon area at the top of each Leo frame.  See the nav_buttons.py plugin for an example of how to use this area.

- Added a "status area" at the bottom of each Leo frame.  This area reports the line and column number of the cursor.  Plugins may send status messages to this this area.

- Added convenience routines for the icon and status areas to the LeoFrame class.  Plugins may use these convenience routines to create, update, manage and destroy fields in the icon and status areas.</t>
<t tx="edream.110203163054.159">These aren't quite ready for prime time.</t>
<t tx="edream.110203163054.160"></t>
<t tx="edream.110203163054.161"></t>
<t tx="edream.110203163054.162">Hypertext links now enabled by default.  Control-click any section reference to go to its definition.  I changed the colorer so that it does _not_ underline active hyperlinks in section reference.  If a section reference is underlined, it means the definition does _not_ exist.  Otherwise the section reference _does_ exist and control-clicking the reference takes you to the defining node in one of its descendents.</t>
<t tx="edream.110203163054.163">The new code is substantially more robust than the old.</t>
<t tx="edream.110203163054.164"></t>
<t tx="edream.110203163054.165"></t>
<t tx="edream.110203163054.166">Leo was not honoring the requested size of Leo windows.

As the result of this change Leo will open old .leo files much smaller than expected.  Do not panic!  Simply resize the Leo window and save it.  The next time you open the window all will be well.</t>
<t tx="edream.110203163054.167">I have found this command to be highly annoying and unwanted.</t>
<t tx="edream.110203163054.168">This is very important for the spell-checking plugin, and is quite useful in all other situations.</t>
<t tx="edream.110203163054.169"></t>
<t tx="edream.110203163054.170"></t>
<t tx="edream.110203163054.171">- Added the following stub hooks:

"after-create-leo-frame"
"close-frame"
"create-optional-menus"
"destroy-all-global-windows"
"init-color-markup"
"new"
"redraw-entire-outline"
"scan-directives"

See the section called "About hooks" for full details.

- Changed handleLeoHook to doHook.  This simplifies the code a bit.
</t>
<t tx="edream.110203163054.172">@nowrap

At startup time Leo looks all files of the form mod_*.py in the plugins
directory. Leo assumes that these files are "plugins" containing Python modules
that customizes Leo's operation. Leo attempts to import each file.

Each module should register routines that are called at various times during
execution. Such times are identified by strings known as "tags". The code in in
one or more plugins corresponding to each tag are known as the "hook" routines
for that tag. Leo catches exceptions (including syntax errors) in hook
routines, so it is safe to hack away on this code.

Leo passes two argument to all hook routines: the tag and a keywords dictionary
containing additional information. For example, keywords["label"] indicates the
kind of command for "command1" and "command2" hooks.

For some hooks, returning anything other than None "overrides" Leo's default
action. Hooks have full access to all of Leo's source code. Just import the
relevant file. For example, top() returns the commander for the topmost Leo
window.

The following table summarizes the arguments passed to hooks: ( Overrides is
"yes" if returning anything other than None overrides Leo's normal command or
event processing.)

tag argument                                              keys in keywords
(hook name)  overrides       when called                  dictionary argument
---------    ---------       -----------                  -------------------
"bodyclick1"   yes      before normal click in body       c,v,event
"bodyclick2"            after  normal click in body       c,v,event
"bodydclick1"  yes      before double click in body       c,v,event
"bodydclick2"           after  double click in body       c,v,event
"bodykey1"     yes      before body keystrokes            c,v,ch,oldSel,undoType
"bodykey2"              after  body keystrokes            c,v,ch,oldSel,undoType
"bodyrclick1"  yes      before right click in body        c,v,event
"bodyrclick2"           after  right click in body        c,v,event
"boxclick1"    yes      before click in +- box            c,v,event
"boxclick2"             after  click in +- box            c,v,event
"command1"     yes      before each command               c,v,label (note 2)
"command2"              after  each command               c,v,label (note 2)
"drag1"        yes      before start of drag              c,v,event
"drag2"                 after  start of drag              c,v,event
"dragging1"    yes      before continuing to drag         c,v,event
"dragging2"             after  continuing to drag         c,v,event
"end1"                  start of app.quit()
"enddrag1"     yes      before end of drag                c,v,event
"enddrag2"              after  end of drag                c,v,event
"headclick1"   yes      before normal click in headline   c,v,event
"headclick2"            after  normal click in headline   c,v,event
"headrclick1"  yes      before right click in headline    c,v,event
"headrclick2"           after  right click in headline    c,v,event
"headkey1"     yes      before headline keystrokes        c,v,ch
"headkey2"              after  headline keystrokes        c,v,ch
"hypercclick1" yes      before control click in hyperlink c,v,event
"hypercclick2"          after  control click in hyperlink c,v,event
"hyperenter1"  yes      before entering hyperlink         c,v,event
"hyperenter2"           after  entering hyperlink         c,v,event
"hyperleave1"  yes      before leaving  hyperlink         c,v,event
"hyperleave2"           after  leaving  hyperlink         c,v,event
"iconclick1"   yes      before single click in icon box   c,v,event
"iconclick2"            after  single click in icon box   c,v,event
"iconrclick1"  yes      before right click in icon box    c,v,event
"iconrclick2"           after  right click in icon box    c,v,event
"icondclick1"  yes      before double click in icon box   c,v,event
"icondclick2"           after  double click in icon box   c,v,event
"idle"                  periodically (at idle time)       c,v
"menu1"        yes      before creating menus             c,v        (note 3)
"menu2"        yes      before updating menus             c,v
"open1"        yes      before opening any file           old_c,new_c,fileName (note 4)
"open2"                 after  opening any file           old_c,new_c,fileName (note 4)
"openwith1"    yes      before Open With command          c,v,openType,arg,ext
"openwith2"             after  Open With command          c,v,openType,arg,ext
"recentfiles1" yes      before Recent Files command       c,v,fileName,closeFlag
"recentfiles2"          after  Recent Files command       c,v,fileName,closeFlag
"save1"        yes      before any Save command           c,v,fileName
"save2"                 after  any Save command           c,v,fileName
"select1"      yes      before selecting a vnode          c,new_v,new_v
"select2"               after  selecting a vnode          c,new_v,old_v
"select3"               after  selecting a vnode          c,new_v,old_v
"set-mark"     no       when a mark is set                c,v           (new)
"start1"       no       after app.finishCreate()
"start2"                after opening first Leo window    c,v,fileName
"unselect1"    yes      before unselecting a vnode        c,new_v,old_v
"unselect2"             after  unselecting a vnode        c,old_v,old_v
"@url1"        yes      before double-click @url node     c,v           (note 5)
"@url2"                 after  double-click @url node     c,v           (note 5)

Notes:

(1) "activate" and "deactivate" hooks: These have been removed because they do
not work as expected.

(2) "commands" hooks: The label entry in the keywords dict contains the
"canonicalized" form of the command, that is, the lowercase name of the command
with all non-alphabetic characters removed.

Commands hooks now set the label for undo and redo commands "undo" and "redo"
rather than "cantundo" and "cantredo".

(3) "menu1" hook: Setting app().realMenuNameDict in this hook is an easy way of
translating menu names to other languages. Note: the "new" names created this
way affect only the actual spelling of the menu items, they do _not_ affect how
you specify shortcuts in leoConfig.txt, nor do they affect the "official"
command names passed in app().commandName. For example, suppose you set
app().realMenuNameDict["Open..."] = "Ouvre".

(4) "open1" and "open2" hooks: These are called with a keywords dict containing
the following entries:

old_c: The commander of the previously open window.
new_c: The commander of the newly opened window.
fileName: The name of the file being opened.

You can use old_c.currentVnode() and new_c.currentVnode() to get the current
vnode in the old and new windows.

Leo calls the "open1" and "open2" hooks only if the file is already open. Leo
will also call the "open1" and "open2" hooks if: a) a file is opened using the
Recent Files menu and b) the file is not already open.

(5) "@url1" and "@url2" hooks are only executed if "icondclick1" hook returns None.


New in version 3.12:

The following hooks are a new breed of hook, called "stub hooks". Conceptually,
these hooks are like calls to stub routines that can be filled in by code in
plugins.

tag argument                                                       keys in keywords
(hook name)               overrides        when called           dictionary argument
---------                 ---------        -----------           -------------------
"after-redraw-outline"       no        end of tree.redraw        c (note 6)
"clear-mark"                 no        when mark is set          c,v
"close-frame"                no        in app.closeLeoWindow     c
"color-optional-markup"      yes *     (note 7)                  colorer,v (note 7)
"create-optional-menus"      no        (note 8)                  (note 8)
"destroy-all-global-windows" no        (note 12)                 None
"create-popup-menu-items"    no        in tree.OnPopup           c,v,event (new)
"enable-popup-menu-items"    no        in tree.OnPopup           c,v,event (new)
"init-color-markup"          no        (note 7)                  colorer,v,s,i,j,colortag (note 7)
"new"                        no        start of New command      old_c,new_c (note 9)
"redraw-entire-outline"      yes       start of tree.redraw      c (note 6)
"scan-directives"            no        in scanDirectives         c,v,s,old_dict,dict,pluginsList (note 10)
"set-mark"                   no        when mark is set          c,v
"show-popup-menu"            no        in tree.OnPopup           c,v,event

Notes:

(6) These hooks are useful for testing.

(7) These stub hooks allow plugins to parse and handle markup withing doc
parts, comments and Python """ strings. Note that these hooks are _not_ called
in Python ''' strings. See the color_markup plugin for a complete example of
how to use these hooks.

(8) The "create-optional-menus" stub hook is called when Leo is creating menus,
at the place at which creating new menus is appropriate. Therefore, this hook
need only create new menus in the correct order, without worrying about the
placement of the menus in the menu bar. See the plugins_menu and scripts_menu
plugins for examples of how to use this hook. Leo now executes hooks in
alphabetical order, so that the Plugins menu will be created before the Scripts
menu.

(9) The "new" stub hook is called at the beginning of the code that implements
the New command. This provides a much easier way of recognizing when Leo is
about to create a new Leo window.

(10) The "scan-directives" stub hooks is called inside the scanDirectives
global function. The dictionary returned by scanDirectives now contains an item
whose key is "pluginsList". The value of this item is a list of tuples
(d,v,s,k) where:

- d is the spelling of the @directive, without the leading @.
- v is the vnode containing the directive, _not_ the original vnode.
- s[k:] is a string containing whatever follows the @directive. k has already
been moved past any whitespace that follows the @directive.

See the add_directives plugins directive for a complete example of how to use
the "scan-directives" stub hook.

(11) The "close-frame" stub hook is called in app.closeLeoWindow just before
removing the window from app.windowList. The hook code may remove the window
from app.windowList to prevent app.closeLeoWindow from destroying the window.

(12) Leo calls the "destroy-all-global-windows" hook in app.destroyAllGlobalWindows().
This hook gives plugins the chance to clean up after themselves when Leo shuts down.</t>
<t tx="edream.110203163054.173">Leo now supports two new stub hooks: "clear-mark" and "set-mark".  Both fully update the marks window, so it is important that they not be called "too often", and they aren't.

As a side effect, it is no longer necessary to update the marks window after every command that affects marks, a nice simplification and generalization of the code.

While I was at it, I moved the two dialog classes used only by the nav_buttons plugin out of leoDialog.py and into nav_buttons.py where they belong.</t>
<t tx="edream.110203163054.174">Added the "create-popup-menu", "enable-popup-menu-items" and "show-popup-menu" hooks.</t>
<t tx="edream.110203163054.175">Added the "create-popup-menu", "enable-popup-menu-items" and "show-popup-menu" hooks.</t>
<t tx="edream.110203163054.176"></t>
<t tx="edream.110203163054.177">This plugin allows users to create new directives.

As an example, this plugin creates a new @markup wiki directive.</t>
<t tx="edream.110203163054.178">This plugin supports coloring for markup in doc parts and Python triple-double-quoted strings.

At present, this plugin supports wiki-style markup, and it would be easy to change the style of markup.</t>
<t tx="edream.110203163054.179">This plugin adds 4 new buttons to the icon area at the top of each Leo window:

- Back and Forward arrows that work like a typical web browser.  Clicking the back arrow button takes you to the last node in the tree you visited.  Clicking the forward arrow button moves you forward.  The forward arrow button is dimmed unless you have clicked the back arrow button recently.

- The Recent button opens a non-modal dialog showing all the nodes you have visited recently.  This dialog is updated cleanly by the tree.select method.  You will see this entries change dynamically.  There are buttons in this dialog for clearing individual entries or clearing all entries.  Double-clicking any entry in this dialog takes you to that node, as does clicking the Go button.

The entries in the Recent Nodes pane do _not_ correspond to the order implied by the Forward and Back arrows.  Rather, the most recently visited node is on top, followed by the next most recently visited node, and so on, with the additional feature that nodes appear only once in the list.

- The Marks button opens a non-modal dialog showing all marked nodes in the tree.  Marking or unmarking nodes in the tree adds or deletes entries from this dialog.  Double-clicking any entry in this dialog takes you to that node, as does clicking the Go button.</t>
<t tx="edream.110203163054.180">This creates a plugins menu describing each loaded plugin.</t>
<t tx="edream.110203163054.181">The scripts_menu.py plugin creates a Scripts menu for all scripts in scripts folder.</t>
<t tx="edream.110203163054.182">- Leo now scans all .py files in the plugins folder when looking for plugins.

Filenames need not start with mod_, and Leo scans only the plugins folder.

- Leo loads plugins in alphabetical order.

- Leo now prints only a brief summary of the number of files loaded &amp; examined to the log file.</t>
<t tx="edream.110203163054.183">1. Created config, doc, examples, plugins, scripts, src, test &amp; tools folders.

2. Removed the following files:

- nsi.leo file.  This was a duplicate of code in LeoPy.leo.  
- bdist.bat, go.bat, help.bat, sdist.bat.
- leo.rc and leo.res.  These were resource files used by the Delphi classes.</t>
<t tx="edream.110203163054.184">These were written by Frank Merenda.</t>
<t tx="edream.110203163054.185">leo.py 3.11.1                       May 1, 2003

This version fixes two bugs:
	
- Version 3.11 had startup problems on some Linux systems.

- Creating clones by control dragging did not always work.
  This bug has existed in Leo for a long time.</t>
<t tx="edream.110203163054.186">leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.
leo.py will work on Linux, Windows and MacOs X Jaguar.

leo.py 3.11.1                       May 1, 2003

This version fixes the following bugs:

- Leo would crash on startup on some Linux systems due to a problem
  with Leo's local copy of getpreferredencoding.

- Leo sometimes did not set clone bits properly after creating a clone
  by control-dragging a node.  This bug has existed for about 6 months!

leo.py 3.11                         April 27, 2003

This version of Leo contains many important improvements since 3.10,
especially support for unicode and a new plugin architecture.

The Highlights of 3.11:

** Leo supports unicode.
	- New @encoding directives specifies encoding for derived files.
	- New settings specify default encodings for .leo and derived files.
	- Derived files specify encodings used to create them.
** A new plugin architecture for customizing Leo. (A major improvement.)
- New commands:
	- Toggle Angle Brackets.
	- Insert Time/Date (in headline or body text).
	- Go To First/Last Node, Parent, Next/Previous Sibling.
	- Write Missing @file Nodes.
	- Expand/Contract Node.
- Improved commands:
	- Fixed a huge performance bug that slowed moving nodes left.
	- Expand/Contract commands now operate on the selected tree.
	  ( A major improvement)
	- Sort Siblings command can now sort top-level nodes.
	- Leo now allows multiple writes of cloned nodes.
	  (Useful when different @path directives are in effect.)
- Other improvements:
	- New @lineending directive specifies line endings.
	- Improved syntax coloring for html and xml.
	- Leo scrolls partially visible headlines into full view.
	- Added "Replace tabs with spaces" checkbox in Prefs panel.
- New settings in leoConfig.leo/.txt.
	- Added "tk_encoding" setting and related logic.
	- Colors for Show Invisibibles command and body_insertion_cursor
	- Settings affecting when control-drags start.
	- Defaults for unicode (see above).
- Many other bug fixes and improvements.

See the children of this node for full details.</t>
<t tx="edream.110203163054.187"></t>
<t tx="edream.110203163054.188"></t>
<t tx="edream.110203163054.189">This ensures that the outline is redrawn properly after the Read @file Nodes command.</t>
<t tx="edream.110203163054.190">Browsing the comp.lang.python yesturday I found that there are serious problems with Python's getdefaultlocale() routine.  Martin v. Lwis says "getdefaultlocale() is broken, and cannot be fixed", though he does suggest the following workaround:

leoGlobals.py uses locale.getpreferredencoding to define getpreferredencoding if locale.getpreferredencoding exists (it is new in Python 2.3alpha).  Otherwise, Leo uses the code copied from the 2.3a2 version of Python to define getpreferredencoding.  Either way, leoGlobals.py now defines getpreferredencoding and Leo uses getpreferredencoding rather than getdefaultlocale.</t>
<t tx="edream.110203163054.191">After opening the Python window the call to tkFont() threw a (caught) exception on every call to frame.setTabWidth.  The fix was to add the optional root param.</t>
<t tx="edream.110203163054.192">skip_long was throwing an exception if there were no valid digits following a + or - sign.</t>
<t tx="edream.110203163054.193"></t>
<t tx="edream.110203163054.194">- tangle.scanAllDirectives was not setting self.encoding when handling @encoding.
- tangle.scanAllDirectives wasn't scanning the @encoding line properly.
- fixed crashers in Tangle and Untangle logic.</t>
<t tx="edream.110203163054.195">Fixed bug in handleLinesFollowingSentinel:
c:\prog\LeoCVS\leo\leoAtFile.py:482: No global (i) found
Removed i arg from rfind.

Fixed bug in definition of BadLeoFile:
c:\prog\LeoCVS\leo\leoFileCommands.py:27: Base class (exceptions.Exception) __init__() not called
Added call to Exception.__init__(self,message)

Fixed bug in askYesNoCancel
c:\prog\LeoCVS\leo\leoDialog.py:283: Variable (no) used before being set.
Disabled defaultButton logic.  New code would have to be thoroughly tested.

Removing unused routine: setDefaultLoc.
c:\prog\LeoCVS\leo\leoNodes.py:2581: No class attribute (defaultLoc) found

Fixed bug in put: changed a to app()
c:\prog\leoCvs\leo\leoFrame.py:4973: No global (a) found
</t>
<t tx="edream.110203163054.196">I had completely misunderstood __del__ methods!  __del__ methods _disable_ the gc's ability to collect circular garbage (!!) and so __del__ methods will _never_ be called (!!)

BTW, when deleting an entire Leo window Leo calls various destroy methods to unlink items.  This allows the garbage collector to collect all data structures.  Because of unlimited undo only these destroy methods have the potential for creating "real" garbage.</t>
<t tx="edream.110203163054.197"></t>
<t tx="edream.110203163054.198">This adds http:\\ to url's if needed.</t>
<t tx="edream.110203163054.199">New in version 3.11.  The @lineending directive allows you to specify the line endings for individual derived files.  This directive will override the output_newline setting in leoConfig.txt.  Note that @lineending _never_ affects the line endings in .leo files themselves:  we must have consistent line endings in .leo files!  See below for more details.

The valid forms of the new @lineending directive are:

@lineending nl       (the default, Linux)
@lineending cr       (Mac)
@lineending crlf     (Windows)
@lineending lf       (same as nl, not recommended)
@lineending platform (same as platform value for output_newline setting in leoConfig.txt)</t>
<t tx="edream.110203163054.200">This will have no effect until version 4.0.</t>
<t tx="edream.110203163054.201">Leo now uses unicode internally for most strings.  This solves a lot of problems.  The children of this node discuss all the details...</t>
<t tx="edream.110203163054.202">This fixes several bugs.</t>
<t tx="edream.110203163054.203">In particular, the locale returned by locale.getdefaultlocale()[1] need not be a valid unicode encoding.
</t>
<t tx="edream.110203163054.204">Leo now uses unicode internally for most strings.  The highlights:

1. Leo converts headline and body text to unicode when reading .leo files and derived files.  Both .leo files and derived files may specify their encoding, with "utf-8" being used by default.  If the encoding used in a derived file is not "utf-8" it is represented in the @+leo sentinel line.  For example:

#@+leo-encoding=iso-8859-1.

The "utf-8" encoding is a "lossless" encoding (it can represent all unicode code points), so encoding and decoding to and from utf-8 plain strings will never cause a problem.  When reading or writing a character not in a "lossy" encoding, Leo converts such characters to '?' and issues a warning. 

2. When writing .leo files and derived files Leo uses the same encoding used to read the file, again with "utf-8" used as a default.

3. leoConfig.py contains two settings used to specify the default encoding used for .leo and derived files:

default_derived_file_encoding = UTF-8 
new_leo_file_encoding = UTF-8 

I do not recommend changing new_leo_file_encoding (see the comments in leoConfig.leo) and you may set 
default_derived_file_encoding to anything that makes sense for you.

4. You may use the @encoding directive to specify the encoding used in a derived file.  You can't mix encodings in a single derived file.

This is all should need to know to use extended character sets on Leo.</t>
<t tx="edream.110203163054.205">leoConfig.py now contains two new settings, with the defaults shown below: 

default_derived_file_encoding = UTF-8 
new_leo_file_encoding = UTF-8 

These control the default encodings used when writing derived files and .leo files.

I do not recommend changing new_leo_file_encoding (see the comments in leoConfig.leo)

You may set default_derived_file_encoding to anything that makes sense for you.
</t>
<t tx="edream.110203163054.206">The following paragraphs discuss code-level details.  You should not need to read this section in order to use Leo.

1. Leo uses unicode objects in vnodes and tnodes to denote headline and body text.  Note that unicode strings have no encoding; only plain strings have encodings. This means that once an (encoded) plain string has been converted to a unicode string it doesn't matter how the unicode string was created.  This is the key that makes Leo's new code robust. 

So internally Leo never has to worry about encodings. The only times encoding matter is when encoded strings are converted to and from unicode when Leo reads or writes files (or when the passing strings to and from Tk.Text widgets, but the idea is the same).

2. Python expressions that mix unicode strings u and plain strings s, like:

	u + s 
or 
	u == s 
or 
	u[5] == s[2:]

are promoted to unicode objects using the "system encoding". This encoding should never be changed, but we can't assume that we know what it is, so for safety we should assume the most restrictive encoding, namely "ascii".  With this assumption, Leo's code can't throw an exception during these promotions provided that: 

- All strings are converted to unicode when Leo reads files or gets text from Tk.Text widgets. 
- All string literals in Leo's code have only ascii characters.</t>
<t tx="edream.110203163054.207"></t>
<t tx="edream.110203163054.208">It is now much easier to customize Leo.  The new scheme is based on plugins (files in the plugins directory) rather than modifying customizeLeo.py.  Many thanks to Paul Paterson for suggesting this scheme and for doing the first implementation.
</t>
<t tx="edream.110203163054.209">@nocolor

New in 3.11. Leo now looks in the plugins folder for files whose name matches
mod_*.py. Leo tries to import all such files at startup ("start2") time. 

The child of this node gives an example of the code that creates the Open With
menu. The following code, appearing at the end of mod_open_with.py, registers
two different hook functions. The on_idle function is the "idle" hook. The
create_open_with_menu is the "start2","open2" and "command2" hooks.
@color

if 1: # Register the handlers... 
	registerHandler("idle", on_idle) 
	registerHandler(("start2","open2","command2"), create_open_with_menu) 
	es("...open with")
	
@nocolor
Plugins may call registerHandler with a hook name like "idle" or a list of hook
names like ("start2","open2","command2"). Also, you can use the "all" hook name
to indicate that code will be called for all hooks. This is useful for tracing
hooks. Plugins may also call registerExclusiveHandler for hooks that should not
be redefined in other plugins.

mod_open_with.py also contains the on_idle and create_open_with functions that
actually handle the hook. Such functions have two arguments: tag and keywords.
You will find many examples of this in LeoPy.leo.

About distribution:

1. LeoPy.leo now contains all the plugins in @ignore'd @file nodes. This way
Leo won't complain when you open LeoPy.leo.

2. Most plugins actually are disabled: the code that registers the hooks is
contained in #if 0: blocks. So to create a pluging you have to remove the
@ignore and you have to change #if 0: to #if 1.

3. Most mod_*.py will never be part of Leo distributions, and the single-click
installer will create an plugins folder containing just mod_open_with.py.

4. There is no longer a need for a customizeLeo.py file.

About error checking:

At present Leo will disable all hooks if any hook throws an exception. In
practice this isn't a big deal, but obviously something better could be done. I
won't do anything until after 3.11b1 goes out.

How to send me your plugins:

It should now be _much_ easier to submit a plugin for inclusion in LeoPy.leo.
Just send me a .leo file containing @file mod_your_plugin.py. Please have this
@file node be @ignored: this is more convenient for me. Ideally, your .leo file
should contain _only_ your plugin code.</t>
<t tx="edream.110203163054.210">@color
@language python
@ignore

"""Open With handler"""

from customizeLeo import *
from leoGlobals import *

@others

if 1: # Register the handlers...
	registerHandler("idle", on_idle)
	registerHandler(("start2","open2","command2"), create_open_with_menu)
	es("...open with")</t>
<t tx="edream.110203163054.211"># frame.OnOpenWith creates the dict as follows:
# dict = {"c":c, "v":v, "f":f, "path":path, "time":time}

def on_idle (tag,keywords):

	import os
	a = app()
	for dict in a.openWithFiles:
		path = dict.get("path")
		c = dict.get("c")
		v = dict.get("v")
		if path and os.path.exists(path):
			try:
				time = os.path.getmtime(path)
				if time and time != dict.get("time"):
					dict["time"] = time
					&lt;&lt; update v's body text &gt;&gt;
			except: pass</t>
<t tx="edream.110203163054.212">&lt;&lt; set s to the new text &gt;&gt;
body = v.bodyString()
&lt;&lt; set conflict flag &gt;&gt;

if conflict:
	# Report the conflict &amp; set update.
	import leoDialog
	d = leoDialog.leoDialog()
	message = "Conflict in %s.\n\n" % (v.headString())
	message += "Replace outline with external changes?"
	update = d.askYesNo("Conflict!",message) == "yes"
else:
	update = s != body

if update:
	h = v.headString()
	es("changed:" + h)
	v.setBodyStringOrPane(s)
	c.selectVnode(v)
	v.OpenWithOldBody = s
</t>
<t tx="edream.110203163054.213">try:
	# Update v from the changed temp file.
	f=open(path)
	s=f.read()
	f.close()
except:
	es("can not open " + shortFileName(path))
	break
</t>
<t tx="edream.110203163054.214">try:
	# The OpenWithOldBody attribute does not normally exist in vnodes.
	old_body = v.OpenWithOldBody
	conflict = body != old_body and body != s
except:
	conflict = v.isDirty() and body != s
</t>
<t tx="edream.110203163054.215">def create_open_with_menu (tag,keywords):

	if  (tag in ("start2","open2") or
		(tag=="command2" and keywords.get("label")=="new")):
	
		&lt;&lt; create the Open With menu &gt;&gt;

		# Enable the idle-time hook so we can check temp files created by Open With.
		from leoGlobals import enableIdleTimeHook
		enableIdleTimeHook(idleTimeDelay=500)
</t>
<t tx="edream.110203163054.216">@ Entries in the following table are the tuple (commandName,shortcut,data).
data is the tuple (command,arg,ext).
command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the extension ext,
Otherwise, Leo computes an extension based on what @language directive is in effect.
@c

idle_arg = "c:/python22/tools/idle/idle.py -e "

if 1: # Default table.
 table = (
  ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
  ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
  ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
else: # David McNab's table.
 table = (
  ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)))

top().frame.createOpenWithMenuFromTable(table)
</t>
<t tx="edream.110203163054.217">Simplified and regularized hooks:

- replaced "event1" and "event2" hooks with 'regular' hooks.
	* Much easier to understand.
- added "iconrclick" hooks.
- added "bodyrclick" hooks.
- added "save1" and "save2" hooks
- added "dragging" hooks.
	* These are called when drag hook called while already dragging.
- added "hyperenter" and "hyperleave" hooks.
	* These only fire if use_hyperlinks = 1 in leoConfig.txt.
- removed "activate" and "deactivate" hooks.
	* These were not reliable.
- almost all hooks now have c,v arguments.
- "command" hooks now return "undo" and "redo" rather than "cantundo" and "cantredo"

Improved code:

- improved the tracing of hooks.
- the tracing code also checks to make sure that most hooks have c,v keywords.
- created es_event_exception().
- put all event handlers in try/except blocks that call es_event_exception on errors.</t>
<t tx="edream.110203163054.218">At startup time Leo looks all files of the form mod_*.py in the plugins
directory. Leo assumes that these files are "plugins" containing Python modules
that customizes Leo's operation. Leo attempts to import each file.

Each module should register routines that are called at various times during
execution. Such times are identified by strings known as "tags". The code in in
one or more plugins corresponding to each tag are known as the "hook" routines
for that tag. Leo catches exceptions (including syntax errors) in hook
routines, so it is safe to hack away on this code.

Leo passes two argument to all hook routines: the tag and a keywords dictionary
containing additional information. For example, keywords["label"] indicates the
kind of command for "command1" and "command2" hooks.

For some hooks, returning anything other than None "overrides" Leo's default
action. Hooks have full access to all of Leo's source code. Just import the
relevant file. For example, top() returns the commander for the topmost Leo
window.

The following table summarizes the arguments passed to hooks: ( Overrides is
"yes" if returning anything other than None overrides Leo's normal command or
event processing.)

tag argument                                              keys in keywords
(hook name)  overrides       when called                  dictionary argument
---------    ---------       -----------                  -------------------
"bodyclick1"   yes      before normal click in body       c,v,event (new)
"bodyclick2"            after  normal click in body       c,v,event (new)
"bodydclick1"  yes      before double click in body       c,v,event (new)
"bodydclick2"           after  double click in body       c,v,event (new)
"bodykey1"     yes      before body keystrokes            c,v,ch,oldSel,undoType
"bodykey2"              after  body keystrokes            c,v,ch,oldSel,undoType
"bodyrclick1"  yes      before right click in body        c,v,event (new)
"bodyrclick2"           after  right click in body        c,v,event (new)
"boxclick1"    yes      before click in +- box            c,v,event (new)
"boxclick2"             after  click in +- box            c,v,event (new)
"command1"     yes      before each command               c,v,label (note 2)
"command2"              after  each command               c,v,label (note 2)
"drag1"        yes      before start of drag              c,v,event (new)
"drag2"                 after  start of drag              c,v,event (new)
"dragging1"    yes      before continuing to drag         c,v,event (new)
"dragging2"             after  continuing to drag         c,v,event (new)
"end1"                  start of app.quit()
"enddrag1"     yes      before end of drag                c,v,event (new)
"enddrag2"              after  end of drag                c,v,event (new)
"headclick1"   yes      before normal click in headline   c,v,event (new)
"headclick2"            after  normal click in headline   c,v,event (new)
"headrclick1"  yes      before right click in headline    c,v,event (new)
"headrclick2"           after  right click in headline    c,v,event (new)
"headkey1"     yes      before headline keystrokes        c,v,ch
"headkey2"              after  headline keystrokes        c,v,ch
"hypercclick1" yes      before control click in hyperlink c,v,event (new)
"hypercclick2"          after  control click in hyperlink c,v,event (new)
"hyperenter1"  yes      before entering hyperlink         c,v,event (new)
"hyperenter2"           after  entering hyperlink         c,v,event (new)
"hyperleave1"  yes      before leaving  hyperlink         c,v,event (new)
"hyperleave2"           after  leaving  hyperlink         c,v,event (new)
"iconclick1"   yes      before single click in icon box   c,v,event (new)
"iconclick2"            after  single click in icon box   c,v,event (new)
"iconrclick1"  yes      before right click in icon box    c,v,event (new)
"iconrclick2"           after  right click in icon box    c,v,event (new)
"icondclick1"  yes      before double click in icon box   c,v,event (new)
"icondclick2"           after  double click in icon box   c,v,event (new)
"idle"                  periodically (at idle time)       c,v
"menu1"        yes      before creating menus             c,v (note 3)
"menu2"        yes      before updating menus             c,v
"open1"        yes      before opening any file           old_c,new_c,fileName (note 4)
"open2"                 after  opening any file           old_c,new_c,fileName (note 4)
"openwith1"    yes      before Open With command          c,v,openType,arg,ext
"openwith2"             after  Open With command          c,v,openType,arg,ext
"recentfiles1" yes      before Recent Files command       c,v,fileName,closeFlag
"recentfiles2"          after  Recent Files command       c,v,fileName,closeFlag
"save1"        yes      before any Save command           c,v,fileName
"save2"                 after  any Save command           c,v,fileName
"select1"      yes      before selecting a vnode          c,new_v,new_v
"select2"               after  selecting a vnode          c,new_v,old_v
"start1"       no       after app.finishCreate()
"start2"                after opening first Leo window    c,v,fileName
"unselect1"    yes      before unselecting a vnode        c,new_v,old_v (new)
"unselect2"             after  unselecting a vnode        c,old_v,old_v (new)
"@url1"        yes      before double-click @url node     c,v (note 5)
"@url2"                 after  double-click @url node     c,v (note 5)

Notes:

(1) "activate" and "deactivate" hooks: These have been removed because they do
not work as expected.

(2) "commands" hooks: The label entry in the keywords dict contains the
"canonicalized" form of the command, that is, the lowercase name of the command
with all non-alphabetic characters removed.

Commands hooks now set the label for undo and redo commands "undo" and "redo"
rather than "cantundo" and "cantredo".

(3) "menu1" hook: Setting app().realMenuNameDict in this hook is an easy way of
translating menu names to other languages. Note: the "new" names created this
way affect only the actual spelling of the menu items, they do _not_ affect how
you specify shortcuts in leoConfig.txt, nor do they affect the "official"
command names passed in app().commandName. For example, suppose you set
app().realMenuNameDict["Open..."] = "Ouvre".

(4) "open1" and "open2" hooks: These are called with a keywords dict containing
the following entries:

old_c: The commander of the previously open window.
new_c: The commander of the newly opened window.
fileName: The name of the file being opened.

You can use old_c.currentVnode() and new_c.currentVnode() to get the current
vnode in the old and new windows.

Leo calls the "open1" and "open2" hooks only if the file is already open.
Leo will also call the "open1" and "open2" hooks if:
a) a file is opened using the Recent Files menu and
b) the file is not already open.

(5) "@url1" and "@url2" hooks are only executed if "icondclick1" hook returns
None.</t>
<t tx="edream.110203163054.219">See the Code:Customizing Leo:Plugins folder in LeoPy.leo for full details of all plugins.

- Added disabled support for @folder.

- Demoted up/down arrow stuff to a disabled plugin for now.</t>
<t tx="edream.110203163054.220">The idle-time hook now checks for dirty @file nodes that have been modified in an external editor since the last check.  An alert is raised when such conflicting changes are found.

Improved sanitize_filename utility (in leoGlobals.py) so that it converts all characters used to denote filenames to underscores.</t>
<t tx="edream.110203163054.221">This allows output from registering hooks to appear in the log pane.</t>
<t tx="edream.110203163054.222"></t>
<t tx="edream.110203163054.223">The following new plugins are now in LeoPy.leo.

- mod_script_io_to_body.py
	Redirect output from scripts to end of body pane.

- mod_vim.py
	Adds support for VIM editor.

- mod_french_fm.py
	Full translation of all Leo's menus into French.</t>
<t tx="edream.110203163054.224">Added support for the following options:

show_invisibles_space_background_color
show_invisibles_tab_background_color
</t>
<t tx="edream.110203163054.225">This option controls when the control key is considered to start a control-drag.

If look_for_control_drag_on_mouse_down = 1 the the control key must be down when dragging starts.  Otherwise, the control key must be down when dragging ends.</t>
<t tx="edream.110203163054.226">This allows Leo to be used with a black background.</t>
<t tx="edream.110203163054.227">Two new settings in leoConfig.leo/.txt specify the format of the time/date
strings inserted by the Insert Body Time/Date and Insert Headline Time/Date
commands:

body_time_format_string
headline_time_format_string

These settings are really the format string passed to time.strftime(format).

See http://www.python.org/doc/current/lib/module-time.html for a complete list
of the format options. The "%m/%d/%Y %H:%M:%S" format is used by default,
resulting in a time/date format such as: 1/30/2003 8:31:55

</t>
<t tx="edream.110203163054.228"></t>
<t tx="edream.110203163054.229">- if the headline is bracketed (named) then the &lt;&lt; &gt;&gt; are removed.
- if the headline is not bracketed (unnamed) then the &lt;&lt; &gt;&gt; are inserted. 
</t>
<t tx="edream.110203163054.230">The Insert Body Time/Date and Insert Headline Time/Date commands are in the
Edit Body and Edit Headline menus respectively. They insert the formatted time
&amp; date into the body or headline text. You must be editing a headline to be
able to insert the time/date into the headline. If you aren't Leo will say:
"Edit headline to append date/time"

Two new settings in leoConfig.leo/.txt specify the time/date format:

body_time_format_string
headline_time_format_string

These settings are really the format string passed to time.strftime(format).

See http://www.python.org/doc/current/lib/module-time.html for a complete list
of the format options. The "%m/%d/%Y %H:%M:%S" format is used by default,
resulting in a time/date format such as: 1/30/2003 8:31:55</t>
<t tx="edream.110203163054.231">These commands select the first or last node of an outline and make that node visible.</t>
<t tx="edream.110203163054.232">This command selects the parent of the previously selected node and makes that node visible.</t>
<t tx="edream.110203163054.233">These commands select the previous or following sibling of a node and make the newly selected node visible.</t>
<t tx="edream.110203163054.234">This command writes any files (in the presently selected outline) that do not exist.</t>
<t tx="edream.110203163054.235"></t>
<t tx="edream.110203163054.236">This allows time to be expressed as local time or gmttime.</t>
<t tx="edream.110203163054.237"></t>
<t tx="edream.110203163054.238">The Expand To Level n commands now expand only the nodes in the presently selected outline.  This makes these commands much more useful.

With these changes there is no longer any need for the Expand Subheads command.</t>
<t tx="edream.110203163054.239">This can be useful when clones are in the range of different @path directives.</t>
<t tx="edream.110203163054.240"></t>
<t tx="edream.110203163054.241">1. Leo now longer warns when writing customizeLeo.py.

2. Inserted a lock that prevents customizeLeo.py from being written unless use_customize_leo_dot_py = 1 in leoConfig.txt.  Leo writes a message to the log if customizeLeo.py is dirty but was not written because of the setting in leoConfig.txt.
</t>
<t tx="edream.110203163054.242"></t>
<t tx="edream.110203163054.243"></t>
<t tx="edream.110203163054.244"></t>
<t tx="edream.110203163054.245">This makes the file name easier to see in the Windows task bar.
</t>
<t tx="edream.110203163054.246"></t>
<t tx="edream.110203163054.247">This allows Leo to syntax color comments with @language plain.
The @comment directive must follow the @langauge directive.</t>
<t tx="edream.110203163054.248">In other words, the Pressing the Enter key in the Find panel executes the Find Next command.
</t>
<t tx="edream.110203163054.249">The syntax colorer now colors all element tags.  See the example in the child of this node.</t>
<t tx="edream.110203163054.250">@language html
@color
@ignore
&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</t>
<t tx="edream.110203163054.251">- Added "Replace tabs with spaces" checkbox.

- The close button is equivalent to the "Cancel" button rather than the "Ok" button.</t>
<t tx="edream.110203163054.252">This was causing great confusion.</t>
<t tx="edream.110203163054.253"></t>
<t tx="edream.110203163054.254"></t>
<t tx="edream.110203163054.255">- There was a bug that prevented the command from working properly if the line number preceeded the present line.

- The goto line number option only works on full path names in @file nodes. 
It does not work for relative paths or in combination with an @path directive.</t>
<t tx="edream.110203163054.256">This problem only arose with languages such as html that have no single-line comment delimiter.
</t>
<t tx="edream.110203163054.257"></t>
<t tx="edream.110203163054.258">Leo did not properly handle configuration settings containing the % character.
</t>
<t tx="edream.110203163054.259"></t>
<t tx="edream.110203163054.260">Double-clicking the icon box used to set the cursor to the hand.
</t>
<t tx="edream.110203163054.261">Every call to v.unjoinNode was calling c.clearAllVistied.

Fixing this bug will allow me not to use inodes &amp; locations for the foreseeable future.</t>
<t tx="edream.110203163054.262"></t>
<t tx="edream.110203163054.263"></t>
<t tx="edream.110203163054.264">In the unusual case that a language has no single-line comment delimiter, Leo will remove the block delimiters from the headline text in node sentinels.  createNthChild must take this into account by doing a second comparison of headlines if the normal comparison fails.  If the second comparison of headlines succeeds we assume that we should use the headline from the outline instead of the derived file.  I believe some kind of kludge like this will also be required for 4.0.</t>
<t tx="edream.110203163054.265">- Translating the "Tangle..." label differently from the "Tangle" one was 
impossible without modifying leo's source code (same thing for "Untangle..." 
and "Untangle").

- Couldn't translate either "Show Invisibles" and "Hide Invisibles". First 
toggle is OK then an error occurs after the second...</t>
<t tx="edream.110203163054.266">- changed copyPart so it returns on @code as well as @c.

- changed convertVnodeToWeb so that it takes acount of the "at_root_bodies_start_in_doc_mode" setting.

- For the most part, directives other than @c, @code, @space, @doc, @others get written to the file as @@directive.  There are minor differences between how this is handled in @root and @file trees. This might be considered a bug, and I am not going to do anything unless someone complains loudly.
</t>
<t tx="edream.110203163054.267">Enabling or disabling @language or @comment now recolors entire text.</t>
<t tx="edream.110203163054.268"></t>
<t tx="edream.110203163054.269">I had forgotten to compile leo.nsi.</t>
<t tx="edream.110203163054.270"></t>
<t tx="edream.110203163054.271"></t>
<t tx="edream.110203163054.272">Python 2.3a1 contains a bug in the tkinter code.  This bug has been fixed on Python's cvs site.  Until this bug is fixed in an official Python release Leo must use:

true,false = 1,0

rather than:

true,false = True,False</t>
<t tx="edream.110203163054.273">leo.py 3.10                             December 14, 2002

This version of Leo corrects bugs, improves Leo's documentation and adds many new features:

- Rewrote the Scripting Chapter in Leo's Users Guide.
- Improved the Customization Chapter of the Users Guide.
- Adds several customizations contributed by Leo's users.
  Among these: @read-only nodes. Reading empty .leo files.
  Redirecting stderr and stdout to Leo's log pane.
- New Mark Clones and Go To Next Clone commands.
- New Export Headlines command.
- Control-dragging a node now clones it.
- New "Node Only checkbox in the Find/Change panel.
- @root-code trees start in code mode by default.
  This allows @root trees to work like @file trees.
- @root-doc  trees start in doc  mode by default.
- Converted leoConfig.py to use @root-code
- New at_root_bodies_start_in_doc_mode option in leoConfig.py.
  Specifies whether @root trees work like @root-code or @root-doc.
- New synonyms: @file-asis = @silentfile
  @file-nosent = @nosentinelsfile ; @file-noref = @rawfile.
- Leo now supports navigation of menus using underlined menus.
- Added an easy way to replace any Leo method by a function.
  The code in customizeLeo.py can now override any part of Leo's code!
- Added routines to redirect stderr and stdout to Leo's log pane.
  These routines can be called from customizeLeo.py.
- Added "event1" and "event2" hooks for customize event handling.
- Improved Leo's window icon, and improved how that icon is loaded.
- The usual assortment of bug fixes and minor improvements.
  Actually, this release fixes more than the usual number of bugs.

See the children of this node for full details.

The quote of the month:

I must say I am very impressed. I have been absolutely seduced by Leo over the
past few days. I tell you, I can not put it down. I feel like a kid with a
shiny new bike...I'm already bursting with new ways I'd like to use the tool in
the future -- Lyn Adams Headley</t>
<t tx="edream.110203163054.274"></t>
<t tx="edream.110203163054.275">The old code did not allow &lt;tag /&gt; in many cases.  The new code reads minimal.leo without complaint.  It is:

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="2" /&gt;
&lt;globals /&gt;
&lt;preferences /&gt;
&lt;find_panel_settings /&gt;
&lt;vnodes /&gt;
&lt;tnodes /&gt;
&lt;/leo_file&gt;
</t>
<t tx="edream.110203163054.276">Apparently the F4 shortcuts interferes with the Alt-F4 shortcut.</t>
<t tx="edream.110203163054.277">The content formerly on evisa.com, including the Leo tutorials is now on 3dtree.com.</t>
<t tx="edream.110203163054.278">Leo improperly added extra blank lines and tabs in @file-noset trees.</t>
<t tx="edream.110203163054.279">Untangle was warning about a missing section if the section had only an @doc part.</t>
<t tx="edream.110203163054.280">Leo was not handling the class keyword properly.</t>
<t tx="edream.110203163054.281">When leo.py was launched from the command line specifying a non-existent file the message "file not found" was displayed but the outline pane was not drawn properly.</t>
<t tx="edream.110203163054.282">@nosentinelsfile nodes were not being marked dirty properly.

Also, the message in atFile.writeAll about "no @file node found"  did not include these nodes.  The message was generalized.</t>
<t tx="edream.110203163054.283">While scanning for the initial state we must make sure that i &lt; old_len and i &lt; new_len.

Leo was not handling Python ''' strings properly.</t>
<t tx="edream.110203163054.284">It is not correct to do:

	exec s in __builtins__

because that pollutes the namespaces of the __builtin__ module.  Correct is simply:

  exec s in {}</t>
<t tx="edream.110203163054.285">Previous versions of Leo did not properly recycle bindings in the outline pane.

This was reported by David LeBlanc and fixed with major hints from Chad Netzer.
</t>
<t tx="edream.110203163054.286"></t>
<t tx="edream.110203163054.287"></t>
<t tx="edream.110203163054.288">The lambda functions for callbacks were not working properly.</t>
<t tx="edream.110203163054.289">The fix was made to atFile.scanAllDirectives() and leoGlobals.scanDirectives()
tangle.scanAllDirectives() was not affected.

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):</t>
<t tx="edream.110203163054.290">This bug was created recently by the new underline/realMenuName logic.  We must not set the undo/redoRealMenuName ivars in clearUndoState: that should only be done when actually setting the menu names.</t>
<t tx="edream.110203163054.291"></t>
<t tx="edream.110203163054.292">Both command are enabled only if the presently selected node is a clone.  Mark Clones marks all nodes that are clones of the present node.  Go To Next Clone goes to the next node that is a clone of the present node. A little experimentation convinced me that this command should wrap.  So this command endlessly cycles among the nodes.  Trying to end the this endless cycling would not be easy, as my experience with the Find command shows.

These are straightforward (and surprisingly useful) commands.  Please report any problems immediately.</t>
<t tx="edream.110203163054.293">This works just like the Flatten Outline command except it writes only headlines.</t>
<t tx="edream.110203163054.294">How did I ever live without this.

Also improved messages and fixed a major performance bug: tree.numberOfVisibleNodes was being called repeatedly!</t>
<t tx="edream.110203163054.295">The Node Only checkbox takes precedence over Suboutline Only if they are both checked.</t>
<t tx="edream.110203163054.296">For the first time Leo allows you to choose whether body text in @root trees will start in code mode or doc mode by default.  Ever since I created @file trees I've regretted the choice of making doc mode the default.  Just last week I realized I'm not stuck with that old choice.

1. @root-doc filename and @root-code filename specify that body text is assumed to start in doc mode or code mode respectively.  The options (-doc and -code) must follow @root immediately with no intervening whitespace.  In effect, @root-code and @root-doc are two new directives.  (They aren't syntax colored yet: they will be today or tomorrow.)

2. These @root options override the new at_root_bodies_start_in_doc_mode option in leoConfig.py.  This option affects only @root trees without options.  Such "plain" @root trees are now deprecated, which only means that it is now better style to use either @root-code or @root-doc.  The reason is simple: the meaning of plain @root trees will depend on the at_root_bodies_start_in_doc_mode option, and that isn't good.

3. By default, at_root_bodies_start_in_doc_mode = 1 for compatibility for old @root trees.  I actually don't think this option is good for much; I created it before I created @root-doc and @root-code, and I decided it wouldn't hurt to leave it in.  Anyway, you now have complete flexibility about how @root works, and in particular you can make @root work just like @file.</t>
<t tx="edream.110203163054.297"></t>
<t tx="edream.110203163054.298">@file-asis is a synonym for @silentfile.
@file-nosent is a synonym for @nosentinelsfile.
@file-noref is a synonym ffor @norefsfile.

</t>
<t tx="edream.110203163054.299">Completed a major revision of the menu handling code to handle underlined menus.  As is typical on Windows, you specify the underlined character by preceding it with an ampersand character.</t>
<t tx="edream.110203163054.300">Created a new icon and improved the code that loads it.</t>
<t tx="edream.110203163054.301">This is the funcToMethod function in customizeLeo.py.</t>
<t tx="edream.110203163054.302">See the relevant section of customizeLeo.py</t>
<t tx="edream.110203163054.303">"event1" and "event2" are generated for many Leo events. keywords.get("kind") returns one of the following for "event1" and "event2" hooks:

"activate",             activate window event   (not uniform across window managers).
"deactivate"            deactivate window event (not uniform across window managers).
"boxClick"              The +- box has been clicked.
"drag"                  Generated repeated while dragging nodes.
"endDrag"               mouseUp that ends a drag.
"headClick"             Left-click in a headline.
"headPopup"             Right-click in a headline.
"headKey"               A keypress in a headline.
"hyperLinkControlClick" Control-click on a hyperlink.
"hyperLinkEnter"        Mouse moves over a hyperlink.       Disabled at present.
"hyperLinkLeave"        Mouse moves away from a hyperlink.  Disabled at present.
"iconDoubleClick"       The icon box has been double-clicked.</t>
<t tx="edream.110203163054.304"></t>
<t tx="edream.110203163054.305"></t>
<t tx="edream.110203163054.306">The present code properly handles undo/redo for operations that copy trees, but copying trees itself causes problems for further undoes.  I've disabled further undos, as was done previously, but this is a pity.

To fix this, we may have to hack on the beads to indicated that a copy has been made.  No doubt about it: copying trees is tricky.</t>
<t tx="edream.110203163054.307">leo.py 3.9                               Nov 23, 2002

This is one of the most interesting versions of Leo ever released:

* Major performance improvements:
  - Incremental syntax coloring speeds response when typing.
  - Incremental undo drastically reduces memory used.

* Major improvements in customizing Leo:
  - Leo looks in the file customizeLeo.py for user-specific customizations.
  - Leo calls "hook routines" in customizeLeo.py for all commands and events.
    These hook routines can modify or replace any command or event.
  - New convenience routines simplify creating and modifying menus.
  - Easy translation of menus to other languages using customizeLeo.py.

* Better integration with other tools:
  - The Open With command allows you to communicate back and forth to other editors.
  - The Go To Line Number command converts lines numbers in derived files
    to locations in the outline.
  - Double-clicking the icon of a @url node launches any url in your web browser.
  - The Execute Script command executes Python code in any body pane.
    This is much more convenient than opening Leo's Idle window.
  - Much better support for cweb. At last, Leo has a power user of cweb.
    By default, @space, @* and @** sections are colored as latex text.
    Leo properly generates @q..@&gt; sentinels.
  - @nosentinelfile is like @file except Leo writes no sentinel lines.

* Other improvements:
  - Optional Emacs-style auto-indent.
  - Reformat Paragraph command.
  - Leo will optionally create nonexistent directories specified in
    @file, @root or @path, including all nonexistent parent directories.
  - Leo will place its own icon in Leo windows provided that you have
    installed Fredrik Lundh's PIL and tkIcon packages.
  - The usual assortment of bug fixes.

See the children of this node for full details.

P.S. Here is what Travers A. Hough recently said about Leo:

"When first I opened Leo, it was out of curiosity.  But having used it...I'LL NEVER GO BACK. THEY'LL HAVE TO PRY LEO OUT OF MY COLD, DEAD FINGERS! Seriously, it should be renamed "Crack Cocaine" because it's that addictive. I'm ready to start a 12-Step group."
</t>
<t tx="edream.110203163054.308"></t>
<t tx="edream.110203163054.309">The cweb prefs panel setting was overriding @language python (!)</t>
<t tx="edream.110203163054.310">@language pascal
@color

private
uses</t>
<t tx="edream.110203163054.311">app().log is now set correctly when there are multiple windows.  Previously, app().log depended on activate events, and was not reliable.  The following routines now set app().log:

- frame.doCommand
- frame.OnMenuClick

Thus, top() will be reliable after any command is executed.  Creating a new window and opening a .leo file also set app().log correctly, so it appears that all holes have now been plugged.

Note: The value of top() may change during a new or open command, which may change the routine used to execute the "command1" and "command2" hooks.  This is not a bug, and hook routines must be aware of this fact.
</t>
<t tx="edream.110203163054.312">Leo no longer massages comments when importing Java files.

There was a bug in massageBody that prevented text from being undented properly.  There was a bug in find_line_start (!!) that caused the start of the _previous_ line to be found if s[i] was a newline.  It's amazing that these bugs were undiscovered for so long.

Treat interface like class.</t>
<t tx="edream.110203163054.313"></t>
<t tx="edream.110203163054.314">Version 3.9 contains many new features and commands.  The children of this node document them.</t>
<t tx="edream.110203163054.315"></t>
<t tx="edream.110203163054.316">Undo now uses incremental syntax coloring.  This speed up undo tremendously.</t>
<t tx="edream.110203163054.317">Previous versions of Leo stored the complete body text whenever any change was made to the body text.  The present version of undo stores only enough information to undo or redo the typing: typically two lines of text.  This results in about a 90% reduction in the memory used by undo.
</t>
<t tx="edream.110203163054.318">These are discussed in the child of this node.</t>
<t tx="edream.110203163054.319">@nocolor

You may customize Leo in several ways:

I.  Using leoConfig.txt

When Leo first starts, Leo looks for a file called leoConfig.txt, derived from leoConfig.leo, which contains extensive documentation for each setting.  The settings in leoConfig.txt include:

- Fonts used in Leo's body, outline and log panes.
- Colors used for syntax coloring.
- Menu shortcuts for all menu items.
- Sizes and splitter orientation for newly created windows.
- Initial entries in the Recent Files menu, and the Find, Preferences and Compare panels.
- The format of .leo files.

The section called "Using leoConfig.leo and leoConfig.txt" gives the rules for how Leo uses these two files.

II. Using plugins and hooks

New in 3.11:  It is no longer necessary to modify customizeLeo.py.  Instead of modifying customizeLeo.py you now should add plugins to the plugins directory.  In fact, customizeLeo.py will soon disappear entirely.

During startup, Leo looks for plugins, i.e., files whose name matches mod_*.py in the plugins directory.  These plugins register functions called "hooks" to be called a various times during execution.  Full details are provided below.

Plugins provide the following advantages:

- Any time you see a nice hook handler that someone has written you can just copy it to a plugin file and it runs next time you start Leo.
- You don't have to keep updating a large and growing customizeLeo.py file.
- You can disable and enable hooks by renaming the relevant plugin file.
  (or by enabling or disabling the code in the plugin that registers hook functions).
- You don't have to merge code from hooks pertaining to the same Leo event.

When executing any command or handling any event, Leo calls hook routines registered from the plugin files.  The arguments to hooks are:

- "tag", a string telling the kind of command or event about to be executed, and
- "keywords", a Python dictionary whose keys depend on the specific command or event.

This is a very simple, powerful and general mechanism for customizing Leo as you see fit.  There are dozens of kinds of hooks, including the "command1" and "command2" hooks that are called before and after each of Leo's menu commands.  Leo will allow you to override most commands and event handling.  In many cases, if a hook returns any value except None Leo will assume that the hook has completely handled the command or event and will take no further action.  The details will be explained in full below.

Leo catches all exceptions raised in hook code, so you can modify hooks without worry.

SECURITY WARNINGS: Using hooks naively can create the potential for virus-like behavior.  Please read the section called SECURITY WARNINGS for full details.

III. Using convenience routines called from hooks.

Hook routines can import any file in Leo's source code and execute routines in that file.  Leo's contains a number of convenience routines designed to make common customization tasks easier.  Hooks can use these routines to create your own menus, to translate menus into other languages, and to create entries in the Open With menu.  These convenience routines are discussed in detail below.

IV. Setting app().realMenuNameDict inside hooks to translate menus into other languages.

This is discussed below.</t>
<t tx="edream.110203163054.320">@nocolor

Leo will override settings in .leo files if it finds a file called leoConfig.txt in the config subdirectory.  Leo works just as before if it does not find a leoConfig.txt file.

You should make changes to leoConfig.txt by changing leoConfig.leo and then executing the Tangle All command.  There are two advantages to changing leoConfig.txt in this manner.  First, it is just easier to change leoConfig.leo.  Second, all comments are lost in leoConfig.txt when Leo updates it, so using leoConfig.leo as the primary data file means you will always have the comments available.

Leo looks for leoConfig.txt first in the directory specified by the Python variable sys.leo_config_directory.  You would typically set this variable in Python's sitecustomize.py file.  If this variable does not exist, Leo looks in the directory from which Leo was loaded.

The child of this node contains an example of leoConfig.txt that shows all the options that may be set.

Settings in leoConfig.txt overrides preferences in .leo files, but only for those items actually in leoConfig.txt, so you can choose which settings you want to override.  Also, a Leo ignores any setting in leoConfig.txt whose value is "ignore" (without the quotes). For example:

[prefs panel options]
tab_width = ignore

If a setting is overridden, it is _not_ written to the .leo file when the outline is saved.  Note that this does not change the file format: all previous versions of Leo will be able to read such .leo files.

The preceding is probably all you need to know to use leoConfig.txt.  The following discuss some minor details: 

1. When reading a .leo file, if a setting is found neither in leoConfig.txt nor in the .leo file, Leo uses a default, hard-coded value.  In leo.py 3.0 and later these default settings are found in tables that appear in the section called:

	&lt;&lt; define default tables for settings &gt;&gt;

in the file leoConfig.py. So it is now convenient to change settings in leo.py itself as well as in leoConfig.txt.

2. Leo will update leoConfig.txt unless the read_only option is on in leoConfig.txt.  

WARNING: there are problems when Leo does write leoConfig.txt: all comments are lost and options and sections are written in a random order.  This is due to problems in Python's ConfigParser module and will not be changed any time soon.

3. Provided the read_only option is off, Leo updates leoConfig.txt whenever it saves a .leo file or whenever the Preferences panel is closed without being canceled.  When updating leoConfig.txt, Leo will write only existing settings whose value is not "ignore".

4. When Leo saves a .leo file, Leo will write a Preferences setting to the .leo file only if the setting will not be written when updating leoConfig.txt.  In particular, changes made in the Preferences Panel will become permanent immediately if Leo the read_only option is off.  Otherwise the change will become permanent when any .leo file is saved.</t>
<t tx="edream.110203163054.321">Beginning with version 3.11, you may use plugins to customize how Leo works.  You can

- override or modify any command
- add or customize menus or
- translate menus into any language.

Plugins have full access to all of Leo's source code.  In particular, several convenience methods have been added to make customizing menus and commands easier.

Plugins are permanent: they will not go away when Leo is updated.  You can take
advantage of the latest CVS updates _without_ having to throw away your modifications.

Important warning: plugins must avoid blindly executing scripts in .leo files.  Doing so could expose all parts of your computer to malicious Python code.  The section called "Security warnings and precautions" discusses how to customize Leo safely and how to avoid several pitfalls.</t>
<t tx="edream.110203163054.322">@nocolor

What is a plugin?

A plugin is a .py file that appears in Leo's plugin subdirectory. Leo tries to
import all such files while starting up. This is done at "start1" time, that
is, in the call to doHook("start1") in the run function in leo.py. Plugins
exist to define "hook code".

What is hook code?

Leo automatically calls hook code at various times during Leo's execution.
Typical hooks are:

- "start2", called at the end of Leo's startup process,
- "command1", called before executing any of Leo's commands
- "idle", called at Tk's idle time, when nothing else is happening,

See the documentation for hooks in this file for full details.

N.B. Plugins can use "start2" hooks to override any of Leo's classes. See
"Overriding functions, methods &amp; classes" in leoPlugins.leo for several
examples of how to do this.

How do plugins work?

Plugins register themselves when Leo imports them using the following code,
which should appear as the outer level of the .py file:

@color

"""A description of this plugin"""

if 1: # 1 to enable the plugin, 0 to disable the plugin:
	registerHandler("xxx", onXXX)
	__version__ = "1.2"
	plugin_signon(__name__)
	
@nocolor

Line by line:

1) """A description of this plugin"""

This is a Python doc string describing the plugin. This string becomes the
value of the __name__ attribute for the module (.py file).

2) if 1: # 1 to enable the plugin, 0 to disable the plugin:

This line enables or disables the code that registers the plugin. Plugins do
nothing unless they are actually registered when Leo first imports them.

3) registerHandler("xxx", onXXX)

This line registers a handler called onXXX for the hook called "xxx". See the
documentation for hooks for a complete list of hook names that you can use
instead of "xxx". onXXX is the name of a function or method, presumably defined
in the plugin file, that Leo will call at "xxx" time. For example:

registerHandler("idle",onIdle)

will cause Leo to call the onIdle function at "idle" time.

You can pass a list of hook names as the first argument to registerHandler. For
example:

registerHandler(("bodykey1","bodykey2","headkey1","headkey2"), onKey)

4) __version__ = "1.2"

This assigns a version attribute to module. At present this attribute is used
by the plugin code that creates Leo's Plugins menu.

5) plugin_signon(__name__)

This line increases the count of loaded modules. The present code for
plugin_signon does not actually print separate signons--it seems to verbose.

About hook handlers

See the "About hooks" section of leoPlugins.leo for full documentation about
how to write hook handler routines, like onXXX or onKey in the examples above.
Basically, each hook should have this pattern:
	
@color

def onXXX (tag,keywords):
	c = keywords.get("c")
	otherKeyword = keywords.get("otherKeyword")
	&lt;&lt; do something with c and otherKeyword, etc. &gt;&gt;
	
@nocolor

In other words, keywords is a Python dictionary containing the keyword
arguments passed to the hook handler. See the See the "About hooks" section of
leoPlugins.leo for a list of the keywords passed to each hook handler.

The tag is the name of the hook. For example, tag would one of
"bodykey1","bodykey2","headkey1","headkey2", for the onKey hook handler in the
example above.

What's next?

It's one thing to know how to create a plugin. It's another to know how to
actually change Leo. Obviously, some study is needed. The place to start your
study is LeoPy.leo. In particular, study very carefully the section called
"Overview of code". Leo is a highly modular program, and Python is ideally
suited to this style of programming.</t>
<t tx="edream.110203163054.323">@nocolor

New in 3.11. Leo now looks in the plugins folder for .py files. Leo tries to
import all such files at startup ("start2") time.

The child of this node gives an example of the code that creates the Open With
menu. The following code, appearing at the end of mod_open_with.py, registers
two different hook functions. The on_idle function is the "idle" hook. The
create_open_with_menu is the "start2","open2" and "command2" hooks.
@color

if 1: # Register the handlers... 
	registerHandler("idle", on_idle) 
	registerHandler(("start2","open2","command2"), create_open_with_menu) 
	es("...open with")
	
@nocolor
Plugins may call registerHandler with a hook name like "idle" or a list of hook
names like ("start2","open2","command2"). Also, you can use the "all" hook name
to indicate that code will be called for all hooks. This is useful for tracing
hooks. Plugins may also call registerExclusiveHandler for hooks that should not
be redefined in other plugins.

mod_open_with.py also contains the on_idle and create_open_with functions that
actually handle the hook. Such functions have two arguments: tag and keywords.
You will find many examples of this in LeoPy.leo.

About distribution:

1. LeoPy.leo now contains all the plugins in @ignore'd @file nodes. This way
Leo won't complain when you open LeoPy.leo.

2. Most plugins actually are disabled: the code that registers the hooks is
contained in #if 0: blocks. So to create a pluging you have to remove the
@ignore and you have to change #if 0: to #if 1.

3. Most mod_*.py will never be part of Leo distributions, and the single-click
installer will create an plugins folder containing just mod_open_with.py.

4. There is no longer a need for a customizeLeo.py file.

About error checking:

At present Leo will disable all hooks if any hook throws an exception. In
practice this isn't a big deal, but obviously something better could be done. I
won't do anything until after 3.11b1 goes out.

How to send me your plugins:

It should now be _much_ easier to submit a plugin for inclusion in LeoPy.leo.
Just send me a .leo file containing @file mod_your_plugin.py. Please have this
@file node be @ignored: this is more convenient for me. Ideally, your .leo file
should contain _only_ your plugin code.</t>
<t tx="edream.110203163054.324">@color
@language python
@ignore

"""Open With handler"""

from customizeLeo import *
from leoGlobals import *

@others

if 1: # Register the handlers...
	registerHandler("idle", on_idle)
	registerHandler(("start2","open2","command2"), create_open_with_menu)
	es("...open with")</t>
<t tx="edream.110203163054.325"># frame.OnOpenWith creates the dict as follows:
# dict = {"c":c, "v":v, "f":f, "path":path, "time":time}

def on_idle (tag,keywords):

	import os
	a = app()
	for dict in a.openWithFiles:
		path = dict.get("path")
		c = dict.get("c")
		v = dict.get("v")
		if path and os.path.exists(path):
			try:
				time = os.path.getmtime(path)
				if time and time != dict.get("time"):
					dict["time"] = time
					&lt;&lt; update v's body text &gt;&gt;
			except: pass</t>
<t tx="edream.110203163054.326">&lt;&lt; set s to the new text &gt;&gt;
body = v.bodyString()
&lt;&lt; set conflict flag &gt;&gt;

if conflict:
	# Report the conflict &amp; set update.
	import leoDialog
	d = leoDialog.leoDialog()
	message = "Conflict in %s.\n\n" % (v.headString())
	message += "Replace outline with external changes?"
	update = d.askYesNo("Conflict!",message) == "yes"
else:
	update = s != body

if update:
	h = v.headString()
	es("changed:" + h)
	v.setBodyStringOrPane(s)
	c.selectVnode(v)
	v.OpenWithOldBody = s
</t>
<t tx="edream.110203163054.327">try:
	# Update v from the changed temp file.
	f=open(path)
	s=f.read()
	f.close()
except:
	es("can not open " + shortFileName(path))
	break
</t>
<t tx="edream.110203163054.328">try:
	# The OpenWithOldBody attribute does not normally exist in vnodes.
	old_body = v.OpenWithOldBody
	conflict = body != old_body and body != s
except:
	conflict = v.isDirty() and body != s
</t>
<t tx="edream.110203163054.329">def create_open_with_menu (tag,keywords):

	if  (tag in ("start2","open2") or
		(tag=="command2" and keywords.get("label")=="new")):
	
		&lt;&lt; create the Open With menu &gt;&gt;

		# Enable the idle-time hook so we can check temp files created by Open With.
		from leoGlobals import enableIdleTimeHook
		enableIdleTimeHook(idleTimeDelay=500)
</t>
<t tx="edream.110203163054.330">@ Entries in the following table are the tuple (commandName,shortcut,data).
data is the tuple (command,arg,ext).
command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the extension ext,
Otherwise, Leo computes an extension based on what @language directive is in effect.
@c

idle_arg = "c:/python22/tools/idle/idle.py -e "

if 1: # Default table.
 table = (
  ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
  ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
  ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
else: # David McNab's table.
 table = (
  ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)))

top().frame.createOpenWithMenuFromTable(table)
</t>
<t tx="edream.110203163054.331">Naively using hooks can expose you and your .leo files to malicious attacks.  You will be safe as long as you follow these basic principles:

1. Hooks should _never_ blindly execute Python scripts in .leo files. Blindly executing scripts in .leo files runs the extreme risk of executing malicious code if you ever share any .leo file with someone else.  Moreover, using rexec instead of exec WILL NOT PROTECT YOU.  See the children of this node for further discussion of this important topic.

2. Hooks can execute any code safely _provided_ that all code is contained entirely within the plugin file. If you have a nifty customization that you want to do on a particular .leo file, put that code into a plugin.

3. Use only authentic copies of Leo that come from Leo's SourceForge site.</t>
<t tx="edream.110203163054.332">I'd like to thank Stephen Schaefer for gently insisting that we must guard against malicious code in shared .leo files.  Here is a little story Stephen told on Leo's SourceForge site that makes clear what the danger is:

"I foresee a future in which the majority of leo projects come from marginally trusted sources...I see a world of leo documents sent hither and yon - resumes, project proposals, textbooks, magazines, contracts - and as a race of Pandora's, we cannot resist wanting to see "What's in the box?" And are we going to fire up a text editor to make a detailed examination of the ASCII XML? Never! We're going to double click on the cute leo file icon, and leo will fire up in all its raging glory. Just like Word (and its macros) or Excel (and its macros)."

This succinctly illustrates the fundamental problem: when we share "our" .leo files we can _not_ assume that we know what is our "own" documents.  So hooks that naively searches through .leo files looking for scripts to execute is looking for big trouble.

The following node contains an example of the kind of code that is extremely dangerous.</t>
<t tx="edream.110203163054.333">@color
@ WARNING ***** Using the following routine exposes you to malicious code in .leo files! *****

Do not EVER use code that blindly executes code in .leo files!
Someone could send you malicious code embedded in the .leo file.

WARNING 1: Changing "@onloadpythonscript" to something else will NOT protect
           you if you EVER share either your files with anyone else.

WARNING 2: Replacing exec by rexec below provides NO additional protection!
           A malicious rexec script could trash your .leo file in subtle ways.
@c
if 0: # WRONG: This blindly execute scripts found in an .leo file! NEVER DO THIS!
	def onLoadFile():
		v = top().rootVnode()
		while v:
			h = v.headString().lower()
			if match_word(h,0,"@onloadpythonscript"):
				s = v.bodyString()
				if s and len(s) &gt; 0:
					try: # SECURITY BREACH: s may be malicious!
						exec(s + '\n',__builtins__,__builtins__)
					except:
						es_exception()
			v = v.threadNext()
</t>
<t tx="edream.110203163054.334">@color
@ It would be most foolish to expect rexec to protect you against malicious code contained in .leo files.  Remember that Leo is a repository of source code, so any text operation is potentially malicious.

For example, consider the following script.  This script is valid in rexec mode:
@c

c = top()
thisNode = c.currentVnode()
v = c.rootVnode()
while v:
	&lt;&lt; change all instances of rexec to exec in v's body &gt;&gt;
	v = v.threadNext()
&lt;&lt; delete thisNode &gt;&gt;
&lt;&lt; clear the undo stack &gt;&gt;

@ This script will introduce a security hole the .leo file without doing anything prohibited by rexec, and without leaving any traces of the perpetrating script behind.  The damage will become permanent _outside_ this script when the user saves the .leo file.
</t>
<t tx="edream.110203163054.335">pass</t>
<t tx="edream.110203163054.336">pass</t>
<t tx="edream.110203163054.337">pass</t>
<t tx="edream.110203163054.338">Hooks have full access to all of Leo's source code simply by importing it.

Moreover, several convenience methods have been added to make customizing menus and commands easier.  The following paragraphs discuss these routines and how to use them.

</t>
<t tx="edream.110203163054.339">The following routines enable and disable "idle" hooks.  They are defined in leoGlobals.py.

enableIdleTimeHook(idleTimeDelay=100)

Enables the "idle" hook. After this routine is called Leo will call the "idle" hook approximately every idleTimeDelay milliseconds.  Leo will continue to call the "idle" hook periodically until disableIdleTimeHook() is called.

disableIdleTimeHook()

Disables the "idle" hook.</t>
<t tx="edream.110203163054.340">The following convenience routines make creating menus easier.

These are methods of the leoFrame class.  Use top().frame to get the frame object for the presently active Leo window.

The plugins node in LeoPy.leo gives examples of how to use these routines to create custom menus and to add items to the Open With menu.

These convenience methods all do complete error checking and write messages to the log pane and to the console if errors are encountered.</t>
<t tx="edream.110203163054.341">@nocolor
createMenuItemsFromTable (self,menuName,table,openWith=0)

This method adds items to the menu whose name is menuName.  The table argument describes the entries to be created.  This table is a sequence of items of the form (name,shortcut,command).

- name is the command name
- shortcut is the shortcut, or None to indicate no shortcut.
- command is the routine to execute when the menu item is selected.

An entry of the form ("-",None,None) indicates a separator line between menu items.

For example:
@color
table =
	("Toggle Active Pane","Ctrl-T",self.OnToggleActivePane),
	("-",None,None),
	("Toggle Split Direction",None,self.OnToggleSplitDirection))

top().frame.createMenuItemsFromTable("Window",table)
@nocolor

If the openWith keyword argument is 1 the items are added to a submenu of the Open With menu.  However, it will be more convenient to use the createOpenWithMenuFromTable method to create the Open With menu.
</t>
<t tx="edream.110203163054.342">createNewMenu (self,menuName,parentName="top")

This method creates a new menu:

- menuName is the name of the menu to be created.
- parentName is the name of the parent menu, or "top" if the menu is to created in the menu bar.

This method returns the menu object that was created, or None if there was a problem.  Your code need not remember the value returned by this method.  Instead, your code will refer to menus by name.
</t>
<t tx="edream.110203163054.343">createOpenWithMenuFromTable (self,table)

This method adds items to submenu of the Open With menu item in the File menu.

The table argument describes the entries to be created.  This table is a sequence of items of the form (name,shortcut,data).

- name is the command name
- shortcut is the shortcut, or None to indicate no shortcut.
- data is a tuple of the form (command,arg,ext)
- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- arg is an argument to be passed to the given command.
- path is the full path name of the temporary file to be passed to the external editor.
- ext is a file extension or None.

When the user selects the Open With item corresponding to the table item Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on what @language directive is in effect.

For example:

table = (
	("Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
	("Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
	("Wordpad","Alt+Shift+T",("os.startfile",None,".txt")))

top().frame.createOpenWithMenuFromTable(table)
	</t>
<t tx="edream.110203163054.344">deleteMenu (self,menuName)

Deletes the menu whose name is given, including all entries in the menu.</t>
<t tx="edream.110203163054.345">deleteMenuItem (self,itemName,menuName="top")

Deletes the item whose name is itemName from the menu whose name is menuName.  To delete a menu in the menubar, specify menuName="top".</t>
<t tx="edream.110203163054.346">@nocolor
The leoFrame class creates the Window menu as follows:
@color

windowMenu = self.createNewMenu("&amp;Window")

table = (
	("&amp;Equal Sized Panes","Ctrl-E",self.OnEqualSizedPanes),
	("Toggle &amp;Active Pane","Ctrl-T",self.OnToggleActivePane),
	("Toggle &amp;Split Direction",None,self.OnToggleSplitDirection),
	("-",None,None),
	("Casca&amp;de",None,self.OnCascade),
	("&amp;Minimize All",None,self.OnMinimizeAll),
	("-",None,None),
	("Open &amp;Compare Window",None,self.OnOpenCompareWindow),
	("Open &amp;Python Window","Alt+P",self.OnOpenPythonWindow))

self.createMenuEntries(windowMenu,table)
</t>
<t tx="edream.110203163054.347">@nocolor

It is easy for hooks to translate menus into another language.  For example, code similar to the following code would typically be found in the "start2" hook:

@color

table = (
	("Open...","&amp;Ouvre"),
	("OpenWith","O&amp;uvre Avec..."),
	("close","&amp;Ferme"),
	("Undo Typing","French &amp;Undo Typing"), # Shows you how much French I know ;-)
	("Redo Typing","French &amp;Redo Typing"),
	("Can't Undo", "French Can't Undo"),
	("Can't Redo", "French Can't Redo"))
# Call the convenience routine to do the work.
app().setRealMenuNamesFromTable(table)</t>
<t tx="edream.110203163054.348">New in 4.0: Leo can now read and write "foreign" attributes in &lt;v&gt; and &lt;t&gt; elements in .leo files:

- When reading a .leo file, Leo will create t.unknownAttributes or v.unknownAttributes ivars for any tnode and vnode object whose corresponding &lt;v&gt; or &lt;t&gt; element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are a dictionary whose keys are the attribute names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if  a vnode or tnode contains an unknownAttributes ivar.

- The only "native" attributes that Leo expects to find are the "tx" attribute in &lt;t&gt; elements and the "a", "t", "vtag" and "tnodeList" attributes of &lt;v&gt; elements.  Everything else is a foreign attribute.

- Leo performs the usual xml escapes on these strings when reading or writing the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching unknownAttributes ivars to a vnode or tnode.  For example:

	v.unknownAttributes = {"vnodeIcon" : pathToIcon}

It would be best not to delete other foreign attributes, so the following would be preferred:

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

Another way:

	try:
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	except AttributeError:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}</t>
<t tx="edream.110203163054.349">Leo creates nonexistent directories only if create_nonexistent_directories = 1 in leoConfig.txt.

Previous versions of Leo created a new directory only if its parent directory already existed.  Now, Leo will create all non-existing directories as required.

For example.  Suppose neither dir1 nor dir2 exists.  Leo will create both dir1 and dir1 when it writes the following @file \root\dir1\dir2\spam.py.</t>
<t tx="edream.110203163054.350"></t>
<t tx="edream.110203163054.351">Double-clicking the icon box of a node whose headline has the form:

@url &lt;any url&gt;

executes the url in your default web browser.

Leo checks that the url is valid before doing so. A valid url is:

-- 3 or more lowercase alphas,
-- followed by one ':',
-- followed by one or more of: $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
-- followed by one of:         $%&amp;'()*+/0-9:=?@A-Z_a-z}~

Url's should contain no spaces: use %20 to indicate spaces.

You may use any type of url that your browser supports: http,mailto,ftp,file,etc.
</t>
<t tx="edream.110203163054.352"></t>
<t tx="edream.110203163054.353">The present version should be quite usable for its main purpose: tracking
down lines corresponding to error messages. In particular, except for possible
pathological cases, Leo should always put the cursor in the node containing the
referenced line. Possible pathologies involve asking Leo to "go to" a sentinel
line. It won't always be clear what node contains the sentinel.

I am well aware that Leo may not put the cursor on the proper line within
the vnode, but human beings being the excellent pattern matchers that we are,
we should be easily be able to find a line within a node.

Notes in LeoPy.leo, in the node called (Go to line number), discuss a variety
of issues that may cause the cursor not to go to the "proper" line. It also
discusses a better way to position the cursor.

Internally, there are two main versions of this command: one for @silentfile
trees, and one for @rawfile and @file trees. In the first case, there are no
sentinels in the derived file, so Leo just steps through the outline. This is
the easy case, and should work well. In the second case (@rawfile and @file
trees), the derived file contains sentinels, and Leo uses those sentinels to
determine in what vnode the given line occurs.

In this second case, Leo can almost always position the cursor within the
proper node, because Leo just scans back in the derived file looking for the
proper @+node sentinel. However, in order to "count" lines in the derived file
(to place the cursor properly _within_ the body text) Leo must recreate exactly
the logic used by the atFile.read logic, and that isn't easy. Moreover, there
is _no_ guarantee that the derived file is unchanged from when it was written;
after all, if you get syntax errors you tend to want to fix them ;-)

Please do not report bugs in this command, unless the bug involves a
crash, which would be reported both in Leo's log pane and in the console
window. This command will probably be improved in 3.10.</t>
<t tx="edream.110203163054.354">At last Leo has a power user of cweb.  Cweb mode is now fully tested and fully functional.  The following improvements have been made to cweb mode:

1. Corrected sentinels used in cweb mode.

Leo must double _all_ @ signs following the @q@. For example, an @@color sentinel gets turned into @q@@@@@color@&gt;.

2. Leo colors cweb doc parts and C comments in LaTex mode by default.

In cweb mode Leo colors @space, @* and @** sections using LaTeX coloring by default.  The color_cweb_doc_parts_with_latex option in leoConfig.py/.txt affects this default.

Similarly, Leo colors C comments in cweb mode using LaTeX coloring by default. The color_cweb_comments_with_latex option in leoConfig.py/.txt affects this default.

3. Cweb mode works similarly in @file and @root trees.

See the child of this node for full details about cweb mode.
</t>
<t tx="edream.110203163054.355">Cweb mode refers to how Leo tangles an outline when @language cweb is in effect or the cweb option in the Preferences Panel is in effect.

Leo treats _all_ cweb code in cweb mode as unevaluated text.  That is, Leo treats cweb control codes, including @&lt;...@&gt;, @&lt;...@&gt;=, @c, @space, @* and @** as "raw" text within cweb mode.  Leo does _not_ expand _cweb_ section references when writing derived files in cweb mode.  However, Leo _does_ expand _noweb_ section references, so you may use noweb sections to organize cweb files! You can create _noweb_ code and doc sections using the @code and @doc directives in place of @c and @space directives.

By default, cweb colors @space, @* and @** sections using the same syntax coloring as for LaTeX.  In addition, cweb colors C // and /*..*/ comments using LaTeX coloring by default.  You may change these defaults using the color_cweb_doc_parts_with_latex and color_cweb_comments_with_latex options in leoConfig.py.</t>
<t tx="edream.110203163054.356">The Open With command allows you to communicate with external editor.  When you select this command Leo creates a temporary file and invokes an external program.  Leo periodically checks whether this temporary file has changed; Leo changes the corresponding node in the outline if so.

You must create the entries in the Open With submenu. This would typically be done in a hook routine, using the createOpenWithMenuFromTable routine described in the child of this node.

The @file mod_open_with.py node in LeoPy.leo gives a complete example of handling the Open With menu.</t>
<t tx="edream.110203163054.357">Leo now supports optional Emacs-style auto-indent.  This style of auto-indent aligns newly created lines with unmatched ( [ or { brackets in the previous line. This feature is enabled only if smart_auto_indent = 1 in leoConfig.txt.

This code was contributed by David McNab, david@rebirthing.co.nz.</t>
<t tx="edream.110203163054.358">New in leo.py v3.9

Whether importing text from an outside source, typing in text, or modifying text, eventually you end up with a block of text in which some lines are too long and some are too short.  The Reformat Paragraph command will rearrange the words in a text paragraph to fill each line as full as possible, up to the @pagewidth setting.

A paragraph is delimited by blank lines, Leo directives, and (of course) start and end of text in a node.  The width of the line used by the reformatting operation is governed by @pagewidth and the indentation that would be applied to the node when tangled (as part of a @root) or written (as part of a @file).

The command operates on the paragraph containing the insert cursor.  If the insert cursor is on a blank line or directive, nothing happens.  If the cursor is on a line containing text, then the paragraph containing that text line is reformatted and the insert cursor is moved to the next paragraph.

Be careful that you don't do this on source code!  Of course, if you do reformat something that should have been left alone, then just Undo.

NOTE: Lines with hanging indentation are handled so that the hanging indentation is preserved.  This is most useful for bulleted or numbered lists, such as:

  1. This is the first paragraph, and
     it has a hanging indentation.

  2. This is the second paragraph, and
     it too has a hanging indentation.</t>
<t tx="edream.110203163054.359">An @rawfile tree is a tree whose root headline starts with @rawfile &lt;filename&gt;.  Similarly, for @silentfile and @nosentinelsfile trees.

Leo creates files derived from @file and @nosentinelsfile trees in exactly the same way.  The _only_ difference is that files derived from @file trees contain sentinels, while files derived from @nosentinelsfile trees do not.  Therefore, Leo can not update outlines from changed made from files derived from @nosentinelfile trees.

Leo creates files derived from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. However, Leo recognizes the @ignore directive in the _ancestors_ of @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:

1. Leo writes no sentinel lines when writing @silentfile trees.  When writing @rawfile trees, Leo writes only the @+leo, @-leo, @+node, @-node, @+body and @-body sentinels. Therefore, Leo can update @rawfile trees, but _not_ @silentfile trees from changes made in derived files. Unlike @file and @rawfile trees, the primary source of information for an @silentfile tree is the outline containing it.

2. Within @silentfile trees only, if a headline starts with @@, Leo writes everything in the headline following the @@ just before the corresponding body text.

3. Files derived from @silentfile trees contain _nothing_ not contained in body text (or @@ headlines).  In particular, if body text does not end in a newline, the first line from the next node will concatenated to the last line of the preceding node.

In short, you can get any combination of sentinels/no sentinels and references/no references using @file, @nosentinelsfile, @rawfile and @silentfile trees.  This is shown in the following table:

                     Derived files        Sections and 
    Type of tree   contain sentinels?   @others expanded?
    ------------   ------------------   -----------------
           @file   yes                  yes
@nosentinelsfile   no                   yes
        @rawfile   yes                  no
     @silentfile   no                   no
</t>
<t tx="edream.110203163054.360">leo.py 3.8                               October 29, 2002

Many major improvements have been made to Leo, all made as the result of user requests:

- New @rawfile and @silentfile trees complement @file trees.
  @rawfile and @silentfile trees create derived files without using sections.
  @rawfile files contain only those sentinels needed to automatically untangle them.
  @silentfile trees contain no sentinels at all.
- New @raw and @end_raw directives allow unformatted code within @file trees.
- Much better support for CWEB.  You may organize .w files using noweb!
- The @comment and @language directives may now apply simultaneously.
- Leo can now read, remember and write &lt;?xml-stylesheet...?&gt; lines,
  under control of the new stylesheet option.
- The new output_newline option specifies the line endings used when writing files.
- The new output_initial_comment option secifies the text to appear
  in an @comment sentinel at the start of each derived file.
- New commands in the help menu make it much easier to change configuration options.
- Dozens of minor improvements and bug fixes.

This month Dave Hein and I discovered how to uniquely and permanently identify nodes, regardless of where those nodes are located and regardless of how many people are working simultaneously on them.  This discovery will greatly improve Leo, and will simplify how people use Leo with CVS.  Leo 4.0, due out in a month or two, will be the first version of Leo to use this breakthrough.

See the children of this node for full details.
</t>
<t tx="edream.110203163054.361"></t>
<t tx="edream.110203163054.362"></t>
<t tx="edream.110203163054.363">The warning for "unknown language" had an unbound var.</t>
<t tx="edream.110203163054.364">@nocolor</t>
<t tx="edream.110203163054.365">Today I have had series of important insights regarding Leo's implementation. To state my conclusion first: 

** No representation of clones is likely to be better than the present way using vnodes and tnodes. ** 

Since Leo's earliest days I have wondered whether it might not be possible to improve how Leo represents clones. The present scheme laboriously creates and deletes "dependent trees" of vnodes when a node is moved that is a clone or a descendent of a clone. Couldn't we do better if we represented clones as a single tree of nodes that is shared by other nodes? 

Today I thought of a new way of looking at things. You can think of it as a thought experiment, though at first I thought of it as a viable implementation strategy. This new point of view has greatly clarified the essentials of the situation. It strongly suggests the conclusion stated above. 

The thought was this: suppose vnodes are not "real" or "permanent", but merely epiphenomena of the underlying "reality", the shared nodes. I thought of vnodes as existing in "the floating world." The "real" nodes, the potentially shared nodes, I call inodes (information nodes.) All fundamental information would reside in inodes. 

Furthermore, suppose that vnodes are created by the tree class _as a by-product of redrawing the screen_. This actually is a pretty clever idea. It has the following big advantages: 

1. Only a single iterator is ever needed to traverse the tree of inodes. This iterator is called only by the tree class when the tree needs to be redrawn. The result of the tree traversal is the tree of vnodes. Most other Leo code (and user scripts) can use and traverse the tree of transient vnodes without any modifications. 

2. Creating and destroying dependent trees happens automatically as the result of the tree traversal. There is no need for the complex special cases found in the present vnode class. 

So this seems like hot stuff. Very clever indeed, if not a big breakthrough. However, a closer examination reveals that almost nothing is gained by this "cleverness". If this clever way doesn't really improve matters, it is most unlikely that any other scheme will. This insight is the real breakthrough. 

So let us look at the details and implications of generating temporary vnodes while redrawing the screen: 

1. Because inodes may be shared, they need not have unique parents. But the generated vnodes _will_ have unique parents. Therefore, all the code that traverses vnodes will work just fine. 

2. Alas, there is a huge costs in creating vnodes on the fly. We must create: 
a) the vnodes themselves, 
b) the Tk.Text widgets corresponding to visible vnodes and 
c) all the data in the vnodes, including links to other vnodes and links to inodes. 

These costs can't be optimized away. 

3. Most importantly, even if vnodes are "ephemeral" they are in fact essential. We need _unique_ vnodes to represent _different_ areas on the screen, even if those vnodes are on the same join list. For example, we need _distinct_ Tk.Text widgets in order to draw the screen at all. 

4. And join lists too are essential! Indeed, if the headline of a cloned node changes, _different_ Tk.Text widgets must be updated on the screen. No matter how elegant the implementation of inodes, we _still_ must have a way of quickly updating all joined vnodes _on the screen_. 

Summary 

At long last the situation has become clear: 

Fact 1: Separate vnodes are required to redraw the screen properly. 
Fact 2: Join lists (whether in vnodes or tnodes) are also essential so that items _on the screen_ can be redrawn quickly. 
Fact 3: Leo must create and destroy dependent trees of vnodes, _because those trees appear and disappear from the screen._ 
Fact 4: Using shared inodes will not change either fact 1, 2 or 3. 

In short, nothing would be gained by trying to represent clones as shared trees because: 

** join lists and dependent trees are needed to draw the screen correctly ** 

This came as a great surprise to me. It resolves a question that has been on my mind for at least 8 years. As a result, there is no need to do any prototyping of inodes or iterators. Inodes will never see the light of day. 

Edward 

P.S. As I have said before, the present representation of join links can most likely be improved greatly. I plan to do this (and probably not much else) for 4.0. 

P.P.S. There are other implementation problems with temporary vnodes. For example, what would carry marks? These problems aren't really part of the discussion, but they would be quite important if one actually rewrote the code! 

P.P.P.S. I'll look at Gil's ideas (and any others) thoroughly before fixing 4.0 in stone. As Gil suggests, designing 4.0 properly is more important than releasing 4.0 next week :-) 

EKR </t>
<t tx="edream.110203163054.366"></t>
<t tx="edream.110203163054.367">Actually, my first analysis was incomplete. Suppose we eliminate vnodes completely? Leo would then redraw the screen directly from the inodes. This wouldn't be so hard: each inode would contain an list of Tk.Text widgets. The drawing code merely has to place the an unused widget in the correct place in the screen (the Tk.Canvas). 

In some sense, the array of Tk.Text widgets in each inode is like the join list, but only visible nodes need be on this list. Furthermore, this list only needs to be updated when the outline is actually redrawn. It would be easy to insert or delete new Text widgets in this list. There are lots of possibilities, all easy to do in Python. 

However, replacing vnodes with inodes is likely to be a very bad idea, for several reasons: 

1. As I mentioned earlier, this implementation would require massive changes throughout Leo's code. All "user" code would have to use an iterator to traverse the outline. In particular, the fundamental code to manage the outlines would be changed significantly and would almost certainly become more complex. 

2. Inodes complicate Leo from the user's point of view. The present data model is much better because 

** The vnode tree corresponds directly to what the user sees on the screen ** 

Giving up this correspondence seems like a big step backward. We could try to recreate the node list during redrawing, but that seems likely to create a real mess. Impermanent vnodes might well be worse than no vnodes at all. 

3. As mentioned in an earlier post, marks present a problem without vnodes. Perhaps each inode could contain a list of locations (in the full tree traversal) that should be marked. However, updating this kind of list when the outline changes could be very complex. It wouldn't be horrible to say that all joined nodes must be marked in synchronization, but it wouldn't be a step forward. 

4. There are other ways of improving Leo's performance without touching the data model at all. Rewriting the vnode, tnode, atFile and fileCommands modules as C++ code in a Python extension will almost certainly double the speed of key operations. As mentioned in the first post, there are optimizations that the vnode class can do to avoid deleting dependent trees and then immediately recreating them. And don't forget that the average speed of our computers doubles every 2-3 years or so. So just waiting for a faster machine is a highly effective optimization! 

Revised conclusions 

Replacing vnodes with inodes is possible, and it might even provide some performance gains for huge outlines containing many clones. However, replacing vnodes with inodes would be an extremely high risk project: very complex, with likely negative consequences. I doubt that there will ever be a need even to consider such a project. 

The present code base is plenty good enough for most outlines, and there are much simpler and better ways to speed up key outline operations. In short: I have no more interest in inodes and their attendant complexities. </t>
<t tx="edream.110203163054.368">Leo now properly handles @delims directives in @file trees.</t>
<t tx="edream.110203163054.369">Leo now properly recognizes all sentinel lines when @language cweb is in effect.</t>
<t tx="edream.110203163054.370">Fixed a bug that caused Leo to say "methods" rather than "functions" when importing C code.

Leo now adds @root &lt;filename&gt; statement when importing to @root nodes.</t>
<t tx="edream.110203163054.371"></t>
<t tx="edream.110203163054.372"></t>
<t tx="edream.110203163054.373"></t>
<t tx="edream.110203163054.374"></t>
<t tx="edream.110203163054.375">Previously, Java only had block comments, and the ending delim wasn't being removed from doc parts.</t>
<t tx="edream.110203163054.376"></t>
<t tx="edream.110203163054.377">The present code explicitly eliminates control-T processing in headlines, which means that control-T does not switch panes when editing headline text.  Control-T _does_ switch panes in all other cases.

This appears to be another Tk bug.</t>
<t tx="edream.110203163054.378">Only shortcut pastes worked before.</t>
<t tx="edream.110203163054.379"></t>
<t tx="edream.110203163054.380">Leo 3.7 significantly offers you several new ways to create derived files.</t>
<t tx="edream.110203163054.381">@rawfile and @silentfile trees are important new addtions to Leo.  They work like @file trees, but are simpler to use.  See the child of this node for full details.</t>
<t tx="edream.110203163054.382">The @raw and @end_raw directives delimit a region of "raw" text.  No section references are recognized within "raw" text, and no additional leading whitespace is generated within "raw" text when writing the derived file.

The @quiet directive is valid only within @root trees.  It suppresses all sentinels except the @+node sentinels used to mark headlines.

See the children of this node for full details.</t>
<t tx="edream.110203163054.383">The @raw and @end_raw directives are valid only within @file trees.  The @raw directive starts a section of "raw" text.  The @end_raw directive ends such a section, as does the end of body text. No section references are recognized within "raw" text, and no additional leading whitespace is generated within "raw" text when writing the derived file.
</t>
<t tx="edream.110203163054.384">The @verbose, @terse, @quiet and @silent directives determine how the Tangle command outputs comments in @root trees.  Comments written by the user in code sections are always output: these directives control only: a) the comments containing doc sections and b) sentinel comments that delimit the beginning and end of code sections.

When @verbose is in effect Tangle outputs all comments. When @terse is in effect, Tangle outputs only those comments necessary for Untangle to work. When @silent is in effect Tangle adds no additional comments.  The @quiet directive is like @silent except that it does output leading sentinels as comments. Like @silent, @quiet inhibits untangling. 

@verbose is the default. If more than one of these directives appear in the same body text the "most verbose" of these options will be in effect.</t>
<t tx="edream.110203163054.385">It is now possible to create CWEB (.w) files from @file trees.  When @language cweb is in effect the following happen:

1. Leo does not recognize @space and @c directives.

2. The colorizer now recognizes both cweb and noweb section definitions and references.

3. Leo uses @q@ and @&gt; for comment delimiters in files derived from @file or @rawfile trees, and Leo replaces @ by @@ within such comments.

4. Leo now properly warns about orphan nodes when @langauge cweb was in effect.

See the child of this node for the new documentation that applies to cweb mode.</t>
<t tx="edream.110203163054.386">It is now possible to have both the @comment and @language directives to be in effect at the same time.  To do this, both directives must appear in the same node, and the @comment directive must follow the @language directive.</t>
<t tx="edream.110203163054.387"></t>
<t tx="edream.110203163054.388">Leo preserves the &lt;?xml-stylesheet...?&gt; line if it is already present in the .leo file.

Otherwise, Leo writes a &lt;?xml-stylesheet...?&gt; line only if the stylesheet option is present in the configuration file.  The stylesheet option specifies s in &lt;?xml-stylesheet s?&gt;</t>
<t tx="edream.110203163054.389">The Open LeoConfig.leo command opens the configuration file.  The apply setting command applies any changes to settings made as the result of changing leoConfig.leo.</t>
<t tx="edream.110203163054.390">This option allows a comment to be iserted in derived files just after the initial @+leo line.  The comment will appear in an @comment sentinel.  See leoConfig.leo for full details.</t>
<t tx="edream.110203163054.391">This option allows you to specify the line endings to be used when writing derived files and when exporting files.  See leoConfig.leo for full details.</t>
<t tx="edream.110203163054.392">Changed the path_directive_creates_directories option in leoConfig.leo to create_nonexistent_directories.

The old name was too misleading.  Indeed, this option applies not just to @path directives, but to all situations in which the path name specified in @path directives or @root, @file, @rawfile or @silentfile nodes does not exist.

</t>
<t tx="edream.110203163054.393"></t>
<t tx="edream.110203163054.394"></t>
<t tx="edream.110203163054.395"></t>
<t tx="edream.110203163054.396">The new names are less cluttered than the old.</t>
<t tx="edream.110203163054.397">Leo now prints a summary of any exception taken to the log window, and a full traceback to the console window.</t>
<t tx="edream.110203163054.398">This is taken from Python Cookbook.

This may be of use to people developing Leo, though it's not clear how useful this is with Tk programs.</t>
<t tx="edream.110203163054.399">A small convenience that is actually quite nice to have.</t>
<t tx="edream.110203163054.400">Sentinel lines in Java files now start with //@.</t>
<t tx="edream.110203163054.401">It wasn't always completely clear when the command was complete.</t>
<t tx="edream.110203163054.402">Recently I have discovered a way of creating true, immutable global identifiers (called global tnode indices or gti's for short).  Version 4.0, due late this year or early next, will be the first version of Leo to take full advantage of the opportunities created by gti's.

Gti's will be a way of _permanently_ and _uniquely_ identifying every node (headline and body text) ever created by Leo, even when many people are working on the same .leo and derived files.  For the first time, Leo will be able _reliably_ to associate nodes in .leo files with nodes in derived files.

No previous version of Leo, including 3.7, has this ability, although that may not be so apparent to the casual user.  As a work around in all previous versions of Leo, .leo files contain copies of all information in derived files.  This "mirroring scheme" is needed so that clones in .leo files can be associated with their cloned counterparts in derived files.

While the mirroring scheme usually works well, it has some significant problems:

1. .leo files are much larger than they need to be.

2. Read errors occur if the derived files get out-of-synch with the information in the .leo file.  All clone links get broken when read errors occur, which basically ruins the resulting .leo file.  The only real way to recover is to use the Read Outline Only command.

3. Because out-of-synch conditions are so serious, it becomes a dicey proposition to save .leo files as backups; to create a reliable backup one must save the leo file along with all derived files.

Gti's solve all these problems:

1. .leo files no longer need to save a copy of all information in all derived files.  Leo will write only the root node of @file trees to the outline, secure in the knowledge that it can reliably recreate the outline from the derived file.

2. The dreaded read errors will be impossible because there is no longer any data in the .leo file that can become out-of-synch with data in the derived files.

3. Because .leo files can never become out-of-synch with derived files, we can, for the first time, safely backup a project by creating a "fat" .leo file that contains all information in all derived files.  Most .leo files will be "thin."  Saving "fat" .leo files will only happen as the result of a new Save Backup
command. 

I am excited about Leo 4.0.  It promises to revolutionize how people use Leo.</t>
<t tx="edream.110203163054.403">leo.py 3.7                                 October 9, 2002

Many improvements have been made to Leo.  The highlights:

- Now works with Python 2.1.  Previous versions required Python 2.2.
- Many new user options, including user-definable shortcuts for all commands
  and colors for all parts of Leo's windows.
  As a result, it is now possible to use arrow keys as you desire.
- Minimal support for Unicode Latin-1 (iso-8859-1) encoding. Better support is coming.
- Improved handling of relative path names.
- The @first directive allows lines to precede the opening @+leo sentinel line.
- The @last  directive allows lines to follow  the closing @-leo sentinel line.
- Better support for Perl+pod.
- Leo now ends all lines with '\n' regardless of platform.
- Leo is now compatible with Python 2.1.
- Simplified sentinels reduce spurious CVS diffs.
- Many other minor improvements and bug fixes.

Warning: Leo expects that all characters in derived files and .leo files are contained in the encoding specified by the xml_version_string option in leoConfig.txt.  Characters will be garbled if this restriction is not followed.  This restriction will be removed in the next release.

See the children of this node for full details.</t>
<t tx="edream.110203163054.404"></t>
<t tx="edream.110203163054.405"></t>
<t tx="edream.110203163054.406">The old code did not handle @comment /* */ in C mode because the */ given in the comment improperly terminated the scanning.

Changed find to rfind when scanning @@ sentinels.</t>
<t tx="edream.110203163054.407"></t>
<t tx="edream.110203163054.408">Under certain circumstances # was not properly colored when coloring plain text.</t>
<t tx="edream.110203163054.409">single quote colorized text in plain text mode.  This was due to missing parentheses.</t>
<t tx="edream.110203163054.410">The old code did not properly set the text selection in all cases.

This bug affected the Indent, Unindent, Extract and Extract Section.</t>
<t tx="edream.110203163054.411"></t>
<t tx="edream.110203163054.412">Body text was being cleared in a node in an @file tree if the node contained a reference to a section defined in a grandchild.  This was the first serious bug ever reported in the @file read logic.

The problem: Body text was being updated as the result of @+node sentinels rather than @+body sentinels.
This was wrong, as extra @+node sentinels are often generated when no body text is generated. The result is
that the body text was being cleared. 

The fix: I simply moved the code that creates body text from the @+node logic to the @+body logic in
scanText.</t>
<t tx="edream.110203163054.413">The new code resets the error count when reading each derived file, so errors in one file do not cascade to following derived files.</t>
<t tx="edream.110203163054.414"></t>
<t tx="edream.110203163054.415"></t>
<t tx="edream.110203163054.416">st_enter was not returning part numbers, which would have affected the Untangle command.</t>
<t tx="edream.110203163054.417">The old code undid the changes to only one headline of a group of cloned nodes. This was a serious bug because it would destroy the assumed eqquality between all cloned headlines.</t>
<t tx="edream.110203163054.418">The Find Previous command would get stuck once it found a match.</t>
<t tx="edream.110203163054.419">The original bug report:

"If you set the @tabwidth to something other than the Preference value, you'll see the body displayed appropriately. However, if you do a Ctrl-s to save the leo file, the body is redisplayed using the Preferences setting--of course, clicking on another node and then back to the original node displays with the correct tab setting again."</t>
<t tx="edream.110203163054.420">The old code remembered the insertion point only if it were set as the result of a keystroke.
</t>
<t tx="edream.110203163054.421">This was too confusing to users.  setup.py is intended only to create official distributions.</t>
<t tx="edream.110203163054.422">These improvements are listed in the approximate order of importance.</t>
<t tx="edream.110203163054.423"></t>
<t tx="edream.110203163054.424"></t>
<t tx="edream.110203163054.425">path_directive_creates_directories

Specifies whether to create a directory mentioned in an @file, @root node or @path directive if it does not exist.</t>
<t tx="edream.110203163054.426">relative_path_base_directory 

The directory to be used as a prefix for &lt;filename&gt; in @path &lt;filename&gt; and @file &lt;filename&gt; and @root &lt;filename&gt; when &lt;filename&gt; is a relative path.

Valid values for this option:

"!" means relative to the location leo.py (the default).
"." means relative to the location of the .leo file in the top window.
An absolute path (in platform-dependent format).

Relative paths are not allowed: such paths would be dangerous because their meaning would depend on the changing value of the current working directory.</t>
<t tx="edream.110203163054.427">remove_sentinels_extension

Sets the string to be appended to file names resulting from the Remove Sentinels command.  If the value starts with . the extension is appended to the original file name. Otherwise, the extension is appended before the file extension.

Example 1:
	File name x.y
	remove_sentinels_extension = _ns
	Result: x_ns.y

Example 2:
	File name x.y
	remove_sentinels_extension = .txt
	Result: x.y.txt
</t>
<t tx="edream.110203163054.428">write_clone_indices 

Indicates whether derived files will contain clone indices.

Please specify no clone indices if you are going to submit files to Leo's CVS site.</t>
<t tx="edream.110203163054.429">The following options now exist in the &lt;&lt; Options for newly opened windows &gt;&gt; section of LeoConfig.leo.

initial_horizontal_secondary_ratio

Sets the ratio of outline pane size to log pane size when splitting the primary panes horizontally.
The primary panes are the body pane and the secondary pane.

initial_vertical_secondary_ratio

Sets the ratio of tree pane size to body pane size when splitting the primary panes vertically.
The primary panes are the body pane and the secondary pane.


</t>
<t tx="edream.110203163054.430">The following options now exist in the &lt;&lt; Window options &gt;&gt; section of LeoConfig.leo.

body_text_foreground_color
body_text_background_color

The foreground and background colors of body text.

body_cursor_foreground_color
body_cursor_background_color

The foreground and background colors for the cursor in body text.

headline_text_unselected_foreground_color
headline_text_unselected_background_color

The foreground and background colors of unselected headline text.
Both must be specified for either to take effect.

headline_text_selected_foreground_color 
headline_text_selected_background_color

The foreground and background colors of selected headline text that is not being edited.
Both must be specified for either to take effect.

headline_text_editing_foreground_color
headline_text_editing_background_color

The foreground and background colors of unselected headline text in a headline that is being edited.
Both must be specified for either to take effect.

headline_text_editing_selection_foreground_color
headline_text_editing_selection_background_color

The foreground and background colors of selected text headline text in a headline that is being edited.
Both must be specified for either to take effect.

outline_pane_background_color

The background color of outline pane itself.

log_text_foreground_color
log_text_background_color

The foreground and background colors of log text.</t>
<t tx="edream.110203163054.431">The &lt;&lt; Keyboard shortcuts settings &gt;&gt; section of leoConfig.leo allows the user to specify keyboard shortcuts for all commands.

Notes:

1. There is one option for every command in Leo's menus; they won't be listed separately here.

2. For full documentation, see the

&lt;&lt; Keyboard shortcuts settings &gt;&gt; and
&lt;&lt; About keyboard shortcuts &gt;&gt;

sections of leoConfig.leo.  The gist of this documentation is that you must use names known to Tk, and Leo also provides a few other names.

3. At most one shortcut may be associated with a command.  If one really wanted to have two shortcuts, one would have to use two different command names. In particular, there is now only one shortcut for the Find Next command.
</t>
<t tx="edream.110203163054.432">Leo checks all characters that are entered (via typing or via paste) into headline and body text to see whether they can be represented in the encoding specified by the xml_version_string setting in leoConfig.txt.  Leo issues a message and _disallows_ the entry of the character if it can't be represented in that encoding.

This draconian behavior shouldn't be too much of a nuisance, at least temporarily. Note that _all_ characters are valid in the UTF-8 encoding, so the present version of Leo will allow you to specify all characters if you must. But the Latin-1 (iso-8859-1) encoding, being a one-byte encoding, limits you to at most 256 separate characters. 

In 3.8 I plan to allow you to use all Unicode characters, regardless of encoding, by using character references.  This will require some reorganization of the present code, and I don't want to delay 3.7 to handle them.

Warning: The present code does not handle well files (.leo or derived files) that contain characters outside the specified encoding.  At present, your best bet is to remove such characters for now.  Hopefully 3.8 will do a much better job handling characters "foreign" to the specified encoding.</t>
<t tx="edream.110203163054.433">Leo now writes only \n (Linux newlines) in derived files and .leo files.  This was done simply by opening derived files and .leo files in "wb" mode.</t>
<t tx="edream.110203163054.434"></t>
<t tx="edream.110203163054.435">1. Leo now supports relative_path_base_directory and path_directive_creates_directories user options.  See the discussion of those options in this document.

2. Leo now retains file modes when tangling and writing derived files.</t>
<t tx="edream.110203163054.436">Blank lines now preceed and follow =pod and =cut.

Improvements made to @first and @last directives.</t>
<t tx="edream.110203163054.437">These were added so to resolve the debate about what the Esc key should do.  The user can now bind Esc to either of these commands.</t>
<t tx="edream.110203163054.438">Leo no longer gives an error message when reading or writing cloned @file nodes.</t>
<t tx="edream.110203163054.439"></t>
<t tx="edream.110203163054.440">Leo writes derived files a bit differently than before.  These changes are compatible with the Borland version of Leo, provided that xml_version_string = UTF-8 in leoConfig.txt.

The changes:

1. Eliminated writing clone indices in derived files.  This reduces the number of spurious changes reported by CVS.  Leo now relies solely on information in .leo files to recreate clone indices.  This is safe because read errors clear clone indices anyway.  You can force clone indices to be written using the write_clone_indices user option in leoConfig.txt.

2. Removed extra newline following @+leo directive.  This is part of an unfinished plan to eliminate all extra blank lines in derived files.  It's not clear whether this plan will ever succeed.</t>
<t tx="edream.110203163054.441">Leo enables the Tangle and Untangle items in popup menus if any descendent of the selected node contains an @root node.  Similarly, Leo enables the Read @file nodes and Write @file nodes items in popup menus if any descendent of the selected node contains an @file node.</t>
<t tx="edream.110203163054.442"></t>
<t tx="edream.110203163054.443">leo.py 3.6                                 September 11, 2002

Highlights:

- Fixed a large number of bugs, especially bugs that appear only on Linux.
- Leo now remembers the previous insertion point and location of the scrollbar when switching between nodes.
- Added Match Brackets command.
- Added support for MouseWheel (Linux only).
- Added support for LaTex and PHP.
- Improved all aspects of the Help menu.
- Discovered a minor bug involving the Python (Idle) window and documented a workaround.

See the children of this node for full details.</t>
<t tx="edream.110203163054.444">The following minor bug can not easily be fixed because it involves an interaction between Leo and Idle.

After opening Idle with the Open Python Window command, opening another Leo window shows both the Leo window and a blank, square window.  Closing either of the new windows may cause exceptions, either immediately or later.

The best workaround is simply not to open any new Leo windows after using the Open Python Window command.</t>
<t tx="edream.110203163054.445"></t>
<t tx="edream.110203163054.446"></t>
<t tx="edream.110203163054.447">os.rename can fail on some Linux systems.</t>
<t tx="edream.110203163054.448">When starting Leo with no arguments the 'NewHeadline' node was not displayed. </t>
<t tx="edream.110203163054.449">Changed:

bitmap_name = os.path.join(self.loadDir,"Icons\LeoApp.ico") 

to:

bitmap_name = os.path.join(self.loadDir,"Icons","LeoApp.ico") 
</t>
<t tx="edream.110203163054.450">There were problems handling relative path names in @root and @path directives.</t>
<t tx="edream.110203163054.451">With Tk/Tcl 8.4, the Preferences window is empty (no buttons, fields, labels). 

Tcl 8.4 complains about using "col" in the grid() calls.</t>
<t tx="edream.110203163054.452">This routine does a better job of checking the Tk version than the old code in leoApp.py</t>
<t tx="edream.110203163054.453"></t>
<t tx="edream.110203163054.454">Only the last directive was in effect in @root trees.  The new code allows node-by-node control.</t>
<t tx="edream.110203163054.455">This involved calling readlineForceUnixNewline instead of readline in the atFile:read logic.</t>
<t tx="edream.110203163054.456"></t>
<t tx="edream.110203163054.457">How did I ever live without this?</t>
<t tx="edream.110203163054.458"></t>
<t tx="edream.110203163054.459">The cursor now changes to an arrow when it moves over a link in the About Leo dialog.

The About Leo dialog now includes a build revision number.

Fixed problems with the Leo icon in the About Leo dialog.

Improved download dialog in Tutorial command.</t>
<t tx="edream.110203163054.460">CVS conflict files produce so many error messages that these errors are useless.</t>
<t tx="edream.110203163054.461"></t>
<t tx="edream.110203163054.462"></t>
<t tx="edream.110203163054.463"></t>
<t tx="edream.110203163054.464">The Match Brackets command is enabled if the cursor is next to one of the following characters in the body pane:

( ) [ ] { } &lt; &gt;

This command looks for the matching character, searching backwards through the body text if the cursor is next to ) ] } or &gt; and searching forward through the text otherwise.  If the cursor is between two brackets the search is made for the bracket matching the leftmost bracket.

If a match is found, the entire range of characters delimited by the brackets is highlighted and the cursor is placed just to the left of the matching characters.  Thus, executing this command twice highlights the range of matched characters without changing the cursor.</t>
<t tx="edream.110203163054.465">This code is due to Dave Hein.

Leo understands the following PHP keywords:

&lt;?php, ?&gt;, __CLASS__, __FILE__, __FUNCTION__, __LINE__, and,	as, break, case, cfunction, class, const, continue, declare, default, do, else, elseif,  enddeclare, endfor, endforeach, endif, endswitch, endwhile, eval,  extends, for, foreach, function, global, if, new, old_function, or, static, switch, unset(), use, var, while, xor,

Leo does not yet color the following keywords containing():

array(), die(), echo(), empty(), exit(), include(), include_once(), isset(), list(), print(), require(), require_once(), return()</t>
<t tx="edream.110203163054.466">This code is due to Marcus A. Martin.

Leo understands the following LaTex keywords: capitalization is significant.  For example, \vert produces a single vertical line and \Vert produces a double vertical line.

\@, \(, \), \{, \},

\acute, \addcontentsline, \addtocontents, \addtocounter, \address,
\addtolength, \addvspace, \AE, \ae, \aleph, \alph, \angle, \appendix, 
\approx,\arabic, \arccos, \arcsin, \arctan, \ast, \author,

\b, \backmatter, \backslash, \bar, \baselineskip, \baselinestretch,
\begin, \beta, \bezier, \bf, \bfseries, \bibitem, \bigcap, 
\bigcup, \bigodot, \bigoplus, \bigotimes, \bigskip, \biguplus, 
\bigvee, \bigwedge,\bmod, \boldmath, \Box, \breve, \bullet,

\c, \cal, \caption, \cdot, \cdots, \centering, \chapter, 
\check, \chi, \circ, \circle, \cite, \cleardoublepage, \clearpage, 
\cline,\closing, \clubsuit, \coprod, \copywright, \cos, \cosh, 
\cot, \coth,csc,

\d, \dag, \dashbox, \date, \ddag, \ddot, \ddots, \decl, 
\deg, \Delta, \delta, \depthits, \det, 
\DH, \dh, \Diamond, \diamondsuit, \dim, \div, \DJ, \dj, 
\documentclass, \documentstyle, \dot, \dotfil, \downarrow,

\ell, \em, \emph, \end, \enlargethispage, \ensuremath, 
\enumi, \enuii, \enumiii, \enuiv, \epsilon, \equation, \equiv,
\eta, \example, \exists, \exp,

\fbox, \figure, \flat, \flushbottom, \fnsymbol, \footnote, 
\footnotemark, \fotenotesize, 
\footnotetext, \forall, \frac, \frame, \framebox, \frenchspacing, 
\frontmatter,

\Gamma, \gamma, \gcd, \geq, \gg, \grave, \guillemotleft, 
\guillemotright,\guilsinglleft, \guilsinglright,

\H, \hat, \hbar, \heartsuit, \heightits, \hfill, \hline, \hom, \hrulefill,\hspace, \huge,\Huge,\hyphenation

\Im, \imath, \include, includeonly, indent, \index, \inf, \infty, \input, \int, \iota,\it, \item, \itshape,

\jmath, \Join,

\k, \kappa, \ker, \kill,

\label, \Lambda, \lambda, \langle, \large, \Large, \LARGE, 
\LaTeX, \LaTeXe, 
\ldots, \leadsto, \left, \Leftarrow, \leftarrow, \lefteqn, \leq,
\lg, \lhd, \lim, \liminf, \limsup, \line, \linebreak, 
\linethickness, \linewidth,\listfiles,
\ll, \ln, \location, \log, \Longleftarrow, \longleftarrow, 
\Longrightarrow,longrightarrow,

\mainmatter, \makebox, \makeglossary, \makeindex,\maketitle, \markboth, \markright,
\mathbf, \mathcal, \mathit, \mathnormal, \mathop,
\mathrm, \mathsf, \mathtt, \max, \mbox, \mdseries, \medskip,
\mho, \min, \mp, \mpfootnote, \mu, \multicolumn, \multiput,

\nabla, \natural, \nearrow, \neq, \newcommand, \newcounter, 
\newenvironment, \newfont,
\newlength,\newline, \newpage, \newsavebox, \newtheorem, \NG, \ng,
\nocite, \noindent, \nolinbreak, \nopagebreak, \normalsize,
\not, \nu, nwarrow,

\Omega, \omega, \onecolumn, \oint, \opening, \oval, 
\overbrace, \overline,

\P, \page, \pagebreak, \pagenumbering, \pageref, \pagestyle, 
\par, \parbox,\paragraph, \parindent, \parskip, \part, 
\partial, \per, \Phi, \phi,\Pi, \pi, \pm, 
\pmod, \pounds, \prime, \printindex, \prod, \propto, \protext, 
\providecomamnd, \Psi,\psi, \put,

\qbezier, \quoteblbase, \quotesinglbase,

\r, \raggedbottom, \raggedleft, \raggedright, \raisebox, \rangle, 
\Re, \ref, \renewcommand, \renewenvironment, \rhd, \rho, \right, 
\Rightarrow,\rightarrow, \rm, \rmfamily,
\Roman, \roman, \rule, 

\s, \samepage, \savebox, \sbox, \sc, \scriptsize, \scshape, 
\searrow, \sec, \section,
\setcounter, \setlength, \settowidth, \settodepth, \settoheight, 
\settowidth, \sf, \sffamily, \sharp, \shortstack, \Sigma, \sigma, 
\signature, \sim, \simeq, \sin, \sinh, \sl, \SLiTeX,
\slshape, \small, \smallskip, \spadesuit, \sqrt, \sqsubset,
\sqsupset, \SS,
\stackrel, \star, \subsection, \subset, 
\subsubsection, \sum, \sup, \supressfloats, \surd, \swarrow,

\t, \table, \tableofcontents, \tabularnewline, \tan, \tanh, 
\tau, \telephone,\TeX, \textbf,
\textbullet, \textcircled, \textcompworkmark,\textemdash, 
\textendash, \textexclamdown, \textheight, \textquestiondown, 
\textquoteblleft, \textquoteblright, \textquoteleft,
\textperiod, \textquotebl, \textquoteright, \textmd, \textit, \textrm, 
\textsc, \textsl, \textsf, \textsuperscript, \texttt, \textup,
\textvisiblespace, \textwidth, \TH, \th, \thanks, \thebibligraphy,
\Theta, theta, 
\tilde, \thinlines, 
\thispagestyle, \times, \tiny, \title,\today, \totalheightits, 
\triangle, \tt, 
\ttfamily, \twocoloumn, \typeout, \typein,

\u, \underbrace, \underline, \unitlength, \unlhd, \unrhd, \Uparrow,
\uparrow,\updownarrow, \upshape, \Upsilon, \upsilon, \usebox,
\usecounter, \usepackage, 

\v, \value, \varepsilon, \varphi, \varpi, \varrho, \varsigma, 
\vartheta, \vdots, \vec, \vector, \verb, \Vert, \vert, \vfill,
\vline, \vphantom, \vspace,

\widehat, \widetilde, \widthits, \wp,

\Xi, \xi,

\zeta</t>
<t tx="edream.110203163054.467">leo.py 3.5                                  August 14, 2002

Highlights:

- Added new entries in the help menu.
 (Including a link to Joe Orr's excellent ScreenBook tutorial).
- Added the importFiles script in leoImport.py.
- Added configuration options for horizontal scrollbars.
- Added better warnings for read-only files.
- Removed all '\r' when reading derived files.
- Fixed crasher in Read Outline Only command.
- Fixed crasher when leoConfig.txt did not exist.
- Many small improvements and bug fixes.</t>
<t tx="edream.110203163054.468"></t>
<t tx="edream.110203163054.469">This may be the cause of truncated leoConfig.txt files on Linux.</t>
<t tx="edream.110203163054.470"></t>
<t tx="edream.110203163054.471"></t>
<t tx="edream.110203163054.472">Removed '\r' characters when reading.  The write logic is unchanged.</t>
<t tx="edream.110203163054.473">Relative paths should not set the global default paths.  Instead, the relative path is concatenated to the global default path when the file is opened.</t>
<t tx="edream.110203163054.474"></t>
<t tx="edream.110203163054.475"></t>
<t tx="edream.110203163054.476">Added log_pane_wraps and outline_pane_scrolls_horizontally configuration settings.</t>
<t tx="edream.110203163054.477"></t>
<t tx="edream.110203163054.478">Note: b4 contains a fix to b3 in this area:  for writing, we must first test whether the file exists.  Otherwise we may get a false indication that the (non-existent) file is read-only.</t>
<t tx="edream.110203163054.479">Added the importFiles script in leoImport.py. Use this script as follows:

- Select the node under which you want the imported files to appear.
- Open the Python window within Leo.
- Type the following in the Python window:

import leoImport
dir = "c:/prog/test"  # or some other directory
type = ".py"  # Type of files you want to import.
leoImport.importFiles(dir,type)

If you want to import all files in a directory, replace the last line with:

leoImport.importFiles(dir)</t>
<t tx="edream.110203163054.480">leo.py 3.4                                     August 11, 2002

This release contains many small improvements and bug fixes.  The highlights:

- Fixed several crashers involving Unicode.
- The Show Invisibles command now makes blanks and tabs look much better.
- Created leoConfig.leo, from which leoConfig.txt is now derived.
- Added save_clears_undo_buffer configuration option.
- Fixed a large number of problems with the configuration code.
- The usual minor improvements and bug fixes.

See the children of this node for full details.</t>
<t tx="edream.110203163054.481"></t>
<t tx="edream.110203163054.482">The problem is that the ratio is saved in the .leo file and the split direction is not. So if leoConfig.txt is read-only you the Toggle Split Direction command will permanently change the body-outline ratio _without_ permanently changing the split direction itself.

This basically sucks, and here are my reasons: 

1. I do not want to be adding more options to .leo files; the whole idea of leoConfig.txt is to move in the opposite direction. 

2. You can make everything work more like you would expect by making leoConfig.txt read-write. 

3. Especially in the case of the split direction, I expect people to have strong preferences one way or the other, so even if leoConfig.txt is read-only it shouldn't be too odious to pick a split direction and live with it.</t>
<t tx="edream.110203163054.483">The undo buffer creates a lot of strings.  On some system this may be a problem.  If save_clears_undo_buffer = 1 the Save command (and only the Save command) will clear the undo buffer.</t>
<t tx="edream.110203163054.484">The new spelling is to limit_directory_search_extension.  Note that this affects the valid entries in leoConfig.txt.</t>
<t tx="edream.110203163054.485">This allows us to create leoConfig.txt more easily, and provides a safe place to permanently store comments when read-write mode is on.</t>
<t tx="edream.110203163054.486">If a setting was missing or "ignore" it could never be set!  This no doubt could have caused a wide variety of symptoms.  In particular, in the distributed leoConfig.txt file it meant that settings for "default" fonts and sizes were never updated!</t>
<t tx="edream.110203163054.487">The new code properly deletes previous entries regardless of case or path separators.</t>
<t tx="edream.110203163054.488">There were a couple of bugs here.

Note that the ratio (whichever the direction) is stored in the .leo file.  The initial_splitter_orientation setting in leoConfig.txt applies to _all_ files.  The initial_vertical_ratio and the corresponding initial_horizontal_ratio  apply only to new files, so are essentially useless.

Yes, this is pretty stupid; it's the result of not wanting to add more stuff to Leo's file format.</t>
<t tx="edream.110203163054.489"></t>
<t tx="edream.110203163054.490"></t>
<t tx="edream.110203163054.491"></t>
<t tx="edream.110203163054.492"></t>
<t tx="edream.110203163054.493">leo.py 3.1 contains Python code that may be of interest to some Python programmers.  All Python files are derived from LeoPy.leo.

See the children of this node for details.</t>
<t tx="edream.110203163054.494">This script does much of the grunt work of converting from C/C++ syntax to Python syntax.  It was surprisingly effective in converting Leo from C++ to Python.  These scripts don't need to be perfect to save a _lot_ of work.  And of course you can always add your own improvements...

As written, the script converts an entire Leo tree.  It would be easy to write an entry that would convert plain text files, but it's probably best to import the files to be converted into Leo first.  That way the slow algorithms in c2py.py will work on smaller pieces of text.</t>
<t tx="edream.110203163054.495">This code gathers and prints static statistics about Python bytecode.</t>
<t tx="edream.110203163054.496">The file leoUtils.py contains some small Tkinter utilities:

w,h,x,y = get_window_info(top) returns the width, height, x and y positions of the Tkinter window top.

center_dialog(top) centers the Tkinter window top on the screen.

w,f = create_labeled_frame(parent...) creates a labeled Tkinter window as a child of parent.  The caller packs widgets into f to create the frame.

leoUtils.py contains many other routines including an Python version of the Sherlock tracing package.</t>
<t tx="edream.110203163054.497">leoFontPanel.py puts up a Font dialog.  This dialog dispenses with the typical "sample" pane and instead changes text immediately directly on the screen.  Comes with Ok, Cancel and Revert buttons.  IMO, this dialog is much better than the sample Tk/Tkinter font dialogs available on the web.</t>
<t tx="edream.110203163054.498">leoColor.py contains code to syntax color Tk.Text widgets for a variety of languages.  Supporting a new language here is mostly a matter of adding another table of keywords.</t>
<t tx="edream.110203163054.499">Leo supports powerful outlining features, including clones.  Clones are challenging to implement, to say the least.  The vnode and tnode classes, defined in leoNodes.py, represent the underlying data.  vnodes represent nodes on the screen.  vnodes may share text, the tnode class is the "unit of sharing" of such text.  The leoTree class draws the tree and handles events, including dragging nodes around the screen.  The Commands class calls the vnode, tnode and leoTree classes to handle menu commands.  In Smalltalk's model/view/controller terminology, the vnode and tnode classes are model class, the leoTree class is a view class, and the Commands class is a controller class.</t>
<t tx="edream.110203163054.500"></t>
<t tx="edream.110203163054.501">Now at last it is clear why Leo hasn't been writing derived files affected by clones.  It's not enough to mark v dirty.  We must mark all the cloned nodes of v's tree dirty as well.

However, we only need do this when a node is deleted, and we definitely do _not_ want to do this otherwise, for that would mark far too many nodes dirty.  To get around this, we leave v.setDirty() as it was, and use the new code only in v.setDirtyDeleted.

Note that the undo and redo cases handle this automatically because they call c.doDelete.

So now we can state a rule that should not ever be broken: after doing a Save command, a Write @file Nodes command should always report "unchanged" for all files.</t>
<t tx="edream.110203163054.502"></t>
<t tx="edream.110203163054.503">Added setRevertVars to update revert settings.  This is called from __init__ and onOk.</t>
<t tx="edream.110203163054.504">Changed idle_body_key and idle_head_key, leoTangle::os and tnode::setTnodeText.

We must remove backticks from messages that might contain unicode characters so they will print properly.  There were only a few instances, and they are all error messages that hardly ever get executed, so I hope I was careful putting them in.  I should be able to find them all by looking for '"'.</t>
<t tx="edream.110203163054.505">Repeated double-clicking (without intervening single-click) caused the selection to move to the left.</t>
<t tx="edream.110203163054.506"></t>
<t tx="edream.110203163054.507"></t>
<t tx="edream.110203163054.508">This is consistent with what the Import commands do for the other file types.  It's also much safer.</t>
<t tx="edream.110203163054.509"></t>
<t tx="edream.110203163054.510">This makes selected text look much better and makes Show Invisibles look much better as well.  

This was not easy to do.  Apparently tag settings interfer with the Tk.Text settings.  I have not found a way to specify the selectbackground color for tags.  The only way I could get things to work is define whitespace tags only when in showInvisibles mode.</t>
<t tx="edream.110203163054.511">.tmp files disappear On Windows XP after Leo exits!</t>
<t tx="edream.110203163054.512">leo.py 3.3                                     August 3, 2002

This version of Leo:

- Added support for Unicode.
- Improved the Import commands.
- Fixed numerous bugs related to configuration settings.
- Fixed the "Javadoc" bug and several latent bugs related to it.

See the children of this node for details.

Edward K. Ream</t>
<t tx="edream.110203163054.513">It is now possible to use non-Ascii characters in Leo!

Leo uses the xml_version_string setting to encode Unicode characters in .leo files.  This will be UTF-8 by default.  I've also very briefly tested ISO-8859-1.

I am a complete Unicode ignoramous.  It seemed trivial to add Unicode support to Leo, and if there are any fine points that should have been considered I no doubt did not consider them...</t>
<t tx="edream.110203163054.514">The Import command now does a better job of removing excess leading whitespace.

When importing .java files, Leo now preserves newlines in leading block comments.  This makes the typical weird Java comments look better.  For example,

/**  This is a typical,
  * brain-dead,
  * Java comment.
  */

Now gets redered as

@ * This is a typical
 * brain-dead,
 * Java comment.
@c

The comment will be reconstituted properly when rewritten.
</t>
<t tx="edream.110203163054.515">This never happened before because all languages had either 1 or 3 delims.  But Java now has only 2 delims to force block comments.</t>
<t tx="edream.110203163054.516">Leo should now handle negative tab widths properly.</t>
<t tx="edream.110203163054.517">- Negative tab widths are now honored properly.

- Made 'additional_body_text_border' setting functional.

- Made 'body_pane_wraps' setting functional.

- There was a bug that made the following non-functional.

	"read_only"
	"xml_version_string"
	"limit_count"
	"body_pane_wraps"

That is, only the default settings in leoConfig.py were used, not the settings in leoConfig.txt.

- The old code did not use the "page_width" and "tab_width" settings from leoConfig.txt.</t>
<t tx="edream.110203163054.518">leo.py 3.2                                     July 30, 2002

This version generalizes the @others directive, improves the Import command and fixes several bugs.  See the children of this node for full details.

The highlights:

- Nested @others directives are now valid, an important improvement.
  This simplifies files that define more than one class.
- Improved the Import command and squashed several bugs lurking there.
- Made the various Go commands in the Outline-Move/Select menu functional
  by reassigning keyboard shorts
- Fixed a crasher in the Prefs Panel.
- Fixed numerous bugs in the Set Colors command.
- Fixed syntax coloring of C strings that span multiple lines.
- The usual minor improvements and bug fixes.

Edward K. Ream</t>
<t tx="edream.110203163054.519">Nested @others directives are now valid, even when no named node intervenes.  This is a significant enhancement to Leo because it is now easier to define multiple classes in a single file.  The leoNode.py file also uses nested @others directives.

The outline shown in the child of this node shows the general idea.

The Import command uses nested @others to great effect in Python files containing many classes.  For example, try importing the file Python/Lib/Compiler/ast.py.</t>
<t tx="edream.110203163054.520">@color
@ignore

# This is the "outer" @others
@others
</t>
<t tx="edream.110203163054.521">class a:
	# This is an "inner" @others.  No named node intervenes.
	@others</t>
<t tx="edream.110203163054.522">def one():
	pass</t>
<t tx="edream.110203163054.523">def two():
	pass</t>
<t tx="edream.110203163054.524">class b:
	# This is an "inner" @others.  No named node intervenes.
	@others</t>
<t tx="edream.110203163054.525">def one():
	pass</t>
<t tx="edream.110203163054.526">def two():
	pass</t>
<t tx="edream.110203163054.527">The Import command creates nested @others directives when parsing Python classes.

Fixed two bugs in the Import command:

1. The Import command now properly places the first @others directive of Python files.  Previously the @others directive was placed before section references, so code could be rearranged.

2. The Import command now properly handles all C preprocessor directives.  Previously there were problems handling the #ifndef directive which could ruin imports.

Two other minor improvements:

1. This is reasonable: we don't wan't people generating files from imported files unless they take some positive action.

2. The Import command now checks that different branches of #if, #else, #endif directives have the same net number of braces, and warns if they do not.  This logic was inserted while trying to fix bug #2 above.</t>
<t tx="edream.110203163054.528">It's too confusing to have arrow keys mean different things in different panes.

For one thing, we want to leave the focus in the body pane after the first click in the outline pane, but that means that the arrow keys must still be functional in the _body_ pane!

Alas, all the various combinations of key bindings of arrow keys appear to do something; there are none left to use for moving around in the outline pane.  So we are stuck with poor shortcuts.</t>
<t tx="edream.110203163054.529">Leo could sometimes crash when the user selected Cancel in the Preferences panel.</t>
<t tx="edream.110203163054.530"></t>
<t tx="edream.110203163054.531">There were too many problems in the old color panel.

- Completely revised the Revert logic in the main Color panel.
- The color name picker now reverts properly.
- Color names and color swatches are now properly updated in all cases,
  so there is no need to write color values to the log window.
- Eliminate quotation marks around color names and values.
- The color picker now shows the value of the present color, not the revert color.
- Increased the width of name buttons to handle long color names.
</t>
<t tx="edream.110203163054.532">Thanks to Thomas Guettler for suggesting this.</t>
<t tx="edream.110203163054.533">This script uses the dis module to print static statistics about Python bytecode.  Of no use to anyone but me.</t>
<t tx="edream.110203163054.534">leo.py 3.1                                     July 20, 2002

This version fixes a blunder that affects only leo.py 3.0.  I recommend that all users of 3.0 upgrade to this version.

With this release Leo's to-do list is now empty! I shall fix bugs as they are reported. I'll add new features only if convinced that they contribute significantly to Leo.

The highlights:

- Fixed a blunder: Leo 3.0 did nothing when it was opened directly from leo.py.
  (Opening leo using openLeo.py did work.)
- Created a compare panel to control scripts in leoCompare.py.
- Added many new settings in leoConfig.txt to initialize the compare panel.
- The FAQ tells how to add support for new languages.
  (These instructions also appear in the "Notes/How To" section in LeoPy.leo)
- The usual minor improvements and bug fixes.

Edward K. Ream</t>
<t tx="edream.110203163054.535">The file comparison window helps people verify that imported files are, in fact, precisely equivalent to the original files.</t>
<t tx="edream.110203163054.536">Here are the new settings in leoCompare.txt:

# Initial settings of the Compare panel.
# 	These correspond to the keyword parameters of the leoCompare constructor.
# 	Exception: there are no keywords for compare file names in the constructor.

[compare options]

# ----- Options specifying files for the Compare panel.

compare_file_1 = c:/prog/test/compareTest1/file1.txt
#	Path to the first file or directory to be compared.
#	Directory compares ignore a filename part of the path, if present.
#	E.g., c:/directory1/spam.py is valid for directory compares.

compare_file_2 = c:/prog/test/compareTest2/file2.txt
#	Path to the second file or directory to be compared.
#	Directory compares ignore a filename part of the path, if present.
#	E.g., c:/directory2/spam.py is valid for directory compares

output_file = c:/prog/test/compareResults.txt
#	Path to the output file.
#	Leo will silently write to this file, regardless of whether it already exists.
#	Leo will write to the log pane if this path is empty or invalid.

append_output_to_output_file = 0
#	0: Replace output file with results of compare.
#	1: Append output to output file.

# ----- Options related to directory compares.
#	These options has no effect when comparing files.

limit_directory_search_extenstion = .py
#	Limit directory searches to files with the given file extension.
# 	Examples:
#		None	Compare all files when comparing directories.
#		.py  	Compare .py files when comparing directories.

# ----- Options related to file compares.
#	These options have no effect when comparing directories.

ignore_blank_lines = 1
#	1: Ignore blanks lines when comparing files.

ignore_first_line_of_file_1 = 0
#	1: Ignore the first line of compare_file_1 when comparing files.

ignore_first_line_of_file_2 = 0
#	1: Ignore the first line of compare_file_2 when comparing files.

ignore_interior_whitespace = 0
#	1: Ignore whitespace after the leading whitespace of a line when comparing files.

ignore_leading_whitespace = 0
#	1: Ignore leading whitespace of each line when comparing files.
#	Not recommended when comparing .py files.

ignore_sentinel_lines = 0
#	1: Ignore sentinel lines when comparing files.
#	Leo sets sentinel comment delimiters from the first line of each file.
#	This option has no effect if the first line is not a @+leo line.

# ----- Options affecting how Leo shows the results of file compares.
#	(Leo gathers statistics regardless of these options.)

limit_count = 9
#	0: Show lines regardless of the number of mismatches.
#	n: Stop showing lines after n mismatches.

make_whitespace_visible = 0
#	1: Show blanks as [ ] and tabs as [t]

print_both_lines_for_matches = 0
#	0: Print only the line of compare_file_1 when showing matching lines.
#	1: Print lines of both files when showing matching lines.

print_matching_lines = 0
#	1: Print lines that match using the print_both_lines_for_matches option.

print_mismatching_lines = 1
#	1: Print lines that do not compare equal to each other.

print_trailing_lines = 1
#	1: Print lines all lines in one file after an end-of-file is seen on the other file.</t>
<t tx="edream.110203163054.537">The new rules allow leo.py 3.1 to read and write .leo files more like leo.py 2.x when there is no leoConfig.txt file.  The scheme used in leo.py 3.0 meant that preferences were _never_ written to .leo files.  It's advantage was that all defaults were specified in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

I think the present scheme is more natural, but we shall see...

In effect, Leo sets and gets various options in the following order of precedence:

1. Use explicit settings in leoConfig.txt if they exist.

2. Use defaults for leoConfig.txt, but only if leoConfig.txt exists.  These defaults are found in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

3. Use settings in .leo files if leoConfig.txt does not exist.

4. If leoConfig.txt does not exist, and the .leo file does not specify a setting, use hard-coded settings in the various classes, just as leo.py 2.x did.</t>
<t tx="edream.110203163054.538">The @pagewidth, @tabwidth and @language directives could not have worked while tangling. Apparently nobody has every used these directives in @root trees!</t>
<t tx="edream.110203163054.539">The Flatten Outline command must use an escape convention so that it can distinguish between the "+" and "-" characters that denote a headline and any "+" and "-" characters that start a line of body text.

The old version of Flatten Outline inserted a backspace before _all_ "+", "-" and backspace characters.  The new version of Flatten Outline inserts a backspace before such characters only if they are the first non-whitespace character of a line.

This change affects the "file format" used by the Import Flattened Outline command.  If you import a file flattened with the old version of Flatten Outline, the new Import Flattened Outline will remove the inserted backspace only if it is the first non-whitespace character of the line.  In practice, this is unlikely to be a problem: you could just manually convert "\\", "\+" and "\-" to "\", "+" and "-" throughout the imported file.</t>
<t tx="edream.110203163054.540">The Open Python Window command now attempts to add IDLE's location to sys.path if import idle fails.

Bernhard Mulder contributed the code that made this improvement possible.

</t>
<t tx="edream.110203163054.541"></t>
<t tx="edream.110203163054.542">leo.py 3.0                                     July 16, 2002

This version is called 3.0 because it can optionally produce files that can NOT be read by the leo.py 2.x or the Borland version of Leo.  However, by default, leo.py 3.0 DOES produce files that all previous versions of Leo can read.

See the children of this node for full details.  The highlights:

- Support for many user options stored in leoConfig.txt, including, among others,
  fonts in all panes, colors for syntax coloring and default window size and position.
- Support for .leo files with XML types like "ISO-8859-1", controlled by a user option.
  Note: by default, Leo writes files compatible with previous versions of Leo.
- Powerful new Color and Font pickers, fully connected to user options.
- Added Toggle Split Direction command, under control of user options.
- Added autoscrolling in the outline pane.
- Windows open at the position in which they were saved.
- The size and position of new windows can be controlled with user options.
- Eliminated drawing problems while opening files.
- Improved syntax coloring for @comment plain.
- The Convert All Blanks and Convert All Tabs commands are now undoable.
- Leo warns and aborts if Python 2.2 or above is not running.
- The usual bug fixes.

At least one more version of leo.py is planned.</t>
<t tx="edream.110203163054.543">You now have a choice: you can configure Leo to please previous versions of Leo or to please XML parsers:

Leo now uses the xml_version_string configuration setting, if present, to override the UTF-8 setting used in all previous versions of Leo.  The default value of this setting is UTF-8, so by default leo.py will write files that may be read by any previous version of leo.py or the Borland version of Leo.

However, xml_version_string = ISO-8859-1 will produce .leo files that are more acceptable to XML parsers when those .leo files contain Unicode characters that are not found in the UTF-8 (Ascii) character set.  In any event, the choice of whether to please previous versions of Leo or XML parser is completely up to you. 

If the setting does not exist, whatever value is present in the .leo file will be written when the .leo file is written.  For new files, a value of UTF-8 will be used when this setting is not present.

Notice that this also affects what is written to the clipboard.</t>
<t tx="edream.110203163054.544"></t>
<t tx="edream.110203163054.545">This version supports many more options than before.  See leoConfig.txt for the full list.

Leo looks for leoConfig.txt in the same places as in leo.py 2.5.  If Leo does not find leoConfig.txt, This version will use defaults specified in tables defined in the section
	&lt;&lt; define default tables for settings &gt;&gt;
in leoConfig.py.  So it is now convenient to change settings in leo.py itself as well as in leoConfig.txt.</t>
<t tx="edream.110203163054.546">Including the split direction and split ration.

Leo now uses all configuration settings from leoConfig.txt.</t>
<t tx="edream.110203163054.547">If you drag a headline above or below the outline pane the outline pane will scroll automatically.  As before, Leo will cancel the drag if you release a headline anywhere but over another headline's icon.</t>
<t tx="edream.110203163054.548">You can specify colors for each syntax coloring construct using a color wheel or by choosing one of the standard Tk color names.  When a color becomes active Leo writes its value or color name to the log pane for your reference.  This is useful when setting coloring options in leoConfig.txt.</t>
<t tx="edream.110203163054.549">Using this panel should be self-explanatory (what you see is what you get) with the following exceptions:

1.  When a font becomes "active", the new font appears in the panes whose check boxes are selected.  A font becomes active when you double-click its name, or check or uncheck any checkbox.

It would be much better to have a font become active if you just select its name.  Alas, that is not possible due to a well-known gap in the Tk.Listbox class.

2. Font sizes must be greater than 0 and less than 100 for them to become in effect.

3. Choosing very _small_ values for font sizes may cause Leo's window to _expand_ its width.

4. When you choose OK or Cancel Leo writes the fonts presently active in each pane to the log pane for your reference.  This is useful when setting font options in leoConfig.txt.</t>
<t tx="edream.110203163054.550">This was a supremely irritating bug.</t>
<t tx="edream.110203163054.551">This command switches between vertical and horizontal orientations of the Leo window.  In the vertical orientation, the body pane appears below the pane containing the outline and log panes.  In the horizontal orientation, the body pane appears to the left the pane containing the outline and log panes.

leoConfig.txt specifies the default direction.  If leoConfig.txt does not exist, or does not specify the direction, the "vertical" orientation is used, just as in previous versions.

By default, the ratio of pane outline pane to the body pane is 0.5 in the vertical orientation and 0.3 in the horizontal orientation.  These two ratios may be changed using leoConfig.txt.</t>
<t tx="edream.110203163054.552">The @comment directive no longer suppresses syntax coloring.  Leo directives (but not doc parts) are colored when @language plain is in effect.  The user can, as always, suppress all coloring by using @nocolor.  The new rules are much more natural than the old, and much less confusing.</t>
<t tx="edream.110203163054.553"></t>
<t tx="edream.110203163054.554"></t>
<t tx="edream.110203163054.555">The old colorer colored all Leo directives blue, the same color as keywords in whatever language is current. I think the distinction between Leo directives and language keywords is useful.  Of course, you can control syntax coloring yourself by altering leoConfig.txt.</t>
<t tx="edream.110203163054.556">This message is printed to the console, not the log pane.  On windows, this may not always be visible.</t>
<t tx="edream.110203163054.557">Leo will convert underscores in the @comment directives to significant spaces.  For example,

@comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).</t>
<t tx="edream.110203163054.558"></t>
<t tx="edream.110203163054.559">This happened sometimes when using @comment.</t>
<t tx="edream.110203163054.560">Leo directives were mostly being colored using the colors for keywords.  This didn't show up because both were colored blue.</t>
<t tx="edream.110203163054.561">Only one window now appears when opening a .leo file, and the window is completely drawn before anything gets written to the log pane.</t>
<t tx="edream.110203163054.562">Added new code for Convert All Blanks and Convert All Tabs.

Fixed a bug that resulted in Convert Tabs being undoable.</t>
<t tx="edream.110203163054.563">This makes the panel much more convenient to use.</t>
<t tx="edream.110203163054.564"></t>
<t tx="edream.110203163054.565">leo.py version 2.5.1                            July 7, 2002

2.5.1 This version corrects crashers that affect undo/redo move commands.
Version 2.5 has been withdrawn.
Anyone using 2.5 should use 2.5.1 instead.

This is a major step forward to completing leo.py.  It adds significant new features and corrects many bugs.  Full details are found in the children of this node.  Here are the highlights, in approximate order of importance:

1. Leo supports tab widths properly, and negative tab widths cause Leo to convert tabs to blanks as you type.  Three new commands appear in the Edit Body menu: Convert Tabs, Convert All Tabs and Convert All Blanks.  Convert All Tabs and Convert All Spaces convert the entire selected tree.

2. Leo now allows you to override selected preferences using a configuration file called leoConfig.txt. Leo acts as before if this file does not exist.  An option in leoConfig.txt specifies whether leoConfig.txt is read-only.

3. The Preferences panel is now a modal dialog containing Ok, Cancel and Revert buttons.  This makes it clear what preferences are being set.

4. At long last, cut and paste work properly in all situations.  You can cut and paste between Leo and other applications, or between two different copies of Leo.

5. Added the Recent Files submenu to the File menu.  Very nice to have.

6. Fixed a number of bugs, including several crashers.  Fixed several bugs in the Import commands.  Leo will no longer abort reading if it detects an invalid directory name in the Default Tangle Directory in the Preferences panel.

leo.py is almost complete.  The only remaining tasks on my list are:

1. Make the Set Font... and Set Colors... commands functional.  This will be easy now that leoConfig.txt exists.
2. Fix the Javadoc bug.</t>
<t tx="edream.110203163054.566">The following are listed in the approximate order of their importance.  The marked nodes are particularly important.</t>
<t tx="edream.110203163054.567">Gary Herron suggested this changes.</t>
<t tx="edream.110203163054.568">These commands convert an entire tree.</t>
<t tx="edream.110203163054.569">This command converts leading tabs to blanks in a single node.</t>
<t tx="edream.110203163054.570">Previous versions of Leo ignored the tab width field!  This field is now fully functional.  </t>
<t tx="edream.110203163054.571">Leo converts tabs to blanks as you type when a negative tab width is specified.</t>
<t tx="edream.110203163054.572">The Preferences panel is now a modal dialog.  This solves a number of problems, both for the implementation and for the user.  It is now completely clear which preferences are being set, viz., the preferences for the window on top.  In addition, the Prefs panel now shows the name of the window whose preferences are to be set.

The Prefs panel now contains OK, Cancel and Revert buttons.  These are useful, and they are possible only because we have a modal dialog.</t>
<t tx="edream.110203163054.573">You may now cut and paste between Leo and other apps, or between two different copies of Leo.</t>
<t tx="edream.110203163054.574">The elements of this submenu are saved in leoConfig.txt, if present.

Leo adds files to this submenu even if leoConfig.txt is missing or read-only, but those additions will not be remembered unless leoConfig.txt is present and writable.</t>
<t tx="edream.110203163054.575"></t>
<t tx="edream.110203163054.576"></t>
<t tx="edream.110203163054.577"></t>
<t tx="edream.110203163054.578">1. Importing the following script

class C:
    def __init__(self):
        pass

created an outline with class C appearing in two nodes.

2. Importing the following file created orphan nodes for declaration.

import sys # This line becomes an orphaned node
class C:
    xyz = 'xyz' # This line becomes an orphaned node
    def __init__(self):
        pass

3. Importing a Python file containing classes without methods resulted in nested classes. There is still a minor problem:  The following

class A:
	pass

puts the "pass" in a section called &lt;&lt; class A declarations &gt;&gt;.  This is not easy to fix: you will have to correct it by hand.

4. Improved the Import to @root command.  Added @root &lt;filename&gt; to the body text of the root of tree and eliminated @language and @others directives.</t>
<t tx="edream.110203163054.579">This is important, because it means that invalid entries in, say, the Default Tangle Directory preference will no longer abort an attempted read.</t>
<t tx="edream.110203163054.580"></t>
<t tx="edream.110203163054.581">This would happen if the Default Tangle Directory did not exist in the Prefs panel.</t>
<t tx="edream.110203163054.582">This command always crashed, perhaps due to a reversion.</t>
<t tx="edream.110203163054.583">The crash happened if the Import command was executed in a new, unsaved file.

The fix was to the directory logic in import.scanAllDirectives.</t>
<t tx="edream.110203163054.584"></t>
<t tx="edream.110203163054.585"></t>
<t tx="edream.110203163054.586">The bug involves only the clone mark itself: nodes have always been properly joined.</t>
<t tx="edream.110203163054.587">Gary Herron reported this bug and told me how to fix it. This change is to the default file extension field of file dialogs.  It seems to have no effect on Windows. Apparently this makes a difference in Linux...</t>
<t tx="edream.110203163054.588">These commands no longer change the file name associated with a window if the user cancels the Save or Save As dialog.</t>
<t tx="edream.110203163054.589">This involved changing the documentation for the Demote, Insert Headline, Extract Headline, Syntax Coloring... and Font... commands.  Removed documentation for the Open/Close Log Window command.</t>
<t tx="edream.110203163054.590"></t>
<t tx="edream.110203163054.591">leo.py version 2.4                             June 20, 2002

This version fixes some annoying bugs and adds some nice features.  The children of this node contain full details.

1. Leo now properly highlights the headline of a newly created node.  Similarly, the Edit Headline command (control-H) now works.  Double-clicking in a headline now does what you would expect: it selects the word under the cursor.  Similarly, triple-clicking now selects the entire headline.  Also fixes several other minor bugs.

2. Drag and drop.  You can now reorganize outlines by dragging nodes around.  You must drag from a node's headline and release on another node's headline.  See a child of this node for complete details.

3. You can now open .leo files in leo.py by double clicking on .leo files.  You must associate leo.py with .leo files.  See a child of this node for detailed instructions about how to do this.

4. Improves error recovery when there are errors writing .leo files.

5. Updates this file to match the documentation of Leo's web site.  At long last, Leo's documentation is complete.</t>
<t tx="edream.110203163054.592">1. Fixed a bug in app.finishCreate that caused Leo to take an exception on MacOS X.

2. Leo now properly highlights the headline of a newly created node.  Similarly, the Edit Headline command (control-H) now works properly.

3. Removed a useless assert in st_enter_root_name that could fail under unusual circumstances.</t>
<t tx="edream.110203163054.593">When writing a .leo file, say f.leo, Leo now attempts to create a backup file called f.leo.back.  If there is an error while writing f.leo, Leo will restore f.leo from f.leo.back.  Note that Leo will write derived files correctly even when there is an error writing the .leo file.</t>
<t tx="edream.110203163054.594">New in leo.py v2.4: You may drag an node (including all its descendents) from one place to another in an outline.  To start a drag, press the main (left) mouse button while the cursor is over the icon for a node.  The cursor will change to a hand icon. If you release the mouse button while the hand cursor is above the icon for another node, Leo will move the dragged node after that node.  If you release the mouse button when the hand cursor is not over an icon, Leo will print "not moved" and leave the outline pane as it is.  This can result in the dragged node not being visible on the screen, but it seems less alarming not to force the current node to become visible as that would undo any scrolling that has just been done.

New in leo.py 3.0: If you drag outside the outline pane, the outline pane will scroll automatically.

Leo scrolls the outline pane as the result of mouse-moved events, so to continue scrolling you must keep moving the mouse.  I experimented with scrolling the outline pane whenever the cursor is dragged outside it, but the results were not good.  There was a noticeable delay between releasing the cursors and halting the scrolling.  The present code is simpler and more likely to work on all platforms.

Leo only allows dragging from one icon to another.  In particular, you can't move a node to the first child of another node unless that node is already expanded.   I experimented with automatically open nodes when the cursor moves over an unexpanded node with children.  However, this was confusing and alarming.  It seems best to expand and contract nodes explicitly.</t>
<t tx="edream.110203163054.595">leo.py version 2.3                             June 5, 2002

This version fixes a minor problem with Leo.

1.  The code that reads and writes @file nodes now uses the directory containing the .leo file as a default when the Default Tangle Directory setting is empty in the Preferences panel.  This is a reasonable default because derived files are most often created in the same directory as the .leo file.  BTW, the Tangle and Untangle commands have used this convention for a long time.

Note: This default allows us to distribute LeoPy.leo without specifying a directory in the Preferences Panel.</t>
<t tx="edream.110203163054.596">leo.py version 2.2                             June 1, 2002

The version fixes two bugs that happen rarely and can cause loss of data when they do happen.

1.  In certain circumstances leo.py v2.1 would delete most of an outline when a node was moved in front of the previous root node!

2.  All previous versions of leo.py will crash when saving body text containing unicode characters.  This could occur as the result of cutting and pasting text from another application into the body pane.  Leo.py now writes body text containing unicode characters using Python's u-prefixed notation.  That is, the body text is written as: u'escaped_text'  where escaped text replaces unicode characters not in the ascii character set by escape sequences of the form \uxxxx.  The result contains nothing but ascii characters, so leo.py will have no problem reading it.  Naturally, compilers and other tools may not understand Python's notation, so you may have to convert escaped text to something that your tools can understand.

3.  This file, LeoDocs.leo, now more closely matches the documentation on Leo's web site.</t>
<t tx="edream.110203163054.597">leo.py version 2.1                             May 16, 2002

This version of Leo adds Import and Export commands and fixes several bugs:

1. All Import and Export commands now work. Several of these commands are found only in Leo.py.  Some of these commands may be of beta quality.

I use Import commands mainly for studying other people's code.  Be wary of generating source files from trees generated by the Import commands.

2. Fixed a bug that caused Leo to crash when a node was moved up in front of the previous root node.

3. Fixed several bugs in the syntax colorer.  One of these bugs caused Leo to crash when handling CWEB.

4. Leo now colors strings green.</t>
<t tx="edream.110203163054.598">I use Import commands mainly for studying other people's code.  Be wary of generating source files from trees generated by the Import commands.

The Remove Sentinels command can "clean" files for publication or walk-throughs.  You can also use the Remove Sentinels command to prepare files for comparisons.  For example, one could study a file, say f.py, as follows:

1. Use the Import Files command to create an @file tree, say @file f2.py, for study.  Changing the name to f2.py ensures that saving the .leo file won't destroy the original file.

2. Use the Remove Sentinels command to create a file f3.py.  Use a file comparison program to ensure that f1.py is identical to f3.py.</t>
<t tx="edream.110203163054.599">Fixed several bugs that caused Leo to hang when moving an outline up before the previous root node.</t>
<t tx="edream.110203163054.600">Fixed a bug that caused Leo to hang when syntax coloring noweb code with the CWEB syntax colorer.

The syntax colorizer now handles Python triple strings and C preprocessor directives properly.

Leo now colors strings with the same green used by IDLE.  I think this color looks very good.

Improved the syntax coloring for CWEB.</t>
<t tx="edream.110203163054.601">leo.py version 2.0                             March 4, 2002

leo.py v2.0 and Borland Leo v2.6 are being released simultaneously.  I urge all users of Leo to upgrade to one or both of these versions.  Note: the Untangle commands of both v2.0 and v2.6 should be considered beta quality.  Please report any problems with Untangle ASAP.

This is an important milestone in Leo's history, for several reasons:

1. For the first time, leo.py (v2.0) and the Borland Leo (v2.6) are functionally identical.  In particular, their respective Tangle commands produce identical output.

2. All "mission critical" aspects of leo.py are now complete: only the Import commands remain unfinished. leo.py v2.0 adds unlimited Undo/Redo, Untangle and full syntax coloring.  Unlimited Undo/Redo are reason enough to upgrade to v2.0.

3. leo.py v2.0 and Borland Leo v2.6 introduce an optimized format for derived files: both versions remove blank lines from between sentinel lines.  This is an upward compatible change in the format of derived files: leo.py v2.0 and Borland Leo v2.6 can read derived files from all previous versions of Leo, but previous versions of Leo can not read derived files without blanks lines between sentinels.

See the children of this node for full details.</t>
<t tx="edream.110203163054.602">leo.py v2.0 optionally can remove blanks from between sentinel lines in derived files.  This is an upward compatible change in the format of derived files: leo.py v2.0 can read derived files from all previous versions of Leo, but previous versions of Leo can not read derived files without blanks lines.

Removing blank lines requires a new kind of sentinel, the "verbatimAfterRef" sentinel.  This allows Leo to handle comments following section references that would otherwise be treated as sentinels themselves.  For example:
   
   &lt;&lt; section &gt;&gt; #+others
   
Leo removes blanks lines between sentinels by default.  To cause Leo not to remove blank lines do the following.  In the section called &lt;&lt; initialize atFile ivars &gt;&gt; in leoAtFile.py, change:

	self.suppress_newlines = true
to
	self.suppress_newlines = false

Note: leo.py v2.0 can read derived files without blank lines between sentinels regardless of the setting of self.suppress_newlines.
</t>
<t tx="edream.110203163054.603">leo.py supports unlimited Undo and Redo.  All outline operations and all typing operations may be undone and redone.  Undo state persists even after Saves.  Even the Change All command is undoable.  Only the "Read @file Nodes" command is undoable; it clears the entire undo state. This command raises a dialog to allow the user to cancel.

Think of the actions that may be Undone or Redone as a string of beads.  A "bead pointer" points to the present bead.  Performing an operation creates a new bead after the present bead and removes all following beads.  Undoing an operation moves the bead pointer backwards; redoing an operation moves the bead pointer forwards.  The Undo command is disabled when the bead pointer moves in front of the first bead; the Redo command is disabled when the bead pointer points to the last bead.

</t>
<t tx="edream.110203163054.604"></t>
<t tx="edream.110203163054.605">leo.py syntax colors all languages mentioned in the Preferences Panel.</t>
<t tx="edream.110203163054.606">1. Show Invisibles command works in @nocolor mode.

2. @unit, @root, @nocolor and @color now terminate doc parts.

3. Three characters were colored blue at the start of a section def in:

  &lt;&lt;name&gt;&gt;=
  
This didn't show up if there is a space after the &lt;&lt;.</t>
<t tx="edream.110203163054.607">Leo adds extra space at the end of headlines so that headlines now have enough room to show all text.  This works around an apparent Tk bug.</t>
<t tx="edream.110203163054.608"></t>
<t tx="edream.110203163054.609">The Untangle command is beta quality. Please make backups before untangling.</t>
<t tx="edream.110203163054.610">leo.py v2.0 fixes two bugs present in Borland v2.5 and fixed in Borland v2.6:

1. Untangle did not work properly for languages like Perl and Python that do not have block comments. 

2. Untangle did not recognize @ on a line by itself as the start of a doc part.</t>
<t tx="edream.110203163054.611">@c now works the same as @code.  This makes the syntax colorers agree with what the Tangle commands actually do.  Previously, the syntax colorers indicated that everything following an @c was code, while the Tangle commands placed everything following an @c in the doc part!</t>
<t tx="edream.110203163054.612">Previous versions of untangle silently trimmed trailing lines from all nodes, which seems rude.</t>
<t tx="edream.110203163054.613">The font size for code text is now 12 on Linux.

Changed code so that the path to the Icons folder is computed correctly on all platforms.</t>
<t tx="edream.110203163054.614">leo.py version 1.0                             February 10, 2002

Version 1.0 adds many new features and fixes several bugs.  I recommend that all users of leo.py upgrade to this version.  This version deserves the number 1.0; it has no known bugs.

Here are the highlights of this release.  See the children of this node for details.

1. Fixed bugs: the Tangle All and Tangle Marked commands didn't work at all. Fixed several bugs in the Find and Change commands.  The "Suboutline Only" option now applies to the Search All and Change All commands.  Settings in the Preferences Panel now "stick" properly to the currently selected window.  Fixed many minor bugs.

2. leo.py now re-marks @file trees as dirty if errors are found while writing those trees.  This makes it difficult to write derived files that will be out-of-synch when read again.

3. New commands and features:  Added the Revert, Select All, Delete, Sort Children, Sort Siblings, Contract Parent (very useful!) and Toggle Active Pane commands, and all commands in the Edit Body menu, and all the Go To commands in the Move/Select menu. The Show Invisibles commands is ugly, and useful nonetheless.

The Edit Body commands work much more reliably than the similar commands in the Borland version of Leo.  You may now specify Python scripts rather than .bat files in the Preferences panel. Added a way, albeit clumsy, to cut and paste nodes between Borland Leo and leo.py.  When syntax coloring Python text, leo.py increments the auto-indentation by one tab after a trailing colon.  This provides a subtle reminder to add such colons.

4. leo.py handles events and shortcuts properly.  The shortcut for the Insert Node command is now Control-I, as it is in the Borland version of Leo.  Worked around a TK bug that prevented double-clicks from properly selecting words.  leo.py enables and disables all menu items properly.</t>
<t tx="edream.110203163054.615">Removed the Print and Page setup commands because Tk provides no support for printing.  This is not significant: we can use the export commands to create text files.  These text files can then be formatted and printed as desired.

The following commands remain unfinished.  They will be finished in this order:

1. Untangle commands. 
	
2. Import/Export commands.

3. Unlimited Undo and Redo.

4. Toggle Split Direction, Cascade and Recent Windows commands.

5. Font Panel and Syntax Coloring commands.</t>
<t tx="edream.110203163054.616">It should be possible to cut a node or tree in Borland Leo and paste it using the Copy Node command in leo.py.  At present, cutting and pasting trees between applications can only be done indirectly.  Do this:

1. Copy the tree in Borland Leo using the Copy Node or Cut Node command.
2. Paste the tree into empty body text of leo.py using the Paste command from the Edit menu, _not_ the Paste Node command from the Outline menu.
3. Select all the body text and choose Copy or Cut from the Edit menu.
4. Move to the tree view, and choose Paste Node.

I hope to make this unpleasantness go away soon.</t>
<t tx="edream.110203163054.617">1. Fixed the Tangle All and Tangle Marked commands.  They always crashed.

2. The Change command did not work in headlines because of a reversion in how headline text is selected.

3. All event handlers now return "break".  This prevents further event handling and allows leo.py to handle events properly.  This cleared up the last major mystery in leo.py.

4. Settings in the Prefs Panel now "stick" to windows.  That is, they change when the user selects a new Leo window.  In particular, the Default Tangle Directory is restored properly.  This is important, as otherwise the Tangle commands might write files to the wrong place.

5. Removed calls to trace during shutdown.  In general, it is not possible to call app() during shutdown because the app object may no longer exist.

6. @others was not syntax colored properly if it was indented.</t>
<t tx="edream.110203163054.618">1. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this bug because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.

2. Cutting and pasting between applications can only be done indirectly.  See the node called
"How to copy an outline from Borland Leo to Leo.py".</t>
<t tx="edream.110203163054.619">leo.py version 0.08                             February 3, 2002

Version 0.08 adds important new features and fixes several bugs.  All users of version 0.07 should upgrade to this version.  This code seems solid, and significant bugs may remain.  Note: this code has been tested only on Windows XP.  Please report any problems with Linux or Macintosh.

This is the first version of Leo to feel as smooth as the Borland v2.5. leo.py is now less buggy than v2.5; the Borland version will soon be upgraded to match leo.py.

Here is a summary of new features.  See the children of this node for full details.

1. The Find and Change commands are fully functional.  These commands support Tk's "advanced regular expressions" when the "pattern match" option is checked.  Tk's regular expressions are documented at:

  http://tcl.activestate.com/man/tcl8.4/TclCmd/regexp.htm

2. The Tangle commands work; leo.py now supports @root trees.  The next release will support the Untangle commands.  Converting the Untangle code to Python is almost complete.

3. Leo now ensures that the currently selected headline is always visible, scrolling the outline pane as needed.

4. Improved Leo's memory management and eliminated several serious bugs.  One bug caused errors while reading @file trees.  Eliminating this is a huge step forward.  This bug exists in the Borland version of Leo and will be fixed soon.

5. Leo now underlines undefined section references.  Added support for hyperlinking, but disabled hyperlinking because it is not very useful without browser navigation buttons.</t>
<t tx="edream.110203163054.620">leo.py handles Find and Change commands much more smoothly than does the Borland version of Leo.  Indeed, I plan to rewrite the Borland code to match the code in leo.py.

In general, leo.py handles the Find and Change commands more smoothly than does the Borland version of Leo.  Note: the node that "anchors" wrapped searches is the current node when any change is made to the Find panel.  The anchor is recomputed after a wrapped search fails.

Changed the meaning of a Find panel setting from "batch" to "context".  This will be changed in a future Borland version.  In the meantime, setting the "context" option in leo.py will set the "batch" option in the Borland version.

The "context" option affects only the "Find All" and "Change All" commands.  When this option is in effect, more context information is printed when matches are found.

The "reverse" option affects all Searches and Changes, both those initiated from the Find Panel itself, and those initiated from menu commands.  In particular, F3 will find the previous search if the "reverse" option is in effect.</t>
<t tx="edream.110203163054.621">The Tangle command has passed significant tests, and bugs may remain.  Be warned.

leo.py's Tangle command produces output that is slightly different from Leo v2.5. The differences are insignificant; here is the complete list:

1. The header line, i.e., the first comment line of the tangled file: leo.py produces forward slashes in the path name, Leo v2.5 produces back slashes.

2. Leading whitespace: leo.py produces "optimized" leading whitespace.  leo.py removes blanks if they do not affect the visual appearance of whitespace; this depends on the tab width specified in the Preferences Panel.  Leo v2.5 copies leading whitespace exactly.  The leo.py way is preferable; it will produce output acceptable to Python's tabnanny regardless of tab width used while running Python.

3. Trailing blanks lines in body text: leo.py removes all trailing whitespace.  Leo v2.5 does not.  Conceivably, leo.py might have to change to make the Untangle command work properly.  More likely the leo.py way is just better.</t>
<t tx="edream.110203163054.622">Underlining "live" links clutters the screen too much, and hyperlinks from section references to section definitions isn't very useful without the standard "back" and "forward" buttons typically found in web browsers.  For these reasons, I have disabled hyperlinking.

To enable hyperlinking, just set:

	self.use_hyperlinks = true
	
in color.__init__ in the @file leoColor.py tree.</t>
<t tx="edream.110203163054.623">1. Fixed several bugs involving cloned headlines.  One bug caused cloned headlines not to be updated in synch.  Another bug caused @file trees not to be marked as dirty under certain conditions.

Both bugs could have caused read errors while reading @file trees, so fixing these bugs is a big step forward.  I have experienced no read errors since fixing these bugs.  A huge step forward.  This bug exists in the Borland versions of Leo and should be fixed ASAP.

2. There was a big performance bug lurking in the tree code that became apparent during testing of the Find and Change commands.  Closing a window could take almost a minute if the tree had been redrawn many times.  Old widgets were never deleted until the window was closed.  This may be a problem with tkinter, and the workaround was straightforward.

3. Fixed a bug in the "Save To" command.  After doing a Save To, a following Save command used the Save To file name!  This explains why some saves "didn't take".

4. Fixed a bug in the Save commands.  Cancelling a Save dialog did not work: instead it wrote a file called ".leo".  I am not sure whether this bug occurred in previous releases. 

5. All Save commands now always recompute file indices.  This old logic accomplished very little, and introduced needless differences between the various kinds of Save commands.

6. Made file and path name processing more portable.  Removed all calls to os.chdir().

7. Fixed a bug that caused a control-d to delete a character in the body pane when the Move Down command didn't do anything, i.e., when the presently selected node was the bottom node on the screen.</t>
<t tx="edream.110203163054.624">1. Used Tk.Text widgets in headlines rather than Tk.Entry widgets.  This allows the Find/Change commands to search headlines.  Control-k no longer deletes text following the cursor in headlines.

2. Improved the performance of screen updates and markedly reduced flicker in the body pane.

3. Found a way to handle keystrokes without knowing the status of the control and alt keys.  The idle event handlers now ignore the actual keystrokes in most cases, and take action solely based on whether the headline or body text has actually changed as the result of those keystrokes.  If not, we can assume that a command has been entered and we do not set the dirty or changed bits.

4. Replaced es_newline global with app().log.es_newline, i.e., frame.es_newline.  This is better than before because each log stream now has its own newline count.

5. Reduced width of the log pane to give more space to the tree pane.

6. The LeoPy folder now contains a dummy file called __init__.py.  This file marks the LeoPy folder as a potential package.

7. Added several new functions to the file leo.py.  These are useful for invoking leo.py from a Python interpreter.  See the section "How to Install &amp; Run Leo" for details.</t>
<t tx="edream.110203163054.625">Previous version of leo.py did not release memory when windows close.  This version does.

Memory management is remarkably easy in Python/Tk.  Added __del__ routines and corresponding destroy routines to the frame, vnode and tree classes.  The destroy routines eliminate circular references between objects. The __del__ routines do nothing except print debugging traces; we know that all references to an object have been removed when its __del__ routine is called.

Added app.deleteOnClose ivar to control memory management.  When true, Leo deletes all frame objects when a frame closes.  This is always true at present.

Fixed a memory botch: previously a dummy vnode was allocated for every vnode created while reading files.</t>
<t tx="edream.110203163054.626">Starting with this release, you will see trace statements throughout the code.  The trace function is defined in leoUtils.py; trace implements much of the functionality of my Sherlock tracing package.  Traces are more convenient than print statements for two reasons: 1) you don't need explicit trace names and 2) you can disable them without recompiling.

In the following examples, suppose that the call to trace appears in function f.

trace(string) prints string if tracing for f has been enabled.  For example, the following statement prints from s[i] to the end of the line if tracing for f has been enabled.

	j = skip_line(s,i) ; trace(s[i:j])

trace(function) executes the function if tracing for f has been enabled.  For example,

	trace(self.f2)

You enable and disable tracing by calling init_trace(args).  Examples:

	init_trace("+*")         # enable all traces
	init_trace("+a","+b")    # enable traces for a and b
	init_trace(("+a","+b"))  # enable traces for a and b
	init_trace("-a")         # disable tracing for a
	traces = init_trace("?") # return the list of enabled traces

If two arguments are supplied to trace, the first argument is the "tracepoint name" and the second argument is the "tracepoint action" as shown in the examples above.  If tracing for the tracepoint name is enabled, the tracepoint action is printed (if it is a string) or executed (if it is a function name).

"*" will not match an explicit tracepoint name that starts with a minus sign.  For example,

	trace("-nocolor", self.disable_color)</t>
<t tx="edream.110203163054.627">Rewrote the code that computes file names.  This should have two beneficial effects:

Note:  This code has only been tested on Windows XP.

1. The code should be more portable.  I've used os.path.join throughout to concatenate parts of filenames, and this should handle differences involving path separators on different platforms.

2. The code no longer calls os.chdir().  The "current application directory" changes only as the result of completing file open and save dialogs.  In particular, @path, @root and @file do not change the current application directory.

3. Used leo.__file__ to get the directory from which leo.py was loaded.  This seems to be reliable, though it has only been tested on Windows XP.</t>
<t tx="edream.110203163054.628">The following features of leo.py will be incorporated into the Borland version 2.6 of Leo:

1. Improve leading whitespace handling in Tangle.

2. Fix clone bugs (rewrite vnode::setDirty).  These bugs can cause errors while reading @file nodes.

3. Improve Find/Change commands. Change "batch" to "context".  This will make the Preferences Panel work identically in both programs.

4. Always recompute file indices and compute file indices.  This will make derived files produced by v2.6 identical to the files produced by leo.py.

5. Make sure all file names end in .leo.</t>
<t tx="edream.110203163054.629">I urge anyone using leo.py upgrade to this version.  This is the first version of leo.py that has been thoroughly tested.

See the children of this node details about this release.  Here are the highlights:

1. Fixed many bugs, including a bug that can cause body text to be lost when creating a new headline.

2. The Python window now works. You can now run Python scripts from within leo.py!

3. Added a script to convert Leo files from Leo 1 to Leo 2 format.

4. @nocolor and @color are now inherited properly from ancestor nodes.

5. Added Leo Documentation to Help menu.  This command opens LeoDocs.leo.
	
6. Added auto indent to body pane.

For even more details, see the diary entries for January 6-9 in LeoPy.leo.

See the To Do lists in LeoPy.leo for a list of unfinished features.  The primary unfinished features are the Find/Change commands, preferences settings and the Tangle/Untangle commands.</t>
<t tx="edream.110203163054.630">This is the first version of leo.py that has been heavily tested.  About 70 percent of my work on leo.py has been done using leo.py itself.   I know of no remaining bugs that can cause data to be lost.</t>
<t tx="edream.110203163054.631">I have concentrated on removing all significant irritations encountered while using leo.py.  Far fewer still remain than before.  Among the remaining irritations:

1. Syntax coloring happens at "idle time", that is, after all events have been handled.  This means that characters are initially colored black, then changed to another couple after an obvious delay.  The obvious event-handling code does not work.  Perhaps using a "virtual event" may work.

2. Keystrokes that should initiate commands _also_ get passed to widgets.  I am hoping to find a way around this, and it may take a bit of work.  The two biggest offender:  Control-k while editing a headline deletes from the cursor to the end of the headline (in addition to creating a new node!)  Control-i gets passed to the body pane as a tab.

3. The border around the tree pane gets over-written by headlines.  I'm not sure how to fix this: it is certainly a Tk bug.</t>
<t tx="edream.110203163054.632">Fixed a bug that can cause body text to be lost when creating a new node.</t>
<t tx="edream.110203163054.633">Choosing Open Python Window brings up IDLE, the standard Python IDE, from which scripts may be run and debugged.

Note: The path to idle.py must exist in sys.paths.  For Python2.1 on windows, this path will typically be \Python21\Tools\idle  If this path does not exist, a message will be sent to the log pane.  The usual way to add a path to sys.paths is to modify the sitecustomize.py file.

Changed names of several vnode and commands methods to make them compatible with the scripting documentation on Leo's web site.   You may now run any script that runs on Borland Leo on leo.py.

When running scripts from leo.py, you may refer to any method or instance variable (attribute) in the code for leo.py.  If you want to run those scripts on Borland Leo you should restrict yourself to the methods documented in the Scripting chapter of Leo's online documentation.</t>
<t tx="edream.110203163054.634">To convert an @root tree to an @file tree, choose the root of the tree to be converted, then do the following in the Python window:

	import c2py
	c2py.leo1to2()
	
This script makes numerous changes throughout the tree.  It does not, however, change @root to @file, or insert the needed @others directives.  You must do that by hand.</t>
<t tx="edream.110203163054.635">At long last it is possible to open this file, LeoDocs.leo, from the help menu.

This command will work only if LeoDocs.leo is located in the directory in which leo.py exists.</t>
<t tx="edream.110203163054.636">The body pane now has auto-indent on at all times.</t>
<t tx="edream.110203163054.637">leo.py version 0.06 (alpha)                     December 20, 2001

This version fixes several minor problems that prevented leo.py from running on Linux.  There is no need to upgrade to this version if leo.py works on your system.  This version is neither more nor less stable than version 0.05.  This file, LeoDocs.leo, has also been improved substantially.

There still may be problems running leo.py on Linux.  You may be able to fix those problems yourself after reading this file... I'll be on vacation until about January 8.  I may be able to answer questions on Leo's SourceForge site, and I'll make no code changes until then.

Problems fixed:

1.  Removed call to print_stack() in es() logic.  If there are problems during initialization this logic printed "Null log" and then printed a stack dump.  This dump was more confusing than helpful.

2.  Changed "darkblue" to "DarkBlue".  The standard colors known to Tk are listed at
	http://tcl.activestate.com/man/tcl8.4/TkCmd/colors.htm
	
If you have more problems with unknown colors, please use a color listed above.

3.  Eliminated some accelerators (Linux only).  You may take an exception in createAccelerators() in leoFrame.py if Linux does not support the accelerators defined in one of the following sections:

  &lt;&lt; control key bindings &gt;&gt;
  &lt;&lt; alt key bindings &gt;&gt;
  
Just comment out the relevant entry.  Please let me know which accelerators don't work.  I can add platform-specific code to deal with them.

4.  Added loaddir code to leo.py.  Leo tries to guess where leo.py was loaded from.  If this doesn't work leo may take an exception in leo.py.

As a temporary hack, please set loaddir correctly in the following code at the start of leo.py:

  # loaddir should be the directory that contains leo.py
  if sys.platform=="win32":
    loaddir = "c:\\prog\\LeoPy\\"
  else:
    loaddir = "LeoPy"
	
5. Removed bullet 0x95 characters from this file. They don't show up well on Linux.

6. In leoTree.py, changed the filenames from x.gif to x.GIF.  Linux is more picky about case in filenames than Windows.

Edward K. Ream
December 20, 2001</t>
<t tx="edream.110203163054.638">leo.py version 0.05 (alpha)                      December 17, 2001

This version of Leo marks a major milestone in Leo's history.  leo.py is the first functional version of Leo written completely in Python and Tkinter, Python's interface to the tcl/Tk system.

leo.py is quite useable. leo.py should work on any machine with recent Python and tcl/Tk interpreters.  This version of Leo was created using Windows XP, Python 2.1 and tcl/Tk 8.3.

Warning: This version is alpha quality.  Use extreme caution: please save your work often and make full backups of all .leo files and derived files.

Please read this node's children before sending bug reports or feature requests.  Send all bug reports to Leo's SourceForge web site at: http://sourceforge.net/projects/leo/

Edward K. Ream</t>
<t tx="edream.110203163054.639">I have been happily using leo.py to develop itself for the last three days without serious problems.  leo.py reads and writes all its source files exactly as does the Borland version.  This is an important test, and significant errors may remain.

Performance on a 1.2 Ghz Pentium is good to excellent.  Drawing the screen happens quickly, smoothly and without flicker.  Expanding and contracting nodes is usually excellent, and slows when a many nodes have been expanded.  Syntax coloring appears instantaneous, even with an unsophisticated algorithm.  Loading LeoPy.leo files takes about 3 seconds. This could be improved by using Python's XML classes.</t>
<t tx="edream.110203163054.640">You must have recent versions of Python and tcl/Tk installed on your machine.
Download Python from http://python.org/
Download tcl/Tk from http://tcl.activestate.com/software/tcltk/

After installing Python and Tk, run Leo double clicking the file leo.py in the LeoPy folder.  On Windows this will bring up a Leo window and a black Python interpreter window.

The LeoPy folder contains all files in this distribution.  leo.py is the main source file; run Leo by double clicking leo.py.  The Python interpreter will create corresponding .pyc files as .py files are imported by leo.py.

LeoPy.leo is the master source code file; all .py files were derived from LeoPy.leo.  c2py.py and leoCompare.py are tools that should be run from a Python interpreter.
</t>
<t tx="edream.110203163054.641"></t>
<t tx="edream.110203163054.642">Functional Commands and Features

    Open, Save, Save As, Save To commands.
    Read @file Nodes command.
    Read Outline Only command.
    Write Outline Only command. Warning: this has not been tested thoroughly.
    Insert Node, Delete Node and Clone commands.
    Move Node Right/Left/Up/Down commands.
    Cut Node, Copy Node, Paste Node commands.
    Syntax coloring for Python only.
    The @color and @nocolor directives, but these are not inherited yet.</t>
<t tx="edream.110203163054.643">Unfinished Commands and Features:

	Revert.
	All Tangle and Untangle commands.
	All Import commands.
	All Find and Change commands.
	Sort Children command.
	Toggle Split Direction, Toggle Active Pane and Cascade commands.
	Auto indent in the body pane.
	The Preferences panel is semi-functional: see note one below.
	The Find panel is non-functional.
	The Python scripting window is non-functional.
	Syntax Coloring Options and Font Options windows are not ready yet.
	@color and @nocolor directives are not inherited yet.

Notes:

1. The Preferences panel is partly functional.  The default target language option has no effect: syntax coloring is for Python only.  Tab width can not be changed; tabs are 8 characters wide.

2. Menu items are not yet dynamically dimmed and undimmed.  Some non-functional commands have undimmed menus.  Keyboard accelerators work even for dimmed menus.

3. Scripting Leo is not possible yet.  You can't control Leo from the Python interpreter because control passes to the Tk event loop.

4. Leo's Save commands do not yet save the information about which node was visible at the top of the tree.

5. The Save/SaveAs/SaveTo dialogs don't handle shortcuts to folders properly; they try to replace the shortcut with the .leo file.

6. Initialization code in leo.py computes the directory from which Leo was loaded using argv[0].  I am not sure this is proper, though I have had no problems recently.  Tree icons will not load properly if argv[0] does not specify this directory.  If the path is invalid Leo will print: os.chdir failed: `dir`

7. The tree class does not automatically ensure that the current node is visible after an outline operation.

8. The font used in the body pane is not great.  I hope to improve it.

9. Headline text is sometimes obscured.
</t>
<t tx="edream.110203163054.644">leo.py already feels less buggy than the wxWindows versions of Leo.  Rewriting Leo in Python and Tkinter has greatly improved the code. Further improvements are possible.  BTW, work began in earnest on this version of Leo in late October, 2001.  It's been a great month.

The following problems have resisted my initial attempts at solving them.  Any help from Tk experts would be appreciated:

1. Window icons are the Tk icon, not the nifty Leo icon.  Really, there _must_ be a way to do this!

2. Can variable-width tabs can be done in Tk?  If not, Leo may have to convert tabs to blanks as specified by the preferences panel.

3. Cut, copy and paste work in the log and body panes using Control-X, Control-C and Control-V keys.  However, there are no Cut, Copy or Paste menu items in the Edit menu.  Is it possible to send simulated keystrokes to a text widget?

4. Some menu accelerators do not seem to be available in Tk.  In particular, many of the items in the submenus of the Outline menu have no accelerators yet.  These commands are useful only if they can be chosen from the keyboard rather than the menu.

5. The border of the tree control is gray.  It can be overwritten by large headlines.  This appears to be a Tk or Tkinter bug; I haven't found any way to eliminate the border or color it white.

6. There doesn't seem to be a way to select all the headline text when editing starts.  The click that starts editing always clears the selection.

7. Changing the type of leo.py to .pyw doesn't seem to work.

8. A message flash briefly on the screen when leo.py exits, too fast to read. These messages do not appear when invoking leo.py from the Python interpreter.  They probably would be visible in a Linux window.</t>
<t tx="edream.110203163054.645">It will be much easier to make such improvements to leo.py than to previous versions of Leo. Here is my list of new things to do:

1. Create "hyperlinks" from section references to section definitions.  This will happen in the next release.

2. Add automatic "tab nanny" checking and full syntax checking of Python body text.

3. Build a file/directory comparison window using code in leoCompare.py.

4. Build a Python debugger into Leo.  Python provides excellent hooks for debugging and tracing.  Python's stand-alone IDLE debugger doesn't seem to work well with the Tk command loop.

5. Expand Leo's file format to take advantage of the power of Tk text widgets.
</t>
<t tx="edream.110203163054.646"></t>
<t tx="edream.110203163054.647">Leo Borland version 2.6                             May 15, 2002

This version fixes a bug that can cause errors while reading derived files.  Earlier versions do not ensure that clone indices in derived files are distinct.

I recommend that all users of the Windows version of Leo upgrade to this version.</t>
<t tx="edream.110203163054.648">Leo Borland version 2.6                             March 4, 2002

leo.py v2.0 and Borland Leo v2.6 are being released simultaneously.  I urge all users of Leo to upgrade to one or both of these versions.  This is an important milestone in Leo's history,  For the first time, leo.py (v2.0) and the Borland Leo (v2.6) are functionally identical.  In particular, their respective Tangle commands produce identical output.

Borland version 2.6 fixes major problems and contains numerous changes to make it fully compatible with leo.py v2.0.  Highlights of Borland v2.6:

1. Fixes bugs that caused spurious errors while reading @file trees.  Such errors can destroy clone links.

2. Supports an improved format for derived files.  This format is used by leo.py 2.0.  This is an upward compatible change: previous versions of Leo can not read the new format, and this version of Leo can read all previous derived files.

3. Fixes two long-standing bugs in the Untangle command.

4. As mentioned above, the Tangle commands are byte-for-byte compatible with leo.py v2.0.  Also, @c is now equivalent to @code.

5. Adds two very useful commands: Sort Siblings and Contract Parent.

See the Children of this node for full details.</t>
<t tx="edream.110203163054.649">This version of Leo removes blanks from between sentinel lines in derived files.  This version of Leo is fully compatible with leo.py v2.0 in this regard.

This is an upward compatible change in the format of derived files: Borland Leo v2.6 can read derived files from all previous versions of Leo, but previous versions of Leo can not read derived files without blanks lines.

Removing blank lines requires a new kind of sentinel, the "verbatimAfterRef" sentinel.  This allows Leo to handle comments following section references that would otherwise be treated as sentinels themselves.  For example:
   
   &lt;&lt; section &gt;&gt; #+others</t>
<t tx="edream.110203163054.650">Whenever a node changes, Leo now ensures that all nodes cloned to it, and all ancestor @file nodes are marked dirty.  This is the cause of spurious read errors.

As a side effect, nodes now become dirty when they move.

This change was made in leo.py v0.8.

It is also vital that @file nodes remain dirty until they are written without errors.  Otherwise, a Save command will succeed without warning, and a later read may cause the dreaded "clones have been cleared" message.

This change was made in leo.py v1.0.</t>
<t tx="edream.110203163054.651">@c now works the same as @code.  This makes the syntax colorers agree with what the Tangle commands actually do.  Previously, the syntax colorers indicated that everything following an @c was code, while the Tangle commands placed everything following an @c in the doc part!</t>
<t tx="edream.110203163054.652">This version fixes two long-standing bugs:

1. Untangle did not work properly for languages like Perl and Python that do not have block comments. 

2. Untangle did not recognize @ on a line by itself as the start of a doc part.</t>
<t tx="edream.110203163054.653">The Tangle commands are now byte-for-byte compatible with leo.py 2.0.  Tangle outputs "optimized" leading whitespace just as leo.py does.  This can be important in Python programs.

All the Save commands now recompute clone indices just as in leo.py 2.0.</t>
<t tx="edream.110203163054.654">The "Show Context" checkbox in the Find Panel is presently non-functional.  (In leo.py it affects the messages produced by the Find All and Change All commands.)</t>
<t tx="edream.110203163054.655">Unlike leo.py, the Borland version of Leo can not ensure that saved outlines have .leo extensions.

There are two problems:

1.  The ensureExtension routine is called after the dialog closes.  If this routine changes the file name we could overwrite an existing file!

2.  There appears to be problems with the Borland DefaultExt field.  Setting this field causes crashes.</t>
<t tx="edream.110203163054.656">This version fixes several serious bugs.  All users of Leo2 should upgrade to version 2.5 immediately.

1. Eliminated the ill-fated automatic updating feature.  This turns out to be very dangerous and disconcerting.  If one makes changes to the .leo file and does not save those changes, a later update could erase those unsaved changes!

2. Removing automatic updating also fixed another bug:  The current outline node was not being selected properly when a .leo file was read, so that in some cases the body text did not correspond to the selected outline node.  This never caused loss of data, and was disconcerting.

3. Fixed a bug that caused Find/Change settings to be saved to a file only if a find or change command was actually executed.

4. Restored several parts of Leo2(cb).leo that were inadvertently erased due to earlier bugs.  In particular, the outlines for xbuf.c and xbuf.h have now been restored.

One bug remains.  On Windows XP, the cursor is obscured in the Find/Change dialog when it is at the far left of the Find or Change text areas.  This may be a botch in the XP text control itself.  The solution would be to create a border in the text areas, and there is no obvious way to do this using the Borland classes.</t>
<t tx="edream.110203163054.657">Version 2.4 is a major improvement in Leo2.  I urge all users of Leo2 to upgrade to this version.  See the children of this node for full details.

The "old" Leo2 tried to save space by not writing all information in @file trees.  This was a serious mistake.  The "new" Leo2 saves all information in an outline to the .leo file, including all information in @file trees.
Once again you may back up a project merely by backing up the project's .leo file.  There is no Archive command, and no need for one.  All .leo files are now safe archives.

As the result of the change in file formats, Leo 2.4 may clear clone links when loading derived files created with previous versions of Leo.  Leo 2.4 will issue detailed messages when that happens.

The new Leo2 is much safer and more convenient to use than the old Leo2.  Error messages and error recovery have been improved.

Leo2 updates @file trees automatically when Leo2 is activated.  For example, suppose you change a derived file in another editor, say in an IDE.  Leo2 will update the @file tree when you switch to Leo, provided that you have saved the file in the IDE.  Warning: due to several apparent bugs in the Delphi code, this feature only works if the main Leo window is at least partially visible on the screen (!)
</t>
<t tx="edream.110203163054.658">Version 2.4 fixes several bugs involving clones.

1. Version 2.4 rewrites clone indices when writing derived filed, so node sentinels accurately reflect the clone status of the node.  The node sentinel for the root node no longer contains the maximum clone index.  Leo2 clears the root's clone index on reading and writing so that the root node is not mistakenly joined so another node!

2. Version 2.4 takes more care to recreate clone links properly when reading derived files.  A derived file can be read into a .leo file different from the .leo that wrote the derived file, so Leo2 makes sure that clone links are proper in the .leo file being opened.  A minor drawback: .leo files now are "big", so reading them is a little slower.

Note: Clone links into @file trees work only if the .leo file is "in synch" with the files derived from the @file trees.  Clone links will break if the .leo file and derived files are not in synch.  Typically "backup" .leo files will be out-of-synch with present derived files, so it's best to use "backup" .leo files only in emergencies, for example to revert a project to a previous state.</t>
<t tx="edream.110203163054.659">The "old" Leo2 tried to save space by not writing all information in @file trees.  This was a serious mistake.  The "new" Leo2 saves all information in an outline to the .leo file, including all information in @file trees.  It is once again possible to back up a project merely by backing up the project's .leo file.</t>
<t tx="edream.110203163054.660">The archive command was a backup disaster waiting to happen.  It has been replaced by the following four file commands are located in the File:Read/Write submenu.

Read Outline Only: reads an outline using only the .leo file, not any files derived from @file nodes.  This command is useful for reverting a project to a previously saved state.

Read @file Nodes: updates all @file nodes in an outline.  This ensures that the state of an outline matches all files derived from @file nodes.  Included for completeness.  This happens automatically when a .leo file is first read, and it also happens automatically when Leo2 is reactivated.

Write Outline Only: saves an outline without writing any @file trees.  Useful for inserting an @file node into an outline without modifying a derived file with the same name.

Write @file Nodes: forces an update of all @file trees.  Surprisingly useful.</t>
<t tx="edream.110203163054.661">Leo2 updates @file trees automatically when Leo2 is activated.  For example, suppose you change a derived file in another editor, say in an IDE.  Leo2 will update the @file tree when you switch to Leo, provided that you have saved the file in the IDE.

Warning: due to several apparent bugs in the Delphi code, this feature only works if the main Leo window is at least partially visible on the screen (!)</t>
<t tx="edream.110203163054.662">Revised for version 2.4

Loading and saving .leo files usually keeps the .leo file and derived files "in synch".  However, if you create backup .leo files, it can easily happen that the structure of @file nodes in the backup .leo files no longer matches that structure in the derive files.  Leo2 will detect this condition the next time you next open the old .leo file.  When that happens, Leo2 discards the entire out-of-synch @file tree, and recreates it solely using the derived file.  In the process all marks and clone links from outside the file are lost. Leo2 issues the messages:

	Error reading @file &lt;filename&gt;
	-- Rereading file.  Clone links into this file will be lost.

to remind you that the .leo file you are using is out-of-date.  Saving the .leo file will bring it up to date.

If one or more sentinel lines in a derived file have been corrupted in some way, by inserting, deleting, altering or moving a sentinel, Leo issues these messages:

	Error reading @file &lt;filename&gt;
	&lt;An error message about a bad sentinel&gt;
	-- Rereading file.  Clone links into this file will be lost.
	&lt;An error message about a bad sentinel&gt; (again)
	----- File may have damaged sentinels!

Data may not actually be lost, and the outline structure will be seriously damaged.  The most sensible thing to do is to restore the derived file from a .leo file using the Read Outline Only command.

No error recovery is attempted when automatically updating @file trees.  If an error is found the update is canceled (leaving the outline unchanged) and the following message is given:

    -- Update canceled due to structure errors
	
We don't attempt error recovery because error recovery would clear clone links.  For example, suppose we are editing a .leo file, and for some reason we also edit a derived file _without_ saving the .leo file.  Now the files could be out of synch!  So it is best not to press on with an automatic update.
	</t>
<t tx="edream.110203163054.663">Revised for version 2.4

If Leo2 detects orphan or ignored nodes while writing an @file node it saves all information in the @file tree in the outline (.leo) file.  No information is lost.  When the .leo file is read again Leo2 will load the information in the @file tree from the .leo file, not the derived file.

As a reminder, Leo2 marks the erroneous @file node as dirty so that saving the .leo file will attempt to rewrite the @file node.  Version 2.4 no longer marks the @file node as "stuck on dirty".  If you save the .leo file the dirty mark will be cleared.  However, the @file node will be dirty every time the file is read until all errors are corrected.
</t>
<t tx="edream.110203163054.664">@file trees are less flexible than @root trees:

1.  You can not use section definitions in more than one file.  For example, you can't define declarations in one file to be used in another file.  If you need all the features of noweb you must use @root trees.

2. @file trees use no escape conventions whatever.  A code part in an @file tree contains a section reference if &lt;&lt; precedes &gt;&gt; on the line, regardless of whether &lt;&lt; or &gt;&gt; are contained in strings or comments.  In practice, such "false references" occur infrequently, and the workaround is simply to split the offending line.  Moreover, noweb's escape conventions (@&lt;&lt; and @&gt;&gt;) cause problems in @root trees, so this "drawback" is very minor.

3. Clone links into @file trees work only if the .leo file is "in synch" with the files derived from the @file trees.  In particular, backup .leo files will usually be out of synch with derived files.  Clone links will break otherwise.  To recover from such errors, simply use the "Read Outline Only" command.</t>
<t tx="edream.110203163054.665">Note: 10/19/01: I recommend that all users upgrade to version 2.4.  There are some serious problems with version 2.3.

This version of Leo contains some significant improvements.  See the children of this node for details:

1. The new @first directive allows you to place lines at the very start of files derived from @file nodes. For example, @first #!/usr/bin/env python

2. The log window is now part of the Leo window.  Very handy.

3. Fixed several bugs involving the Find command.

4. A new Archive command saves an entire outline (including all @file trees) to a .leo file.  Use this command with caution.  Loading and then saving a .leo file created with the Archive command will revert an entire project to the state it had when the archived .leo file was created.</t>
<t tx="edream.110203163054.666">The @first directive allows you to place lines at the very start of files derived from @file nodes. For example, the body text of @file spam.py might be:

@first #! /usr/bin/env python

The body text of @file foo.perl might be:

@first #/usr/bin/perl

@first directives are recognized only at the start of the body text of @file nodes.  No text may precede @first directives.  More than one @first directive may exist, like this:

@first #! /usr/bin/env python
@first # more comments.</t>
<t tx="edream.110203163054.667">The Archive command writes all nodes of an outline to a .leo file, including all parts of @file trees.  All @file trees are marked in such a way that when the archived .leo file is read 1) all @file trees will be restored from the archived outline rather from derived files and 2) all @file trees will be marked dirty so that when the archived .leo file is written all @file nodes will be updated.

Use the Archive command (and the files written by it) with caution: loading and then saving an archived .leo file will back up an entire project to its state when the archive was originally written!</t>
<t tx="edream.110203163054.668">Added support for @c in syntax colorers for Python, Pascal, Perl, Java and HTML.</t>
<t tx="edream.110203163054.669">Fixed a bug in the Change, Then Find command.  The Change, Then Find command would rescan the newly changed text if the "change text" contained the "find text" preceded by other text of length greater or equal to the length of the original "find text".

For example, changing "blah" to "const blah" would result in rescanning the newly inserted "blah".  This would cause the "Change All" command to hang.

The old code advanced the search point by the length of the "find text."  The new code advances the insertion point by the length of the "change text".

Fixed the Find/Change panel: some captions were cut off.</t>
<t tx="edream.110203163054.670">@file nodes are now marked dirty whenever any change is made in the @file tree, including changes made as the result of changing cloned nodes outside the @file tree.</t>
<t tx="edream.110203163054.671">Made the log window part of the Leo window.  Having the log be part of the leo window is very convenient.</t>
<t tx="edream.110203163054.672">Leo2 readme file
Borland version 2.2, 9/16/01

This version fixes several bugs in Leo2:

1. Fixed a bug that causes all data in an @file tree to be lost under the following conditions:

A. The @file tree was erroneous, i.e., it contained orphan or ignored nodes.
B. The .leo file containing the erroneous tree was saved twice.

Leo2 now marks an erroneous @file node as "stuck on dirty" until the tree is fixed.  Recall that dirty nodes have icons with a black border rather than a gray border.  Whenever a file Save operation occurs, Leo2 will attempt to write all dirty @file trees, thereby reminding you that errors remain.  However, the .leo file itself is not "stuck on unsaved", so you won't be prompted to save the .leo file endlessly.

While fixing this bug I also improved error and warning messages relating to reading and writing @file nodes.  This should make it clear that a) data in erroneous @file trees is saved to the .leo file and b) data is recovered from the .leo file when reading erroneous @file nodes.

2. Fixed a bug relating to clones that could cause loss of data.  Leo2 now marks all clones dirty when any clone changes, and makes sure to mark @file nodes dirty that contain changed clones.

3.  Changed the code that writes @file trees to end lines with "\r\n" rather than "\n".  I hope this will improve matters, though I have my doubts.  Please report any problems with the new scheme immediately.

4. Added Write @file Nodes command.  The command writes all @file nodes in the selected tree, regardless of whether they have been changed.

5. Made the commands in the Main Leo2 window functional.</t>
<t tx="edream.110203163054.673">Version 2.1 is the first public release of Leo2.  This version appears stable, and should be used with caution.

The major feature of Leo2 is that tangling and untangling happen automatically for all code derived from @file nodes.  

Remember to back up all files derived from @file nodes; such files are original source files!  It is no longer possible to back up an entire project by backing up a single .leo file.</t>
<t tx="edream.110203163054.674"></t>
<t tx="edream.110203163054.675">Version 1.15 can read @file trees.  Leo warns when reading @file files, and changing @file trees in Leo v1.15 is not recommended.</t>
<t tx="edream.110203163054.676">This version corrects a problem with double-clicking Leo icons under Windows Me.  You may now launch Leo by double-click the icon for any .leo file and you may open any .leo file by double-clicking on it.</t>
<t tx="edream.110203163054.677">This version of Leo corrects a problem with how whitespace was handled in @silent mode.</t>
<t tx="edream.110203163054.678">Barring serious bugs, version 1.12 is likely to be the last Borland/Windows version of Leo for a while.  The wxWindows versions of Leo are usable enough to justify putting all further work into them.

There are several important improvements in version 1.12:

1. Added the Sort command to the Outline menu.  This command sorts all the children of a node into alphabetical order.

2. A major improvement to Tangle.  In @silent mode, Tangle now outputs derived files with "verbatim" whitespace, that is, without any extra blanks, tabs and newlines.  This makes Tangle much more useful for Python, and in other applications.  For example, it is now possible to do the following in Python:

if &lt;&lt;condition1&gt;&gt; &amp;&amp; &lt;&lt;condition2&gt;&gt;:
	print &lt;&lt;list of vars&gt;&gt;

In the derived file, expansions of the sections will be placed on the lines in which the reference appears.  This works in Python as long as the expansions themselves appear on a single logical line.

This "verbatim" expansion only happens in @silent mode, so these kinds of derived files can not be Untangled.

3. Tangle now reports errors more fully and less redundantly.  Errors involving missing or erroneous path names (specified in @root directives, @path directives or the Preferences Panel) are more specific.  These errors are reported only once per Tangle command, and these errors terminate the Tangle command immediately.  This is wise; we don't want to write files to the wrong directory!  Finally, Tangle no longer prints the actual text of a section when giving the "possibly duplicate section definition" error.  This should be helpful: no longer are huge error messages generated.  It should be easy enough to find the relevant section definitions using Leo's find command.</t>
<t tx="edream.110203163054.679">This version corrects a problem that can cause the Import CWEB Files command to hang in an endless loop.

This file also contains improved documentation (see the children of this node) in two sections:

1.  Added an explanation of the following error message given by the Tangle command: "Multiple parts not allowed for &lt;&lt; section name &gt;&gt;"

2.  Added a warning about using Untangle to update cloned nodes.
(See the last paragraph of the node.)</t>
<t tx="edream.110203163054.680">Sections can be defined in several parts in two ways:

1.  Using &lt;&lt; section name &gt;&gt;= in several places with the same section name.

2.  Using several @code directives within the _same_ body text.

As a precaution against mistakenly defining a section in more than one place, it is invalid to use @code in different nodes to define multiple parts for the same section.  In particular, this error may arise when using cloned nodes.

This error may always be eliminated by using &lt;&lt; section name &gt;&gt;= instead of @code.
	
</t>
<t tx="edream.110203163054.681">The Untangle, Untangle All and Untangle Marked commands are the reverse of the corresponding Tangle commands.  They update an outline based on changes made to one or more derived files.  These are exceptionally useful commands.

For example, suppose you create a new part of the outline and Tangle it for the first time.  When you compile the resulting derived files for the first time, you are likely to get many syntax errors.  You could fix those errors in the outline and Tangle the outline again, but there is a much easier way:  you fix the errors in the derived files using the compiler's editor, then run the untangle command on the part of the outline that created the derived file.  The Untangle command updates the selected outline to match the changes in the derived files.  It's as simple as that.  By the way, the Untangle command marks all the nodes in the outline that it updates, and you can examine all such nodes with the Go To Next Marked command in the Outline menu.

You cannot use Untangle to update doc parts, or leading comments in code parts or "trivial" whitespace in code parts.  This is a limitation of the Untangle command that cannot be fixed; Untangle has no way of knowing whether leading comments came from doc parts or are just leading comments.

Untangle never changes the structure of an outline;  it never inserts, deletes or moves nodes.  Don't attempt to change the structure of an outline by modifying derived files; it won't work.  Also, never delete, move or alter the sentinel lines in derived files written by the Tangle command.  Such lines start with /// followed by a section name.

If you change the section name in a sentinel line Untangle will not update the code in the outline (with the old name) that generated the renamed section.  Untangle now warns about sections that appear in a derived file but not in the outline.  Untangle has no trouble with changed section references in derived files; it is only changed sentinel lines that cause problems.

Cloned nodes that generate code in several files may cause problems for Untangle if not all the code is changed the same way in derived files.  If Untangle is run separately on these derived files, Untangle will update all cloned nodes each time it is run, so only the code in the last Untangle run will take effect.  Therefore, the only reliable way to update text in cloned nodes is to make the change in the .leo file rather than the derived files.</t>
<t tx="edream.110203163054.682">Version 1.10 incorporates the following changes:

1. The Untangle command no longer updates @doc chunks under any circumstances.  This makes Untangle safe to use when the "Tangle outputs doc chunks" preferences is not selected.  In previous versions the Untangle command would delete all @doc chunks in the outline when a derived file had been Tangled without "Tangle outputs doc chunks".

The new version of Untangle is experimental; only one line of code has been added.  I welcome any comments about this change.  This change also fixes (or rather bypasses) a crasher reported in Untangle.

2. The shortcut for the Execute Script command has been changed from Alt-E to Shift-Alt-E to avoid conflicting with the shortcut that brings up the edit menu.

</t>
<t tx="edream.110203163054.683">Version 1.9 contains several improvements that make Leo more Python-friendly:

1. The Execute Script command (Alt-E) in the Edit menu allows you to execute Python scripts directly from body text.

2. Several small changes make the Python window significantly easier to use.

Also, considerable reference (study-only) code has been removed from leo(CB).leo.</t>
<t tx="edream.110203163054.684">It is now possible to execute any Python script directly from any body text.  Just select the script in the body text (including a trailing newline) and use the Execute Script (Alt-E) command from the edit menu.  The script is copied to the Python window and executed as usual.
</t>
<t tx="edream.110203163054.685">Several small changes make the Python window significantly easier to use:

1. The paste command now works in the Python window whenever the Python window is visible.  This fixes a bug that required a mouse click in either pane before paste would work.

2. It is now possible to execute scripts multi-line scripts pasted into the input pane.  Other changes make it easier (or possible) to terminate continued code.</t>
<t tx="edream.110203163054.686">Fixed a crasher that makes it impossible to tangle outlines containing doc parts in languages like HTML that have no single-line comment delimiter.</t>
<t tx="edream.110203163054.687">Leo v 1.7 accepts a slightly more general file format so that it can read XML generated from external XML tools.  Leo v 1.7 can read all previous .leo files.  Leo's Save commands remain unchanged.

Leo still only understands Leo files.  However, Leo now understands a slightly generalized form of Leo files. Specifically:

1.  Attributes may now appear in any order.  (Leo writes attributes in a fixed order, but some XSLT tools rewrite Leo files with attributes in a different order.)

2.  Leo will now accept &lt;tag/&gt; instead of &lt;tag&gt;stuff&lt;/tag&gt; when "stuff" is empty.
</t>
<t tx="edream.110203163054.688">This version corrects a small bug: the wrong text is selected when the syntax colorer changes.  This is a cosmetic bug only; the selected text will not be replaced when further typing occurs.

Unless major bugs are found, this will be the last version of Leo for several months.  I want to freeze the code so that I can work on the wxWindows version.</t>
<t tx="edream.110203163054.689">This version is a major milestone in Leo's code.  Improvements were made throughout Leo's code in an attempt to correct an extremely hard-to-find bug that can cause data in body panes to be lost.  Only time will tell if the bug has, in fact, finally been eradicated.

This version also corrects a minor bug; icons in a newly cloned tree were not always drawn properly.  Also, the currently selected headline no longer changes if you click on the + or - icons that expand and contract headlines.  This new behavior is a result of simplifying the event handlers; I won't consider changing this behavior until it is clear that the data loss bug has finally been fixed.

Use this version of Leo with caution until the new code has been thoroughly tested.  New asserts will guard against silent data loss and other unexpected events.  I don't expect these asserts to fail, but then one never does...

The following lists the changes that were made the code.  You don't need to read the following details; they are provided only for completeness.

1.  Greatly simplified the event handlers.  This should have been done long ago.

The event handlers now handle _all_ aspects of switching tree nodes and updating data structures when the body pane changes.  In particular, this guarantees that tnodes are "synched" when the body pane changes.  This is a major simplification and a major improvement: it should no longer be possible to lose data once it appears in the body pane.

The reverse is not true: the code must still take care that the body pane is updated if tnodes are changed "by hand."  (This is typically done when new nodes are being created.  Such nodes are never the current node and so are not shown in the body pane.)  I re-checked all code to make sure this constraint is satisfied.

Removed synchVnodes and updateBodyPane methods.  These have always been the most error-prone methods in Leo.  Removing them was made possible because the global constraint that tnodes are up-to-date is now guaranteed by the event handlers.

Created a new updateSyntaxColorer routine, which is called when moving a node or changing its text might affect syntax coloring.  This routine can never affect tnodes.

2.  Removed reference counting from tnodes.  The new code deletes tnodes only during the read process.  After that, tnodes are never deleted.  This could be called a memory leak, but it ensures that tnodes can never be deleted out from under a vnode.  I don't this was ever the problem with losing data, and the new code makes sure that it can't be.

3.  Improved how icons are redrawn.  Event handlers now set the dirty bit when text changes, which simplifies matters.

4.  Added asserts to guard against silent data loss, unexpected calls to event handlers, and mismatches between vnodes and their commanders.

6.  Added the mCommands data member to vnodes.  This member ensures that the correct commander is returned by vnode::commands().  The old code got the commander by looking for the current window.  Conceivably this could have caused the wrong commander to be used in some cases.</t>
<t tx="edream.110203163054.690">This version adds the following features:

1. Outline to noweb command.
2. Python scripts for finding and changing text in Leo outlines.
3. A Python method of the vnode class returning the commander corresponding to a vnode.
4. Documentation for Leo's import/export commands.

This may be the last version of Leo for a while; I am about to start work on a cross-platform wxWindows version of Leo.  However, bug reports and requests for new features are always welcome.

Edward K. Ream
September 19, 2000
</t>
<t tx="edream.110203163054.691">The "Outline To Noweb" command converts the selected outline to a flat file containing noweb text.  The name of the root section is taken from the @root directive.  &lt;&lt;*&gt;&gt; is used if the @root directive is not followed by any file name.</t>
<t tx="edream.110203163054.692">Leo's Python scripting does not support Leo's Find and Replace commands directly because these commands are interactive.  Calling these commands from a Python script would be clumsy.

Instead you can use the new find and change scripts to search and replace text.  These scripts use Python's powerful re module.</t>
<t tx="edream.110203163054.693">The commands() method has been added to the Python vnode class.

c=v.commands()

This method returns the commander for the window containing v.  This method can be used to avoid passing commanders as arguments to vnode methods.  For example, given just v, we can call either of the following:

	v.commands().synchNode()
	v.commands().Repaint()</t>
<t tx="edream.110203163054.694">This version corrects a problem with the Save As command;  it worked only once!  That is, after the Save As command was executed the window's title would change, but a later Save command would change the file specified before the Save As command was executed.</t>
<t tx="edream.110203163054.695">This version of Leo introduces Python scripting.  This is a major new addition to Leo.  See the new Chapter 7 of this documentation.  Python support still has rough edges; the next release will be cleaner.  Any suggestions for improvements to Leo's support for Python would be appreciated.

Alt-V now toggles the "View All Characters" option.  This is especially useful when editing Python code.

Besides Python support, a number of minor bug fixes have been made:

Added syntax coloring for try and catch to the C parsers.

Control-K, I now indents blocks of text uniformly, regardless of the language being syntax colored, and regardless of @nocolor and @color directives.  Similarly, Control-K, U now undents blocks of text.  The old keys, control-[ and control-] only worked when the current language was C and syntax coloring was enabled.

Removed the menu items that had the enter key as a shortcut.  The only way to create a new node now is with Control-I.  Using the enter key for a shortcut is not a good idea: it causes problems throughout the code.

Fixed a bug in forgiving compare.  The code that was calling compare_comments wasn't handling mismatched whitespace properly.

Got the Import command for Python working.  I found a bug in Tangle: in @silent mode we must always output a newline in the place of the function name.  Otherwise the Python indentation will be wrong.

The Untangle is now disabled when in @silent mode.  Nothing good can happen in that case!

Fixed a minor problem with the @path directive:  ff a _new_ file has not been saved we issue a warning, not an error if no path has been specified.  We can't really test the @root command for a path because the @root command may be found much later.  Fortunately, this warning will happen very rarely.  It's important, however, to warn that the file may be written to the standard directory if no path is specified in the @root command.  Otherwise, Leo's behavior would be quite confusing.</t>
<t tx="edream.110203163054.696">This version corrects an oversight in the Flatten Outline command.  In order to recreate the outline structure it is not enough to know whether each node has children; you must also know how many children each node has.

The new version of the Flatten Outline command represents the outline the same way the Export MORE Text does:  a child headline is indented one tab more than its parent headline.</t>
<t tx="edream.110203163054.697">The Tangle commands now examine all nodes, including cloned nodes that have previously been visited.  Previously, such nodes were skipped during tangling.  The new logic allows clones to represent code common to more than one unit. You can always insert an @ignore directive in an ancestor of a cloned node to prevent the node from being processed during tangling.
</t>
<t tx="edream.110203163054.698">Version 0.19 fixes some bugs and eliminates some problematic features of Leo.  Also, the role of CWEB mode has been documented more thoroughly.

The PC version of PC is feature complete.  I will release version 1.0 after people have played with this version for a while.

As always, I'll be happy to fix bugs or add urgently needed features.
</t>
<t tx="edream.110203163054.699">Fixed a bug that could result in Tangle outputting derived files in the wrong directory.

Tangle and Untangle now set the current directory using @path directive if it exists, otherwise the directory specified in the Preferences panel if it exists, otherwise the directory set by the Load or Save commands if it exists.  (The Save As and Save To never alter this directory.) Finally, a check to see if the @root directive specifies a full path.  If so, the current directory is not changed.

If none of these directories exists an error is raised so that no Tangling or Untangling is done.  This error can only occur if Tangling or Untangling a file that has just been created by the New command and never saved with the Save command.</t>
<t tx="edream.110203163054.700">Added the @language html, @language perl and @language perlpod directives, and added HTML, Perl and Perl + POD items in the Preferences panel.

The HTML script is rudimentary at present.  Suggestions for improvement are welcome.</t>
<t tx="edream.110203163054.701">The @cweb and @noweb commands are no longer functional.  The new @language cweb directive replaces @cweb, and the other @language directives effectively replace @noweb.  There is an new CWEB option in the Preference panel.
</t>
<t tx="edream.110203163054.702">Leo now parses the @language directive as you type, so if you change the language specified by the @language directive you will see the effect immediately.

There is no longer a limit of 6 languages that can be syntax colored. Let me know if you would like Leo to support another language.</t>
<t tx="edream.110203163054.703">The Print command is now much more flexible and convenient: it will print any node and all its descendents, whether or not the node contains @unit, @root or @ignore directives.  
</t>
<t tx="edream.110203163054.704">Modified massage_block_comment so that it converts the first of a series of newlines to a blank and deletes the rest; Untangle no longer mangles modified @doc sections.

A more complete solution would be for Tangle to insert a flag for inserted newlines ( say backslash newline) so that Untangle could know which newlines to remove.  I'd like to wait until all Tangle/Untangle code is converted to C++ before doing a more thorough job.
</t>
<t tx="edream.110203163054.705">Leo no longer supports clone _windows_.  Cloned outlines, however, will remain with Leo forever.  

Clone windows were never very useful and were buggy.  Eliminating clone windows has made it possible to handle events more smoothly and powerfully.</t>
<t tx="edream.110203163054.706">The Extended Noweb Syntax option in the Preferences panel is gone.  This option has always been deprecated.</t>
<t tx="edream.110203163054.707"></t>
<t tx="edream.110203163054.708">Version 0.18 changes the file format in an upward compatible way.  That is, version 0.18 can read all previous versions of Leo files, but you must have version 0.18 of Leo to read files written by version 0.18.</t>
<t tx="edream.110203163054.709">Fixed a bug that caused @doc section not to be output properly for those languages like Fortran and Perl that do not have block comments.</t>
<t tx="edream.110203163054.710">The @noheader directive suppresses the header line normal written by Tangle at the start of each derived file.  The @noheader directive is especially useful in Perl.  Also added the corresponding "Tangle outputs header line" checkbox in the preferences panel.  This checkbox sets the default which may be over-ridden by the @header or @noheader directives.</t>
<t tx="edream.110203163054.711">@language fortran specifies that comments start with C.
@language fortran90 specifies that comments start with !.</t>
<t tx="edream.110203163054.712">@language perlpod specifies the Perl language with block comments being delimited by =pod and =cut</t>
<t tx="edream.110203163054.713">Version 0.17 fixes some bugs and puts some finishing touches on Leo.

The Borland C++ Builder version of Leo is now feature complete; there are no further items on the to-do list.  Yes, I'll be happy to fix bugs or add urgently needed features.
</t>
<t tx="edream.110203163054.714">Tangle and Untangle now treat &lt;&lt;*&gt;&gt;= as a synonym for @root filename if the _headline_ starts with text of the form @root filename.  This convention allows full compatibility with noweb.
</t>
<t tx="edream.110203163054.715">The @path, @tabwidth and @pagewidth directives are new.

These directives allow the user to override the defaults specified in the Prefs panel on a file-by-file basis.   For the first time, every option in the Preferences panel may be overridden by a directive.</t>
<t tx="edream.110203163054.716">I fixed several severe bugs involving CWEB mode.  It is now possible to tangle and untangle files when in CWEB mode, though CWEB mode has still not been tested thoroughly.</t>
<t tx="edream.110203163054.717">Reduced the default size of Leo windows so that they can be more easily resized on a small screen.</t>
<t tx="edream.110203163054.718">Version 0.16 is a significant new release of Leo.  All users of the PC version of Leo should upgrade to version 0.16.

Significant changes have been made to Tangle and Untangle:  these commands should now be able to handle code in almost any language.  The new @language directive specifies the comment and string conventions used when Tangling and Untangling.

The @verbose, @terse and @silent directives are new:  they control how Tangle outputs comments.

The Import Files command now handles Pascal, Python and Java files in addition to C and C++ files.

Besides the major changes a number of bug fixes and other minor features have been added.

Acknowledgements:  Thanks to Zak Greant for numerous suggestions and bug fixes, and to Garold Johnson for improving this file.</t>
<t tx="edream.110203163054.719">Version 0.16 fixes all bugs mentioned on the SourceForge site as of April 27, 2000.  These bugs involved problems with

@comment &lt;empty&gt;
@comment 2 delims
Not inheriting @comment properly
non-delimited filenames in @root directives
Crashes while Tangling
Problems with Untangle with languages other than C.

Later sections discuss some of these in more detail.</t>
<t tx="edream.110203163054.720">Version 0.16 fixes a crasher related to changing windows.

This _may_ have been the source of crashes when cutting and pasting outlines, but don't count on it!  Make sure you back up files _before_ cutting and pasting outlines!</t>
<t tx="edream.110203163054.721">The @language directive is new.  The @language directive actually specifies the comment delimiters and string types used by the Tangle and Untangle.

The form of this directive is

@language x

where x is one of the following: c,c++,html,java,objective-c,pascal,perl,python and shell.  Shell files have comments that start with #.  Case is ignored in the language specifiers, but not in the @language itself.  Thus, the following are equivalent:

@language html
@language HTML
@language hTmL

but the following is invalid:

@LANGUAGE html

The @comment directive is now officially deprecated: you should use the @language directive whenever possible.  At present Untangle will not process an @root or @unit node if an @comment directive is in effect.  Why?  Because Untangle can't be sure of properly parsing a derived file if the language of the derived file isn't known.  It might be possible to assume some defaults in this case, but that is not done at present and is not a high priority.</t>
<t tx="edream.110203163054.722">Scanning for @directives is now much faster.  As a result, the @language and @comment directives will be recognized anywhere in an outline.  This means

1) child nodes will "inherit" @language or @comment directives from ancestors unless over-ridden in the child node and

2) @language and @comment directives need not be placed in @unit or @root nodes.  This is a much more intuitive and powerful way of handling these directives.</t>
<t tx="edream.110203163054.723">Key parts of the untangle logic have been generalized so that they can handle essentially any computer language. The following routines no longer have any C-specific code and have essentially been completely rewritten:

scan_derived_file (formerly scan_c_file)
forgiving_compare (formerly c_compare)

Tangle now will properly output comments using the present comment delimiters as specified by either the @language directive or the @comment directive.  As mentioned before, you should use @language instead of @comment wherever possible.</t>
<t tx="edream.110203163054.724">As a side effect of the Untangle command, Leo now removes trailing blank lines from the body text of all nodes being untangled.  This finally crushes a long-standing bug.  If the body text ends with one or more blank lines, the altered body text contains exactly one trailing newline.

Nodes that are altered in this way are not marked, nor is the file-changed mark set.  This seems to be the most appropriate action to take:  it would be confusing to prompt the user to save a changed file if the only changes involve trailing whitespace.</t>
<t tx="edream.110203163054.725">The @verbose, @terse and @silent directives determine how Tangle outputs comments.  When @verbose is in effect Tangle outputs all comments.  When @terse is in effect, Tangle outputs only those comments necessary for Untangle to work.  When @silent is in effect Tangle no additional comments.  Note: comments written by the user in code sections are always output: these directives control only:

1.  The comments containing doc chunks and
2.  Sentinel comments that delimit the beginning and end of code chunks.

@verbose is the default.  If more than one of these directives appear in the same body text the "most verbose" of these options will be in effect.</t>
<t tx="edream.110203163054.726">At long last Leo has a useful notion of default directory.  By default, the default directory is the directory containing the .leo file.  This may be over-ridden using the "Tangle Default Directory" option in the Preferences panel.

The default directory is used whenever a file name in an @root directive contains no path component.
</t>
<t tx="edream.110203163054.727">The Import Files command looks at the file extension to see how it should handle files.

Extension	Language
.c			C
.cpp		C++
.java		Java
.pas		Pascal
.py			Python

If the extension is not one of the above the Import files commands merely puts the entire file into the body text of a single node.

The Import Files command probably needs quite a bit of work.</t>
<t tx="edream.110203163054.728">Control-T now changes the pane that is currently active.  If the outline pane was active, the body pane becomes active, and vice versa.  This command makes it possible to switch between panes without using the mouse.</t>
<t tx="edream.110203163054.729">In previous versions of leo.leo I used slash instead of backslash as path delimiters.  This should never have worked, but somehow it did.  The present code uses the correct backslash in all @root directives.</t>
<t tx="edream.110203163054.730">Many improvements were made to the code.  See the diary section of leo.leo if you are interested.  In particular, I created args.h and args.c to define arguments.  This cleans up the code quite a bit.</t>
<t tx="edream.110203163054.731">Changed Tangle and Untangle so that empty section names like &lt;&lt; &gt;&gt; and &lt;&lt; &gt;&gt;= are treated as ordinary characters.  No warning is issued, which is debatable.</t>
<t tx="edream.110203163054.732">As mentioned in the main documentation, you must not change sentinel lines in derived files in any way.  In particular, if you change the section name in a sentinel line Untangle will not update the code in the outline (with the old name) that generated the renamed section.  Untangle now warns about sections that appear in a derived file but not in the outline.  Untangle has no trouble with changed section references in derived files; it is only changed sentinel lines that cause problems.
</t>
<t tx="edream.110203163054.733">Leo is being used to develop HTML files for web sites.  In this context it is natural to define sections that are shared between files.  Don't expect Untangle to update such sections if you make changes to them in derived files.  The natural place to change sections shared by several roots is in the outline, not in the files derived from the outline.

If you do change code in a derived file that appears in several derived files, and try to use Untangle to update the code in the outline one of two things will happen:

1) You untangle an @root node.  Untangle will never compare examine the common section of code for changes, as the common section appear under a @unit node, not the @root node. Untangle will complain about an orphan node.
 
2) You untangle an @unit node.  Untangle will examine each @root node under the @unit node.  Unless the change is made in the last root examined, Untangle will propagate the change when it first sees it, then go right ahead and undo the change when it sees the next expansion of the node in a derived file.
 
Untangle tests for inconsistent expansions of a section only within a single derived file.  Such tests are not done between different derived files because we do not want disallow sections with the same names in different roots.</t>
<t tx="edream.110203163054.734">Known bugs and limitations in all versions of Leo.

1. Untangle has no way of updating a section(chunk) whose name has been changed in the derived file.  Because of the @unit directive, there is not even a way to issue a meaningful warning.

2. Tangle treats @c like @code when in CWEB mode.
I recommend changing @c to @&lt; c @&gt;= throughout your CWEB sources and adding a reference
to @&lt; c @&gt; in all roots of CWEB files.

Known bugs and limitations of the PC version of Leo.

Syntax coloring options are not saved to the file.

The Log window has a limited capacity. This mainly affects debugging traces but could affect the output from the Tangle or Untangle commands if you tangled or untangled a large number of files.
</t>
<t tx="edream.110203163054.735">@nocolor

This outline contains the latest documentation available for Leo.</t>
<t tx="edream.110203163054.736">@nocolor

The following was written by Joe Orr, a user of Leo.  For more details, see http://www.jserv.com/jk_orr/xml/leo.htm

Leo is a powerful tool for organizing text into tree structures, and for just generally attacking a number of problems from a tree-based perspective. 

&lt;opinion&gt;
There has been a lot of hype about XML and all the uses to which it can be put. But, to my mind, the greatest benefit of XML is that it allows people to easily work with tree structures. All the benefits of XML really flow from that. Leo is the best application I've seen for conceiving and planning the trees that are then put into action via various XML technologies.
&lt;/opinion&gt;

Outlining Editors have existed for a while (e.g. PC-Outline, MORE) but Leo takes a major leap beyond previous tools for three reasons:

You can embed a simple macro language inside of a Leo document to instruct Leo to assemble pieces of the Leo document into another file. This facilitates, among other things, one type of Literate Programming.

Leo saves its files in XML format. This means that you can easily import and export Leo documents to any number of programs that can understand XML. for example, you can use an XSLT stylesheet to export a Leo file to HTML. And you can import any XML file into Leo using another XSLT stylesheet.

Leo is fully scriptable via Python.</t>
<t tx="edream.110203163054.737">@nocolor</t>
<t tx="edream.110203163054.738">Leo Users Manual
June 15, 2002

Leo is a programmer's editor and a flexible browser for projects, programs, classes or data. Leo clarifies design, coding, debugging, testing and maintenance.

Leo is a literate programming tool, compatible with noweb and CWEB. Leo enhances any text-based programming language, from assembly language and C to Java and Python to XML and English.

Leo is an outlining editor. Outlines clarify the big picture while providing unlimited space for details.

Leo is also a data organizer. A single Leo outline can generate complex data spanning many different files.  Leo has been used to manage web sites.

Leo is a project manager. Leo provides multiple views of a project within a single outline. Leo naturally represents tasks that remain up-to-date.

Leo is fully scriptable using Python and saves its files in XML format.

Leo is portable.  Leo.py is 100% pure Python and will run on any platform supporting Python and Tk/tcl, including Windows, Linux and MacOS X.  Leo.exe runs on any Windows platform.

Leo is Open Software, distributed under the Python License.

Leo was designed and built by:

Edward K. Ream
email:  edream@tds.net
voice: (608) 231-0766</t>
<t tx="edream.110203163054.739">Leo creates a better way of programming by making clear the relationships between parts of programs. The larger the program, the more valuable Leo becomes. I would never willing program without Leo again.

Leo has hundreds of users. They use Leo to create programs in all kinds of languages, from assembly language, C and C++ to Java, Python and Tk. They use Leo to build and maintain web sites and to manage large amounts of other data. Leo's users have extended Leo in directions I never imagined. See the Acknowledgments below.

Inventing and building Leo, and completely re-visioning Leo to add @file trees has been the happiest and most creative part of my professional life. Leo grew out of my attempts to understand and use Donald Knuth's CWEB system of "literate programming". Chapter 6 discusses how Leo relates to traditional literate programming. Chapter 8 contains a history of Leo and a detailed account of how I invented Leo2.</t>
<t tx="edream.110203163054.740">This is what I wanted when I started this project.

1. A tool that I could use successfully. I had tried flat literate programming and failed to produce a program that I could understand. The design of my own literate programs were a mystery to me. With the insight gained with two years experience with literate outlines, I believe I could now probably create flat literate outlines with some success. But how would I do that? By mentally simulating a literate outline! So although it would be possible for me to use flat literate programming tools, it would never be easy or natural.

Using literate outlines instantly transformed how I program. No longer was I confused about what I had done or what remained to do. No longer did I need to remember section names. No longer did I have to search for where functions and variables were defined. March 5, 1996, the day I started using MORE as a prototype of a literate outliner, changed my programming life forever. Within an hour of writing code in MORE, I knew that literate outlines would work, and work spectacularly well.

2. A way to ignore formatting. Printed listings, no matter how "beautiful", simply do not convey the structure of complex programs as well as an on-screen outline. What matters is how a program is represented on screen. I have been using Leo since early 1996. Not once have I had any inclination to look at a printed listing in order to understand my program better.

3. An outliner as good as MORE. I accomplished this by borrowing a large part of MORE's screen design. Consider this the sincerest form of flattery.

I did make one real change to MORE's design. MORE shows body text in multiple separate windows within the main outline pane; Leo shows body text in a single body pane. Leo's approach simplifies switching between nodes: one simply selects a new headline and the body text appears in the body pane. With MORE, one has to explicitly open the body pane for each individual headline, which can be clumsy.
However, MORE's approach does have some advantages. First, when opening body text in MORE, the subsidiary window becomes as large as necessary to show the entire body text, up to the limit of the size of the containing window. With Leo, the body pane stays fixed unless one resizes it. This is the reason Leo has several shortcuts for resizing the body pane.

MORE leaves lots of open windows around when doing a search or change command; MORE could be called a slob in this regard. However, MORE's way does have one benefit: one can see all the places where the search command found a match just be looking at all the open windows. With Leo this can not be done so directly; one must mark headlines to see where one has been. This is the main reason why Leo has a Find Next Marked Headline command. Without this command one must resort to something like expanding all headlines.
Leo and MORE have superb outlining facilities; each provides true outline objects and a full range of outline operations. Leo attempts to fix the one clumsy feature of MORE, the need to explicitly open body text. On the whole, I believe that Leo is slightly easier to use than MORE, especially for programming.

4. A self-contained programming system.  Leo's Tangle command provides basic support for literate programming.  Leo's Untangle command is a novel addition to literate programming.  The automatic tangling and untangling of @file trees is another major step forward.  Finally, Leo's many import and export commands ensure that Leo is compatible with noweb and CWEB.

5. A fun tool.  In Chapter 6 I list several highbrow reasons for liking literate programming. I know somebody gets what literate programming is all about when he or she says how much fun literate programming is. Clearly, Leo has succeeded admirably in this regard. I would never again willingly program without a literate outliner.</t>
<t tx="edream.110203163054.741">COPYRIGHT

All parts of Leo are distributed under the following copyright.  This is intended to be the same as the Python license, namely that Leo is absolutely free, even for commercial use, including resale.  There is no GNU-like "copyleft" restriction.  This license is compatible with the GPL.

Copyright 1997-2002 by Edward K. Ream.  All Rights Reserved.

Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the names of Edward K. Ream or Leo not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission from Edward K. Ream. 

DISCLAIMER OF WARRANTIES

EDWARD K. REAM (REAM) SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESSED OR IMPLIED, WITH RESPECT TO THIS COMPUTER SOFTWARE, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS RO A PARTICULAR PURPOSE.  IN NO EVENT SHALL REAM BE LIABLE FOR ANY LOSS OF PROFIT OR ANY COMMERCIAL DAMAGE, INCLUDING BUT NOT LIMITED TO SPECIAL, INCIDENTAL, CONSEQUENTIAL OR OTHER DAMAGES.</t>
<t tx="edream.110203163054.742"></t>
<t tx="edream.110203163054.743">Leo's main window contains an _outline pane_ and a _body pane_. An _outline_ represents an entire project and is stored in a single .leo file.  An outline consists of _headlines_. Headlines may be expanded and contracted.  Each headline has its own _body text_.  The body pane shows the body text of the presently selected headline. A _node_ is a headline and its body text.

_Sections_ group arbitrary text into a meaningful unit. Sections increase the expressive power of any language, from C to Python to XML to English. Outlines may be reorganized freely because the meaning of a section does not usually depend on its position.

_Clones_ are parts of an outline that change in unison.  Any change to a clone's headline, body text or its children is propagated to all other clones.  Clones can represent tasks and clones can create multiple views of a project within a single outline.

_Derived files_ are files generated from parts of an outline. An outline may generate many derived files. Conversely, an outline may be updated using changes to derived files.

In short, sections simplify text, clones represent tasks, outlines organize projects and outlines generate derived files.</t>
<t tx="edream.110203163054.744">Leo's main window contains two panes, an outline pane on top and a body pane below.  The outline pane contains a set of headlines.  Headlines fold (expand and contract) like Windows Explorer when you click the + or - icons. Headlines group components (subheadlines) into larger units.

The bottom pane contains the body text associated with the selected headline.  The combination of a headline and its associated body text is called a node. Body text can simply be plain text or text in the noweb or CWEB languages. A Leo program is a collection of all the body text of an outline organized by the headline.

Leo's outline are much more flexible and powerful than typical class browsers:

1. Leo's programming language understands outline structure.  The programmer may name a part of the tree and refer to that tree by name in source code.

2. Leo's commands understand outline structure.  Many of Leo's dozens of commands act on individual nodes and their descendents.  For example, one may limit a Find or Change operation to a specified part of an outline.

3. Leo allows the user to reorganize outlines freely by adding, deleting and moving nodes.

4. Leo opens an outline as it was when the user last used it, restoring the selected node, the top visible node, and the expansion state of all nodes.</t>
<t tx="edream.110203163054.745">@nocolor

Text in Leo's body pane is simply plain text that may contain section references.  For example, here is part of Leo's source code.

@color
def removeSentinelsCommand (self,fileName):
	valid = true
	&lt;&lt; Read file into s &gt;&gt;
	&lt;&lt; Set delims from the header line &gt;&gt;
	if valid:
		s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
		newFileName = fileName + ".tmp"
		&lt;&lt; Write s into newFileName &gt;&gt;
	else:
		es("Invalid @+leo sentinel in " + fileName)
		
@nocolor
Section references have the form &lt;&lt;section name&gt;&gt; and may appear anywhere in code.   Leo replaces a section reference by its definition  when Leo creates a source (derived) file.
Section references clarify code.  In this example, the code that is represented by the three section references does not conceal the overall shape of the removeSentinelsCommand function.  In particular, the role of the valid and s variable are clear.  Section references are often more convenient than functions.  For example, there is no need to return s from

	&lt;&lt;Read file into s&gt;&gt;
	
or to pass s to

	&lt;&lt;Write s into newFileName&gt;&gt;.
	
There are two ways to define sections.  The first way is to use a section definition line,

	&lt;&lt;section name&gt;&gt;=

(notice the equal sign) on a line by itself in body text, followed by the source code that defines the section.   The second way is to create a node with &lt;&lt;section name&gt;&gt; in its headline and the source code that defines the section in its body text.  Either way, the section definition may contain other section references.</t>
<t tx="edream.110203163054.746">Outlines can show relationships between sections. In the example above, a natural way of organizing the outline would as shown in the child of this node.  The removeSentinelsCommand method is defined in one node which has three children, one for each section referenced in the definition of removeSentinelsCommand.

Furthermore, Leo uses outline structure to delimit derived files and to control the scope of section definitions.  See Chapter 4 for details.</t>
<t tx="edream.110203163054.747">@color
def removeSentinelsCommand (self,fileName):

	path, self.fileName = os.path.split(fileName) # path/fileName
	trace(`self.fileName`)
	&lt;&lt; Read file into s &gt;&gt;
	valid = true
	line_delim = start_delim = end_delim = None
	&lt;&lt; set delims from the header line &gt;&gt;
	if valid == false:
		es("Invalid @+leo sentinel in " + fileName)
	else:
		trace("line:"+`line_delim`+","+
			"start:"+`start_delim`+","+
			"end:"+`end_delim`)
		s = removeSentinelLines(s,line_delim,start_delim,end_delim)
		newFileName = os.path.join(path,fileName+".tmp")
		&lt;&lt; Write s into newFileName &gt;&gt;</t>
<t tx="edream.110203163054.748">try:
	file = open(fileName)
	s = file.read()
	file.close()
except:
	es("Can not read " + fileName)
	return</t>
<t tx="edream.110203163054.749">@ This code is similar to atFile::scanHeader.
@c

tag = "@+leo"
# Skip any non @+leo lines.
i = 0
while i &lt; len(s) and not find_on_line(s,i,tag):
	i = skip_line(s,i)
# We should be at the @+leo line.
i = j = skip_ws(s,i)
# The opening comment delim is the initial non-whitespace.
while i &lt; len(s) and not match(s,i,tag) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i: line_delim = s[j:i]
else: valid = false
# Make sure we have @+leo
i = skip_ws(s,i)
if match(s,i,tag): i += len(tag)
else: valid = false
# The closing comment delim is the trailing non-whitespace.
i = j = skip_ws(s,i)
while i &lt; n and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i:
	start_delim = line_delim
	end_delim = s[j:i]
	line_delim = None</t>
<t tx="edream.110203163054.750">try:
	file = open(newFileName,"w")
	file.write(s)
	file.close()
except:
	es("Can not create " + newFileName)</t>
<t tx="edream.110203163054.751">Headlines (and the sections they contain) are the natural building block of tasks. To build tasks from headlines we need another feature of Leo's outlines, namely clones. A clone is a copy of a tree that changes whenever any part of the original tree changes.  Clones are powerful. For example, adding a node to a cloned tree adds the same node to all cloned trees as well.

We can use an ordinary headline to represent any task as follows.  We create an ordinary headline to represent the task and we label the headline with the name of the task.  Let us call such a headline a task headline. Then, throughout the entire outline, we clone all headlines (sections) that pertain to the task and move the new clones as sub-headlines of the task headline.

In effect, the task headline becomes a separate view of the project. The task headline is a natural place to place notes about the task, for example, design documents, test data and logs, etc.  Most importantly, the task view will change when any of its cloned headlines changes, and conversely, changes to clones under the task outline are propagated throughout the outline. This means that,

a) the task headline will remain up-to-date when the project changes, and
b) we can make changes in the task view and rather than throughout an outline.

In short, task headlines focus our attention on only those parts of a project that relate directly to a task and makes it easy to change code scattered throughout a project.</t>
<t tx="edream.110203163054.752">Leo outlines are stored in a single .leo file. Leo can create many derived files from a single outline.  You can create derived files explicitly using the Tangle command, or automatically when an outline file is saved.  Conversely, Leo can update outlines based on changes to derived files. Again, you can update an outline explicitly using the Untangle command, or automatically when an outline file is opened.  Outline files contain all information contained in derived files.  This redundancy is useful for backing up data and for error recovery.

This introduction has only sketched Leo's capabilities.  Chapter 3 shows how to create and reorganize Leo's outlines. This chapter covers clones, a powerful outline feature found in few other outliners.  Chapter 4 tells you everything you need to write programs in Leo.  Chapter 5 discusses all of Leo's commands.  Chapter 7 discusses scripting Leo with Python.</t>
<t tx="edream.110203163054.753">@nocolor

This chapter tells how to install Leo.

New in version 4.1:  The first time you start Leo, Leo will ask you for a unique identifier.  If you are using cvs, use your cvs login name.  Otherwise your initials will do.

Leo stores this identifier in leoID.txt, so you can change this identifier at any time by chaning leoID.txt.</t>
<t tx="edream.110203163054.754">@nocolor

This chapter tells how to use Leo's outline pane.  It introduces terminology and discusses creating, moving, marking, cloning headlines.

This chapter also discusses the control keys that can be used in the body pane.  This material is excerpted from documentation at http://tcl.activestate.com/man/tcl8.4/TkCmd/text.htm</t>
<t tx="edream.110203163054.755">A cloned node is a copy of a node that changes when the original changes. Changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes.  Clones are marked by a small arrow  by their leader characters.

There is no real distinction between the "original" node and any of its clones.  This makes it possible to update any of the clones and the original node will change as well.  When the second-to-last cloned node is deleted the last cloned node becomes a regular node again.

Clones are useful for making alternate views of a program.  For example, when I begin to fix a bug I clone all the sections of the code that relate to the bug, and place those cloned sections under a new headline whose name is the name of the bug I am fixing.

The children of this headline show some complex clones.  To see how clones work, try moving the node marked f around with the nodes marked a fully expanded.  Not all moves are allowed:  you can't move a cloned node so it would become a child of another clone of itself.</t>
<t tx="edream.110203163054.756">This is a kind of bizarre outline that I use to test clone operations.  Try moving the nodes a through g around and see what happens to the children of the various clones.</t>
<t tx="edream.110203163054.757"></t>
<t tx="edream.110203163054.758"></t>
<t tx="edream.110203163054.759"></t>
<t tx="edream.110203163054.760"></t>
<t tx="edream.110203163054.761"></t>
<t tx="edream.110203163054.762"></t>
<t tx="edream.110203163054.763"></t>
<t tx="edream.110203163054.764">The Insert Node command inserts a new headline into the outline.

The Delete Node command deletes a headline and all its children.
</t>
<t tx="edream.110203163054.765">The Cut Outline, Paste Outline, Copy Outline and Delete Outline commands work on nodes rather than text.  For example, to delete a headline, select the headline and choose the Cut Outline or Delete Outline commands.

The Cut Outline and Copy Outline copy a text representation of the outline to the clipboard.  This representation is the same as the file format with some information deleted.  You may copy this text representation into a body pane (or into any other text editor) using the Paste command in the Edit menu.

Warning:  In practice, it is almost always wiser to move clones rather than cutting or pasting them.  Cutting and pasting outlines preserves clones, but the links between clones only exist within the part of the outline that was pasted.  Therefore, if you are cutting and pasting an outline containing clones it is best to cut and paste the _entire_ outline.  Alternatively, you can paste part of an outline, then delete all clones.</t>
<t tx="edream.110203163054.766">Body text in leo.py has the following features:

Leo auto indents when @nocolor is not in effect.  That is, typing a newline automatically inserts the same leading whitespace present on the previous line.  If the present language is Python (set either in the preferences or with an @language Python command), Leo inserts an additional tab if the previous line ends with a colon.

The default features of Leo's body text derive from the Tk Text widget, described at:
http://www.tcl.tk/man/tcl8.3/TkCmd/text.htm
Not all these features are found on all platforms.

The following features are mostly derived from the Tk Text widget.  Some default behaviors have been changed because they conflict with other Leo features.

Clicking mouse button 1 positions the insertion cursor just before the character underneath the mouse cursor, sets the input focus to this widget, and clears any selection in the widget. Dragging with mouse button 1 strokes out a selection between the insertion cursor and the character under the mouse. 

Double-clicking with mouse button 1 selects the word under the mouse and positions the insertion cursor at the beginning of the word.

The ends of the selection can be adjusted by dragging with mouse button 1 while the Shift key is down; this will adjust the end of the selection that was nearest to the mouse cursor when button 1 was pressed. 

Clicking mouse button 1 with the Control key down will reposition the insertion cursor without affecting the selection. 

If any normal printing characters are typed, they are inserted at the point of the insertion cursor. 

If the mouse is dragged out of the body pane while button 1 is pressed, the entry will automatically scroll to make more text visible (if there is more text off-screen on the side where the mouse left the window). 

The Left and Right (arrow) keys move the insertion cursor one character to the left or right; they also clear any selection in the text. If Left or Right is typed with the Shift key down, then the insertion cursor moves and the selection is extended to include the new character. Control-Left and Control-Right move the insertion cursor by words, and Control-Shift-Left and Control-Shift-Right move the insertion cursor by words and also extend the selection.

The Up and Down (arrow) keys move the insertion cursor one line up or down and clear any selection in the text. If Up or Right is typed with the Shift key down, then the insertion cursor moves and the selection is extended to include the new character. Control-Up and Control-Down move the insertion cursor by paragraphs (groups of lines separated by blank lines), and Control-Shift-Up and Control-Shift-Down move the insertion cursor by paragraphs and also extend the selection. Control-p and Control-n behave the same as Up and Down, respectively. 

The Next(Page Down) and Prior(Page Up) keys move the insertion cursor forward or backwards by one screenful and clear any selection in the text. If the Shift key is held down while Next or Prior is typed, then the selection is extended to include the new character.

Line movement is by text lines terminated by hard returns (newlines), not by displayed lines;  if a text line is long and wraps across more than one display line, then the Up and Down movement will skip the extra wrapped display lines.

Home moves the insertion cursor to the beginning of its line and clear any selection in the widget. Shift-Home moves the insertion cursor to the beginning of the line and also extends the selection to that point. 

End moves the insertion cursor to the end of the line and clear any selection in the widget. Shift-End moves the cursor to the end of the line and extends the selection to that point. 

Control-Home moves the insertion cursor to the beginning of the text and clear any selection in the widget. Control-Shift-Home moves the insertion cursor to the beginning of the text and also extends the selection to that point. 

Control-End moves the insertion cursor to the end of the text and clear any selection in the widget. Control-Shift-End moves the cursor to the end of the text and extends the selection to that point. 

The Select key and Control-Space set the selection anchor to the position of the insertion cursor. They don't affect the current selection. Shift-Select and Control-Shift-Space adjust the selection to the current position of the insertion cursor, selecting from the anchor to the insertion cursor if there was not any selection previously. 

Control-/ selects the entire contents of the widget. 

Control-\ clears any selection in the widget. 

The F16 key (labeled Copy on many Sun workstations) or Control-c copies the selection in the widget to the clipboard, if there is a selection. This action is carried out by the command tk_textCopy. 

The F20 key (labeled Cut on many Sun workstations) or Control-x copies the selection in the widget to the clipboard and deletes the selection. This action is carried out by the command tk_textCut. If there is no selection in the widget then these keys have no effect. 

The F18 key (labeled Paste on many Sun workstations) or Control-v inserts the contents of the clipboard at the position of the insertion cursor. This action is carried out by the command tk_textPaste. 

The Delete key deletes the selection, if there is one in the widget. If there is no selection, it deletes the character to the right of the insertion cursor. 

Backspace deletes the selection, if there is one in the widget. If there is no selection, they delete the character to the left of the insertion cursor. </t>
<t tx="edream.110203163054.767">You can expand or contract a headline by clicking in the standard Windows Tree View icon to the left of the status icon.

Expanding a node shows its immediate children; contracting a node hides all its children.  The Expand All Subheads command expands all of a nodes offspring (children, grandchildren, etc.)</t>
<t tx="edream.110203163054.768">Leo auto indents body text following colons when @language is in effect.

You may use Emacs-style auto-indentation instead.  The child of this node provides full details.</t>
<t tx="edream.110203163054.769">You can mark headlines in several ways: with the various Outline:Mark commands, with the Find or Change commands, or with the Untangle command.  The "Go To Next Marked" command will go to the next marked node, if any.

The Mark command will unmark the selected headline if it is already marked.</t>
<t tx="edream.110203163054.770">There are a number of ways to move and reorganize headlines.

The Move Up, Move Down, Move Left and Move Right commands move the currently selected outline.  The Promote command makes all the children of a headline siblings of the headline.  The Demote command makes all the siblings of a headline children of the headline.

You can cut and paste any part of a tree.  If a headline contains selected text, the cut, copy, clear or paste operation affects only the selected text. Otherwise, the cut, copy, clear or paste operations acts on the node and all nodes contained by it.  For example, you can move a headline by cutting it, selecting another location in the outline and pasting the headline in the new location.

Warning:  In practice, it is almost always wiser to move clones rather than cutting or pasting them.  Cutting and pasting outlines preserves clones, but the links between clones only exist within the part of the outline that was pasted.  Therefore, if you are cutting and pasting an outline containing clones it is best to cut and paste the _entire_ outline.  Alternatively, you can paste part of an outline, then delete all clones.  
</t>
<t tx="edream.110203163054.771">Double-clicking the icon box of a node whose headline has the form:

@url &lt;any url&gt;

executes the url in your default web browser.  See the child of this node for full details.</t>
<t tx="edream.110203163054.772">You can change the relative sizes of the outline and body panes by dragging the splitter bar.  The Equal Sized Panes command resizes the panes so that each fills half of the main window.</t>
<t tx="edream.110203163054.773">The outline pane supports one level of undo.

The body pane supports unlimited undo.  However, you can not undo an operation affecting body text after selecting a new headline.  You can undo or redo the last operation involving the outline itself.  You can not undo operations affecting headline text.</t>
<t tx="edream.110203163054.774">@nocolor
@ignore
@language python</t>
<t tx="edream.110203163054.775">Important note 1: This chapter tells how to use the noweb markup language.  See the node called About CWEB if you plan to use the CWEB markup language.

Important note 2: This chapter discusses only the @file directive.

-- Appendix 1 to this chapter tells how to use the new @rawfile directive.
-- Appendix 2 to this chapter tells how to use the older @root directive.

This is the most important chapter because it describes everything you need to know to write programs with Leo. Unless otherwise mentioned, this chapter applies to all versions of Leo.  Newcomers to Leo should read Introducing Leo before reading further.

I _strongly recommend_ that you have look at an example of a Leo outline like LeoPy.leo while you read this documentation. It is much easier to use Leo than to describe all the rules in detail.  Looking at a real Leo outline will make many points clear that are difficult to describe succinctly in words.

Terminology: _Directives_ are commands that appear in body text.  Directives start with an @ in the leftmost column followed by a directive name. We often refer to outline nodes by the directives they contain.  For example, an @others node is a node containing an @others directive, an @ignore node is a node containing an @ignore directive, and so on.  Exception: an @file node is a node whose headline starts with @file.  We also speak of @root trees, trees whose is an @root node, @file trees, trees whose root is an @file node, and so on.

The essentials of writing programs in Leo are as follows:

1. A Leo program is composed the all the body text in an outline, or part of an outline.

2. Body text is a sequence of _sections_.  There are two kinds of sections: doc sections and code sections.

3. Sections may contain _section references_ that refer to other sections by their nam.

4. Leo uses outline structure to control the scope of section definitions.

5. Leo creates source files called _derived files_ by expanding all section references in an @file tree.
</t>
<t tx="edream.110203163054.776">@nocolor
There are two kinds of sections: code sections and doc sections.  Code sections start with the @c directive.  Within @file trees, the entire body text of a node is a code section by default, so the @c directive can be omitted if there are no doc sections in the body pane.  Doc sections start with @ followed by a space at the start of a line.  Doc sections continue until the end of body text or until the next @c or @(space) directive.

The term "section" has two related meanings.  Sections are syntactic units of text in the body pane.  Leo writes the text of section to derived files, so another meaning of "section" is "the text that is written to the derived file."  Which meaning is intended should be clear from context.

Code sections may contain section references of the form &lt;&lt;section name&gt;&gt;. That is, a section reference is any sequence of characters except newlines enclosed in &lt;&lt; and &gt;&gt;. Leo ignores whitespace and case inside section names, so the following are equivalent:
@color

	&lt;&lt; Read file into s &gt;&gt;
	&lt;&lt;READ File into S&gt;&gt;

@nocolor
Leo underlines section names whose definitions are not found in any descendent.  Such sections are always invalid in @file trees, and may be valid in @root trees provided that the section is defined somewhere else.

Paired &lt;&lt; and &gt;&gt; characters on the same line always denote a section name, even within comments and strings.  That is, &lt;&lt; and &gt;&gt; characters that do not delimit a section name must be placed on separate lines.  If &lt;&lt; and &gt;&gt; are not paired on a line, they are treated as literal &lt;&lt; and &gt;&gt; characters.

Body text may contain zero or more sections in any order.  A code section is named if the node's headline starts with &lt;&lt;section name&gt;&gt;.  Otherwise, the code section is unnamed.  Body text that contains no @ or @c directive is considered to be a single unnamed code section. @ and @c directives terminate any previous section. For example,

@color
@ This method puts an open node sentinel for node v.
@c
def putOpenNodeSentinel(self,v):
	if v.isAtFileNode() and v != self.root:
		&lt;&lt; issue an error message &gt;&gt;
	else:
		s = self.nodeSentinelText(v)
		self.putSentinel("@+node:" + s)

@nocolor
An @c directive is optional at the start of body text, so:
@color

@c
def hasChildren(self):
	return self.firstChild() != None

@nocolor
is equivalent to the following text without any markup:
@color

def hasChildren(self):
	return self.firstChild() != None

@nocolor
The @c directive is needed here:
@color

@ Returns true if the receiver has child nodes.
@c
def hasChildren(self):
	return self.firstChild() != None

@nocolor
However, we could replace the doc part with a comment, like this:
@color

# Returns true if the receiver has child nodes.
def hasChildren(self):
	return self.firstChild() != None

@nocolor
The choice of using doc parts or comments is a matter of style.  Doc parts are convenient for longer comments that would be tedious to format by hand.

Minor note 1: For historical reasons, the @code directive is a synonym for the @c directive and the @doc directive is a synonym for @ directive. Only the @c, @code, @ and @doc directives terminate sections.

Minor note 2: A line of the form:
	
@ %def identifiers

terminates the previous code section and indicates that the preceding code section defines the list of identifiers.  This list contains identifiers separated by whitespace; any sequence of non-white characters may be an identifier.  This construction is used in traditional noweb programming to generate indices.</t>
<t tx="edream.110203163054.777">Lets see how to organize typical outlines.  The only rules we must follow are:

- All nodes containing body text must be referenced.

- Each named node must descend from the node that refers to it.

- The @ignore directive is not valid in @file trees.

A node that is not referenced is called an _orphan node_.  If an @file tree contains an orphan node or @ignore node, Leo issues a warning and does not write the derived file when saving an outline. Leo saves all the information in the @file tree in the .leo file, so nothing is lost; Leo will recreate the @file tree from the .leo file when reading the outline the next time.

We can avoid having to refer to sections by name by using the @others directive.  This can save a lot of work.

The @others directive refers to _all unnamed_ sections.  An @file tree may contain more than one @others directive.  @others directives that descend from other @other directives refer only to unnamed nodes that descend from them.  The @others directive that occurs highest in the @file tree refers to all other unnamed nodes.

There are two minor restrictions on the @others directive:

- No single node may contain more than one @others directive.

- No named node may "intervene" between an unnamed node containing body text and an @others node. This restriction will be discussed in detail below.  In practice this is never a problem.

When saving an outline, Leo creates derived files from all changed @file trees by expanding references to named and unnamed sections:

- Section references place the body text of a single named section in the derived file.

- @others directives place the body text of all unnamed nodes in the derived file.

- The @others directive places unnamed nodes in outline order, the order in which nodes appear in an outline when all nodes are expanded.

When reading an outline, Leo recreates @file trees from derived files. In particular, you may change derived files outside of Leo, and Leo will update the outline accordingly.  You may change derived files in any way provided that you don't change sentinel lines.  Sentinel lines are comment lines whose first character (after the comment delimiter) is @.  Leo represents outline structure in sentinel lines, so changing sentinel lines will corrupt the outline structure. (The appendix lists the format and meaning of all sentinel lines.)

Some examples should make all this much clearer.  See the children of this node.

The @ignore directive is not valid in @file trees because derived files contain primary data.  The .leo file also contains a copy of the information in the @file tree, but this information is used for backup and error recovery. As a result, everything in an @file trees must correspond to information the derived file and the @ignore directive may not appear in @file trees.</t>
<t tx="edream.110203163054.778">@file f.c shows how to create a C file.

@file classX.py shows how to create a single Python class.

@file mainClass.py shows how to define two classes in a single Python file.

The @file bad tree is invalid.  No named node may "intervene" between an unnamed node containing body text and an @others node.
</t>
<t tx="edream.110203163054.779">@color
@ This @file node generates the file f.c.

This body text ensures that the expansions of &lt;&lt; constants &gt;&gt; and &lt;&lt; declarations &gt;&gt; precede the expansions of all unnamed sections. It is good style to name those sections that must appear in a particular place in the derived file. All unnamed sections are placed in the derived file where the @others directive appears. Unnamed sections appear in the derived file the order in which they appear in the outline.

The children of the @file node contain the definitions of all sections, both named and unnamed. Unnamed sections usually contain functions or method. It is bad style for the meaning of a derived file to depend on the order of unnamed sections in the outline.
@c

&lt;&lt; constants &gt;&gt;
&lt;&lt; declarations &gt;&gt;
@others</t>
<t tx="edream.110203163054.780">the constants</t>
<t tx="edream.110203163054.781">the declarations</t>
<t tx="edream.110203163054.782">text of function 1</t>
<t tx="edream.110203163054.783">text of function 2</t>
<t tx="edream.110203163054.784">@color
@ This @file node generates the file classX.py.

Indentation is significant in languages like Python. When Leo expands a section reference (or an @others directive), Leo adds the leading whitespace of the line containing the section reference to all lines of the reference's expansion. The text of body text need not be indented beyond its natural indentation.

Organizing nodes (nodes with no body text) do not affect the derived file in any way. In particular, such nodes never change indentation. Organizing nodes are often useful. 
@c

&lt;&lt; imports for classX &gt;&gt;
class classX:
	@others</t>
<t tx="edream.110203163054.785"></t>
<t tx="edream.110203163054.786">@ This is an organizing node.  Using this node does not change the indentation in the derived file.</t>
<t tx="edream.110203163054.787"></t>
<t tx="edream.110203163054.788"></t>
<t tx="edream.110203163054.789">@ This is an organizing node.  Using this node does not change the indentation in the derived file.</t>
<t tx="edream.110203163054.790"></t>
<t tx="edream.110203163054.791"></t>
<t tx="edream.110203163054.792">@color
@ This @file node generates the file mainClass.py.

When two classes appear in the same file, a single @others directive does not suffice. However, no node may contain more than one @others directive.  To get around this limitation we can organize the outline as shown.

The @others directive refers only to unnamed nodes in the descendents of the @others node, so the two @others directives refer to disjoint sets of unnamed sections.
@c

&lt;&lt;mainClass imports&gt;&gt;
&lt;&lt;class mainClass&gt;&gt;
&lt;&lt;class helperClass&gt;&gt;</t>
<t tx="edream.110203163054.793"></t>
<t tx="edream.110203163054.794">class mainClass:
	@others</t>
<t tx="edream.110203163054.795"></t>
<t tx="edream.110203163054.796"></t>
<t tx="edream.110203163054.797">class helperClass:
	@others</t>
<t tx="edream.110203163054.798"></t>
<t tx="edream.110203163054.799"></t>
<t tx="edream.110203163054.800">@color
@language python
@ The following outline is invalid.  Node A is an unnamed node containing body text, and the &lt;&lt;section one&gt;&gt; node intervenes between Node A and the @others node.
@c

class classX:
	@others
</t>
<t tx="edream.110203163054.801">def bad():
	&lt;&lt; section 1 &gt;&gt;</t>
<t tx="edream.110203163054.802">@ This node is invalid because it intervenes between Node A and the @others node above.
</t>
<t tx="edream.110203163054.803">def spam():
	pass</t>
<t tx="edream.110203163054.804">The following sections discuss directives that have not been discussed previously.  Unless otherwise noted, these directives are valid anywhere in an outline.</t>
<t tx="edream.110203163054.805">Syntax coloring is on by default in all body text. Leo formats comments and documentation parts in red, directives and C keywords in blue, strings and character constants in gray and all other text in code parts in black.

The @nocolor directive disables syntax coloring for the body text in which it appears. No syntax coloring is done until an @color directive re-enables syntax coloring.

If a node contains neither the @color nor the @nocolor directive it may inherit the syntax coloring attribute from an ancestor. The nearest ancestor that contains exactly one of the @color or @nocolor directives will control the syntax coloring. Ambiguous nodes, nodes containing both the @color and @nocolor directives, never affect the coloring of their offspring.

Note: the @color or @nocolor directives do not affect the Tangle commands in any way. In particular, the Tangle commands will recognize section definitions as usual even after an @nocolor directive is seen.</t>
<t tx="edream.110203163054.806">Note: the @comment directive is now officially deprecated: you should use the @language directive whenever possible.

Untangle will not process an @root or @unit node if an @comment directive is in effect because Untangle can't be sure of properly parsing a derived file if the language of the derived file isn't known. It might be possible to assume some defaults in this case, but that is not done at present and is not a high priority.

By default, the Tangle Commands produces C-language comments. Single-line comments generated during tangling start with ///, while documentation parts are surrounded by /* and */. The @comment directive allows you to use Tangle to produce shell and make files, as well as source code for other programming languages.

The @comment directive may be followed by zero to three delimiters, separated by whitespace. This directive sets the single-line comment delimiter and the opening and closing block comment delimiters as follows:

@comment
	(no delim) restores the defaults to ///, /* and */
@comment ///
	(one delim) sets the single-line comment and clears the other delimiters.
@comment /* */
	(two delims) sets the opening and closing block comment delimiters and clears the single-line comment.
@comment /// /* */
	(three delims) sets all three delimiters.

If only one delimiter is given, Leo does not write any documentation parts while tangling. If two delimiters are given, block-style comments are used instead of single-line comments.
For example, the @comment { } directive could be used to Tangle Pascal files.

The @comment directive is only recognized in @root, @unit or @file nodes, and the @comment directive must precede the first section name or @code directive. An @comment directive in the body text of an @unit directive specifies the current global defaults. An @comment directive in the body text of an @root directive affects comments generated for one root only. Comments in all other roots are governed by the global defaults.

New in leo.py 3.0: Leo will convert underscores in the @comment directives to significant spaces.  For example,

@comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).</t>
<t tx="edream.110203163054.807">@nocolor

The @delims directive changes the comment strings used to mark sentinel lines. This directive is often used to place Javascript text inside XML or HTML files.

The @delims directive contains one or two delimiters, separated by whitespace. If only one delim is present it delimits single-line comments. If two delims are present they delimit block comments. The @delims directive can not be used to change the comment strings at the start of the derived file, that is, the comment strings for the @+leo sentinel and the initial @+body and @+node sentinels. The @delims directive inserts @@delims sentinels into the derived file. The new delimiter strings continue in effect until the next @@delims sentinel in the derived file or the end of the derived file.

Note: Leo can not revert to previous delimiters automatically; you must change back to previous delimiters using another @delims directive. For example:

@color

@delims /* */?
Javascript stuff?
@delims &lt;-- --&gt;?
HTML stuff

@nocolor
Adding, deleting or changing @@delims sentinels will destroy Leo's ability to read the derived file. Mistakes using the @delims directive have no effect on Leo, though such mistakes will thoroughly mess up a derived file as far as compilers, HTML renderers, etc. are concerned.</t>
<t tx="edream.110203163054.808">You may use the @encoding directive to specify the encoding used in a derived file.  You can't mix encodings in a single derived file.  For example,

@encoding iso-8859-1

If the encoding used in a derived file is not "utf-8" it is represented in the @+leo sentinel line, like this:

#@+leo-encoding=iso-8859-1.

The "utf-8" encoding is used by default.  The "utf-8" encoding is a "lossless" encoding (it can represent all unicode code points), so encoding and decoding to and from utf-8 plain strings will never cause a problem.  When reading or writing a character not in a "lossy" encoding (such as iso-8859-1), Leo converts such characters to '?' and issues a warning. </t>
<t tx="edream.110203163054.809">The @first directive allows you to place lines at the very start of files derived from @file nodes. For example, the body text of @file spam.py might be:

	@first #! /usr/bin/env python

The body text of @file foo.perl might be:

	@first #/usr/bin/perl

@first directives are recognized only at the start of the body text of @file nodes. No text may precede @first directives. More than one @first directive may exist, like this:

	@first #! /usr/bin/env python
	@first # more comments.

Similarly, @last directives are recognized only at the end of body text of @file nodes.  No text may follow @last directives.  More than one @last directive may exist.  For example, here is how a PHP file might be set up:

	@first &lt;?php
	...
	@last ?&gt;</t>
<t tx="edream.110203163054.810">@nocolor
The @language directive specifies the comment delimiters and string types used by the Tangle and Untangle commands. This directive over-rides the default specified in the Preferences panel. The form of this directive is:
@color

@language x

@nocolor
where x is one of the following: c, c++, html, java, objective-c, pascal, perl, perlpod, plain, python and shell. Shell files have comments that start with #. Case is ignored in the language specifiers, but not in the @language itself. Thus, the following are equivalent:
@color

@language html
@language HTML
@language hTmL

but the following is invalid:

@LANGUAGE html</t>
<t tx="edream.110203163054.811">@nocolor

The @path, @pagewidth and @tabwidth directives allow preferences to be set on a file-by-file basis: they override the corresponding defaults in the Preferences panel.

The form of the @path directive is @path filename, where filename is taken to be everything following @path to the end of the line.

If the filename in @file pathname or @root pathname is an absolute filename the location of the derived file is specified only by the filename.  Otherwise, if the filename is a relative filename, the location of the derived file is relative to:
	
1. the directory specified the applicable @path directive, or
2. the "Default Tangle Directory" in the Preferences panel if no @path directive is in effect, or
3. the directory in which the .leo resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules, or if the filename or directory does not exist.

The form of the @pagewidth directive is @pagewidth n, where n is a positive integer that indicates the width of tangled pages in columns. This setting only affects how Tangle outputs block comments.

The form of the @tabwidth directive is @tabwidth n, where n is a positive integer that indicates the width of tabs in spaces. This is used by Tangle to output leading whitespace.</t>
<t tx="edream.110203163054.812">New in version 3.12: By default, the body_pane_wraps setting in leoConfig.txt controls whether body text wraps.  You may override this setting for a particular tree using the @wrap and @nowrap directives.
</t>
<t tx="edream.110203163054.813"></t>
<t tx="edream.110203163054.814">@file trees are much easier to use than @root trees:

1. @file trees require less markup than @root trees; all sections in @root trees must have names, but @file trees usually contain many unnamed sections. Within @file trees, the @others directive acts like a reference to all unnamed sections.

2. The user must explicitly tangle and untangle @root trees using the Tangle and Untangle commands.  Leo tangles and untangles @file trees automatically,  tangling all changed @file trees when writing an outline and untangling all @file trees when reading an outline.

However, @root trees are more flexible than @file trees:

1. Within @file trees, sections must be defined in descendents of the node that contains the section reference.

2. Within @root trees a section may be defined anywhere within the @root tree, regardless of where the section is referenced.  Moreover, the @unit directive expands the scope of section definitions in @root trees so that a section may be referenced in several @root trees.  (See "Tangling @root trees with the Tangle commands for a complete description of the @root directives.)

3. The meaning of section definitions in @root trees are independent of their position within the tree.

@root trees differ from @file trees as follows:

- Only @root trees may contain section definition lines (see below.)

- Only @file trees may contain @others directives.

- @c directives require section names in the headline of @root trees.

- @c directives are optional at the start of body text in @file trees only.
Body text without markup is ignored in @root trees; it creates unnamed code sections in @file trees.</t>
<t tx="edream.110203163054.815">@nocolor
Just as with @file trees, @root trees may contain kinds of sections: code sections and doc sections.  Code sections start with section definition lines (see below) or the @c directive.  Doc sections start with @ followed by a space at the start of a line.  Doc sections continue until the end of body text or until the next @c or @(space) directive.

The term "section" has two related meanings.  Sections are syntactic units of text in the body pane.  Leo writes the text of section to derived files, so another meaning of "section" is "the text that is written to the derived file."  Which meaning is intended should be clear from context.

Body text in @root trees contain zero or more sections in any order. The @c directive starts a named code section if the node's headline starts with &lt;&lt;section name&gt;&gt;.  Otherwise, the @c directive is invalid.

Section definition lines of the form:

	&lt;&lt; section name&gt;&gt;=

(note the equal sign) also start named code sections.  Named code sections in @root trees may be defined in several places.  The definition of a named code section is the concatenation of all code sections with the same name. Body text that defines no code section is ignored.

As in @file trees, paired &lt;&lt; and &gt;&gt; characters on the same line always denote a section name, even within comments are strings.  That is, &lt;&lt; and &gt;&gt; characters that do not delimit a section name must be placed on separate lines.  If &lt;&lt; and &gt;&gt; are not paired on a line, they are treated as literal &lt;&lt; and &gt;&gt; characters.

At least one non-blank line must follow the section definition line.  That is, empty sections are not allowed. 

Here is a typical example of body text within an @root tree:
@color

@ This method puts an open node sentinel for node v.
&lt;&lt;atFile methods&gt;&gt;=
def putOpenNodeSentinel(self,v):
	if v.isAtFileNode() and v != self.root:
		&lt;&lt; issue an error message &gt;&gt;
	else:
		s = self.nodeSentinelText(v)
		self.putSentinel("@+node:" + s)

@nocolor
Provided that the node's headline starts with &lt;&lt;atFile methods&gt;&gt;, the example above is equivalent to:
@color

@ This method puts an open node sentinel for node v.
@c
def putOpenNodeSentinel(self,v):
	if v.isAtFileNode() and v != self.root:
		&lt;&lt; issue an error message &gt;&gt;
	else:
		s = self.nodeSentinelText(v)
		self.putSentinel("@+node:" + s)

@nocolor
We may not eliminate @c directives in @root trees.  If we convert the doc part to a comment we are left with:
@color

@c
# This method puts an open node sentinel for node v.
def putOpenNodeSentinel(self,v):
	if v.isAtFileNode() and v != self.root:
		&lt;&lt; issue an error message &gt;&gt;
	else:
		s = self.nodeSentinelText(v)
		self.putSentinel("@+node:" + s)

@nocolor
The following escape convention applies only in @root trees.  Within a code parts @@ in the first column (and only in the first column) stands for a single @ sign.</t>
<t tx="edream.110203163054.816">@nocolor
Each @root tree  represents a single derived file.  Tangling is the process of creating derived files from @file or @root trees. Leo tangles @file trees automatically whenever an outline is saved.  The user must tangle @file trees explicitly using one of the Tangle commands.

Leo creates derived files by expanding all section references in an @root node. Leo expands a section reference by substituting the code section itself for the section reference. This is a recursive process: the substituted code section may contain other code references which are themselves expanded, and so on.

It is unusual and bad style for the meaning of an @root tree to depend on the position of nodes within it. The meaning of a section definition in an @root tree usually does not depend on is position, and we may place sections wherever we want.  The outline provides a natural way of organizing an sections as follows:

	Place the definition of a section S in a child of
	the node containing the reference to S.

If a section is referenced in more than one node, I usually place its definition in a node containing all the nodes that refer to it. Using this rule of thumb creates an outline whose structure mirrors the intrinsic organization of a program.

The Tangle command creates derived files from @root node. The @root directive indicates which sections constitute an output file. The text following a @root directive forms the entire content of the file, that is, after section references are expanded. An outline can contain arbitrarily many @root directives: Leo's Tangle commands will create one output file for each. The process of creating derived files is called "tangling" because the code from the outline is rearrange to create the derived files.

For example, the following @root section shows a typical way of specifying a header file xx.h.
@color

@root"xx.h"
#ifndef xx_defined
#define xx_defined
&lt;&lt; declarations of public constants of the xx class &gt;&gt;
&lt;&lt; declarations of public types of the xx class &gt;&gt;
&lt;&lt; declarations of public variables of the xx class &gt;&gt;
&lt;&lt; public prototypes of the xx class &gt;&gt;
#endif

@nocolor
The Tangle commands will create the file xx.h from this body text by expanding all the section references. Incidentally, the introductory documentation will be included in the header file: any text preceding the @root directive is treated just like the documentation part of an section definition.

As another example, the following shows a typical way of specifying the corresponding xx.c file:
@color

@root"xx.c"
&lt;&lt; public variables of the xx class &gt;&gt;
&lt;&lt; private types of the xx class &gt;&gt;
&lt;&lt; private variables of the xx class &gt;&gt;
&lt;&lt; private function prototypes of the xx class &gt;&gt;
&lt;&lt; methods of the xx class &gt;&gt;

@nocolor
There are three menu commands that tangle an outline: Tangle, Tangle All and Tangle Marked. These commands are identical except for how much of the outline is tangled. The Tangle command tangles only the selected portion of the outline, the Tangle All command tangles the entire outline, and the Tangle Marked command tangles only marked headlines.

The @root directive has three forms. All three forms mean exactly the same thing.
@color

@root filename
@root "filename"
@root &lt;filename&gt;

@nocolor

If filename is an absolute filename the location of the derived file is specified only by the filename.  Otherwise, if the @root node contains a relative filename, the location of the derived file is relative to:
	
1. the directory specified the applicable @path directive, or
2. the "Default Tangle Directory" in the Preferences panel if no @path directive is in effect, or
3. the directory in which the .leo resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules, or if the filename or directory does not exist.

The Tangle commands format derived files so they are easy to read. The .c file in the Examples folder shows how derived files are formatted by the Tangle commands.

There is one complication that we haven't discussed yet: the scope of section definitions. The scope of a definition is the tree in which the definition is known.

By default, Tangle commands look for section definitions only in the suboutline of the @root node being tangled. That is, all sections are assumed to be defined either in the body text of the headline, say h, containing the @root directive, or in the body texts of the descendants of h.

The @unit directive explicitly indicates the scope of section definitions. When a Tangle command encounters the @unit directive it treats the suboutline containing the @unit command as the scope for all enclosed roots. This ensures that the group of roots in the subtree use the same section definitions.

For example, suppose we have a tree organized as follows:
	+ @unit
		+ @root A
		sections in A
		+ @root B
		sections in B
		
The @unit directive insures that:
1. only sections defined in the unit can effect files A and B and
2. all sections definitions in A and B are compatible with each other.

Finally, Tangle commands ignore any tree containing an @ignore directive. This ensures that trees that contain cloned nodes or other subsidiary information do not cause the tangle commands to issue spurious error messages. It also ensures that a tree can never contribute a section definition to another part of the outline by mistake.</t>
<t tx="edream.110203163054.817">The Untangle, Untangle All and Untangle Marked commands are the reverse of the corresponding Tangle commands. They update one or more @root nodes based on changes made to the corresponding derived files.

For example, suppose you create a new part of the outline and Tangle it for the first time. When you compile derived files for the first you are likely to get many syntax errors. You could fix those errors in the outline and Tangle the outline again, but there is a much easier way: you fix the errors in the derived files using the compiler's editor, then run the untangle command on the part of the outline that created the derived file. The Untangle command updates the selected outline to match the changes in the derived files. It's as simple as that. By the way, the Untangle command marks all the nodes in the outline that it updates, and you can examine all such nodes with the Go To Next Marked command in the Outline menu.

You cannot use Untangle to update doc parts, or leading comments in code parts or "trivial" whitespace in code parts.  This is a limitation of the Untangle command that cannot be fixed; Untangle has no way of knowing whether leading comments came from doc parts or are just leading comments.

Untangle never changes the structure of an outline; it never inserts, deletes or moves nodes. Don't attempt to change the structure of an outline by modifying derived files; it won't work. Also, never delete, move or alter the sentinel lines in derived files written by the Tangle command. Such lines start with /// followed by a section name.

If you change the section name in a sentinel line Untangle will not update the code in the outline (with the old name) that generated the renamed section. Untangle now warns about sections that appear in a derived file but not in the outline. Untangle has no trouble with changed section references in derived files; it is only changed sentinel lines that cause problems.

Cloned nodes that generate code in several files may cause problems for Untangle. If Untangle is run separately on these derived files, Untangle will update all cloned nodes each time it is run, so only the code in the last Untangle run will take effect. Therefore, the safe way to update text in cloned nodes is to make the change in the .leo file rather than the derived files.</t>
<t tx="edream.110203163054.818">@nocolor

This chapter is discusses all of Leo's menu commands.  It is organized by menu, and by function within each menu.

A note about typography:  in this chapter command names and menu names will be capitalized, just as they would be in a menu.  This convention allows us to write, for example, the Save A Copy As command, rather than having to use distracting quotation marks, like the "Save A Copy As" command.</t>
<t tx="edream.110203163054.819"></t>
<t tx="edream.110203163054.820">The New command creates a new Leo main window.  The Open command opens an existing Leo file and shows it in a main window.  The Close command closes the topmost Leo window, and gives you an opportunity to save your work if you haven't yet done so.

The Save, Save As and Save A Copy As commands save the topmost Leo window to a file.  The Save As and Save A Copy As commands create a complete copy of a Leo file.  The Save command updates the file without rewriting those parts that have not been changed.  As a result, the Save command is significantly faster than the Save As and Save A Copy As commands.

The Revert command reloads a file, discarding any changes made to the file since it was last saved.

New in Leo 2.5: The Recent Files... command brings up a submenu containing a list of recently opened files.  Choosing an item in this submenu opens the selected file or brings it to the front. Leo adds files to this submenu even if leoConfig.txt is missing or read-only, but those additions will not be remembered unless leoConfig.txt is present and writable.  New in Leo 4.0: The Clear Recent Files command deletes all entries in the Recent Files submenu except the most recent file.  The files themselves are not affected, just the menu entries.

The following four file commands are located in the File:Read/Write submenu.

Read Outline Only: reads an outline using only the .leo file, not any files derived from @file nodes.  This command is useful for reverting a project to a previously saved state.

Read @file Nodes: updates all @file nodes in an outline.  This ensures that the state of an outline matches all files derived from @file nodes.  Included for completeness.  This happens automatically when a .leo file is first read, and it also happens automatically when Leo2 is reactivated.

Write Outline Only: saves an outline without writing any @file trees.  Useful for inserting an @file node into an outline without modifying a derived file with the same name.

Write @file Nodes: forces an update of all @file trees.  Surprisingly useful.

New in Leo 3.12:  The Write Dirty @file Nodes command writes all @file trees that have been changed.

New in Leo 4.0: The Write 4.x Derived Files command and Write 3.x Derived Files command work just like the Write @file Nodes command, except that they write the indicated format off derived file.  In contrast, the Write @file Nodes command writes 3.x format derived files if and only if the write_old_format_derived_files = 1 in leoConfig.txt.  Auto Save: all three of these commands automatically save the outline (the .leo file) if any derived file was actually written.  This is necessary so that information in the .leo file always remains in synch with all derived files.</t>
<t tx="edream.110203163054.821">The Open With command allows you to communicate with external editor.  See the child of this node for full details.</t>
<t tx="edream.110203163054.822">The Tangle, Tangle All and Tangle Marked commands create derived files from portions of an outline.  These commands indent and format the derived files so that they are easy to read and so that it is clear what sections produced the code.  The .c file in the Examples folder shows the code produced by the Tangle commands.

The three Tangle commands are identical except for how much of the outline is tangled.  The Tangle command tangles only the selected portion of the outline, the Tangle All command tangles the entire outline, and the Tangle Marked command tangles only marked headlines.

Derived files are usually .h or .c files (C), .cpp files (C++), or .m files (Objective-C) files, and they can also be other files such as "make" or "help" files.

The Tangle commands create a derived file, call it F, from each @root node.  This process is very much like macro expansion.  The contents of F are simply the body text of the @root node, with each section reference replaced by its definition.  Substitution continues until all references to sections are replaced with their definitions.

By default, Tangle commands look for section definitions only in the suboutline containing the @root directive being tangled.  That is, all sections are assumed to be defined either in the body text of the headline, say h, containing the @root directive, or in the body texts of the descendants of h.

The @unit directive changes the default scope of the tangle command, while the @ignore directive causes the tangle commands to ignore a subtree.  For more details, see the discussion of the @unit and @ignore commands in Chapter called "Using noweb, CWEB and directives". 
</t>
<t tx="edream.110203163054.823">When using the Tangle and Untangle commands there are several issues to be aware of concerning your IDE (Integrated Development Environment). This section applies particularly to the Borland IDE; similar remarks apply to other IDE's.

Assuming you have added a .cpp file to your project, you update the file with the Tangle command.  When you switch to the IDE you will get a dialog asking whether you want to update the file.  Say yes and rebuild or remake.

You won't get the dialog unless the file is already open in the IDE.  There is a bug in the Borland IDE: the dialog doesn't come to the front, so it can be easy to miss.

Now suppose you compile the file and get 20 errors all over the .cpp file. You fix the errors _in the IDE_, save the file, switch to Leo, and run the Untangle command. All your changes will appear in the outline! Each changed node will be marked by the Untangle command.

If you like you can use the Go To Next Marked command to find each changed node.
</t>
<t tx="edream.110203163054.824">Note: the following describe the import and export commands found in leo.py.  This documentation notes differences with the Windows version of Leo.

The Import to @file command creates an @file node from a file.  The Import to @root command creates an @root node from a file.  These commands do not attempt to do perfect translations; they merely automate the bulk of the drudgery.  The Import to @root command is called Import Files in the Borland/Windows version of Leo.  The Import to @file command does not exist in the Borland/Windows version of Leo.
The Import CWEB Files command creates an @file node from a CWEB file.  This command does not exist in the Borland/Windows version of Leo.

The Import noweb Files command creates an @file node from a CWEB file.  The Borland/Windows version of this command creates an @root node.

The Import Flattened Outline command (called Import MORE Text in the Borland/Windows version of Leo) converts plain text written in MORE format to an outline. This command brings up a dialog which will accept at most one file. If that file contains MORE-format text it creates an outline corresponding to that text.

MORE is a now- defunct Macintosh outliner program. MORE represents outlines as follows. Headlines are denoted by a leading + or - character, preceding by zero or more tabs that denote the level of the headline. Body text follows its headline, with no indentation. The original MORE format did not escape lines in the body text that started with + or -. Leo escapes such characters by preceding +, - or backslash with a backslash.

New in Leo 4.0: The Import Derived File command imports all the nodes in a derived file into the outline.  Unlike the read commands, no outline structure is preserved.  This command can import either 3.x or 4.x derived files.  This command is necessary in version 4.0 because there is no other way to read derived files that are out-of-synch with a .leo file.</t>
<t tx="edream.110203163054.825">The Outline To CWEB command creates a CWEB file from the selected outline.

The Outline TO noweb command creates a noweb file from the selected outline.

The Flatten Outline command creates a text file in MORE format from the selected outline.  See the previous section for a discussion of the MORE format.

The Remove Sentinels command removes all sentinel lines from a file derived from an @file node.</t>
<t tx="edream.110203163054.826">The Quit command causes Leo to exit.   You may also exit Leo by closing the main window.  In either event you will be prompted to save any file that has been altered but not saved. </t>
<t tx="edream.110203163054.827"></t>
<t tx="edream.110203163054.828">For leo.py version 2.0 and above:

leo.py supports unlimited Undo and Redo.  All outline operations, including the Change All command and all operations and commands that affect body text may be undone and redone.  Only the "Read @file Nodes" command is undoable; it clears the undo state. This command raises a dialog to allow the user to cancel.

Think of actions that may be Undone or Redone as a string of beads.  A "bead pointer" points to the present bead.  Performing an operation creates a new bead after the present bead and removes all following beads.  Undoing an operation moves the bead pointer backwards; redoing an operation moves the bead pointer forwards.  The Undo command is disabled when the bead pointer moves in front of the first bead; the Redo command is disabled when the bead pointer points to the last bead.

For all Borland versions:

The body pane supports unlimited undo.  However, you can not undo an operation affecting body text after selecting a new headline.  You can undo or redo the last operation involving the outline itself.  You can not undo operations affecting headline text.</t>
<t tx="edream.110203163054.829">Leo supports the standard editing commands that appear in the edit menu: Undo, Cut, Copy, Paste and Clear. These commands work with either headline (when a headlines text is being edited) or body text. Text may be cut, copied and pasted between headline text and body text.

The Select All command selects all text in the body pane.
</t>
<t tx="edream.110203163054.830">The Shift Left and Shift Right commands shift selected lines in the body text left or right one tab position. The entire line is shifted if any characters of the line are selected.</t>
<t tx="edream.110203163054.831">The Extract, Extract Section and Extract Section Names commands create child nodes whose headline is the first line of the selected body text.

The Extract command creates a new node whose headline is the first line of selected body text and whose body is all following lines of body text.  All selected text is deleted from the original body text. This command is enabled only if the first line contains a section name (enclosed in angle brackets) on a line by itself.

The Extract Section command creates a new node whose headline is the first line of selected text and whose body is @code followed by all the other lines of selected text.  All selected text lines except the first line are deleted from the original body text. This command is enabled only if the first line contains a section name (enclosed in angle brackets), on a line by itself.

The Extract Section Names command creates one or more child nodes, one for each section name (enclosed in angle brackets) in the selected body text.  The headline of each created node is the section name and the body text of each created node is just @code followed by a newline.</t>
<t tx="edream.110203163054.832">New in leo.py v2.5.

The Convert Tabs command converts leading tabs to blanks in a single node.  The Convert Blanks command converts blanks to tabs in a single node.  The Convert All Tabs converts leading tabs to blanks throughout the selected tree.  The Convert All Blanks command converts leading blanks to tabs throughout the selected tree.

All these commands convert between tabs and blanks using the tab width shown in the Preferences panel.</t>
<t tx="edream.110203163054.833">The Execute Script command executes body text as a Python script.  Leo execute the selected text, or the entire body text if no text is selected.

Scripts are executed in a "pristine" environment, that is, with __builtins__ as both the local and global environments.</t>
<t tx="edream.110203163054.834">The Edit menu contains four commands for searching and replacing text.  The Find and Find Again commands search through the outline for text and the Change and Change, Then Find commands change selected text.

The following check boxes options appear in the search dialog and control the operations of the find and change commands.
</t>
<t tx="edream.110203163054.835">When checked, the Find and Change commands proceed without stopping.  Output is sent to the log window regarding the progress of the command.
</t>
<t tx="edream.110203163054.836">When checked, the Find and Change commands ignore the case of alphabetic characters when determining matches.
</t>
<t tx="edream.110203163054.837">When checked, the Change command marks all headlines whose headline or body text are changed by the command.
</t>
<t tx="edream.110203163054.838">When checked, the Find and Change commands mark all headlines in which a match is found with the pattern.
</t>
<t tx="edream.110203163054.839">When checked, the Find and Change commands treat several characters specially in the find pattern.  The '*' character matches any sequence of zero or more characters.  The '.' character matches any single character. The '^' character at the start of a pattern, or a '$' character at the end of a pattern matches a newline.

Examples:
The pattern "^abc$" matches lines that only contain "abc".
The pattern "^a" matches any line starting with "A".
The pattern "a$" matches any line ending with "a".
The pattern "^*$" matches any line at all.</t>
<t tx="edream.110203163054.840">When checked, the Find and Change commands search backward through the file.
</t>
<t tx="edream.110203163054.841">When checked, the Find and Change commands search body text.
</t>
<t tx="edream.110203163054.842">When checked, the Find and Change commands search headline text.
</t>
<t tx="edream.110203163054.843">When checked, the Find and Change commands search only the currently selected headline and its offspring.
</t>
<t tx="edream.110203163054.844">When checked, the find pattern must match an entire word.  Words consist of an alphabetic character or underscore, followed by zero or more alphabetic characters, numbers or underscores.
</t>
<t tx="edream.110203163054.845">When checked, the Find and Change commands continues at the top of the file when the command reaches the bottom of the file.  For reverse searches, the find or change command continues at the bottom of the file when the command reaches the top of the file.
</t>
<t tx="edream.110203163054.846">The Go To Line Number command selects the locations in your outlines corresponding to a line in a derived file.  See the child of this node for full details.</t>
<t tx="edream.110203163054.847">New in leo.py 3.11: Insert Body Time/Date and Insert Headline Time/Date
commands. These are in the Edit Body and Edit Headline menus respectively.
These commands insert the formatted time &amp; date into t body or headline text.
You must be editing a headline to be able to insert the time/date into the
headline. If you aren't Leo will say: "Edit headline to append date/time"

Leo allows you to specify your prefered format for time and date using settings
in leoConfig.leo/.txt: body_time_format_string in &lt;&lt; body pane options &gt;&gt; and
headline_time_format_string in &lt;&lt; outline pane options&gt;&gt;

These settings specify the format string passed to time.strftime(format). For a
complete list of the format options see
http://www.python.org/doc/current/lib/module-time.html

If the format specified by either of these two settings is erroneous the
"%m/%d/%Y %H:%M:%S" format is used by default, resulting in a time/date format
like 1/30/2003 8:31:55</t>
<t tx="edream.110203163054.848">The Reformat Paragraph command allows you to easily reformat body text.  See the child of this node for full details.</t>
<t tx="edream.110203163054.849">The Match Brackets command is enabled if the cursor is next to one of the following characters in the body pane:

( ) [ ] { } &lt; &gt;

This command looks for the matching character, searching backwards through the body text if the cursor is next to ) ] } or &gt; and searching forward through the text otherwise.  If the cursor is between two brackets the search is made for the bracket matching the leftmost bracket.

If a match is found, the entire range of characters delimited by the brackets is highlighted and the cursor is placed just to the left of the matching characters.  Thus, executing this command twice highlights the range of matched characters without changing the cursor.</t>
<t tx="edream.110203163054.850">New in leo.py 3.11:  The Preferences Panel now contains a checkbox called "Replace tabs with spaces".  It is no longer necessary to type a negative tab width to indicate that tabs are to be converted to spaces.

New in leo.py 3.0: The Set Colors command brings up a dialog specifying colors for syntax coloring.  You can specify colors for each syntax coloring construct using a color wheel or by choosing one of the standard Tk color names.  When a color becomes active Leo writes its value or color name to the log pane for your reference.  This is useful when setting coloring options in leoConfig.txt.

New in leo.py 3.0:  The Set Font command brings allows you to specify the fonts used in the body pane, the outline pane (in headlines) and in the log pane. A font becomes active when you double-click its name, or check or uncheck any checkbox.  When a font becomes "active", the new font appears in the panes whose check boxes are selected. Font sizes must be greater than 0 and less than 100 for them to become in effect.  When you choose OK or Cancel Leo writes the fonts presently active in each pane to the log pane for your reference.  This is useful when setting font options in leoConfig.txt.

The Preferences command brings up the preferences dialog. The Page Width option determines where Tangle will break lines. The other two global options control whether the Tangle and Untangle commands will execute a batch file when they are finished. The Default Target Language determines the default syntax coloring and the comment delimiters used by default when Tangling.

New in leo.py 2.5, negative tab widths: Leo converts tabs to blanks as you type when a negative tab width is specified.</t>
<t tx="edream.110203163054.851">Leo understands the following PHP keywords:

&lt;?php, ?&gt;, __CLASS__, __FILE__, __FUNCTION__, __LINE__, and,	as, break, case, cfunction, class, const, continue, declare, default, do, else, elseif,  enddeclare, endfor, endforeach, endif, endswitch, endwhile, eval,  extends, for, foreach, function, global, if, new, old_function, or, static, switch, unset(), use, var, while, xor,

Leo does not yet color the following keywords containing():

array(), die(), echo(), empty(), exit(), include(), include_once(), isset(), list(), print(), require(), require_once(), return()</t>
<t tx="edream.110203163054.852">Leo understands the following LaTex keywords: capitalization is significant.  For example, \vert produces a single vertical line and \Vert produces a double vertical line.

\@, \(, \), \{, \},

\acute, \addcontentsline, \addtocontents, \addtocounter, \address,
\addtolength, \addvspace, \AE, \ae, \aleph, \alph, \angle, \appendix, 
\approx,\arabic, \arccos, \arcsin, \arctan, \ast, \author,

\b, \backmatter, \backslash, \bar, \baselineskip, \baselinestretch,
\begin, \beta, \bezier, \bf, \bfseries, \bibitem, \bigcap, 
\bigcup, \bigodot, \bigoplus, \bigotimes, \bigskip, \biguplus, 
\bigvee, \bigwedge,\bmod, \boldmath, \Box, \breve, \bullet,

\c, \cal, \caption, \cdot, \cdots, \centering, \chapter, 
\check, \chi, \circ, \circle, \cite, \cleardoublepage, \clearpage, 
\cline,\closing, \clubsuit, \coprod, \copywright, \cos, \cosh, 
\cot, \coth,csc,

\d, \dag, \dashbox, \date, \ddag, \ddot, \ddots, \decl, 
\deg, \Delta, \delta, \depthits, \det, 
\DH, \dh, \Diamond, \diamondsuit, \dim, \div, \DJ, \dj, 
\documentclass, \documentstyle, \dot, \dotfil, \downarrow,

\ell, \em, \emph, \end, \enlargethispage, \ensuremath, 
\enumi, \enuii, \enumiii, \enuiv, \epsilon, \equation, \equiv,
\eta, \example, \exists, \exp,

\fbox, \figure, \flat, \flushbottom, \fnsymbol, \footnote, 
\footnotemark, \fotenotesize, 
\footnotetext, \forall, \frac, \frame, \framebox, \frenchspacing, 
\frontmatter,

\Gamma, \gamma, \gcd, \geq, \gg, \grave, \guillemotleft, 
\guillemotright,\guilsinglleft, \guilsinglright,

\H, \hat, \hbar, \heartsuit, \heightits, \hfill, \hline, \hom, \hrulefill,\hspace, \huge,\Huge,\hyphenation

\Im, \imath, \include, includeonly, indent, \index, \inf, \infty, \input, \int, \iota,\it, \item, \itshape,

\jmath, \Join,

\k, \kappa, \ker, \kill,

\label, \Lambda, \lambda, \langle, \large, \Large, \LARGE, 
\LaTeX, \LaTeXe, 
\ldots, \leadsto, \left, \Leftarrow, \leftarrow, \lefteqn, \leq,
\lg, \lhd, \lim, \liminf, \limsup, \line, \linebreak, 
\linethickness, \linewidth,\listfiles,
\ll, \ln, \location, \log, \Longleftarrow, \longleftarrow, 
\Longrightarrow,longrightarrow,

\mainmatter, \makebox, \makeglossary, \makeindex,\maketitle, \markboth, \markright,
\mathbf, \mathcal, \mathit, \mathnormal, \mathop,
\mathrm, \mathsf, \mathtt, \max, \mbox, \mdseries, \medskip,
\mho, \min, \mp, \mpfootnote, \mu, \multicolumn, \multiput,

\nabla, \natural, \nearrow, \neq, \newcommand, \newcounter, 
\newenvironment, \newfont,
\newlength,\newline, \newpage, \newsavebox, \newtheorem, \NG, \ng,
\nocite, \noindent, \nolinbreak, \nopagebreak, \normalsize,
\not, \nu, nwarrow,

\Omega, \omega, \onecolumn, \oint, \opening, \oval, 
\overbrace, \overline,

\P, \page, \pagebreak, \pagenumbering, \pageref, \pagestyle, 
\par, \parbox,\paragraph, \parindent, \parskip, \part, 
\partial, \per, \Phi, \phi,\Pi, \pi, \pm, 
\pmod, \pounds, \prime, \printindex, \prod, \propto, \protext, 
\providecomamnd, \Psi,\psi, \put,

\qbezier, \quoteblbase, \quotesinglbase,

\r, \raggedbottom, \raggedleft, \raggedright, \raisebox, \rangle, 
\Re, \ref, \renewcommand, \renewenvironment, \rhd, \rho, \right, 
\Rightarrow,\rightarrow, \rm, \rmfamily,
\Roman, \roman, \rule, 

\s, \samepage, \savebox, \sbox, \sc, \scriptsize, \scshape, 
\searrow, \sec, \section,
\setcounter, \setlength, \settowidth, \settodepth, \settoheight, 
\settowidth, \sf, \sffamily, \sharp, \shortstack, \Sigma, \sigma, 
\signature, \sim, \simeq, \sin, \sinh, \sl, \SLiTeX,
\slshape, \small, \smallskip, \spadesuit, \sqrt, \sqsubset,
\sqsupset, \SS,
\stackrel, \star, \subsection, \subset, 
\subsubsection, \sum, \sup, \supressfloats, \surd, \swarrow,

\t, \table, \tableofcontents, \tabularnewline, \tan, \tanh, 
\tau, \telephone,\TeX, \textbf,
\textbullet, \textcircled, \textcompworkmark,\textemdash, 
\textendash, \textexclamdown, \textheight, \textquestiondown, 
\textquoteblleft, \textquoteblright, \textquoteleft,
\textperiod, \textquotebl, \textquoteright, \textmd, \textit, \textrm, 
\textsc, \textsl, \textsf, \textsuperscript, \texttt, \textup,
\textvisiblespace, \textwidth, \TH, \th, \thanks, \thebibligraphy,
\Theta, theta, 
\tilde, \thinlines, 
\thispagestyle, \times, \tiny, \title,\today, \totalheightits, 
\triangle, \tt, 
\ttfamily, \twocoloumn, \typeout, \typein,

\u, \underbrace, \underline, \unitlength, \unlhd, \unrhd, \Uparrow,
\uparrow,\updownarrow, \upshape, \Upsilon, \upsilon, \usebox,
\usecounter, \usepackage, 

\v, \value, \varepsilon, \varphi, \varpi, \varrho, \varsigma, 
\vartheta, \vdots, \vec, \vector, \verb, \Vert, \vert, \vfill,
\vline, \vphantom, \vspace,

\widehat, \widetilde, \widthits, \wp,

\Xi, \xi,

\zeta</t>
<t tx="edream.110203163054.853"></t>
<t tx="edream.110203163054.854">The Insert Headline command inserts a new headline after the presently selected headline, either as the next sibling or the first child of the presently selected headline if the presently selected headline has children and is expanded.</t>
<t tx="edream.110203163054.855">The Cut Outline, Paste Outline, Copy Outline and Delete Outline commands work on nodes rather than text.  For example, to delete a headline, select the headline and choose the Cut Outline or Delete Outline commands.

The Cut Outline and Copy Outline copy a text representation of the outline to the clipboard.  This representation is the same as the file format with some information deleted.  You may copy this text representation into a body pane (or into any other text editor) using the Paste command in the Edit menu.

To Copy an outline from Borland Leo to leo.py:

1. Copy the tree in Borland Leo.
2. Paste the tree into empty body text of leo.py.
3. Select all the body text and choose Paste from the Edit Menu.
4. Move to the tree view, and choose Paste Node.

Yes, this is clumsy.  I do not as yet know how to read the System clipboard using Tk, so I use the Tk.Text command to read it for me.  Hopefully this unpleasantness will go away soon.

Warning:  In practice, it is almost always wiser to move clones rather than cutting or pasting them.  Cutting and pasting outlines preserves clones, but the links between clones only exist within the part of the outline that was pasted.  Therefore, if you are cutting and pasting an outline containing clones it is best to cut and paste the _entire_ outline.  Alternatively, you can paste part of an outline, then delete all clones.</t>
<t tx="edream.110203163054.856">The Expand command expands the currently selected node so that all its children are visible.  The Expand All Subheads command expands the currently selected node so that all its offspring are visible.  The Expand All command expands all the nodes of the entire tree.

New with leo.py version 1.0 and Borland Leo v2.6:

The Contract Parent contracts the parent node of the present node, making the parent the new present node.</t>
<t tx="edream.110203163054.857">The Move Up, Move Down, Move Left and Move Right commands move the currently selected node in the indicated direction.  The Promote command makes all the children of a node siblings of the node.  The Demote command makes all the siblings that follow a node children of the node.

The Sort Children command sorts all children of the present node in alphabetical order, based on the headlines of the children.

The Sort Siblings command sorts all siblings of the present node in alphabetical order.

New in version 4.1:  The Hoist command redraws the outline making the present node the root node.  The outline itself is unaffected by the Hoist command.  The De-Hoist command removes one level of hoisting.</t>
<t tx="edream.110203163054.858">The Mark Headline command marks a headline with a red marker  near the leader characters, while the Unmark Headline command removes such a mark.  Only one of these commands appear in the Outline menu at any time: the Mark Headline command appears if the currently selected headline is unmarked.  Otherwise, the Unmark Headline command appears.  The Mark Subheads command marks all offspring of the currently selected node.  The Unmark All command removes the marks from the entire tree.

The Mark Changed Items command marks all headlines whose headline or body text has been changed since the file was last saved.  The Mark Changed Roots command marks all changed headlines whose body text contains the @root directive.  This command is especially useful with the Tangle Marked command.</t>
<t tx="edream.110203163054.859"></t>
<t tx="edream.110203163054.860">The Equal Sized Panes command adjusts the sizes of the code and body pane of the topmost window so that they are the same height.
</t>
<t tx="edream.110203163054.861">The Cascade command cleans up the screen by cascading all Leo windows.  The Minimize All command minimizes all Leo windows.</t>
<t tx="edream.110203163054.862">This command changes the pane that is currently active.  If the outline pane was active, the body pane becomes active, and vice versa.  This command makes it possible to switch between panes without using the mouse.</t>
<t tx="edream.110203163054.863">New in leo.py 3.0:  The Toggle Split Direction command switches between vertical and horizontal orientations of the Leo window.  In the vertical orientation, the body pane appears below the pane containing the outline and log panes.  In the horizontal orientation, the body pane appears to the left the pane containing the outline and log panes.

leoConfig.txt specifies the default direction.  If leoConfig.txt does not exist, or does not specify the direction, the "vertical" orientation is used, just as in previous versions.

By default, the ratio of pane outline pane to the body pane is 0.5 in the vertical orientation and 0.3 in the horizontal orientation.  These two ratios may be changed using leoConfig.txt.</t>
<t tx="edream.110203163054.864">The Open Compare Window command opens a dialog that allows you to compare two files.

This is not really a general-purpose file-compare dialog.  The purpose of this window is to show what sentinels a derived file contains.  One file is assumed to contain sentinels, the other file is assumed not to contain sentinels.</t>
<t tx="edream.110203163054.865"></t>
<t tx="edream.110203163054.866">The About Leo command puts up a dialog box showing the version of Leo.
</t>
<t tx="edream.110203163054.867">The Online Home Page command opens Leo's home page at http://personalpages.tds.net/~edream/front.html.

The Open Online Tutorial command opens Joe Orr's excellent ScreenBook tutorial at http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm.

The Open Offline Tutorial command opens the file sbooks.chm if it exists in the folder containing leo.py.  If sbooks.chm does not exist, you will be asked whether you want to download it from Leo's SourceForge web site.  If you say yes, the page http://sourceforge.net/project/showfiles.php?group_id=3458 will open.  You should then download sbooks.sbm to the folder containing leo.py.

The Open LeoDocs.leo command opens this file, leoDocs.leo.

</t>
<t tx="edream.110203163054.868">The Open LeoConfig.leo command opens the file leoConfig.leo, the primary source file for the derived file leoConfig.txt.  Use the Tangle All command to update leoConfig.txt from changes made to leoConfig.leo.

The Apply Settings command applies the settings in leoConfig.txt.  Leo reads these settings when it begins execution, so the only time you would need to use this command is just after changing leoConfig.txt.</t>
<t tx="edream.110203163054.869">@nocolor

This chapter discusses Leo's relationship with traditional literate programming.</t>
<t tx="edream.110203163054.870">The following sections discuss the main benefits of traditional literate programming. It's worth noting that none of these benefits derives from being able to produce printed output.</t>
<t tx="edream.110203163054.871">Sections add a new dimension to the design and coding process. Choices about what sections do, what they are named, what order they appear in, are choices in a design space different from "normal" programming. This an abstract concept, to be sure. However, the following concrete discussions are really manifestation of working in this new design space.</t>
<t tx="edream.110203163054.872">The names of sections are constrained only by one's design skill, not by any rules of language. You say what you mean, and that becomes both the design and the code. You never have to simulate a concept because concepts become section names.</t>
<t tx="edream.110203163054.873">The visual weight of a web section is simply the length and complexity of the section's name, regardless of how complex the actual definition of the section is. The results of this separation are spectacular. No longer is one reluctant to do extensive error handling (or any other kind of minutia) for fear that it would obscure the essence of the program. Donald Knuth stresses this aspect of literate programming and I fully agree.</t>
<t tx="edream.110203163054.874">Sections can show and enforce relationships between apparently unrelated pieces of code. Comments, macros or functions are other ways to indicate such relationships, but often sections are ideal. Indeed, a natural progression is to create sections as a matter of course. I typically convert a section to a function only when it becomes apparent that a function's greater generality outweighs the inconvenience of having to declare and define the function.</t>
<t tx="edream.110203163054.875">A section name is complex when it implies unwholesome dependencies between the caller (user) of the section and the section itself. Such section names tend to be conspicuous, so that the programmer is lead to revise both the section name and its purpose. Many times my attention has been drawn to a poorly conceived section because I didn't like what its name implied. I have always been able to revise the code to improve the design, either by splitting a section into parts or be simplifying its relation to colleagues.</t>
<t tx="edream.110203163054.876">One of the most surprising thing about literate programming is how severely traditional programming tends to limit comments. In a conventional program the formatting of code must indicate structure, and comments obscure that formatting. Sections in literate programming provide a place for lengthy comments that do not clutter up the code at the place the section is referenced.</t>
<t tx="edream.110203163054.877">The section name often says it all. The reference to the section says everything that the user needs to know, and the section name at the point of definition also eliminates the need for many comments.</t>
<t tx="edream.110203163054.878">@nocolor

A typical root starts out with something like.
@color

	&lt;&lt; includes for class x &gt;&gt;
	&lt;&lt; private data for class x &gt;&gt;
	&lt;&lt; private prototypes for class x &gt;&gt;
	&lt;&lt; functions of class x &gt;&gt;

@nocolor
In the derived file there is a comment that looks like this:
@color

	/// &lt;&lt; includes for class x &gt;&gt;

@nocolor
It would be silly to write this comment by hand, though often programmers do just that in order to have a place holder for a mark in the source file. With literate programming the situation is different: the comment indicates that the code came from a particular section; that is, the comment servers a real purpose.
</t>
<t tx="edream.110203163054.879">These last several paragraphs have discussed comments in detail because the net effect of "putting comments where they belong" is that comments don't clutter the code. Section references hide irrelevant detail, so larger-scale patterns within functions (or declarations) become more apparent. Often just recasting code into web format has created Ahas about my own code, with no special attention to recoding or redesign! Recasting a function as a web raises the real and apparent level of abstraction.</t>
<t tx="edream.110203163054.880">Formatting no longer has to indicate overall design; sections do that. I am less obsessive about formatting code; it simply doesn't matter much whether different sections are formatted consistently because the format of one section has no effect on the look of other sections. Also, I don't worry about most line breaks within documentation parts, or about adding comment delimiters.</t>
<t tx="edream.110203163054.881">Outlines add something brand new to traditional literate programming, namely an explicit mechanism for expressing structure at any level of detail, from largest overall view to smallest detail. The following sections elaborate on this theme.</t>
<t tx="edream.110203163054.882">By far the biggest drawback of conventional literate programming is that there are so many sections; it becomes difficult to understand the relationships, if any, between sections. Using an outline to express a literate programming instantly solves this problem. The programmer is always aware of how sections are related.</t>
<t tx="edream.110203163054.883">Outlines provide a convenient way of expressing the intended scope of commands.  For example, the Tangle command operates only on the presently selected tree. The Extract Section command creates a new section as the last child of the present node.</t>
<t tx="edream.110203163054.884">Clones transform a tree into a directed graph without loops. This is a very powerful data structure. Nothing would be gained by cloning an arbitrary directed graph: in general, the clone would simply become the entire tree. Cloning a tree, however, is very effective.

A set of clones becomes essentially a different view of the outline. The set is itself part of the outline, so the outline itself contains an elegant mechanism for representing arbitrarily many views of the same data. It is because of the power of clones that I described MORE in the dedication as possibly the most elegant computer program ever written.

It is easy to create different (and useful) view of a literate outline. For example, I often make clones of all relevant sections of my outline while debugging or adding new features. The clones carry along relevant suboutlines, so essential context is retained, but gathering all the clones together automatically concentrates attention on the problem at hand.</t>
<t tx="edream.110203163054.885">The meaning of a well written literate outline is independent on the order in which sections appear, so outlines may be reorganized at will. In addition, headlines without body text do not affect derived files in any way; such headlines can be inserted freely at any time. In fact, such "nonfunctional" headlines often convey the most information about the structure and design of a large system. Decoupling structure from content in this way is precisely what is needed for flexibility: one can reorganize at will without worrying about changing the meaning of the code.</t>
<t tx="edream.110203163054.886">Hierarchy is often implicit in programming: for example, the grouping of functions into files, or the organization of a single file as a set of functions, etc. An outline directly expresses hierarchy. For example, Leo's tangle or Find and Change commands may be restricted to a particular suboutline. That's a direct expression of an hierarchical constraint or property: I only want to deal with this part of the outline. With outlines, I can do so effortlessly.

Traditional literate programming often simulates the hierarchy using "bridge" comments. Those comments are far weaker than explicit structure. Experience with the Print command clearly shows that a clear literate outline can easily become unintelligible when printed, no matter how "beautiful" the typeset printout is.

My experience shows that organizational crutches such as printed listings, tables of contents and indices are much less clear than the corresponding outline. You could say the entire outline is a table of contents!</t>
<t tx="edream.110203163054.887">There are many ways to express a program as a literate outline. Again, the choices made when doing so are choices in another design space. Such choices are important, and add clarity to the entire program, but can only be expressed when the hierarchy is expressed explicitly.</t>
<t tx="edream.110203163054.888">Tangling and untangling are the fundamental operations of literate programming. Any editor that supports literate programming should provide these operations directly. Moreover, Leo automatically untangles @file trees when reading .leo files and tangles @file trees when writing .leo files.  Eliminating the need for explicit tangling and untangling is a huge improvement.</t>
<t tx="edream.110203163054.889">Leo changes the theory and practice of literate programming as follows:

1. Leo reduces the need for comments within a program. In particular, bridge or transition phrases are almost always unnecessary in a literate outline. One never needs to say something like, "having just finished with topic x, we turn now to topic y." Literate outlines tend to be far less chatty than flat literate programs.

2. Leo shows that printed listings are not necessary to understand noweb or CWEB programs. No printed listing can be as clear as Leo's outline view. It is possible to make printed listings intelligible by adding "context lines" that show the outline context of a section definition. Without such context lines a literate program must rely on extensive bridge comments.

3. Leo shows that simple, standard, yet flexible outline organizations provide a more natural way to organize large programs than narrative organizations. Indeed, narrative style creates severe maintenance problems. The narrative is soon forgotten, and when that happens it becomes difficult to find anything. The few times I have tried narrative organization I soon regretted it: things just weren't where I expected them to be.

4. Leo shows that traditional literate programming encourages a too creative approach to programming. A dictionary is a better model for programs than a novel. Literate outlines provide a more regular organization, while providing space for the most lengthy discussions when those discussions are required.

In short, Leo shows that the phrase "literate programming" is a misnomer. Indeed, chunks or sections, the atoms of literate programming, have little to do with literature. Outlines eliminate the need for narrative. One can use chunks or sections to write narrative prose, but Leo demonstrates that one is under no obligation to do so.</t>
<t tx="edream.110203163054.890">@nocolor
@language python

This chapter documents scripting for Leo.py.  Scripting is always available for leo.py.

This chapter describes only the most useful functions, classes and methods in leo.py.  However, keep in mind the following:

	** Your scripts have complete access to _all_ of Leo's source code **

Therefore, the most complete documentation for scripting is Leo's source code itself, that is, the file LeoPy.leo.  In particular, see the node called "Overview of the Code", the first child of the node called "Code".

You can execute many of the scripts in this chapter by selecting the script and executing the "Execute Script" command.  Note that the print statement will send its output to the console window.</t>
<t tx="edream.110203163054.891">@nocolor
Leo's source code is a collection classes, along with utility functions in leoGlobals.py.

The _application instance_ is a singleton class representing the entire Leo application.  The ivars (instance variables) of this class represent Leo's global variables.

A _commander_ (an instance of the Commands class) represents the operations that can be performed on a _particular_ window.  Each open Leo window has its own commander.

A _frame_ (an instance of the LeoFrame class) contains all the internal data needed to manage a Leo window.

A _vnode_ represents a headline and its associated body text.  vnode methods get and set headline text, body text and properties.

All these classes have ivars that allow code to find all the other classes.  The top() and app() utility functions allow you to find the application instance and the commander of the topmost window.

You can execute this script right now by selecting the script and choosing the "Execute Script" command!  The output from the print command will go to the console.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import app,top
a=app() # The singleton instance.
windows = a.windowList # The list of all open _frames_
for w in windows:
	print w
	print w.commands
	print w.commands.rootVnode()</t>
<t tx="edream.110203163054.892"></t>
<t tx="edream.110203163054.893">@nocolor
The top() function returns the Commands object of the top Leo window.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import top
c = top()
print c
print c.rootVnode()

@nocolor
The windowlist attribute of the application instance contains the list of the frames of all open windows.  The commands ivar of the frame gives the commander for that frame.  Execute this code now with the Execute Script command.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import app
a = app() # get the singleton application instance.
windows = a.windowList # get the list of all open frames.
for f in windows:
	c = f.commands
	print
	print "frame:", f
	print "file name:", f.shortFileName()
	print "commander:", c
	print "root vnode:", c.rootVnode()
</t>
<t tx="edream.110203163054.894">@nocolor
leoGlobal.py defines 6 convenience methods for redirecting stdout and stderr:

- redirectStderr() # Redirect stderr to the current log pane.
- redirectStdout() # Redirect stdout to the current log pane.
- restoreStderr()  # Restores stderr so it prints to the console window.
- restoreStdout()  # Restores stdout so it prints to the console window.
- stdErrIsRedirected() # Returns true if the stderr stream is redirected to the log pane.
- stdOutIsRedirected() # Returns true if the stdout stream is redirected to the log pane.

Calls need _not_ be paired.  Redundant calls are ignored and the last call made controls where output for each stream goes.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import stdErrIsRedirected,stdOutIsRedirected
print "stdout isRedirected:", stdOutIsRedirected()
print "stderr isRedirected:", stdErrIsRedirected()

from leoGlobals import redirectStderr
redirectStderr()

from leoGlobals import stdErrIsRedirected,stdOutIsRedirected
print "stdout isRedirected:", stdOutIsRedirected()
print "stderr isRedirected:", stdErrIsRedirected()

from leoGlobals import redirectStdout
redirectStdout()

from leoGlobals import stdErrIsRedirected,stdOutIsRedirected
print "stdout isRedirected:", stdOutIsRedirected()
print "stderr isRedirected:", stdErrIsRedirected()

from leoGlobals import restoreStderr
restoreStderr()

from leoGlobals import stdErrIsRedirected,stdOutIsRedirected
print "stdout isRedirected:", stdOutIsRedirected()
print "stderr isRedirected:", stdErrIsRedirected()

from leoGlobals import restoreStdout
restoreStdout()

from leoGlobals import stdErrIsRedirected,stdOutIsRedirected
print "stdout isRedirected:", stdOutIsRedirected()
print "stderr isRedirected:", stdErrIsRedirected()

@nocolor
It may be convenient to redirect output in a hook.  This can be done as follows:
@color

if tag == "start1":
	from leoGlobals import redirectStdout,redirectStderr
	redirectStdout() # Redirect stdout
	redirectStderr() # Redirect stderr</t>
<t tx="edream.110203163054.895">@nocolor
The following script shows how to access the data of a Leo window.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import top
c=top()  # get the commander for the topmost outline window.
v=c.currentVnode() # get the current vnode.
print v
print "head:", v.headString()
print "body:", v.bodyString()</t>
<t tx="edream.110203163054.896">@nocolor
The following routines will work whether or not v is the current vnode.  
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import top
c = top() ; v = c.currentVnode()

body = v.bodyString()
print "body:", body
head = v.headString()
print "head:", head

# This won't really anyting because we haven changed body or head.
v.setBodyStringOrPane(body)     # set body text of v to s.
v.setHeadStringOrHeadline(head) # set headline text of v to s.</t>
<t tx="edream.110203163054.897">@nocolor
The following shows how to access all the vnodes of an outline in order.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import top
v=top().rootVnode()
while v:
	# ...do something with v...
	print v
	v=v.threadNext()
</t>
<t tx="edream.110203163054.898">@nocolor
All of Leo's commands update the screen so as to eliminate flicker.  That is, commands cause the outline pane to be redrawn only once.  This is typically done using c.beginUpdate() and c.endUpdate().

c.beginUpdate() suppresses all drawing in the outline pane until the matching c.endUpdate() is seen.  These methods can be nested; each c.beginUpdate() must have a corresponding c.endUpdate().  c.endUpdate takes an optional parameter.  If this parameter is false, no redrawing is done.  This can sometimes be useful; inner code can tell other code whether redrawing is actually required.

c.redraw() forces an update of the entire screen.  c.endUpdate() calls c.redraw() as needed.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import top
c = top()
# Force a screen redraw
c.redraw()
# Typical way to redraw the screen:
c.beginUpdate()
# ...code that alters the screen...
c.endUpdate()
# Typical way to conditionally redraw the screen:
c.beginUpdate()
# ...code sets flag if the screen needs redrawing.
flag = 0
c.endUpdate(flag)</t>
<t tx="edream.110203163054.899">@nocolor
Leo dispatches commands using the frame.doCommand and "Menu Command Handlers" defined in the node by the same name in leoFrame.py.  This node contains the menu handlers for _all_ of Leo's menu commands, organized by menu and submenu.

I recommend that your scripts use frame.doCommand for the following reasons:

- frame.doCommand calls the "command1" and "command2" hook routines for the given label and
- frame.doCommand catches all exceptions thrown by the command.
- the menu commands handles hide a number of implementation details.

For example, try executing this code using the "Execute Script" command:
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import top
c = top() ; f = c.frame
f.doCommand(f.OnMark,label="markheadline") # Executes command and calls hooks.

@nocolor
Your scripts may also call command methods directly, like this:
@color

from leoGlobals import top
top().markHeadline() # Executes the command without calling hooks.

@nocolor
As stated above, the commands handlers in leoFrame.py hide many implementation details involved in involking the various commands.  If you want to invoke commands without calling frame.doCommand, you should study the corresponding menu command handler to see what may be required.

Among these details is this: commanders create subcommanders to handle complex commands:

- The atFile class (leoAtFile.py) reads and writes files derived from @file trees.
- The LeoFind class (leoFind.py) handles the Find and Change commands.
- The leoImportCommands class (leoImport.py) handles the Import and Export commands.
- The tangleCommands class (leoTangle.py) handles the Tangle and Untangle commands.
- The undoer class (leoUndo.py) handles the Undo command.
- All other command are handled by the commander itself (leoCommands.py)
</t>
<t tx="edream.110203163054.900">@nocolor
Your scripts may also get one of the following prefs ivars in a commander.

	c.tangle_batch_flag
	c.untangle_batch_flag
	c.use_header_flag
	c.output_doc_flag
	c.page_width
	c.tab_width
	c.tangle_directory
	c.target_language
	
LeoPrefs.ivars is a list of the _names_ of these ivars.

Each commander maintains its own preferences.
The prefs panel updates its commander's ivars as needed.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import top
from leoPrefs import ivars # Get list of ivars that exist in LeoPrefs class and Commands class.
c = top()
print "\n\nPrefs ivars...\n"
for ivar in ivars:
	exec("val=c."+ivar) # do val = c.ivar
	print "c.%-20s = %s" % (ivar,`val`)
</t>
<t tx="edream.110203163054.901">@nocolor
Your scripts may also set preferences by setting one of the following commands ivars: c.tangle_batch_flag, c.untangle_batch_flag, c.use_header_flag, c.output_doc_flag, c.page_width, c.tab_width, c.tangle_directory, c.target_language.

If the prefs panel is open, your script may call f.prefsPanel.init(c) to update the corresponding prefs panel ivars.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import top
c = top() ; f = c.frame
c.tab_width = 4 # Change this and see what happens.
# If the prefs panel is open, your script may call f.prefsPanel.init(c) to update it.
if f.prefsPanel:
	f.prefsPanel.init(c)
# If your script sets c.tab_width your script may call f.setTabWidth to redraw the screen.
f.setTabWidth(c.tab_width)</t>
<t tx="edream.110203163054.902">@nocolor
The file leoFindScript.py contains functions for finding and changing text from within scripts. The children of this node show two examples of using the functions.  See the @file leoFindScript.py tree in LeoPy.leo for full details.
@color
</t>
<t tx="edream.110203163054.903">@nocolor
The findall function returns a list of tuples (v,pos) describing matches in c's entire tree.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import top,get_line_after
from leoFindScript import findAll

pattern="from leoGlobals import"
result = findAll(top(),pattern,bodyFlag=1)

print "\n\n%-3d instances of: '%s'...\n" % (len(result),pattern)
for v,pos in result:
	body = v.bodyString()
	print '\n%-4d %s' % (pos,v.headString())
	print get_line_after(body,pos)</t>
<t tx="edream.110203163054.904">@nocolor
The reFindall function returns a list of tuples (v,mo,pos), where mo is a "Match Object". The reFlags argument are flags to re.search()
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import top,get_line_after
from leoFindScript import reFindAll

pattern="from .* import"
result = reFindAll(top(),pattern,bodyFlag=1,reFlags=None)

print "\n\n%-3d instances of: '%s'...\n" % (len(result),pattern)
for v,mo,pos in result:
	body = v.bodyString()
	print '\n%-4d %s' % (pos,v.headString())
	print get_line_after(body,pos)
</t>
<t tx="edream.110203163054.905">@nocolor
Most scripts will use the vnode class methods.  The following section summarizes the most useful methods that your scripts can use.  For a complete list, see the @file leoNodes.py tree of LeoPy.leo.
@color</t>
<t tx="edream.110203163054.906">@nocolor
This section lists the most useful vnode methods for getting information from vnodes.
@color

# Returning commanders...
v.commands() # The commander for v.

# Returning vnodes...These may return None.
v.next() # the previous sibling of v.
v.back() # the next sibling of v.
v.firstChild() # the first child of v.
v.lastChild() # the last child of v.
v.lastNode() # the last node of the subtree of which v is the root.
v.nodeAfterTree()  # v.lastNode.threadNext
v.nthChild(n)  # the n'th child of v, starting at index 0.
v.parent()  # the parent node of v.  Level 0 nodes have no parent.
v.threadBack()  # the node before v.
v.threadNext()  # the node after v.
v.visBack() # the visible node before v.
v.visNext() # the visible node after v.

# Returning strings...
v.bodyString() # the body string of v.
v.headString() # the headline string of v.

# Returning ints...
v.childIndex()
v.numberOfChildren()
v.level()

# Returning bools representing property bits...
v.hasChildren()
v.isAncestorOf(v2) # true if v2 is a child, grandchild, etc. of v.
v.isCloned()
v.isDirty()
v.isExpanded()
v.isMarked()
v.isVisible()
v.isVisited()</t>
<t tx="edream.110203163054.907">@nocolor
This section lists the most useful vnode methods that set vnode data or properties.
@color

# Convenience methods for altering headline or body text...
# These work whether or not v is the presently selected node.
v.setBodyTextOrPane(s)       # Sets the body text of v.
v.setHeadStringOrHeadline(s) # Sets the headline text of v.

# Moving nodes...
v.moveAfter(v2)  # move v after v2
v.moveToNthChildOf(v2,n)  # move v to the n'th child of v2
v.moveToRoot()  #  make v the root vnode

# The "visited bit" may be used by commands or scripts for any purpose.
# Many commands use this bits for tree traversal, so these bits do not persist.
c.clearAllVisited() # Clears all visited bits in c's tree.
v.clearVisited()
v.setVisited()
</t>
<t tx="edream.110203163054.908">@nocolor
Here is an example code that uses vnode methods.
@color

# You may execute this code with the "Execute Script" command...

# Returns a list of v's children
def children (v):
	result = []
	child = v.firstChild()
	while child:
		result.append(child)
		child=child.next()
	return result

# Test code.
from leoGlobals import top
c=top() ; v = c.currentVnode()
siblings = children(v.parent())
for sib in siblings:
	print sib</t>
<t tx="edream.110203163054.909">@nocolor
The file leoGlobals.py contains a large number of "utility" functions.  For a list of all these functions, do the following:
@color

# You may execute this code with the "Execute Script" command...

# Print a list of symbols defined in leoGlobals.
import leoGlobals
print "\n\nNames defined in leoGlobals.py...\n"
d = leoGlobals.__dict__
names = d.keys()
names.sort()
for name in names:
	print name

@nocolor
Unless you are familiar with the names of all these functions it may be more comfortable to import just the names you want, like this:
@color

from leoGlobals import app,es,top # And whatever else you want to use.

@nocolor
We have already discussed the app() and top() functions.

true and false are synonyms for True and False (Python 2.2 and later) or 1 and 0 (before Python 2.2).

The es(s) function puts s+'\n' to the log pane.
es(s,newline=false) puts s to the log pane.
@color

# You may execute this code with the "Execute Script" command...
from leoGlobals import es,false
es("Hello World")
es("Hello",newline=false) ; es(" World")

@nocolor
For complete details of all routines defined in leoGlobals.py, see LeoPy.leo.
</t>
<t tx="edream.110203163054.910">@nocolor
@language python

This appendix discusses how you can execute Python scripts in the Borland version of Leo.  It lists all the Python functions, classes and methods that are available in the Borland version of Leo.  The Borland version of Leo creates these using an extension module; they don't happen naturally as is the case in leo.py.

This appendix uses the same terminology and conventions as does Chapter 7 itself.  That is, c represents a commander, v represents a vnode, and s represents a Python string.  In addition, b represents a boolean value.

</t>
<t tx="edream.110203163054.911">For leo.py:

leo.py requires Python 2.1 or later.  Scripting is always available for leo.py.


For Borland versions of Leo:

To use Leo's Python window you must install Python 1.5.2 or later.  Python's installer will place the Python DLL where Leo will find it.  Leo's Python window has been tested only with Python 1.5.2.  It's not clear whether later versions will work.

To open the Python window the following files should exist in the same directory as leo.exe.  These files are part of both the leoNN.zip and leosrcNN.zip.  Note: leosrc.leo is the primary source for these .py files.

leo.py				Makes Leo's commands and data available to Python.
leoEval.py  		Manages Leo's Python window.
wxdb.py				Runs the pdb debugger from Leo's Python window.
sitecustomize.py	Optional site-specific customization called by 
					..\Python\Lib\site.py.</t>
<t tx="edream.110203163054.912">Executing the "Open Python Window" command from Leo's Window menu brings up a window with two panes.  You enter Python source code in the top pane.  Pressing return executes the code in the top pane.  Results are sent to the bottom pane.

To run the standard pdb debugger inside Leo:

1. import wxdb

2. call the wxdb.run, wxdb.runeval and wxdb.runcall routines.  Output goes to the output pane.  Input comes from a modal dialog.  The only way to close this dialog is by typing the quit.</t>
<t tx="edream.110203163054.913"></t>
<t tx="edream.110203163054.914">c = leo.topCommand()

The topCommand() function returns the Commands object of the top Leo window.

For example:

	import leo
	c=leo.topCommand()
	v=c.rootVnode()</t>
<t tx="edream.110203163054.915">@nocolor

[c] = leo.getCommands()

The clist=getCommands() function returns a list of commanders for all open windows.

clist[0] is the commander for the main window, so clist[0].rootVnode() will be None.  Use clist[1:] to get the list of all outline windows. For example:

@color

import leo
clist=leo.getCommands()
for c in clist[1:]:
    root=c.rootVnode()
    name=c.fileName()
    print 'The root of ', name, ' is ', root.headString()
</t>
<t tx="edream.110203163054.916">w = leo.getLeoPyWindow()

The getLeoPyWindow() method returns the interface class for Leo's Python window.  This class contains the following routines:

w.read()
w.readline()
w.setStatus()
w.write()
</t>
<t tx="edream.110203163054.917">@nocolor

The commands class represents the commands for a _particular_ open Leo window.  The following description is organized by the menus in Leo's outline window.  All commands return None; use Commands methods to determine whether an operation may take place _before_ attempting the operation.

The leo.topCommand() function returns the commander for the topmost outline window.  The leo.Commands() function returns a list of commanders for all open outline windows.

The Commands class provides almost all the operations for creating, deleting, moving, cloning vnodes.  The vnode class provides getters for extracting information from vnodes and setters for changing some aspects of vnodes.  When there is a choice, you should use commands in the Commands class; they are safer.

Scripts have no access to Leo's interactive Find/Change commands.  It is easy to write scripts that mimic these commands.  Indeed, these scripts will have the full power of Python's patter matching at their disposal.

@color</t>
<t tx="edream.110203163054.918">@nocolor

c.BeginUpdate() suppresses all drawing until the matching c.EndUpdate() is seen.  These methods can be nested and each c.BeginUpdate() must have a corresponding c.EndUpdate().  Wrapping code in calls to c.BeginUpdate() and c.EndUpdate() eliminates screen flicker.

c.Repaint() forces an update of the entire screen.  This should seldom be necessary since all commands update the screen properly.

c.EndUpdate() calls c.Repaint(), so the typical way to update the screen is simply:

@color
@code
	c.BeginUpdate()
	# code that alters the screen.
	c.EndUpdate()</t>
<t tx="edream.110203163054.919">@code

c.new(windowName)
b=c.open(fileName)
	# returns TRUE if file could be opened or was already open. 
	# brings the window to the front if it has already been opened.
c.close()
b=c.save(fileName)
b=c.saveAs(fileName)
b=c.saveACopyAs(fileName)
c.revert(windowName)

c.tangle()
c.tangleAll()
c.tangleMarked()

c.untangle()
c.untangleAll()
c.untangleMarked()

# fileNames is a list of file names

c.flattenOutline(fileNames)
c.cwebToOutline(fileNames)
c.importFiles(fileNames)
c.importMoreText(fileNames)

c.exportMoreText()  # copies MORE format text to the clipboard
</t>
<t tx="edream.110203163054.920">@code

c.cut
c.copy
c.paste
c.delete
c.selectAll

c.editCurrentHeadline()

c.extract()
c.extractSection()
c.extractSectionNames()
c.convertBlanks()
c.ReformatParagraph()
</t>
<t tx="edream.110203163054.921">@code

c.cutOutline()
c.copyOutline()
c.pasteOutline()
c.deleteHeadline()
c.insertHeadline()
c.clone()

c.contractSubheads()
c.contractAllSubheads()
c.contractAllHeadlines()

c.expandAllHeadlines()
c.expandAllSubheads()
c.expandSubheads()

c.expandLevel1()
c.expandLevel2()
c.expandLevel3()
c.expandLevel4()
c.expandLevel5()
c.expandLevel6()
c.expandLevel7()
c.expandLevel8()
c.expandLevel9()
c.expandNextLevel()

c.moveOutlineLeft()
c.moveOutlineRight()
c.moveOutlineUp()
c.moveOutlineDown()

c.promote()
c.demote()

c.selectThreadBack()
c.selectThreadNext()
c.selectVisBack()
c.selectVisNext()

c.markHeadline()
c.markSubheads()
c.markChangedHeadlines()
c.markChangedRoots()
c.unmarkAll()

c.goToNextDirtyHeadline()
c.goToNextMarkedHeadline()
</t>
<t tx="edream.110203163054.922">@code

c.equalSizedPanes()
</t>
<t tx="edream.110203163054.923">@nocolor

The following routines all return true if the corresponding Menu command should be enabled.  The actual menu commands themselves silently do nothing if they are called when the corresponding canXXX routines returns false.

@color

b=canContractAllHeadlines()
b=canContractAllSubheads()
b=canContractSubheads()
b=canCutOutline()
b=canDeleteHeadline()
b=canDemote()
b=canExpandAllHeadlines()
b=canExpandAllSubheads()
b=canExpandSubheads()
b=canExtractSection()
b=canExtractSectionNames()
b=canGoToNextDirtyHeadline ()
b=canGoToNextMarkedHeadline()
b=canMarkChangedHeadlines()
b=canMarkChangedRoots()
b=canMoveOutlineDown()
b=canMoveOutlineLeft()
b=canMoveOutlineRight()
b=canMoveOutlineUp()
b=canPasteOutline()
b=canPromote()
b=canRevert()
b=canSelectVisBack()
b=canSelectVisNext()
b=canSelectThreadBack()
b=canSelectThreadNext()
b=canSelectToEnd()
b=canSelectToStart()
b=canShiftBodyLeft()
b=canShiftBodyRight()
b=canUndo()
b=canUnmarkAll()</t>
<t tx="edream.110203163054.924">@nocolor
These utilities are important.  There is no need to call them when using Leo's own commands, and they will come in handy when creating your own commands.
@color

Drawing utilities...

c.BeginUpdate() # suppress screen updates.
c.EndUpdate() # enable screen updates and redraw the screen.
c.Repaint() # force the screen to be redrawn

@nocolor
Enclose code in BeginUpdate/EndUpdate pairs to inhibit drawing while the screen is being changed.  BeginUpdate/EndUpdate may be nested and each BeginUpdate must be matched with a corresponding EndUpdate call.  EndUpdate calls Repaint automatically.  You can call Repaint to force the screen to be updated immediately though all commands repaint the screen properly.  c.bringToFront() brings the window corresponding to the command class to the front.  A later leo.topCommand() will return c.
@color

Getters...

v=c.currentVnode() # The currently selected vnode or None.
v=c.rootVnode() # The first vnode of the outline or None.
b=c.isChanged() # True if the outline has been changed since it was saved.
s=c.fileName() # The file to which the Save command will write the window.  May be "Untitled"

Setters...

c.bringToFront() # Bring the window to the front. see leo.topCommand().
c.clearAllVisited() # Clear all "visited" bits.
c.editVnode(v) # Enter editing mode for v's headline.
c.endEditing(v) # End editing mode for v's headline.
c.makeVisible(v) # Expand outline if necessary to make v visible.
c.selectVnode(v)  # Make v the presently selected vnode.
c.synchVnode()  # No longer used.  Retained for compatibility with old scripts.
</t>
<t tx="edream.110203163054.925">@nocolor

This class exists to handle the interaction between the Python interpreter and Leo's Python window.  Scripts would typically not use this class.

@color

w=leo.getLeoPyWindow()
	# get the interaction class.
s=w.read()
	# Return what the user has _already_ typed.
	# This is used to start the Python interpreter
s=w.readline()
	# Put up a modal dialog to get input and return what the user types.
	# It is not possible to break out of this dialog.
	# This routine is called by the pdb debugger.
w.setStatus(n)
	# Called by leoEval.py to control how Leo's Python window works.
	# n=0: normal input of Python text.
	# n=1: continuation input.
	# n=2: immediate exit (not used).
	# n=3: call readline to get stdin input.
w.write(s)
	# Writes s to the output pane of the Python window.</t>
<t tx="edream.110203163054.926">@nocolor

This class provides access to the Preference settings and the contents of the log window.

@color

Getters...

p = leo.getPrefs() # returns instance of the Prefs class

b=p.defaultTangleDirectory()
b=p.doLeoDoneBat()
b=p.doLeoUnBat()
s=p.logWindowString() # returns contents of log window
n=p.pageWidth()
b=p.tangleOutputsHeaderLine()
b=p.tangleOutputsDocChunks()

Setters...

p.setDefaultTangleDirectory(s)
p.setDoLeoDoneBat(b)
p.setDoLeoUnBat(b)
p.setPageWidth(n)
p.setTangleOutputsHeaderLine(b)
p.setTangleOutputsDocChunks(b)</t>
<t tx="edream.110203163054.927">@nocolor

The vnode class represents a node containing headline text, body text and various properties.

@color</t>
<t tx="edream.110203163054.928">@nocolor

This section lists all the methods that return data and properties of vnodes.

Returning commanders...

The following method is quite handy.  It allows us to avoid passing commanders as arguments to vnode methods.  For example, we can call
v.commands().synchNode()

@color

c=v.commands() # The commands object for the window containing v.

@nocolor

Returning vnodes...
These may return None.  Be warned.

@color

v=v.next() # the previous sibling of v.
v=v.back() # the next sibling of v.
v=v.currentVnode() # the presently selected vnode.
v=v.findRoot() # the root vnode.
v=v.firstChild() # the first child of v.
v=v.lastChild() # the last child of v.
v=v.lastNode() # the last node of the subtree of which v is the root.
v=v.nodeAfterTree()  # v.lastNode.threadNext
v=v.nthChild(n)  # the n'th child of v, starting at index 0.
v=v.parent()  # the parent node of v.  Level 0 nodes have no parent.
v=v.threadBack()  # the node before v.
v=v.threadNext()  # the node after v.
v=v.visBack() # the visible node before v.
v=v.visNext() # the visible node after v.

Returning Python strings...

s=v.bodyString()  # the body string of v.
	# Warning:  this string may not match the body text if
	# v is the current vnode.  Call c.synchVnode to make sure it does.
s=v.convertTreeToString()  # Converts v's subtree to an ascii string.
s=v.headString() # the headline string of v.

# These two are of limited use: they are called by c.convertTreeToString().
s=v.moreBody()  # the body text of v in MORE format.
s=v.moreHead(n)  # n = the first level of the converted string

Returning Python (short) ints...

n=v.childIndex()
n=v.numberOfChildren()
n=v.level()

@nocolor

Returning bools representing property bits...
Only the "visited" bit may be altered directly by scripts.

@color

b=v.hasChildren()
b=v.isAncestorOf(v2) # true if v2 is a child, grandchild, etc. of v.
b=v.isCloned()
b=v.isDirty()
b=v.isExpanded()
b=v.isMarked()
b=v.isVisible()
b=v.isVisited()</t>
<t tx="edream.110203163054.929">@nocolor

This section lists all vnode methods that set vnode data or properties.

Altering headline or body text...

@color

v.setBodyTextOrPane(s)
	# Sets the body text of v, whether or not v is the current node.
v.setHeadStringOrHeadline(s)
	# Replaces the headline text of v, whether or not v is the current node.
v.trimTrailingLines()  # Removes all blanks lines from v.
	# Warning: will not work if v is the current vnode.

Moving nodes..

v.moveAfter(v2)  # move v after v2
v.moveToNthChildOf(v2,n)  # move v to the n'th child of v2
v.moveToRoot()  #  make v the root vnode

@nocolor

Redraws v's icon.  This is usually done automatically.

v.setIcon()

The "visited bit" may be used by commands or scripts for any purpose.  Commands use this bits for tree traversal.  See also: c.clearAllVisited()

v.clearVisited()
v.setVisited()
</t>
<t tx="edream.110203163054.930">This chapter discusses the history of Leo and its various incarnations.  A large part of this chapter discusses the process by which I discovered how to implement @file trees.</t>
<t tx="edream.110203163054.931">Leo grew out of my efforts to use Donald Knuth's "CWEB system of Structured documentation."  I had known of literate programming since the mid 1980's, but I never understood how to make it work for me: I was confused about when to create new sections and it was difficult to keep track of all the sections once they were created.

In November 1995 I started thinking about literate programming in earnest.  Over the holidays I mused about making literate programs more understandable.  In January 1996 the fog of confusion suddenly cleared.  I summarized my thinking with the phrase, "Webs are outlines in disguise".  I strongly suspected that outline views were the key to literate programming, but many details remained obscure.  It still wasn't clear exactly how to represent webs in an outline.

March 5, 1996, is the most important date in Leo's history.   While returning from a day of skiing, I discussed my thoughts with Rebecca.  During that conversation I realized that I could use the MORE outliner as a prototype for a "literate outliner." I immediately started work on my first literate outline. It quickly became apparent that outlines work: all my old problems with literate programming vanished.   Furthermore, I realized that MORE's outlines could form the basis for Leo's screen design. Rather than opening body text within the outline, as MORE does, I decided to use a separate body pane.

In about a week I hacked a translator called M2Cwhich allowed me to use MORE to write real code.  I would write code in MORE, copy the text to the clipboard in MORE format, then run M2C, which would tangle the outline into C code.  This process was useful, if clumsy.  I called the language used in the outline SWEB, for simplified CWEB.  Much later I converted to the noweb language. noweb is simpler than SWEB, more standard and more general.</t>
<t tx="edream.110203163054.932">Throughout 1996 I created a version of Leo on the Macintosh in plain C and the native Mac Toolbox.   This was a poor choice; I wasted a huge amount of time programming with these primitive tools.  However, this effort convinced me that Leo was a great way to program.

Late in 1997 I wrote a Print command to typeset an outline. Printing (Weaving) is supposedly a key feature of literate programming.  Imagine my surprise when I realized that such a "beautiful" program listing was almost unintelligible; all the structure inherent in the outline was lost!  I saw clearly that typesetting, no matter how well done, is no substitute for explicit structure.

Starting in May of 1998 I began work on a version of Leo using objective C and Apple's Yellow Box environment.  In some ways, this was the most powerful version of Leo.  Alas, a year later Apple chose not to support Yellow Box on Windows, so I had to begin again.  I was most unhappy.

In May of 1999 I began work on the Borland version of Leo for Windows.  This version was successful, and I continue to support the Windows/Borland version to the present day.  The Borland Delphi classes are a pleasure to use and free of bugs.  I redesigned Leo's file format for the Windows version of Leo;  the Yellow Box file format is a binary format that requires the Yellow Box runtime.  Fortunately, I choose to use XML for Leo's file format. I have Marc-Antoine Parent to thank for this decision; he urged me to use XML and patiently explained how to use XML properly.  However, there are two significant problems with the Borland version of Leo.  First, it works only on Windows.  Second, it can never be Open software, because it uses Borland's Delphi classes and a commercial syntax coloring component.

In May of 2000 I began work an wxWindows version of Leo.  This was supposed to be a cross-platform version.  Alas, after much work I chose to abandon the wxWindows version.  There were too many bugs and too many incompatibilities between platforms.  Something good did come from this effort.  I spent a lot of time adding Python scripting to the wxWindows code and I became familiar with Python and its internals.

In October of 2001 I began work on the leo.py, an Open Software version of leo.py, a version of Leo written in Python and Tk.  At last I have found the proper platform for Leo.  leo.py naturally supports scripting in Python.  The combination of Python and Tk is incredibly powerful, very easy to use, and truly cross platform.  I rewrote Leo in Python in about two months!  For the first time in my career I no longer am anxious while programming; it simply isn't possible to create bad bugs in Python.</t>
<t tx="edream.110203163054.933">The following sections give a pseudo-chronological list of the major Aha's involved in creating Leo2. These Aha's form the real design and theory of operation of Leo. See the "Diary", "Notes" and "Letters to Speed Ream" sections in LeoDocs.leo for a more accurate and less tidy history of Leo2.

I am writing these notes for several reasons.  First, the initial design and coding of Leo2, spanning a period of about 8 weeks, was some of the most creative and rewarding work I have ever done. The result is elegant and simple.  I'm proud of it.  Second, much of the design work is not reflected in the code, because improved design often eliminated code entirely. The final code is so elegant that it obscures the hard work that created it.  Third, you must understand this design in order to understand the implementation of @file trees and their derived files.  Someday someone else may take charge of Leo. That person should know what really makes Leo2 work.</t>
<t tx="edream.110203163054.934">In the summer of 2001 I began work on a project that for a long time I had considered impossible.  I had long considered that "private" file formats such as .leo files were the only way to represent an outline properly and safely.  I'm not sure exactly what changed my mind, but I finally was willing to consider that information embedded in derived files might be useful.  This meant accepting the possibility that sentinel lines might be corrupted.  This was a crucial first step.  If we can trust the user not to corrupt sentinel lines than we can embed almost any kind of information into a derived file.

There were several motivations for this work.  I wanted to eliminate the need for explicit Tangle and Untangle commands. I thought of this as "Untangle on Read/Tangle on Write."  If tangling and untangling could be made automatic it would save the user a lot of work.  I also wanted to make derived files the primary sources files.  .leo files might be made much smaller derived files contained the primary source information. This hope turned out to be false.

The result of this design work was something I originally called Leo2, though I now usually prefer to talk about @file trees.  Initially most design issues were unresolved or unknown. I resolved to attempt a robust error-recovery scheme, not knowing in advance what that might involve. I also wanted to solve what I thought of as the "cross-file clone" problem: clones that point from a .leo outline into a derived file. With Leo1 cross-file clones do not exist; everything is in the same .leo file. It was clear that Leo2 would have to change some aspects of clones, but all details were fuzzy.
</t>
<t tx="edream.110203163054.935">The next step was also crucial.  I started to use Leo1 as a prototype to design what the new body pane would look like to the user. In retrospect, using Leo1 as a prototype for Leo2 was just as inspired as using MORE as a prototype for Leo1.  Both prototypes marked the true beginning of their respective projects.  The Leo2 prototype was a mockup in Python of the code for reading and writing derived files. The file LeoDocs.leo contain these first prototype nodes.

Writing the prototype got me thinking about improving noweb.  With my experience with Leo1, I was able to create a new markup language that took advantage of outline structure.  I called the new language  "simplified noweb", though that terminology is obsolete.  I created @file nodes to distinguish between the old and new ways of creating derived files.  In Leo1, the @code directive is simply an abbreviation for a section definition line.  Simplified noweb used @c as an abbreviation for @code.  More importantly, simplified noweb used @c to separate doc parts from code parts without necessarily specifying a section name.  It quickly became apparent that most nodes could be unnamed.  All I needed was the @others directive to specify the location for all such unnamed nodes.

From the start, simplified noweb was a joy to use. Indeed, the @others directive could replace all section definition lines.  Furthermore, I could make @doc directive optional if the body pane started in "code mode".  But this meant that plain body text could become a "literate" program! This was an amazing discovery.  These Aha's got me excited about Leo2. This was important, as it motivated me to do a lot of difficult design work.</t>
<t tx="edream.110203163054.936">In spite of this excitement, I was uneasy. After much "daydreaming" I realized that I was afraid that reading and writing derived files would be interrupted by a long series of alerts. I saw that designing the "user interaction" during reading and writing would be very important. The next Aha was that I could replace a long series of alerts with messages to the log window, followed by a single "summary" alert. Much later I saw how to eliminate alerts entirely.

At this time I thought there would be two kinds of "errors" while reading derived files. Warnings would alert the user that something non-serious had happened. True errors would alert the user that data might have been lost. Indeed, if Leo2 saves orphan and ignored nodes in a .leo file under an @file node, then read errors could endanger such nodes. Much later I saw that a robust error recovery scheme demands that @file nodes not contain orphan and @ignored nodes. (More on this subject later.) But if orphan and @ignored nodes are moved out of @file trees, there are no read errors that can cause data loss! So the distinction between warnings and errors finally went away.</t>
<t tx="edream.110203163054.937">I next turned my attention to writing @file nodes.  A huge Aha: I realized that sentinel lines must contain both a leading and a trailing newline.  The general principle is this: the write code must contain absolutely no "conditional" logic, because otherwise the read code could not figure out whether the condition should be true or false.  So derived files contain blank lines between sentinel lines. These "extra" newlines are very useful, because the read (untangle) code can now easily determine exactly where every blank, tab and newline of the derived file came from.  It would be hard to overstate how important this simplifying principle was in practice.

Much later, with urging from a customer, I realized that the write code could safely remove "extra" newlines between sentinels with a caching scheme in the low level atFile::os() routine. This scheme does not alter the body of the write code in any way: in effect, sentinels still contain leading and trailing "logical" newlines. The read code had to be modified to handle "missing" leading newlines, but this can always be done assuming that sentinels still contain logical leading and trailing newlines!

At about this time I designed a clever way of having the write code tell the read code which newlines were inserted in doc parts. (The whole point of doc parts is to have the write code format long comments by splitting long lines.) To quote from my diary:

"We can use the following convention to determine where putDocPart has inserted line breaks: A line in a doc part is followed by an inserted newline if and only if the newline is preceded by whitespace. This is a really elegant convention, and is essentially invisible to the user.
Tangle outputs words until the line would become too long, and then it inserts a newline. To preserve all whitespace, tangle always includes the whitespace that terminates a word on the same line as the word itself. Therefore, split lines always end in whitespace. To make this convention work, tangle only has to delete the trailing whitespace of all lines that are followed by a 'real' newline."

</t>
<t tx="edream.110203163054.938">After the write code was working I turned my attention to the read (untangle) code.  Leo's Untangle command  is the most complex and difficult code I have ever written. Imagine my surprise when I realized that the Leo2 read code is essentially trivial! Indeed, the Leo2 untangle code is like an assembler. The read code scans lines of a derived files looking for "opcodes", that is, sentinel lines, and executes some simple code for each separate opcode. The heart of this code is the scanText routine in atFile.cpp.

The read code was written and debugged in less than two days! It is the most elegant code I have ever written. While perfecting the read code I realized that sentinel lines should show the complete nesting structure found in the outline, even if this information seems redundant. For example, I was tempted to use a single sentinel to represent an @other directive, but finally abandoned this plan in favor of the @+other and @-other sentinels.

This redundancy greatly simplified the read code and made the structure of derived files absolutely clear. Moreover, it turned out that we need, in general, all the information created by the present sentinel lines. In short, sentinels are as simple as they can be, and no simpler.

The atFile::createNthChild method is a very important: it ensures that nodes will be correctly inserted into the outline. createNthChild must be bullet-proof if the Read code is to be robust. Note that the write code outputs @node sentinels, that is, section definitions, in the order in which sections are referenced in the outline, not the order in which sections appear in the outline. So createNthChild must insert the n'th node of parent p properly even if p contains fewer than n-1 children! The write code ensures that section references are properly nested: @node sentinels are enclosed in @node sentinels for all their ancestors in the @file tree. createNthChild creates dummy siblings as needed, then replaces the dummy siblings later when their actual definitions, that is, @node sentinels, are encountered.

At this point the fundamental read/write code was complete. I found three minor bugs in the code over the next week or so, but it was clear that the read/write code formed a rock-solid base from which to continue design and implementation. This was an entirely unexpected surprise.</t>
<t tx="edream.110203163054.939">At this point I could read and write derived files "by hand", using temporary Read and Write commands. The next step was to integrate the reading and writing of derived files with the loading and saving of .leo files.  From time to time I made minor changes to the drivers for the read/write code to accommodate the Load and Save code, but at no time did I significantly alter the read or write code itself.

The user interaction of the Load and Save commands drove the design and implementation of the load/store code. The most important questions were: "what do we tell the user?", and "what does the user do with the information?" It turns out that the user can't make any complex decision during error recovery because the user doesn't have nearly enough information to make an informed choice. In turn, this means that certain kinds of error recovery schemes are out of the question...</t>
<t tx="edream.110203163054.940">I now turned my attention to "attributes" of nodes.  Most attributes, like user marks, are non-essential. However, clone information is essential; we must never lose clone links. At this time I had a preliminary design for cross-file clones that involved a two part "pointer" consisting of a full path name and an immutable clone index within the derived file. Eventually such pointers completely disappeared, but the immutable clone indices remain.

My first thought was that it would be good to store all attributes in @node sentinels in the derived file, but experience showed that would be irritating. Indeed, one wants Leo2 to rewrite derived files only if something essential has changed. For example, one doesn't want to rewrite the derived file just because a different node as been selected.

At this point I had another Aha: we can use the .leo file to store all non-essential attributes. For example, this means that the .leo file, not the derived files, will change if we select a new node. In effect, the .leo file mirrors the derived file. The only reason to store nodes in the .leo file under an @file node is to carry these attributes, so Leo2 wrote dummy nodes that do not reference body text.  Much later I saw that dummy nodes were dangerous and that .leo files should contain all information found in derived files.</t>
<t tx="edream.110203163054.941">The concept of mirroring created a huge breakthrough with cross-file clones: Here is an excerpt of an email i sent to my brother Speed:

"I realized this morning that since a .leo file contains dummy vnodes for all nodes in a derived file, those dummy nodes can carry clone info! I changed one line to make sure that the write code always writes clone info in dummy vnodes and voila! Cross-file clones worked!"

All of Leo1's clone code could be used completely unchanged. Everything "just works".</t>
<t tx="edream.110203163054.942">At first I thought we could make sure that the .leo file always correctly mirrors all derived file, but disastrous experience showed that is a completely false hope. Indeed, backup .leo files will almost never mirror derived file correctly. So it became urgent to find a completely fool-proof error recovery scheme.

I had known for quite a while that error recovery should work "as if" the mirroring nodes were deleted, then recreated afresh. Several failed attempts at an error recovery scheme convinced me that error recovery would actually have to delete all dummy nodes and then do a complete reread. This is what Leo2 does.

But erasing dummy nodes would destroy any orphan and ignored nodes--by definition such nodes appear nowhere in the derived file. Therefore, I had to enforce the rule that @file nodes should contain no such nodes. Here is an email I wrote to my brother, Speed Ream discussing what turned out to be the penultimate error recovery scheme:

"The error recovery saga continues. After much pondering and some trial coding I have changed my mind about orphans and @ignored nodes. They simply should never appear as descendants of @file nodes. Fortunately, this simplifies all aspects of Leo2.
Leo2 will issue a warning (not an error) if an orphan or @ignored node appears as the descendant of an @file node when a .leo file is being saved. If any warnings occur while writing the derived file, Leo2 will write the "offending" @file tree to the .leo file instead of the derived file. This has several advantages:

1.	The user gets warned about orphan nodes. These are useful warnings! Orphan nodes arise from missing @others directives or missing section references.

2. The user doesn't have to change anything immediately in order to save an outline. This is very important. Besides warnings about orphans, Leo2 will also warn about undefined or unreferenced sections. User's shouldn't have to fix these warnings to do a Save!

3. No errors or alerts will occur during Reading or Writing, so the user's anxiety level goes way down. At worst, some informational message will be sent to the log. The user will never have to make important decisions during Loads or Saves. [At last the dubious distinction between errors and warnings disappears.]

4. Error recovery can be bullet-proof. Simple code will guarantee that after any read operation the structure of an @file node will match the structure of the derived file. Also, sentinels in derived files will now account for all children of an @file node. There are no more "missing nodes" that must be filled in using the .leo file. Finally, error recovery will never change the @file tree in any way: no more "recovered nodes" nodes.

5. The present read code can be used almost unchanged. The only addition is the posting of a warning if the structure of the .leo file does not match the structure of the derived file. We need a warning because non-essential attribute of nodes (like user marks) may be altered."

This ends the original history of Leo2. In fact, it took quite a while before Leo recovered properly from all errors. I finally saw that .leo files should duplicate all information in derived files. This allows a .leo file to be used a single backup file and allows maximal error recovery in all situations.  It took several months to stamp out several subtle bugs involving clones that caused spurious read errors. Such errors undermine confidence in Leo and can cause disastrous reversions. See my diary entries for January 2002 in leo.py for details.

</t>
<t tx="edream.110203163054.943">This chapter discusses how Leo's code works, paying particular attention to topics that have caused difficulties in design or implementation.  This information will be of use primarily to those wanting to change Leo's code.  The previous chapter contains a full discussion of how Leo reads and writes @file trees.</t>
<t tx="edream.110203163054.944">This documentation describes leo.py. Other versions of Leo are similar in design; the differences between versions are generally not interesting enough to describe here.

All versions of Leo are organized as a collection of classes.  The general organization of Leo has remained remarkably stable throughout all versions of Leo, although the names of classes are different in different versions. Smalltalk's Model/View/Controller terminology is a good way to organize Leo's classes conceptually.

Model classes represent the fundamental data. The vnode and tnode classes are Leo's primary model classes.

View classes draw the screen. The main view classes are leoFrame.py and leoTree.py.  The colorizer class in leoColor.py handles syntax coloring in the body pane. In leo.py, the view classes know about data stored in the vnode class. Most events (keystrokes and mouse actions) in the outline and body pane are handled in the leoTree class. The leoFrame class also creates the Leo window, including menus, and dispatches the appropriate members of the controller classes in response to menu commands.

Controller classes (aka commanders) control the application. In Leo, controllers mostly handle menu commands. In leo.py, the Commands class creates subcommanders to handle complex commands. The atFile class reads and writes files derived from @file trees. The LeoFind class handles the Find and Change commands. The leoImportCommands class handles the Import and Export commands, the tangleCommands class handles the Tangle and Untangle commands and the undoer class handles the Undo command. Other classes could be considered controller classes.

Each Leo window has its own commander and subcommanders. Subcommanders are not subclasses of their commander. Instead, subcommanders know the commander that created them, and call that commander as needed. Commanders and subcommanders call the model and view classes as needed. For example, the Commands class handles outline commands. To move a headline, the commander for the window calls a vnode move routine to alter the data, then calls the view class to redraw the screen based on the new data.

A singleton instance of the LeoApp class represents the application itself. All code uses the app() global function to gain access to this singleton member. The ivars of the LeoApp object are the equivalent of Leo's global variables. leo.py uses no global Python variables, except the gApp variable returned by app(). leoGlobals.py defines all application constants.  Naturally, most constants are local to the class that uses them.

Several classes combine aspects of model, view and controller. For example, the LeoPrefs class represents user preferences (model), the Preference Panel (view) and the Preferences menu command (controller). Similarly, the LeoFind class represents find settings, the Find/Change dialog, and the Find/Change commands.

We use the following convention throughout this documentation. Any variable named c is a commander, i.e., an instance of the Commands class in leoCommands.py. Variables named v and t are vnodes and tnodes respectively. These classes are defined in leoNode.py.
</t>
<t tx="edream.110203163054.945">The vnode and tnode classes represent most of the data contained in the outline. These classes are Leo's fundamental Model classes.

A vnode (visual node) represents a headline at a particular location on the screen. When a headline is cloned, vnodes must be copied. vnodes persist even if they are not drawn on the screen. Commanders call vnode routines to insert, delete and move headlines.

The vnode contains data associated with a headline, except the body text data which is contained in tnodes. A vnode contains headline text, a link to its tnode and other information. In leo.py, vnodes contain structure links: parent, firstChild, next and back ivars. To insert, delete, move or clone a vnode the vnode class just alters those links. The Commands class calls the leoTree class to redraw the outline pane whenever it changes. The leoTree class knows about these structure links; in effect, the leoTree and vnode classes work together. The implementation of vnodes is quite different in the Borland version of Leo. This does not affect the rest of the Leo. Indeed, vnodes are designed to shield Leo from such implementation details.

A tnode, (text node) represents body text: a tnode is shared by all vnodes that are clones of each other. In other words, tnodes are the unit of sharing of body text. The tnode class is more private than the vnode class. Most commanders deal only with vnodes, though there are exceptions.

Because leo.py has unlimited Undo commands, vnodes and tnodes can be deleted only when the window containing them is closed. Nodes are deleted indirectly. Several classes, including the vnode, tnode, leoFrame and leoTree classes, have destroy() routines. These destroy() routines merely clear links so that Python's and Tkinter's reference counting mechanisms will eventually delete vnodes, tnodes and other data when a window closes.

Leo uses several kinds of node indices. Leo's XML file format uses tnode indices to indicate which tnodes (t elements) belong to which vnodes (v elements). Such indices are required. Even if we duplicated the body text of shared tnodes within the file, the file format would still need an unambiguous way to denote that tnodes are shared.

Present versions of Leo recompute these tnodes indices whenever Leo writes any .leo file. Earlier versions of Leo remembered tnode indices and rewrote the same indices whenever possible. Those versions of Leo recomputed indices when executing the Save As and Save To commands, so using these commands was a way of "compacting" indices. The main reason for not wanting to change tnode indices in .leo files was to reduce the number of changes reported by CVS and other Source Code Control Systems. I finally abandoned this goal in the interest of simplifying the code. Also, CVS will likely report many differences between two versions of the same .leo file, regardless of whether tnode indices are conserved.

A second kind of node index is the clone index used in @+node sentinels in files derived from @file trees. As with indices in .leo files, indices in derived files are required so that Leo can know unambiguously which nodes are cloned to each other.

It is imperative that clone indices be computed correctly, that is, that tnode @+node sentinels have the same index if and only if the corresponding vnodes are cloned. Early versions of leo.py had several bugs involving these clone indices. Such bugs are extremely serious because they corrupt the derived file and cause read errors when Leo reads the @file tree. Leo must guarantee that clone indices are always recomputed properly. This is not as simple as it might appear at first. In particular, Leo's commands must ensure that @file trees are marked dirty whenever any changed is made that affects cloned nodes within the tree. For example, a change made outside any @file tree may make several @file trees dirty if the change is made to a node with clones in those @file trees.</t>
<t tx="edream.110203163054.946">@nocolor

Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.  The main challenges are eliminating flicker and handling events properly.  These topics are interrelated.

Eliminating flicker.  Leo must update the outline pane with minimum flicker.  Various versions of Leo have approached this problem in different ways.  The drawing code in leo.py is robust, flexible, relatively simple and should work in almost any conceivable environment.

Leo assumes that all code that changes the outline pane will be enclosed in matching calls to the c.beginUpdate and c.endUpdate  methods of the Commands class. c.beginUpdate() inhibits drawing until the matching c.endUpdate().  These calls may be nested; only the outermost call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.

In leo.py, code may call c.endUpdate(flag) instead of c.endUpdate().  Leo redraws the screen only if flag is true.  This allows code to suppress redrawing entirely when needed.  For example, here is how the idle_body_key event handler in leoTree.py conditionally redraws the outline pane:

@language python
@color
	redraw_flag = false
  	c.beginUpdate()
	val = v.computeIcon()
	if val != v.iconVal:
		v.iconVal = val
		redraw_flag = true
	c.endUpdate(redraw_flag) # redraw only if necessary
@nocolor

The leoTree class redraws all icons automatically when c.redraw() is called.  This is a major simplification compared to previous versions of Leo.  The entire machinery of drawing icons in the vnode class has been eliminated.  The v.computeIcon method tells what the icon should be.  The v.iconVal ivar that tells what the present icon is. The event handler simply compares these two values and sets redraw_flag if they don't match.

Handling events. Besides redrawing the screen, Leo must handle events or commands that change the text in the outline or body panes.  It is surprisingly difficult to ensure that headline and body text corresponds to the vnode and tnode corresponding to presently selected outline, and vice versa. For example, when the user selects a new headline in the outline pane, we must ensure that 1) the vnode and tnode of the previously selected node have up-to-date information and 2) the body pane is loaded from the correct data in the corresponding tnode.  Early versions of Leo attempted to satisfy these conditions when the user switched outline nodes.  Such attempts never worked well; there were too many special cases.  Later versions of Leo, including leo.py, use a much more direct approach.  The event handlers make sure that the vnode and tnode corresponding to the presently selected node are always kept up-to-date.  In particular, every keystroke in the body pane causes the presently selected tnode to be updated immediately.  There is no longer any need for the c.synchVnode method, though that method still exists for compatibility with old scripts.

The leoTree class contains all the event handlers for the body and outline panes.  The actual work is done in the idle_head_key and idle_body_key methods.  These routines are surprisingly complex; they must handle all the tasks mentioned above, as well as others. The idle_head_key and idle_body_key methods should not be called outside the leoTree class.  However, it often happens that code that handles user commands must simulate an event.  That is, the code needs to indicate that headline or body text has changed so that the screen may be redrawn properly.   The leoTree class defines the following simplified event handlers: onBodyChanged, onBodyWillChange, onBodyKey, onHeadChanged and onHeadlineKey.  Commanders and subcommanders call these event handlers to indicate that a command has changed, or will change, the headline or body text.  Calling event handlers rather than c.beginUpdate and c.endUpdate ensures that the outline pane is redrawn only when needed.</t>
<t tx="edream.110203163054.947">The following is a definition of clones from the user's point of view.

Definition 1

A clone node is a copy of a node that changes when the original changes. Changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Clones are marked by a small clone arrow by its leader character. 

As we shall see, this definition glosses over a number of complications. Note that all cloned nodes (including the original node) are equivalent. There is no such thing as a "master" node from which all clones are derived. When the penultimate cloned node is deleted, the remaining node becomes an ordinary node again. 

Internally, the clone arrow is represented by a clone bit in the status field of the vnode. The Clone Node command sets the clone bits of the original and cloned vnodes when it creates the clone. Setting and clearing clone bits properly when nodes are inserted, deleted or moved, is non-trivial. We need the following machinery to do the job properly. 

Two vnodes are joined if a) they share the same tnode (body text) and b) changes to any subtree of either joined vnodes are made to the corresponding nodes in all joined nodes.  For example, Definition 1 defines clones as joined nodes that are marked with a clone arrow.  Leo links all vnodes joined to each other in a circular list, called the join list. For any vnode n, let J(n) denote the join list of n, that is, the set of all vnodes joined to n. Again, maintaining the join lists in an outline is non-trivial. 

The concept of structurally similar nodes provides an effective way of determining when two joined nodes should also have their cloned bit set.  Two joined nodes are structurally similar if a) their parents are distinct but joined and b) they are both the nth child of their (distinct) parents.  We can define cloned nodes using the concept of structurally similar nodes as follows:

Definition 2

Clones are joined vnodes such that at least two of the vnodes of J(n) are not structurally similar to each other. Non-cloned vnodes are vnodes such that all of the vnodes of J(n) are structurally similar. In particular, n is a non-cloned vnode if J(n) is empty.

Leo ensures that definitions 1 and 2 are consistent. Definition 1 says that changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Making "corresponding changes" to the non-cloned descendents of all cloned nodes insures that the non-cloned joined nodes will be structurally similar. On the other hand, cloned nodes are never structurally similar. They are created as siblings, so they have the same parent with different "child indices."  To see how this works in practice, let's look at some examples.

Example 1

+ root
	+ a' (1)
	+ a' (2)

This example shows the simplest possible clone. A prime (') indicates a cloned node.  Node a in position (1) has just been cloned to produce a' in position (2). Clearly, these two cloned nodes are not structurally similar because their parents are not distinct and they occupy different positions relative to their common parent.

Example 2

If we add a node b to either a' node we get the following tree:

+ root
	+ a'
		+ b
	+ a'
		+ b

The b nodes are structurally similar because the a' nodes are joined and each b node is the first child of its parent.

Example 3

If we now clone either b, we will get:

+ root
	+ a'
		+ b' (1)
		+ b' (2)
	+ a'
		+ b' (1)
		+ b' (2)

All b' nodes must be clones because the nodes marked (1) are not structurally similar to the nodes marked (2).

Dependent nodes are nodes created or destroyed when corresponding linked nodes are created or destroyed in another tree. For example, going from example 1 to example 2 above, adding node b to either node a' causes another (dependent) node to be created as the ancestor of the other node a'. Similarly, going from example 2 to example 1, deleting node b from either node a' causes the other (dependent) node b to be deleted from the other node a'.  Cloned nodes may also be dependent nodes. In Example 3, all the b' nodes are dependent on any of the other b' nodes.

We can now give simple rules for inserting and deleting dependent vnodes when other vnodes are created, moved or destroyed. For the purposes of this discussion, moving a node is handled exactly like deleting the node then inserting the node; we need not consider moving nodes further.  We insert a new node n as the nth child of a parent node p as follows. We insert n, then for every node pi linked to p, we insert a dependent node ni as the nth child of pi. Each ni is linked to n. Clearly, each ni is structurally similar to n.  Similarly, it is easy to delete a node n that is the nth child of a parent node p. We delete each dependent node ni that is the nth child of any node pi linked to p. We then delete n.  When inserting or deleting any vnode n we must update its join list, J(n). Updating the join list is easy because the join list is circular: the entire list is accessible from any of its members.

Inserting or deleting nodes can cause the clone bits of all joined nodes to change in non-trivial ways. To see the problems that can arise, consider deleting any of the b' nodes from Example 3. We would be left with the tree in Example 2. There are two remaining b nodes, each with the clone bit set. Unless we know that both b nodes are structurally similar, there would be no way to conclude that we should clear the clone bits in each node. In order to update clone links properly we could examine many special cases, but there is an easier way. Because of definition 2, we can define a shouldBeCloned function that checks J(n) to see whether all nodes of J(n) are structurally similar.

Leo's XML file format does not contain join lists. This makes it easy to change a Leo file "by hand." If join lists were a part of the file, as they are in the Mac version of Leo, corrupting a join list would corrupt the entire file. It is easy to recreate the join lists when reading a file using a dedicated field in the tnode.  This field is the head of a list of all vnodes that points to the tnode. After reading all nodes, Leo creates this list with one pass through the vnodes.  Leo then convert each list to a circular list with one additional pass through the tnodes.
</t>
<t tx="edream.110203163054.948">The find and change commands are tricky; there are many details that must be handled properly. This documentation describes the leo.py code. Previous versions of Leo used an inferior scheme.  The following principles govern the LeoFind class:

1.	Find and Change commands initialize themselves using only the state of the present Leo window. In particular, the Find class must not save internal state information from one invocation to the next. This means that when the user changes the nodes, or selects new text in headline or body text, those changes will affect the next invocation of any Find or Change command. Failure to follow this principle caused all kinds of problems in the Borland and Macintosh codes. There is one exception to this rule: we must remember where interactive wrapped searches start. This principle simplifies the code because most ivars do not persist. However, each command must ensure that the Leo window is left in a state suitable for restarting the incremental (interactive) Find and Change commands. Details of initialization are discussed below.

2. The Find and Change commands must not change the state of the outline or body pane during execution. That would cause severe flashing and slow down the commands a great deal. In particular, c.selectVnode and c.editVnode methods must not be called while looking for matches.

3. When incremental Find or Change commands succeed they must leave the Leo window in the proper state to execute another incremental command. We restore the Leo window as it was on entry whenever an incremental search fails and after any Find All and Change All command.
Initialization involves setting the self.c, self.v, self.in_headline, self.wrapping and self.s_text ivars. Setting self.in_headline is tricky; we must be sure to retain the state of the outline pane until initialization is complete. Initializing the Find All and Change All commands is much easier because such initialization does not depend on the state of the Leo window.

Using Tk.Text widgets for both headlines and body text results in a huge simplification of the code. Indeed, the searching code does not know whether it is searching headline or body text. The search code knows only that self.s_text is a Tk.Text widget that contains the text to be searched or changed and the insert and sel Tk attributes of self.search_text indicate the range of text to be searched. Searching headline and body text simultaneously is complicated. The selectNextVnode() method handles the many details involved by setting self.s_text and its insert and sel attributes.
</t>
<t tx="edream.110203163054.949">This section describes Leo's explicit Tangle and Untangle commands.  Such commands operate only on @root and @unit trees.  The previous chapter discusses the implicit Tangle on Write/Untangle on Read processes used to read and write @file trees.

The Tangle command translates the selected @root tree into one or more well-formatted C source files. The outline should contain directives, sections references and section definitions, as described in Chapter 4. The Untangle command is essentially the reverse of the Tangle command. The Tangle command creates a derived file from an @root tree; the Untangle command incorporates changes made to derived files back into the @root tree.

The Tangle command operates in two passes. The first pass discovers the complete definitions of all sections and places these definitions in a symbol table. The first pass also makes a list of root sections. Definitions can appear in any order, so we must scan the entire input file to know whether any particular definition has been completed.

Tangle's second pass creates one file for each @root node. Tangle rescans each section in the list of roots, copying the root text to the output and replacing each section reference by the section's definition. This is a recursive process because any definition may contain other references. We can not allow a section to be defined in terms of itself, either directly or indirectly. We check for such illegally recursive definitions in pass 2 using the section stack class.  Tangle indicates where sections begin and end using comment lines called sentinel lines.  The this part of the appendix discusses the format of the sentinels output by the Tangle command.

The key design principle of the Tangle command is this: Tangle must output newlines in a context-free manner. That is, Tangle must never output conditional newlines, either directly or indirectly. Without this rule Untangle could not determine whether to skip or copy newlines.

The Tangle command increases the indentation level of a section expansion the minimum necessary to align the section expansion with the surrounding code. In essence, this scheme aligns all section expansions with the line of code in which the reference to the section occurs. In some cases, several nested sections expansions will have the same indentation level. This can occur, for example, when a section reference in an outline occurs at the left margin of the outline.

This scheme is probably better than more obvious schemes that indent more "consistently." Such schemes would produce too much indentation for deeply nested outlines. The present scheme is clear enough and avoids indentation wherever possible, yet indents sections adequately. End sentinel lines make this scheme work by making clear where the expansion of one section ends and the expansion of a containing section resumes.

Tangle increases indentation if the section reference does not start a line. Untangle is aware of this hack and adjusts accordingly. This extra indentation handles several common code idioms, which otherwise would create under-indented code. In short, Tangle produces highly readable, given the necessity of preserving newlines for Untangle.

Untangle is inherently complex.  It must do a perfect job of updating the outline, especially whitespace, from expansions of section definitions created by the Tangle command.  Such expansions need not be identical because they may have been generated at different levels of indentation.  The Untangle command can not assume that all expansions of a section will be identical in the derived file; within the derived file, the programmer may have made incompatible changes to two different expansions of the same section. Untangle must check to see that all expansions of a section are "equivalent".  As an added complication, derived files do not contain all the information found in @root trees.  @root trees may contain headlines that generate no code at all.  Also, an outline may define a section in several ways: with an @c or @code directive or with a section definition line.  To be useful, Untangle must handle all these complications flawlessly. The this part of the appendix discusses the various conventions used in the sentinels output by the Tangle command.  These conventions allow the Untangle command to recreate whitespace correctly.

Untangle operates in two passes. The first pass finds definitions in the derived file and enters them into the Untangle Symbol Table, or UST.   Definitions often include references to other sections, so definitions often include nested definitions of referenced sections. The first pass of Untangle uses a definition stack to keep track of nested definitions. The top of the stack represents the definition following the latest reference, except for the very first entry pushed on the stack, which represents the code in the outline that contains the @root directive. The stack never becomes empty because of the entry for the @root section. All definitions of a section should match--otherwise there is an inconsistent definition. This pass uses a forgiving compare routine that ignores differences that do not affect the meaning of a program.

Untangle's second pass enters definitions from the outline into the Tangle Symbol Table, or TST. The second pass simultaneously updates all sections in the outline whose definition in the TST does not match the definition in the UST.  The central coding insight of the Untangle command is that the second pass of Untangle is almost identical to the first pass of Tangle! That is, Tangle and Untangle share key parts of code, namely the skip_body() method and its allies.  Just when skip_body() enters a definition into the symbol table, all the information is present that Untangle needs to update that definition.

</t>
<t tx="edream.110203163054.950">The following paragraphs discuss code-level details.  You should not need to read this section in order to use Leo.

1. Leo uses unicode objects in vnodes and tnodes to denote headline and body text.  Note that unicode strings have no encoding; only plain strings have encodings. This means that once an (encoded) plain string has been converted to a unicode string it doesn't matter how the unicode string was created.  This is the key that makes Leo's new code robust. 

So internally Leo never has to worry about encodings. The only times encoding matter is when encoded strings are converted to and from unicode when Leo reads or writes files (or when the passing strings to and from Tk.Text widgets, but the idea is the same).

2. Python expressions that mix unicode strings u and plain strings s, like:

	u + s 
or 
	u == s 
or 
	u[5] == s[2:]

are promoted to unicode objects using the "system encoding". This encoding should never be changed, but we can't assume that we know what it is, so for safety we should assume the most restrictive encoding, namely "ascii".  With this assumption, Leo's code can't throw an exception during these promotions provided that: 

- All strings are converted to unicode when Leo reads files or gets text from Tk.Text widgets. 
- All string literals in Leo's code have only ascii characters.</t>
<t tx="edream.110203163054.951">Only leo.py supports unlimited undo.  Unlimited undo is straightforward; it merely requires that all commands that affect the outline or body text must be undoable. In other words, everything that affects the outline or body text must be remembered.

We may think of all the actions that may be Undone or Redone as a string of beads (undo nodes). Undoing an operation moves backwards to the next bead; redoing an operation moves forwards to the next bead. A bead pointer points to the present bead. The bead pointer points in front of the first bead when Undo is disabled.  The bead pointer points at the last bead when Redo is disabled. An undo node is a Python dictionary containing all information needed to undo or redo the operation.

The Undo command uses the present bead to undo the action, then moves the bead pointer backwards. The Redo command uses the bead after the present bead to redo the action, then moves the bead pointer forwards. All undoable operations call setUndoParams() to create a new bead. The list of beads does not branch; all undoable operations (except the Undo and Redo commands themselves) delete any beads following the newly created bead.

I did not invent this model of unlimited undo.  I first came across it in the documentation for Apple's Yellow Box classes.</t>
<t tx="edream.110203163054.952">@nocolor
@ignore</t>
<t tx="edream.110203163054.953">To convert an @root tree to an @file tree, choose the root of the tree to be converted, then do the following in the Python window:

	import c2py
	c2py.leo1to2()
	
This script makes numerous changes throughout the tree.  It does not, however, change @root to @file, or insert the needed @others directives.  You must do that by hand.

To convert @root trees to @file trees by hand:

1.  Change the @root node to an @file node.  That is, delete the @root &lt;filename&gt; directive from the body text and insert @file &lt;filename&gt; in the headline.  Typically, the root node contains a reference like &lt;&lt;methods of class x&gt;&gt; as the last body text.  Replace this reference with the @others directive.  The expansion of @others is all text that is not part of a section definition.

2.  Add @&lt;space&gt; to the start of all doc parts.  Leo2 starts syntax coloring in code mode rather than doc mode, so if a doc part starts body text it should start with @&lt;space&gt; or @doc.

3.  Replace all section definition lines (like &lt;&lt;name&gt;&gt;=) by @c (or @code).  This results in the node being added to the expansion of @others.

4.  Remove all unused code from the @file tree.  Leo2 does not write derived files whose @file trees contain orphan or @ignored nodes.  If an @file tree does contain an orphan or @ignored node, Leo2 issues a warning and writes the entire @file tree to the .leo file instead of the derived file.  This prohibition of orphan an @ignored nodes is necessary to make error recovery completely safe and reliable.

5.  Make sure that all nodes defining a section have a headline that starts with &lt;&lt;section&gt;&gt;.  This will typically be true when converting @root trees that use the @code directive.

6. If a section is referenced in more than one node (a rare occurence in my code), clone the defining node and move one clone under each referencing node.

7. If a node contains the definitions of several sections, place each different definition in a different node.</t>
<t tx="edream.110203163054.954">@ignore</t>
<t tx="edream.110203163054.955">In @root and @unit trees, the @code directive indicates the start of a code section. The headline must contain a valid section name.

In @file trees, the @c directive indicates the start of a code section.

</t>
<t tx="edream.110203163054.956">This directive affects only the Weave (Print) command (and possibly the Create CWEB command).  It indicates the start of a chapter.  This puts the chapter title at the top of each page.</t>
<t tx="edream.110203163054.957">Indicates that syntax coloring is enabled for the body text in which it appears and all descendent nodes ( unless over-ridden in the descendent nodes ).</t>
<t tx="edream.110203163054.958">This directive indicates the delimiters to be used by the Tangle command.</t>
<t tx="edream.110203163054.959">@nocolor

The @delims directive changes the comment strings used to mark sentinel lines. This directive is often used to place Javascript text inside XML or HTML files.  This directive is valid only in @file trees.  You can use the @comment directive in @unit or @root trees.

The @delims directive contains one or two delimiters, separated by whitespace. If only one delim is present it delimits single-line comments. If two delims are present they delimit block comments. The @delims directive can not be used to change the comment strings at the start of the derived file, that is, the comment strings for the @+leo sentinel and the initial @+body and @+node sentinels. The @delims directive inserts @@delims sentinels into the derived file. The new delimiter strings continue in effect until the next @@delims sentinel in the derived file or the end of the derived file.

Note: Leo can not revert to previous delimiters automatically; you must change back to previous delimiters using another @delims directive. For example:

@color

@delims /* */
Javascript stuff
@delims &lt;-- --&gt;
HTML stuff

@nocolor
Adding, deleting or changing @@delims sentinels will destroy Leo's ability to read the derived file. Mistakes using the @delims directive have no effect on Leo, though such mistakes will thoroughly mess up a derived file as far as compilers, HTML renderers, etc. are concerned.</t>
<t tx="edream.110203163054.960">In @root and @unit trees, the @doc directive indicates the start of a comment enclosed in the beginning and ending block comment delimiters ( see @comment ).

In @file trees, the @(space) (@ followed by a space, tab or newline) indicates the start of an doc part.  @(space) is optional: it is not needed if the body text contains no doc part.

</t>
<t tx="edream.110203163054.961">Strictly speaking, @file is not a directive; it is not valid in body text.

A headline that starts with @file &lt;filename&gt; forms the root of an @file tree.  Leo writes all nodes in the tree to the derived file &lt;filename&gt; when any Save command is executed.  The @file tree is recreated from the derived file when the .leo file is opened.

The Leo2 documentation discusses how to write code in @file trees.
</t>
<t tx="edream.110203163054.962">The @first directive allows you to place lines at the very start of files derived from @file nodes. For example, the body text of @file spam.py might be:

	@first #! /usr/bin/env python

The body text of @file foo.perl might be:

	@first #/usr/bin/perl

@first directives are recognized only at the start of the body text of @file nodes. No text may precede @first directives. More than one @first directive may exist, like this:

	@first #! /usr/bin/env python
	@first # more comments.</t>
<t tx="edream.110203163054.963">This directive causes the Tangle and Untangle commands to ignore this node and all its descendents.</t>
<t tx="edream.110203163054.964">The @language directive specifies the comment delimiters and string types used by the Tangle and Untangle.

The form of this directive is

@language x

where x is one of the following: c,c++,html,java,objective-c,pascal,perl,python and shell.  Shell files have comments that start with #.  Case is ignored in the language specifiers, but not in the @language itself.  Thus, the following are equivalent:

@language html
@language HTML
@language hTmL

but the following is invalid:

@LANGUAGE html

The @comment directive is now officially deprecated: you should use the @language directive whenever possible.  At present Untangle will not process an @root or @unit node if an @comment directive is in effect.  Why?  Because Untangle can't be sure of properly parsing a derived file if the language of the derived file isn't known.  It might be possible to assume some defaults in this case, but that is not done at present and is not a high priority.</t>
<t tx="edream.110203163054.965">Indicates that syntax coloring is disabled for the body text in which it appears and all descendent nodes ( unless over-ridden in the descendent nodes ).</t>
<t tx="edream.110203163054.966">The @others directive is valid only in @file trees.  The @others directive causes the expansion of all unnamed nodes to be output to the derived file in the position of the @others directive.

For example, a common Python idiom is:

class myClass:
	&lt;&lt; constants of myClass &gt;&gt;
	@others
	
The @others directive inserts the expansion of all unnamed sections into the class definition, indented just as the @others directive is indented.

An @file tree may have more than one @others directive.  Each @others directive collects only those nodes found in the descendents of the node containing the @others directive.

A single node may contain at most one @others directive.  To use more than one @others directive in an @file tree, use the following pattern:

class x:
	&lt;&lt;members of x&gt;&gt;
class y:
	&lt;&lt;members of y&gt;&gt;
	
The named nodes &lt;&lt;members of x&gt;&gt; and &lt;&lt;members of y&gt;&gt; contain only an @others directive.  Define members of the x and y classes as descendents of the nodes containing @Others.

</t>
<t tx="edream.110203163054.967">The @pagewidth directives affects how Tangle outputs block comments:  it specifies the width of output pages in columns.  The form of the @pagewidth directive is @pagewidth n, where n is a positive integer.
</t>
<t tx="edream.110203163054.968">The @path directive specifies the directory to be used if an @file or @root directive does not specify a full path name. The form of the @path directive is @path filename, where filename is taken to be everything following @path to the end of the line.

If the filename in @file pathname or @root pathname is an absolute filename the location of the derived file is specified only by the filename.  Otherwise, if the filename is a relative filename, the location of the derived file is relative to:
	
1. the directory specified the applicable @path directive, or
2. the "Default Tangle Directory" in the Preferences panel if no @path directive is in effect, or
3. the directory in which the .leo resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules, or if the filename or directory does not exist.</t>
<t tx="edream.110203163054.969">This directive starts the text that forms a single derived file, after all section references have been replaced by their definitions.

By default, only descendents of the @root node are examined for section definitions.  However, if the @root directive is a descendent of a node containing the @unit directive, all descendents of the @unit node are examined for section definitions.</t>
<t tx="edream.110203163054.970">This directive affects only the Weave (Print) command (and possibly the Create CWEB command).  It indicates the start of a section.  This puts the section title at the top of each page.</t>
<t tx="edream.110203163054.971">The @silent causes Tangle to output no comments for doc chunks and no sentinel lines for Untangle. Comments written by the user in code sections are always output.

</t>
<t tx="edream.110203163054.972">The @tabwidth directives affects how Tangle outputs leading whitespace:  it specifies the width of tabs in spaces.  The form of the @tabwidth directive is @tabwidth n, where n is a positive integer.
</t>
<t tx="edream.110203163054.973">The @terse directive causes Tangle not to output comments for doc chunks.  Tangle will output only those sentinel comments needed by Untangle.  As always, comments written by the user in code sections are output.

These directives are not valid in @file trees.</t>
<t tx="edream.110203163054.974">Expands the nodes searched for section definitions when processing an @root directive.

By default, only descendents of the @root node are examined for section definitions.  However, if the @root directive is a descendent of a node containing the @unit directive, all descendents of the @unit node are examined for section definitions.</t>
<t tx="edream.110203163054.975">The @verbose directive causes Tangle to output comments for doc chunks and sentinel comments needed by Untangle.  This is the default behavior if none of the @verbose, @terse or @silent directives are in effect.
</t>
<t tx="edream.110203163054.976"></t>
<t tx="edream.110203163054.977">The following error messages may be generated by the Tangle commands.  Such errors appear in the log window, which will be opened if necessary.	
</t>
<t tx="edream.110203163054.978">A file error occurred while trying to reopen the temporary file used during tangling.</t>
<t tx="edream.110203163054.979">A file error occurred while trying to change the name of the temporary file used during tangling.</t>
<t tx="edream.110203163054.980">An @code directive appeared in body text whose header does not contain a section name.</t>
<t tx="edream.110203163054.981">An @directive was seen somewhere other than the start of a line.</t>
<t tx="edream.110203163054.982">Tangle detected more than 20 errors.</t>
<t tx="edream.110203163054.983">A section was defined in terms of itself, either directly or indirectly.  The trace shows the chain of section definitions that resulted in the illegal definition.

This message is followed by a walkback of the section names that recursively reference the section.  The walkback looks like this:

called from &lt;&lt; section name &gt;&gt;
called from &lt;&lt; section name &gt;&gt;
...
</t>
<t tx="edream.110203163054.984">Tangle did not write a file because errors were found.</t>
<t tx="edream.110203163054.985">A C-language comment was not properly terminated.</t>
<t tx="edream.110203163054.986">The file name in an @root directive was not terminated with the proper delimiter.</t>
<t tx="edream.110203163054.987">A section name was not properly terminated before the end of the line in which it started.
</t>
<t tx="edream.110203163054.988">A C-language string or character constant was not properly terminated.</t>
<t tx="edream.110203163054.989">Something that looks like a section definition was seen in the middle of a line.</t>
<t tx="edream.110203163054.990">A section was defined using more than 100 levels of section definitions (!)

You could easily create an outline containing every computer program ever written in less than 50 levels.</t>
<t tx="edream.110203163054.991">The selected outline contained no @root directive.</t>
<t tx="edream.110203163054.992">A reference to an undefined section was encountered.</t>
<t tx="edream.110203163054.993">Tangle outputs 2-character WEB control code in a comment.  This message is given if we find such comments in a code definition.</t>
<t tx="edream.110203163054.994">(The text of the duplicate definition follows.)

The section may have been defined in more than one place.</t>
<t tx="edream.110203163054.995">The indicated section appears in the outline but is never referenced.</t>
<t tx="edream.110203163054.996">The following error messages may be generated by the Untangle commands.  Such errors appear in the log window, which will be opened if necessary.	
</t>
<t tx="edream.110203163054.997">Two expansions of &lt;&lt; section name &gt;&gt; were different in the derived file.  This typically arises when the programmer changes one of the expansions but not the other.</t>
<t tx="edream.110203163054.998">No end sentinel line was found for a part of the expansion of the code in the @root node.  This is likely the result of adding, deleting or altering a sentinel line.</t>
<t tx="edream.110203163054.999">No end sentinel line was found for the expansion of the code in the @root node.  This is likely the result of adding, deleting or altering a sentinel line.</t>
<t tx="edream.110203163054.1000">The end sentinel name for &lt;&lt; section name &gt;&gt; was expected but not found.  This is likely the result of adding, deleting or altering a sentinel line.</t>
<t tx="edream.110203163054.1001">The end of the file was reached before encountering the end sentinel line for
	&lt;&lt; section name &gt;&gt;.
This is likely the result of adding, deleting or altering a sentinel line.</t>
<t tx="edream.110203163054.1002"></t>
<t tx="edream.110203163054.1003">The following are all minor errors, meaning that no data is likely to have been lost.  You can proceed as usual.

1. Rereading file.  Clone links into this file will be lost

The .leo file is out of synch with the derived file, so non-essential information usually stored in the .leo file will be deleted.  Clone links may be severed.

2. Missing file name.  Restoring @file tree from .leo file

No file name follows @file

3. Error reading file.  Restoring @file tree from .leo file

The file name following @file could not be found

4. File name in @node sentinel does not match file's name

The name of the derived file may have been changed.

5. Ignoring text after @-leo

Some text follows the trailing @-leo sentinel line.  Make sure this text is not important.</t>
<t tx="edream.110203163054.1004">The following are all serious errors, meaning that the data in a derived file has been corrupted.  You should restore the information from a backup .leo file using the Read Outline Only commands, followed by a Write @file Nodes command.

 1. Bad @+leo sentinel in &lt;filename&gt;
 2. Bad @delims"
 3. Bad attribute field in @+node
 4. Bad child index in @+node
 5. File may have damaged sentinels!
 6. Ignoring &lt;sentinel kind&gt; sentinel.  Expecting &lt;sentinel kind&gt;
 7. Ignoring unexpected @+leo sentinel
 8. Missing &lt;sentinel kind&gt; sentinel
 9. Missing @file in root @node sentinel
10. Outline corrupted: different nodes have same clone index!
11. Replacing body text of orphan &lt;node name&gt;
12. Unexpected end of file. Expecting &lt;sentinel kind&gt; sentinel
13. Unknown sentinel: &lt;sentinel line&gt;
</t>
<t tx="edream.110203163054.1005">Errors while writing @file nodes are harmless.  No information is lost because all information is written to the .leo file rather than the derived file.

1. Bad @delims directive

2. Can not open &lt;file name&gt;

3. @ignore node: &lt;headline&gt;

The body text of &lt;headline&gt; contains an @ignore directive.

4. Missing file name: &lt;file name&gt;

@file is not followed by a file name.

5. Orphan node: &lt;headline&gt;

The node is referenced by no ancestor node, and no @others directive applies to it.

6. @others already expanded in: &lt;headline&gt;

The node contains more than one @others directive.

7.  Rename failed: no file created! (file may be read-only)

Leo's Save commands write derived files to a temporary file, and rename that file to be the derived file only if the old derived file is different from the temporary file.  This message means that a problem with the file system prevented the temporary file from being renamed.

8. Path does not exist: &lt;file name&gt;

The path may be specified by the Preferences panel, an @path directive or by a path in the @file node.

9.  undefined section: &lt;section name&gt; referenced from: &lt;headline&gt;
			
The node given by &lt;headline&gt; contains a reference to &lt;&lt;section name&gt;&gt;, 
but no named node for &lt;&lt;section name&gt;&gt; exists in the descendents of &lt;headline&gt;	</t>
<t tx="edream.110203163054.1006">New for leo.py v2.0 and Borland Leo 2.6:

Leo suppresses blank lines between sentinels by default.  This is an upward compatible change in the format of derived files: leo.py v2.0 can read derived files from all previous versions of Leo, but previous versions of Leo can not read derived files without blanks lines.

To cause leo.py not to remove blank lines do the following.  In the section called &lt;&lt; initialize atFile ivars &gt;&gt; in leoAtFile.py, change:

	self.suppress_newlines = true
to
	self.suppress_newlines = false

Note: leo.py v2.0 can read derived files without blank lines between sentinels regardless of the setting of self.suppress_newlines.
</t>
<t tx="edream.110203163054.1007">The following sections describe the comment lines embedded in derived files.  It is not necessary to understand this in detail.  All you need to know is this:

1. Sentinel lines are comment lines whose first character (following the comment delimiter) is @.
2. Do not alter sentinel lines in derived files.  Doing so will corrupt the outline structure!
3. Do not alter blank lines in front of, behind or between sentinels.  Doing so will corrupt the outline structure in older versions of Leo.</t>
<t tx="edream.110203163054.1008">The @delims directive changes the comment strings used to mark sentinel lines.  The @delims directive contains one or two delimiters, separated by whitespace.  If only one delim is present it delimits single-line comments.  If two delims are present they delimit block comments. The @delim directive can _not_ be used to change the comment strings at the start of the derived file, that is, the comment strings for the @+leo sentinel and the initial @+body and @+node sentinels.

NB: Leo can not revert to previous delimiters automatically; you must change back to previous delimiters using another @delims directive.  For example:

@delims /* */
Javascript stuff
@delims &lt;-- --&gt;
HTML stuff
</t>
<t tx="edream.110203163054.1009">A file produced by an @file node begins with an @+leo sentinel.  The last lines of the file should be the matching @-leo sentinel

The comment delimiters that delimit all sentinels are specified by the first line of the file, that is, the @+leo sentinel.  This sentinel has the form:

&lt;opening_delim&gt;@leo&lt;closing_delim&gt;

&lt;closing_delim&gt; may be empty, in which case single-line comments are used.  The Write code generates single-line comments if possible.  Presently, the Write logic generates single line comments for all languages except HTML.  (Block comments can be specified using the @comment directive.)</t>
<t tx="edream.110203163054.1010">Suppose the parent node of a node N is P and that P has n children.  The sentinel 

  @+node:&lt;child_index&gt;:&lt;status_fields&gt;:&lt;headline&gt;

begins the expansion of node N.  The expansion continues until a matching

  @-node::&lt;child_index&gt;:&lt;status_fields&gt;:&lt;headline&gt;
  
sentinel.

The &lt;child_index&gt; field is a number from 1 to n indicating the index of the node in the list of its parent's children.

The &lt;status_field&gt; field the cloneIndex field of the form: "C=nnn", where nnn is an immutable clone index.

The &lt;headline&gt; field contains headline text, not reference text.

The indentation of the expansion is increased by the extra indentation of preceding the reference.  tree level never affects indentation level.</t>
<t tx="edream.110203163054.1011">If a node contains significant I(non-whitespace) body text, @+body and @-body sentinels surround the text.  These sentinels are nested within @node directives.
</t>
<t tx="edream.110203163054.1012">@+doc and @-doc delimit doc parts within a node that start with @doc. These sentinels are nested within @body directives.  Similarly, @+at and @-at delimit doc parts within a node that start with @&lt;whitespace&gt;.

We use the following convention to determine where putDocPart has inserted line breaks: A line in a doc part is followed by an inserted newline if and only if the newline if  preceded by whitespace.  To make this convention work, the Write deletes the trailing whitespace of all lines that are followed by a "real" newline.</t>
<t tx="edream.110203163054.1013">@+others indicates the start of the expansion of an @+others directive, which continues until the matching @-others. @others sentinels are nested within @body sentinels; the expansion of the @others directive always occurs within the body text of some node N.
</t>
<t tx="edream.110203163054.1014">The @delims directive inserts @@delims sentinels into the derived file. The new delimiter strings continue in effect until the next @@delims sentinel _in the derived file_ or the end of the derived file.

Adding, deleting or changing @@delim _sentinels_ will destroy Leo's ability to read the derived file.  Mistakes in using the @delims _directives_ have no effect on Leo, though such mistakes will thoroughly mess up a derived file as far as compilers, HTML renderers, etc. are concerned.</t>
<t tx="edream.110203163054.1015">The @@&lt;text&gt; sentinel represents any line starting with @ in body text except @&lt;whitespace&gt;, @doc and @others. Examples:

  @@nocolor
  @@pagewidth 80
  @@tabwidth 4
  @@code</t>
<t tx="edream.110203163054.1016">@verbatim indicates that the next line of the derived file is not a sentinel.  This escape convention allows body text to contain lines that would otherwise be considered sentinel lines.

New for leo.py version 2.0 and Borland Leo version 2.6:

@verbatimAfterRef is generated when a comment following a section reference would otherwise be treated as a sentinel.   In Python code, an example would be:

  &lt;&lt; ref &gt;&gt; #+others

This sentinel is required only when blank lines are suppressed between sentinel lines.</t>
<t tx="edream.110203163054.1017">@&lt;&lt;section_name&gt;&gt; represents section reference.  If the reference does not end the line, the sentinel line ending the expansion is followed by the remainder of the reference line.  This allows the Read code to recreate the reference line exactly.</t>
<t tx="edream.110203163054.1018">@nocolor

The 4.0 file format meets all of the following goals:

- The minimum of sentinels needed to properly recreate the outline.
- A robust way of telling whether newlines belong to sentinels or not.
- A minimum of intrusion and ugliness.

Changes to derived file format:

The @+leo sentinel indicates whether the format is 3.x or 4.x.

@+node and @-node sentinels no longer contain child or clone indices.  Therefore, such sentinels do not change when outline nodes are inserted, deleted or moved.  This will grealy reduce (but not entirely eliminate) cvs conflicts involving sentinel lines.

Leo generates @+node sentinels only for nodes containing body text.  Leo no longer generates other @+node sentinels to indicate outline structure.  As a result, there is no longer any need for @+body sentinels.

The @nl and @nonl sentinels adjust contribution of _previous_ sentinels.  This eliminates all lookahead logic and greatly simplifies the read code.

The @+others and @&lt;&lt; sentinels indicte leading whitespace appearing before @others directives and section refs.

Leo writes the @afterref whenever any non-whitespace text appears after a section references.

The @+doc and @+at sentinels now contain the whitespace that follows the corresponding @doc or @ directives.</t>
<t tx="edream.110203163054.1019">The following is a list of features I'd like to add to Leo.

Styled text and graphics

Except for syntax coloring, there is no way to style text in an outline.  The ultimate would be for Leo to support arbitrary XML code in the body pane.  Perhaps someday Tk's text panes will allow this.

Lists of sections

It would be useful to have easily available, possibly as a pop-up menu, a list of the most recently accessed sections, and possibly a full list of all section names as well.</t>
<t tx="edream.110203163054.1020">The following documentation applies to @file trees.

@file node:			Node whose headline starts with @file filename.
Named node:			Node whose headline starts with  &lt;&lt;section_name&gt;&gt;.
Unnamed node:		Node that is neither an @file node nor a definition node.
Organizer node:		An unnamed node with no body text.
@ignore node:		Node with an @ignore directive in its body text.
@others node:		Node with an @others directive in its body text.
Orphan node:		Ordinary node that is not part of any section definition.
Directive:			A line of body text that starts with '@'.
Doc part:			Body text from an @&lt;space&gt; or @doc directive to
					the next @c or @code directive.
Code part:			Body text from an @c or @code directive to the
					next @&lt;space&gt; or @directive.
Natural tree order:	The order of nodes would appear on the screen if all nodes
					were expanded.

An @file node forms the root of a tree whose expansion forms a derived file.

The expansion of an @file node or a section definition node is the entire text of the node with all section references replaced by their definition.  Section references is any text containing &lt;&lt;section name&gt;&gt;.  Section references are recognized anywhere within code parts, even within comments or strings.

Definition nodes must be a descendant of the node containing the section reference.  If a section is referenced in more than one node, you may use clones to "copy" the definition to more than one location.

Organizer nodes never affect the generated code, except to produce sentinels.  In particular, organizer nodes do not affect indentation of code in the derived file.

The body text of each node is assumed to start in code mode.  @ or @doc are used to create a doc part.  No escape conventions are used: if a line contains &lt;&lt; followed by &gt;&gt; then everything between the &lt;&lt; and &gt;&gt; becomes a section name.

The @others directive may be used at most once in named nodes and @file nodes.  @others refers to descendant nodes that would not otherwise be included in the derived file. More exactly, the expansion of the @others directive in node N is the set of unnamed descendents of N that are the descendents of no named node or @others node other than N.

Often, a single @others appears at the end of the body text of the @file node.  The expansion of @others is the concatenation of the body text of all ordinary nodes, in natural tree order.

For a more complex example, suppose we have a tree with the following headlines:

  @file name (contains @others in body text)
    &lt;&lt;section1&gt;&gt; (contains @others in body text)
      &lt;&lt;section2&gt;&gt; (contains @others in body text)
         node A1
		 node A2
      node B
    node C1
	node C2
	
The expansion of @others in node &lt;&lt;section2&gt;&gt; is the concatenation of the expansion of the body texts of nodes A1 and A2.  Similarly, the expansion of @others in node &lt;&lt;section1&gt;&gt; is the concatenation of the expansion of the body texts of node B.  Finally, the expansion of @others in node @file name is the concatenation of the expansion of nodes C1 and C2.

The derived file corresponding to an @file node is not written if any descendant of the @file node is an orphan. For example, the following outline contains an orphan node:

@file name (no @others)
    &lt;&lt;section1&gt;&gt; (contains @others)
      node A
    node B (orphan node)
	
Leo2 issues a warning when a .leo file is saved if any @file node contains an orphan or @ignored node.

Typically a single @others directive in the @file node suffices.  For example, the body text of the @file node would be something like:

  &lt;&lt; preliminary definitions &gt;&gt;
  @others

Sections may be defined in any descendant of the @file node provided that the method is not a descendant of any definition node.</t>
<t tx="edream.110203163054.1021"></t>
<t tx="edream.110203163054.1022">The following is a list of the major differences between the Macintosh and PC versions of Leo.

1.  The PC version does not have a Print (Weave) command. This command is under development.

2.  The PC version implements the Untangle command.  The commercial Mac version will implement the Untangle command but the free Mac version does not.

3.  The PC version uses an XML file format.  The commercial Mac version will use the same format.  The free Mac version uses an entirely different format.

4.  The PC version implements clone windows; the Mac versions don't.

5.  Syntax coloring is partially customizable when using the PC version of Leo.  However, at present it is not possible to fully save these options.

6.  The Preferences panel is functional in the PC version.


</t>
<t tx="edream.110203163054.1023">The commercial Mac and PC versions of Leo will use the same file format, so nothing special will need to be done to transfer files between these two versions.  Transferring information between the commercial PC version and the free Mac version is relatively straightforward.

1. Create a text file in MORE format.

On the Mac, simply copy an outline in Leo and paste into a text file.  I use the Metrowerks IDE to create the text file because it handles newlines properly, but almost any text editor will do.  Use the text editor to create the text file.

On the PC, use the Export More Text command, then paste the text into any text editor and use the text editor to create the file.

2. Transfer the text file to the other machine.

3. Create an outline using the text file created in step 1.

On the Mac, load the text file into a text editor.  Select all the text and copy it to the clipboard.  In Leo, choose the Copy Outline command to create the outline.

On the PC, load the text file into a text editor.  Select all the text and copy it to the clipboard.  In Leo, choose the Import More Text command to create the outline.
</t>
<t tx="edream.110203163054.1024">Sherlock is a flexible tracing and measurement package for C, C++ and Objective C.  All parts of Sherlock are in the public domain.

You will see Sherlock macros throughout Leo's C++ code.  The most common of these macros are FTAG, STATB, STATX, TRACEP, TRACEPB and TRACEPX.  These Sherlock macros are not functional in the production version of Leo.

Full documentation for Sherlock can be found at:
	http://personalpages.tds.net/~edream/sl_index.html</t>
<t tx="edream.110203163054.1025">Leo now uses unicode internally for most strings.  This solves a lot of problems.  The children of this node discuss the details...
</t>
<t tx="edream.110203163054.1026">Leo now uses unicode internally for most strings.  The highlights:

1. Leo converts headline and body text to unicode when reading .leo files and derived files.  Both .leo files and derived files may specify their encoding, with "utf-8" being used by default.  If the encoding used in a derived file is not "utf-8" it is represented in the @+leo sentinel line.  For example:

#@+leo-encoding=iso-8859-1.

The "utf-8" encoding is a "lossless" encoding (it can represent all unicode code points), so encoding and decoding to and from utf-8 plain strings will never cause a problem.  When reading or writing a character not in a "lossy" encoding, Leo converts such characters to '?' and issues a warning. 

2. When writing .leo files and derived files Leo uses the same encoding used to read the file, again with "utf-8" used as a default.

3. leoConfig.py contains two settings used to specify the default encoding used for .leo and derived files:

default_derived_file_encoding = UTF-8 
new_leo_file_encoding = UTF-8 

I do not recommend changing new_leo_file_encoding (see the comments in leoConfig.leo) and you may set 
default_derived_file_encoding to anything that makes sense for you.

4. You may use the @encoding directive to specify the encoding used in a derived file.  You can't mix encodings in a single derived file.

This is all should need to know to use extended character sets on Leo.</t>
<t tx="edream.110203163054.1027">leoConfig.py now contains two new settings, with the defaults shown below: 

default_derived_file_encoding = UTF-8 
new_leo_file_encoding = UTF-8 

These control the default encodings used when writing derived files and .leo files.

I do not recommend changing new_leo_file_encoding (see the comments in leoConfig.leo)

You may set default_derived_file_encoding to anything that makes sense for you.
</t>
<t tx="edream.110203163054.1028">This Appendix describes Leo's file format.  Most users of Leo can skip this appendix.  This technical information will be of use only to those wanting to process Leo files with special-purpose filters.

Leo's uses XML for its file format.  The following sections describe this format in detail.  The last node gives an example, and it will be useful to refer to this example frequently.

In the description below sss denotes a string with the XML escapes for the &amp; &lt; and &gt; characters:

&amp; becomes &amp;amp;
&lt; becomes &amp;lt;
&gt; becomes &amp;gt;

This translation is performed on any text that could contain the &amp; &lt; or &gt; characters.

For those of you who grok DTD's a preliminary DTD for Leo's XML follows.  This DTD is under development and may contain syntax or semantics errors.  It may also simply be inaccurate.

The format of Leo2 .leo files is very similar to the format of Leo1 .leo files.  The major differences are:

1.  Leo1 .leo files have file version 1.  Leo2 .leo files have file version 2.  This allows Leo1 to issue an important warning if a version 2 file is opened.

2.  vnodes in Leo2 .leo files contain a new cloneIndex field, which records the immutable clone indices found in derived files.

3.  vnodes in Leo2 .leo files contain a new attribute byte, the "orphan" attribute.

In all other respects Leo1 and Leo2 .leo files are identical. Leo1 can open Leo2 files, but Leo1 ignores all information unique to Leo2.  However,  Leo1 treats @file nodes as regular outline nodes: Leo1 neither reads derived files when outlines (.leo files) are loaded nor writes derived files when outlines are saved.
</t>
<t tx="edream.110203163054.1029">Leo files start out with the following line declaring the format to be formatted as a type of XML.

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</t>
<t tx="edream.110203163054.1030">The &lt;leo_file&gt; tag opens an element that contains the entire file. The &lt;/leo_file&gt; tag at the end of the file ends this element.

The following sections describe the elements that may appear between the &lt;leo_file&gt; tag and the &lt;/leo_file&gt; tag.  These elements must appear in the order given.  However, the clone_windows element is optional.
</t>
<t tx="edream.110203163054.1031">The file header element specifies information used to parse the file or to allocate data structures needed to read the file.  The header starts with &lt;leo_header and ends with /&gt;  In between are the following four required attribute fields.

file_format="1" indicates the version number of the file format: 1, 2, 3, etc.

tnodes="2" indicates the number of tnodes that appear in the file.

max_tnode_index="2"	indicates the largest tnode index.

clone_windows="0" indicates the number of clone windows specified by the file.

I'll say more about tnodes later.
</t>
<t tx="edream.110203163054.1032">The globals element specifies information relating to the entire file.  This element starts with the following the &lt;globals body_outline_ratio="0.50"&gt; tag and ends with &lt;/globals&gt; tag.

The body_outline_ratio attribute specifies the ratio of the height of the body pane to the total height of the Leo window.  It initializes the position of the splitter separating the outline pane from the body pane.

In between the &lt;globals...&gt; tag and the &lt;/globals tag&gt; are the following two elements.  These specify the position of the Leo window and Log window in global coordinates:

&lt;global_window_position top="27" left="27" height="472" width="571"/&gt;

&lt;global_log_window_position top="183" left="446" height="397" width="534"/&gt;
</t>
<t tx="edream.110203163054.1033">The preferences element specifies the preferences that the user can change using the Preferences command.  It starts with the &lt;preferences...&gt; tag and ends with &lt;/preferences&gt; tag.

The following three attributes may appear before the &gt; that ends the &lt;preferences...&gt; tag.

allow_rich_text="1"
tab_width="4"
page_width="132"

At present the "Allow Rich Text" option is non-functional.

Following the &lt;preferences...&gt; tag is the following element.

&lt;syntax_prefs&gt;sss&lt;/syntax_prefs&gt;

The sss string encodes the settings of the TSyntaxMemo component used for body text.  This string is simply passed to and from TSyntaxMemo and is not used by Leo in any other way.  Future versions of TSyntaxMemo will allow more settings to be encoded, and those settings will appear between the &lt;preferences...&gt; and &lt;/preferences&gt; tags.
</t>
<t tx="edream.110203163054.1034">The find_panel_settings element specifies the settings of the Find panel at the time the file was saved.  This element starts with the &lt;find_panel_settings...&gt; tag and continues until the &lt;/find_panel_settings&gt; tag.

Zero or more of the following attributes may appear before the &gt; that terminates the &lt;find_panel_settings...&gt; tag. Leo writes these attributes in the order shown, but they may appear in any order.

whole_word="1"
search_body="1"
whole_word="1"
ignore_case="1"
pattern_match="1"
search_headline="1"
search_body="1"
suboutline_only="1"
mark_changes="1"
mark_finds="1"
reverse="1"

The default for all attributes is "0" (unchecked check box) and an attribute is written only if is "1" (checked check box).

The following elements appear after the &lt;find_panel_settings&gt; tag and before the &lt;/find_panel_settings&gt; tag.

&lt;find_string&gt;sss&lt;/find_string&gt;
&lt;change_string&gt;sss&lt;/change_string&gt;

The sss strings indicate the find and change strings in the Find panel.  Either sss string may be empty.  Both sss strings are encoded with the usual XML escapes.
</t>
<t tx="edream.110203163054.1035">The vnodes element specifies the list of so-called vnodes of an outline.  

The vnodes element starts with &lt;vnodes...&gt; and ends with &lt;/vnodes&gt;.  In between these tags are one or more v elements.
</t>
<t tx="edream.110203163054.1036">The v element represents a single vnode and has the following form:

&lt;v...&gt;&lt;vh&gt;sss&lt;/vh&gt; (zero or more nested v elements) &lt;/v&gt;

The vh element specifies the headline text.  As usual it starts at the &lt;vh&gt; tag and continues until the &lt;/vh&gt; tag.  sss is the headline text encoded with the usual XML escapes.

As shown above, a v element may contain nested v elements.  Each vnode corresponds to a headline on the screen, and vnodes are written to the file in the order they would appear on the screen if all headlines were fully expanded.

The nesting relationship between vnodes gives the outline structure.  v elements for child vnodes are nested within the v elements of parent vnodes.  Therefore, the outline level of a v element is the number of unclosed v elements containing it.

Zero or more of the following three attributes may appear before the &gt; that terminates the &lt;v...&gt; tag.

t="T23"
vtag="V18"
a="xxxx"

The t="Tnnn" attribute specifies the tnode associated with this vnode.  (See the section describing the &lt;t&gt; tag for more details.

The vtag="Vnnn" attributes specifies the vtag number for this node.  This tag is specified only if a clone window exists for this vnode.

The a="xxxx" attribute specifies vnode attributes.  The xxxx denotes one or more upper-case letters whose meanings are as follows:

C	The vnode is a clone.
E	The vnode is expanded so its children are visible.
M	The vnode is marked.
T	The vnode is the top visible node.
V	The vnode is the current vnode.

For example, a="CEM"  specifies that the vnode is a clone, is expanded and is marked.
</t>
<t tx="edream.110203163054.1037">The tnodes element specifies the list of tnodes of an outline.

The tnodes element starts with &lt;tnodes...&gt; and ends with &lt;/tnodes&gt;.  In between these tags are zero or more t elements.  
</t>
<t tx="edream.110203163054.1038">The t element represents a single tnode.  Each tnode represents body text.  Because of cloning, a tnode may be shared among several vnodes.

tnodes have the following form:

&lt;t...&gt;&lt;tb&gt;sss&lt;/tb&gt;&lt;/t&gt;

The tb element specifies the body text.  As usual it starts at the &lt;tb&gt; tag and continues until the &lt;/tb&gt; tag.  sss is the headline text encoded with the usual XML escapes.

The tx="Tnnn" attribute must appear before the &gt; that terminates the &lt;t...&gt; tag.  It specifies the tnode index of the tnode.  Vnodes refer to this index in their t="Tnnn" attribute.

The rtf="1" attribute may appear before the &gt; that terminates the &lt;t...&gt;tag.  If present it specifies that body text is encoded as Rich Text Format.  This attribute is not used at present.
</t>
<t tx="edream.110203163054.1039">The clone_windows element is optional.  If present it specifies the list of cloned windows of an outline.

The clone_windows element starts with &lt;clone_windows&gt; and ends with &lt;/clone_windows&gt;.  In between these tags are one or more clone_window elements.  
</t>
<t tx="edream.110203163054.1040">The clone_window element specifies a single clone window to be opened when the file opens.

The clone_window element has the following form:

	&lt;clone_window vtag="Vnnn"&gt;
		&lt;global_window_position top="nnn" left="nnnn" height="nnn" width="nnn" &gt;
	&lt;/clone_window&gt;

All attributes and elements shown above are required.

The vtag attribute must match the vtag attribute in some vnode, and associates the clone window with the vnode.

The global_window_position element specifies the size and position of the clone window.  The top and left attributes specify the position of the clone window in global coordinates.  The height and width attributes specify the size of the clone window.</t>
<t tx="edream.110203163054.1041">&lt;!-- This is a comment --&gt;
&lt;!-- Version 1 of LEO DTD --&gt;

&lt;!DOCTYPE LeoOutlineDocumentType [

&lt;!-- A LEO file consists of the following parts (clone_windows is optional) --&gt;
&lt;!ELEMENT leo_file (header, globals, prefs, find_settings, vnodes, tnodes, clone_windows?) &gt;

&lt;!ELEMENT header EMPTY &gt;
    &lt;!ATTLIST header
        file_format     CDATA #REQUIRED  &lt;!-- An integer version number --&gt;
        tnodes          CDATA #REQUIRED  &lt;!-- Unused at present --&gt;
        max_tnode_index CDATA #REQUIRED  &lt;!-- The size of the array used to resolve tnode indices --&gt;
        clone_windows   CDATA 0 &gt;  &lt;!-- Number of clone windows --&gt;

&lt;!ELEMENT globals (global_window_position? global_log_window_position?) &gt;
    &lt;!ATTLIST globals body_outline_ratio CDATA 0.5 &gt;
    &lt;!ELEMENT global_window_position EMPTY &gt;
        &lt;!ATTLIST global_window_position
            top     CDATA #REQUIRED
            left    CDATA #REQUIRED
            height  CDATA #REQUIRED
            width   CDATA #REQUIRED &gt;
    &lt;!ELEMENT global_log_window_position EMPTY &gt;
        &lt;!ATTLIST global_window_position
            top     CDATA #REQUIRED
            left    CDATA #REQUIRED
            height  CDATA #REQUIRED
            width   CDATA #REQUIRED &gt;

&lt;!ELEMENT preferences ( syntax_options? ) &gt;
    &lt;!ATTLIST preferences
        &lt;!-- The following specify defaults for preferences --&gt;
		allow_rich_text  CDATA 0
		tab_width        CDATA 4
		page_width       CDATA 132
		font_name		CDATA "Courier New"
		font_size		CDATA 9 &gt;
    &lt;!ELEMENT syntax_options (#PCDATA) &gt;

&lt;!ELEMENT find_settings (find_string? change_string?) &gt;
    &lt;!ATTLIST find_settings
        &lt;!-- The following specify defaults for the find/change panel --&gt;
        batch            CDATA 0
        wrap_around      CDATA 0
        batch            CDATA 0
        whole_word       CDATA 1
        ignore_case      CDATA 0
        pattern_match    CDATA 0
        search_head_text CDATA 0
        search_body_text CDATA 1
        suboutline_only  CDATA 0
        mark_changes     CDATA 0
        mark_finds       CDATA 0
        reverse          CDATA 0 &gt;
    &lt;!ELEMENT find_string   (#PCDATA) &gt;
    &lt;!ELEMENT change_string (#PCDATA) &gt;

&lt;!ELEMENT vnodes (v*) &gt;
    &lt;!ELEMENT v (vh, v*) &gt;  &lt;!-- The crucial change: vnode may contain other vnodes --&gt;
        &lt;!ATTLIST v
            vtag ID    #IMPLIED       &lt;!-- for use by clone_windows section --&gt;
            t    IDREF #IMPLIED       &lt;!-- the tnode for this vnode, or none --&gt;
            a    CDATA "" &gt;    &lt;!-- V=current, M=marked, C=cloned, E=expanded --&gt;
    &lt;!ELEMENT vh (#PCDATA) &gt;

&lt;!ELEMENT tnodes (t*)&gt;
    &lt;!ELEMENT t (#PCDATA) &gt;
        &lt;!ATTLIST t
            tx  ID
            rtf CDATA 0 &gt;      &lt;!-- 1 if the #PCDATA is rtf format --&gt;

&lt;!ELEMENT clone_windows (clone_window*) &gt;
    &lt;!ELEMENT clone_window (global_clone_window_position) &gt;
        &lt;!ATTLIST clone_window
            vref IDREF #REQUIRED &gt;    &lt;!-- the vtag of the vnode that owns this clone window --&gt;
        &lt;!ELEMENT global_clone_window_position EMPTY &gt;
            &lt;!ATTLIST global_clone_window_position
                top     CDATA #REQUIRED
                left    CDATA #REQUIRED
                height  CDATA #REQUIRED
                width   CDATA #REQUIRED &gt;
]
</t>
<t tx="edream.110203163054.1042">The following node contains the text of an actual leo file.  After that node is a node containing the outline that created the leo file.</t>
<t tx="edream.110203163054.1043">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="1" tnodes="4" max_tnode_index="4" clone_windows="0"/&gt;
&lt;globals body_outline_ratio="0.499"&gt;
	&lt;global_window_position top="54" left="54" height="550" width="559"/&gt;
	&lt;global_log_window_position top="2" left="630" height="397" width="336"/&gt;
&lt;/globals&gt;
&lt;preferences allow_rich_text="0" tab_width="4" page_width="72" tangle_bat="0" untangle_bat="0"&gt;
	&lt;TSyntaxMemo_options&gt;DBSoft6:OPT#8#67100656GWD#1#0GCL#11#-2147483633WRC#1#0IDS#1#1WRO#3#&amp;gt;|:FON#11#Courier NewFOS#1#9STC#8#16777215STB#7#8388608TBC#0#TBD#1#4EFF#323#18,0,0,16777215,;3,0,16777215,;4,8421504,16777215,;5,0,16777215,;6,255,16777215,;10,16711680,16777215,;11,0,16777215,;12,16711680,16777215,;14,16711680,16777215,;15,255,16777215,;16,16711680,16777215,;17,255,16777215,;18,16711680,16777215,;19,32768,16777215,;30,255,16777215,;32,0,16777215,;33,255,16777215,;36,0,16777215,;GDF#1#0MDF#1#0SDF#1#0BDF#1#0FOC#1#0RMG#1#0LNN#13#MS Sans SerifLNS#1#8LNC#11#-2147483640LNT#1#1LNE#0##END#&lt;/TSyntaxMemo_options&gt;
&lt;/preferences&gt;
&lt;find_panel_settings whole_word="1" search_body="1"&gt;
	&lt;find_string&gt;error&lt;/find_string&gt;
	&lt;change_string&gt;&lt;/change_string&gt;
&lt;/find_panel_settings&gt;
&lt;vnodes&gt;
&lt;v t="T1" a="TV"&gt;&lt;vh&gt;Headline 1&lt;/vh&gt;
&lt;v t="T2" a="E"&gt;&lt;vh&gt;Headline 2&lt;/vh&gt;
&lt;v&gt;&lt;vh&gt;Headline 3 ( No body text)&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;v t="T3" a="C"&gt;&lt;vh&gt;Headline 4 ( a clone )&lt;/vh&gt;
&lt;v t="T4"&gt;&lt;vh&gt;Headline 5&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="T3" a="C"&gt;&lt;vh&gt;Headline 4 ( a clone )&lt;/vh&gt;
&lt;v t="T4"&gt;&lt;vh&gt;Headline 5&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="T1"&gt;Text of headline 1.&lt;/t&gt;
&lt;t tx="T2"&gt;Text of headline 2.&lt;/t&gt;
&lt;t tx="T3"&gt;Text of headline 4.&lt;/t&gt;
&lt;t tx="T4"&gt;Text of headline 5.&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;</t>
<t tx="edream.110203163054.1044"></t>
<t tx="edream.110203163054.1045">Text of headline 1.</t>
<t tx="edream.110203163054.1046">Text of headline 2.</t>
<t tx="edream.110203163054.1047"></t>
<t tx="edream.110203163054.1048">Text of headline 4.</t>
<t tx="edream.110203163054.1049">Text of headline 5.</t>
<t tx="edream.110203163054.1050">@nocolor</t>
<t tx="edream.110203163054.1051"></t>
<t tx="edream.110203163054.1052">First, read the introduction to Leo at:
http://webpages.charter.net/edreamleo/intro.html

Then study LeoPy.leo, the source code for leo.py. The best way to learn about
Leo is to spend 15 or 20 minutes just browsing through the outline, not
worrying about details but just seeing how most nodes are organized and how
directives and section references are typically used. Then read Chapter 4 to
learn the details.

When studying leo.py, I would suggest paying particular attention to the
following:

1. The (Projects) tree shows how to use clones to represent tasks.

2. The @file leoNodes.py tree shows how to define more than one class in a
single file using several @others directives. Note that the @others directives
must be in separate nodes.

3. Most other files show how to use a single @others directive to define one
class.

4. Note in particular that the vast majority of methods are defined in unnamed
nodes.</t>
<t tx="edream.110203163054.1053">The file LeoDocs.leo contains two "Hello World" programs, using @file trees and
@root trees.

The file LeoPy.leo contains a large number of other examples, some small, some
large and complex.</t>
<t tx="edream.110203163054.1054">Leo's clones provide an excellent way of solving any organizational problem.
The fundamental principle is this: Clones create multiple views of data.

For example, whenever I have a task to do, say a new feature to implement, or a
non-trivial bug to fix, I create a new headline to represent that task. Let's
call such a headline a task headline. By convention, I enclose the headline in
parentheses and put an @ignore in the body text of the headline, but that's
just a convention I use.

I clone all nodes that relate to that task and move the clones under the
headline. Voila. I now have a new view of Leo's source code, containing all and
only those nodes that relate to the task. It is now trivial to find the parts
of code relating to the task. Note that I can change the cloned nodes under the
headline task in any way, and the clones under the @file tree also change and
the @file node itself is marked dirty so that when I save the .leo file all
affected @file trees are also saved. The task headline is a perfect place to
place notes about the task: why some approaches didn't work, to-do lists, test
data, whatever. You could even create @file nodes to create test files if you
want.

There are situations where you need to use @root trees. However, those
situations are rare. Most of the time you can use clones to great effect. For
extended examples, look at the (Projects) section in LeoPy.leo. That section
contains a large number of views of Leo itself.</t>
<t tx="edream.110203163054.1055">Leo's @file trees and @root trees represent derived files within an outline.
Leo outlines may contain both @root and @file trees, and I recommend using
@file trees whenever possible.

Indeed, @file trees are much easier to use than @root trees:

1. @file trees require less markup than @root trees; all sections in @root
trees must have names, but @file trees usually contain many unnamed sections.
Within @file trees, the @others directive acts like a reference to all unnamed
sections.

2. The user must explicitly tangle and untangle @root trees using the Tangle
and Untangle commands. Leo tangles and untangles @file trees automatically,
tangling all changed @file trees when writing an outline and untangling all
@file trees when reading an outline.

However, @root trees are more flexible than @file trees.

1. Within @file trees, sections must be defined in descendents of the node that
contains the section reference.

2. Within @root trees a section may be defined anywhere within the @root tree,
regardless of where the section is referenced. Moreover, the @unit directive
expands the scope of section definitions in @root trees so that a section may
be referenced in several @root trees.

3. The meaning of section definitions in @root trees are independent of their
position within the tree.</t>
<t tx="edream.110203163054.1056"></t>
<t tx="edream.110203163054.1057">Internally, Leo represents all strings as unicode. Leo translates from a particular encoding to unicode when reading .leo files or derived files. Leo translates from unicode to a particular encoding when writing derived files. You may see strange looking characters if your text editor is expecting a different encoding.

The encoding used in any derived file is shown in the #@+leo line like this: #@+leo-encoding=iso-8859-1. Exception: the encoding is UTF-8 if no -encoding= field exists.  You can also use the @encoding directive to set the encoding for individual derived files.

If no @encoding directive is in effect, Leo uses settings in leoConfig.leo/.txt to translate to and from unicode. These settings are in the section in leoConfig.leo called

&lt;&lt; General configuration options, especially read-only mode &gt;&gt;

Here is a summary of those settings:

default_derived_file_encoding

This is the encoding used for derived files if no @encoding directive is in
effect. This setting is also used to encode files created by the Tangle
commands. The default is UTF-8 (case not important).

new_leo_file_encoding

This is the encoding specified in the following line of new .leo files: &lt;?xml
version="1.0" encoding="UTF-8"&gt; The default is UTF-8 (upper case for
compatibility for old versions of Leo). Important: once a .leo file is created
the &lt;?xml..."&gt; line can only be changed by hand. Changing the &lt;?xml..."&gt; line
by hand may cause unicode errors the next time the .leo file is loaded, so you
should change the &lt;?xml..."&gt; line by hand only when first creating a .leo file.

tk_encoding

This is the encoding that Leo uses to communicate with Tk text widgets. You
would typically use this setting only in an emergency. The section called &lt;&lt;
set app.tkEncoding &gt;&gt; in app.finishCreate sets this encoding as follows:

a)using the tk_encoding setting if it exists,
b) using locale.getpreferredencoding if it exists, or the equivalent code in pre-python
2.3 versions,
c) using sys.getdefaultencoding
d) defaulting to "utf-8"

Neither b nor c are guaranteed to give a valid encoding in all systems, and Leo
will ignore invalid encodings returned from b or c. Therefore, setting
tk_encoding in leoConfig may be needed.</t>
<t tx="edream.110203163054.1058">The encoding used in the file being imported doesn't match the encoding in
effect for Leo. You have two options:Use the @encoding directive in an
ancestor of the node selected when doing the Import command to specify the
encoding of file to be imported.Set the tk_encoding option in
leoConfig.leo/.txt to the encoding you normally use. See the previous answer.</t>
<t tx="edream.110203163054.1059"></t>
<t tx="edream.110203163054.1060">You have two options, depending on whether you want to be able to use sections
or not.

Option 1: Use @nosentinelsfile trees.

Files derived from @nosentinelsfile trees contain no sentinels. However, Leo
creates derived files just as in @file trees. In particular, Leo expands
section references and understands the @others directive.

Option 2: Use @silentfile trees.

Files derived from @silentfile trees contain no sentinels. Moreover, Leo does
not expand section references in @silentfile trees. In other words, Leo creates
the derived file simply by writing all body text in outline order.

Leo can't update the outline unless the derived file contains sentinels, so Leo
does not update @nosentinelfile trees or @silentfile trees automatically when
you change the derived file in an external editor.

For complete details about @nosentinelfile trees and @silentfile trees, see the
child of this node.</t>
<t tx="edream.110203163054.1061">You have two options, depending on whether you want sentinel lines in your
derived file or not.

Option 1: Use @rawfiles trees.

Leo creates files derived from @rawfile trees by writing all the nodes of the
tree to the derived file in outline order. The derived file _does_ contain some
sentinels, so you _can_ update @rawfile trees from changes made to derived
files.

Option 1: Use @silentfiles trees.

Files derived from @silentfile trees contain no sentinels. Leo creates the
derived file simply by writing all body text in outline order.

Leo can't update the outline unless the derived file contains sentinels, so Leo
does not update @silentfile trees automatically when you change the derived
file in an external editor.

For complete details about @rawfile and @silentfile trees, see the child of
this node.</t>
<t tx="edream.110203163054.1062">The import commands insert @ignore directives in the top-level node. Leo does
this so that you won't accidentally overwrite your files after importing them.
Change the filename following @file or @root as desired, then remove the
@ignore directive. Saving the outline will then create the file.</t>
<t tx="edream.110203163054.1063">Q: I'm writing a Windows Script Component, which is an XML file with a CData
section containing javascript. I can get the XML as I want it by setting the
language to html, but how can I get the tangling comments inside the CData
section to be java-style comments rather than html ones?

A: In @file trees you use the @delims directive to change comment delimiters.
For example:

@delims /* */ 
Javascript stuff 
@delims &lt;-- --&gt; 
HTML stuff

Important: Leo2 can not revert to previous delimiters automatically; you must
change back to previous delimiters using another @delims directive.

In @root trees you can work around this problem using the @silent directive.</t>
<t tx="edream.110203163054.1064">Here is a letter from Zvi Boshernitzan which might be helpful:

I was having trouble disabling &lt;?php with comments (and couldn't override the
comment character for the start of the page).

Finally, I found a solution that worked, using php's heredoc string syntax:

-------------------------------
@first &lt;?php
@first $comment = &lt;&lt;&lt;EOD
EOD;

// php code goes here.
echo "boogie";

$comment2 = &lt;&lt;&lt;EOD
@last EOD;
@last ?&gt;
--------------------

  -- or --

---------------------
@first &lt;?php
@first /*
*/

echo "hi";

@delims /* */
@last ?&gt;
------------------------</t>
<t tx="edream.110203163054.1065">Use the @first directive @file or @nosentinelsfile trees. Use the @silent in
@root trees.

The @first directive allows you to place lines at the very start of files
derived from @file nodes. For example, the body text of @file spam.py might be:

@first #! /usr/bin/env python

The body text of @file foo.perl might be:

@first #/usr/bin/perl

@first directives are recognized only at the start of the body text of @file nodes.
No text may precede @first directives. More than one @first directive may exist,
like this:

@first #! /usr/bin/env python
@first # more comments.
</t>
<t tx="edream.110203163054.1066">Leo has good support for cweb. In @file trees can organize any part of cweb
code using _noweb_ sections. You can also use @rawfile, @silentfile or
@nosentinelsfile trees to create cweb files.

By default, cweb colors @space, @* and @** sections using the same syntax
coloring as for LaTeX. In addition, cweb colors C // and /*..*/ comments using
LaTeX coloring by default. You may change these defaults using the
color_cweb_doc_parts_with_latex and color_cweb_comments_with_latex options in
leoConfig.leo.

See the child of this node for full details.</t>
<t tx="edream.110203163054.1067">Everything in an @file tree must be part of the derived file: orphan and
@ignore nodes are invalid in @file trees. This restriction should not be
troublesome. For example, you can organize your outline like this:

+ myClass
..+ ignored stuff
..+ @file myClass

As usual, + denotes a headline. So you simply create a new node, called
myClass, that holds your @file tree and stuff you don't want in the @file tree.</t>
<t tx="edream.110203163054.1068">There are many ways to customize Leo.  The child of this node is a clone of Chapter 8: Customizing Leo of Leo's Users Guide.</t>
<t tx="edream.110203163054.1069">Step 1: Set use_plugins = 1 in leoConfig.leo, then execute the Tangle All
command.

Or you can set use_plugins = 1 directly in leoConfig.txt.

Step 2: For a particular @file node in leoPlugins.leo, enable the code that
calls registerHandler by changing if 0: to if 1:

For example:

if 1: # Register the handlers...
	registerHandler("start2", onStart)

</t>
<t tx="edream.110203163054.1070">1. What's the best way to go about adding a new @language? 

In the short term, the instructions are in LeoPy.leo in the Notes:How To:How to
add support for a new language section. This section contains clones of all
relevant parts of Leo that you will change.

Longer term, I plan to move to a scheme like JEdit's, which uses language
description files. Perhaps Leo could even use these files. However, this won't
happen for quite a while...

2. How can the changes be best folded back into Leo?

For now, you can only change Leo's source code and submit the changes for
inclusion in Leo's "official" code. Longer term you will be able to create
your own language description file.</t>
<t tx="edream.110203163054.1071"></t>
<t tx="edream.110203163054.1072">leo.py v2.5 and later does this automatically.

For earlier versions, the workaround is as follows:

1. Copy the node with the Copy Node command.
2. Paste it into to _body_ text with a regular paste command.
3. Copy the body text with a regular copy or cut command.
4. Switch to the other copy of Leo, then do Paste Node.</t>
<t tx="edream.110203163054.1073">@nocolor

Here are the steps involved in adding a new language.

- Add a new language constant in leoGlobals.&lt;&lt;define global constants&gt;&gt;

- Add a new Tk.Radiobutton in leoPrefs.&lt;&lt;create the Target Language frame&gt;&gt;

- Add a new entry for the language in self.languageNameDict in leoConfig.py.&lt;&lt;initialize constant ivars&gt;&gt;.

This entry represents the name of the language in leoConfig.txt.

- Modify the utility routines set_delims_from_language and set_language to handle the new language.

- Modify the code in leoFileCommands.getPrefs.&lt;&lt; check for syntax coloring prefs &gt;&gt; to support the new language.

This involves making new entries in lists in each function.

- Modyify leoColor.py so that colorizeAnyLanguage will handle the new language:

a. Add an entry in the list called "languages" defined  in
	leoColor.&lt;&lt;configure language-specific settings&gt;&gt;

b. Add a list containing the keywords of the new language to
	leoColor.&lt;&lt; define colorizer keywords &gt;&gt;
	
Note: the name of this list must be x_keywords, where x is the entry in language in step a.
	
For example, to add tcltk:
	
	languages = (..., "tcltk",...) # list of names of keyword lists.
	tcltk_keywords = ("after", "append", ...) # The keyword list for the tcl/tk language.
		
c. Add any language-specifig code to leoColor.colorizeAnyLanguage.

For most languages nothing need be done in this step because colorizeAnyLanguage gets the comment delimiters from set_delims_from_language.

-  Make the following tests:

1. Test the syntax coloring for the new language by using the @language directive.

2. Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

3. Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

4. Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the &lt;preferences&gt; tag (near the top) contains an entry like this:

&lt;preferences allow_rich_text="0" defaultTargetLanguage="Python"&gt;
&lt;/preferences&gt;

but with the name of your new language instead of "Python".

5. Create an @root node and verify that you can Tangle it.

</t>
<t tx="edream.110203163054.1074"># We put an @color here so it is unambiguous.

@ignore
@language python
@color</t>
<t tx="edream.110203163054.1075"># General constants...
true = 1
false = 0 # Better than None
body_newline = '\n'
body_ignored_newline = '\r'
prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

# New in leo.py 3.0
prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
prolog_version_string1 = "UTF-8" # for leo.py 2.x
prolog_version_string2 = "ISO-8859-1" # for leo.py 3.x
prolog_postfix_string = "?&gt;"

# These are set by the @langauge directive.
# Used by Tangle, Untangle and syntax coloring.
ada_language =		 1
c_language =		 2  # C, C++ or objective C.
cweb_language =		 3  # CWEB syntax coloring
cobol_language =	 4  # literate cobol??
fortran_language =	 5  # Comments start with C
fortran90_language =	 6  # Comments start with !
html_language =		 7
java_language =		 8
lisp_language =		 9
pascal_language =	10
plain_text_language =	11
perl_language =		12  # just ##
perlpod_language =	13  # ## and =pod and =cut
python_language =	14
shell_language =	15  # shell scripts
tcltk_language = 16
unknown_language =	17  # Set when @comment is seen.

# Synonyms for the bits returned by is_special_bits...
color_bits =    0x00001
comment_bits =	 0x00002
cweb_bits =     0x00004
header_bits =   0x00008
ignore_bits =   0x00010
language_bits = 0x00020
nocolor_bits =	 0x00040
noheader_bits = 0x00080
noweb_bits =    0x00100
#               0x00200 #unused
page_width_bits=0x00400
path_bits =	    0x00800
root_bits =	    0x01000 # Also represents &lt; &lt; * &gt; &gt; =
silent_bits =	  0x02000
tab_width_bits =0x04000
terse_bits = 	  0x08000
unit_bits = 	   0x10000
verbose_bits =	 0x20000</t>
<t tx="edream.110203163054.1076"># Frame and title
w,target = create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
	("C/C++",c_language), ("CWEB", cweb_language),
	("HTML", html_language), ("Java", java_language),
	("Pascal", pascal_language) ]

for text,value in left_data:
	button = Tk.Radiobutton(lt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x") 
	
# Right column of radio buttons.
right_data = [ ("Perl", perl_language), ("Perl+POD", perlpod_language),
	("Plain Text", plain_text_language), ("Python", python_language),
	("tcl/tk", tcltk_language) ]
	
for text,value in right_data:
	button = Tk.Radiobutton(rt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x")</t>
<t tx="edream.110203163054.1077">leoKeywords = (
	# Leo 2 directives.
	"@","@c","@code","@doc","@color","@comment",
	"@delims","@first","@language","@nocolor","@others",
	"@pagewidth","@path","@tabwidth",
	# Leo 1 directives.
	"@ignore","@root","@unit","@silent","@terse","@verbose")
	
c_keywords = (
	# C keywords
	"auto","break","case","char","continue",
	"default","do","double","else","enum","extern",
	"float","for","goto","if","int","long","register","return",
	"short","signed","sizeof","static","struct","switch",
	"typedef","union","unsigned","void","volatile","while"
	# C++ keywords
	"asm","bool","catch","class","const_cast",
	"delete","dynamic_cast","explicit","false","friend",
	"inline","mutable","namespace","new","operator",
	"private","protected","public","reinterpret_cast","static_cast",
	"template","this","throw","true","try",
	"typeid","typename","using","virtual","wchar_t")
	
cweb_keywords = c_keywords

html_keywords = (
	# HTML constructs.
	"&lt;","&lt;/","&gt;",
	'"',
	"&lt;!---","&lt;!--","&lt;!",
	"&lt;%","%&gt;",
	"&lt;a","&lt;/a",
	"&lt;img",
	"&lt;cf","&lt;/cf",
	# Common tags: tables
	"&lt;table","&lt;/table",
	"&lt;td","&lt;/td",
	"&lt;th","&lt;/th",
	"&lt;tr","&lt;/tr",
	"&lt;caption","&lt;/caption",
	"&lt;col","&lt;/col",
	"&lt;colgroup","&lt;/colgroup",
	"&lt;tbody","&lt;/tbody",
	"&lt;tfoot","&lt;/tfoot",
	"&lt;thead","&lt;/thead",	
	# Common tags: styles
	"&lt;style","&lt;/style",
	# Common tags: scripts
	"&lt;script","&lt;/script",
	# Escapes
	"&amp;amp;", "&amp;lt;", "&amp;gt;", "&amp;quot;" )

java_keywords = (
	"abstract","boolean","break","byte","byvalue",
	"case","cast","catch","char","class","const","continue",
	"default","do","double","else","extends",
	"false","final","finally","float","for","future",
	"generic","goto","if","implements","import","inner",
	"instanceof","int","interface","long","native",
	"new","null","operator","outer",
	"package","private","protected","public","rest","return",
	"short","static","super","switch","synchronized",
	"this","throw","transient","true","try",
	"var","void","volatile","while")

pascal_keywords = (
	"and","array","as","begin",
	"case","const","class","constructor","cdecl"
	"div","do","downto","destructor","dispid","dynamic",
	"else","end","except","external",
	"false","file","for","forward","function","finally",
	"goto","if","in","is","label","library",
	"mod","message","nil","not","nodefault""of","or","on",
	"procedure","program","packed","pascal"
	"private","protected","public","published",
	"record","repeat","raise","read","register",
	"set","string","shl","shr","stdcall",
	"then","to","true","type","try","until","unit","uses"
	"var","virtual","while","with","xor"
	# object pascal
	"asm","absolute","abstract","assembler","at","automated",
	"finalization",
	"implementation","inherited","initialization","inline","interface",
	"object","override","resident","resourcestring",
	"threadvar",
	# limited contexts
	"exports","property","default","write","stored","index","name" )

perl_keywords = (
	"continue","do","else","elsif","format","for","format","for","foreach",
	"if","local","package","sub","tr","unless","until","while","y",
	# Comparison operators
	"cmp","eq","ge","gt","le","lt","ne",
	# Matching ooperators
	"m","s"
	# Unary functions
	"alarm","caller","chdir","cos","chroot","exit","eval","exp",
	"getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
	"hex","int","length","localtime","log","ord","oct",
	"require","reset","rand","rmdir","readlink",
	"scalar","sin","sleep","sqrt","srand","umask",
	# Transfer ops
	"next","last","redo","go","dump",
	# File operations...
	"select","open",
	# FL ops
	"binmode","close","closedir","eof",
	"fileno","getc","getpeername","getsockname","lstat",
	"readdir","rewinddir","stat","tell","telldir","write",
	# FL2 ops
	"bind","connect","flock","listen","opendir",
	"seekdir","shutdown","truncate",
	# FL32 ops
	"accept","pipe",
	# FL3 ops
	"fcntl","getsockopt","ioctl","read",
	"seek","send","sysread","syswrite",
	# FL4 &amp; FL5 ops
	"recv","setsocket","socket","socketpair",
	# Array operations
	"pop","shift","split","delete",
	# FLIST ops
	"sprintf","grep","join","pack",
	# LVAL ops
	"chop","defined","study","undef",
	# f0 ops
	"endhostent","endnetent","endservent","endprotoent",
	"endpwent","endgrent","fork",
	"getgrent","gethostent","getlogin","getnetent","getppid",
	"getprotoent","getpwent","getservent",
	"setgrent","setpwent","time","times","wait","wantarray",
	# f1 ops
	"getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
	"sethostent","setnetent","setprotoent","setservent",
	# f2 ops
	"atan2","crypt",
	"gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
	"index","link","mkdir","msgget","rename",
	"semop","setpgrp","symlink","unpack","waitpid",
	# f2 or 3 ops
	"index","rindex","substr",
	# f3 ops
	"msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
	# f4 &amp; f5 ops
	"semctl","shmread","shmwrite","msgrcv",
	# Assoc ops
	"dbmclose","each","keys","values",
	# List ops
	"chmod","chown","die","exec","kill",
	"print","printf","return","reverse",
	"sort","system","syscall","unlink","utime","warn")

perlpod_keywords = perl_keywords
	
python_keywords = (
	"and",       "del",       "for",       "is",        "raise",    
	"assert",    "elif",      "from",      "lambda",    "return",   
	"break",     "else",      "global",    "not",       "try",      
	"class",     "except",    "if",        "or",        "yield",   
	"continue",  "exec",      "import",    "pass",      "while",
	"def",       "finally",   "in",        "print")
	
tcltk_keywords = ( # Only the tcl keywords are here.
	"after",     "append",    "array",
	"bgerror",   "binary",    "break",
	"catch",     "cd",        "clock",
	"close",     "concat",    "continue",
	"dde",
	"encoding",  "eof",       "eval",
	"exec",      "exit",      "expr",
	"fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
	"filename",  "flush",     "for",       "foreach",   "format",
	"gets",      "glob",      "global",
	"history",
	"if",        "incr",      "info",      "interp",
	"join",
	"lappend",   "lindex",    "linsert",   "list",      "llength",
	"load",      "lrange",    "lreplace",  "lsearch",   "lsort",
	"memory",    "msgcat",
	"namespace",
	"open",
	"package",   "parray",    "pid",
	"proc",      "puts",      "pwd",
	"read",      "regexp",    "registry",   "regsub",
	"rename",    "resource",  "return",
	"scan",      "seek",      "set",        "socket",   "source",
	"split",     "string",    "subst",      "switch",
	"tell",      "time",      "trace",
	"unknown",   "unset",     "update",     "uplevel",   "upvar",
	"variable",  "vwait",
	"while" )</t>
<t tx="edream.110203163054.1078"># Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end

(single_comment_start,
	block_comment_start,
	block_comment_end) = set_delims_from_language(language)

has_string = language != plain_text_language

languages = ["c","cweb","html","java","pascal","perl","perlpod","python","tcltk"]

keywords = []
if language==cweb_language:
	for i in c_keywords:
		keywords.append(i)
	for i in cweb_keywords:
		keywords.append(i)
else:
	for name in languages:
		exec("if language==%s_language: keywords=%s_keywords" % (name,name))

if 1: # 7/8/02: Color plain text unless we are under the control of @nocolor.
	state = choose(flag,normalState,nocolorState)
else: # Stupid: no coloring at all in plain text.
	state = choose(language==plain_text_language,nocolorState,normalState)

lb = choose(language==cweb_language,"@&lt;","&lt;&lt;")
rb = choose(language==cweb_language,"@&gt;","&gt;&gt;")</t>
<t tx="edream.110203163054.1079"># Must match longer tags before short prefixes.
language = c_language # default

if self.matchTag("CWEB"):
	language = cweb_language ; self.getDquote();
elif self.matchTag("C"):
	language = c_language ; self.getDquote()
elif self.matchTag("HTML"):
	language = html_language ; self.getDquote()
elif self.matchTag("Java"):
	language = java_language ; self.getDquote()
elif self.matchTag("Pascal"):
	language = pascal_language ; self.getDquote()
elif self.matchTag("PerlPod"):
	language = perlpod_language ; self.getDquote()
elif self.matchTag("Perl"):
	language = perl_language ; self.getDquote()
elif self.matchTag("Plain"):
	language = plain_text_language ; self.getDquote()
elif self.matchTag("Python"):
	language = python_language ; self.getDquote()
elif self.matchTag("tcl/tk"):
	language = tcltk_language ; self.getDquote()
	
# print(`language`)

c.target_language = language</t>
<t tx="edream.110203163054.1080"># Language names.
self.languageNameDict = {
	c_language: "C",
	cweb_language: "CWEB",
	html_language: "HTML",
	java_language: "Java",
	pascal_language: "Pascal",
	perl_language: "Perl",
	perlpod_language: "PerlPod",
	plain_text_language: "Plain",
	python_language: "Python",
	tcltk_language: "tcl/tk" }

# Names of sections.
self.configSection = "config options"
self.compareSection = "compare options"
self.findSection = "find/change options"
self.prefsSection = "prefs panel options"
self.recentFilesSection = "recent files"
self.colorsSection = "syntax coloring options"
self.windowSection = "window options"</t>
<t tx="edream.110203163054.1081"># Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):
	
	# trace(`language`)

	for lang, val in [ (cweb_language, "// /* */"),
		(c_language, "// /* */"), (java_language, "// /* */"),
		(fortran_language, "C"), (fortran90_language, "!"),
		(html_language, "&lt;!-- --&gt;"), (pascal_language, "// { }"),
		(perl_language, "#"), (perlpod_language, "# =pod =cut"),
		(plain_text_language, "#"), # 7/8/02: we have to pick something.
		(shell_language, "#"), (python_language, "#"),
		(tcltk_language, "#") ]: # 7/18/02
		if lang == language:
			# trace(`val`)
			return set_delims_from_string(val)

	return None, None, None # Indicate that no change should be made</t>
<t tx="edream.110203163054.1082">@  Scans the @language directive that appears at s[i]. 'default' returns default_language.

Returns (language, delim1, delim2, delim3)
@c

def set_language(s,i,issue_errors_flag,default_language):

	tag = "@language"
	# trace(`get_line(s,i)`)
	assert(i != None)
	assert(match_word(s,i,tag))
	i += len(tag) ; i = skip_ws(s, i)
	# Get the argument.
	j = i
	i = skip_c_id(s,i)
	# Allow tcl/tk.
	arg = string.lower(s[j:i])
	if len(arg) &gt; 0:
		for name, language in [ ("ada", ada_language),
			("c", c_language), ("c++", c_language),
			("cweb", cweb_language), ("default", default_language),
			("fortran", fortran_language), ("fortran90", fortran90_language),
			("html", html_language), ("java", java_language),
			("lisp", lisp_language), ("objective-c", c_language),
			("pascal", pascal_language), ("perl", perl_language),
			("perlpod", perlpod_language),
			("plain", plain_text_language), # 7/8/02
			("python", python_language),
			("shell", shell_language),
			("tcl", tcltk_language) ]: # 7/18/02.  Note: this also matches tcl/tk.
		
			if arg == name:
				delim1, delim2, delim3 = set_delims_from_language(language)
				return language, delim1, delim2, delim3

	if issue_errors_flag:
		es("ignoring: " + get_line(s,i))

	return None, None, None, None,</t>
<t tx="edream.110203163054.1083">tags = (
	"blank", "comment", "cwebName", "docPart", "keyword", "leoKeyword",
	"link", "name", "nameBrackets", "pp", "string", "tab")

def colorizeAnyLanguage(self,v,body,language,flag):
	
	#trace(`language`)

	hyperCount = 0 # Number of hypertext tags
	self.body = body # For callbacks
	s = body.get("1.0", "end")
	sel = body.index("insert") # get the location of the insert point
	start, end = string.split(sel,'.')
	start = int(start)
	# trace(`self.count` + `v`)
	# trace(`body.tag_names()`)

	if 0: # Remove all tags from the selected line.
		for tag in self.tags:
			body.tag_remove(tag, index(start,0), index(start,"end"))
	else: # Remove all tags from body.
		body.tag_delete(
			"blank", "comment", "cwebName", "docPart", "keyword", "leoKeyword",
			"link", "name", "nameBrackets", "pp", "string", "tab")
	&lt;&lt; configure tags &gt;&gt;
	&lt;&lt; configure language-specific settings &gt;&gt;
	self.count += 1
	
	lines = string.split(s,'\n')
	n = 0 # The line number for indices, as in n.i
	for s in lines:
		n += 1 ; i = 0 ; sLen = len(s)
		# trace(`n` + ", " + `s`)
		while i &lt; sLen:
			progress = i
			ch = s[i]
			if state == string3State:
				&lt;&lt; continue python triple string &gt;&gt;
				continue
			elif state == docState:
				&lt;&lt; continue doc part &gt;&gt;
				continue
			elif state == nocolorState:
				&lt;&lt; continue nocolor state &gt;&gt;
				continue
			elif state == blockCommentState:
				&lt;&lt; continue block comment &gt;&gt;
				continue
			else: assert(state == normalState)

			if has_string and ch == '"' or ch == "'":
				&lt;&lt; handle string &gt;&gt;
			elif single_comment_start and match(s,i,single_comment_start):
				&lt;&lt; handle single-line comment &gt;&gt;
			elif block_comment_start and match(s,i,block_comment_start):
				&lt;&lt; start block comment &gt;&gt;
			elif ch == '#' and language in [c_language,cweb_language]:
				&lt;&lt; handle C preprocessor line &gt;&gt;
			elif match(s,i,lb) or (language==cweb_language and match(s,i,"@(")):
				&lt;&lt; handle possible section ref or def &gt;&gt;
			elif ch == '@':
				&lt;&lt; handle possible @keyword &gt;&gt;
			elif ch in string.letters:
				&lt;&lt; handle possible keyword &gt;&gt;
			elif ch == ' ':
				&lt;&lt; handle blank &gt;&gt;
			elif ch == '\t':
				&lt;&lt; handle tab &gt;&gt;
			else:
				&lt;&lt; handle normal character &gt;&gt;
			assert(progress &lt; i)</t>
<t tx="edream.110203163054.1084">config = app().config
assert(config)

for name in default_colors_dict:
	option_name,default_color = default_colors_dict[name]
	option_color = config.getColorsPref(option_name)
	color = choose(option_color,option_color,default_color)
	# Must use foreground, not fg.
	try:
		body.tag_config(name, foreground=color)
	except: # Recover after a user error.
		body.tag_config(name, foreground=default_color)

underline_undefined = config.getBoolColorsPref("underline_undefined_section_names")
use_hyperlinks      = config.getBoolColorsPref("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if use_hyperlinks: 
	body.tag_config("link",underline=1) # defined
	body.tag_config("name",underline=0) # undefined
else:
	body.tag_config("link",underline=0)
	if underline_undefined:
		body.tag_config("name",underline=1)
	else:
		body.tag_config("name",underline=0)

if self.showInvisibles:
	if 1: # Very poor, and vaguely usable.
		body.tag_config("blank",background="black",bgstipple="gray25")
		body.tag_config("tab",background="black",bgstipple="gray50")
	else: # Doesn't work, but does increase the spacing ;-)
		body.tag_config("blank",font="Symbol")
		body.tag_config("tab",font="Symbol")
else:
	body.tag_config("blank",background="white")
	body.tag_config("tab",background="white")</t>
<t tx="edream.110203163054.1085"></t>
<t tx="edream.110203163054.1086">if language == cweb_language:
	&lt;&lt; handle cweb doc part &gt;&gt;
else:
	&lt;&lt; handle noweb doc part &gt;&gt;</t>
<t tx="edream.110203163054.1087">word = self.getCwebWord(s,i)
if word and len(word) &gt; 0:
	j = i + len(word)
	if word in ("@&lt;","@(","@c","@d","@f","@p"):
		state = normalState # end the doc part and rescan
	else:
		# The control code does not end the doc part.
		body.tag_add("keyword", index(n,i), index(n,j))
		i = j
		if word in ("@^","@.","@:","@="): # Ended by "@&gt;"
			j = string.find(s,"@&gt;",i)
			if j &gt; -1:
				body.tag_add("cwebName", index(n,i), index(n,j))
				body.tag_add("nameBrackets", index(n,j), index(n,j+2))
				i = j + 2
else:
	# Everthing up to the next "@" is in the doc part.
	j = string.find(s,"@",i+1)
	if j == -1: j = len(s)
	body.tag_add("docPart", index(n,i), index(n,j))
	i = j</t>
<t tx="edream.110203163054.1088">if i == 0 and match(s,i,lb):
	# Possible section definition line.
	state = normalState # rescan the line.
	continue
if i == 0 and ch == '@':
	j = self.skip_id(s,i+1)
	word = s[i:j]
	word = string.lower(word)
else:
	word = ""

if word in ["@c","@code","@unit","@root","@color","@nocolor"]:
	# End of the doc part.
	body.tag_remove("docPart", index(n,i), index(n,j))
	body.tag_add("leoKeyword", index(n,i), index(n,j))
	i = j ; state = normalState
else:
	# The entire line is in the doc part.
	body.tag_add("docPart", index(n,i), index(n,sLen))
	i = sLen # skipt the rest of the line.</t>
<t tx="edream.110203163054.1089">delim = self.delim
if delim=="'''":
	j = string.find(s,"'''",i)
elif delim=='"""':
	j = string.find(s,'"""', i)
else:
	state=normalState ; self.delim = None ; continue

if j == -1:
	# The entire line is part of the triple-quoted string.
	body.tag_add("string", index(n,i), index(n,"end"))
	i = sLen # skipt the rest of the line.
else:
	# End the string
	body.tag_add("string", index(n,i), index(n,j+3))
	i = j + 3 ; state = normalState ; self.delim = None</t>
<t tx="edream.110203163054.1090">j = string.find(s,block_comment_end,i)
if j == -1:
	# The entire line is part of the block comment.
	body.tag_add("comment", index(n,i), index(n,"end"))
	i = sLen # skipt the rest of the line.
else:
	# End the block comment.
	k = len(block_comment_end)
	body.tag_add("comment", index(n,i), index(n,j+k))
	i = j + k ; state = normalState</t>
<t tx="edream.110203163054.1091">if i == 0 and ch == '@':
	j = self.skip_id(s,i+1)
	word = s[i:j]
	word = string.lower(word)
else:
	word = ""

if word == "@color" and language != plain_text_language:
	# End of the nocolor part.
	body.tag_add("leoKeyword", index(n,0), index(n,j))
	i = j ; state = normalState
else:
	# The entire line is in the nocolor part.
	# Add tags for blanks and tabs to make "Show Invisibles" work.
	for ch in s[i:]:
		if ch == ' ':
			body.tag_add("blank", index(n,i))
		elif ch == '\t':
			body.tag_add("tab", index(n,i))
		i += 1</t>
<t tx="edream.110203163054.1092">if language == python_language:
	j, state = self.skip_python_string(s,i)
	body.tag_add("string", index(n,i), index(n,j))
	i = j
else:
	j = self.skip_string(s,i)
	body.tag_add("string", index(n,i), index(n,j))
	i = j</t>
<t tx="edream.110203163054.1093">k = len(block_comment_start)
body.tag_add("comment", index(n,i), index(n,i+k))
i += k ; state = blockCommentState</t>
<t tx="edream.110203163054.1094">body.tag_add("comment", index(n,i), index(n,"end"))
i = sLen</t>
<t tx="edream.110203163054.1095">body.tag_add("pp", index(n,i), index(n,"end"))
i = sLen</t>
<t tx="edream.110203163054.1096">body.tag_add("nameBrackets", index(n,i), index(n,i+2))

# See if the line contains the rb
j = string.find(s,rb+"=",i+2) ; k = 3
if j == -1:
	j = string.find(s,rb,i+2) ; k = 2
if j == -1:
	i += 2
else:
	if language != cweb_language:
		searchName = body.get(index(n,i),   index(n,j+k)) # includes brackets
		ref = findReference(searchName,v)
	
	if language == cweb_language:
		body.tag_add("cwebName", index(n,i+2), index(n,j))
	elif ref:
		body.tag_add("link", index(n,i+2), index(n,j))
		if self.use_hyperlinks:
			&lt;&lt; set the hyperlink &gt;&gt;
	elif k == 3: # a section definition
		body.tag_add("link", index(n,i+2), index(n,j))
	else:
		body.tag_add("name", index(n,i+2), index(n,j))
	body.tag_add("nameBrackets", index(n,j), index(n,j+k))
	i = j + k</t>
<t tx="edream.110203163054.1097"># Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + `hyperCount`
hyperCount += 1
body.tag_delete(tagName)
body.tag_add(tagName, index(n,i+2), index(n,j))
ref.tagName = tagName
body.tag_bind(tagName,"&lt;Control-1&gt;",ref.OnHyperLinkControlClick)
body.tag_bind(tagName,"&lt;Any-Enter&gt;",ref.OnHyperLinkEnter)
body.tag_bind(tagName,"&lt;Any-Leave&gt;",ref.OnHyperLinkLeave)</t>
<t tx="edream.110203163054.1098">word = None
if language == cweb_language:
	&lt;&lt; Handle all cweb control codes &gt;&gt;
if not word:
	&lt;&lt; Handle non-cweb @keywords &gt;&gt;</t>
<t tx="edream.110203163054.1099">word = self.getCwebWord(s,i)
if word:
	# Color and skip the word.
	j = i + len(word)
	body.tag_add("keyword",index(n,i),index(n,j))
	i = j

	if word in ("@ ","@\t","@\n","@*","@**"):
		state = docState
		continue ;

	if word in ("@^","@.","@:","@="): # Ended by "@&gt;"
		j = string.find(s,"@&gt;",i)
		if j &gt; -1:
			body.tag_add("cwebName", index(n,i), index(n,j))
			body.tag_add("nameBrackets", index(n,j), index(n,j+2))
			i = j + 2
</t>
<t tx="edream.110203163054.1100">j = self.skip_id(s,i+1)
word = s[i:j]
word = string.lower(word)
if i != 0 and word != "@others":
	word = "" # can't be a Leo keyword, even if it looks like it.

# 7/8/02: don't color doc parts in plain text.
if language != plain_text_language and (word == "@" or word == "@doc"):
	# at-space starts doc part
	body.tag_add("leoKeyword", index(n,i), index(n,j))
	# Everything on the line is in the doc part.
	body.tag_add("docPart", index(n,j), index(n,sLen))
	i = sLen ; state = docState
elif word == "@nocolor":
	# Nothing on the line is colored.
	body.tag_add("leoKeyword", index(n,i), index(n,j))
	i = j ; state = nocolorState
elif word in leoKeywords:
	body.tag_add("leoKeyword", index(n,i), index(n,j))
	i = j
else:
	i = j</t>
<t tx="edream.110203163054.1101">j = self.skip_id(s,i)
word = s[i:j]
if word in keywords:
	body.tag_add("keyword", index(n,i), index(n,j))
i = j</t>
<t tx="edream.110203163054.1102">body.tag_add("blank", index(n,i)) ; i += 1</t>
<t tx="edream.110203163054.1103">body.tag_add("tab", index(n,i)) ; i += 1</t>
<t tx="edream.110203163054.1104"># body.tag_add("normal", index(n,i))
i += 1
</t>
<t tx="edream.110203163054.1105">def getPrefs (self):

	c = self.commands ; config = app().config
	
	self.getTag("&lt;preferences")
	while 1:
		if self.matchTag("allow_rich_text="):
			self.getDquote() ; self.getBool() ; self.getDquote() #ignored
		elif self.matchTag("tab_width="):
			self.getDquote() ; c.tab_width = self.getLong() ; self.getDquote()
		elif self.matchTag("page_width="):
			self.getDquote() ; c.page_width = self.getLong() ; self.getDquote()
		elif self.matchTag("tangle_bat="):
			self.getDquote() ; c.tangle_batch_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("untangle_bat="):
			self.getDquote() ; c.untangle_batch_flag = self.getBool() ; self.getDquote()
		# New in version 0.10
		elif self.matchTag("output_doc_chunks="):
			self.getDquote() ; c.output_doc_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("extended_noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("defaultTargetLanguage="):
			# New in version 0.15
			self.getDquote()
			&lt;&lt; check for syntax coloring prefs &gt;&gt;
		elif self.matchTag("use_header_flag="):
			self.getDquote() ; c.use_header_flag = self.getBool() ; self.getDquote()
		else: break
	self.getTag("&gt;")
	while 1:
		if self.matchTag("&lt;defaultDirectory&gt;"):
			# New in version 0.16.
			c.tangle_directory = self.getEscapedString()
			self.getTag("&lt;/defaultDirectory&gt;")
			if not os.path.exists(c.tangle_directory):
				es("default tangle directory not found:" + c.tangle_directory)
		elif self.matchTag("&lt;TSyntaxMemo_options&gt;"):
			self.getEscapedString() # ignored
			self.getTag("&lt;/TSyntaxMemo_options&gt;")
		else: break
	self.getTag("&lt;/preferences&gt;")
	
	# Override .leo file's preferences if settings are in leoConfig.txt.
	if config.configsExist:
		config.setCommandsIvars(c)</t>
<t tx="edream.110203163054.1106">@color
@language tcl/tk
@root "c:\prog\test\tcltktest.txt"

after # 'after' is a keyword
all # 'all' is not a keyword

&lt;&lt; stuff &gt;&gt;

# A comment
// Not a comment
"A string"
'A string'</t>
<t tx="edream.110203163054.1107">@ This is a tcl/tk doc part

This is code</t>
<t tx="edream.110203163054.1108">Question:

It would be nice if Leo could open empty files. I tend to be "document
oriented" rather than "application oriented" in my thinking and prefer "create
empty file at location -&gt; open it with program" to "start program -&gt; create new
file -&gt; save it at location".

Answer by Paul Paterson

If you are on Windows 98/2000/XP then the procedure is as follows...

1. Start Leo
2. Click New
3. Click Save as...
4. Save the file as "c:\windows\shellnew\leofile.leo" (or c:\winnt for 2000/XP)
5. Open regedit "start...run...regedit"
6. Open HKEY_CLASSES_ROOT and find the ".leo" extension type
7. Go New ... Key from the context menu 
8. Call the new key ShellNew 
9. Select the new key, right-click, choose New ... String Value from the contextmenu
10. Call it FileName 
11. Double-click on the string, and modify it to be the filename of the leofile.leo
file you created, including the extension
12. Exit the registry editor and restart Windows Explorer (or you may need to
reboot on Windows 98)

Now you should have a New.. Leo File option in Explorer. This creates a
duplicate of the file you saved. This can be useful because you could make a
template Leo file containing some standard nodes that you always have and then
save this.</t>
<t tx="edream.110203163054.1109">@nocolor
@ignore</t>
<t tx="edream.110203163054.1110">We often refer to outline nodes by the directives they contain.  For example, an @root node is a node containing an @root directive, an @ignore node is a node containing an @ignore directive, and so on.

Exception: an @file node is a node whose headline starts with @file.</t>
<t tx="edream.110203163054.1111">An @root tree is a tree whose is an @root node.  An @file tree is a tree whose root is an @file node, and so on.</t>
<t tx="edream.110203163054.1112">The pane containing the body text of the currently selected headline in the outline pane.</t>
<t tx="edream.110203163054.1113">The text in the body pane.  Body text is always associated with a particular headline.</t>
<t tx="edream.110203163054.1114">A small blue box in the icon just to the left of a headline that indicates that the node contains body text.</t>
<t tx="edream.110203163054.1115">A node directly contained by a node.</t>
<t tx="edream.110203163054.1116">Another name for a section or part.</t>
<t tx="edream.110203163054.1117">A copy of a tree that changes whenever the original changes.  The original and all clones are treated equally:  no special status is given to the "original" node.</t>
<t tx="edream.110203163054.1118">A small red arrow in the icon just to the left of a headline that indicates that the node is a clone of another node.</t>
<t tx="edream.110203163054.1119">A section containing code.  Code sections start with @c or @code directives.</t>
<t tx="edream.110203163054.1120">A literate programming language invented by Donald Knuth and Silvio Levy.  CWEB produces derived files for the C language.

http://www-cs-faculty.stanford.edu/~knuth/cweb.html</t>
<t tx="edream.110203163054.1121">To move right all following siblings of a node so that they become children of a node.</t>
<t tx="edream.110203163054.1122">The output file created as the result of tangling a node containing an @root directive. The file consists of the expansion of the text following the @root directive.</t>
<t tx="edream.110203163054.1123">An offspring of a node.  That is, a child, grandchild, etc. of a node.</t>
<t tx="edream.110203163054.1124">A keyword, preceded by an '@' sign, that is used to control syntax coloring or the Tangle, Untangle or Weave commands.</t>
<t tx="edream.110203163054.1125">A section containing only documentation. That is, a section that start with @.  Doc sections are associated with the immediately following code section, if any.</t>
<t tx="edream.110203163054.1126">A convention for representing sequences of characters that would otherwise have special meaning.  Leo has only one such convention: in @root trees, @@ in the leftmost column of a code part stands for a single @ character.

Note: the markup language Leo uses in body pane is based on noweb.  However, Leo does not support noweb's @&lt;&lt; and @&gt;&gt; escape conventions.  If a line in a code part contains &lt;&lt; followed by &gt;&gt;, then that line does contain a section name, regardless of context.  If the &lt;&lt; and &gt;&gt; characters should not, if fact, delimit a section name, then you must place the &lt;&lt; and &gt;&gt; on separate lines.

Eliminating noweb's escape conventions for &lt;&lt; and &gt;&gt; characters solves some difficult problems when automatically untangling derived files.  Moreover, it is typically easier to split source lines than to use @&lt;&lt; and @&gt;&gt;.  Finally, Leo's Export and Import commands do support the @&lt;&lt; and @&gt;&gt; conventions.</t>
<t tx="edream.110203163054.1127">The child of a child of a node.</t>
<t tx="edream.110203163054.1128">The organizational unit of an outline.  A node.  Each headline contains headline text and (possibly empty) body text.</t>
<t tx="edream.110203163054.1129">Leo stands for Literate Editor with Outlines. That is, Leo supports both literate programming and outlining.

Leo1 denotes all versions of Leo that write version 1 .leo files, that is, all Windows version of Leo prior to version 2.0.  The last version of Leo1, version 1.15, understands enough about Leo2 to issue a warning when opening version 2 files.

Leo2 denotes all versions of Leo that write version 2 .leo files, that is, all versions of leo.py and all Windows versions with version number 2.0 and above.  Only Leo2 can generate derived files from @file trees.</t>
<t tx="edream.110203163054.1130">A style of programming that aims at producing the highest quality program listings.  Literate programming languages apply two fundamental operations to text: weaving and tangling.  Leo supports two literate programming languages, CWEB and noweb.

Knuth's book is the best overall introduction to literate programming:
Literate Programming, by D. E. Knuth ISBN 0-937073-80-6.

More information is available at Knuth's web site:
http://www-cs-faculty.stanford.edu/%7Eknuth/lp.html</t>
<t tx="edream.110203163054.1131">Marking a node by placing a red mark near its leader character. Marks can be placed using the Mark command, as the result of Find and Change commands, or as the result of the Mark Changed Roots and Mark Changed Items command. The Tangle Marked command tangles only those subtrees that are marked.</t>
<t tx="edream.110203163054.1132">Within an @file tree, a node that contain a section name, like &lt;&lt;x&gt;&gt;, at the start of its headline text.

Within an @file tree, all nodes containing a section reference must have a descendent named node corresponding to the reference.

Within an @root or @unit tree, an @code directive is an abbreviation for &lt;&lt;x&gt;&gt;=, where &lt;&lt; x &gt;&gt; is found in the headline.

</t>
<t tx="edream.110203163054.1133">The organizational unit of an outline.  A headline.  The combination of headline text and outline text.
</t>
<t tx="edream.110203163054.1134">A simple literate programming language invented by Norman Ramsey.  noweb can produce derived files for any text-based programming language.

http://www.eecs.harvard.edu/~nr/noweb/</t>
<t tx="edream.110203163054.1135">The children, grandchildren, etc. of a node.</t>
<t tx="edream.110203163054.1136">An unnamed node in an @tree that contains no body text.  Such nodes may appear anywhere in an @file tree; they do not affect the derived file in any way.  In particular, organizing nodes do not affect indentation in the derived file.</t>
<t tx="edream.110203163054.1137">An unnamed node that is either 1) a descendent of a named node or 2) the descendent of no @others node.

Orphan and @ignore nodes are not allowed in @file trees: no derived file is written if an @file node contains an @ignore or orphan node.</t>
<t tx="edream.110203163054.1138">1. A visual representation of a hierarchy on the screen.

2. The data contained by the hierarchy.

Outlines are composed of headlines representing data.  The combination of a headline and its associated body text is called a node.
</t>
<t tx="edream.110203163054.1139">he pane containing a visual representation of outlines.</t>
<t tx="edream.110203163054.1140">The node the directly contains a node.</t>
<t tx="edream.110203163054.1141">Another name for a section or chunk.</t>
<t tx="edream.110203163054.1142">A file that can be read by Adobe Acrobat.</t>
<t tx="edream.110203163054.1143">To move all children of a node left in an outline so that they become siblings of the node.</t>
<t tx="edream.110203163054.1144">The first node of the entire outline.  In the PC version of Leo several nodes may be siblings of the root.</t>
<t tx="edream.110203163054.1145">The portion of the outline in which a section definition is known. By default the scope of a section definition is the smallest subtree containing both the section and a node containing an @root directive. The @unit directive declares that the subtree containing the @unit directive is the scope for all sections defined in that tree.</t>
<t tx="edream.110203163054.1146">A fragment of text that can be incorporated into derived files.  A syntactic unit of body text.

There are two kinds of sections: code sections and doc sections. Sections are defined in slightly different ways in @file in @root trees (that's the difference between the two kinds of trees.)

In @file trees
--------------
Code sections start with the @c directive.  The entire body text of a node is a code section by default, so the @c directive can be omitted if there are no doc sections in the body pane.  Doc sections start with @ followed by a space at the start of a line. Doc sections continue until the end of body text or until the next @c or @(space) directive.

In @root trees
--------------
Code sections start with the @c directive or section definition lines of the form:
&lt;&lt; section name &gt;&gt;=
Such lines begin named code sections.  Other code sections are unnamed. Doc sections start with @ followed by a space at the start of a line.  Doc sections continue until the end of body text or until the next @c or @(space) directive.

The term "section" has two related meanings.  Sections are syntactic units of text in the body pane.  Leo writes the text of section to derived files, so another meaining of "section" is "the text that is written to the derived file."  Which meaning is intended should be clear from context.</t>
<t tx="edream.110203163054.1147">A name enclosed in &lt;&lt; and &gt;&gt;.  Section names may contain any characters except newlines and "&gt;&gt;".</t>
<t tx="edream.110203163054.1148">A section name appearing in a code part. Tangling replaces all references by their definitions.</t>
<t tx="edream.110203163054.1149">Comment lines in files derived from @file nodes.  Such lines start with an @ following the opening comment delimiter.  Sentinels embed outline structure into derived files.  Do not alter such lines!  Doing so can corrupt the outline structure.</t>
<t tx="edream.110203163054.1150">Nodes with the same parent.  Siblings of the root have no parent.</t>
<t tx="edream.110203163054.1151">The icon that appears just to the left of headline text in the outline pane.  This icon shows: a blue body text box if the node contains body text, a red clone arrow if the node is cloned, and a red marker bar if the node is marked.  The icon is outlined in black if the node is dirty, that is, if the node has been changed since the file was last change.
</t>
<t tx="edream.110203163054.1152">The process of creating derived files from @root or @file trees.  Leo tangles @file automatically when writing a .leo file.  The user must explicitly tangle @root trees using the Tangle command.  Tangling expands all references in an @root node or @file node.</t>
<t tx="edream.110203163054.1153">The language used to syntax color text.  This language determines the default comment delimiters used during tangling and untangling.
</t>
<t tx="edream.110203163054.1154">Another name for an outline.</t>
<t tx="edream.110203163054.1155">A node whose headline text does not start with &lt;&lt; name &gt;&gt;.

Unnamed nodes in @file trees must be a descendent of an @others node and must not be the descendent of any named node.

For example, the following tree is invalid:

@others node
  &lt;&lt; name &gt;&gt;
    unnamed node
	
The unnamed node would be an orphan node.</t>
<t tx="edream.110203163054.1156">Updating an outline based on changes to derived files.  Untangling allows changes to be propagated from derived files back to the outline.  Especially useful when fixing syntax errors outside Leo.
</t>
<t tx="edream.110203163054.1157">The process of creating typeset documentation from a noweb or CWEB source file.  Weaving creates documentation. Tangling creates source code files known as derived files.

Leo does not support weaving directly.  If you want to weave a file you can create noweb or CWEB files using Leo's export commands, then use the noweb or CWEB systems to weave those files.</t>
<t tx="edream.110203163054.1158">@ The following is part of Leo's actual source code.  The code is written in C++ and uses Borland's Delphi classes.

For @root trees:  The Tangle command will generate derived files from @root trees.  The Untangle command will update outlines based on changes made to files derived from @root trees.

For @file trees:  The Save command will generate the derived files from @file trees.  The Open command will update outlines based on changes made to files derived from @file trees.

When looking through this outline pay particular attention to:

a) How the outline organizes classes, methods and chunks.
b) How the @root and @unit directives are used in @root trees.
c) How the @file and @others directives are used in @file trees.

If you actually want to create files you must remove the @ignore directive below.
@c

@ignore
@language c</t>
<t tx="edream.110203163054.1159">@ To create the file hello.c in the current directory.

1. Remove the @ignore directive from the parent of this node.
2. Select this headline.
3. Choose the Tangle command from the File menu.

When you look at hello.c you will see that it contains comments starting with ///.  Leave these comments alone: they are used by the Untangle command.

@root "sampleHello.c"

&lt;&lt; includes &gt;&gt;
&lt;&lt; methods &gt;&gt;
</t>
<t tx="edream.110203163054.1160">@code

#include "stdio.h"</t>
<t tx="edream.110203163054.1161">@code

void main ( void )
{
	printf("Hello World!\n");
}</t>
<t tx="edream.110203163054.1162">@ To create the file hello.c in the current directory.

1. Remove the @ignore directive from the parent of this node.
2. Save this file.  This will create hello.c automatically.

When you look at hello.c you will see that it contains comments starting with //@.  Leave these comments alone!  They are needed to recreate the outline when reading this .leo file.</t>
<t tx="edream.110203163054.1163">@ This shows how to use Leo to create source files for Leo2.  
@c

&lt;&lt; includes &gt;&gt;
@others</t>
<t tx="edream.110203163054.1164">#include "stdio.h"</t>
<t tx="edream.110203163054.1165">void main ( void )
{
	printf("Hello World!\n");
}</t>
<t tx="edream.110203163054.1166"></t>
<t tx="edream.110203163054.1167">@ The vnodes and tnodes classes form the heart of the "model" classes (using the Smalltalk model/view/controller terminology).  That is, the vnode and tnode classes represent nearly all the data contained in the outline.  These two classes also provide a way of hiding the underlying implementation.  For instance, the Delphi classes used to implement outlines (TTreeView, TTreeNode and TTreeNodes) appear only in the implementation of the vnodes and tnodes class.

The developer documentation contains an extended discussion of these two classes.  To summarize:  a vnode (visual nodes) represents a headlines _at a particular location on the screen_.  When a headline is cloned, vnodes must be copied.  tnodes, (text nodes) on the other hand, represent body text: a tnode is shared by all vnodes that are clones of each other.  In other words, tnodes are the "unit of sharing" of body text.</t>
<t tx="edream.110203163054.1168">@unit
</t>
<t tx="edream.110203163054.1169">@ tnode.h created May 20, 1999.

tnodes represent the body text associated with headlines.

@root "sampleTnode.h"

#ifndef tnode_h_
#define tnode_h_

#include &lt;comctrls.hpp&gt;
#include "SynParse.hpp"
#include "SyntaxEd.hpp"

class vnode;

class tnode
{
private:
	&lt;&lt; tnode data members &gt;&gt;
public:
	&lt;&lt; tnode constructors &amp; destructors &gt;&gt;
	&lt;&lt; tnode debugging &gt;&gt;
	&lt;&lt; tnode getters &gt;&gt;
	&lt;&lt; tnode setters &gt;&gt; 
};

#endif // tnode_h_</t>
<t tx="edream.110203163054.1170">@code

String * mBodyRTF ;  // The string containing the RTF.
String * mBodyString ;  // The body text itself.

@ At present we use TTReeView to keep track of the headline text.  This has advantages and disadvantages.

Pros:
	It simplifies the "normal" code.
	It reduces the in-memory storage requirements.

Cons:
	It forces us to update clone headlines manually.
	Cloned headlines are duplicated in the output file.
@code

#if 0  // Headlines are stored in the TTreeView.
	String mHeadString ;  // The headline string.
#endif

@ The following are routine tnode fields.
@code

short mStatusBits ; // Dirty bit. (not archived)
long mFileIndex ;  // File index for file format.
vnode * mJoinHead ;  // The head of the join list while a file is being read.
int mSelectionStart ;  // The start of the selected body text.
int mSelectionLength ;  // The length of the selected body text.

@ New for Leo2: the clone index of this node.  This index is immutable so that cross-file clone links will not break.

For @root nodes this field contains the maximum clone index.
@code

long mCloneIndex ;
</t>
<t tx="edream.110203163054.1171">@code

tnode ( long index = 0, char * bodyText = NULL ) ;
~tnode () ;</t>
<t tx="edream.110203163054.1172">@code

void edump ( bool verboseFlag = FALSE ) ;
</t>
<t tx="edream.110203163054.1173">@code

char * bodyCString ( void ) ;
long bodyCStringLength ( void ) ;
String bodyRTF ( void ) ;
String bodyString ( void ) ;

long cloneIndex ( void ) ;
long fileIndex ( void ) ;
bool hasBody ( void ) ;
bool isDirty ( void ) ;  // Used by the Tangle command.
bool isRichTextBit ( void ) ;
bool isVisited ( void ) ;
vnode * joinHead ( void ) ;
void loadBodyPaneFromTnode ( TSyntaxMemo * syntaxMemo ) ;  // Sets syntaxMemo.
long refCount ( void ) ;
int selectionLength ( void ) ;
int selectionStart ( void ) ;
</t>
<t tx="edream.110203163054.1174">@code

void clearDirty ( void ) ;
void clearRichTextBit ( void ) ;
void clearVisited ( void ) ;
void saveBodyPaneToTnode ( TSyntaxMemo * memo ) ;

void setCloneIndex ( long index ) ;
void setDirty ( void ) ;
void setFileIndex ( long index ) ;
void setJoinHead ( vnode * v ) ;
void setRichTextBit ( void ) ;
void setSelection ( int start, int length ) ;
void setTnodeRTF ( String s ) ; // For reading from files.
void setTnodeText ( String s ) ;
void setVisited ( void ) ;
</t>
<t tx="edream.110203163054.1175">@root "sampleTnode.cpp"

#pragma option -w-par  // suppress warning: "Parameter is never used"

&lt;&lt; tnode includes &gt;&gt;
&lt;&lt; tnode abbreviations &gt;&gt;
&lt;&lt; tnode methods &gt;&gt;
</t>
<t tx="edream.110203163054.1176">@code

#include &lt;vcl.h&gt;
#pragma hdrstop

#include "args.h"
#include "tnode.h"

#include "Leo.h"
</t>
<t tx="edream.110203163054.1177">@code

enum {
    // Not archived...
	dirtyBit = 0x01,
	richTextBit = 0x02, // Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
	visitedBit = 0x04
} ;
</t>
<t tx="edream.110203163054.1178">&lt;&lt; tnode methods &gt;&gt;=

// Note: all params have defaults, so new tnode() is valid.

tnode::tnode ( long index , char * bodyCString  )
{
	if ( bodyCString )
		mBodyString = new String ( bodyCString ) ;
	else
		mBodyString = new String ( "" ) ;
		
	mBodyRTF = new String ("") ;

	mJoinHead = NULL ;
	mStatusBits = 0 ;
	mFileIndex = index ;
	mSelectionStart = 0 ;  // a TSyntaxMemo is not a String.
	mSelectionLength = 0 ;
	mCloneIndex = 0 ;
}

tnode::~tnode ()
{
	delete mBodyString ;
	delete mBodyRTF ;
}
</t>
<t tx="edream.110203163054.1179"></t>
<t tx="edream.110203163054.1180">&lt;&lt; tnode methods &gt;&gt;=

void tnode::edump ( bool verboseFlag )
{
	if ( verboseFlag ) {

	}
	else {

	}
}</t>
<t tx="edream.110203163054.1181"></t>
<t tx="edream.110203163054.1182"></t>
<t tx="edream.110203163054.1183">&lt;&lt; tnode methods &gt;&gt;=

String tnode::bodyRTF ( void )
{
	assert ( mBodyRTF ) ;
	return *mBodyRTF ;
}</t>
<t tx="edream.110203163054.1184">&lt;&lt; tnode methods &gt;&gt;=

char * tnode::bodyCString ( void )
{
	assert ( mBodyString ) ;
	return mBodyString -&gt; c_str() ;
}</t>
<t tx="edream.110203163054.1185">&lt;&lt; tnode methods &gt;&gt;=

long tnode::bodyCStringLength ( void )
{
	assert ( mBodyString ) ;

	#if 0 // faster
		return mBodyString -&gt; Length();
	#else // safer
		return strlen( mBodyString -&gt; c_str() );
	#endif
}</t>
<t tx="edream.110203163054.1186">&lt;&lt; tnode methods &gt;&gt;=

String tnode::bodyString ( void )
{
	assert ( mBodyString ) ;
	return *mBodyString ;
}</t>
<t tx="edream.110203163054.1187">&lt;&lt; tnode methods &gt;&gt;=

void tnode::loadBodyPaneFromTnode ( TSyntaxMemo * syntaxMemo )
{
	if (
		arg_allow_rich_text &amp;&amp; this -&gt; isRichTextBit() &amp;&amp;
		mBodyRTF &amp;&amp; mBodyRTF -&gt; Length() &gt; 0
	) {
		TMemoryStream * ms = new TMemoryStream ();	
		ms -&gt; Write ( mBodyRTF -&gt; c_str(), mBodyRTF -&gt; Length() ) ;
		ms -&gt; Position = 0 ;
		syntaxMemo -&gt; Lines -&gt; LoadFromStream (ms) ;
		delete ms ;
	}
	else if ( mBodyString &amp;&amp; mBodyString -&gt; Length() &gt; 0 ) {
		syntaxMemo -&gt; Clear();
		syntaxMemo -&gt; Text = *mBodyString ;
		syntaxMemo -&gt; SelStart = mSelectionStart ;
		syntaxMemo -&gt; SelLength = mSelectionLength ;
	}
	else {
		syntaxMemo -&gt; Clear();
		syntaxMemo -&gt; Text = "" ;
		mSelectionStart = 0 ;
		mSelectionLength = 0 ;
	}
}</t>
<t tx="edream.110203163054.1188">&lt;&lt; tnode methods &gt;&gt;=

int tnode::selectionLength ( void )
{
    return mSelectionLength ;
}
</t>
<t tx="edream.110203163054.1189">&lt;&lt; tnode methods &gt;&gt;=

int tnode::selectionStart ( void )
{
    return mSelectionStart ;
}
</t>
<t tx="edream.110203163054.1190"></t>
<t tx="edream.110203163054.1191">&lt;&lt; tnode methods &gt;&gt;=

bool tnode::isDirty ( void )
{
    return ( ( mStatusBits &amp; dirtyBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1192">&lt;&lt; tnode methods &gt;&gt;=

bool tnode::isRichTextBit ( void )
{
    return ( ( mStatusBits &amp; richTextBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1193">&lt;&lt; tnode methods &gt;&gt;=

bool tnode::isVisited ( void )
{
    return ( ( mStatusBits &amp; visitedBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1194">&lt;&lt; tnode methods &gt;&gt;=

long tnode::cloneIndex ( void )
{
	return mCloneIndex ;
}</t>
<t tx="edream.110203163054.1195">&lt;&lt; tnode methods &gt;&gt;=

long tnode::fileIndex ( void )
{
	return mFileIndex ;
}</t>
<t tx="edream.110203163054.1196">&lt;&lt; tnode methods &gt;&gt;=

bool tnode::hasBody ( void )
{
	assert ( mBodyRTF &amp;&amp; mBodyString) ;  // Be default, these are String("");
	
	if ( arg_allow_rich_text &amp;&amp; this -&gt; isRichTextBit() )
		return mBodyRTF -&gt; Length() &gt; 0 ;
	else
		return mBodyString -&gt; Length() &gt; 0 ;
}</t>
<t tx="edream.110203163054.1197">&lt;&lt; tnode methods &gt;&gt;=

vnode * tnode::joinHead ( void )
{
    return mJoinHead ;
}</t>
<t tx="edream.110203163054.1198"></t>
<t tx="edream.110203163054.1199"></t>
<t tx="edream.110203163054.1200">&lt;&lt; tnode methods &gt;&gt;=

void tnode::saveBodyPaneToTnode ( TSyntaxMemo * memo )
{
	assert(memo);

	if ( this -&gt; isRichTextBit() )
	{
		TMemoryStream * ms = new TMemoryStream ();
		memo -&gt; Lines -&gt; SaveToStream( ms ); // Transfers RTF to stream.
		char * s = (char *) ( ms -&gt; Memory ) ;
		delete mBodyRTF ;
		mBodyRTF = new String ( s , ms -&gt; Size ) ;
		delete ms ;
		this -&gt; setSelection ( 0, 0 ) ;
	}
	else {
		delete mBodyString ;
		mBodyString = new String ( memo -&gt; Text ) ;
		this -&gt; setSelection ( memo -&gt; SelStart, memo -&gt; SelLength ) ;
	}
}
</t>
<t tx="edream.110203163054.1201">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setTnodeRTF ( String s )
{
	if ( this -&gt; isRichTextBit() ) {
		delete mBodyRTF ;
		mBodyRTF = new String ( s ) ;
	}
}</t>
<t tx="edream.110203163054.1202">@ This sets the text in the tnode from the given string.

&lt;&lt; tnode methods &gt;&gt;=

void tnode::setTnodeText ( String s )
{
	delete mBodyString ;
	mBodyString = new String ( s ) ;
}
</t>
<t tx="edream.110203163054.1203">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setSelection ( int start, int length )
{
	mSelectionStart = start ;
	mSelectionLength = length ;
}
</t>
<t tx="edream.110203163054.1204"></t>
<t tx="edream.110203163054.1205">&lt;&lt; tnode methods &gt;&gt;=

void tnode::clearDirty ( void )
{
    mStatusBits &amp;= ~ dirtyBit ;
}</t>
<t tx="edream.110203163054.1206">&lt;&lt; tnode methods &gt;&gt;=

void tnode::clearRichTextBit ( void )
{
	mStatusBits &amp;= ~richTextBit ;
}</t>
<t tx="edream.110203163054.1207">&lt;&lt; tnode methods &gt;&gt;=

void tnode::clearVisited ( void )
{
    mStatusBits &amp;= ~visitedBit ;
}</t>
<t tx="edream.110203163054.1208">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setDirty ( void )
{
    mStatusBits |= dirtyBit ;
}</t>
<t tx="edream.110203163054.1209">&lt;&lt; tnode methods &gt;&gt;=

void tnode:: setRichTextBit ( void )
{
	mStatusBits |= richTextBit ;
}
</t>
<t tx="edream.110203163054.1210">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setVisited ( void )
{
	mStatusBits |= visitedBit ;
}</t>
<t tx="edream.110203163054.1211">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setCloneIndex ( long index )
{
	mCloneIndex = index ;
}</t>
<t tx="edream.110203163054.1212">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setFileIndex ( long index )
{
	mFileIndex = index ;
}</t>
<t tx="edream.110203163054.1213">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setJoinHead ( vnode * v )
{
	mJoinHead = v ;
}</t>
<t tx="edream.110203163054.1214">@unit
</t>
<t tx="edream.110203163054.1215">@ vnodes represent all additional data attached to TTreeNodes.

@root "sampleVnode.h"

#ifndef vnode_h_
#define vnode_h_

#include &lt;vcl.h&gt;
#pragma hdrstop

#include &lt;comctrls.hpp&gt;

#undef V_XCLONES

class tnode;
class TLeoForm;
class Commands;
class vnode;

struct dvnode {
	&lt;&lt; dvnode data members &gt;&gt;
} ;

class vnode
{
private:
	&lt;&lt; vnode data members &gt;&gt;
	&lt;&lt; vnode private methods &gt;&gt;
public:
	&lt;&lt; vnode access methods &gt;&gt;
	&lt;&lt; vnode comparisons &gt;&gt;
	&lt;&lt; vnode constructors &amp; destructors &gt;&gt;
	&lt;&lt; vnode debugging &gt;&gt;
	&lt;&lt; vnode file methods &gt;&gt;
	&lt;&lt; vnode getters &gt;&gt;
	&lt;&lt; vnode setters &gt;&gt;
	&lt;&lt; vnode tree methods &gt;&gt;
};

#endif // vnode_h_</t>
<t tx="edream.110203163054.1216">@ The following stores all information needed to restore a vnode that is about to be deleted.  Much of this information is held in the TTreeView or TTreeNode classes, so it must be captured before actually deleting any information.

vnode::doDelete does not delete vnodes, nor does it decrease the refCount field in tnodes, so we save the pointers to these nodes here.

@code

dvnode * next ;
long level ;  // The level of the outline relative to the root.
String headline ;  // The text of the soon-to-be deleted TTreeNode.
vnode * v ;  // The vnode.  Neither v nor v -&gt; mT will be deleted by doDelete().
</t>
<t tx="edream.110203163054.1217">@code

vnode * next ( void ) ;
vnode * back ( void ) ;
vnode * nodeAfterTree ( void ) ;
vnode * threadBack ( void ) ;
vnode * threadNext ( void ) ;
vnode * visBack ( void ) ;
vnode * visNext ( void ) ;</t>
<t tx="edream.110203163054.1218">@code

String atFileNodeName ( void ) ;
bool isAtFileNode ( void ) ;
bool isAtIgnoreNode ( void ) ;
bool isAtOthersNode ( void ) ;
bool matchHeadline ( String pattern ) ;</t>
<t tx="edream.110203163054.1219">@code

vnode ( Commands * commands, tnode * t = NULL ) ;</t>
<t tx="edream.110203163054.1220">@ The commander for this vnode.  This allows us to determine reliably what the current vnode is, regardless of what window is active.  It also speeds access to the current body pane, tree view, etc.
@code

Commands * mCommands ;

@ The TTreeNode that owns this vnode.   The "Data" member of a TTreeNode points to its vnode.  Unlike the Yellow Box code, vnodes contain no structure information:  that information is retrieved from the corresponding TTreeNode.
@code

TTreeNode * mTreeNode;

@ The tnode.  tnodes contain only the body text of the vnode:  TTreeNodes contain the headline text.
@code

tnode * mT;

@ Status bits unique to vnodes.
@code

short mStatusBits;

@ The following field links all vnodes that are joined together.  Such nodes must be updated together.
@code

vnode * mJoinList;

@ The value of the image index associated with the vnode's icon.  This allows setIcon() to redraw the icon (and more importantly, refresh the screen), only if the icon actually changes.
@code

long mIconVal ;

@ New for Leo2.  Cross-file clone information.
@code

#ifdef V_XCLONES

String mXCloneName ;  // Full path name of the file containing the clone.
unsigned long mXCloneIndex ; // Immutable cloneIndex field within the file.

#endif
</t>
<t tx="edream.110203163054.1221">@code

String description ( void ) ;
void edump ( bool verboseFlag = FALSE ) ;
</t>
<t tx="edream.110203163054.1222">@code

String convertTreeToString ( void ) ;
String moreBody ( void ) ;
String moreHead ( long firstLevel ) ;</t>
<t tx="edream.110203163054.1223">@code

// Getters outside this class.
Commands * commands ( void ) ;
TLeoForm * leoForm ( void ) ;
TTreeNode * treeNode ( void ) ;
TTreeNodes * treeNodes ( void ) ;
TTreeView * treeView ( void ) ;

char * bodyCString ( void ) ;
char * headCString ( void ) ;

long bodyCStringLength ( void ) ;
long headCStringLength ( void ) ;

String bodyRTF ( void ) ;
String bodyString ( void ) ;
String headString ( void ) ;

long childIndex ( void ) ;
vnode * currentVnode ( void ) ;
vnode * findRoot ( void ) ;
vnode * firstChild ( void ) ;
bool hasChildren ( void ) ;
long iconVal ( void ) ;
bool isAncestorOf ( vnode * v ) ;
bool isCloned ( void ) ;
bool isDirty ( void ) ;
bool isDummy ( void ) ;
bool isExpanded ( void ) ;  // Uses outline class.
bool isExpandedBitSet ( void ) ; // Uses status bits.
bool isMarked ( void ) ;
bool isOrphan ( void ) ;
bool isRoot ( TTreeView * treeView ) ;
bool isSelectedBitSet ( void ) ;
bool isTopBitSet ( void ) ;
bool isVisible ( void ) ;  
bool isVisited ( void ) ;
vnode * joinList ( void ) ;
vnode * lastChild ( void ) ;
vnode * lastNode ( void ) ;
long level ( void ) ;
vnode * nthChild ( long n ) ;
long numberOfChildren ( void ) ;
vnode * parent ( void ) ;
int selectionStart ( void ) ;
int selectionLength ( void ) ;
short status ( void ) ;  // Returns all the status bits.
tnode * t ( void ) ;

#ifdef V_XCLONES
    String xCloneName ( void ) ;
    long xCloneIndex ( void ) ;
#endif</t>
<t tx="edream.110203163054.1224">@ The following must must not be called externally.
@code

vnode * cloneNode ( void ) ;
void linkNodeAsChildOfAtIndex (vnode * theParent, long index ) ;
void unlinkNode ( void ) ;</t>
<t tx="edream.110203163054.1225">@code

void appendStringToBody ( String s ) ;

void clearClonedBit ( void ) ;
void clearDirty ( void ) ;
void clearDirtyJoined ( void ) ;
void clearDummy ( void ) ;
void clearMarked ( void ) ;
void clearOrphan ( void ) ;
void clearVisited ( void ) ;

long computeIcon ( void ) ;

void initClonedBit ( bool val ) ;
void initDirtyBit ( void ) ;
void initExpandedBit( void ) ;
void initHeadString ( String s ) ;
void initMarkedBit ( void ) ;
void initSelectedBit ( void ) ;
void initStatus ( short status ) ;
void initTopBit ( void ) ;

void setAncestorAtFileNodeDirty ( void ) ;
void setBodyStringOrPane ( String s ) ;
void setClonedBit  ( void ) ;
void setDirty ( void ) ;
void setDirtyJoined ( void ) ;
void setDummy ( void ) ;
void setHeadString ( String s ) ;
void setHeadStringOrHeadline( String s ) ;
void setIcon ( void ) ;
void setIconVal ( long val ) ;  // sets mIconVal
void setIconWithVal ( long val ) ;  // uses val to draw icon.
void setJoinList ( vnode * v ) ;
void setMarked ( void ) ;
void setOrphan ( void ) ;
void setSelection ( int start, int length ) ;
void setT (tnode * t ) ;
void setTreeNode ( TTreeNode * treeNode ) ;
void setVisited ( void ) ;

#ifdef V_XCLONES
    void setXCloneName ( String name ) ;
    void setXCloneIndex ( long index ) ;
#endif

void trimTrailingLines ( void ) ;</t>
<t tx="edream.110203163054.1226">@code

// Entry points...(These call TTreeNode methods)
vnode * clone ( vnode * v ) ;
void createDependents ( void ) ;
dvnode * doDelete ( vnode * newVnode ) ;  // delete is a C++ keyword.
void freeDVnodes ( dvnode * dv ) ;
vnode * insertAfter ( tnode * t = NULL ) ;
vnode * insertAsLastChild ( tnode * t = NULL ) ;
vnode * insertAsNthChild ( long index, tnode * t = NULL ) ;
void moveAfter ( vnode * back ) ;
void moveToNthChildOf ( vnode * parent, long index ) ;
void moveToRoot ( void  ) ;
vnode * restoreOutlineFromDVnodes ( dvnode *dv, vnode *parent, vnode *back ) ;

// Helpers...
void clearTreeNodeFields ( void ) ;
vnode * cloneTree ( vnode *oldTree ) ;
void copyCloneBitsTo ( vnode *tree2 ) ;
void copyTree( vnode * oldRoot, vnode * newRoot ) ;
void destroyDependents ( void ) ;
void destroyTree ( void ) ;
void invalidOutline ( String message ) ;
bool isJoinedTo ( vnode *v ) ;
bool isOnJoinListOf ( vnode *v2 ) ;
void joinNodeTo ( vnode *v2 ) ;
void joinTreeTo ( vnode *tree2 ) ;
dvnode * saveOutlineWithLevel ( long level ) ;
bool shouldBeClone ( void ) ;
void unjoinNode ( void ) ;
void unjoinTree ( void ) ;
bool validateOutlineWithParent (vnode *p ) ;
</t>
<t tx="edream.110203163054.1227">@ vnode.w.cpp created May 19, 1999.

@root "sampleVnode.cpp"

#pragma option -w-par  // suppress "Parameter not used" warning

&lt;&lt; vnode includes &gt;&gt;
&lt;&lt; vnode abbreviations &gt;&gt;
&lt;&lt; vnode methods &gt;&gt;</t>
<t tx="edream.110203163054.1228">@code

#include &lt;vcl.h&gt;
#pragma hdrstop

#include "CloneUnit.h"
#include "Commands.h"
#include "LeoWindow.h"
#include "MainUnit.h"
#include "tnode.h"
#include "vnode.h"
#include "Utils.h"

#include "Leo.h"
</t>
<t tx="edream.110203163054.1229">@ Define the meaning of vnode status bits.
@code

enum {
    // Archived.
	clonedBit	= 0x01 ,  // TRUE: vnode has clone mark.
	dummyBit	= 0x02 ,  // TRUE: vnode is a placeholder under @file node.
	expandedBit	= 0x04 ,  // TRUE: vnode is expanded.
    markedBit	= 0x08 ,  // TRUE: vnode is marked
	orphanBit	= 0x10 ,  // TRUE: vnode saved in .leo file, not derived file.
    selectedBit	= 0x20 ,  // TRUE: vnode was current vnode when saved.
	topBit		= 0x40 ,  // TRUE: vnode was top vnode when saved.

    // Not archived
    visitedBit	= 0x80
} ;
</t>
<t tx="edream.110203163054.1230">&lt;&lt; vnode methods &gt;&gt;=

vnode::vnode ( Commands * commands, tnode * t )
{
	assert(t);
	assert(commands);
	mCommands = commands ;
	mTreeNode = NULL ;
	mT = t ;
	mStatusBits = 0 ;
	mJoinList = NULL ;
	mIconVal = -1 ;
}
</t>
<t tx="edream.110203163054.1231"></t>
<t tx="edream.110203163054.1232">@ Returns the filename following @file in the receivers's headline, or the empty string if the receiver is not an @file node.

&lt;&lt; vnode methods &gt;&gt;=

String vnode::atFileNodeName ( void )
{
	String h = this -&gt; headString();
	char * ip = h . c_str();
	char * limit = ip + strlen(ip);
	if ( ip + 5 &lt; limit &amp;&amp; match_word(ip, limit, "@file") ) {
		ip += 5 ;
		String s (ip, limit - ip ) ;
		return s.Trim();
	}
	else return "" ;
}
</t>
<t tx="edream.110203163054.1233">@ Returns TRUE if the receiver's headline starts with @file.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isAtFileNode ( void )
{
	String s = this -&gt; atFileNodeName();
	return s . Length() &gt; 0 ;
}
</t>
<t tx="edream.110203163054.1234">@ Returns TRUE if the receiver contains @ignore in its body at the start of a line.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isAtIgnoreNode ( void )
{
	String body = this -&gt; bodyString();
	char *ip = body.c_str();
	return is_special (ip, body.Length(), "@ignore");
}
</t>
<t tx="edream.110203163054.1235">@ Returns TRUE if the receiver contains @others in its body at the start of a line.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isAtOthersNode ( void )
{
	String body = this -&gt; bodyString();
	char *ip = body.c_str();
	return is_special (ip, body.Length(), "@others");
}
</t>
<t tx="edream.110203163054.1236">@ Returns TRUE if the headline matches the pattern ignoring whitespace.  The headline may contain characters following the successfully matched pattern.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::matchHeadline ( String pattern )
{
	String headline = this -&gt; headString();
	char * ip = headline . c_str();
	char * pat = pattern . c_str();
	for (;;) {
		while ( is_ws(*pat) )
			++pat ;
		while ( is_ws(*ip) )
			++ip ;
		if ( *pat == '\0' )
			return true ; // Headline need not end.
		if (tolower(*pat) != tolower(*ip))
			return FALSE ;
		++pat ;
		++ip;
	}
}
</t>
<t tx="edream.110203163054.1237"></t>
<t tx="edream.110203163054.1238">&lt;&lt; vnode methods &gt;&gt;=

void vnode::edump ( bool verboseFlag )
{
    if ( mT )
		mT -&gt; edump ( verboseFlag ) ;
}</t>
<t tx="edream.110203163054.1239">&lt;&lt; vnode methods &gt;&gt;=

String vnode::description ( void )
{
	return "v: " + this -&gt; headString() ;
}
</t>
<t tx="edream.110203163054.1240"></t>
<t tx="edream.110203163054.1241">@ Convert the outline to a string in "MORE" format.

&lt;&lt; vnode methods &gt;&gt;=

String vnode::convertTreeToString ( void )
{
	String s ;
	String body ;
	String newline ("\r\n") ;
	vnode * v = this ;
	long level1 = v -&gt; level() ;
	vnode * after = v -&gt; nodeAfterTree() ;

	while ( v &amp;&amp; v != after )
	{
		s += v -&gt; moreHead ( level1 ) ;
		s += newline ;
		body = v -&gt; moreBody ();
		if ( body . Length() &gt; 0 ) {
            s += body ;
			s += newline ;
		}
		v = v -&gt; threadNext() ;
	}

	// s += newline ;
	return s ;
}
</t>
<t tx="edream.110203163054.1242">@ Return the headline string in MORE format.

&lt;&lt; vnode methods &gt;&gt;=

String vnode::moreHead ( long firstLevel )
{
	long level = this -&gt; level() - firstLevel ;
	String s ;
	
	// 8/17/00 Protect against bad level arg in script.
	s += AnsiString::StringOfChar( '\t', max(0,level) ) ;
	s += ( this -&gt; hasChildren() ? "+ " : "- ") ;
	s += this -&gt; headString();

	return s;
}</t>
<t tx="edream.110203163054.1243">@ Return the body string in MORE format.

&lt;&lt; vnode methods &gt;&gt;=

String vnode::moreBody ( void )
{
	String s = this -&gt; bodyString();
	long index = 1 ;  // Strings are 1-based.

	// Insert a backslash before any leading plus, minus or backslash.
	while ( index &lt;= s . Length() ) {
		if ( index == 1 || s [ index ] == body_newline ) {
			if ( s [ index ] == body_newline )
				++ index ;
			if ( index &lt;= s . Length() ) {
				char c = s [ index ] ;
				if ( c == '+' || c == '-' || c == '\\' )
					s . Insert( "\\",  index ) ;
			}
		}
		++ index ;
	}

	return s ;
}
</t>
<t tx="edream.110203163054.1244"></t>
<t tx="edream.110203163054.1245"></t>
<t tx="edream.110203163054.1246">@ The first child has index 1.

&lt;&lt; vnode methods &gt;&gt;=

long vnode::childIndex ( void) 
{
	assert(mTreeNode);
	return mTreeNode -&gt; Index ;
}</t>
<t tx="edream.110203163054.1247">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::firstChild ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; getFirstChild() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="edream.110203163054.1248">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::hasChildren ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; HasChildren ;
}</t>
<t tx="edream.110203163054.1249">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::lastChild ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; GetLastChild() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="edream.110203163054.1250">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::nthChild ( long n )
{
	vnode * child = this -&gt; firstChild();
	long i = 0 ;

	while ( child ) {
		if ( i == n )
			return child ;
		++ i ;
		child = child -&gt; next();
	}
	return NULL ;
}</t>
<t tx="edream.110203163054.1251">&lt;&lt; vnode methods &gt;&gt;=

long vnode::numberOfChildren ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Count ;
}</t>
<t tx="edream.110203163054.1252"></t>
<t tx="edream.110203163054.1253">&lt;&lt; vnode methods &gt;&gt;=

#ifdef V_XCLONES

String vnode::xCloneName ( void )
{
	return mXCloneName ;
}

#endif</t>
<t tx="edream.110203163054.1254">&lt;&lt; vnode methods &gt;&gt;=

#ifdef V_XCLONES

long vnode::xCloneIndex ( void )
{
	return mXCloneIndex ;
}

#endif</t>
<t tx="edream.110203163054.1255"></t>
<t tx="edream.110203163054.1256">@ Return the previous sibling, or NULL.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::back ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; getPrevSibling() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="edream.110203163054.1257">@ This function returns the last node of the receiver's tree.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::lastNode ( void )
{
	vnode * v = this ;
	long level = this -&gt; level() ;
	vnode * result = NULL ;

	while ( v ) {
		result = v;
		v = v -&gt; threadNext() ;
		if ( v == NULL || v -&gt; level() &lt;= level )
			break;
	}

	return result;
}
</t>
<t tx="edream.110203163054.1258">@ This function returns the indentation level of the receiver. The root nodes have level 0, their children have level 1, and so on.

&lt;&lt; vnode methods &gt;&gt;=

long vnode::level ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Level ;
}</t>
<t tx="edream.110203163054.1259">@ Return the next sibling, or NULL.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::next (void)
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; getNextSibling() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="edream.110203163054.1260">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::parent ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; Parent ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="edream.110203163054.1261">@ Return the vnode following the tree whose root is the receiver.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::nodeAfterTree ( void )
{
    vnode * next = this -&gt; next() ;
    vnode * p = this -&gt; parent() ;

    while ( next == NULL &amp;&amp; p != NULL ) {
        next = p -&gt; next() ;
        p = p -&gt; parent() ;
    }
    return next ;
}</t>
<t tx="edream.110203163054.1262">@ Return the previous element of the outline, or NULL if at the start of the outline.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::threadBack ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; GetPrev() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="edream.110203163054.1263">@ Return the next item in the outline, or NULL if at the end of the outline.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::threadNext ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; GetNext() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="edream.110203163054.1264">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::visBack ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; GetPrevVisible() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="edream.110203163054.1265">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::visNext ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; GetNextVisible() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="edream.110203163054.1266"></t>
<t tx="edream.110203163054.1267">&lt;&lt; vnode methods &gt;&gt;=

char * vnode::bodyCString ( void )
{
	assert ( mT ) ;
    return mT -&gt; bodyCString() ;
}</t>
<t tx="edream.110203163054.1268">&lt;&lt; vnode methods &gt;&gt;=

long vnode::bodyCStringLength ( void )
{
	assert ( mT ) ;
    return mT -&gt; bodyCStringLength() ;
}</t>
<t tx="edream.110203163054.1269">&lt;&lt; vnode methods &gt;&gt;=

String vnode::bodyRTF ( void )
{
	assert(mT);
	return mT -&gt; bodyRTF();
}</t>
<t tx="edream.110203163054.1270">&lt;&lt; vnode methods &gt;&gt;=

String vnode::bodyString ( void )
{
	assert (mT);
    return mT -&gt; bodyString() ;
}</t>
<t tx="edream.110203163054.1271">&lt;&lt; vnode methods &gt;&gt;=

char * vnode::headCString ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Text . c_str();
}</t>
<t tx="edream.110203163054.1272">&lt;&lt; vnode methods &gt;&gt;=

long vnode::headCStringLength ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Text . Length() ;
}</t>
<t tx="edream.110203163054.1273">&lt;&lt; vnode methods &gt;&gt;=

String vnode::headString ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Text ;
}</t>
<t tx="edream.110203163054.1274"></t>
<t tx="edream.110203163054.1275">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isCloned ( void )
{
    return ( ( mStatusBits &amp; clonedBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1276">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isDirty ( void )
{
    return mT -&gt; isDirty() ;
}</t>
<t tx="edream.110203163054.1277">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isDummy ( void )
{
    return ( ( mStatusBits &amp; dummyBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1278">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isExpanded ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Expanded ;
}</t>
<t tx="edream.110203163054.1279">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isExpandedBitSet ( void )
{
	return ( ( mStatusBits &amp; expandedBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1280">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isMarked ( void )
{
    return ( ( mStatusBits &amp; markedBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1281">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isOrphan ( void )
{
    return ( ( mStatusBits &amp; orphanBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1282">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isSelectedBitSet ( void )
{
	return ( ( mStatusBits &amp; selectedBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1283">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isTopBitSet ( void )
{
	return ( ( mStatusBits &amp; topBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1284">@ Return TRUE if all parents are expanded.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isVisible ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; IsVisible ;
}</t>
<t tx="edream.110203163054.1285">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isVisited ( void )
{
    return ( ( mStatusBits &amp; visitedBit ) != 0 ) ;
}</t>
<t tx="edream.110203163054.1286">&lt;&lt; vnode methods &gt;&gt;=

short vnode::status ( void )
{
    return mStatusBits ;
}</t>
<t tx="edream.110203163054.1287"></t>
<t tx="edream.110203163054.1288">@ Return the root (the first node) of the tree containing the receiver.  This is called by the commands class.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::findRoot ( void )
{
    vnode * v = this ;

    while ( v &amp;&amp; v -&gt; parent() )
        v = v -&gt; parent() ;

	while ( v &amp;&amp; v -&gt; back() )
		v = v -&gt; back();

    return v ;
}</t>
<t tx="edream.110203163054.1289">@ This method returns the active form.

&lt;&lt; vnode methods &gt;&gt;=

Commands * vnode::commands ( void )
{
	assert(mCommands);
	return mCommands;

	#if 0 // old code
    	TLeoForm * leoForm = this -&gt; leoForm() ;
    	assert(leoForm);  // Vnodes are _always_ contained in a TLeoForm.
    	return leoForm -&gt; commands();
	#endif
}</t>
<t tx="edream.110203163054.1290">@ This method returns the TLeoForm containing v. We can not assume that this form is the active form.

&lt;&lt; vnode methods &gt;&gt;=

TLeoForm * vnode::leoForm ( void )
{
	assert(mCommands &amp;&amp; mCommands -&gt; mLeoForm);
	return mCommands -&gt; mLeoForm ;

	#if 0 // old code
    	assert(this -&gt; mTreeNode);
        TTreeView * treeView = (TTreeView *) (this -&gt; mTreeNode -&gt; TreeView );
    	assert(treeView);
    
        // The TTreeView's parent is a TPanel.
        TWinControl * winControl = treeView -&gt; Parent ;
        assert ( String(winControl -&gt; ClassName()) == String("TPanel") );
    	TPanel * panel = dynamic_cast&lt;TPanel *&gt;(treeView -&gt; Parent) ;
    
        // The TPanel's parent is a TLeoForm.
        TWinControl * winControl2 = panel -&gt; Parent ;
        assert ( String(winControl2 -&gt; ClassName()) == String("TLeoForm") );
    	TLeoForm * leoForm = dynamic_cast&lt;TLeoForm *&gt;(panel -&gt; Parent) ;
    	return leoForm ;
	#endif
}
</t>
<t tx="edream.110203163054.1291">&lt;&lt; vnode methods &gt;&gt;=

TTreeNode * vnode::treeNode ( void )
{
	assert(mTreeNode);
    return mTreeNode ;
}</t>
<t tx="edream.110203163054.1292">&lt;&lt; vnode methods &gt;&gt;=

TTreeNodes * vnode::treeNodes ( void )
{
	assert(mTreeNode);
	TTreeView * treeView = (TTreeView *) mTreeNode -&gt; TreeView ;
	assert(treeView &amp;&amp; treeView -&gt; Items);
	return treeView -&gt; Items ;
}</t>
<t tx="edream.110203163054.1293">&lt;&lt; vnode methods &gt;&gt;=

TTreeView * vnode::treeView ( void )
{
	assert(mTreeNode &amp;&amp; mTreeNode -&gt; TreeView);
    return (TTreeView *) mTreeNode -&gt; TreeView ;
}</t>
<t tx="edream.110203163054.1294">@ We can not use this -&gt; treeView() -&gt; Selected because the Selected property will be NULL if the TLeoForm is not the current form.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::currentVnode ( void )
{
	assert(mCommands);
	return mCommands -&gt; currentVnode();
}</t>
<t tx="edream.110203163054.1295">&lt;&lt; vnode methods &gt;&gt;=

long vnode::iconVal ( void )
{
   return mIconVal ;
}</t>
<t tx="edream.110203163054.1296">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isAncestorOf ( vnode * v )
{
    for ( v = v -&gt; parent() ; v ; v = v -&gt; parent() )
        if ( v == this )
            return TRUE ;

    return FALSE ;
}</t>
<t tx="edream.110203163054.1297">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isRoot ( TTreeView * treeView )
{
	return this -&gt; threadBack() == NULL ;
}</t>
<t tx="edream.110203163054.1298">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::joinList ( void )
{
	return mJoinList ;
}</t>
<t tx="edream.110203163054.1299">&lt;&lt; vnode methods &gt;&gt;=

int vnode::selectionStart ( void )
{
	return mT -&gt; selectionStart();
}
</t>
<t tx="edream.110203163054.1300">&lt;&lt; vnode methods &gt;&gt;=

int vnode::selectionLength ( void )
{
	return mT -&gt; selectionLength();
}
</t>
<t tx="edream.110203163054.1301">&lt;&lt; vnode methods &gt;&gt;=

tnode * vnode::t ( void )
{
	// This is a _highly_ useful assertion.
	assert(mT);
	return mT ;
}</t>
<t tx="edream.110203163054.1302"></t>
<t tx="edream.110203163054.1303"></t>
<t tx="edream.110203163054.1304">&lt;&lt; vnode methods &gt;&gt;=

#ifdef V_XCLONES

void vnode::setXCloneIndex ( long index )
{
	mXCloneIndex = index ;
}

#endif</t>
<t tx="edream.110203163054.1305">&lt;&lt; vnode methods &gt;&gt;=

#ifdef V_XCLONES

void vnode::setXCloneName ( String name )
{
	mXCloneName = name ;
}

#endif</t>
<t tx="edream.110203163054.1306"></t>
<t tx="edream.110203163054.1307">&lt;&lt; vnode methods &gt;&gt;=

void vnode::appendStringToBody ( String s )
{
	if ( s . Length() == 0 ) return ;
	String body = this -&gt; bodyString();
	body += s ;
	this -&gt; setBodyStringOrPane ( body ) ;
	this -&gt; setIcon();
}
</t>
<t tx="edream.110203163054.1308">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setBodyStringOrPane ( String s )
{
	Commands * c = this -&gt; commands();
	if ( c == NULL ) return ;
	vnode * current = c -&gt; currentVnode();
	if ( current == NULL ) return ;

	if ( this == current ) {
		// Replace the body text with s.
		TSyntaxMemo * memo = c -&gt; mSyntaxMemo;
		memo -&gt; Text = s ;
	}
	
	// Keep the body text in the tnode up-to-date.
	tnode * t = this -&gt; t();
	t -&gt; setTnodeText(s);
	t -&gt; setSelection(0,0);  // 9/27/00
}
</t>
<t tx="edream.110203163054.1309">&lt;&lt; vnode methods &gt;&gt;=

void  vnode::setHeadString ( String s )
{
	assert(mTreeNode);
	mTreeNode -&gt; Text = s ;
	this -&gt; setDirtyJoined();
}

void  vnode::initHeadString ( String s )
{
	assert(mTreeNode);
	mTreeNode -&gt; Text = s ;
}</t>
<t tx="edream.110203163054.1310">@ Unlike setBodyStringOrPane, this code will work whether or not the receiver is the presently selected vnode, because the assignment mTreeNode -&gt; Text = s updates the headline.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::setHeadStringOrHeadline ( String s )
{
	if ( mTreeNode == NULL ) return ;
	Commands * c = this -&gt; commands();
	if ( c == NULL ) return ;

	c -&gt; endEditing();
	this -&gt; setHeadString( s );
}
</t>
<t tx="edream.110203163054.1311">@ This trims trailing blank lines from a node.  It is surprising difficult to do this during Untangle.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::trimTrailingLines(void)
{
	String s1 = this -&gt; bodyString();
	char * s = s1 . c_str();
	long len = strlen(s) ;
	long newlines = 0 ;
	long ws = 0 ;

	for (long i = len - 1; i &gt;= 0 ; -- i ) {
		char c = s[i] ;
		if ( is_ws(c) ) { --len, ++ws ; }
		else if ( c == '\r' ) --len ;
		else if ( c == '\n' ) { --len ; ++newlines ; }
		else break ;
	}

	if ( newlines &gt; 1 || newlines &gt; 0 &amp;&amp; ws &gt; 0 ) {
		String s2 ( s, len ) ;
		this -&gt; setBodyStringOrPane ( ( newlines &gt; 0 ) ? s2 + "\n" : s2 ) ;
		// Don't set the dirty bit: it would just be annoying.
	}
}
</t>
<t tx="edream.110203163054.1312"></t>
<t tx="edream.110203163054.1313">&lt;&lt; vnode methods &gt;&gt;=

long vnode::computeIcon ( void )
{
	vnode * current = this -&gt; currentVnode();
	if ( current == NULL ) return -1 ;

    long val = 0 ;
	if ( this -&gt; t() -&gt; hasBody() ) val += 1 ;
	if ( this -&gt; isMarked() ) val += 2 ;
	if ( this -&gt; isCloned() ) val += 4 ;
	if ( this -&gt; isDirty() ) val += 8 ;
	return val ;
}
</t>
<t tx="edream.110203163054.1314">@ The caller must call commands -&gt; Repaint().

&lt;&lt; vnode methods &gt;&gt;=

void vnode::setIcon ( void )
{
	static long guard = 0 ;
	assert(guard == 0);  // This routine should never cause recursion.

	long val = this -&gt; computeIcon();
	if ( val != -1 ) {
    	// Update the icon.
    	++guard ;
    		this -&gt; setIconWithVal ( val );
    	--guard ;
	}
}
</t>
<t tx="edream.110203163054.1315">@ Calling setIconVal -1 is the idiom to force the icon to be redrawn.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::setIconVal ( long val )
{
	mIconVal = val ;
}
</t>
<t tx="edream.110203163054.1316">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setIconWithVal ( long val )
{
	if ( val != mIconVal ) {
        mIconVal = val ;
        assert(mTreeNode);
        mTreeNode -&gt; ImageIndex = val ;
        mTreeNode -&gt; SelectedIndex = val ;
	}
}</t>
<t tx="edream.110203163054.1317">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setJoinList ( vnode * v )
{
	assert(mJoinList==NULL);
	mJoinList = v ;
}</t>
<t tx="edream.110203163054.1318">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setSelection ( int start, int length )
{
	mT -&gt; setSelection ( start, length );
}
</t>
<t tx="edream.110203163054.1319">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setT (tnode * t )
{
	// Bug fix: 7/9/01: do nothing if t == mt (!)
	if ( t != mT ) {
		delete mT ;  // Delete the tnode created when reading a file.
		mT = t ;
	}
}
</t>
<t tx="edream.110203163054.1320">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setTreeNode ( TTreeNode * treeNode )
{
	assert(treeNode);
    mTreeNode = treeNode ;
}</t>
<t tx="edream.110203163054.1321"></t>
<t tx="edream.110203163054.1322">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearClonedBit ( void )
{
    mStatusBits &amp;= ~ clonedBit ;
	this -&gt; setIcon();
}</t>
<t tx="edream.110203163054.1323">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearDirty ( void )
{
	mT -&gt; clearDirty() ;
	this -&gt; setIcon();
}

void vnode::clearDirtyJoined ( void )
{
	mT -&gt; clearDirty() ;
	this -&gt; setIcon();

	for (
		vnode * v2 = this -&gt; joinList();
		v2 &amp;&amp; v2 != this ;
		v2 = v2 -&gt; joinList()
	)
		v2 -&gt; setIcon();
}
</t>
<t tx="edream.110203163054.1324">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearDummy ( void )
{
    mStatusBits &amp;= ~ dummyBit ;
}</t>
<t tx="edream.110203163054.1325">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearMarked ( void )
{
    mStatusBits &amp;= ~ markedBit ;
	this -&gt; setIcon();
}
</t>
<t tx="edream.110203163054.1326">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearOrphan ( void )
{
    mStatusBits &amp;= ~ orphanBit ;
}</t>
<t tx="edream.110203163054.1327">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearVisited ( void )
{
    mStatusBits &amp;= ~ visitedBit ;
}</t>
<t tx="edream.110203163054.1328">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initClonedBit ( bool val )
{
	if ( val )
    	mStatusBits |= clonedBit ;
	else
		mStatusBits &amp;= ~clonedBit ;
}</t>
<t tx="edream.110203163054.1329">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initDirtyBit ( void )
{
	mT -&gt; setDirty();
}
</t>
<t tx="edream.110203163054.1330">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initExpandedBit ( void )
{
    mStatusBits |= expandedBit ;
}</t>
<t tx="edream.110203163054.1331">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initMarkedBit ( void )
{
	mStatusBits |= markedBit ;
}</t>
<t tx="edream.110203163054.1332">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initSelectedBit ( void )
{
    mStatusBits |= selectedBit ;
}</t>
<t tx="edream.110203163054.1333">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initTopBit ( void )
{
    mStatusBits |= topBit ;
}</t>
<t tx="edream.110203163054.1334">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initStatus ( short status )
{
	mStatusBits = status ;
}
</t>
<t tx="edream.110203163054.1335">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setAncestorAtFileNodeDirty ( void )
{
    for ( vnode * v = this ; v ; v = v -&gt; parent() ) {
		if ( ! v -&gt; isDirty() &amp;&amp; v -&gt; isAtFileNode() ) {
			v -&gt; setDirty();
			v -&gt; setDirtyJoined();
		}
	}
}
</t>
<t tx="edream.110203163054.1336">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setClonedBit ( void )
{
    mStatusBits |= clonedBit ;
	this -&gt; setIcon();
}
</t>
<t tx="edream.110203163054.1337">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setDirty ( void )
{
	mT -&gt; setDirty(); // Prevent recursion below.

	// Leo2: set the dirty bits of all ancestor @file nodes.
	for ( vnode * v = this ; v ; v = v -&gt; parent() ) {
		if ( ! v -&gt; isDirty() &amp;&amp; v -&gt; isAtFileNode() ) {
			v -&gt; setDirty();
			v -&gt; setDirtyJoined();
		}
	}

	this -&gt; setIcon();
}

void vnode::setDirtyJoined ( void )
{
	mT -&gt; setDirty();
	this -&gt; setIcon();

	for (
		vnode * v2 = this -&gt; joinList();
		v2 &amp;&amp; v2 != this ;
		v2 = v2 -&gt; joinList()
	)
		v2 -&gt; setDirty();
}
</t>
<t tx="edream.110203163054.1338">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setDummy ( void )
{
    mStatusBits |= dummyBit ;
}</t>
<t tx="edream.110203163054.1339">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setOrphan ( void )
{
    mStatusBits |= orphanBit ;
}</t>
<t tx="edream.110203163054.1340">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setVisited ( void )
{
    mStatusBits |= visitedBit ;
}</t>
<t tx="edream.110203163054.1341">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setMarked ( void )
{
	mStatusBits |= markedBit ;
	this -&gt; setIcon();
}
</t>
<t tx="edream.110203163054.1342"></t>
<t tx="edream.110203163054.1343"></t>
<t tx="edream.110203163054.1344">@ Create a clone of back and insert it as the next sibling of back.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::clone ( vnode * back )
{
	vnode * clone = this -&gt; cloneTree ( back ) ;
	clone -&gt; createDependents() ;
	#if 0 // too slow
		this -&gt; initAllCloneBits() ;
	#endif
	// Set the clone bit in all nodes joined to back.
	back -&gt; setClonedBit() ;
	for ( vnode * v = back -&gt; mJoinList ; v &amp;&amp; v != back ; v = v -&gt; mJoinList )
		v -&gt; setClonedBit() ;
	return clone ;
}</t>
<t tx="edream.110203163054.1345">@ This method creates all nodes that depend on the receiver.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::createDependents ( void )
{
	vnode *v = this ;
	tnode *t = v -&gt; mT ;
	vnode *parent = v -&gt; parent();
	if ( parent == NULL ) return ;

	// Copy v as the nth child of all nodes joined to parent.
	long n = v -&gt; childIndex() ;
	vnode *p = parent -&gt; mJoinList ;
	while ( p &amp;&amp; p != parent ) {
		vnode * copy = p -&gt; insertAsNthChild ( n, t ) ;
		copy -&gt; initHeadString ( v -&gt; headString() ) ;
		copyTree( v, copy );
		this -&gt; joinTreeTo ( copy ) ;
		p = p -&gt; mJoinList ;
	}
}
</t>
<t tx="edream.110203163054.1346">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.

Deleting an outline is actually a tricky operation because of the Undo command.  We don't actually delete vnodes (or reduce the refCount field of tnodes) until the delete operation becomes undoable.  (This can happen even if unlimited undo/redo is ever implemented.)

Therefore, dvnodes can store a pointer to the tnode containing the body text, and a good thing too, because otherwise undoing a joined node would not rejoin the node.

&lt;&lt; vnode methods &gt;&gt;=

dvnode * vnode::doDelete ( vnode * newVnode )  // delete is a C++ keyword
{
	Commands * commands = this -&gt; commands();  // Needed after 'this' no longer valid.
	assert(mTreeNode);
	TTreeNode * treeNode = mTreeNode ;  // Will be cleared below.

	// Destroy all dependent vnodes &amp; TTreeNodes.
	this -&gt; destroyDependents() ;

	// Create a list of dvnodes containing all info from the outline.
	dvnode * dv = this -&gt; saveOutlineWithLevel ( 0 ) ;
	&lt;&lt; dump the dv list &gt;&gt;

	// Unjoin all nodes of the deleted tree.
	this -&gt; unjoinTree();

	// Destroy the entire tree of TTreeNodes.
	treeNode -&gt; Delete() ;

	// Bug fix: 1/18/99: we must set the currentVnode here!
	commands -&gt; selectVnode ( newVnode ) ;

	// Update all clone bits.
	commands -&gt; initAllCloneBits();

	return dv ;
}
</t>
<t tx="edream.110203163054.1347">@code

TRACEP("vnode::doDelete:dumpDVnodes",
	ecnl(); es("Dump of dvnodes: ");
	while ( dv ) {
		String s = dv -&gt; headline ;
		ecnl(); epadlong( dv -&gt; level, 2 ); ecs(); es(s.c_str());
		dv = dv -&gt; next ;
	}
	ecnls(2);
);
</t>
<t tx="edream.110203163054.1348">&lt;&lt; vnode methods &gt;&gt;=

void vnode::freeDVnodes ( dvnode * dv )
{
	while ( dv ) {
		dvnode * next = dv -&gt; next ;
		delete dv ;
		dv = next ;
	}
}
</t>
<t tx="edream.110203163054.1349">@ This method inserts a new vnode after the receiver.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::insertAfter ( tnode * t )
{
	assert(mTreeNode);
	vnode * back = this ;
	vnode * next = back -&gt; next() ;
	vnode * parent = back -&gt; parent() ;
	if ( t == NULL ) t = new tnode() ;
	vnode * v = new vnode( this -&gt; mCommands, t ) ;
	String s ( "NewHeadline" ) ;
	TTreeNodes * treeNodes = back -&gt; treeNodes() ;

	if ( next )
		// Insert before next.
		v -&gt; mTreeNode = treeNodes -&gt; InsertObject( next -&gt; mTreeNode, s, v ) ;
	else if ( parent )
		// Insert as the last child of parent.
		v -&gt; mTreeNode = treeNodes -&gt; AddChildObject( parent -&gt; mTreeNode, s, v ) ;
	else
		// Insert as the first sibling of back.
		v -&gt; mTreeNode = treeNodes -&gt; AddObject( back -&gt; mTreeNode, s, v ) ;

	return v ;
}
</t>
<t tx="edream.110203163054.1350">@ This method inserts a new node as the last child of the receiver.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::insertAsLastChild ( tnode * t )
{
	long n = this -&gt; numberOfChildren() ;
	return insertAsNthChild ( n, t ) ;
}</t>
<t tx="edream.110203163054.1351">@ This method inserts a new vnode as the nth child of the receiver.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::insertAsNthChild ( long index, tnode * t )
{
	assert(mTreeNode);
	vnode * parent = this ;
	if ( t == NULL ) t = new tnode() ;
	vnode * v = new vnode( this -&gt; mCommands, t );
	String s ( "NewHeadline" ) ;
	TTreeNodes * treeNodes = parent -&gt; treeNodes() ;

	if ( index == 0 )
		// Insert as the first child of parent.
		v -&gt; mTreeNode =
			treeNodes -&gt; AddChildObjectFirst( parent -&gt; mTreeNode, s, v ) ;
	else if ( index &gt;= parent -&gt; numberOfChildren() )  // bug fix: 8/28/99 (was index+1)
		// Insert as the last child of the parent. 
		v -&gt; mTreeNode =
			treeNodes -&gt; AddChildObject( parent -&gt; mTreeNode, s, v ) ;
	else {
		// Insert before the child index .
		vnode * child = parent -&gt; nthChild ( index ) ;
		assert(child);
		v -&gt; mTreeNode = treeNodes -&gt; InsertObject( child -&gt; mTreeNode, s, v ) ;
	}

	return v ;
}
</t>
<t tx="edream.110203163054.1352">@ This method moves the receiver after node v.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::moveAfter (vnode * v )
{
	assert(mTreeNode);
	vnode * next = v -&gt; next() ;
	vnode * parent = v -&gt; parent() ;

	this -&gt; destroyDependents() ;

	if ( next )
		// Move _before_ next.  (The documentation is incorrect.)
		mTreeNode -&gt; MoveTo ( next -&gt; mTreeNode, naInsert ) ;
	else if ( parent )
		// Move to the last child of parent.
		mTreeNode -&gt; MoveTo ( parent -&gt; mTreeNode, naAddChild ) ;
	else
		// Move to the last node.
		mTreeNode -&gt; MoveTo ( NULL, naAdd ) ;

	this -&gt; createDependents() ;
}
</t>
<t tx="edream.110203163054.1353">@ This method moves the receiver before node v.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::moveToRoot ( void  )
{
	assert(mTreeNode);
	this -&gt; destroyDependents() ;
	mTreeNode -&gt; MoveTo ( NULL, naAddFirst ) ;
	this -&gt; createDependents() ;
}
</t>
<t tx="edream.110203163054.1354">&lt;&lt; vnode methods &gt;&gt;=

void vnode:: moveToNthChildOf (vnode * parent, long index )
{
	assert(mTreeNode);
	this -&gt; destroyDependents() ;

	// Move the tree.
	if ( index == 0 )
		mTreeNode -&gt; MoveTo ( parent -&gt; mTreeNode, naAddChildFirst ) ;
	else if ( index + 1 &gt;= parent -&gt; numberOfChildren() )
		// Move to the last child of the parent. 
		mTreeNode -&gt; MoveTo ( parent -&gt; mTreeNode, naAddChild ) ;
	else {
		// Move before the child with index + 1.
		vnode * child = parent -&gt; nthChild ( index + 1 ) ;
		assert(child);
		mTreeNode -&gt; MoveTo ( child -&gt; mTreeNode, naInsert ) ;
	}

	this -&gt; createDependents() ;
}</t>
<t tx="edream.110203163054.1355">@ This method restores the tree described by dv in the position described by back and parent.  If back exists, we insert the tree after back.  Otherwise, if parent exists we insert the tree as the first child of parent.  If both back and parent are null the new tree becomes the root vnode.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::restoreOutlineFromDVnodes ( dvnode * dv, vnode * parent, vnode * back )
{
	Commands * commands = this -&gt; commands();
	TTreeNodes * treeNodes = this -&gt; treeNodes() ;
	vnode * result = NULL ;

    while ( dv ) {
        String s = dv -&gt; headline ;
        vnode *v = dv -&gt; v ;
        if ( result == NULL ) result = v;
        &lt;&lt; Insert v into the outline &gt;&gt;
        if ( dv -&gt; next ) {
        	&lt;&lt; Set back and parent fields for the new vnode &gt;&gt;
        }
        dv = dv -&gt; next ;
    }
	&lt;&lt; set icons for all vnodes of the result tree &gt;&gt;
	return result ;
}
</t>
<t tx="edream.110203163054.1356">@code

if ( back ) {
	vnode * next = back -&gt; next();
	if ( next ) {
		// Insert v before next.
		v -&gt; mTreeNode =
			treeNodes -&gt; InsertObject( next -&gt; mTreeNode, s, v ) ;
	}
	else {
		// Insert v as the last sibling of back.
		v -&gt; mTreeNode =
			treeNodes -&gt; AddObject( back -&gt; mTreeNode, s, v ) ;
	}
}
else if ( parent )
	// Insert v as the first child of parent.
	v -&gt; mTreeNode =
		treeNodes -&gt; AddChildObjectFirst( parent -&gt; mTreeNode, s, v ) ;
else {
	// Insert v as the root node.
	vnode * root = commands -&gt; rootVnode();
	v -&gt; mTreeNode =
        treeNodes -&gt; InsertObject( root -&gt; mTreeNode, s, v ) ;
}
</t>
<t tx="edream.110203163054.1357">@code

long delta = dv -&gt; next -&gt; level - dv -&gt; level ;

if ( delta &gt; 0 ) {
	assert(delta==1);
	back = NULL ;
	parent = v ;
}
else if ( delta == 0 ) {
	back = v ;
	parent = back -&gt; parent();
}
else {
	while ( ++delta &lt; 0 &amp;&amp; parent )
		parent = parent -&gt; parent();
	back = parent ;
	if ( back )
		parent = back -&gt; parent();
}
</t>
<t tx="edream.110203163054.1358">@ New code:  8/8/00
@code

vnode * next = result -&gt; nodeAfterTree();
for ( vnode * v = result ; v &amp;&amp; v != next ; v = v -&gt; threadNext() ) {
	v -&gt; setIconVal(-1);  // Disable usual optimization.
	v -&gt; setIcon();
}
</t>
<t tx="edream.110203163054.1359">@ This method creates a cloned tree after oldTree.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::cloneTree ( vnode * oldTree )
{
	// Create a new tree following oldTree.
	vnode * newTree = this -&gt; insertAfter ( oldTree -&gt; mT ) ;
	newTree -&gt; initHeadString ( oldTree -&gt; headString() ) ;
	copyTree ( oldTree, newTree ) ;

	// Join the trees and copy clone bits.
	oldTree -&gt; joinTreeTo ( newTree ) ;
	oldTree -&gt; copyCloneBitsTo ( newTree ) ;
	
	// 9/19/00
	vnode * next = newTree -&gt; nodeAfterTree();
    for ( vnode * v = newTree ; v &amp;&amp; v != next ; v = v -&gt; threadNext() ) {
    	v -&gt; setIconVal(-1);  // Disable usual optimization.
    	v -&gt; setIcon();
    }

	return newTree ;
}
</t>
<t tx="edream.110203163054.1360">@ This methods propagates clone bits from the receiver's tree to tree2.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::copyCloneBitsTo ( vnode * tree2 )
{
	vnode * tree1 = this ;
	ASSERT(tree2);

	// Set the bit in the root.
	if ( tree1 -&gt; isCloned() )
		tree2 -&gt; setClonedBit();
	else
		tree2 -&gt; clearClonedBit();

	// Recursively set the bits in all subtrees.
	vnode *child1 = tree1 -&gt; firstChild() ;
	vnode *child2 = tree2 -&gt; firstChild() ;
	while (child1)
	{
		PERM_ASSERT(child2);
		if ( child1 -&gt; isCloned() )
			child2 -&gt; setClonedBit();
		else
			child2 -&gt; clearClonedBit();
		child1 = child1 -&gt; next() ;
		child2 = child2 -&gt; next() ;
	}
	PERM_ASSERT(child2 == NULL);
}</t>
<t tx="edream.110203163054.1361">@ This method copies all subtrees of oldRoot to the subtrees of newRoot.  The caller is responsible for copying the headline text from oldRoot to newRoot.

This method must be given the new root as well as the old:  the Borland classes do not allow us to create an unattached outline.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::copyTree( vnode * oldTree, vnode * newTree )
{
	vnode * old_v = oldTree -&gt; firstChild();
	if ( old_v == NULL ) return ;

	// Copy the first child of oldTree to the first child of newTree.
	vnode * new_v = newTree -&gt; insertAsNthChild ( 0, old_v -&gt; mT ) ;
	new_v -&gt; initHeadString ( old_v -&gt; headString() ) ;

	// Copy all other children of oldTree after the first child of newTree.
	for ( old_v = old_v -&gt; next() ; old_v ; old_v = old_v -&gt; next() ) {
		new_v = new_v -&gt; insertAfter ( old_v -&gt; mT ) ;
		new_v -&gt; initHeadString ( old_v -&gt; headString() ) ;
	}

	// Recursively copy all descendents of oldTree.
	new_v = newTree -&gt; firstChild() ;
	old_v = oldTree -&gt; firstChild() ;
	while ( old_v ) {
		assert ( new_v ) ; 
		copyTree ( old_v, new_v ) ;
		old_v = old_v -&gt; next();
		new_v = new_v -&gt; next();
	}
	assert ( new_v == NULL ) ;
}
</t>
<t tx="edream.110203163054.1362">@ This method destroys all dependent vnodes and TTreeNode's associated with the receiver.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::destroyDependents ( void )
{
	vnode * parent = this -&gt; parent() ;
	if ( parent == NULL ) return ;

	// Destroy the nth child of all nodes joined to the receiver's parent.
	long n = this -&gt; childIndex();
	vnode * join = parent -&gt; mJoinList ;
	while ( join &amp;&amp; join != parent ) {
		vnode *child = join -&gt; nthChild ( n ) ;
		if ( child ) {
			child -&gt; unjoinTree() ;
			child -&gt; destroyTree() ;
		}
		join = join -&gt; mJoinList ;
	}
}
</t>
<t tx="edream.110203163054.1363">@ This method destroys (irrevocably deletes) a vnode tree.

This code should be called only when it is no longer possible to undo a previous delete.  It is always valid to destroy dependent trees.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::destroyTree ( void )
{
	assert(mTreeNode);
	TTreeNode * treeNode = this -&gt; mTreeNode ;  // Will be cleared below.
	
	// Delete all the vnodes of the tree.
	vnode * v = this ;
	vnode * after = this -&gt; nodeAfterTree();
	while ( v &amp;&amp; v != after ) {
		vnode * next = v -&gt; threadNext() ;
		delete v ;
		v = next ;
	}

	// Destroy the entire tree of TTreeNodes.
	treeNode -&gt; Delete() ;
}</t>
<t tx="edream.110203163054.1364">&lt;&lt; vnode methods &gt;&gt;=

void vnode::invalidOutline ( String message )
{
    vnode * parent = this -&gt; parent() ;
	String s("invalid outline: ") ;
	s += message ;
	s += '\r' ;

	if ( parent )
		s += parent -&gt; description() ;
	else
		s += this -&gt; description() ;

	alert ( s . c_str() ) ;
}
</t>
<t tx="edream.110203163054.1365">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isJoinedTo ( vnode * v )
{
	return v &amp;&amp; this -&gt; mT == v -&gt; mT ;
}</t>
<t tx="edream.110203163054.1366">@ This function returns true if the nodes v1 and v2 are on the same join list.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isOnJoinListOf ( vnode *v2)
{
	vnode * v1 = this ;
	assert( v2 &amp;&amp; v1 -&gt; mT &amp;&amp; v2 -&gt; mT );

	// v1 and v2 must share the same tnode.
	if ( v1 -&gt; mT != v2 -&gt; mT )
		return FALSE;

	// v1 and v2 must have join lists.
	if ( v1 -&gt; mJoinList == NULL || v2 -&gt; mJoinList == NULL )
		return FALSE;

	// Return TRUE if v2 is on v1's join list.
	for ( vnode * v = v1 -&gt; mJoinList ; v &amp;&amp; v != v1 ; v = v -&gt; mJoinList )
		if ( v == v2 )
			return TRUE;

	return FALSE;
}
</t>
<t tx="edream.110203163054.1367">@ This method joins the receiver to v2 if the two nodes have not already been joined.

Joining involves placing each vnode on the others join list.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::joinNodeTo ( vnode * v2 )
{
	vnode *v1 = this ;
	if ( v1 -&gt; isOnJoinListOf ( v2 ) ) return ; // Bug fix: 7/9/01 ??? (was v1)

	vnode *j1 = v1 -&gt; mJoinList ;
	vnode *j2 = v2 -&gt; mJoinList ;

	if (j1 &amp;&amp; j2) {
		// Swapping pointers joins the two cycles.
		v1 -&gt; mJoinList = j2;  // Neither join list is NULL.
		v2 -&gt; mJoinList = j1;
	}
	else if (j1) {
		v2 -&gt; mJoinList = j1;  // Link v2 after v1.
		v1 -&gt; mJoinList = v2;
	}
	else if (j2) {
		v1 -&gt; mJoinList = j2;  // Link v1 after v2.
		v2 -&gt; mJoinList = v1;
	}
	else {
		v1 -&gt; mJoinList = v2;  // point v1 and v2 at each other.
		v2 -&gt; mJoinList = v1;
	}

	#if 0
		v1 -&gt; setDirty();
		v2 -&gt; setDirty();
	#endif

	PERM_ASSERT( v1 -&gt; mJoinList &amp;&amp; v2 -&gt; mJoinList );
}
</t>
<t tx="edream.110203163054.1368">@ This function joins all nodes in the receiver and tree2.  This code makes no assumptions about the two trees, and some or all of the nodes may already have been joined.  The PERM_ASSERT's guarantee that both trees have the same topology.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::joinTreeTo ( vnode *tree2 )
{
	vnode * tree1 = this ;
	ASSERT(tree2);

	// Join the roots.
	tree1 -&gt; joinNodeTo ( tree2 ) ;

	// Recursively join all subtrees.
	vnode *child1 = tree1 -&gt; firstChild() ;
	vnode *child2 = tree2 -&gt; firstChild() ;
	while (child1)
	{
		PERM_ASSERT(child2);
		child1 -&gt; joinTreeTo ( child2 ) ;
		child1 = child1 -&gt; next() ;
		child2 = child2 -&gt; next() ;
	}
	PERM_ASSERT(child2 == NULL);
}
</t>
<t tx="edream.110203163054.1369">@ This method is called just before destroying a Tree of TTreeNodes.  It copies the data into the dvnode so the headlines can be restored if the deleted is undone.

&lt;&lt; vnode methods &gt;&gt;=

dvnode * vnode::saveOutlineWithLevel ( long level )
{
	vnode * v = this ;
	dvnode * root = new dvnode() ;
	dvnode * dv = root ;
	&lt;&lt; Set the data fields of dv &gt;&gt;

	vnode * child = this -&gt; firstChild();
	while ( child ) {
		// Recursively create a list of dvnodes for child's subtree.
		dv -&gt; next = child -&gt; saveOutlineWithLevel ( level + 1 ) ;
		// Move dv to the end of the list of dvnodes.
		while ( dv &amp;&amp; dv -&gt; next )
			dv = dv -&gt; next ;
		child = child -&gt; next();
	}
	return root ;
}
</t>
<t tx="edream.110203163054.1370">@code

dv -&gt; next = NULL ;
dv -&gt; level = level ;
dv -&gt; headline = v -&gt; headString();
dv -&gt; v = v ;</t>
<t tx="edream.110203163054.1371">@ This function returns true if the receiver should be a clone.  This can be done _very_ quickly using the receiver's join list.

The receiver is a clone if and only it is structurally _dissimilar_ to a node joined to it.  Structurally _similar_ joined nodes have non-null, distinct and joined parents, and have the same child indices.

9/16/99 We now return the node that proves that the receiver should be a clone.  This allows us to dispense with the old "survivor" logic in commands::deleteHeadline.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::shouldBeClone ( void )
{
	vnode *p = this -&gt; parent() ;
	long n = this -&gt; childIndex();

	for ( vnode * v = this -&gt; mJoinList ; v &amp;&amp; v != this ; v = v -&gt; mJoinList ) {
		vnode * vp = v -&gt; parent() ;
		if (
			p == NULL || vp == NULL ||  // Nodes joined to top level nodes are clones.
			vp == p ||  // Joined nodes with the same parent are clones.
			! p -&gt; isJoinedTo ( vp ) ||  // Nodes with unjoined parents are clones.
			v -&gt; childIndex() != n  // Nodes with different child indices are clones.
		)
			return TRUE;  // The receiver is structurally _dissimilar_ to v.
	}

	// The receiver is structurally similar to all nodes joined to it.
	return FALSE ;  
}
</t>
<t tx="edream.110203163054.1372">@ This code carefully unlinks the receiver from its join list.  We can not simply assume that all such links will eventually be cleared.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::unjoinNode ( void )
{
	vnode * next = this -&gt; mJoinList ;
	if ( next == NULL ) return ;
	
	if ( next -&gt; mJoinList == this ) {
		// The list contains only two elements.
		next -&gt; mJoinList = NULL ;
		this -&gt; mJoinList = NULL ;
		#if 0
			this -&gt; setDirty() ;
			next -&gt; setDirty() ;
		#endif
	}
	else {
		vnode * prev = NULL ;
		&lt;&lt; Set prev to the node that points to this &gt;&gt;
		// Remove this from the join list.
		prev -&gt; mJoinList = next;
		this -&gt; mJoinList = NULL;
		#if 0
			this -&gt; setDirty() ;
			prev -&gt; setDirty() ;
		#endif
	}
}</t>
<t tx="edream.110203163054.1373">@ We guard against any cycles in the join list, which would cause this loop to hang.  It's much better to cause an assert to fail.
@code

Commands * commands = this -&gt; commands() ;
commands -&gt; clearAllVisited();

for (
	prev = next;
	prev &amp;&amp; prev -&gt; mJoinList != this ;
	prev = prev -&gt; mJoinList
)
	if ( prev -&gt; isVisited() )
		assert ( 0 ) ;
	else
		prev -&gt; setVisited() ;</t>
<t tx="edream.110203163054.1374">@ This function unjoins all nodes of the receiver's tree.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::unjoinTree ( void )
{
	vnode * v = this ;
	vnode * after = this -&gt; nodeAfterTree() ;

	while ( v &amp;&amp; v != after ) {
		v -&gt; unjoinNode() ;
		v = v -&gt; threadNext() ;
	}
}</t>
<t tx="edream.110203163054.1375">@ This routine checks the structure of the receiver's tree.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::validateOutlineWithParent ( vnode * p )
{
	bool result = TRUE ;  // optimists get only unpleasant surprises.
	vnode * parent = this -&gt; parent() ;
	long childIndex = this -&gt; childIndex() ;

	&lt;&lt; validate parent ivar &gt;&gt;
	&lt;&lt; validate childIndex ivar &gt;&gt;
	&lt;&lt; validate x ivar &gt;&gt;

	// Recursively validate all the children.
	for ( vnode * child = this -&gt; firstChild(); child; child = child -&gt; next() )
	{
		bool r = child -&gt; validateOutlineWithParent ( this ) ;
		if ( r == FALSE ) result = FALSE ;
	}

	return result ;
}</t>
<t tx="edream.110203163054.1376">@code

if ( parent != p )
	this -&gt; invalidOutline ( "Invalid parent link: " + parent -&gt; description() ) ;</t>
<t tx="edream.110203163054.1377">@code

if ( p )
{
	if ( childIndex &lt; 0 )
		this -&gt; invalidOutline ( "missing childIndex" + childIndex ) ;

    else if ( childIndex &gt;= p -&gt; numberOfChildren() )
		this -&gt; invalidOutline ( "missing children entry for index: " + childIndex ) ;
}
else if ( childIndex &lt; 0 )
	this -&gt; invalidOutline ( "negative childIndex" + childIndex ) ;
</t>
<t tx="edream.110203163054.1378">@code

if ( this -&gt; t() == NULL &amp;&amp; p != NULL )
	this -&gt; invalidOutline ( "NULL t" ) ;</t>
<t tx="edream.110203163054.1379"></t>
<t tx="edream.110203163054.1380"></t>
<t tx="edream.110203163054.1381">#include &lt;stdio.h&gt;

class vnode ;
class Commands ;

&lt;&lt; declare public utility functions &gt;&gt;

class atFile
{
public:
	atFile (Commands * commands) ;
	void read (vnode * v) ;
	void readAll (vnode * v) ;
	void write (vnode * v) ;
	void writeAll (vnode * v) ;
private:
	&lt;&lt; private atFile data &gt;&gt;
	&lt;&lt; private read methods &gt;&gt;
	&lt;&lt; private sentinel methods &gt;&gt;
	&lt;&lt; private utilities &gt;&gt;
	&lt;&lt; private write methods &gt;&gt;
};
</t>
<t tx="edream.110203163054.1382">bool compareFiles ( String path1, String path2 ) ;
short directiveKind (char * ip, char * limit) ;
bool isSectionName ( char *ip, char *limit, char **end_pp ) ;
bool matchHeadline ( vnode * v, String pattern ) ;
void setAncestorAtFileNodeDirty ( vnode * v ) ;</t>
<t tx="edream.110203163054.1383">@ The commander for the current window.
@c

Commands * mCommands ;

@ mErrors is number of errors seen while reading and writing.  We no longer make a distinction between warnings and errors, because there is no problem that can result in lost data.  mStructureErrors are errors reported by createNthChild.  If structure errors are found we delete the outline tree and rescan.
@c

long mErrors ;
long mStructureErrors ;

@ The files used by the output routines.  When tangling, we first write to a temporary output file.  After tangling is complete we compare the temporary file to the target file, if it exists.  If the files are equal we just delete the temporary file.  Otherwise we delete the old target file and rename the temporary file to be the target file.
@c

String mTargetFileName ;
String mOutputFileName ;

@ The stream used to write the temporary output file.
@c

TFileStream * mOutputStream ;

@ The indentation used when outputting section references or at-others sections.  We add the indentation of the line containing to reference or at-others to indent before expansion, then restore indent to its previous value when expansion is complete.

The unit of indentation is spaces, not tabs.
@c

long indent ;

@ The strings to be output before and after each sentinel line, i.e., the strings used to specify the beginning and end of sentinel comments. mEndSentinelComment is empty for single-line comments.

When writing, we set these strings to the comments delimiters specified by the Preferences Panel and any applicable @language and @comment directives, with single-line comment delimiters being used by default.  When reading, we set the strings using the characters before and after the &lt;leo&gt; tag in the first line of the file.
@c

String mStartSentinelComment ;
String mEndSentinelComment ;

@ The root of tree being written.
@c

vnode * mRoot ;
</t>
<t tx="edream.110203163054.1384">@code

vnode * createNthChild (long n, vnode * parent, String headline) ;
void joinTrees ( vnode *tree1, vnode *tree2 ) ;
char * scanDoc (TMemoryStream * ms, char *ip, char *limit, short kind) ;
char * scanHeader ( char * ip, char * limit ) ;
char * scanText (vnode *v, TMemoryStream *ms,
	char *ip, char *limit, short endSentinelKind) ;
void updateCloneIndices ( vnode * root, vnode * next ) ;</t>
<t tx="edream.110203163054.1385">@code

String nodeSentinelText ( vnode * v ) ;

void putCloseNodeSentinel ( vnode * v ) ;
void putCloseSentinels ( vnode * root, vnode * v ) ;

void putOpenLeoSentinel ( String text ) ;
void putOpenNodeSentinel ( vnode * v ) ;
void putOpenSentinels ( vnode * root, vnode * v ) ;

void putSentinel ( String text ) ;

short sentinelKind ( char *ip, char *limit ) ;
String sentinelName ( short sentinelKind ) ;

char * skipSentinelStart( char *ip, char *limit) ;</t>
<t tx="edream.110203163054.1386">@code

void appendToBody (TMemoryStream *ms, char *start, char *end);
void appendToBody (TMemoryStream *ms, String s);
void error ( String message );
void scanAllDirectives ( vnode * v );
char * skipIndent (long n, char * ip, char * limit);
void writeError ( String message );</t>
<t tx="edream.110203163054.1387">@code

// Top level...
vnode * findReference (vnode *root, char *ip, char *end_p, char *limit ) ;
bool inAtOthers (vnode * v) ;
void putAtOthers ( vnode * v, long delta ) ;
void putAtOthersChild ( vnode * v ) ;
void putBody ( vnode * root, vnode * v, long delta ) ;
void putBodyPart ( vnode * v ) ;
char * putCodePart ( vnode * v, char * ip, char * limit ) ;
char * putDirective ( char * ip, char * limit ) ;
char * putDoc ( char *ip, char *limit, short kind ) ;
char * putDocPart ( char * ip, char * limit ) ;

// Output methods...
void putBlanks (int n) ;
void putChar (char c) ;
void putIndent (int n) ;  // Outputs tabs corresponding to n spaces.
void putInt (int n) ;
char * putLeadingWs ( char * ip, char * limit_p ) ;
void putString ( String s ) ;
void putTabs (int n) ;</t>
<t tx="edream.110203163054.1388">// atFile.cpp created June 6, 2001.

#pragma option -w-par  // no warning: "Parameter is never used"
#pragma option -w-sig  // no warning: "Conversion may lose significant digits"

&lt;&lt; atFile includes &gt;&gt;
&lt;&lt; atFile abbreviations &gt;&gt;
&lt;&lt; atFile constants &gt;&gt;

@others</t>
<t tx="edream.110203163054.1389"></t>
<t tx="edream.110203163054.1390">#include &lt;vcl.h&gt;
#pragma hdrstop

#include "args.h"
#include "C_Tangle.h" // for some globals.
#include "Commands.h"
#include "hash.h"
#include "MainUnit.h" // for alert().
#include "atFile.h"
#include "tnode.h"
#include "Utils.h"
#include "vnode.h"

#include &lt;io.h&gt; // for creattemp().
#include &lt;ctype.h&gt;
#include &lt;dir.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;Filectrl.hpp&gt;  // For DirectoryExists.

#include "Leo.h"
</t>
<t tx="edream.110203163054.1391">#define oblank() this -&gt; putBlanks(1)
#define oblanks(n) this -&gt; putBlanks(n)
#define ochar(c) this -&gt; putChar(c)
#define oint(n) this -&gt; putInt(n)
#define onl() this -&gt; putChar('\n')
#define os(s) this -&gt; putString(s)
#define otab() this -&gt; putTabs(1)
#define otabs(n) this -&gt; putTabs(n)
</t>
<t tx="edream.110203163054.1392">@ These constants indicate the kind of at_directives.
@c

enum {
	noDirective,  // not an at-directive.
	docDirective, // @doc.
	atDirective,  // @&lt;space&gt; or @&lt;newline&gt;
	codeDirective, // @code
	cDirective, // @c&lt;space&gt; or @c&lt;newline&gt;
	othersDirective, // at-others
	miscDirective // All other directive
};

@ These constants indicate the kind of sentinel line.
@c

enum {
	noSentinel,  // Not a sentinel
	startAt, endAt, //@+at, @-at
	startBody, endBody, //@+body,@-body
  	startDoc, endDoc, //@+doc, @-doc
	startLeo, endLeo, // @+leo, @-leo
  	startNode, endNode, //@+node, @-node
 	startOthers, endOthers, //@+others, //@-others
	startRef, //@ &lt; &lt; ... @ &gt; &gt;
 	startVerbatim, //@verbatim
  	startDirective //@@
};
</t>
<t tx="edream.110203163054.1393"></t>
<t tx="edream.110203163054.1394">void Commands::readAtFile ( vnode * v )
{
	atFile * at = new atFile( this );
	at -&gt; read ( v ) ;
	delete at ;
}
</t>
<t tx="edream.110203163054.1395">void Commands::writeAtFile ( vnode * v )
{
	atFile * at = new atFile( this );
	at -&gt; write ( v ) ;
	delete at ;
}
</t>
<t tx="edream.110203163054.1396">atFile::atFile( Commands * theCommander )
{
	// Inialize ivars.
	mCommands = theCommander ;
	mErrors = 0 ;
	mStructureErrors = 0 ;
	mTargetFileName = "" ;
	mOutputFileName = "" ;
	mOutputStream = NULL ;
	indent = 0 ;
	mStartSentinelComment = "//" ;
	mEndSentinelComment = "" ;
	mRoot = NULL ;
}
</t>
<t tx="edream.110203163054.1397"></t>
<t tx="edream.110203163054.1398">@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c

vnode * atFile::createNthChild(long n, vnode * parent, String headline)
{
	assert(n &gt; 0);
	vnode * result = NULL ;

	// Create any needed dummy children.
	long dummies = n - parent -&gt; numberOfChildren() - 1 ;
	if ( dummies &gt; 0 )
		++ mStructureErrors ;

	while (dummies-- &gt; 0) {
		vnode * dummy = parent -&gt; insertAsLastChild(new tnode()) ;
		// The user should never see this headline.
		dummy -&gt; initHeadString ( "Dummy" ) ;
	}

	if (n &lt;= parent -&gt; numberOfChildren()) {
		result = parent -&gt; nthChild(n-1);
        if ( headline.Trim() != result -&gt; headString() . Trim() ) 
				++ mStructureErrors ;
    }
	else {
		++ mStructureErrors ;
        result = parent -&gt; insertAsLastChild(new tnode()) ;
	}

	result -&gt; initHeadString ( headline ) ;
    return result ;
}
</t>
<t tx="edream.110203163054.1399">@ This function joins all nodes in the two trees which should have the same topology. This code makes no other assumptions about the two trees; some or all of the nodes may already have been joined.

There are several differences between this method and the similar vnode:joinTreeTo method.  First, we can not assert that the two trees have the same topology because the derived file could have been edited outside of Leo.  Second, this method also merges the tnodes of all joined nodes.
@c

void atFile::joinTrees ( vnode *tree1, vnode *tree2 )
{
	assert(tree1 &amp;&amp; tree2);
	// Use a common tnode for both nodes.
	if ( tree1 -&gt; t() != tree2 -&gt; t() )
		tree1 -&gt; setT ( tree2 -&gt; t() ) ;
	// Join the roots using the vnode class.
    tree1 -&gt; joinNodeTo ( tree2 ) ;
    // Recursively join all subtrees.
    vnode *child1 = tree1 -&gt; firstChild() ;
    vnode *child2 = tree2 -&gt; firstChild() ;
    while (child1 &amp;&amp; child2) {
    	joinTrees ( child1, child2 ) ;
    	child1 = child1 -&gt; next() ;
    	child2 = child2 -&gt; next() ;
    }
	if (child1 || child2)
		error("cloned nodes have different topologies");
}
</t>
<t tx="edream.110203163054.1400">@ This is the entry point to the read code.  The root vnode should be an @file node.

If there are structure errors the first time we delete root and its body text, then rescan.  All other errors indicate potentially serious problems with sentinels.

The caller has enclosed this code in BeginUpdate/EndUpdate.
@c

void atFile::read ( vnode * root )
{
	&lt;&lt; Declare read vars &gt;&gt;
	mCommands -&gt; endEditing();  // Capture the current headline.
	mCommands -&gt; clearAllVisited() ;  // Clear the list of nodes for orphans logic.
	mTargetFileName = root -&gt; atFileNodeName();
	mRoot = root ;
	&lt;&lt; read the entire file into fileData &gt;&gt;
	if ( mErrors &gt; 0 ) return ;
	&lt;&lt; Scan the file buffer &gt;&gt;
	vnode *next = root -&gt; nodeAfterTree();
	if ( mStructureErrors &gt; 0 ) {
		mErrors = 0 ;
		&lt;&lt; Delete root's tree and body text &gt;&gt;
		&lt;&lt; Scan the file buffer &gt;&gt;
	}
	if ( mErrors == 0 ) {
		if ( mStructureErrors &gt; 0 ) {
			&lt;&lt; Issue structure error message &gt;&gt;
		}
        &lt;&lt; Handle clone bits &gt;&gt;
        &lt;&lt; Join cloned trees &gt;&gt;
        &lt;&lt; Handle all status bits &gt;&gt;
	}
	else {
		&lt;&lt; Issue serious error message &gt;&gt;
	}
}
</t>
<t tx="edream.110203163054.1401">String fileData("");
hashTable * h = NULL ;
TMemoryStream * ms = NULL ;
char *buf = NULL ;
char *ip = NULL ;
char *limit = NULL ;</t>
<t tx="edream.110203163054.1402">@c

if ( mTargetFileName . IsEmpty() )
	error("Missing file name in @file node");
else if ( FileExists ( mTargetFileName ) ) {
	TMemoryStream * ms = new TMemoryStream();
	try {
		ms -&gt; LoadFromFile(mTargetFileName);
		fileData = String ( (char *) ms -&gt; Memory, ms -&gt; Size - 1 ) ;
		buf = fileData . c_str() ;
	}
	catch (...) {
		error("Can not open " + mTargetFileName) ;
	}
	delete ms ;
}
else error ( mTargetFileName + " does not exit ");
</t>
<t tx="edream.110203163054.1403">indent = 0 ;
ip = buf ;
limit = ip + fileData.Length() ;
ms = new TMemoryStream() ;  // Must use new.

ip = scanHeader(ip, limit);
ip = scanText(root, ms, ip, limit, endLeo);

String s( (char *) ms -&gt; Memory, ms -&gt; Size);
root -&gt; setBodyStringOrPane(s);
delete ms ;
</t>
<t tx="edream.110203163054.1404">es("----- Minor error reading: ");
es(mRoot -&gt; headCString());
es(":marks have been cleared."); enl();</t>
<t tx="edream.110203163054.1405">while ( root -&gt; firstChild() )
	root -&gt; firstChild() -&gt; doDelete(root);
	
root -&gt; setBodyStringOrPane ( "" ) ;
</t>
<t tx="edream.110203163054.1406">@code

mCommands -&gt; clearAllVisited() ;

h = new hashTable() ;

for (vnode *v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() )
{
	long cloneIndex = v -&gt; t() -&gt; cloneIndex() ;
	
	// Special case: the root's cloneIndex field contains the max clone index.
	if ( v != root &amp;&amp; cloneIndex &gt; 0 ) {
		String key = h -&gt; longToString ( cloneIndex ) ;
		unsigned long hash = h -&gt; computeHash( key ) ;
		tnode * t = (tnode *) (h -&gt; lookup ( key, hash ));
		if ( t ) {
			// v is a clone: share the previous tnode.
			v -&gt; setT(t);
			t -&gt; setVisited(); // We will mark these clones later.
		}
		else h -&gt; enter ( key, v -&gt; t(), hash ) ;
	}
}

delete h ;

// Set clone marks for all visited tnodes.
for (vnode *v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() )
	if ( v -&gt; t() -&gt; isVisited() )
		v -&gt; initClonedBit(TRUE);</t>
<t tx="edream.110203163054.1407">@code

h = new hashTable() ;

for (vnode *v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() )
{
	long cloneIndex = v -&gt; t() -&gt; cloneIndex() ;
	
	// Special case: the root's cloneIndex field contains the max clone index.
	if ( v != root &amp;&amp; cloneIndex &gt; 0 ) {
		String key = h -&gt; longToString ( cloneIndex ) ;
		unsigned long hash = h -&gt; computeHash( key ) ;
		vnode * clone = (vnode *) (h -&gt; lookup ( key, hash ));
		if ( clone )
			this -&gt; joinTrees ( clone, v ) ;
		// Enter v so we can join the next clone to it.
		// The next call to lookup will find this v, not the previous.
		h -&gt; enter ( key, v, hash ) ;
	}
}

delete h ;</t>
<t tx="edream.110203163054.1408">vnode *current = NULL ;

for (vnode *v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() )
{
	v -&gt; setIcon();
	if ( v -&gt; isExpandedBitSet() )
		v -&gt; treeNode() -&gt; Expand ( FALSE ) ;
	else
		v -&gt; treeNode() -&gt; Collapse ( FALSE ) ;
	if ( v -&gt; isSelectedBitSet() )
		current = v ;
	if ( v -&gt; isTopBitSet() ) {
		// Just tell the open code we have seen the top vnode.
		mCommands -&gt; mTopVnode = v ;
	}
}

if ( current ) {
	// Indicate what the current node will be.
	mCommands -&gt; setCurrentVnode ( current ) ;
	#if 0 // old code
    	mCommands -&gt; makeVisible(current);
    	mCommands -&gt; setCurrentVnode ( NULL ) ;
    	mCommands -&gt; selectVnode ( current ) ;
	#endif
}
</t>
<t tx="edream.110203163054.1409">es("----- Serious error reading: ");
es(mRoot -&gt; headCString()); enl();
es("----- Outline may be corrupted due to damaged sentinel lines!"); enl();</t>
<t tx="edream.110203163054.1410">@ This method scans all vnodes, calling read for every @file node found.  v should point to the root of the entire tree on entry.
@c

void atFile::readAll ( vnode * root )
{
	vnode * v = root ;
	while (v) {
		if ( v -&gt; isAtIgnoreNode() )
			v = v -&gt; nodeAfterTree();
		else if ( v -&gt; isAtFileNode() ) {
			if ( ! v -&gt; isOrphan() )
            	this -&gt; read(v) ;
			v = v -&gt; nodeAfterTree();
		}
		else v = v -&gt; threadNext();
	}
	
	// Clear all dummy and orphan status bits.
	v = root ;
	while (v) {
		v -&gt; clearDummy();
		v -&gt; clearOrphan();
		v = v -&gt; threadNext();
	}
}

</t>
<t tx="edream.110203163054.1411">@ This method scans the doc part and appends the text to v's body.  The caller has already appended @&lt;space&gt; or @doc.
@c

char * atFile::scanDoc (
	TMemoryStream *ms, char *ip, char *limit, short kind )
{
	short endKind = kind == startDoc ? endDoc : endAt ;
	bool single = mEndSentinelComment . IsEmpty();
	&lt;&lt; Skip the opening sentinel &gt;&gt;
	&lt;&lt; Skip an opening block delim &gt;&gt;
	while (ip &lt; limit &amp;&amp; sentinelKind(ip, limit) != endKind ) {
		&lt;&lt; Append the next comment line to v's body &gt;&gt;
	}
	&lt;&lt; Skip the closing sentinel &gt;&gt;
	&lt;&lt; Remove a closing block delim from v's body &gt;&gt;
	return ip ;
}</t>
<t tx="edream.110203163054.1412">assert(match(ip, limit, kind == startDoc ? "+doc" : "+at"));
ip = skip_line(ip, limit); 
this -&gt; appendToBody(ms, kind == startDoc ? "@doc" : "@");
</t>
<t tx="edream.110203163054.1413">if ( ! single ) {
	char *ip1 = skip_ws(ip, limit);
	if (match(ip1, limit, mStartSentinelComment.c_str()))
		ip = skip_line(ip, limit);
}</t>
<t tx="edream.110203163054.1414">char *ip2 = skip_to_end_of_line(ip, limit);  // End of line.

// Point ip to the start of the real line.
if ( single ) {
	ip = skip_ws(ip, limit);
	if ( match(ip, limit, mStartSentinelComment.c_str()) ) {
	// Skip the opening comment delim and a blank.
		ip += mStartSentinelComment . Length();
		if (match(ip, limit, " "))
				++ip;
	}
}
else ip = skipIndent(indent, ip, limit);

// Append the line.
String line (ip, ip2-ip);
String trim = line . TrimRight();
this -&gt; appendToBody(ms, line);

// Append a newline if it is real.
if ( ip2 &lt; limit &amp;&amp; is_nl(*ip2) &amp;&amp; line == trim)
	this -&gt; appendToBody(ms, "\n");

// Finish the line.
ip = skip_line(ip, limit);
</t>
<t tx="edream.110203163054.1415">if ( sentinelKind(ip, limit) == endKind ) {
	ip = skipSentinelStart(ip, limit);
	ip = skip_line(ip, limit);
}
else error("Missing " + sentinelName(endKind) + " sentinel");
</t>
<t tx="edream.110203163054.1416">@ This code will typically only be executed for HTML files.
@c

if ( ! single )
{
	// Get what we have written so far.
	String s( (char *) ms -&gt; Memory, ms -&gt; Size);

	// Remove the ending block delimiter.
	// The delimiter includes leading and trailing newlines.
	String delim("\n");
	delim += mEndSentinelComment ;
	delim += "\n" ;
	long slen = s.Length(), dlen = delim.Length();
	if ( slen &gt; dlen ) {
		char * cs = s.c_str();
		char * ds = delim.c_str();
		if (strncmp(cs + slen - dlen, ds, dlen) == 0) {
			s = String(cs, slen - dlen);
			// Rewrite the stream.
			ms -&gt; Clear();
			ms -&gt; Write ( s.c_str(), s.Length() ) ;
        }
	}
}
</t>
<t tx="edream.110203163054.1417">@ This method sets mStartSentinelComment and mEndSentinelComment based on the first @+leo sentinel line of the file.  We can not call sentinelKind here because that depends on the comment delimiters we set here.
@c

char * atFile::scanHeader ( char * ip, char * limit )
{
    bool valid = TRUE ;
    char *tag = "@+leo" ;
    
    // Skip blank lines.
    ip = skip_ws_and_nl(ip, limit);
    char *ip0 = ip ;
    char *ip1 = ip ;
    
    // The opening comment delim is the initial non-whitespace.
    while (ip &lt; limit &amp;&amp; !match(ip,limit,tag) &amp;&amp; !is_ws(*ip) &amp;&amp; !is_nl(*ip))
    	++ip ;
    if (ip1 &lt; ip )
    	mStartSentinelComment = String (ip1, ip - ip1 ) ;
    else valid = FALSE ;
    
    // Make sure we have @+leo
    ip = skip_ws(ip, limit);
    if ( match(ip, limit, tag))
    	ip += strlen(tag) ;
    else valid = FALSE ;
    
    // The closing comment delim is the trailing non-whitespace.
    ip1 = ip = skip_ws(ip, limit);
    while (ip &lt; limit &amp;&amp; !is_ws(*ip) &amp;&amp; !is_nl(*ip))
    	++ip ;
    mEndSentinelComment = String (ip1, ip - ip1);
    
    if ( valid )
    	ip = skip_line(ip0, limit);
    else
    	error("Bad @+leo sentinel in " + mTargetFileName);
		
	return ip ;
}</t>
<t tx="edream.110203163054.1418">@ This method is the heart of the new read code.  It scans text until the given ending sentinel is found, and warns if any other ending sentinel is found instead.  It calls itself recursively to handle most nested sentinels.
@c

char * atFile::scanText (
	vnode *v, // The vnode whose body we are accumualting.
	TMemoryStream *ms,  // The stream used to accumulate the body.
	char *ip, // Pointer into the file buffer.
	char *limit,  // The end of the file buffer.
	short endSentinelKind )  // The ending sentinel we expect.
{
	long lineIndent = 0 ;  // Changed only for sentinels.
	while (ip &lt; limit) {
		short kind = sentinelKind(ip, limit) ;
		char *linep = ip ;
		if ( kind != noSentinel ) {
			&lt;&lt; set lineIndent and linep &gt;&gt;
			ip = this -&gt; skipSentinelStart(ip, limit);
		}
		switch (kind) {
		case noSentinel: &lt;&lt; remove indent and append line &gt;&gt;break ;
		case startAt: &lt;&lt; scan @+at &gt;&gt; break ;
		case startBody: &lt;&lt; scan @+body &gt;&gt;; break ;
		case startDirective: &lt;&lt; scan @@ &gt;&gt; break ;
		case startDoc: &lt;&lt; scan @+doc &gt;&gt; break ;
		case startLeo: &lt;&lt; scan @+leo &gt;&gt; break ;
  		case startNode: &lt;&lt; scan @+node &gt;&gt; break ;
 		case startOthers: &lt;&lt; scan @+others &gt;&gt; break ;
		case startRef: &lt;&lt; scan @ref &gt;&gt; break ;
 		case startVerbatim: &lt;&lt; scan @verbatim &gt;&gt; break ;
		case endAt: case endBody: case endDoc:
		case endLeo: case endNode: case endOthers:
			&lt;&lt; handle an ending sentinel &gt;&gt; break ;
		default: &lt;&lt; warn about unknown sentinel &gt;&gt;
		}
	}
	&lt;&lt; handle unexpected end of text &gt;&gt;
	return ip ;
}
</t>
<t tx="edream.110203163054.1419">@ lineIndent is the total indentation on a sentinel line.  The first "indent" portion of that must be removed when recreating text.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

{
	// All sentinels except +leo should start with a newline.
    char *ip1 = ip ;
    if ( is_nl(*ip1) )
    	ip1 = skip_nl(ip1, limit);
    	
    linep = skipIndent ( indent, ip1, limit ) ;
    
	// Calculate the total indentation on the line.
    long n = 0 ;
    while (ip1 &lt; limit) {
    	if (*ip1 == '\t') n += ( arg_tab_width - n % arg_tab_width ) ;
    	else if (*ip1 == ' ') ++ n ;
    	else break ;
    	++ ip1 ;
    }

	lineIndent = n ;
}</t>
<t tx="edream.110203163054.1420">@ The sentinelKind routine returned noSentinel, so if the line contains only a newline that newline is not part of a sentinel and it must be appended to make progress.  Otherwise, we don't want to append the trailing newline here because it might be part of a sentinel.
@c

{
	char *ip1 = skipIndent ( indent, ip, limit ) ;
	// Append only newlines that can't be part of a sentinel.
	if (ip &lt; limit &amp;&amp; is_nl(*ip))
		ip = skip_nl(ip, limit);
	else
		ip = skip_to_end_of_line(ip, limit);
	String line (ip1, ip-ip1);
	this -&gt; appendToBody(ms, line);
}</t>
<t tx="edream.110203163054.1421">ip = skip_line(ip, limit); // Skip the sentinel.

if (kind == endSentinelKind) {
	if (kind == endLeo) {
		ip = skip_ws_and_nl(ip,limit);
		if (ip &lt; limit)
			error("Ignoring text after @-leo");
	}
	return ip ;
}
else {
	// Tell of the structure error.
	String name = sentinelName(kind);
	String expect = sentinelName(endSentinelKind);
	error( "Ignoring " + name + " sentinel.  Expecting " + expect);
}</t>
<t tx="edream.110203163054.1422">// Issue the error.
String name = sentinelName(endSentinelKind);
error("Unexpected end of file. Expecting " + name + "sentinel" );</t>
<t tx="edream.110203163054.1423"></t>
<t tx="edream.110203163054.1424">assert(match(ip,limit,"+at"));
ip = scanDoc(ms, ip, limit, kind);</t>
<t tx="edream.110203163054.1425">assert(match(ip,limit,"+body"));
ip = skip_line(ip, limit); // Skip the sentinel.
ip = scanText(v, ms, ip, limit, endBody );
</t>
<t tx="edream.110203163054.1426">assert(match(ip,limit,"+doc"));
ip = scanDoc(ms, ip, limit, kind);
</t>
<t tx="edream.110203163054.1427">assert(match(ip,limit,"+leo"));
ip = skip_line(ip, limit);
error("Ignoring unexpected @+leo sentinel" );</t>
<t tx="edream.110203163054.1428">{
	long n = 0 ; // Default for bad index.
	String headline (""), ref("");
	tnode dummy_t(0,"");
	vnode dummy(mCommands, &amp;dummy_t) ;  // A dummy vnode to carry status bits.
	&lt;&lt; skip the node sentinel, setting headline, ref and n &gt;&gt;
	long cloneIndex = dummy . t() -&gt; cloneIndex();
	long oldIndent = indent ;
	indent = lineIndent ;
	if ( n == 0 ) {
		&lt;&lt; Check the filename in the sentinel &gt;&gt;
		// Put the text of the root node in the current node.
		ip = scanText(v, ms, ip, limit, endNode );
		v -&gt; t() -&gt; setCloneIndex ( cloneIndex ) ;
	}
	else {
		TMemoryStream * new_ms = new TMemoryStream() ;  // Must use new.
		vnode *child = createNthChild(n, v, headline);
		child -&gt; t() -&gt; setCloneIndex ( cloneIndex ) ;
		ip = scanText(child, new_ms, ip, limit, endNode );
		// If text followed the section reference in the outline,
		// that text will immediately follow the //@-node sentinel.
		if (ip &lt; limit &amp;&amp; !is_nl(*ip)) {
			char *ip1 = ip;
			ip = skip_line(ip, limit);
			String line (ip1, ip-ip1);
			this -&gt; appendToBody(ms, line);
		}
		&lt;&lt; copy new_ms to child's body &gt;&gt;
		delete new_ms;
	}
	indent = oldIndent ;
}
</t>
<t tx="edream.110203163054.1429">assert(match(ip,limit,"+node:"));
ip += 6 ;
ip = skip_ws(ip, limit);

// Compute the child index.
char *np = ip ; // Start of number.
while (ip &lt; limit &amp;&amp; isdigit(*ip))
	++ip ;

if (np == ip || !match(ip, limit, ":"))
	error("Bad child index in @+node");
else {
    String s(np, ip-np);
    n = s . ToInt();
    ++ip ; // Skip the ":".
}

&lt;&lt; Set status bits in dummy vnode &gt;&gt;

if ( match(ip, limit, ":") )
	++ ip ;
else
	error("Bad attribute field in @+node");

// Set headline.
char *hp = ip ;

if ( mEndSentinelComment . IsEmpty() )
	ip = skip_to_end_of_line(ip, limit);
else {
	while (
		ip &lt; limit &amp;&amp; ! is_nl(*ip) &amp;&amp;
		! match (ip, limit, mEndSentinelComment . c_str() )
	)
		++ ip ;
}
headline = String(hp, ip-hp);
headline = headline . TrimRight();

// Set reference if it exists.
ip = hp ;
ip = skip_ws(ip, limit);
char *rp = ip ;
if (match(ip, limit, "&lt;&lt;")) {
	while ( ip &lt; limit &amp;&amp; !is_nl(*ip) &amp;&amp; !match(ip, limit, "&gt;&gt;"))
		++ ip ;
	if (match(ip, limit, "&gt;&gt;"))
		ref = String(rp, ip+2-rp);
}
ip = skip_line(hp, limit);
</t>
<t tx="edream.110203163054.1430">while ( ip &lt; limit &amp;&amp; *ip != ':' &amp;&amp; !is_nl(*ip) )
{
	long index = 0 ;
	
	switch (*ip++) {
	case 'C' :
		&lt;&lt; set index from the C=nnn, field &gt;&gt;
		dummy . t() -&gt; setCloneIndex(index);
		break ;
	default : break ; // Ignore unknown status bits.
	}
}
</t>
<t tx="edream.110203163054.1431">@code

if ( *ip == '=' ) {
	++ ip ;
	char *ip1 = ip ;
	while ( ip &lt; limit &amp;&amp; isdigit(*ip) )
		++ ip ;
	String s(ip1, ip - ip1);
	index = s.ToInt();
	if ( ip &lt; limit &amp;&amp; *ip == ',' )
		++ ip ;
}
</t>
<t tx="edream.110203163054.1432">String s( (char *) new_ms -&gt; Memory, new_ms -&gt; Size);
String body = child -&gt; bodyString();

if ( child -&gt; isDummy() )
	child -&gt; clearDummy();
else if ( child -&gt; isOrphan() )
	error("Replacing body text of orphan: " + child -&gt; headString());
else if ( body . Length() &gt; 0 &amp;&amp; body != s )
	error("Duplicate definition of " + child -&gt; headString());

// At present we _always_ update the body text.
// This is reasonable, but maybe not best.
child -&gt; t() -&gt; setTnodeText ( s );
</t>
<t tx="edream.110203163054.1433">String fileName = headline.Trim();
long len = fileName.Length();
if ( len &gt; 5 &amp;&amp; fileName.SubString(1,5) == "@file") {
	fileName = fileName.SubString(6,len-5);
	if ( fileName.Trim() != mTargetFileName.Trim() )
		error("File name in @node sentinel does not match file's name");
}
else error ("Missing @file in root @node sentinel");
</t>
<t tx="edream.110203163054.1434">@ We must make sure that the generated at-others is properly indented.
@c

assert(match(ip,limit,"+others"));
ip = skip_line(ip, limit); // Skip the sentinel.

// Append the real leading whitespace and at-others.
{
	char *ip2 = skip_ws(linep, limit);
	String ws(linep, ip2 - linep );
	this -&gt; appendToBody(ms, ws);
	this -&gt; appendToBody(ms, "@others");
}
ip = scanText(v, ms, ip, limit, endOthers );
</t>
<t tx="edream.110203163054.1435"></t>
<t tx="edream.110203163054.1436">@ The sentinel contains an @ followed by a section name in angle brackets.

This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(match(ip,limit,"&lt;&lt;"));
{
	String line("");
	char *ip1 = ip ;

	if ( mEndSentinelComment . IsEmpty() ) {
    	// Append the rest of the sentinel line to the text.
    	ip = skip_to_end_of_line(ip, limit);
    	line = String(ip1, ip-ip1);
	}
	else {
		while (
			ip &lt; limit &amp;&amp; ! is_nl(*ip) &amp;&amp;
			! match (ip, limit, mEndSentinelComment . c_str() )
		)
			++ ip ;
		line = String(ip1, ip-ip1);
	}
	ip = skip_line(ip1, limit);
    this -&gt; appendToBody(ms, line);
}</t>
<t tx="edream.110203163054.1437">assert(match(ip,limit,"verbatim"));
{
	// Skip the sentinel.
	ip = skip_line(ip,limit);

	// Append the next line to the text.
	char *ip1 = skipIndent ( indent, ip, limit ) ;
	ip = skip_line(ip, limit);
	String line (ip1, ip-ip1);
	this -&gt; appendToBody(ms, line);
}</t>
<t tx="edream.110203163054.1438">assert(match(ip,limit,"@"));
{
	String line("");
	char *ip1 = ip ;  // The first '@' has already been eaten.

	if ( mEndSentinelComment . IsEmpty() ) {
    	// Append the rest of the sentinel line to the text.
    	ip = skip_line(ip, limit);
    	line = String(ip1, ip-ip1);
	}
	else {
		while (
			ip &lt; limit &amp;&amp; ! is_nl(*ip) &amp;&amp;
			! match (ip, limit, mEndSentinelComment . c_str() )
		)
			++ ip ;
		line = String(ip1, ip-ip1);
		line += "\n" ;
		ip = skip_line(ip1, limit);
	}
    this -&gt; appendToBody(ms, line);
}</t>
<t tx="edream.110203163054.1439">{
	char * ip1 = ip ;
	ip = skip_line(ip, limit);
	String line (ip1, ip-ip1);
	error("Unknown sentinel: " + line);
}</t>
<t tx="edream.110203163054.1440"></t>
<t tx="edream.110203163054.1441">@ root is an ancestor of v, or root == v.  This puts the entire expansion of v's body text enclosed in sentinel lines.
@c

void atFile::putBody ( vnode * root, vnode * v, long delta )
{
	indent += delta ;
		putOpenSentinels(root, v) ;
			putBodyPart(v);
			v -&gt; setVisited();
		putCloseSentinels(root, v) ;
	indent -= delta ;
}</t>
<t tx="edream.110203163054.1442">@ We generate the body part only if it contains something besides whitespace. The check for at-ignore is made in atFile::write.
@c

void atFile::putBodyPart ( vnode * v )
{
	char *ip = (char *) v -&gt; bodyCString() ;
	char *limit = ip + v -&gt; bodyCStringLength() ;
	char *ip2 = skip_ws_and_nl(ip, limit) ;
	if ( ip2 &gt;= limit ) return ;
	// adjust limit so there is no trailing whitespace.
	while ( limit &gt; ip &amp;&amp; is_ws( *(limit-1) ) )
		--limit ;
	putSentinel("@+body");
	&lt;&lt; put code/doc parts and sentinels &gt;&gt;
	putSentinel("@-body");
}</t>
<t tx="edream.110203163054.1443">while (ip &lt; limit) {
	short kind = directiveKind(ip, limit) ;
	char *ip1 = ip ;
	switch ( kind ) {
	case docDirective :
	case atDirective :
		ip = putDoc(ip, limit, kind); break ;
	case miscDirective :
		ip = this -&gt; putDirective(ip, limit); break ;
	case noDirective :
	case othersDirective :
		ip = this -&gt; putCodePart(v, ip, limit); break ;
	case cDirective :
	case codeDirective :
		ip = this -&gt; putDirective(ip, limit);
		ip = this -&gt; putCodePart(v, ip, limit);
		break ;
	default : assert (0);
    }
	assert (ip1 &lt; ip);  // We must make progress.
}
</t>
<t tx="edream.110203163054.1444">@ This method expands a code part, terminated by any at-directive except at-others.  It expands references and at-others and outputs @verbatim sentinels as needed.
@c

char * atFile::putCodePart ( vnode * v, char * ip, char * limit )
{
	bool atOthersSeen = FALSE ; // TRUE: at-others has been expanded.
	while (ip &lt; limit) {
		long delta = 0 ; // How much indent should change.
		&lt;&lt; handle the start of a line &gt;&gt;
		&lt;&lt; put the line &gt;&gt;
	}
done:
	return ip ;
}</t>
<t tx="edream.110203163054.1445">@ The at-others directive is the only directive that is recognized following leading whitespace, so it is just a little tricky to recognize it.
@c

&lt;&lt; compute delta, the width of the whitespace &gt;&gt;

short kind1 = directiveKind(ip, limit);
short kind2 = directiveKind(skip_ws(ip,limit), limit);

if ( kind1 == othersDirective || kind2 == othersDirective ) {
	&lt;&lt; handle @others &gt;&gt;
}
else if ( kind1 == noDirective ) {
	&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;
}
else goto done ;</t>
<t tx="edream.110203163054.1446">delta = 0 ;
{
	char * ip2 = ip ;
	while ( ip2 &lt; limit ) {
		if ( *ip2 == ' ' ) {
			++ delta ;
			++ ip2 ;
		}
		else if ( *ip2 == '\t' ) {
			delta += (arg_tab_width - (delta % arg_tab_width)) ;
			++ ip2 ;
		}
		else break ;
	}
}
</t>
<t tx="edream.110203163054.1447">// This skips all indent and delta whitespace, so putAtOthers must generate it all.

ip = skip_to_end_of_line(ip, limit);  // Bug fix: 7/6/01
if ( atOthersSeen )
	writeError( "@others already expanded in: " + v -&gt; headString());
else {
	atOthersSeen = TRUE ;
	putAtOthers(v, delta);
}
</t>
<t tx="edream.110203163054.1448">{
	String s(mStartSentinelComment);
	s += "@" ;
	if (match (ip, limit, s.c_str()))
		putSentinel("verbatim");
}
</t>
<t tx="edream.110203163054.1449">putIndent(indent);

while (ip &lt; limit ) {
    if (*ip == body_newline) {
    	onl();
    	ip = skip_nl(ip, limit);
    	break ;
    }
    else if (*ip == body_ignored_newline)
    	++ip;
	// at-others is recognized _only_ at the start of a line.
    else if (*ip == '&lt;') {
    	&lt;&lt; put possible section reference &gt;&gt;
    }
    else ochar(*ip++);
}</t>
<t tx="edream.110203163054.1450">char *end_p = NULL ;

if ( isSectionName ( ip, limit, &amp;end_p ) )
{
	// Create a reference sentinel.
	String s(ip, end_p - ip);
	putSentinel("@" + s);

	// Output the expansion.
	vnode * ref = findReference(v, ip, end_p, limit);
	if ( ref )
		putBody(v, ref, delta);
	else {
		String s("undefined section: ");
		s += String(ip, end_p - ip);
		s += "\n\treferenced from: ";
		s += v -&gt; headString();
		writeError(s);
	}
	ip = end_p ;
}
else ochar(*ip++);  // This is _not_ an error.
</t>
<t tx="edream.110203163054.1451">@ ip points to the start of a reference in root.  We search the descendents of root looking for the matching definition node.  There should be exactly one such node (descendents of other definition nodes are not searched).
@c

vnode * atFile::findReference (
	vnode * root, char * ip, char *end_p, char * limit )
{
	String pattern(ip, end_p - ip);
	vnode * next = root -&gt; nodeAfterTree();
	vnode * v = root -&gt; firstChild();
	while ( v &amp;&amp; v != next ) {
		if ( v -&gt; matchHeadline(pattern) &amp;&amp; ! v -&gt; isAtIgnoreNode() )
			return v ;
		v = v -&gt; threadNext();
	}
	return NULL ;
}</t>
<t tx="edream.110203163054.1452">@ Returns TRUE if v should be included in the expansion of the at-others directive in the body text of v's parent. v will not be included if it is a definition node or if its body text contains another at-others or @ignore directive.
@c

bool atFile::inAtOthers (vnode * v)
{
	// Return FALSE if this has been expanded previously.
	if ( v -&gt; isVisited() )
		return FALSE;
	// Return FALSE if this is a definition node.
	String h = v -&gt; headString();
	char * ip = h . c_str();
	char * limit = ip + strlen(ip);
	ip = skip_ws(ip, limit);
	if ( isSectionName(ip, limit, NULL) )
		return FALSE ;
	// Return FALSE if v's body contains an @ignore or at-others directive.
	return ! v -&gt; isAtIgnoreNode() &amp;&amp; ! v -&gt; isAtOthersNode() ;
}
</t>
<t tx="edream.110203163054.1453">@ The at-others directive is recognized only at the start of the line.  This code must generate all leading whitespace for the opening sentinel.
@c

void atFile::putAtOthers ( vnode * v, long delta )
{
	indent += delta ;
	putSentinel("@+others");
        vnode * child = v -&gt; firstChild();
        while ( child ) {
        	if ( this -&gt; inAtOthers( child ) )
        		putAtOthersChild( child ) ;
        	child = child -&gt; next();
        }
	putSentinel("@-others");
	indent -= delta ;
}
</t>
<t tx="edream.110203163054.1454">void atFile::putAtOthersChild ( vnode * v )
{
	putOpenNodeSentinel(v) ;
		// Insert the expansion of v.
		v -&gt; setVisited(); // Make sure it is never expanded again.
		putBodyPart(v);
		// Insert expansions of all children.
		vnode * child = v -&gt; firstChild();
		while ( child ) {
			if ( this -&gt; inAtOthers( child ) )
				putAtOthersChild( child ) ;
			child = child -&gt; next();
		}
	putCloseNodeSentinel(v) ;
}
</t>
<t tx="edream.110203163054.1455">@ This method outputs the directive or reference at ip in a sentinel.
@c

char * atFile::putDirective ( char * ip, char * limit )
{
	assert(ip &lt; limit &amp;&amp; *ip == '@');
	char *ip1 = ip;
	ip = skip_to_end_of_line(ip, limit);
	assert(ip1 &lt; ip);
	String directive(ip1, ip-ip1);
	ip = skip_line(ip1, limit);
	this -&gt; putSentinel ( "@" + directive ) ;
	return ip ;
}
</t>
<t tx="edream.110203163054.1456">@ This method outputs a doc section terminated by @code or end-of-text.  All other interior directives become part of the doc part.
@c

char * atFile::putDoc ( char *ip, char *limit, short kind )
{
	assert(kind == atDirective || kind == docDirective);
	&lt;&lt; skip the @&lt;space&gt; or @doc &gt;&gt;
	&lt;&lt; set limit to the end of the doc part &gt;&gt;
	String tag = kind == docDirective ? "doc" : "at" ;
	putSentinel("@+" + tag);
	ip = putDocPart(ip,limit);
	putSentinel("@-" + tag);
	return ip ;
}
</t>
<t tx="edream.110203163054.1457">@ Do not skip whitespace following the @doc or @.  It is needed by the read code.
@c

if ( kind == docDirective )
	ip += 4 ; // Skip the "@doc"
else
	++ip; // Skip the "@";
</t>
<t tx="edream.110203163054.1458">@ at-code or the end of body text terminates the doc part.
@c

char *ip2 = ip ;
while ( ip2 &lt; limit ) {
	ip2 = skip_line(ip2, limit) ;
	short kind = directiveKind(ip2, limit) ;
	if (kind == codeDirective || kind == cDirective)
		break ;
}

limit = ip2 ;
</t>
<t tx="edream.110203163054.1459">@ This method puts a comment part in comments.
@c

char * atFile::putDocPart ( char * ip, char * limit )
{
	bool single = mEndSentinelComment . IsEmpty() ;

	if (!single) {
		putIndent(indent);
		os(mStartSentinelComment.c_str()); onl();
	}
	// Put all lines.
	while (ip &lt; limit) {
		putIndent(indent);
		long leading = indent ;
		if (single) {
			os(mStartSentinelComment.c_str()); oblank();
			leading += mStartSentinelComment . Length() + 1 ;
		}
		&lt;&lt; copy words, splitting the line if needed &gt;&gt;
	}
	if (!single) {
		// This comment is like a sentinel.
		onl(); putIndent(indent);
		os(mEndSentinelComment.c_str());
		onl();  // Note: no trailing whitespace.
	}
	return ip ;
}
</t>
<t tx="edream.110203163054.1460">@ We remove trailing whitespace from lines that have _not_ been split so that a newline has been inserted by this routine if and only if it is preceded by whitespace.
@c

char *line = ip ; // Start of the current line.

while (ip &lt; limit) {
	char * word = ip;  // Start of the current word.

	// Skip the next word and trailing whitespace.
	ip = skip_ws(ip, limit);
	while (ip &lt; limit &amp;&amp; !is_nl(*ip) &amp;&amp; !is_ws(*ip))
		++ ip ;
	ip = skip_ws(ip,limit);
	
	// Output the line if no more is left.
	if (ip &lt; limit &amp;&amp; is_nl(*ip))
		break ;

	// Split the line before the current word if needed.
    long len = ip - line ;
    if (line == word || leading + len &lt; arg_page_width )
    	word = ip ; // Advance to the next word.
    else {
    	// Write the line before the current word and insert a newline.
    	String theLine(line, word-line);
    	putString(theLine);
    	onl();  // This line must contain trailing whitespace.
		line = ip = word ; // Rescan the word on the next line.
    	break ;
	}
}

// Remove trailing whitespace and output the remainder of the line.
String theLine(line, ip-line);
theLine = theLine . TrimRight();
putString(theLine);

if (ip &lt; limit &amp;&amp; is_nl(*ip) ) {
	ip = skip_nl(ip, limit);
	onl();  // No an inserted newline and no trailing whitespace.
}</t>
<t tx="edream.110203163054.1461">@ This is the entry point to the write code.  The root vnode should be an @file node.
We set the orphan flag if there are problems writing the file to force Commands::write_LEO_file to the tree to the .leo file.
@c

void atFile::write ( vnode * root )
{
	mRoot = root ;
	mCommands -&gt; endEditing();  // Capture the current headline.
	&lt;&lt; Open files.  Set orphan flag and return on errors &gt;&gt;
	mCommands -&gt; clearAllVisited() ; // Unvisited nodes will be orphans.
    vnode * next = root -&gt; nodeAfterTree();
	updateCloneIndices(root, next);
	putOpenLeoSentinel("@+leo");
		putOpenNodeSentinel(root) ;
    	putBodyPart(root);
		root -&gt; setVisited();
		putCloseNodeSentinel(root) ;
	putSentinel("@-leo");
	delete mOutputStream ;  // Close the output file.
	mOutputStream = NULL ;
	&lt;&lt; Warn about @ignored and orphans  &gt;&gt;
	if ( mErrors &gt; 0 || mRoot -&gt; isOrphan() ) {
		mRoot -&gt; setOrphan() ;
		remove ( mOutputFileName.c_str() ) ;  // Delete the temp file.
		&lt;&lt; Issue final write error message &gt;&gt;
	}
	else {
		&lt;&lt; Replace the target with the temp file if different &gt;&gt;
	}
}
</t>
<t tx="edream.110203163054.1462">@code

// Set globals from ancestors.
this -&gt; scanAllDirectives(root);
if ( mErrors &gt; 0 ) {
	mRoot -&gt; setOrphan();
	return ;
}

mTargetFileName = root -&gt; atFileNodeName();
&lt;&lt; setOrphan and return if mTargetFileName is bad &gt;&gt;
&lt;&lt; Open a temp file and set mOutputFileName &gt;&gt;
mOutputStream = new TFileStream(mOutputFileName, fmOpenWrite);
if ( mOutputStream == NULL ) {
	mRoot -&gt; setOrphan();
	return ;
}</t>
<t tx="edream.110203163054.1463">@code


if ( mTargetFileName . Length() == 0 ) {
	root -&gt; setOrphan();
	return ;
}

long index = mTargetFileName.LastDelimiter("\\");

if ( index &gt; 0 ) {
	String path = mTargetFileName.SubString(1, index - 1);
	if ( path.Length() &gt; 0 &amp;&amp; ! DirectoryExists(path) ) {
		root -&gt; setOrphan();
		return ;
	}
}
</t>
<t tx="edream.110203163054.1464">@ We create the temporary file where the target file will eventually be placed:

1. In the directory specified in mTargetFileName if it contains a full path.
2. In the directory specified in an @path directive.
3. In the directory specified in the Preferences panel.
4. In the current directory.

scanAllDirectives sets the current directory as specified by @path or the Preferences panel, so we need only check to see if mTargetFileName contains a full path.
@c

// Put the current directory path in pathname.
char pathname[MAXPATH];
strcpy(pathname, "X:\\");
pathname[0] = 'A' + getdisk(); // replace X with current drive letter
int result = getcurdir(0, &amp;pathname[3]);
if ( result == -1 ) strcat(pathname, "\\");

// Make sure pathname ends with a backslash.
long len = strlen(pathname);
if ( len == 0 || pathname[len-1] != '\\')
	strcat(pathname, "\\");

// scanAllDirectives also checks directory names.
if ( ! DirectoryExists ( pathname ) ) {
	writeError ( String("Directory \"") + pathname + "\" does not exist " );
	return ;
}

int handle = creattemp(pathname, 0);
if (handle == -1 ) {
	writeError ( String("Can not create \"") + pathname + "\"" );
	return ;
}
else close (handle);

String s ( (char *) pathname);
mOutputFileName = s ;</t>
<t tx="edream.110203163054.1465">for ( vnode * v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() ) {
	if ( ! v -&gt; isVisited() ) {
		mRoot -&gt; setOrphan();
		String s("Orphan node:  ");
		s += v -&gt; headString();
		writeError ( s.c_str() ) ;
	}
	if ( v -&gt; isAtIgnoreNode() ) {
		mRoot -&gt; setOrphan();
		String s("@ignore node: ");
		s += v -&gt; headString();
		writeError ( s.c_str() ) ;
	}
}
</t>
<t tx="edream.110203163054.1466">ecnl() ;
es("----- Not written: ");
es(mTargetFileName.c_str()); enl();</t>
<t tx="edream.110203163054.1467">if ( compareFiles ( mOutputFileName, mTargetFileName ) ) {
	// Just delete the temp file.
	remove ( mOutputFileName.c_str() ) ;
	es("Unchanged: "); es(mTargetFileName.c_str() ); enl();
}
else {
	// Replace target file with temp file.
	if ( FileExists ( mTargetFileName ) )
		remove ( mTargetFileName . c_str() ) ;
	if ( 0 != rename ( mOutputFileName . c_str(), mTargetFileName.c_str() ) ) {
		writeError("Rename failed: no file created!");
	}
	else {
		es("Writing: "); es(mTargetFileName.c_str() ); enl();
	}
}
</t>
<t tx="edream.110203163054.1468">@ This method scans all vnodes, calling write for every @file node found.  v should point to the root of the entire tree.
@c

void atFile::writeAll ( vnode * v )
{
	&lt;&lt; Clear all orphan bits &gt;&gt;
    while ( v ) {
        if ( v -&gt; isAtIgnoreNode() )
            v = v -&gt; nodeAfterTree();
        else if ( v -&gt; isAtFileNode() ) {
			if ( v -&gt; isDirty() )
            	this -&gt; write(v) ;
            v = v -&gt; nodeAfterTree();
        }
        else v = v -&gt; threadNext();
    }
}
</t>
<t tx="edream.110203163054.1469">@ We must clear these bits because they may have been set on a previous write.  Calls to atFile::write may set the orphan bits in @file nodes.  If so, write_LEO_file will write the entire @file tree.
@c

for ( vnode * v2 = v ; v2 ; v2 = v2 -&gt; threadNext() )
	v2 -&gt; clearOrphan();</t>
<t tx="edream.110203163054.1470">@ These methods write their arguments to the output file.
</t>
<t tx="edream.110203163054.1471">void atFile::putBlanks ( int n )
{
	while (n-- &gt; 0)
		ochar(' ');
}
</t>
<t tx="edream.110203163054.1472">void atFile::putChar (char c)
{
	if ( mOutputStream )
		mOutputStream -&gt; Write( &amp;c, 1 );
}
</t>
<t tx="edream.110203163054.1473">@ This methods puts tabs and spaces corresponding to n spaces, assuming that we are at the start of a line.
@c

void atFile::putIndent ( int n )
{
	if ( arg_tab_width &gt; 1 ) {
		otabs ( n / arg_tab_width ) ;
    	oblanks ( n % arg_tab_width ) ;
	}
	else
		oblanks ( n ) ;
}</t>
<t tx="edream.110203163054.1474">void atFile::putInt (int i) 
{
	char buf [100];
	long n = sprintf(buf, "%d", i);
	if ( n != EOF )
		putString(buf);
}</t>
<t tx="edream.110203163054.1475">void atFile::putString ( String s ) 
{
	if ( mOutputStream )
		mOutputStream -&gt; Write( s.c_str(), s.Length() );
}
</t>
<t tx="edream.110203163054.1476">void atFile::putTabs ( int n )
{
	while ( n-- &gt; 0 )
		ochar('\t');
}
</t>
<t tx="edream.110203163054.1477"></t>
<t tx="edream.110203163054.1478">String atFile::nodeSentinelText ( vnode * v )
{
	String s("");
	// A hack: zero indicates the root node so scanText won't create a child.
	long index = 0 ;
	if ( v != mRoot &amp;&amp; v -&gt; parent() )
		index = v -&gt; childIndex() + 1 ;
	s += String(index);
	s += ":" ;
	&lt;&lt; append the status-bit characters to s &gt;&gt;
	s += ":" ;
	s += v -&gt; headString();
	return s ;
}
</t>
<t tx="edream.110203163054.1479">@ The cloneIndex field of the @root node is really the maximum clone index.

We make the @file node the top or current node if the top or current node is a descendent of the root.  This minimizes changes to the derived file.
@c

long cloneIndex = v -&gt; t() -&gt; cloneIndex() ;

if ( cloneIndex &gt; 0 ) {
	s += "C=" ;
	s += String ( cloneIndex );
}

</t>
<t tx="edream.110203163054.1480">void atFile::putCloseNodeSentinel ( vnode * v )
{
	String s = this -&gt; nodeSentinelText(v);
	this -&gt; putSentinel( "@-node:" + s);
}
</t>
<t tx="edream.110203163054.1481">@ root is an ancestor of v, or root == v.  We call putCloseSentinel for v up to, but not including, root.
@c

void atFile::putCloseSentinels ( vnode * root, vnode * v )
{
	this -&gt; putCloseNodeSentinel(v);
	for (;;) {
		v = v -&gt; parent();
		assert(v); // root must be an ancestor of v.
		if ( v == root ) break ;
		this -&gt; putCloseNodeSentinel(v);
	}
}</t>
<t tx="edream.110203163054.1482">@ This method is the same as putSentinel except we don't put an opening newline and leading whitespace.
@c

void atFile::putOpenLeoSentinel ( String text )
{
	os(mStartSentinelComment);
	os(text);
	os(mEndSentinelComment);
	onl(); // Ends of sentinel.
}</t>
<t tx="edream.110203163054.1483">@ This method puts an open node sentinel for node v.
@c

void atFile::putOpenNodeSentinel ( vnode * v )
{
	if ( v -&gt; isAtFileNode() &amp;&amp; v != mRoot )
		writeError("@file not valid in: " + v -&gt; headString() );
	else {
		String s = this -&gt; nodeSentinelText(v);
		this -&gt; putSentinel( "@+node:" + s);
	}
}
</t>
<t tx="edream.110203163054.1484">@ root is an ancestor of v, or root == v.  We call putOpenNodeSentinel on all the descendents of root which are the ancestors of v.
@c

void atFile::putOpenSentinels ( vnode * root, vnode * v )
{
	vnode * last = root ;
	while ( last != v ) {
		// Set node to v or the ancestor of v that is a child of last.
		vnode * node = v ;
		while ( node &amp;&amp; node -&gt; parent() != last )
			node = node -&gt; parent();
		assert(node);
		this -&gt; putOpenNodeSentinel(node);
		last = node ;
	}
}</t>
<t tx="edream.110203163054.1485">@ All sentinels are eventually output by this method.

Sentinels include both the preceding and following newlines. This rule greatly simplies the code and has several important benefits:

1. Callers never have to generate newlines before or after sentinels.  Similarly, routines that expand code and doc parts never have to add "extra" newlines.
2. There is no need for a "no-newline" directive.  If text follows a section reference, it will appear just after the newline that ends sentinel at the end of the expansion of the reference.  If no significant text follows a reference, there will be two newlines following the ending sentinel.

The only exception is that no newline is required before the opening "leo" sentinel. The putLeoSentinel and isLeoSentinel routines handle this minor exception.
@c

void atFile::putSentinel ( String text )
{
	onl(); putIndent(indent); // Start of sentinel.
	os(mStartSentinelComment);
	os(text);
	os(mEndSentinelComment);
	onl(); // Ends of sentinel.
}</t>
<t tx="edream.110203163054.1486">@ This method tells what kind of sentinel appears at ip.  Typically ip will point to the newline before the actual sentinel, but it is also valid for ip to point directly at the start of a sentinel line.
@c

#define test(name,start,end)\
	if(match_word(ip,limit,name)) { return plus ? start : end ; }

short atFile::sentinelKind ( char *ip, char *limit )
{
	if (is_nl(*ip))
		ip = skip_nl(ip, limit) ;
	ip = skip_ws(ip,limit);
	if (!match(ip, limit, mStartSentinelComment.c_str()))
		return noSentinel ;
	ip += mStartSentinelComment . Length() ;
	if (!match(ip, limit, "@"))
		return noSentinel ;
	++ip ; // Skip the first '@'.
	if (match(ip, limit, "@"))
		return startDirective ;
	else if (match(ip, limit, "@verbatim"))
		return startVerbatim ;
	else if (match(ip, limit, "&lt;&lt;"))
		return startRef ;
		
	// All the following start with + or -.
	char delim = *ip++ ;
	if (delim != '+' &amp;&amp; delim != '-')
		return noSentinel ;
	bool plus = delim == '+' ;
	test("at", startAt, endAt);
	test("body", startBody, endBody);
	test("doc", startDoc, endDoc);
	test("leo", startLeo, endLeo);
	test("node", startNode, endNode);
	test("others", startOthers, endOthers);
 	return noDirective ;
}

#undef test</t>
<t tx="edream.110203163054.1487">@ This method returns the name of the sentinel for warnings.
@c

String atFile::sentinelName ( short sentinelKind )
{
	switch ( sentinelKind )
	{
	case endAt: return "@-at" ;
	case endBody: return "@-body" ;
	case endDoc: return "@-body" ;
	case endLeo: return "@-leo" ;
	case endNode: return "@-node" ;
	case endOthers: return "@-others" ;
	case noSentinel: return "&lt;no sentinel&gt;" ;
	case startAt: return "@+at" ;
	case startBody: return "@+body" ;
	case startDirective: return "@@" ;
	case startDoc: return "@+doc" ;
	case startLeo: return "@+leo" ;
  	case startNode: return "@+node" ;
 	case startOthers: return "@+others" ;
 	case startVerbatim: return "@verbatim" ;
	default: return "&lt;unknown sentinel!&gt;" ;
	}
}</t>
<t tx="edream.110203163054.1488">char * atFile::skipSentinelStart( char * ip, char * limit)
{
	if (is_nl(*ip))
		ip = skip_nl(ip, limit) ;
	ip = skip_ws(ip, limit);
	assert(match(ip, limit, mStartSentinelComment.c_str()));
	ip += mStartSentinelComment . Length() ;
	assert(ip &lt; limit &amp;&amp; *ip == '@');
	return ++ip ;
}</t>
<t tx="edream.110203163054.1489"></t>
<t tx="edream.110203163054.1490">@ Returns TRUE if two files are identical.
@c

bool compareFiles ( String path1, String path2 )
{
	char buf1[1024], buf2[1024];
	int f1 = FileOpen(path1, fmOpenRead) ;
	int f2 = FileOpen(path2, fmOpenRead) ;
	bool result = f1 &gt; -1 &amp;&amp; f2 &gt; -1 ;
    while (result) {
    	long n1 = FileRead(f1, buf1, 1024) ;
    	long n2 = FileRead(f2, buf2, 1024) ;
		if (n1 == 0 &amp;&amp; n2 == 0) break ;  // Files are equal.
    	result = (n1 == n2 &amp;&amp; memcmp(buf1, buf2, n1) == 0);
	}
	if (f1 &gt; -1) FileClose(f1);
	if (f2 &gt; -1) FileClose(f2);
	return result ;
}</t>
<t tx="edream.110203163054.1491">@ Returns the kind of at-directive or noDirective.
@c

short directiveKind ( char * ip, char * limit )
{
	if ( ip &gt;= limit || *ip != '@' )
		return noDirective ;
	else if ( match_word(ip, limit, "@c") )
		return cDirective ;
	else if ( match_word(ip, limit, "@code") )
		return codeDirective ;
	else if ( match_word(ip, limit, "@doc") )
		return docDirective ;
	else if (
		match(ip, limit, "@ ") ||
		match(ip, limit, "@\t") ||
		match(ip, limit, "@\n")
	)
		return atDirective ;
	else if (match_word(ip, limit, "@others"))
		return othersDirective ;
	else
		return miscDirective ;
}
</t>
<t tx="edream.110203163054.1492">@ Returns TRUE if ip points to the start of a section name.  If so, we set end_pp in the caller to the character past the section reference.
@c

bool isSectionName ( char *ip, char *limit, char **end_pp )
{
	if (! match(ip, limit,"&lt;&lt;"))
		return FALSE ;

	// Find the end of the section name.
	while (ip &lt; limit &amp;&amp; !is_nl(*ip) &amp;&amp; !match(ip,limit, "&gt;&gt;" ) )
		++ ip ;

	if (end_pp &amp;&amp; match(ip, limit, "&gt;&gt;"))
		*end_pp = ip + 2 ;

	return match(ip, limit, "&gt;&gt;") ;
}
</t>
<t tx="edream.110203163054.1493">@ This function sets any ancestor @file node to be dirty.
@c

void setAncestorAtFileNodeDirty ( vnode * v )
{
	while ( v ) {
		if ( v -&gt; isAtFileNode() ) {
			v -&gt; setDirty();
			v -&gt; setDirtyJoined();
		}
		v = v -&gt; parent();
	}
}</t>
<t tx="edream.110203163054.1494"></t>
<t tx="edream.110203163054.1495">void atFile::appendToBody (TMemoryStream *ms, String s)
{
	assert(ms);
	if ( s . Length() &gt; 0 )
		ms -&gt; Write( s . c_str(), s . Length() ) ;
}

void atFile::appendToBody (TMemoryStream *ms, char *start, char *end)
{
	assert(ms);
	long len = end - start ;
	if ( len &gt; 0 )
		ms -&gt; Write( start, len ) ;
}
</t>
<t tx="edream.110203163054.1496">@ This code scans the node v and all of v's ancestors looking for directives.  If found, the corresponding Tangle/Untangle globals are set.

Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node x, no @owncolor or @nocolor directives are examined in any ancestor of x.

This code is similar to Commands::scanAllDirectives, but it has been modified for use by the atFile class.
@c

#define test(bit) ((bit &amp; bits) != 0)
#define prev(bit) ((bit &amp; old_bits) != 0)

void atFile::scanAllDirectives ( vnode * v )
{
    assert(v);
    TLeoForm * form = v -&gt; leoForm() ;
	long old_bits = 0 ;  // One bit for each directive.
	long val = 0 ;
	bool path_specified = FALSE ;
	&lt;&lt; Set global arguments to default values &gt;&gt;
	&lt;&lt; Set path from @file node &gt;&gt;
	for ( ; v ; v = v -&gt; parent() ) {
		String s;  // Must have the same lifetime as ip!
		char * ip = v -&gt; bodyCString() ;
		long len = v -&gt; bodyCStringLength() ;
		char * limit = ip + len ;
		long bits = is_special_bits ( ip, len, DONT_SET_ROOT_FROM_HEADLINE ) ;
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @comment or @language &gt;&gt;
		&lt;&lt; Test for @pagewidth and @tabwidth &gt;&gt;
		old_bits |= bits ;
	}
	if ( !path_specified &amp;&amp; !prev(path_bits)) {
		// No path in @file headline and no @path directive.
		&lt;&lt; Set current directory if possible &gt;&gt;
	}
	&lt;&lt; Set comment Strings from global vars &gt;&gt;
}

#undef test
#undef prev
</t>
<t tx="edream.110203163054.1497">#if 0 // not used in atFile::scanAllDirectives.
	// CWEB flag might be useful.
    arg_allow_rich_text = default_allow_rich_text ;
    arg_extended_noweb_flag = default_extended_noweb_flag ;
    arg_output_doc_flag = default_output_doc_flag ;
    arg_tangle_batch = default_tangle_batch ;
    arg_untangle_batch = default_untangle_batch ;
    arg_use_noweb_flag = default_use_noweb_flag ;
    arg_use_CWEB_flag = default_use_CWEB_flag ;
    arg_use_header_flag = default_use_header_flag ;  // 6/1/00
    tangle_print_bits = verbose_bits ;
#endif

arg_page_width = default_page_width ;
arg_tab_width = default_tab_width ;
arg_present_language = arg_target_language = default_target_language ;
set_delims_from_language(arg_present_language);</t>
<t tx="edream.110203163054.1498">@ A directory in an @file node over-rides everything else.
@c

String s = v -&gt; atFileNodeName() ;
String dir = ExtractFileDir ( s ) ;
if ( dir.Length() &gt; 0 ) {
    path_specified = SetCurrentDir ( dir ) ;
	if ( ! path_specified )
		error ( String("Directory \"") + dir + "\" does not exist ");
}</t>
<t tx="edream.110203163054.1499">if ( prev(comment_bits) || prev(language_bits) )
	;  // Do nothing more.
else if (test(comment_bits)) {
	set_root_delims ( at_comment_ptr, len-(at_comment_ptr-ip) ) ;
	// @comment effectively disables Untangle.
	arg_present_language = unknown_language ;
}
else if (test(language_bits))
	set_language (ip, len, at_language_ptr, 0 /* issue_error_flag */ ) ;</t>
<t tx="edream.110203163054.1500">if (test(path_bits) &amp;&amp; !path_specified &amp;&amp; !prev(path_bits)) {
	char * p2 = at_path_ptr + 5 ; // Point past @path
	ip = skip_to_end_of_line(at_path_ptr, limit);
	String s(p2, ip - p2 );
	s = s . Trim();
	&lt;&lt; Remove leading and trailing delims if they exist &gt;&gt;
	s = s . Trim();
	if ( s . Length() &gt; 0 ) {
		path_specified = SetCurrentDir ( s . c_str() ) ;
		if ( ! path_specified )
			error ( "Invalid @path: " + s ) ;
	}	
	else error ("ignoring empty @path") ;
}</t>
<t tx="edream.110203163054.1501">if ( s . Length() &gt; 2 &amp;&amp; (
		s[1] == '"' &amp;&amp; s[s.Length()] == '"' ||
		s[1] == '&lt;' &amp;&amp; s[s.Length()] == '&gt;'
) ) {
	s . Delete ( s.Length(), 1 ) ;
	s . Delete ( 1, 1 ) ;
}</t>
<t tx="edream.110203163054.1502">if (test(page_width_bits) &amp;&amp; !prev(page_width_bits) ) {
	char * p2 = at_page_width_ptr + 10 ; // Point past @pagewidth
	val = 0 ;
	ip = skip_long (p2, limit, &amp; val );
	if ( ip == NULL ) {
		ip = skip_to_end_of_line(p2, limit);
		String line(at_page_width_ptr, ip - at_page_width_ptr);
		error ( "Ignoring " + line ) ;
	}
	else arg_page_width = val ;
}

if (test(tab_width_bits) &amp;&amp; !prev(tab_width_bits) ) {
	char * p2 = at_tab_width_ptr + 9 ; // Point past @tabwidth
	val = 0 ;
	ip = skip_long (p2, limit, &amp; val );
	if ( ip == NULL ) {
		ip = skip_to_end_of_line(p2, limit);
		String line(at_tab_width_ptr, ip - at_tab_width_ptr);
		error ( "Ignoring " + line ) ;
	}
	else arg_tab_width = val ;
}
</t>
<t tx="edream.110203163054.1503">@ This code is executed if no valid path was specified in the @file node or in an @path directive.  We try to set the current directory to the following:

1. The Tangle Default Directory specified in the Preferences panel.
2. The mOpenDirectory specified by the Open command.
@c

if ( form == NULL )
	path_specified = TRUE ;  // We are opening.  Do nothing.

if ( !path_specified &amp;&amp; form -&gt; mDefaultDirectory . Length() &gt; 0 ) {
	path_specified = SetCurrentDir ( form -&gt; mDefaultDirectory . c_str() ) ;
	if ( !path_specified )
		error(
			"Invalid Default Tangle Directory: " +
			form -&gt; mDefaultDirectory ) ;
}

if ( !path_specified &amp;&amp; form -&gt; mOpenDirectory . Length() &gt; 0 ) {
	path_specified = SetCurrentDir ( form -&gt; mOpenDirectory . c_str() ) ;
	if ( !path_specified )
		error (
			"Directory no longer valid: " + 
			form -&gt; mDefaultDirectory ) ;
}

if ( !path_specified ) {
	// Always issue this error.
	error ("No directory specified by @file, @path or Preferences.");
}
</t>
<t tx="edream.110203163054.1504">@ We use single-line comments if we have a choice.
@c

if ( single_comment_string ) {
	mStartSentinelComment = single_comment_string ;
	mEndSentinelComment = "" ;
}
else {
	mStartSentinelComment = start_comment_string ;
	mEndSentinelComment = end_comment_string ;
}</t>
<t tx="edream.110203163054.1505">void atFile::error ( String message )
{
	if ( message.Length() &gt; 0 ) {
		message += "\n" ;
    	put_cstring_to_log_window ( message.c_str() );
	}
	++ mErrors ;
}
</t>
<t tx="edream.110203163054.1506">@ ip points at the start of a line.  Skip past whitespace equivalent to n spaces.
@c

char * atFile::skipIndent ( long n, char * ip, char * limit )
{
	long ws = 0 ;
	while (ip &lt; limit &amp;&amp; ws &lt; n)
	{
		if (*ip == '\t') ws += ( arg_tab_width - ws % arg_tab_width ) ;
		else if (*ip == ' ') ++ ws ;
		else break ;
		++ ip ;
	}
	return ip ;
}</t>
<t tx="edream.110203163054.1507">@ Update the cloneIndex field of each vnode of root's subtree. The maximum clone index is stored in the cloneIndex field of root (root should not be cloned).  next points to the node after the tree.
@c

void atFile::updateCloneIndices ( vnode * root, vnode * next )
{
	if ( root -&gt; isCloned() ) {
		error ("Ignoring clone mark for " + root -&gt; headString());
		root -&gt; t() -&gt; setCloneIndex(0);
	}

	long maxIndex = root -&gt; t() -&gt; cloneIndex() ;

	for ( vnode * v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() )
		if ( v -&gt; isCloned() &amp;&amp; v -&gt; t() -&gt; cloneIndex() == 0 )
			v -&gt; t() -&gt; setCloneIndex ( ++ maxIndex ) ;
			
	root -&gt; t() -&gt; setCloneIndex(maxIndex) ;
}</t>
<t tx="edream.110203163054.1508">void atFile::writeError ( String message )
{
	if ( mErrors == 0 ) {
		es("----- Errors in: "); es(mTargetFileName.c_str() ); enl();
	}
	error ( message ) ;
	mRoot -&gt; setOrphan();
}</t>
<t tx="edream.110203163054.1509"></t>
<t tx="edream.110203163054.1510">#pragma option -w-par  // suppress warning: "Parameter `param' not used."

&lt;&lt; File commands includes &gt;&gt;
&lt;&lt; Declare the fileInfo class &gt;&gt;
&lt;&lt; Declare the EBadLeoFile class &gt;&gt;
&lt;&lt; Declare File commands private functions &gt;&gt;

@others</t>
<t tx="edream.110203163054.1511"></t>
<t tx="edream.110203163054.1512">#include &lt;vcl.h&gt;
#pragma hdrstop

#include "args.h"
#include "atFile.h"
#include "Clipbrd.hpp"
#include "Commands.h"
#include "CloneUnit.h"
#include &lt;Filectrl.hpp&gt; // For DirectoryExists.
#include "FindUnit.h"  // for find globals.
#include "LeoWindow.h"
#include "MainUnit.h"  // For alert().
#include "Prefs.h"  // Alters Prefs form.
#include "Sherlock.h"  // For Sherlock.cpp (defines SherlockForm).
#include "vnode.h"
#include "tnode.h"
#include "Utils.h"

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "Leo.h"
</t>
<t tx="edream.110203163054.1513">static String convertToNoweb ( vnode * v ) ;
static char * convertCodePartToNoweb(
	vnode *v, char *p, char *limit, String&amp; result) ;
static char * convertDocPartToNoweb( char *p, char *limit, String&amp; outerResult) ;
static char * copyPart( char *p, char *limit, String&amp; result) ;</t>
<t tx="edream.110203163054.1514">class EBadLeoFile {} ;</t>
<t tx="edream.110203163054.1515"></t>
<t tx="edream.110203163054.1516">void Commands::deleteTagList( void )
{
	while ( mTagList ) {
		tag_list * next = mTagList -&gt; next ;
		delete mTagList ;
		mTagList = next ;
	}
}</t>
<t tx="edream.110203163054.1517">vnode * Commands::getVtag ( long vref )
{
	for ( tag_list * p = mTagList ; p ; p = p -&gt; next )
		if ( p -&gt; vref == vref )
			return p -&gt; v ;

	return NULL ;
}

long Commands::getVtag ( vnode * v )
{
	for ( tag_list * p = mTagList ; p ; p = p -&gt; next )
		if ( p -&gt; v == v )
			return p -&gt; vref ;

	return NULL ;
}</t>
<t tx="edream.110203163054.1518">void Commands::newVtag ( long vtag, vnode * v )
{
    // Allocate the node.
    tag_list * p = new tag_list();
    p -&gt; v = v ;
    p -&gt; vref = vtag ;
    
    // Link the node into the list.
    p -&gt; next = mTagList ;
    mTagList = p ;
}</t>
<t tx="edream.110203163054.1519"></t>
<t tx="edream.110203163054.1520">void Commands::exportMoreText ( void )
{
	vnode * v = this -&gt; currentVnode();
	if ( v == NULL ) return ;
    TClipboard * clipboard = Clipboard();
    if ( clipboard == NULL ) return ;

	String s = v -&gt; convertTreeToString() ;
	clipboard -&gt; Open();
	clipboard -&gt; Clear();
	clipboard -&gt; SetTextBuf( s . c_str() );
	clipboard -&gt; Close();
}</t>
<t tx="edream.110203163054.1521">void Commands::flattenOutline ( TStrings * files )
{
	vnode * v = this -&gt; currentVnode() ;
	if ( v == NULL ) return ;
	long count = files -&gt; Count ;
	if ( count != 1 ) return ;

	String fileName = files -&gt; Strings [ 0 ] ;
	vnode * after = v -&gt; nodeAfterTree() ;
	String s ;
	String body ;
	String newline ("\n") ;
	long firstLevel = v -&gt; level();

	try {
		int fileHandle = FileCreate( fileName) ;
	
		#if 0 // Elegant, but uses lots of memory.
			s = v -&gt; convertTreeToString() ;
			FileWrite(fileHandle, s . c_str(), s . Length() ) ;
		#else  // Redundant, but uses much less memory.
        	while ( v &amp;&amp; v != after ) {
				s  = v -&gt; moreHead ( firstLevel ) ;
				s += newline ;
        		body = v -&gt; moreBody ();  // Insert escapes.
        		if ( body . Length() &gt; 0 ) {
                    s += body ;
        			s += newline ;
        		}
    			FileWrite(fileHandle, s . c_str(), s . Length() ) ;
        		v = v -&gt; threadNext() ;
        	}
		#endif
		FileClose(fileHandle) ;
	}
	catch(...) {
		alert("File error while flattening the outline") ;
	}
}
</t>
<t tx="edream.110203163054.1522">void Commands::flattenOutlineWithFilename ( String fileName )
{
	TStringList * list = new TStringList();
	list -&gt; Add(fileName);
	flattenOutline(list);
    delete list ;
}
</t>
<t tx="edream.110203163054.1523">void Commands::outlineToNoweb( TStrings * files )
{
	vnode * v = this -&gt; currentVnode() ;
	if ( v == NULL ) return ;
	long count = files -&gt; Count ;
	if ( count != 1 ) return ;

	String fileName = files -&gt; Strings [ 0 ] ;
	vnode * after = v -&gt; nodeAfterTree() ;

	try {
		int fileHandle = FileCreate( fileName) ;
	
    	while ( v &amp;&amp; v != after ) {
			String s = convertToNoweb(v);
			if ( s . Length() &gt; 0 ) {
				// Don't rely on s.Length() when writing!
				char * cs = s.c_str();
				long len = strlen(cs);
				if ( len &gt; 0 )
					FileWrite(fileHandle, cs, len ) ;
				if ( len &gt; 0 &amp;&amp; cs[len-1] != '\n' )
					FileWrite(fileHandle, "\n", 1 ) ;
			}
    		v = v -&gt; threadNext() ;
    	}

		FileClose(fileHandle) ;
	}
	catch(...) {
		alert("File error in Outline To noweb command") ;
	}
}
</t>
<t tx="edream.110203163054.1524">@ This code converts a vnode to noweb text as follows:

Convert @root to &lt; &lt; * &gt; &gt;
Convert @doc to @
Convert @code to &lt; &lt; name &gt; &gt; =, assuming the headline contains &lt; &lt; name &gt; &gt;
Ignore other directives
Format parts so they fit in pagewidth columns.
Output code parts as is.
@c

static String convertToNoweb ( vnode * v )
{
	String result ("");
	if ( v == NULL ) return result ;
	char * p = v -&gt; bodyCString();
	char * limit = p + v -&gt; bodyCStringLength() ;
	char * p2 = skip_ws_and_nl(p, limit);
	if ( p2 == limit )
		return result ;

	while ( p &lt; limit) {
		p = skip_ws_and_nl(p, limit);
		if ( p &gt;= limit )
			break ;
		else if ( p + 3 &lt; limit &amp;&amp; strn_eq(p, "@doc", 4))
			p = convertDocPartToNoweb(p + 4, limit, result);
		else if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@code", 5))
			p = convertCodePartToNoweb(v, p, limit, result);
		else if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@root", 5))
			p = convertCodePartToNoweb(v, p, limit, result);
		else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "&lt;&lt;", 2))
			p = convertCodePartToNoweb(v, p, limit, result);
		else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "@ ", 2))
			p = convertDocPartToNoweb(p + 2, limit, result);
		else if ( *p == '@' )
			p = skip_line(p, limit);  // Ignore all other directives.
		else // Assume we are in a doc part.
			p = convertDocPartToNoweb(p, limit, result);
	}
	
	#if 0 // this is not the problem
    	TReplaceFlags flags ;
    	flags &lt;&lt; rfReplaceAll ;
    	result = StringReplace( result, "\r", "\n", flags ) ;
	#endif
	
	return result ;
}
</t>
<t tx="edream.110203163054.1525">@ The code part should start either with @code or @root or &lt;&lt; section name &gt;&gt;=
@c

static char * convertCodePartToNoweb( vnode *v, char *p, char *limit, String&amp; result)
{
	if ( p &gt;= limit )
		return p ;
	&lt;&lt; Output the section reference &gt;&gt;
	p = copyPart(p, limit, result);
	return p ;
}
</t>
<t tx="edream.110203163054.1526">if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@code", 5)) {
	p = skip_line(p, limit);
	char * p1 = NULL, *p2 = NULL ;
	&lt;&lt; point p1 and p2 at section name in v's headline &gt;&gt;
	if ( p1 &amp;&amp; p2 ) {
		String headline(p1, p2-p1);
		result += "\n" ;
		result += headline ;
		result += "=" ;
	}
	else {
		result += "\n\n&lt;&lt; *** " ;
		result += "no section name for @code ***&gt;&gt;" ;
	}
}
else if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@root", 5)) {
	String name("*");  // Default name for empty file names.
	p += 5 ;
	p = skip_ws(p, limit);
	char * p2 = p ;
	p = skip_line(p, limit);
	&lt;&lt; Set name to the file name p2..p &gt;&gt;
	result += "\n\n&lt;&lt;" ;
	result += name ;
	result += "&gt;&gt;=" ;
}
else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "&lt;&lt;", 2)) {
	// copy the line to the output.
	char * p2 = skip_line(p, limit);
	while ( p &lt;= p2 )
		result += *p++ ;
}
</t>
<t tx="edream.110203163054.1527">if ( p2 &lt; p ) {
	char delim = ' ';
	if ( *p2 == '&lt;' ) { ++ p2 ; delim = '&gt;' ; }
	if ( *p2 == '"' ) { ++ p2 ; delim = '"' ; }
	char * p3 = p2 ;
	while ( p2 &lt; p &amp;&amp; *p2 != delim &amp;&amp; ! is_nl(*p2) )
		++ p2 ;
	if ( p3 &lt; p2 ) {
		name = String(p3, p2-p3);
		name = name.Trim();
		if ( name . Length() == 0 )
			name = "*" ;
	}
}
</t>
<t tx="edream.110203163054.1528">char * hp = v -&gt; headCString();
char * hlim = hp + v -&gt; headCStringLength();

hp = skip_ws (hp, hlim);

if ( hp + 2 &lt; hlim &amp;&amp; strn_eq(hp, "&lt;&lt;", 2)) {
	p1 = hp ;
	hp += 2 ;
	while ( hp + 2 &lt;= hlim ) {
		if ( strn_eq(hp, "&gt;&gt;", 2) ) {
			p2 = hp + 2 ;
			break ;
		}
		else ++ hp ;
	}
}
</t>
<t tx="edream.110203163054.1529">static char * convertDocPartToNoweb( char *p, char *limit, String&amp; outerResult)
{
	String result("") ;
	// Ignore anything following @space or @doc.
	if (
		p + 3 &lt; limit &amp;&amp; strn_eq(p, "@doc", 4) ||
		p + 1 &lt; limit &amp;&amp; strn_eq(p, "@ ", 2)
	)
		p = skip_line(p, limit);
	
	p = skip_ws_and_nl(p, limit);
	if ( p &gt;= limit )
		return p ;
	p = copyPart(p, limit, result);
	if ( result . Length() &gt; 0 ) {
    	// We could break long lines in result here.
    	outerResult += "@ \n" ;
    	outerResult += result ;
	}
	return p ;
}</t>
<t tx="edream.110203163054.1530">@ This code copies characters to result until the end of the present section is seen.
@c

static char * copyPart( char *p, char *limit, String&amp; result)
{
	while ( p &lt; limit) {
		// We should be at the start of a line here.
		char * p2 = p ;
		p = skip_nl(p, limit);
		p = skip_ws(p, limit);

		if ( p + 3 &lt; limit &amp;&amp; strn_eq(p, "@doc", 4))
			break ;
		else if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@code", 5))
			break ;
		else if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@root", 5))
			break ;
		else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "&lt;&lt;", 2)) {
			&lt;&lt; return p if this is a section definition &gt;&gt;
		}
		else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "@ ", 2))
			break ;
		else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "@@", 2))
			;  // Will be handled below.
		else if ( *p == '@' ) {
			p = skip_line(p, limit);  // Ignore all other directives.
			continue ;
		}

        // Copy the entire line.
        p = p2 ;  // Copy leading whitespace.
        p2 = skip_line(p, limit);
        while ( p &lt;= p2 )
            result += *p++ ;
	}

	return p ;
}
</t>
<t tx="edream.110203163054.1531">// This code leaves p and the outer p2 unchanged.
{
	char * p1 = p ;
	char * p2 = skip_line (p, limit);
	
	while ( p1 &lt; p2 )
		if ( p1 + 3 &lt;= p2 &amp;&amp; strn_eq(p1, "&gt;&gt;=", 3) )
        	return p ;
		else
			++ p1 ;
}</t>
<t tx="edream.110203163054.1532"></t>
<t tx="edream.110203163054.1533">@ Almost all the time spent in this command is spent here.
@c

vnode * Commands::convertMoreStringsToOutlineAfter
	( TStrings * strings, vnode * firstVnode )
{
    if ( ! this -&gt; stringsAreValidMoreFile ( strings ) ) return NULL ;

	&lt;&lt; Declare the vars for convertMoreStringsToOutlineAfter &gt;&gt;
	this -&gt; BeginUpdate();
		while ( index &lt; count )
		{
			s = strings -&gt; Strings [ index ] ;
			cs = s . c_str() ;
			level = this -&gt; moreHeadlineLevel ( cs, &amp;newFlag ) - firstLevel ;

			if ( level &gt;= 0 ) {
				&lt;&lt; Link a new vnode v into the outline &gt;&gt;
				&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;
				&lt;&lt; Count the number of following body lines &gt;&gt;
				&lt;&lt; Add the lines to the body text of v &gt;&gt;
				v -&gt; setDirty();  // Set the icon and the dirty bit last.
			}
			else ++ index ;
		}
		if ( theRoot ) this -&gt; setChanged ( TRUE ) ;
	this -&gt; EndUpdate();

    return theRoot ;
}</t>
<t tx="edream.110203163054.1534">vnode * theRoot = NULL ;
vnode * lastVnode = NULL ;
vnode * v = NULL ;  // The new vnode.
long index = 0 ;
long lastLevel = -1 ;
bool junkFlag = 0 ;
bool newFlag = 0 ;
long bodyLines = 0;
long firstLevel = 0 ;
long level = 0 ;
String s("");
char * cs = NULL ;

long count = strings -&gt; Count ;
if ( count &gt; 0 ) {
	s = strings -&gt; Strings [ 0 ] ;
	cs = s . c_str();
	firstLevel = this -&gt; moreHeadlineLevel ( cs, &amp;junkFlag );
}
</t>
<t tx="edream.110203163054.1535">assert(level &gt;= 0 );

if ( lastVnode == NULL )
	theRoot = v = firstVnode -&gt; insertAfter ( ) ;
else if ( level == lastLevel )
	v = lastVnode -&gt; insertAfter ( ) ;
else if ( level == lastLevel + 1 )
	v = lastVnode -&gt; insertAsNthChild ( 0 ) ;
else {
	assert ( level &lt; lastLevel ) ;

	while ( level &lt; lastLevel ) {
		-- lastLevel ;
		lastVnode = lastVnode -&gt; parent();
		assert(lastVnode);
		assert ( lastLevel &gt;= 0 ) ;
	}
	v = lastVnode -&gt; insertAfter ( ) ;
}

lastVnode = v ;
lastLevel = level ;</t>
<t tx="edream.110203163054.1536">{
	char * cString = cs ;
	
	while ( *cString == '\t' )
		++ cString ;

    if ( ( *cString == '+' || *cString == '-' ) &amp;&amp; *(cString+1) == ' ' )
       cString += 2 ;

	v -&gt; treeNode() -&gt; Text = String ( cString ) ;
}
</t>
<t tx="edream.110203163054.1537">bodyLines = 0 ;
++ index ;  // Skip the headline.

while ( index &lt; count )
{
    s = strings -&gt; Strings [ index ] ;
	cs = s . c_str();
    level = this -&gt; moreHeadlineLevel ( cs, &amp;newFlag ) - firstLevel ;
    if ( level &gt;= 0 )
        break ;
   
    // Remove first backslash of the body line.
	if ( s . Length() &gt; 0 &amp;&amp; s [ 1 ] == '\\' )
		strings -&gt; Strings [ index ] = s . Delete ( 1, 1 ) ;

    ++ bodyLines ;
    ++ index ;
}
</t>
<t tx="edream.110203163054.1538">if ( bodyLines &gt; 0 )
{
	String body ( "" ) ;

	for ( long n = index - bodyLines ; n &lt; index ; ++ n ) {
		body += strings -&gt; Strings [ n ] ;
		if ( n != index - 1 )
			body += "\n" ;
	}

	v -&gt; t() -&gt; setTnodeText ( body ) ;
}
</t>
<t tx="edream.110203163054.1539">@ On entry, files contains at most one file to convert.
@c

void Commands::importMoreText ( TStrings * files )
{
	vnode * current = this -&gt; currentVnode() ;
	if ( current == NULL ) return ;
	if ( files -&gt; Count &lt; 1 ) return ;
	
	String fileName = files -&gt; Strings [ 0 ] ;
	TStrings * strings = new TStringList () ;
    &lt;&lt; Read the file into strings &gt;&gt;
    // Convert the string to an outline and insert it after the current node.
	vnode * newVnode = this -&gt; convertMoreStringsToOutlineAfter ( strings, current ) ;
	delete strings ;
	strings = NULL ;

    if ( newVnode ) {
		this -&gt; endEditing () ;
		this -&gt; validateOutline () ;
		this -&gt; editVnode ( newVnode ) ;
		this -&gt; setChanged ( TRUE ) ;
    }
    else {
		String s = fileName + " is not a valid MORE file." ;  
		alert ( s . c_str() ) ;
    }
}</t>
<t tx="edream.110203163054.1540">@ This code is _very_ fast.
@c

try {
	strings -&gt; LoadFromFile ( fileName ) ;
}
catch ( ... )
{
	String s ( "Not enough memory to convert: ") ;
	s += fileName ;
	alert ( s . c_str() );
	return ;
}</t>
<t tx="edream.110203163054.1541">@ return the headline level of s, or -1 if the string is not a MORE headline.
@c

long Commands::moreHeadlineLevel ( char * s, bool * plusFlag )
{
    long level = 0 ;

    while ( *s &amp;&amp; *s == '\t') {
        ++level ;
        ++s ;
    }

    if ( plusFlag ) *plusFlag = ( *s == '+' ) ;

    if ( ( *s == '+' || *s == '-' ) &amp;&amp; * (s+1) == ' ' )
        return level ;
    else
        return -1 ;
}</t>
<t tx="edream.110203163054.1542">bool Commands::stringsAreValidMoreFile ( TStrings * strings )
{
    long count = strings -&gt; Count ;
	if ( count &lt; 1 ) return FALSE ;

	bool plusFlag = 0 ;
	char *cs = strings -&gt; Strings [0] . c_str() ;
    long level1 = this -&gt; moreHeadlineLevel ( cs, &amp;plusFlag ) ;
    if ( level1 == -1 ) return FALSE ;
    long lastLevel = level1 ;

    // Check the level of all headlines.
    for ( long i = 1 ; i &lt; count ; ++ i )
    {
		bool newFlag = 0 ;
		cs =  strings -&gt; Strings [ i ] . c_str() ;
		long level = this -&gt; moreHeadlineLevel ( cs, &amp;newFlag ) ;
		
		if ( level &gt; 0 ) {
		    if ( level &lt; level1 || level &gt; lastLevel + 1 )
		        return FALSE ;  // improper level.
		    else if ( level &gt; lastLevel &amp;&amp; plusFlag == FALSE )
		        return FALSE ;  // parent of this node has no children.
		    else if ( level == lastLevel &amp;&amp; plusFlag == TRUE )
		        return FALSE ;  // last node has missing child.
		    else {
		        lastLevel = level ;
		        plusFlag = newFlag ;
		    }
		}
    }

    return TRUE ;
}</t>
<t tx="edream.110203163054.1543"></t>
<t tx="edream.110203163054.1544"></t>
<t tx="edream.110203163054.1545">@ This class buffers all information from an outline while a file is being read.  The setMaxTnodeIndex method creates the mTnodes array used to associate tnodes with tnode indices.  The createVnode method creates a vnode and also creates its tnode if it has not already been created.  The finishOutline completes the construction of the outline.

Vnode tags are not part of vnodes:  they are created by this class and destroyed when this class is destroyed.
@c

class fileInfo
{
private:
	long mTnodesSeen ;
	long mVnodesSeen ;
	long mMaxTnodeIndex ;
	long mNumberOfTnodes ;
	tnode ** mTnodes ;
	TLeoForm * mLeoForm ;
	Commands * mCommands ;
	vnode * mRootVnode ;

public:
	// Data.
	long mFileFormatNumber ;
	long mCloneWindowsSeen ;
	long mNumberOfCloneWindows ;
	vnode * mCurrentVnode ;
	double mRatio ;

	// Birth &amp; death.
	fileInfo ( TLeoForm * leoForm, Commands * commands ) ;
	~fileInfo ( void ) ;

	// Methods.
	vnode * createVnode ( vnode * parent, vnode * next,
		String headline, short attrib, long tref, long tag,
		String xfile, long xindex ) ;
	void finishOutline ( void ) ;
	vnode * finishPaste ( void ) ;
	tnode * getT ( long index ) ;
	void newCloneWindow ( long vref, long top, long left, long height, long width ) ;
	tnode * newTnode ( long index ) ;
	void setMaxTnodeIndex ( long n ) ;
	void setNumberOfTnodes ( long n ) ;
};
</t>
<t tx="edream.110203163054.1546">fileInfo::fileInfo ( TLeoForm * leoForm, Commands * commands )
{
	mLeoForm = leoForm ;
	mCommands = commands ;
	mFileFormatNumber = 0 ;
	mCloneWindowsSeen = mTnodesSeen = 0 ;
	mMaxTnodeIndex = 0 ;
	mRatio = 0.5 ;
	mNumberOfCloneWindows = mNumberOfTnodes = 0 ;
	mTnodes = NULL ;
	mRootVnode = NULL ;
	mCurrentVnode = NULL ;
}

fileInfo::~fileInfo ( void )
{
	delete [] mTnodes ;
	mCommands -&gt; deleteTagList();
}
</t>
<t tx="edream.110203163054.1547">vnode * fileInfo::createVnode ( 
	vnode * parent, vnode * back, String headline, 
	short attrib, long tref, long vtag,
	String xfile, long xindex )
{
	vnode * v = NULL ;
	tnode * t = NULL ;

	// No tnode is specified in the file for vnodes with empty body text.
	// 8/29/99: shared tnodes are placed in the file even if empty. 
	if ( tref == 0 )
		t = new tnode();
	else {
        // Bug fix: 8/26/99
		t = this -&gt; getT ( tref ) ;
		if ( t == NULL )
			t = this -&gt; newTnode ( tref ) ;
	}

	if ( back ) // create v after back.
		v = back -&gt; insertAfter ( t ) ;
	else if ( parent ) // create v as the parent's first child.
		v = parent -&gt; insertAsNthChild ( 0, t ) ;
	else {
		&lt;&lt; Create a root vnode &gt;&gt;
	}
	v -&gt; initHeadString ( headline) ;
	v -&gt; initStatus ( attrib ) ;

    #ifdef V_XCLONES
	v -&gt; setXCloneName ( xfile ) ;
	v -&gt; setXCloneIndex ( xindex ) ;
    #endif

	if ( vtag ) mCommands -&gt; newVtag ( vtag, v ) ;
	return v ;
}
</t>
<t tx="edream.110203163054.1548">v = mCommands -&gt; rootVnode();
assert(v);
v -&gt; setT(t) ;  // deletes previous root tnode.
mRootVnode = v ;
</t>
<t tx="edream.110203163054.1549">void fileInfo::finishOutline ( void )
{
	&lt;&lt; Set attributes and icons for all nodes &gt;&gt;
	&lt;&lt; Create join lists of all vnodes &gt;&gt;
	&lt;&lt; Set the current node &gt;&gt;
}</t>
<t tx="edream.110203163054.1550">this -&gt; mCommands -&gt; BeginUpdate();

for ( vnode * v = mRootVnode ; v ; v = v -&gt; threadNext() )
{
	if ( v -&gt; isExpandedBitSet() )
    	v -&gt; treeNode() -&gt; Expand ( FALSE ) ;
    else
    	v -&gt; treeNode() -&gt; Collapse ( FALSE ) ;
    
    v -&gt; clearDirty () ;  // Calls setIcon();
}

this -&gt; mCommands -&gt; EndUpdate();
</t>
<t tx="edream.110203163054.1551">@ We can create all join lists in a first pass through all vnodes using the mJoinHead field in each tnode.  The second pass circularizes each list.
@c

for ( vnode * v = mRootVnode ; v ; v = v -&gt; threadNext() )
{
	tnode * t = v -&gt; t();
	// Put v at the head of t's list of joined vnodes.
	v -&gt; setJoinList ( t -&gt; joinHead() ) ;
	t -&gt; setJoinHead ( v ) ;
}

// Circularize each non-empty list.
for ( vnode * v = mRootVnode ; v ; v = v -&gt; threadNext() )
{
	tnode * t = v -&gt; t();
	vnode * head = t -&gt; joinHead() ;
	if ( head == NULL ) continue ;

	// Make sure we don't handle this list again.
	t -&gt; setJoinHead ( NULL ) ; 

    // Clear the join list if it has only one member.
    if ( head == v &amp;&amp; v -&gt; joinList() == NULL ) {
        v -&gt; setJoinList(NULL);
        continue;
    }

	// Point last at the last vnode of the list.
	vnode * last = head ;
	while ( last &amp;&amp; last -&gt; joinList() )
		last = last -&gt; joinList() ;
	assert(last);

	// Link last to head.
	last -&gt; setJoinList(head);
}
</t>
<t tx="edream.110203163054.1552">@ Initializing the current vnode is tricky.  We must not "update" the old current node, namely the new root.

Leo2: we do not set the current node here, because it might be a dummy node. We must wait until we have a complete node so that the event handler will set the body text properly.
@c

if ( mCurrentVnode == NULL )
	mCurrentVnode = mRootVnode ;
	
// Leo2: Just indicate what the current node will be.
mCommands -&gt; setCurrentVnode ( mCurrentVnode ) ;
	
#if 0 // Leo2: this must be done later.
    mCommands -&gt; setCurrentVnode ( NULL ) ;
    mCommands -&gt; selectVnode ( mCurrentVnode ) ;
#endif
</t>
<t tx="edream.110203163054.1553">@ This method finishes pasting the outline from the clipboard.
@c

vnode * fileInfo::finishPaste ( void )
{
	mRootVnode = mCommands -&gt; rootVnode();
	if ( mCurrentVnode == NULL ) mCurrentVnode = mRootVnode ;
	vnode * after = mCurrentVnode -&gt; nodeAfterTree();
	&lt;&lt; Check number of created tnodes &gt;&gt;
	&lt;&lt; Set attributes and icons for all pasted nodes &gt;&gt;
	// Warning:  this will only join pasted clones.
	#if 1 // Don't allow clones in pasted outlines.
	&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;
	&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;
	#endif
	mCommands -&gt; compactFileIndices ( ) ;
	mCommands -&gt; selectVnode ( mCurrentVnode ) ;
	return mCurrentVnode ;
}</t>
<t tx="edream.110203163054.1554">if ( mTnodesSeen != mNumberOfTnodes )
{
	String s("Bad tnode count.  Seen: ") ;
	s += mTnodesSeen ;
	s += ", Expected: " ;
	s += mNumberOfTnodes ;
	alert( s . c_str() );
}
</t>
<t tx="edream.110203163054.1555">for ( vnode * v = mCurrentVnode ; v &amp;&amp; v != after ; v = v -&gt; threadNext() )
{
	if ( v -&gt; isExpandedBitSet() )
    	v -&gt; treeNode() -&gt; Expand ( FALSE ) ;
    else
    	v -&gt; treeNode() -&gt; Collapse ( FALSE ) ;

	#if 0 // done later.
		v -&gt; clearDirty () ;  // Calls setIcon();
	#endif
}
</t>
<t tx="edream.110203163054.1556">@ We can create all join lists in a first pass through all vnodes using the mJoinHead field in each tnode.  The second pass circularizes each list.
@c

for ( vnode * v = mCurrentVnode ; v &amp;&amp; v != after ; v = v -&gt; threadNext() )
{
	tnode * t = v -&gt; t();
	// Put v at the head of t's list of joined vnodes.
	v -&gt; setJoinList ( t -&gt; joinHead() ) ;
	t -&gt; setJoinHead ( v ) ;
}

// Circularize each non-empty list.
for ( vnode * v = mCurrentVnode ; v &amp;&amp; v != after ; v = v -&gt; threadNext() )
{
	tnode * t = v -&gt; t();
	vnode * head = t -&gt; joinHead() ;
	if ( head == NULL ) continue ;

	// Make sure we don't handle this list again.
	t -&gt; setJoinHead ( NULL ) ; 

    // Clear the join list if it has only one member.
    if ( head == v &amp;&amp; v -&gt; joinList() == NULL ) {
        v -&gt; setJoinList(NULL);
        continue;
    }

	// Point last at the last vnode of the list.
	vnode * last = head ;
	while ( last &amp;&amp; last -&gt; joinList() )
		last = last -&gt; joinList() ;
	assert(last);

	// Link last to head.
	last -&gt; setJoinList(head);
}
</t>
<t tx="edream.110203163054.1557">@ This must be done after the join lists have been created.  The saved clone bit is unreliable for pasted nodes.
@c

for ( vnode * v = mCurrentVnode ; v &amp;&amp; v != after ; v = v -&gt; threadNext() ) {
	v -&gt; initClonedBit ( v -&gt; shouldBeClone() ) ;
	v -&gt; clearDirty () ;  // Calls setIcon();
}
</t>
<t tx="edream.110203163054.1558">@ The entry for tnode i is stored at mTnodes [ i - 1 ].  An index of 0 represents NULL.
@c

tnode * fileInfo::getT ( long index )
{
	return ( index &lt; 1 || index &gt; mMaxTnodeIndex ) ?
		NULL : mTnodes [ index - 1 ] ;
}</t>
<t tx="edream.110203163054.1559">void fileInfo::newCloneWindow (
	long vref, long top, long left, long height, long width )
{
#if USE_CLONE_WINDOW
	if ( ++ mCloneWindowsSeen &gt; mNumberOfCloneWindows ) {
		String s("Unexpected number of clone windows. ") ;
		alert ( s . c_str() ) ;
	}

	vnode * v = mCommands -&gt; getVtag ( vref ) ;
	if ( v ) {
		// Create a clone window.
		assert (mLeoForm ) ;
		TCloneForm * form = new TCloneForm ( mLeoForm, v ) ;
		form -&gt; SetBounds(left, top, width, height) ;
		form -&gt; Show();
		form -&gt; SendToBack();
	}
	else {
		String s("Missing clone tag: ");
		s += vref ;
		alert ( s . c_str() ) ;
	}
#endif
}
</t>
<t tx="edream.110203163054.1560">tnode * fileInfo::newTnode ( long index )
{
	if ( index &lt;= 0 || index &gt; mMaxTnodeIndex ||
		mTnodes [ index - 1 ] != NULL
	) {
		String s("bad tnode index: ");
		s += index ;
		s += ".  Using empty text." ;
		// alert ( s . c_str() ) ;
		es(s.c_str()); enl();
		return new tnode();
	}
	else {
		++mTnodesSeen ;
		tnode * t = new tnode () ;
		mTnodes [ index - 1 ] = t ;
		t -&gt; setFileIndex ( index ) ;
		return t ;
	}
}
</t>
<t tx="edream.110203163054.1561">void fileInfo::setMaxTnodeIndex ( long n )
{
	mMaxTnodeIndex = n ;
	mCommands -&gt; mMaxTnodeIndex = n ;

	// Create the array of pointers to tnodes.
	mTnodes = (tnode **) new char [ sizeof (tnode *) * (n+1) ] ;
	
	for ( long i = 0 ; i &lt;= n ; ++ i )
		mTnodes [i] = NULL ;
}</t>
<t tx="edream.110203163054.1562">void fileInfo::setNumberOfTnodes ( long n )
{
	mNumberOfTnodes = n ;
}</t>
<t tx="edream.110203163054.1563"></t>
<t tx="edream.110203163054.1564">bool Commands::getBool ( void )
{
	skipWs();
	char c = *mLinePtr++ ;

	if ( c == '0' )
		return FALSE ;
	else if ( c == '1' )
		return TRUE ;
	else
		throw EBadLeoFile() ;
}

double Commands::getDouble ( void )
{
	skipWs();

	char *end = NULL;
	double val = strtod( mLinePtr, &amp;end );
	if ( end == NULL || end == mLinePtr || end &gt; mLineLimit )
		throw EBadLeoFile();
	mLinePtr = end ;
	return val ;
}

void Commands::getDoubleQuote ( void )
{
	getTag( "\"" );
}

long Commands::getIndex ( void )
{
	long val = getLong();
	if ( val &lt; 0 ) throw EBadLeoFile() ;
	return val ;
}

long Commands::getLong ( void )
{
	skipWs();

	bool neg = *mLinePtr == '-';
	if ( neg ) ++mLinePtr ;

	// Count the number of numerals.
	long len = 0 ;
	while ( mLinePtr + len &lt; mLineLimit &amp;&amp; isdigit( mLinePtr[len] ) )
		++len ;
	if ( len &lt; 1 ) throw EBadLeoFile() ;

	// Compute the value.
	long val = 0 ;
	for ( long i = 0 ; i &lt; len ; ++i ) {
		val *= 10 ;
		val += ( mLinePtr[i] - '0' ) ;
	}

	mLinePtr += len ;
	return neg ? - val : val ;
}

void Commands::getTag ( char * tag )
{
	if ( ! matchTag ( tag ) )
		throw EBadLeoFile() ;
}

bool Commands::matchTag ( char * tag )
{
	long len = strlen ( tag ) ;

	skipWsAndNl();
	bool result =
		( mLinePtr + len &lt;= mLineLimit &amp;&amp;
		strncmp( mLinePtr, tag, len ) == 0 ) ;
	if ( result )
		mLinePtr += len ;

	return result ;
}

bool Commands::matchChar ( char c )
{
	skipWs();
	if (*mLinePtr == c) {
		++mLinePtr ;
		return TRUE ;
	}
	else {
		return FALSE ;
	}
}
</t>
<t tx="edream.110203163054.1565">void Commands::getClipboardHeader ( fileInfo * info )
{
	// Set defaults.
	bool maxIndexSeen = FALSE ;
	bool numberSeen = FALSE ;
	info -&gt; mFileFormatNumber = 1 ;
	info -&gt; mNumberOfCloneWindows = 0 ;

	getTag("&lt;leo_header");
	
	// New in version 1.7: fields may appear in any order.
	for (;;) {
		if ( matchTag("file_format=\"") ) {
			info -&gt; mFileFormatNumber = getLong();
			getDoubleQuote();
		}
		else if ( matchTag("tnodes=\"") ) {
			numberSeen = TRUE ;
			info -&gt; setNumberOfTnodes ( getLong() ) ;
			getDoubleQuote();
		}
		else if ( matchTag("max_tnode_index=\"") ) {
			maxIndexSeen = TRUE ;
			info -&gt; setMaxTnodeIndex ( getLong() ) ;
			getDoubleQuote();
		}
		else {
			getTag("/&gt;");
			break ;
		}
	}

	if ( ! numberSeen )
		info -&gt; setNumberOfTnodes ( 0 ) ;
	if ( ! maxIndexSeen )
		info -&gt; setMaxTnodeIndex ( 0 ) ;
}</t>
<t tx="edream.110203163054.1566">void Commands::getCloneWindows ( fileInfo * info )
{
	// The clone_windows tag is optional.
	if ( ! matchTag("&lt;clone_windows&gt;") ) return ;

	long vtag, top, left, height, width ;

	while ( matchTag("&lt;clone_window vtag=\"V") ) {
		vtag = getLong(); getDoubleQuote(); getTag("&gt;");
		getTag("&lt;global_window_position");
			getPosition ( &amp;top, &amp;left, &amp;height, &amp;width ) ;
		getTag("/&gt;");
		getTag("&lt;/clone_window&gt;");
		info -&gt; newCloneWindow ( vtag, top, left, height, width );
	}
	getTag("&lt;/clone_windows&gt;");
}
</t>
<t tx="edream.110203163054.1567">String Commands::getEscapedString ( void )
{
	if ( mTextBuf == NULL ) {
		&lt;&lt; allocate mTextBuf &gt;&gt;
	}
	mTextPtr = mTextBuf ;

	// Fill mTextBuf up to the next &lt; character.
	for ( ;; ) {
		if ( mTextPtr + 1 &gt;= mTextLimit ) {
			&lt;&lt; increase the size of mTextBuf &gt;&gt;
		}
		if ( mLinePtr &gt;= mLineLimit )
			if ( ! this -&gt; readLine() )
				break ;  // 11/15/00
		if ( mLinePtr &gt;= mLineLimit || *mLinePtr == '&lt;' )
			break ;
		*mTextPtr++ = *mLinePtr++ ;
	}

	assert(mTextPtr &lt; mTextLimit );
	*mTextPtr = '\0' ;

	return this -&gt; xmlUnescape ( mTextBuf ) ;
}</t>
<t tx="edream.110203163054.1568">mTextBufSize = 1000 ;
mTextBuf = new char [ mTextBufSize ] ;
mTextPtr = mTextBuf ;
mTextLimit = mTextBuf + mTextBufSize ;</t>
<t tx="edream.110203163054.1569">{
	long offset = mTextPtr - mTextBuf ;
	char * oldBuf = mTextBuf ;

	// Allocate and fill the new buffer.
	long size = mTextBufSize + 1000 ;
	mTextBuf = (char *) new char [ size ] ;
	assert(mTextBuf);
	memset(mTextBuf, 0 , size );

	if ( oldBuf )
		memcpy( mTextBuf, oldBuf, mTextBufSize ) ;

	// Set the new buffer values.
	mTextBufSize += 1000 ;
	mTextLimit = mTextBuf + mTextBufSize ;
	mTextPtr = mTextBuf + offset ;

	if ( oldBuf ) delete [] oldBuf ;
}</t>
<t tx="edream.110203163054.1570">#define match_flag(a, b)\
	if ( matchTag(b) ) { getTag("=\""); a=getBool(); getDoubleQuote(); }

void Commands::getFindPanelSettings ( void )
{
	&lt;&lt; Set defaults of all flags &gt;&gt;
	getTag("&lt;find_panel_settings");
	for (;;) {
		     match_flag ( batch_flag, "batch" )
		else match_flag ( wrap_flag, "wrap" )
		else match_flag ( whole_word_flag, "whole_word" )
		else match_flag ( ignore_case_flag, "ignore_case" )
		else match_flag ( pattern_match_flag, "pattern_match" )
		else match_flag ( search_headline_flag, "search_headline" )
		else match_flag ( search_body_flag, "search_body" )
		else match_flag ( suboutline_only_flag, "suboutline_only" )
		else match_flag ( mark_changes_flag, "mark_changes" )
		else match_flag ( mark_finds_flag, "mark_finds" )
		else match_flag ( reverse_flag, "reverse" )
		else break;
	}
	getTag("&gt;");

	if ( matchTag("&lt;find_string&gt;") ) {
		find_text = getEscapedString();
		getTag("&lt;/find_string&gt;");
	}
	else {
		getTag("&lt;find_string/&gt;");
		find_text = "" ;
	}

	if ( matchTag("&lt;change_string&gt;") ) {
		change_text = getEscapedString();
		getTag("&lt;/change_string&gt;");
	}
	else {
		getTag("&lt;change_string/&gt;");
		change_text = "" ;	
	}
	getTag("&lt;/find_panel_settings&gt;");
	
	// Update the settings immediately.
	if ( FindForm ) FindForm -&gt; set_check_boxes();
}

#undef match_flag
</t>
<t tx="edream.110203163054.1571">batch_flag = FALSE ;
wrap_flag = FALSE ;
whole_word_flag = FALSE ;
ignore_case_flag = FALSE ;
pattern_match_flag = FALSE ;
search_headline_flag = FALSE ;
search_body_flag = FALSE ;
suboutline_only_flag = FALSE ;
mark_changes_flag = FALSE ;
mark_finds_flag = FALSE ;
reverse_flag = FALSE ;
</t>
<t tx="edream.110203163054.1572">void Commands::getGlobals ( fileInfo * info )
{
	long top, left, height, width ;

	getTag("&lt;globals") ;
		getTag("body_outline_ratio=\"");
			info -&gt; mRatio = getDouble();
		getDoubleQuote();
	getTag("&gt;");

	getTag("&lt;global_window_position");
		getPosition( &amp;top, &amp;left, &amp;height, &amp;width ) ;
		
	&lt;&lt; set the window position &gt;&gt;

	getTag("/&gt;");

	getTag("&lt;global_log_window_position");
		getPosition( &amp;top, &amp;left, &amp;height, &amp;width ) ;
		
	&lt;&lt; set the log window position &gt;&gt;

	getTag("/&gt;");

	getTag("&lt;/globals&gt;") ;
}
</t>
<t tx="edream.110203163054.1573">assert ( mLeoForm ) ;
mLeoForm -&gt; SetBounds(left, top, width, height) ;</t>
<t tx="edream.110203163054.1574">if ( SherlockForm )
	SherlockForm -&gt; SetBounds(left, top, width, height) ;</t>
<t tx="edream.110203163054.1575">double Commands::getLeoFile ( TLeoForm * leoForm )
{
	fileInfo * info = new fileInfo( leoForm, this );
	try {
		readLine();
		getTag(prolog_string);
		getTag("&lt;leo_file&gt;");
		getLeoHeader ( info );
		getGlobals ( info );
		getPrefs ( info );
		getFindPanelSettings ();
		getVnodes ( info );
		getTnodes ( info );
		getCloneWindows ( info );
		getTag ("&lt;/leo_file&gt;");
		info -&gt; finishOutline();
	}
	catch ( const EBadLeoFile&amp; err ) {
		String s = *mFileName + String(" is not a valid Leo file");
		alert( s . c_str() );
	}
	catch ( ... ) {
		String s = String("error reading ") + *mFileName ;
		alert( s . c_str() );
	}
	this -&gt; deleteTagList();
	double ratio = info -&gt; mRatio ;
	delete info  ;
	
	// Leo2: read all @file nodes and reset dummy &amp; orphan bits.
	atFile * at = new atFile( this );
	at -&gt; readAll ( this -&gt; rootVnode() ) ;
	delete at ;
	
	// Leo2: set the current node only after all nodes have been read.
	if ( mCurrentVnode )
		this -&gt; selectVnode ( mCurrentVnode ) ;

	return ratio ;
}
</t>
<t tx="edream.110203163054.1576">void Commands::getLeoHeader ( fileInfo * info )
{
	// Set defaults.
	bool maxIndexSeen = FALSE ;
	bool numberSeen = FALSE ;
	info -&gt; mFileFormatNumber = 1 ;
	info -&gt; mNumberOfCloneWindows = 0 ;

	getTag("&lt;leo_header");
	
	// New in version 1.7: attributes may appear in any order.
	for (;;) {
		if ( matchTag("file_format=\"") ) {
			info -&gt; mFileFormatNumber = getLong();
			getDoubleQuote();
		}
		else if ( matchTag("tnodes=\"") ) {
			numberSeen = TRUE ;
			info -&gt; setNumberOfTnodes ( getLong() ) ;
			getDoubleQuote();
		}
		else if ( matchTag("max_tnode_index=\"") ) {
			maxIndexSeen = TRUE ;
			info -&gt; setMaxTnodeIndex ( getLong() ) ;
			getDoubleQuote();
		}
		else if ( matchTag("clone_windows=\"") ) {
			info -&gt; mNumberOfCloneWindows = getLong();
			getDoubleQuote();
		}
		else {
			getTag("/&gt;");
			break ;
		}
	}

	if ( ! numberSeen )
		info -&gt; setNumberOfTnodes ( 0 ) ;
	if ( ! maxIndexSeen )
		info -&gt; setMaxTnodeIndex ( 0 ) ;
}
</t>
<t tx="edream.110203163054.1577">@ This method reads a Leo outline from string s.
@c

vnode * Commands::getLeoOutline ( String * s )
{
	mUsingClipboard = TRUE ;
    vnode * v = NULL ;  // The new outline.
	mMemoryStream = new TMemoryStream();
	mMemoryStream -&gt; Write ( s -&gt; c_str(), s -&gt; Length() ) ;
	mMemoryStream -&gt; Position = 0 ;

	// Allocate the file buffer.
	mFileBufSize = 1024 * 16 ;
	mFileBuf = new char [ mFileBufSize ] ;

	fileInfo * info = new fileInfo( mLeoForm, this );
	try {
		readLine();
		getTag(prolog_string);
		getTag("&lt;leo_file&gt;");
		getClipboardHeader ( info ) ;
		getVnodes ( info );
		getTnodes ( info );
		getTag ("&lt;/leo_file&gt;");
		v = info -&gt; finishPaste();
	}
	catch ( const EBadLeoFile&amp; err ) {
		String s ("The clipboard is not a valid Leo outline");
		alert( s . c_str() );
	}
	catch ( ... ) {
		String s ("Error pasting Leo outline ");
		alert( s . c_str() );
	}

	// Clean up.
	delete info  ;
	delete [] mFileBuf ;
	delete mMemoryStream ;  // 10/27/99
	mMemoryStream = NULL ;  // 10/27/99
	mFileBuf = NULL ;
	mFileBufSize = 0 ;
	mUsingClipboard = FALSE ;

	return v ;
}
</t>
<t tx="edream.110203163054.1578">void Commands::getPosition ( long *top, long *left, long *height, long *width )
{
	*top = *left = *height = *width = 0 ;
	// New in version 1.7: attributes may appear in any order.
	for(;;) {
		if ( matchTag("top=\"") ) {
			*top = getLong(); getDoubleQuote();
		}
		else if ( matchTag("left=\"") ) {
			*left = getLong(); getDoubleQuote();
		}
		else if ( matchTag("height=\"") ) {
			*height = getLong(); getDoubleQuote();
		}
		else if ( matchTag("width=\"") ) {
			*width = getLong(); getDoubleQuote();
		}
		else break ;
	}
}
</t>
<t tx="edream.110203163054.1579">void Commands::getPrefs ( fileInfo * info )
{
	TLeoForm * form = this -&gt; mLeoForm ;
	PERM_ASSERT(form);

	getTag("&lt;preferences");
	for (;;) {
		if ( matchTag("allow_rich_text=\"") ) {
			form -&gt; mAllowRichTextFlag = getBool();
			getDoubleQuote();
		}
		else if ( matchTag("tab_width=\"") ) {
			form -&gt; mTabWidth = getLong();
			getDoubleQuote();
		}
		else if ( matchTag("page_width=\"") ) {
			form -&gt; mPageWidth = getLong();
			getDoubleQuote();
		}
		else if ( matchTag("tangle_bat=\"") ) {
			form -&gt; mTangleBatchFlag = getBool();
			getDoubleQuote();
		}
		else if ( matchTag("untangle_bat=\"") ) {
			form -&gt; mUntangleBatchFlag = getBool();
			getDoubleQuote();
		}
		// New in version 0.10
		else if ( matchTag("output_doc_chunks=\"") ) {
			form-&gt; mOutputDocFlag = getBool();
			getDoubleQuote();
		}
		else if ( matchTag("noweb_flag=\"") ) {
			#if 1 // New in version 0.19
				// Ignore this flag.
				getBool();
				getDoubleQuote();
			#else
    			form -&gt; mUseNowebFlag = getBool();
    			form -&gt; mUseCwebFlag = ! form -&gt; mUseNowebFlag ;
				getDoubleQuote();
			#endif
		}
		else if ( matchTag("extended_noweb_flag=\"" ) ) {
			#if 1 // New in version 0.19
				// Ignore this flag.
				getBool();
    			getDoubleQuote();
			#else
    			form -&gt; mExtendedNowebFlag = getBool();
    			getDoubleQuote();
			#endif
		}
		else if ( matchTag ("defaultTargetLanguage=\"" ) ) {
			// New in version 0.15
			&lt;&lt; check for syntax coloring prefs &gt;&gt;
		}
		else if ( matchTag ("use_header_flag=\"" ) ) {
			form -&gt; mUseHeaderFlag = getBool();
			getDoubleQuote();
		}
		else break;
	}

	if ( ! matchTag("/&gt;") )
	{
    	getTag("&gt;");
    
    	for (;;) {
    		if ( matchTag ("&lt;defaultDirectory&gt;" ) ) {
    			// New in version 0.16.
    			&lt;&lt; Set the default directory preference &gt;&gt;
    			getTag("&lt;/defaultDirectory&gt;");
    		}
    		else if ( matchTag("&lt;TSyntaxMemo_options&gt;") ) {
    			&lt;&lt; Set the TSyntaxMemo options &gt;&gt;
    		}
    		else break ;
    	}
    
    	getTag("&lt;/preferences&gt;");
	}
}
</t>
<t tx="edream.110203163054.1580">// Must match longer tags before short prefixes.
if ( matchTag("CWEB") ) {
	form -&gt; mTargetLanguage = cweb_language ;
	getDoubleQuote();
}
else if ( matchTag("C") ) {
	form -&gt; mTargetLanguage = c_language ;
	getDoubleQuote();
}
else if ( matchTag("HTML") ) {
	form -&gt; mTargetLanguage = html_language ;
	getDoubleQuote();
}
else if ( matchTag("Java") ) {
	form -&gt; mTargetLanguage = java_language ;
	getDoubleQuote();
}
else if ( matchTag("Pascal") ) {
	form -&gt; mTargetLanguage = pascal_language ;
	getDoubleQuote();
}
else if ( matchTag("PerlPod") ) {
	form -&gt; mTargetLanguage = perlpod_language ;
	getDoubleQuote();
}
else if ( matchTag("Perl") ) {
	form -&gt; mTargetLanguage = perl_language ;
	getDoubleQuote();
}
else if ( matchTag("Plain") ) {
	form -&gt; mTargetLanguage = plain_text_language ;
	getDoubleQuote();
}
else if ( matchTag("Python") ) {
	form -&gt; mTargetLanguage = python_language ;
	getDoubleQuote();
}

mSyntaxMemo -&gt; Parser1 = TSMParser ( form -&gt; mTargetLanguage ) ;
</t>
<t tx="edream.110203163054.1581">mLeoForm -&gt; mDefaultDirectory = getEscapedString();
SetCurrentDir ( mLeoForm -&gt; mDefaultDirectory ) ;
</t>
<t tx="edream.110203163054.1582">String s = getEscapedString();
getTag("&lt;/TSyntaxMemo_options&gt;");

// Update the syntax settigns immediately.
assert(mSyntaxMemoParser1);
#if 0 // at present, this causes problems!
	mSyntaxMemoParser1 -&gt; StylesFromString( s );
	mSyntaxMemoParser1 -&gt; UpdateEditors();
#endif
</t>
<t tx="edream.110203163054.1583">void Commands::getSize ( long *height, long *width )
{
	*height = *width = 0 ;
	// New in version 1.7: attributes may appear in any order.
	for (;;) {
		if ( matchTag("height=\"") ) {
			*height = getLong(); getDoubleQuote();
		}
		else if ( matchTag("width=\"") ) {
			*width = getLong(); getDoubleQuote();
		}
		else break ;
	}
}
</t>
<t tx="edream.110203163054.1584">void Commands::getTnodes ( fileInfo * info )
{
	if ( matchTag("&lt;tnodes&gt;") ) {
		while ( matchTag("&lt;t") )
			getTnode ( info );
		getTag ("&lt;/tnodes&gt;");
	}
}</t>
<t tx="edream.110203163054.1585">void Commands::getTnode ( fileInfo * info )
{
	// we have already matched &lt;t.
	bool rtf = FALSE ;
	long index = -1 ;
	// New in version 1.7: attributes may appear in any order.
	for (;;) {
		if ( matchTag("tx=\"T") ) {
			index = getIndex();
			getDoubleQuote();
		}
		else if ( matchTag("rtf=\"1\"") )
			rtf = TRUE ;
		else if ( matchTag("rtf=\"0\"") )
			rtf = FALSE ;
		else break ;
	}
	getTag("&gt;");

	tnode * t = info -&gt; getT ( index ) ;

	if ( t == NULL ) {
		// No vnode refers to this tnode.
		String s( "No tnode with index: " ) ;
		s += index ;
		s += ".  The text will be discarded" ;
		// alert ( s . c_str() );
		es(s.c_str()); enl();
		getEscapedString();
	}
	else {
		String text = getEscapedString() ;
		if ( rtf )
			t -&gt; setTnodeRTF ( text ) ;
		else
			t -&gt; setTnodeText ( text ) ;
	}

	getTag ("&lt;/t&gt;");
}
</t>
<t tx="edream.110203163054.1586">void Commands::getVnodes ( fileInfo * info )
{
	vnode * parent = NULL, * back = NULL ;

	// We paste the first pasted vnode after the current vnode.
	if ( mUsingClipboard ) {
		back = this -&gt; currentVnode() ;
		parent = back -&gt; parent();
	}

	getTag("&lt;vnodes&gt;");
	while ( matchTag("&lt;v") )
		back = getVnode ( info, parent, back );

	getTag ("&lt;/vnodes&gt;");
}
</t>
<t tx="edream.110203163054.1587">vnode * Commands::getVnode ( fileInfo * info, vnode * parent, vnode * back )
{
	vnode * v = NULL ;  // The newly created vnode.
	tnode dummy_t(0,"");
	vnode dummy(this, &amp;dummy_t) ;  // A dummy vnode to carry status bits.
	bool currentVnodeFlag = FALSE ;  // TRUE if the 'V' attribute seen.
	bool topVnodeFlag = FALSE ;  // TRUE if 'T' attribute seen.
	long tref = 0 , vtag = 0;
	long xindex = 0 ;
	String headline("") ;
	String xfile("");

	// we have already matched &lt;v.
	for ( ;; ) {
		if ( matchTag("t=\"T") ) {
			tref = getIndex () ;
			getDoubleQuote();
		}
		else if ( matchTag("vtag=\"V") ) {
			vtag = getIndex();
			getDoubleQuote();
		}
		else if ( matchTag("a=\"") ) {
			&lt;&lt; Handle vnode attribute bits &gt;&gt;
		}
		else if ( matchTag ("xfile=\"") ) {
			// New for Leo2
			xfile = getEscapedString();
			getDoubleQuote();
		}
		else if ( matchTag ("xindex=\"") ) {
			// New for Leo2
			xindex = getIndex();
			getDoubleQuote();
		}
		else break ;
	}
	getTag("&gt;");
	
	// Leo2: headlines are optional.
	if ( matchTag("&lt;vh&gt;") ) {
		headline = getEscapedString () ;
		getTag("&lt;/vh&gt;");
	}

	// Link v into the outline using parent and back.
	v = info -&gt; createVnode (
		parent, back, headline,
		dummy.status() /*attrib*/ ,
		tref, vtag, xfile, xindex) ;

	// Remember various info that may have been specified.
	if ( currentVnodeFlag )
		info -&gt; mCurrentVnode = v ;
	if ( topVnodeFlag )
		this -&gt; mTopVnode = v ;
	if ( vtag &gt; 0 )
		this -&gt; newVtag ( vtag, v ) ;

	// Recursively create all nested nodes.
	parent = v ;  back = NULL ;
	while ( matchTag("&lt;v") )
		back = getVnode ( info, parent, back ) ;

	// End this vnode.
	getTag("&lt;/v&gt;");

	return v ;
}
</t>
<t tx="edream.110203163054.1588">// The a=" has already been seen.
for (;;) {
	if      ( matchChar('C') ) dummy.initClonedBit(TRUE);
	else if ( matchChar('D') ) dummy.setDummy();
	else if ( matchChar('E') ) dummy.initExpandedBit();
	else if ( matchChar('M') ) dummy.initMarkedBit();
	else if ( matchChar('O') ) dummy.setOrphan();
	else if ( matchChar('T') ) topVnodeFlag = TRUE ;
	else if ( matchChar('V') ) currentVnodeFlag = TRUE ;
	else break;
}
getDoubleQuote();
</t>
<t tx="edream.110203163054.1589">void Commands::skipWs ( void )
{
	while ( mLinePtr &lt; mLineLimit ) {
		char c = *mLinePtr ;
		if ( is_ws ( c ) )
			++mLinePtr;
		else break ;
	}

	// The caller is entitled to get the next character.
	if ( mLinePtr &gt;= mLineLimit )
		throw EBadLeoFile() ;
}</t>
<t tx="edream.110203163054.1590">@ This routine is part of the read logic, and as such must handle raw '\r' and '\n' characters.  This is an adjustment to help TSyntaxMemo recognize lines properly.
@c

void Commands::skipWsAndNl ( void )
{
	while ( mLinePtr &lt; mLineLimit ) {
		char c = *mLinePtr ;
		if ( is_ws ( c ) || c == '\r' )
			++mLinePtr;
		else if ( c == '\n' )
			readLine();
		else break ;
	}

	// The caller is entitled to get the next character.
	if ( mLinePtr &gt;= mLineLimit )
		throw EBadLeoFile() ;
}
</t>
<t tx="edream.110203163054.1591">void Commands::open ( String fileName )
{
	mFileName = new String( fileName ) ;  // Do not delete this!
	mLeoForm -&gt; Caption = fileName ;
	&lt;&lt; Create the TFileStream and the file buffer &gt;&gt;
	&lt;&lt; Set the default directory &gt;&gt;
	this -&gt; BeginUpdate();
		double ratio = this -&gt; getLeoFile ( mLeoForm ) ;
	this -&gt; EndUpdate();
	mLeoForm -&gt; Show();
	this -&gt; setChanged ( FALSE ) ;
	this -&gt; resizePanesToRatio ( ratio ) ;
	// This should be done after the pane size has been set.
	if ( mTopVnode )
		this -&gt; setTopVnode (mTopVnode);
	&lt;&lt; Delete the TFileStream and the file buffer &gt;&gt;
}
</t>
<t tx="edream.110203163054.1592">mFileStream = new TFileStream ( fileName, fmOpenRead | fmShareDenyWrite ) ;
mFileBufSize = 1024 * 16 ;
mFileBuf = new char [ mFileBufSize ] ;
</t>
<t tx="edream.110203163054.1593">@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

String dir = ExtractFileDir ( fileName ) ;
if ( dir . Length() &gt; 0 ) {
    mLeoForm -&gt; mOpenDirectory = dir ;
	SetCurrentDir ( dir ) ;
}
</t>
<t tx="edream.110203163054.1594">delete mFileStream ;
mFileStream = NULL ;

delete [] mFileBuf ;
mFileBuf = NULL ;

mFileBufSize = 0 ;
</t>
<t tx="edream.110203163054.1595">@ This method fills a line buffer from a TFileStream.  There is no maximum size of a line:  we reallocate mLineBuf if needed.  We return FALSE if no more lines remain.  Otherwise, mLinePtr points to the start of the line and mLineLimit points to the character after the newline that ends the line.

8/25/99: This routine now removes all body_ignored_newline characters.
@c

bool Commands::readLine ( void )
{
	mLinePtr = mLineBuf ;

	for ( ; ; ) 
	{
		// Make sure there is room for the last character and a zero byte.
		if ( mLinePtr + 1 &gt;= mLineBuf + mLineBufSize ) {
			&lt;&lt; reallocate mLineBuf &gt;&gt;
		}

		if ( mFilePtr &gt;= mFileLimit ) {
			if ( ! mFileEmptyFlag ) {
				&lt;&lt; fill mFileBuf or set mFileEmptyFlag &gt;&gt;
			}
			if ( mFileEmptyFlag ) {
				&lt;&lt; return the last line, if any &gt;&gt;
			}
		}

		// Get the next character.
		char c = *mFilePtr++ ;

		// TSyntaxMemo appears to want lines ending in '\n'
		if ( c == '\n' ) {
			*mLinePtr++ = c ;
			*mLinePtr = '\0' ;
			mLineLimit = mLinePtr ;  // Point mLimitPtr after the last valid character.
			mLinePtr = mLineBuf ;  // The next character starts the line.
			return TRUE ;
		}
		else *mLinePtr++ = c ;  // copy '\r' characters as well.
	}
}
</t>
<t tx="edream.110203163054.1596">{
	unsigned long increment = 10000 ;
	long offset = mLinePtr - mLineBuf ;
	char * oldBuf = mLineBuf ;

	// Allocate and fill the new buffer.
	long size = mLineBufSize + increment ;
	mLineBuf = (char *) new char [ size ] ;
	assert(mLineBuf);
	memset(mLineBuf, 0 , size );

	if ( oldBuf )
		memcpy( mLineBuf, oldBuf, mLineBufSize ) ;

	// Set the new buffer values.
	mLineBufSize += increment ;
	mLineLimit = mLineBuf + mLineBufSize ;
	mLinePtr = mLineBuf + offset ;

	if ( oldBuf ) delete [] oldBuf ;
}</t>
<t tx="edream.110203163054.1597">if ( mUsingClipboard ) {
	// Get the next line from the memory stream.
	if ( mMemoryStream &amp;&amp; ! mFileEmptyFlag ) {
		assert( mFileBufSize &gt; 0 ) ;
		long n = mMemoryStream -&gt; Read( mFileBuf, mFileBufSize ) ;
		mFileEmptyFlag = ( n == 0 ) ;
		mFilePtr = mFileBuf ;
		mFileLimit = mFileBuf + n ;
	}
	else mFileEmptyFlag = TRUE ;
}
else {
	// Get the next line from the file.
	if ( mFileStream &amp;&amp; ! mFileEmptyFlag ) {
		assert( mFileBufSize &gt; 0 ) ;
		long n = mFileStream -&gt; Read( mFileBuf, mFileBufSize ) ;
		mFileEmptyFlag = ( n == 0 ) ;
		mFilePtr = mFileBuf ;
		mFileLimit = mFileBuf + n ;
	}
	else mFileEmptyFlag = TRUE ;
}</t>
<t tx="edream.110203163054.1598">if ( mLinePtr == mLineBuf ) {
	mLineLimit = mLinePtr ;
	return FALSE ;
}
else {
	// End the last line with a newline
	assert(mLinePtr + 1 &lt; mLineLimit);
	*mLinePtr++ = body_newline ;
	*mLinePtr = '\0' ;
	mLineLimit = mLinePtr ;
	mLinePtr = mLineBuf ;
	return TRUE ;
}
</t>
<t tx="edream.110203163054.1599">String Commands::xmlUnescape ( char * cs )
{
	char * cs1 = cs;

	// Compute the length of the result.
	long length = 0 ;
	while (*cs)
	{
		++ length ;
		if ( *cs++ == '&amp;' ) {
			if ( strncmp ( cs, "amp;", 4 ) == 0 )
				cs += 4 ;
			else if ( strncmp ( cs, "lt;", 3 ) == 0 )
				cs += 3 ;
			else if ( strncmp ( cs, "gt;", 3 ) == 0 )
				cs += 3 ;
			else
				--length ;  // We will ignore the ampersand.
		}
	}

	// Allocate the result and copy the characters into it.
	char * result = new char [ length + 2 ] ;
	long i = 0 ;
	cs = cs1;  // rescan.
	while (*cs) {
		if ( *cs == '&amp;' ) {
			++ cs ;
			if ( strncmp ( cs, "amp;", 4 ) == 0 ) {
				cs += 4 ;
				result [i++] = '&amp;';
			}
			else if ( strncmp ( cs, "lt;", 3 ) == 0 ) {
				cs += 3 ;
				result [i++] = '&lt;' ;
			}
			else if ( strncmp ( cs, "gt;", 3 ) == 0 ) {
				cs += 3 ;
				result [i++] = '&gt;' ;
			}
			else ++ cs ;  // Skip the ampersand:  this should never happen.
		}
		else result [i++] = *cs++ ;
	}
	result [ i ] = '\0' ;
	assert ( i &lt; length + 2 ) ;
	
	// Fixes a major memory leak.
	String s2 ( result ) ;
	delete [] result ;
	return s2 ;
}
</t>
<t tx="edream.110203163054.1600"></t>
<t tx="edream.110203163054.1601">void Commands::assignFileIndices ( void )
{
	for ( vnode * v = this -&gt; rootVnode(); v ; v = v -&gt; threadNext() )
	{
		tnode * t = v -&gt; t();
		// 8/28/99.  Write shared tnodes even if they are empty.
		if ( t -&gt; hasBody() || v -&gt; joinList() != NULL ) {
			if ( t -&gt; fileIndex() == 0 )
				t -&gt; setFileIndex ( ++ mMaxTnodeIndex ) ;
		}
		else t -&gt; setFileIndex ( 0 ) ;
	}
}</t>
<t tx="edream.110203163054.1602">void Commands::compactFileIndices ( void )
{
	mMaxTnodeIndex = 0 ;
	
	// Clear all indices.
	for ( vnode * v = this -&gt; rootVnode(); v ; v = v -&gt; threadNext() ) {
		tnode * t = v -&gt; t();
		t -&gt; setFileIndex ( 0 ) ;
	}

	// Set indices for all shared tnodes or tnodes containing body text.
	for ( vnode * v = this -&gt; rootVnode(); v ; v = v -&gt; threadNext() ) {
		tnode * t = v -&gt; t();
		// 8/28/99.  Write shared tnodes even if they are empty.
		if ( t -&gt; hasBody() || v -&gt; joinList() != NULL ) {
			if ( t -&gt; fileIndex() == 0 )
				t -&gt; setFileIndex ( ++ mMaxTnodeIndex ) ;
		}
	}
}</t>
<t tx="edream.110203163054.1603">@ This method sets policy for when we should compact a file before doing a Save Command.
@c

bool Commands::shouldCompactOnSave ( void )
{
	long tnodesUsed = 0 ;
	&lt;&lt; Compute the number of tnodes used &gt;&gt;
	long tnodesUnused = mMaxTnodeIndex - tnodesUsed ;
	return ( tnodesUnused &gt; 100 ) ;
}</t>
<t tx="edream.110203163054.1604">this -&gt; clearAllVisited();

for ( vnode * v = this -&gt; rootVnode(); v ; v = v -&gt; threadNext() )
{
	tnode * t = v -&gt; t();
	if ( t &amp;&amp; ! t -&gt; isVisited() ) {
		++ tnodesUsed ;
		t -&gt; setVisited();
	}
}
</t>
<t tx="edream.110203163054.1605"></t>
<t tx="edream.110203163054.1606">@ All output eventually comes to put (char *)
@c

void Commands::put ( char * s )
{
	if ( s == NULL ) return ;
	long len = strlen(s) ;
	if ( len == 0 ) return ;

	if ( mUsingClipboard ) {
		&lt;&lt; put s to the mMemoryStream &gt;&gt;
	}
	else {
		&lt;&lt; put s to mFileStream &gt;&gt;
	}
}

void Commands::put_bool ( bool b )
{
	put ( b ?  "1" : "0" ) ;
}

void Commands::put_double_quote ( void )
{
	put ( "\"" ) ;
}

void Commands::put_nl ( void )
{
	put ( "\r\n" ) ;
}

void Commands::put_tab ( void )
{
	put ( "\t" ) ;
}

void Commands::put_tabs ( long n )
{
	while ( n-- &gt; 0 )
		put_tab();
}

void Commands::put ( String s )
{
	long length = s . Length();

	if ( length &gt; 0 ) {
		char * buffer = s . c_str();
		put (buffer);
		assert(buffer == s . c_str());
	}
}

void Commands::put ( long n )
{
	put ( String ( n ) ) ;
}

void Commands::put ( double n )
{
	put ( String ( n ) ) ;
}
</t>
<t tx="edream.110203163054.1607">@ mFileStream will be NULL if there is any file error.
@c

if ( mMemoryStream == NULL ) return ;

try {
	mMemoryStream -&gt; Write ( s, len );
}
catch (...)
{
	delete mMemoryStream ;
	mMemoryStream = NULL ;
	String s("Error writing to clipboard") ;
	alert ( s . c_str() ) ;
}</t>
<t tx="edream.110203163054.1608">@ mFileStream will be NULL if there is any file error.
@c

if ( mFileStream == NULL ) return ;

try {
	mFileStream -&gt; Write ( s, len );
	mFileSize += len ;
}
catch (...)
{
	delete mFileStream ;
	mFileStream = NULL ;
	String s = String("Error writing to ") + ( * mFileName ) ;
	alert ( s . c_str() ) ;
}</t>
<t tx="edream.110203163054.1609">void Commands::putClipboardHeader ( void )
{
	long tnodes = 0;
	&lt;&lt; count the number of tnodes &gt;&gt;
	put("&lt;leo_header");
		put(" file_format=\"");
			put ( "1" ) ; put_double_quote();
		put(" tnodes=\"");
			put(tnodes); put_double_quote();
		put(" max_tnode_index=\"");
			put( mMaxTnodeIndex ); put_double_quote();
	put("/&gt;"); put_nl();
}</t>
<t tx="edream.110203163054.1610">this -&gt; clearAllVisited();

// Count the vnode and tnodes.
vnode * current = this -&gt; currentVnode() ;
vnode * after = current -&gt; nodeAfterTree();

for ( vnode * v = current ; v &amp;&amp; v != after ; v = v -&gt; threadNext() ) {
	tnode * t = v -&gt; t();
	if (
        t &amp;&amp; ! t -&gt; isVisited() &amp;&amp;
        ( t -&gt; hasBody() || v -&gt; joinList() != NULL )
    ) {
		t -&gt; setVisited();
		++tnodes ;
	}
}</t>
<t tx="edream.110203163054.1611">void Commands::putCloneWindows ( void )
{
#if USE_CLONE_WINDOW
	if ( mLeoForm == NULL || mLeoForm -&gt; mCloneFormList == NULL ) return ;

	put("&lt;clone_windows&gt;"); put_nl();

	for ( TCloneForm * clone = mLeoForm -&gt; mCloneFormList ;
		clone ; clone = clone -&gt; mNextForm )
	{
		vnode * v = clone -&gt; mVnode ;
		long vtag = this -&gt; getVtag ( v ) ; ;

		put_tab();
			put("&lt;clone_window vtag=\"V");
				put (vtag) ; put_double_quote(); put("&gt;"); put_nl();
		put_tabs(2);
			&lt;&lt; put position of clone window &gt;&gt;
		put_tab();
			put("&lt;/clone_window&gt;"); put_nl();
	}

	put("&lt;/clone_windows&gt;"); put_nl();
#endif
}
</t>
<t tx="edream.110203163054.1612">long top = clone -&gt; Top;
long left = clone -&gt; Left;
long height = clone -&gt; Height;
long width = clone -&gt; Width;

put("&lt;global_window_position");
	put(" top=\""); put( top ); put_double_quote();
	put(" left=\""); put( left ); put_double_quote();
	put(" height=\""); put( height ); put_double_quote();
	put(" width=\"");  put( width ); put_double_quote();
put("/&gt;"); put_nl();
</t>
<t tx="edream.110203163054.1613">@ Surprisingly, the call to xmlEscape here is _much_ faster than calling put for each characters of s.c_str().
@c

void Commands::putEscapedString ( String s )
{
   put ( this -&gt; xmlEscape ( s ) ) ;
}
</t>
<t tx="edream.110203163054.1614">#define put_flag(a,b) if (a) { put(" "); put(b); put("=\"1\""); }

void Commands::putFindSettings ( void )
{
	put("&lt;find_panel_settings"); 
		put_flag ( batch_flag, "batch" ) ;
		put_flag ( wrap_flag, "wrap" ) ;
		put_flag ( whole_word_flag, "whole_word" ) ;
		put_flag ( ignore_case_flag, "ignore_case" ) ;
		put_flag ( pattern_match_flag, "pattern_match" );
		put_flag ( search_headline_flag, "search_headline" );
		put_flag ( search_body_flag, "search_body" );
		put_flag ( suboutline_only_flag, "suboutline_only" );
		put_flag ( mark_changes_flag, "mark_changes" );
		put_flag ( mark_finds_flag, "mark_finds" );
		put_flag ( reverse_flag, "reverse" );
	put("&gt;"); put_nl();
		put_tab();
			put("&lt;find_string&gt;"); putEscapedString(find_text);
			put("&lt;/find_string&gt;"); put_nl();
		put_tab();
			put("&lt;change_string&gt;"); putEscapedString(change_text);
			put("&lt;/change_string&gt;"); put_nl();
	put("&lt;/find_panel_settings&gt;"); put_nl();
}

#undef put_flag
</t>
<t tx="edream.110203163054.1615">void Commands::putGlobals ( void )
{
	long top, left, height, width ;

	put("&lt;globals");
		&lt;&lt; put the body/outline ratio &gt;&gt;
	put("&gt;"); put_nl();
		&lt;&lt; put the position of this form &gt;&gt;
		&lt;&lt; put the position of the log window &gt;&gt;
	put("&lt;/globals&gt;"); put_nl();
}</t>
<t tx="edream.110203163054.1616">{
	long treeViewH = mTreeView -&gt; Height ;
	long richViewH = mSyntaxMemo -&gt; Height ;
	double ratio = double(treeViewH) / (double) (treeViewH + richViewH) ;

	put(" body_outline_ratio=\"");
	#if 0 // Puts an innumerate number of digits
		put ( ratio );
	#else
		char buffer [ 50 ] ;
		sprintf( buffer, "%2.3f", ratio );
		put ( buffer ) ;
	#endif
	put_double_quote();
}
</t>
<t tx="edream.110203163054.1617">top = mLeoForm -&gt; Top ;
left = mLeoForm -&gt; Left;
height = mLeoForm -&gt; Height ;
width = mLeoForm -&gt; Width ;

put_tab();
put("&lt;global_window_position");
	put(" top=\""); put( top ); put_double_quote();
	put(" left=\""); put( left ); put_double_quote();
	put(" height=\""); put( height ); put_double_quote();
	put(" width=\"");  put( width ); put_double_quote();
put("/&gt;"); put_nl();
</t>
<t tx="edream.110203163054.1618">top = SherlockForm -&gt; Top ;
left = SherlockForm -&gt; Left;
height = SherlockForm -&gt; Height ;
width = SherlockForm -&gt; Width ;

put_tab();
put("&lt;global_log_window_position");
	put(" top=\""); put( top ); put_double_quote();
	put(" left=\""); put( left ); put_double_quote();
	put(" height=\""); put( height ); put_double_quote();
	put(" width=\"");  put( width ); put_double_quote();
put("/&gt;"); put_nl();
</t>
<t tx="edream.110203163054.1619">void Commands::putHeader ( void )
{
	long tnodes = 0, clone_windows = 0 ;
	#if 0 // These counts are not used in Leo2.
		&lt;&lt; count the number of tnodes and clone windows &gt;&gt;
	#endif
	put("&lt;leo_header");
		// Leo2 use file format 2 so that Leo1 can warn about altering Leo2 files.
		put(" file_format=\""); put ( "2" ) ; put_double_quote();
		put(" tnodes=\""); put(tnodes); put_double_quote();
		put(" max_tnode_index=\""); put( mMaxTnodeIndex ); put_double_quote();
		put(" clone_windows=\""); put(clone_windows); put_double_quote();
	put("/&gt;"); put_nl();
}
</t>
<t tx="edream.110203163054.1620">this -&gt; clearAllVisited();

// Count the vnode and tnodes.
for ( vnode * v = this -&gt; rootVnode(); v ; v = v -&gt; threadNext() ) {
	tnode * t = v -&gt; t();
	// 8/28/99: we write all shared tnodes, even if empty.
	if (
		t &amp;&amp; ! t -&gt; isVisited() &amp;&amp;
		( t -&gt; hasBody() || v -&gt; joinList() != NULL )
	) {
		t -&gt; setVisited();
		++tnodes ;
	}
}

#if USE_CLONE_WINDOW
	// Count the clone windows.
    if ( mLeoForm ) {
    	for (
    		TCloneForm * clone = mLeoForm -&gt; mCloneFormList ;
    		clone ;
    		clone = clone -&gt; mNextForm 
    	)
    		++clone_windows ;
    }
#endif  // USE_CLONE_WINDOW
</t>
<t tx="edream.110203163054.1621">@ This method writes a Leo outline to the clipboard.
@c

bool Commands::putLeoOutline ( TMemoryStream * ms )
{
	mMemoryStream = ms ;  // Create an alias.
	mUsingClipboard = TRUE ;
		// assignFileIndices();  // The caller does this.
		putProlog();
		putClipboardHeader();
		putVnodes();
		putTnodes();
		putPostlog();
		bool ok = ( mMemoryStream != NULL ) ;
	// The caller will delete ms.
	// Do _not_ delete mMemoryStream; it is just an alias.
	mMemoryStream = NULL ;
	mUsingClipboard = FALSE ;
	return ok ;
}
</t>
<t tx="edream.110203163054.1622">void Commands::putPrefs ( void )
{
	TLeoForm * form = this -&gt; mLeoForm ;
	PERM_ASSERT(form);

	put("&lt;preferences");
		put(" allow_rich_text=\"");
			put_bool( default_allow_rich_text ); put_double_quote();
		put(" tab_width=\"");
			put( default_tab_width ); put_double_quote();
		put(" page_width=\"");
			put( default_page_width ); put_double_quote();
		put(" tangle_bat=\"");
			put_bool( default_tangle_batch ); put_double_quote();
		put(" untangle_bat=\"");
			put_bool( default_untangle_batch ); put_double_quote();
		// New in version 0.10
		put(" output_doc_chunks=\"");
			put_bool( default_output_doc_flag ); put_double_quote();
		&lt;&lt; put syntax coloring prefs &gt;&gt; // New in version 0.15
		// New in version 0.18
		put(" use_header_flag=\"");
			put_bool( default_use_header_flag ); put_double_quote();
		// Removed in version 0.19
		#ifdef USE_CWEB
    		put(" noweb_flag=\"");
    			put_bool( default_use_noweb_flag ); put_double_quote();
    		put(" extended_noweb_flag=\"");
    			put_bool( default_extended_noweb_flag ); put_double_quote();
		#endif
	put("&gt;");
	put_nl(); put_tab();
		&lt;&lt; put default directory &gt;&gt; // New in version 0.16
		put_nl();
		put("&lt;TSyntaxMemo_options&gt;");
		putEscapedString ( mSyntaxMemoParser1 -&gt; StylesAsString() ) ;
		put ("&lt;/TSyntaxMemo_options&gt;");
	put_nl(); put("&lt;/preferences&gt;"); put_nl();
}
</t>
<t tx="edream.110203163054.1623">String key = " defaultTargetLanguage=\"" ;

switch ( default_target_language ) {
	case c_language:		put(key); put("C\""); break;
	case cweb_language:		put(key); put("CWEB\""); break;
	case html_language:		put(key); put("HTML\""); break;
	case java_language:		put(key); put("Java\""); break;
	case pascal_language:	put(key); put("Pascal\""); break;
	case perl_language:		put(key); put("Perl\""); break;
	case perlpod_language:	put(key); put("PerlPod\""); break;
	case plain_text_language: put(key); put("Plain\""); break;
	case python_language:	put(key); put("Python\""); break;
	default: put("Plain\"");
}
</t>
<t tx="edream.110203163054.1624">if ( mLeoForm -&gt; mDefaultDirectory . Length() &gt; 0 ) {
	put("&lt;defaultDirectory&gt;");
	putEscapedString ( mLeoForm -&gt; mDefaultDirectory ) ;
	put ("&lt;/defaultDirectory&gt;");
}
</t>
<t tx="edream.110203163054.1625">void Commands::putProlog ( void )
{
	put(prolog_string); put_nl();
	// internal or external DTD goes here
	put("&lt;leo_file&gt;"); put_nl();
}
</t>
<t tx="edream.110203163054.1626">void Commands::putPostlog ( void )
{
	put("&lt;/leo_file&gt;"); put_nl();
}
</t>
<t tx="edream.110203163054.1627">@ This method puts all tnodes in index order.  All tnode indices must have been assigned at this point.
@c

void Commands::putTnodes ( void )
{
	if ( mMaxTnodeIndex &lt; 1 ) return ;

	tnode ** tnodes = (tnode **) new char
		[ sizeof (tnode *) * (mMaxTnodeIndex+1) ] ;

	for ( long i = 0 ; i &lt; mMaxTnodeIndex  ; ++ i )
		tnodes [i] = NULL ;

	// Populate the tnodes array.
	if ( mUsingClipboard ) {  // Just write the current tree.
		vnode * current = this -&gt; currentVnode();
		vnode * after = current -&gt; nodeAfterTree();
		for (vnode * v = current; v &amp;&amp; v != after ; v = v -&gt; threadNext() ) {
       		tnode * t = v -&gt; t();
        	long index = t -&gt; fileIndex();
        	if ( index &gt; 0 ) {
				if ( 
		    		index &lt;= mMaxTnodeIndex &amp;&amp;
					(tnodes[index-1]==NULL || tnodes[index-1]== t )
				)
		    		tnodes [ index - 1 ] = t ;
				else
					alert ("error writing to clipboard");
        	}
		}
	}
	else {  // Write the entire outline.
		for (vnode * v = this -&gt; rootVnode(); v; v = v -&gt; threadNext() ) {
       		tnode * t = v -&gt; t();
        	long index = t -&gt; fileIndex();
        	if ( index &gt; 0 ) {
				if ( index &lt;= mMaxTnodeIndex )
		    		tnodes [ index - 1 ] = t ;
				else
					alert(
"error writing file (bad tnode)! Try using the Save To command");
        	}
		}
	}

	// Put all tnodes in index order.
	put("&lt;tnodes&gt;"); put_nl();
		for ( long i = 0 ; i &lt; mMaxTnodeIndex ; ++ i ) {
			// New for Leo2: write only those tnodes whose vnodes were written.
			tnode * t = tnodes [i] ;
			if ( t &amp;&amp; t -&gt; isVisited() )
				put ( t ) ;
		}
	put("&lt;/tnodes&gt;"); put_nl();

	delete [] tnodes ;
}
</t>
<t tx="edream.110203163054.1628">void Commands::put ( tnode * t )
{
	assert(t);
	String bodyString = t -&gt; bodyString();
	String bodyRTF = t -&gt; bodyRTF();
	bool hasBody = t -&gt; hasBody();
	bool hasRichText = arg_allow_rich_text &amp;&amp; t -&gt; isRichTextBit()
		&amp;&amp; bodyRTF . Length() &gt; 0;

	put("&lt;t tx=\"T");
		put( t -&gt; fileIndex() ); put_double_quote();
		if ( hasBody &amp;&amp; hasRichText ) put(" rtf=\"1\"");
	put("&gt;");

	if ( hasBody &amp;&amp; hasRichText )
		putEscapedString( bodyRTF ) ;
	else if ( hasBody &amp;&amp; bodyString . Length() &gt; 0 )
		putEscapedString( bodyString ) ;

	put("&lt;/t&gt;"); put_nl();
}
</t>
<t tx="edream.110203163054.1629">@ This method puts all vnodes by starting the recursion.  put(vnode*) will write all vnodes in the order in which they appear in the outline.
@c

void Commands::putVnodes ( void )
{
	// Set the global.
	mMaxVnodeTag = 0 ;

	TTreeView * treeView = this -&gt; treeView();
	TTreeNode * topNode = treeView -&gt; TopItem ;
	vnode * topVnode = (vnode *) topNode -&gt; Data ;
	assert(topVnode);
	
	// New for Leo2: put(vnode*) will visit
	// only those tnodes whose vnodes were written.
	this -&gt; clearAllVisited();

	put("&lt;vnodes&gt;"); put_nl();
		if ( mUsingClipboard )
			put (
				this -&gt; currentVnode(), // Write only current tree.
				NULL, // Don't write top vnode status bit.
				TRUE, // forceFlag.
				FALSE); // dummyFlag (don't care).
		else for ( vnode * v = this -&gt; rootVnode() ; v ; v = v -&gt; next() )
			put (
				v, // Write the next top-level node.
				topVnode,  // Write the top-vnode status bit.
				FALSE, // forceFlag,
				FALSE);  // dummyFlag.
	put("&lt;/vnodes&gt;"); put_nl();
}
</t>
<t tx="edream.110203163054.1630">@ When forceFlag is TRUE we generate full vnodes for v's tree.  Otherwise, if dummyFlag is TRUE we generate dummy vnodes only.  In particular, we generate dummy vnodes for all valid, non-ignored @file nodes.

atFile::write has already set the orphan bit for some nodes, including all invalid @file nodes.  However, we must make a separate check for atIgnored nodes.
@c

void Commands::put ( vnode * v, vnode * topVnode, bool forceFlag, bool dummyFlag )
{
	atFile * at = new atFile( this );
	
	// The heart of Leo2's write code.
	bool isAtFile = v -&gt; isAtFileNode();
	bool isIgnore = v -&gt; isAtIgnoreNode();
	bool orphanFlag = v -&gt; isOrphan() || isIgnore;
	forceFlag = forceFlag || orphanFlag ;
	#if 0 // We always write the headline now.
		bool writeHead = forceFlag || !dummyFlag || isAtFile;
	#endif
	dummyFlag = !forceFlag &amp;&amp; ( dummyFlag || isAtFile );

	put("&lt;v");
		if ( !dummyFlag || v -&gt; joinList() != NULL ) {
			&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;
		}
		&lt;&lt; Put a vnode tag if this vnode has a clone window &gt;&gt;
		&lt;&lt; Put attribute bits &gt;&gt;
	put("&gt;");
		&lt;&lt; write the head text &gt;&gt;
			
		vnode * child = v -&gt; firstChild() ;
		if ( child ) {
			put_nl();
			while ( child ) {
				put ( child, topVnode, forceFlag, dummyFlag ) ;
				child = child -&gt; next();
			}
		}
	put("&lt;/v&gt;"); put_nl();
	
	delete at ;
}
</t>
<t tx="edream.110203163054.1631">tnode * t = v -&gt; t();

if ( t &amp;&amp; t -&gt; hasBody() || v -&gt; joinList() != NULL )
{
	if ( t -&gt; fileIndex() &gt; 0 ) {
		put (" t=\"T"); put ( t -&gt; fileIndex() ); put_double_quote();
		v -&gt; t() -&gt; setVisited(); // Indicate we wrote the body text.
	}
	else {
		alert("error writing file (bad vnode)!  Try using the Save To command");
	}
}</t>
<t tx="edream.110203163054.1632">#if USE_CLONE_WINDOW

// See if any clone window has this vnode as its master.
if ( mLeoForm )
{
	bool found = FALSE ;

	for (
		TCloneForm * form = mLeoForm -&gt; mCloneFormList ;
		form &amp;&amp; ! found ; form = form -&gt; mNextForm
	)
		if ( v == form -&gt; mVnode )
			found = TRUE ;

	if ( found ) {
		long tag = ++mMaxVnodeTag ;
		this -&gt; newVtag ( tag, v ) ;
		put(" vtag=\"V"); put ( tag ); put_double_quote();
	}
}

#endif
</t>
<t tx="edream.110203163054.1633">@ Dummy vnodes carry all attributes.
@c

vnode * current = this -&gt; currentVnode();
vnode * top = this -&gt; topVnode();

if (
	v -&gt; isCloned() || v -&gt; isExpanded() || v -&gt; isMarked() ||
	forceFlag || dummyFlag ||
	v == current || v == top
) {
	put(" a=\"");
		if ( v -&gt; isCloned())	put("C");
		if ( dummyFlag )		put("D");
		if ( v -&gt; isExpanded())	put("E");
		if ( v -&gt; isMarked())	put("M");
		if ( orphanFlag )		put("O");
		if ( v == top )			put("T");
		if ( v == current )		put("V");
	put_double_quote();
}
</t>
<t tx="edream.110203163054.1634">@ Dummy vnodes have no headline text.
@c

assert(v -&gt; treeNode());
String headString = v -&gt; treeNode() -&gt; Text ;

if ( headString . Length() &gt; 0 ) {
    put("&lt;vh&gt;");
    putEscapedString( headString );
    put("&lt;/vh&gt;");
}
</t>
<t tx="edream.110203163054.1635">bool Commands::save ( String fileName )
{
	this -&gt; endEditing () ;  // Set the current headline text.

	if ( this -&gt; shouldCompactOnSave() )
		this -&gt; compactFileIndices();
	else
		this -&gt; assignFileIndices();

	try {
    	if ( this -&gt; write_LEO_file ( fileName, FALSE /* outlineOnlyFlag */ ) ) {
    		this -&gt; setChanged ( FALSE ) ;  // Clears all dirty bits.
    		this -&gt; Repaint();
			return TRUE;
    	}
	}
	catch ( ... ) {}
	return FALSE;
}</t>
<t tx="edream.110203163054.1636">bool Commands::saveAs ( String fileName )
{
	this -&gt; endEditing () ;  // Set the current headline text.
	this -&gt; compactFileIndices() ;

	try {
    	if ( this -&gt; write_LEO_file ( fileName, FALSE /* outlineOnlyFlag */ ) ) {
    		this -&gt; setChanged ( FALSE ) ;  // Clears all dirty bits.
    		this -&gt; Repaint();
			return TRUE;
    	}
	}
	catch ( ... ) {}
	return FALSE;
}</t>
<t tx="edream.110203163054.1637">bool Commands::saveACopyAs ( String fileName )
{
	try {
    	this -&gt; endEditing () ;  // Set the current headline text.
    	this -&gt; compactFileIndices() ;
    	this -&gt; write_LEO_file ( fileName, FALSE /* outlineOnlyFlag */ ) ;
		return TRUE;
	}
	catch ( ... ) {}
	return FALSE;
}</t>
<t tx="edream.110203163054.1638">bool Commands::saveOutlineOnlyTo ( String fileName )
{
	try {
    	this -&gt; endEditing () ;  // Set the current headline text.
    	this -&gt; compactFileIndices() ;
    	this -&gt; write_LEO_file ( fileName, TRUE /* outlineOnlyFlag */ ) ;
		return TRUE;
	}
	catch ( ... ) {}
	return FALSE;
}</t>
<t tx="edream.110203163054.1639">@ Surprisingly, this is a time critical routine.  This code is much faster than creating the result string by concatenations.  It is also much faster to use this routine than calling put() repeatedly for each character of s.c_str().

8/25/99:  We enforce the end-of-line convention here by turning bare '\r' or '\n' characters into cr/lf sequences.  This is an adjustment for TSyntaxMemo's difficulty recognizing lines that start with only '\r'.
@c

String Commands::xmlEscape ( String s )
{
	char * cs = s . c_str() ;
	char * cs1 = cs;

	// Compute the length of the result.
	long length = 0 ;
	while (*cs)
	{
		switch ( *cs++ ) {
		case '&amp;': length += 5 ; break;
		case '&lt;': length += 4 ; break;
		case '&gt;': length += 4 ; break;
        // Convert any combination of cr or lf to cr/lf.
        case '\r': length += 2 ;
            if ( *cs == '\n' ) ++cs;
            break;
        case '\n': length += 2 ; break;
		default : ++ length ; break ;
		}
	}

	// Allocate the result and copy the characters into it.
	char * result = new char [ length + 2 ] ;
	long i = 0 ;
	cs = cs1;  // rescan.
	while (*cs)
	{
		switch ( *cs++ ) {
		case '&amp;': strcpy( result + i, "&amp;amp;" ) ; i += 5; break;
		case '&lt;': strcpy( result + i, "&amp;lt;" ) ;  i += 4; break;
		case '&gt;': strcpy( result + i, "&amp;gt;" ) ;  i += 4; break;
        case '\r':
            strcpy ( result + i, "\r\n" ) ; i += 2 ;
            if ( *cs == '\n') ++cs;
            break ;
        case '\n': strcpy ( result + i, "\r\n" ) ; i += 2 ; break;
		default : result [ i ] = *(cs-1) ; ++i ; break ;
		}
	}
	result [ i ] = '\0' ;
	assert ( i &lt; length + 2 ) ;

	String s2 ( result ) ; 
	delete [] result ;
	return s2 ; 
}
</t>
<t tx="edream.110203163054.1640">@ The caller does any repainting.
@c

bool Commands::write_LEO_file ( String fileName, bool outlineOnlyFlag )
{
	// Leo2: write all @file nodes and set orphan bits.
	if ( ! outlineOnlyFlag ) {
    	atFile * at = new atFile( this );
    	at -&gt; writeAll ( this -&gt; rootVnode() ) ;
    	delete at ;
	}
	
	&lt;&lt; Open fileName and buffer it &gt;&gt;
	putProlog();
	putHeader();
	putGlobals();
	putPrefs();
	putFindSettings();
	putVnodes();
	putTnodes();
	putCloneWindows();
	putPostlog();
	bool ok = ( mFileStream != NULL ) ;
	&lt;&lt; Close the file &gt;&gt;
	deleteTagList();

	return ok ;
}
</t>
<t tx="edream.110203163054.1641">delete mFileName ;
mFileName = new String( fileName ) ;
mFileSize = 0 ;

try {
	mFileStream = new TFileStream ( fileName, fmCreate | fmShareDenyWrite ) ;
}
catch (...) {
	mFileStream = NULL ;
}
</t>
<t tx="edream.110203163054.1642">if ( mFileStream ) {
	mFileStream -&gt; Size = mFileSize ;  // Truncate the file.
	delete mFileStream ;
	mFileStream = NULL ;
}
</t>
<t tx="edream.110203163054.1643">@nocolor

These papers discuss topics related to Leo.</t>
<t tx="edream.110203163054.1644">This paper presents my present thoughts about recovering from "read errors", that is, errors encountered while reading @file trees.

Recall that read errors will occur when the .leo file is out of synch with the derived files that it creates.  Read errors break clone links into the derived file, a highly undesirable situation.  Read errors will occur when restoring a project from a backup file.  They can also occur when using CVS if derived files aren't checked out with the .leo file that created them.

No More "False" Read Errors

leo.py v 0.8 fixed a bug that caused some changed clone nodes not to be marked dirty.  I haven't suffered a read error since then.  "False" read errors, that is, read errors encountered while reading derived files that are in synch with the .leo files, seem to be gone forever.

Note:  This bug still exists in the Borland version of Leo.  I plan to fix this and all other known bugs in the Borland version in the next week or so.

No More Broken Clone Links

Even though "false" read errors are gone, read errors can still occur when the .leo file is out of synch with derived files.  To repeat: this can happen when using a backup .leo file, or when failing to check out all files in synch from CVS.

At present Leo restores the @file tree in the outline from the derived file when a read error occurs, breaking clone links into the derived file in the process. Leo could retain clone links if it recovered from read errors using the outline rather than the derived file.  This way has the following features:
	
1. We retain clone links by default.  The user doesn't have to understand all the issues involved when read errors occur.  In particular, the user won't be confronted with an dialog when read errors occur that requires the user to make an obscure choice. Leo will clearly state that data is recovered from the outline rather than the derived file.

2. When restoring a project from a backup .leo file, it is natural to have the information in the .leo file take precedence over the derived file.  Ditto when using CVS.

3. The user can "manually" restore information from a derived file using the Read @file Nodes command if  necessary.  This operation, and only this operation, will break clone links.</t>
<t tx="edream.110203163054.1645"></t>
<t tx="edream.110203163054.1646">Let us consider how to use CVS with Leo.  Our goal is this:
	
	CVS operations should retain clone links.
	
In general, clone links will break whenever Leo reads a derived file from a .leo file different from the .leo file that created it.  This leads immediately to

-- Rules for using Leo files with CVS --
	
1. All derived files in a particular revision in the CVS repository must be generated by a single .leo file. Call that .leo file the _generating_ .leo file (for the revision as a whole and for each derived file in particular).  In other words, all .leo files in the repository should be proper snapshots of their revision.
	
2. When we check files out of the repository, we must check out their generating .leo file.

3. When we check files into the repository, we must check in their (unique!) generating .leo file.  Developers should use Write @file Nodes command to ensure that all derived files are in synch with this .leo file.

4. When CVS detects update conflicts, developers should resolve those conflicts into a single "merged" .leo file.  Again, developers should use Write @file Nodes to recreate all derived files.

5. Developers should retain clone links when creating a merged .leo file.  Most merges will have to be done "by hand" by starting with one .leo file and pasting changes from the other .leo file into it.

In short: Developers should include generating .leo files in all CVS operations.

We could conceivably go further and include _only_ .leo files in CVS operations.  We would check out only  .leo files, creating derived files as needed using the Write @file Nodes command.  One drawback to this scheme is that the repository would contain only .leo files, so all diffs would be based on .leo files. This will make detecting conflicts more difficult.  Another drawback is that the repository would contain no human readable files.  So probably we should include both .leo files and derived files in the repository.

Rules 4 and 5 imply that there is extra work to be done when using Leo with CVS.  That should not be too surprising; there are extra files (the .leo files) to update.

I always envisioned that update conflicts would have to be resolved in .leo files rather than derived files.  It is now clear that this is the only way to prevent clone links from being broken.

I believe these rules are correct.  If you disagree with these conclusions please let me know immediately.

Edward</t>
<t tx="edream.110203163054.1647">My last posting is completely wrong.  Leo can not mend clone links for a very simple reason: cloned nodes must have the same structure!  Most read errors come about because Leo has detected that nodes do _not_ have the same structure.

Even if a Mend Clone dialog were put up, the user would have no way of knowing whether any joins made sense.  Joining two nodes with different structure would be disastrous.

Mending clones would be possible only if the only differences between trees were differences in headline text.  This suggests that Leo shouldn't test headline text during reads. This would eliminated false read errors.  This is an easy change and I plan to test it soon.

My next posting will try to make a virtue out of necessity by proposing guidelines for using Leo with CVS.

Edward</t>
<t tx="edream.110203163054.1648">Development work on Leo is about to start using CVS.  This raises a number of questions about how to use Leo projects with CVS.  Resolving these issues is very important; people won't use Leo if it doesn't work well with CVS.
	
1. CVS may not do very well in reporting conflicts involving .leo files.  Indeed, .leo files might almost be considered to be "binary" files as far as CVS is concerned.  Experience will show how serious this problem turns out to be, and I have some ideas about how to help out CVS.

2. Files derived from @root or @file trees contain structure information that should not be edited by hand.  In particular, if CVS reports a conflict, that conflict should be resolved at the outline level, not in the derived file.  Again, it remains to be seen how big a problem this will be, and again I have some ideas about how to make things more smooth.

Note: It will never be possible to update outline _structure_ using the Untangle command.  Indeed, the Untangle command traverses the outline to find body text to update; there is absolutely no way for Untangle to change outline structure.  It _is_ possible to update outline structure by reading @file trees (that was a big reason for creating @file trees!), and there are problems with clones.  See the next section.</t>
<t tx="edream.110203163054.1649">This note addresses problem 1 of my initial posting, namely that .leo files are like "binary" files as far as CVS is concerned.  That is, CVS may have problems providing intelligent diffs of .leo files.

It would be easy for Leo to write a "diff-friendly" version of a .leo file.  Call such files .cvs.leo files.  .cvs.leo files would be easy for us humans to understand.  I am thinking that people would check .cvs.leo files in and out rather than .leo files.  On checkout, one would then recreate .leo files from .cvs.leo files.  Before checkin, one would create .cvs.leo files from .leo files.

A .cvs.leo file would be a text file, but not an XML file. It would have the following format:

1. header line:  // created by leo: &lt;file name&gt;

The information found in the &lt;leo_header&gt;, &lt;globals&gt;, &lt;preferences&gt; and &lt;find_panel_settings&gt;
parts of the present .leo file format would be omitted.  Such information is not needed and will only confuse diff.

2. vnode (outline) section

Optional.  A list of headline names without status bits and without tnode indices.  It indicates the structure of the outline.

3. separator line

Optional.  It might make it easy for diff to distinguish the vnode section from the tnode section.

4. tnode (full outline) section:
	
This would be easy for humans to understand and would be like the format used in the Import/Export MORE text commands:
	
Each headline on separate line, starts with + or -.  The + or = depends only on children: the expansion state of the headline doesn't matter.  The headline is followed by body text, with escapes for + and - so that body text can never be confused with headlines.

Still unresolved is a way of specifying clones in a bullet-proof way.

Edward</t>
<t tx="edream.110203163054.1650">This note is another approach to handling some of the problems mentioned in my original post.

It may be desirable to use @cvs trees instead of @file tree.  When Leo writes a @cvs tree to a .leo file it writes only the headline of the tree; it writes none of the headlines below the @cvs tree and writes none of the body text of the tree.  This is suspiciously like the infamous "Archive" command, and it may be a good idea nevertheless in the context of CVS.  With @cvs, the .leo file becomes just a dummy file, so it would not be common to check .leo files in or out.

Implementing this command can be done easily.  The question is, does it make sense to do so?</t>
<t tx="edream.110203163054.1651">The more I look at Tk, the more convinced I am that Python + Tk (aka tkinter) is, by far, the best way to go with Leo.py.  I now have Open Source code for tree widgets and splitter windows, and have intensely studied how to modify that code for use in Leo.  It is clear, even at this early date, that this code will provide a very pleasant base on which to build Leo.

The tree code is based on code in IDLE, the Python IDE.  This code is simple, good and plenty fast enough. The tree code draws directly to a Tk canvas object.  The look and feel matches Windows exactly.  It would be trivial to use Mac triangle icons instead of the Windows plus and minus icons.  It would also be trivial to modify the look and feel for Linux.

The tree widget code solves several intractable problems with wxTreeCtrl.  Moving nodes becomes trivial.  Bugs in wxTreeCtrl involving editing and redrawing disappear.  Using Python/Tk code simplifies the vnode class, and having access to the vnode class simplifies and speeds up the tree widget code.  There is no SWIG overhead in calling the wxTreeCtrl code.  It will now be possible to bind keystrokes properly; this simply can not be done in wxWindows.

Actually, the tree widget code shows just how trivial the Windows native tree control is.  Of course, the Tk canvas class simplifies matters, but there are several important points here:

1. The wxTreeCtrl tree class actually does very little, and does it rather badly.
2. There is absolutely no need for C++ code (except in the Tk canvas class) to draw trees.
3. Leo can _easily_ have _complete_ control over the look and feel of tree controls.
4. I can modify in the tree code to simplify the rest of Leo, especially Leo's vnode class.

Here we have a splendid example of higher-level code being superior, in _every_ way, to lower level code.  The wxTreeCtrl code is horrendously complex, and in fact does almost nothing!

Similar remarks apply to the splitter window.  The Tk code for splitter windows is about a page long.  No code could be higher level because the Tk code describes only _what_ is to be done, not _how_ it is too be done.

Another big win comes from using the Tk text widget.  This widget is extraordinarily powerful.  The only text control that rivals it is the MacOS/Yellow Box text control.  Indeed, the Tk text widget does everything that Leo could possibly want.  One can even embed images in text!

Syntax coloring Tk text will be straightforward in Python. IDLE's syntax coloring is very fast on modern workstations.  There will be no need to use or modify the Scintilla C++ code.

In short, using Tk for Leo.py will be fast enough and will greatly increase what is possible in Leo while at the same time greatly simplifying Leo's code.  I am about to convert Leo.py from wxPython to Python + Tk.

Edward K. Ream
November 4, 2001</t>
<t tx="edream.110203163054.1652">I've known for a while that Python was interesting; I attended a Python conference last year and added Python support to Leo.  But last week I got that Python is something truly remarkable.  I wanted to convert Leo from wxWindows to wxPython, so I began work on c2py, a Python script that would help convert from C++ syntax to Python.  While doing so, I had an Aha experience.  Python is more than an incremental improvement over Smalltalk or C++ or objective-C; it is "something completely different".  The rest of this post tries to explain this difference.

Clarity: no clutter, easy prototyping
-------------------------------------

What struck me first as I converted C++ code to Python is how much less blah, blah, blah there is in Python.  No braces, no stupid semicolons and most importantly, _no declarations_.  No more pointless distinctions between const char *, char const *, char * and wxString. No more wondering whether a variable should be signed, unsigned, short or long.

Declarations add clutter, declarations are never obviously right and declarations don't prevent memory allocation tragedies.  Declarations also hinder prototyping.  In C++, if I change the type of something I much change all related declarations; this can be a huge and dangerous task.  With Python, I can change the type of an object without changing the code at all!  It's no accident that Leo's new log pane was created first in Python.

Functions returning tuples are a "minor" feature with a huge impact on code clarity.  No more passing pointers to data, no more defining (and allocating and deallocating) temporary structs to hold multiple values.

Python can't check declarations because there aren't any.  However, there is a really nifty tool called Pychecker that does many of the checks typically done by compilers.  See http://pychecker.sourceforge.net/ for details.

Power
-----

Python is much more powerful than C++, not because Python has more features, but because Python needs _less_ features.  Some examples:

1. Python does everything that the C++ Standard Template Library (STL) does, without any of the blah, blah, blah needed by STL.  No fuss, no muss, no code bloat.

2. Python's slicing mechanism is very powerful and applies to any sequence (string, list or tuple).  Python's string library does more with far less functions because slices replace many functions typically found in other string libraries.

3. Writing dict = {} creates a dictionary (hash table).  Hash tables can contain anything, including lists and other hash tables.

4. Python's special functions, like __init__, __del__, __repr__, __cmp__, etc. create an elegant way to handle any special need that might arise.

Safety
------

Before using Python I never fully realized how difficult and dangerous memory allocation is in C++.  Try doing

        aList[i:j] = list(aString)

in C.  You will write at least 10 - 20 lines of code.  Any error in this code will create a memory allocation crash or leak.

Python is fundamentally safe.  C++ is fundamentally unsafe.  When I am using Python I am free from worry and anxiety.  When I am using C++ I must be constantly "on guard."  A momentary lapse can create a hard-to-find pointer bug.  With Python, almost nothing serious can ever go wrong, so I can work late at night, or after a few beers.

And the Python debugger is always available.  If an unexpected exception occurs, the debugger/interpreter tells me just what went wrong.  I don't have to plan a debugging strategy!  Finally, wxPython recovers from exceptions, so Leo can keep right on going even after a crash!

Code Speed
----------

Python has almost all the speed of C.  Other interpretive environments such as icon and smalltalk have clarity, power and safety similar to Python.  What makes Python unique is its seamless way of making C code look like Python code.

Much of Python executes at essentially the speed of C code because most Python modules are written in C.  The overhead in calling such modules is negligible.  Moreover, if code is too slow, one can always create a C module to do the job.

In fact, Python encourages optimization by moving to _higher_ levels of expression.  For example, Leo's Open command reads an XML file.  If this command is too slow I can use Python's XML parser module.  This will speed up Leo while at the same time raising the level of the code.

Conclusions
-----------

Little of Python is completely new.  What stands out is the superb engineering judgment evident in Python's design.  Python is extremely powerful, yet small, simple and elegant.  Python allows me to express my intentions clearly and at the highest possible level.

The only hope of making Leo all it can be is to use the best possible tools.  I believe Python (possibly with tkinter) will allow me to add, at long last, the new features that Leo should have.

Edward K. Ream
October 25, 2001</t>
<t tx="edream.110203163054.1653">@nocolor

I would like to set up a system for planning, discussing and implementing major additions to Leo. Python has
PEP's (Python Enhancement Proposals). I'd like to start something similar called Leap's (Leo Enhancement
&amp; Advancement Proposals).</t>
<t tx="edream.110203163054.1654">100 Series: Leaps that apply to the Leap process itself. 

Leap 101: How to administer Leaps. 

- Assigned to nobody. 
- No formality needed yet. </t>
<t tx="edream.110203163054.1655">

- Assigned to nobody. 
- Create, plan, promote &amp; administer a gathering of Leo enthusiasts. 
- Part of the planning would be to create a date and setting for the conferences. </t>
<t tx="edream.110203163054.1656"></t>
<t tx="edream.110203163054.1657">- Project abandoned.  Prototypes largely complete.
- Assigned to EKR.
- Remove tnodes as a fundamental part of Leo. 
- Represent clones as link nodes and target nodes. 
- Create vxnodes as needed. (Some new thoughts about this are coming). 

</t>
<t tx="edream.110203163054.1658">- Project abandoned.

- Assigned to EKR.
- Sentinels are immutable, with mutable information following on separate lines. 
- We could create such a file format without Leap 201. 
- Leap 201, if implemented, will imply changes to this Leap. 

</t>
<t tx="edream.110203163054.1659">- Assigned to EKR.
- More flexible and more powerful than present hand-drawn code. 
- Ideally, it would be a path to anygui. 
- No firm commitment to this Leap: it depends on further study. 

</t>
<t tx="edream.110203163054.1660">- Assigned to EKR and Paul Paterson.

This will be released in 3.12.</t>
<t tx="edream.110203163054.1661"></t>
<t tx="edream.110203163054.1662">Produce a plugin (with related design) that allows people to share all or part of .leo files via a
central server. 

- Assigned to nobody. 
- This plugin need _not_ address itself to issues raised in Leap 302: it is a prototype for experimentation. The
initial aim of this Leap would be to produce a starting point design that would be incorporated into this Leap
for review. 

</t>
<t tx="edream.110203163054.1663">- Assigned to nobody 
- This plugin need _not_ address itself to issues raised in Leap 301: it is a prototype for experimentation. The
initial aim of this Leap would be to produce a starting point design that would be incorporated into this Leap
for review.</t>
<t tx="edream.110203163054.1664">Open Discussion

 RE: Status report: ten breakthroughs
2003-05-30 12:50  
About merging / CVS etc: 

Perhaps it helps to think about the big picture a bit, I mean about what do we really want / is practical. 

CVS is a de-facto standard on the internet for collaboration, so being compatible is highly desirable. Unfortunately CVS has a series of shortcomings, particularly for Leo. 

CVS merges on a line-by-line basis, so interdependencies of code are ignored (I think all other tools I know of do the same). Now, I believe this is ok for large sets of files, where mutiple changes to the same function or file are rare. Using CVS to merge only single Leo nodes (body text) would be rather silly though: Mostly these texts are short (a page or so) and one single function (or less). Multiple changes in such a codde snipped are likely to be interdependent, and I would rather like to look at the different texts rather than have them merged automatically. 

On the other hand, I don't mind if the versioning or merging tool at hand allows me to update any nodes I did not touch myself. So rather than CVS-like merging, I would like to see which nodes are being affected by the change, then have it done automatically for thouse nodes I don't worry about, but by hand (or interactively) for thouse I changed myself too, or for thouse I worry about, because they are related to my own changes. 

In other words, I would like to see a merge tool, that understands versions, can tell me which nodes in a Leo file have changed, remembers which changes I made myself, and gives me the choice, tree branch by tree branch, to automatically accept the changes, or screen them interactively. 

I think Leo should have such a tool built-in. 

- Josef</t>
<t tx="edream.110203163054.1665">@ Recent diary entries are in LeoPy.leo.</t>
<t tx="edream.110203163054.1666"></t>
<t tx="edream.110203163054.1667"></t>
<t tx="edream.110203163054.1668"></t>
<t tx="edream.110203163054.1669">This has been changed in Python 2.3 and it probably wasn't ever a good idea...</t>
<t tx="edream.110203163054.1670"></t>
<t tx="edream.110203163054.1671">This removes a warning new in Python 2.3.
</t>
<t tx="edream.110203163054.1672"></t>
<t tx="edream.110203163054.1673"></t>
<t tx="edream.110203163054.1674"></t>
<t tx="edream.110203163054.1675">However, no change was required to cutomizing.html.  In other words, the online description of plugins and hooks was already good.</t>
<t tx="edream.110203163054.1676"></t>
<t tx="edream.110203163054.1677">@nocolor

Put install/uninstall in base directory of distribution

Put leo-script.txt goes in ./scripts/install/leo-script.txt
</t>
<t tx="edream.110203163054.1678">The new values are:

"initial_window_height" : 600, # 7/24/03: In pixels.
"initial_window_width" :  800, # 7/24/03: In pixels.</t>
<t tx="edream.110203163054.1679"></t>
<t tx="edream.110203163054.1680"></t>
<t tx="edream.110203163054.1681"></t>
<t tx="edream.110203163054.1682"></t>
<t tx="edream.110203163054.1683">There was no way to remove a default shortcut so that no shortcut was used.

The problem:

You attempted to remove a shortcut merely by removing an entry in the shortcuts section of leoConfig.leo/.txt.  That doesn't work:  the default shortcut remained and conflicted with a new shortcut.  BTW, Leo does need defaults for when leoConfig.txt does not exist.

The workaround:

Specify in leoConfig.leo/.txt some shortcut to override the conflicting shortcuts.
The proper fixes (now on cvs):

1. Leo now sends a warning both to the console window (if any) and to the log pane when it detects a duplicate shortcut.

2. Leo now allows leoConfig.txt to remove the shortcut for a command by specifying None (case doesn't matter) as the value of the shortcut.</t>
<t tx="edream.110203163054.1684"></t>
<t tx="edream.110203163054.1685"></t>
<t tx="edream.110203163054.1686"></t>
<t tx="edream.110203163054.1687">These aren't great tests, and they do show that now exceptions are thrown in the colorizer.</t>
<t tx="edream.110203163054.1688">Also fixed some bugs (missing commas) in the list of rebol keywords.</t>
<t tx="edream.110203163054.1689"></t>
<t tx="edream.110203163054.1690">This was a most irritating bug.

The problem was in tree.OnDeactivate.  The calls to tree.endEditLabel() and tree. self.dimEditLabel() were interfering with the double-click logic.

What I did:

- Changed tree.OnDeactivate so that it only tried to deactivate the headline if the focus was previously in the tree.  Simple, effective.

- Added get_focus to leoGlobals.py.

- Removed unused frame.active and frame.activeFrame ivars.
	
- Changed set_focus so it only call widget.focus_set if there has been a real change in focus.
	- This has no effect, and could cause problems due to bad params being passed.</t>
<t tx="edream.110203163054.1691">Added openWithFileName to leoGlobals.py.

	- This allows startup code to create a frame without an existing frame.
	- frame.OpenWithFileName now just calls this global.

Changed startup code so that:

	- Only one window is ever created on startup.
	- Windows are not witdrawn when they are created.</t>
<t tx="edream.110203163054.1692">This shows Leo's nav buttons and status line.</t>
<t tx="edream.110203163054.1693"></t>
<t tx="edream.110203163054.1694">Fixed minor bugs in convertAllBlanks and convertAllTabs (reported no change when there was a change.)</t>
<t tx="edream.110203163054.1695">This constitutes a major changes to Leo's fundamental vnode code.  

v.copyTree now creates a free-standing tree that may be linked into an existing outline using any of the v.linkX routines.  This is a major simplification that was long overdue.

N.B.  Copied trees share tnodes with the original code.  It would be easy to make this optional, and at present all code expects tnodes to be shared.

N.B.  Nodes of the copied trees are _not_ joined to the original tree.  That is, the copied vnodes v do not appear in v.t.joinList.
</t>
<t tx="edream.110203163054.1696">The following commands are affected:

Convert All Blanks, Convert All Tabs, Extract, Extract Names, Extract Section.

What I did:

- Rewrote undoer.undoReplace.
	- It is not enough to call createDependents or destroyDependents.
	- 

- Called setUndoParams with oldText, newText, oldSel, newSel params.
</t>
<t tx="edream.110203163054.1697"></t>
<t tx="edream.110203163054.1698">The new code assumes nothing about when event handlers get called.</t>
<t tx="edream.110203163054.1699"></t>
<t tx="edream.110203163054.1700"></t>
<t tx="edream.110203163054.1701">- added set_focus and force_focus utilities for better tracing.
- changed drawText so it calls setNormalLabelState when v == editVnode.
	idle_redraw no longer interferes with the headline being edited.
- setNormalLabelState now selects all text and calls set_focus.
- added callers keyword param to trace.
- simplified c.insertHeadline: it no longer has to avoid redraws.</t>
<t tx="edream.110203163054.1702">This must be done to plug a major security hole.
</t>
<t tx="edream.110203163054.1703"></t>
<t tx="edream.110203163054.1704">This was pretty easy.  What I did:

- Changed getTextSelection so that it returns a tuple (insert,insert) instead of (None,None) if the selection range is empty.  This does most of the work!  However, the changeSelection code must now explicitly test to see whether start==end

- Pass an oldSel param to most calls of onBodyChanged.

- Added a newSel param to onBodyChanged and idle_body_key.

- Forced the focus to the body pane after pressing undo/redo buttons in the Spell Checker.  This makes the selection visible.</t>
<t tx="edream.110203163054.1705">Shift-Control-O was causing a crash.  Not surprising since it had no business in call OnOpenWith.

What I did:
	
- removed event param from OnOpenWith.
- Created an Open With Submenu in &lt;&lt; create the top-level file entries &gt;&gt;
	This has the effect of not allowing a shortcut for this menu.
- Use app().hasOpenWithMenu to enable or disable Open With menu.
- Removed Shift-Control-O setting in leoConfig.leo/.txt.</t>
<t tx="edream.110203163054.1706"></t>
<t tx="edream.110203163054.1707"></t>
<t tx="edream.110203163054.1708">Made this change to the Color, Compare, Font, Prefs and Spelling panels.  However, this doesn't set the focus as I would like.</t>
<t tx="edream.110203163054.1709">dict was being altered in a loop where it shouldn't be.  Changed the name of the var in the loop from dict to d.</t>
<t tx="edream.110203163054.1710">Symptom: Sometimes the "reading" messages would not appear when reading an outline.

Cause: Several event handlers are called at unpredictable times during the load process.  These may try to reset the log.

Solution:

- create app.setLog, app.lockLog and app.unlocklog methods.
- call app.lockLog before opening an outline.</t>
<t tx="edream.110203163054.1711">Changed destroyOpenWithFilesForFrame and createOpenWithTempFile so they don't loop on a list that is being modified.</t>
<t tx="edream.110203163054.1712"></t>
<t tx="edream.110203163054.1713"></t>
<t tx="edream.110203163054.1714">@color

# Commanders and subcommanders.
class Commands (baseCommands): pass
class atFile (baseAtFile): pass
class fileCommands (baseFileCommands): pass
class leoImportCommands (baseLeoImportCommands): pass
class tangleCommands (baseTangleCommands): pass

# Helper classes.
class colorizer (baseColorizer): pass
class config (baseConfig): pass
class undoer (baseUndoer): pass

# Key data classes.
class LeoFrame (baseLeoFrame): pass
class leoTree (baseLeoTree): pass
class tnode (baseTnode): pass
class vnode (baseVnode): pass

# Dialogs and other panels
class leoColorPanel (baseLeoColorPanel): pass
class leoColorNamePanel(baseLeoColorNamePanel): pass
class leoComparePanel (baseLeoComparePanel): pass
class leoCompare (baseLeoCompare): pass
class leoFontPanel (baseLeoFontPanel): pass
class leoDialog (baseLeoDialog): pass
class LeoPrefs (baseLeoPrefs): pass
</t>
<t tx="edream.110203163054.1715">- Made functions into class methods.
- Make sure to close pipes after every command.
- Rewrite local dictionary in alph order.
</t>
<t tx="edream.110203163054.1716"></t>
<t tx="edream.110203163054.1717">At present setup.py must be run from the top level leo directory.  Hopefully this will be fixed.

Also, the linux install script won't work.
</t>
<t tx="edream.110203163054.1718">c:\prog\leoCVS\leo\src\leoAtFile.py:2791: Format string argument count (1) doesn't match arguments (2)

c:\prog\leoCVS\leo\src\leoFrame.py:976: No global (a) found

This may have been the cause of some problems with the log panel.

c:\prog\leoCVS\leo\src\leoNodes.py:1174: Parameter (encoding) not used

This may have been the cause of some "unicode" problems.</t>
<t tx="edream.110203163054.1719">The old code had no chance of working.  I think I actually understand what is happening now...</t>
<t tx="edream.110203163054.1720">The body_pane_wraps setting is used if neither of these directives is in effect.
</t>
<t tx="edream.110203163054.1721"></t>
<t tx="edream.110203163054.1722">Added code to check for errors in the table passed to createOpenWithMenuFromTable.</t>
<t tx="edream.110203163054.1723">We have to do the &lt;&lt; set removeTrailing &gt;&gt; logic when the delete key is pressed, and that wasn't happening.

The new code now remembers properly when the user deletes a trailing newline.</t>
<t tx="edream.110203163054.1724"></t>
<t tx="edream.110203163054.1725">created frame.setInitialWindowGeometry.</t>
<t tx="edream.110203163054.1726">1. Added destroy routines for all major classes

This allows most window objects to be garbage collected when a window closes.  In practice it is _very_ difficult to remove all references to all window objects.  Breaking those links "by hand" in the destroy routines is a more pragmatic approach.

The big drawback is that destroy methods must be updated when a new ivar is added to a ctor that refers to other objects.  In practice, such ivars aren't added often.

With these new routines in place Leo does, in fact, recycle most objects from windows when a window closes.  This plugs the last (relatively minor) leak in Leo.

2. Created a _general_ way of clearing all ivars of an object.

o.__dict__.clear() does the job!

3. Remvoed all destroy routines, replacing them by app.destroyAllWindowObjects().

This is a simple, effective, pragmatic approach, and it doesn't require changes when new ivars are added to ivars!</t>
<t tx="edream.110203163054.1727"></t>
<t tx="edream.110203163054.1728"></t>
<t tx="edream.110203163054.1729">These are not needed now that Python has a gc that can recover cycles.

Everything should go away because:

- app().windowList no longer points to a frame.
- frame.top.destroy() eliminates all the Tk pointers.</t>
<t tx="edream.110203163054.1730">I did the following:

- Searched for use_gnx, using_gnx, use_pre_4pt0_file_formats.
- Removed all 4.0 constants from &lt;&lt; atFile constants &gt;&gt;
- Removed the setting corresponding to use_pre_4pt0_file_formats config ivar.

As I was doing this I moved routines and code snippets into the Abandoned Code from 4.0 node.

This is a major step forward for Leo!  The code base is mostly back to 3.10 days, with some improvements to vnodes and tnodes.</t>
<t tx="edream.110203163054.1731"></t>
<t tx="edream.110203163054.1732"></t>
<t tx="edream.110203163054.1733">Fractions cause problems in some locales.  The height/width params weren't used anyway!
</t>
<t tx="edream.110203163054.1734">This was all that was needed to correct the problem with new windows.</t>
<t tx="edream.110203163054.1735">- Added self.widgets list and associated logic in deleteBindings.

We can't rely on the Tk.Widget to delete the associated Python objects!

- Added printGarbage routine to leoGlobals.py.</t>
<t tx="edream.110203163054.1736">This is significant for two reasons:

1.  It shows how to reduce the number of Tk widgets allocated to a constant (linear in size of the canvas).

2.  It shows that incremental drawing could be used with vxnodes.

This code took a lot of work.  Issues involving the scrollbar resulted in a two-pass drawing algorithm.  The first pass populates the canvas.  The second pass sets the visible area properly after the scrollbar is set properly.

The visual appearance of scrolling appears identical, regardless of whether incremental allocation is used.  This is an important result.

To enable incremental allocation of Tk widgets during redraws, set self.allocateOnlyVisibleNodes = true in tree.__init__.

Pros:
	
- substantially reduces the number of Tk widgets that get allocated.

Cons:
	
- More complex code (it appears solid)
- A two-pass screen redrawing algorithm (it appears fast enough)
- Not all nodes become visible immediately when sliding the scrollbar.
	This is mostly likely because the actual redrawing of the screen happens at idle time.</t>
<t tx="edream.110203163054.1737">The new code is simple, elegant, efficient, flexible.  A good day.</t>
<t tx="edream.110203163054.1738">Here are the results from running checkClones2Links script on this file:

multipleTargetsInDerivedFiles: 8

(fixed) class nodeIndices      (improperly duplicated in leoAtFile.py)
(fixed) frame.OpenWithFileName (improperly duplicated in Recent Files submenu)
(fixed) recentButtonCallback   (improperly duplicated in Mark/Goto submenu)

-- Used several times in same derived file.  Will this be valid in LeoN?

&lt;&lt; Append any unused text to the parent's body text &gt;&gt; (used several times in leoImport.py)
&lt;&lt; Check both parts for @ comment conventions &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Compare single characters &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Set the default directory &gt;&gt; (used several times in leoAtFile.py)

-- Used (properly) in two different derived files:

replacePatterns (used on purpose in setup.py and postSetup.py)

clonedAtFileNodes: 9

@file ../plugins/add_directives.py
@file ../plugins/french_fm.py
@file ../plugins/open_with.py
@file ../plugins/vim.py
@file ../plugins/xemacs.py
@file c:\prog\test\multiple.txt
@file-nosent nosentCloneTest.txt
@silentfile ../doc/PKG-INFO.TXT
@silentfile ../doc/README.TXT
</t>
<t tx="edream.110203163054.1739"></t>
<t tx="edream.110203163054.1740"></t>
<t tx="edream.110203163054.1741">This code is extremely dangerous at present.</t>
<t tx="edream.110203163054.1742"></t>
<t tx="edream.110203163054.1743"></t>
<t tx="edream.110203163054.1744"></t>
<t tx="edream.110203163054.1745"></t>
<t tx="edream.110203163054.1746"></t>
<t tx="edream.110203163054.1747">This completely eliminates namespace polution and also simplifies tree.select.</t>
<t tx="edream.110203163054.1748">Nav plugin now warns if icons do not exist.

Leo now destroys the Recent Nodes dialog when user hit the close button at the top of the window.

Leo updates the Recent Nodes panel only if it is visible.</t>
<t tx="edream.110203163054.1749"></t>
<t tx="edream.110203163054.1750">Created new nav_buttons plugin.  This plugin adds 4 new buttons to the icon area at the top of each Leo window:

- Back and Forward arrows that work like a typical web browser.  Clicking the back arrow button takes you to the last node in the tree you visited.  Clicking the forward arrow button moves you forward.  The forward arrow button is dimmed unless you have clicked the back arrow button recently.

- The Recent button opens a non-modal dialog showing all the nodes you have visited recently.  This dialog is updated cleanly by the tree.select method.  You will see this entries change dynamically.  There are buttons in this dialog for clearing individual entries or clearing all entries.  Double-clicking any entry in this dialog takes you to that node, as does clicking the Go button.

The entries in the Recent Nodes pane do _not_ correspond to the order implied by the Forward and Back arrows.  Rather, the most recently visited node is on top, followed by the next most recently visited node, and so on, with the additional feature that nodes appear only once in the list.

- The Marks button opens a non-modal dialog showing all marked nodes in the tree.  Marking or unmarking nodes in the tree adds or deletes entries from this dialog.  Double-clicking any entry in this dialog takes you to that node, as does clicking the Go button.

I think the Marks dialog will be more useful for most people, for the following reasons:
1. You get to choose the nodes that appear in the dialog (using the Mark and Unmark commands)
2. The nodes appear in outline order.

In addition, hypertext links now enabled by default.  Control-click any section reference to go to its definition.  I changed the colorer so that it does _not_ underline active hyperlinks in section reference.  If a section reference is underlined, it means the definition does _not_ exist.  Otherwise the section reference _does_ exist and control-clicking the reference takes you to the defining node in one of its descendents.

Still to do: extending the color_markup plugin so that it underlines hypertext links in comments, """ python strings and doc parts.

It was great fun doing this project: plugins rule!  However, I am not really convinced that these dialogs are actually going to get used all that much.  For me, gathering nodes together using clones is by far the best way to make sense of a complex project.

Anyway, the code looks robust and fairly complete.  I have no plans for any more hacking, though all sorts of additions are fairly obvious, including more buttons in the Marks window. 

What I did:

leoColor.py

- Hypertext links now enabled by default.  Control-click any section reference to go to its definition.

- Leo no longer underlines active hypertext links. 

- To do: http hypertext links in color_markup plugin?

leoCommands.py

- Added c.beadList &amp; c.beadPointer to implement browser-style forward and back buttons.  Adding these ivars to the commands class is reasonable because the Forward &amp; Back commands are now official Leo commands.

The logic for the Forward &amp; Back commands is similar to the "bead" scheme used by undo.  However, it is completely separate.  In particular, these commands are careful to check that a node actually exists in the present tree before going to it!  And the Recent Nodes dialog removes nodes that do not presently exist using the v.exists method.

- Added optional updateBeadList param to c.selectVnode.  This adds flexibility to how the Forward &amp; Back commands work: I'm not sure that Leo uses this flexibility at present.

leoDialog.py

Added three new classes to support Recent nodes and Marks listboxes: class listBoxDialog and two derived classes:
	
- class recentSectionsDialog (listBoxDialog):
- class marksDialog (listBoxDialog):

leoFrame.py

- Initialized bead logic in frame.__init__.  This is a kludge.  Beads should be a separate class.

- Added support for existing graphics to addIconButton. (different names for keyword args).

- Added Go Back and Go Forward commands (and related logic) renaming the old commands to Go To Prev Node and Go To Next Node.

leoNodes.py

- Added exists method.  This method is used to check (quickly!) whether v is in c's tree.  We need this logic because undo may have altered nodes that appear on the bead list.

leoTree.py

- Added support for Forward &amp; Back commands to tree.select after select2 hook.

- Added select3 so that plugins can call their own code following this new code.</t>
<t tx="edream.110203163054.1751">Apparaently the zfill string method was added in Python 2.2.2.</t>
<t tx="edream.110203163054.1752"></t>
<t tx="edream.110203163054.1753">@color

I am uneasy about the security implications of having Leo execute script x if it is passed a "script:x" parameter.  Perhaps I am being over-cautious.

Anyway, there is no need for this machinery.  To create reference file for unit testing call leoUnitTest.createReferenceFiles in the old copy of Leo.  This only needs to be done once.

@color

if 0: # Just run this from the reference copy of Leo.
	import leoUnitTest
	leoUnitTest.createReferenceFiles()

if 0: # Not needed.  It does work, though.

	from leoGlobals import *
	import os

	os.spawnl(os.P_NOWAIT,"c:/python22/python.exe",
		"-i c:/prog/leoCVS/leo/src/leo.py",
		"script:leoUnitTest,createReferenceFiles")</t>
<t tx="edream.110203163054.1754"></t>
<t tx="edream.110203163054.1755">Using an idle hooks completely simplifies the code, and it means that Leo never slows down to update the area.</t>
<t tx="edream.110203163054.1756"></t>
<t tx="edream.110203163054.1757"></t>
<t tx="edream.110203163054.1758"></t>
<t tx="edream.110203163054.1759">Removed the ancient kludge for forcing the height &amp; width of f.  The code in leoFileCommands.getGlobals now works!

The reason that Leo was opening small windows without the height &amp; width params is that getGlobals was telling it to do so!

Changed leoConfig.leo/.txt to use 75 and 200 for the initial height and width.</t>
<t tx="edream.110203163054.1760"></t>
<t tx="edream.110203163054.1761">I replaced all the ivars with a dict and several lists.  This is much more clean.  However, the same idea isn't so good for the commands class: using individual ivars is much simpler.  Similar remarks apply to the Prefs panel.</t>
<t tx="edream.110203163054.1762">destroyIconFrame
createIconFrame
insertButtonInIconFrame</t>
<t tx="edream.110203163054.1763">This affect the Write Missing @file Nodes command.</t>
<t tx="edream.110203163054.1764"></t>
<t tx="edream.110203163054.1765"></t>
<t tx="edream.110203163054.1766"></t>
<t tx="edream.110203163054.1767">The new code uses three passes in colorizeAnyLanguage!

Pass 0:  The normal code.

insertWiki picture sets colorer.redoColoring = true if it is ever called in pass 0.  This ensures that the following two passes will be called.  If the body contains no images, the new code is equivalent to the old.

Pass 1:  Insert graphics into the body text.

We do this in a separate pass to simplify the following kludge.

Pass 2:  Insert dummy characters and recolor the text.

Images take up a real index, yet the get routine does not return any character for them!  We insert dummy blanks in s at the positions corresponding to each image to keep everything in synch.  We then recolor the line normally.

This three-pass algorithm appears to be robust.  In particular, it handles the following special cases:

- The user can invalidate an image name, requiring a full redraw.

- The user can delete an image itself, leaving the markup unchanged.  The image will reappear the next time Leo does a full redraw.

- An image may appear twice in the body text.

- The user may edit any line not containing a graphic without invoking passes 1 and 2.</t>
<t tx="edream.110203163054.1768">	- Fixed bug: continued """ weren't colored properly when @markup wiki not in effect!

</t>
<t tx="edream.110203163054.1769">There is now only a single entry point into Leo: the run() routine.

This routine uses an optional fileName arg.</t>
<t tx="edream.110203163054.1770">- This supports the @markup wiki directive.

- It can add arbitrarily many directives.</t>
<t tx="edream.110203163054.1771">Not yet: user directives for leoAtFile.py or leoTangle.py.</t>
<t tx="edream.110203163054.1772">Created "init-color-markup" hook for use of markup plugins.

This allows the colorizer to completely recolor a node when the @markup directive changes.</t>
<t tx="edream.110203163054.1773">Continued """ weren't colored properly when @markup wiki not in effect!
</t>
<t tx="edream.110203163054.1774"></t>
<t tx="edream.110203163054.1775">1.  Leo now scans all .py files in the plugins folder when looking for plugins.

Filenames need not start with mod_, and Leo scans only the plugins folder.

2. Replaced detailed loading message with a summary of the number of files loaded &amp; examined.

3. Added importFromPath in leoGlobals.py.

This encapsulates a lot of details, and makes it unnecessary to alter sys.path.

</t>
<t tx="edream.110203163054.1776">1.  Changed handleLeoHook to doHook.

2. Changed most instances of:

  if doHook(...) == None:

to:

	if not doHook(...)

This works provided that doHook does not return a "significant" value.</t>
<t tx="edream.110203163054.1777">- Converted wiki code to a plugin.  No need for config settings!

- Added code to parse wiki stuff in doc parts and comments.</t>
<t tx="edream.110203163054.1778">Added the following stub hooks for customizing the outline pane:

	drawBox   doHook("draw-outine-box",tree=self,v=v,x=x,y=y)
	drawIcon  doHook("draw-outline-icon",tree=self,v=v,x=x,y=y)
	drawNode  doHook("draw-outline-node",tree=self,v=v,x=x,y=y)
	drawText  doHook("draw-outline-text-box",tree=self,v=v,x=x,y=y)
	drawTree  doHook("draw-sub-outline",tree=self,v=v,x=x,y=y,h=h,level=level)
	redraw    doHook("redraw-entire-outline",c=self.commands)

Conceivably it would be better for a plugin just to replace these routines.</t>
<t tx="edream.110203163054.1779">I have found this command to be highly annoying and unwanted.</t>
<t tx="edream.110203163054.1780"></t>
<t tx="edream.110203163054.1781"></t>
<t tx="edream.110203163054.1782">- Load plugins and execute hooks in alphabetical order.

- Created "new" hook.  Somewhat useful.

Created "create-optional-menus" hook: extremely useful.  The first stub hook.</t>
<t tx="edream.110203163054.1783"></t>
<t tx="edream.110203163054.1784">

Early this morning I uploaded the new 4.0 code base to cvs.  This is an important milestone in Leo's history.  I urge anyone using code on cvs to at least skim through this long posting.

1.  Code on cvs is safe and stable

AT PRESENT, the code on cvs reads and writes 3.x files just as before.   The code appears stable, which is not surprising because the new code is based on the old.  Very few changes were needed to handle the new file formats.  These changes are enabled when app().use_gnx is true. app().use_gnx is false on cvs now.

I think the present cvs code is safe and stable.  However, I _strongly_ recommend that you assume otherwise:  Please make backups of any files or folders affected by the new cvs code.

Most of the work required to read and write 4.x .leo and derived files is complete; there are only a few days work left before the transition to 4.x formats.  I do NOT recommend that you enable the new code; some file format changes are in store.  You will be warned when the transition to the new file formats happens on cvs.  This will be another major event: all sentinels will change.

2.  Code bases have merged

The code on cvs merges the 3.x and 4.x code bases.  In retrospect, I regret splitting the development.  It really didn't help.  In any event, there will be no more splits in development.

With the merged code base, one can easily imaging releasing both 3.x versions and 4.0 beta versions in parallel.  Indeed, the only difference between the two versions would be the setting of app().use_gnx.  Also note that even in the 4.0 final version you will be able to write 3.x files.  Just set use_pre_4pt0_file_formats = 1 in leoConfig.txt.

The latest cvs code assumes that leo folders contain the config, doc,  plugins, scripts and src subfolders.  The new version of the installer script, leo.nsi, found in LeoPy.leo, creates these folders.  See the diary entry for 5/12 in LeoPy.leo for a list of the changes made to support the new directory structure.

3.  Improved code base &amp; new invariant

I took the opportunity afforded by 4.0 to clean up the old code base in several important ways.  First, the new code uses proper Python lists to represent join lists.  This greatly clarifies the relevant sections of code, and may even provide a performance boost.  Secondly, tnodes now contain both headline and body text.   This change creates an important invariant:  vnodes with the same vnx's always point to tnodes with the same tnx's.  This invariant is vital to resolving conflicts properly.

4.  Prototype of graphics &amp; styled text

leoColor.py contains a prototype of code that allows wiki-style markup in body panes.  This is important work, because it tests Tk's abilities to handle styling and graphics in the highly dynamic environment that is Leo's body pane.  Some details:

- There are a few bugs left to fix, and it is clear that this prototype is a great success.  The combination of Python and Tk are easily up to the job.  The programming details are interesting, and not interesting enough to discuss here :-)  Look at the topic called (Graphics &amp; Styled Text: Wiki format) in LeoPy.leo if you are curious.

- The code that handles the wiki formatting is disabled at present on cvs.  To enable it, just change if 1: to if 0: in doWikiText.  It is quite safe to do so: the syntax colorer catches all exceptions.  The worst that can happen is that some of your text won't be colored properly.

- The present code only handles wiki markup in Python triple-quoted strings denoted by three double quotes.  Because wiki markup uses single quotes, it does not seem prudent to allow wiki formatting in ''' strings.  Still to do: allow wiki markup in doc parts and comments.  This will be easy enough.

- doWikiText at present only handles the following markup:

    __bold__,
    ''italics'' (two single quotes, not a single double quote!)
   {picture file=&lt;filename&gt;}
   ~~&lt;color specifier&gt;~~ 

To repeat: using wiki markup to denote styling and graphics is merely a prototyping expedient.  I'm not sure how to represent such information.  The great advantage of a text-based specification is that it doesn't change the rest of Leo _at all_.  In particular, I had a nice aha: we can use the Show Invisibles command to show or hide the wiki text.  When invisibles are hidden, all you see are the _effects_ of the wiki markup.  When invisibles are visible, you see the markup plus their effects.  No need for extra commands.

- rst is another alternative to wiki format.  I'll soon start another thread to discuss the pros &amp; cons.  Please don't vote here.

- Instead of the present hand-written parser, Leo should use an "official" parser for whatever markup is chosen.  However, this can wait.

5. To do

There are significant additional work to do before 4.0 final.  After 4.0 alpha 1 comes out (maybe in a week?), I plan to rewrite the code that reads .leo files.  The new code will use an xml parser (probably sax) to read .leo files rather than the present hand-written mess.  I have fairly high hopes that sax will significantly speed up the reading of .leo files themselves.  Note, however, that such tools can _not_ be used to read derived files because derived files are not xml files.

Edward</t>
<t tx="edream.110203163054.1785">This required folder-by-folder copies, so it was potentially error prone.</t>
<t tx="edream.110203163054.1786"></t>
<t tx="edream.110203163054.1787">This cleans up the list of files being read.</t>
<t tx="edream.110203163054.1788">These don't change often enough to warrant reading every time.</t>
<t tx="edream.110203163054.1789"></t>
<t tx="edream.110203163054.1790">1. Created config, doc, examples, plugins, scripts, src, test &amp; tools folders.  This really clarifies matters.

2. Removed the following files:

- nsi.leo file.  This was a duplicate of code in LeoPy.leo.  
- The following unused .bat files: bdist.bat, go.bat, help.bat, sdist.bat.
- The two resource files: leo.rc and leo.res.  These are for Delphi!

3. These changes required changes to:

- Actual code.  The following commands were affected:
	- The About Leo dialog (path to icon in dialog).
	- Tree drawing code (path to icons)
	- Open LeoDocs.leo and Open leoConfig.leo commands in help dialog.
	- Initialization in leoConfig.py.

Note: Tangle/Untangle will find tangle_done.py and untangle_done.py provided that the scripts folder is in sys.path.

- The leo.nsi script that creates leoinstall.exe.  This required considerable amount of work.

- Paths specified in @file nodes.

- All files in cvs.  The attic contains all the old files.  cvs contains new 1.1 versions of all code.  This is most unfortunate.  However, the cvs code started out with the 3.11.1 code base, so 4.0 changes will be visible.
</t>
<t tx="edream.110203163054.1791">Sometimes the reading: @file messages were not showing up during Open commands. Perhaps the are differences in the events that caused app().log to be set to None, or to be set before the Tk text widget was initialized.  Could problems with configuration show up like this?  Or maybe it was just a weird Windoze bug...

Added code to force setting of app().log in OpenWithFileName.

If this bug shows itself again I'll add print code to show the following:

- The frame associated with app().log.
- The events that set app().log to something _other than_ None.</t>
<t tx="edream.110203163054.1792"></t>
<t tx="edream.110203163054.1793">Saving LeoPy.leo generated 46740 calls to v.threadNext!

It looks like optimizing threadNext would be useful.
There seems to be no need to optimize threadBack.</t>
<t tx="edream.110203163054.1794"></t>
<t tx="edream.110203163054.1795"></t>
<t tx="edream.110203163054.1796">What I did:

- Replaced mFirstChild with mChildren.
- Partially replaced mBack and mNext fields.
- Assumed the existence of c.frame.dummyChildren array.

I abaondoned this code for the following reasons:

- The new code might be slower than the old code!

- mBack, mNext and mFirstChild will take less space than mChildren.

- Precomputing threadNext() and maybe threadBack() may be _much_ faster.</t>
<t tx="edream.110203163054.1797"></t>
<t tx="edream.110203163054.1798">In 4.0 we must have a single, global (per-outline) tnodesDict so that all joined vnodes in fact use the same tnode.

This dict must never be reinitialized!

*** N.B.: we create the sharing of the common tnode first, then create the join link later, at the end of getLeo2 or other top-level read routines.

</t>
<t tx="edream.110203163054.1799">This actually may have found one broken clone.  It certainly did find a copy of code.</t>
<t tx="edream.110203163054.1800">nodeAfterTree was being called too often.

Used same logic to delete tree after read errors that was used to delete tree when using gnx.  The old code called doDelete, and that was the cause of huge delays when there were read errors.

Removed the &lt;&lt; Handle all status bits &gt;&gt; logic from atFile.read.  There is no need for this!  The fileCommands logic sets the current node logic.</t>
<t tx="edream.110203163054.1801">Eliminated awkward dummy nodes.</t>
<t tx="edream.110203163054.1802"></t>
<t tx="edream.110203163054.1803"></t>
<t tx="edream.110203163054.1804"></t>
<t tx="edream.110203163054.1805">What I did:

- Created fileCommands.setAllJoinLinks to create or update all join links.

- The fileCommands.getLeoFile and fileCommands.readAtFileNodes now contain:

self.setAllJoinLinks(c.rootVnode())
c.initAllCloneBits()

** Removed the code equivalent to setAllJoinLinks from atFile.read.

** Removed the code that scans the entire vnode tree for the current &amp; top attributes.
	The code _must_ set these without rescanning an entire derived file!

- Added atFileNodesFlag=true param to getLeoFile.

- Added partialFlag=false param to atFile.readAll.</t>
<t tx="edream.110203163054.1806">More checks would be good.</t>
<t tx="edream.110203163054.1807">This was easy to do because most code uses the v.headString() getter.
</t>
<t tx="edream.110203163054.1808">The first version didn't work, and caused clones not to work!

This could have caused a major mess with Leo.py, but I reverted to a previous copy and I believe no clone links have been damaged.</t>
<t tx="edream.110203163054.1809"></t>
<t tx="edream.110203163054.1810">I'm not sure how an empty filename got passed to this routine, and it did happen.</t>
<t tx="edream.110203163054.1811">See the (Rewriting joinList code) project for full details.

Examining the code revealed that the undoReplace code does not work.  This is a long-standing bug!

</t>
<t tx="edream.110203163054.1812"></t>
<t tx="edream.110203163054.1813">Leo was using the defaultID when creating new gnx's.  We must always use app().userID when creating new gnx's!

- Added userID ivar to node indices class.
- Removed the id arg to getNewIndex.</t>
<t tx="edream.110203163054.1814">We do this to discourage users from messing with such lines.

Leo writes bogus @space "sentinels" following @+v and @+t sentinels, and readLinesToNextSentinel looks for such lines while scanning without calling sentinelKind.

Perhaps readLinesToNextSentinel should be called readLinesToNextRealSentinel ;-)</t>
<t tx="edream.110203163054.1815"></t>
<t tx="edream.110203163054.1816"></t>
<t tx="edream.110203163054.1817">What I did:

- created nodeIndices.setTimestamp() routine.

This sets the new timeString ivar.  This saves a large number of calls to time.strftime.
All write routines should call setTimestamp once.

- created assignAllGnx method.  The compact/AssignFileIndices methods call this if use_gnx is true.

This ensures that all fileCommands write code assigns gnx's.

Also, Leo doesn't needlessly compute file indices when use_gnx is true.

- Assert's will fail in the fileCommands write code if we try to write a node without a gnx.

- The atFile.write code allocates t.gnx if needed.

This may be needed for the Write @file Nodes command.</t>
<t tx="edream.110203163054.1818"></t>
<t tx="edream.110203163054.1819"></t>
<t tx="edream.110203163054.1820">I left in the commented out code that reads these fields, just in case we come across old .leo files with them in.  This code should be removed completely soon.

What I did:

For reading/writing .leo files:

- Removed gnx arg from createChild.
- Removed the code that allocates v.gnx.
- Removed the code that reads and writes the vnx= field.
- Removed v.getGnx

For reading/writing derived files:

- Removed the code that reads the gnx field in @+v sentinel lines.
- Called putSentinel instead of putSentinelAndGnx when writing vnodes in derived files.</t>
<t tx="edream.110203163054.1821">This should minimize any pain on Linux systems.</t>
<t tx="edream.110203163054.1822">I want to make sure that the proper read code is executed when reading _old_ .leo files when a.use_gnx is true.

I checked to make sure that node indices are resolved properly in all cases.  They are because self.tnodesDict is used regardless of a.use_gnx.

I also did a search on .use_gnx and in all cases the code will handle old .leo files even when use_gnx is true.</t>
<t tx="edream.110203163054.1823">This makes the code clearer and cleaner.  I wrote getT before knowing about dict.get.</t>
<t tx="edream.110203163054.1824"></t>
<t tx="edream.110203163054.1825">This is far simpler than trying to figure out whether to allocate them beforehand.

Added code to do this when writing both .leo files and derived files.
</t>
<t tx="edream.110203163054.1826"></t>
<t tx="edream.110203163054.1827">The read code handles both txn and t attributes for compatibility wity old files.</t>
<t tx="edream.110203163054.1828">We want to be specific because v elements will have both vnx and tnx fields.  The tnx field is about to replace the old tx field.</t>
<t tx="edream.110203163054.1829">It sets app().use_gnx = false.</t>
<t tx="edream.110203163054.1830"></t>
<t tx="edream.110203163054.1831">This was a vain attempt to speed up the code.  Apparently the problem is elsewhere.  However, the new code is much simpler, so I'll stay with it.</t>
<t tx="edream.110203163054.1832">This substantially reduces the size and clutter of .leo files.</t>
<t tx="edream.110203163054.1833"></t>
<t tx="edream.110203163054.1834"></t>
<t tx="edream.110203163054.1835"></t>
<t tx="edream.110203163054.1836"></t>
<t tx="edream.110203163054.1837">This should be false if you plan to upload changes to Leo's cvs site.</t>
<t tx="edream.110203163054.1838">This command is needed, I think, so that people can continue to use older versions of Leo.</t>
<t tx="edream.110203163054.1839"></t>
<t tx="edream.110203163054.1840"></t>
<t tx="edream.110203163054.1841">This is required to be able to recognize shared nodes.
</t>
<t tx="edream.110203163054.1842">The nodes are created by default, and we must be very careful to share tnodes properly.

The present code probably does this, but we must be ever vigilant.</t>
<t tx="edream.110203163054.1843"></t>
<t tx="edream.110203163054.1844"></t>
<t tx="edream.110203163054.1845">List comprehensions are present in Python 2.0 or above.</t>
<t tx="edream.110203163054.1846"></t>
<t tx="edream.110203163054.1847"></t>
<t tx="edream.110203163054.1848"></t>
<t tx="edream.110203163054.1849">Fixed bug in handleLinesFollowingSentinel:
c:\prog\LeoCVS\leo\leoAtFile.py:482: No global (i) found
Removed i arg from rfind.

Fixed bug in definition of BadLeoFile:
c:\prog\LeoCVS\leo\leoFileCommands.py:27: Base class (exceptions.Exception) __init__() not called
Added call to Exception.__init__(self,message)

Fixed bug in askYesNoCancel
c:\prog\LeoCVS\leo\leoDialog.py:283: Variable (no) used before being set.
Disabled defaultButton logic.  New code would have to be thoroughly tested.

Removing unused routine: setDefaultLoc.
c:\prog\LeoCVS\leo\leoNodes.py:2581: No class attribute (defaultLoc) found

Fixed bug in put: changed a to app()
c:\prog\leoCvs\leo\leoFrame.py:4973: No global (a) found
</t>
<t tx="edream.110203163054.1850"></t>
<t tx="edream.110203163054.1851">@nocolor

I have just uploaded code to cvs that supports a new @lineending directive.  This directive allows you to specify the line endings for individual derived files.  This directive will override the output_newline setting in leoConfig.txt.  Note that @lineending _never_ affects the line endings in .leo files themselves:  we must have consistent line endings in .leo files!  See below for more details.

More importantly, I have "cleaned up" the code in the vital tangle.scanAllDirectives, atFile.scanAllDirectives and the scanDirectives global function by factoring out code to global helper functions.  Normally this should have been done at the start of a release cycle, not at the end, but I got carried away :-)

So please test this new code by writing all your files with the Write @file Nodes command and the Tangle all command.

I'll delay 3.11 final just a little longer to make sure I haven't done something really stupid, though I have reviewed the cvs change logs carefully (and found a few minor mistakes in the process).  I promise this will be the last changes to 3.11 (except for bug fixes) before 3.11 final finally goes out the door.

Anyway, the valid forms of the new @lineending directive are:

@lineending nl         (the default, Linux)
@lineending cr         (Mac)
@lineending crlf       (Windows)
@lineending lf          (same as nl, not recommended)
@lineending platform (same as platform value for output_newline setting in leoConfig.txt)

Edward</t>
<t tx="edream.110203163054.1852">These utilities simplify and regularize scanning for the @encoding, @lineending, @pagewidth and @tabwidth directives for atFile.scanAllDirectives, tangle.scanAllDirectives and scanDirectives.

This is a partial solution for the problem of duplicated code in these routines.</t>
<t tx="edream.110203163054.1853">skip_long was throwing an exception if there were no valid digits following a + or - sign.</t>
<t tx="edream.110203163054.1854">- Enabled ok button only if 4 or more characters.
- Message now says that 4 or more characters are required.</t>
<t tx="edream.110203163054.1855">Browsing the comp.lang.python yesturday I found that there are serious problems with Python's getdefaultlocale() routine.  Martin v. Lwis says "getdefaultlocale() is broken, and cannot be fixed", though he does suggest the following workaround:

leoGlobals.py uses locale.getpreferredencoding to define getpreferredencoding if locale.getpreferredencoding exists (it is new in Python 2.3alpha).  Otherwise, Leo uses the code copied from the 2.3a2 version of Python to define getpreferredencoding.  Either way, leoGlobals.py now defines getpreferredencoding and Leo uses getpreferredencoding rather than getdefaultlocale.</t>
<t tx="edream.110203163054.1856">This adds http:\\ to url's if needed.</t>
<t tx="edream.110203163054.1857">I had completely misunderstood __del__ methods!  __del__ methods _disable_ the gc's ability to collect circular garbage (!!) and so __del__ methods will _never_ be called (!!)

BTW, when deleting an entire Leo window Leo calls various destroy methods to unlink items.  This allows the garbage collector to collect all data structures.  Because of unlimited undo only these destroy methods have the potential for creating "real" garbage.</t>
<t tx="edream.110203163054.1858"></t>
<t tx="edream.110203163054.1859"></t>
<t tx="edream.110203163054.1860"></t>
<t tx="edream.110203163054.1861">- tangle.scanAllDirectives was not setting self.encoding when handling @encoding.
- tangle.scanAllDirectives wasn't scanning the @encoding line properly.
- fixed crashers in Tangle and Untangle logic.</t>
<t tx="edream.110203163054.1862">After opening the Python window the call to tkFont() threw a (caught) exception on every call to frame.setTabWidth.  The fix was to add the optional root param.</t>
<t tx="edream.110203163054.1863"></t>
<t tx="edream.110203163054.1864">This makes the output look much better.  Only time will tell whether cvs likes this way...</t>
<t tx="edream.110203163054.1865">- Added comments param to handleLinesFollowingSentinel.

- Hacked readLinesToNextSentinel so it accepts the first line even if it looks like a sentinel.
  This won't handle all cvs conflicts perfectly, but perfection isn't possible anyway...</t>
<t tx="edream.110203163054.1866">- wrote readLinesToNextSentinel and handleLinesFollowingSentinel.
- added optional nextLine param to scanText to handle look-ahead.</t>
<t tx="edream.110203163054.1867">I spent several days on a false start. My first try was to create a new version
of scanText called scanGnxText. This dispatched routines to handle 4.x
sentinels. There were several big problems with this approach:

- Much of scanGnxText was identical to scanText.

- Using separate routines to do the work meant that ivars had to be used for
communication between the routines rather than the local vars.

- Instead of using recursion to handle nested sentinels, scanGnxText had to
manage explicit stacks. This was so ugly...

This morning I threw in the towel. Rather than do all this extra work in the
name of "elegance" I simply added a few new cases to the old scanText. The
result is that all the old code works exactly as before, and the new code gets
to use the old tested code.

While I was at it, I made the following changes:

- Renumbered the constants in leoAtFile. Some of these numbers were duplicates,
which might have caused problems, though apparently it did not.

- Removed the "implicit child index" logic from scanText. This was never used.

BTW, the write logic always used the old logic as a starting point. The present
4.0 write code was up and running in a couple of hours.

Other notes:

- Setting app().use_gnx to true enables two commands in the Read/Write menu
that test the new code. I don't recommend doing this: there are plenty of
problems yet... app().use_gnx will be false for all 3.x releases.

- The present code uses id(v) as a dummy global node index (gnx). This will be
changed very soon.

- Still to do: the code in leoFileCommands to read and write "mark" elements.
This isn't essential, and without this no marks will be remembered in derived
files. I must also handle the process of telling Leo the user's cvs id. This
will probably involve reading leoId.txt.</t>
<t tx="edream.110203163054.1868"></t>
<t tx="edream.110203163054.1869">I had forgotten to compile leo.nsi.</t>
<t tx="edream.110203163054.1870">The children of this node are a test of this.</t>
<t tx="edream.110203163054.1871"></t>
<t tx="edream.110203163054.1872"></t>
<t tx="edream.110203163054.1873"></t>
<t tx="edream.110203163054.1874"></t>
<t tx="edream.110203163054.1875"></t>
<t tx="edream.110203163054.1876"></t>
<t tx="edream.110203163054.1877"></t>
<t tx="edream.110203163054.1878"></t>
<t tx="edream.110203163054.1879"></t>
<t tx="edream.110203163054.1880"></t>
<t tx="edream.110203163054.1881"></t>
<t tx="edream.110203163054.1882"></t>
<t tx="edream.110203163054.1883"></t>
<t tx="edream.110203163054.1884"></t>
<t tx="edream.110203163054.1885"></t>
<t tx="edream.110203163054.1886"></t>
<t tx="edream.110203163054.1887"></t>
<t tx="edream.110203163054.1888"></t>
<t tx="edream.110203163054.1889">Changed redraw_now to force_redraw in tree select routines.</t>
<t tx="edream.110203163054.1890"></t>
<t tx="edream.110203163054.1891"></t>
<t tx="edream.110203163054.1892">This allows time to be expressed as local time or gmttime.</t>
<t tx="edream.110203163054.1893"></t>
<t tx="edream.110203163054.1894"></t>
<t tx="edream.110203163054.1895"></t>
<t tx="edream.110203163054.1896"></t>
<t tx="edream.110203163054.1897"></t>
<t tx="edream.110203163054.1898">These were long-standing bugs.</t>
<t tx="edream.110203163054.1899"></t>
<t tx="edream.110203163054.1900"></t>
<t tx="edream.110203163054.1901">This makes the file name easier to see in the Windows task bar.
</t>
<t tx="edream.110203163054.1902">This fixes several bugs.</t>
<t tx="edream.110203163054.1903"></t>
<t tx="edream.110203163054.1904">Every call to v.unjoinNode was calling c.clearAllVistied.

Fixing this bug will allow me not to use inodes &amp; locations for the foreseeable future.</t>
<t tx="edream.110203163054.1905"></t>
<t tx="edream.110203163054.1906"></t>
<t tx="edream.110203163054.1907"></t>
<t tx="edream.110203163054.1908"></t>
<t tx="edream.110203163054.1909">scanColorDirectives now returns self.language.</t>
<t tx="edream.110203163054.1910"></t>
<t tx="edream.110203163054.1911"></t>
<t tx="edream.110203163054.1912"></t>
<t tx="edream.110203163054.1913"></t>
<t tx="edream.110203163054.1914">@nocolor

1. Put customizeLeo.py on cvs.  I don't particularly see why this file should be much more dangerous than any other file.

2. Remove the @ignore directive from the ancestor of @file customizeLeo.py.

3. Remove the warning when customizeLeo.py is written.  However, I shall _insert_ a lock that prevents customizeLeo.py from being written unless use_customize_leo_dot_py = 1 in leoConfig.txt.

Leo will write a message to the log if customizeLeo.py is dirty but was not written because of the setting in leoConfig.txt.
</t>
<t tx="edream.110203163054.1915"></t>
<t tx="edream.110203163054.1916"></t>
<t tx="edream.110203163054.1917">Simplified and regularized hooks:

- replaced "event1" and "event2" hooks with 'regular' hooks.
	* Much easier to understand.
- added "iconrclick" hooks.
- added "bodyrclick" hooks.
- added "dragging" hooks.
	* These are called when drag hook called while already dragging.
- added "hyperenter" and "hyperleave" hooks.
	* These only fire if use_hyperlinks = 1 in leoConfig.txt.
- removed "activate" and "deactivate" hooks.
	* These were not reliable.
- almost all hooks have c,v arguments now.
- "command" hooks now return "undo" and "redo" rather than "cantundo" and "cantredo"

Improved code:

- improved the tracing of hooks in customizeLeo.py.
- the tracing code also checks to make sure that most hooks have c,v keywords.
- created es_event_exception().
- put all event handlers in try/except blocks that call es_event_exception on errors.</t>
<t tx="edream.110203163054.1918">The fix was to set the hand cursor in </t>
<t tx="edream.110203163054.1919">v.OnEndDrag can be called even though tree.dragging is false.  </t>
<t tx="edream.110203163054.1920"></t>
<t tx="edream.110203163054.1921">replaced c.contractVnode by v.contract.
replaced c.expandVnode by v.expand.

This was mostly done earlier, but wasn't done completely.  Not doing so completely caused exceptions in the promote, demote and import commands.</t>
<t tx="edream.110203163054.1922"></t>
<t tx="edream.110203163054.1923">added raw=1 to all calls to config.get in leoConfig.py.</t>
<t tx="edream.110203163054.1924"></t>
<t tx="edream.110203163054.1925"></t>
<t tx="edream.110203163054.1926"></t>
<t tx="edream.110203163054.1927"></t>
<t tx="edream.110203163054.1928">This can be useful when clones are in the range of different @path directives.</t>
<t tx="edream.110203163054.1929">Dirty bits are kept in tnodes, so setting/clearing a dirty bit in a node v does the same in all nodes joined to v.

Also, made setDirtyDeleted equivalent to setDirty, which means that setAncestorsOfClonedNodesInTreeDirty is no longer used.  This is a bizarre routine:  I have no idea why it should be needed.</t>
<t tx="edream.110203163054.1930"></t>
<t tx="edream.110203163054.1931"></t>
<t tx="edream.110203163054.1932">Previously saving a new file did not result update the Recent Files menu.

Created frame.updateRecentFiles routine and called it from openWithFileName and all Save routines.</t>
<t tx="edream.110203163054.1933">In the preferences dialog the close button is now equivalent to the Cancel button.

While I was at it, I eliminated OnClosePrefsFrame.  The OnCancel routine works just fine.
</t>
<t tx="edream.110203163054.1934">There was a typo in the documentation of chapter 8, "About hooks". In the hook table the "when called" column of "headkey1" and "headkey2" says "before/after *body* keystrokes", instead of "headline keystrokes".

Fixed in LeoPy.leo, LeoDocs.leo and on the web site.</t>
<t tx="edream.110203163054.1935">These were easy to do and they may be of real help to some people in some situations.</t>
<t tx="edream.110203163054.1936">I have just uploaded a major improvement to Leo's expand/contract routines.
This came about as the result of a request by Travers A. Hough.

His comment was that it would be better to have the Expand To Level n commands
work only on the presently selected outline: "Having Expand" commands that work
only on a suboutline...would most likely be what the programmer really wanted."
Indeed, this is correct. I'm not sure why I didn't see this earlier.

As I played with the expand/contract commands it gradually became apparent that
the new way of doing things makes a number of existing or requested commands
obsolete:

1. I redefined Expand To Level 1 to mean contract the presently selected
outline. So there is no need for a Contract Present Node command (!)

2. Expand To Level 2 now does what the requested Expand Present Node command
would have done. Moreover, this command eliminates the need for the old
Contract Subheads command!

3. Expand to Level 3 now does what the old Expand Subheads command did!

4. With all these commands now gone (without sacrificing anything!) it became
possible to consolidate the Expand and Contract submenus into a single
Expand/Contract submenu. This is a pretty big win, in fact, because it shows in
one place all the shortcuts that cause expansion and contraction.

As requested, I changed the Contract All command to select the topmost ancestor
of the presently selected node if that node becomes invisible as the result of
the contraction. This eliminates what was in fact quite irritating behavior.

It is truly unusual that a feature request should spark both wholesale
simplifications and an increase in power, and that is what has happened. In
this area, I think, as perhaps in no other, Leo's way of handling outlines is
now clearly superior to how the great MORE outliner worked.</t>
<t tx="edream.110203163054.1937"></t>
<t tx="edream.110203163054.1938"></t>
<t tx="edream.110203163054.1939"></t>
<t tx="edream.110203163054.1940"></t>
<t tx="edream.110203163054.1941">In other words, the Pressing the Enter key in the Find panel executes the Find Next command.
</t>
<t tx="edream.110203163054.1942"></t>
<t tx="edream.110203163054.1943"></t>
<t tx="edream.110203163054.1944">These are just conveniences, so the user doesn't have to check for save, saveas and saveto command hooks.</t>
<t tx="edream.110203163054.1945"></t>
<t tx="edream.110203163054.1946"></t>
<t tx="edream.110203163054.1947"></t>
<t tx="edream.110203163054.1948"></t>
<t tx="edream.110203163054.1949">In the unusual case that a language has no single-line comment delimiter, Leo will remove the block delimiters from the headline text in node sentinels.  createNthChild must take this into account by doing a second comparison of headlines if the normal comparison fails.  If the second comparison of headlines succeeds we assume that we should use the headline from the outline instead of the derived file.  I believe some kind of kludge like this will also be required for 4.0.

This is kludgy, and I don't know what else to do.</t>
<t tx="edream.110203163054.1950">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1806338
By: stwerff
Open Discussion 12/23/02

There seems to be a problem to find the correct vnode when there is a double
comment given:

vnode not found in outline: exp_definitions*)

The finish comment seems to interfere with the @+node:

(*@+node:1::exp_definitions*)

Jurjen

</t>
<t tx="edream.110203163054.1951">@nocolor

I see. This is an interesting hole. This problem only arises with languages such as html that have
paired comment delims _and_ that have no single-line comment delimiter. 

The only solution seems to me to remove either just the closing comment delim or both comment
delims from the headline text of +-node sentinels. Do you agree? I'll make the change today.
</t>
<t tx="edream.110203163054.1952"></t>
<t tx="edream.110203163054.1953">leoFileCommands.put was recently changed, and the following code was accidentally omitted:

	elif self.outputString != None: # Write to a string
		self.outputString += s</t>
<t tx="edream.110203163054.1954">Re-enabled the following code in
&lt;&lt; set path to the full pathname of a temp file using ext &gt;&gt;

a.openWithFileNum += 1</t>
<t tx="edream.110203163054.1955">This allows Leo to be used with a black background.</t>
<t tx="edream.110203163054.1956">changed s.self to s,self in tangle.os.</t>
<t tx="edream.110203163054.1957">The error reporting code is still highly experimental.  In particular, encoding errors in headlines may generate many redundant messages as sentinel lines are written.

Here is what I did:

Phase I: get body text working with utf-8.
	done: accept @+leo,encoding=&lt;the_encoding&gt; when reading derived files.
	done: always use &lt;?xml version="1.0" encoding="UTF-8"&gt;
	done: Read and write .leo files using utf-8 encoding. (It's always been this way).
	done: convert body text to unicode when reading .leo files.
	done: ensure unicode in body key handler.

Phase II: get find/change working with utf-8.
	done:  don't call repr on unicode strings in es().
	done: convert from utf-8 to unicode when reading find/change params in leoConfig.txt
	done: encode unicode to utf-8 before writing find/change params in leoConfig.txt.

Phase III: support @encode.  Test with iso-8859-1 and utf-8 encodings.
	done: Colorize @encoding.
	done: Recognize @encoding in various scanDirectives routines.
	done: Add self.encoding ivars to atFile and Tangle classes.
	done: Write -encoding=x. in @+leo header
	done: Write derived files using atFile.self.encoding
	done: Use unicode for all headline text.
	done: Read derived files using atFile.self.encoding.
	done: Add leo_file_encoding to leoFileCommands class.
	done: Initialize leo_file_encoding when reading .leo file
	done: Use leo_file_encoding when reading tnode and vnode text.
	done: Use leo_file_encoding when writing tnode and vnode text.
	done: Create config.new_leo_file_encoding.
	done: Create config.default_derived_file_encoding.
	done: Use default_derived_file_encoding when writing derived files.
	done: Use new_leo_file_encoding when creating new .leo files.

Phase IV: Use unicode everywhere
	done: @encoding on import/export
	done: @encoding on tangle/untangle

Phase V: cleanup
	done: replace fnW by fn.  replace pathW by path.
	done: assert unicode type when writing derived files.
	done: remove unused unicode utilities
	done: remove or replace all instances of xml_version_string.
	done: create toUnicode and toString utils.
	done: change test+unicode to toUnicode
	done: change test+encode to toString
	done: create isValidEncoding
	- better error reporting</t>
<t tx="edream.110203163054.1958">I don't believe there is a great need for other encodings in leoConfig.txt and I don't plan to support anything but utf-8 encoding in leoConfig.txt.</t>
<t tx="edream.110203163054.1959"></t>
<t tx="edream.110203163054.1960"></t>
<t tx="edream.110203163054.1961">The fix was to set true = 1 ; false = 0 in leoGlobals.py.</t>
<t tx="edream.110203163054.1962"></t>
<t tx="edream.110203163054.1963">This corrects a hang in the Open With command.
</t>
<t tx="edream.110203163054.1964"></t>
<t tx="edream.110203163054.1965"></t>
<t tx="edream.110203163054.1966"></t>
<t tx="edream.110203163054.1967">@ Please add "event=event" to the parameter list when calling handleLeoHook() from event handlers. 

I'm trying to add a menu item to the popup menu and am trying to use "event1"
for "headPopup" to do so.

I need to replace the OnPopup method with my custom method.  But I find that
I need the event object in order to do so.  However, the calls to handleLeoHook
(in event handler methods) do not pass the event object.

It seems like a good idea to pass the event as one of the keywords for event1
and event2.</t>
<t tx="edream.110203163054.1968"></t>
<t tx="edream.110203163054.1969"></t>
<t tx="edream.110203163054.1970">It's actually working, but it's work is being undone by a previous binding.</t>
<t tx="edream.110203163054.1971"></t>
<t tx="edream.110203163054.1972">This was done in c2py.py, leoAtFile.py and leoColor.py.

I actually think this was foolish to do, regardless of how much "cleaner" the code looks.  The problem is that it is not at all easy to test.  I think this kind of thing should wait until has a full regression testing suite.</t>
<t tx="edream.110203163054.1973">What I did:

- es, trace &amp; trace_tag take a variable number of args.
- es, trace &amp; trace_tag convert to string using repr as needed.
- move init_sherlock to leoGlobals where it belongs.
- init_sherlock now takes an echo param.
- only trace_tag takes a "tracepoint" arg.</t>
<t tx="edream.110203163054.1974">redoMenuLabel and undoMenuLabel must be initialized in the ctor, _not_ in clearUndoState.
</t>
<t tx="edream.110203163054.1975">The self.oldcursor logic wasn't working reliably.
</t>
<t tx="edream.110203163054.1976"></t>
<t tx="edream.110203163054.1977">In most case the "x2" hook is always called, whether or not the "x1" hook overrides the default code.

The only time this can possibly make a difference is when the "x1" hook actually does override, so the issue of whether or not this is a good idea is almost always moot.</t>
<t tx="edream.110203163054.1978">@nocolor

The following are real problems that should be cleaned up:

c:\prog\leoCvs\leo\leoApp.py:293: Object (d) has no attribute (testDialogs)

	(done) remove app.testDialogs

c:\prog\LeoCVS\leo\leoFileCommands.py:342: No class attribute (getCollapsedOpenTag) found

	(done) change getCollapsedOpenTag to getOpenTag

c:\prog\LeoCVS\leo\leoFileCommands.py:525: Catching a non-Exception object (BadLeoFile)
c:\prog\LeoCVS\leo\leoFileCommands.py:583: Catching a non-Exception object (BadLeoFile)

	(done) derive class BadLeoFile from Execption

(done) c:\prog\LeoCVS\leo\leoUndo.py:134: No class attribute (redoMenuLabel) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:138: No class attribute (undoMenuLabel) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:320: No class attribute (commands) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:394: No class attribute (debug_print) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:423: No class attribute (new_undo) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:424: No class attribute (debug) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:430: No class attribute (old_mem) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:433: No class attribute (new_mem) found

	These arise because we refer to both self.x and u.x.
	to do: change self.x to u.x.

c:\prog\LeoCVS\leo\leoCompare.py:425: No class attribute (makeWhitespaceVisible) found

(done) changed self.makeWhitespaceVisible to cmp.makeWhitespaceVisible</t>
<t tx="edream.110203163054.1979"></t>
<t tx="edream.110203163054.1980"></t>
<t tx="edream.110203163054.1981"></t>
<t tx="edream.110203163054.1982"></t>
<t tx="edream.110203163054.1983">We must do

exec s in {}

NOT

exec s in __builtins__

Passing __builtins__ to exec is the _worst possible_ thing to do, because it pollutes the only truly global namespace FOREVER.</t>
<t tx="edream.110203163054.1984"></t>
<t tx="edream.110203163054.1985"></t>
<t tx="edream.110203163054.1986"></t>
<t tx="edream.110203163054.1987"></t>
<t tx="edream.110203163054.1988">What I did:
	
- added self.trace ivar to trace write logic.

- changed the following sections of putCodePart:

1. &lt;&lt; put the line &gt;&gt;
	Buffered characters to make tracing easier. (reduces calls to self.os)
	Don't write trailing indentation if not writing sentinels.

2. &lt;&lt; handle @others &gt;&gt;
	Skip the newline after @others if we aren't putting sentinels.
</t>
<t tx="edream.110203163054.1989">The present code properly handles undo/redo for operations that copy trees, but copying trees itself causes problems for further undoes.  I've disabled further undos, as was done previously, but this is a pity.

To fix this, we may have to hack on the beads to indicated that a copy has been made.  No doubt about it: copying trees is tricky.</t>
<t tx="edream.110203163054.1990"></t>
<t tx="edream.110203163054.1991">This bug was created recently by the new underline/realMenuName logic.  We must not set the undo/redoRealMenuName ivars in clearUndoState: that should only be done when actually setting the menu names.</t>
<t tx="edream.110203163054.1992"></t>
<t tx="edream.110203163054.1993">The fix was made to atFile.scanAllDirectives() and leoGlobals.scanDirectives()
tangle.scanAllDirectives() was not affected.

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):</t>
<t tx="edream.110203163054.1994">Completed a major revision of the menu handling code to handle underlined menus.  The new code has a chance of working with translated menus.


What I did:

- Added app()./frame.setRealMenuNamesFromTable() convenience methods.
- Use underline param to specify underlined characters in menu names.
- Translate &amp; to underline index before removing &amp;.
- Alt-E conflicts with Edit menu: changed to Alt+Shift+E
- Added f.get/setMenu (canonicalize menu names)
- Used realMenuNames for undo/redo.
- Disabled Can't Undo, Can't Redo.
</t>
<t tx="edream.110203163054.1995"></t>
<t tx="edream.110203163054.1996"></t>
<t tx="edream.110203163054.1997">The lambda functions for callbacks were not working properly.  While I was at it I simplified the code</t>
<t tx="edream.110203163054.1998">The original bug report:

"The sample code to invoke idle via "Open With" does not work if leo 
is installed in a path with a blank, for example "program files/leo". 
On windows, the pathname needs to be quoted in this case."

I did not find this to be the case.  However, there were problems with the sample Open With code in customizeLeo.py and I corrected these.
</t>
<t tx="edream.110203163054.1999">We scanning for the initial state we must make sure that i &lt; old_len and i &lt; new_len.</t>
<t tx="edream.110203163054.2000">This was reported by David LeBlanc and fixed with major hints from Chad Netzer.
</t>
<t tx="edream.110203163054.2001">Apparently the F4 shortcuts interferes with the Alt-F4 shortcut.</t>
<t tx="edream.110203163054.2002">The content formerly on evisa.com, including the Leo tutorials is now on 3dtree.com.</t>
<t tx="edream.110203163054.2003"></t>
<t tx="edream.110203163054.2004">Use keyword params instead of synonym constants.

- import
	- removed dont_indent_refs and indent_refs synonyms.

- tangle
	- removed verbose and brief synonyms to st_dump.
	- left other flags alone: they are complex.</t>
<t tx="edream.110203163054.2005"></t>
<t tx="edream.110203163054.2006"></t>
<t tx="edream.110203163054.2007">Added options for @file and @root.

The options to @root are more important (and potentially more buggy).  For the first time Leo allows you to choose whether body text in @root trees will start in code mode or doc mode by default.  Ever since I created @file trees I've regretted the choice of making doc mode the default.  Just last week I realized I'm not stuck with that old choice.

This is a little tricky, so please pay attention :-)

1. @root-doc filename and @root-code filename specify that body text is assumed to start in doc mode or code mode respectively.  The options (-doc and -code) must follow @root immediately with no intervening whitespace.  In effect, @root-code and @root-doc are two new directives.  (They aren't syntax colored yet: they will be today or tomorrow.)

2. These @root options override the new at_root_bodies_start_in_doc_mode option in leoConfig.py.  This option affects only @root trees without options.  Such "plain" @root trees are now deprecated, which only means that it is now better style to use either @root-code or @root-doc.  The reason is simple: the meaning of plain @root trees will depend on the at_root_bodies_start_in_doc_mode option, and that isn't good.

3. By default, at_root_bodies_start_in_doc_mode = 1 for compatibility for old @root trees.  I actually don't think this option is good for much; I created it before I created @root-doc and @root-code, and I decided it wouldn't hurt to leave it in.  Anyway, you now have complete flexibility about how @root works, and in particular you can make @root work just like @file.

Only minor changes were made to the Tangle and Untangle code, and the new code appears to work.  However, it has not been extensively tested.  I would like to get 3.9.1 out the door this week so the latest "official" version of Leo won't crash when PIL or tkIcon are not present.  So please report any problems with the new code immediately.</t>
<t tx="edream.110203163054.2008">Untangle was warning about a missing section if the section had only an @doc part.</t>
<t tx="edream.110203163054.2009">There is a good reason why os.path.normpath does not mess with slashes on Linux, and there is no reason to create another routine to do so.
</t>
<t tx="edream.110203163054.2010"></t>
<t tx="edream.110203163054.2011"></t>
<t tx="edream.110203163054.2012">Used .gif file so transparency info used by tkIcon code.
Rewrote tkIcon code so it doesn't try to resize the icon.
Created custom 16x16 LeoWin.gif.</t>
<t tx="edream.110203163054.2013">The code now uses the list leoConfig.ivars to generate exec statements that do the work.  This makes it possible to add ivars to leoConfig.ivars without changing code in leoConfig.py.
</t>
<t tx="edream.110203163054.2014">It might be beter if the Suboutline Only and Node Only checkboxes were Radio buttons, but then we would need yet another radio button to say "Search Entire Outline", which is a bit pedantic.

Note that Node Only takes precedence over Suboutline Only if they are both checked.</t>
<t tx="edream.110203163054.2015">This works just like the Flatten Outline command except it writes only headlines.</t>
<t tx="edream.110203163054.2036"></t>
<t tx="edream.110203163054.2037">The code that checks whether leading and trailing have been supplied must check against None.  Otherwise, a leading or trailing value of zero will cause middle_lines to be miscalculated.</t>
<t tx="edream.110203163054.2038">The commands now remember the scroll position so the screen doesn't hope around.</t>
<t tx="edream.110203163054.2039"></t>
<t tx="edream.110203163054.2040">Created the long-overdue convertUnicodeToString utility.</t>
<t tx="edream.110203163054.2041"></t>
<t tx="edream.110203163054.2042"></t>
<t tx="edream.110203163054.2043">This is called from atFile.scanAllDirectives, tangle.scanAllDirectives and utils_rename.</t>
<t tx="edream.110203163054.2044"></t>
<t tx="edream.110203163054.2045">@ test

@nocolor

@ test

@color</t>
<t tx="edream.110203163054.2046">This may or may not solve a crash under Python 2.1.</t>
<t tx="edream.110203163054.2047"></t>
<t tx="edream.110203163054.2048">Leo now ensures that u.oldText and u.newText are set to None when using the new undo scheme.  This means that Python now has a chance of reclaiming much more memory.</t>
<t tx="edream.110203163054.2049"></t>
<t tx="edream.110203163054.2050"></t>
<t tx="edream.110203163054.2051">Leo now forces a full update and redraw if there is a mismatch between the expected value and the result calculated from the Tk.Text widget.  This is safe, and won't happen often.</t>
<t tx="edream.110203163054.2052">This was making it impossible to specify trailing newlines.  It also seems to have helped undo.</t>
<t tx="edream.110203163054.2053"></t>
<t tx="edream.110203163054.2054"></t>
<t tx="edream.110203163054.2055"></t>
<t tx="edream.110203163054.2056"></t>
<t tx="edream.110203163054.2057"></t>
<t tx="edream.110203163054.2058"></t>
<t tx="edream.110203163054.2059">We can't use after_idle because that completely overloads the system.  On my machine a delay of 500-1000 msec between calls would be sufficient to handle most "periodic" tasks.</t>
<t tx="edream.110203163054.2060">It's not perfect, and it will do for now.</t>
<t tx="edream.110203163054.2061"></t>
<t tx="edream.110203163054.2062"></t>
<t tx="edream.110203163054.2063">Noweb section refs and defs _are_ valid in cweb mode!
Allow LaTex coloring in cweb @space, @* and @** doc parts.</t>
<t tx="edream.110203163054.2064"></t>
<t tx="edream.110203163054.2065">Cweb prefs panel setting was overriding @language python (!)</t>
<t tx="edream.110203163054.2066"></t>
<t tx="edream.110203163054.2067">This makes it much easier to pass parameters to hooks.
</t>
<t tx="edream.110203163054.2068"></t>
<t tx="edream.110203163054.2069"></t>
<t tx="edream.110203163054.2070"></t>
<t tx="edream.110203163054.2071">@language pascal
@color

private
uses</t>
<t tx="edream.110203163054.2072"></t>
<t tx="edream.110203163054.2073">We can only suppress redraws in undo/redo under very special conditions, namely that we are undoing typing in the same node.

The recent code will leave the screen in the wrong state!</t>
<t tx="edream.110203163054.2074"></t>
<t tx="edream.110203163054.2075">Eliminated the self.delim ivar.  This can't be set correctly when coloring incrementally.

Realized that full, non-incremental coloring must _always_ be done when switching nodes.  Even if we move from one cloned node to another, the context can be different:  different @color, @nocolor, @language and @comment directives may be in effect.

Used incremental syntax coloring when undoing.  This speed up undo tremendously.</t>
<t tx="edream.110203163054.2076"></t>
<t tx="edream.110203163054.2077"></t>
<t tx="edream.110203163054.2078"></t>
<t tx="edream.110203163054.2079"></t>
<t tx="edream.110203163054.2080">The principle is this: people should see the scripts they are executed.
</t>
<t tx="edream.110203163054.2081"></t>
<t tx="edream.110203163054.2082"></t>
<t tx="edream.110203163054.2083"></t>
<t tx="edream.110203163054.2084"></t>
<t tx="edream.110203163054.2085"></t>
<t tx="edream.110203163054.2086"></t>
<t tx="edream.110203163054.2087">@color

@ See the actual code in the child node for complete notes.</t>
<t tx="edream.110203163054.2088">@ frame.doCommand and frame.OnMenuClick now set app.log, so top() will be reliable after any command is executed.

Note 1: The value of top() may change during a new or open command, which may change the routine used to execute the "command1" and "command2" hooks.  This is not a bug, and hook routines must be aware of this fact.
@c

def top():
	
	"""Return the commander of the topmost window"""
	
	# Warning: may be called during startup or shutdown when nothing exists.
	try:
		return app.log.commands
	except:
		return None</t>
<t tx="edream.110203163054.2089"></t>
<t tx="edream.110203163054.2090"></t>
<t tx="edream.110203163054.2091">The old code jumped through hoops not to duplicate code.  The new code just uses a new doAtKeyword routine.</t>
<t tx="edream.110203163054.2092">The key invarient:  frame.menus contains _untranslated_ names.  The translated names are used only in the label param to the Tk.menu routines.</t>
<t tx="edream.110203163054.2093">The menu hooks make it easy to customize menus.

The open hooks make it easy to perform custom actions when opening already-existing files.</t>
<t tx="edream.110203163054.2094">Finished convenience routines.

Used createNewMenu to create Leo's menus.</t>
<t tx="edream.110203163054.2095"></t>
<t tx="edream.110203163054.2096">This will allow users to create new menus without creating new ivars, an important generalization.

self.menus["top"] represents the top-level menu.  All other menus are represented by their menu name.</t>
<t tx="edream.110203163054.2097">This is long overdue:

- put the entire command in a try: except: block.
- eliminates the need for return "break"
- provides the natural place for hooks.

It was quite easy now that we have createMenuEntries.</t>
<t tx="edream.110203163054.2098">At present, only the start1, start2 and end1 hooks are handled, and many more could be added easily.</t>
<t tx="edream.110203163054.2099"></t>
<t tx="edream.110203163054.2100"></t>
<t tx="edream.110203163054.2101"></t>
<t tx="edream.110203163054.2102"></t>
<t tx="edream.110203163054.2103">This was almost too easy :-)</t>
<t tx="edream.110203163054.2104"></t>
<t tx="edream.110203163054.2105">Leo no longer massages comments when importing Java files.

There was a bug in massageBody that prevented text from being undented properly.  There was a bug in find_line_start (!!) that caused the start of the _previous_ line to be found if s[i] was a newline.  It's amazing that these bugs were undiscovered for so long.

Treat interface like class.</t>
<t tx="edream.110203163054.2106">It was moving past the present line if the s[i] was a newline.

This caused problems in the Java scanner, and could also cause problems in other places.</t>
<t tx="edream.110203163054.2107"></t>
<t tx="edream.110203163054.2108">The trailing @ in @q@ "doubles" the first @ in a sentinel, so putSentinel should not do this, and sentinelKind needs no special code to test for sentinels.

The tcweb.py script tests cweb files.  Invoke as follows:

python tcweb.py file1 file2...</t>
<t tx="edream.110203163054.2109">@ What I did:
	
- Changed g to geom or glob.
- Removed print_stack.
- Moved alert, handleLeoHook &amp; unloadAll to leoUtils.
- Moved all leoUtils routines into leoGlobals.py.
- Removed all instances of "from leoUtils import *"
- Removed "script functions" from leo.py: getCommands, topCommands, topCommand.
	These are no longer used anywhere in the code.
- Made the prolog_xxx constants ivars of leoApp.
- Made language_delims_dict and language_extension_dict ivars of leoApp.

I have decided to leave the present scheme pretty much in place,
except to move the variables in leoGlobals.py to leoApp.py.

This will allow us to say the following:
	
1. any function f() is defined in leoGlobals.py.
2. any variable v not of the form x.f is a local variable.


</t>
<t tx="edream.110203163054.2110"></t>
<t tx="edream.110203163054.2111"></t>
<t tx="edream.110203163054.2112">We must double _all_ @ signs following the @q@, so, e.g., a @@color sentinel gets turned into @q@@@@@color@&gt;.

This is easy to do in putSentinel, but a bit harder to undo:

1. sentinelKind locally adjusts the string in cweb mode.
2. skipSentinelStart skips both @@ signs in cweb mode.
3. All sections in scanText that deal with variable text must change @@ to @ within that text.</t>
<t tx="edream.110203163054.2113"></t>
<t tx="edream.110203163054.2114">Only rarely does a routine as elegant as wrap_lines come along.</t>
<t tx="edream.110203163054.2115"></t>
<t tx="edream.110203163054.2116"></t>
<t tx="edream.110203163054.2117"></t>
<t tx="edream.110203163054.2118"></t>
<t tx="edream.110203163054.2119"></t>
<t tx="edream.110203163054.2120">Added return "break" to body and headline key handlers.
Added unreachable return 0 to end of findMatchingBracket.</t>
<t tx="edream.110203163054.2121">@nocolor

This is miserable code to get just right because there are so many paths through the code.  In addition, making informative error messages is a bit tricky too.

Changes made:

1. Removed unhelpful warnings about non-existent paths.  Only errors are given now.
2. Added logic to set self.root_name if it has not already been set.  Without this, it is impossible to test for relative filenames in @root directives, and errors happen only after tangling is complete, which is quite confusing.
3. Added error messages when a "computed" file name does not exist.
4. Removed unused self.default_directory ivar from leoTangle.py.
5. Set self.tangle_directory ivar to base directory when @root node specifies a relative directory.  This is required so the later code will try to create the proper file.
6. Renamed the path_directive_creates_directories option to create_nonexistent_directories.  This makes clearer what is going on.
</t>
<t tx="edream.110203163054.2122">The old name was too misleading.</t>
<t tx="edream.110203163054.2123"></t>
<t tx="edream.110203163054.2124">Leo was not warning about orphan nodes in cweb mode.

There was new code in atFile.write _not_ to check for orphan nodes in cweb mode.  I just removed the test for language=="cweb".</t>
<t tx="edream.110203163054.2125">The present code explicitly eliminates control-T processing in headlines, which means that control-T does not switch panes when editing headline text.  Control-T _does_ switch panes in all other cases.

This appears to be another Tk bug.</t>
<t tx="edream.110203163054.2126"></t>
<t tx="edream.110203163054.2127"></t>
<t tx="edream.110203163054.2128">The old code scanned the moved tree once for every parent.  The new code scans the tree only once.  This can result in a significant speedup.</t>
<t tx="edream.110203163054.2129">This is taken from Python Cookbook.
It's not clear how useful this is with Tk programs.</t>
<t tx="edream.110203163054.2130">1. Eliminated special-case code (putCWEB) in atFile.write code.
2. Changed directiveKind so it returns noDirective for @space and @c when language=="cweb".
3. Changed colorizer to recognize both cweb and noweb section definitions and references when language == "cweb"</t>
<t tx="edream.110203163054.2131">Leo preserves the &lt;?xml-stylesheet...?&gt; line if it is already present in the .leo file.

Otherwise, Leo writes a &lt;?xml-stylesheet...?&gt; line only if the stylesheet option is present in the configuration file.  The stylesheet option specifies s in &lt;?xml-stylesheet s?&gt;</t>
<t tx="edream.110203163054.2132"></t>
<t tx="edream.110203163054.2133"></t>
<t tx="edream.110203163054.2134">Changed find to rfind in &lt;&lt; Set headline and ref &gt;&gt;</t>
<t tx="edream.110203163054.2135"></t>
<t tx="edream.110203163054.2136">scanAllDirectives just about must be called on the root of the tree, so directives are recognized.  Not @first or @last though.</t>
<t tx="edream.110203163054.2137">The aha, just concatenate a unique user id with any local timestamp.</t>
<t tx="edream.110203163054.2138">This may complete raw cweb mode.</t>
<t tx="edream.110203163054.2139">It appears that nobody ever used @delims in @file trees!</t>
<t tx="edream.110203163054.2140">Only shortcut pastes worked before.</t>
<t tx="edream.110203163054.2141"></t>
<t tx="edream.110203163054.2142">1. Changed "c" to "." in

methodKind = choose(self.fileType==".c","functions","methods")

2. Added self.rootLine logic to add @root self.fileName when importing to @root nodes.</t>
<t tx="edream.110203163054.2143"></t>
<t tx="edream.110203163054.2144"></t>
<t tx="edream.110203163054.2145">Previously, Java only had block comments, and the ending delim wasn't being removed from doc parts.</t>
<t tx="edream.110203163054.2146"></t>
<t tx="edream.110203163054.2147"></t>
<t tx="edream.110203163054.2148">As usual, I am leary of changing the Untangle logic.

To be effective, the @comment directive should follow the @language directive.</t>
<t tx="edream.110203163054.2149"></t>
<t tx="edream.110203163054.2150"></t>
<t tx="edream.110203163054.2151"></t>
<t tx="edream.110203163054.2152"></t>
<t tx="edream.110203163054.2153"></t>
<t tx="edream.110203163054.2154">The warning for "unknown language" had an unbound var.</t>
<t tx="edream.110203163054.2155">The new code must check for @raw and @end_raw directives.</t>
<t tx="edream.110203163054.2156">The &lt;&lt; Set path from @file node &gt;&gt; code was assuming that v.isAtFileNode() was non-Null.  This is no longer true with @rawfile.  The traceback was:

 File "c:\prog\leoCvs\leo\leoAtFile.py", line 424, in scanAllDirectives
    name = v.atFileNodeName()
AttributeError: 'NoneType' object has no attribute 'atFileNodeName'

The correct code is:

if v.isAtFileNode():
	name = v.atFileNodeName()
else:
	name = v.atRawFileNodeName()

dir = choose(name,os.path.dirname(name),None)</t>
<t tx="edream.110203163054.2157"></t>
<t tx="edream.110203163054.2158"></t>
<t tx="edream.110203163054.2159"></t>
<t tx="edream.110203163054.2160"></t>
<t tx="edream.110203163054.2161"></t>
<t tx="edream.110203163054.2162"></t>
<t tx="edream.110203163054.2163">A small convenience urgently requested.</t>
<t tx="edream.110203163054.2164">It wasn't always completely clear when the command was complete.</t>
<t tx="edream.110203163054.2165">atFile.directiveKind returned miscDirective on _any_ line that starts with @.</t>
<t tx="edream.110203163054.2166">This entailed using lots of ivars for communication between routines.</t>
<t tx="edream.110203163054.2167"></t>
<t tx="edream.110203163054.2168"></t>
<t tx="edream.110203163054.2169"></t>
<t tx="edream.110203163054.2170"></t>
<t tx="edream.110203163054.2171">A recent change was not writing language names properly (double quotes were ommitted) in the &lt;preferences&gt; element of .leo files.</t>
<t tx="edream.110203163054.2172">The new code is much simpler and more rational than the old, without affecting the defaults that are delivered by the module.

In addition, fixed a but that was causing most new params not to be written.</t>
<t tx="edream.110203163054.2173">This directive only applies to @root trees.  Like @silent, it inhibits untangling.</t>
<t tx="edream.110203163054.2174">Added missing comma before the keyword.</t>
<t tx="edream.110203163054.2175"></t>
<t tx="edream.110203163054.2176">Another major reorganization.</t>
<t tx="edream.110203163054.2177">This was a major reorganization.</t>
<t tx="edream.110203163054.2178"></t>
<t tx="edream.110203163054.2179"></t>
<t tx="edream.110203163054.2180"></t>
<t tx="edream.110203163054.2181">Replaced almost all calls to traceback.print_exc by calls to es_exception.</t>
<t tx="edream.110203163054.2182">We call scanAllDirectives on the _parent_ node, so no directives are recognized in the @rawfile tree itself, and directives _are_ recognized in ancestor nodes.  atFile::writeAll has new logic that recognizes @ignore in ancestors of @rawfile nodes, but not in @rawfile nodes themselves.

Writing the file was easy; updating the screen was harder.  We must redraw the screen whenever a headline changes, regardless of whether a node is joined to another.  The reason is that we must redraw the dirty bits of ancestor @file and @rawfile nodes.</t>
<t tx="edream.110203163054.2183"></t>
<t tx="edream.110203163054.2184">Removed v22 var from leoApp.py.
Removed ch3 var from getCwebWord() in leoColor.py
Removed self and name args from go function in leoCompare.py.
Added from leoUtils import * and from leoGlobals import * to leoCompare.py
Removed ok from onCompareFiles in leoCompare.py
Removed c from setAncestorsOfClonedNodesInTreeDirty in leoNodes.py
Removed import leoPrefs from leoAtFile.py
Moved unused assignment to top into #if 0 block in open in leoFileCommands.py
Removed unused name var from scanPHPText in leoImport.py
Bug fix: changed tangle_state to self in several places in root_attributes.__repr__
Bug fix: converted represent_print_bits to a method
	(It was indented as a method under class root_attributes)
Removed language,single_comment_string,start_comment_string,end_comment_string params from st_enter in leoTangle.py.
Bug fix (Major?): restored code to return part number at end of st_enter.
Latent bug fix: changed self.font to font in tree.setLineHeight.
Bug fix: all paths through idle_body_key and idle_head_key now return "break"
Removed topMenu var from tree.OnPopup.
Removed config var from leoFrame.__init__
Latent bug fix: changed editHeadlineMenu to self.editHeadlineMenu in leoFrame.__init__ 
Real bug fix: changed editHeadlineMenu to self.editHeadlineMenu in leoFrame.__del__
	(This affects how storage is freed)
Removed interp var from leoPyShellMain.</t>
<t tx="edream.110203163054.2185"></t>
<t tx="edream.110203163054.2186">Asumming that python and tcl are installed, It shouldn't take familiarity with python to be able to use leo. I want to be able to type

leo foo

and have leo start up on a new [outline] named foo.leo, or open the existing one if it's there.</t>
<t tx="edream.110203163054.2187"></t>
<t tx="edream.110203163054.2188"></t>
<t tx="edream.110203163054.2189">Leo now does the following: 

1. Leo checks all characters that are entered (via typing or via paste) into headline and body text to see whether they can be represented in the encoding specified in leoConfig.txt. 

2. Leo issues a message and _disallows_ the entry of the character if it can't be represented in the encoding specified in leoConfig.txt. 

In practice, this draconian behavior shouldn't be too much of a nuisance, at least temporarily. Note that _all_ characters are valid in UTF-8 encoding, so the present version of Leo will allow you to specify all characters if you must. But the Latin-1 (iso-8859-1) encoding, being a one-byte encoding, limits you to at most 256 separate characters. 

In 3.8 I plan to allow you to use _all_ Unicode characters, regardless of encoding, by using so-called character references.  This will require some reorganization of the present code, so I don't want to delay 3.7 to handle them.</t>
<t tx="edream.110203163054.2190">It is much more convenient to set these to proper defaults than it would be for the callers to do so.  Nevertheless, perhaps the caller should do so, but not now...</t>
<t tx="edream.110203163054.2191"></t>
<t tx="edream.110203163054.2192">This makes the present code compatible with Python 2.1.</t>
<t tx="edream.110203163054.2193">I needed this clarification.</t>
<t tx="edream.110203163054.2194">&gt; # Tk always uses utf-8 encoding.

You may get that impression, but it is slightly wrong. It is more
reliable if you pass Unicode strings to Tk, instead of UTF-8 encoded
byte strings.

For a byte string, Tk will guess the encoding. If it looks like UTF-8,
it is taken treated UTF-8. Otherwise, it is treated as the locale's
encoding. Unfortunately, if you ever manage to mix the two, you get
byte salad that you can't ever chew. By using Unicode strings to
interface with Tk only, you can avoid those problems.

&gt; print `s`,"tk"
&gt; s = s.encode("utf-8") # result is a string.
&gt; print `s`,"utf-8"
&gt; s = s.decode(xml_encoding) # result is unicode.
&gt; s = s.encode(xml_encoding) # result is a string.

Since xml_encoding is iso-8859-1, you are making a mistake here. You
have UTF-8 data, but you are decoding them as Latin-1. This will
succeed, but it will give an incorrect result. It will succeed since
iso-8859-1 is an single-byte code where every byte value is valid.
That means an arbitrary byte sequence can be interpreted as Latin-1,
but for many byte sequences, the resulting string is non-sense
(mojibake, as the Japanese say).

&gt; BTW, with out the first encode/decode pair I can take exceptions in
&gt; the last encode.

Nevertheless, this is the correct processing. If you have a Unicode
object, as originally obtained from Tk, you should encode as Latin-1
using

s = s.encode("iso-8859-1")

Now, for this specific string (u'a\u0102\xdf\xc9\n'), you will get a
Unicode error. The reason is that one character (\u0102) is not
supported in Latin-1 - this encoding supports only the first 256
Unicode characters.

So, when saving this as XML, the proper representation would be

'a&amp;#x102;\xdf\xc9\n'

i.e. you'll have to use a character reference. Python 2.2 does not
support generating such text very well - you'll have to catch the
Unicode error yourself, find the offending character, encode it as a
character reference, and encode all other characters as requested.

Alternatively, you can refuse encoding a document in a certain
encoding (such as Latin-1), and fall back to UTF-8.

PEP 293 (http://www.python.org/peps/pep-0293.html) will provide a
mechanism to generate character references more conveniently - in
Python 2.3, you can specify

  s.encode('iso-8859-1',errors='xmlcharrefreplace')

HTH,
Martin</t>
<t tx="edream.110203163054.2195">The Find Previous command could not go to previous nodes.</t>
<t tx="edream.110203163054.2196"></t>
<t tx="edream.110203163054.2197">It would be good to have a prefix option too.</t>
<t tx="edream.110203163054.2198">This fix was suggested by Rich Ries.  The original report follows:

I found the culprit; it's in the node &lt;&lt; scan @@ &gt;&gt; that reads: 

k = string.find(s,self.endSentinelComment,i) 

This means it stops at the FIRST endSentinelComment, which is the "*/". The rest of the line (with the correct "*/") gets chucked. Changing the line to: 

k = string.rfind(s,self.endSentinelComment,i) 

(note the "r" before "find") seems to fix the problem. 
</t>
<t tx="edream.110203163054.2199"></t>
<t tx="edream.110203163054.2200"></t>
<t tx="edream.110203163054.2201">The new code in putOpenLeoSentinel follows the example of putSentinel.</t>
<t tx="edream.110203163054.2202"></t>
<t tx="edream.110203163054.2203">They are simply relative representations of absolute indices, and so are basically useless.</t>
<t tx="edream.110203163054.2204">This is a huge step, and I hope it is forward. In any event, the change is simple and reversable.

I am now considering whether to use relative node indices instead of absolute node indices.

These would have the form +n and -n.  This would eliminate the cascade of changes when nodes were inserted.  The key question is whether the read logic can handle them.  I believe it can, with just a single ivar.</t>
<t tx="edream.110203163054.2205">Amazingly, the only change required to allow reads and writes of cloned @file nodes was to eliminate the error in updateCloneIndices.  I also fixed a bug: set self.errors = 0 in atFile.read.</t>
<t tx="edream.110203163054.2206"></t>
<t tx="edream.110203163054.2207">The upshot: both =pod and =cut must be preceded and followed by blank lines.  The simple tests have this.

Added perlpod hack to set_delims_from_string and changed delims to use double underscores in set_delims_from_language.</t>
<t tx="edream.110203163054.2208">This affects @path, @file and @root code.  This is probably the code with the most separate paths in all of Leo.  I would be amazed if there were no bugs here, and it does seem mostly to work.

The getBaseDirectory utility routine implements the relative_path_base_directory option:

"!" means relative to leo.py
"." means relative to .leo file.
anything else should be absolute path.</t>
<t tx="edream.110203163054.2209">This was just too horrible to keep straight, and bodyKeepsFocus should always be true anyway.</t>
<t tx="edream.110203163054.2210"></t>
<t tx="edream.110203163054.2211"></t>
<t tx="edream.110203163054.2212"></t>
<t tx="edream.110203163054.2213"></t>
<t tx="edream.110203163054.2214"></t>
<t tx="edream.110203163054.2215"></t>
<t tx="edream.110203163054.2216"></t>
<t tx="edream.110203163054.2217"></t>
<t tx="edream.110203163054.2218"></t>
<t tx="edream.110203163054.2219">It looks like the undo command does not fully undo changes to cloned nodes. Follow these steps to experience this effect: 

1) clone a node (same effect whether @file / @root or other) 
2) change the headline of either node. 
3) Edit-&gt;Undo change Headline (or ctrl-Z) 

Only the node that was changed will go back to the original headline. The undo command appears to be the problem since it does not properly undo changes to all cloned nodes' headlines. </t>
<t tx="edream.110203163054.2220">The new code is much more elegant than the old, and does a better job of reporting errors.

One new restriction has been imposed: at most one shortcut can be associated with a command.  If one really wanted to have two shortcuts, one would have to use two different command names.

In particular, there is now only one shortcut for the Find Next command.  This should not be a problem.

It is now possible to bind the arrow keys as desired.  See the complete discussion in leoConfig.leo.

Note that all bindings are made both to the body pane and the top-level pane. This keeps things consistent.</t>
<t tx="edream.110203163054.2221"></t>
<t tx="edream.110203163054.2222">There was a missing comma.</t>
<t tx="edream.110203163054.2223">It was remembering it only if set as the result of a keystroke.  The present code is redundant, but what the heck.</t>
<t tx="edream.110203163054.2224">1. Use the present body font in frame.setTabWidth.

2. Do not call frame.setTabWidth in setCommandsIvars.  Just set the ivar.  This fixes the following bug:

"If you set the @tabwidth to something other than the Preference value, you'll
see the body displayed appropriately.  However, if you do a Ctrl-s to save the
leo file, the body is redisplayed using the Preferences setting -- of course,
clicking on another node and then back to the original node displays with the
correct tab setting again.  The redisplay on save must not go through precisely
the same body display logic."
</t>
<t tx="edream.110203163054.2225">This was too confusing to users.</t>
<t tx="edream.110203163054.2226"></t>
<t tx="edream.110203163054.2227">This was done simply by opening derived files and .leo files in "wb" mode.</t>
<t tx="edream.110203163054.2228">Essentially I moved the code that updates body text from the @+node logic to the @+body logic.

This can not be completely correct.  It breaks verbatimAfterRef

From the forum message:

I have just uploaded a major change to the logic that reads derived files. Indeed, this is the first change to that logic that has ever been made since I first invented @file trees. This change is needed to correct a bug reported by Rich Ries involving referencing a section defined in a grandchild of the referencing node. 

WARNING: although this code is similar to previous code, and passes all the tests that I can think of, you
should still consider this code experimental for a while. 

The problem: Body text was being updated as the result of @+node sentinels rather than @+body sentinels.
This was stupid, as extra @+node sentinels are often generated when no body text is generated. The result is
that the body text was being cleared. 

The fix: I simply moved the code that creates body text from the @+node logic to the @+body logic in
scanText. This was relatively straightforward, and I do have some hopes that everything will once again be rock
solid. However, the context in which this code is executing is obviously changed (that is, after all, the whole
point), so no guarantees can be given at this point. 

Everything appears to work (all files derived from this file appear to be OK), and this code must be considered experimental for now.</t>
<t tx="edream.110203163054.2229"></t>
<t tx="edream.110203163054.2230">At this point there are no known issues with Leo and Python 2.1.

Python 2.1 gave the following warnings when importing Leo:

Python 2.1.3 (#35, Apr  8 2002, 17:47:50) [MSC 32 bit (Intel)] on win32
Type "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import leo

leoFrame.py:197: SyntaxWarning: local name 'self' in 'createMenuBar' shadows use of 'self' as
global in nested scope 'lambda'
  def createMenuBar(self, top):

leoFrame.py:1262: SyntaxWarning: local name 'self' in 'OpenWithFileName' shadows use of 'self' as
global in nested scope
 'lambda'
  def OpenWithFileName(self, fileName):

leoColor.py:1367: SyntaxWarning: local name 'self' in 'run' shadows use of 'self' as
global in nested scope 'lambda'
  def run (self):
</t>
<t tx="edream.110203163054.2231"></t>
<t tx="edream.110203163054.2232"></t>
<t tx="edream.110203163054.2233"></t>
<t tx="edream.110203163054.2234"></t>
<t tx="edream.110203163054.2235">It was just a matter of binding some unbound vars to defaults.</t>
<t tx="edream.110203163054.2236">- The font settings in leoConfig.txt are not active when I open Leo. They instantly activate when opening the Edit|Set Font... dialog, without having to click anything in said dialog. Then, once the .leo file is saved, the problem goes away.</t>
<t tx="edream.110203163054.2237"></t>
<t tx="edream.110203163054.2238"></t>
<t tx="edream.110203163054.2239">This code improperly removed trailing whitespace, including newlines, from the "middle" text.  Clearly this is wrong, regardless of what other effects it might have.

Affected commands are indent, dedent, extract and extract section.</t>
<t tx="edream.110203163054.2240"></t>
<t tx="edream.110203163054.2241">This makes it convenient to update the version number in this file properly.</t>
<t tx="edream.110203163054.2242"></t>
<t tx="edream.110203163054.2243">We now look through the entire tree looking for @root and @file nodes.</t>
<t tx="edream.110203163054.2244">single quote colorized text in plain text mode.  This was due to missing parentheses.</t>
<t tx="edream.110203163054.2245"></t>
<t tx="edream.110203163054.2246"></t>
<t tx="edream.110203163054.2247"></t>
<t tx="edream.110203163054.2248"></t>
<t tx="edream.110203163054.2249"></t>
<t tx="edream.110203163054.2250"></t>
<t tx="edream.110203163054.2251">CVS conflict files produce so many error messages that these errors are useless.</t>
<t tx="edream.110203163054.2252">1. Created a new sandbox and updated CVS into it.  This did not update LeoPy.leo.
2. Opened LeoPY.leo.  There were read errors in leoImport.py and leoUtils.py.
3. Used diff on CVS to determine which routines had been added to these files.
4. Cut and pasted from updated LeoPy.leo to my "real" copy of LeoPy.leo.

This is most annoying, though it is helpful to pay attention to the added code.

The read errors themselves are useless, and I removed them.

I forgot to do an update first, so after I opened LeoPy.leo with Read Outline Only, saving all files with Write @file Nodes reverted Dave Hein's changes.  So I reloaded them from the temporary sandbox.  This is very bad.</t>
<t tx="edream.110203163054.2253"></t>
<t tx="edream.110203163054.2254"></t>
<t tx="edream.110203163054.2255"></t>
<t tx="edream.110203163054.2256">The code is now functionally identical to the similar code in atFile.scanAllDirectives.  The old code did not handle relative paths properly in all cases.</t>
<t tx="edream.110203163054.2257"></t>
<t tx="edream.110203163054.2258">This code crashes on some Windows systems, including my XP system.  It may work on Win98.</t>
<t tx="edream.110203163054.2259">This involved calling readlineForceUnixNewline instead of readline in the atFile:read logic.</t>
<t tx="edream.110203163054.2260"></t>
<t tx="edream.110203163054.2261"></t>
<t tx="edream.110203163054.2262"></t>
<t tx="edream.110203163054.2263"></t>
<t tx="edream.110203163054.2264"></t>
<t tx="edream.110203163054.2265">Only the last directive was in effect in @root trees.  The new code allows node-by-node control.</t>
<t tx="edream.110203163054.2266">This routine does a better job of checking the Tk version than the old code in leoApp.py</t>
<t tx="edream.110203163054.2267">With Tk/Tcl 8.4, the Preferences window is empty (no buttons, fields, labels). 

Tcl 8.4 complains about using "col" in the grid() calls.</t>
<t tx="edream.110203163054.2268">Removed calls to c.frame.canvas.focus_force() selectThreadBack/Next, selectVisBack/Next.

I have no idea why this code was there originally.</t>
<t tx="edream.110203163054.2269">This may or may not fix Rich Reis's problems.</t>
<t tx="edream.110203163054.2270">How did I ever live without this?</t>
<t tx="edream.110203163054.2271"></t>
<t tx="edream.110203163054.2272">Changed:

bitmap_name = os.path.join(self.loadDir,"Icons\LeoApp.ico") 

to:

bitmap_name = os.path.join(self.loadDir,"Icons","LeoApp.ico") 
</t>
<t tx="edream.110203163054.2273"></t>
<t tx="edream.110203163054.2274">&gt; I'd love to open a node and be in the same place as when I was last there.
</t>
<t tx="edream.110203163054.2275">Everything appears to be working properly.</t>
<t tx="edream.110203163054.2276">When starting Leo with no arguments the 'NewHeadline' node was not displayed. </t>
<t tx="edream.110203163054.2277">os.rename can fail on some Linux systems.</t>
<t tx="edream.110203163054.2278">@nocolor

The new code is as follows.  This is extremely ugly, and I'm not sure there is any workaround.  The problem is that open is really just a stand-in for C's fopen routine, and the mode param is not uniform across platforms.

@color

# 9/1/02: apparently Linux requires w+ and XP requires w.
mode = choose(sys.platform=="win32","w","w+")
cf = open(self.configFileName,mode)</t>
<t tx="edream.110203163054.2279"></t>
<t tx="edream.110203163054.2280"></t>
<t tx="edream.110203163054.2281">This will allow Joe Orr to keep track of hits.</t>
<t tx="edream.110203163054.2282">The cursor now changes to an arrow when it moves over a link.</t>
<t tx="edream.110203163054.2283">1.  The link now takes the user to the SourceForge download page.
2.  Called os.setcwd(app().loadDir) to set the working directory for the download.</t>
<t tx="edream.110203163054.2284"></t>
<t tx="edream.110203163054.2285">This is still not working, and I am beginning to doubt that it can be done.

Notes:

1. In Tk terminology, bitmaps are 2-color only.  Most .bmp files must be considered _photo_ files.
2. I have figured out how to read .bmp and .gif files using image create photo.
3. All tests were run using tcl/tk 8.3.4, and wm iconbitmap has never worked.</t>
<t tx="edream.110203163054.2286">It already works in the other panes, but the recommended code crashes tk83.dll!</t>
<t tx="edream.110203163054.2287"></t>
<t tx="edream.110203163054.2288"></t>
<t tx="edream.110203163054.2289"></t>
<t tx="edream.110203163054.2290"></t>
<t tx="edream.110203163054.2291"></t>
<t tx="edream.110203163054.2292"></t>
<t tx="edream.110203163054.2293">There were a couple of botches in the new code:

1. leoTangle.scanAllDirectives should not issue any warning when it sees a relative path name in the @root directive.  (Which is the only place it will see it).  This is not an error.

2. leoTangle.pathError would create an exception when called.</t>
<t tx="edream.110203163054.2294"></t>
<t tx="edream.110203163054.2295"></t>
<t tx="edream.110203163054.2296">Amazing!</t>
<t tx="edream.110203163054.2297">1. Simplified the path logic in the various scanAllDirectives routines.

2. Distinguished between absolute and relative paths.  Relative paths do _not_ set the global defaults: they are handled by the file open logic which does os.path.join(default_path,file_name).

The logic is still quite complex, and for the first time the code may be simple enough to work.</t>
<t tx="edream.110203163054.2298">This should end most of the confusion.</t>
<t tx="edream.110203163054.2299">There are several problems here:

1. os.path.join(dir,file) won't work if both dir and file contain a partial path name.  I'm not sure whether this is a bug--there is probably no behavior that makes sense in all cases.

2. Unless os.path.join works above there is no way to see whether the directory is valid.</t>
<t tx="edream.110203163054.2300">Removed '\r' characters when reading.  The write logic is unchanged, which makes the changes slightly safer.</t>
<t tx="edream.110203163054.2301"></t>
<t tx="edream.110203163054.2302"></t>
<t tx="edream.110203163054.2303">An arg got dropped out when I added a flag.</t>
<t tx="edream.110203163054.2304">Found several bugs while doing so.  What else is new...

Use this script as follows:

- Select the node under which you want the imported files to appear.
- Open the Python window within Leo.
- Type the following in the Python window:

import leoImport
dir = "c:/prog/test"  # or some other directory
type = ".py"  # Type of files you want to import, or None for all files.
leoImport.importFiles(dir,type)</t>
<t tx="edream.110203163054.2305"></t>
<t tx="edream.110203163054.2306"></t>
<t tx="edream.110203163054.2307"></t>
<t tx="edream.110203163054.2308"></t>
<t tx="edream.110203163054.2309">The new code properly deletes previous entries regardless of case or path separators.</t>
<t tx="edream.110203163054.2310">Changed idle_body_key and idle_head_key so the old values are also checked for Unicode strings.  I don't understand why that is needed, and after a cut and paste operation it is needed.

Also fixed Tangle's version of the os routine.

Also changed the assertion and converted to unicode in tnode::setTnodeText.</t>
<t tx="edream.110203163054.2311"></t>
<t tx="edream.110203163054.2312">The calls to config.setX in the put routines in leoFileCommands.py were happening _after_ the calls to config.update().  There is not need to call the config.set routines in putPrefs and putFindSettings provided we do the following in write_LEO_file:

	c.setIvarsFromFind()
	config.setConfigFindIvars(c)
	c.setIvarsFromPrefs()
	config.setCommandsIvars(c)
	config.update()</t>
<t tx="edream.110203163054.2313">This creates leoConfig.txt</t>
<t tx="edream.110203163054.2314">The old code was totally brain dead.  If a setting was missing or "ignore" it could never be set!!  Sheesh.  This is a major bug because _all_ writes to leoConfig.txt go throught this routine.</t>
<t tx="edream.110203163054.2315"></t>
<t tx="edream.110203163054.2316">Otherwise there is no way to change the prefs!</t>
<t tx="edream.110203163054.2317">There were a couple of bugs here.

Note that the ratio (whichever the direction) is stored in the .leo file.  The initial_splitter_orientation setting in leoConfig.txt applies to _all_ files.  The initial_vertical_ratio and the corresponding initial_horizontal_ratio  apply only to new files, so are essentially useless.

Yes, this is pretty stupid; it's the result of not wanting to add more stuff to Leo's file format.</t>
<t tx="edream.110203163054.2318"></t>
<t tx="edream.110203163054.2319">This makes selected text look much better and makes Show Invisibles look much better as well.  

This was not easy to do.  Apparently tag settings interfer with the Tk.Text settings.  I have not found a way to specify the selectbackground color for tags.  The only way I could get things to work is only define whitespace tags when in showInvisibles mode.</t>
<t tx="edream.110203163054.2320">Added setRevertVars to update revert settings.  This is called from __init__ and onOk.</t>
<t tx="edream.110203163054.2321">This is consistent with what the Import commands do for the other file types.  It's also much safer.</t>
<t tx="edream.110203163054.2322">.tmp files disappear On Windows XP after Leo exits!</t>
<t tx="edream.110203163054.2323"></t>
<t tx="edream.110203163054.2324">The new spelling is to limit_directory_search_extension.  Note that this affects the valid entries in leoConfig.txt.</t>
<t tx="edream.110203163054.2325">Repeated double-clicking (without intervening single-click) caused the selection to move to the left.</t>
<t tx="edream.110203163054.2326"></t>
<t tx="edream.110203163054.2327">We must remove backticks from messages that might contain unicode characters so they will print properly.  There were only a few instances, and they are all error messages that hardly ever get executed, so I hope I was careful putting them in.  I should be able to find them all by looking for '"'.</t>
<t tx="edream.110203163054.2328">Simplified leoCompare.py and leoTangle.py.</t>
<t tx="edream.110203163054.2329">Now at last it is clear why Leo hasn't been writing derived files affected by clones.  It's not enough to mark v dirty.  We must mark all the cloned nodes of v's tree dirty as well.

However, we only need do this when a node is deleted, and we definitely do _not_ want to do this otherwise, for that would mark far too many nodes dirty.  To get around this, we leave v.setDirty() as it was, and use the new code only in v.setDirtyDeleted.

Note that the undo and redo cases handle this automatically because they call c.doDelete.</t>
<t tx="edream.110203163054.2330"></t>
<t tx="edream.110203163054.2331"></t>
<t tx="edream.110203163054.2332">Amazing.  All that was needed was some code to force conversion on write, and code in the event handlers to convert "real" unicode to UTF-8.  We are talking about 10 lines of code!

There was a problem in leoFind.findNext: it was backquoting the search string when reporting search failures.  Removing the back quotes made the message appear properly.

What was needed was simply to do:

	if type(s) == types.UnicodeType:
		xml_encoding = app().config.xml_version_string
		s = s.encode(xml_encoding)

On the string s gotten from the Text widgets in the event handlers.

As a defensive measure, I also changed the write code in two places to:

	try:
		self.outputFile.write(s)
	except UnicodeError: # This might never happen.
		xml_encoding = app().config.xml_version_string
		s = s.encode(xml_encoding)
		self.outputFile.write(s)

The old code wrote `s` instead of s.encode(xml_encoding).</t>
<t tx="edream.110203163054.2333">Also changed the calling code to check for val != None and val &gt; 0 or val != 0.  The only callers of skip_long are the various places that handle the @pagewidth and @tabwidth code.  Negative tab widths are allowed, but not negative page widths.</t>
<t tx="edream.110203163054.2334">Initializing to something else was preventing a lot of code from being used!

Retested the @path logic.  Everything seems good.</t>
<t tx="edream.110203163054.2335">These were used only to set the delim1, delim2 and delim3 locals in atFile.scanAllDirectives.  Getting rid of these two useless ivars greatly clarifies the code.</t>
<t tx="edream.110203163054.2336">This is weird.  set_language would set the delims to the default_language delims if the lanuage was "default"</t>
<t tx="edream.110203163054.2337"></t>
<t tx="edream.110203163054.2338">We can't use choose because both branches are evaluated.

self.single_comment_string was never None before because all languages had either 1 or 3 delims.  But Java now has only 2 delims to force block comments.</t>
<t tx="edream.110203163054.2339">The same bug appeared in leoAtFile.putIndent and leoTangle.put_leading_ws.  These routines should not do w = abs(tab_width) before the test.  I was confused that n (the desired indentation) might be negative.

Anyway, as a defensive measure, I used ' ' * abs(n) and '\t' * abs(n) in the routines in leoAtFile and leoTangle that put tabs and spaces.

Also, changed n / w to int(n/w) to avoid problems with future division.</t>
<t tx="edream.110203163054.2340">1. The botch was this: set_delims_from_language used to return
	delim1 = start_block_comment_string
	delim2 = end_block_comment_string
if there were only two delims.  But the callers thought that delim1 was _always_ the single_comment_string.

This actually never caused problems with @language, because all languages had either 1 or 3 delimiters.  However, it appeared when I forced block comments in Java by using only two delims.  And it could always have caused problems when people used the @comment directive.

2. Issued a warning and do nothing when no delims specified with @comment.  This could have caused crashes.

3. set_delims_from_string no longer returns hard-coded defaults.  Instead it returns None.  Callers must now beware, but this is the correct action to take.</t>
<t tx="edream.110203163054.2341">The change was made to leoFrame.py::reconfigurePanes.</t>
<t tx="edream.110203163054.2342"></t>
<t tx="edream.110203163054.2343">If a name table has only one name, it must be defined like

name = ("x",)

rather than

name = ("x")

This affected the following options:

"read_only"
"xml_version_string"
"limit_count"
"body_pane_wraps"</t>
<t tx="edream.110203163054.2344">1. Removed the following ivars.  They were never used.

self.singleCommentString = "#"
self.startCommentString = ""
self.endCommentString = ""

2. Initialized the following ivars to None in the ctor:

self.default_directory = None
self.page_width = None
self.tab_width  = None
self.presentLanguage = None
self.targetLanguage = None
self.startSentinelComment = None
self.endSentinelComment = None

This makes clear that they are really initialized in leoAtFile.scanAllDirectives.

3. Renamed leoAtFile.scanAllDirectives.&lt;&lt; Set delims to default values &gt;&gt; to &lt;&lt; Set ivars &gt;&gt;.  It's contents is now:

if 1: # 8/2/02
	self.page_width = self.commands.page_width
	self.tab_width = self.commands.tab_width
	self.presentLanguage = self.targetLanguage = c.target_language
else:
	self.page_width = leoPrefs.default_page_width
	self.tab_width = leoPrefs.default_tab_width
	self.presentLanguage = self.targetLanguage = leoPrefs.default_target_language
	
self.default_directory = leoPrefs.default_default_directory
delim1, delim2, delim3 = set_delims_from_language(self.presentLanguage)</t>
<t tx="edream.110203163054.2345"></t>
<t tx="edream.110203163054.2346">There were many, many problems in the old color panel.

- Completely revised the Revert logic in the main Color panel.
- The color name picker now reverts properly.
- Color names and color swatches are now properly updated in all cases.
  As a result, there is no need to write color values to the log window.
- Used str(name) rather than `name` to eliminate quotation marks around color names and values.
- The color picker now shows the value of the present color, not the revert color.
- Increased the width of name buttons to handle long color names.
</t>
<t tx="edream.110203163054.2347">See the child node for a proof.</t>
<t tx="edream.110203163054.2348">@nocolor

The test code shows that all normal cases are handled correctly.  Nevertheless, we must prove that Leo can properly read and write @file nodes with nested @others directives.

Writing:

putAtOthers writes all nodes to be generated by @others.  inAtOthers returns false if the node has already been visited.  Nodes will not be visited when expanding the "outer" or "upper" @others, and will be visited thereafter.  Thus, nodes will be written at most once.

putAtOthers writes only sibling nodes and nodes descending from sibling nodes.  The expansion of inner @others nodes will never include parent nodes.  The expansion of an @others directive at @file node will write all unwritten nodes in the @file node.

In short,

1. all nodes in the "range" of an @others directive are written once and only once.
2. all nodes in the "range" of an @others directive are written enclosed in @+-others sentinels.
3. No orpan nodes are written.

Reading:

The read logic is unchanged.  Everything will work as before.  In particular, note that @+-others sentinels create trees under nodes containing the @others directive, just as before.  The read logic naturally handles nesting!</t>
<t tx="edream.110203163054.2349"></t>
<t tx="edream.110203163054.2350">The bug was testing for ifdef instead of #ifdef at the start of skip_pp_if.  However, I thought the bug might be related to something else, so I ended up being much more careful about brace levels in different branches of an #if statement.  The result was the skip_pp_part routine.</t>
<t tx="edream.110203163054.2351">I think this is most reasonable: we don't wan't people generating files from imported files unless they take some positive action.</t>
<t tx="edream.110203163054.2352">This bug caused following defs to be included in the current def if the line ended in a comment that was followed immediately by another def.</t>
<t tx="edream.110203163054.2353">I wanted to generate the following if a class declaration is in a separate node:

class x:
	@others

Instead of:

class x:
	&lt;&lt; class x methods &gt;&gt;

+ &lt;&lt; class x methods &gt;&gt;
@others

This doesn't work at first: all nodes under class x become orphans.  However, the new version of 
</t>
<t tx="edream.110203163054.2354">In order to make the new import code work, I have _experimentally_ allowed a change to how leoAtFile writes code.  This is the first such change in about a year.

The old code in leoAtFile.inAtOthers did not write nodes in @others trees if such nodes descended from another @others node.  The new code allows such nodes.  Apparently the write code handles this case just fine and the old restriction was unnecessary...</t>
<t tx="edream.110203163054.2355">Added entries for default target language, outline, promote and demote.</t>
<t tx="edream.110203163054.2356">The code now makes sure that c.target_language and related vars are not None.  This should fix the problem, and I wouldn't bet my life on it.</t>
<t tx="edream.110203163054.2357">It's too confusing to have arrow keys mean different things in different panes.

For one thing, we want to leave the focus in the body pane after the first click in the outline pane, but that means that the arrow keys must still be functional in the _body_ pane!

Alas, all the various combinations of key bindings of arrow keys appear to do something; there are none left to use for moving around in the outline pane.  So we are stuck with poor shortcuts.</t>
<t tx="edream.110203163054.2358"></t>
<t tx="edream.110203163054.2359">The @others directive was appearing before &lt;&lt; declarations &gt;&gt; reference.

The bug report and the fix were from Walter H. Rauser.</t>
<t tx="edream.110203163054.2360"></t>
<t tx="edream.110203163054.2361">I used the dis module as a base.  It was remarkably easy.  All I needed was

1. dis.opname, the names of the opcodes and
2. some code in the dis module to use as a starting point.</t>
<t tx="edream.110203163054.2362">The performance of Leo is as I expected.  In particular, reading files is the biggest bottleneck, and scanning string.find, isAtFileNode, is_ws, etc. are called frequently.</t>
<t tx="edream.110203163054.2363"></t>
<t tx="edream.110203163054.2364"></t>
<t tx="edream.110203163054.2365"></t>
<t tx="edream.110203163054.2366">@nocolor

Bernhard Mulder suggested the following code for adding the path to idle to sys.path.  I used this code with only trivial modifications.  I retained the previous error handling code in case there are further exceptions...

@color

try: 
	import idle 
except: 
	executable_dir = os.path.split(sys.executable)[0]
	idledir=os.path.join(executable_dir, "tools/idle") 
	sys.path.append(idledir)
</t>
<t tx="edream.110203163054.2367">The fix was to put a call to frame.top.deiconify() in run() right after the call to the frame ctor.

Apparently I only use openLeo.py to open Leo.</t>
<t tx="edream.110203163054.2368">The Compare panel is much easier to use than the old scripts in leoCompare.py.</t>
<t tx="edream.110203163054.2369"></t>
<t tx="edream.110203163054.2370">It is remarkable how recasting the code as two classes clarifies and fortifies the code.</t>
<t tx="edream.110203163054.2371">@nocolor

The new rules allow leo.py 3.1 to read and write .leo files more like leo.py 2.x when there is no leoConfig.txt file.  The scheme used in leo.py 3.0 meant that preferences were _never_ written to .leo files.  It's advantage was that all defaults were specified in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

I think the present scheme is more natural, but we shall see...

In effect, Leo sets and gets various options in the following order of precedence:

1. Use explicit settings in leoConfig.txt if they exist.

2. Use defaults for leoConfig.txt, but only if leoConfig.txt exists.  These defaults are found in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

3. Use settings in .leo files if leoConfig.txt does not exist.

4. If leoConfig.txt does not exist, and the .leo file does not specify a setting, use hard-coded settings in the various classes, just as leo.py 2.x did.

Added the config.configsExist ivar to tell whether leoConfig.txt exists (as far as Leo is concerned).</t>
<t tx="edream.110203163054.2372">Also added tcl keywords for syntax coloring.</t>
<t tx="edream.110203163054.2373">The @pagewidth, @tabwidth and @language directives could not have worked while tangling!  Apparently nobody has every used these directives in @root trees!

1. Apparently, skip_long had never been executed successfully (!!)  Indeed, it computed the value of a string character by character using (s[i] - '0') which has no chance of ever working!

2. The code in tangle.scanAllDirectives that handles @pagewidth and @tabwidth could not have ever worked. is_special_bits sets the dict entries for "page_width" and "tab_width", but tangle.scanAllDirectives looks for dict["pagewidth"] and dict["tab_width"], both of which will cause exceptions!

3. The code in tangle.scanAllDirectives that handles @language failed to set the self.x copies of the c.x ivars relating to language! This bug may have dated from fairly recent times when I changed the tangle code to use the self.x ivars rather than the c.x ivars.</t>
<t tx="edream.110203163054.2374"></t>
<t tx="edream.110203163054.2375">This affects Flatten Outline and Import Flattened Outline.</t>
<t tx="edream.110203163054.2376">While I was at it, I made a few minor changes to leoDialog.py.

1.  Added padx and pady padding in dialogs.
2.  Added text="OK" param to AskOk.
3.  Used center_dialog utility in leoDialog.center.

The leoDialog code is still ugly, but not ugly enough to fix.</t>
<t tx="edream.110203163054.2377"></t>
<t tx="edream.110203163054.2378">I wanted to see if this would corrupt any derived files by interrupting the write.  I doubted that this would be so: events do not work like interrupts.

What happened was that the pending event seemed to slow the writing, and all derived files were written correctly.</t>
<t tx="edream.110203163054.2379">The answer to the question, "why not just improve compare scripts?" is that people rarely use scripts.  A compare window would be much more convenient.  And convenience matters here: it is very important that people feel comfortable importing and exporing files.</t>
<t tx="edream.110203163054.2380"></t>
<t tx="edream.110203163054.2381"></t>
<t tx="edream.110203163054.2382">Found many spelling errors and repeated words.</t>
<t tx="edream.110203163054.2383">We can't just keep getting the x,y coordinates from the event, because then we can't stop.</t>
<t tx="edream.110203163054.2384">All files now pass.  I changed the followoing:

	leoAtFile.py:   found bug: unbound c in read()
	leoColor.py:    removed import keyword
	leoCommands.py: removed unused vars from Convert Blanks.
</t>
<t tx="edream.110203163054.2385"></t>
<t tx="edream.110203163054.2386"></t>
<t tx="edream.110203163054.2387">It was amazingly easy to do this.  We need only compute self.line_height from self.font.metrics().</t>
<t tx="edream.110203163054.2388">Also fixed a but that resulted in Convert Tabs being undoable.</t>
<t tx="edream.110203163054.2389">There were several important optimizations:

1. OnDrag precomputes self.numberOfVisibleNodes().
2. Eliminate all calls to findVnodeWithIconId() in OnContinueDrag.</t>
<t tx="edream.110203163054.2390">Including the split direction and split ration.

Leo now uses all configuration settings from leoConfig.txt.</t>
<t tx="edream.110203163054.2391">Just putting a call to update() in leoFileCommands.getGlobals() does 90% of what we want.  Moving the calls to

	frame.top.deiconify()
	frame.top.lift()
	
from OpenWithFileName to getGlobals gets us to 99% of perfection.  There is a tiny flash when the frame created in leoFrame.__init__ is drawn then withdrawn.

The last 1% is accomplished by withdrawing the newly-created frame in frame.__init__.  With this last change there is no perceptable flash when a window is opened.  Of course, all callers of frame.__init__ must now call deiconify as needed.

Trying not to create a frame at all until its size is known would be much, much harder, because the frame and commands classes initialize each other.
</t>
<t tx="edream.110203163054.2392">The bug was in leoFileCommands.getGlobals.

This was a _really_ irritating bug.  Now windows open where they were when closed.</t>
<t tx="edream.110203163054.2393">This saves the "user" code a lot of work.

Note: if leoConfig.txt does not exist, the default tables in the section called:

&lt;&lt; define default tables for settings &gt;&gt;

in leoConfig.py take effect, so modifying these tables is yet another way of managing preferences.</t>
<t tx="edream.110203163054.2394"></t>
<t tx="edream.110203163054.2395">The present code works wether we destroy the prefs, font and color panels when we close them, or just withdraw them.  It is best to withdraw them, because this preserves their location on the screen when we bring them back.

Some things to keep in mind about this code:

1.  There must be code in frame.OnCloseLeoEvent to destroy these frames if present.  The reason is that these are now non-modal frames, so they could still be open when we close the Leo window that "owns" them.
This is true Regardless of whether these frames are withdrawn or destroyed when closed.

2.  Since the window are no longer modal, we might try creating them after they exist.  In that case, we must simply deiconify the panel, even if we destroy panels when they are closed.

In both cases, we _must_ maintain ivars accurately telling whether the panels have been created or not.  These ivars are owned by the leoFrame class.  They are created by leoFrame when creating a frame, and set to Null by panel code if panels are destroyed when closed.  Since the leoFrame class owns these ivars, a cleaner way would be to create a frameDestroy method for each kind of panel.  But that borders on the pedantic...</t>
<t tx="edream.110203163054.2396"></t>
<t tx="edream.110203163054.2397"></t>
<t tx="edream.110203163054.2398">so code can say getXparam("name") and always get a proper value.</t>
<t tx="edream.110203163054.2399">This was easy to do and useful.</t>
<t tx="edream.110203163054.2400">This was much more work than it "ought" to have been, due mainly to the fact that Tk.ListBox does not have a callback for changed selection.  So the selection becomes active only on a double-click or a change to the size or bold or italics boxes.

The present frame seems to handle all cases properly and without surprise.  The code to do so is tricky.</t>
<t tx="edream.110203163054.2401"></t>
<t tx="edream.110203163054.2402">All that is needed is that each Font and Color panel be firmly connected to a particular Leo window.  In fact, we must have separate Font &amp; Color panels for each Leo window.  The point isn't that we want all these window: in practice there is almost always just one Leo around. The point is that we can eliminate the irritation of modal windows!

This insight also applies to the Preferences panel.  It's not so important for the Find/Change window.</t>
<t tx="edream.110203163054.2403">This was a _huge_ amount of work.  I am quite proud of the result.  The present font panel is much more elegant and less cluttered than the examples I have looked at.  Indeed, the font panel pack a lot of power in a very small space.  I think this is really elegant design.

I spent hours and hours experimenting with different looks.  I finally realized that there is no need for radiobuttons:  they just add clutter.  More importantly, there is no need for an example frame!  The entire Leo window becomes an example.</t>
<t tx="edream.110203163054.2404"></t>
<t tx="edream.110203163054.2405">Leo keywords were mostly being coloring under the keyword settings.</t>
<t tx="edream.110203163054.2406">Using Ok, Cancel &amp; Revert buttons is _much_ better than Ok, Apply, Cancel because changes are made instantly.  The only problem is that the modal dialog makes it impossible to change text.  But with just a little foresight the user could create a "test" document beforehand.</t>
<t tx="edream.110203163054.2407"></t>
<t tx="edream.110203163054.2408">Leo now uses the xml_version_string configuration setting, if present, to override the UTF-8 setting used in all previous versions of Leo.  The usual value of the setting is = ISO-8859-1.  This effective changes Leo's file format: older versions of Leo will not be able to read the new files.

If the setting does not exist, whatever value is present in the .leo file will be written when the file is written.  For new files, a value of ISO-8859-1 will be used when this setting is not present.

Notice that this also affects what is written to the clipboard.</t>
<t tx="edream.110203163054.2409"></t>
<t tx="edream.110203163054.2410"></t>
<t tx="edream.110203163054.2411">Used the following to bind callbac:

@color

for i in xrange(len(self.recentFiles)):
	name = self.recentFiles[i]
	callback = lambda n=i: self.OnOpenRecentFile(n)
	recentFilesMenu.add_command(label=name,command=callback)
	
@nocolor
</t>
<t tx="edream.110203163054.2412"></t>
<t tx="edream.110203163054.2413"></t>
<t tx="edream.110203163054.2414"></t>
<t tx="edream.110203163054.2415"></t>
<t tx="edream.110203163054.2416">1. The @comment directive no longer suppresses syntax coloring.

2. Directives (but not doc parts) are colored when @language plain is in effect.  The user can, as always, suppress all coloring by using @nocolor.

The new rules are much more natural than the old, and much less confusing.</t>
<t tx="edream.110203163054.2417">This was a bit of a fiasco.  I updated CVS without a real test.  Hopefully I'll learn from this.

Anyway, the REM hack is as follows:  Leo will convert underscores in the @comment directives to significant spaces.  For example,

@comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).

I originally inserted a skip_space in sentinelKind where the comment was "Do not skip spaces here!".  However, I eventually settled on a better solution, namely making spaces significant in scanHeader. To quote from scanHeader:

"Leading whitespace is now significant here before the @+leo.  This is part of the "REM hack".  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches."</t>
<t tx="edream.110203163054.2418">The "comment" code was looking for "language", not "comment" in dict.</t>
<t tx="edream.110203163054.2419">I'm proud of the code: it is simpler, clearer and more general than the previous code.

There were several important breakthroughs:

1. The old divideSplitter routine had hard binding to various panes.  This was wrong.  The new divideAnySplitter routine uses params for all frames, so it can be general.

2. The key invariant is that self.splitVerticalFlag tells the alignment of the main splitter.  Getting clear about this was crucial to making everything work.  I could then split the old divideSplitter routine into divideLeoSplitter and divideAnySplitter.  Once that happened, everything just worked when I changed self.splitVerticalFlag from true to false in frame.__init__ (!!)

3. We shouldn't ever delete any frames when toggling the split direction.  It's just too hard to reinitialize them.  The key to making this happen are:

a) the calls to pack_forget and
b) creating placeSplitter from the old createSplitter (now createLeoSplitter) code.

4. The key invariant allows us to define onDragMainSplitBar and onDragMainSplitBar instead of the old onDragVSplitBar and onDragHSplitBar. The new routines work regardless of split direction, so we don't have to rebind the split bars when the split direction changes.</t>
<t tx="edream.110203163054.2420"></t>
<t tx="edream.110203163054.2421"></t>
<t tx="edream.110203163054.2422">Change c.initJoinedCloneBit to c.initJoinedCloneBits.</t>
<t tx="edream.110203163054.2423"></t>
<t tx="edream.110203163054.2424"></t>
<t tx="edream.110203163054.2425"></t>
<t tx="edream.110203163054.2426">Added @root node to root of tree and eliminated @language and @others directives.</t>
<t tx="edream.110203163054.2427">Importing a Python file containing classes without methods results in nested classes.  A workaround is to insert a dummy method in each class.

The fix was to define classIndent and defIndent variables, and to ensure that we break on equality with these values.  Also changed code to generate reference to methods only if methods or nested classes were seen.

There is still a minor bug:  The following

class A:
	pass

Puts the pass statement in &lt;&lt; class A declarations &gt;&gt;.  This bug is not so easy to fix, and it is easy to correct by hand.</t>
<t tx="edream.110203163054.2428">Importing the following file creates orphan nodes for declaration.

import sys # This line becomes an orphaned node
class C:
    xyz = 'xyz' # This line becomes an orphaned node
    def __init__(self):
        pass

The fix was in &lt;&lt; Create a child node for declarations &gt;&gt;.</t>
<t tx="edream.110203163054.2429">Importing the following script

class C:
    def __init__(self):
        pass

created an outline with class C appearing in two nodes, something like:

class C:
        class C:
                def __init__(self):
                    pass

The fix was to &lt;&lt; Append a reference to class_vnode's methods &gt;&gt;.</t>
<t tx="edream.110203163054.2430"></t>
<t tx="edream.110203163054.2431">This fixes a bug involving clone bits, and is much faster than calling c.initAllCloneBits.  The code involves c.moveOutlineRight and similar code in the undo and redo logic.</t>
<t tx="edream.110203163054.2432">Verified that u.undoReplace will handle all clones properly.  c.copyTree simply makes copies of all tnodes after v.copyTree has actually copied the tree.  These are really simple and elegant routines.</t>
<t tx="edream.110203163054.2433"></t>
<t tx="edream.110203163054.2434">The new "replace" paradigm greatly simplifies complex undo.  The ahas:

1. swap_links is a very simple way of replacing trees.
2. The caller of swap_links can easily redo join lists and clone info.
3. We need to use new tnodes in copied trees.  This hasn't been done yet.
4. Undo and redo use exactly the same code.</t>
<t tx="edream.110203163054.2435">The aha is this: the import commands are in essence nothing but an insertion of a tree rather than a single node, so exactly the same code will work for undo and redo!</t>
<t tx="edream.110203163054.2436">@ It is often useful to print a traceback message when a try block unexpected fails.  This can be done as follows:
@color

import traceback
try:
	...
except:
	# traceback.print_exc()
	pass</t>
<t tx="edream.110203163054.2437"></t>
<t tx="edream.110203163054.2438"></t>
<t tx="edream.110203163054.2439"></t>
<t tx="edream.110203163054.2440"></t>
<t tx="edream.110203163054.2441"></t>
<t tx="edream.110203163054.2442">This is important, because it means that invalid entries in, say, the Default Tangle Directory preference will no longer abort an attempted read.</t>
<t tx="edream.110203163054.2443">This is a little tricky.  The general rules are:

1. Settings in the [override .leo file prefs] section of leoConfig.txt override similar settings that exist in the &lt;preferences&gt; element in .leo files.

2. You may cancel this overriding by using "ignore" (without the quotes) as the value of a setting in leoConfig.txt.  For example:

[override .leo file prefs]
tab_width = ignore

In this example, Leo will use the tab width in each .leo file, or a default value if it doesn't exist.

3. Leo won't write overridden settings to .leo files.

The actual rules are as follows:

1. If a setting is not found in either the [override .leo file prefs] section of leoConfig.txt or the preferences section of the .leo file, Leo uses a default, hard-coded value.

2. When reading a .leo file, Leo will use settings in the [override .leo file prefs] section of leoConfig.txt unless the value of the setting is "ignore" (without the quotes).  Case is insignificant when specifying the value of default_target_language.

3. When writing leoConfig.txt, Leo will write settings in the [override .leo file prefs] section of leoConfig.txt if the setting exists in leoConfig.txt and its value is not "ignore" (without the quotes).

4. When Leo saves a .leo file, Leo updates leoConfig.txt (using rule 3) and Leo will write a Preferences setting to the .leo file only if the setting will not be written to leoConfig.txt using rule 3.  NB: this rule does not change Leo's file format because all atrributes of the &lt;preferences&gt; element have always been optional.

5. Leo will update leoConfig.txt (using rule 3) whenever the user closes the Preferences Panel successfully.

As the result of these rules, changes made in the Preferences Panel will become permanent immediately if the the setting will be written under rule 3.  Otherwise, the change will become permanent when any .leo file is saved.

I believe these rules are flexible and good.</t>
<t tx="edream.110203163054.2444"></t>
<t tx="edream.110203163054.2445">These commands convert an entire tree.</t>
<t tx="edream.110203163054.2446"></t>
<t tx="edream.110203163054.2447"></t>
<t tx="edream.110203163054.2448">It is important not to change the c. copies of these ivars.</t>
<t tx="edream.110203163054.2449">These are actually quite nice to have, and they are possible only because we have a modal dialog.</t>
<t tx="edream.110203163054.2450">This makes it absolutely clear what is happening.</t>
<t tx="edream.110203163054.2451">Added @language to all @file nodes.  This is good style.</t>
<t tx="edream.110203163054.2452"></t>
<t tx="edream.110203163054.2453">Gary Herron suggested this change.  This affects a number of commands.  Apparently this makes a difference in Linux...</t>
<t tx="edream.110203163054.2454">This allows us to remove the c.setIvarsFromPrefs routine.  I have left it in as a reminder of what needed to be done formerly.

Removed app().prefs and all references to it.</t>
<t tx="edream.110203163054.2455">This variable should _not_ be eliminated!  It is needed when reading the .leo file for the first time.</t>
<t tx="edream.110203163054.2456">These commands now set self.mFileName only if the dialog succeeds.  This is much more natural.</t>
<t tx="edream.110203163054.2457"></t>
<t tx="edream.110203163054.2458">This was a weird one.  I have no idea what I was thinking about!  Using c.openDirectory makes absolutely no sense.  Probably the c.openDirectory ivar should go away!</t>
<t tx="edream.110203163054.2459">The whole preferences issue needs rethinking and reworking...</t>
<t tx="edream.110203163054.2460"></t>
<t tx="edream.110203163054.2461">DEMOTE:

  Doc: The Demote command makes all the siblings of a node children of
  the node.

  Reality: Not quite: it makes all sibilings WHICH FOLLOW a node into
  children
</t>
<t tx="edream.110203163054.2462">LOG WINDOW:

  Doc: The Open Log Window command opens the window, and the Close Log
  Window command closes it.  Only one of these commands is present in
  the Window menu at any time.

  Reality: These don't seem to exist.
</t>
<t tx="edream.110203163054.2463">INSERT HEADLINE:

  Doc: The Insert Headline command inserts a new headline as the next
  sibling of the currently selected headline.  If the root headline is
  selected, this command inserts the new headline as the first child
  of the root.

  Reality: Insert Headline appears to insert a child if the current
  headline has any children, and it appears to insert a sibling
  otherwise.
</t>
<t tx="edream.110203163054.2464">EXTRACT SECTION COMMAND:

  Doc: The Extract Section command creates a new node ...

  Reality: The menu item is highlighted (no mater what the first line
  contains), but NOTHING HAPPENS (no mater what the first line
  contains).

Leo.py works correctly.  Fixed docs.</t>
<t tx="edream.110203163054.2465">SYNTAX COLORING

  Is never highlighted so can't be used


FONT PANEL:

  Is never highlighted so can't be used

</t>
<t tx="edream.110203163054.2466">At long last cut/paste works properly!

1.  The way to get the contents of the clipboard is:

s = app().root.selection_get(selection="CLIPBOARD")

The following does _not_ work:

s = app().root.selection_get(selection="clipboard")

2.  Added stringIsValidMoreFile and convertMoreStringToOutlineAfter to leoImport.py.  These routines just convert the string to an array and call stringsAreValidMoreFile and convertMoreStringsToOutlineAfter.

3.  Removed app().clipboard ivar.</t>
<t tx="edream.110203163054.2467"></t>
<t tx="edream.110203163054.2468">Once again, things are easier with Python than I expect.  The ConfigParser class is quite nice: it gives a flexible framework for all kinds of preferences.  It would be good to move most, if not all, preferences into this framework.

Note: we no longer need to change the format of .leo files to handle new kinds of preferences!  Indeed, we can just define new sections of leoConfig.txt!

Leo reads and writes leoConfig.txt.  Leo looks first in sys.leo_config_directory.  If that has not been set in sitecustomize.py, then Leo looks in app().loaddir.

</t>
<t tx="edream.110203163054.2469">This assert isn't useful and doesn't have to be true.</t>
<t tx="edream.110203163054.2470">Added code to recover the old .leo file if the write fails.  We create a backup (.bak) file by renaming the .leo file if it exists.  If there is a write error, we rename the .bak file back to .leo.  Otherwise, we just delete the .bak file.</t>
<t tx="edream.110203163054.2471">This was so easy...It should have been done ages ago.</t>
<t tx="edream.110203163054.2472">LeoDocs.leo now matches Leo's web site as closely as possible.  At this point, I consider Leo's documentation completely finished.</t>
<t tx="edream.110203163054.2473">The solutions to the control-H bug was to call v.edit_text.focus_force() in tree.editLabel().

Adding a call to es() in endEditLabel() makes everything work, at least on XP, but this is too strange.  I finaly fixed the problem by having c.insertHeadline call c.endUpdate(false) followed by c.tree.redraw_now().  This is pretty kludgy. Apparently the call to c.endUpdate() was redrawing the outline after the headline had been selected, with the usual bad results.  </t>
<t tx="edream.110203163054.2474">I removed a binding that resulted in double-clicks in headlines expanding or contracting nodes.  You can expand or contract headlines now by double-clicking a node's headline or by clicking its plus/minus box.

This change was requested by Bill Drissel.</t>
<t tx="edream.110203163054.2475">I have spent quite a bit of time on getting dragging to work as smoothly as possible.  This has been made more difficult because I know of know way of reading the state of the mouse button without generating a mouse-moved event.

To start a drag, press the main (left) mouse button while the cursor is over the icon for a node.  The cursor will change to a hand icon. Continuing to drag the mouse will scroll the outline pane if the hand cursor moves above or below the outline pane.  If you release the mouse button while the hand cursor is above another icon, Leo will move the dragged node after the node over which the cursor rests.  If you release the mouse button when the hand cursor is not over an icon, Leo will print "not moved" and leave the outline pane as it is.  This can result in the dragged node not being visible on the screen, but it seems less alarming not to force the current node to become visible as that would undo any scrolling that has just been done.

As usual, there are a number of details.  

1. Leo only allows dragging from one icon to another.  In particular, you can't move a node to the first child of another node unless that node is already expanded.   I experimented with automatically open nodes when the cursor moves over an unexpanded node with children.  However, this was highly confusing.  It seems less alarming to expand and contract nodes explicitly. 

2. Leo scrolls the outline pane as the result of mouse-moved events, so to continue scrolling you must keep moving the mouse.  I experimented with scrolling the outline pane whenever the cursor is dragged outside it, but the results are not good.  There was a noticable delay between releasing the cursors and halting the scrolling.  The present code is simpler and more likely to work on all platforms.</t>
<t tx="edream.110203163054.2476">Note that tangle.scanAllDirectives already did this.</t>
<t tx="edream.110203163054.2477"></t>
<t tx="edream.110203163054.2478">es() failed if log is None because log.newlines does not exist.  The new code alters log.newlines only if log is not None.</t>
<t tx="edream.110203163054.2479">Leo takes an exception.  It may be because tcl 8.3.4+ is required.  The download tcl is 8.3.4.2, but I'm not sure what version is included in Python 2.2.1.</t>
<t tx="edream.110203163054.2480"></t>
<t tx="edream.110203163054.2481">In particular, the theory of operation for Tangle and Untangle was eliminated by mistake several months ago.</t>
<t tx="edream.110203163054.2482"></t>
<t tx="edream.110203163054.2483">There were two problems in this area.  First, v.moveToRoot wasn't preserving the tree when a node was moved to the root.  This caused nodes to disappear.  Second, the code wasn't taking care to change c.tree.rootVnode as needed when nodes moved up or down.

Several important routines had to be changed.  v.moveAfter and v.moveToNthChild now are careful to set c.tree.rootVnode if the root changes.  I hacked v.moveToRoot and v.linkAsRoot so that they update c.tree.rootVnode only if the oldRoot param is not None.  This allows the init code to work properly, and allows the v.moveToRoot routine to properly link in the rest of the tree.  The undo and redo code now use the new param to v.moveToRoot.</t>
<t tx="edream.110203163054.2484">@nocolor

The new code isn't great, and it seems to solve the immediate problem.

@color

try: # 5/27/02: We can get Unicode strings here via cut/paste.
	try:
		self.outputFile.write(s)
	except UnicodeError:
		self.outputFile.write(`s`)
except:
	es("error writing:" + `s`)</t>
<t tx="edream.110203163054.2485">After creating some clone nodes with the Borland version of Leo, LeoPy.leo was corrupted.  Reading the damaged file with Read Outline Only works, so apparently the problem involves the clone indices in the derived files.

The problem was that not all the code in atFile::updateCloneIndices got copied back to the Borland code.  In particular, clone indices were not cleared before being reassigned!</t>
<t tx="edream.110203163054.2486"></t>
<t tx="edream.110203163054.2487">Added skip_matching_delims utility function.</t>
<t tx="edream.110203163054.2488">Removed extra whitespace between sections.

Fixed bug in convertCodePartToWeb: added code to skip @file line.</t>
<t tx="edream.110203163054.2489">This was an attempt (probably futile) to fix a crash in cut/paste logic.</t>
<t tx="edream.110203163054.2490">This allows the the last filename used to be the default for the Outline To Noweb dialog.</t>
<t tx="edream.110203163054.2491">We generate &lt;&lt;*&gt;&gt;= only if no file name is given in @root or @file.  The old code always generated * for @root.

Also, changed &lt;&lt; append head_ref &gt;&gt; so that @c generates &lt;&lt;fileName&gt;&gt;= instead of &lt;&lt;*&gt;&gt;= whenever possible.</t>
<t tx="edream.110203163054.2492">I rewrote isDocStart.</t>
<t tx="edream.110203163054.2493"></t>
<t tx="edream.110203163054.2494"></t>
<t tx="edream.110203163054.2495">Moving an outline up before the "root" node hung in v.setDirty.

The fix was in c.moveOutlineUp: we must call v.moveToRoot, followed by back.moveAfter.  To make this work, v.moveToRoot must leave the mFirstChild link unchanged.

Fixes were also needed in undo.undo() and undo.redo() to handle this special case.</t>
<t tx="edream.110203163054.2496">This fixed a bug that caused Leo to hang when syntax coloring noweb code with the CWEB syntax colorer.</t>
<t tx="edream.110203163054.2497">This routine must take into account the kind of file being imported.</t>
<t tx="edream.110203163054.2498">There are many details here.  The present code handles substantial code well, and looks good.</t>
<t tx="edream.110203163054.2499">The green used by IDLE looks really good to me.</t>
<t tx="edream.110203163054.2500">The code now purports to work for both CWEB and noweb files.</t>
<t tx="edream.110203163054.2501"></t>
<t tx="edream.110203163054.2502">Outline To Noweb creates &lt;&lt; * &gt;&gt; sections when it doesn't know what name to give something.  This may be partially correct, or entirely wrong.</t>
<t tx="edream.110203163054.2503">Please note that the same mechanisms work unchnaged for both @root and @file trees.</t>
<t tx="edream.110203163054.2504">I hacked the Python and Java code (hacks on hacks) to insert nodes to carry @others commands when generating @file trees.  The Python code now handles nested classes fairly well.

At this point I'm not sure what is a bigger kludge, the "parsing" parts or the "code generation" parts.  I really don't want to do full parsing here, but the present code is pretty wild.  OTOH, it works.

Fixed bug in skip_pascal_string.

Split the Import Files command into Import To @file and Import To @root.</t>
<t tx="edream.110203163054.2505"></t>
<t tx="edream.110203163054.2506">Debugged the Import Files command for .py files.  The main problems were getting the params to the scanPythonX routines correct: these were just transcription problems.

Fixed 2 bugs in the colorizer: it wasn't handling Python triple strings or C preprocessor directives properly.

Fixed a bug in skip_python_string.  It was returning the start of the ending delim, not past it.</t>
<t tx="edream.110203163054.2507">It only took an hour.  I am amazed this hasn't been done long ago.</t>
<t tx="edream.110203163054.2508"></t>
<t tx="edream.110203163054.2509">Issue the "reading:" message only if the file can be opened.
Eliminated the #--- error reading x" message before read errors.</t>
<t tx="edream.110203163054.2510">Added a return value to update_def so that skip_body can tell if a node has been changed.  skip_body now calls v.trimTrailingLines only if the node has changed.</t>
<t tx="edream.110203163054.2511">Untangle was setting the pane changed even when not reporting any changes.  This was due to a call to v.trimTrailingLines.  Changed v.setBodyStringOrPane so that it calls c.setChanged and v.setDirty only if the new text is different from the old, but this doesn't completely solve the problem.</t>
<t tx="edream.110203163054.2512">These are helpful in leo.py because the commands are slower than in LeoCB.</t>
<t tx="edream.110203163054.2513"></t>
<t tx="edream.110203163054.2514"></t>
<t tx="edream.110203163054.2515">The code mistakenly set part to zero before calling update_def, with the result that the wrong parts were compared.  This simple blunder took several hours to find.</t>
<t tx="edream.110203163054.2516"></t>
<t tx="edream.110203163054.2517"></t>
<t tx="edream.110203163054.2518"></t>
<t tx="edream.110203163054.2519">Documented new file format, unlimited undo/redo, auto indent, Contract Parent and Sort Siblings commands.</t>
<t tx="edream.110203163054.2520">Note: this code is still untested and very likely has major bugs.</t>
<t tx="edream.110203163054.2521">I did this to reasssure myself that such changes were benign, and they are: all files Tangle and Untangle as before.  Also, @space (or @doc) is needed at the start of all doc parts so that Leo2 will syntax color them properly.

This took quite a bit of time, and I really should do this for all of LeoCB.leo, or alternatively, convert all of LeoCB.leo to @file trees.  I'll probably leave this as an exercise for someone else to do ;-)  Actually, the proper way to do this is probably to write a Python script.</t>
<t tx="edream.110203163054.2522">The code is straightforward.</t>
<t tx="edream.110203163054.2523"></t>
<t tx="edream.110203163054.2524"></t>
<t tx="edream.110203163054.2525">Fixed &lt;&lt; Scan and define an @code defininition &gt;&gt; and &lt;&lt; Scan and define a section definition &gt;&gt; in skip_body.  The calls to skip_code were setting k, not i.  I'm not sure how Tangle could ever have worked before.  Perhaps a reversion of some kind.

With these fixes, all files are tangled identically by LeoCB and leo.py.

Removed trailing lines in code part in st_enter.  With this change almost all files compare identical except those containing (!newline).  Fixed a bug in put_section which caused whitespace not to be properly output after (!newline).  With this fix leo.py tangles all files in tangleTest.leo exactly the same as LeoCB!</t>
<t tx="edream.110203163054.2526">One bug remains in the Borland version and will probably never be fixed: Preferences settings do not stick to windows.  This is a result of using the arg_xxx vars rather than ivars.</t>
<t tx="edream.110203163054.2527"></t>
<t tx="edream.110203163054.2528"></t>
<t tx="edream.110203163054.2529">It is intolerable to have misleading syntax coloring.  The syntax colorer treats @c just like @code.  Tangle must do the same.</t>
<t tx="edream.110203163054.2530">Made the root arg optional.  If present it is a list with one element and is_special_bits checks for @root.  We pass a list of one element to is_special_bits so we can distinguish between None and [None].

Removed @owncolor code.</t>
<t tx="edream.110203163054.2531">In leoFrame.py: make the font size platform-dependent.
In leoTree.py: use os.path.join to join Icons and file names.</t>
<t tx="edream.110203163054.2532"></t>
<t tx="edream.110203163054.2533">''' wasn't handled like """</t>
<t tx="edream.110203163054.2534">pychecker is a marvelous tool.  It fixes most of the problems that compilers fix.</t>
<t tx="edream.110203163054.2535">Caught by pychecker:  the call to special_bits was missing the i param.  This would cause a fault when executed.</t>
<t tx="edream.110203163054.2536">changed mStartSentinelComment to self.startSentinelComment.
changed mEndSentinelComment to self.endSentinelComment.</t>
<t tx="edream.110203163054.2537">changed writeError to self.writeError.</t>
<t tx="edream.110203163054.2538">Changed message to self.message in BadLeoFile.__init__.

Changed param to es in getTnode().</t>
<t tx="edream.110203163054.2539">Initialized s to "" in moreHead.

Note: v.trimTrailingLines does nothing(!)

removed v.saveOutlineWithLevel.  This uses dvnodes and is old, old code.

removed v.setThreadLinks.  This was a bad idea that should have gone away a long time ago.</t>
<t tx="edream.110203163054.2540">x Changed all arg_ vars to ivars in scanAllDirectives:
	arg_present_language --&gt; self.language
	arg_tab_width --&gt; self.tab_width
	arg_page_width --&gt; self.page_width
	arg_use_header_flag -&gt; self.use_header_flag
	These will affect the @comment and @language directives!
x Changed set_root_delims() to self.set_root_delims()
x Changed end_sentinel_len to len(end_sentinel)
x Changed sentinel_end to self.sentinel_end in scanDerivedFile.
x Added c = self.commands in massage_block_comment. (This routine is never used, though).
x Removed extra param to match in put_section.
x Initialized code = None in skip_body.
x Initialized path in untangleRoot before error messages that use path.
x Used marked_flag properly in untangleMarked.</t>
<t tx="edream.110203163054.2541">A weird one: LeoCB was removing the last character (typically half of a cr-lf combination), probably in the mistaken belief that it was an end-of-file character.  Geeze:  how do C++ programs ever work when you have to deal with minutia like eof marks and 2-character newlines.  Tk has really spoiled me.

I added code to leo.py to ensure that even compressed derived files end in a newline, which will help.</t>
<t tx="edream.110203163054.2542"></t>
<t tx="edream.110203163054.2543">Emailed Guido.  He indicated that the fix just involves filenames, so I took a look at it immediately.  Used Leo to study the code and made a simple fix.</t>
<t tx="edream.110203163054.2544">This fixes a serious hole in Leo:  The read logic would crash (report corrupted sentinels) if what follows a reference looked like a sentinel line!</t>
<t tx="edream.110203163054.2545">It turns out to be easy to suppress newlines between sentinels.  It is a bit harder to make the read logic work properly.

By single-stepping through the Borland code (which also fails when newlines are suppressed) I see that there is logic in scanText that checks for a non-blank line after a +body sentinel!  By adding a check to see that the next line is not another sentinel line we can make the read logic work properly.

I wonder: suppose the text after a reference looks like a sentinel?  What happens then?</t>
<t tx="edream.110203163054.2546"></t>
<t tx="edream.110203163054.2547">Fixed a bug that for all languages (like Python and Perl) that do not have block comments.  The change was to update_def.</t>
<t tx="edream.110203163054.2548">Three characters were colored blue at the start of a section def in:
  &lt;&lt;name&gt;&gt;=
The fix was to change k to 2 in one spot.</t>
<t tx="edream.110203163054.2549"></t>
<t tx="edream.110203163054.2550">This is the only undoable command.  Now it puts up a dialog saying that.</t>
<t tx="edream.110203163054.2551"></t>
<t tx="edream.110203163054.2552"></t>
<t tx="edream.110203163054.2553">Optimize Undo Typing by suppressing the "oldText" entry in the dict if the previous entry was "Typing" and the vnode match.  This optimization saves almost half the space used in the bead list!

Verified that the Change All and Read @file Nodes commands call clearUndoState().

The "Cut", "Copy", "Delete", "Change", "Convert Blanks", "Indent", "Undent" are now undoable.  The only change was a new param to the body key handler.

Created onBodyWillChange event handler.  We must distinguish between commands like "Find, Then Change", which must call onBodyChanged, and commands like "Cut" and "Paste" that must call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.

Keystrokes in the headline are now undoable.</t>
<t tx="edream.110203163054.2554">The code is hardly more complex than the old limited code.  In many places it is simpler.

The code now saves only the "optional" ivars that are non-None.  This should be an important space optimization for "Undo Typing".

While messing with Undo in the body pane I realized I could simplify idle_body_key a bit.  I believe this is important.</t>
<t tx="edream.110203163054.2555"></t>
<t tx="edream.110203163054.2556">alt-v now work in @nocolor mode.</t>
<t tx="edream.110203163054.2557"></t>
<t tx="edream.110203163054.2558"></t>
<t tx="edream.110203163054.2559">Almost all of the logic is language independent!

Added keywords for c,pascal,perl &amp; python.</t>
<t tx="edream.110203163054.2560">skip_doc must test for actual strings, not the return value from token_type.</t>
<t tx="edream.110203163054.2561">This was a fix to the syntax colorer only.

Also colored the equal sign in &lt;&lt;name&gt;&gt;=.</t>
<t tx="edream.110203163054.2562">Added undoers for Cut/Past Node commands and Sort commands.

Apparently the Copy Node command has no undo consequences.

Added calls to clearUndoState for Read and Import commands.  Actually, the Import commands could easily be undone: they are just like insert commands.

Decided not to clear the undo state after Save commands.  Do so is confusing and seems pointless.  I may revisit this issue when implementing Unlimited Undo.</t>
<t tx="edream.110203163054.2563">These are not present in the CVS tree.  They should be.

c2py.py, openLeo.py, tangle_done.py, untangle_done.py, __init__.py.</t>
<t tx="edream.110203163054.2564"></t>
<t tx="edream.110203163054.2565">Most problems had to do with changing c.undoX to c.undoer.undoX or u.undoX.

Everything with an undoer now works.

Cut/Copy/Paste Nodes have no undoers.
Sort commands have no undoers.</t>
<t tx="edream.110203163054.2566">Apparently WinCVS is set up appropriately.  Remember to use my corrct password

Did a checkout from the create menu and everything went well!</t>
<t tx="edream.110203163054.2567"></t>
<t tx="edream.110203163054.2568">It is clear that broken clone links can't be mended automatically.  That is, Leo can't be made significantly more CVS friendly.  That being so, let us consider how to use CVS with Leo.

Our goal is this: we don't want clone links to break when we check derived files into or out of the repository.  In general, clone links will break whenever we a read derived file from a .leo file different from the .leo file that created it.  So to meet our goal we must obey the following rules:

Rules for using Leo files with CVS:
	
1. All derived files in a particular revision in the CVS repository must be generated by a single .leo file. Call that file the _generating_ .leo file (for the revision as a whole and for each derived file in particular).
	
2. When we check out files from the repository we must check out the generating .leo file in addition to the derived files that we are checking out.

3. When we check in files to the repository we must check in the single .leo file that generated the derived files that we are checking in.

4. When CVS detect update conflicts in derived files, developers must resolve those conflicts in a "merged" .leo file.  All derived files that are later checked in must be derived from this .leo file.  When creating this merged .leo files, developers should take care to retain clone links.  

These rules make a virtue out of necessity.  I always envisioned that update conflicts would have to be resolved in .leo files rather than derived files.  What I now see is that this is the also the only way to prevent clone links from being broken.</t>
<t tx="edream.110203163054.2569">Just after I completed the Mending Dialog I realized that the concept behind this dialog was fatally flawed: cloned nodes must have the same structure!

Indeed, at the time the Mend Clone dialog is put up, the user would have no way of knowing whether any joins made sense.  Conceivably Leo could test for structural simularity, and in that case this dialog would be useless.  Note: many read errors arise from structural mismatches; clones could never be mended properly in those cases.

About the only situation in which mending would be possible is if the only differences between trees were outline differences.  This suggests that we don't test headline text at all and just rely on structure identity.</t>
<t tx="edream.110203163054.2570">This dialog returns a list of pairs of names.  It is up to the caller to associate the names with vnodes.</t>
<t tx="edream.110203163054.2571"></t>
<t tx="edream.110203163054.2572"></t>
<t tx="edream.110203163054.2573">Moved these out of the frame class: the undo class also uses them.</t>
<t tx="edream.110203163054.2574">We want to remove only the leading whitespace present on the first line, not all leading whitespace!

Also, the Extract Section command was deleting the section reference line.

I could have sworn I tested these commands.  Apparently not.</t>
<t tx="edream.110203163054.2575"></t>
<t tx="edream.110203163054.2576">It appears that DnD will be straightforward: probably less then 100 lines of code!</t>
<t tx="edream.110203163054.2577">Removed "blank" and "tab" tags on entry.  I thought I did this!  Anyway, it remains to be seen whether this has any effect on the "disappearing" selection bug.

I did some perfunctory tests on the various find/change commands and everything appears to be working well.  We shall see...</t>
<t tx="edream.110203163054.2578">Made headlines longer in tree.headWidth(). Sometimes the right edge of a headline was being cut off.  This must be a Tk bug, and the workaround is easy enough.</t>
<t tx="edream.110203163054.2579">Cleaned up the code in several ways.  Some of these have been bugging me for a while.

Yesturday I realized that the proper time to clean up code is just _after_ a release.  That way the new code will be thoroughly tested before the next release.

c.tree.currentVnode -&gt; c.currentVnode()
Used keyword.iskeyword() in leoColor.py to test whether a word is a Python keyword.
Used string.endswith() in Import code.
Renamed is_c_word() to match_c_word() to be compatible with the match and match_word names.</t>
<t tx="edream.110203163054.2580"></t>
<t tx="edream.110203163054.2581">This is used in v.sortChildren and in leoImport.sort testing routine.  Apparently the latest code is about the best that can be done.  Passing a param to the list.sort() routine might seem elegant, and apparently it is slow.  Also, it is not clear how to pass the "n" param to the sort routine. I might challenge the net to do better, but the present code works and is fast, general, elegant and clear.</t>
<t tx="edream.110203163054.2582">Experimented with using Python's inspect module.  However, it doesn't provide nearly the level of parsing needed for Leo's import commands.  We need access to the entire parse tree.  It is probably possible...</t>
<t tx="edream.110203163054.2583"></t>
<t tx="edream.110203163054.2584">Removing from leoUtils import * from reload_all() will cause problems.  The only workaround appears to quit Python when modifying leoUtils.  Sigh.</t>
<t tx="edream.110203163054.2585"></t>
<t tx="edream.110203163054.2586">This is a really useful command!</t>
<t tx="edream.110203163054.2587">This is quite tricky code.  To capture changed values we typically must set a commands method that calls an idle routine. We can't capture the values by binding Button clicks because values haven't changed yet, or so it seems.

Anyway, the preferences panel settings now appear to "stick" to the presently active window.

The print_prefs routine was vital to sorting out what was happening.</t>
<t tx="edream.110203163054.2588"></t>
<t tx="edream.110203163054.2589">Now the real work begins.</t>
<t tx="edream.110203163054.2590">This will serve as a start for CVS.</t>
<t tx="edream.110203163054.2591">Added commands handler for all radio buttons.  There was a timing problem: it took 2 clicks to set the current language.  Also added code to recolor the body pane immediately.</t>
<t tx="edream.110203163054.2592">It is vital that @file nodes remain dirty until they are written without errors.  Otherwise, a Save command will succeeed without warning, and a later read may cause the dreaded "clones have been cleared" message.</t>
<t tx="edream.110203163054.2593">The settings in the Preferences panel now "stick" to the current window.  This turns out to be very important for Tangling: I ran into serious problems with Tangling to the wrong directory when more than one window was open.</t>
<t tx="edream.110203163054.2594"></t>
<t tx="edream.110203163054.2595">This turns out to be more useful than Sort Children.</t>
<t tx="edream.110203163054.2596"></t>
<t tx="edream.110203163054.2597">All the "Tangle" Constants must be defined in the same place.  It turns out that leoUtils no longer use any of these constants anyway, so I moved them to leoTangle where they have always belonged.

scanError() is now the only part of leoUtils that uses Tangle data.  It accesses the commands instances using the top() function.  A kludge...

In any event, when I split them I also defined some new values, so values from leoGlobals.py overlapped with values from leoTangle.py.  It is a good thing I caught the problem now...</t>
<t tx="edream.110203163054.2598"></t>
<t tx="edream.110203163054.2599">Moved the tangle constants into the tangle class.

Changed header to self.header in an error message in scanAllDirective.

The source of the "mismatch" in Utils.h was that somehow I inserted @c into the root of Utils.h, which should produce errors, and eventually it did.</t>
<t tx="edream.110203163054.2600">I reset the default tangle directory while doing regression testing, then saved LeoPy.leo.  This destroyed files LeoPy directory, I'm not sure how, so I had to revert.  All looks well now.</t>
<t tx="edream.110203163054.2601"></t>
<t tx="edream.110203163054.2602">There was a problem with a global change command.  I'll have to do a full regression test of Tangle.  This would be a good time to use the new whitespace utility routines.</t>
<t tx="edream.110203163054.2603"></t>
<t tx="edream.110203163054.2604">This was the result of a Change All disaster.</t>
<t tx="edream.110203163054.2605">We have to update s_text as well as c.body so that another call to search on the same line will find the updated text.</t>
<t tx="edream.110203163054.2606"></t>
<t tx="edream.110203163054.2607"></t>
<t tx="edream.110203163054.2608">Newlines now set the dirty bit.

We increase auto indent after a colon.  This should happen only for Python mode...</t>
<t tx="edream.110203163054.2609"></t>
<t tx="edream.110203163054.2610">Once again, I am astounded at how easy this is.</t>
<t tx="edream.110203163054.2611">Convert Blanks now converts the entire body pane if there is no selected text.</t>
<t tx="edream.110203163054.2612">It is doubtful that leo.py will ever support a Print command directly.  Rather, users can use export commands to create text files that may then be formatted and printed as desired.  Tk does provide print support.</t>
<t tx="edream.110203163054.2613">Only blanks and tabs are shown, and they not very well.

What we need is a font that shows blanks and tabs as descent symbols for blanks, tabs and newlines.</t>
<t tx="edream.110203163054.2614">The key is that two things have to happen:

1. Menu items should be enabled only when focus is in the canvas pane.
2. Bindings for for the outline commands should be added only to the canvas pane.</t>
<t tx="edream.110203163054.2615"></t>
<t tx="edream.110203163054.2616">A useful convenience method that makes it much clearer what is going on.</t>
<t tx="edream.110203163054.2617"></t>
<t tx="edream.110203163054.2618"></t>
<t tx="edream.110203163054.2619"></t>
<t tx="edream.110203163054.2620">Sherlock attempts to read the file SherlockArgs.  If found, each line is assumed to be a separate sherlock argument.

However, the main improvement is defaulting empty arguments to "+*".  This makes tracing as easy to use as print statements.

Could trace accept multiple arguments, just like print?  No: we would lose the ability to specify tracepoints by default.  There is no need to duplicate print!</t>
<t tx="edream.110203163054.2621">Very easy to do, compared with other systems.</t>
<t tx="edream.110203163054.2622">This should solve some compatibility problems.</t>
<t tx="edream.110203163054.2623"></t>
<t tx="edream.110203163054.2624">Alt-1 refers to Alt-Button-1, not Alt-Key-1 (!)</t>
<t tx="edream.110203163054.2625">Changed frame.put routines so that they return during quitting.

Also removed trace statements from __del__ routines.</t>
<t tx="edream.110203163054.2626">We must be careful to enclose all find/change code in c.beginUpdate/c.endUpdate(false) so a redraw after the call to tree.redraw_now() in find.showSuccess won't deselect the headline text.

It would be elegant to cancel any pending redraw in tree.redraw_now, and that does not seem to work.

Because we don't always redraw the screen, we must update icons "by hand" by calling c.tree.drawIcon.

It is very tricky to compute self.in_headline correctly.

Perhaps a more sensible approach would be to have the tree.redraw routine save and restore the editing status and selection of the current headline.  However, the present code works and minimizes redraws, so there isn't much incentive...</t>
<t tx="edream.110203163054.2627">The idea was that if all drawing happens at idle time we could do the following:

	Eliminate all c.beginUpdate()
	Eliminate all c.endUpdate(false)
	Replace c.endUpdate() with c.redraw()
	Replace c.endUpdate(flag) with if flag: c.redraw()
	
However, the find command needs to _prohibit_ drawing, and there doesn't seem to be a clean way to do this, so using c.endUpdate(false) seems to be needed.

In other words, without c.endUpdate(false) we would need c.cancelDrawing(), and this doesn't seem any cleaner than the present code.</t>
<t tx="edream.110203163054.2628"></t>
<t tx="edream.110203163054.2629">I messed things up when I "optimized" the redraw code.  The Find code must redraw the screen _before_ making selections in the headline--otherwise the headline becomes inactive.</t>
<t tx="edream.110203163054.2630">Altered the Cut/Copy routines so they set Leo's internal clipboard (app().clipboard).  So to cut from LeoCB to leo.py do the following:

Copy the tree in LeoCB.
Paste the tree into empty body text of leo.py.
Select all the body text and paste.
Move to the tree view, and do a Paste Node.

Yes, this is very clumsy, but how often do we want to transfer information between LeoCB and leo.py?</t>
<t tx="edream.110203163054.2631">This is defensive programming.  Only a few event handlers override body handlers:  These include Control-I, Control-T and Control-D.

Exception: the command handlers for cut/copy/paste must _not_ return "break"!  The actual work is done by the Tk.Text widget.</t>
<t tx="edream.110203163054.2632"></t>
<t tx="edream.110203163054.2633">Now that event handlers return "break" they can do things involving focus that they could not do before.</t>
<t tx="edream.110203163054.2634">This is done in frame.createAccelerators().  For the first time leo.py handles keystrokes properly!

We could override _all_ body pane keys, and this would be dangerous until all event handlers return "break."  Indeed, doing so would create duplicate bindings, one for frame.top and one for frame.body, so without a "break" the command would be done twice!</t>
<t tx="edream.110203163054.2635"></t>
<t tx="edream.110203163054.2636">Event scripts need only return the string "break" to inhibit all further event processing!  This is what I have been missing all along, and it was staring me right in the face.  Sheesh.

This eliminates the need for several kludgy workarounds:
	The double-click event handler no longer needs to wait till idle time.
	The c.moveDown routine no longer needs to call c.select.

Another breakthrough.  Way down at the bottom of the Tk.Text documentation I discovered a list of all the key bindings defined by default in Text widgets.  This includes Control-O, which explains why body text sometimes had blanks lines inserted at the top. (Amazingly, Control-O never seems to have split lines, purely by luck.)

I can now use control-I to insert nodes again!</t>
<t tx="edream.110203163054.2637">This is similar to the double-click logic!</t>
<t tx="edream.110203163054.2638">We must compute the word to be selected before the Tk.Text widget does its default double-click handling, then actually select the text at idle-time.</t>
<t tx="edream.110203163054.2639"></t>
<t tx="edream.110203163054.2640">The code was easy to write and worked the first time.  I love Python.  I chose to ignore case in the comparison.

A more elegant solution would be to define a v.__cmp__ method, but the present code is clear enough and works.</t>
<t tx="edream.110203163054.2641">Fixed the Tangle Marked command.  It had numerous problems.

The code that executes Leo_done.bat and Leo_un.bat didn't work.  Now these options specify Python scripts to execute, and these scripts are passed a list of filenames that were tangled or untangled.</t>
<t tx="edream.110203163054.2642">Created go.bat and openLeo.py.  These simplify the process of starting leo.  Just open a console window and type go.

Added "c:\prog\LeoPy\LeoPy.leo" as default to filename argument to leo.open().</t>
<t tx="edream.110203163054.2643"></t>
<t tx="edream.110203163054.2644"></t>
<t tx="edream.110203163054.2645">The whole-word search only fails if there are two consecutive "in-word" characters at the beginning or end of the supposed match.

Added some logic to make suboutline-only searches work correctly.

In the process, discovered a bug in is_c_id.  It was testing for blank instead of underscore!</t>
<t tx="edream.110203163054.2646">tree.select now calls tree.recolor_now instead of tree.recolor.  The result is much better than before.

Did add the tree.updateScheduled ivar and logic.  This ensures that only one redraw ever happens at idle time.  It seems like the body text is drawn much faster now.  This may have been a big performance bug!

At present the performance of leo.py seems excellent.</t>
<t tx="edream.110203163054.2647">When the "Move Down" command did nothing the control-d ate the character at the cursor!  The workaround is to have c.moveOutlineDown call c.selectVnode(v) even if nothing happens.  This forces the body text to be restored.</t>
<t tx="edream.110203163054.2648">c.makeVisible and even c.beginUpdate/c.endUpdate can be eliminated!  Indeed, the tree class can work as follows:

1. All ancestors of the current node are expanded at the start of tree.redraw.
2. The current node is scrolled into view at the end of tree.redraw.

We want to do the expansion of nodes before drawing so offsets are computed properly.  We must do scrolling after idle tasks are complete so Tk.Scrollbar.get() will return proper values.

Note: we still may want to inhibit drawing even though all drawing happens at idle time.  We don't really need begin/endUpdate to do that:  just keep a flag and call c.redraw() only if the flag is true.

I'm not going to eliminate c.beginUpdate/c.endUpdate just yet.</t>
<t tx="edream.110203163054.2649"></t>
<t tx="edream.110203163054.2650">Eliminated redundant error messages.
All path problems now generate an error.  This seems safest.</t>
<t tx="edream.110203163054.2651">tree.makeVisible and tree.scrollTo are called before the tree is redrawn, so we can't get accurate measurements from the canvas class.  I created tree.yoffset() and tree.lastVisible() to get proper measurements.  The final code is deceptively simple; it took several hours to get it all right.

This is an important step forward because now the screen is drawn properly during interactive search commands.  It would have been intolerable to release Leo with only partly functional Find commands.

There are still "policy" questions about when and how to scroll.  The present code doesn't work smoothly in all cases.  It may be that the Tk.canvas.yview routine doesn nothing in certain unexpected situations.</t>
<t tx="edream.110203163054.2652">I have spent several pleasant hours preparing setup.py, manifest.in and sdist.bat.

Create a source distribution (.zip file) by running sdist.bat from c:\prog\LeoPy.

I have not been able to create a .gzip file yet.</t>
<t tx="edream.110203163054.2653"></t>
<t tx="edream.110203163054.2654"></t>
<t tx="edream.110203163054.2655">There was an assignment kind = kind in the section &lt;&lt; set kind for directive &gt;&gt;, so @chapter, @section were never recognized.  Amazingly, this blunder did not seem to affect anything else.

With this this bug fixed, all files in LeoCB.leo are tangled the same by LeoCB and leo.py, except for the first line and whitespace.  The first line is different because LeoCB puts slashes differently than leo.py.

When ignoring only trailing whitespace and blank lines, we see that LeoCB and leo.py differ in how they output (!newline).  LeoCB outputs a single space before (!newline) in put_section(), so this is what leo.py must do as well.

With this bugs fixed, the only differences between LeoCB.leo and leo.py involve leading and trailing whitespace and blank lines.  Tangle works!  Actually, leo.py now does a better job than LeoCB, for the following reasons:

1. leo.py does a good job of deleting trailing blank lines in sections, and this should simplify Untangle.
2. leo.py does a better job of putting leading whitespace than LeoCB, because leo.py more accurately computes the effective width of leading whitespace than does LeoCB.</t>
<t tx="edream.110203163054.2656">This allows us to open a file when leo starts.  From the Python interpreter do the following:

import leo
fn = "c:\prog\LeoPy\LeoPy.leo"
leo.open(fn)

The open script is the companion to the run and go scripts.  leo.run() just runs leo.  leo.go() reloads all modules before running. For reasons that I don't fully understand, leo.go() does not always handle leoUtils properly: it is sometimes necessary to do

from leoUtils import *</t>
<t tx="edream.110203163054.2657">Actually, clicking on another node should probably reset the "wrap_node", but it doesn't.  Only changing something in the Find panel does that.</t>
<t tx="edream.110203163054.2658">Tested paths when Leo invoked directly.
Tested explicit paths in @file nodes
Tested paths in prefs panel.
Tested paths in @path directive.
Tested no path anywhere.

As a result, changed writeError by error in atFile.scanAllDirectives.</t>
<t tx="edream.110203163054.2659">frame.defaultDirectory was never being used.</t>
<t tx="edream.110203163054.2660"></t>
<t tx="edream.110203163054.2661">It appears that putting the following in app.finishCreate will work:

	import leo
	loaddir = os.path.dirname(leo.__file__)

Apparently we can not reference leo.__file__ reliably until leo has been completely imported.  The workaround is to do so in app.finishCreate.  This is a bit mysterious, and it appears to work.</t>
<t tx="edream.110203163054.2662">The new path philosophy is as follows:

1. Leo will not call os.chdir except possibly after file dialogs that are not cancelled.  This will leave the file system's current directory (returned by os.getcwd()) unchanged by tangling, importing, reading or writing.

2. Commands that access files (tangling, untangling, reading, writing, importing) call either os.getcwd(), atFile.scanAllDirectives or tangle.scanAllDirectives to set appropriate ivars indicating what the proper default directory will be.

3. These commands open a file as follows, where self.default_directory is set in step 2:

	fn = os.path.join(self.default_directory, fileName)
	f = open(fn,...)</t>
<t tx="edream.110203163054.2663">@file trees were not being marked as dirty when cloned headlines outside those trees were changed.  This definitely would have caused errors while reading @file trees!  Fixing this bug is a big step forward.

The fix was to to have v.setDirty() ensure that all cloned nodes are set dirty and that all ancestor @file nodes are set dirty.  I eliminated v.setDirtyJoined() entirely, and eliminated all calls to v.setAncestorAtFileNodeDirty() outside of v.setDirty().  The result is much safer, cleaner and simpler code.

As a side effect, nodes now become dirty when they move.</t>
<t tx="edream.110203163054.2664">leo.py used to call chdir from many places to indicate which default directory should be in effect.  That was wrong. From now on, leo.py will call chdir only file dialogs return without being cancelled, that is, for Open, Save and Import commands.

Otherwise, directives will set ivars, and the code will compute full path names using
os.path.join(directory_ivar, pathname).  The neat thing about this is that if pathname already contains a full path name it will override the path in directory_ivar.

For example, the Tangle code now writes the final file like this:

	file_name = os.path.join(self.tangle_directory,section.name)
	... # tangle into temp file
	update_file_if_changed(file_name,temp_name)

This works properly whether or not section.name contains a full path name.</t>
<t tx="edream.110203163054.2665">If the present node is expanded, the Paste Nodes command now pastes the pasted node as the first child of the present node, rather than as the next sibling of the present node.</t>
<t tx="edream.110203163054.2666">trace(a) prints a if s is a string and executes a() if a is a function.</t>
<t tx="edream.110203163054.2667">The symptom of the bug was that it was taking a _long_ time to close windows after doing many interactive find commands.  Actually, it was redrawing the tree that was the real problem.

Disable the recycling of nodes made no difference.  By removing code I isolated the performance bug to the call to tree.redraw in find.showSuccess().  This was very good news, as it meant that the bug was in the tree code rather than in Tk or Tkinter.

The bug was caused by "extra" links to the Tk.text widgets in the vnode, specifically, the v.box_id, v.edit_text_id, v.icon_id and v.box_id ivars.  These links apparently created permanent references that prevented widgets from being deallocated when the tree was redrawn, so a large number of widgets and their binding had to be deleted when the tree was deleted.

The fix was just to eliminate these vnode ivars entirely: they were not being used!  The v.edit_text ivar could not be eliminated, so I added a call to self.edit_text.destroy() just before reallocating.  Perhaps just moving the edit_text would be better than destroying and reallocating it, but that wouldn't be so easy because of the call to self.canvas.destroy("all").</t>
<t tx="edream.110203163054.2668">If a clone problem is reported, the @file node is not marked dirty again, so if we save the .leo file and then quit the problem will still exist in the derived file.

This happened in Borland Leo, so it is clear if it is a problem in leo.py.

I recovered by doing a Read Outline Only.</t>
<t tx="edream.110203163054.2669"></t>
<t tx="edream.110203163054.2670">Moved Tangle utils into Tangle leoTangle.py.  These should be methods because they deal with tangle ivars.

Separated utils that call scanError from other utils.</t>
<t tx="edream.110203163054.2671"></t>
<t tx="edream.110203163054.2672"></t>
<t tx="edream.110203163054.2673">This happened after deleting a clone outside of the tree for @file leoColor.py.  I am not sure of the exact sequence.  Perhaps LeoCB was involved.</t>
<t tx="edream.110203163054.2674">This was pretty easy.  I think underlining hyperlinked section references looks good.

Still to do:

1. We need browser-style navigation: forward, up, back, home.

2. We may have to change things for Leo1.</t>
<t tx="edream.110203163054.2675"></t>
<t tx="edream.110203163054.2676"></t>
<t tx="edream.110203163054.2677">I finally realized why c.redraw and c.endUpdate wiped out the edit status:

1.  tree.redraw does not preserve the edit status (it probably should)
2.  tree.redraw only causes queuing of the redraw.  It doesn't happen immediately.

This was causing problems in find.show_success.  My quick fix was to create tree.redraw_now, and then to restore the status as needed.  Another, probably better, way would be to have tree.redraw restore edit status.  Duh.

However, in this case tree.redraw_now is exactly what is needed, so I feel a bit less stupid...</t>
<t tx="edream.110203163054.2678">There are a huge number of details to get exactly correct.  It appears that the code is close to working.</t>
<t tx="edream.110203163054.2679">I finally realized that v.edit_text is defined only if v is visible on the screen, that is, only if all of v's ancestors are expanded.</t>
<t tx="edream.110203163054.2680"></t>
<t tx="edream.110203163054.2681">Previously, cloned headlines were not updated in unison.  This could have been the source of some apparent "lost data".  It is remarkable how complex this logic is.

I finally chose to do a redraw in tree.endUpdate() to force headlines in synch.  We can't typically just do a redraw() in idle_headline because that messes up the editing state of v.edit_text.

I also fixed a bug in idle_body that caused control-Q to call c.setChanged() again.  The new code just sees whether the code has caused the text to change: it does not need the value of ch to do that.

idle_headline also now handles all details of marking nodes dirty.  This used to be done partly in undimHeadline.</t>
<t tx="edream.110203163054.2682">I made terrible blunder: I eliminated a commands ivar that was involved in writing, so the write failed and wiped out the .leo file.  Since I didn't have a recent backup .leo file, I lost todays notes.

Let this be a lesson to myself:

1.  Backup .leo files _are_ useful for backing up ouline only data.
2.  Make backup of entire LeoPy folder when there are problems.  I came very close to all of today's programming work, which would have been hard to bear.</t>
<t tx="edream.110203163054.2683"></t>
<t tx="edream.110203163054.2684">We don't need to keep track of the status of control or alt keys!  Instead, we let idle_body_key and idle_head_key compare the old with the new value.  They do nothing on a match.

An important point:  idle_body_key must make sure that v == c.currentVnode.  If it doesn't make this check we will lose data when the user types Control-K to create a new node.

The new code also takes care not to allow any newlines in headline text.</t>
<t tx="edream.110203163054.2685"></t>
<t tx="edream.110203163054.2686">This code is _vastly_ superior to the Borland code, for several reasons:

1.  Unlike the Borland code, the Python code uses no "state" variables.  This not only greatly simplifies the code, it makes it possible to restart incremental searches after the user has changed nodes or changed postion in body text.

Instead of using state variables in the find class, the code uses the c.currentVnode and the "insert" and "sel" tags of the Tk.text widgets.  This automatically ensures that the state of the search matches the state of the outline and body panes!

2. At last!  I know how to restart incremental searches without using state variables.  The trick is _not_ to call c.endEditing() in the setup routines, so set_in_headline() can use c.tree.editVnode to see if we are editing a headline.  If so, we start there.  OTOH, select_next_v _does_ call c.endEditing() and c.editVnode() to force c.tree.editVnode to have the proper value.

3. Leo now uses Tk.Text widgets for both headline and body text.  This eliminates all the special case code that selects between headline and body searches.  Moreover, the same regular expressions are now used for searches in both headlines and body text.  I doubt I could ever have produced bug-free code without this simplification.</t>
<t tx="edream.110203163054.2687">This hugely simplfies the find/change commands, and makes them more capable.

This also solves the "Control-K" problem in headlines.</t>
<t tx="edream.110203163054.2688"></t>
<t tx="edream.110203163054.2689">The ensure_extension routine was adding a .leo extension, thereby defeating the test for an empty file name.</t>
<t tx="edream.110203163054.2690">This code is much cleaner than the Borland code.  The search commands keep almost no state variables now: we always search from the present location.  This hugely simplifies the logic, and makes the code do what is expected more often.

In particular, is no longer any "first_v" or "first_position" state.  The various find and change commands will save the present state on entry, and restore that state if no finds are found.  This "local" save/restore makes much clearer what is happening.

Still to do: searching in headlines.</t>
<t tx="edream.110203163054.2691">The save message immediately showed a Save bug.  After doing a Save To, a following Save command used the Save To file name!  This explains why some saves "didn't take".</t>
<t tx="edream.110203163054.2692"></t>
<t tx="edream.110203163054.2693"></t>
<t tx="edream.110203163054.2694">This probably should depend on the size of the window, and at present it does not.</t>
<t tx="edream.110203163054.2695"></t>
<t tx="edream.110203163054.2696">I have a new toy: Python's exec statement.  This allows one to have all the flexibility found in tcl scripts.  For example, one can treat the name of variables as variables themselves.  Building statements from strings isn't quite as simple as in tcl, but the effect is exactly the same.

The added flexibily is useful when loading and saving many variables, as in the prefs and find code.  For example:

ivars = [ "tangle_batch_flag", "untangle_batch_flag",
	"use_header_flag", "output_doc_flag",
	"tangle_directory", "page_width", "tab_width" ]
	
for var in ivars:
	exec("self." + var + " = c." + var)  # self.var = c.var
	
This exec statement expresses the pattern directly.  Moreover, once the ivars list is defined many similar exec statements are possible.  Using the % operator might be even clearer:

	exec("self.%s = c.%s" % (var,var))</t>
<t tx="edream.110203163054.2697">This is tedious code, and Tk makes it much simpler than with other systems.</t>
<t tx="edream.110203163054.2698"></t>
<t tx="edream.110203163054.2699">Replaced global with app().idle_imported.

Replaced global with fileCommands..  This fixed a big memory botch: previously a new dummy vnode was allocated for every vnode created!

Replaced es_newline global with app().log.es_newline, i.e., frame.es_newline.  This is better than before because each log stream has its own count.</t>
<t tx="edream.110203163054.2700">These allow us to reclaim memory when closing a window.  It also showed a that we are wasting lots of space allocating dummy vnodes in the read logic.

With these routines in place, all __del__ routines are eventually being called, which indicates that all circular references are being destroyed by the destroy() routines.  Note that it is _not_ necessary to do any of the following:  del v, del tree, del commands or del frame.  Setting the pointers to None is enough.

Added tree.vnode_alloc_list.  v.__init__ adds items to this list.  tree.destroy removes items from this list.  This is an elegant and powerful solution: all vnodes will be reclaimed eventually, and we don't need to worry about reclaiming them while the window is open.  In particular, this avoids all problems with undo.

Added two new app() ivars to control memory management and tracing.
	self.deleteOnClose	# true: delete all frame objects when a frame closes.
	self.printDel		# true: enable prints in __del__ routines</t>
<t tx="edream.110203163054.2701">The frame dtor is never being called because (I think) of circular references throughout the vnode, commands and frame classes.  There are several possible approaches:

1.  Ignore the problem completely.  This makes a lot of sense, for several reasons.
	A: Memory is not an issue, and reclaiming memory at termination time doesn't help!
	B: Memory reclamation can legitimately be called a Python implementation issue.
	C: It takes time and memory to reclaim memory.
	D: Errors in reclaiming memory can lead to intermittent crashes.
	
2.  Create destroy() routine for vnodes, tnodes, commands and frames.  These routines would eliminate links between nodes, thereby freeing Python's references.  The frame.destroy() routine would also call self.top.destroy() to force the closing of the frame's window.  The destroy() routine would also do a del self to reduce the reference count of the object.

Note:  deleting vnodes and tnodes is tricky because of undo.  By far the safest course of action is never to delete these nodes until a window closes.  The easy way to do this is put every vnode in a vnode allocation list, an ivar of the tree class.  Calling tree.destroy() would do the following:

	for v in self.vnode_alloc_list:
		v.destroy()
		del v
		
With this structure in place, the __del__ routines would do nothing.  We could insert a print statement in the routines to show when the routines are actually called.  This would indicate whether circular references remain.</t>
<t tx="edream.110203163054.2702">The old code marked the loading headline as changed.  Added c.loading ivar to disable update of window title during loading.</t>
<t tx="edream.110203163054.2703">This happens when a save is quickly followed by a quit.  I can get this error when in the Python window, which is reassuring, I suppose.

frame in app().windowList trick doesn't work: very weird.

I enclosed the code in idle_redraw() in a try/except block.  I'm not sure whether this will cure all problems, but it seems like it should.</t>
<t tx="edream.110203163054.2704">The old code never got around to deleting the frame, tree and commands objects.

However, del self just decrements the reference count; it does not guarantee that self.__del__ is called.  In fact, it doesn't seem that __del_ is _ever_ called!  So much for cleaning up memory.

There may be a bug here, or perhaps this is just a weirdness of usint Tk or Tkinter.  At this point I haven't a clue.</t>
<t tx="edream.110203163054.2705"></t>
<t tx="edream.110203163054.2706">This is a strange one.  The problem happens when a save is quickly followed by a quit.  It appears that there is a fault in idle_redraw(), even when the code is locked out with if self in app().windowList.  This is very weird.  Even stranger is that the error traceback never happens when the Python window is opened first (so it stays open).</t>
<t tx="edream.110203163054.2707"></t>
<t tx="edream.110203163054.2708">Tested c2py.leo1to2() on LeoCB.  The script now works on both Borland and leo.py.

There is a problem with the v.commands method on Borland. The workaround was to pass the value from top() to convertLeo1to2(v,c).</t>
<t tx="edream.110203163054.2709"></t>
<t tx="edream.110203163054.2710">Once again, I am making faster progress with Python than expected.  Amazing.</t>
<t tx="edream.110203163054.2711">I just imported idle and voila: the IDLE IDE is available!

I did have to add r"c:\Python21\Tools\Idle" to sys.path.  I also removed the wxPython stuff from the path: they interfered with the include.

I added a few top-level functions to leo.py that were described in the scripting documentation.

I added the public commands and vnodes methods described in the scripting documentation.  Several of these routines had names that conflicted with ivars.  In those cases I changed x to mX.  The changed vnode ivars were back, firstChild, headString, next and parent.

I also added several vnode and commands methods that were described in the documentation but that did not presently exist.  Like c.findRoot, c.currentVnode, etc.

The script c2py.convertLeoTree(v) appears to work, so leo.py appears to be largely compatible with scripting in LeoCB.</t>
<t tx="edream.110203163054.2712"></t>
<t tx="edream.110203163054.2713"></t>
<t tx="edream.110203163054.2714">I spent almost an entire day messing with focus issues.  There are two choices:

1.  If tree.bodyKeepsFocus is true the body pane will always have focus unless we are editing a headline.  The current headline is highlighted in grey to indicate the tree has no focus.

2.  If tree.bodyKeepsFocus is false the body pane will not have focus if we select a headline by clicking on it.  In that case the curren headline will be white text on a dark blue background.  When focus shifts to the body pane, the current headline will be greyed.

After much experimentation, it seems that the first way is more convenient, though slightly less accurate as far as visual protocol goes.  I think the convenience of having focus in the body pane (where it is useful) outweighs the small visual incongruity of having the current headline be grayed even when the tree canvas is selected.

Warning: Using frame.getFocus() is much less good than using the tree.active flag, because we can edit a headline with at most two clicks.  That is not true when using frame.getFocus()

The bodyKeepsFocus logic affects all routines that alter the highlighting of headlines.</t>
<t tx="edream.110203163054.2715">Changed OnCloseLeoEvent so it returns not veto.</t>
<t tx="edream.110203163054.2716">TThe body handler didn't call setDirtyJoined.  Changed setDirtyJoined so it returns a redraw flag.</t>
<t tx="edream.110203163054.2717">Added virtual_event_name utility to generate &lt; &lt; name &gt; &gt;.  Sigh.

The OnCut, OnCopy and OnPaste routines just call the body key event handler to do syntax coloring and set the various dirty/changed bits.

There is a small glitch: choosing cut/copy/paste "by hand" from the menu doesn't work when the focus is in an edit label in a headline.  I'm not sure how to fix this and it is extremely minor anyway.</t>
<t tx="edream.110203163054.2718">Added v param to tree.recolor so we don't assume that v is the current vnode.</t>
<t tx="edream.110203163054.2719"></t>
<t tx="edream.110203163054.2720"></t>
<t tx="edream.110203163054.2721">I tried several options, with no luck: selectborderwidth, selectbackground, selectforground.</t>
<t tx="edream.110203163054.2722">Added code to leo.py to set the window icon.  Alas, the documentation is poor enough so that I don't know what the arguments to iconbitmap should be.</t>
<t tx="edream.110203163054.2723">I tried a lot of experiments in fileCommands.getGlobals(), and it is still not possible to set the height and width of the top level window properly.  It is still too large, and its size does not depend on the requrested width.

Note that the size of the window is set in createSplitter, by setting the size of a Frame object.  Perhaps this is interfering with matters.

The present situation is poor, but tolerable.</t>
<t tx="edream.110203163054.2724">Changed bd="2m" to bd=2.  This makes a big difference in how the panel looks.</t>
<t tx="edream.110203163054.2725">The syntax colorers can use tag_config to show tabs and spaces.  This isn't perfect (it doesn't look good now) and does not work for newlines.  It may be better than nothing, however.</t>
<t tx="edream.110203163054.2726">I just forgot to add it to the list of @keywords.</t>
<t tx="edream.110203163054.2727"></t>
<t tx="edream.110203163054.2728"></t>
<t tx="edream.110203163054.2729">These "bugs" may be appearing because these commands are always enabled in the menu.  In any case, the fixes were straightforward.</t>
<t tx="edream.110203163054.2730">The problem was that the body key handler was being scheduled before the new node was inserted and being called at idle time after the new node was inserted, so the body text disappeared.  The fix was to disabling scheduling if control or alt keys are down.</t>
<t tx="edream.110203163054.2731">All it took was the following:

font = tkFont.Font(family="Courier",size=9)
tabw = font.measure("    ")
self.body = body = Tk.Text(...font=font,tabs=tabw...)

This hard codes tabs as 4 spaces.  Later I'll make it more general.</t>
<t tx="edream.110203163054.2732"></t>
<t tx="edream.110203163054.2733">I am getting closer to getting the look of the splitter panes just right.  Setting bg="white",relief="flat",bd=0 in createSplitter helps quite a bit.

The problem with the tree pane is clearly in the Canvas widget.  If that widget is not packed the pane looks fine.  There seems to be no way to eliminate the canvas's border, and no way to prevent the border from being overwritten by the Entry widget.

Maybe there is a way: the problem may be that Entry widgets are embedded in their own windows...</t>
<t tx="edream.110203163054.2734">I will use leo.py from now on to develop leo.py.  It is the only way to really get the bugs out.

Changed the code that computes the length of the edit box for headlines.  We always use len(v.headString) now.  This still does not quite work properly, but it is better.

Fixed a bug in the selection logic.  The colors for the previous headline are changed only if the previous is not the same as the current.  This can happen if we click in the icon or plus/minus icon of the current headline.

Added the v.iconx and v.icony ivars so the tree.OnHeadlineKey routine can just redraw the cursor in place if it needs to change.  This is a workaround to a problem that I haven't been able to solve: namely, how to force the cursor to be visible again after the headline loses focus.  This is more than a little kludgy, especially after creating the elegant endUpdate mechanisim.  OTOH, it may point a way towards incremental redrawing of the screen.</t>
<t tx="edream.110203163054.2735"></t>
<t tx="edream.110203163054.2736"></t>
<t tx="edream.110203163054.2737">Changed "darkblue" to "DarkBlue".  The colors known to Tk are listed at
	http://tcl.activestate.com/man/tcl8.4/TkCmd/colors.htm 

Changed print_stack() to Print statements in es() logic.  This was more confusing than helpful.

Eliminated some accelerators (Linux only)

Added loaddir code to leo.py.
</t>
<t tx="edream.110203163054.2738">Added many terms to the Glossary.

Improved description of Leo2.  Partially merged Leo1 and Leo2 documentation.  It still isn't perfect.</t>
<t tx="edream.110203163054.2739">Probably very few people could understand the description of Leo2.</t>
<t tx="edream.110203163054.2740">I fixed the "last" serious bug in this version.  What was happening was that the clone information in leoFileCommands.py and leoCommands.py was alternatively being written and not being written.  The fix was to v.joinNodeTo:  there was a bug that was fixed in the Borland version that had not been fixed in this version.</t>
<t tx="edream.110203163054.2741">It turns out the updateCloneIndices routines in both LeoCB and leo.py are slightly buggy.  Both can increment indices multiple times for the same tnode.  In addition, LeoCB computes indices for parts of the tree beyond the actual tree, so that would increase the indices further, which is why the LeoCB version sometimes has a larger clone indices.

Neither of these "bugs" really makes a difference.  In either case, nodes are joined properly.

To "minimize" the clone indices we would do the following:

	index = 0
	v = root
	# Zero all indices.
	while v and v != next:
		v.t.cloneIndex = 0
	# Set clone index only if it has not already been set.
	while v and v != next:
		if v.t.cloneIndex == 0 and v.isCloned() and v.shouldBeClone():
			index += 1
			v.t.cloneIndex = index
		v = v.threadNext()
		
This might be just slightly slower than the "wasteful" way.</t>
<t tx="edream.110203163054.2742">The directory compare routines in the Python lib do not seem to exist.  The new routines compare only .py files.</t>
<t tx="edream.110203163054.2743"></t>
<t tx="edream.110203163054.2744">The lineIndent var was not set properly in &lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;, with the result that some sections contained extra leading whitespace in their body parts.

With this bug fixed, leo.py reads and writes all files correctly!</t>
<t tx="edream.110203163054.2745">Fixed a bug that was causing the last newline of doc parts to be deleted.  The problem was that string.rstrip() also strips newlines!  With this bug fixed it appears that Leo.py can read and write @file nodes just like Leo2CB does.

Created the removeTrailingWs() in leoUtils that strips trailing blanks and tabs.</t>
<t tx="edream.110203163054.2746">Rewrote the code in scanText and scanDoc that figures out where sentinels start.

The new nextLine and nextKind vars clarify what is going on.  When a non-sentinel line is output, the trailing newline is part of a sentinel if and only if nextKind is some kind of sentinel.

I'm not convinced the code in scanDoc is correct...

</t>
<t tx="edream.110203163054.2747">This is a very useful comparison tool.  It allows me to compare whitespace easily.</t>
<t tx="edream.110203163054.2748">This puts up a model dialog.  The hardest part was writing the code that centers the dialog on the screen.  Sheesh.</t>
<t tx="edream.110203163054.2749">I fixed many minor problems in preparation for releasing the first usable version of Leo.py.</t>
<t tx="edream.110203163054.2750">These bugs were simple transcription errors; they do not occur in LeoCB.

v.childIndex() was always returning 0, so naturally v.createDependents() was not working well.

Added a call to v.unlink() in v.destroyDependents.  The call to v.destroyTree() no longer does anything.</t>
<t tx="edream.110203163054.2751">We no longer need setIcon!!  Indeed, setIcon just calls c.redraw(), so as long as the callers enclose code in beginUpdate/endUpdate all will be well.  This eliminates a _major_ mess, and will result in further simplifications: we no longer need the distinction between the setX and initX routines!</t>
<t tx="edream.110203163054.2752">It turned out that tree.idle_body_key was the bottleneck, _not_ syntax coloring!

What was happening was this:  tree.redraw was being called on _every_ keystroke, and that was causing a huge amount of memory allocation and deallocation.  After a while everything ground to a halt.

The fix was very clever: I added a flag to c.endUpdate and tree.endUpdate, true by default.  tree.redraw is called only if count==0 and flag==true. So calling endUpdate(false) prevents all redraws from happening in a range of code.  This is a wonderful addition to the beginUpdate/endUpdate pattern.

Both tree.idle_body_key and v.setAncestorAtFileNodeDirty use this pattern.  The result is that tree.redraw() is called only when the icon really and truly must change.
</t>
<t tx="edream.110203163054.2753">Amazing.  I wrote some dummy code last night, read up on indices this morning, and got everything to work in a couple of hours. The result is very fast: no optimization is needed for Leo. I love Tkinter!

Added c.recolor and tree.recolor routines.  This hooks should be called whenever the body text changes.  Apparently there is no "OnTextChanged" event in Tk.</t>
<t tx="edream.110203163054.2754">Implementing this was trivial: we use a app.clipboard ivar, a string.  Using an internal clipboard means that we can't inadvertantly paste the XML representation of a string into body text.</t>
<t tx="edream.110203163054.2755">The only major step left before releasing a functional version of Leo is to check the @file write code.
</t>
<t tx="edream.110203163054.2756">The Tk clipboard handling is confusing: there are routines for clearing and setting the clipboard, but no obvious way to get the contents of the clipboard.  I could use an internal clipboard (part of the LeoApp class) for leo nodes, which would work pretty well.  If I did that I might want other commands: cut, copy and paste between node clipboard and the text widgets...

There doesn't seem to be any Python support for the clipboard, which is weird.</t>
<t tx="edream.110203163054.2757">This is a tedious task, no matter how it is done.</t>
<t tx="edream.110203163054.2758">Simplified the code that sets the current vnode and initializes icons.  Having tree.redraw update icons automatically helps a lot.

Added tree.initing hack to disable endEditLabel from marking the tree as changed. Actually, this probably isn't necessary, as top.title probably won't be redrawn until idle time anyway.</t>
<t tx="edream.110203163054.2759">Here is how to get accelerators working:

fileMenu.add_command(label="New", accelerator="Ctrl+N", command=self.OnNew)
self.top.bind("&lt;Control-n&gt;", self.OnNew)

Warning: using top.bind_all would not work well with multiple windows.

The accelerator="Ctrl+N" option merely sets the menu text(!).  The bind_all method actually does the work.  BTW, I had to change (self) to (self,event=None) in all the command handlers.  When an accelerator is used the handler is called with two args.  When the menu is used the handler is called with only one arg.

IDLE shows how to be a bit more clever with initialization.  I probably should study the Idle code and be clever ;-)  IDLE also use the configuration data base, and I probably should study that too.</t>
<t tx="edream.110203163054.2760">There are now just two routines, v.computeIcon() and v.setIcon().

v.setIcon just does c.tree.redraw() (!)

c.tree.redraw() now does nothing if the update count &gt; 0, so this is safe. Moreover, we can now enclose any code in c.beginUpdate()/c.endUpdate() without worry.

This is the way it is written in the Book.</t>
<t tx="edream.110203163054.2761">The &lt;Key&gt; event is called _before_ the body text is updated, so it is not possible to properly update syntax coloring, icons or tnodes there.  Instead, the &lt;Key&gt; event handler just registers an idle-time event to do the real work.  Very simple!</t>
<t tx="edream.110203163054.2762">The canvas widget appears to have an improper 1 or 2 pixel gray border.  I have worked around this by limiting the size of the Tk.Entry widget: expanding it only when editing is enabled.</t>
<t tx="edream.110203163054.2763"></t>
<t tx="edream.110203163054.2764">Following the IDLE code lead me astray.  IDLE does not allow the headline text to be edited!  At last some of the confusion is gone.</t>
<t tx="edream.110203163054.2765">openWithFileName now shows the window before loading, so that reading messages become visible.  To do this, we call app().root.update().

Made leoFrames bigger: this is done in createSplitter(!)</t>
<t tx="edream.110203163054.2766"></t>
<t tx="edream.110203163054.2767">We close the initial open window if it has not been changed.

app.quit() now closes the hidden root window to close the app.

Close processing now calls the close event handler.

There are no bugs as in wxWindows!  Everything is straightforward.</t>
<t tx="edream.110203163054.2768">I have rewritten the code to draw the tree, and it seems to work reliably.  However, expanding an entire tree is slow, and redrawing the tree is also slow is many nodes are visible.  I'm not sure what is causing this...

Disabling drawNode speeds up the redraw greatly.
Disabling only tags also speeds up the redraw greatly.  Indeed, way too many tags appear to be created...

Still to do: I have not been able to create edit windows in the canvas properly...</t>
<t tx="edream.110203163054.2769">I'm not sure whether Tkinter can read .bmp icons, so I created .gif icons, which work well.</t>
<t tx="edream.110203163054.2770">Rewrote v.restoreOutlineFromDVnodes.  It is now very simple because undo no longer creates dvnodes; vnodes now contain all tree information.  So when we "delete" a tree we just unlink and unjoin it, and when we "restore a tree we just relink and rejoin it.  It is truly amazing how simple the tree code now is.</t>
<t tx="edream.110203163054.2771">It now takes about 3 seconds to read this file, rather than the 9+ seconds needed by wxPython!  Apparently the wxPython tree class was very slow.

The _old_ bottleneck was as follows:
	Most of the time is spent in atFile scanning code
		.. c.clearAllVisited is very slow(!!) because it clears the entire tree.
			c.clearAllVisited takes about 1/3 time of the entire scanning phase (!!)
		.. Reading the file itself, is very fast, scanning in atFile::read is slow.
		.. es calls are fast.
</t>
<t tx="edream.110203163054.2772">A milestone.  It is now possible to read a .leo file and to draw the tree at least partially.  Most of the conversion to Tkinter has now been completed.

I removed vnode and commands getters that merely returned ivars.  Also converted wxWindows calls to Tk calls.  It is remarkable how easily the changes went.  
</t>
<t tx="edream.110203163054.2773">Converted all Tk prototype code to Tkinter.  It was straightforward for the most part.  The Leo window works: scrollbars work and the text panes work.  However, the tree pane is a text pane at present.

Copied menu code from Leo.py version 0.04.  Somehow the old code was lost, I have no idea why.  The copied code is wxWindows code, so it will have to be rewritten for Python.  Still, it is much easier to use the properly converted Python code.  Perhaps I deleted the code thinking that it would all have to be rewritten.  If so, that was a minor mistake.</t>
<t tx="edream.110203163054.2774"></t>
<t tx="edream.110203163054.2775">The use_tk global indicates whether Leo will use wxPython or Tkinter.  The next step is to transliterate the Tk code that creates the Leo window into Tkinter.</t>
<t tx="edream.110203163054.2776">After much experimentation, adding a -padx param to the log window pane seems like the only way to handle the width of the vertical scroll bar.  Without this extra padding, the scroll bar obscures the left edge of the log window.</t>
<t tx="edream.110203163054.2777">It simplifies and speeds up the code to use file.readline to process lines as a unit.  This way I never have to scan to the end of a line.  However, it turns out that scanning is not really the bottleneck.  In addition, we no longer read entire derived files into memory at once.

BTW, it may be possible to use readline() in the getLeoFile logic as well.  I have no idea whether this would help or not.

The problem is the _second_ half of atFile::read, that is, after the derived file has been completely scanned and all vnodes have been created!  Apparently, something (maybe shouldBeClone?) involved with setting bits is horribly slow.  I'm not sure why earlier testing didn't show this problem.  I must have been mistaken somehow in my earlier conclusions.

This actually is very good news.  It means that the raw file code is good enough as it is.  Note:  reading derived files will not slow down when I switch to Tk because we don't create vnodes unless there are file errors!

I have just found that a single call to c.clearAllVisited() in read() _substantially_ slows down the read!  Amazing.

Create v.clearVisitedInTree() and v.clearAllVisitedInTree()</t>
<t tx="edream.110203163054.2778">@nocolor
@ignore

This is a _very_ easy class.

Ivars
	self.root: the root vnode
	self.update: update count
		tree::beginUpdate increments.  tree::endUpdate decrements.
		Disable redraw if &gt; 0
		Redraw when falls to 0.
	self.selected: the selected vnode
	self.top the top vnode on the screen (needed?)

Tree methods know about vnodes(!) Greatly simplifies both tree and vnode classes.
tree:endUpdate does nothing if self.update &gt; 0
	User code should not call tree::redraw directly.
	Most tree methods call redraw
Insert methods create a vnode, set links and redraw.
Move methods just set links and redraw
Commands methods enclose complex operations in tree.beginUpdate/endUpdate, as they do now.
tree::delete(v) just unlinks v's tree
	vnodes are not deleted until window goes away: unlimited undo!
	v.threadNext ivar makes deleting a list trivial.

vnodes

vnodes contain headString, expanded, firstChild, parent, back, next and threadNext ivars
	tree::getThreadNext() used to set v.threadNext
	no need for dvnodes: vnodes contain all undo info!


		</t>
<t tx="edream.110203163054.2779">added use_tk constant in leoGlobals.</t>
<t tx="edream.110203163054.2780">es now outputs a newline, which makes most uses of enl and ecnl superfluous.  We can do this be string concatenation is so easy.</t>
<t tx="edream.110203163054.2781">There was a transliteration error in computing the line to be output which mangled long lines.</t>
<t tx="edream.110203163054.2782">This code has not been tested.</t>
<t tx="edream.110203163054.2783">There was a bug in sentinelKind.  skip_c_id won't handle @@, so @@ must be handled separately.</t>
<t tx="edream.110203163054.2784">It is not possible to access global _variables_ using from leoGlobals import * because that creates copies of the data.  The new way is simpler and more modular.

Revised how the prefs panel works.  The new code just sets the prefs ivars.  It is up to the caller to access the prefs panel as needed. Added tab_width preference and prefs.tab_width ivar.  This should have been done long ago.</t>
<t tx="edream.110203163054.2785">Fixed problems with at_xxx_ptr globals.  The problem that from leoGlobals import * doesn't work, so I changed is_special_bits so it returns a dictionary containing name:value pairs rather than setting globals.

Fixed many problems in scanAllDirectives involving paths.  Also rewrote the code in atFile::write that opens files.

At this point leo.py can read and write files except files containing @first.
</t>
<t tx="edream.110203163054.2786">.. initAllCloneBits had several errors.
.. self.structureErrors wasn't being initialized in atFile::Read
.. createNthChild must mark nodes as visited to suppress unvisited node logic later.
.. Added log messages any time self.structureErrors is incremented in createNthChild

At this point leo.py can read a simple test file properly, except files containing @first.</t>
<t tx="edream.110203163054.2787">It wasn't too hard to create a proper splitter window.  After that, creating a Leo window was trivial.</t>
<t tx="edream.110203163054.2788"></t>
<t tx="edream.110203163054.2789">I am beginning to think that globals should _never_ be used.

The @language bug appears to be a problem of not setting globals properly.</t>
<t tx="edream.110203163054.2790"></t>
<t tx="edream.110203163054.2791">Added assert in tnode::setTnodeText that we are getting a string.  This assert was not always true before I added a call to listToString in &lt;&lt; copy new_out to child's body t't' in scanText.</t>
<t tx="edream.110203163054.2792">The read code is slow.  I'll have to see why.

3 seconds with read doing nothing (reads leoPy.leo)
5 seconds with read reading files but not scanning them.
9 seconds with read fully enabled.

Therefore:

3 sec to read and scan LeoPy.leo
2 sec for reading all derived files
4 sec to scan all derived files.

So scanning derived files is pretty slow.

BTW, LeoCB can do everything in about 2 sec.
</t>
<t tx="edream.110203163054.2793">There was the usual assortment of minor problems.

.. The write code was writing flags using `flag`, and this fails if false is None.
.. Added code to make sure None is never passed to wxFileDialog as a file name.  I wonder if this could have caused problems earlier.  Once again, the C++ code is shown to be radically unsafe.

.. I think false should be defined as 0, not None.  There are several advantages:

1.  not 0 == not None, so various tests work as before.
2.  `0` is very different from `None`, and this affects the file format.

I'll make this change.  Hope it works ;-)</t>
<t tx="edream.110203163054.2794">A major milestone:  the read command works and so do most outline commands.  It is now clear that reading a file is fast enough so that no further work is required!

The main problems today:

1.  The code must use the test: id and id.IsOk().  Failure to make _both_ tests will cause the code to fail, possibly in an unbounded loop.  This was ultimately the problem with the Move Down command:  the threadNext code didn't make these test.  I finally called wxGetThreadNext inside threadNext and that solved the problem.

2.  I added the self.changing lockout in the LeoFrame OnTextUpdate handler so that tnodes would not be erroneously updated while switching tnodes.  The new code seems simple and robust.</t>
<t tx="edream.110203163054.2795">A case can be made for getters of the form:

	def getX():
		return x
		
In particular, they are a reaonable place to put asserts.  However, such getters do not seem good style in Python because all ivars are public anyway.  Moreover, getters like

	def x():
		return x
		
are invalid in Python, so there is a problem.  The simplest approach seems to be to get rid of all such redundant getters, and that is what I have just done.  Note that assert's aren't so important in wxPython, because nothing bad can happen anyway.</t>
<t tx="edream.110203163054.2796">This was a very interesting experience, for the following reason.

1.  The weakness of a non-compiled language is that problems don't show up until code is actually executed.
2.  Python is very safe.  The only real problem are unbounded loops.
3.  In particular, the continue statement will _always_ loop in Python unless progress the loop variable is incremented.  So care must be taken when translating C for loops into Python while loops.
4.  Even without the ability to set breakpoints (which means that single-stepping is impossible in wxPython!) it wasn't too hard to trace with print statements.  Amazing.
5.  The biggest mess came with getters that return an ivar of the same name.  I'll sleep on this, and I think the thing to do is get rid of the getter entirely:  convert x.getY() x.Y.
6.  Defining constants in a class is nice: they are accessed by class name.  For example: vnode.dirtyBit.

Status:
1.  The outline is being read in correctly.
2.  The atFile::read logic hasn't been tested.
3.  The body pane (and probably all the tnode text) is not being set properly.
4.  It is possible that we might be able to get rid of join lists!  They are used:
	a) To update the headline text
	b) For shouldBeClone.
	We could replace join lists by a reference count and temporary join lists.
	This could be really cool, and I'll have to think about this more...
	</t>
<t tx="edream.110203163054.2797">Created leoFileCommands.py.  We use com=self.mCommands to access the "real" commander for this class.  It would be wrong to make fileCommands a subclass of Commands; we must have exactly one commander per frame so that mCurrentVnode, mRootVnode, etc. are updated properly.

In short, the ivars of fileCommands are mFrame, mCommands and any ivars used exclusively by fileCommands.  This pattern will be used to create outlineCommands.py, findCommands.py, etc.</t>
<t tx="edream.110203163054.2798">The info class was confusing.  All the ivars from that class now become ivars in the fileCommands class.  The mTnodes array is now a Python dict, so there is no need for the mNumberOfTnodes or mMaxTnodeIndex ivars!  The new clode is _much_ clearer.  A major victory.</t>
<t tx="edream.110203163054.2799">Fixed several bugs in c2py.

Greatly simplified handlePossibleFunctionHeader; there is no need to compute a delta there:  we munge the head, args and body separately, then replace the original all at once with the new lists.  This is bullet proof.

Fixed some bugs in safeReplace and matchWord.

Fixed bugs in convertCStringToPython that caused skipDoc and skipCode to be called in the wrong places.  That was really messing things up!

Tested the speed of tests by writing speedTest.  This is so much fun!</t>
<t tx="edream.110203163054.2800">I have been happily converting, with the help of c2py, Leo's C++ code to python.  The new code is far, far easier to understand.</t>
<t tx="edream.110203163054.2801">Fixed several bugs in c2py:

1. removeExcessWS was sometimes skipping past a newline, thereby removing leading whitespace in the following line.  This made it look like the code for "if", "while" and "for" was bad.

2. the function scanning code had several bugs.  Added new code to ignore "if", "while" and "for" code.  Added new code to ignore # lines (preprocessor directives).  Added the firstOpen variable to eliminate scanning later.  This is pretty tricky code.

3. Added code to replace " . " by "." and "\t " by "\t".

4. Fixed skipPastWord so it handles underscores and digits.  This helped a lot ;-)

5. @code was not always properly converted to @c.

I think I will leave c2py as is for now.  It has the following rough edges:

1.  I don't know how to break long scripts.
2.  c2py doesn't handle : initializers in constructors well; they inhibit processing of the initializer.
3.  c2py doesn't place self. in all the places it is needed.  I'm not sure there is an elegant way to do this...</t>
<t tx="edream.110203163054.2802">Worked on c2py.  As documented in LeoCB.leo, had to add a __cmp__ routine in leo.py so that vnodes compare equal properly.  Fixed some minor bugs in c2py.

We now have two separate routines called leo.py.  The one used by LeoCB and LeoWX is the python expression evaluator.  The leo.py in LeoPy is the top level of leo.py.

Added signed, unsigned and bool to the list of type names.</t>
<t tx="edream.110203163054.2803"></t>
<t tx="edream.110203163054.2804">Documented the theory of operation of c2py.  This is a remarkably simple program!  Converting from string to list representation turns out to be a very good choice.</t>
<t tx="edream.110203163054.2805">For the last two days I have been working on c2py.py.  I am totally in love with Python.  Everything is so much easier:  Automatic debugging, no declarations, no types, no compilation. Great data structures. Even without single stepping the debugging is easy.

All major aspects of c2py are now complete.</t>
<t tx="edream.110203163054.2806">It has been staring me right in the face.  Idle.py supports tree views and syntax coloring!  All I need do is adapt the Idle code for Leo.  The only remaining piece of the puzzle is a good splitter window (and splitter events?)
</t>
<t tx="edream.110203163054.2807">All menu work is now complete, with stubs for many calls to Commands routines...
The Python menu is functional.
The Find Panel can be opened.
The Find Panel can be opened.

Still to do:
	Icons for outline
	Nodes classes
	Commands classes:
		outline commands
		file commands,
		find commands,
		tangle/untangle commands</t>
<t tx="edream.110303182253.3">Leo does an auto-save only if something has actually been changed.</t>
<t tx="edream.110303182253.39"></t>
<t tx="edream.110303182719">The config_encoding setting controls the encoding of non-ascii characters in leoConfig.txt.

The use_gnx setting in leoConfig.txt determines whether uses gnx's (cvs friendly) or ints.  No version of Leo before 4.1 can read .leo files containing gnx.   Only gnx's are immutable.  Leo recomputes all non-gnx indices from scratch whenever writing a .leo file. It is possible to convert between 3.x and 4.1 file formats by changing the use_gnx setting.
</t>
<t tx="edream.110603185805">Leo 4.1 beta 2                   November 9, 2003

This is the second official release of the reorganized 4.1 code base.

Beta 2 fixes a startup problem with Linux: "mbcs" is not a valid encoding.

The code appears solid, and has not been widely tested.  Please use caution when using this code.

N.B. By default Leo 4.1 creates .leo files that can not be read by older versions of Leo.  Please read the following carefully if that concerns you.

Highlights of 4.1:
-----------------
* Leo 4.1 includes several new commands:
  - script-based find/change commands: very powerful and flexible.
  - Hoist &amp; DeHoist commands for viewing parts of an outline.
  - Check Outline command finds user clone mistakes.
* New configuration settings:
  - use_gnx specifies whether .leo files use integers as indices:
    use_gnx = 0 makes .leo files compatible with previous versions of Leo.
    use_gnx = 1 makes .leo files cvs-friendly
  - config_encoding specifies the encoding of leoConfig.txt.
* Several significant code-level changes:
  - The 4.1 code base has been reorganized to support gui plugins.
    An example wx_gui plugin is partly functional.
  - Created a flexible framework for creating &amp; running regression tests.
    This framework takes full advantage of outlines to organize tests.
  - app.forceShutdown now works when called from plugins.
- Fixed several long-standing bugs.  More fixes are coming.</t>
<t tx="edream.110603190125.1">Leo 4.1 uses immutable gnx's (id:timestamp:n) by default to associate tnodes with vnodes in .leo files.  This makes Leo as cvs friendly as possible.  From now on .leo files will be checked in to cvs with the -ko (text/keywords off) option.</t>
<t tx="edream.110603190125.3">The file test.leo in the test directory contains real regression tests for syntax coloring.   Regression testing scripts create regression tests dynamically from data in Leo's outline.  Very cool, very easy, very general.  In particular, regression tests may use temporary nodes in test.leo rather than creating separate Tk windows for testing.</t>
<t tx="edream.110603190125.4">The 4.1 code base has been reorganized to support gui's other than tkinter.  Leo's src directory contains several new source files.

This reorg affects almost all plugins.  Considerably more work and testing will be done before 4.1 final.

The __wx_gui.py plugin is uses the newly reoganized code.  At present it is only partly functional.</t>
<t tx="edream.110603190234.1"></t>
<t tx="edream.110603190322.2">A useful little utility to set up script-find/change.</t>
<t tx="edream.110603190322.3">This involved fixing a bug in idle_body_key so that the oldText param is honored if present.</t>
<t tx="edream.110603190322.6">Yes, we really do need script-based find/change.  The reason is that the find panel (and the associated find commands) is really the only good place to allow the user to do an interactive search.  Without this feature, all interactive find/change scripts would have to duplicate all the work of the find/change commands.

Still to do: help scripts do undo.

Conventions enforced by Leo:

- The app.searchDict ivar can be used for communication between find &amp; change scripts.
- app.searchDict["type"] contains either "find", "change", "findAll" or "changeAll".
- The Find All command executes the find script only once unless the script sets
  app.searchDict["Continue"] = True  (similarly for the change all command.
- The Find Then Change command executes the find command followed by the change command.
- The Change Script command supports undo if app.searchDict has the following entry after the script executes:
	{ "v" : v, "oldText" : oldText, "newText" : s }
	A "keys" key is an optional keyword dict to be passed to setUndoParams.

Leo actually doesn't do much:

- Leo doesn't clear app.searchDict.
	- However, a _script_ can
		a) init itself and
		b) bring up the find window (Eureka!)
- The find script is repsonsible for traversing the tree.
- The find script is responsible for highlighting the found text
  or otherwise indicating to the change script what the found text was.
  For example, the re find script can set app.searchDict["m"] to the match object.
- The find script must communicate with the change script.  Leo does nothing.
- The change script must change the text, usually by using v.setBodyStringOrPane.</t>
<t tx="edream.110603190322.8">Undoing Change All cleared the body pane.

The fix was simple: call setUndoParams instead of setUndoTypingParams in batchChange.</t>
<t tx="edream.110603190322.9"></t>
<t tx="edream.110603190322.10"></t>
<t tx="edream.110603190322.11">The node-only option wasn't working due to a bug in createFrame.

There still may be a problem with the interaction between Node-only,Change All and Undo.</t>
<t tx="edream.110603190322.13">The fix was to open files with 'rb' instead of 'r'.  This probably should be done in more places.</t>
<t tx="edream.110603190322.14">This command checks for unused tnodeLists and checks the topology of all clones.</t>
<t tx="edream.110603190322.15">The Hoist command redraws the screen so presently selected tree becomes the only visible part of the outline.  Leo prevents the you from moving nodes outside the hoisted outline.  The De-hoist command restores the outline.  Hoist commands may be nested.</t>
<t tx="edream.110603190404"></t>
<t tx="edream.110603192009"></t>
<t tx="edream.110603192009.1"></t>
<t tx="edream.110703093314">The Check Outline command checks the outline for consistency and warns if it finds dubious clones.</t>
<t tx="edream.110703093314.1">The Hoist command redraws the screen so presently selected tree becomes the only visible part of the outline.  Leo prevents the you from moving nodes outside the hoisted outline.  The De-hoist command restores the outline.  Hoist commands may be nested.</t>
<t tx="edream.110803170826">from leoGlobals import *
import leoTest

u = leoTest.testUtils()
nodes = 0 ; lines = 0
c = top()
c.clearAllVisited()
v = u.findNodeAnywhere(c,"Users Guide")
after = v.nodeAfterTree()
# trace(v,after)
while v and v != after:
	if not v.t.isVisited():
		v.t.setVisited()
		nodes += 1
		lines += len(splitLines(v.bodyString()))
	v = v.threadNext()
	
pages = ((nodes * 10) + lines) / 50
print "nodes,lines,pages",nodes,lines,pages
es("nodes,lines,pages",nodes,lines,pages)</t>
</tnodes>
</leo_file>
