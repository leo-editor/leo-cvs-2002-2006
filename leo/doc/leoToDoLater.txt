#@+leo-ver=4-thin
#@+node:ekr.20060207133601:@thin ../doc/leoToDoLater.txt
#@+all
#@+node:ekr.20060116073938:To do 4.4b3
#@+node:ekr.20060212110815:First: urgent
#@+node:ekr.20051126122638:Autocompletion tab
- Use typing completion to select desired word.
- No auto-scan: use database instead.
- Scan button does manual scan.
- Use import or inspect instead of text scan.
- @strings autocompleter-info
list of names for which classes are known: c,frame,g,k,p,t,tree,v etc.
  (Autocompleter may already do this)
#@+node:ekr.20051205093049:Use dir for auto-complete ?
@nocolor

Working throught the IronPython tutorial just now I saw how useful the dir function could be, especially dir(object)

I'm thinking that Leo might use dir(object) to discover members for the auto-complete command.  It's not clear if or how this can be made to work, but it might be slick.
#@nonl
#@-node:ekr.20051205093049:Use dir for auto-complete ?
#@+node:ekr.20051025144611:Reference (Do not delete)
#@+node:ekr.20051025144611.1:Configuration
@nocolor
#@nonl
#@+node:ekr.20051025144611.2:autocompleter.ini
The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.
#@nonl
#@-node:ekr.20051025144611.2:autocompleter.ini
#@+node:ekr.20051025144611.3:.ato files in the autocompleter folder
The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word(     ) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.
#@nonl
#@-node:ekr.20051025144611.3:.ato files in the autocompleter folder
#@-node:ekr.20051025144611.1:Configuration
#@+node:ekr.20051025144611.4:autocompleter.py
<< docstring >>
<<imports>>
<<version history>>
<<a note on newCreateControl>>
<<coding conventions>>
<< configuration >>

#These two global determine if the autocompleter and calltip systems are used.  Default is on.
useauto = 1
usecall = 1

<<globals>>
<<patterns>>

@others
#@nonl
#@+node:ekr.20051025144611.5:<< docstring >>
'''Autocompletion and calltips plugin.

- ``.`` summons the autocompletion.
- ``(`` summons the calltips
- ``Escape`` closes either box.
- ``Ctrl`` selects an item.
- ``alt-up_arrow``, ``alt-down_arrow`` move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocomplete.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesnt find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleters runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.
'''
#@nonl
#@-node:ekr.20051025144611.5:<< docstring >>
#@+node:ekr.20051025144611.6:<< imports >>
## import leoTkinterFrame 

import sets 
import threading
import weakref
#@nonl
#@-node:ekr.20051025144611.6:<< imports >>
#@+node:ekr.20051025144611.7:<<version history>>
@
.425:
    -The initial scan thread is now a daemon thread.
    -Creates autocompleter box and Calltip box once.
    -Broke long functions apart.
    -'Esc'now closes autobox and calltip.

.500 EKR:
    - Made minor changes based on .425:
    -Improved docstring.
    -Converted to 4.2style.
.501 EKR:
    - Changed select method following patch by original author.
    - Added event.keysym=='Up' case to
.55 Lu:
     - Made the watcher def more greedy.  See def for rationale
     - Made the calltip identification regex more liberal.
     - streamlined some code.
     - added DictSet class, experimental in the sense that I haven't had a bug with it yet.  see <<DictSet>> node, under << globals>>
     - discovered dependency between this and Chapters, auto needs to be loaded first
.60 Lu
    - Changed some method names to more acuaretely reflect what they do.  Added more comments.
    - processKeyStroke cleaned up.
    - added Functionality where any mouse button press, anywhere in Leo will turn off autobox and calltip label.
    - waiting for Chapters( or chapters ) to have its walkChapters def fixed up, so we can walk the chapters on startup.
 .7 Lu( The placer revolution!)
   -migrated to the placer!  This got rid of Canvas based drawing.  The placer may be a good tool to know in the future.  This seemed to
   be about an even replacement codewise, but I think it gives us an efficiency boost.
   -changed some lambdas to defs, more for clarities sake then anything.
   -made global changes to how objects are referred to
   -got rid of factory defs, autobox and calltip label are created at Editor creation time
   -dependency between this and Chapters eliminated.
   -added code to automatically create the .ini file and the autocompleter directory if they do not exist.
   -added a section about how to configure autocompleter
   -switched the patterns from using '+' to add pieces together to using '%s'.
.71 investigated and hopefully fixed startup bug on Windows. Changes that appear to have fixed it:
1. We synchronize with an threading Event object.  IO acting screw on windows in a thread.
2. There is a global flag indicating whether the config file needs to be read again.
3. Explicitly set the file type to 't'.  This could all be attributed to a bug in ConfigParser.  I looked at the source and it doesnt write its data with a 't'.  This indicates trouble with windows.
4. Make the 'aini' path composed of os.sep instead of the char '/'.  Im uncertain if the config file ever got read on Windows at this point because of the explicit '/' , instead of using os.path.
5. Moved createConfig part out of thread. problems seems centered on Windows/IO/Threading.

 .72 The thesis and experiments to confirm the problem identified in .71 appear
completely wrong. I could not recreate threading+writeIO staling on XP at all.
Windows 98 didnt even work. But after commenting out g.es calls it did work. My
new target for the problem is now focused on keeping g.es calls out of the
initialScan thread. This will just entail moving all the reading and writing of
the config and language files out of the thread.

.73 EKR:
    - Changed 'new_c' logic to 'c' logic in initialScan.
    - Added init function.
.74 EKR:
    - Changed 'start2' hook to 'new' hook.
.75 EKR:
    - Disable scan during unit testing.
#@nonl
#@-node:ekr.20051025144611.7:<<version history>>
#@+node:ekr.20051025144611.8:<<a note on newCreateControl>>
@

the function newCreateControl decorates the leoTkinterFrame.leoTkinterBody.createControl method.
It does so to intercept the point where the editor is created.  By doing so, autocompleter is able
to ensure that the placer is used instead of the packer.  By using the placer autocompleter is able
to put the autobox and calltip label over the editor when the appropiate time is reached.  In versions
prior to .7, this was achieved by using a Tk Canvas as the background of the Editor.  The placer is simpler
and from what I see more efficient.

#@-node:ekr.20051025144611.8:<<a note on newCreateControl>>
#@+node:ekr.20051025144611.10:<<coding conventions>>
@

context - means the widget that backs the editor.  In versions before .7 it was called c and was a canvas.  context is the new name, and it is no longer a canvas. c, now means commander.

context.autobox - means the Pmw.ScrolledListBox that offers the autocompletion options.

The autobox contains other widgets that can be accessed by autobox.component( 'widgetname' )

context.calltip - means the Tk.Label that offers calltip information

context.which = 0 indicates its in autocompleter mode
context.which = 1 indicates its in calltip mode
#@nonl
#@-node:ekr.20051025144611.10:<<coding conventions>>
#@+node:ekr.20051025144611.11:<< configuration >>
@
Autocompleter looks in the plugin directory for a file called autocompleter.ini

This file contains two options under the [ autocompleter ] section:
    useauto
    usecalltips
    setting either to 1 will turn on the feature. 0 means off.
If there is a section called [ newlanguages ] it will read each option as a new language for autocompleter to recognize,
and compile its value as a regex pattern for the autocompleter system to recognize as a calltip.  This has relevance for the .ato
system described below.

languages that currently have patterns:
    python, java, c++, c and perl
This file will automatically be generated for the user if it does not exist at startup time.


Autocompleter looks in the plugin directory for a directory called autocompleter.  If it doesnt find one
it will attempt to create this directory.  This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a languages name.  For example:
    python.ato
    autocompleter recognizes python, and will scan this file.  The contents are read with the same mechanism that
    reads the information in the nodes, so calltip and autocompleter information is added to autocompleters runtime database.
If a new language has been added in the autocompleter.ini file then an .ato file that starts with the new languages name will be recognized and read in.  Note, this language needs to be recognizable to Leo.
Used correctly an .ato file is a mechanism by which a user can carry autocompletion and calltip information between .leo files/sessions.
#@nonl
#@-node:ekr.20051025144611.11:<< configuration >>
#@+node:ekr.20051025144611.12:<< globals >>
orig_CreateControl = leoTkinterFrame.leoTkinterBody.createControl 

<<DictSet>>
#watchwords ={} switched to DictSet
watchwords = DictSet() # a DictSet that is the autocompleter database.
#calltips ={} switched to DictSet
calltips = DictSet( factory = DictSet) # a DictSet that is the calltip database
pats ={} #used to hold regex patterns to find defintions for calltips
lang = None #determines what language is in effect.  Though its global, only one autobox or calltip label should be visible for the entire leo instance.
configfilesread = False #Determines if the config files need to be read
haveseen = weakref.WeakKeyDictionary()# a dict that tracks the commanders that have been seen without stopping garbage collection of that commander.
#@+node:ekr.20051025144611.13:<<DictSet>>
class DictSet( dict ):
    '''A dictionary that always returns either a fresh sets.Set or one that has been stored from a previous call.
    a different datatype can be used by setting the factory keyword in __init__ to a different class.'''
    
    def __init__( self , factory = sets.Set ):
        dict.__init__( self )
        self.factory = factory
        
    def __getitem__( self, key ):
        try:
            return dict.__getitem__( self, key ) # EAFTP
        except:
            dict.__setitem__( self, key, self.factory() )
            return dict.__getitem__( self, key )
#@-node:ekr.20051025144611.13:<<DictSet>>
#@-node:ekr.20051025144611.12:<< globals >>
#@+node:ekr.20051025144611.14:<< patterns >>
# This section defines patterns for calltips.
space = r'[ \t\r\f\v ]+'
end = r'\w+\s*\([^)]*\)'

pats ['python'] = re.compile(r'def\s+%s' % end)

pats ['java'] = re.compile(
    r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
        space, space, end))

pats ['perl'] = re.compile(r'sub\s+%s' % end)

pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (space,end))

pats ['c'] = re.compile(r'\w+%s%s' % (space,end))

r = string.punctuation.replace('(','').replace('.','')
pt = string.digits + string.letters + r

ripout = string.punctuation + string.whitespace + '\n'
ripout = ripout.replace('_','')

okchars = {}
for z in string.ascii_letters:
    okchars [z] = z
okchars ['_'] = '_'
#@nonl
#@-node:ekr.20051025144611.14:<< patterns >>
#@+node:ekr.20051025170832:Initialization
#@+node:ekr.20051025144611.15:init
def init ():
    
    ok = Pmw and Tk and not g.app.unitTesting # Not for unit tests: modifies core classes.
    
    if ok:
        leoTkinterFrame.leoTkinterBody.createControl = newCreateControl 
        leoPlugins.registerHandler(('new','open2'),initialScan)   
        g.plugin_signon(__name__)
        
    return ok
#@nonl
#@-node:ekr.20051025144611.15:init
#@+node:ekr.20051025170832.1:Config stuff
#@+node:ekr.20051025144611.24:has read config file meths
#These functions determine if the config and language files have been read or not.
# No need to read it more than once.

def hasReadConfig():
    return configfilesread

def setReadConfig():
    global configfilesread
    configfilesread = True
#@nonl
#@-node:ekr.20051025144611.24:has read config file meths
#@+node:ekr.20051025144611.25:readConfigFile
def readConfigFile (aini):
    '''reads the autocompleter config file in.'''
    global usecall, useauto 
    
    try:
        cp = ConfigParser.ConfigParser()
        fp = open( aini, 'rt' )
        cp.readfp( fp )
        fp.close()
    except Exception, x:
        g.es( "Could not open %s because of %s" % ( aini, x ), color = 'red' )
    ac = None 
    
    for z in cp.sections():
        if z.strip()=='autocompleter':
            ac = z 
        else:
            continue
        if cp.has_section(ac):
            if cp.has_option(ac,'useauto'):
                useauto = int(cp.get(ac,'useauto'))
                if useauto:
                    g.es( "autocompleter enabled", color = 'blue' )
            if cp.has_option(ac,'usecalltips'):
                usecall = int(cp.get(ac,'usecalltips'))
                if usecall:
                    g.es( "calltips enabled" , color = 'blue' )
        break

    nl = None
    for z in cp.sections():
        if z.strip()=='newlanguages':
            nl = z 
        else:
            continue
        if nl and cp.has_section( nl ):
            for z in cp.options( nl ):
                try:
                    pats[ z ] = re.compile( cp.get( nl, z ) )
                    g.es( 'added %s to autocompleter languages' % z , color = 'blue' )
                except Exception, x:
                    g.es( "Could not add %s pattern, because of %s " %( z, x ) , color = 'red')
                    
        break
#@-node:ekr.20051025144611.25:readConfigFile
#@+node:ekr.20051025144611.26:createConfigFile
def createConfigFile( aini ):
    '''This function creates a config file identified by the parameter aini'''
    cp = ConfigParser.ConfigParser()
    cp.add_section( 'autocompleter' )
    cp.set( 'autocompleter', 'useauto', '1' )
    cp.set( 'autocompleter', 'usecalltips', '1' )
    cp.add_section( 'newlanguages' )
    try:
        ini = open( aini, 'wt' )
        cp.write( ini )
        ini.close()
        g.es( "autocompleter .ini file created in %s" % aini, color = 'blue' )
    except Exception, x:
        g.es( "Error in creating %s, caused by %s" % ( aini, x ) , color = 'red' )


#@-node:ekr.20051025144611.26:createConfigFile
#@+node:ekr.20051025144611.27:readLanguageFiles
def readLanguageFiles (bankpath):
    '''reads language files in directory specified by the bankpath parameter'''
    global lang
    if not os.path.exists( bankpath ):
        try:
            os.mkdir( bankpath )
        except Exception, x:
            g.es( "Could not make %s because of %s" %( bankpath, x ) )
    for z in pats:
        bpath = bankpath+z+'.ato'
        if os.path.exists(bpath):
            f = open(bpath)
            lang = z 
            map( scanText, f )
            #for x in f:
            #    scanText(x)
            f.close()
#@nonl
#@-node:ekr.20051025144611.27:readLanguageFiles
#@+node:ekr.20051025144611.28:readOutline
def readOutline (c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    global lang
    if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
        import chapters 
        it = chapters.walkChapters()
        for x in it:
            lang = None 
            setLanguage(x)
            scanText(x.bodyString())
    else:
        for z in c.rootPosition().allNodes_iter():
            setLanguage( z )
            scanText( z.bodyString() )
#@nonl
#@-node:ekr.20051025144611.28:readOutline
#@-node:ekr.20051025170832.1:Config stuff
#@+node:ekr.20051025144611.16:watcher
watchitems = ('.',')')
txt_template = '%s%s%s'

def watcher (event):
    '''A function that tracks what chars are typed in the Text Editor.
    Certain chars activate the text scanning code.'''
    global lang
    if not (event.char.isspace() or event.char in watchitems):
        return
        
@
This if statement ensures that attributes set in another node are put in the
database.Of course the user has to type a whitespace to make sure it happens.
We try to be selective so that we dont burn through the scanText def for  every
whitespace char entered.This will help when the nodes become big.
@c
    bCtrl = event.widget
    if event.char.isspace():
        # Do nothing if the previous char was a whitespace
        if bCtrl.get('insert -1c').isspace(): return
        if bCtrl.get('insert -1c wordstart -1c') != '.': return
    c = bCtrl.commander
    lang = c.frame.body.getColorizer().language
    txt = txt_template % (
        bCtrl.get("1.0",'insert'),
        event.char, bCtrl.get('insert',"end"))
        # Add the newest char; its not in the bCtrl yet
    scanText(txt)
#@nonl
#@-node:ekr.20051025144611.16:watcher
#@+node:ekr.20051025144611.23:initialScan
def initialScan (tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")
    if not c or haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    pth = os.path.split(g.app.loadDir)  
    aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    if not os.path.exists(aini):
        createConfigFile( aini )
    try:
        if not hasReadConfig():
            if os.path.exists(aini):
                readConfigFile(aini) 

            bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
            readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    finally:
        setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.            
    def scan():
        #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
        # During unit testing c gets destroyed before the scan finishes.
        if not g.app.unitTesting:
            readOutline( c )
        
    t = threading.Thread( target = scan )
    t.setDaemon(True)
    t.start()
#@-node:ekr.20051025144611.23:initialScan
#@-node:ekr.20051025170832:Initialization
#@+node:ekr.20051025144611.17:scanText
def scanText (txt):

    '''This function guides what gets scanned.'''

    if useauto:
        scanForAutoCompleter(txt)
    if usecall:
        scanForCallTip(txt)
#@nonl
#@-node:ekr.20051025144611.17:scanText
#@+node:ekr.20051025144611.18:scanForAutoCompleter
def scanForAutoCompleter (txt):
    
    '''This function scans text for the autocompleter database.'''

    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b:makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            #if watchwords.has_key(a):
            #    watchwords[a].add(b)
            #else:
            #    watchwords[a] = sets.Set([b])
            watchwords[ a ].add( b )
            # we are using the experimental DictSet class here.
            # usage removed the above statements
            # notice we have cut it down to one line of code here!
#@nonl
#@-node:ekr.20051025144611.18:scanForAutoCompleter
#@+node:ekr.20051025144611.19:scanForCallTip
def scanForCallTip (txt):

    '''this function scans text for calltip info'''

    # pat2 = pats['python']
    # if lang:
        # if pats.has_key(lang):
            # pat2 = pats[lang]

    pat2 = pats.get(lang or 'python')
    g2 = pat2.findall(txt) or []

    for z in g2:
        if isinstance(z,tuple):
            z = z [0]
        pieces2 = z.split('(')
        pieces2 [0] = pieces2 [0].split() [ -1]
        a, b = pieces2 [0], pieces2 [1]
        calltips [lang][a].add(z)
#@nonl
#@-node:ekr.20051025144611.19:scanForCallTip
#@+node:ekr.20051025144611.20:makeAutocompletionList
def makeAutocompletionList (a,b,glist):
    
    '''A helper function for autocompletion'''
    a1 = _reverseFindWhitespace(a)
    if a1:
        b2 = _getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 

#@-node:ekr.20051025144611.20:makeAutocompletionList
#@+node:ekr.20051025144611.21:_getCleanString
def _getCleanString (s):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    for n, l in enumerate(s):
        if l in okchars:pass 
        else:return s[:n]
    return s 
#@-node:ekr.20051025144611.21:_getCleanString
#@+node:ekr.20051025144611.22:_reverseFindWhitespace
def _reverseFindWhitespace (s):
    '''A helper for autocompletion scan'''
    for n, l in enumerate(s):
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
#@-node:ekr.20051025144611.22:_reverseFindWhitespace
#@+node:ekr.20051025144611.29:reducer
def reducer (lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
#@-node:ekr.20051025144611.29:reducer
#@+node:ekr.20051025144611.30:unbind
def unbind (context):

    '''This method turns everything off and removes the calltip and autobox from the canvas.'''

    if context.on: #no need to do this stuff, if were not 'on'
        context.on = False
        context.clean_editor()
        map(context.unbind,(
            "<Control_L>", "<Control_R>", "<Alt-Up>", "<Alt-Down>", "<Alt_L>", "<Alt_R>"))
        context.unbind_all('<Button>')
        context.update_idletasks()
#@nonl
#@-node:ekr.20051025144611.30:unbind
#@+node:ekr.20051025144611.31:moveSelItem
def moveSelItem (event, context ):

    '''Move the selection in the autobox up or down.'''

    autobox = context.autobox
    i = autobox.curselection()
    if len(i)==0:
        return None 
    i = int(i[0])
    # g.trace(event.keysym,i)
    try:
        if event.keysym=='Down':
            if autobox.size() - 1 > autobox.index( i ):
                i += 1
            elif i!=0:
                i -1  ## Can't be correct.
        elif event.keysym=='Up': # EKR.
            if i > 0:
                i -= 1
    finally:
        autobox.select_clear( 0, 'end' )
        autobox.select_set( i )
        autobox.see( i )
        context.update_idletasks()
        return "break"
#@-node:ekr.20051025144611.31:moveSelItem
#@+node:ekr.20051025144611.32:processKeyStroke
def processKeyStroke (event,context,body):

    '''Take action based on the state of context (a Tk.Canvas) and the event'''
    
    autobox = context.autobox

    if not context.on or event.keysym in ("??","Shift_L","Shift_R"):
        return None
    elif testForUnbind(event,context):
        unbind(context)
        return None
    elif context.which == 1:
        return None # It is calltip time.
        
    index = body.index('insert-1c wordstart')
    pat = body.get(index,'insert') + event.char
    pat = pat.lstrip('.')
    ww = list(autobox.get(0,'end'))
    aList = reducer(ww,pat)
    if not aList: return None
    # Select which item to select based on what the user has typed.
    i = ww.index(aList[0])
    # Set the current selection to match what the user has typed.
    autobox.select_clear(0,'end') 
    autobox.select_set(i)
    autobox.see(i)
    return 'break'
#@nonl
#@-node:ekr.20051025144611.32:processKeyStroke
#@+node:ekr.20051025144611.33:testForUnbind
def testForUnbind( event, context ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if event.keysym in ('parenright','Control_L','Control_R', 'Escape' ):
        return True
    elif not context.which and event.char in ripout:
        return True
    return False
#@-node:ekr.20051025144611.33:testForUnbind
#@+node:ekr.20051025144611.34:processAutoBox
def processAutoBox(event, context , body ):
    '''This method processes the selection from the autobox.'''
    if event.keysym in("Alt_L","Alt_R"):
        return None 

    a = context.autobox.getvalue()
    if len(a)==0:return None 
    try:
        a = a[0]
        ind = body.index('insert-1c wordstart')
        pat = body.get(ind,'insert')
        pat = pat.lstrip('.')

        if a.startswith(pat):a = a[len(pat):]
        body.insert('insert',a)
        body.event_generate("<Key>")
        body.update_idletasks()
    finally:
        unbind( context )
#@-node:ekr.20051025144611.34:processAutoBox
#@+node:ekr.20051025144611.35:add_item
def add_item (event, context ,body,colorizer):
    '''This function will add the autobox or the calltip label.'''
    if not event.char in('.','(')or context.on:return None 
    txt = body.get('insert linestart','insert')
    txt = _reverseFindWhitespace(txt)
    if event.char!='('and not watchwords.has_key(txt):
         return None 

    if event.char=='.' and useauto:

        ww = list(watchwords[txt])
        ww.sort()
        autobox = context.autobox
        configureAutoBox( autobox, ww )
        autolist = autobox.component( 'listbox' )
        #We have to hand the listbox in, its the only thing providing accuracy of size and position.
        calculatePlace( body, autolist, context, autobox )
        autobox.select_set( 0 )
        context.which = 0 #indicates it's in autocompletion mode
        add_bindings( context, body )
    
    elif event.char=='(' and usecall:
        language = colorizer.language 
        if calltips.has_key(language):
            if calltips[language].has_key(txt):

                s = list(calltips[language][txt])
                t = '\n'.join(s)
                calltip = context.calltip 
                calltip.configure(text=t)
                #The calltip provides sufficient size information to calculate its place on top of the context. 
                calculatePlace(body, calltip ,context, calltip  )
                context.which = 1 #indicates it's in calltip mode
        
        else:
            context.on = False 
            return None 

#@-node:ekr.20051025144611.35:add_item
#@+node:ekr.20051025144611.36:add_bindings
def add_bindings( context, body ):
    
    '''This def adds bindings to the Canvas so it can work with the autobox properly.'''
            
    event = Tk.Event()
    event.keysym = ''

    def processAutoBoxHandler( event = event , context = context, body = body  ): 
        processAutoBox( event, context , body  )
        
    context.autobox.configure( selectioncommand = processAutoBoxHandler )
    
    def moveSelItemHandler( event, context = context ): 
        moveSelItem( event, context )
    
    bindings = ( ( "<Control_L>", processAutoBoxHandler ), ( "<Control_R>", processAutoBoxHandler ),
                 ( "<Alt-Up>", moveSelItemHandler, '+' ), ( "<Alt-Down>", moveSelItemHandler , '+'),
                 ( "<Alt_L>", processAutoBoxHandler ), ( "<Alt_R>", processAutoBoxHandler ) )
         
    def bind2( args ): context.bind( *args )
    map( bind2, bindings )
#@nonl
#@-node:ekr.20051025144611.36:add_bindings
#@+node:ekr.20051025144611.37:configureAutoBox
def configureAutoBox ( autobox ,ww):
    '''sets data and size of autobox.'''
    autobox.setlist(ww)
    lb = autobox.component('listbox')
    height = len(ww)
    if height>5:height = 5
    lb.configure(height=height)
#@-node:ekr.20051025144611.37:configureAutoBox
#@+node:ekr.20051025144611.38:calculatePlace
def calculatePlace (body,cwidg, context ,toBePlaced):
     '''This def determines where the autobox or calltip label goes on the canvas.
       And then it puts it on the canvas.
       body is the Tk Text instance.
       cwidg is the widget from which we derive the calculations.
       context is the parent of the cwidg, we bind the context in this function.
       toBePlaced is the widget that is placed with the calculatsions performed.'''
     try:
        x, y, lww, lwh = body.bbox('insert -1c')
        x, y = x+lww, y+lwh 
     except:
         x = 1
         y = 1
     rwidth = cwidg.winfo_reqwidth()
     rheight = cwidg.winfo_reqheight()
     if body.winfo_width()<x+rwidth:  
        x = x-rwidth 
     if y>body.winfo_height()/2:
        h2 = rheight 
        h3 = h2+lwh 
        y = y-h3 

     toBePlaced.place( x = x, y = y )
     context.on = True
     context.bind_all( '<Button>', context.do_unbind )
#@-node:ekr.20051025144611.38:calculatePlace
#@+node:ekr.20051025144611.39:setLanguage
def setLanguage ( pos ):
    '''This method checks a node for the current language in effect
       and accends the parent line until it finds a language.'''
    global lang 
    while pos:
        xs1 = pos.bodyString()
        dict = g.get_directives_dict(xs1)
        if dict.has_key('language'):
            lang = g.set_language(xs1,dict['language'])[0]
            break 
        pos = pos.parent()
#@-node:ekr.20051025144611.39:setLanguage
#@+node:ekr.20051025144611.40:newCreateControl
def newCreateControl (self,frame,parentFrame):
    '''A decoration of the createControl def.
    We set up the ancestory of the control so we can draw
    widgets over the Text editor without disturbing the text.'''

@
Creating the background:
- We now use a placer: simpler to use and more efficient.
- We have to decorate the Tk.Text widget with a constructor that creates an
  intermediate Frame for the Text to be placed instead of packed.
  Had no idea that the placer could do this so nicely.
  With a couple changes in 3 places, we are using the placer !
@c
    orig_init = Tk.Text.__init__ #We stash the original init of Tk.Text
    def pre_init (self,master,*args,**kwords):

        context = Tk.Frame(master)
            #This is what we need to put in before the text to make place work.
        orig_init(self,context,*args,**kwords)

    Tk.Text.__init__ = pre_init #We restore the original init of Tk.Text
    body = orig_CreateControl(self,frame,parentFrame) #orig_CreatControl is the method this def decorates
    Tk.Text.__init__ = orig_init

    context = body.master #This is the Frame we created to intercept the passed in master.
    context.pack(expand=1,fill='both',after=frame.bodyBar) #We have to add it to the environment, since we pass on it in the __init__
    body.place(relwidth=1.0,relheight=1.0)
    body.commander = self.c #used in watcher
    context.on = False #determines if the system is autocompleting or calltiping
    addAutoboxAndCalltipWidgets(context)
    #These used to be lambdas, but I think this is clearer.
    def processKeyStrokeHandler (event,context=context,body=body):
        processKeyStroke(event,context,body)
    def addItemHandler (event,context=context,body=body,colorizer=frame.body):
        add_item(event,context,body,colorizer.getColorizer())

    for z in (watcher,processKeyStrokeHandler,addItemHandler):
        context.bind("<Key>",z,'+')

    ignore = [] #ignore items added to this list when a Button event occurs.
    if hasattr(context,'autobox'):
        ignore.append(context.autobox.component('listbox'))
        ignore.append(context.autobox.component('vertscrollbar'))
    def do_unbind (event):
        '''This def is for doing the unbind on any <Button> events.
           It only is in effect when the autobox or calltip label are showing.'''
        if event.widget not in ignore: #This ensures a click or scroll in the autobox takes effect.
                unbind(context)

    context.do_unbind = do_unbind

    # This part protects this plugin from others that use Alt-Up, Alt-Down.
    # The frame didnt seem to work.  Im assuming it was not appropiate enought in the bindtag order for the event.
    context.block_alt = Tk.Entry()
    def block_alt (event):
        '''This def blocks specific keyboard commands from reaching the Text editor.  'breaking' in
           the context does not occur before the event reaches the Text editor, so it has no effect'''
        if context.on: return 'break'
    for z in ('<Alt-Up>','<Alt-Down>'): context.block_alt.bind(z,block_alt)

    #set the bindtags for the body, protects the autocompleter from other plugins unbinding this plugins bindings.
    ctags = []
    ctags.append(context.bindtags()[0])
    ctags.append(context.block_alt.bindtags()[0])
    ctags.extend(body.bindtags())
    body.bindtags(tuple(ctags))

    return body
#@nonl
#@-node:ekr.20051025144611.40:newCreateControl
#@+node:ekr.20051025144611.41:addAutoboxAndCalltipWidgets
def addAutoboxAndCalltipWidgets( context ):
    '''This builds the autobox and the calltip label for the editor.
      It should be called once for every editor created.'''
    
    call_pack_forget = []

    if useauto:
        context.autobox = Pmw.ScrolledListBox(
            context ,hscrollmode='none',
            listbox_selectbackground='#FFE7C6',
            listbox_selectforeground='blue',
            listbox_background='white',
            listbox_foreground='blue',
            vertscrollbar_background='#FFE7C6',
            vertscrollbar_width=10)
        call_pack_forget.append( context.autobox.component( 'hull' ) )
    
    if usecall:            
        context.calltip = Tk.Label(context,background='lightyellow',foreground='black')
        call_pack_forget.append( context.calltip )
    
    def clean_editor( ca = call_pack_forget ):
        #This def makes removing the autobox or calltip label easy.
        # No need for an intermediate variable like 'current'.
        for z in ca: z.place_forget()

    context.clean_editor = clean_editor
#@nonl
#@-node:ekr.20051025144611.41:addAutoboxAndCalltipWidgets
#@+node:ekr.20051025144611.42:onOpenWindow
def onOpenWindow ():

    #what does this do?
    c = keywords.get("c")
    if haveseen.has_key(c):
        return 
        
    autocompleter = autocomplet(c)
#@nonl
#@-node:ekr.20051025144611.42:onOpenWindow
#@-node:ekr.20051025144611.4:autocompleter.py
#@-node:ekr.20051025144611:Reference (Do not delete)
#@+node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.4062:center_dialog
def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4062:center_dialog
#@+node:ekr.20031218072017.4063:create_labeled_frame
# Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) > 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f
#@nonl
#@-node:ekr.20031218072017.4063:create_labeled_frame
#@-node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4065:get_focus
def get_focus(self,c):
    
    """Returns the widget that has focus, or body if None."""

    return c.frame.top.focus_displayof()
#@nonl
#@-node:ekr.20031218072017.4065:get_focus
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@-node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            << try to use the PIL and tkIcon packages to draw the icon >>
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None
#@nonl
#@+node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("<Visibility>",visibilityCallback)

if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)
#@nonl
#@-node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
#@+node:ekr.20031218072017.4070:createLeoIcon
# This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.4070:createLeoIcon
#@-node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
#@-node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
#@-node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4075:firstIndex
def firstIndex (self):

    return "1.0"
#@nonl
#@-node:ekr.20031218072017.4075:firstIndex
#@+node:ekr.20031218072017.4076:lastIndex
def lastIndex (self):

    return "end"
#@nonl
#@-node:ekr.20031218072017.4076:lastIndex
#@+node:ekr.20031218072017.4077:moveIndexBackward
def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
#@-node:ekr.20031218072017.4077:moveIndexBackward
#@+node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
#@nonl
#@-node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
#@+node:ekr.20031218072017.4079:compareIndices
def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False
#@nonl
#@-node:ekr.20031218072017.4079:compareIndices
#@+node:ekr.20031218072017.4080:getindex
def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))
#@nonl
#@-node:ekr.20031218072017.4080:getindex
#@-node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4082:getInsertPoint
def getInsertPoint(self,t):
    
    try:
        return t.index("insert")
    except Exception:
        return '1.0'
#@nonl
#@-node:ekr.20031218072017.4082:getInsertPoint
#@+node:ekr.20031218072017.4083:setInsertPoint
def setInsertPoint (self,t,pos):

    try:
        t.mark_set("insert",pos)
    except Exception:
        pass
#@nonl
#@-node:ekr.20031218072017.4083:setInsertPoint
#@-node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4085:getSelectionRange
def getSelectionRange (self,t):
    
    try:
        # Warning: this can return None.
        return t.tag_ranges("sel")
    except Exception:
        return 0,0
#@nonl
#@-node:ekr.20031218072017.4085:getSelectionRange
#@+node:ekr.20051126125950:getSelectedText
def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
#@nonl
#@-node:ekr.20051126125950:getSelectedText
#@+node:ekr.20031218072017.4086:getTextSelection
def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, ">", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert
#@nonl
#@-node:ekr.20031218072017.4086:getTextSelection
#@+node:ekr.20051126171929:hasSelection
def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j
#@nonl
#@-node:ekr.20051126171929:hasSelection
#@+node:ekr.20031218072017.4088:setSelectionRangeWithLength
def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))
#@nonl
#@-node:ekr.20031218072017.4088:setSelectionRangeWithLength
#@+node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return
        
    try:
        if t.compare(start, ">", end):
            start,end = end,start
            
        t.tag_remove("sel","1.0",start)
        t.tag_add("sel",start,end)
        t.tag_remove("sel",end,"end")
        
        # New in 4.4a5: this logic ensures compatibility with previous code.
        if insert == 'sel.end':
            g.app.gui.setInsertPoint(t,end)
        elif insert is not None:
            g.app.gui.setInsertPoint(t,insert)
    except Exception:
        pass
    
setSelectionRange = setTextSelection
#@nonl
#@-node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
#@-node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4091:getAllText
def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4091:getAllText
#@+node:ekr.20031218072017.4092:getCharAfterIndex
def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c",">=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4092:getCharAfterIndex
#@+node:ekr.20031218072017.4093:getCharAtIndex
def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4093:getCharAtIndex
#@+node:ekr.20031218072017.4094:getCharBeforeIndex
def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4094:getCharBeforeIndex
#@+node:ekr.20031218072017.4095:getLineContainingIndex
def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4095:getLineContainingIndex
#@+node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)
#@nonl
#@-node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
#@-node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20031218072017.4098:makeIndexVisible
def makeIndexVisible(self,t,index):

    return t.see(index)
#@nonl
#@-node:ekr.20031218072017.4098:makeIndexVisible
#@-node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20051220144507:isTextWidget
def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) 
#@nonl
#@-node:ekr.20051220144507:isTextWidget
#@-node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20051126123249:class autoCompleterClass (prototype)
class autoCompleterCommandsClass (baseEditCommandsClass):
    
    '''Similar to typing completion in the minibuffer,
    but the presently selected completion is shown in the widget itself.'''

    @others
#@nonl
#@+node:ekr.20051126123759: birth
#@+node:ekr.20051126123759.1: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.c = c
    self.k = c.k
    self.membersList = None
    self.prefix = None
    self.tabList = []
    self.tabListIndex = -1
    self.text = None # For Escape.
    self.widget = None
#@nonl
#@-node:ekr.20051126123759.1: ctor
#@+node:ekr.20051126123759.2: getPublicCommands (autoCommandsClass)
def getPublicCommands (self):

    k = self.k

    return {
        'auto-complete':    self.autoComplete,
    }
#@nonl
#@-node:ekr.20051126123759.2: getPublicCommands (autoCommandsClass)
#@-node:ekr.20051126123759: birth
#@+node:ekr.20051127105431:abort
def abort (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    
    c.widgetWantsFocus(w)

    w.delete('1.0','end')
    w.insert('1.0',self.text)
    gui.setTextSelection(w,'1.0','1.0')
#@nonl
#@-node:ekr.20051127105431:abort
#@+node:ekr.20051126122952.1:autoComplete
def autoComplete (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    self.widget = w = event and event.widget 
    self.prefix = gui.getSelectedText(w) or ''
    self.text = gui.getAllText(w)

    c.frame.log.clearTab('Completion') # Creates the tab if necessary.
    self.membersList = c.commandsDict.keys() ## Testing only.
    k.setState('auto-completer',1,handler=self.stateHandler)
    self.computeCompletionList()
#@nonl
#@-node:ekr.20051126122952.1:autoComplete
#@+node:ekr.20051126123149:computeCompletionList (autoCompleter)
def computeCompletionList (self):
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    c.widgetWantsFocus(w)
    s = gui.getSelectedText(w)
    if s:
        self.tabList,common_prefix = g.itemsMatchingPrefixInList(s,self.membersList)
        c.frame.log.clearTab('Completion') # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            g.es('%s' % (name),tabName='Completion')
#@nonl
#@-node:ekr.20051126123149:computeCompletionList (autoCompleter)
#@+node:ekr.20051126131103:doBackSpace
def doBackSpace (self):

    '''Cut back to previous prefix.'''

    self.prefix = self.prefix[:-1]
    self.setSelection(self.prefix)
    self.computeCompletionList()
#@nonl
#@-node:ekr.20051126131103:doBackSpace
#@+node:ekr.20051126123249.1:doTabCompletion (autoCompleter)
def doTabCompletion (self):
    
    '''Handle tab completion when the user hits a tab.'''
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    s = gui.getSelectedText(w)

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex >= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20051126123249.1:doTabCompletion (autoCompleter)
#@+node:ekr.20051127065601:extendSelection
def extendSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
    else:
        i = j = gui.getInsertPoint(w)
    
    w.insert(j,s)
    j = w.index('%s + 1c' % (j))
    gui.setSelectionRange(w,i,j)
#@nonl
#@-node:ekr.20051127065601:extendSelection
#@+node:ekr.20051127105102:finish
def finish (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.widgetWantsFocus(w)
    
    i,j = gui.getTextSelection(w)
    if i != j:
        gui.setTextSelection(w,j,j)
#@nonl
#@-node:ekr.20051127105102:finish
#@+node:ekr.20051127070018:setSelection
def setSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = gui.getInsertPoint(w)
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    gui.setSelectionRange(w,i,j)
#@nonl
#@-node:ekr.20051127070018:setSelection
#@+node:ekr.20051126124705:stateHandler (autoCompleter)
def stateHandler (self,event):
    
    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.widget
    keysym = event and event.keysym
    ch = event and event.char or ''
    # g.trace(repr(ch),repr(keysym))
    if keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.finish()
    elif keysym == 'Escape':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif ch in string.printable:
        self.extendSelection(ch)
        s = gui.getSelectedText(w)
        if s.startswith(self.prefix):
            self.prefix = self.prefix + ch
            # g.trace('prefix',self.prefix)
        self.computeCompletionList()
#@nonl
#@-node:ekr.20051126124705:stateHandler (autoCompleter)
#@-node:ekr.20051126123249:class autoCompleterClass (prototype)
#@-node:ekr.20051126122638:Autocompletion tab
#@+node:ekr.20060211100150:Fix chapters plugin
#@-node:ekr.20060211100150:Fix chapters plugin
#@-node:ekr.20060212110815:First: urgent
#@+node:ekr.20060122183544:Improve isearch
@nocolor

- Handle backspace for isearch: keep a stack of previous matches.
- Allow cross-node isearches.
#@-node:ekr.20060122183544:Improve isearch
#@+node:ekr.20060122185507:New commands
#@+node:ekr.20060210140415:Most important
#@+node:ekr.20060211093935:Support for @list and on-enter-mode
#@-node:ekr.20060211093935:Support for @list and on-enter-mode
#@+node:ekr.20060113090042:open-outline-by-name & filename completion
#@-node:ekr.20060113090042:open-outline-by-name & filename completion
#@+node:ekr.20060122194643:isearch-headline (forward & backward)
#@-node:ekr.20060122194643:isearch-headline (forward & backward)
#@+node:ekr.20060116085649:find-word-on-line, find-character-on-line (forward & backward)
#@-node:ekr.20060116085649:find-word-on-line, find-character-on-line (forward & backward)
#@+node:ekr.20060206103922:Minibuffer interface for GoToLine number
#@-node:ekr.20060206103922:Minibuffer interface for GoToLine number
#@+node:ekr.20060116074839.2:extend-to-word
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20060117115212:Rename buffer doesn't seem to work
#@-node:ekr.20060117115212:Rename buffer doesn't seem to work
#@+node:ekr.20060123091352:Incremental search in switch-to-buffer
#@-node:ekr.20060123091352:Incremental search in switch-to-buffer
#@+node:ekr.20060104083551:move-line-up/down (LeoUser)
http://sourceforge.net/forum/message.php?msg_id=3488030

move-region-up

Swap the selection with the line above it. If we are at the top of a node, the
node identified by threadBack() is selected and the text is moved to the bottom
of the node.

move-region-down

Swap the selection with the line below it. If we are at the bottom of the node,
the node identified by threadNext() is selected and the text is moved to the top
of the node.

In all cases the moved text remains selected, even when the text moves to another node.
#@nonl
#@-node:ekr.20060104083551:move-line-up/down (LeoUser)
#@+node:ekr.20060116084526.1:insert/remove spaces/tabs from lines (LeoUser)
http://sourceforge.net/forum/message.php?msg_id=3488030

add-space-to-lines      Adds a space is added to start of all selected lines.

add-tab-to-line         Adds 4 spaces to start of all selected lines.

remove-space-from lines Removes a space from start of all selected lines.

remove-tab-from lines   Removes a space from start of all selected lines.
#@nonl
#@-node:ekr.20060116084526.1:insert/remove spaces/tabs from lines (LeoUser)
#@+node:ekr.20060123095316:clear-selection
Useful, e.g., after a find.
#@nonl
#@-node:ekr.20060123095316:clear-selection
#@+node:ekr.20051202095626:help-for-command
Use docstrings as the help message.
#@nonl
#@-node:ekr.20051202095626:help-for-command
#@+node:ekr.20060116090428:Expand 'point' so it indicates node as well as text location
#@-node:ekr.20060116090428:Expand 'point' so it indicates node as well as text location
#@-node:ekr.20060210140415:Most important
#@+node:ekr.20060210140415.1:Others
#@+node:ekr.20060209105218.2:contract-all-except-present-tree
#@-node:ekr.20060209105218.2:contract-all-except-present-tree
#@+node:ekr.20060206114203:toggle-find-tab-views
show/hide buttons, etc.
#@-node:ekr.20060206114203:toggle-find-tab-views
#@+node:ekr.20060206104205:Finish query-replace
#@-node:ekr.20060206104205:Finish query-replace
#@+node:ekr.20060109183500.1:execute-named-script
execute-named-script executes script in leo/scripts.
#@nonl
#@-node:ekr.20060109183500.1:execute-named-script
#@+node:ekr.20060116074450:Drive tabs from keyboard
- create-tab
- clear-tab
- delete-tab
- hide-tab
- show-tab, show-log

These might get the tab name from the minibuffer...
#@nonl
#@-node:ekr.20060116074450:Drive tabs from keyboard
#@+node:ekr.20051021074728:Space completion
#@-node:ekr.20051021074728:Space completion
#@-node:ekr.20060210140415.1:Others
#@+node:ekr.20060202231708.1:Use minibuffer names for all menu entries
This will allow @menu nodes in leoSettings.leo
#@nonl
#@-node:ekr.20060202231708.1:Use minibuffer names for all menu entries
#@+node:ekr.20051121070552:Finish Cmds menu
#@+node:ekr.20060117112444:What I did
@nocolor

- Call menu.defineMenuTables from menu.createMenusFromTables.
  This ensures the keyHandler class has been created.

- Added support for using minibuffer command names instead of command in menu
tables. This is a signal that the command is a new-style minibuffer command
rather than a legacy command. This required minor changes in createMenu entries
and defineMenuCallback.
#@nonl
#@-node:ekr.20060117112444:What I did
#@+node:ekr.20060117114903:Others
#@+node:ekr.20050920085536.65:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None
    
    if trace and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    elif k.inState():
        return 'break' # New in 4.4b2: ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event)
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.
k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65:masterCommand & helpers
#@+node:ekr.20031218072017.4117:defineMenuCallback
def defineMenuCallback(self,command,name,minibufferCommand):
    
    if minibufferCommand:
        
        # Create a dummy event as a signal to doCommand.
        event = g.Bunch(keysym='',char='',widget='')
        
        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label,event)
    
        return minibufferMenuCallback
        
    else:
    
        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label)
    
        return legacyMenuCallback
#@nonl
#@-node:ekr.20031218072017.4117:defineMenuCallback
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@+node:ekr.20031218072017.3752:defineMenuTables & helpers
def defineMenuTables (self):
    
    c = self.c
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()
#@nonl
#@+node:ekr.20031218072017.3753:defineEditMenuTables & helpers
def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditCursorTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
#@nonl
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo",c.undoer.undo), # &U reserved for Undo
        ("Can't Redo",c.undoer.redo), # &R reserved for Redo
        ("-",None),
        ("Cu&t",f.OnCutFromMenu), 
        ("Cop&y",f.OnCopyFromMenu),
        ("&Paste",f.OnPasteFromMenu),
        ("&Delete",c.editCommands.backwardDeleteCharacter),
        ("Select &All",f.body.selectAllText),
        ("-",None),
    ]

    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20050711091931:defineEditMenuEditCursorTable
def defineEditMenuEditCursorTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    if 0: ### Not ready yet.
        # These should have Emacs names...
        self.editMenuEditCursorTable = [
            ('Delete Right',c.deleteRightChar), 
            ('Delete Left',c.deleteLeftChar), 
            # Moving the cursor.
            ('Start of Line',c.moveToStartOfLine), 
            ('End of Line',c.moveToEndOfLine), 
            ('Start of Node',c.moveToStartOfNode),
            ('End of Node',c.moveToEndOfNode), 
            ('-',None,None),
            # Extending the selection...
            ('Select Line',c.selectEntireLine),
            ('Extend To Start of Word',c.extendToStartOfWord),
            ('Extend To End of Word',c.extendToEndOfWord),
            ('Extend To Start Of Line',c.extendToStartOfLine), 
            ('Extend To End Of Line',c.extendToEndOfLine), 
            ('Extend To End of Node',c.extendToEndOfNode),
            # The mark...
        ]
#@nonl
#@-node:ekr.20050711091931:defineEditMenuEditCursorTable
#@+node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
def defineEditMenuEditBodyTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuEditBodyTable = [
        ("Extract &Section",c.extractSection),
        ("Extract &Names",c.extractSectionNames),
        ("&Extract",c.extract),
        ("-",None,None),
        ("Convert All B&lanks",c.convertAllBlanks),
        ("Convert All T&abs",c.convertAllTabs),
        ("Convert &Blanks",c.convertBlanks),
        ("Convert &Tabs",c.convertTabs),
        ("Insert Body Time/&Date",c.insertBodyTime),
        ("&Reformat Paragraph",c.reformatParagraph),
        ("-",None,None),
        ("&Indent",c.indentBody),
        ("&Unindent",c.dedentBody),
        ("&Match Brackets",c.findMatchingBracket),
        ("Add Comments",c.addComments),
        ("Delete Comments",c.deleteComments),
    ]
    # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
#@nonl
#@-node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
#@+node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
def defineEditMenuEditHeadlineTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    self.editMenuEditHeadlineTable = [
        ("Edit &Headline",c.editHeadline),
        ("&End Edit Headline",f.endEditLabelCommand),
        ("&Abort Edit Headline",f.abortEditLabelCommand),
        ("Insert Headline Time/&Date",f.insertHeadlineTime),
        ("Toggle Angle Brackets",c.toggleAngleBrackets),
    ]
#@nonl
#@-node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    # Bind to the Find tab.
    sc = c.searchCommands
    self.editMenuFindMenuTable = [
        ("&Show Find Tab",  sc.openFindTab),
        ("&Hide Find Tab",  sc.hideFindTab),
        ("-",None),
        ("Find &Next",          sc.findTabFindNext),
        ("Find &Previous",      sc.findTabFindPrev),
        ("&Replace",            sc.findTabChange),
        ("Replace, &Then Find", sc.findTabChangeThenFind),
    ]
#@nonl
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20031218072017.3757:defineEditMenuTop2Table
def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&visibles","Show In&visibles")
        
    self.editMenuTop2Table = [
        ("&Go To Line Number",c.goToLineNumber),
        ("&Execute Script",c.executeScript),
        (label,c.viewAllCharacters),
        ("Setti&ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.3757:defineEditMenuTop2Table
#@-node:ekr.20031218072017.3753:defineEditMenuTables & helpers
#@+node:ekr.20031218072017.3758:defineFileMenuTables & helpers
def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
#@nonl
#@+node:ekr.20031218072017.3759:defineFileMenuTopTable
def defineFileMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTopTable = [
        ("&New",c.new),
        ("&Open...",c.open),
    ]
#@nonl
#@-node:ekr.20031218072017.3759:defineFileMenuTopTable
#@+node:ekr.20031218072017.3760:defineFileMenuTop2Table
def defineFileMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop2Table = [
        ("-",None),
        ("&Close",c.close),
        ("&Save",c.save),
        ("Save &As",c.saveAs),
        ("Save To",c.saveTo), # &Tangle
        ("Re&vert To Saved",c.revert), # &Read/Write
    ]
#@nonl
#@-node:ekr.20031218072017.3760:defineFileMenuTop2Table
#@+node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame ; fc = c.fileCommands

    self.fileMenuReadWriteMenuTable = [
        ("&Read Outline Only",c.readOutlineOnly),
        ("Read @file &Nodes",c.readAtFileNodes),
        ("-",None),
        ("Write &Dirty @file Nodes",fc.writeDirtyAtFileNodes),
        ("Write &Missing @file Nodes",fc.writeMissingAtFileNodes),
        ("Write &Outline Only",fc.writeOutlineOnly),
        ("&Write @file Nodes",fc.writeAtFileNodes),
    ]
#@nonl
#@-node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
#@+node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
def defineFileMenuTangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTangleMenuTable = [
        ("Tangle &All",c.tangleAll),
        ("Tangle &Marked",c.tangleMarked),
        ("&Tangle",c.tangle),
    ]
#@nonl
#@-node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
#@+node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
def defineFileMenuUntangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuUntangleMenuTable = [
        ("Untangle &All",c.untangleAll),
        ("Untangle &Marked",c.untangleMarked),
        ("&Untangle",c.untangle),
    ]
#@nonl
#@-node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
#@+node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
def defineFileMenuImportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuImportMenuTable = [
        ("Import Derived File",c.importDerivedFile),
        ("Import To @&file",c.importAtFile),
        ("Import To @&root",c.importAtRoot),
        ("Import &CWEB Files",c.importCWEBFiles),
        ("Import &noweb Files",c.importNowebFiles),
        ("Import Flattened &Outline",c.importFlattenedOutline),
    ]
#@nonl
#@-node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
#@+node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
def defineFileMenuExportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuExportMenuTable = [
        ("Export &Headlines",c.exportHeadlines),
        ("Outline To &CWEB",c.outlineToCWEB),
        ("Outline To &Noweb",c.outlineToNoweb),
        ("&Flatten Outline",c.flattenOutline),
        ("&Remove Sentinels",c.removeSentinels),
        ("&Weave",c.weave),
    ]
#@nonl
#@-node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
#@+node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
def defineFileMenuTop3MenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop3MenuTable = [
        ("E&xit",g.app.onQuit),
    ]
#@nonl
#@-node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
#@-node:ekr.20031218072017.3758:defineFileMenuTables & helpers
#@+node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
#@nonl
#@+node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&ut Node",c.cutOutline),
        ("C&opy Node",c.copyOutline),
        ("&Paste Node",c.pasteOutline),
        ("Pas&te Node As Clone",c.pasteOutlineRetainingClones),
        ("&Delete Node",c.deleteOutline),
        ("-",None,None),
        ("&Insert Node",c.insertHeadline),
        ("&Clone Node",c.clone),
        ("Sort Childre&n",c.sortChildren), # Conflicted with Hoist.
        ("&Sort Siblings",c.sortSiblings),
        ("-",None),
        ("&Hoist",c.hoist),
        ("D&e-Hoist",f.c.dehoist),
        ("-",None),
    ]
    # Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
    # Bindings for entries that go to submenus: a,g,k,m,x
#@nonl
#@-node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
#@+node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &Outline",c.checkOutline),
        ("&Dump Outline",c.dumpOutline),
        ("-",None),
        ("Check &All Python Code",c.checkAllPythonCode),
        ("&Check Python &Code",c.checkPythonCode),
        ("-",None),
        ("Pretty P&rint All Python Code",c.prettyPrintAllPythonCode),
        ("&Pretty Print Python Code",c.prettyPrintPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r
#@nonl
#@-node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
#@+node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&Contract All",c.contractAllHeadlines),
        ("Contract &Node",c.contractNode),
        ("Contract &Parent",c.contractParent),
        ("Contract Or Go Left",c.contractNodeOrGoToParent),
        ("-",None),
        ("Expand P&rev Level",c.expandPrevLevel),
        ("Expand N&ext Level",c.expandNextLevel),
        ("Expand And Go Right",c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",c.expandNodeOrGoToFirstChild),
        ("-",None),
        ("Expand To Level &1",c.expandLevel1),
        ("Expand To Level &2",c.expandLevel2),
        ("Expand To Level &3",c.expandLevel3),
        ("Expand To Level &4",c.expandLevel4),
        ("Expand To Level &5",c.expandLevel5),
        ("Expand To Level &6",c.expandLevel6),
        ("Expand To Level &7",c.expandLevel7),
        ("Expand To Level &8",c.expandLevel8),
        ("-",None),
        ("Expand &All",c.expandAllHeadlines),
        ("Expand N&ode",c.expandNode),
    ]
#@nonl
#@-node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
#@+node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &Down",c.moveOutlineDown),
        ("Move &Left",c.moveOutlineLeft),
        ("Move &Right",c.moveOutlineRight),
        ("Move &Up",c.moveOutlineUp),
        ("-",None),
        ("&Promote",c.promote),
        ("&Demote",c.demote),
    ]
#@nonl
#@-node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
#@+node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&Mark",c.markHeadline),
        ("Mark &Subheads",c.markSubheads),
        ("Mark Changed &Items",c.markChangedHeadlines),
        ("Mark Changed &Roots",c.markChangedRoots),
        ("Mark &Clones",c.markClones),
        ("&Unmark All",c.unmarkAll),
    ]
#@nonl
#@-node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
#@+node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",c.goNextVisitedNode),
        ("Go To Prev Node",c.selectThreadBack),
        ("Go To Next Node",c.selectThreadNext),
        ("-",None),
        ("Go To Next Marked",c.goToNextMarkedHeadline),
        ("Go To Next Changed",c.goToNextDirtyHeadline),
        ("Go To Next Clone",c.goToNextClone),
        ("-",None),
        ("Go To First Node",c.goToFirstNode),
        ("Go To Prev Visible",c.selectVisBack),
        ("Go To Next Visible",c.selectVisNext),
        ("Go To Last Node",c.goToLastNode),
        ('Go To Last Visible',c.goToLastVisibleNode),
        ("-",None),
        ("Go To Parent",c.goToParent),
        ('Go To First Sibling',c.goToFirstSibling),
        ('Go To Last Sibling',c.goToLastSibling),
        ("Go To Prev Sibling",c.goToPrevSibling),
        ("Go To Next Sibling",c.goToNextSibling),
    ]
#@nonl
#@-node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
#@-node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
#@+node:ekr.20050921103230:defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):
    
    self.defineCmdsMenuTopTable()
    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCenterTable()
    self.defineCmdsMenuChangeCaseTable()
    self.defineCmdsMenuIndentTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuSortTable()
    self.defineCmdsMenuSpellCheckTable()
#@+node:ekr.20060117094955: defineCmdsMenuTopTable
def defineCmdsMenuTopTable (self):
    
    self.cmdsMenuTopTable = [
        ('Repeat Last Complex Command','repeat-complex-command'),
        ('Execute Named Command','full-command'),
        ("-",None),
    ]
#@-node:ekr.20060117094955: defineCmdsMenuTopTable
#@+node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable (to do)
def defineCmdsMenuAbbrevTable (self):
    
    c = self.c
    
    self.cmdsMenuAbbrevTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable (to do)
#@+node:ekr.20060117095212:defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        ('Append To Buffer',             'append-to-buffer'),
        ('Kill Buffer',                  'kill-buffer'),
        ('List Buffers',                 'list-buffers'),
        ('List Buffers Alphbetically',   'list-buffers-alphabetically'),
        ('Prepend To Buffer',            'prepend-to-buffer'),
        ('Rename Buffer',                'rename-buffer'),
        ('Switch To Buffer',             'switch-to-buffer'),
    ]
#@nonl
#@-node:ekr.20060117095212:defineCmdsMenuBufferTable
#@+node:ekr.20060117095212.5:defineCmdsMenuCenterTable
def defineCmdsMenuCenterTable (self):

    c = self.c

    self.cmdsMenuCenterTable = [
        ('Center Line',     'center-line'),
        ('Center Region',   'center-region'),
    ]
#@nonl
#@-node:ekr.20060117095212.5:defineCmdsMenuCenterTable
#@+node:ekr.20060117095212.4:defineCmdsMenuChangeCaseTable
def defineCmdsMenuChangeCaseTable (self):

    c = self.c

    self.cmdsMenuChangeCaseTable = [
        ('Capitalize Word', 'capitalize-word'),
        ('Downcase Region', 'downcase-region'),
        ('Downcase Word',   'downcase-word'),
        ('Upcase Region',   'upcase-region'), # Crashes.
        ('Upcase Word',     'upcase-word'),
    ]
    
#@nonl
#@-node:ekr.20060117095212.4:defineCmdsMenuChangeCaseTable
#@+node:ekr.20060117095212.6:defineCmdsMenuIndentTable
def defineCmdsMenuIndentTable (self):

    c = self.c

    self.cmdsMenuIndentTable = [
        ('Indent Region',   'indent-region'),
        ('Indent Relative', 'indent-relative'),
        ('Indent Rigidly',  'indent-rigidly'),
        ('Unindent Region', 'unindent-region'),
    ]
#@nonl
#@-node:ekr.20060117095212.6:defineCmdsMenuIndentTable
#@+node:ekr.20060117114315:defineCmdsMenuMacroTable(to do)
def defineCmdsMenuMacroTable (self):

    c = self.c

    self.cmdsMenuMacroTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117114315:defineCmdsMenuMacroTable(to do)
#@+node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable(to do)
def defineCmdsMenuRectanglesTable (self):

    c = self.c

    self.cmdsMenuRectanglesTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable(to do)
#@+node:ekr.20060117095212.1:defineCmdsMenuRegistersTable(to do)
def defineCmdsMenuRegistersTable (self):

    c = self.c

    self.cmdsMenuRegistersTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117095212.1:defineCmdsMenuRegistersTable(to do)
#@+node:ekr.20060117095212.3:defineCmdsMenuSortTable
def defineCmdsMenuSortTable (self):

    c = self.c

    self.cmdsMenuSortTable = [
        ('Sort Columns',    'sort-columns'),
        ('Sort Fields',     'sort-fields'),
        ('Sort Lines',      'sort-lines'),
    ]
#@nonl
#@-node:ekr.20060117095212.3:defineCmdsMenuSortTable
#@+node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    c = self.c

    self.cmdsMenuSpellCheckTable = [
        ('Check Spelling',      'open-spell-tab'),
        ('Change',              'spell-change'),
        ('Change, Then Find',   'spell-change-then-find'),
        ('Find',                'spell-find'),
        ('Ignore',              'spell-ignore'),
    ]
#@nonl
#@-node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
#@-node:ekr.20050921103230:defineCmdsMenuTables & helpers
#@+node:ekr.20031218072017.3773:defineWindowMenuTables
def defineWindowMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.windowMenuTopTable = [
        ("&Equal Sized Panes",f.equalSizedPanes),
        ("Toggle &Active Pane",f.toggleActivePane),
        ("Toggle &Split Direction",f.toggleSplitDirection),
        ("-",None),
        ("Resize To Screen",f.resizeToScreen),
        ("Casca&de",f.cascade),
        ("&Minimize All",f.minimizeAll),
        ("-",None),
        ("Open &Compare Window",c.openCompareWindow),
        ("Open &Python Window",c.openPythonWindow),
    ]
#@nonl
#@-node:ekr.20031218072017.3773:defineWindowMenuTables
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.helpMenuTopTable = [
        ("&About Leo...",c.about),
        ("Online &Home Page",c.leoHome),
        ("Open Online &Tutorial",c.leoTutorial),
    ]

    self.helpMenuTop2Table = [
        ("Open &Offline Tutorial",f.leoHelp),
    ]

    self.helpMenuTop3Table = [
        ("-",None,None),
        ("Open Leo&Docs.leo",c.leoDocumentation),
        ("Open Leo&Plugins.leo",c.openLeoPlugins),
        ("Open Leo&Settings.leo",c.openLeoSettings),
    ]
#@nonl
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20031218072017.3752:defineMenuTables & helpers
#@+node:ekr.20031218072017.3785:createMenusFromTables & helpers
def createMenusFromTables (self):
    
    c = self.c
    
    self.defineMenuTables()
    
    self.createFileMenuFromTable()
    self.createEditMenuFromTable()
    self.createOutlineMenuFromTable()
    
    g.doHook("create-optional-menus",c=c)
    
    if self.useCmdMenu:
        self.createCmndsMenuFromTable()

    self.createWindowMenuFromTable()
    self.createHelpMenuFromTable()
#@nonl
#@+node:ekr.20031218072017.3790:createFileMenuFromTable
def createFileMenuFromTable (self):
    
    c = self.c
    fileMenu = self.createNewMenu("&File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    << create the recent files submenu >>
    self.add_separator(fileMenu)
    << create the read/write submenu >>
    << create the tangle submenu >>
    << create the untangle submenu >>
    << create the import submenu >>
    << create the export submenu >>
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
#@nonl
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
#@nonl
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("&Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
#@nonl
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
#@nonl
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
#@nonl
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
#@nonl
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:createFileMenuFromTable
#@+node:ekr.20031218072017.3786:createEditMenuFromTable
def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    << create the edit body submenu >>
    << create the edit headline submenu >>
    << create the find submenu >>
    
    self.createMenuEntries(editMenu,self.editMenuTop2Table)
#@nonl
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
#@nonl
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
#@nonl
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
#@nonl
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:createEditMenuFromTable
#@+node:ekr.20031218072017.3797:createOutlineMenuFromTable
def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&Outline")
    
    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)
    
    << create check submenu >>
    << create expand/contract submenu >>
    << create move submenu >>
    << create mark submenu >>
    << create goto submenu >>
#@nonl
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
#@nonl
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
#@nonl
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
#@nonl
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
#@nonl
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
#@nonl
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:createOutlineMenuFromTable
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('C&mds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table,sep in (
        ('Abbrev...',       self.cmdsMenuAbbrevTable,       False),
        ('Buffers...',      self.cmdsMenuBuffersTable,      False),
        ('Center...',       self.cmdsMenuCenterTable,       False),
        ('Change Case...',  self.cmdsMenuChangeCaseTable,   False),
        ('Indent...',       self.cmdsMenuIndentTable,       False),
        ('Macro...',        self.cmdsMenuMacroTable,        False),
        ('Rectangles...',   self.cmdsMenuRectanglesTable,   False),
        ('Registers...',    self.cmdsMenuRegistersTable,    False),
        ('Sort...',         self.cmdsMenuSortTable,         False),
        ('Spell Check...',  self.cmdsMenuSpellCheckTable,   False),
    ):
        menu = self.createNewMenu(name,'Cmds')
        self.createMenuEntries(menu,table)
        if sep: self.add_separator(cmdsMenu)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20031218072017.3802:createWindowMenuFromTable
def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&Window")
    
    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
#@nonl
#@-node:ekr.20031218072017.3802:createWindowMenuFromTable
#@+node:ekr.20031218072017.3803:createHelpMenuFromTable
def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu()
        if not helpMenu: return
    else:
        helpMenu = self.createNewMenu("&Help")
    
    self.createMenuEntries(helpMenu,self.helpMenuTopTable)
    
    if sys.platform=="win32":
        self.createMenuEntries(helpMenu,self.helpMenuTop2Table)
    
    self.createMenuEntries(helpMenu,self.helpMenuTop3Table)
#@nonl
#@-node:ekr.20031218072017.3803:createHelpMenuFromTable
#@-node:ekr.20031218072017.3785:createMenusFromTables & helpers
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('C&mds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table,sep in (
        ('Abbrev...',       self.cmdsMenuAbbrevTable,       False),
        ('Buffers...',      self.cmdsMenuBuffersTable,      False),
        ('Center...',       self.cmdsMenuCenterTable,       False),
        ('Change Case...',  self.cmdsMenuChangeCaseTable,   False),
        ('Indent...',       self.cmdsMenuIndentTable,       False),
        ('Macro...',        self.cmdsMenuMacroTable,        False),
        ('Rectangles...',   self.cmdsMenuRectanglesTable,   False),
        ('Registers...',    self.cmdsMenuRegistersTable,    False),
        ('Sort...',         self.cmdsMenuSortTable,         False),
        ('Spell Check...',  self.cmdsMenuSpellCheckTable,   False),
    ):
        menu = self.createNewMenu(name,'Cmds')
        self.createMenuEntries(menu,table)
        if sep: self.add_separator(cmdsMenu)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and k.prettyPrintKey(accelerator).lstrip('<').rstrip('>')
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20060117114903:Others
#@+node:ekr.20060117123143:editing commands
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
       
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
      
#@-node:ekr.20060117123143:editing commands
#@+node:ekr.20050921103230:defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):
    
    self.defineCmdsMenuTopTable()
    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCenterTable()
    self.defineCmdsMenuChangeCaseTable()
    self.defineCmdsMenuIndentTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuSortTable()
    self.defineCmdsMenuSpellCheckTable()
#@+node:ekr.20060117094955: defineCmdsMenuTopTable
def defineCmdsMenuTopTable (self):
    
    self.cmdsMenuTopTable = [
        ('Repeat Last Complex Command','repeat-complex-command'),
        ('Execute Named Command','full-command'),
        ("-",None),
    ]
#@-node:ekr.20060117094955: defineCmdsMenuTopTable
#@+node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable (to do)
def defineCmdsMenuAbbrevTable (self):
    
    c = self.c
    
    self.cmdsMenuAbbrevTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable (to do)
#@+node:ekr.20060117095212:defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        ('Append To Buffer',             'append-to-buffer'),
        ('Kill Buffer',                  'kill-buffer'),
        ('List Buffers',                 'list-buffers'),
        ('List Buffers Alphbetically',   'list-buffers-alphabetically'),
        ('Prepend To Buffer',            'prepend-to-buffer'),
        ('Rename Buffer',                'rename-buffer'),
        ('Switch To Buffer',             'switch-to-buffer'),
    ]
#@nonl
#@-node:ekr.20060117095212:defineCmdsMenuBufferTable
#@+node:ekr.20060117095212.5:defineCmdsMenuCenterTable
def defineCmdsMenuCenterTable (self):

    c = self.c

    self.cmdsMenuCenterTable = [
        ('Center Line',     'center-line'),
        ('Center Region',   'center-region'),
    ]
#@nonl
#@-node:ekr.20060117095212.5:defineCmdsMenuCenterTable
#@+node:ekr.20060117095212.4:defineCmdsMenuChangeCaseTable
def defineCmdsMenuChangeCaseTable (self):

    c = self.c

    self.cmdsMenuChangeCaseTable = [
        ('Capitalize Word', 'capitalize-word'),
        ('Downcase Region', 'downcase-region'),
        ('Downcase Word',   'downcase-word'),
        ('Upcase Region',   'upcase-region'), # Crashes.
        ('Upcase Word',     'upcase-word'),
    ]
    
#@nonl
#@-node:ekr.20060117095212.4:defineCmdsMenuChangeCaseTable
#@+node:ekr.20060117095212.6:defineCmdsMenuIndentTable
def defineCmdsMenuIndentTable (self):

    c = self.c

    self.cmdsMenuIndentTable = [
        ('Indent Region',   'indent-region'),
        ('Indent Relative', 'indent-relative'),
        ('Indent Rigidly',  'indent-rigidly'),
        ('Unindent Region', 'unindent-region'),
    ]
#@nonl
#@-node:ekr.20060117095212.6:defineCmdsMenuIndentTable
#@+node:ekr.20060117114315:defineCmdsMenuMacroTable(to do)
def defineCmdsMenuMacroTable (self):

    c = self.c

    self.cmdsMenuMacroTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117114315:defineCmdsMenuMacroTable(to do)
#@+node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable(to do)
def defineCmdsMenuRectanglesTable (self):

    c = self.c

    self.cmdsMenuRectanglesTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable(to do)
#@+node:ekr.20060117095212.1:defineCmdsMenuRegistersTable(to do)
def defineCmdsMenuRegistersTable (self):

    c = self.c

    self.cmdsMenuRegistersTable = [
        ("-",None),
    ]
#@nonl
#@-node:ekr.20060117095212.1:defineCmdsMenuRegistersTable(to do)
#@+node:ekr.20060117095212.3:defineCmdsMenuSortTable
def defineCmdsMenuSortTable (self):

    c = self.c

    self.cmdsMenuSortTable = [
        ('Sort Columns',    'sort-columns'),
        ('Sort Fields',     'sort-fields'),
        ('Sort Lines',      'sort-lines'),
    ]
#@nonl
#@-node:ekr.20060117095212.3:defineCmdsMenuSortTable
#@+node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    c = self.c

    self.cmdsMenuSpellCheckTable = [
        ('Check Spelling',      'open-spell-tab'),
        ('Change',              'spell-change'),
        ('Change, Then Find',   'spell-change-then-find'),
        ('Find',                'spell-find'),
        ('Ignore',              'spell-ignore'),
    ]
#@nonl
#@-node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
#@-node:ekr.20050921103230:defineCmdsMenuTables & helpers
#@-node:ekr.20051121070552:Finish Cmds menu
#@-node:ekr.20060122185507:New commands
#@+node:ekr.20060206104841:New features
#@+node:ekr.20060116083043.1:Add context-menus on nodes or text
#@-node:ekr.20060116083043.1:Add context-menus on nodes or text
#@+node:ekr.20060122184114:Support the exectution of a command when entering a mode
- Entering outline mode should call c.endEditing.
- Entering edit mode shouldn't call c.endEditing!
#@-node:ekr.20060122184114:Support the exectution of a command when entering a mode
#@+node:ekr.20060202235215.1:Make sure the user doesn't specify Enter and Leave bindings by mistake
#@-node:ekr.20060202235215.1:Make sure the user doesn't specify Enter and Leave bindings by mistake
#@+node:ekr.20051112075511:Switch cursor when changing search direction
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3424153
By: rogererens

When reversing the search direction, it would be better to place the cursor
'on the other side' of the current hit, and then proceed to find the next occurrence
of <pattern>. At the current state of affairs, searching in the reverse direction
first finds the current occurrence _again_, just placing the cursor on the other
side of the higlighted selection.

This suggestion is based on the way searching in Vim works.
#@nonl
#@-node:ekr.20051112075511:Switch cursor when changing search direction
#@+node:ekr.20060125113540:Specify open-with bindings from settings
Maybe the entire table should be specified this way.
#@nonl
#@-node:ekr.20060125113540:Specify open-with bindings from settings
#@+node:ekr.20060203165231:Change outline or body text background when changing panes.
#@-node:ekr.20060203165231:Change outline or body text background when changing panes.
#@+node:ekr.20060202141338.4:Add support for widget bindings
#@-node:ekr.20060202141338.4:Add support for widget bindings
#@+node:ekr.20060116085217:Make scroll-pane-up/down work in tree
@nocolor

The following commands already work in the body pane.

scroll-down
scroll-down-extend-selection  
scroll-up
scroll-up-extend-selection

Note: arrow keys scroll the outline as needed, so there *is* a way to scroll the outline without the UniversalScrolling plugin.
#@nonl
#@-node:ekr.20060116085217:Make scroll-pane-up/down work in tree
#@+node:ekr.20060206131908.1:set-first-search-node command (indicate it in the find tab)
@nocolor

This will indicate the start of searches.
It would be shown in the Find tab.
#@nonl
#@-node:ekr.20060206131908.1:set-first-search-node command (indicate it in the find tab)
#@-node:ekr.20060206104841:New features
#@+node:ekr.20060116173818:*** Fix vampire nodes
#@-node:ekr.20060116173818:*** Fix vampire nodes
#@+node:ekr.20060209201859.1:Trap AttributeErrors in dummy base classes
Having to define dummy methods is getting odious.
#@nonl
#@-node:ekr.20060209201859.1:Trap AttributeErrors in dummy base classes
#@+node:ekr.20060122184800:Later
#@+node:ekr.20060117074259:Handle Mac issues
#@+node:ekr.20060117074259.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3526056
By: nobody

Hi Edward. I've been using the linux and windows version but would like to try
leo on the mac. The install instructions seem a bit out of date. I take it any
additional downloading of TclTkAqua is unneccessary?

I have python2.4 in addition to the stock python 2.3.5 that comes with osx 10.4.
Launching leo like so:  "python2.4 leo.py", as I do on linux, seems to run just
fine.

I don't know if this was fixed on osx or in leo in general, but moving the mouse
to each of the panes and scrolling with the wheel works just great now. Thanks.

Plugin manager: the plugin text font is really tiny, and the window opens to
a default width such that the 'Installed Plugins' button reads 'talled Plugi'.
Resizing the window does stretch the buttons horizontally.

Ok -- here's maybe a big issue. I open a new leo file (File->New) and type in:

for i in range(3):

I hit return after the colon, but a newline is not entered.

Stephen
#@-node:ekr.20060117074259.1:Report
#@-node:ekr.20060117074259:Handle Mac issues
#@+node:ekr.20060111152145:Improve scripts menu plugin
- Organize scripts menu from subfolders of leo/scripts folder.

- Create minibuffer commands for each script?
#@nonl
#@-node:ekr.20060111152145:Improve scripts menu plugin
#@+node:ekr.20060108120501:Add @find node to scripting plugin
This is the easy way to do script finds!
#@nonl
#@-node:ekr.20060108120501:Add @find node to scripting plugin
#@+node:ekr.20051202102337:Finish minibuffer commands
@nocolor
#@nonl
#@+node:ekr.20051202102337.1:abbrevCommandsClass (not ready yet)
auto-complete command is merely a prototype.
#@nonl
#@-node:ekr.20051202102337.1:abbrevCommandsClass (not ready yet)
#@+node:ekr.20051202102337.2:bufferCommandsClass Inot ready yet)
ok:

list-buffers

Not ready yet:

append-to-buffer
copy-to-buffer
insert-to-buffer
kill-buffer
prepend-to-buffer
rename-buffer       probably should change headline too
switch-to-buffer    use typing completion to get node name (headline)
#@nonl
#@-node:ekr.20051202102337.2:bufferCommandsClass Inot ready yet)
#@+node:ekr.20051202102337.3:controlCommandsClass (ok)
advertised-undo
keyboard-quit
iconify-frame
save-buffers-kill-leo
shell-command
shell-command-on-region
suspend
#@nonl
#@-node:ekr.20051202102337.3:controlCommandsClass (ok)
#@+node:ekr.20051202102337.4:editCommandsClass
back-sentence
back-to-indentation
backward-char
backward-delete-char
backward-kill-paragraph
backward-paragraph
backward-word
beginning-of-buffer
beginning-of-line
capitalize-word
center-line
center-region
count-region
cycle-focus
dabbrev-completion
dabbrev-expands
delete-char
delete-indentation
delete-spaces
downcase-region
downcase-word
end-of-buffer
end-of-line
escape
eval-expression
exchange-point-mark
fill-paragraph
fill-region
fill-region-as-paragraph
flush-lines
focus-to-body
focus-to-log
focus-to-minibuffer
focus-to-tree
forward-char
forward-paragraph
forward-sentence
forward-word
goto-char
goto-line
how-many
# Use indentBody in leoCommands.py
#indent-region
indent-relative
indent-rigidly
indent-to-comment-column
insert-newline
insert-parentheses
keep-lines
kill-paragraph
line-number
move-past-close
newline-and-indent
next-line
previous-line
remove-blank-lines
replace-regex
replace-string
reverse-region
scroll-down
scroll-up
select-paragraph
# Exists, but can not be executed via the minibuffer.
# self-insert-command
set-comment-column
set-fill-column
set-fill-prefix
set-mark-command
show-colors
show-fonts
# save-buffer
sort-columns
sort-fields
sort-lines
split-line
tabify
transpose-chars
transpose-lines
transpose-words
untabify
upcase-region
upcase-word
view-lossage
what-line
#@nonl
#@-node:ekr.20051202102337.4:editCommandsClass
#@+node:ekr.20051202102337.6:editFileCommandsClass
delete-file
diff
insert-file
make-directory
remove-directory
save-file
#@nonl
#@-node:ekr.20051202102337.6:editFileCommandsClass
#@+node:ekr.20051202102752.1:keyHandlerCommandsClass (not ready yet)
digit-argument
help
hide-mini-buffer
negative-argument
number-command
number-command-0
number-command-1
number-command-2
number-command-3
number-command-4
number-command-5
number-command-6
number-command-7
number-command-8
number-command-9
print-bindings
print-commands
repeat-complex-command
show-mini-buffer
toggle-mini-buffer
universal-argument
#@nonl
#@-node:ekr.20051202102752.1:keyHandlerCommandsClass (not ready yet)
#@+node:ekr.20051202102752.2:killBufferCommandsClass
backward-kill-sentence
backward-kill-word
kill-line
kill-word
kill-sentence
kill-region
kill-region-save
yank
yank-pop
zap-to-character
#@nonl
#@-node:ekr.20051202102752.2:killBufferCommandsClass
#@+node:ekr.20051202102752.3:macroCommandsClass
call-last-keyboard-macro
end-kbd-macro
name-last-kbd-macro
load-file
insert-keyboard-macro 
start-kbd-macro
#@nonl
#@-node:ekr.20051202102752.3:macroCommandsClass
#@+node:ekr.20051202102752.4:queryReplaceCommandsClass
query-replace
query-replace-regex
#@nonl
#@-node:ekr.20051202102752.4:queryReplaceCommandsClass
#@+node:ekr.20051202102752.5:rectangleCommandsClass (ok)
clear-rectangle
close-rectangle
delete-rectangle
kill-rectangle
open-rectangle
string-rectangle
yank-rectangle
#@nonl
#@-node:ekr.20051202102752.5:rectangleCommandsClass (ok)
#@+node:ekr.20051202102752.6:registerCommandsClass (ok, but could be expanded)
append-to-register
copy-rectangle-to-register
copy-to-register
increment-register
insert-register
jump-to-register
number-to-register not used: used copy-to-register insead.
point-to-register
prepend-to-register
view-register

To do:

point-to-register should write an 'expanded point' so inter-node jumps are possible.
#@nonl
#@-node:ekr.20051202102752.6:registerCommandsClass (ok, but could be expanded)
#@+node:ekr.20051202102752.7:searchCommandsClass (ok, but could be expanded)
hide-find-tab
open-find-tab
find-tab-find
find-tab-find-prev
find-tab-change
find-tab-change-then-find

isearch-forward
isearch-backward
isearch-forward-regexp
isearch-backward-regexp

re-search-forward
re-search-backward

search-forward
search-backward
word-search-forward
word-search-backward
#@nonl
#@-node:ekr.20051202102752.7:searchCommandsClass (ok, but could be expanded)
#@+node:ekr.20051202102752.8:spellCommandsClass (ok)
ok:

hide-spell-tab
open-spell-tab
spell-find
spell-change
spell-change-then-find
spell-ignore
#@nonl
#@-node:ekr.20051202102752.8:spellCommandsClass (ok)
#@-node:ekr.20051202102337:Finish minibuffer commands
#@+node:ekr.20050916180203:Make more commands undoable
#@-node:ekr.20050916180203:Make more commands undoable
#@+node:ekr.20060202235215.3:Remove deprecation warning
#@+node:EKR.20040627114602:getDescendentUnknownAttributes
# Only @thin vnodes have the descendentTnodeUnknownAttributes field.
# The question is: what are we to do about this?

def getDescendentUnknownAttributes (self,s):
    
    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except (TypeError,pickle.UnpicklingError,ImportError):
        g.trace('oops: getDescendentUnknownAttributes')
        return None
#@nonl
#@-node:EKR.20040627114602:getDescendentUnknownAttributes
#@-node:ekr.20060202235215.3:Remove deprecation warning
#@+node:ekr.20060207085518:Improve c.insertHeadline (minor)
c.insertHeadlineTime uses the edit widget.  It shouldn't.
#@nonl
#@-node:ekr.20060207085518:Improve c.insertHeadline (minor)
#@-node:ekr.20060122184800:Later
#@-node:ekr.20060116073938:To do 4.4b3
#@+node:ekr.20060209104733:Urgent and big (overdue)
#@+node:ekr.20051202094427:Resolve cvs conflicts
Investigate meld:  http://meld.sourceforge.net/

Create a 'generate cvs conflicst' script for testing.
#@nonl
#@+node:ekr.20031218072017.658:Resolve CVS Conflicts command (Stepen Schaefer)
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@+node:ekr.20050501111900:Stephen Schaefer
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."
#@nonl
#@-node:ekr.20050501111900:Stephen Schaefer
#@+node:ekr.20031218072017.659:Jonathon 1
https://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  

 
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?

More things to think about.

Gil
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20031218072017.658:Resolve CVS Conflicts command (Stepen Schaefer)
#@-node:ekr.20051202094427:Resolve cvs conflicts
#@+node:ekr.20041228084018.5:Finish zodb plugin
@ New notes:

- openFromZODB would be similar to openWithFileName, but gets root, current positions from zodb.

- Either we save positions in the zodb, or we figure out how to create root, current positions from vnodes.
    - Root positions is easy, but current position could be anywhere.

- Save commands would commit to zodb.  Revert would abort.
#@nonl
#@+node:ekr.20040226114127: Zope test
@color

import leoGlobals as g
import ZODB

d = dir(ZODB) ; d.sort()

g.trace(g.toString(d))

if 0:
    storage = ZODB.FileStorage.FileStorage(r"c:\prog\zopeTemp\leo.fs")
    g.trace(storage)
    if 0:
        db = ZODB.DB(storage)
        g.es(storage)
        g.es(db)
        db.close()
#@nonl
#@-node:ekr.20040226114127: Zope test
#@+node:ekr.20041002151816:ZODB docs
#@+node:ekr.20041002151816.1:What is the ZODB?
http://zope.org/Wikis/ZODB/FrontPage/guide/node2.html#SECTION000210000000000000000

1.1 What is the ZODB?

The ZODB is a persistence system for Python objects. Persistent programming
languages provide facilities that automatically write objects to disk and read
them in again when they're required by a running program. By installing the
ZODB, you add such facilities to Python.

#@-node:ekr.20041002151816.1:What is the ZODB?
#@+node:ekr.20041002151816.2:How ZODB Works
2.2 How ZODB Works

The ZODB is conceptually simple. Python classes subclass a persistent.Persistent
class to become ZODB-aware. Instances of persistent objects are brought in from
a permanent storage medium, such as a disk file, when the program needs them,
and remain cached in RAM. The ZODB traps modifications to objects, so that when
a statement such as obj.size = 1 is executed, the modified object is marked as
``dirty.'' On request, any dirty objects are written out to permanent storage;
this is called committing a transaction. Transactions can also be aborted or
rolled back, which results in any changes being discarded, dirty objects
reverting to their initial state before the transaction began.

#@-node:ekr.20041002151816.2:How ZODB Works
#@+node:ekr.20041002151816.3:Rules for Writing Persistent Classes
2.6 Rules for Writing Persistent Classes

Practically all persistent languages impose some restrictions on programming
style, warning against constructs they can't handle or adding subtle semantic
changes, and the ZODB is no exception. Happily, the ZODB's restrictions are
fairly simple to understand, and in practice it isn't too painful to work around
them.

The summary of rules is as follows:

* If you modify a mutable object that's the value of an object's attribute, the
ZODB can't catch that, and won't mark the object as dirty. The solution is to
either set the dirty bit yourself when you modify mutable objects, or use a
wrapper for Python's lists and dictionaries (PersistentList, PersistentMapping)
that will set the dirty bit properly.

* Recent versions of the ZODB allow writing a class with __setattr__ ,
__getattr__, or __delattr__ methods. (Older versions didn't support this at
all.) If you write such a __setattr__ or __delattr__ method, its code has to set
the dirty bit manually.

* A persistent class should not have an __del__ method. The database moves
objects freely between memory and storage. If an object has not been used in a
while, it may be released and its contents loaded from storage the next time it
is used. Since the Python interpreter is unaware of persistence, it would call
the __del__ each time the object was freed.
#@nonl
#@-node:ekr.20041002151816.3:Rules for Writing Persistent Classes
#@-node:ekr.20041002151816:ZODB docs
#@+node:ekr.20031218072017.406:Zop url's
#@+node:ekr.20031218072017.407:@url http://24.243.129.68:8080/members/sandbox
#@-node:ekr.20031218072017.407:@url http://24.243.129.68:8080/members/sandbox
#@+node:ekr.20031218072017.408:@url http://www.zopelabs.com/cookbook
#@-node:ekr.20031218072017.408:@url http://www.zopelabs.com/cookbook
#@+node:ekr.20031218072017.409:@url http://zwiki.org/FrontPage  Zope implementation of wiki
#@-node:ekr.20031218072017.409:@url http://zwiki.org/FrontPage  Zope implementation of wiki
#@-node:ekr.20031218072017.406:Zop url's
#@+node:ekr.20040107064101.5:Zope notes
#@+node:ekr.20031218072017.405:Kent Tenny Notes
@nocolor

Outlook: server for email, addresses & calendar.  Groupware.  Chandler similar.

Zope: back end is ZODB.  Zope like an OS: run Python code on Zope.

Zope: another way to access Leo files.  Maybe twisted is better?

Wiki anology: edit Leo files with browser.  Write through the web.

longrun.org

Wiki principles: 
	- Sharing is 90% of collaboration.
	- Zope: Subscribe to a wiki: email when page changes.
	- RSS: xml that defines piece of info(tile,url,abstract)
		- Client has a list of rss feeds: an xml file.
		- List of intesting people: notified when they say something.

Two goals:
	- publish Leo files
	- edit Leo files

Brother needs cvs.
Kent not so worried about cvs.
	-Leo file is a web site!
	- Helper layer between user and OS.
		- Look at aap project.  Author of vim. a-p.org
			- Replacement for make in Python.  Automating tool.
		- Expert prepares Leo file.  User uses it.
#@nonl
#@-node:ekr.20031218072017.405:Kent Tenny Notes
#@+node:ekr.20040107065006:posting
@nocolor

Yes he's absolutely right -- focus on the ZODB.

..stay alway from ZTP. ZPT, TPZ, CMF, Plone and all that other stuff for now.

I jsut came accross a handy slide show overview from last spring:
http://jace.seacrow.com/tech/zope/blug-zodb

BerkeyDB Storage is cool too and fits Leo well I think. plays nicely wiht ZODB
standalnioe and in Zope.
#@-node:ekr.20040107065006:posting
#@+node:ekr.20040107064854:example Code
from ZODG import FileStorage,DB
from Persistence import Persistent

# Connect to db.
# FileStorage is standard: entire db is stored in a single file.
storage = FileStorage.FileStorage("/tmp/test-filestorage.fs")
db = DB.(storage)
conn = db.open()

# Get the root of the db.
root = conn.root()

# Defining user classes.
class leoData(Persistent):
	pass
	
# Commit or revert.
get_transaction().commit()
get_transaction().abort()
#@nonl
#@-node:ekr.20040107064854:example Code
#@+node:ekr.20040107080609.1:Zshell
@nocolor

By: jasonic ( Jason Cunliffe )
ZShell  
2003-12-31 22:25

Hi, Just another friendly reminder to check out Jerome Alet's ZShell, one of Zope's best kept secrets:

http://www.librelogiciel.com/software/

ZShell : Manipulate the Zope Object DataBase with Unix shell like commands

and also

ZShellScripts : Unifies the Zope notion of Scripts and provides several Script interpreters : Python, Unix shell , Lisp, Perl, PHP, Ruby, and Zope ZShell

Not only for obvious usefullness, but also as a valuable study of Python access to the ZODB.

JAXML is cool too..
http://www.librelogiciel.com/software/jaxml/action_Presentation

- Jason
#@nonl
#@-node:ekr.20040107080609.1:Zshell
#@+node:ekr.20040107064854.1:@url http://zope.org/Products/StandaloneZODB
#@-node:ekr.20040107064854.1:@url http://zope.org/Products/StandaloneZODB
#@+node:ekr.20040107064854.2:@url http://jace.seacrow.com/tech/zope/blug-zodb
#@-node:ekr.20040107064854.2:@url http://jace.seacrow.com/tech/zope/blug-zodb
#@-node:ekr.20040107064101.5:Zope notes
#@+node:ekr.20031218072017.412:Zope postings
#@+node:ekr.20031218072017.413:From Rodrigo re: Zope.
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007586
By: rodrigo_b

z2.py,
>Supposing that that I did find this file, what would I be looking for? 

This is the Main script, the principal program, the code that startup all the
servers, the only python program that make run Zope, it the code called by start.py,
and it is the one to which you pass the command lines.

With the command line you can indicate which services to start up at which ports.
This is IMPORTANT. Also you can enable/disable the Debug mode.

python z2.py --help will give you some infos about what I'm talking about.

In linux the debug or not debug mode, enable the console or daemon mode (that
means 'background task mode').

In windows, I'm not sure that disabling the debug mode will be enough.
I know that at the install time you can setup Zope as a Windows Service, so
it will start automatically every time Windows Startup, and it will not open
a console window.

But first look at the debug mode.

Start.bat give some defaults command lines to z2.py

Webdav,
>What issues are involved in this choice, and why should I care today? 

from www.webdav.org

What is WebDAV? 
Briefly: WebDAV stands for "Web-based Distributed Authoring and Versioning".
It is a set of extensions to the HTTP protocol which allows users to collaboratively
edit and manage files on remote web servers.

For example that means that you can open you Windows Explorer (from your mail
I understand that you work on an MsWindows OS),
tip the url "localhost:%i"%(your webdav port) and you will be able to navigate,
view and edit the Zope Objects just as a normal file system (well, almost).

WebDav is a standard and there are Python implementations. WebDav is support
by  Oscom.

WebDav is cool.
WebDav is the 'highest level tool'.

ZODB,

>Does that mean that gnx's aren't needed with Zope? Could Leo nodes live in
the ZODB?

You have to thinks to ZODB just as what it is: a Persistent Object Database.
Most objects in Zope are Persistents, that mean that their instances do not
die when you shutdown the server.

The ZODB store his data in it own format.
I think that GNX should be keeped.
You have to basic ways to put nodes into Zope.

First: the hard way: create a new Product (Products are something like Zope
plugins) that is based on the Leo code, but were there is no node storage, instead
the node should be Persistents. Then add rendering code to this objects.

Leo node object + Persistence + ZClass + Rendering Code -> Leo Zope node.

Additionaly you should create an Folder like object that should be an 'Leo Outline
Zope Object',  actuating as an Leo nodes container.

This shema is similar to the Zwiki way, with a Zwiki Web and the Zwiki Pages.

Second: Use A zope folder just as Leo manage the @file nodes. Let have simple
DTMLDocuments, edited via WebDav, with <dtml-comments> , and stuff like that.
The Leo import/export that nodes.

RodrigoB.

#@-node:ekr.20031218072017.413:From Rodrigo re: Zope.
#@+node:ekr.20031218072017.414:Clarification from Kent Tenny
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2009081
By: ktenney

Edward,

I don't see ZLeo replacing Leo, rather a method of accessing
Leo files.

When I write, I almost always want it to be web accessable,
so that I can access it from any browser, and so that I can
share it easily. I would like myfile.leo to live
at http://longrun.org/leo/myfile.leo. It can be read and
written to from any browser (according to how permissions are
configured) The page describing how to configure Apache would
be found at http://longrun.org/leo/myfile.leo/Apache/configure
The only requirement to work with Leo files is a browser.

I wouldn't want to lose the capability to edit outside
the browser, using a standalone version of Leo or Zope's
ExternalEditor product. ExternalEditor allows me to click
an icon to open the page I'm viewing in any editor. I could
open it in Leo as a Leo file, or open just the page in
Vim (http://vim.sourceforge.net/index.php)

Zope is ponderous, I think of it as more of a platform
than an application. My understanding of how Zope works
grows slowly, in the mean time my focus is on _products_.
Installing a product in Zope is like installing an application
in Windows or Linux.

One of the most evolved products is Plone/CMF http://plone.org
which is basically a turnkey web site.

twisted http://twistedmatrix.com is a brilliant set of network
programming tools. That's all I know about it.

I'm not sure about Chandler (http://www.osafoundation.org/) 
(they did choose Python and ZODB http://www.osafoundation.org/technology.htm)

You might try subscribing to a Zope mailing list or two
http://www.zope.org/Resources/MailingLists
The community of users and developers is very important to Zope.

Thanks,
Kent
#@-node:ekr.20031218072017.414:Clarification from Kent Tenny
#@+node:ekr.20031218072017.415:From Rodrigo re: ip
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007817
By: rodrigo_b

If zope is running some server then this server will be accesible from your
network if and only if there is no firewall in the way.

The people can access to your services using (normally on internet you do not
have a domain name)

your_ip:the_service_port

Example:
zope http service on port 8080 on your machine.
When  you connect to internet your machine got an extra IP.
Then simple put on the web browser

http://your_conexion_ip:8080

and Tada you will see the root_zope/index_html object rendered intro HTML.

Most of the ISP give you a dinamic IP.
Some companies provides you dinamic IP Domain Name services, allowing to attach
a domain name to your machine dinamically (each time you reconect).

then you can have:

http://leo.edward.com:8080/

The 8080 stuff can be avoied if you setup zope to use the standard port 80 for
HTTP service.

With this in mind you can access ftp

ftp://your_ip_or_domain_name:8021

or webdav, or anything else.
#@-node:ekr.20031218072017.415:From Rodrigo re: ip
#@+node:ekr.20031218072017.416:Other servers
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2007832
By: rodrigo_b

I would made a warning.

Zope IT IS NOT the only way to obtain an local HTTP server, pythonic and
flexible.

There is a lot of other way.

Also Zope IT IS NOT THE BEST pythonic http/ftp/webdav or anything server
aviable.

I think that we should define better 

What we want to do?

before choosing the tool.

As I said, I had already used Zope, I choosed it because of very specific features,
but nothing indicate that Zope is the best way to get Leo to the colaborative
network universe.

I think that we should at least consider:
- SimpleHTTPServer
- To take of the Medusa Server from Zope (that is use Zope code in the standard
Leo distribution, avoying dependences)
- Twisted matrix (I had no experience with it, but it looks much more
flexible/powerfull)

Zope provides you a specific framework, you have to match you application to
this framework, Zope (in my opinion) it is not a tool, it's an ambient.

It's seems that Edward it is new in the web oriented software, I think it has
a lot of potencialities and it will benefits Leo devellopment.

Please Edward, look at Zope as an example but not as THE options. Think about
what can be done, what should be done, and then we will take the best tool.

Anyway my opinion:
- SimpleHTTP server: usefull, it is in python, not very eficiente, just http
server	
- Medusa: usefull, very eficiente, just http server...
- Twisted Matrix: very powerfull, fresh comunity, confusing documentation, a
new paradigm, a devellopment tool.
- Zope: powerfull, eficient, comes with battery included, bad documentation,
to very paradigm oriented, the apps have to fit the paradigm, don't believe
all the promises, strong enthousiast comunity, poor web examples.


RodrigoB. 
#@-node:ekr.20031218072017.416:Other servers
#@+node:ekr.20031218072017.417:Is my ip public?
https://sourceforge.net/forum/message.php?msg_id=2007962
By: bwmulder

Since no one else answered this question, let me take a first take on the
question:

If you are connected to the internet, people can use your IP number to connect
to your computer. This IP number is often given dynamically, though some DSL
providers give you fixed IP numbers for an additional fee. If you did not ask
for fixed IP numbers, you probably have an dynamic IP number (I think).

An IP number consist of four digits. A connection to the (example) IP number
111.222.333.444 can by made via the request http://111.222.333.444

If you have a dynamic IP number, and your Internet provider provides you with
some space to publish HTML, you could, via a script, upload your current IP
number dynamically.

You might also consider buying a domain name. In this case, people can use the
domain name to connect to your computer instead of the IP number.

Another consideration are firewalls. Normally, you want a firewall isolating
your computer from attacks from the Internet. I firewall can be some additional
software. I am currently using a router, a piece of hardware, as a firewall.
Windows XP has firewall software build in. You might have to configure your
firewall to let requests for your server go through.

Finally, you might want to check the agreement you entered with your Internet
service provider, if you are allowed to run a server from your connection. It
might become a problem if your server becomes very popular.
#@-node:ekr.20031218072017.417:Is my ip public?
#@+node:ekr.20031218072017.418:Back ends for storing/retrieving nodes: Paul Paterson
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2009279
By: paulpaterson

What I see Zope offering is an alternative way of storing and retrieving nodes.
What you also get for "free" with Zope is concurrent access, security,
http/ftp/webdav access to the same node information etc. The hidden price you
pay is that Zope is big and many users will have other tools which can provide
these facilities also.

So, my thinking is that we can abstract the basic idea (alternative ways of
storing and retrieving node information) into Leo and then let the magic really
happen in the concrete implementation stage.

What does this mean? Well, we could change Leo so that whenever it goes to retrieve
Headline or Body it goes to a Node Server object to do that. The Node Server
object uses whatever method it wants to retrieve or set the information. The
Node server would also be responsible for telling Leo what child nodes an object
has and whether they are clones or not.

The cool part is that we could implement different kinds of Node server to talk
to different back-ends. These can then be thought of as drivers. So we might
have,

- a file system driver where all information is stored in files and directories
- a database driver where the DB stores all information
- an ftp driver
- a Zope driver
- the default Leo driver

People could write a driver to their own back end storage system. 

What is the advantage of this?

Well, the magic really happens in the back-end. If you choose a back end which
supports versioning, security, concurrent working, web access, etc etc then
Leo now supports them. If you choose a back-end which supports dynamic mark-up
or some other fancy stuff then Leo supports it. The key is that Leo doesn't
need to bind itself to any one system to achieve this - the end user can install
the relevant driver, configure the back-end and just go with it.

Paul
#@-node:ekr.20031218072017.418:Back ends for storing/retrieving nodes: Paul Paterson
#@+node:ekr.20031218072017.419:From Paul Paterson
Ok, I'll have a bash in a rough order or when things occurred...


1. Everything is web based. I had the same problem you did. I ran the
thing and said, "ok, so what did it do". Others have pointed you in the
right direction now with visiting http://localhost:8080 and
http://localhost:8080/manage to view the site and mange it respectively.

If you are running WinNT, 2000 or XP you can also run Zope as a service,
which is much more convenient as you don't need the console window open
all the time.


2. Everything in Zope is an object. Ok, you'll see this a lot. The best
thing to do is think "wow, cool" and then forget it again as you
probably wont really see how this helps at all until you get much deeper
into Zope. 


3. DTML allows you to construct web pages by piecing together bits much
like writing a program from functions. In fact you will find DTML is a
lot like tangling Leo's @root nodes. Here's a bit...

<!-- start html -->

<h>DTML allows you to assemble web pages much like Leo tangles
documents</h>

<p>For instance, have a look at how this page is constructed</p>

<dtml-var first_bit>
<dtml-var second_bit>
<dtml-var third_bit>

<!-- end html -->

The <dtml-var name> bit is like a < < name > > directive. It effectively
inserts the object (could be HTML, an image or something more complex)
in the current page. 

To see this snippet in action you can visit my server at
http://24.243.129.68:8080/members/sandbox/index_html

To see the code, visit http://24.243.129.68:8080/members/sandbox/manage
(username=edream, pwd=leo) and then click on the index_html to see the
main DTML. Feel free to mess around in here but please don't publish the
IP address as my ISP doesn't allow servers!


4. There is a lot of power in Zope products. Try going to www.zope.org
and seeing what is available. As an example I put a Wiki in the sandbox
area http://24.243.129.68:8080/members/sandbox/edswiki


5. If you are looking for a good book to begin with then steer clear of
"The Zope Book"! If you don't mind paying then "The book of Zope" is a
much better introduction. When you have read this then "The Zope Book"
will make some sense but really I found this book tremendously hard to
get through.


6. Web standards are very cool! Zope supports FTP. Point your favourite
FTP tool to,

ftp://24.243.129.68:8021/members/sandbox/

Or try using WebDav by creating a network place pointing to

http://24.243.129.68:8080/members/sandbox

You can then use windows explorer or an ftp tool to browse your objects.


7. Everything is an object! I can't do justice to the concept of
Acquisition here but by the time you have messed around with Zope a bit
you should start to see how acquisition starts to make things really
work like classes in Python. 


I realize this isn't very coherent - if I get a spare moment this
weekend I'll knock up a quick demo showing Leo interacting with Zope.

Regards,

Paul
#@-node:ekr.20031218072017.419:From Paul Paterson
#@+node:ekr.20040117092727.2:using zodb versions
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2379351
By: korakot

If leo use database storage (ZODB or otherwise)
it could scale much better. This will bring us some
possiblity to store all versions of changes to a node
or a tree.

Cloning will then point to a specific version. If there
is no conflict, it can update to a later version when
the primary clone change. If there is a conflict
we can deal with it wisely using 'diff information'
because we have 'all versions' stored.

#@-node:ekr.20040117092727.2:using zodb versions
#@+node:ekr.20031218072017.737:Leo & data bases
From: "Scott Chapman" <scott_list@mischko.com>
To: <edreamleo@charter.net>
Sent: Monday, November 10, 2003 11:05 AM
Subject: Enhancement request: Make Leo deal with a database

It would be Way Cool if Leo could deal with psycopg or other DataBase 
API compliant implementations and fetch and store database records.

Details of what I'd like to see:

I'm working on Python source code. I want Leo to pull a source code file 
from a database record built something like this:

filename: text
updated: datetimestamp
code: text

Leo would insert a new record, not update an existing one, each time a 
Save was done, with a more current time stamp.  

When a File Open was requested (i.e. a node on a existing Leo outline 
was being pulled from a database), Leo would fetch the most recent 
time-stamped version only.

I use this same technique for my wiki pages.  It's very easy to 
implement in SQL and works great.

Leo would also need the ability to save the same file to a regular 
python source code file on disk at a specific location, so you'd have 
to be able to put more than one save/load directive in a given node.

This would provide a nice version history and could lead to other Useful 
Things in Leo.

Scott
#@nonl
#@-node:ekr.20031218072017.737:Leo & data bases
#@-node:ekr.20031218072017.412:Zope postings
#@-node:ekr.20041228084018.5:Finish zodb plugin
#@+node:ekr.20031218072017.1032:Drive syntax colorer from jEdit files
@ To do:

- ** Use a general purpose XML parser to parse the jEdit mode files.
- ** Do incremental syntax coloring
	- Create lines table.
	- Initialize lines table when select new node.
- Use strings for states.
- Define colorizeLine method.
- Create self.state ivar
- Use a keyword lead-in table.
	- Use this for latex keywords and Leo keywords.
	- Add ignore-case ivar.
- Define @language xml.
- Defined syntax coloring for all jEdit token types:
	KEYWORD1,KEYWORD2,KEYWORD3,LABEL,LITERAL1,LITERAL2,MARKUP,OPERATOR
	Where do Leo keywords fit in?

#@-node:ekr.20031218072017.1032:Drive syntax colorer from jEdit files
#@+node:ekr.20060130151453:Find leaks (may be fixed)
- Test referers when deleting objects.
#@nonl
#@+node:ekr.20060202153509:Gc todo
@nocolor

* Use Tk or Pmw calls to discover existing widgets.
#@nonl
#@-node:ekr.20060202153509:Gc todo
#@+node:ekr.20060201114832:Notes
@nocolor

Turned off plugins.
Turned off idle-time hook.
Turned off colorizer.

** Leak 1:  c.beadList and c.visitedList

** Leak 2:  There is one object leaked for every headline visited.
    This may be p.edit_widget()
    
** The entire headline widget logic is bizarre.
    - Create p.id() -> concatenation of vnodes.
    - Create tree.widgetForPositionDict.
        - keys are p.id's, values are widgets.
    - Change p.edit_widget() to tree.edit_widget(p)

** It looks like the find command is a major leak.
#@nonl
#@-node:ekr.20060201114832:Notes
#@+node:ekr.20060202082221:Reference code
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    << start psycho >>
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@nonl
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    windowFlag = False
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script, windowFlag
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20031218072017.1588:Garbage Collection
# debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
#@+node:ekr.20060127162818:enable_gc_debug
def enable_gc_debug(event=None):
    
    if g.app.trace_gc_inited:
        return
    
    if gc:
        if g.app.trace_gc_verbose:
            gc.set_debug(
                gc.DEBUG_STATS | # prints statistics.
                gc.DEBUG_LEAK | # Same as all below.
                gc.DEBUG_COLLECTABLE |
                gc.DEBUG_UNCOLLECTABLE |
                gc.DEBUG_INSTANCES |
                gc.DEBUG_OBJECTS |
                gc.DEBUG_SAVEALL
            )
            g.es('enabled verbose gc stats',color='blue')
        else:
            gc.set_debug(gc.DEBUG_STATS)
            g.es('enabled brief gc stats',color='blue')
    else:
        g.es('Can not import gc module',color='blue')
#@nonl
#@-node:ekr.20060127162818:enable_gc_debug
#@+node:ekr.20031218072017.1589:clearAllIvars
def clearAllIvars (o):
    
    """Clear all ivars of o, a member of some class."""
    
    o.__dict__.clear()
#@-node:ekr.20031218072017.1589:clearAllIvars
#@+node:ekr.20060205043324:Called from commands
#@+node:ekr.20031218072017.1590:collectGarbage
def collectGarbage():

    try:
        if not g.app.trace_gc_inited and g.app.trace_gc_verbose:
            g.enable_gc_debug()

        if g.app.trace_gc_verbose or g.app.trace_gc_calls:
            g.es_print('Collecting garbage')

        gc.collect()
    except:
        pass
        
    # Only init once, regardless of what happens.
    g.app.trace_gc_inited = True
#@nonl
#@-node:ekr.20031218072017.1590:collectGarbage
#@+node:ekr.20060205043324.1:printGcSummary
def printGcSummary (message='',trace=False):
    
    if not message:
        message = g.callerName(n=2)

    g.enable_gc_debug()

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = 'garbage: %d, objects: %d, %s' % (n,n2,message)
        if trace:
            print s
        else:
            g.es_print(s)
    except:
        traceback.print_exc()
#@nonl
#@-node:ekr.20060205043324.1:printGcSummary
#@+node:ekr.20060202161935:printGcAll
def printGcAll (message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    d = {} ; objects = gc.get_objects()
    g.es_print('-' * 30)
    g.es_print('%d objects' % len(objects),message)

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        d[t] = d.get(t,0) + 1
        
    if 1: # Sort by n
        
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            g.es_print('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            g.es_print('%40s %7d' % (t,d.get(t)))
#@-node:ekr.20060202161935:printGcAll
#@+node:ekr.20060127164729.1:printGcObjects
def printGcObjects(message=''):
    
    if not message:
        message = g.callerName(n=2)

    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        lastObjectCount = n2

        g.es_print('-' * 30)
        g.es_print("garbage: %d, objects: %d, delta: %d %s" % (n,n2,delta,message))
        
        << print number of each type of object >>
        if 0:
            << print added functions >>

    except:
        traceback.print_exc()
#@nonl
#@+node:ekr.20040703065638:<< print added functions >>
import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if not lastFunctionsDict.has_key(key):
            g.es_print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            g.es_print("args", args)
            if varargs: g.es_print("varargs",varargs)
            if varkw: g.es_print("varkw",varkw)
            if defaults:
                g.es_print("defaults...")
                for s in defaults: g.es_print(s)

lastFunctionsDict = funcDict
funcDict = {}
#@nonl
#@-node:ekr.20040703065638:<< print added functions >>
#@+node:ekr.20040703054646:<< print number of each type of object >>
global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    t = type(obj)
    if t == 'instance':
        try: t = obj.__class__
        except: pass
    typesDict[t] = n + 1
    
# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

keys.sort()
for key in keys:
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        g.es_print("%+6d =%7d %s" % (delta2,n2,key))
    
lastTypesDict = typesDict
typesDict = {}
#@nonl
#@-node:ekr.20040703054646:<< print number of each type of object >>
#@-node:ekr.20060127164729.1:printGcObjects
#@+node:ekr.20060127165509:printGcVerbose
# WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(message=''):
    
    if not message:
        message = g.callerName(n=2)

    global lastObjectsDict
    objects = gc.get_objects()
    
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]
    
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o
        
    dicts = 0 ; seqs = 0
    
    i = 0 ; n = len(newObjects)
    while i < 100 and i < n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            seqs += 1
        else:
            g.es_print(o)
        i += 1
    g.es_print('-' * 40)
    g.es_print('dicts: %d, sequences: %d' % (dicts,seqs))
    g.es_print("%25s: %d new, %d total objects" % (message,len(newObjects),len(objects)))
#@nonl
#@-node:ekr.20060127165509:printGcVerbose
#@-node:ekr.20060205043324:Called from commands
#@+node:ekr.20060205043324.2:Called from unit tests
#@+node:ekr.20031218072017.1592:printGc
def printGc(message=None):
    
    if not g.app.trace_gc: return None
    
    if not message:
        message = g.callerName(n=2)
        
    printGcObjects(message)
    printGcRefs(message)
    
    if g.app.trace_gc_verbose:
        printGcVerbose(message)
        
    
#@+node:ekr.20031218072017.1593:printGcRefs
def printGcRefs (message=''):

    refs = gc.get_referrers(app.windowList[0])
    g.es_print('-' * 30,message)

    if g.app.trace_gc_verbose:
        g.es_print("refs of", app.windowList[0])
        for ref in refs:
            g.es_print(type(ref))
    else:
        g.es_print("%d referers" % len(refs))
#@nonl
#@-node:ekr.20031218072017.1593:printGcRefs
#@-node:ekr.20031218072017.1592:printGc
#@-node:ekr.20060205043324.2:Called from unit tests
#@-node:ekr.20031218072017.1588:Garbage Collection
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@nonl
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False
#@nonl
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args & keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@nonl
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@+node:ekr.20040803072955.126:tree.endEditLabel
def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    if k:
        k.setDefaultUnboundKeyAction()
        k.showStateAndMode()
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)
#@nonl
#@-node:ekr.20040803072955.126:tree.endEditLabel
#@+node:ekr.20040803072955.127:editLabel
def editLabel (self,p):
    
    """Start editing p's headline."""
    
    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p
    
    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget'))

    if p and p.edit_widget():
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
#@nonl
#@-node:ekr.20040803072955.127:editLabel
#@+node:ekr.20040803072955.128:tree.select
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
# c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20060207101443:tree.setHeadline (new in 4.4b2)
def setHeadline (self,p,s):
    
    '''Set the actual text of the headline widget.
    
    This is called from the undo/redo logic to change the text before redrawing.'''
    
    w = self.edit_widget(p)
    if w:
        w.configure(state='normal')
        w.delete('1.0','end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert('1.0',s)
        self.revertHeadline = s
        # g.trace(repr(s),w.get('1.0','end'))
    else:
        g.trace('-'*20,'oops')
#@nonl
#@-node:ekr.20060207101443:tree.setHeadline (new in 4.4b2)
#@+node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.135:setEditLabelState
def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
#@nonl
#@-node:ekr.20040803072955.135:setEditLabelState
#@+node:ekr.20040803072955.136:setSelectedLabelState
def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.136:setSelectedLabelState
#@+node:ekr.20040803072955.138:setUnselectedLabelState
def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.138:setUnselectedLabelState
#@+node:ekr.20040803072955.139:setDisabledHeadlineColors
def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.139:setDisabledHeadlineColors
#@+node:ekr.20040803072955.140:setEditHeadlineColors
def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color") or 'white'
    selbg = c.config.getColor("headline_text_editing_selection_background_color") or 'black'
    
    try: # Use system defaults for selection foreground/background
        w.configure(state="normal",highlightthickness=1,
        fg=fg,bg=bg,selectforeground=selfg,selectbackground=selbg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.140:setEditHeadlineColors
#@+node:ekr.20040803072955.141:setUnselectedHeadlineColors
def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.141:setUnselectedHeadlineColors
#@-node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setSelectedLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)
#@nonl
#@-node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
#@+node:ekr.20040803072955.143:tree.expandAllAncestors
def expandAllAncestors (self,p):
    
    '''Expand all ancestors without redrawing.
    
    Return a flag telling whether a redraw is needed.'''
    
    c = self.c ; redraw_flag = False

    c.beginUpdate()
    try:
        for p in p.parents_iter():
            if not p.isExpanded():
                p.expand()
                redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag
#@nonl
#@-node:ekr.20040803072955.143:tree.expandAllAncestors
#@-node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@+node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
#@+node:ekr.20031218072017.893:p.__cmp__
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self
    
    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal

    # Check entire stack quickly.
    # The stack contains vnodes, so this is not a recursive call.
    if p1.v != p2.v or p1.stack != p2.stack:
        return 1 # notEqual

    # This is slow: do this last!
    if p1.childIndex() != p2.childIndex():
        # Disambiguate clones having the same parents.
        return 1 # notEqual

    return 0 # equal
#@nonl
#@-node:ekr.20031218072017.893:p.__cmp__
#@-node:ekr.20060202082221:Reference code
#@+node:ekr.20060202082221.1:Leaky code
#@+node:ekr.20040803072955.128:tree.select
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
# c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@-node:ekr.20060202082221.1:Leaky code
#@+node:ekr.20060202163829:Stats
51439 objects
                          <type 'tuple'>   27855
                           <type 'dict'>    6107
                           <type 'list'>    2063
              <class 'leoGlobals.Bunch'>    1668
47985 objects
                          <type 'tuple'>   27371
                           <type 'dict'>    4870
              <class 'leoGlobals.Bunch'>    1646
                           <type 'list'>    1476
49414 objects
                          <type 'tuple'>   27725
                           <type 'dict'>    5405
                           <type 'list'>    1657
              <class 'leoGlobals.Bunch'>    1646
48654 objects
                          <type 'tuple'>   27535
                           <type 'dict'>    5215
              <class 'leoGlobals.Bunch'>    1646
                           <type 'list'>    1467
48912 objects
                          <type 'tuple'>   27616
                           <type 'dict'>    5279
              <class 'leoGlobals.Bunch'>    1646
                           <type 'list'>    1523
#@nonl
#@-node:ekr.20060202163829:Stats
#@+node:ekr.20060127162818.1:class debugCommandsClass
class debugCommandsClass (baseEditCommandsClass):
    
    @others
#@nonl
#@+node:ekr.20060127162921: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
#@nonl
#@-node:ekr.20060127162921: ctor
#@+node:ekr.20060205050659:collectGarbage
def collectGarbage (self,event=None):
    
    g.collectGarbage()
#@nonl
#@-node:ekr.20060205050659:collectGarbage
#@+node:ekr.20060127163325: getPublicCommands
def getPublicCommands (self):
    
    k = self

    return {
        'collect-garbage':      self.collectGarbage,
        'disable-gc-trace':     self.disableGcTrace,
        'dump-all-objects':     self.dumpAllObjects,
        'dump-new-objects':     self.dumpNewObjects,
        'enable-gc-trace':      self.enableGcTrace,
        'free-tree-widgets':    self.freeTreeWidgets,
        'print-focus':          self.printFocus,
        'print-stats':          self.printStats,
        'print-gc-summary':     self.printGcSummary,
        'verbose-dump-objects': self.verboseDumpObjects,
    }
#@nonl
#@-node:ekr.20060127163325: getPublicCommands
#@+node:ekr.20060202160523:dumpAll/New/VerboseObjects
def dumpAllObjects (self,event=None):
    
    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcAll()
    g.app.trace_gc = old
    
def dumpNewObjects (self,event=None):

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcObjects()
    g.app.trace_gc = old
    
def verboseDumpObjects (self,event=None):
    
    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcVerbose()
    g.app.trace_gc = old
#@-node:ekr.20060202160523:dumpAll/New/VerboseObjects
#@+node:ekr.20060127163325.1:enable/disableGcTrace
def disableGcTrace (self,event=None):
    
    g.app.trace_gc = False
    
def enableGcTrace (self,event=None):
    
    g.app.trace_gc = True
    g.app.trace_gc_inited = False
    g.enable_gc_debug()
#@nonl
#@-node:ekr.20060127163325.1:enable/disableGcTrace
#@+node:ekr.20060202154734:freeTreeWidgets
def freeTreeWidgets (self,event=None):
    
    c = self.c
    
    c.frame.tree.destroyWidgets()
    c.redraw()
#@nonl
#@-node:ekr.20060202154734:freeTreeWidgets
#@+node:ekr.20060210100432:printFocus
# Doesn't work if the focus isn't in a pane with bindings!

def printFocus (self,event=None):
    
    c = self.c
    
    g.es_print('      hasFocusWidget: %s' % c.widget_name(c.hasFocusWidget))
    g.es_print('requestedFocusWidget: %s' % c.widget_name(c.requestedFocusWidget))
    g.es_print('           get_focus: %s' % c.widget_name(c.get_focus()))
#@nonl
#@-node:ekr.20060210100432:printFocus
#@+node:ekr.20060205043324.3:printGcSummary
def printGcSummary (self,event=None):

    g.printGcSummary()
#@nonl
#@-node:ekr.20060205043324.3:printGcSummary
#@+node:ekr.20060202133313:printStats
def printStats (self,event=None):
    
    c = self.c
    c.frame.tree.showStats()
    self.dumpAllObjects()
#@nonl
#@-node:ekr.20060202133313:printStats
#@-node:ekr.20060127162818.1:class debugCommandsClass
#@+node:ekr.20060127100926:(Improved gc stats)
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.dialogs = 0 # Count of open dialogs.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.globalOpenDir = None # The directory last used to open a file.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scanErrors = 0 # The number of errors seen by g.scanError.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.statsDict = {} # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.trace_gc = False # defined in run()
    self.trace_gc_calls = False # defined in run()
    self.trace_gc_verbose = False # defined in run()
    self.trace_gc_inited = False
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None
    
    << Define global constants >>
    << Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    << start psycho >>
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@nonl
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    windowFlag = False
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script, windowFlag
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20040803072955.58:redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            g.trace(self.redrawCount,g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:redraw_now & helper
#@+node:ekr.20031218072017.1588:Garbage Collection
# debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
#@+node:ekr.20060127162818:enable_gc_debug
def enable_gc_debug(event=None):
    
    if g.app.trace_gc_inited:
        return
    
    if gc:
        if g.app.trace_gc_verbose:
            gc.set_debug(
                gc.DEBUG_STATS | # prints statistics.
                gc.DEBUG_LEAK | # Same as all below.
                gc.DEBUG_COLLECTABLE |
                gc.DEBUG_UNCOLLECTABLE |
                gc.DEBUG_INSTANCES |
                gc.DEBUG_OBJECTS |
                gc.DEBUG_SAVEALL
            )
            g.es('enabled verbose gc stats',color='blue')
        else:
            gc.set_debug(gc.DEBUG_STATS)
            g.es('enabled brief gc stats',color='blue')
    else:
        g.es('Can not import gc module',color='blue')
#@nonl
#@-node:ekr.20060127162818:enable_gc_debug
#@+node:ekr.20031218072017.1589:clearAllIvars
def clearAllIvars (o):
    
    """Clear all ivars of o, a member of some class."""
    
    o.__dict__.clear()
#@-node:ekr.20031218072017.1589:clearAllIvars
#@+node:ekr.20060205043324:Called from commands
#@+node:ekr.20031218072017.1590:collectGarbage
def collectGarbage():

    try:
        if not g.app.trace_gc_inited and g.app.trace_gc_verbose:
            g.enable_gc_debug()

        if g.app.trace_gc_verbose or g.app.trace_gc_calls:
            g.es_print('Collecting garbage')

        gc.collect()
    except:
        pass
        
    # Only init once, regardless of what happens.
    g.app.trace_gc_inited = True
#@nonl
#@-node:ekr.20031218072017.1590:collectGarbage
#@+node:ekr.20060205043324.1:printGcSummary
def printGcSummary (message='',trace=False):
    
    if not message:
        message = g.callerName(n=2)

    g.enable_gc_debug()

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = 'garbage: %d, objects: %d, %s' % (n,n2,message)
        if trace:
            print s
        else:
            g.es_print(s)
    except:
        traceback.print_exc()
#@nonl
#@-node:ekr.20060205043324.1:printGcSummary
#@+node:ekr.20060202161935:printGcAll
def printGcAll (message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    d = {} ; objects = gc.get_objects()
    g.es_print('-' * 30)
    g.es_print('%d objects' % len(objects),message)

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        d[t] = d.get(t,0) + 1
        
    if 1: # Sort by n
        
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            g.es_print('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            g.es_print('%40s %7d' % (t,d.get(t)))
#@-node:ekr.20060202161935:printGcAll
#@+node:ekr.20060127164729.1:printGcObjects
def printGcObjects(message=''):
    
    if not message:
        message = g.callerName(n=2)

    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        lastObjectCount = n2

        g.es_print('-' * 30)
        g.es_print("garbage: %d, objects: %d, delta: %d %s" % (n,n2,delta,message))
        
        << print number of each type of object >>
        if 0:
            << print added functions >>

    except:
        traceback.print_exc()
#@nonl
#@+node:ekr.20040703065638:<< print added functions >>
import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if not lastFunctionsDict.has_key(key):
            g.es_print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            g.es_print("args", args)
            if varargs: g.es_print("varargs",varargs)
            if varkw: g.es_print("varkw",varkw)
            if defaults:
                g.es_print("defaults...")
                for s in defaults: g.es_print(s)

lastFunctionsDict = funcDict
funcDict = {}
#@nonl
#@-node:ekr.20040703065638:<< print added functions >>
#@+node:ekr.20040703054646:<< print number of each type of object >>
global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    t = type(obj)
    if t == 'instance':
        try: t = obj.__class__
        except: pass
    typesDict[t] = n + 1
    
# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

keys.sort()
for key in keys:
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        g.es_print("%+6d =%7d %s" % (delta2,n2,key))
    
lastTypesDict = typesDict
typesDict = {}
#@nonl
#@-node:ekr.20040703054646:<< print number of each type of object >>
#@-node:ekr.20060127164729.1:printGcObjects
#@+node:ekr.20060127165509:printGcVerbose
# WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(message=''):
    
    if not message:
        message = g.callerName(n=2)

    global lastObjectsDict
    objects = gc.get_objects()
    
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]
    
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o
        
    dicts = 0 ; seqs = 0
    
    i = 0 ; n = len(newObjects)
    while i < 100 and i < n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            seqs += 1
        else:
            g.es_print(o)
        i += 1
    g.es_print('-' * 40)
    g.es_print('dicts: %d, sequences: %d' % (dicts,seqs))
    g.es_print("%25s: %d new, %d total objects" % (message,len(newObjects),len(objects)))
#@nonl
#@-node:ekr.20060127165509:printGcVerbose
#@-node:ekr.20060205043324:Called from commands
#@+node:ekr.20060205043324.2:Called from unit tests
#@+node:ekr.20031218072017.1592:printGc
def printGc(message=None):
    
    if not g.app.trace_gc: return None
    
    if not message:
        message = g.callerName(n=2)
        
    printGcObjects(message)
    printGcRefs(message)
    
    if g.app.trace_gc_verbose:
        printGcVerbose(message)
        
    
#@+node:ekr.20031218072017.1593:printGcRefs
def printGcRefs (message=''):

    refs = gc.get_referrers(app.windowList[0])
    g.es_print('-' * 30,message)

    if g.app.trace_gc_verbose:
        g.es_print("refs of", app.windowList[0])
        for ref in refs:
            g.es_print(type(ref))
    else:
        g.es_print("%d referers" % len(refs))
#@nonl
#@-node:ekr.20031218072017.1593:printGcRefs
#@-node:ekr.20031218072017.1592:printGc
#@-node:ekr.20060205043324.2:Called from unit tests
#@-node:ekr.20031218072017.1588:Garbage Collection
#@-node:ekr.20060127100926:(Improved gc stats)
#@-node:ekr.20060130151453:Find leaks (may be fixed)
#@-node:ekr.20060209104733:Urgent and big (overdue)
#@+node:ekr.20060116073229:To do 4.4.1
#@+node:ekr.20051217175058:*Add chapters  to Leo's core & make positions permanent
show-chapters
hide-chapters
add-chapter
delete-this-chapter
#@nonl
#@+node:ekr.20060201150547:Chapters
@ignore

from __future__ import generators
import java
import java.awt as awt
import java.awt.event as aevent
import javax.swing as swing
import javax.swing.event as sevent
import javax.swing.tree as stree
import java.util.concurrent.locks as locks
import leoNodes
import leoGlobals as g
import leoSwingUndo
import javax.swing.undo as undo
from utilities.DefCallable import DefCallable
from utilities.Phaser import Phaser
from utilities.Slider import Slider
from leoSwingFrame import leoSwingTree


class Chapters( sevent.ChangeListener ):
    
    def __init__( self, c ):
        
        self.c = c
        self.book = None
        path = g.os_path_join( g.app.loadDir,"..","Icons", "x.png" )
        self.icon = swing.ImageIcon( path )
        self.popup = self.ChaptersPopup( self )
        self.chapters = {}
        self.trees_chapters = {}
        self.current_chapter = self.Chapter()
        self.chapterlist = []
        #let's skip adding the first chapter
        #self.chapterlist.append( self.current_chapter )
        self.current_chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
        self.updateLock = locks.ReentrantLock() #this increase by 1 for each lock call. -1 for each unlock.  If it becomes 0, the lock is released
        self.chaptersIterationBlocked = 0
        self.chaptersundoer = undo.UndoManager()
        self.chaptersPromptingForRemove = False
        
    
    def getChapter( self ):
        return self.current_chapter
    
    def startPromptingForRemove( self ):
        self.chaptersPromptingForRemove = True
        
    def stopPromptingForRemove( self ):
        self.chaptersPromptingForRemove = False
    
    def isPromptingForRemove( self ):
        return self.chaptersPromptingForRemove
    
    
    
    def disablePopup( self ):
        self.popup.disable()
        
    def enablePopup( self ):
        self.popup.enable()
    
    def beginUpdate( self ):
        self.updateLock.lock()
        
    def endUpdate( self ):
        self.updateLock.unlock()
    
    def getWidget( self ):
        if self.book is None:
            # We defer creating until here because otherwise the book variable might miss a L&amp;F change
            self.book = swing.JTabbedPane()
            self.book.addMouseListener( self.popup )
            ssm = self.book.getModel()
            ssm.addChangeListener( self )
        return self.book
        
    def getSelectedChapter( self ):
        return self.current_chapter
    
    def getSelectedChapterWidget( self ):
        
        return self.book.getSelectedComponent()
    
    @others
    

#@+node:ekr.20060201150547.1:What are Chapters?
@
Chapters simply put are multiple Outlines within the Leo instance.  The definition doesn't stop there though since having more than one Outline defines an interaction model between these Outlines.  It is better to think of it like so:
    An Outline is composed of at least 1 Chapter.
    A writen Outline with multiple Chapters should be indistinguishable from an Outline with one Chapter.  The only mark is that the roots will have a uA marking them as belonging to a specific Chapter.
    So at read time, the Outline is read in then broken into its separate Chapters.
    At write time, the Outline is reconstituted as one Outline during output.  The reunification is only realised on disk.  Internally we use magic unfication iterators that give the write process a sense that it is writing one outline.  These special iterators mean that there is a low impact upon the write code.  Much of it has stayed the same except that it now uses a different iterator.
#@-node:ekr.20060201150547.1:What are Chapters?
#@+node:ekr.20060201150547.2:Things A Developer should know about Chapters
@
Observation 1: Do not start a beginUpdate in one chapter and finish it with a endUpdate in another chapter.  You will lose your ability to work with the outline/chapter where the beginUpdate started.  I have seen this happen, so let this be a warning to you.  I guess a protective fix against this would be to keep track of which chapter an endUpdate belongs to.  Hence doing a beginUpdate in one chapter followed by and endUpdate in another chapter would target the first chapter.  Im unsure if this would work, but it is a thought that may make the implementation more robust.

Observation 2: root positions should not become stale.  Since we aggresively copy everytime the root or current position is asked for from the chapter, the main copy should never change unless it is explicitly set.

Observation 3: Sliders and Phasers work better than dialogs with Chapters.  Ive found it disruptive when working with Chapters to suddenly have a dialog pop up grabbing my attention away from the Chapter Im working on.  Hence Ive moved informational and querying of the user primarily to Sliders.  Not only does it attach a question or notification to a Chapter better it also is very nice animation to observe.  Keeping our focus on the Chapter in question is essential!

Observation 4: We use the doHook mechanism to notify listeners that the current chapter has changed.  This makes it easy to monitor the changing of chapters, but the devloper must ensure that the chapter belongs to the chapters instance he is interested in.  Hence the commander is passed in as well.  If you are interested in the a specific Chapters instance the Commander should be enough to discern which chapters the chapter belongs to.  See the Node "A Note about Chapters and Commanders".

#@-node:ekr.20060201150547.2:Things A Developer should know about Chapters
#@+node:ekr.20060201150547.3:A Note about Chapters and Commanders
@

Chapters Swing takes the lessons learned from past Chapters plugins and simplifies the implementation by making the Chapters instance the provider of the root, current and top positions.  The Command is no longer in charge of this and will delegate the:
    getCurrentPosition() # or is it c.currentPosition()? :D
    getTopPosition()
    getRootPosition()

to the Chapters instance.  Each Commander now has a Chapters instance upon instantiation.

Also setting the variables will be delegated to the Chapters instance, which in turn delegates to a Chapter instance.

Hence we can keep the Commander interface and just restructure the internals and Chapters are now available.
#@nonl
#@-node:ekr.20060201150547.3:A Note about Chapters and Commanders
#@+node:ekr.20060201150547.4:commander delegates
def setRootPosition( self, p ):
    
    #if self.loading: return
    if p:
        p = p.copy()
    if self.current_chapter:
        self.current_chapter.setRootPosition( p )
    #self.roots[ self.current_chapter ] = p


def getRootPosition( self ):
    
    #if self.loading: return
    if self.current_chapter:
        return self.current_chapter.getRootPosition()
    return None   
    #return self.roots[ self.current_chapter ].copy()
    #rv = self.roots.get( self.current_chapter, None )
    #if rv: rv = rv.copy()
    #return rv
    
    
def setCurrentPosition( self, p ):
    
    #if self.loading: return    
    if p:
        p = p.copy()
    if self.current_chapter:
        self.current_chapter.setCurrentPosition( p )   
    #self.currentPositions[ self.current_chapter ] = p
        
    
def getCurrentPosition( self ):
    
    #if self.loading: return
    if self.current_chapter:
        return self.current_chapter.getCurrentPosition()
    return None
        
    #return self.currentPositions[ self.current_chapter ].copy()
    #rv = self.currentPositions.get( self.current_chapter, None )
    #if rv: rv = rv.copy()
    #return rv
#@nonl
#@-node:ekr.20060201150547.4:commander delegates
#@+node:ekr.20060201150547.5:stateChanged
def stateChanged( self, event ):
    
    c = self.c
    try:
        self.beginUpdate()
        index = self.book.getSelectedIndex()
        component = self.book.getComponentAt( index )
        chapter = self.chapters[ component ]
        c.frame.tree = chapter.tree
        self.current_chapter = chapter
        #chapter.tree.jtree.treeDidChange()
        c.beginUpdate()
        c.endUpdate()
        #c.selectPosition( chapter.getCurrentPosition() )
        self.current_chapter.undoer.setMenu( forceupdate = 1 )
        g.doHook( "chapter-changed", c = self.c, chapter = chapter )
    finally:
        self.endUpdate()
        
    #if chapter.root:
    #    chapter.root.linkAsRoot( None )

@   
    oldchapter = self.current_chapter
    index = self.book.getSelectedIndex()
    title = self.book.getTitleAt( index )
    self.current_chapter = title
    nwroot = self.chapters[ title ]
    oldroot = self.c.rootPosition().copy()
    self.chapters[ oldchapter ] = oldroot
    c.beginUpdate()
    c.setRootPosition( nwroot.copy() )
    c.endUpdate()


#@-node:ekr.20060201150547.5:stateChanged
#@+node:ekr.20060201150547.6:getChaptersIterator
def iterateOverChapters( self ):
    
    for x in self.chaptersIterator():
        print x
        
    

#@-node:ekr.20060201150547.6:getChaptersIterator
#@+node:ekr.20060201150547.7:markNodesForChapterization
def markNodesForChapterization( self ):

    if not self.chaptersIterationBlocked:    
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for n in xrange( len(self.chapterlist)):
            chapter = self.chapterlist[ n ]
            rp = chapter.getRootPosition()
            rp_base = rp.copy()
            for z in rp.self_and_siblings_iter( copy = True ):
                v = z.v
                if not hasattr( v, "unknownAttributes" ):
                    v.unknownAttributes = {}
                v.unknownAttributes[ 'chapter' ] = n
                if z == rp_base:
                    v.unknownAttributes[ 'chapter_name' ] = chapter.name
    else:
        rp = self.getRootPosition()
        rp_base = rp.copy()
        for z in rp.self_and_siblings_iter( copy = True ):
            v = z.v
            if not hasattr( v, "unknownAttributs" ):
                v.unknownAttributes = {}
            v.unknownAttributes[ 'chapter' ] = 0
            if z == rp_base:
                v.unknownAttributes[ 'chapter_name' ] = self.current_chapter.name
#@nonl
#@-node:ekr.20060201150547.7:markNodesForChapterization
#@+node:ekr.20060201150547.8:utility
def changeChaptersName( self ):
       
    chapter = self.current_chapter
    if chapter.isMessaging(): return
    chapter.startMessaging()
    jp = swing.JPanel( java.awt.BorderLayout() )
    slider = Slider( jp, direction = Slider.down )
    #phaser = Phaser( jp )
    nlabel = swing.JLabel( "Chapter Name:" )
    jp.add( nlabel, java.awt.BorderLayout.NORTH )
    jtf = swing.JTextField()
    slider.setComponentToFocus( jtf )
    #phaser.setComponentToFocus( jtf )
    jtf.setText( str( chapter.name ) )
    jp.add( jtf )
    top = self.c.frame.top
    def closeAndChange():
        chapter.doneMessaging()
        nw_name = jtf.getText()
        book = self.book
        index = book.getSelectedIndex()
        old_name= book.getTitleAt( index ) 
        book.setTitleAt( index, nw_name )
        self.chaptersundoer.addEdit( self.UndoChangeChapterName( self, chapter, old_name, nw_name ) )
        chapter.name = nw_name
        slider.startRemoving()
        #phaser.phaseRemove()
    
    class aa( swing.AbstractAction ):
        def __init__( self, *args ):
            swing.AbstractAction.__init__( self, *args )
        
        def actionPerformed( self, ae ):
            closeAndChange()
    ks = swing.KeyStroke.getKeyStroke( "ENTER" )
    if ks:
        am = jtf.getActionMap()
        im = jtf.getInputMap()
        im.put( ks, "enter" )
        am.put( "enter", aa() )
    jp2 = swing.JPanel() 
    jb = swing.JButton( "Ok" )
    jb.actionPerformed = lambda event : closeAndChange()
    jp2.add( jb )
    jp.add( jp2, java.awt.BorderLayout.SOUTH )
    tree = self.c.frame.tree
    jtree = tree.jtree
    bg = jtree.getBackground()
    fg = jtree.getForeground()
    jp.setBackground( bg )
    jp.setForeground( fg )
    nlabel.setForeground( fg )
    jp2.setBackground( bg )
    jp2.setForeground( fg )
    lb = swing.border.LineBorder( fg )
    jp.setBorder( lb )
    main_widget = tree.getWidget()
    vrect = tree.jspane.getViewportBorderBounds()
    height = slider.getPreferredSize().height
    #height = phaser.getPreferredSize().height
    vrect.height = height
    slider.setBounds( vrect )
    #phaser.setBounds( vrect )
    gp = main_widget.getGlassPane()
    gp.setVisible( True )
    gp.add( slider )
    #gp.add( phaser )



#@+node:ekr.20060201150547.9:changeChaptersName
#@-node:ekr.20060201150547.9:changeChaptersName
#@+node:ekr.20060201150547.10:moveNodeToChapter
def moveNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
        
    if cpos.isRoot():
        testroot = cpos.copy()
        testroot.moveToNext()
        if not testroot:
            return
    
    parent = cpos.getParent()    
    if parent:
        ok =  c.checkMoveWithParentWithWarning( pos.copy(), parent, True )
    else:
        ok = 1
        
    if not ok:
        return
    
    try:    
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        pos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        pos.linkAfter( cpos )
        c.endUpdate()
    

        self.current_chapter = current
        c.frame.tree = current.tree
    finally:
        self.endUpdate()

#@-node:ekr.20060201150547.10:moveNodeToChapter
#@+node:ekr.20060201150547.11:copyNodeToChapter
def copyNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
    
    nwpos = pos.copyTreeAfter()    
    #if cpos.isRoot():
    #    testroot = cpos.copy()
    #    testroot.moveToNext()
    #    if not testroot:
    #        return
    
    #parent = cpos.getParent()    
    #if parent:
    #    ok =  c.checkMoveWithParentWithWarning( pos.copy(), parent, True )
    #else:
    #    ok = 1
        
    #if not ok:
    #    return
    try:
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        nwpos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        nwpos.linkAfter( cpos )
        undo = leoSwingUndo.UndoableInsertNode( self.c, [ "Insert Node", nwpos.copy(), ], {} )
        chapter.undoer.addUndo( undo )
        c.endUpdate()
        self.current_chapter = current
        c.frame.tree = current.tree
        current.undoer.setMenu( forceupdate = 1 )
    finally:
        self.endUpdate()
#@-node:ekr.20060201150547.11:copyNodeToChapter
#@+node:ekr.20060201150547.12:cloneNodeToChapter
def cloneNodeToChapter( self, pos, chapter ):
    
    c = self.c
    cpos = chapter.getCurrentPosition()
    if not cpos:
        cpos = chapter.getRootPosition()
    
    nwpos = pos.clone( pos.copy() )
        
    #if cpos.isRoot():
    #    testroot = cpos.copy()
    #    testroot.moveToNext()
    #    if not testroot:
    #        return
    
    parent = cpos.getParent()    
    if parent:
        ok =  c.checkMoveWithParentWithWarning( nwpos.copy(), parent, True )
    else:
        ok = 1
        
    if not ok:
        nwpos.unlink()
        c.beginUpdate()
        c.endUpdate()
        return
    
    try:
        self.beginUpdate()
        current = self.current_chapter
        c.beginUpdate()
        nwpos.unlink()
        c.endUpdate()
    
        self.current_chapter = chapter
        c.frame.tree = chapter.tree
        c.beginUpdate()
        nwpos.linkAfter( cpos )
        undo = leoSwingUndo.UndoableInsertNode( self.c, [ "Insert Node", nwpos.copy(), ], {} )
        chapter.undoer.addUndo( undo )
    finally:
        c.endUpdate()
    

    self.current_chapter = current
    c.frame.tree = current.tree
    self.endUpdate()
    current.undoer.setMenu( forceupdate = 1 )
#@nonl
#@-node:ekr.20060201150547.12:cloneNodeToChapter
#@+node:ekr.20060201150547.13:testNode
def testNode( self ):
    
    chapter = self.current_chapter
    pos = chapter.getCurrentPosition()
    
    print pos
    for ancestor in pos.self_and_parents_iter(): #copy = 1):
        print ancestor, ancestor.isCloned()
#@nonl
#@-node:ekr.20060201150547.13:testNode
#@+node:ekr.20060201150547.14:swapChapters
def swapChapters( self, chapter1, chapter2, undo = True ):

    try:    
        self.beginUpdate()
        widget1 = chapter1.tree.getWidget()
        widget2 = chapter2.tree.getWidget()
        index1 = self.book.indexOfComponent( widget1 )
        index2 = self.book.indexOfComponent( widget2 )
        jp = swing.JPanel() #place holder, keeps order
        self.book.setComponentAt( index1, jp )
        self.book.setComponentAt( index2, widget1 )
        self.book.setComponentAt( index1, widget2 )
        self.book.setTitleAt( index1, chapter2.name )
        self.book.setTitleAt( index2, chapter1.name )
        i1 = self.chapterlist.index( chapter1 )
        i2 = self.chapterlist.index( chapter2 )
        self.chapterlist[ i1 ] = chapter2
        self.chapterlist[ i2 ] = chapter1
        self.current_chapter = chapter2
        self.c.frame.tree = chapter2.tree
        self.c.beginUpdate()
        self.c.endUpdate()
        if undo:
            self.chaptersundoer.addEdit( self.UndoSwapChapters( self, chapter1, chapter2 )) 
    finally:
        self.endUpdate()
    
    
#@nonl
#@-node:ekr.20060201150547.14:swapChapters
#@+node:ekr.20060201150547.15:mergeChapters
def mergeChapters( self, chapter1, chapter2 ):

	try:    
        self.beginUpdate()
    
        rp = chapter2.getRootPosition()
        nodes = []
        for z in rp.self_and_siblings_iter( copy = True ):
            nodes.append( z )
    
        for z in nodes:
            z.unlink()
        
        rp2 = chapter1.getRootPosition()
        for z in rp2.self_and_siblings_iter( copy = True ):
            pass   
        base = z.copy()

    
        self.c.beginUpdate()
    
        for z in nodes:
            z.linkAfter( base )
            base = z.copy()
        
        self.quietRemoveChapter( chapter2 )
        self.c.endUpdate()    
    finally:
        self.endUpdate()
#@nonl
#@-node:ekr.20060201150547.15:mergeChapters
#@+node:ekr.20060201150547.16:selectChapter
def selectChapter( self, chapter ):
    
    widget = chapter.tree.getWidget()
    index = self.book.indexOfComponent( widget )
    if index != -1:
        self.book.setSelectedComponent( widget )
    
#@nonl
#@-node:ekr.20060201150547.16:selectChapter
#@+node:ekr.20060201150547.17:insertChapter
def insertChapter( self, chapter ):
    
    self.chapterlist.append( chapter )
    tree = chapter.tree 
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()   
    self.chapters[ widget ] = chapter
    ic = self.IconCloser( self.icon, self.removeChapter )
    self.book.addTab( chapter.name, ic, widget )

#@-node:ekr.20060201150547.17:insertChapter
#@+node:ekr.20060201150547.18:findChapterForNode
def findChapterForNode( self, p ):
    
    for n in xrange( self.book.getTabCount() ):
        widget = self.book.getComponentAt( n )
        chapter = self.chapters[ widget ]
        rp = chapter.getRootPosition()
        for z in rp.fromSelfAllNodes_iter( copy = True ):
            if z == p: return chapter
        
    return None
#@nonl
#@-node:ekr.20060201150547.18:findChapterForNode
#@+node:ekr.20060201150547.19:turnNodeIntoChapter
def turnNodeIntoChapter( self ):
    
    cp = self.current_chapter.getCurrentPosition()
    if cp.isRoot():
        testroot = cp.copy()
        testroot.moveToNext()
        if not testroot:
            return
    self.c.beginUpdate()
    cp.unlink()
    rp = self.current_chapter.getRootPosition()
    self.current_chapter.setCurrentPosition( rp )
    self.c.endUpdate()
    self.freshChapter( p = cp )
#@nonl
#@-node:ekr.20060201150547.19:turnNodeIntoChapter
#@-node:ekr.20060201150547.8:utility
#@+node:ekr.20060201150547.20:import and export
@others
#@+node:ekr.20060201150547.21:import outline
def importOutline( self ):
    
    fc = swing.JFileChooser()
    fc.showOpenDialog( None )
    sfile = fc.getSelectedFile()
    if sfile:
        self.loadFileAsChapter( sfile.getAbsolutePath() )
    
def loadFileAsChapter( self, fname ):
    
    c = self.c
    targetfile = java.io.File( fname )
    if not targetfile.exists() or targetfile.isDirectory():
        return
    
    mungedname = targetfile.getName()
    if mungedname.endswith( ".leo") : mungedname = mungedname[ : -4 ]
    def run():
        self.freshChapter( name = mungedname, edit = False, undo = False )
        
    dc = DefCallable( run )
    ft = dc.wrappedAsFutureTask()
    if java.awt.EventQueue.isDispatchThread():
        ft.run()
    else:
        swing.SwingUtilities.invokeAndWait( ft )
    
    edit = sel.UndoImport( self, self.current_chapter )
    self.chaptersundoer.addEdit( edit )
    c.frame.disableResizing()
    p = c.fileCommands.getLeoFileAsOutline( fname )
    c.frame.enableResizing()
    oldir = c.frame.openDirectory
    parent = targetfile.getParentFile()
    c.frame.openDirectory = parent.getAbsolutePath()
    c.atFileCommands.readAll( c.rootPosition().copy() ,partialFlag=False)
    c.frame.openDirectory= oldir
    self.deferedChapterization( c.rootPosition(), selectchapter = self.getSelectedChapterWidget(), edit = edit )

#@-node:ekr.20060201150547.21:import outline
#@+node:ekr.20060201150547.22:export outline
def exportOutline( self ):
    
    self.chaptersIterationBlocked = 1
    self.beginUpdate()
    fc = swing.JFileChooser()
    fc.showSaveDialog( None )
    sfile = fc.getSelectedFile()
    if not sfile:
        g.es( "No file name entered." )
        return
    fileName = fc.getName( sfile )
    if not fileName.endswith( ".leo" ):
        fileName = "%s.leo" % fileName
    self.c.fileCommands.write_Leo_file( fileName, True )
    self.chaptersIterationBlocked = 0
    self.endUpdate()
    g.es( "Done Exporting %s as %s" % ( self.current_chapter.name, fileName ) )
#@nonl
#@-node:ekr.20060201150547.22:export outline
#@-node:ekr.20060201150547.20:import and export
#@+node:ekr.20060201150547.23:adding and removing chapters
@others
#@+node:ekr.20060201150547.24:addChapter
def addChapter( self, name, p = None ):
    

    c = self.c
    chapter = self.Chapter()
    self.chapterlist.append( chapter )
    chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
    chapter.setRootPosition( p )
    chapter.setCurrentPosition( p )
    #self.current_chapter = current
    cm = self.ChapterModel( c , chapter) #, p )
    tree = leoSwingTree( frame = c.frame, model = cm, chapter= chapter )
    tree.createAuxilaryWidgets()
    #self.c.frame.tree = tree
    chapter.setTree( tree )
    chapter.name = name
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()
    
    self.chapters[ widget ] = chapter
    ic = self.IconCloser( self.icon, self.removeChapter )
    self.book.addTab( name, ic, widget )

    if not self.current_chapter:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        self.endUpdate()

    return tree



#@-node:ekr.20060201150547.24:addChapter
#@+node:ekr.20060201150547.25:addChapterForSettingsTree
def addChapterForSettingsTree( self, name, p = None , controller = None):
    
    c = self.c
    chapter = self.current_chapter
    #chapter = self.Chapter()
    #chapter.setUndoer( leoSwingUndo.leoSwingUndo( c ) )
    chapter.setRootPosition( p )
    chapter.setCurrentPosition( p )
    #c.chapters.current_chapter = chapter
    #chapter = self.current_chapter
    cm = self.ChapterModel( c , chapter)
    import leoConfig
    tree = leoConfig.settingsTree( frame = c.frame, model = cm, chapter = chapter, controller = controller )
    chapter.setTree( tree )
    chapter.name = name
    self.trees_chapters[ tree ] = chapter
    widget = tree.getWidget()
    
    self.chapters[ widget ] = chapter
    self.book = self.getWidget()
    self.book.addTab( name, widget )
    if not self.current_chapter:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        self.endUpdate()

    return tree




#@-node:ekr.20060201150547.25:addChapterForSettingsTree
#@+node:ekr.20060201150547.26:freshChapter
def freshChapter( self, p = None, name = None, edit = True, undo = True ):
    
    c = self.c
    if not p:
        t = leoNodes.tnode( headString = "NewHeadline" )
        v = leoNodes.vnode( c, t )
        p = leoNodes.position( v, [] )
    if not name:
        name = "New Chapter"
    tree = self.addChapter( name, p = p )                    
    chapter = self.trees_chapters[ tree ]
    if undo:
        self.chaptersundoer.addEdit( self.UndoAddChapter( self, chapter ) ) 
    try:
        self.beginUpdate()
        self.current_chapter = chapter
        c.frame.tree = tree
        p.linkAsRoot( None )
        #self.current_chapter = current 
        widget = tree.getWidget()
        self.book.setSelectedComponent( widget )   
    finally:
        self.endUpdate()
    tree.loaded = 1
    if edit:
        self.c.editPosition( p.copy() )
#@nonl
#@-node:ekr.20060201150547.26:freshChapter
#@+node:ekr.20060201150547.27:removeChapter
def removeChapter( self, chapter = None, undo = True ):

    tree = self.c.frame.tree
    vrect = tree.jspane.getViewportBorderBounds()
    main_widget = tree.getWidget()
    gp = main_widget.getGlassPane()
    bgc = tree.jtree.getBackground()
    fgc = tree.jtree.getForeground() 
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    fg = self.book.getForegroundAt( index )
    bg = self.book.getBackgroundAt( index )
    if chapter.isMessaging() or self.isPromptingForRemove(): return
    chapter.startMessaging()
    self.startPromptingForRemove()
    self.book.setForegroundAt( index, bg )
    self.book.setBackgroundAt( index, fg )
    if self.book.getTabCount() == 1:
        def ok( chapter = chapter ):
            self.stopPromptingForRemove()
            chapter.doneMessaging()
            self.book.setForegroundAt( index, fg )
            self.book.setBackgroundAt( index, bg )
        buttons = ( ( "Ok", ok ), )
        sa = self.SliderMessageButtons( "Can't remove the only Chapter", buttons = buttons, bgc = bgc, fgc = fgc )
        gp.setVisible( True )
        swidget = sa.getSlider()
        height = swidget.getPreferredSize().height
        vrect.height = height
        swidget.setBounds( vrect )
        gp.add( swidget )
        return
    else:
        message = "Do you want to remove Chapter: %s ?" % chapter.name
        def yes( component = component, chapter = chapter ):
            self.book.remove( component )
            chapter.doneMessaging()
            self.chapterlist.remove( chapter )
            tree = chapter.tree 
            del self.trees_chapters[ tree ]
            del self.chapters[ component ]
            self.chaptersundoer.addEdit( self.UndoRemoveChapter( self, chapter ) )
            try:
                index = self.book.getSelectedIndex()
                component = self.book.getComponentAt( index )
                #self.chapters[ widget ] = chapter
                chapter = self.chapters[ component ]
                self.beginUpdate()
                self.current_chapter = chapter
                self.c.frame.tree = chapter.tree
            finally:
                self.endUpdate()
            self.stopPromptingForRemove()            
            g.doHook( "chapter-removed", c = self.c, chapter = chapter )
            
        def no( chapter = chapter ):
            self.stopPromptingForRemove()
            chapter.doneMessaging()
            self.book.setForegroundAt( index, fg )
            self.book.setBackgroundAt( index, bg )
            
        buttons = ( ( "Yes", yes ), ( "No", no ) )
        sa = self.SliderMessageButtons( message, buttons = buttons, bgc = bgc, fgc = fgc )
        gp.setVisible( True )
        swidget = sa.getSlider()
        height = swidget.getPreferredSize().height
        vrect.height = height
        swidget.setBounds( vrect )
        gp.add( swidget )            
           
@    
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    rv = swing.JOptionPane.showConfirmDialog( None,
                                             "Do you want to remove Chapter: %s" % chapter.name,
                                             "Remove a Chapter?",
swing.JOptionPane.YES_NO_OPTION )
    if rv == swing.JOptionPane.NO_OPTION: return


    self.book.removeTabAt( index ) #removing does not fire a change event
    index = self.book.getSelectedIndex()
    component = self.book.getComponentAt( index )
    chapter = self.chapters[ component ]
    self.chapterlist.remove( chapter )
    try:
        self.beginUpdate()
        self.current_chapter = chapter
        self.c.frame.tree = chapter.tree
    finally:
        self.endUpdate()
    g.doHook( "chapter-removed", c = self.c, chapter = chapter )
#@-node:ekr.20060201150547.27:removeChapter
#@+node:ekr.20060201150547.28:quietRemoveChapter
def quietRemoveChapter( self, chapter ):
    
    tree = chapter.tree
    component = tree.getWidget()
    self.book.remove( component )
    self.chapterlist.remove( chapter )
    del self.trees_chapters[ tree ]
    del self.chapters[ component ]    
#@-node:ekr.20060201150547.28:quietRemoveChapter
#@-node:ekr.20060201150547.23:adding and removing chapters
#@+node:ekr.20060201150547.29:transforming an Outline into Chapers components
@others
#@+node:ekr.20060201150547.30:deferedChaperization
def deferedChapterization (self,pos,selectchapter=None,edit=None):

    x = lambda: self.breakOutlineIntoChapters(pos,selectchapter,edit)
    dc = DefCallable(x)
    ft = dc.wrappedAsFutureTask()
    swing.SwingUtilities.invokeLater(ft)
#@nonl
#@-node:ekr.20060201150547.30:deferedChaperization
#@+node:ekr.20060201150547.31:breakOutlineIntoChapters
def breakOutlineIntoChapters( self, p, selectchapter = None, edit = None ):
    
    #self.loading = 1
    self.beginUpdate()
    #self.updateLock.unlock()
    n = 0 
    last_z = None
    p2 = p.copy()
    level_0 = []
    for z in p.self_and_siblings_iter( copy = True ):
        level_0.append( z )

    if level_0:
        p1 = level_0[ 0 ]
        v1 = p1.v
        if hasattr( v1, "unknownAttributes" ):
            uA = v1.unknownAttributes
            if uA.has_key( "chapter_name" ):
                name = uA[ 'chapter_name' ]
                i = self.book.getSelectedIndex()
                self.book.setTitleAt( i, name )
                if self.current_chapter: #This needs to be set here or its lost in the next save
                    self.current_chapter.name = name

    for z in level_0:
        v = z.v
        name = "New Chapter"
        if hasattr( v, "unknownAttributes" ):
            if v.unknownAttributes.has_key( "chapter" ):
                a_n = v.unknownAttributes[ "chapter" ]
            else:
                a_n = n
            if v.unknownAttributes.has_key( "chapter_name" ):
                name = v.unknownAttributes[ "chapter_name" ]
        else:
            a_n = n
   
        if a_n != n:
            #self.c.endUpdate()
            n = a_n
            #z.doDelete( p2 )
            z.unlink()
            tree = self.c.chapters.addChapter( name, z.copy() )
            widget = tree.getWidget()
            chapter = self.chapters[ widget ]
            self.c.frame.tree = chapter.tree
            self.current_chapter = chapter
            if edit and hasattr( edit, "addChapter" ):
                edit.addChapter( chapter )
            ic = self.IconCloser( self.icon, self.removeChapter )
            self.book.addTab( name, ic, widget )
            #self.book.addTab( name, widget )
            self.book.setSelectedComponent( widget )
            #self.c.beginUpdate()
            last_z = z
            z.linkAsRoot( None )
            tree.loaded = 1
            continue
        
        if last_z:
            #z.moveAfter( last_z )
            z.unlink() 
            z.linkAfter( last_z )
        last_z = z           
    
    if not selectchapter:
        selectchapter = self.book.getComponentAt( 0 )       
    self.book.setSelectedComponent( selectchapter )
    self.c.beginUpdate()
    self.c.endUpdate()       
    self.endUpdate()
#@nonl
#@-node:ekr.20060201150547.31:breakOutlineIntoChapters
#@-node:ekr.20060201150547.29:transforming an Outline into Chapers components
#@+node:ekr.20060201150547.32:class ChaptersPopup
class ChaptersPopup( aevent.MouseAdapter ):
    
    def __init__( self, chapters ):
        aevent.MouseAdapter.__init__( self )
        self.chapters = chapters
        self.copyNodeToChapter = self.CopyNodeToChapter( chapters )
        self.cloneNodeToChapter = self.CloneNodeToChapter( chapters )
        self.swapChapters = self.SwapChapters( chapters )
        self.mergeChapters = self.MergeChapters( chapters )
        self.enabled = True
        
    def disable( self ):
        self.enabled = False
        
    def enable( self ):
        self.enabled = True
        
    @others
#@nonl
#@+node:ekr.20060201150547.33:mousePressed
def mousePressed( self, mE ):
                
    if mE.getClickCount() == 1 and self.enabled:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()
            DefAction = self.chapters.DefAction        
            popup = swing.JPopupMenu()            
            popup.add( DefAction( "Add Chapter", self.chapters.freshChapter ) ) 
            #popup.add( DefAction( "Remove Chapter", self.chapters.removeChapter ) )
            #popup.add( DefAction( "ITERATE!", self.chapters.iterateOverChapters ) ) 
            popup.add( DefAction( "Edit Chapters Name", self.chapters.changeChaptersName ) )
            popup.addSeparator()
            popup.add( self.copyNodeToChapter.getWidget() )
            popup.add( self.cloneNodeToChapter.getWidget() )
            popup.add( self.swapChapters.getWidget() )
            popup.add( self.mergeChapters.getWidget() )
            popup.add( DefAction( "Copy Node Into Chapter", self.chapters.turnNodeIntoChapter ) )
            #popup.add( DefAction( "Test NODE", self.chapters.testNode ) )
            popup.addSeparator()
            menu = swing.JMenu( "Import/Export" )
            popup.add( menu )
            menu.add( DefAction( "Import Outline", self.chapters.importOutline ) )
            menu.add( DefAction( "Export Chapter as Outline", self.chapters.exportOutline ) )
            popup.addSeparator()
            undoer = self.chapters.chaptersundoer
            utext = undoer.getUndoPresentationName()
            item = popup.add( DefAction( utext, undoer.undo ) )
            if not undoer.canUndo():
                item.setEnabled( False )
                
            rtext = undoer.getRedoPresentationName()
            item = popup.add( DefAction( rtext, undoer.redo ) )
            if not undoer.canRedo():
                item.setEnabled( False )    
                              
            source = mE.getSource()                
            popup.show( source, x, y )
#@-node:ekr.20060201150547.33:mousePressed
#@+node:ekr.20060201150547.34:class CopyNodeToChapter
class CopyNodeToChapter( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Copy Node To Chapter" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        cpos = current.getCurrentPosition()
        root = current.getRootPosition()
        #if cpos == root:
        #    roottest = cpos.copy()
        #    roottest.moveToNext()
        #    if not roottest:
        #        return
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mvnd = lambda event, cpos = cpos.copy(), chapter = z: self.chapters.copyNodeToChapter( cpos, chapter )
            jmi.actionPerformed = mvnd
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
#@-node:ekr.20060201150547.34:class CopyNodeToChapter
#@+node:ekr.20060201150547.35:class CloneNodeToChapter
class CloneNodeToChapter( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Clone Node To Chapter" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        cpos = current.getCurrentPosition()
        root = current.getRootPosition()
        #if cpos == root:
        #    roottest = cpos.copy()
        #    roottest.moveToNext()
        #    if not roottest:
        #        return
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mvnd = lambda event, cpos = cpos.copy(), chapter = z: self.chapters.cloneNodeToChapter( cpos, chapter )
            jmi.actionPerformed = mvnd
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
#@-node:ekr.20060201150547.35:class CloneNodeToChapter
#@+node:ekr.20060201150547.36:class SwapChapters
class SwapChapters( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Swap Chapters" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            swapchap = lambda event,  chapter = z: self.chapters.swapChapters( current, chapter )
            jmi.actionPerformed = swapchap
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
#@-node:ekr.20060201150547.36:class SwapChapters
#@+node:ekr.20060201150547.37:class MergeChapters
class MergeChapters( sevent.MenuListener ):
    
    def __init__( self, chapters ):
        self.chapters = chapters
        self.menu = swing.JMenu( "Merge Chapters" )
        self.menu.addMenuListener( self )
        
    def getWidget( self ):
        return self.menu
        
    def menuSelected( self, me ):
        
        self.menu.removeAll()
        current = self.chapters.current_chapter
        
        for z in self.chapters.cycleThroughChapters( swap = 0 ):
            if z == current: continue
            jmi = swing.JMenuItem( z.name )
            mergechapters = lambda event,  chapter = z: self.chapters.mergeChapters( current, chapter )
            jmi.actionPerformed = mergechapters
            self.menu.add( jmi )
    
    def menuDeselected( self, me ):
        pass
        
    def menuCanceled( self, me ):
        pass
#@-node:ekr.20060201150547.37:class MergeChapters
#@-node:ekr.20060201150547.32:class ChaptersPopup
#@+node:ekr.20060201150547.38:Action Classes
@others
#@+node:ekr.20060201150547.39:DefAction
class DefAction( swing.AbstractAction ):
    
    def __init__( self, name, function ):
        swing.AbstractAction.__init__( self, name )
        self.function = function
    
    def actionPerformed( self, event ):
        self.function()
#@nonl
#@-node:ekr.20060201150547.39:DefAction
#@-node:ekr.20060201150547.38:Action Classes
#@+node:ekr.20060201150547.40:class ChapterModel
class ChapterModel( stree.TreeModel, java.lang.Runnable ):
    
    
    
    def __init__( self, c , chapter ):#, proot ):

        self.c = c
        self.tmlisteners = java.util.ArrayList();
        self._root = self._rootN( c, chapter ) # , proot )
        self._rTreePath = stree.TreePath( self._root ) 
        self.chapter = chapter
        self.drunning = 0

        
    def getChapter( self ):
        return self.chapter

    def getRoot( self ):
        return self._root

    def reload( self, full_reload = False ):
        
        
        if full_reload:
            t_r = self.c.frame.tree.tree_reloader
            #for z in self.c.rootPosition().allNodes_iter( copy = True ):
            for z in self._root.getRootPosition().allNodes_iter( copy = True ):
                if z.isExpanded():
                    t_r.expand( z )
        
        import jarray
        a = jarray.zeros( 1, stree.TreeNode )
        a[ 0 ] = self._root
        e = sevent.TreeModelEvent( self._root, a )
        for z in list( self.tmlisteners ):
            z.treeStructureChanged( e )

            
    def dRun( self ):
        self.drunning = 1
        swing.SwingUtilities.invokeLater( self )
            
    def run( self ):
        
        try:
            import jarray
            a = jarray.zeros( 1, stree.TreeNode )
            a[ 0 ] = self._root
            e = sevent.TreeModelEvent( self._root, a )
            for z in list( self.tmlisteners ):
                z.treeStructureChanged( e )
            if self.chapter.tree.jtree:
                self.chapter.tree.jtree.fireTreeExpanded( self._rTreePath )
                cp = self.chapter.getCurrentPosition()
                cpp = self.getPathToRoot( cp )
                self.chapter.tree.jtree.setSelectionPath( cpp )
        finally:
            self.drunning = 0
    
    def addTreeModelListener( self, listener ):
        self.tmlisteners.add( listener )
        
    def removeTreeModelListener( self, listener ):
        self.tmlisteners.remove( listener )
    
    def getChild( self, parent, ind ):
        if parent is self._root:
            return parent.getChildAt( ind ).copy()
        return parent.getNthChild( ind ).copy()
        
    def getChildCount( self, parent ):
        
        if parent is self._root:
            return parent.getChildCount()
        if parent:
            return parent.numberOfChildren()
        else:
            return 0
        
    def getIndexOfChild( self, parent, child ):
        if parent is self._root:
            return self._root.getIndex( child )
        else:
            return child.childIndex()


    
    def valueForPathChanged( self, path, value ):

        pos = path.getLastPathComponent()
        pos.setHeadString( value )
        
    def isLeaf( self, node ):
        if node is self._root: return False
        if node:
            if node.numberOfChildren(): return False
            else: return True
        else:
            return True
            
            
    def getPathToRoot( self, node, masterlist = None ):
        
        path = []
        #if not node:
        #    node = self.c.rootPosition()
        stopat = None
        if self.chapter.hoistStack:
            bunch = self.chapter.hoistStack[ -1 ]
            stopat = bunch.p.copy()
            
        while node and node.level() != 0:
            path.append( node.copy() )
            if node == stopat: break
            node = node.getParent()
            if masterlist:
                if node in masterlist:
                    masterlist.remove( node )
        else:
            path.append( node.copy() )
        
        path.append( self._root )  
        path.reverse()
        tp = stree.TreePath( path )
        return tp
            
    class _rootN( stree.TreeNode ):
        
        def __init__( self, c, chapter ):#, proot ):
            self.c = c
            self.chapter = chapter
            self.v = None # These are for comparisons with positions, we must pretend to be a position
            self.stack = None
            
            #self.chapters = c.chapters
            #self.proot = proot
        def expand( self ): pass
        def contract( self ): pass
        
        def getChildIndex( self ):
            return -1
        
        def getRootPosition( self ):
            rp = self.chapter.getRootPosition()
            return rp

        
        def getChildAt(self, childIndex):
            rp = self.getRootPosition() #self.c.rootPosition()                
            #if len( self.c.hoistStack ) != 0: #Hoist Code
            if len( self.chapter.hoistStack ) != 0:
                #rp = self.c.hoistStack[ -1 ].p.copy()
                rp = self.chapter.hoistStack[ -1 ].p.copy()
                def getParent( root = self ): #This slight modification to a copy allows the Tree to keep its expanded state
                    return root
                rp.getParent = getParent
                return rp #End of Hoist Code
            if not rp: return None
            i = 0
            for z in rp.siblings_iter():
                if i == childIndex:
                    return z
                i = i + 1
            return None       
        
        def getChildCount( self ):
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            if len( self.chapter.hoistStack ) != 0:
                return 1
            #if len( self.c.hoistStack ) != 0:
            #    return 1
            i = 0
            for z in rp.siblings_iter():
                i = i + 1
            return i
        
        def getParent( self ):
            return None
            
        def getIndex( self, node):
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            if len( self.chapter.hoistStack ) != 0:
                return 0
            i = 0
            for z in rp.siblings_iter():
                if z == node: return i
                i = i + 1
            return -1
            
        def getAllowsChildren( self ):
            return True
            
        def isLeaf( self ):
            return False
            
        def equal( self, x ):
            if self is x: return True
            else: return False
            
        def equals( self, x ):
            if self is x: return True
            else:
                return False
            
        def copy( self ):
            return self
            
        def bodyString( self ):
            return ""
            
        def headString( self ):
            return ""
            
        def children( self ):
            
            class _enum( util.Enumeration ):
                
                def __init__( self, iter ):
                    self.iter = iter
                    try:
                        self.next = iter.next()
                    except:
                        self.next = None
                
                def hasMoreElements( self ):
                    if self.next: return True
                    else: return False
                    
                def nextElement( self ):
                    
                    try:
                        rt = self.next
                        self.next = iter.next()
                    finally:
                        return rt
            #rp = self.c.rootPosition()
            rp = self.getRootPosition()
            return _enum( rp.siblings_iter( copy = True ) )
            #return _enum( self.c.rootPosition.siblings_iter( copy = True ) )


#@-node:ekr.20060201150547.40:class ChapterModel
#@+node:ekr.20060201150547.41:class Chapter
class Chapter:
    
    def __init__( self ):
        
        self.root = None
        self.currentPosition = None
        self.tree = None
        self.name = None
        self.hoistStack = []
        self.undoer = None
        self.messaging = False
        
    def startMessaging( self ):
        self.messaging = True
    
    def isMessaging( self ):
        return self.messaging
        
    def doneMessaging( self ):
        self.messaging = False
        
    def isValid( self ):
        widget = self.tree.getWidget()
        if widget.getParent(): return True
        else:
            return False    
        
    def setUndoer( self, undoer ):
        self.undoer = undoer
        
    def getUndoer( self ):
        return self.undoer
        
    def getName( self ):
        return self.name
        
    def setName( self, name ):
        self.name = name
        
    
    def getTree( self ):
        return self.tree
        
    def setTree( self, tree ):
        self.tree = tree
    
    def setRootPosition( self, p ):
        if p:
            p = p.copy()
        self.root = p

    def getRootPosition( self ):
        p = self.root
        if p:
            p = p.copy()
        return p
    
    def setCurrentPosition( self, p ):
        if p:
            p = p.copy()        
        self.currentPosition = p
        
    
    def getCurrentPosition( self ):
        p = self.currentPosition
        if p:
            p = p.copy()
        return p
#@nonl
#@-node:ekr.20060201150547.41:class Chapter
#@+node:ekr.20060201150547.42:class SliderMessageButtons
class SliderMessageButtons( sevent.AncestorListener ):
    '''A class that manages creates a message with 0 to N buttons for
       the user to select.  After selecting the button, the slider is removed.
       After removal the function corresponding to the button is fired'''
       
    def __init__( self, message, buttons = (), direction = Slider.down, bgc = None, fgc = None ):
        
        self.backingpanel = swing.JPanel( awt.BorderLayout() )
        self.slider = Slider( self.backingpanel, direction )
        if fgc:
            lb = swing.border.LineBorder( fgc )
            self.backingpanel.setBorder( lb )
        else:
            lb = swing.border.LineBorder( self.backingpanel.getForeground() )
            self.backingpanel.setBorder( lb )
        jl = swing.JLabel( message )
        jl.setHorizontalAlignment( swing.SwingConstants.CENTER )
        self.backingpanel.add( jl )
        jp2 = swing.JPanel()
        self.func = None
        for z in buttons:
            label = z[ 0 ]
            func = z[ 1 ]
            b = swing.JButton( label )
            b.actionPerformed = lambda event, func = func: self.__removeCall( func )
            jp2.add( b )

        self.backingpanel.add( jp2, awt.BorderLayout.SOUTH )
        self.slider.setSize( self.slider.getPreferredSize() )
        if not fgc is None:
            self.backingpanel.setForeground( fgc )
            jp2.setForeground( fgc )
            jl.setForeground( fgc )
        if not bgc is None:
            self.backingpanel.setBackground( bgc )
            jp2.setBackground( bgc )
            jl.setBackground( bgc )
        
    def __removeCall( self, func ):
        self.slider.addAncestorListener( self )
        self.slider.startRemoving()
        self.func = func
        
    def ancestorAdded( self, event):
        pass
        
    def ancestorMoved( self, event ):
        pass
        
    def ancestorRemoved( self, event ):
        if not self.func is None:
            self.func()
        
    def getSlider( self ):
        return self.slider

#@-node:ekr.20060201150547.42:class SliderMessageButtons
#@+node:ekr.20060201150547.43:IconCloser
class IconCloser( swing.Icon, aevent.MouseAdapter ):
    
    def __init__( self, iicon, callback ):
        
        aevent.MouseAdapter.__init__( self )
        self.iicon = iicon
        self.component = None
        self.x = None
        self.y = None
        self.callback = callback
        
    def mousePressed( self, event ):
        
        if event.getButton() == event.BUTTON1:
            x = event.getX(); y = event.getY()
            rec = awt.Rectangle( self.x, self.y, self.iicon.getIconWidth(), self.iicon.getIconHeight() )
            if rec.contains( x,y ):
                self.component.removeMouseListener( self )
                self.component = None
                dc = DefCallable(self.callback)
                swing.SwingUtilities.invokeLater(dc.wrappedAsFutureTask())
        
    def getIconHeight( self ):
        
        return self.iicon.getIconHeight()
        
    def getIconWidth( self ):
        
        return self.iicon.getIconWidth()
        
    def paintIcon( self, jc, g, x, y ):
        
        if self.component == None:
            self.component = jc
            jc.addMouseListener( self )
        self.x = x
        self.y = y
        self.iicon.paintIcon( jc, g, x ,y )
        
#@nonl
#@-node:ekr.20060201150547.43:IconCloser
#@+node:ekr.20060201150547.44:iterators
@others
#@+node:ekr.20060201150547.45:chaptersIterator
def chaptersIterator( self ):

    if not self.chaptersIterationBlocked:
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            rp = chapter.getRootPosition()
            for z in rp.fromSelfAllNodes_iter( copy = True ):
                yield z
    else:
        
        for z in self.c.allNodes_iter( copy = 1 ):
            yield z            

                
#@-node:ekr.20060201150547.45:chaptersIterator
#@+node:ekr.20060201150547.46:topLevelSiblingsIterator
def topLevelSiblingsIterator( self, ):

    if not self.chaptersIterationBlocked:
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            rp = chapter.getRootPosition()
            for z in rp.self_and_siblings_iter( copy = True ):
                yield z
    else:
        rp = self.c.rootPosition()
        for z in rp.self_and_siblings_iter( copy = True ):
            yield z
            
#@-node:ekr.20060201150547.46:topLevelSiblingsIterator
#@+node:ekr.20060201150547.47:cycleThroughChapters
def cycleThroughChapters( self, swap = 1 ):

    if not self.chaptersIterationBlocked:
        current = self.current_chapter
        if swap: self.beginUpdate()
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for chapter in self.chapterlist:
            if swap:    
                self.current_chapter = chapter
            yield chapter
    
        self.current_chapter = current
        if swap: self.endUpdate()
    else:
        yield self.current_chapter
    
#@-node:ekr.20060201150547.47:cycleThroughChapters
#@-node:ekr.20060201150547.44:iterators
#@+node:ekr.20060201150547.48:Undo
@others
#@nonl
#@+node:ekr.20060201150547.49:UndoRemoveChapter
class UndoRemoveChapter( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter = chapter
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Remove Chapter %s" % self.chapter.name
    def getRedoPresentationName( self ): return "Redo Removing %s" % self.chapter.name
    def getUndoPresentationName( self ): return "Undo Removing %s" % self.chapter.name
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.quietRemoveChapter( self.chapter )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.insertChapter( self.chapter )
        self.undone = True
    
#@-node:ekr.20060201150547.49:UndoRemoveChapter
#@+node:ekr.20060201150547.50:UndoChangeChapterName
class UndoChangeChapterName( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter, name1, name2 ):
        self.chapters = chapters
        self.chapter = chapter
        self.name1 = name1
        self.name2 = name2
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Changing Chapter Name From %s to %s" % ( self.name1, self.name2 )
    def getRedoPresentationName( self ): return "Redo Changing Name From %s to %s" %  ( self.name1, self.name2 )
    def getUndoPresentationName( self ): return "Undo Changing Name From %s to %s" % ( self.name1, self.name2 )
    def isSignificant( self ): return True
    def redo( self ):
        
        book = self.chapters.book
        index = book.indexOfComponent( self.chapter.tree.getWidget() )
        book.setTitleAt( index, self.name2 )
        self.chapter.name = self.name2
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        book = self.chapters.book
        index = book.indexOfComponent( self.chapter.tree.getWidget() )
        book.setTitleAt( index, self.name1 )
        self.chapter.name = self.name1
        self.undone = True
#@-node:ekr.20060201150547.50:UndoChangeChapterName
#@+node:ekr.20060201150547.51:UndoAddChapter
class UndoAddChapter( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter = chapter
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Add Chapter"
    def getRedoPresentationName( self ): return "Redo Add Chapter"
    def getUndoPresentationName( self ): return "Undo Add Chapter"
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.insertChapter( self.chapter )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.quietRemoveChapter( self.chapter )
        self.undone = True
    
#@-node:ekr.20060201150547.51:UndoAddChapter
#@+node:ekr.20060201150547.52:UndoImport
class UndoImport( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter ):
        self.chapters = chapters
        self.chapter_list = []
        self.chapter_list.append( chapter )
        self.undone = False
    
    def addChapter( self, chapter ):
        self.chapter_list.append( chapter )
           
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Import Outline"
    def getRedoPresentationName( self ): return "Redo Import Outline"
    def getUndoPresentationName( self ): return "Undo Import Outline"
    def isSignificant( self ): return True
    def redo( self ):
        
        for z in self.chapter_list:
            self.chapters.insertChapter( z )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        for z in self.chapter_list:
            self.chapters.quietRemoveChapter( z )
        self.undone = True
    
#@-node:ekr.20060201150547.52:UndoImport
#@+node:ekr.20060201150547.53:UndoSwapChapters
class UndoSwapChapters( undo.UndoableEdit ):
    
    def __init__( self, chapters, chapter1, chapter2 ):
        self.chapters = chapters
        self.chapter1 = chapter1
        self.chapter2 = chapter2
        self.undone = False
        
    def addEdit( self, edit ): return False
    def canRedo( self ): return self.undone
    def canUndo( self ): return not self.undone
    def die( self ):
        self.chapters = None
        self.chapter = None
    def getPresentationName( self ): return "Undo Swap Chapters %s , %s" % ( self.chapter1.name, self.chapter2.name )
    def getRedoPresentationName( self ): return "Redo Swap Chapters %s, %s" % ( self.chapter1.name , self.chapter2.name )
    def getUndoPresentationName( self ): return "Undo Swap Chapters %s, %s" % ( self.chapter1.name , self.chapter2.name )
    def isSignificant( self ): return True
    def redo( self ):
        
        self.chapters.swapChapters( self.chapter1, self.chapter2, undo = False )
        self.undone = False
        
    def replaceEdit( self, edit ): return False
    def undo( self ):
        
        self.chapters.swapChapters( self.chapter1, self.chapter2, undo = False )
        self.undone = True
    
#@-node:ekr.20060201150547.53:UndoSwapChapters
#@-node:ekr.20060201150547.48:Undo
#@+node:ekr.20060201161901:(Important)
#@+node:ekr.20060201150547.7:markNodesForChapterization
def markNodesForChapterization( self ):

    if not self.chaptersIterationBlocked:    
        #for n in xrange( self.book.getTabCount() ):
        #    widget = self.book.getComponentAt( n )
        #    chapter = self.chapters[ widget ]
        for n in xrange( len(self.chapterlist)):
            chapter = self.chapterlist[ n ]
            rp = chapter.getRootPosition()
            rp_base = rp.copy()
            for z in rp.self_and_siblings_iter( copy = True ):
                v = z.v
                if not hasattr( v, "unknownAttributes" ):
                    v.unknownAttributes = {}
                v.unknownAttributes[ 'chapter' ] = n
                if z == rp_base:
                    v.unknownAttributes[ 'chapter_name' ] = chapter.name
    else:
        rp = self.getRootPosition()
        rp_base = rp.copy()
        for z in rp.self_and_siblings_iter( copy = True ):
            v = z.v
            if not hasattr( v, "unknownAttributs" ):
                v.unknownAttributes = {}
            v.unknownAttributes[ 'chapter' ] = 0
            if z == rp_base:
                v.unknownAttributes[ 'chapter_name' ] = self.current_chapter.name
#@nonl
#@-node:ekr.20060201150547.7:markNodesForChapterization
#@+node:ekr.20060201150547.29:transforming an Outline into Chapers components
@others
#@+node:ekr.20060201150547.30:deferedChaperization
def deferedChapterization (self,pos,selectchapter=None,edit=None):

    x = lambda: self.breakOutlineIntoChapters(pos,selectchapter,edit)
    dc = DefCallable(x)
    ft = dc.wrappedAsFutureTask()
    swing.SwingUtilities.invokeLater(ft)
#@nonl
#@-node:ekr.20060201150547.30:deferedChaperization
#@+node:ekr.20060201150547.31:breakOutlineIntoChapters
def breakOutlineIntoChapters( self, p, selectchapter = None, edit = None ):
    
    #self.loading = 1
    self.beginUpdate()
    #self.updateLock.unlock()
    n = 0 
    last_z = None
    p2 = p.copy()
    level_0 = []
    for z in p.self_and_siblings_iter( copy = True ):
        level_0.append( z )

    if level_0:
        p1 = level_0[ 0 ]
        v1 = p1.v
        if hasattr( v1, "unknownAttributes" ):
            uA = v1.unknownAttributes
            if uA.has_key( "chapter_name" ):
                name = uA[ 'chapter_name' ]
                i = self.book.getSelectedIndex()
                self.book.setTitleAt( i, name )
                if self.current_chapter: #This needs to be set here or its lost in the next save
                    self.current_chapter.name = name

    for z in level_0:
        v = z.v
        name = "New Chapter"
        if hasattr( v, "unknownAttributes" ):
            if v.unknownAttributes.has_key( "chapter" ):
                a_n = v.unknownAttributes[ "chapter" ]
            else:
                a_n = n
            if v.unknownAttributes.has_key( "chapter_name" ):
                name = v.unknownAttributes[ "chapter_name" ]
        else:
            a_n = n
   
        if a_n != n:
            #self.c.endUpdate()
            n = a_n
            #z.doDelete( p2 )
            z.unlink()
            tree = self.c.chapters.addChapter( name, z.copy() )
            widget = tree.getWidget()
            chapter = self.chapters[ widget ]
            self.c.frame.tree = chapter.tree
            self.current_chapter = chapter
            if edit and hasattr( edit, "addChapter" ):
                edit.addChapter( chapter )
            ic = self.IconCloser( self.icon, self.removeChapter )
            self.book.addTab( name, ic, widget )
            #self.book.addTab( name, widget )
            self.book.setSelectedComponent( widget )
            #self.c.beginUpdate()
            last_z = z
            z.linkAsRoot( None )
            tree.loaded = 1
            continue
        
        if last_z:
            #z.moveAfter( last_z )
            z.unlink() 
            z.linkAfter( last_z )
        last_z = z           
    
    if not selectchapter:
        selectchapter = self.book.getComponentAt( 0 )       
    self.book.setSelectedComponent( selectchapter )
    self.c.beginUpdate()
    self.c.endUpdate()       
    self.endUpdate()
#@nonl
#@-node:ekr.20060201150547.31:breakOutlineIntoChapters
#@-node:ekr.20060201150547.29:transforming an Outline into Chapers components
#@-node:ekr.20060201161901:(Important)
#@-node:ekr.20060201150547:Chapters
#@+node:ekr.20060201161901.1:Postings re undo
#@+node:ekr.20060201161901.2:@url http://sourceforge.net/forum/message.php?msg_id=3332355
@nocolor

By: Edward K. Ream - edream 
   RE: Dividing The Undo: doing w/o v.uA 
2005-09-09 14:17  
> If we can open up how [Leo] reads xml, it may make it simpler to start developing a stash scheme. 
 
I agree that reading xml more properly would be A Good Thing (tm). As we shall see, however, it is not the main issue. 
 
> DOM seems like a good path to start out on. 
 
This is not the path I would have chosen. The new colorizer at in leoPlugins.leo at: 
 
Plugins-->Experimental/unfinished-->New colorizer-->@thin __jEdit_colorizer__.py 
 
uses sax. I like the light-weight approach. I would rather do a bit more work in the initial parsing and create the data structures myself then relying on DOM. 
 
But parsing is irrelevant. The problem is the design of *thin* derived files and the code that reads such files. Let us consider how we can "do without" v.unknownAttributes in thin derived files. I **shall not** change the format of thin derived files, so some trickery is required. The first step is read this section of Leo's new docs: 
 
http://webpages.charter.net/edreamleo/customizing.html#adding-extensible-attributes-to-nodes-and-leo-files  /> 
The key here is the so-called 'hidden machinery'. This is an essential feature of the code that reads and writes thin derived files and it **will not** change. **Note**: Leo has two sets of read code: the code that reads .leo files has no trouble whatever recreating vnodes. It is only vnodes in thin derived files that may not have attributes. 
 
**Important**: for @thin trees (in the outline) Leo saves *only* the <v> element corresponding to the @thin node itself. It is this <v> element that contains the 'hidden machinery'. Don't even think about having Leo write the whole tree of <v> elements: the 4.0 read code is made possible because these <v> elements do *not* exist. This eliminates all the error 'recovery' schemes that can not, if fact, be robust enough. 
 
So the only real alternative is to add uA's sufficient to recreate elements in the *reconstituted* vnodes that Leo creates in the leoAtFile read logic. Happily, we can do this as follows. When writing, a plugin (or an extended Leo) would 'piggyback' the vnode attributes in the corresponding **t**.unknownAttributes field. When reading, the plugin (or Leo) would put the vnode attributes "where they belong" in the appropriate vnode. We associate a 'vnode traversal index' with each vnode. This is simply how many previous "same" vnodes appeared in the traversal before getting to the desired vnode. Something like this:: 
 
vx = {} # traversal indices for vnodes. 
for p in c.allNodes_iter(): 
....n = vx.get(p.v.t,0) # n is the traversal index for vnode p.v. 
....vx[p.v.t] = n+1 # bump the index for the next v such that v.t == p.v.t 
 
We store attributes for vnode v in v.t.unknownAttributes, along with the traversal index. The read code uses the traversal index to copy vnode attributes from t.unknownAttributes to v.unknownAttrutes. Rather than forcing each plugin to do this, Leo should probably have support for this in the leoFileCommands read/write code. In short, the t.unknownAttributes machinery suffices in theory, and in practice a bit of support code would be good. 
 
Glad you asked :-) . I have been willing to live without v.uA's in thin derived files. I never thought much about this until you asked, but necessity is the mother... So this is good. A way exists to treat all vnodes as first-class citizens. 
 
Edward 
#@-node:ekr.20060201161901.2:@url http://sourceforge.net/forum/message.php?msg_id=3332355
#@-node:ekr.20060201161901.1:Postings re undo
#@+node:ekr.20060201152349:NodeUndoer.py
@ignore

<<imports>>
#commanders = util.WeakHashMap()
commanders = {}


class NodeUndoer:
    '''A class that manages NodeUndoerBase instances for tnodes'''
    
    undoers = {} #util.WeakHashMap()
    checksums = util.WeakHashMap()
    
    def __init__( self, c, umenu, rmenu, gtnu, gtnr, vunstack, clearundo ):
        '''c -> a commander
           umenu -> a JMenuItem that is the 'undo' action
           rmenu -> a JMenuItem that is the 'redo' action
           gtnu -> a JMenuItem that is the 'goto next undo' action
           gtnr -> a JMenuItem that is the 'goto next redo' action
           vunstack -> a JMenuItem that is the 'visualise undo stack' action
           clearundo -> a JMenuItem that is the 'clear undo stack' action
        '''
        
        self.c = c
        self.umenu = umenu
        umenu.actionPerformed = lambda event: self.undo()
        self.rmenu = rmenu
        rmenu.actionPerformed = lambda event: self.redo()
        self.gtnu = gtnu
        gtnu.actionPerformed = lambda event: self.gotoNextUndoSpot()
        self.gtnr = gtnr
        gtnr.actionPerformed = lambda event : self.gotoNextRedoSpot()
        self.umanager = None
        self.vunstack = vunstack
        vunstack.actionPerformed = lambda event: self.visualiseUndoStack()
        self.clearundo = clearundo
        clearundo.actionPerformed = lambda event: self.clearUndo()
        self.ignore = 0
        self.tnode = None
        self.compound = None 
        self.checksums_ok = 1
        self.checksum_violations = []
        wm1 = WeakMethod( self, "serializeForLeoFile" ); wm2 = WeakMethod( self, "unserializeFromLeoFile" )
        wm3 = WeakMethod( self, "checkSumViolation" )
        leoPlugins.registerHandler( "write-leo-file-data", wm1 )
        leoPlugins.registerHandler( "read-leo-file-data", wm2 )
        leoPlugins.registerHandler( "checksum-violation", wm3 )
    
    def undo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.undo()
        self.setMenu()
        self.ignore = 0
        return
        
    def redo( self ):
        
        if self.ignore: return
        self.ignore = 1
        self.umanager.redo()
        self.setMenu()
        self.ignore = 0
        return
        
    
    def setNode( self, p ):
        
        #print "SETTING NODE!!! %s" % t
        #print "FILEINDEX %s" % t.fileIndex
        #java.lang.Thread.dumpStack()
        v = p.v
        t = v.t
        #vid = v.vid
        
        if self.tnode:
            self.checksums[ self.tnode ] = md5.md5( self.tnode.bodyString ).hexdigest()
        
        #if self.undoers.containsKey( t ):
        if self.undoers.has_key( v ):
            #print "CONTAINTS %s" % t
            ua = self.undoers[ v ]
            print "--!!!!!!-- %s" % v
            print ua.__class__
            if ua.__class__ == leoSwingUndo.UndoBase:
                self.umanager = self.undoers[ v ]
                #if self.checksums.containsKey( v ):
                #    checksum = self.checksums[ v ]
                #    amd5 = md5.md5( t.bodyString )
                #    if amd5.hexdigest() != checksum:
                #        self.umanager.discardAllEdits()
                #        g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                #        #self.tnode = t
                #        #return
                #for z in self.umanager.undostack:
                #    commanders[ z ] = self.c
            else:
                print "UNPICKLING!!!!!"
                ua = cPickle.loads( ua )
                print "UNPICKLED Is now %s %s" % ( ua, len( ua.undostack ) )
                self.undoers[ v ] = ua
                self.umanager = ua
            if self.checksums.containsKey( t ):
                checksum = self.checksums[ t ]
                amd5 = md5.md5( t.bodyString )
                if amd5.hexdigest() != checksum:
                    self.umanager.discardAllEdits()
                    print "DISCARDED EDITSS!!!!"
                    g.es( "Emptied undoer for %s:%s because of checksum mismatch" % ( t.headString, t ), color = "red" )
                    #self.tnode = t
                    #return
            for z in self.umanager.undostack:
                commanders[ z ] = self.c
                                    
        else:
            print "V not in Undoers %s" % v
            #print v.vid
            self.umanager = leoSwingUndo.UndoBase()
            self.undoers[ v ] = self.umanager

        self.tnode = t
        self.setMenu()
        
    def __addUndo( self, undo ):
        #self.umanager.addEdit( undo )
        self.umanager.addUndo( undo )
        #upe = self.UndoableProxyEvent( undo, self.umanager, self, self.c )
        #self.c.undoer.addUndo( upe )
        #die_listeners[ undo ] = upe
        
        
    def addUndo( self, undo ):
        
        if not self.ignore:
            
            if self.compound:
                self.compound.addEdit( undo )
                return
            
            self.__addUndo( undo )                
    
        self.setMenu()
            
    def setMenu( self ):
        
        self.umenu.setText( self.umanager.getUndoPresentationName() )
        self.umenu.setEnabled( self.umanager.canUndo() )
        if self.umanager.canUndo():
            self.gtnu.setEnabled( 1 )
        else:
            self.gtnu.setEnabled( 0 )
        self.rmenu.setText( self.umanager.getRedoPresentationName() )    
        self.rmenu.setEnabled( self.umanager.canRedo() ) 
        if self.umanager.canRedo():
            self.gtnr.setEnabled( 1 )
        else:
            self.gtnr.setEnabled( 0 )
        
        self.c.undoer.setMenu()
               
    
    
    def getUStack( self, tnode ):
            
        if hasattr( tnode, 'unknownAttributes' ):
            uas = tnode.unknownAttributes
        else:
            tnode.unknownAttributes = uas = {}
        
        return uas
        

    def clearUndo( self ):
        
        self.umanager.discardAllEdits()
        self.setMenu()
        
    def gotoNextUndoSpot( self ):
        
        ua = self.umanager.editToBeUndone()
        if ua:
            spot = ua.spot
            self.c.frame.body._current_editor.setCaretPosition( spot )
            return
            
    def gotoNextRedoSpot( self ):
        ua = self.umanager.editToBeRedone()
        if ua:
            spot = ua.spot
            self.c.frame.body._current_editor.setCaretPosition( spot )
            return

    @others
    

                    
<<UndoableDocumentEvent>>
<<UndoableCompoundEvent>>




#@+node:ekr.20060201152349.1:<<imports>>
import java
import java.util as util
import javax.swing as swing
import javax.swing.undo as sundo
import javax.swing.event as sevent
import java.io as io
import jarray
import md5
import org.python.util as putil
import NodeUndoerBase
import LeoCompoundEdit
import leoGlobals as g
import zlib
import leoSwingUndo
import leoPlugins
import leoNodes
import base64
import pickle
import cPickle
from utilities.WeakMethod import WeakMethod
#@nonl
#@-node:ekr.20060201152349.1:<<imports>>
#@+node:ekr.20060201152349.2:visualiseUndoStack
def visualiseUndoStack( self ):
    
    umanager = self.umanager            
    table = swing.JTable( self.UneditableTableModel() )#( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    table.setSelectionMode( swing.ListSelectionModel.SINGLE_SELECTION )
    self.setDataForTable( table )

    
    jd = swing.JDialog()
    jd.setTitle( "Undo Stack" )
    cp = jd.getContentPane()
    cp.add( swing.JScrollPane( table ) )
    bholder = swing.JPanel()
    cp.add( bholder, java.awt.BorderLayout.SOUTH )
    uto = swing.JButton( "Undo To" )
    bholder.add( uto )
    <<_undoTo>>
    uto.actionPerformed = _undoTo
    
    rto = swing.JButton( "Redo To" )
    bholder.add( rto )
    <<_redoTo>>
    rto.actionPerformed = _redoTo
    
        
    jb = swing.JButton( "Close" )
    jb.actionPerformed = lambda event : jd.dispose()
    bholder.add( jb )
    jd.pack()
    g.app.gui.center_dialog( jd )
    jd.setModal( 1 )
    jd.show()
    
    
#@+node:ekr.20060201152349.3:<<_undoTo>>
def _undoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canUndo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Undo To This Point", 
                                            "Illegal Undo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
    self.ignore = 1
    umanager.undoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
#@-node:ekr.20060201152349.3:<<_undoTo>>
#@+node:ekr.20060201152349.4:<<_redoTo>>
def _redoTo( event ):
    sr = table.getSelectedRow()
    if sr == -1:
        swing.JOptionPane.showMessageDialog( None,
                                            "No Selected Row",
                                            "Select A Row Please",
                                            swing.JOptionPane.INFORMATION_MESSAGE )
        return
    edits = umanager.getEdits()
    undo = edits.get( sr )
    if not undo.canRedo():
        swing.JOptionPane.showMessageDialog( None, 
                                            "Cant Redo To This Point", 
                                            "Illegal Redo Selection", 
                                            swing.JOptionPane.WARNING_MESSAGE )
        return
        
    self.ignore = 1
    umanager.redoTo( undo )
    self.ignore = 0
    self.setDataForTable( table )
    
#@-node:ekr.20060201152349.4:<<_redoTo>>
#@-node:ekr.20060201152349.2:visualiseUndoStack
#@+node:ekr.20060201152349.5:buildTableData
def buildTableData( self ):
    
    data = util.Vector()
    editu = self.umanager.editToBeUndone()
    editr = self.umanager.editToBeRedone()
    umanager = self.umanager
    cu = cr = -1
    edits = umanager.getEdits()
    for z in edits:
        if z.__class__ == LeoCompoundEdit:
            vec = java.util.Vector()
            edits2 = z.getEdits()
            spot = edits2[ 0 ].spot
            vec.add( spot )
            vec.add( "?" )
            vec.add( z.getPresentationName() )
            vec.add( "" )
        else:
            vec = z.getForTableModel()
            
        if z is editu:
            vec.set( 3, 'current undo' )
            cu = edits.indexOf( z )
        elif z.canUndo():
            vec.set( 3, 'undo' )
        if z is editr:
            vec.set( 3, 'current redo' )
            cr = edits.indexOf( z )
        elif z.canRedo():
            vec.set( 3, 'redo' )
        data.add( vec )
    
    return data, cu, cr


#@-node:ekr.20060201152349.5:buildTableData
#@+node:ekr.20060201152349.6:setDataForTable
def setDataForTable( self, table ):
    
    data, cu, cr = self.buildTableData()
    dm = table.getModel()
    dm.setDataVector( data, util.Vector( [ 'spot', 'data', 'action', 'redo/undo' ] ) )
    lsm = table.getSelectionModel()
    if cu != -1:
        lsm.setLeadSelectionIndex( cu )
    elif cr != -1:
        lsm.setLeadSelectionIndex( cr )
        
    
#@nonl
#@-node:ekr.20060201152349.6:setDataForTable
#@+node:ekr.20060201152349.7:pickle and unpickle
def serializeForLeoFile( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c:
        nwundoers = {}
        for z in self.undoers:
            if  self.undoers[ z ].__class__ == leoSwingUndo.UndoBase:
                nwundoers[ z.vid ] = cPickle.dumps( self.undoers[ z ] )
            else:
                nwundoers[ z.vid ] = self.undoers[ z ]
                
        store.addData( "tundoer", nwundoers ) #the storage class does the rest of the work for us
        

def unserializeFromLeoFile( self, tag, *args, **kwords ):

    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    store = args[ 0 ][ 'store' ]
    if c == self.c and self.checksums_ok:
        try:
            udata = store.getData( "tundoer" )
            if udata:
                for z in udata:
                    if leoNodes.vid_vnode.has_key( z ):
                        #print "A connection %s %s" % ( z, leoNodes.vid_vnode[ z ] )
                        v = leoNodes.vid_vnode[ z ]
                        self.undoers[ v ] = udata[ z ]

        except:
            self.undostack = []
            self.undopointer = 0

    if not self.checksums_ok:
        self.checksums_ok = 1
        self.checksum_violations = []
        self.undostack = []
        self.undopointer = 0
        
#@-node:ekr.20060201152349.7:pickle and unpickle
#@+node:ekr.20060201152349.8:checkSumViolation
def checkSumViolation( self, tag, *args, **kwords ):
    
    if not args[ 0 ].has_key( "c" ): return
    c = args[ 0 ][ 'c' ]
    filename = args[ 0 ][ 'filename' ]
    if c == self.c:
        self.checksums_ok = 0
        self.checksum_violations.append( filename )
#@nonl
#@-node:ekr.20060201152349.8:checkSumViolation
#@+node:ekr.20060201152349.9:startCompounding stopCompounding
def startCompounding( self, name ):
    self.compound = UndoableCompoundEvent( name )
    #self.compound = LeoCompoundEdit( name )
        
def stopCompounding( self ):
        
    compound = self.compound
    compound.end()
    self.compound = None
    #print "COMPOUND is %s" % compound
    self.__addUndo( compound )
    self.setMenu()
#@-node:ekr.20060201152349.9:startCompounding stopCompounding
#@+node:ekr.20060201152349.10:infrastructure
@others
#@nonl
#@+node:ekr.20060201152349.11:UneditableTableModel
class UneditableTableModel( swing.table.DefaultTableModel ):
    
    def __init__( self ):
        swing.table.DefaultTableModel.__init__( self )
        
    def isCellEditable( self, row, column ):
        return 0
        
#@-node:ekr.20060201152349.11:UneditableTableModel
#@+node:ekr.20060201152349.12:PickleProxy
class PickleProxy:
    '''This class exists to pickle the NodeUndoerBase instance into a form
       that can be safely stored in a Leo ua.'''
       
    def __init__( self, undoer, t ):
        self.undoer = undoer
        self.t = t
            
    def getPickleProxy( self ):
        
      
        try:
            #array = self.undoer.serializeSelf()
            data = pickle.dumps( self.undoer )
            ds = len( data )
            pp = zlib.compress( data, level = 9 )
            ps = len( pp )
            amd5 = md5.md5( self.t.bodyString )
            checksum = amd5.hexdigest()
            return pp, checksum 
        except Exception, x:
            return "", ""  
#@-node:ekr.20060201152349.12:PickleProxy
#@-node:ekr.20060201152349.10:infrastructure
#@+node:ekr.20060201152349.13:UndoableProxyEvent
class UndoableProxyEvent( sundo.UndoableEdit ):

       
    def __init__( self, event, owner, master , c):
        
        self.event = event
        self.owner = owner
        self.master = master
        self.c = c
        self.cp = c.currentPosition().copy()
        self._can_undo = event.canUndo()
        self._can_redo = event.canRedo()
        self.can_undo = self._can_undo
        self.can_redo = self._can_redo
        self.dieable = 0
        self.ignore = 0
        
    
    def __canRedo( self ):
        return self._can_redo == self.event.canRedo()
        
    def __canUndo( self ):
        return self._can_undo == self.event.canUndo()
            
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        #if self.__canUndo():
        return self.can_redo
        #else:
        #    return self.event.canRedo()
        
    def canUndo( self ):
        #if self.__canRedo():
        return self.can_undo
        #else:
        #    return self.event.canUndo()
        
    def isAlive( self ):
        return self.can_redo or self.can_undo
    
    def invalidate( self ):
        self.c.undoer.killFromEvent( self )
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
        #edits = self.owner.getEdits()
        #spot = edits.indexOf( self.event )
        #self.owner.trimEdits( spot, edits.size() )
    
        
    def getPresentationName( self ):
        return self.event.getPresentationName()
        
    def getRedoPresentationName( self ):
        
        if self.__canRedo():
            return self.event.getRedoPresentationName()
        elif self.isAlive():
            return "Expended %s" % self.event.getRedoPresentationName()
        else:
            return "Dead %s" % self.event.getRedoPresentationName()
        
    def getUndoPresentationName( self ):
        
        if self.__canUndo():
            return self.event.getUndoPresentationName()
        elif self.isAlive():
            return "Expended %s" % self.event.getUndoPresentationName()
        else:
            return "Dead %s" % self.event.getUndoPresentationName()
        
        
    def isSignificant( self ):
        return 1
    
    def sync( self ):
        self._can_redo = self.event.canRedo()
        self._can_undo = self.event.canUndo()
        
    def redo( self ):
        
        self.c.selectPosition( self.cp.copy() )
        self.can_redo = 0
        self.can_undo = 1
        if self.__canRedo():
            self.master.ignore = 1
            if not self.ignore:
                self.owner.redo()
            self.master.ignore = 0
            self.master.setMenu()
            
        self.sync()
            
        
    def undo( self ):
        
        self.c.selectPosition( self.cp.copy() )
        self.can_undo = 0
        self.can_redo = 1
        if self.__canUndo():
            self.master.ignore = 1
            if not self.ignore:
                self.owner.undo()
            self.master.ignore = 0
            self.master.setMenu()
            
        self.sync()
        
    def replaceEdit( self, edit ):
        return 0
        

#@-node:ekr.20060201152349.13:UndoableProxyEvent
#@+node:ekr.20060201152349.14:<<UndoableDocumentEvent>>
class UndoableDocumentEvent3:#( sundo.UndoableEdit, io.Serializable ):
    '''A class that takes the current Editors document and does undo changes
       upon the data within the Editor.  It is assumed that the data in the document
       will be in sync with the changes represented within the UndoableDocumentEvent'''
       
    def __init__( self, c, event, txt = "" ):
        
        commanders[ self ] = c
        self.spot = event.getOffset()
        self.length = event.getLength()
        self.txt = txt

        self.can_undo = 1
        self.can_redo = 0
        if self.txt.isspace():
           name_txt = "%s whitespaces" % len( self.txt )
        else:
           name_txt = self.txt
        
        if event.getType() == sevent.DocumentEvent.EventType.INSERT:
            self.etype = "insert"
        elif event.getType() == sevent.DocumentEvent.EventType.REMOVE:
            self.etype = "remove"

            
            
        if self.etype == "insert":
            self.name = "insert %s" % name_txt  
        elif self.etype == "remove":
            self.name = "remove %s" % name_txt
    
    #def __getstate__( self ):
    #    dic = self.__dict__
    #    import copy
    #    rv = copy.copy( dic )
    #    #del rv[ c ]
    #    return rv        
            
    def addEdit( self, edit ):
        return 0
        
    def canRedo( self ):
        return self.can_redo
        
    def canUndo( self ):
        
        return self.can_undo
        
    def die( self ):    
        self.can_undo = self.can_redo = 0
        #if die_listeners.has_key( self ):
        #    dlistener = die_listeners[ self ]
        #    if dlistener.dieable:
        #        print "WHACKING %s" % dlistener
        #        dlistener.invalidate()
    
        
    def getPresentationName( self ):
        return self.name 
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.name
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.name
        
    def isSignificant( self ):
        return 1
        
    def redo( self ):
        
        self.can_redo = 0
        self.can_undo = 1
        self.redoEvent()
        
    def undo( self ):
        
        self.can_undo = 0
        self.can_redo = 1
        self.undoEvent()
        
    def replaceEdit( self, edit ):
        return 0
        
    def redoEvent( self ):
        
        c = commanders.get( self )
        doc = c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            doc.insertString( self.spot, self.txt, None )
            return       
        elif self.etype == "remove":            
            doc.remove( self.spot, self.length )
            return    
        
    def undoEvent( self ):
        

        c = commanders.get( self )                
        doc = c.frame.body._current_editor.getDocument()
        if self.etype == "insert":
            print 'undoing spot %s %s %s' % ( self.spot, self.length, self.txt )
            doc.remove( self.spot, self.length )
            print 'undone %s' % self
            return  
        elif self.etype == "remove":
            doc.insertString( self.spot, self.txt, None )
            return 

    def getForTableModel( self ):
        return util.Vector( [ self.spot, self.txt, self.name, '' ] )
        


#@-node:ekr.20060201152349.14:<<UndoableDocumentEvent>>
#@+node:ekr.20060201152349.15:<<UndoableCompoundEvent>>
class UndoableCompoundEvent3:
    
    def __init__( self, pname ):
        #self.ce = sundo.CompoundEdit()
        self.pname = pname
        self.undostack = []
        self.can_undo = 1
        self.can_redo = 0
        
    def getPresentationName( self ):
        return self.pname
        
    def getRedoPresentationName( self ):
        return "Redo %s" % self.pname
        
    def getUndoPresentationName( self ):
        return "Undo %s" % self.pname
        
    def canUndo( self ):
        return self.can_undo
        #return self.ce.canUndo()
        
    def canRedo( self ):
        return self.can_redo
        #return self.ce.canRedo()
        
    def undo( self ):
        for z in self.undostack:
            print z
            z.undo()
        self.can_undo = 0
        self.can_redo = 1
        
    def redo( self ):
        
        self.undostack.reverse()
        for z in self.undostack:
            print z
            z.redo()
        
        self.undostack.reverse()
        self.can_undo = 1
        self.can_redo = 0
        
    def isSignificant( self ):
        return 1
        #return self.ce.isSignificant()
        
    def addEdit( self, edit ):
        self.undostack.insert( 0, edit )
        

    
    def die( self ):
        pass
        #return self.ce.die()
        
    def end( self ):
        pass
        #return self.ce.end()
        
        

            
        

#@-node:ekr.20060201152349.15:<<UndoableCompoundEvent>>
#@-node:ekr.20060201152349:NodeUndoer.py
#@-node:ekr.20051217175058:*Add chapters  to Leo's core & make positions permanent
#@+node:ekr.20060116074450.1:Bugs
# These are minor
#@nonl
#@+node:ekr.20051104152338:Fix bug in Remove Sentinels command
#@+node:ekr.20051104152338.1:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3413805
By: nobody

I thought this might be for 4.4a2, but I see the same effect w/ 
Leo 4.3.3, build  1.282 , September 17, 2005
Python 2.3.5, Tk 8.4.7, win32

I haven't used Leo for code, but just started to try to re-organize some Perl
I inherited.

Leo apears to remove sentinels, AND preceding newlines, so the effect is something
like this:

.... some code....

   next line;
}
#@verbatim
#@ leo sentinel here...
#

    If  ( something ) {
      more code;
......

becomes:

.... some code....

   next line;
} If  ( something ) {
      more code;
......

Now, that may be annoying, but mildly so - it still runs.
When this:

#
#@verbatim
#@ sentinel
if () {

turns to this:

# if() {

code just breaks.
#@nonl
#@-node:ekr.20051104152338.1:Report
#@-node:ekr.20051104152338:Fix bug in Remove Sentinels command
#@+node:ekr.20051014152256:Fix long-standing bug in import code
Improve import code so it handles stufff like this from Ipyton/iplib

### This should *not* terminate the function!

    self.LOGHEAD = Itpl(
"""#log# Automatic Logger file. *** THIS MUST BE THE FIRST LINE ***
#log# DO NOT CHANGE THIS LINE OR THE TWO BELOW
#log# opts = $self.rc.opts
#log# args = $self.rc.args
#log# It is safe to make manual edits below here.
#log#-----------------------------------------------------------------------
""")

- Handle blanks better in imports:
    - Add tab_width keyword arg to import command.
    - Convert tabs to blanks if tab width < 0.
- Ignore position of blank lines wrt sentinels.
- Ignore (optionally?) underindented blank lines.
- Use pyclbr to parse Python imports?
#@nonl
#@+node:ekr.20040930075711:Handle underindented lines
@nocolor

Leo can't represent some files using nodes!

I call this the "underindented blank line" problem.

Example:

@color

class aClass:
    def spam(): pass
# comment line
    def eggs(): pass
    
@nocolor

Leo's import code can't handle this:
    
- If the import code puts the comment line in a node, the line won't be output with the proper indentation!!

- Having the comment line stop the scanning of aClass is even worse.

- This usually shows up with an unindented blank line instead of the comment line.
#@nonl
#@-node:ekr.20040930075711:Handle underindented lines
#@+node:ekr.20040722132104:Write script to report underindented lines
#@-node:ekr.20040722132104:Write script to report underindented lines
#@-node:ekr.20051014152256:Fix long-standing bug in import code
#@+node:ekr.20060107082929:Fix problem reporting indentation errors
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3510448
By: ktenney

Howdy,

I'm executing a script in a Leo node which has
an indentation error. I get the following report,
which doesn't help locate the error.

Pardon me if this is well known issue, I don't
remember discussion of it.

Thanks,
Kent

################################################
exception executing script
Traceback (most recent call last):
  File "C:\python24\lib\site-packages\leo\src\leoCommands.py", line 1277, in
executeScript
    exec script in d
IndentationError: unindent does not match any outer indentation level (line
103)
--------------------
  line 1276:                     # g.trace(script)
* line 1277:                     exec script in d
  line 1278:                     if not script1 and not silent:
  line 1279:                         g.es("end of script",color="purple")

#@-node:ekr.20060107082929:Fix problem reporting indentation errors
#@-node:ekr.20060116074450.1:Bugs
#@+node:ekr.20060116073938.2:Other
#@+node:ekr.20060110102039:--script option
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3505544
By: nobody

this topic deserves another thread, rather 
than hijack the IPython one in the main forum.

presently Leo has a few options documented,
--script has a required parameter filename
batch mode also requires a filename.
why are they not documented in the same place?
why is batch mode option called --script?
is it too late to change to --batch ?

filenames in windows that have spaces will 
have to be quoted if they follow an option.
otherwise there will be no telling the filename
after a --script from a possibly 'file name.leo'

luckily, there was no need to force everyone 
on windows to quote leo names or use -fsome.leo,
especially when other options aren't used.
a little tricky, but I think it works.

the --script could as well load the leo itself
for that matter maybe all the args after --script 
should be assumed to be part of the scripts options
and Leo should only process up to the --script fname.
maybe there can be another option to collect
options for the script to batch process.
not necessary to decide now.

optparse can verify option parameters 
with callbacks. like does a filename exist,
is there enough free diskspace etc etc.
and provide a standard usage menu on exit.
rather than a roll your own wherever it happens.
I am not familiar enough with Leo startup to say
how is the best way to verify filenames or to
pass the filenames to run or set ivars.
import leoGlobals as I have might not be possible
this early in startup. need to get version info too.

leo -script whatever.py  error or not? typo? fixable?
leo --script whatever.py is ['script', 'whatever.py'] 
coming up with a comprehensive set of input args and
expected outcomes will be necessary for testing.
I'll do that next.

what about encoding problems, should check optparse archive.
what about py2.2 using optparse from 2.4? trust but verify.
this also has to be well tested.

--help -? or -h all work.
wasn't able to mimic the /help  /?
windows world method of option entry.
probably someone knows how.
hope its not a registry setting!

profile options might only be available if you
enter -xpert mode, to avoid confusing anyone who 
thinks they may need to run it because it is there.
and be removed from the help menu as well.

here is the proof of concept leomain.py,
all it does is process commandline args and 
print what command it will run or var it will set.
nothing is actually opened or run.

$ \c\py\python22\python leomain.py some.leo
run(some.leo)

$ \c\py\python22\python leomain.py some.leo -P
profile(leoProfile.txt,some.leo)

$ python leomain.py -profile=/tmp/proFile.txt my favorite.leo
profile(rofile=/tmp/proFile.txt,my favorite.leo)

woops! not sure how to guard against that.
verifing is valid creatable filename could help.
that should have been:

$ python leomain.py --profile=/tmp/proFile.txt my favorite.leo
profile(/tmp/proFile.txt,my favorite.leo)

$ python leomain.py --script some.py some.leo
script some.py
run(some.leo)

$ python leomain.py --script some.py
script some.py
run()

that's the basics.
needless to add, some of the code default 
choices and wording of help messages 
will have to be fine tuned. 
have at it.

post a note if something breaks.
I know of a few typos already.

[http://rclick.netfirms.com/leomain.py.htm]

e
#@+node:ekr.20060110102239.1:leomain.py
@color
"""  to run, add your path to leo below if not already set.

proposed modification to leo.py for hprof or hotshot profile 
giving standard help options from the commandline
and making additional options or combinations less work.

using optparse for commandline parsing
for py2.2 will use optik if installed, but not critical
requires copy of optparse.py from py2.4 in leo/extensions
no problem for py2.3+ already in the stdlib
this also need seperate testing, unittests to follow.

to use from command or shell window:
python leomain.py some args, see what happens.
nothing except print will happen, no open or file creation.
presently use a copy of sys.argv but that would be mutated.
if something is not obvious it should be fixed.


comments presently are interspersed throughout the file
will be collected and shortened as bugs are removed.
getting all options and filenames correctly is complicated
by the possibility of unicode or spaces in filenames.
some options require filenames for later processing in run()
and a leo may be specified or even more than one at some point
wildcard handling is not especially cross platform compatible.

want to make it possible to enter filenames w/o quoting
but will be impossible for now for batch & script option params.
they have to have quotes if there are spaces in the filenames on win.

also somewhat ambiguous, -sscript filename
will actually parse as --script cript filename
this could be a source of error and questions.
not sure if it can be avoided if there is to be longword args.

another point, -script is a possible typo to document at least.

a script like this could actually be some kind of leo launcher.
an option could popup a filedialog to get a leo, so it could in Leo.
or open the last leo that has been modified on the local filesystem.
as well as be a test bed for optparse & profile, read from ini file.
not dependant on changing leo.py, just import leo, then leo.run(fname)

for scripting, ability to set argv should be possible somehow.
maybe set sys.argv = [] before run

maybe just breeze through argv trying to concatenate filenames
then try to parse it. and let parseopts save a copy
later calls to parseopts w/o argv will use the saved attribute copy.
probably passing opts+args to run() is cleaner though.


this is the kind of merge that can give cvs merge a bad name, 
good luck!
leoGlobals and change of sys.path used only for testing.
import leoGlobals may not work for the real leo.py this early
before g.app is created. some refactoring is inevitable

why check for win before trying to make filename w/spaces?
does other os not have problem w/spaces in argv w/o quotes?
and why win32? is there no win64 in Leo's user base
or does it not have the space problem w/argv
are single and double quotes around filename the same for other os?
for windows they don't work like double quotes.


the order of parameters might have to be significant
but as it is, the.leo can appear anywhere
and on win, all unused args are joined with spaces just in case
if you do strange stuff possibly you get what you ask for.

does Leo try to find filename.leo if filename is sans the extension?
does it cause an overwrite existing file y/n/c or pass silently overwriting?

-d datadir might be useful if you want to have other than the some.leo same dir
-set somesetting=this like for outline bg color in script playback mode

if leo is started from another shell, argv[0] might not be python or might be
it could be IPython or something else, but there might be its args
as well as the program it started that started Leo
so really, argv should be [find(leo.py'):]
and for some associations or os, no .py or .pyw required
for that matter import leo; leo.run() bypasses option parsing altogether!
this is another problem now that I think of it...
but only if you also expected to get --script or some other option parsed
if you import leo you probably know what you are doing
you would have to set some global options, args I guess is what __main__ will do.
searching to cut back sys.argv for python or python.exe leo etc etc 
is bound to failure, too many cross platform possibilities.

__file__ can also be unreliable when started from py2exe or freeze or a zip

can't so far get /h (a default windows help option) to trigger --help.
seems like if there is no -h option defined, -hanything gets help
could be a source of typo errors 
if other longword no param option started w/'h' 
optparse doesn't handle word-otherword conversion to word_otherword
may be reading the doc wrong on that.
but will handle -sb scriptfile batchfile combining
says -s outfile equivalent to --script=outfile
but what about --script outfile?
carefully avoiding too much smart processing.


hopefully a test suite will expose any anomalies.
the default help output has a few more inconsistencies.
strange there are no bug reports about it in 2 years!
also want to give default values in help, maybe there is a %default

help gets cutoff at 80 chars, 79 according to a lone bugtrack entry
but that was for optparse, nd maybe its base0 counting.
maybe its still bug tracked as optik.sf.net, the original project name.

for future editors, and I sense there will be future edits,
if an individual help entry is longer than ~79 it will get formated ok.


see if we can avoid the ridiculous problem on win where on error
you get an exit and see nothing unless started from console!
source of some forum traffic as well.
maybe, if sys.platform etc: raw_input('press any key to exit')
and for pythonw maybe should popup an alert somehow...
one can dream.

proof of concept, still missing pasing args to run somehow
or seetting an ivar or whatever to get script/batchmode filenames
from main to where it is required. that should be easy enough.



filename is be mandatory for both and it should exist
its checked for batch in leo.py already so checking should be more generic
haven't looked up where --script is processed
didn't rewtrite getbatchfile or whatever its called.
that will be replaced with a check if tobatch has a filename
decide if optparse callback should check for valid existing file
and exit or continue accordingly.

and for an opposing view, if you are scripting leo from another script
then want to enter script mode or batch mode
what has to be available is to intercept the call to read the file.
and pass it a string of the script or batch, w/o problem.
a seperate function instead of hardwireing the read at least.



if I've forgotten anything please post a note to the forums.
beyond that, I don't know what to tell you.
this is proto typical alpha proof of concept pseudo code
although tested somewhat and worked as I expect it to,
it can't be expected to do everything unforseen as well.
and I can't be sure some transmission error hasn't occured.
hold me harmless or hit delete now.

"""

#replace w/Leo's real version assuming it can be known this early
#won't be much use if its leo.py's version
__version__ = '4.4a5' #w06104p01:34 optparse & profile for Leo

import sys, os

#####for testing use only, obviously don't add to leo.py
k = os.path.normpath(os.path.abspath(r"C:\c\leo\V43leos\leo-4-4-\src"))

#path being unicode can affect less than py2.3
if sys.version_info[:2] < (2, 3):
    k = str(k)

#might not be found in sys path on win9x, there is no unicode paths
if k not in sys.path:
    sys.path.append(k)
del k
#needed in profile()too
import leoGlobals as g


@others

#replace from here to end, sans comments
if __name__ == "__main__":


@

    #print os.environ #('IPYTHON') #thought they had this!
    #there is no IPY env var when @run is used -p shell?
    #for IPy need to trim sys.argv
    #sys.argv = sys.argv[2:]
@c


    #not the final configuration FIXME FIXME, danger will robinson
    leofile = None
    argvtight = []

    #going to have to decide to build OptionParser seperatly
    #before parsing so concatate can have access to it.
    #concatate() should be here but is problematic
    #needs to know too much about options.

    #no sense if there are no options or no args.
    #there are ways this can fail though probably rare 
    #dir name w/trailing space + filename leading minus sign
    #and have to decide if slash is ok for option indicator
    #assume no complains if not win argv[1] is ok
    if sys.argv > 1:
        if not [x for x in sys.argv if x[0] == '-']:  #in '-/'
            if sys.platform=="win32": # 
                leofile = ' '.join(sys.argv[1:])
            else:
                leofile = sys.argv[1]
        else:
            #just a test, don't trust it yet
            #may not even need it after all.
            #argvtight = concatate(sys.argv)
            argvtight = sys.argv[1:]
            #print 'concatate arg', argvtight

    #might have to add these to g.app or some kind of global?
    #they are needed in other parts of Leo before it completely starts
    #may need to pass to run and through profile into run as well.

    opts, args = parseopts(argvtight)

    if args and not leofile: leofile = ' '.join(args)
    elif args:
        print >> sys.stderr, 'too many args, try --help'
        #maybe print usage too? except its defined in parseopts
        raise SystemExit(2)

    #print 'past parse_args', `args`, 'leo=', `leofile`

    #for testing only, don't merge exactly
    if opts.tobatch:
        #w/filename hopefully w/o spaces
        print 'batch', opts.tobatch
    if opts.toscript:
        #w/filename hopefully w/o spaces
        print 'script', opts.toscript

    #assume run can get the options it needs at some later point
    #the profile run might require other options 
    #like print sorted stats report to file after exit
    #maybe delay start gathering for 20 seconds but continue

    #maybe should pass run a dict of the options 
    #rather than a static function attribute or global 
    #or just add to globals?

    if opts.toprofile:
        #will probably require filename arg
        #can take a leofile arg as well, default to ''
        #have to use keywords in case leofile is '' or drop coma
        #the actual call may be different, print is for ease of testing
        if leofile is None:  leofile = ''
        else:  leofile  = ','+ leofile
        #must be -P otherwise would be a string filename
        if opts.toprofile == True: opts.toprofile = 'leoProfile.txt'
        print 'profile(%s%s)'%(opts.toprofile, leofile)

    else:
        if leofile is None:  leofile = ''
        print 'run(%s)'%leofile


#e

#@+node:ekr.20060110102239.2:def profile
def profile (statfile='/tmp/leoProfile.txt', leofile= ''):
    
    """Gather and print statistics about Leo
    using new speedy hprof 
    http://www.planetsoc.com
    http://www.soton.ac.uk/~fb102/Python/hprof-0.1.0.tar.gz
    needs a blank __init__.py in the hprof dir

    or hotshot 
    even older profile if you want to go that far back
    add option to force profile, hotshot, hprof or lstat

    valid combined w/script or batch mode as well.
    
    may have the default args and calling sequence wrong
    refactored too much too fast with no time for testing
    should be easily fixed though. it did work yesterday!
    """

    #import profile, pstats
    try:
        from hprof.hprofile import Profile
    except ImportError:
        from hotshot import Profile

    import time

    start = time.time()
    #print "start %s seconds"%((start))


    prof = Profile(statfile)
    prof.run('run(%s)' % leofile)
    prof.close()

    stop = time.time()
    print 'Profile process ', statfile
    print "took %7.3f seconds"%((stop-start)),
    print "or %7.3f min"%((stop-start)/60)

    #skip the profile stats output after run
    #use scriptButton hprof in your work leo
    #may add option to generate stats after the run
#@-node:ekr.20060110102239.2:def profile
#@+node:ekr.20060110102239.3:def parseopts(argv)
def parseopts(argv):
    """  
    should verify leo.py is [0]? optparse ignores [:1] if no argv passed
    except as %prog  in usage help
    running test in commandline manually too, 
    maybe need a maintest.py based on optik unit tests?

    >>> import sys
    >>> print 'argv:',`sys.argv`
    'before sys set'
    >>> sys.argv = ["leo.py", "b", "b.txt"]
    >>> sys.argv = ["leo.py", "b", "-?"]
    >>> print 'argv:',`sys.argv`
    'after sys set'
    >>> parseopts(sys.argv)
    profile
    """    
    import leoGlobals as g
    try:
        #was the original name available for py2.2
        import optik as optparse
    except ImportError:
        #using py2.3+ optparse
        optparse = g.importExtension('optparse')

    #description is in addition to normal help
    #any way to get description to be the help w/o subclassing?
    #later can use parser.usage= '%prog [-h,-n etc  defaults: -c ]'
    
    #if a filename doesn't have leo extension is it assumed?
    #I think some of the comments are starting to repeat.
    #maybe come will get closer to the point of active choice
    #and I can delete the impostor comments.

    descript = 'Leo the python scriptable literate programming editor '
        
    #usage  and description mutually exclusive?
    #usage alone is printed on unknown option or maybe other error
    #no wrap in that case

    #getting this cross platform correct could be difficult
    #especially with variations in associations
    #and isn't and can't be complete wrt paths and pythonpath
    #maybe point to the webspace and docs is enough
    #.py not required for some , python not required for others
    #maybe no choice but to generate some os specific strings
    
    #doesn't mac also have pythonw and can we detect running under wine?
    #has to be some way of embedding \n 

    #-s file -sfile --script=file or --script file all the same?
    
    usage = r'''options [-s/--script scriptfile -b/--batch batchfile leofile]
        more options [-h, --help  and --version]
        problems: try quoting any filenames
        if there is still a problem: please report it with any details
   http://webpages.charter.net/edreamleo/front.html  Leo version %s'''% __version__

    #prog name assumed eventually to be leo.py
    if sys.platform[:3] == 'win':
        usage = 'python -i %%prog leofile.leo  no console pythonw leo.py'+ usage
    else:
        usage = 'python %%prog leofile.leo  -h or --help' + usage
        
    
    parser = optparse.OptionParser(version='%%prog %s' % __version__, 
                        description=descript, usage= usage)

    #how to require a filename? and how to specify it is possibly w/spaces
    #is -s:filename acceptable? that is a common arg convention.
    #ideally tobatch would be None or be the filename
    #and because of spaces con-cation will have to happen outside the parser

    #please comment out any options that are not implemented yet.

    for (l,w,a,t,d,f,h) in (

        # -help does work because its just -h, gets me every time!
        ('-?', '--hepl', "help", "", "", "",
            "help message"),

        ("-q", "--quiet", "store_true", "int", "verbose", 0,
            "don't print status or trace messages"),

        #    -script invalid option
        ("-s", "--script", "store", "string", "toscript", None,
            " script.py to run on startup"),

        ("-b", "--batch", "store", "string", "tobatch", None,
            "batch.py to run, no GUI"),

        #if validate callback for script & batch filename exists, 
        #could happen here if Leo is going to quit later anyway
        #and --safe may be mutually exclusive, confused -s being --script
        #so validate has to wait for parsing to complete, would it?

        #for profile filename is it valid? have permissions/disk space?
        #may want to force hotshot even if hprof or lprof installed
        #maybe only show these options if expert mode is on
        #no need to get a flood of forum reports about profile results
        #maybe leox.py has these options. oh, the possibilitiies.
        #this is for the 5 other people interested in this...
        #not something you want to do every day unless under duress.
        #combined with script and/or batch mode should be very powerful
        ("-p", "--profile", "store", "string", "toprofile", "",
            " save  profile results in outfile.ext       DEFAULT:\
            hprof or hotshot"),

        #a conflicting option repeat of -p won't work, so upcased it
        ("-P", "--Profile", "store_true", "", "toprofile", 0,
            " save  profile results in leoProfile.txt in the leo dir"),

        ):



        #add --settings add -home for change of home maybe -temp maybe -set
        #--settingsneeds leo/config as well as -home which one is germain


        if a == 'help':
            parser.add_option(l, w, action=a)

        elif a != 'store':
            parser.add_option(l, w, action=a,
                        dest= d, default= f, help= h )
        else:
            parser.add_option(l, w, action=a,
                type= t, dest= d, default= f, help= h )
#


@

    parser.add_option("--no-trace",action="store_false",
                  dest="trace", 
                  help="Don't print commands before executing them.") 


    #may want to subclass OptionParser to provide a Leo error exit

    #is there a generic way to check for / used as an option trigger?
    #is // even valid as a trigger
    

    #woops, if -h in argv a little too good
    #better not prevent -high 20 or something similar
    if '-h' in argv or '--help' in argv
           
    #for the win nubiee, / is the default win option starter
    #have to check every arg individually, py2.2 no substring in
    #definate bug that -? is not expected as help in optparse.
    #able to enter -? as an option though.
    
    #can't seem to get /h to trigger help
    for h in argv:
        for i in ('-?', '/help', '/h', '/?'):
            if i == h:
                #parser.error("does this help?")
                #parser.print_help()
                parser.print_usage()
                #print "didn't already exit!"
                raise SystemExit(2)
@c
                

    (opts, args) = parser.parse_args(argv)

    #can I just trap error: no such option: -? and set help=True

    return opts, args
#@nonl
#@-node:ekr.20060110102239.3:def parseopts(argv)
#@+node:ekr.20060110102239.4:concatate(sys.argv)
#### may have to skip this whole concatate thing ###
#please ignore the comments too
def concatate(argv, paramdict={}):
    """
    paramdict is a dict of single letter keys and
    item = [T/F, 'longname'] set [1] as True/False for require param
    
    walk the list concatate anything with a space
    to the previous item if it doesn't look like a valid option.
    what are the valid options? we don't care...
    is - s filename parseable as -s:filename ??
    this has got to have generated lots of point counterpoint over the years.
    should do some research... 
    have to decide if will accept / as option seperator or if optparse does
    this may not be doable if we alow options to also have spaces in filenames
    does optparse resolve -ffilename as well as -f:filenname the same?

    lets assume an options param can't have spaces, just get it working for now.
    if you enter an option you better quote it if you need to
    leave the space correcting behaviour for default or trailing filenames only
    
    now there is a problem need to know which oiptions have required params
    otherwise can't decide how to concate, unless the space was preserved (it isn't)
    I think on win or anywhere argv[n][0] is never going to be a space
    dito for argv[n][-1]
    so, its a simple FSM with 2 states, an option or a param
    cancel concatate space if previous was an option
    but here we go again, what about options that don't have params?
    optparse doc talks at length about options not having optional params.
    in Leo's case we may need to pass it a list of options that have no params?
    maybe optparse team needs to gix this not the module user
    maybe someone filed a patch already? more study!
    if not who is going to need optparse after this gets done?
    
    maybe just concatate all trailing args till an option, process backward
    its looking moore like a parser than a FSM now and I need to know too much.
    maybe assume all options have required params for now untill imp paramdict
    what about "-script=name, the doc implys that this may be valid?
    
    all validm but they don't mention -file=outfile, maybe is a typo missing -?
    <yourscript> -f outfile --quiet
    <yourscript> --quiet --file outfile
    <yourscript> -q -foutfile
    <yourscript> -qfoutfile
    damm, this is not going to even be worth trying
    seems -script == --script criptm 
    that could be confusing and error prone


    >>> concatate(['1','2','3'])
    ['1 2 3']
    >>> concatate(['-1','2','3'])  #rule option param can't have spaces
    ['-1', '2', '3']
    >>> concatate(['-s','2','3' '4']) #-s has required param
    ['-s', '2', '3 4']
    >>> # a little trickier -ffilename default arg, 
    >>> #optparse won't do this? getopt probably would,
    >>> concatate(['-1',' 2','3' '4'])
    ['-1', '2', '3 4']

    >>> #fix for extra credit, user probably screwed up? should ask them?
    >>> concatate(['1','- 2','3'])
    ['1', '- 2', '3']
    
    """

    #preparse sys.argv concating filenames w/spaces 
    #as appropriate for --script and --batch and any leofilename
    #or is this something parseopts should be doing?
    #not so simple really 
    #if argc ==1 then no options or filename
    #if any options start w/ - or / then it gets dicey
    # could be a space in the last part of a directory in seperate items
    #we may not be able to cover every concievable case
    
    prev = ''
    lst = []
    
    for x in argv:

        if x[0] == '-':  #or '/' or x in '/-'
            lst.append(x)
            if prev:
                lst.append(prev)
                prev = ''
        else:
            if prev: prev = prev + ' ' + x
            else:    prev = x
        
        #print 'droped thru x:prev', `x`, `prev`
    else:
        if prev:
            lst.append(prev)

    return lst
    

#@-node:ekr.20060110102239.4:concatate(sys.argv)
#@+node:ekr.20060110102239.5:test run manual
@
make into a real series of tests
I made the name leo\smain.py because my associateions for py are to open editor
so this could never run leo then open main.py even if I was in leo/src


$ python leo main.py
C:\C\PY\PYTHON~1\PYTHON.EXE: can't open file 'leo'

$ python "leo main.py"
past parse_args ['leo main.py']
leo.run()

$ python 'leo main.py'
C:\C\PY\PYTHON~1\PYTHON.EXE: can't open file ''leo'

$ python "leo main.py" filename
past parse_args ['leo main.py', 'filename']
leo.run()

$ python "leo main.py" c:/filename /help/some.leo
processed arg ['leo main.py', 'c:/filename', '/help/some.leo']
past parse_args ['leo main.py', 'c:/filename', '/help/some.leo']
leo.run()

$ python "leo main.py" "c:/filename /help/some.leo"
processed arg ['leo main.py', 'c:/filename /help/some.leo']
past parse_args ['leo main.py', 'c:/filename /help/some.leo']
leo.run()

$ python "leo main.py" "c:/filename /help/some.leo"
processed arg ['leo main.py', 'c:/filename /help/some.leo']
past parse_args ['leo main.py', 'c:/filename /help/some.leo'] leo= c:/filename /
help/some.leo
leo.run(c:/filename /help/some.leo)

$ python "leo main.py" c:/filename /help/some.leo
processed arg ['leo main.py', 'c:/filename', '/help/some.leo']
past parse_args ['leo main.py', 'c:/filename', '/help/some.leo'] leo= c:/filenam
e /help/some.leo
leo.run(c:/filename /help/some.leo)

-script works for --script cript it seems
and that could be a typo missing --script so the next filename
gets concatated into the leo name which I guess can't be helped

OTOH, if you use the default version=
then --versions works but -v or -version doesn't


$ \c\py\python24\python "leo main.py" test.leo -p whatever else
concatate arg ['test.leo', '-p', 'whatever', 'else']
past parse_args ['test.leo', 'else'] leo= 'test.leo else'
profile(whatever, test.leo else)
this is the thing that is still hard to avoid. on win, has to be
$ \c\py\python24\python "leo main.py" test.leo -p "whatever else"

really need to get this tested on other than old win9x,





@killcolor
#@-node:ekr.20060110102239.5:test run manual
#@+node:ekr.20060110102239.6:notes
@
will it handle spaces in filenames w/o quotes?

leo.py --script filename.leo is not good
leo.py -script filename is not good, which is it a scriptfile or a leo to be?

as error for -profile as an option, going to have to subclass override error
AttributeError Values instance has no attribute 'profile' ["__module__ = 'exceptions' .", "__doc__ = 'Attribute not found.' ."] 
this was a programmer error though, the var is toprofile

little hard to test this as a script, can't control argv
update, sys.argv = seems now to be working from doctest
better readup, haven't used this in a while
haven't read the docs in a while either, a good read.
especially the origional optik.sf.net


need to make this a function to call returning a dict maybe?
at least to doctest it better w/o needing to create a test module 
and then run it saving stdout

its also going to be a little trickier to --script or --batch with --profile
and what is exactly the difference with --batch and --script?
one has no GUI maybe?


- is valid in a filename, so primitive argv parsing
will be difficult to distinguish in a filename w./spaces
since the spaces cause seperate items and just a join
is not good because you have to know if it is a valid arg
what if it is a valid arg? this is a nightmare in any case...


need a timer on operations while getting a profile
expandall, contrract all so can be output with the pstats

need to set options in a seperate function
so can generate test for all functions and params on the fly
this will be good in the general case for other programs

anyone already depending on case insensitive args?

default file for profile not working out
comprimise -P as an option w/o param uses default leoProfile.txt

if -p file name -s some.py will be difficult to get right w/o quoting
will anyone ever expect a default? 
unless thats in the leodir or something?
dito for script and batch but what possible default could they have, 



does x is None work on py2.2?

#@-node:ekr.20060110102239.6:notes
#@-node:ekr.20060110102239.1:leomain.py
#@+node:ekr.20060110102239.7:Leo hprof script
@color
@
hprof from google summer of code replace hotshot & profile
much faster on the uptake and output!
has compatibility modules so can use mostly the same calls
this script uses the hprof calls. didn't mod leo.py yet
as I am not able to compile _hotshot.c to pyd or .so
it will use hotshot created profile ok.

added psyco, need to create batch file so can automate & timeit.
also have modified leoGlobals match and a few other things already
and proven You can shave at lest a few seconds overall,

can combine add more than one profile run to get better data
but I don;t do that in this script.

and pypy has lstat which also didn't compile for me
and possibly isn't windows compatible yet
along with another mentioned in this past weeks py-dev summary.


need something to compare the diff of 2 profiles
sorted the same way, something to add comments to the
profile, maybe a simple flatfile to manage profiling.
seems this would have been a project for someone already?

chg leo.py profile to create hotshot profile file
then run, copy a node from library
expand/contract a few times then exit.

takes a few minutes to process the hotshot file
then prints enormous amout of stats...
you see a few leoGlobals called a few hundred thousand times
on a run of 5 or 10 minutes.

        Stats('foo', 'goo').strip_dirs().sort_stats('calls').\
                            print_stats(5).print_callers(5)
              "calls"     : (((1,-1),              ), "call count"),
              "cumulative": (((3,-1),              ), "cumulative time"),
              "file"      : (((4, 1),              ), "file name"),
              "line"      : (((5, 1),              ), "line number"),
              "module"    : (((4, 1),              ), "file name"),
              "name"      : (((6, 1),              ), "function name"),
              "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
              "pcalls"    : (((0,-1),              ), "call count"),
              "stdname"   : (((7, 1),              ), "standard name"),
              "time"      : (((2,-1),              ), "internal time"),

@c
from dyna_menu import dtef
@others 

 
def showstats():
    """ log sort of stops printing when you type! or grab scrollbars.
    need to print to copybuffer, redirect io to log print very slow
    may actually be faster if you minimize leo
    also can make the log window very small
    in Leo4.4 you can multitask a little when it starts to print.
    """
    import leoGlobals as g
    #import profile, pstats
    try:
        from hprof.hpstats import Stats
    except ImportError:
        from hotshot import Stats
    import sys
    
    name = "/tmp/leoProfile.txt"
    print 'processing ', name

    #profile.run('leo.run()',name)
    #prof = hotshot.Profile(name)
    #prof.runcall(run)
    #prof.close()

    #p = pstats.Stats(name)
    #p.strip_dirs()
    #p.sort_stats('cum','file','name')
    #p.print_stats()

    
    #would be nicer if strip_dirs left one more level of dir
    #or even better took an int to leave how many levels
    #several modules have similar def names, __init__ etc
    #will have to override that.
    
    s = Stats(name).strip_dirs()

    #need to reverse or trap stdout to file    
    #why does g. not have a simple command to do this?
    #whydoes stats.print not take a filename? 
    #weird no one thinks of these things. is it just me?

#    sys.stdout = g.fileLikeObject()
    
    print 'start.sort', dtef(c),
    s.sort_stats("time").print_stats()  #.print_callers()
@
    stat = sys.stdout.get()
    sys.stdout.close()
    sys.stdout = sys.__stdout__

    #attempt to get a better strip_dirs later
    for k,v in repdict.iteritems():
        stat = stat.replace(k,v)
    print stat[:400]
@c    

print 'start', dtef(c),
showstats()
print 'done', dtef(c)
#@nonl
#@+node:ekr.20060110102239.8:try: psyco
try:
    if 1:#1/0  If present, use psyco to accelerate the program
        import psyco
        psyco.full()  #carefull with this in py2.3 esp w/leo 
        #shows alot of time in tkinter and other plain leo routines!
        #though this was per module only 
        #from psyco.classes import *

        #psyco.log(logfile='c:/temp/sb1.log', mode='w', top=30)
        #psyco.profile(0.2)
        #psyco.profile( watermark=0.09, halflife=0.5, pollfreq=20,  parentframe=0.25, memory=None, time=None, memorymax=None, timemax=None) 
        #psyco.bind(searchButton) #not in scope, put after def
        #psyco.bind(gen_nodes)  #generators 
except ImportError: pass
#@-node:ekr.20060110102239.8:try: psyco
#@-node:ekr.20060110102239.7:Leo hprof script
#@-node:ekr.20060110102039:--script option
#@+node:ekr.20060111134004:Run Idle in a separate process
#@+node:ekr.20060111103821:This would fix weird crasher in Plugins Manager plugin
#@+node:ekr.20060111103821.1:Report
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3517023
By: ktenney

W2K, recent CVS (Sourceforge is asking for a
passwords and refusing to let me update)

Window - Open Python Window

Close the Python Window

Plugins - Core - Plugin Manager causes traceback;

exception executing command
Traceback (most recent call last):
  File "C:\python24\lib\site-packages\leo\src\leoCommands.py", line 238, in
doCommand
    val = command()
  File "C:\python24\lib\site-packages\leo\plugins\plugins_menu.py", line 548,
in callback
    p.hastoplevel()
  File "C:\python24\lib\site-packages\leo\plugins\plugin_manager.py", line 231,
in topLevelMenu
    dlg = ManagerDialog(True)
  File "C:\python24\lib\site-packages\leo\plugins\plugin_manager.py", line 777,
in __init__
    self.plugin_view = PluginView(self.upper, self.file_text)
  File "C:\python24\lib\site-packages\leo\plugins\plugin_manager.py", line 282,
in __init__
    labelpos = 'w',label_text = 'Name:')
  File "C:\Python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwEntryField.py", line
73, in __init__
    sequences = root.bind_class(tag)
AttributeError: 'NoneType' object has no attribute 'bind_class'
#@-node:ekr.20060111103821.1:Report
#@-node:ekr.20060111103821:This would fix weird crasher in Plugins Manager plugin
#@+node:ekr.20060111134004.1:Posting
Leo's Open Python Window command should take care to run Idle in a separate process.

The present code is essentially:

import idlelib.PyShell
idlelib.PyShell.main()

As the present problems with the Plugins manager show, this has the potential for mischief.  Indeed, idle is a Tkinter process, so Idle's shutdown code could interfere with Tkinter, Pmw, g.app or all three.

It's no good blaming Pmw or Idle or whatever, there needs to be a solid way of avoiding problems, both now and in the future.  The obvious way is to use os.system or subprocess to keep Idle at arm's length.  If necessary we can use settings in leoSettings.leo to tell Leo exactly how to start Idle.
#@nonl
#@-node:ekr.20060111134004.1:Posting
#@+node:ekr.20031218072017.2932:openPythonWindow (Dave Hein)
def openPythonWindow (self,event=None):

    if sys.platform == "linux2":
        << open idle in Linux >>
    else:
        << open idle in Windows >>
#@+node:ekr.20031218072017.2933:<< open idle in Linux >>
# 09-SEP-2002 DHEIN: Open Python window under linux

try:
    pathToLeo = g.os_path_join(g.app.loadDir,"leo.py")
    sys.argv = [pathToLeo]
    from idlelib import idle
    if g.app.idle_imported:
        reload(idle)
    g.app.idle_imported = True
except:
    try:
        g.es("idlelib could not be imported.")
        g.es("Probably IDLE is not installed.")
        g.es("Run Tools/idle/setup.py to build idlelib.")
        g.es("Can not import idle")
        g.es_exception() # This can fail!!
    except: pass
#@-node:ekr.20031218072017.2933:<< open idle in Linux >>
#@+node:ekr.20031218072017.2934:<< open idle in Windows >>
# Initialize argv: the -t option sets the title of the Idle interp window.
sys.argv = ["leo"] # ,"-t","Leo"]

ok = False
if g.CheckVersion(sys.version,"2.3"):
    << Try to open idle in Python 2.3 systems >>
else:
    << Try to open idle in Python 2.2 systems >>

if not ok:
    g.es("Can not import idle")
    if idle_dir and idle_dir not in sys.path:
        g.es("Please add '%s' to sys.path" % idle_dir)
#@nonl
#@+node:ekr.20031218072017.2936:<< Try to open idle in Python 2.3 systems >>
try:
    idle_dir = None
    
    import idlelib.PyShell

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    idlelib.PyShell.main()
    ok = True

except:
    ok = False
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2936:<< Try to open idle in Python 2.3 systems >>
#@+node:ekr.20031218072017.2935:<< Try to open idle in Python 2.2 systems>>
try:
    executable_dir = g.os_path_dirname(sys.executable)
    idle_dir = g.os_path_join(executable_dir,"Tools","idle")

    # 1/29/04: sys.path doesn't handle unicode in 2.2.
    idle_dir = str(idle_dir) # May throw an exception.

    # 1/29/04: must add idle_dir to sys.path even when using importFromPath.
    if idle_dir not in sys.path:
        sys.path.insert(0,idle_dir)

    if 1:
        import PyShell
    else: # Works, but is not better than import.
        PyShell = g.importFromPath("PyShell",idle_dir)

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    if 1: # Mostly works, but causes problems when opening other .leo files.
        PyShell.main()
    else: # Doesn't work: destroys all of Leo when Idle closes.
        self.leoPyShellMain()
    ok = True
except ImportError:
    ok = False
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2935:<< Try to open idle in Python 2.2 systems>>
#@-node:ekr.20031218072017.2934:<< open idle in Windows >>
#@+node:ekr.20031218072017.2937:leoPyShellMain
@ The key parts of Pyshell.main(), but using Leo's root window instead of a new Tk root window.

This does _not_ work well.  Using Leo's root window means that Idle will shut down Leo without warning when the Idle window is closed!
@c

def leoPyShellMain(self):
    
    import PyShell
    root = g.app.root
    PyShell.fixwordbreaks(root)
    flist = PyShell.PyShellFileList(root)
    shell = PyShell.PyShell(flist)
    flist.pyshell = shell
    shell.begin()
#@nonl
#@-node:ekr.20031218072017.2937:leoPyShellMain
#@-node:ekr.20031218072017.2932:openPythonWindow (Dave Hein)
#@-node:ekr.20060111134004:Run Idle in a separate process
#@+node:ekr.20051012062458.1:Strip quotes from color, font settings.
- 

- 
#@nonl
#@-node:ekr.20051012062458.1:Strip quotes from color, font settings.
#@+node:ekr.20060116074450.3:Put about dialog in a tab?
#@-node:ekr.20060116074450.3:Put about dialog in a tab?
#@+node:ekr.20051112080017:Problem removing script buttons on the mac
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3423121
By: nobody

Hi! I need help removing script buttons. It says I should right click the ofending
button. I have a mac and Ctl-click, Command-click, etc doesn't work. What should
I do?

EKR: This is on the list of unfixable bugs, but I have a hard time believing there is no workaround.
#@nonl
#@-node:ekr.20051112080017:Problem removing script buttons on the mac
#@+node:ekr.20051110155735.1:Improve Spell tab
@nocolor

- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.

@color
#@nonl
#@+node:ekr.20051025071455:Spell classes (ok)
@others
#@+node:ekr.20051025071455.6:class Aspell
class Aspell:
    
    """A wrapper class for Aspell spell checker"""
    
    @others

#@+node:ekr.20051025071455.7:Birth & death
#@+node:ekr.20051025071455.8:__init__
def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = c.config.getString('aspell_dir')
    self.aspell_bin_dir = c.config.getString('aspell_bin_dir')

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=__name__,verbose=True)
        
    self.aspell = aspell
    if aspell:
        self.sc = aspell.spell_checker(prefix=self.aspell_dir,lang=local_language_code)
        self.local_language_code = local_language_code
        self.local_dictionary_file = local_dictionary_file
        self.local_dictionary = "%s.wl" % os.path.splitext(local_dictionary_file) [0]
#@nonl
#@-node:ekr.20051025071455.8:__init__
#@-node:ekr.20051025071455.7:Birth & death
#@+node:ekr.20051025071455.10:processWord
def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    & original count offset: miss, miss, ... 
    None: 
    # original offset 
    simplifyed to not create the string then make a list from it    
    """

    if self.sc.check(word):
        return None
    else:
        return self.sc.suggest(word)
#@nonl
#@-node:ekr.20051025071455.10:processWord
#@+node:ekr.20051025071455.11:updateDictionary
def updateDictionary(self):

    """Update the aspell dictionary from a list of words.
    
    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl < %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False
#@nonl
#@-node:ekr.20051025071455.11:updateDictionary
#@-node:ekr.20051025071455.6:class Aspell
#@+node:ekr.20051025071455.1:class spellCommandsClass
class spellCommandsClass (baseEditCommandsClass):
    
    '''Commands to support the Spell Tab.'''

    @others
#@nonl
#@+node:ekr.20051025080056:ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.handler = None
    
    # All the work happens when we first open the frame.
#@nonl
#@-node:ekr.20051025080056:ctor
#@+node:ekr.20051025080420:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):
    
    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
#@nonl
#@-node:ekr.20051025080420:getPublicCommands (searchCommandsClass)
#@+node:ekr.20051025080633:openSpellTab
def openSpellTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.handler = spellTab(c,f)
        
    self.handler.bringToFront()
#@nonl
#@-node:ekr.20051025080633:openSpellTab
#@+node:ekr.20051025080420.1:commands...
# Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()
        
def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
#@nonl
#@-node:ekr.20051025080420.1:commands...
#@-node:ekr.20051025071455.1:class spellCommandsClass
#@+node:ekr.20051025071455.18:class spellTab (leoFind.leoFind)
class spellTab(leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others
#@nonl
#@+node:ekr.20051025071455.19:Birth & death
#@+node:ekr.20051025071455.20:spellTab.__init__
def __init__(self,c,parentFrame):
    
    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = Tk.Text(None) # A text widget for scanning.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.createSpellTab(parentFrame)
        self.createBindings()
#@nonl
#@-node:ekr.20051025071455.20:spellTab.__init__
#@+node:ekr.20051025094004:init_aspell
def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = Aspell(c,dictionaryFileName,self.local_language_code)
    
    if not self.aspell.aspell:
        g.es_print('Can not open Aspell',color='red')
        return False
        
    self.dictionary = self.readDictionary(dictionaryFileName)
    return True
#@-node:ekr.20051025094004:init_aspell
#@+node:ekr.20051025071455.22:createSpellTab
def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    << Create the outer frames >>
    << Create the text and suggestion panes >>
    << Create the spelling buttons >>
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
    
    self.fillbox([])
    self.listBox.bind("<Double-1>",self.onChangeThenFindButton)
    self.listBox.bind("<Button-1>",self.onSelectListBox)
    self.listBox.bind("<Map>",self.onMap)
#@nonl
#@+node:ekr.20051113090322:<< Create the outer frames >>
self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
#@nonl
#@-node:ekr.20051113090322:<< Create the outer frames >>
#@+node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
#@nonl
#@-node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
#@+node:ekr.20051025071455.24:<< Create the spelling buttons >>
# Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
#@nonl
#@-node:ekr.20051025071455.24:<< Create the spelling buttons >>
#@-node:ekr.20051025071455.22:createSpellTab
#@+node:ekr.20051025120920:createBindings (spellTab)
def createBindings (self):
    
    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
           
#@nonl
#@-node:ekr.20051025120920:createBindings (spellTab)
#@+node:ekr.20051025071455.16:readDictionary
def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
#@nonl
#@-node:ekr.20051025071455.16:readDictionary
#@-node:ekr.20051025071455.19:Birth & death
#@+node:ekr.20051025071455.29:Buttons
#@+node:ekr.20051025071455.30:onAddButton
def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()
#@nonl
#@-node:ekr.20051025071455.30:onAddButton
#@+node:ekr.20051025071455.31:onIgnoreButton
def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()
#@nonl
#@-node:ekr.20051025071455.31:onIgnoreButton
#@+node:ekr.20051025071455.32:onChangeButton & onChangeThenFindButton
def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.change()
    self.updateButtons()
    

def onChangeThenFindButton(self,event=None):
    
    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.change():
        self.find()
    self.updateButtons()
#@-node:ekr.20051025071455.32:onChangeButton & onChangeThenFindButton
#@+node:ekr.20051025071455.33:onFindButton
def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    c = self.c
    self.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocusNow()
#@nonl
#@-node:ekr.20051025071455.33:onFindButton
#@+node:ekr.20051025071455.34:onHideButton
def onHideButton(self):
    
    """Handle a click in the Hide button in the Spell tab."""
    
    self.hide()
#@nonl
#@-node:ekr.20051025071455.34:onHideButton
#@-node:ekr.20051025071455.29:Buttons
#@+node:ekr.20051025071455.36:Commands
#@+node:ekr.20051025071455.37:add
def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()
#@nonl
#@-node:ekr.20051025071455.37:add
#@+node:ekr.20051025071455.38:change
def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; t = body.bodyCtrl
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = g.app.gui.getTextSelection(t)
        if start:
            if t.compare(start, ">", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            g.app.gui.setTextSelection(t,start,start + "+%dc" % (len(selection)))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
#@nonl
#@-node:ekr.20051025071455.38:change
#@+node:ekr.20051025071455.40:find
def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; bodyCtrl = body.bodyCtrl

    # Reload the work pane from the present node.
    s = bodyCtrl.get("1.0","end").rstrip()
    self.workCtrl.delete("1.0","end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = bodyCtrl.index("insert")
    self.workCtrl.mark_set("insert",ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Copy the working selection range to the body pane
        start, end = g.app.gui.getTextSelection(self.workCtrl)
        g.app.gui.setTextSelection(bodyCtrl,start,end)
        bodyCtrl.see(start)
    else:
        g.es("no more misspellings")
        self.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
#@nonl
#@-node:ekr.20051025071455.40:find
#@+node:ekr.20051025121408:hide
def hide (self,event=None):
    
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []
#@nonl
#@-node:ekr.20051025121408:hide
#@+node:ekr.20051025071455.41:ignore
def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()
#@nonl
#@-node:ekr.20051025071455.41:ignore
#@-node:ekr.20051025071455.36:Commands
#@+node:ekr.20051025071455.42:Helpers
#@+node:ekr.20051025071455.43:bringToFront
def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')
#@nonl
#@-node:ekr.20051025071455.43:bringToFront
#@+node:ekr.20051025071455.44:fillbox
def fillbox(self, alts, word=None):
    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1) 

#@-node:ekr.20051025071455.44:fillbox
#@+node:ekr.20051025071455.45:findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            << Skip word if ignored or in local dictionary >>
            alts = aspell.processWord(word)
            if alts:
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                break
    except:
        g.es_exception()
    return alts, word
#@nonl
#@+node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
#@nonl
#@-node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
#@-node:ekr.20051025071455.45:findNextMisspelledWord
#@+node:ekr.20051025071455.47:findNextWord
# Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    # This breaks words at non-ascii 'letters' such as .  I don't know what the solution is.
    word_start = string.letters
    word_end   = string.letters + string.digits
    word_chars = string.letters + string.digits + "`" + "'" + "_"
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # g.trace(repr(line))
        # Start the word at the first letter.
        i = 0
        while i < len(line) and line[i] not in word_start:
            i += 1
        if i < len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j < len(line) and line[j] in word_chars:
                j += 1
            word = line[i:j]
            while word and word[-1] not in word_end:
                word = word[:-1]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert",">=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.
#@nonl
#@-node:ekr.20051025071455.47:findNextWord
#@+node:ekr.20051025071455.48:getSuggestion
def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
#@nonl
#@-node:ekr.20051025071455.48:getSuggestion
#@+node:ekr.20051025071455.49:onMap
def onMap (self, event=None):
    """Respond to a Tk <Map> event."""
    
    self.update(show= False, fill= False)
#@nonl
#@-node:ekr.20051025071455.49:onMap
#@+node:ekr.20051025071455.50:onSelectListBox
def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    c = self.c
    self.updateButtons()
    c.bodyWantsFocus()
#@-node:ekr.20051025071455.50:onSelectListBox
#@+node:ekr.20051025071455.51:update
def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    c = self.c
    
    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.bodyWantsFocus()
#@nonl
#@-node:ekr.20051025071455.51:update
#@+node:ekr.20051025071455.52:updateButtons
def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c

    start, end = g.app.gui.getTextSelection(c.frame.body.bodyCtrl)
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
#@nonl
#@-node:ekr.20051025071455.52:updateButtons
#@-node:ekr.20051025071455.42:Helpers
#@-node:ekr.20051025071455.18:class spellTab (leoFind.leoFind)
#@-node:ekr.20051025071455:Spell classes (ok)
#@-node:ekr.20051110155735.1:Improve Spell tab
#@+node:ekr.20060103101524:Improve command-line handling
@nocolor
https://sourceforge.net/forum/message.php?msg_id=3501995
By: nobody

::But I don't understand why it's difficult to edit leoSettings.leo

--safe would use default settings,
maybe you set all body fg/bg to the same color
by mistake and you don't have a backup leoSettings to use. as a dumb example.

another nice option would be to override a setting
--set something=whatever
this could breakdown easy and on (older?) windows.
there is a limit to how many chars on a command line.
this would add another layer of choice
yet another chicken egg problem, 
parsing settings before settings can be parsed.

what about override @settings file, its a standard thing.
many people will expect this is possible 
and try it
or even leo.py -? 
help you get for free w/optparse.
--keys emacs anyone? 
especially the first time
untill you can get a chance to edit leoSettings.leo

I have already started enabling optparse
for leo.py so I can try various profile options.
I will post it when it works.

have to check how it handles filenames with spaces
seems that is all Leo is currently doing 
with multiple args, if there is no problem.
and later checking for -batch -script etc.

not to minimize how much work this would be.
parsing options is probably the least difficult part.

e
#@nonl
#@-node:ekr.20060103101524:Improve command-line handling
#@+node:ekr.20050713105353:Add configuration setting to set menu fonts
#@+node:ekr.20050713105353.1:Email from Martin Moncrieffe <mcm35@cam.ac.uk>
@nocolor

I have looked into leo's code and managed to figure out how to change 
some fonts. Here's what I did to change the menu fonts for example.

Fonts for the menu can be set in Code->Gui Tkinter classes->@thin 
leoTkinterMenu.py->Tkinter menu bindings->Routines with Tk 
spellings->new_menu

so to use the system font (linux) I changed the return statement to:

return Tk.Menu(parent,tearoff=tearoff, font=("System",11))

I'll try using .leo_xresources file and see if that works as well.
#@nonl
#@-node:ekr.20050713105353.1:Email from Martin Moncrieffe <mcm35@cam.ac.uk>
#@-node:ekr.20050713105353:Add configuration setting to set menu fonts
#@+node:ekr.20050512031131:Use global_log_window_position to specify outline/log ratio?
#@-node:ekr.20050512031131:Use global_log_window_position to specify outline/log ratio?
#@+node:ekr.20051016155819:treat plugins/options.py  differently?
#@-node:ekr.20051016155819:treat plugins/options.py  differently?
#@+node:ekr.20060102092148.1:--safe option
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3501193
By: nobody

::improving how Leo handle's arguments? 

Leo only needs a few simple options.
I don't think option handling would
work correctly in the IPYthon case either.

put optparse.py in leo/extensions for py2.2
docutils installs it if it isn't available.
its been the standard since py2.3
adding new options will be much less painfull.
some kind of --safe startup to allow editing
of leoSettings.leo, no @buttons or @scripts
might be a good thing.

Leo should allow scripts to set sys.argv for
commands they create. its very difficult to do now.

e
#@nonl
#@-node:ekr.20060102092148.1:--safe option
#@-node:ekr.20060116073938.2:Other
#@-node:ekr.20060116073229:To do 4.4.1
#@+node:ekr.20051023192433:Maybe or never
#@+node:ekr.20060111103821.2:Fix problems with universalScrolling pluing
#@+node:ekr.20060111103821.3:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3517180
By: rich_ries

With Universal Scrolling, the Right mouse button works (scrolls up) but the
Left mouse button (scroll down) does not. (Yes, I made sure I had a Leo file
I could scroll up/down in.)

--Rich
P.S. -- Is there any way for the "select-node-on-mouse-click" feature to be
disabled during scrolling? When I'm scrolling along, and I come to a long node,
the scrolling stops and the long node is selected. NOT what I want! FWIW, my
workaround is to locate the mouse on the far left side of the Outline Pane.
#@nonl
#@-node:ekr.20060111103821.3:Report
#@-node:ekr.20060111103821.2:Fix problems with universalScrolling pluing
#@+node:ekr.20060120084705:Overwrite mode doesn't work in headllines
#@-node:ekr.20060120084705:Overwrite mode doesn't work in headllines
#@+node:ekr.20060114052626:@alias nodes set minibuffer aliases
This is not needed with Ctrl-C mode.
#@nonl
#@-node:ekr.20060114052626:@alias nodes set minibuffer aliases
#@+node:ekr.20060105143454.2:Convert Emacs-Style Names to Menu Style Names when creating undo name
#@-node:ekr.20060105143454.2:Convert Emacs-Style Names to Menu Style Names when creating undo name
#@+node:ekr.20051220062654:Open .leo file in new process
An alternative to test.leo!
#@nonl
#@-node:ekr.20051220062654:Open .leo file in new process
#@+node:ekr.20051207130144:Investigate Tk DnD
@nocolor
https://sourceforge.net/forum/message.php?msg_id=3460955
By: nobody

I found this link:
http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html
TkinterDnD

so if Edward is interested in adding drag and drop support for regular leo,
this might be a path to do so.  It looks like an active project.

leouser
#@+node:ekr.20051207130144.1:@url http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html
#@-node:ekr.20051207130144.1:@url http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html
#@-node:ekr.20051207130144:Investigate Tk DnD
#@+node:ekr.20051104051733:Make Focus-in in minibuffer widget equivalent to Alt-x
FocusIn does nothing for Label widgets.

http://sourceforge.net/forum/message.php?msg_id=3412640
By: btheado

Currently clicking on the minibuffer and typing text has no effect.  Kinda confusing
until the Alt-x binding I discovered that Alt-x is the way to access the minibuffer
command mode.

It would be nice if the <FocusIn> binding on the minibuffer widget were equivilent
to Alt-x.
#@nonl
#@-node:ekr.20051104051733:Make Focus-in in minibuffer widget equivalent to Alt-x
#@+node:ekr.20050318072227.2:Python-oriented find
Use Python search commands instead of Tk.
Use Python indices
#@nonl
#@+node:ekr.20040130073846:Use Python indices instead of Tk indices (Done except for leoFind!!)
@color
#@nonl
#@+node:ekr.20050313174347.1:Code notes
@nocolor

- Apparently, the colorizer _already_ uses Python indices!

- colorizer.tag calls colorizer.index to do all conversion, so it is completely index-neutral.

- The edit body routines _already_ use Python indices!
    - c.getBodyLines calls:
        - body.getSelectionLines
        - body.getAllText
        - body.getYScrollPosition
        - body.getTextSelection
    - c.updateBodyPane calls:
        - body.setSelectionAreas
        - body.setYScrollPosition
        - body.makeInsertPointVisible

    That is, these routines never _use_ Tk indices,
    although they may pass them to and from body methods.

Find code:
    - The leoFind methods use the Tk wrappers to insulate the code from the Tk indices.
    - leoFind.search calls gui_search, which is a thin wrapper around the Tk find search.
        - This is a major simplification of the code, but it would have to be rewritten
          to make the code really portable.
        - In other words, we would use string.find or re.find instead of tk.find.
            - The code can use Python indices, then convert to body(gui) indices
            pretty much like the colorizer does:

@color
def index (self,i):
    return self.body.convertRowColumnToIndex(self.line_index,i)
@nocolor

        - The only difference is that we might have to compute the row and column indices
          from the Python index, but that is easy!
#@nonl
#@-node:ekr.20050313174347.1:Code notes
#@+node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
def convertPythonIndexToRowCol (s,i):
    
    '''Convert index i into string s into zero-based row/col indices.'''
    
    if not s or i == 0:
        return 0,0
    else:
        i = min(i,len(s)-1)
        # works regardless of what s[i] is
        row = s.count('\n',0,i) # Don't include i
        if row == 0:
            return row,i
        else:
            prevNl = s.rfind('\n',0,i) # Don't include i
            # assert prevNl > -1
            return row,i-prevNl-1
#@nonl
#@+node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
def bruteForceConvertPythonIndexToRowCol (s,i):
        
    lines = g.splitLines(s)
    row,total = 0,0
    for line in lines:
        n = len(line)
        if i < total + n:
            break
        else:
            total += n
            row += 1
    return row, i-total
#@nonl
#@-node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
#@+node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
def test_g_convertPythonIndexToRowCol ():
    
    s = '\nabc\n\npdq\nxy'

    for i in xrange(len(s)+1): # Test one-too-large case.
        try: ch = s[i]
        except IndexError: ch = '**'
        rowCol_1 = g.convertPythonIndexToRowCol(s,i)
        rowCol_2 = g.bruteForceConvertPythonIndexToRowCol(s,i)
        if g.app.unitTesting:
            assert i == len(s) or rowCol_1 == rowCol_2
        else:
            print '%2d %4s %5s' % (i,repr(ch),rowCol_1==rowCol_2),
            print rowCol_1,rowCol_2
#@nonl
#@-node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
#@+node:ekr.20050315071727:g.convertRowColToPythonIndex & test
def convertRowColToPythonIndex (s,row,col):
    
    lines = g.splitLines(s)

    if row > len(lines) or col > len(lines[row]):
        raise IndexError
    
    prev = 0
    for line in lines[:row]:
        prev += len(line)
        
    return prev + col
#@nonl
#@+node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
def test_g_convertRowColToPythonIndex ():

    s = '\nabc\n\npdq\nxy'
    lines = g.splitLines(s)
    row = 0 ; prev = -1
    for line in lines:
        col = 0
        for ch in line:
            i = g.convertRowColToPythonIndex(s,row,col)
            assert i == prev + 1,'i %d prev %d' % (i,prev)
            if not g.app.unitTesting:
                print '%4s %2d %2d %2d' % (repr(ch),row,col,i)
            prev = i
            col += 1
        row += 1
#@nonl
#@-node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050315071727:g.convertRowColToPythonIndex & test
#@+node:ekr.20050313174347:Code that uses Tk indices (outside of Tkinter classes)
@color
#@nonl
#@+node:ekr.20050313174347.2:In leoTkinterBody
#@+node:ekr.20031218072017.4006:Indices (leoTkinterBody)
#@+node:ekr.20031218072017.4007:adjustIndex
def adjustIndex (self,index,offset):
    
    t = self.bodyCtrl
    return t.index("%s + %dc" % (t.index(index),offset))
#@nonl
#@-node:ekr.20031218072017.4007:adjustIndex
#@+node:ekr.20031218072017.4008:compareIndices
def compareIndices(self,i,rel,j):

    return self.bodyCtrl.compare(i,rel,j)
#@nonl
#@-node:ekr.20031218072017.4008:compareIndices
#@+node:ekr.20031218072017.4009:convertRowColumnToIndex
def convertRowColumnToIndex (self,row,column):
    
    return self.bodyCtrl.index("%s.%s" % (row,column))
#@nonl
#@-node:ekr.20031218072017.4009:convertRowColumnToIndex
#@+node:ekr.20031218072017.4010:convertIndexToRowColumn
def convertIndexToRowColumn (self,index):
    
    index = self.bodyCtrl.index(index)
    start, end = string.split(index,'.')
    return int(start),int(end)
#@nonl
#@-node:ekr.20031218072017.4010:convertIndexToRowColumn
#@+node:ekr.20031218072017.4011:getImageIndex
def getImageIndex (self,image):
    
    return self.bodyCtrl.index(image)
#@nonl
#@-node:ekr.20031218072017.4011:getImageIndex
#@+node:ekr.20031218072017.4012:tkIndex (internal use only)
def tkIndex(self,index):
    
    """Returns the canonicalized Tk index."""
    
    if index == "start": index = "1.0"
    
    return self.bodyCtrl.index(index)
#@nonl
#@-node:ekr.20031218072017.4012:tkIndex (internal use only)
#@-node:ekr.20031218072017.4006:Indices (leoTkinterBody)
#@+node:ekr.20031218072017.4002:Color tags (Tk spelling)
# Could have been replaced by the __getattr__ routine above...
# 12/19/03: no: that would cause more problems.

def tag_add (self,tagName,index1,index2):
    self.bodyCtrl.tag_add(tagName,index1,index2)

def tag_bind (self,tagName,event,callback):
    self.bodyCtrl.tag_bind(tagName,event,callback)

def tag_configure (self,colorName,**keys):
    self.bodyCtrl.tag_configure(colorName,keys)

def tag_delete(self,tagName):
    self.bodyCtrl.tag_delete(tagName)

def tag_remove (self,tagName,index1,index2):
    return self.bodyCtrl.tag_remove(tagName,index1,index2)
#@nonl
#@-node:ekr.20031218072017.4002:Color tags (Tk spelling)
#@-node:ekr.20050313174347.2:In leoTkinterBody
#@+node:ekr.20050313174347.3:In colorizer...
#@+node:ekr.20031218072017.1609:index & tag
def index (self,i):
    
    return self.body.convertRowColumnToIndex(self.line_index,i)
        
def tag (self,name,i,j):

    self.body.tag_add(name,self.index(i),self.index(j))
#@nonl
#@-node:ekr.20031218072017.1609:index & tag
#@-node:ekr.20050313174347.3:In colorizer...
#@+node:ekr.20050313174347.4:In commands...
#@+node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20031218072017.1704:convertAllBlanks
def convertAllBlanks (self,event=None):
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1704:convertAllBlanks
#@+node:ekr.20031218072017.1705:convertAllTabs
def convertAllTabs (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1705:convertAllTabs
#@+node:ekr.20031218072017.1821:convertBlanks
def convertBlanks (self,event=None):

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1821:convertBlanks
#@+node:ekr.20031218072017.1822:convertTabs
def convertTabs (self,event=None):

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False,None

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1822:convertTabs
#@+node:ekr.20031218072017.1823:createLastChildNode
def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) > 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p
#@nonl
#@-node:ekr.20031218072017.1823:createLastChildNode
#@+node:ekr.20031218072017.1824:dedentBody
def dedentBody (self,event=None):
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1824:dedentBody
#@+node:ekr.20031218072017.1706:extract
def extract (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.1706:extract
#@+node:ekr.20031218072017.1708:extractSection
def extractSection (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    << Set headline for extractSection >>
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
#@nonl
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection
#@+node:ekr.20031218072017.1710:extractSectionNames
def extractSectionNames(self,event=None):

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                << Find the next section name >>
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()
#@nonl
#@+node:ekr.20031218072017.1711:<< Find the next section name >>
head1 = string.find(s,"<<")
if head1 > -1:
    head2 = string.find(s,">>",head1)
else:
    head1 = string.find(s,"@<")
    if head1 > -1:
        head2 = string.find(s,"@>",head1)
        
if head1 == -1 or head2 == -1 or head1 > head2:
    name = None
else:
    name = s[head1:head2+2]
#@nonl
#@-node:ekr.20031218072017.1711:<< Find the next section name >>
#@-node:ekr.20031218072017.1710:extractSectionNames
#@+node:ekr.20031218072017.1825:findBoundParagraph
def findBoundParagraph (self,event=None):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i < len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#   para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool
#@nonl
#@+node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)
#@nonl
#@-node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
#@-node:ekr.20031218072017.1825:findBoundParagraph
#@+node:ekr.20031218072017.1827:findMatchingBracket
def findMatchingBracket (self,event=None):
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}<>"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"<=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)
#@nonl
#@+node:ekr.20031218072017.1828:findMatchingBracket
# To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{<" ; close_brackets = ")]}>"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,">=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level <= 0:
                return index
        if not forward and body.compareIndices(index,"<=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
#@nonl
#@-node:ekr.20031218072017.1828:findMatchingBracket
#@-node:ekr.20031218072017.1827:findMatchingBracket
#@+node:ekr.20031218072017.1829:getBodyLines
def getBodyLines (self,expandSelection=False):

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use splitLines.

    return head,lines,tail,oldSel,oldVview
#@nonl
#@-node:ekr.20031218072017.1829:getBodyLines
#@+node:ekr.20031218072017.1830:indentBody
def indentBody (self,event=None):
    
    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; undoType = 'Indent Region' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1830:indentBody
#@+node:ekr.20031218072017.1831:insertBodyTime & allies
def insertBodyTime (self,event=None):
    
    c = self ; undoType = 'Insert Body Time'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(undoType,oldSel=oldSel)
#@nonl
#@+node:ekr.20031218072017.1832:getTime & test
def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getBool("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt    = c.config.getBool("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoSettings.leo.
        s = time.strftime(default_format,time.gmtime())
    return s
#@-node:ekr.20031218072017.1832:getTime & test
#@-node:ekr.20031218072017.1831:insertBodyTime & allies
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self,event=None):

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self,event=None):

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20031218072017.1833:reformatParagraph
def reformatParagraph (self,event=None):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    << compute vars for reformatParagraph >>
    if lines:
        << compute the leading whitespace >>
        << compute the result of wrapping all lines >>
        << update the body, selection & undo state >>
#@nonl
#@+node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL
#@nonl
#@-node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
#@+node:ekr.20031218072017.1835:<< compute the leading whitespace >>
indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i < len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
#@-node:ekr.20031218072017.1835:<< compute the leading whitespace >>
#@+node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
# Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
#@-node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
#@+node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()
#@nonl
#@-node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
#@-node:ekr.20031218072017.1833:reformatParagraph
#@+node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
#@-node:ekr.20031218072017.2884:Edit Body submenu
#@-node:ekr.20050313174347.4:In commands...
#@+node:ekr.20050313175009:In leoFind...
#@+node:ekr.20031218072017.3077:search
def search (self):

    """Searches the present headline or body text for self.find_text and returns True if found.

    self.whole_word, self.ignore_case, and self.pattern_match control the search."""

    c = self.c ; p = self.p ; t = self.s_ctrl ; gui = g.app.gui
    assert(c and t and p)
    if self.selection_only:
        index,stopindex = self.selStart, self.selEnd
        if index == stopindex:
            return None, None
    else:
        index = gui.getInsertPoint(t)
        stopindex = g.choose(self.reverse,gui.firstIndex(),gui.lastIndex())
    while 1:
        try:
            pos = self.gui_search(t,self.find_text,index,
                stopindex=stopindex,backwards=self.reverse,
                regexp=self.pattern_match,nocase=self.ignore_case)
        except Exception:
            g.es_exception(full=False)
            self.errors += 1 ; break
        if not pos: break
        if self.find_text == '\n':
            newpos = gui.moveIndexToNextLine(t,pos)
        else:
            newpos = gui.moveIndexForward(t,pos,len(self.find_text))
        if newpos is None: break
        << break if we are passed the wrap point >>
        if self.whole_word:
            index = t.index(g.choose(self.reverse,pos,newpos))
            << continue if not whole word match >>
        #g.trace("found:",pos,newpos,p)
        gui.setTextSelection(t,pos,newpos)
        return pos, newpos
    # g.trace('not found',p.headString())
    return None,None
#@nonl
#@+node:ekr.20031218072017.3079:<< break if we are passed the wrap point >>
if self.wrapping and self.wrapPos and self.wrapPosition and self.p == self.wrapPosition:

    if self.reverse and gui.compareIndices(t,pos, "<", self.wrapPos):
        # g.trace("wrap done")
        break

    if not self.reverse and gui.compareIndices(t,newpos, ">", self.wrapPos):
        break
#@nonl
#@-node:ekr.20031218072017.3079:<< break if we are passed the wrap point >>
#@+node:ekr.20031218072017.3080:<< continue if not whole word match >>
# Set pos to None if word characters preceed or follow the selection.
before = gui.getCharBeforeIndex(t,pos)
first  = gui.getCharAtIndex    (t,pos)
last   = gui.getCharBeforeIndex(t,newpos)
after  = gui.getCharAtIndex    (t,newpos)

#g.trace("before,first",before,first,g.is_c_id(before),g.is_c_id(first))
#g.trace("after,last",  after,last,  g.is_c_id(after), g.is_c_id(last))

if g.is_c_id(before) and g.is_c_id(first):
    continue

if g.is_c_id(after) and g.is_c_id(last):
    continue
#@nonl
#@-node:ekr.20031218072017.3080:<< continue if not whole word match >>
#@-node:ekr.20031218072017.3077:search
#@-node:ekr.20050313175009:In leoFind...
#@-node:ekr.20050313174347:Code that uses Tk indices (outside of Tkinter classes)
#@-node:ekr.20040130073846:Use Python indices instead of Tk indices (Done except for leoFind!!)
#@+node:ekr.20050314091755:Unit tests for find/change commands
#@-node:ekr.20050314091755:Unit tests for find/change commands
#@-node:ekr.20050318072227.2:Python-oriented find
#@-node:ekr.20051023192433:Maybe or never
#@+node:ekr.20050816165305:Important
#@+node:ekr.20031218072017.801:Zipped .leo files
#@+node:ekr.20050428062312:Request 1
@nocolor

By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57


Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
#@-node:ekr.20050428062312:Request 1
#@+node:ekr.20040226092546:Request 2
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442772
By: ejoy

I made an experiment last night. I replaced the call to open()in leofilecommand.py
with a call to gzip.open().

The LeoPy.leo file saved this way is only 600K! And there is no significant
speed down in saving.

I think it is a good idea to add compression support for load/save .leo files.
When reading or writing file with name ending with ".leo.gz", leo can call gzip
module to uncompress/compress the file, saving a lot of disk space.

What do you think of this?
#@nonl
#@-node:ekr.20040226092546:Request 2
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    # Delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20050428063105:newOpen (From chapters.py)
oldOpen = leoFileCommands.fileCommands.open

def newOpen( self,file,fileName,readAtFileNodesFlag=True,silent=False):

    global iscStringIO
    c = self.c
    
    if zipfile.is_zipfile( fileName ):
        iscStringIO = True
        chapters = openChaptersFile( fileName )
        g.es( str( len( chapters ) ) + " Chapters To Read", color = 'blue' )
        insertChapters( chapters, c.frame, c )
        g.es( "Finished Reading Chapters", color = 'blue' )
        iscStringIO = False
        return True

    return oldOpen(self,file,fileName,readAtFileNodesFlag,silent)
#@nonl
#@-node:ekr.20050428063105:newOpen (From chapters.py)
#@-node:ekr.20031218072017.801:Zipped .leo files
#@+node:ekr.20050831131028:opml
#@+node:ekr.20050831131452:Original post
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3280949
By: billp9619

>>Making Leo a friendly part of the opml world has the potential to be very
important to Leo. <<

This is probably point 5. and covers the implementation of opml features as
exposed in Leo.

Because Leo is highly scripted there may be many requests... currently out on
the OPML list... that are solveable....such as how to see their outlines as
HTML without passing thru the OPML web server /host. BTW...all this new opml
stuff is only a week or two in production. The first message on
http://groups.yahoo.com/group/opml-newbies/
is July 25.

>> The question of whether to duplicate body text in <outline> elements
is minor<<

Good. 

Really, the opml tools are pretty much raw text/xml  and I was thinking the
default fallback is ... all clone text is "duplicate". If you want clones then
you will take care to only edit them in Leo. But if opml users all know and
use clones routinely in other editors,  then this is good news for opml
as technology.

>>more complicated than it needs to be<<

Well, both Leo and opml have only a few elements and each primarilly uses one
which recusively nests to make up the outline portion. I suppose body nodes
could be included more directly in headlines ... allowing un-numbered headlines
basically, ... but I am not sure that the current way is inferior
or complicated.

 A simpler (forgiving?) format might make it easier to create with external
apps and encourage transforming other xml to Leo via XSLT. It would have to
just "work".

(One thing about Leo's bias towards elements to contain markup, versus attributes,
is that ...you can cheat a little on escaping &quot; in vh or t nodes ?...which
makes code blocks smaller in the Leo xml.)

Your list above is pretty much how I see it as well.

regards,

bill p

#@-node:ekr.20050831131452:Original post
#@+node:ekr.20050831131452.1:opml attributes v elements
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3282460
By: billp9619

Looking at some discussion of outline formats there was a remark that because
opml places all text in attributes it is limited in not being able to contan
other elements. On xml-dev I also saw some advice about opml followed by the
comment that it is not a good format.

opml is crippled in this regard but  Leo only restricts itself as a choice in
order to  discern leo xml from content.(out of necessity we know).

Of course with xml you can mix vocabularies based on the use of namespaces.
By becoming namespace aware Leo could be adapted for non-escaped markup. The
purpose then is xml parsing of leo as a standard container of other xml. I do
not believe this is unthinkable  for some future capabilities... especially
if such nodes would contain exclusively xml from another namespace.

Just interesting that leo's format is more versatile than opml, 
but, ...by choice for its own purposes, ...
 is in this part "backward" compatible with opml. :)  

regards,

bill p
#@-node:ekr.20050831131452.1:opml attributes v elements
#@+node:ekr.20050912063133:@url http://sourceforge.net/forum/message.php?msg_id=3273977
#@-node:ekr.20050912063133:@url http://sourceforge.net/forum/message.php?msg_id=3273977
#@+node:ekr.20050912065811:@url http://sourceforge.net/forum/message.php?msg_id=3279900 (summary)
#@-node:ekr.20050912065811:@url http://sourceforge.net/forum/message.php?msg_id=3279900 (summary)
#@+node:ekr.20050915062404:My post
@nocolor

Hi,

I am the author of Leo http://webpages.charter.net/edreamleo/front.html an outline editor supporting clones http://webpages.charter.net/edreamleo/intro.html#clones-views.

I am interested in having Leo be able to read and write opml files.  My understanding is that applications are free to use attributes of <outline> elements as they please, but I am wondering whether there are guidelines or existing conventions for representing clones.  Have any namespaces been defined for that purpose?

Thanks.

Edward
#@-node:ekr.20050915062404:My post
#@-node:ekr.20050831131028:opml
#@+node:ekr.20050419060645:Alternate lead-in characters
@nocolor

An @decorator setting might be good. This would be a list of all Python
decorators. Leo would create @verbatim sentinels for these.
#@nonl
#@-node:ekr.20050419060645:Alternate lead-in characters
#@+node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
#@+node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2674828
By: bwmulder

If I understand correctly, there are two different problems:

- Trailing whitespaces
- Left indented comments

1. Before commenting on these, a question:

If I write something like
    a=b
    if a:
        @others

[four spaces indentation]

I sometimes see tab characters before the lines inserted for '@others'.

It seems that Leo remembers 'two levels of indentation', and then
fabricates this indentation using tab characters.

I think it might be more robust if Leo remembered the actual
characters in front of @others and would use them for indentation.

I suspect that many indentation errors I had with Leo could have been
avoided had not Leo had its own ideas on how to do indentation.

Maybe Leo could use the exact sequence of characters in front of
@others for all inserted lines?

2. I do not care much about trailing whitespaces. Most of the time
they are invisible, but sometimes they are very misleading (trailing in python or C).

As far as I am concerned, Leo need never produce trailing whitespaces.

Maybe we need special machinerie if sources have trailing whitespaces
and the sources are not under our control. 

Not sure if everybody would be happy if we essentially ban all trailing
whitespaces.

3. Unindented commentlines could be dealt with by using indentation to
indicate structure.

Of course, this might break the correspondance Leo structure / Python
structure, which is very ugly.

4. One possible alternative might be a new directive which indicates outindent:

@outindent <number>.

This would apply to the next comment block.

To me, 4. looks a little bit less ugly than 3.

5. As indicated in a different post, I suspect that Leo has a problem
if almost every node in an outline is changed. Profiling should point
to the culprit.

> 2. Have Leo strip whitespace from otherwise blank lines, and hope
that that solves all problems in Perfect Import. This is solving the
problem in the atFile code. The problem is that if we apply settings
in general we will get massive changes to derived files. In most
programming settings these changes might be welcome, but the problem
is actually making these changes. My first few attempts met with
abject failure.

Are you saying that you could not remove trailing blanks? What kind of
problems did you run into?

Summary:
- Use actual characters in front of @others or <<>> for indentation.
- Don't write trailing whitespaces
- Introduce directive for left-indendet comments.
- Profile to find out what slows Leo down if many nodes change.
#@nonl
#@-node:ekr.20040721094203:Make sure Leo uses "verbatim" whitespace
#@+node:ekr.20040930075920:Whitespace options
#@+node:ekr.20040720103642.1:Script to remove trailing body newlines VERY DANGEROUS
current = c.currentPosition()
count = 0

for p in c.all_positions_iter():
    s = p.bodyString().rstrip()
    if s:
        s = p.bodyString().rstrip() + '\n'
        if s != p.bodyString():
            # Do NOT set anything dirty here!
            ## p.v.t.setTnodeText(s)
            count += 1

print "%d nodes converted" % count
print "You MUST do Write All Nodes AND Save this file to complete the conversion"
#@nonl
#@-node:ekr.20040720103642.1:Script to remove trailing body newlines VERY DANGEROUS
#@+node:EKR.20040603092958.1:Add new options for handling newlines in body text
@nocolor

Alas, this really does not solve problems with Import.

- "asis":  ideal, maybe not possible?
- "zero": no trailing newlines.
- "one": exactly one trailing newline.

Special case code is required so empty nodes stay empty with "one" option.
#@nonl
#@+node:ekr.20040802063546.1:(Made sure body text changes reported properly)
# This may have to change when mass whitespace changes happen)
#@nonl
#@+node:ekr.20031218072017.1812:top_df.read
# The caller has enclosed this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False):
    
    """Common read logic for any derived file."""
    
    at = self ; c = at.c
    at.errors = 0
    importing = importFileName is not None
    << set fileName from root and importFileName >>
    << open file or return False >>
    g.es("reading: " + root.headString())
    firstLines,read_new,derivedFileIsThin = at.scanHeader(theFile,fileName)
    df = g.choose(read_new,at.new_df,at.old_df)
    # g.trace(g.choose(df==at.new_df,"new","old"))
    << copy ivars to df >>
    root.clearVisitedInTree()
    try:
        # 1/28/04: Don't set comment delims when importing.
        # 1/28/04: Call scanAllDirectives here, not in readOpenFile.
        importing = importFileName is not None
        df.scanAllDirectives(root,importing=importing,reading=True)
        df.readOpenFile(root,theFile,firstLines)
    except:
        at.error("Unexpected exception while reading derived file")
        g.es_exception()
    theFile.close()
    root.clearDirty() # May be set dirty below.
    after = root.nodeAfterTree()
    << warn about non-empty unvisited nodes >>
    if df.errors == 0:
        if not df.importing:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return df.errors == 0
#@nonl
#@+node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
at.scanDefaultDirectory(root,importing=importing)
if at.errors: return

if importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@nonl
#@-node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
#@+node:ekr.20031218072017.1814:<< open file or return false >>
fn = g.os_path_join(at.default_directory,fileName)
fn = g.os_path_normpath(fn)

try:
    # 11/4/03: open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile = open(fn,'rb')
    if theFile:
        << warn on read-only file >>
    else: return False
except:
    at.error("Can not open: " + '"@file ' + fn + '"')
    root.setDirty()
    return False
#@nonl
#@+node:ekr.20031218072017.1815:<< warn on read-only file >>
try:
    read_only = not os.access(fn,os.W_OK)
    if read_only:
        g.es("read only: " + fn,color="red")
except:
    pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20031218072017.1815:<< warn on read-only file >>
#@-node:ekr.20031218072017.1814:<< open file or return false >>
#@+node:ekr.20031218072017.1816:<< copy ivars to df >>
# Telling what kind of file we are reading.
df.importing = importFileName != None
df.raw = False
if importing and df == at.new_df:
    thinFile = True
df.thinFile = thinFile

# Set by scanHeader.
df.encoding = at.encoding
df.endSentinelComment = at.endSentinelComment
df.startSentinelComment = at.startSentinelComment

# Set other common ivars.
df.errors = 0
df.file = theFile
df.importRootSeen = False
df.indent = 0
df.targetFileName = fileName
df.root = root
df.root_seen = False
df.perfectImportRoot = None # Set only in readOpenFile.
#@nonl
#@-node:ekr.20031218072017.1816:<< copy ivars to df >>
#@+node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file:" + p.headString())
        p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@nonl
#@-node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
#@-node:ekr.20031218072017.1812:top_df.read
#@-node:ekr.20040802063546.1:(Made sure body text changes reported properly)
#@+node:ekr.20040930075920.1:Common to both options
#@+node:ekr.20031218072017.2404:<< define defaultsDict >>
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

# Defaults for ivars are specified in the ctor, _not_ here.

defaultsDict = {
    # compare options...
    "ignore_blank_lines" : 1,
    "limit_count" : 9,
    "print_mismatching_lines" : 1,
    "print_trailing_lines" : 1,
    # find/change options...
    "search_body" : 1,
    "whole_word" : 1,
    # Prefs panel.
    "default_target_language" : "Python",
    "tab_width" : -4,
    "page_width" : 132,
    "output_doc_chunks" : 1,
    "tangle_outputs_header" : 1,
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    "color_directives_in_plain_text" : 1,
    "underline_undefined_section_names" : 1,
    # Window options...
    "allow_clone_drags" : 1,
    "body_pane_wraps" : 1,
    "body_text_font_family" : "Courier",
    "body_text_font_size" : defaultBodyFontSize,
    "body_text_font_slant" : "roman",
    "body_text_font_weight" : "normal",
    "enable_drag_messages" : 1,
    "headline_text_font_size" : defaultTreeFontSize,
    "headline_text_font_slant" : "roman",
    "headline_text_font_weight" : "normal",
    "log_text_font_size" : defaultLogFontSize,
    "log_text_font_slant" : "roman",
    "log_text_font_weight" : "normal",
    "initial_window_height" : 600, # 7/24/03: In pixels.
    "initial_window_width" :  800, # 7/24/03: In pixels.
    "initial_window_left" : 10,
    "initial_window_top" : 10,
    "initial_splitter_orientation" : "vertical",
    "initial_vertical_ratio" : 0.5,
    "initial_horizontal_ratio" : 0.3,
    "initial_horizontal_secondary_ratio" : 0.5,
    "initial_vertical_secondary_ratio" : 0.7,
    "outline_pane_scrolls_horizontally" : 0,
    "split_bar_color" : "LightSteelBlue2",
    "split_bar_relief" : "groove",
    "split_bar_width" : 7 }
#@nonl
#@-node:ekr.20031218072017.2404:<< define defaultsDict >>
#@+node:ekr.20031218072017.3004:<< initialize ivars that may be set by config options >>
# Defaults for these ivaars are specified here, _not_ in defaultsDict.

self.at_root_bodies_start_in_doc_mode = True # For compatibility with previous versions.
self.config = None # The current instance of ConfigParser
self.config_encoding = "utf-8" # Encoding used for leoConfig.txt.
self.create_nonexistent_directories = False
self.default_derived_file_encoding = "utf-8"
self.new_leo_file_encoding = "UTF-8" # Upper case for compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.read_only = True # Make sure we don't alter an illegal leoConfig.txt file!
self.redirect_execute_script_output_to_log_pane = False
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = False
self.stylesheet = None
self.tkEncoding = None # Defaults to None so it doesn't override better defaults.
self.trailing_body_newlines = "asis"
self.use_plugins = False # Should never be True here!
self.use_psyco = False
self.undo_granularity = "word" # "char","word","line","node"
self.write_strips_blank_lines = False
#@nonl
#@-node:ekr.20031218072017.3004:<< initialize ivars that may be set by config options >>
#@+node:ekr.20031218072017.1421:<< get config options >>
@ Rewritten 10/11/02 as follows:

1. We call initConfigParam and initBooleanConfigParam to get the values.

The general purpose code will enter all these values into configDict.  This allows update() to write the configuration section without special case code.  configDict is not accessible by the user.  Rather, for greater speed the user access these values via the ivars of this class.

2. We pass the ivars themselves as params so that default initialization is done in the ctor, as would normally be expected.
@c

self.at_root_bodies_start_in_doc_mode = self.initBooleanConfigParam(
    "at_root_bodies_start_in_doc_mode",self.at_root_bodies_start_in_doc_mode)
    
encoding = self.initConfigParam(
    "config_encoding",self.config_encoding)
    
if g.isValidEncoding(encoding):
    self.config_encoding = encoding
else:
    g.es("bad config_encoding: " + encoding)
    
self.create_nonexistent_directories = self.initBooleanConfigParam(
    "create_nonexistent_directories",self.create_nonexistent_directories)
    
encoding = self.initConfigParam(
    "default_derived_file_encoding",self.default_derived_file_encoding)

if g.isValidEncoding(encoding):
    self.default_derived_file_encoding = encoding
else:
    g.es("bad default_derived_file_encoding: " + encoding)
    
encoding = self.initConfigParam(
    "new_leo_file_encoding",
    self.new_leo_file_encoding)

if g.isValidEncoding(encoding):
    self.new_leo_file_encoding = encoding
else:
    g.es("bad new_leo_file_encoding: " + encoding)

self.output_initial_comment = self.initConfigParam(
    "output_initial_comment",self.output_initial_comment)

self.output_newline = self.initConfigParam(
    "output_newline",self.output_newline)

self.read_only = self.initBooleanConfigParam(
    "read_only",self.read_only)

self.relative_path_base_directory = self.initConfigParam(
    "relative_path_base_directory",self.relative_path_base_directory)
    
self.redirect_execute_script_output_to_log_pane = self.initBooleanConfigParam(
    "redirect_execute_script_output_to_log_pane",
    self.redirect_execute_script_output_to_log_pane)
    
self.remove_sentinels_extension = self.initConfigParam(
    "remove_sentinels_extension",self.remove_sentinels_extension)

self.save_clears_undo_buffer = self.initBooleanConfigParam(
    "save_clears_undo_buffer",self.save_clears_undo_buffer)
    
self.stylesheet = self.initConfigParam(
    "stylesheet",self.stylesheet)
    
encoding = self.initConfigParam(
    "tk_encoding",self.tkEncoding)
    
if encoding and len(encoding) > 0: # May be None.
    if g.isValidEncoding(encoding):
        self.tkEncoding = encoding
    else:
        g.es("bad tk_encoding: " + encoding)
        
# New in 4.2
self.trailing_body_newlines = self.initConfigParam(
    "trailing_body_newlines",self.trailing_body_newlines)
    
self.use_plugins = self.initBooleanConfigParam(
    "use_plugins",self.use_plugins)

self.use_psyco = self.initBooleanConfigParam(
    "use_psyco",self.use_psyco)
    
self.undo_granularity = self.initConfigParam(
    "undo_granularity",self.undo_granularity)

# New in 4.2
self.write_strips_blank_lines = self.initBooleanConfigParam(
    "write_strips_blank_lines",self.write_strips_blank_lines)
    
#g.trace("write_strips_blank_lines",self.write_strips_blank_lines)
#g.trace("trailing_body_newlines",self.trailing_body_newlines)
#@nonl
#@-node:ekr.20031218072017.1421:<< get config options >>
#@-node:ekr.20040930075920.1:Common to both options
#@+node:ekr.20040718050922:(trailing_body_newlines option)
@color
#@nonl
#@+node:ekr.20040720105309:Notes
@killcolor

My first idea was to do this in the body text setters.  However, this converts everything when reading any .leo file, and that is _very_ slow.  It also appears to be very dangerous.
#@nonl
#@-node:ekr.20040720105309:Notes
#@-node:ekr.20040718050922:(trailing_body_newlines option)
#@+node:ekr.20040720075446.1:(write_strips_blank_lines option)
#@+node:ekr.20031218072017.2134:putCodeLine
def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.app.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
#@nonl
#@-node:ekr.20031218072017.2134:putCodeLine
#@-node:ekr.20040720075446.1:(write_strips_blank_lines option)
#@-node:EKR.20040603092958.1:Add new options for handling newlines in body text
#@-node:ekr.20040930075920:Whitespace options
#@+node:ekr.20041022083005.8:Script to catch mixed tab & space in derived files
import glob

@others

dir = c.frame.openDirectory
files = glob.glob('%s\*.py' % dir)

n = 0
for name in files:
    f = file(name)
    lines = f.readlines()
    # print '%5d %s' % (len(lines),name)
    f.close()
    check(name,lines)
    n += 1
print 'done.  checked %d files' % (n)
#@nonl
#@+node:ekr.20050917133402:check
def check(name,lines):
    
    n = 0
    for line in lines:
        n += 1
        i = g.skip_ws(line,0)
        lws = line[0:i]
        if lws:
            if lws.find(' ') > -1 and lws.find('\t') > -1:
                print '%20s %5d %s' % (name,n,repr(line))
#@nonl
#@-node:ekr.20050917133402:check
#@-node:ekr.20041022083005.8:Script to catch mixed tab & space in derived files
#@-node:ekr.20040919182750.1:Better handling of whitespace (cvs fiendly)
#@+node:ekr.20041228092223.2:Integrated Leo debugger
#@+node:ekr.20041029085429:Use pdb.pm as starting point for integrated Leo debugger
@killcolor

> pdb.set_trace() is...quite a pain to use if you are used to pdb.pm() in an interactive session.

Whaterver pdb.pm does (I haven't used it) this might be the starting point for the design of a better interface between pdb and Leo.

#@-node:ekr.20041029085429:Use pdb.pm as starting point for integrated Leo debugger
#@+node:ekr.20050515091432:LeoDb
@killcolor

- Create window with breakpoint symbols.
    - Replace sections with helper functions in f.finishCreate.

- How/when to set breakpoints?
    - Inverse function to go-to line number.
    - Represent breakpoints by node/offset/line-contents?
#@nonl
#@-node:ekr.20050515091432:LeoDb
#@+node:ekr.20050614061954:jEdit debugger url
@nocolor

something else from jEdit, JpyDbg plugin. 
<http://jpydbg.sourceforge.net>
#@nonl
#@-node:ekr.20050614061954:jEdit debugger url
#@+node:ekr.20050831131452.2:DBGp standard
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3286395
By: tfer

Some time in the future when we might be wanting to add more graphical debugging
facilates to Leo (multilanguage), might we want to go with DBGp open source
standard?

I came accross this while looking over ActiveState's Komodo editor.

Tom
#@nonl
#@-node:ekr.20050831131452.2:DBGp standard
#@-node:ekr.20041228092223.2:Integrated Leo debugger
#@+node:ekr.20060105144218:Better regex find
#@-node:ekr.20060105144218:Better regex find
#@+node:EKR.20040628085831:@import, @shadow
@directory-import (Generalization of @import)
#@nonl
#@-node:EKR.20040628085831:@import, @shadow
#@+node:ekr.20041022091645.4:  Emacs/Pymacs
#@+node:ekr.20040125121407:Postings
@nocolor
#@nonl
#@+node:ekr.20040125121407.1:randomandy
http://sourceforge.net/forum/message.php?msg_id=2389876
By: randomandy

Is it only me who sees this as a question on how to reinvent the wheel? (or
in the case of emacs, how to reinvent the <i>everything</i>.)

Leo and Python both seem so well suited as wonderful hierarchal glue programs.
And both are so elegant in the way their simple functionality brings such power
and order to the cause. It just seems it would be a shame to take something
so novel and unique and try to turn it into <i>yet another</i> huge text editor.

I'm with <A HREF="http://sourceforge.net/forum/message.php?msg_id=2345873">Danny
</A> on this one. The ideal solution is to find the most elegant and seamless
way to splice one's own beloved text editor (or multipurpose editor/OS) in with
the Leo paradigm. Have Leo hand off the text duties to the editor, or have the
editor deliver heirarchy commands to Leo.

I'm also quite curious if this makes a good tie in with SciTE. SciTE produces
stunningly readible language highlighting/formatting. Could it be employed for
basic cell text display, and then for heavier editing, a keystroke or button
could open the cell text in one's preferred weapons grade text editor?

Scintilla also has a similarly beautiful code-to-html and code-to-pdf capability
that seems very suited to the literary part of the Leo paradigm: publication.
It would be nice if that code could be exploited as well.

This Leo is really a marvelous work. It's transforming the way I think (i.e.
making it possible again). Nice work, Edward.
#@-node:ekr.20040125121407.1:randomandy
#@+node:ekr.20040125121407.2:dannyobrien
By: dannyobrien ( danny o'brien ) 
 RE: What would it take to turn Leo into Emacs   
2003-12-23 09:18  

 I agree with the embedding; I've used the vim plugin and it works well, but actually embedding the editor directly into the text field of leo (and allowing a range of keyboard shortcuts for eg headline editing) would be perfect.

There is some support for this in gvim, the GUI version of vim that comes as standard. This can be run so as its GUI is "embedded" in another GTK widget, using that library's GtkSocket/GtkPlug system. A quick demo of that (and how to do it in python) is here:

http://www.daa.com.au/pipermail/pygtk/2003-October/006185.html

To see this working with gvim, run the second (socket.py) program on that page then type

gvim --socketid <number generated by socket.py>

I'm not sure how you could do this in other widget libraries - I don't know much about X Windows, but I suppose it would need support in vim as well as the widget set.
 
#@-node:ekr.20040125121407.2:dannyobrien
#@+node:ekr.20040125121407.3:mdawson
http://sourceforge.net/forum/message.php?msg_id=2388448
By: mdawson

I use XEmacs as my text editor.  The first thing I did when
evaluating Leo was to set up "open with" to use XEmacs for editing
Leo body text.

My progress so far:

- my Open_With Plugin opens a Leo node as a foreground buffer in
XEmacs, or a background (invisible) buffer in XEmacs.

- my Open_Tree Plugin opens a sub-tree of Leo nodes as background
buffers in XEmacs.

- my filename modification plugin changes the temporary file names
used by Leo so that they can be spotted more easily in an XEmacs
buffer listing (e.g. ibuffer).

- an elisp function to kill all XEmacs Leo buffers at once.

- another elisp function to indent and unindent the Leo comments in
derived Python source, which improves the readability of code.

- my setup of the elisp Multiple-Major-Modes XEmacs package, so that
XEmacs is in text-mode in Leo @doc sections, and the correct
language mode in @code sections.

Any of these might be able to be adapted for your own use. They
should all work with Emacs as well as XEmacs, but I've not tested
that.

These are all outlined in Appendix "C. XEmacs Text Editor" of the
document at:
    http://devguide.leo.marshallresearch.ca

and the Leo outline that contains them is available
at:
    http://leo.marshallresearch.ca


    ----------------------------------------
    Michael Dawson

 
#@-node:ekr.20040125121407.3:mdawson
#@-node:ekr.20040125121407:Postings
#@+node:ekr.20041022144159:Q: Pymacs bridge
I'm trying to use the Pymacs bridge to add a symbol completion facility to
Emacs's python-mode.  Neither the Python nor Emacs Lisp portions are all
that complex, but I'm having trouble passing a list of strings from Emacs
Lisp into Python.  On the Emacs Lisp side it looks like this:

    (pymacs-load "pycomplete")

    (defun py-complete ()
      (interactive)
      (pycomplete-pycomplete (py-symbol-near-point)
                             (py-find-global-imports)))

(py-find-global-imports) returns a (Lisp) list of strings, e.g.:

    ("import time", "import sys")

On the Python side I have this function:

    def pycomplete(s, imports=None):
        completions = get_all_completions(s, imports)
        dots = s.split(".")
        return os.path.commonprefix([k[len(dots[-1]):] for k in completions])

Unfortunately, the imports arg does not come across as a Python list of
strings (s does come across the bridge as a normal Python string).  Its
repr() prints out like this:

    lisp('("import time")')

What do I need to do to convert that object into a true Python list of
strings?  I'm afraid I don't quite understand the description of the lisp
object in the Pymacs docs.  I tried imports.value() but that just gave me

    (aref pymacs-lisp 0)

Any help appreciated...

Skip
#@nonl
#@-node:ekr.20041022144159:Q: Pymacs bridge
#@+node:ekr.20041022144159.1:A: pymacs-forget-mutability
"""
Proper Emacs Lisp lists, those for which the cdr of last cell is nil, are
normally transmitted opaquely to Python. If pymacs-forget-mutability is
set, or if Python later asks for these to be expanded, proper Emacs Lisp
lists get converted into Python lists, if we except the empty list, which
is always converted as Python None. In the other direction, Python lists
are always converted into proper Emacs Lisp lists.
"""

So, maybe try

    (defun py-complete ()
      (interactive)
      (let ((pymacs-forget-mutability t)) 
	(pycomplete-pycomplete (py-symbol-near-point)
                               (py-find-global-imports))))
#@-node:ekr.20041022144159.1:A: pymacs-forget-mutability
#@-node:ekr.20041022091645.4:  Emacs/Pymacs
#@-node:ekr.20050816165305:Important
#@+node:ekr.20041228090855.3:Others
#@+node:ekr.20041228091154:Commands
#@+node:ekr.20041022083833.1:Easy
#@+node:ekr.20040918165519:Mark Task & Clone To Task commands
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2415033
By: nobody

Ive been scanning Speed Reams Slash post and the Faq and saw an interesting
usage pattern: Creating a node called a Task and adding cloned nodes to it that
represent that task(I hope that explains it).  I can see myself using this idiom
in the future.  Now my question is does the Task/clone idiom warrant special
commands in Leo?  My basis:

1. Do enough Leo users work with this idiom that making it easier to utilize
would be desirable?  I guess a good rule of thumb might be, if the sequence
of actions occur more frequently than the primitive commands like opening a
file it should be considered.

Maybe a way of doing it:

1. A special mark node as Task command.
2. A Add to lask marked task command, that clones a node and moves that node
into the Task node.
#@nonl
#@-node:ekr.20040918165519:Mark Task & Clone To Task commands
#@+node:ekr.20041022091645.1:Find Next Clone command
#@-node:ekr.20041022091645.1:Find Next Clone command
#@+node:ekr.20040315060557:Declone command
By: nobody ( Nobody/Anonymous ) 
 having a declone() method for vnodes?   
2004-03-15 04:36  

 hi,

Ive had a use for a declone() method in vnodes recently. Have you ever thought about adding a method that declones a clone? This would entail:

1. Making a clone node a normal node.

I can see this happening when cutting a node and pasting a node that is a clone. But there doesn't seem to be a dedicated function to do the operation. :)  
#@nonl
#@-node:ekr.20040315060557:Declone command
#@+node:ekr.20041219162724:Add dialog to insert recent directories
http://sourceforge.net/forum/message.php?msg_id=2903742
By: nobody

In the multifile plugin there is an option to insert a directory string.  I
use it alot for the @path directive.  What happens is that when executed a FileDialog
opens up and the user selects the directory he wants to use as a directory string.
When chosen the directory string is inserted into the text editor.

The good of this:
1. It makes using path simpler, you dont have to type out the directory path
yourself, just use the tkFileDialog to select it and have Leo insert the string.
For long directories this saves a lot of typing.

simple, short and quite helpful.  Thoughts? :)

-----------

Time to create a directory class??

#@-node:ekr.20041219162724:Add dialog to insert recent directories
#@+node:ekr.20031218072017.800:Improve extract section command
Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1858824
By: gilshwartz
Open discusstion

Currently Extract Section is only available if the first line in a selection
is a section name <<x>>. I would like to propose a few enhancements I think
should be useful, while I believe most of the code is already implemented in
Leo.

1. If the first line in a selection is not <<x>>, than Extract Section WILL
make a section name from the first line (or a version of it, see below), leave
the section name in the body, create a new node with that section name, and
will copy the selection including the first line to the new node.

Rational: this is useful when selecting a function or a class. Thus the section
name becomes the function or the class definition. The section name can either
be the full first line, or, knowing the language, Leo can make a nice section
name like it does in import, e.g. "function foo", or "class bar", without the
parameters list.

2. Even better, when Extract Section is called WITHOUT a selection it will look
for the first function/class definition before the cursor's position and will
either use it as a selection and do 1 above, or just mark it as selection, which
will enable 1 above upon a second Extract Section.

Rational: Leo does it beautifully in import and when a node's code starts to
build it is most convenient. Also, I think a variation on this was recently
asked by another user.

3. Add an option Merge Section, which when called from a named section will
merge it back to all the sections containing it.

Rational: make it easy (together with 2) to create/delete sections until the
sections picture of a new code becomes clear.

Gil

--

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1859516
By: nobody

Simpler & more intutive:
Mark text, select from menu - 'extract section', this presents a dialog box
in which you fill in the section name. It is too much work to type <<name>>
then select the whole thing...

As an enhancement, the dialog can show the first line of the selection as the
default section name, which obviously can be changed.

- Rajiv Bhagwat
#@-node:ekr.20031218072017.800:Improve extract section command
#@+node:ekr.20041130123243:Clear Undo command
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2859273
e

theres a config option to clear undo on save.
can that be a menu choice as well? 
clear undo now.
enable clear undo on save.
moot as it will be with the new config options
and any undo changes on the table.
maybe there is a single point to involke clear 
undo that could be run from a button?

with py2.3 after allot of small edits on an open leo after a few hours gc can
hit unexpectedly and last several minutes
and return at any time lasting several more minutes.
I think its gc related because the memory use and disk grinding demanding I
free up memory or kill python.

I have no idea if undo is the cause,
 just guessing.
using cvs of last week. I just updated, 
will let you know if it happens again.
(new error reporting jump to error is great)

usually I don't edit in the same process that long.
I have run scripts from leo that run 6, 12 
or 24 hours no problem. 
maybe I can turn on some internals reporting and
get some feedback on whats going on from python if it happens again. 
or run the gc script before and after.

 win98 128meg w/maxmem memory defrager that works well.
but I go from 50% free to 10% when this starts happening.
I haven't noticed this problem yet in py2.4, and it is peppier,
but don't use py2.4 enough. it doesn't happen every day.
I reboot at least once a day for various reasons.
so it isn't that either. 
you do need to reboot and or exit python once it starts.
this was never an issue with py2.2 and Leo 4.1 or less with only 64 megs.
I don't really have any other long running python processes to compare to Leo. 
can't say what it is.
Aha, progress. 
this started sometime early in 4.2 or late 4.1
but I can still be persuaded something in my 
local system is to blame, some install or dll update. or script, psyco or plugin
related.

nonwithstanding, I should be taking better advantage Moore's law in my CPU and
memory.
I only notice this when I'm running the same leo over a few hours of constant
editing and running scrips.
and when I exit python and restart leo everything returns to normal.
more a supporting anomaly report 
than a bug report or feature request.
#@nonl
#@-node:ekr.20041130123243:Clear Undo command
#@+node:ekr.20031218072017.790:Import dialog improvements
@nocolor

Other options I though would be really handy:

1. Use an existing node as a source also

2. Use an node from another Leo file.. I am not sure what the syntax for that
would be exactly

3. From a URL.. this would be really cool. People could post outlines not only
as existing Leo xml files, but as text files or even dynamic scripts. The code
to handle these would presumably need to deal with http:// intelligently. But
that's easy in Python. Rebol is great at that too.

4. Other XML file with valid filepaths in them.
That's probably a much bigger project like Leo 3.10  

Jason
#@-node:ekr.20031218072017.790:Import dialog improvements
#@+node:ekr.20031218072017.807:Put up file dialog on empty @url, etc.
@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2003457
By: dsalomoni

Proposal: modify the code for @url so that if you type for example just "@url"
(no file specified) in a headline, a window pops up allowing you to browse the
local file system and select the file (similar to what browsers do when you
want to open a file).

This would be more convenient than manually writing @url
file://a/long/path/to/the/file. @read-only nodes already allow this, it would
perhaps be nice if all these types of plugins (@folder might be another one
for example) and directives (@file etc) had the same behavior (and this should
probably be specified in some guidelines for writing new plugins -see e.g. the
jedit plugin guidelines).

Davide
#@-node:ekr.20031218072017.807:Put up file dialog on empty @url, etc.
#@+node:ekr.20040217153407:User customizeable tangling and untangling
@template plugin does some (most?) of this.
#@nonl
#@-node:ekr.20040217153407:User customizeable tangling and untangling
#@-node:ekr.20041022083833.1:Easy
#@+node:ekr.20050917080509:Improve g.utils_rename?
#@+node:ekr.20050917080509.1:Request
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3342865
By: nobody

I had to move all my files on a nsf share, so - when tangling - I got the following
error: OSError: [Errno 18] Invalid cross-device link. Searching the source,
I found that the problem was caused by trying first os.rename instead of
distutils.file_util.move_file. So, I propose to change the following piece of
code (in src/leoGlobals.py - utils_rename)

    try:
        if 1: # Use rename in all cases.
            os.rename(src,dst)
            if mode:
                g.utils_chmod(dst,mode,verbose)
            return True
        else:
            # This isn't a great solution: distutils.file_util may not exist.
            if sys.platform=="win32":
                os.rename(src,dst)
            else:
                from distutils.file_util import move_file
                move_file(src,dst)
            if mode:
                g.utils_chmod(dst,mode,verbose)
            return True

with this one:

    try:
        from distutils.file_util import move_file
        distutils_ok=True
    except:
        distutils_ok=False
    try:            
        if distutils_ok: 
            move_file(src,dst)
        else:    
            # Use rename only if distutils isn't available.
            os.rename(src,dst)
        if mode:
            g.utils_chmod(dst,mode,verbose)
        return True

Tiziano Tissino <t.tissino@itaca.coopsoc.it>
#@nonl
#@-node:ekr.20050917080509.1:Request
#@+node:ekr.20031218072017.1263:g.utils_rename & test
<< about os.rename >>

def utils_rename (src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''

    head, tail = g.os_path_split(dst)
    if head and len(head) > 0:
        g.makeAllNonExistentDirectories(head)

    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
    try:
        # New in Leo 4.4b1: try using shutil first.
        try:
            import shutil # shutil is new in Python 2.3
            shutil.move(src,dst)
        except ImportError:
            if sys.platform == "win32":
                os.rename(src,dst)
            else:
                try:
                    # Alas, distutils.file_util may not exist.
                    from distutils.file_util import move_file
                    move_file(src,dst)
                except ImportError:
                    # Desperation: may give: 'Invalid cross-device link'
                    os.rename(src,dst)
        if mode:
            g.utils_chmod(dst,mode,verbose)
        return True
    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception(full=False)
        return False
#@nonl
#@+node:ekr.20050104123726.1:<< about os.rename >>
@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
#@nonl
#@-node:ekr.20050104123726.1:<< about os.rename >>
#@+node:ekr.20050107085710.1:test_g_utils_rename
def test_g_utils_rename():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107085710.1:test_g_utils_rename
#@-node:ekr.20031218072017.1263:g.utils_rename & test
#@-node:ekr.20050917080509:Improve g.utils_rename?
#@+node:ekr.20041004193600:Add safeguards on @button and @script
#@+node:ekr.20041004193600.1:Paul's first posting
@killcolor
http://sourceforge.net/forum/message.php?msg_id=2788477
By: paulpaterson

Perhaps some minor bridling ...

What about managing the security of scripts using some algorithm like this,

1. When Leo scans for @buttons, @scripts etc it makes a list of scripts
2. For each script ...
3.   Calculate a secure hash of the script contents
4.   Consult central repository to see if hash is recognized
5.   If hash recognized
6.     Accept it
7.   Else
8.     Force user to acknowledge the script or disable it

The cental repository could be a file in your Leo directory which stores "approved"
hashes.

Clicking on a @buttons, @script node and selecting "Approve script" would add
the hash to the repository. Selecting "Disable script" would remove it. There
could also be a menu item to bring up a window of approved/not approved script
nodes so that you could centrally manage them.


Additional housekeeping on the list of hashes is possible but probably isn't
required since the size is small and there shouldn't be any collisions. If required
you could just blow away the file and then re-enable all scripts.

Using this approach, no new script would be able to run without being enabled
by the user. There is still the possibility that another plugin or script could
disable the security mechanism or tamper with the repository but with Leo's
architecture a plugin could already do anything anyway so this isn't an additional
hole.

It would protect from 

@script
import os
os.system("del *.*")

being submitted to an OS project!
#@nonl
#@-node:ekr.20041004193600.1:Paul's first posting
#@+node:ekr.20041005075955:Pault's second posting
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2789123
By: paulpaterson

I'm not an expert but from the Python docs this looks like the way to do it,

> import sha
> s = sha.sha("hello there")
> s.hexdigest()
'6e71b3cac15d32fe2d36c270887df9479c25c640'

> s = sha.sha("hello there hacked")
'a42837bba84c53cabd52a98f3671809d475c707f'

It looks like the md5 module offers a similar function but uses less bits.

From what I understand the hexdigest should be different for any change in the
text. Also no two strings should give the same hash (although I seem to recall
that someone found a collision recently).
#@-node:ekr.20041005075955:Pault's second posting
#@+node:ekr.20041003115036:Add --noscripting command-line option
This will disable @button, @script, etc.
#@nonl
#@-node:ekr.20041003115036:Add --noscripting command-line option
#@-node:ekr.20041004193600:Add safeguards on @button and @script
#@+node:ekr.20040329094003:Apply patch command
#@-node:ekr.20040329094003:Apply patch command
#@+node:ekr.20040217090833:Change how Open with works?
By: rogererens ( Roger Erens ) 
 RE: Documentation for 4.1rc3   
2004-02-04 10:04  

@nocolor

It is stated that you can edit the temporary file with the editor as named in the "Open with..." submenu.
However, the temporary files are edited with the application that is associated with their extension. In my case I always fire up vim with .txt-files.

Hence the menu item would be better called something like "Open as..." with submenu items like ".doc file" or ".txt file"

Or, use something else instead of "os.startfile" to really use the intended editor.
#@nonl
#@-node:ekr.20040217090833:Change how Open with works?
#@+node:ekr.20031218072017.748:Import/Export to yaml
Need a good yaml parser first: I don't want to write another parser by hand.
#@nonl
#@-node:ekr.20031218072017.748:Import/Export to yaml
#@+node:ekr.20031218072017.754:Open text files in text window
The at_view plugin already does something like this.
#@nonl
#@-node:ekr.20031218072017.754:Open text files in text window
#@+node:ekr.20041016134312.2:Standard Weave command
Use noweb and TeX, or maybe Pyx.
#@nonl
#@-node:ekr.20041016134312.2:Standard Weave command
#@+node:ekr.20040914095432:Use TreeCC to create generalized import
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2754954
RE: euphoria or general language plugins  
2004-09-11 20:37
>>Leo doesn't really understand languages otherwise.
import is another area Leo is too hardwired
wrt language. if a plugin for each language
could preprocess the file or code string and insert some minimal sentinals to create nodes and headlines,
then pass the string to Leo to do the dirty work, adding new languages for import could be easier.
I'm at this point in a new html file import,
creating the nodes while parsing is more complicated than one would like.
I think this has been discussed before, so
maybe will have to search the forums before I say more.

e

---------

http://sourceforge.net/forum/message.php?msg_id=2758616
By: differance

Check out treecc:
http://www.southern-storm.com.au/treecc.html
http://www.southern-storm.com.au/treecc_essay.html

It was developed for DotGNU, but I think you should be able to use it.

Seth

#@-node:ekr.20040914095432:Use TreeCC to create generalized import
#@-node:ekr.20041228091154:Commands
#@+node:ekr.20041022083226:Directives
#@+node:ekr.20050225070857:@path stuff
#@+node:ekr.20050121081635:Request:  cumulative @path directives
@killcolor
https://sourceforge.net/forum/message.php?msg_id=2936513
By: ktenney

In the @view plugin is a method, currentPath() which examines the current headline
and body, and the headlines and bodies of it's parents, looking for @path and
@view directives. It builds a path from them and checks for validity.

if a top level node contains;
@path /home/ktenney

and a descendant of that node contains;
@path projects/myproject

Then a node further down the tree which contains;
@view readme.txt

will display /home/ktenney/projects/myproject/readme.txt

I like this principle of cumulative paths, and would like other plugins to work
the same way ... @image, @url etc.

This brings me to my question, would it make sense for Leo to offer a 'Plugin'
class to inherit from? It seems that there are some operations that are being
re-written in many plugins.
#@-node:ekr.20050121081635:Request:  cumulative @path directives
#@+node:ekr.20050222045210:Better @path conventions
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.dialogs = 0 # Count of open dialogs.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.globalOpenDir = None # The directory last used to open a file.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scanErrors = 0 # The number of errors seen by g.scanError.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.statsDict = {} # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.trace_gc = False # defined in run()
    self.trace_gc_calls = False # defined in run()
    self.trace_gc_verbose = False # defined in run()
    self.trace_gc_inited = False
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None
    
    << Define global constants >>
    << Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20031218072017.1264:getBaseDirectory
# Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory(c=None):

    base = app.config.relative_path_base_directory

    if base and base == "!":
        base = app.loadDir
    elif base and base == ".":
        base = c.openDirectory

    # g.trace(base)
    if base and len(base) > 0 and g.os_path_isabs(base):
        return base # base need not exist yet.
    else:
        return "" # No relative base given.
#@-node:ekr.20031218072017.1264:getBaseDirectory
#@-node:ekr.20050222045210:Better @path conventions
#@-node:ekr.20050225070857:@path stuff
#@+node:ekr.20041130103128:(killcolor also kills autoindenting )
By: Roger Erens - rogererens
@
2004-11-25 09:14
On leo4.2, winXP, my default language is Python and smart_auto_indent=0. 
Normally, after ending a line with a colon, the next line gets indented by 1 tab, also in comment-sections. 
When using an @killcolor directive in a node, the line following one that ends with a colon starts at column zero. 
I think it is unreasonable for @killcolor to interfere with indenting.
#@-node:ekr.20041130103128:(killcolor also kills autoindenting )
#@+node:ekr.20031218072017.833:Use @file extension by default if no @language
@nocolor

Open discussion
By: jasonic ( Jason Cunliffe ) 
 use of @language   
2003-07-16 03:40  

I am wondering why Leo does not default to just use the file suffix in @file nodes, instead of obliging @language line in in the body pane 

For example any @file ending with a suffix as defined in the language extensions could just default to use those. 

".py" for python 
".r" for rebol 
".as" for actionscript etc.. 

Should anyone need to over-ride those, they could use @language.
#@nonl
#@-node:ekr.20031218072017.833:Use @file extension by default if no @language
#@+node:ekr.20041016134312.1:Allow multiple @language directives in a single node
@killcolor

Treat @language like @color: ambiguous nodes (nodes containing more than one
@language directive) should not affect descendent nodes.
#@nonl
#@-node:ekr.20041016134312.1:Allow multiple @language directives in a single node
#@+node:ekr.20031218072017.805:Allow other section delims besides << and >>
Maybe the section operator could be customizable, 
I personally prefer the wiki way [[name of section]]. 

@setlink-tag [[ ]] 
#@-node:ekr.20031218072017.805:Allow other section delims besides << and >>
#@+node:ekr.20031218072017.745:@@first <n>
@nocolor

Hate to break into the grand design discussions, but here's a hopefully small thing. If you need to place a good sized copyright statement at the top of your files, LEO doesn't handle this case very cleanly. As I'm sure you're aware, you wind up with a matching number of @@first lines for each leading line in your source. 

As an example: 
# 1 
# 2 
# 3 
# 4 
# 5 
#@verbatim
#@+leo 
#@verbatim
#@+node:0::@file /tmp/firstcheck.py 
#@verbatim
#@+body 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@@first 
#@verbatim
#@+doc 
# 
# How many firsts do I get? 

#@verbatim
#@-doc 
#@verbatim
#@@c 
Start code. 
#@verbatim
#@-body 
#@verbatim
#@-node:0::@file /tmp/firstcheck.py 
#@verbatim
#@-leo 

My fellow co-workers who don't use LEO, aren't exactly loving me here. 

Might we introduce an: 

@@first <num> 

Type tag instead? So one '@@first 5' could represent all 5 of the above @@first lines? It makes for a smaller, cleaner LEO footprint and will tick off non-LEO users much less. 

Thanks. 

- ordinarius 
#@nonl
#@-node:ekr.20031218072017.745:@@first <n>
#@+node:ekr.20031218072017.795:Metatags
@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 3.11 todo list & schedule   
2003-02-11 03:25  

Here are some features I'd like to see: 
 
3. Metatags. @sectionname or @savedate are expanded to the appropriate text when saved.

-marshall-  

There are quite a few of these now.  It would be good to generalize:
- Register @node type.
#@-node:ekr.20031218072017.795:Metatags
#@+node:ekr.20041130104552:(Support bird-track programs/comments?)
@killcolor

By: Guenther Enthaler - genthaler
RE: Haskell support  
2004-11-18 22:55

There's a literate programming mode in Haskell (and in a number of other functional programming languages such as Clean & Curry), where the program is in a comment, usually where the line starts with ">" (bird track style, I think it's called), and the comments/documentation are freeform. It would be difficult but cool if Leo could support it, if only because the sentinels in the derived files wouldn't make whole file look so busy. 
 
Gnther 
#@nonl
#@-node:ekr.20041130104552:(Support bird-track programs/comments?)
#@-node:ekr.20041022083226:Directives
#@+node:ekr.20041228093301:Directories
#@+node:ekr.20041022070154:(options for setting working directory during startup)
#@+node:ekr.20041022070154.1:Request & response
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2815599
By: Antonio Pala

All plugins I have tried (notably @run and the @rst variants) have their working
directory set to my home directory, regardless of the position of the Leo file
and all @path directives. This renders most of them useless, since I would have
to use absolute pathnames. Is this the way they were meant to work, or is there
a bug somewhere? Or maybe I have missed some configuration parameter?

I am using Leo 4.2 with Python 2.3 on Linux.

> All plugins I have tried (notably @run and the @rst variants) have their working directory set to my home directory, regardless of the position of the Leo file and all @path directives.

Directory issues are different on different platforms.

I would welcome specific proposals for setting directories during startup.  Early in the startup process Leo sets g.app.loadDir to the directory from which Leo was loaded.  Plugins can use this directory to set the working directory as they choose.

@path directives will have no effect on plugins:  they are loaded before the outline.

> This renders most [plugins] useless, since I would have to use absolute pathnames.

No, it means you might have to add a few lines of code to your plugin to make it work just as you would like it to work.

> Is this the way they were meant to work?

I don't have much control over how plugins were "meant" to work.  However, an improved plugin manager might have facilities for setting the working directory.

This is a non-trivial issue;   Leo uses and sets paths in many places in the code.  It seems dubious to have plugins change the working directory at random times.  Perhaps an option that inits the working directory would be good.  The new config system will allow per-outline options as well as global option. I believe such options could be loaded before plugins.

Edward
#@nonl
#@-node:ekr.20041022070154.1:Request & response
#@-node:ekr.20041022070154:(options for setting working directory during startup)
#@+node:ekr.20041029083459:Remember Import directory
By: Kent Tenney - ktenney
Import to @file request  
2004-10-28 11:27
Howdy, 
 
Please ignore if this is a difficult feature to implement. 
 
File->Import->Import to @file  
always starts in .../leo/src 
 
I would prefer if it opened to the last directory from 
which a file was imported. 
 
I often find myself importing several files from the same area of the directory tree, and repeatedly navigating there from leo/src gets tiresome. 
 
Thanks, 
Kent
#@-node:ekr.20041029083459:Remember Import directory
#@-node:ekr.20041228093301:Directories
#@+node:ekr.20041228084018.6:Foreign languages
Including, e.g., Undo messages.
#@nonl
#@-node:ekr.20041228084018.6:Foreign languages
#@+node:EKR.20040512082621:HTML widgets
#@+node:EKR.20040512082621.1:htmllib.tcl
http://sourceforge.net/forum/message.php?msg_id=2565345
By: nobody

I just met a nice TCL-based html help viewer bundled with the evaluation version
of Fujitsu-Siemens OpenFT for Unix (see
fujitsu-siemens.com/products/software/openseas/openft.html)

It is based on a TCL library htmllib.tcl, written by Stephen Uhler in 1995 while
working in Sun's TCL group.Iit seemts that this lib is owned by Sun and i'm
not certain about license. It is freely downloadable, anyway.

The usage is really simple -- you have to create a text widget, a string variable
containing html text and a link callback, then feed all three to the library
routine. It should be not hard pythonize this process.

see http://www.usenix.org/publications/login/1999-8/features/tclsh.html,
ftp://ftp.scriptics.com/pub/tcl/misc/html_library-0.3.tar.gz
or just google for htmllib.tcl
#@-node:EKR.20040512082621.1:htmllib.tcl
#@+node:ekr.20031218072017.729:HTML rendering in Leo's body pane
#@+node:ekr.20031218072017.731:HTML plugin: opml
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2283466
By: billp9619

FYI
I played around with opml a while back and it seemed very versatile.

It basically consists of an xml file of nested outline tags similiar to v-nodes
in leo xml. This then works with an xsl stylesheet that displays the outline
in a browser with scripted outline manipulation. (Uses div tags for this
display.)

What I discovered is that any html can make up the outline nodes , even forms,
etc. which collapse with the outline interaction. Just that the angle brackets
in the html must be escaped as is done within leo t nodes in .leo xml.

Actually, it would be interesting to see an addin that just passes leo nodes
to opml and then pops into the default browser. Also keep in mind that javascript
has an eval() statement that can be passed any script as a string. The leo text
box could be a form textarea box except that then there is no way to emulate
syntax coloring. Alternatively, this could be a floating window wrappiing node
text in html/body. (if nothing else, just destroy/close the window and reinitialize).
Maybe the images used in the opml could have javascript events like onclick()
to trigger refreshing leo text box from the t-nodes stored in an array or in
hidden form boxes.

Of course the effect of the stylesheet could be done via python script if no
xslt in the receiving browser. The minimal html and script might be just boilerplate
output.

regards,
bill p
#@nonl
#@-node:ekr.20031218072017.731:HTML plugin: opml
#@-node:ekr.20031218072017.729:HTML rendering in Leo's body pane
#@-node:EKR.20040512082621:HTML widgets
#@+node:ekr.20050509085713:Installer
#@+node:ekr.20050328093147.1:Report: improving installer
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3064212
By: djsg

The following applies to Leo 4.3, which is in alpha as I write this. It describes
the LeoSetup routine that I submitted to Edward to solve the "can't find Python"
problem, and which Edward cleaned up for distribution.

I think a few further issues need attention. I noticed them while working on
the "can't find Python" problem, and deferred dealing with them. This appears
to me to be a good time to pick them up.

Before I start work on them, I would like to lay them out for your comment.
Are they pains in the first place? Are my proposals good enough, and do they
make sense?

Issue 1. LeoSetup still thinks Leo's user is an Administrator who owns the whole
machine.

For explanation, let's say that I log on as David to Windows 2000 or Windows
XP and install Leo 4.3. You then log out. You log in as Edward, and click Start,
pick Programs... you have no visible entry for Leo!

The current Setup routine allows no one but David to use Leo on this computer.
To make things worse, when I go to use Leo, I have to log in to Windows using
the account under which I installed it, which has Administrator rights to the
computer. In other words, I can't use Leo without operating the computer in
a mode that leaves it needlessly vulnerable to security violations.

Issue 2. LeoSetup allows only one copy of Leo on a given computer. 

LeoSetup assumes that you want Leo in C:\Program Files\Leo. The installer can
override that already. LeoSetup also goes to some trouble to set up the usual
click-to-open behavior for .leo files. That behavior is tied to the copy of
Python that was current when I ran LeoSetup, and tied to the copy of Leo that
was installed most recently.

Proposal: While LeoSetup should allow all accounts to share the Python code
for core Leo and its plug-ins, my guess is that we don't want to enforce that,
since Leo is a programmer's tool and the individual programmer will wish to
modify Leo and its pieces for the programmer's use.

Proposal Option 1. Setup should ask whether to install Leo for everyone or for
the installer's account only. If the answer to that question is "yes," Setup
should give the user a private copy of everything that comes with Leo -- the
only application shared should be the current Python, assuming that it is installed
for all users.

Python.org's installer for Python 2.4 allows the installed Python to work only
for the account that installed it. I found this in December and wrote code to
handle it, which I then commented out since the issue wasn't critical. I can
check a computer with a single-account installation of Python in order to figure
out how a single-account installation of Leo would have to handle the click-to-open
behavior.

Proposal Option 2. When LeoSetup finds Python installed for that single user,
it should ask whether to install Leo for the installer's account only. If the
answer to that question is "yes," Setup should give the user a private copy
of everything that comes with Leo and use the single-user installation of Python.
Why does this matter. If you need to test your plug-ins with different versions
of Python, this would make that easier.

Issue 3. LeoSetup always installs Python MegaWidgets ("Pmw"), even on computers
whose installed Python installation already includes it.

Proposal: put up a dialog box and ask whether Setup should install Pmw  I do
not know whether doing this is a good idea.

Issue 4. LeoSetup does not run without human intervention. This complicates
deploying Leo in multi-computer sites.

The message box that displays the path of the Python installation found is one
issue. I put it in to allow the installer to cross-check Setup's behavior. Since
nobody has complained about problems with the code I wrote to fix the problem
installing with Python 2.4 and Active Python, Setup need no longer force the
installer to review the message box's contents.

Proposal: The message box needs to time out after, say, 15 seconds. 

I last looked at the installer three months ago so I would have to look at the
rest of it for other barriers to automated installation.

Let me know what you think. I won't be able to start work for a week or so,
so there's no rush.

-- David
#@nonl
#@-node:ekr.20050328093147.1:Report: improving installer
#@-node:ekr.20050509085713:Installer
#@+node:ekr.20041228085245:Options
#@+node:ekr.20031218072017.740:Disallow writes outside a "top-level" folder
1. Warn when creating _any_ new file.

2. Warn when rewriting any file that was not read properly.

This prevents "hijacking" an already existing file.
#@nonl
#@-node:ekr.20031218072017.740:Disallow writes outside a "top-level" folder
#@+node:ekr.20040213090121:* Insert at end
@nocolor

By: tibi ( Thibaut Champenier ) 
 inserting a new node   
2004-02-13 13:23  

 Hi,

When doing ctrl+i I on the node that has children I would prefer Leo to insert the new node as the last children instead of the first. It just makes more sense to me, for exemple when you take a big file and cut it in subnodes you typically start at the top and create new nodes while paging down the file.
What do you think ?
To try it just make this little change:
RCS file: /cvsroot/leo/leo/src/leoCommands.py,v
retrieving revision 1.76
diff -r1.76 leoCommands.py
2516c2516
< v = current.insertAsNthChild(0)
---
> v = current.insertAsLastChild()  
#@nonl
#@-node:ekr.20040213090121:* Insert at end
#@+node:ekr.20040311022923:Make sentinel name in @-node optional
#@-node:ekr.20040311022923:Make sentinel name in @-node optional
#@-node:ekr.20041228085245:Options
#@+node:ekr.20041228090855.2:Plugins
#@+node:ekr.20041022083005.3:@path and other directives accept python expressions
#@-node:ekr.20041022083005.3:@path and other directives accept python expressions
#@+node:ekr.20031218072017.797:Allow @file http & @file ftp
I'd like to see leo's @file can be extended to cover more protocols, like REBOL's "read" does. 

in short, it would be very sweet if the following work: 

@file http://www.somedomain.org/python/foo.py 

@file pass@ftp.sd.org/python/foo.py" target="_blank" target="_new">ftp://user:pass@ftp.sd.org/python/foo.py> 

while we are at it, what about xmlrpc/soap? 

should there be new directive, like @source ?
#@nonl
#@+node:ekr.20031218072017.810:Remote access Scott Powell
I will wait. Here's clarification, when you're ready for it:

All of my projects are stored on remote computers, and accessed via FTP. 
What I want is basically the ability to open up these projects directly 
through leo, instead of transferring the files manually between my computer 
and the computers that hold my projects, preferably through FTP.

My solution: A new menu item called 'FTP' or 'Remote'. Click on this, and an 
FTP dialog opens up, with an empty list of FTP sites, and the ability to add 
more. You select a site, and it brings up a list of files. You select a 
file, and it is added to your project. When you hit 'save', it automatically 
does an FTP send.

Python makes this a lot easier with the builtin module 'ftplib'. I'm sure 
there are similar things for C++. I hope you take this idea into 
consideration.

Scott Powell
CEO, Dev Designs
#@-node:ekr.20031218072017.810:Remote access Scott Powell
#@-node:ekr.20031218072017.797:Allow @file http & @file ftp
#@+node:ekr.20040123102724.2:Templates (already done?)
@nocolor
#@nonl
#@+node:ekr.20040123102724.3:daliuslt
https://sourceforge.net/forum/message.php?msg_id=2385991
By: nobody

I often found myself using the same template for many projects but something differs in them. E.g. name of files. So my offer is add new directive variable:

@variable ProjectName MyFunProject

Later in parent node, child nodes or headers I could use this as:

$(ProjectNode).py or smth. similar.
This line when tangling could be replaces with
MyFunProject.py

Of course, there comes some complexity with untangling, but it is just an offer :)

Dalius
#@-node:ekr.20040123102724.3:daliuslt
#@+node:ekr.20040123102724.4:Rich: @constant
https://sourceforge.net/forum/message.php?msg_id=2386199
By: nobody

Dalius-
FWIW, I like it! I also can think of a LOAD of variations (i.e., multi-line
variables, etc.), but I'll limit myself to one thing: 'variable' by definition
should be changeable. May I suggest you call the directive "@constant"?

--Rich
#@nonl
#@-node:ekr.20040123102724.4:Rich: @constant
#@+node:ekr.20040123102724.5:paulpaterson
https://sourceforge.net/forum/message.php?msg_id=2386359
By: paulpaterson

I like this idea because I think templating is an important "design pattern"
that Leo could usefully support. Currently you can only do this in a limited
way by cloning nodes across derived files, which is something Edward doesn't
like to do because it makes reading derived files ambiguous (same information
in more than one place). I still do this because I rarely read files into Leo,
I mostly explicitely tangle files out of Leo.

Back to your idea ;) ISTM that your idea works well for directives (you can
do the variable substitution) but for general text (where I think there is a
bigger gain) there are two issues,

1. The template itself is now present in multiple derived files (see above)

2. The file derived from the template has now lost the variable name because
it was substituted out for the variable value

The end result is that templated files would almost certainly have to be a one
way street for Leo - they are derived from the Leo file but never read back
in. If you don't mind having this restriction, which basically means you have
to use @root nodes, then I don't see a problem.

Presumably most of this could all be done with a tangle_done script - the only
problem is how to change directives.
#@nonl
#@-node:ekr.20040123102724.5:paulpaterson
#@+node:ekr.20040123102724.6:daliuslt
http://sourceforge.net/forum/message.php?msg_id=2389750
By: daliuslt

Just for your interests where is one way to create constants in leo (even multiline).
Let's way we have outline:

+-[ ] @file-nosent objects.mak
|   +-[clone] << my_const >>
+-[ ] @file-nosent makefile
    +-[close] << my_const >>

objects.mak is:
--
<< my_const >>.o:
gcc -g -c << my_const >>.c -o << my_const >>.o

<< my_const >>cmd.o:
gcc -g -c << my_const >>cmd.c -o << my_const >>cmd.o
--

makefile is
--
<< my_const >>:
gcc << my_const >>.o << my_const >>cmd.o -o << my_const >>
--

<< my_const >> can be:
test

While it works pretty good it still have some drawbacks:
1. You are forced to use @file-nosent. You can edit your files outside of Leo.
2. You can't use << my_const >> in header lines, while it would be really nice
if you could write
@file-nosent obj_<< my_const >>.mak
(Leo lacks introspection?)
3. Result is not 100% what you expect.

---

(constant = variable = define) ???

Constants and clones in fact are the same. Usually clones are used like symbolic
links (or shortcuts) not like clones or constants. I think this could be
separated.

Constants could be read back into leo. E.g.: you have constant value in leo
file and while reading back files to outline you change all values with constant
name.

I hope I am clear :)
Dalius
#@nonl
#@-node:ekr.20040123102724.6:daliuslt
#@-node:ekr.20040123102724.2:Templates (already done?)
#@-node:ekr.20041228090855.2:Plugins
#@+node:ekr.20050127110221:Printing & flash
@killcolor
https://sourceforge.net/forum/message.php?msg_id=2962825
By: jasonic

-- pdf -- 
yes I know what you mean, PDF has it uses.  If nicely embedded into Leo via
'reportwriter'  and some export scripts {and clear useinterfance} would stillbe
a good thing.


As I start to think about how to print Leo, I become more aware of the differneces
between Leo structures and linear [print] layouts.

Different kinds of outlines obviously will need different kinds of printing.
I don't yet have enough experience or overview.

--xslt--
Seems a natural way to go for printing Leo, but yet another langauge and syntax
to wrassle with. Last time I looked I went from being horrified to very impressed
to be being exhausted.

--htmlize--
thanks I'll check into that

"print to web"  should definitely be on Leo's missing PRINT MENU.

--swf [flash]--
This printing topic pushes me harder to get FLC  [my FlashLeoClient project]
into the Leosphere.

Flash has*limited*  CSS handling, but enough to do some nice and useful typographic
formatting in a pretty clean object-oriented manner.

FLC parses .leo files into a Flash object. Flash Textformat instances are created
using CSS and can be applied then to rendering any parts of  the deserialized
Leo object.. The beauty is it can be very fast and ynamic so I can imagine a
real-time WYSIWYG laytou tool for printing Leo to web and at the same making
it suitable at the same time for print-to-paper.

Since FLC is in the very first instance a READ-ONLY client tool for Leo, it
makes it a natural Leo printing service.

To complete full service, it woudl be good if Leo could create SWF files directly
itself, just like using PDF reportwriter.
There are a couple of libraries to help this 
- Ming [with PHP, Perl, Python and Ruby wrappers]
http://ming.sourceforge.net/

- makeswf.r [interesting REBOL/Flash dialect by David Oldes]
http://sweb.cz/oliva.david/swf/

These could also be both configured as web-services.
So Leo print-to-web would include by default rendering a flash swf file versoin
of itself either using locally installed libraries or by passing a view of itself
to a chosen client or server-based tool.

But even without those extra 'services' and libraries a single flash file in
the form of FLC could become an effective Leo printing kit. Using a standalone
desktop  version [not embedded in the browser, out of the sandbox] much more
is possible - remote control, peer-peer editing, file writing etc.

-- flashpaper2--
btw, Lately I've been using Flashpaper2 a lot to print all kinds of stuff, Often
from web pages to my local adhoc home filebase. It's a very fast lighweight
alternative to PDF, saves paper, has excellent zooming and nice search features
built-in.
Flashpaper renders a very litteral snapshot, but as I am discovering that turns
out to be extremely useful.
For example you visit a page and click on some links. Flashpaper saves teh pages
exactly as it looks, viisted links disntinguished.  In the era of info-overload,
even that crude mnemonic is valuable.

Alas, Flashpaper2 is not free nor open in the way Leo is. But worth to play
with it if only for for the experience.
30 day trial downlaod from
http://www.macromedia.com/software/flashpaper/

And of course the flash _players_ is free, so can send people flashpaper documents
just like PDF.
Brilliant when you have a big Excel spreadsheet or CAD document which would
normally get all messy printing across pages, confusing people.
Instead adjust and print to a generous 'piece' of flashpaper - letting your
coleagues pan and zoom to their comfort.

I've not quite figured out the place where  Leo meets Flashpaper, because Leo
needs to preserve its full pane contents. Flashpaper works fine with long web
pages, automatically reading the full window contents and cutting into a paginated
sequence, ready for paper printing.
Leo's does not have aprint menu, so it's off the sytem's print-devices map,
which Flash paper appearing just  like any phtycial printer.

I imagine is possible to fix that in Leo, but I do not where to begin and woudl
not be surprised to learn its a major heachche to write adn debug for multiple
operating systems.

An immediate alternative are screencapture tools like vnc2swf or MDM Capture.

[vnc2swf uses Ming-0.2a]
http://www.unixuser.org/~euske/vnc2swf/

http://www.multidmedia.com/software/capture/index.php

But much is hidden or lost from view. 
Still very vauable for creating dynamic narrative tutorials [aka screencasting]

AS you know I am very excited about what flash can do for Leo, and vice versa.
But I am concerned that there is not yet a 100% Leo means which supports people's
standard print needs and habits.
   
-- PRINT MENU-- 
Leo deserves good friendly printing features which anyone can use. At the moment
we have a confusing patchwork of choices. Printing Leo seems to be both harder
and easier than  first meets the eye.

Having a little library of export scripts - well named, documented and intended
to aid printing woudl go a long way. Thesse scripts anyone coiuld be called
by onayone given a Leo Outline, accessing a navabr button. PRINT MENU or list.
Or they can just insert the appropriate script  into an outline giving finer
grained print control on the fly.
#@nonl
#@-node:ekr.20050127110221:Printing & flash
#@+node:ekr.20041228092223.3:Scripting
#@+node:ekr.20031218072017.733:Execute scripts like IDE's do (does executeFile do this?)
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2321235
By: paulpaterson

I think I understand what Samir is getting at. 

In PythonWin, or other IDE's for other languages, you are able to execute the
"current program" in a way that it will behave identically to if it had been
run from the command line.

For Python this requires,

1. That the script run with __name__ == "__main__", so that the standard "if
__name__ ..." section will be executed properly.

2. You are able to pass command line parameters to the script. In some IDE's
you are able to set default command line parameters and these are "injected"
into the sys.argv (or equivalent) so that, as far as the program is concerned,
it looks like you ran it from the command line with some aruments.

The underlying assumption is that you want to run an entire program from Leo,
not just a script. I would find this very useful also as I could run unit tests
or even my entire apps by just hitting, for exampe, F5.

Paul
#@nonl
#@+node:ekr.20041022083005.5:Define name == "__main__"
#@-node:ekr.20041022083005.5:Define name == "__main__"
#@-node:ekr.20031218072017.733:Execute scripts like IDE's do (does executeFile do this?)
#@+node:EKR.20040611081747.1:Look at windows scripting
------cut openleo.pys
@path c:\bIn\pys\
@lineending crnl
@
w04609p09:57:19 a pys to open leo and do something.
you need the win32 extensions and you have to enable 
the script engine. details how on google or on the win32 page.

the sendkeys method can insert any test or control codes
msdn or microsoft.com/scripting

@c
pypath = r'C:\c\py\Python233'
py =  pypath + r'\python.exe -itOO '
leosrc = r'c:\c\leo\leo4CVS233\src'
name = "blank.leo"

WshShell = WScript.CreateObject("WScript.Shell")

#look like it comes up untitled 
# if it cant find an existing leo of that name?

WshShell.Run(py + leosrc + r'\Leo.py ../' + name)
WScript.Sleep(4900) 

wname = "untitled"

WshShell.AppActivate(wname);  WScript.Sleep(2100)
WshShell.SendKeys("%Fe");   WScript.Sleep(1300);  #^Q

---end openleo.pys
#@nonl
#@-node:EKR.20040611081747.1:Look at windows scripting
#@+node:ekr.20031218072017.753:Emacs comint-mode:  The improved Execute Script command does most of this
@nocolor

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
#@-node:ekr.20031218072017.753:Emacs comint-mode:  The improved Execute Script command does most of this
#@-node:ekr.20041228092223.3:Scripting
#@+node:ekr.20041228092223.4:Windows
#@+node:ekr.20050108051818:Add hyperlinks for url's
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2928436
By: jasonic

> I really do want and need to be able to embed basic links throughout out my Leo outlines in a natural 2005 fashion. 

This should be fairly easy to do.

At present, the use_hyperlinks configuration option controls whether Leo generates 'live' hyperlinks for section names.  I don't enable this be default because I dislike jumping around the outline.  Instead, I use clones.

The code to do these kinds of hyperlinks is pretty straightforward.  There is a little code in the colorizer and callbacks in the leoTkinterTree, iirc.

Supporting hyperlinks to urls would be similar.  They could appear in the following situations:

- Anywhere where @language plain is in effect.
- In comments where @language (a programming language) is in effect.
- Anywhere (except in comments?) where @language html is in effect.

This would make a straightforward plugin.  Mind you, this should be in Leo's core, but a plugin would get my attention :-)  Perhaps the reason I haven't done this is that I keep thinking a generalized syntax colorer is near ;-)

Edward
#@nonl
#@-node:ekr.20050108051818:Add hyperlinks for url's
#@+node:ekr.20041022083005.2:add a Stop button for find/change
#@-node:ekr.20041022083005.2:add a Stop button for find/change
#@+node:ekr.20031218072017.746:Minimizing/maximizing windows
@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2090601
By: jasonic

I'll be happy to run some test and report to you. But  I suspect from your post
a slight misunderstanding about Alt+Tab.

Alt+Tab just toggles the active window.
It works fine with Leo on Windows wherver I have tried it.

Resizing wondows via hotkeys is another matter.
The special "Windows" Key + m will minimize all windows. 

But unfortunately I've not yet discovered any opposite shortcut to  maximize
all windows :-(
I've tried various 3rd party hotkey utililties, but somehow always end up dropping
them.

<rant>
I really hate wasting any time dragging windows around and resizing them or
clicking to bring them into top focus. As I work mainly with graphics, and mult-task
intesenlty bwetn apps,  it is especially important to reduce visual clutter
on screen.

For many years the way to do this has been combining maximized [or minimized]
windows with  Alt+Tab. Alt+Tab  lets one jump rapidly betwen open apps and windows
without ever need to repostion or resize them.

As a consultant, its one of the first things I ever teach clients. Often it
transforms their perception of using Windows.

It is so painful to watch people dragging and rescaling  windows all over the
place. Ironically, I've witnessed some very smart programmers fly through vi
or emacs but then slow to tortoises when navigation mice and windows. I beleive
as long as we have the curertn wnidows UI paradigm,  use of Alt+Tab is an essential
part of  GUI 'litteracy' - an essentail skill all shoudl have. Alas its still
little known or discussed.

There is also a nice toggle feature so one can jump back to the last app/window
as its first "stop". Typically one is working between two apps for some specific
task, even though many are open.

Keeping one's finger on the 'Alt' key then tapping 'Tab' lets one hop along
the list.

Adding 'shift' to the mix helps one to go in reverse. 

Above all one can keep one hand on the mouse, the other on the keyboard [ALt+Tab]
and ones mind/eye on teh screen. For me it means left hand "plays" the bass
pattern using Alt+Tab along with the clipboard shortcuts [CTRL+ z,x,c,v] ,while
right hand on the mouse mouse  provides the melody.

I've been using variations on the above since 1987 when I bought an Amiga2000.
I seem to recall SGI had one also. And after learning about Alt+Tab on windows,
I  found a utility to work the same way on Macintosh.  I am very happy to discover
that MacOSX now has built-in ALt+Tab :-)
</rant>

Meanwhile, Iam  still wondering how to set Leo [3.12 beta 1, Python 2.2.2, Tk
8.3.2] default to a maxmimized or minimized window size by itself.

And also to remember the last size/position it had. I vaguely remember that
it used to do that, but perhaps I am mistaking it for some other software ?

thanks
Jason
#@-node:ekr.20031218072017.746:Minimizing/maximizing windows
#@+node:ekr.20031218072017.852:Scroll improvement
@nocolor

By: jwashin ( James Washington ) 
 Scrolling and the Tree Frame in Linux   
2003-10-20 12:13  

I'm using tk-8.4.3, python-2.2.3 on linux. The MouseWheel events do not work for me in the Tree Frame.

I added <Button-4> and <Button-5> bindings similar to the existing <MouseWheel> binding in LeoFrame.finishCreate(), associating them with two methods, LeoFrame.OnMouseScrollDown and LeoFrame.OnMouseScrollUp that took the appropriate parts of OnMouseWheel()

Now it works, sort-of. It scrolls properly unless the cursor is an I-Bar, e.g., over text. But at least this removes in-part the most glaring UI problem for me with Leo in tk. I suppose I am spoiled with the mouse wheel and want it to work everywhere.

Thanks for the great program.

-- Jim Washington  
#@-node:ekr.20031218072017.852:Scroll improvement
#@+node:ekr.20040220110030:Change cursor when caps lock is down
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2431552
By: nobody

From: Rich

 I just got nipped twice by the following effect: the Caps-Lock key is ON, but
because the LED is on the Caps-Lock key, it is hidden behind my hand. I hit
Ctrl-x, expecting to cut my selection, but the entire node is cut.

   I know there's a problem with tk and the shift key status, so I'm wondering
if it would be possible to change the shape of the cursor when the Caps-Lock
is ON (preferrably a big red flashing blot 8-), or otherwise show that Caps-Lock
is active ( "CAPS" on a status line, for instance).

  Another way: I don't know if this goes against an "anti-modalism rule," but
only allowing Ctrl-Shift-x|c|v in the outline pane would also be acceptable
to me.
#@nonl
#@-node:ekr.20040220110030:Change cursor when caps lock is down
#@+node:ekr.20041228074125:(Make drawing more flexible)
#@+node:ekr.20041228092223:Play with wiki markup
http://sourceforge.net/forum/message.php?msg_id=2205285
From: Rich

Color ''and'' italic/bold characters with @markup. One thing I'd like to
''not'' see are the markup characters in @file-nosent files.  "~~red:NOTE:~~"
does nothing for readability in plain text.
#@nonl
#@-node:ekr.20041228092223:Play with wiki markup
#@+node:EKR.20040602153716:(Finish drawUserIcons)
# Create a better way of writing user icons.
#@nonl
#@+node:ekr.20040317050439:Right-click to add user-specified attributes and icons
Also add corresponding commands.
#@nonl
#@-node:ekr.20040317050439:Right-click to add user-specified attributes and icons
#@+node:ekr.20040317184631:Design for drawUserIcons (use dict instead of tuples) (finished)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2477913
By: edream

A better design for user icons

Using tuples in t.unknownAttributes["icons"] is too constricted.  Much better
to have t.unknownAttributes["icons"] be a list of g.Bunches rather
than a list of tuples.  Each of these bunches could have the
following keys:

"type"

"file", "icon" or "url".  At present my prototype code uses "file" to specify
the location of an icon.

"where":

"beforeBox", "beforeIcon", "beforeHeadLine", "afterHeadline".  This specifies
where to put the icon.  The default would be "beforeHeadline".  "beforeBox"
means before the plus/minus box.  "beforeIcon" means before the standard icon.

"height":

the height of the icon to use when calculating the line height.  Default: get
from the icon itself, if possible.

"width":

the width of the icon to use when calculating where to put the following element.
Default: get from the icon, if possible.

"xoffset"

Leo draws the icon at x + xoffset, where x is determined by the where param
above.  Default 0.

"xpad"

The amount of extra space following the icon.  Default 0.

"yoffset"

Leo draws the icon at y + yoffset.  Default 0.

"ypad"

The amount of extra vertical space to add to the line height.  Default 0.

These offset and pad values are integer pixel values and may be positive or
negative.

"lineHeight"  NOT USED.

Overrides any calculated line height.  Default:  lineHeight = yoffset + height + ypad.

"onClick", "onRightClick", "onDoubleClick"

commands to call when the specified event happens.  By default, the "onRightClick"
icon will be bound to a popup menu that offers the user a chance to delete the
icon,  and maybe other options such as "nudging" the icon up or down, left or
right.

"popUpMenu"

a list of items to put in a popup menu.  This would be a convenience to avoid
having to use "onRightClick".

I think you get the idea.  We want the drawing code to support lots of common
things that plugins would like to do.  I'll probably think of other goodies,
but this already is a big step forward.  Note that each of these keys will have
a default, so plugins only need to specify keys that have non-default values.

Edward

P.S.  Other gui's might not be able to support all these options.  That's ok.
The drawing code in gui plugins should degrade gracefully.

EKR
#@nonl
#@-node:ekr.20040317184631:Design for drawUserIcons (use dict instead of tuples) (finished)
#@+node:ekr.20040317184631.2:Changes
@nocolor

"lineHeight"

This key won't be used.

t.unknownAttributes["lineYOffset"] 

An integer y offset for the entire line (except user icons, which are flexible enough).  You can use this to center the following vertically: the plus/minus box, the horizontal line to the plus/minus box, the standard headline box, and the Tk.Text widget for the headline.
#@nonl
#@-node:ekr.20040317184631.2:Changes
#@+node:ekr.20040317184631.1:To do
@nocolor

"onClick", "onRightClick", "onDoubleClick"

commands to call when the specified event happens.  By default, the "onRightClick"
icon will be bound to a popup menu that offers the user a chance to delete the
icon,  and maybe other options such as "nudging" the icon up or down, left or
right.

"popUpMenu"

a list of items to put in a popup menu.  This would be a convenience to avoid
having to use "onRightClick".

I think you get the idea.  We want the drawing code to support lots of common
things that plugins would like to do.  I'll probably think of other goodies,
but this already is a big step forward.  Note that each of these keys will have
a default, so plugins only need to specify keys that have non-default values.
#@nonl
#@-node:ekr.20040317184631.1:To do
#@+node:EKR.20040526202501:putUnknownAttributes
def putUnknownAttributes (self,torv):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        val = attrDict[key]
        self.putUa(torv,key,val)
#@nonl
#@-node:EKR.20040526202501:putUnknownAttributes
#@-node:EKR.20040602153716:(Finish drawUserIcons)
#@+node:ekr.20041201084142:Add convenience methods to change individual headlines color directly
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2877106

By: Paul Paterson - paulpaterson
RE: Can I color the headline text ?  
2004-12-01 08:01

The cleo plugin makes a permanent change to the headline appearance (using node attributes) while the footprints plugin makes a temporary change in the current session. Footprints was derived from cleo, although you might not be able to tell from looking at it! 
 
Cleo: http://sourceforge.net/forum/message.php?msg_id=2617221 
 
Footprints: http://sourceforge.net/forum/message.php?msg_id=2813450 
 
Between the two of them there should be enough information to help you achieve what you want. 
 
It is possible to do pretty much anything you want but you will have to provide the infrastructure yourself because Leo doesn't natively support it.  
#@nonl
#@-node:ekr.20041201084142:Add convenience methods to change individual headlines color directly
#@-node:ekr.20041228074125:(Make drawing more flexible)
#@+node:ekr.20040908104644:Leo splash screen
To create a splash screen:
    
- Draw the screen.
- Erase the screen with self.after(5000, self.destroy)
#@+node:ekr.20040908221501:@url http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/120687
#@-node:ekr.20040908221501:@url http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/120687
#@-node:ekr.20040908104644:Leo splash screen
#@+node:ekr.20031218072017.743:Note window for each node
http://sourceforge.net/forum/message.php?msg_id=2205285
From: Rich

I envision a short window at the bottom of the edit window that could hold notes
and comments about the code, such as "Test this harder" or "Find a better way of
phrasing this". This is currently available in uSoft Office and the Eclipse IDE
(http://www.eclipse.org). Perhaps a numeric reference, such as "<<1>>" could be
used.
#@nonl
#@-node:ekr.20031218072017.743:Note window for each node
#@-node:ekr.20041228092223.4:Windows
#@-node:ekr.20041228090855.3:Others
#@+node:ekr.20041228094138:4.5  LeoN and collaboration
This may not be so big a project.  LeoN already exists.
#@nonl
#@+node:ekr.20031218072017.420:Jabber
Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2016634
By: jasonic

I have been thinking about LeoZopeWiki integration. I am a recovering Zope addict
[1999-2001] :-)  I believe Zope offers a very valuable client and server for
Leo.

I think Ed higlighted the distinction of collboration vs. sharing. So consdering
that re:  Leo and CVS , Leo and Zope, Leo and wikis, I had another idea this
morning..

LEO+JABBER

Jabber is an open XML-based  instant messaging and *presence* system. Although
Jabber is typically used for IM chat, its core designers have a much bigger
vision in mind.

Jabber Software Foundation
http://www.jabber.org/
O'Reilly Book
http://www.oreilly.com/catalog/jabber/
Python Jabber library
http://jabberpy.sourceforge.net/

CVS etc all depend on runing diff on posted static files which are checked in
or out. Clearly valuable, and good for __sharing__ but not so suitable as the
communication paradigm needed for collboration.

Wikis and Zope all suffer from problem of versioning and the time delay and
lack of timely communications to their cobtributors. There is no 'shared state'
or persistence in the collaboration beyond their own files or objectdatabases.

For example if two people want to edit a wiki or Zope site, they have an imeedaiet
problem of knowing whether or not the someone else is working one it already.

Score:
Sharing 1
Collaboration 0

Two  or more people wanting to edit a common project based on Leo have the same
dilemma. They can check the leo file into a wiki, Zope or CVS, but they still
don't have direct communication at teh content level.

score:
Sharing 1
Collaboration 0

PROPOSAL: LeoJabber
1. Integrate a Jabber client into Leo 
2. Add special Leo module to jabberd [Jabber's server daemon]

Leo-based developers could work in direct communication with each other allowing
them to add, edit and comment nodes in a shared le-space, local or remote. Static
publishing via upload/import etc all still apply.

LeoJabber would mean subscribing developers could immediately be aware of changes
and then apply whatever strategy is appropriate for handling them, such as:
 
a. autoUpdate()
b. makeNewNode()
c. runDiffFunctions()
d. notifyPartners()
e. notifyPublic()
etc..

Jabber via its presencing mechanism offers real-time and just-in time communcations.
If you are logged out, then mesages are queued.

An open Jabber message session is actually one long piece of XML data passed
over an XMLSocket :-) Sounds like a great fit for Leo

- All Jabber configs are XML.
- Good smart open source community.
- Similar open embracing philsophy as Leo
- Jabber connects diverse messaging systems., MSN, AOL etc [Most are
close/proprietary, though the trend is toward greater openness and connectivity]
- Many Jabber clients already. There is even one written in Flash so that any
webpage can participate.

Embedding Jabber in Leo would allow 'discussion' threads to  be integrated.
Developers need to bounce idea and notes around just as this forum does. But
often they need to be more provate or more focused on project specifics.
WORKFLOW 
It is important to know  which code is uptodate, but arguably, even *more* important
is to know which people and what discussions are uptodate. And if not, what
their status is. The larger, longer the more global the develpoment office/project,
the more this is true.

IM [instant messaging] are popular largely becuae they offer direct communication
with status feedback to crucial people's workflow:
"off-line", "on-line", "back-soon", "later" etc

Jabber extends this idea to create a platform for any presence application.
That is its long term-goal.

So in a Leo deevlopment project, that presence might apply to adding status
mesages such as
"making changes" "new version" "debugging" "review only" "major re-write"

or perhaps status/presence woudl be used for much lower level Leo-specific
purposes.

"new node"
"cloned to .."
"@file imported"
"version uploaded"
etc

I am not suggesting that Leo forget CVS or file upload storage. But I think
Jabber may truly provide the Missing Link, literally for Leo collaboration.

Jabber Software Foundation
http://www.jabber.org/
O'Reilly Book
http://www.oreilly.com/catalog/jabber/
Python Jabber library
http://jabberpy.sourceforge.net/

hope this makes sense
Jason
#@-node:ekr.20031218072017.420:Jabber
#@+node:ekr.20031218072017.411:From Rodrigo
Developers Forum
By: rodrigo_b ( Rodrigo Benenson ) 
 RE: Leo over the network   
2003-05-10 00:06  
So this is my first proposal: 

Requirements 
-------------------- 

* Read remote outlines. 
** With Leo clients. 
** Over the web. 

* Edit remote outlines. 

* Import remote outlines (retrieve outlines from the web). 

* Synchronize local outlines with remote ones (web to local and local to web). 

* Publish outlines (send outlines to the web). 

* The Leo client have to be keept lighweigth. 

* The Leo remote outline access server should be a lighweigth daemon. 

* This daemon should automagically render HTML from the outlines. 

* The outlines should be editable from the web and via Leo client. 

* Concurency management is must. 

* The remote servers should be included in the leo client as leo nodes (just like leo files, but remotes). 
"@leo-outline leo.server.org:854" 

* By this way I could have access to local server nodes. 
"@leo-outline localhost:854" 

* The remote server should offer one and only one big outline with sub nodes, and so on, and so on... 

* At least the concurency should be managed as "when someone write, all the other ones only can read" 

* It is better if Leo devellop simultaneaously some hypertext/wiki extensions. 

---------------------------- 
End of requeriments 

This requeriments requires a client-server architecture, with basic commands as: 
- Update node 
- Lock/release node 
- Edit outline 
- Download outline 
- Upload outline 

well that is by the moment, I hope that we will be able to create a Finite, clear, requeriments list for this branch of Leo. 

RodrigoB.  

#@-node:ekr.20031218072017.411:From Rodrigo
#@-node:ekr.20041228094138:4.5  LeoN and collaboration
#@+node:ekr.20041228084143:Maybe
#@+node:ekr.20041007052853:(Fix problems with paste on Linux)
@color
#@nonl
#@+node:ekr.20041007052853.1:@url http://www.freedesktop.org/standards/clipboards-spec/clipboards.txt
#@-node:ekr.20041007052853.1:@url http://www.freedesktop.org/standards/clipboards-spec/clipboards.txt
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self,event=None):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    # g.trace(wname,s,i,j)
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
    
    frame = self.frame ; c = self.c ; k = c.k ; t = self.bodyCtrl
    
    t.bind('<Key>', k.masterKeyHandler)

    for kind,func,handler in (
        ('<Button-1>',  frame.OnBodyClick,          k.masterClickHandler),
        ('<Button-3>',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('<Double-1>',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('<Double-3>',  None,                       k.masterDoubleClick3Handler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        t.bind(kind,bodyClickCallback)
            
    if sys.platform.startswith('win'):
        # Support Linux middle-button paste easter egg.
        t.bind("<Button-2>",frame.OnPaste)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:EKR.20040604082214:Use virtual events for Copy, Paste etc.
@nocolor

- This might fix some binding problems on some platforms.

- Might want to define <<localUndo>> for undo in Find Panel.

- Probably should define <<selectAll>> for Find Panel and similar stuff.
#@nonl
#@-node:EKR.20040604082214:Use virtual events for Copy, Paste etc.
#@-node:ekr.20041007052853:(Fix problems with paste on Linux)
#@+node:ekr.20041228084830.2:Gui stuff...
#@+node:ekr.20041228084830.3:Finish wxWindows plugin
#@-node:ekr.20041228084830.3:Finish wxWindows plugin
#@+node:ekr.20040124074218.3:pyGtk plugin
#@-node:ekr.20040124074218.3:pyGtk plugin
#@-node:ekr.20041228084830.2:Gui stuff...
#@+node:ekr.20031218072017.793:Keep right panes constant when tiling horizontally (Tix)
This is done automatically now!  I may have to use configure events.

> When I have the 'split mode' set to display tree and log on left, and viewpane
on right, I sometimes need to increase the width of the window.

When I do the resize, the tree/log panes grow in proportion. I don't know about
others, but I'd much prefer if the tree/log panes stayed at the same width,
and only the view pane grew.
#@-node:ekr.20031218072017.793:Keep right panes constant when tiling horizontally (Tix)
#@+node:ekr.20031218072017.736:Use xml parser to read .leo files
http://www.reportlab.com

import xml.sax
#@-node:ekr.20031218072017.736:Use xml parser to read .leo files
#@+node:ekr.20031218072017.995:(Incremental update of screen)
@ignore
@nocolor

To enable incremental allocation of Tk widgets during redraws, set self.allocateOnlyVisibleNodes = True in tree.__init__.

To do:
	
- We might switch to a line-oriented scheme.
	- This might simplify the code and make the code more useful to users.
	- Conceivably this scheme might eliminate the need for the auto-scroll in the redraw code,
	and that might make a single-pass redraw scheme possible.

- The last line isn't always completely visible: this is clearly a bug.

@color
#@nonl
#@+node:ekr.20031218072017.996:From Frame class
#@+node:ekr.20031218072017.997:<< create the tree canvas >>
scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
scrolls = choose(scrolls,1,0)

self.canvas = canvas = Tk.Canvas(split2Pane1,name="canvas",
	bd=0,bg="white",relief="flat")
	
self.setTreeColorsFromConfig()

self.treeBar = treeBar = Tk.Scrollbar(split2Pane1,name="treeBar")

# Bind mouse wheel event to canvas
if sys.platform != "win32": # Works on 98, crashes on XP.
	self.canvas.bind("<MouseWheel>", self.OnMouseWheel)
	
canvas['yscrollcommand'] = self.setCallback
treeBar['command']     = self.yviewCallback

treeBar.pack(side="right", fill="y")
if scrolls: 
	treeXBar = Tk.Scrollbar( 
		split2Pane1,name='treeXBar',orient="horizontal") 
	canvas['xscrollcommand'] = treeXBar.set 
	treeXBar['command'] = canvas.xview 
	treeXBar.pack(side="bottom", fill="x")

canvas.pack(expand=1,fill="both")
#@nonl
#@-node:ekr.20031218072017.997:<< create the tree canvas >>
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20031218072017.996:From Frame class
#@-node:ekr.20031218072017.995:(Incremental update of screen)
#@+node:ekr.20040812170616:Pyrex versions of key classes
#@+node:ekr.20040812154307:@file leoCNodes.pyx
<< tnode/vnode constants >>

@others
#@nonl
#@+node:ekr.20040812155849.1:<< tnode/vnode constants >>
# Define the meaning of status bits in tnodes and vnodes.

# Archived...
cdef enum tnode_vnode_type:
    clonedBit	  = 0x01 # True: vnode has clone mark.
    
    # not used	 = 0x02
    expandedBit = 0x04 # True: vnode is expanded.
    markedBit	  = 0x08 # True: vnode is marked
    orphanBit	  = 0x10 # True: vnode saved in .leo file, not derived file.
    selectedBit = 0x20 # True: vnode is current vnode.
    topBit		    = 0x40 # True: vnode was top vnode when saved.
    
    # Not archived...
    dirtyBit    =	0x060 # Shared.
    richTextBit =	0x080 # Shared. Determines whether we use <bt> or <btr> tags.
    visitedBit	 = 0x100 # Shared.
    
    # Only in tnodes...
    writeBit    = 0x200 # Set: write the tnode.
#@nonl
#@-node:ekr.20040812155849.1:<< tnode/vnode constants >>
#@+node:ekr.20040812154838:class c_tnode
cdef class c_tnode:

    """A Pyrex C class that implements tnodes."""
    
    @others
#@nonl
#@+node:ekr.20040812154838.2:t.__init__
# All params have defaults, so t = tnode() is valid.

def __init__ (self,bodyString=None,headString=None):

    self.cloneIndex = 0 # For Pre-3.12 files.  Zero for @file nodes
    self.fileIndex = None # The immutable file index for this tnode.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
    self.statusBits = 0 # status bits

    # Convert everything to unicode...
    self.headString = g.toUnicode(headString,g.app.tkEncoding)
    self.bodyString = g.toUnicode(bodyString,g.app.tkEncoding)
    
    self.vnodeList = [] # List of all vnodes pointing to this tnode.
    self._firstChild = None
#@nonl
#@-node:ekr.20040812154838.2:t.__init__
#@+node:ekr.20040812154838.3:t.__repr__ & t.__str__
def __repr__ (self):
    
    return "<tnode %d>" % (id(self))
    
def __str__ (self):
    
    return self.__repr__()
#@-node:ekr.20040812154838.3:t.__repr__ & t.__str__
#@+node:ekr.20040812154838.4:For undo
#@+node:ekr.20040812154838.5:t.createUndoInfo
def createUndoInfo (self,copyLinks=True):
    
    """Create a dict containing all info needed to recreate a vnode."""
    
    t = self ; d = {}
    
    # Essential fields.
    d ["t"] = t
    d ["headString"] = t.headString
    d ["bodyString"] = t.bodyString
    d ["vnodeList"]  = t.vnodeList[:]
    d ["statusBits"] = t.statusBits
    d ["firstChild"] = t._firstChild

    try: d ["unknownAttributes"] = t.unknownAttributes
    except: pass
    
    if 0: # These neve change, so no need to save/restore them.
        # In fact, it would be wrong to undo changes made to them!
        d ["cloneIndex"]  = t.cloneIndex
        d ["fileIndex"]  = t.fileIndex

    if 0: # probably not needed for undo.
        d ["insertSpot"]      = t.insertSpot
        d ["scrollBarSpot"]   = t.scrollBarSpot
        d ["selectionLength"] = t.selectionLength
        d ["selectionStart"]  = t.selectionStart

    return d
#@-node:ekr.20040812154838.5:t.createUndoInfo
#@+node:ekr.20040812154838.6:t.restoreUndoInfo
def restoreUndoInfo (self,d):
    
    t = d ["t"] ; assert(t == self)

    t.headString  = d ["headString"]
    t.bodyString  = d ["bodyString"]
    t.vnodeList   = d ["vnodeList"]
    t.statusBits  = d ["statusBits"]
    t._firstChild = d ["firstChild"]

    try:
        t.unknownAttributes = d ["unknownAttributes"]
    except KeyError:
        pass
#@nonl
#@-node:ekr.20040812154838.6:t.restoreUndoInfo
#@-node:ekr.20040812154838.4:For undo
#@+node:ekr.20040812154838.7:Getters
#@+node:ekr.20040812154838.8:getBody
def getBody (self):

    return self.bodyString
#@nonl
#@-node:ekr.20040812154838.8:getBody
#@+node:ekr.20040812154838.9:hasBody
def hasBody (self):

    return self.bodyString and len(self.bodyString) > 0
#@nonl
#@-node:ekr.20040812154838.9:hasBody
#@+node:ekr.20040812154838.10:Status bits
#@+node:ekr.20040812154838.11:isDirty
def isDirty (self):

    return (self.statusBits & self.dirtyBit) != 0
#@nonl
#@-node:ekr.20040812154838.11:isDirty
#@+node:ekr.20040812154838.12:isRichTextBit
def isRichTextBit (self):

    return (self.statusBits & self.richTextBit) != 0
#@nonl
#@-node:ekr.20040812154838.12:isRichTextBit
#@+node:ekr.20040812154838.13:isVisited
def isVisited (self):

    return (self.statusBits & self.visitedBit) != 0
#@nonl
#@-node:ekr.20040812154838.13:isVisited
#@+node:ekr.20040812154838.14:isWriteBit
def isWriteBit (self):

    return (self.statusBits & self.writeBit) != 0
#@nonl
#@-node:ekr.20040812154838.14:isWriteBit
#@-node:ekr.20040812154838.10:Status bits
#@-node:ekr.20040812154838.7:Getters
#@+node:ekr.20040812154838.15:Setters
#@+node:ekr.20040812154838.16:Setting body text
#@+node:ekr.20040812154838.17:setTnodeText
# This sets the text in the tnode from the given string.

def setTnodeText (self,s,encoding="utf-8"):
    
    """Set the body text of a tnode to the given string."""
    
    s = g.toUnicode(s,encoding,reportErrors=True)
    
    if 0: # DANGEROUS:  This automatically converts everything when reading files.

        option = g.app.config.trailing_body_newlines
        
        if option == "one":
            s = s.rstrip() + '\n'
        elif option == "zero":
            s = s.rstrip()
    
    self.bodyString = s
#@nonl
#@-node:ekr.20040812154838.17:setTnodeText
#@+node:ekr.20040812154838.18:setSelection
def setSelection (self,start,length):

    self.selectionStart = start
    self.selectionLength = length
#@nonl
#@-node:ekr.20040812154838.18:setSelection
#@-node:ekr.20040812154838.16:Setting body text
#@+node:ekr.20040812154838.19:Status bits
#@+node:ekr.20040812154838.20:clearDirty
def clearDirty (self):

    self.statusBits = self.statusBits & ~ self.dirtyBit
#@nonl
#@-node:ekr.20040812154838.20:clearDirty
#@+node:ekr.20040812154838.21:clearRichTextBit
def clearRichTextBit (self):

    self.statusBits = self.statusBits & ~ self.richTextBit
#@nonl
#@-node:ekr.20040812154838.21:clearRichTextBit
#@+node:ekr.20040812154838.22:clearVisited
def clearVisited (self):

    self.statusBits = self.statusBits & ~ self.visitedBit
#@nonl
#@-node:ekr.20040812154838.22:clearVisited
#@+node:ekr.20040812154838.23:clearWriteBit
def clearWriteBit (self):

    self.statusBits = self.statusBits & ~ self.writeBit
#@nonl
#@-node:ekr.20040812154838.23:clearWriteBit
#@+node:ekr.20040812154838.24:setDirty
def setDirty (self):

    self.statusBits = self.statusBits | self.dirtyBit
#@nonl
#@-node:ekr.20040812154838.24:setDirty
#@+node:ekr.20040812154838.25:setRichTextBit
def setRichTextBit (self):

    self.statusBits = self.statusBits | self.richTextBit
#@nonl
#@-node:ekr.20040812154838.25:setRichTextBit
#@+node:ekr.20040812154838.26:setVisited
def setVisited (self):

    self.statusBits = self.statusBits | self.visitedBit
#@nonl
#@-node:ekr.20040812154838.26:setVisited
#@+node:ekr.20040812154838.27:setWriteBit
def setWriteBit (self):

    self.statusBits = self.statusBits | self.writeBit
#@nonl
#@-node:ekr.20040812154838.27:setWriteBit
#@-node:ekr.20040812154838.19:Status bits
#@+node:ekr.20040812154838.28:setCloneIndex (used in 3.x)
def setCloneIndex (self, index):

    self.cloneIndex = index
#@nonl
#@-node:ekr.20040812154838.28:setCloneIndex (used in 3.x)
#@+node:ekr.20040812154838.29:setFileIndex
def setFileIndex (self, index):

    self.fileIndex = index
#@nonl
#@-node:ekr.20040812154838.29:setFileIndex
#@-node:ekr.20040812154838.15:Setters
#@-node:ekr.20040812154838:class c_tnode
#@+node:ekr.20040812155849:class c_vnode
cdef class c_vnode:

    """A Pyrex C class that implements vnodes."""

    @others
#@nonl
#@+node:ekr.20040812155849.2:Birth & death
#@+node:ekr.20040812155849.4:v.__init__
def __init__ (self,c,t):

    assert(t)
    << initialize vnode data members >>
#@nonl
#@+node:ekr.20040812155849.5:<< initialize vnode data members >>
self.c = c # The commander for this vnode.
self.t = t # The tnode.
self.statusBits = 0 # status bits

# Structure links.
self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20040812155849.5:<< initialize vnode data members >>
#@-node:ekr.20040812155849.4:v.__init__
#@+node:ekr.20040812155849.6:v.__repr__ & v.__str__
def __repr__ (self):
    
    if self.t:
        return "<vnode %d:'%s'>" % (id(self),self.cleanHeadString())
    else:
        return "<vnode %d:NULL tnode>" % (id(self))
        
def __str__ (self):
    
    return self.__repr__()
#@nonl
#@-node:ekr.20040812155849.6:v.__repr__ & v.__str__
#@+node:ekr.20040812155849.7:v.dump
def dumpLink (self,link):
    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)
    
    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v
#@nonl
#@-node:ekr.20040812155849.7:v.dump
#@-node:ekr.20040812155849.2:Birth & death
#@+node:ekr.20040812155849.8:v.Comparisons
#@+node:ekr.20040812155849.9:findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@nonl
#@-node:ekr.20040812155849.9:findAtFileName (new in 4.2 b3)
#@+node:ekr.20040812155849.10:anyAtFileNodeName
def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
#@nonl
#@-node:ekr.20040812155849.10:anyAtFileNodeName
#@+node:ekr.20040812155849.11:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
def atNoSentFileNodeName (self): return  self.atNoSentinelsFileNodeName()
def atNorefFileNodeName  (self): return  self.atRawFileNodeName()
def atAsisFileNodeName   (self): return  self.tSilentFileNodeName()
#@nonl
#@-node:ekr.20040812155849.11:at...FileNodeName
#@+node:ekr.20040812155849.12:isAtAllNode
def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag
#@nonl
#@-node:ekr.20040812155849.12:isAtAllNode
#@+node:ekr.20040812155849.13:isAnyAtFileNode good
def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
#@nonl
#@-node:ekr.20040812155849.13:isAnyAtFileNode good
#@+node:ekr.20040812155849.14:isAt...FileNode
def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
def isAtNoSentFileNode (self): return self.isAtNoSentinelsFileNode
def isAtNorefFileNode  (self): return self.isAtRawFileNode
def isAtAsisFileNode   (self): return self.isAtSilentFileNode
#@nonl
#@-node:ekr.20040812155849.14:isAt...FileNode
#@+node:ekr.20040812155849.15:isAtIgnoreNode
def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag
#@nonl
#@-node:ekr.20040812155849.15:isAtIgnoreNode
#@+node:ekr.20040812155849.16:isAtOthersNode
def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag
#@nonl
#@-node:ekr.20040812155849.16:isAtOthersNode
#@+node:ekr.20040812155849.17:matchHeadline
def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""

    h = string.lower(self.headString())
    h = string.replace(h,' ','')
    h = string.replace(h,'\t','')

    s = string.lower(pattern)
    s = string.replace(s,' ','')
    s = string.replace(s,'\t','')

    # ignore characters in the headline following the match
    return s == h[0:len(s)]
#@nonl
#@-node:ekr.20040812155849.17:matchHeadline
#@-node:ekr.20040812155849.8:v.Comparisons
#@+node:ekr.20040812155849.18:Getters (vnode)
#@+node:ekr.20040812155849.19:Tree Traversal getters
#@+node:ekr.20040812155849.20:v.back
# Compatibility routine for scripts

def back (self):

    return self._back
#@nonl
#@-node:ekr.20040812155849.20:v.back
#@+node:ekr.20040812155849.21:v.next
# Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next
#@nonl
#@-node:ekr.20040812155849.21:v.next
#@-node:ekr.20040812155849.19:Tree Traversal getters
#@+node:ekr.20040812155849.22:Children
#@+node:ekr.20040812155849.23:v.childIndex
def childIndex(self):
    
    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n = n + 1
        v = v._back
    return n
#@nonl
#@-node:ekr.20040812155849.23:v.childIndex
#@+node:ekr.20040812155849.24:v.firstChild (changed for 4.2)
def firstChild (self):
    
    return self.t._firstChild
#@nonl
#@-node:ekr.20040812155849.24:v.firstChild (changed for 4.2)
#@+node:ekr.20040812155849.25:v.hasChildren & hasFirstChild
def hasChildren (self):
    
    v = self
    return v.firstChild()

def hasFirstChild (self): return self.hasChildren()
#@nonl
#@-node:ekr.20040812155849.25:v.hasChildren & hasFirstChild
#@+node:ekr.20040812155849.26:v.lastChild
def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child
#@nonl
#@-node:ekr.20040812155849.26:v.lastChild
#@+node:ekr.20040812155849.27:v.nthChild
# childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n > 0 and child:
        n = n - 1
        child = child.next()
    return child
#@nonl
#@-node:ekr.20040812155849.27:v.nthChild
#@+node:ekr.20040812155849.28:v.numberOfChildren (n)
def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n = n + 1
        child = child.next()
    return n
#@nonl
#@-node:ekr.20040812155849.28:v.numberOfChildren (n)
#@-node:ekr.20040812155849.22:Children
#@+node:ekr.20040812155849.29:Status Bits
#@+node:ekr.20040812155849.30:v.isCloned (4.2)
def isCloned (self):
    
    return len(self.t.vnodeList) > 1
#@nonl
#@-node:ekr.20040812155849.30:v.isCloned (4.2)
#@+node:ekr.20040812155849.31:isDirty
def isDirty (self):

    return self.t.isDirty()
#@nonl
#@-node:ekr.20040812155849.31:isDirty
#@+node:ekr.20040812155849.32:isExpanded
def isExpanded (self):

    return ( self.statusBits & self.expandedBit ) != 0
#@nonl
#@-node:ekr.20040812155849.32:isExpanded
#@+node:ekr.20040812155849.33:isMarked
def isMarked (self):

    return ( self.statusBits & vnode.markedBit ) != 0
#@nonl
#@-node:ekr.20040812155849.33:isMarked
#@+node:ekr.20040812155849.34:isOrphan
def isOrphan (self):

    return ( self.statusBits & vnode.orphanBit ) != 0
#@nonl
#@-node:ekr.20040812155849.34:isOrphan
#@+node:ekr.20040812155849.35:isSelected
def isSelected (self):

    return ( self.statusBits & vnode.selectedBit ) != 0
#@nonl
#@-node:ekr.20040812155849.35:isSelected
#@+node:ekr.20040812155849.36:isTopBitSet
def isTopBitSet (self):

    return ( self.statusBits & self.topBit ) != 0
#@nonl
#@-node:ekr.20040812155849.36:isTopBitSet
#@+node:ekr.20040812155849.37:isVisited
def isVisited (self):

    return ( self.statusBits & vnode.visitedBit ) != 0
#@nonl
#@-node:ekr.20040812155849.37:isVisited
#@+node:ekr.20040812155849.38:status
def status (self):

    return self.statusBits
#@nonl
#@-node:ekr.20040812155849.38:status
#@-node:ekr.20040812155849.29:Status Bits
#@+node:ekr.20040812155849.39:v.bodyString
# Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "Leo internal error: not unicode:" + repr(self.t.bodyString)
        print s ; g.es(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
#@-node:ekr.20040812155849.39:v.bodyString
#@+node:ekr.20040812155849.40:v.currentVnode (and c.currentPosition 4.2)
def currentPosition (self):
    return self.c.currentPosition()
        
def currentVnode (self):
    return self.c.currentVnode()
#@nonl
#@-node:ekr.20040812155849.40:v.currentVnode (and c.currentPosition 4.2)
#@+node:ekr.20040812155849.41:v.findRoot (4.2)
def findRoot (self):
    
    return self.c.rootPosition()
#@nonl
#@-node:ekr.20040812155849.41:v.findRoot (4.2)
#@+node:ekr.20040812155849.42:v.headString & v.cleanHeadString
def headString (self):
    
    """Return the headline string."""
    
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        print s ; g.es(s,color="red")
        
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):
    
    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
#@nonl
#@-node:ekr.20040812155849.42:v.headString & v.cleanHeadString
#@+node:ekr.20040812155849.43:v.directParents (new method in 4.2)
def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@nonl
#@-node:ekr.20040812155849.43:v.directParents (new method in 4.2)
#@-node:ekr.20040812155849.18:Getters (vnode)
#@+node:ekr.20040812155849.44:v.Link/Unlink/Insert methods (used by file read logic)
# These remain in 4.2: the file read logic calls these before creating positions.
#@nonl
#@+node:ekr.20040812155849.45:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(self.c,t)
    v.linkAfter(self)

    return v
#@nonl
#@-node:ekr.20040812155849.45:v.insertAfter
#@+node:ekr.20040812155849.46:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(self.c,t)
    v.linkAsNthChild(self,n)

    return v
#@nonl
#@-node:ekr.20040812155849.46:v.insertAsNthChild
#@+node:ekr.20040812155849.47:v.linkAfter
def linkAfter (self,v):

    """Link self after v."""
    
    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
#@-node:ekr.20040812155849.47:v.linkAfter
#@+node:ekr.20040812155849.48:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v
#@nonl
#@-node:ekr.20040812155849.48:v.linkAsNthChild
#@+node:ekr.20040812155849.49:v.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self ; c = v.c

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v

    newRoot = position(v,[])
    c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20040812155849.49:v.linkAsRoot
#@+node:ekr.20040812155849.50:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    """Moves the receiver to the root position"""

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v
#@nonl
#@-node:ekr.20040812155849.50:v.moveToRoot
#@+node:ekr.20040812155849.51:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self ; c = v.c

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)
    
    # Special case the root.
    if v == c.rootPosition().v: # 3/11/04
        assert(v._next)
        newRoot = position(v._next,[])
        c.setRootPosition(newRoot)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20040812155849.51:v.unlink
#@-node:ekr.20040812155849.44:v.Link/Unlink/Insert methods (used by file read logic)
#@+node:ekr.20040812155849.52:Setters
#@+node:ekr.20040812155849.53: v.Status bits
#@+node:ekr.20040812155849.54:clearClonedBit
def clearClonedBit (self):

    self.statusBits = self.statusBits & ~ self.clonedBit
#@nonl
#@-node:ekr.20040812155849.54:clearClonedBit
#@+node:ekr.20040812155849.55:clearDirty & clearDirtyJoined (redundant code)
def clearDirty (self):

    v = self
    v.t.clearDirty()

def clearDirtyJoined (self):

    g.trace()
    v = self ; c = v.c
    c.beginUpdate()
    v.t.clearDirty()
    c.endUpdate() # recomputes all icons
#@nonl
#@-node:ekr.20040812155849.55:clearDirty & clearDirtyJoined (redundant code)
#@+node:ekr.20040812155849.56:clearMarked
def clearMarked (self):

    self.statusBits = self.statusBits & ~ self.markedBit
#@-node:ekr.20040812155849.56:clearMarked
#@+node:ekr.20040812155849.57:clearOrphan
def clearOrphan (self):

    self.statusBits = self.statusBits & ~ self.orphanBit
#@nonl
#@-node:ekr.20040812155849.57:clearOrphan
#@+node:ekr.20040812155849.58:clearVisited
def clearVisited (self):

    self.statusBits = self.statusBits & ~ self.visitedBit
#@nonl
#@-node:ekr.20040812155849.58:clearVisited
#@+node:ekr.20040812155849.59:contract & expand & initExpandedBit
def contract(self):

    self.statusBits = self.statusBits & ~ self.expandedBit

def expand(self):

    self.statusBits = self.statusBits | self.expandedBit

def initExpandedBit (self):

    self.statusBits = self.statusBits | self.expandedBit
#@nonl
#@-node:ekr.20040812155849.59:contract & expand & initExpandedBit
#@+node:ekr.20040812155849.60:initStatus
def initStatus (self, status):

    self.statusBits = status
#@nonl
#@-node:ekr.20040812155849.60:initStatus
#@+node:ekr.20040812155849.61:setClonedBit & initClonedBit
def setClonedBit (self):

    self.statusBits = self.statusBits | self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits = self.statusBits | self.clonedBit
    else:
        self.statusBits = self.statusBits & ~ self.clonedBit
#@nonl
#@-node:ekr.20040812155849.61:setClonedBit & initClonedBit
#@+node:ekr.20040812155849.62:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits = self.statusBits | self.markedBit

def initMarkedBit (self):

    self.statusBits = self.statusBits | self.markedBit
#@-node:ekr.20040812155849.62:v.setMarked & initMarkedBit
#@+node:ekr.20040812155849.63:setOrphan
def setOrphan (self):

    self.statusBits = self.statusBits | self.orphanBit
#@nonl
#@-node:ekr.20040812155849.63:setOrphan
#@+node:ekr.20040812155849.64:setSelected (vnode)
# This only sets the selected bit.

def setSelected (self):

    self.statusBits = self.statusBits | self.selectedBit
#@nonl
#@-node:ekr.20040812155849.64:setSelected (vnode)
#@+node:ekr.20040812155849.65:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

    self.statusBits = self.statusBits | self.visitedBit
#@nonl
#@-node:ekr.20040812155849.65:t.setVisited
#@-node:ekr.20040812155849.53: v.Status bits
#@+node:ekr.20040812155849.66:v.computeIcon & setIcon
def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val = val + 1
    if v.isMarked():  val = val + 2
    if v.isCloned():  val = val + 4
    if v.isDirty():   val = val + 8
    return val
    
def setIcon (self):

    pass # Compatibility routine for old scripts
#@nonl
#@-node:ekr.20040812155849.66:v.computeIcon & setIcon
#@+node:ekr.20040812155849.67:v.initHeadString
def initHeadString (self,s,encoding="utf-8"):
    
    v = self

    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s
#@nonl
#@-node:ekr.20040812155849.67:v.initHeadString
#@+node:ekr.20040812155849.68:v.setSelection
def setSelection (self, start, length):

    self.t.setSelection ( start, length )
#@nonl
#@-node:ekr.20040812155849.68:v.setSelection
#@+node:ekr.20040812155849.69:v.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):
    
    return self.t.setTnodeText(s,encoding)
#@nonl
#@-node:ekr.20040812155849.69:v.setTnodeText
#@+node:ekr.20040812155849.70:v.trimTrailingLines
def trimTrailingLines (self):

    """Trims trailing blank lines from a node.
    
    It is surprising difficult to do this during Untangle."""

    v = self
    body = v.bodyString()
    # g.trace(body)
    lines = string.split(body,'\n')
    i = len(lines) - 1 ; changed = False
    while i >= 0:
        line = lines[i]
        j = g.skip_ws(line,0)
        if j + 1 == len(line):
            del lines[i]
            i = i - 1 ; changed = True
        else: break
    if changed:
        body = string.join(body,'') + '\n' # Add back one last newline.
        # g.trace(body)
        v.setBodyStringOrPane(body)
        # Don't set the dirty bit: it would just be annoying.
#@-node:ekr.20040812155849.70:v.trimTrailingLines
#@-node:ekr.20040812155849.52:Setters
#@+node:ekr.20040812155849.71:For undo
#@+node:ekr.20040812155849.72:v.createUndoInfo
def createUndoInfo (self):
    
    """Create a dict containing all info needed to recreate a vnode for undo."""
    
    v = self ; d = {}
    
    # Copy all ivars.
    d ["v"] = v
    d ["statusBits"] = v.statusBits
    d ["parent"] = v._parent
    d ["next"] = v._next
    d ["back"] = v._back
    # The tnode never changes so there is no need to save it here.
    
    try: d ["unknownAttributes"] = v.unknownAttributes
    except: pass

    return d
#@nonl
#@-node:ekr.20040812155849.72:v.createUndoInfo
#@+node:ekr.20040812155849.73:v.restoreUndoInfo
def restoreUndoInfo (self,d):
    
    """Restore all ivars saved in dict d."""
    
    v = d ["v"] ; assert(v == self)

    v.statusBits = d ["statusBits"]
    v._parent    = d ["parent"] 
    v._next      = d ["next"] 
    v._back      = d ["back"]
    
    try:
        v.unknownAttributes = d ["unknownAttributes"]
    except KeyError:
        pass
#@nonl
#@-node:ekr.20040812155849.73:v.restoreUndoInfo
#@-node:ekr.20040812155849.71:For undo
#@-node:ekr.20040812155849:class c_vnode
#@+node:ekr.20040812154341:class c_position
cdef class c_position:
    
    """A Pyrex C class representing a position."""
    
    @others
#@+node:ekr.20040812154341.2: ctor & other special methods...
#@+node:ekr.20040812154341.3:p.__cmp__
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal

    # Check entire stack quickly.
    # The stack contains vnodes, so this is not a recursive call.
    if p1.v != p2.v or p1.stack != p2.stack:
        return 1 # notEqual

    # This is slow: do this last!
    if p1.childIndex() != p2.childIndex():
        # Disambiguate clones having the same parents.
        return 1 # notEqual

    return 0 # equal
#@nonl
#@-node:ekr.20040812154341.3:p.__cmp__
#@+node:ekr.20040812154341.4:p.__getattr__  ON:  must be ON if use_plugins
def __getattr__ (self,attr):
    
    """Convert references to p.t into references to p.v.t.
    
    N.B. This automatically keeps p.t in synch with p.v.t."""

    if attr=="t":
        return self.v.t
    elif attr=="__del__":
        # This works around a Python 2.2 wierdness.
        return AttributeError # Silently ignore this.
    else:
        # Only called when normal lookup fails.
        print "unknown position attribute:",attr
        # import traceback ; traceback.print_stack()
        raise AttributeError
#@nonl
#@-node:ekr.20040812154341.4:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20040812154341.5:p.__init__
def __init__ (self,c,v,stack,trace=True):

    """Create a new position."""
    
    self.c = c
    self.v = v
    # assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.

    g.app.positions = g.app.positions + 1
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20040812154341.5:p.__init__
#@+node:ekr.20040812154341.6:p.__nonzero__
@
The test "if p" is the _only_ correct way to test whether a position p is valid.
In particular, tests like "if p is None" or "if p is not None" will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
#@nonl
#@-node:ekr.20040812154341.6:p.__nonzero__
#@+node:ekr.20040812154341.7:p.__str__ and p.__repr__
def __str__ (self):
    
    p = self
    
    if p.v:
        return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d        [%d] None>" % (id(p),len(p.stack))
        
def __repr__ (self):
    
    return self.__str__()
#@nonl
#@-node:ekr.20040812154341.7:p.__str__ and p.__repr__
#@+node:ekr.20040812154341.8:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    if g.app.tracePositions:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)

    return position(self.v,self.stack,trace=False)
#@nonl
#@-node:ekr.20040812154341.8:p.copy
#@+node:ekr.20040812154341.9:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    # return [id(v) for v in p.v.t.vnodeList]
    val = []
    for v in p.v.t.vnodeList:
        val.append(id(v))
#@nonl
#@-node:ekr.20040812154341.9:p.dump & p.vnodeListIds
#@+node:ekr.20040812154341.10:p.equal & isEqual
def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self
    
    # if g.app.trace: "equal",p1.v,p2.v

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1.stack == p2.stack and
        p1.childIndex() == p2.childIndex())
        
def isEqual(self,p2):
    return self.equal(p2)
#@nonl
#@-node:ekr.20040812154341.10:p.equal & isEqual
#@-node:ekr.20040812154341.2: ctor & other special methods...
#@+node:ekr.20040812154341.11:Getters
#@+node:ekr.20040812154341.12: vnode proxies
#@+node:ekr.20040812154341.13:p.Comparisons
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
def atNoSentFileNodeName (self): return self.atNoSentinelsFileNodeName()
def atNorefFileNodeName  (self): return self.atRawFileNodeName()
def atAsisFileNodeName   (self): return self.atSilentFileNodeName()

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
def isAtNoSentFileNode (self): return self.isAtNoSentinelsFileNode()
def isAtNorefFileNode  (self): return self.isAtRawFileNode()
def isAtAsisFileNode   (self): return self.isAtSilentFileNode()

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
#@nonl
#@-node:ekr.20040812154341.13:p.Comparisons
#@+node:ekr.20040812154341.14:p.Extra Attributes
def extraAttributes (self):
    
    return self.v.extraAttributes()

def setExtraAttributes (self,data):

    return self.v.setExtraAttributes(data)
#@nonl
#@-node:ekr.20040812154341.14:p.Extra Attributes
#@+node:ekr.20040812154341.15:p.Headline & body strings
def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
#@-node:ekr.20040812154341.15:p.Headline & body strings
#@+node:ekr.20040812154341.16:p.Status bits
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@nonl
#@-node:ekr.20040812154341.16:p.Status bits
#@+node:ekr.20040812154341.17:p.edit_text
def edit_text (self):
    
    # New in 4.3 beta 3: let the tree classes do all the work.
    
    p = self ; c = p.c
    
    return c.frame.tree.edit_text(p)
#@nonl
#@-node:ekr.20040812154341.17:p.edit_text
#@+node:ekr.20040812154341.18:p.directParents
def directParents (self):
    
    return self.v.directParents()
#@-node:ekr.20040812154341.18:p.directParents
#@+node:ekr.20040812154341.19:p.childIndex
def childIndex(self):
    
    p = self ; v = p.v
    
    # This is time-critical code!
    
    # 3/25/04: Much faster code:
    if not v or not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n = n + 1
        v = v._back

    return n
#@nonl
#@-node:ekr.20040812154341.19:p.childIndex
#@-node:ekr.20040812154341.12: vnode proxies
#@+node:ekr.20040812154341.20:children
#@+node:ekr.20040812154341.21:p.hasChildren
def hasChildren(self):
    
    p = self
    # g.trace(p,p.v)
    return p.v and p.v.t and p.v.t._firstChild
#@nonl
#@-node:ekr.20040812154341.21:p.hasChildren
#@+node:ekr.20040812154341.22:p.numberOfChildren
def numberOfChildren (self):
    
    return self.v.numberOfChildren()
#@-node:ekr.20040812154341.22:p.numberOfChildren
#@-node:ekr.20040812154341.20:children
#@+node:ekr.20040812154341.23:p.exists
def exists(self,c):
    
    """Return True if a position exists in c's tree"""
    
    p = self.copy()
    
    # This code must be fast.
    root = c.rootPosition()
    while p:
        if p == root:
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    return False
#@nonl
#@-node:ekr.20040812154341.23:p.exists
#@+node:ekr.20040812154341.24:p.findRoot
def findRoot (self):
    
    return self.c.frame.rootPosition()
#@nonl
#@-node:ekr.20040812154341.24:p.findRoot
#@+node:ekr.20040812154341.25:p.getX & vnode compatibility traversal routines
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

def back          (self): return self.getBack()
def firstChild    (self): return self.getFirstChild()
def lastChild     (self): return self.getLastChild()
def lastNode      (self): return self.getLastNode()
def next          (self): return self.getNext()
def nodeAfterTree (self): return self.getNodeAfterTree()
def nthChild      (self): return self.getNthChild()
def parent        (self): return self.getParent()
def threadBack    (self): return self.getThreadBack()
def threadNext    (self): return self.getThreadNext()
def visBack       (self): return self.getVisBack()
def visNext       (self): return self.getVisNext()
#@nonl
#@-node:ekr.20040812154341.25:p.getX & vnode compatibility traversal routines
#@+node:ekr.20040812154341.26:p.hasX
def hasBack(self):
    return self.v and self.v._back

def hasFirstChild (self): return self.hasChildren()
    
def hasNext(self):
    return self.v and self.v._next
    
def hasParent(self):
    return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
def hasVisBack(self): return self.hasThreadBack()
#@nonl
#@+node:ekr.20040812154341.27:hasThreadNext (the only complex hasX method)
def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if v.t._firstChild or v._next:
        return True
    else:
        n = len(p.stack)-1
        v,n = p.vParentWithStack(v,p.stack,n)
        while v:
            if v._next:
                return True
            v,n = p.vParentWithStack(v,p.stack,n)
        return False

def hasVisNext (self): return self.hasThreadNext()
#@nonl
#@-node:ekr.20040812154341.27:hasThreadNext (the only complex hasX method)
#@-node:ekr.20040812154341.26:p.hasX
#@+node:ekr.20040812154341.28:p.isAncestorOf
def isAncestorOf (self, p2):
    
    p = self
    
    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False
#@nonl
#@-node:ekr.20040812154341.28:p.isAncestorOf
#@+node:ekr.20040812154341.29:p.isCurrentPosition & isRootPosition
#@+node:ekr.20040812154341.30:isCurrentPosition
def isCurrentPosition (self):
    
    p = self ; c = p.c
    
    return c.isCurrentPosition(p)
    
#@-node:ekr.20040812154341.30:isCurrentPosition
#@+node:ekr.20040812154341.31:isRootPosition
def isRootPosition (self):
    
    p = self ; c = p.c
    
    return c.isRootPosition(p)
#@nonl
#@-node:ekr.20040812154341.31:isRootPosition
#@-node:ekr.20040812154341.29:p.isCurrentPosition & isRootPosition
#@+node:ekr.20040812154341.32:p.isCloned
def isCloned (self):
    
    return len(self.v.t.vnodeList) > 1
#@nonl
#@-node:ekr.20040812154341.32:p.isCloned
#@+node:ekr.20040812154341.33:p.isRoot
def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()
#@nonl
#@-node:ekr.20040812154341.33:p.isRoot
#@+node:ekr.20040812154341.34:p.isVisible
def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if not v.isExpanded():
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True
#@nonl
#@-node:ekr.20040812154341.34:p.isVisible
#@+node:ekr.20040812154341.35:p.lastVisible & oldLastVisible
def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p
#@nonl
#@-node:ekr.20040812154341.35:p.lastVisible & oldLastVisible
#@+node:ekr.20040812154341.36:p.level & simpleLevel
def simpleLevel(self):
    
    p = self ; level = 0
    for parent in p.parents_iter():
        level = level + 1
    return level

def level(self,verbose=False):
    
    # if g.app.debug: simpleLevel = self.simpleLevel()
    
    p = self ; level = 0
    if not p: return level
        
    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level = level + 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==simpleLevel)
            break
    return level
#@nonl
#@-node:ekr.20040812154341.36:p.level & simpleLevel
#@-node:ekr.20040812154341.11:Getters
#@+node:ekr.20040812154341.37:Setters
#@+node:ekr.20040812154341.38:vnode proxies
#@+node:ekr.20040812154341.39: Status bits
# Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self):
    g.doHook("clear-mark",c=self.c,p=self)
    return self.v.clearMarked()

def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus()
    
def setMarked (self):
    g.doHook("set-mark",c=self.c,p=self)
    return self.v.setMarked()

def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()
#@nonl
#@-node:ekr.20040812154341.39: Status bits
#@+node:ekr.20040812154341.40:p.computeIcon & p.setIcon
def computeIcon (self):
    
    return self.v.computeIcon()
    
def setIcon (self):

    pass # Compatibility routine for old scripts
#@nonl
#@-node:ekr.20040812154341.40:p.computeIcon & p.setIcon
#@+node:ekr.20040812154341.41:p.setSelection
def setSelection (self,start,length):

    return self.v.setSelection(start,length)
#@nonl
#@-node:ekr.20040812154341.41:p.setSelection
#@+node:ekr.20040812154341.42:p.trimTrailingLines
def trimTrailingLines (self):

    return self.v.trimTrailingLines()
#@nonl
#@-node:ekr.20040812154341.42:p.trimTrailingLines
#@+node:ekr.20040812154341.43:p.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):
    
    return self.v.setTnodeText(s,encoding)
#@nonl
#@-node:ekr.20040812154341.43:p.setTnodeText
#@-node:ekr.20040812154341.38:vnode proxies
#@+node:ekr.20040812154341.44:Head & body text (position)
#@+node:ekr.20040812154341.45:p.appendStringToBody
def appendStringToBody (self,s,encoding="utf-8"):
    
    p = self
    if not s: return
    
    body = p.bodyString()
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    p.setBodyStringOrPane(body + s,encoding)
#@nonl
#@-node:ekr.20040812154341.45:p.appendStringToBody
#@+node:ekr.20040812154341.46:p.setBodyStringOrPane & p.setBodyTextOrPane
def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    if p == c.currentPosition():
        # 7/23/04: Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

def setBodyTextOrPane (self): return self.setBodyStringOrPane() # Compatibility with old scripts
#@nonl
#@-node:ekr.20040812154341.46:p.setBodyStringOrPane & p.setBodyTextOrPane
#@+node:ekr.20040812154341.47:p.setHeadString & p.initHeadString
def setHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()
    
def initHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
#@-node:ekr.20040812154341.47:p.setHeadString & p.initHeadString
#@+node:ekr.20040812154341.48:p.setHeadStringOrHeadline
def setHeadStringOrHeadline (self,s,encoding="utf-8"):

    p = self ; c = p.c
    
    t = p.edit_text()
    
    p.initHeadString(s,encoding)

    if t:
        
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state)

    p.setDirty()
#@nonl
#@-node:ekr.20040812154341.48:p.setHeadStringOrHeadline
#@+node:ekr.20040812154341.49:p.scriptSetBodyString
def scriptSetBodyString (self,s,encoding="utf-8"):
    
    """Update the body string for the receiver.
    
    Should be called only from scripts: does NOT update body text."""

    self.v.t.bodyString = g.toUnicode(s,encoding)
#@nonl
#@-node:ekr.20040812154341.49:p.scriptSetBodyString
#@-node:ekr.20040812154341.44:Head & body text (position)
#@+node:ekr.20040812154341.50:Visited bits
#@+node:ekr.20040812154341.51:p.clearAllVisited
# Compatibility routine for scripts.

def clearAllVisited (self):
    
    for p in self.allNodes_iter():
        p.clearVisited()
#@nonl
#@-node:ekr.20040812154341.51:p.clearAllVisited
#@+node:ekr.20040812154341.52:p.clearVisitedInTree
# Compatibility routine for scripts.

def clearVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.clearVisited()
#@-node:ekr.20040812154341.52:p.clearVisitedInTree
#@+node:ekr.20040812154341.53:p.clearAllVisitedInTree (4.2)
def clearAllVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.v.clearVisited()
        p.v.t.clearVisited()
        p.v.t.clearWriteBit()
#@nonl
#@-node:ekr.20040812154341.53:p.clearAllVisitedInTree (4.2)
#@-node:ekr.20040812154341.50:Visited bits
#@+node:ekr.20040812154341.54:p.Dirty bits
#@+node:ekr.20040812154341.55:p.clearDirty
def clearDirty (self):

    p = self
    p.v.clearDirty()
#@nonl
#@-node:ekr.20040812154341.55:p.clearDirty
#@+node:ekr.20040812154341.56:p.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):
    
    p = self 
    
    # Start with all nodes in the vnodeList.
    nodes = []
    newNodes = p.v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.t.vnodeList:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
                for v3 in v2.directParents():
                    if v3 not in nodes and v3 not in addedNodes:
                        addedNodes.append(v3)
        newNodes = addedNodes[:]

    # g.trace(len(nodes))
    return nodes
#@nonl
#@-node:ekr.20040812154341.56:p.findAllPotentiallyDirtyNodes
#@+node:ekr.20040812154341.57:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    changed = False
    
    # Calculate all nodes that are joined to v or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
    
    c.beginUpdate()
    if 1: # update...
        count = 0 # for debugging.
        for v in nodes:
            if not v.t.isDirty() and v.isAnyAtFileNode():
                # g.trace(v)
                changed = True
                v.t.setDirty() # Do not call v.setDirty here!
                count = count + 1
        # g.trace(count,changed)
    c.endUpdate(changed)
    return changed
#@nonl
#@-node:ekr.20040812154341.57:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040812154341.58:p.setDirty
# Ensures that all ancestor and descentent @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self,setDescendentsDirty=True):

    p = self ; c = p.c
    
    # g.trace(g.app.count) ; g.app.count += 1

    c.beginUpdate()
    if 1: # update...
        changed = False
        if not p.v.t.isDirty():
            p.v.t.setDirty()
            changed = True
        # N.B. This must be called even if p.v is already dirty.
        # Typing can change the @ignore state!
        if p.setAllAncestorAtFileNodesDirty(setDescendentsDirty):
            changed = True
    c.endUpdate(changed)

    return changed
#@nonl
#@-node:ekr.20040812154341.58:p.setDirty
#@+node:ekr.20040812154341.59:p.inAtIgnoreRange
def inAtIgnoreRange (self):
    
    """Returns True if position p or one of p's parents is an @ignore node."""
    
    p = self
    
    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False
#@nonl
#@-node:ekr.20040812154341.59:p.inAtIgnoreRange
#@-node:ekr.20040812154341.54:p.Dirty bits
#@-node:ekr.20040812154341.37:Setters
#@+node:ekr.20040812154341.60:File Conversion
@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
#@+node:ekr.20040812154341.61:convertTreeToString
def convertTreeToString (self):
    
    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()
    
    array = []
    for p in p.self_and_subtree_iter():
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)
#@-node:ekr.20040812154341.61:convertTreeToString
#@+node:ekr.20040812154341.62:moreHead
def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())
#@nonl
#@-node:ekr.20040812154341.62:moreHead
#@+node:ekr.20040812154341.63:moreBody
@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; array = []
    lines = string.split(p.bodyString(),'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i < len(s) and s[i] in ('+','-','\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)
#@nonl
#@-node:ekr.20040812154341.63:moreBody
#@-node:ekr.20040812154341.60:File Conversion
#@+node:ekr.20040812154341.82:p.Moving, Inserting, Deleting, Cloning, Sorting (position)
#@+node:ekr.20040812154341.83:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline.  May be undone.

    Returns newPosition."""

    p = self ; c = p.c

    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
#@nonl
#@-node:ekr.20040812154341.83:p.doDelete
#@+node:ekr.20040812154341.84:p.insertAfter
def insertAfter (self,t=None):

    """Inserts a new position after self.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2
#@nonl
#@-node:ekr.20040812154341.84:p.insertAfter
#@+node:ekr.20040812154341.85:p.insertAsLastChild
def insertAsLastChild (self,t=None):

    """Inserts a new vnode as the last child of self.
    
    Returns the newly created position."""
    
    p = self
    n = p.numberOfChildren()

    if not t:
        t = tnode(headString="NewHeadline")
    
    return p.insertAsNthChild(n,t)
#@nonl
#@-node:ekr.20040812154341.85:p.insertAsLastChild
#@+node:ekr.20040812154341.86:p.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")
    
    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2
#@nonl
#@-node:ekr.20040812154341.86:p.insertAsNthChild
#@+node:ekr.20040812154341.87:p.moveToRoot
def moveToRoot (self,oldRoot=None):

    """Moves a position to the root position."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)
    
    return p
#@nonl
#@-node:ekr.20040812154341.87:p.moveToRoot
#@+node:ekr.20040812154341.88:p.clone
def clone (self,back):
    
    """Create a clone of back.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    
    # g.trace(p,back)

    p2 = back.copy()
    p2.v = vnode(c,back.v.t)
    p2.linkAfter(back)

    return p2
#@nonl
#@-node:ekr.20040812154341.88:p.clone
#@+node:ekr.20040812154341.89:p.copyTreeAfter, copyTreeTo
# This is used by unit tests.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2
    
def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)
#@nonl
#@-node:ekr.20040812154341.89:p.copyTreeAfter, copyTreeTo
#@+node:ekr.20040812154341.90:p.moveAfter
def moveAfter (self,a):

    """Move a position after position a."""
    
    p = self ; c = p.c # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)
    
    # Moving a node after another node can create a new root node.
    if not a.hasParent() and not a.hasBack():
        c.setRootPosition(a)

    return p
#@nonl
#@-node:ekr.20040812154341.90:p.moveAfter
#@+node:ekr.20040812154341.91:p.moveToLastChildOf
def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!

    p.unlink()
    n = p.numberOfChildren()
    p.linkAsNthChild(parent,n)

    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        p.c.setRootPosition(parent)
        
    return p
#@-node:ekr.20040812154341.91:p.moveToLastChildOf
#@+node:ekr.20040812154341.92:p.moveToNthChildOf
def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self ; c = p.c # Do NOT copy the position!
    
    # g.trace(p,parent,n)

    p.unlink()
    p.linkAsNthChild(parent,n)
    
    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        c.setRootPosition(parent)

    return p
#@-node:ekr.20040812154341.92:p.moveToNthChildOf
#@+node:ekr.20040812154341.93:p.sortChildren
def sortChildren (self):
    
    p = self

    # Create a list of (headline,position) tuples
    pairs = []
    for child in p.children_iter():
        pairs.append((string.lower(child.headString()),child.copy())) # do we need to copy?

    # Sort the list on the headlines.
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        child.moveToNthChildOf(p,index)
        index = index + 1
#@nonl
#@-node:ekr.20040812154341.93:p.sortChildren
#@+node:ekr.20040812154341.94:p.validateOutlineWithParent
# This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
    
    p = self
    result = True # optimists get only unpleasant surprises.
    parent = p.getParent()
    childIndex = p.childIndex()
    
    # g.trace(p,parent,pv)
    << validate parent ivar >>
    << validate childIndex ivar >>
    << validate x ivar >>

    # Recursively validate all the children.
    for child in p.children_iter():
        r = child.validateOutlineWithParent(p)
        if not r: result = False

    return result
#@nonl
#@+node:ekr.20040812154341.95:<< validate parent ivar >>
if parent != pv:
    p.invalidOutline( "Invalid parent link: " + repr(parent))
#@nonl
#@-node:ekr.20040812154341.95:<< validate parent ivar >>
#@+node:ekr.20040812154341.96:<< validate childIndex ivar >>
if pv:
    if childIndex < 0:
        p.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex >= pv.numberOfChildren():
        p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex < 0:
    p.invalidOutline ( "negative childIndex" + childIndex )
#@nonl
#@-node:ekr.20040812154341.96:<< validate childIndex ivar >>
#@+node:ekr.20040812154341.97:<< validate x ivar >>
if not p.v.t and pv:
    self.invalidOutline ( "Empty t" )
#@nonl
#@-node:ekr.20040812154341.97:<< validate x ivar >>
#@-node:ekr.20040812154341.94:p.validateOutlineWithParent
#@+node:ekr.20040812154341.98:p.invalidOutline
def invalidOutline (self, message):
    
    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))
#@nonl
#@-node:ekr.20040812154341.98:p.invalidOutline
#@-node:ekr.20040812154341.82:p.Moving, Inserting, Deleting, Cloning, Sorting (position)
#@+node:ekr.20040812154341.99:p.moveToX
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
#@nonl
#@+node:ekr.20040812154341.100:p.moveToBack
def moveToBack (self):
    
    """Move self to its previous sibling."""
    
    p = self

    p.v = p.v and p.v._back
    
    return p
#@nonl
#@-node:ekr.20040812154341.100:p.moveToBack
#@+node:ekr.20040812154341.101:p.moveToFirstChild (pushes stack for cloned nodes)
def moveToFirstChild (self):

    """Move a position to it's first child's position."""
    
    p = self

    if p:
        child = p.v.t._firstChild
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
        
    return p

#@-node:ekr.20040812154341.101:p.moveToFirstChild (pushes stack for cloned nodes)
#@+node:ekr.20040812154341.102:p.moveToLastChild (pushes stack for cloned nodes)
def moveToLastChild (self):
    
    """Move a position to it's last child's position."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            child = p.v.lastChild()
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p
#@-node:ekr.20040812154341.102:p.moveToLastChild (pushes stack for cloned nodes)
#@+node:ekr.20040812154341.103:p.moveToLastNode (Big improvement for 4.2)
def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    
    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p
#@nonl
#@-node:ekr.20040812154341.103:p.moveToLastNode (Big improvement for 4.2)
#@+node:ekr.20040812154341.104:p.moveToNext
def moveToNext (self):
    
    """Move a position to its next sibling."""
    
    p = self
    
    p.v = p.v and p.v._next
    
    return p
#@nonl
#@-node:ekr.20040812154341.104:p.moveToNext
#@+node:ekr.20040812154341.105:p.moveToNodeAfterTree
def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
#@-node:ekr.20040812154341.105:p.moveToNodeAfterTree
#@+node:ekr.20040812154341.106:p.moveToNthChild (pushes stack for cloned nodes)
def moveToNthChild (self,n):
    
    p = self
    
    if p:
        child = p.v.nthChild(n) # Must call vnode method here!
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p
#@nonl
#@-node:ekr.20040812154341.106:p.moveToNthChild (pushes stack for cloned nodes)
#@+node:ekr.20040812154341.107:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    # if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
        # g.trace("pop",p.v,p)
    else:
        p.v = None

    return p
#@nonl
#@-node:ekr.20040812154341.107:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20040812154341.108:p.moveToThreadBack
def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
#@nonl
#@-node:ekr.20040812154341.108:p.moveToThreadBack
#@+node:ekr.20040812154341.109:p.moveToThreadNext
def moveToThreadNext (self):
    
    """Move a position to the next a position in threading order."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.
                
    return p
#@nonl
#@-node:ekr.20040812154341.109:p.moveToThreadNext
#@+node:ekr.20040812154341.110:p.moveToVisBack
def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p
#@nonl
#@-node:ekr.20040812154341.110:p.moveToVisBack
#@+node:ekr.20040812154341.111:p.moveToVisNext
def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p
#@nonl
#@-node:ekr.20040812154341.111:p.moveToVisNext
#@-node:ekr.20040812154341.99:p.moveToX
#@+node:ekr.20040812154341.112:p.utils...
#@+node:ekr.20040812154341.113:p.vParentWithStack
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@nonl
#@+node:ekr.20040812154341.114:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)

#@-node:ekr.20040812154341.114:<< about the vParentWithStack utility method >>
#@-node:ekr.20040812154341.113:p.vParentWithStack
#@+node:ekr.20040812154341.115:p.restoreLinksInTree
def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        
    for p in root.children_iter():
        p.restoreLinksInTree()
#@nonl
#@-node:ekr.20040812154341.115:p.restoreLinksInTree
#@+node:ekr.20040812154341.116:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20040812154341.117:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        p.v.t.vnodeList.remove(p.v)
        assert(p.v not in p.v.t.vnodeList)
        # g.trace("deleted",p.v,p.vnodeListIds())
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@nonl
#@-node:ekr.20040812154341.117:p.deleteLinksInSubtree
#@+node:ekr.20040812154341.118:p.adjustParentLinksInSubtree
def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@-node:ekr.20040812154341.118:p.adjustParentLinksInSubtree
#@-node:ekr.20040812154341.116:p.deleteLinksInTree & allies
#@-node:ekr.20040812154341.112:p.utils...
#@+node:ekr.20040812154341.119:p.Link/Unlink methods
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@nonl
#@+node:ekr.20040812154341.120:p.linkAfter
def linkAfter (self,after):

    """Link self after v."""
    
    p = self
    # g.trace(p,after)
    
    p.stack = after.stack[:] # 3/12/04
    p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
    
    p.v._back = after.v
    p.v._next = after.v._next
    
    after.v._next = p.v
    
    if p.v._next:
        p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
#@nonl
#@-node:ekr.20040812154341.120:p.linkAfter
#@+node:ekr.20040812154341.121:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of vnode pv"""
    
    # g.trace(self,parent,n)
    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:] 
    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v
            
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@nonl
#@-node:ekr.20040812154341.121:p.linkAsNthChild
#@+node:ekr.20040812154341.122:p.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""
    
    # g.trace(self,oldRoot)

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    p.stack = [] # Clear the stack.
    
    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode # Bug fix: 3/12/04
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v # Bug fix: 3/12/04

    p.c.setRootPosition(p)
    
    if 0:
        p.dump(label="root")
#@-node:ekr.20040812154341.122:p.linkAsRoot
#@+node:ekr.20040812154341.123:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""

    p = self ; v = p.v ; parent = p.parent()
    
    # Note:  p.parent() is not necessarily the same as v._parent.
    
    if parent:
        assert(p.v and p.v._parent in p.v.directParents())
        assert(parent.v in p.v.directParents())

    # g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if parent and parent.v.t._firstChild == v:
        parent.v.t._firstChild = v._next

    # Do _not_ delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@-node:ekr.20040812154341.123:p.unlink
#@-node:ekr.20040812154341.119:p.Link/Unlink methods
#@-node:ekr.20040812154341:class c_position
#@-node:ekr.20040812154307:@file leoCNodes.pyx
#@+node:ekr.20040812155849.74:v.Iterators (Can't use yield in pyrex)
#@+node:ekr.20040812155849.75:self_subtree_iter
def subtree_iter(self):

    """Return all nodes of self's tree in outline order."""
    
    v = self

    if v:
        yield v
        child = v.t._firstChild
        while child:
            for v1 in child.subtree_iter():
                yield v1
            child = child.next()
            
self_and_subtree_iter = subtree_iter
#@nonl
#@-node:ekr.20040812155849.75:self_subtree_iter
#@+node:ekr.20040812155849.76:unique_subtree_iter
def unique_subtree_iter(self,marks=None):

    """Return all vnodes in self's tree, discarding duplicates """
    
    v = self

    if marks == None: marks = {}

    if v and v not in marks:
        marks[v] = v
        yield v
        if v.t._firstChild:
            for v1 in v.t._firstChild.unique_subtree_iter(marks):
                yield v1
        v = v._next
        while v:
            for v in v.unique_subtree_iter(marks):
                yield v
            v = v._next
            
self_and_unique_subtree_iter = unique_subtree_iter
#@nonl
#@-node:ekr.20040812155849.76:unique_subtree_iter
#@-node:ekr.20040812155849.74:v.Iterators (Can't use yield in pyrex)
#@+node:ekr.20040812154341.64:p.Iterators (Can't use yield in pyrex)
@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
#@nonl
#@+node:ekr.20040812154341.65:p.tnodes_iter & unique_tnodes_iter
def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v
#@nonl
#@-node:ekr.20040812154341.65:p.tnodes_iter & unique_tnodes_iter
#@+node:ekr.20040812154341.66:p.vnodes_iter & unique_vnodes_iter
def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v
#@nonl
#@-node:ekr.20040812154341.66:p.vnodes_iter & unique_vnodes_iter
#@+node:ekr.20040812154341.67:p.allNodes_iter
class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)
#@nonl
#@+node:ekr.20040812154341.68:__init__ & __iter__
def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20040812154341.68:__init__ & __iter__
#@+node:ekr.20040812154341.69:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040812154341.69:next
#@-node:ekr.20040812154341.67:p.allNodes_iter
#@+node:ekr.20040812154341.70:p.subtree_iter
class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)
#@nonl
#@+node:ekr.20040812154341.71:__init__ & __iter__
def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20040812154341.71:__init__ & __iter__
#@+node:ekr.20040812154341.72:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@nonl
#@-node:ekr.20040812154341.72:next
#@-node:ekr.20040812154341.70:p.subtree_iter
#@+node:ekr.20040812154341.73:p.children_iter
class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)
#@nonl
#@+node:ekr.20040812154341.74:__init__ & __iter__
def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
#@-node:ekr.20040812154341.74:__init__ & __iter__
#@+node:ekr.20040812154341.75:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040812154341.75:next
#@-node:ekr.20040812154341.73:p.children_iter
#@+node:ekr.20040812154341.76:p.parents_iter
class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):
    
    p = self

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)
#@nonl
#@+node:ekr.20040812154341.77:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@nonl
#@-node:ekr.20040812154341.77:__init__ & __iter__
#@+node:ekr.20040812154341.78:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@-node:ekr.20040812154341.78:next
#@-node:ekr.20040812154341.76:p.parents_iter
#@+node:ekr.20040812154341.79:p.siblings_iter
class siblings_iter_class:

    """Returns a list of siblings of a position."""

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)
#@nonl
#@+node:ekr.20040812154341.80:__init__ & __iter__
def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

#@-node:ekr.20040812154341.80:__init__ & __iter__
#@+node:ekr.20040812154341.81:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040812154341.81:next
#@-node:ekr.20040812154341.79:p.siblings_iter
#@-node:ekr.20040812154341.64:p.Iterators (Can't use yield in pyrex)
#@-node:ekr.20040812170616:Pyrex versions of key classes
#@+node:ekr.20050116094523:Option not to write marks/expansion attributes in .leo files
@

I suppose the rationale is that they interfere with comparing .leo files, but so what?
#@nonl
#@-node:ekr.20050116094523:Option not to write marks/expansion attributes in .leo files
#@-node:ekr.20041228084143:Maybe
#@+node:ekr.20040123102724:Can't or won't
#@+node:ekr.20031218072017.835:(Use pywin extensions to improve cut/paste between apps)
@color

@ This is not going well :-(  Probably what is happening is that Tk is competing with the win32 extensions in setting the clipboard.  It might not be so easy to

a) completely disable Tk's clipboard handling, in _both_ headlines and body text.
b) do the cut/paste operations "by hand".

This might require new body routlines to replace the selected text in the body.  And then there are issues relating to whether the headline or body text should be changed.  All in all, this is much harder than it looks.

Also, if one is not careful one can take fatal Python errors related to missing threads.  Pretty much a nightmare.
#@nonl
#@+node:ekr.20031218072017.836:updateEditMenu
def updateEditMenu (self):

    c = self.c ; frame = c.frame ; gui = g.app.gui
    if not c: return
    try:
        # Top level Edit menu...
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("Edit")
        c.undoer.enableMenuItems()
        << enable cut/paste >>
        if 0: # Always on for now.
            menu = frame.menu.getMenu("Find...")
            enable(menu,"Find Next",c.canFind())
            flag = c.canReplace()
            enable(menu,"Replace",flag)
            enable(menu,"Replace, Then Find",flag)
        # Edit Body submenu...
        menu = frame.menu.getMenu("Edit Body...")
        enable(menu,"Extract Section",c.canExtractSection())
        enable(menu,"Extract Names",c.canExtractSectionNames())
        enable(menu,"Extract",c.canExtract())
        enable(menu,"Match Brackets",c.canFindMatchingBracket())
    except:
        g.es("exception updating Edit menu")
        g.es_exception()
#@nonl
#@+node:ekr.20040130164211:<< enable cut/paste >>
if frame.body.hasFocus():
    data = frame.body.getSelectedText()
    canCut = data and len(data) > 0
else:
    # This isn't strictly correct, but we can't get the Tk headline selection.
    canCut = True

enable(menu,"Cut",canCut)
enable(menu,"Copy",canCut)

data = gui.getTextFromClipboard()
canPaste = data and len(data) > 0
enable(menu,"Paste",canPaste)
#@nonl
#@-node:ekr.20040130164211:<< enable cut/paste >>
#@-node:ekr.20031218072017.836:updateEditMenu
#@+node:ekr.20031218072017.837: tkinterGui.__init__
def __init__ (self):

    # Initialize the base class.
    leoGui.leoGui.__init__(self,"tkinter")

    self.bitmap_name = None
    self.bitmap = None
    self.win32clipboard = None
    self.defaultFont = None
    self.defaultFontFamily = None

    if 0: # This seems both dangerous and non-functional.
        if sys.platform == "win32":
            try:
                import win32clipboard
                self.win32clipboard = win32clipboard
            except:
                g.es_exception()
#@nonl
#@-node:ekr.20031218072017.837: tkinterGui.__init__
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
    
    frame = self.frame ; c = self.c ; k = c.k ; t = self.bodyCtrl
    
    t.bind('<Key>', k.masterKeyHandler)

    for kind,func,handler in (
        ('<Button-1>',  frame.OnBodyClick,          k.masterClickHandler),
        ('<Button-3>',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('<Double-1>',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('<Double-3>',  None,                       k.masterDoubleClick3Handler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        t.bind(kind,bodyClickCallback)
            
    if sys.platform.startswith('win'):
        # Support Linux middle-button paste easter egg.
        t.bind("<Button-2>",frame.OnPaste)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo",c.undoer.undo), # &U reserved for Undo
        ("Can't Redo",c.undoer.redo), # &R reserved for Redo
        ("-",None),
        ("Cu&t",f.OnCutFromMenu), 
        ("Cop&y",f.OnCopyFromMenu),
        ("&Paste",f.OnPasteFromMenu),
        ("&Delete",c.editCommands.backwardDeleteCharacter),
        ("Select &All",f.body.selectAllText),
        ("-",None),
    ]

    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self,event=None):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    # g.trace(wname,s,i,j)
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@-node:ekr.20031218072017.835:(Use pywin extensions to improve cut/paste between apps)
#@+node:ekr.20040216054459:@h @f @endh and @endf directives
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2424151
By: ksejlod ( Peter Barrel ) 
 I Have a (maybe) great idea!   
2004-02-15 04:29

I've been using LEO for a while and finding surprinsingly powerfull new uses now and then, (hey, not a week passes that i dont think to myself : "why did'nt anyone thought of that kind of tool that is LEO. It's so stupid to program such a tool, yet no one thought of doing such a thing ! ")

I was wondering if there was a leo keyword (beginning with "@") that would do a feature I thought would be great: something such as :
@h
@endh
and of course, similarily...
@f
@endf

Standing for "Header", "End Header", "Footer" and "End Footer". Let me please explain ...

When creating files with @file (or nosentinels) I use the keyword "@others" in the starting node body of the file and place in the file, as it's decendants (children, grand-children & so on) some clones of other stuff somewhere else outside of this file (usualy, clones of parts of program regrouped as children of a "components" node up in the leo outline. Typical Example:

-Introduction
-+components
-a
-b
-c
-+@file program.BAS
-b
-c
-a

a, b, and c are clones and the @file node contains @others.

As you see, I proceed that way because in older programming languages or in lower level languages, the order of components such as procs, declarations, etc as an importance. It also has the implication that << and >> brackets are irrelevant in my way of using leo.

Now, my feature that I looked for in the doc but could not find (so i suggest it here in case no one had any need of this before) is that when used in the BODY of a node part of an "@file" the @h and @endh would define a chunk of text in the body, you've guessed it, to be added before _each_ children node and ONLY children no grandchildren or any deeper. But It could also be used INSIDE the body of a children to define headers or footers for IT'S OWN direct children.

so, eehh, do you see the relevance of such a feature? Have i explained it clearly? maybe this would help:
CONST baba=2 AS INTEGER
CONST bebe=7 AS INTEGER
CONST zaza=5 AS INTEGER
CONST bobo=1 AS INTEGER
... the beginning and end of each of those "parts-of-a-program" is the same for a potential lot of lines... 

To Be Precise :
It's just really for adding something at end or beginning of a direct children of a node part of an @file in the tangling process. 

Is this feature already implemented but i have not found it? I'm pretty sure it easy to implement... what do you people think of this?
Thanks 
--
k

p.s. I'm the guy who proposed that in the untangling process, a clone would not be updated by it's _Last-Instance-Found_ in the @file beeing untangled, but instead updated by the _Last-Modified-One-Found_ in the @file... :)

(ooouuuuhh that would be slick...)  

By: ksejlod ( Peter Barrel ) 
 RE: I Have a (maybe) great idea!   
2004-02-15 04:35  

 The tree i tried to draw in ascii did not came out the way i did it, sourceforge "eated" leading spaces sorry a, b and c are children of their "+" node just above them		.
--
k  
#@nonl
#@-node:ekr.20040216054459:@h @f @endh and @endf directives
#@+node:ekr.20040329185649:Known Bugs: can't be fixed or can wait
#@+node:ekr.20031218072017.663:Bug: can't be fixed
#@+node:ekr.20031218072017.664:Cut/paste bug on X windows (waiting for help)
@nocolor

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse.

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node.

Doing copy and paste works normally when done through the edit menu.

@color
#@nonl
#@+node:ekr.20031218072017.665:(Cut & Paste ) (Middle-button bug reported by Timo)
#@+node:ekr.20031218072017.666: Paste bug report
@nocolor

By: riotnrrrd ( Timo Honkasalo ) 
 Pasted text doesn't stick   
2002-11-01 13:38  
System: Linux 

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse. 

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node. 

Doing copy and paste works normally when done through the edit menu. 

-------------------

I also found out that if you do an extra "click" on the control key, it will
stick from then on.

If your text should have color in it, you can see that right before you "click",
the text has no color and the color back on right after you click the control.

It maybe a clue to someone, but seems strange to me. 
#@-node:ekr.20031218072017.666: Paste bug report
#@+node:ekr.20031218072017.667: Test
abc bbb bbbxyz bbb
#@nonl
#@-node:ekr.20031218072017.667: Test
#@-node:ekr.20031218072017.665:(Cut & Paste ) (Middle-button bug reported by Timo)
#@+node:ekr.20031218072017.668:Automatic select & Paste bug (Linux?)
@nocolor

Bumping the thread because the bug still persists. 

I've also noticed that the automatic select'n'paste doesn't work between nodes. That is, I can select text and paste a copy of it in the same node with middle button, but if I change click to another node, the paste buffer is erased. The automatic pasting works between Leo and other applications, however, and I can paste between nodes if I copy the selection to buffer by CTR-C. 

Maybe this is related to the non-sticking bug?

----

This may be a Linux-only bug related to the control-v workaround.
#@nonl
#@-node:ekr.20031218072017.668:Automatic select & Paste bug (Linux?)
#@-node:ekr.20031218072017.664:Cut/paste bug on X windows (waiting for help)
#@+node:ekr.20050514171429:Glitch pasting into headlines

@killcolor

http://sourceforge.net/forum/message.php?msg_id=3152036
By: ngirard

Hi again,

Leo has IMHO a slight inconsistency as when a new node is created and has to
be given a name.

When the new node is created, the string "NewHeadline" appears and is selected.
Then there are 2 ways of setting a new name:

1. by typing the new name character by character using the keyboard. This way,
"NewHeadline" disappears as the first character of the new name is typed. Here
the implicit idea is that "NewHeadline" is very unlikely to be the final node
name -- which makes sense to me ;-)

2. by pasting the contents of the clipboard, with Ctrl-v. This way, "NewHeadline"
*remains* and the contents of the clipboard is appended to it.


I find leo's behaviour in case #2 inconsistent with #1 and suggest that the
first approach should be preferred.

Cheers,
Nicolas


______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit: 
https://sourceforge.net/forum/unmonitor.php?forum_id=10226

#@-node:ekr.20050514171429:Glitch pasting into headlines
#@+node:ekr.20031218072017.669:Linux-only Bugs
These may indicate problems with Tk on Linux.  I can not reproduce them on XP.
#@nonl
#@+node:ekr.20031218072017.670:Possible webbrowser bug
(In Linux) The home page and online tutorial options in the menu only work properly if Mozilla window is already open. If not, a Mozilla window opens, but with empty page and url field. 
#@nonl
#@-node:ekr.20031218072017.670:Possible webbrowser bug
#@+node:ekr.20031218072017.671:Fix horiz scrollbar bug when tiling horizontally
When in 'vertical split' mode (with viewpane on right, and tree pane over log pane on left), the horixontal scrollbar at bottom of screen is at full width, despite the fact that not all of the tree pane area is displayed. 

Another way of saying this - I narrow the tree and log panes, to the extent that the display of tree node headings is truncated. But the horizontal scrollbar at the bottom doesn't contract, and doesn't allow me to horizontally scroll the tree pane to expose the rest of the node headings. 
#@-node:ekr.20031218072017.671:Fix horiz scrollbar bug when tiling horizontally
#@+node:ekr.20031218072017.672:Control-V doesn't work on Linux
This has been and continues to be a known issue with Tk. Has been logged as a bug; no response from the Tk folks. 

Here is a link to the Tk bug report: 

http://sourceforge.net/tracker/?func=detail&aid=605277&group_id=12997&atid=112997 

Note the work-around/patch in the followup post at the bottom of that page. Commenting out some statements in text.tcl removes the problem. 
#@-node:ekr.20031218072017.672:Control-V doesn't work on Linux
#@-node:ekr.20031218072017.669:Linux-only Bugs
#@+node:ekr.20050202073944:Mac bugs
#@+node:ekr.20050201175325.2:Can't delete script buttons
#@-node:ekr.20050201175325.2:Can't delete script buttons
#@+node:ekr.20050201175325.1:Icon buttons are not colored, nor do they have square borders, etc.
#@-node:ekr.20050201175325.1:Icon buttons are not colored, nor do they have square borders, etc.
#@+node:ekr.20050202052911.1:Find Text in Find Panel gets focus only if it contains text
#@-node:ekr.20050202052911.1:Find Text in Find Panel gets focus only if it contains text
#@-node:ekr.20050202073944:Mac bugs
#@+node:ekr.20031218072017.673:Tk bugs
The following bugs can not be fixed because they are Tk bugs.
#@nonl
#@+node:ekr.20041201071145:Tk Freezes on debean when libtk is compiled with thread support
http://sourceforge.net/forum/message.php?msg_id=2876797
By: skal

By: Gross Pascal - skal
RE: Leo freezing up  
2004-12-01 06:15

The freezing problem on debian sid (which is also my current OS) is caused by a bug in Tkinter: Tkinter does not work when libtk is compiled with thread support, which is the case on debian sid for tk8.4 
I compiled my own non-threaded libtk with the corresponding python/tkinter, and the freeze magically vanished.  
 
This is a known bug in debian bugtrack: 
 
http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=171353 
 
Skal
#@-node:ekr.20041201071145:Tk Freezes on debean when libtk is compiled with thread support
#@+node:EKR.20040523192553:(Crash when pasting large text into headlines)
#@+node:EKR.20040606104355:Report
@nocolor

From: <eltronic@juno.com>
To: <edreamleo@charter.net>
Sent: Sunday, May 23, 2004 9:36 AM
Subject: fatal bug in Leo headline handling


> found a fatal bug in Leo headline handling.
> not sure if anyone reported before,
> an oversize string can crash python 2.3.3
> 
> 
> the text was about 4500 bytes. nothing but text.
> opened the  leo again, copy a large page of text,
> insert headline, paste, fatal error in python.
> 
> I have by mistake pasted whatever node xml was in 
> the copy buffer into a headline w/o problem.
> but that was just dumb luck. just verified,
> had the node been large enough it crashes.
> 
> Leo 4.1 final, py2.3.3 win98
> PYTHON caused an invalid page fault in
> module TK84.DLL at 0167:1022b74f.
> 
> Leo 4.1 final, py2.2 win98
> paste a 15k node copy into headline. no problem.
> 
> this is the first repeatable hard crash I've stumbled on
> and thought it best to report it privately.
> I can think of no advantage to allowing a headline 
> of this size anyway. think of the tooltip that would create!
> 
> there are latent bugs in the selectall and delete from 
> the edit menu related to headline as well on the todo list.
> reported many times. 
> covert destruction of the selected body text.
> use of virtual events, with out proper focus to headline.
> 
> without myself being able to supply a patch, I'll guess,
> the virtual event paste called can as well point 
> to a function that checks the size before pasting.
> or simply sets the headline directly with 
> g.app.gui.getTextFromClipboard()[:1024]
> 
> 
> e
#@-node:EKR.20040606104355:Report
#@-node:EKR.20040523192553:(Crash when pasting large text into headlines)
#@+node:ekr.20031218072017.674:Caps lock affects keyboard shortcuts on Windows
Using leo under Windows, the keyboard shortcuts seem to use the "Caps Lock" state in determining the shift state when executing a shortcut.   For example, if the caps-lock key is on, then Ctrl-X is interpreted as Shift-Ctrl-X and cuts a node rather than selected text, and Shift-Ctrl-X is interpreted as Ctrl-X and cuts text.
#@-node:ekr.20031218072017.674:Caps lock affects keyboard shortcuts on Windows
#@+node:ekr.20031218072017.675:Tree problems
1. The border of the tree control is gray, and it is overwritten with large headlines.  This may be a Tk or Tkinter bug.

2. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this glitch because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.
#@nonl
#@-node:ekr.20031218072017.675:Tree problems
#@+node:ekr.20031218072017.676:Control-T can't be overridden in canvas text.
#@-node:ekr.20031218072017.676:Control-T can't be overridden in canvas text.
#@+node:ekr.20031218072017.677:(Alt-ctrl = Alt)
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1765069
By: dalcolmo

I use the bindings that come with Leo:

[keyboard shortcuts]
pastenode = Shift+Ctrl+V
gonextvisible = Alt+DnArrow
importtofile = Shift+Ctrl+F
writefilenodes = Shift+Ctrl+W
editheadline = Ctrl+H
markchangeditems = Alt+C
replace = Ctrl+=
goprevvisible = Alt+UpArrow
gotonextmarked = Alt+M
readoutlineonly = Shift+Ctrl+R
extractnames = Shift+Ctrl+N
gonext = Alt+Shift+DnArrow
findpanel = Ctrl+F
close = Ctrl+W
demote = Ctrl+}
tangle = Shift+Ctrl+T
extract = Shift+Ctrl+D
openpythonwindow = Alt+P
marksubheads = Alt+S
saveas = Shift+Ctrl+S
cut = Ctrl+X
preferences = Ctrl+Y
equalsizedpanes = Ctrl+E
cantundo = Ctrl+Z
open = Ctrl+O
promote = Ctrl+{
sortsiblings = Alt-A
unmarkall = Alt+U
mark = Ctrl+M
showinvisibles = Alt+V
exit = Ctrl-Q
insertnode = Ctrl+I
findprevious = F4
converttabs = Shift+Ctrl+J
save = Ctrl+S
tanglemarked = Shift+Ctrl+M
moveup = Ctrl+U
copynode = Shift+Ctrl+C
contractparent = Alt+0
selectall = Ctrl+A
setfont = Alt+Shift+T
aborteditheadline = Shift+Esc
goback = Alt+Shift+UpArrow
toggleactivepane = Ctrl+T
findnext = F3
tangleall = Shift+Ctrl+A
endeditheadline = Esc
deletenode = Shift+Ctrl+BkSp
cantredo = Shift+Ctrl+Z
new = Ctrl+N
contractall = Alt+1
moveleft = Ctrl+L
copy = Ctrl+C
paste = Ctrl+V
convertblanks = Shift+Ctrl+B
expandall = Alt+9
markchangedroots = Alt+R
cutnode = Shift+Ctrl+X
indent = Ctrl+]
gotonextchanged = Alt+D
expandnextlevel = Alt+=
setcolors = Alt+Shift+S
matchbrackets = Ctrl+K
movedown = Ctrl+D
clonenode = Ctrl+`
untangle = Shift+Ctrl+U
expandtolevel7 = Alt+7
expandtolevel6 = Alt+6
expandtolevel5 = Alt+5
expandtolevel4 = Alt+4
expandtolevel3 = Alt+3
expandtolevel2 = Alt+2
moveright = Ctrl+R
unindent = Ctrl+[
replacethenfind = Ctrl+-
extractsection = Shift+Ctrl+E
expandtolevel8 = Alt+8


However, I use a utility called AllChars (Free as in beer :-(  ) to be able
to type all kinds of chars on my US keyboard, and "Handything" to place the
windows on the screen (Win2000). Perhaps this makes a difference, although disabling
them did not seem to make it go away. Still, on pressing alt+ctrl+uparrow I
end up at the next upper node etc...

- Josef

#@-node:ekr.20031218072017.677:(Alt-ctrl = Alt)
#@+node:ekr.20031218072017.718:(tab bug)
#@+node:ekr.20040117092727:This is definitely a Tk bug
By: dthein ( Dave Hein ) 
 RE: BUG: Non-leading tabs not working properl   
2004-01-17 14:40  

 This seems to be a TK bug. I've reproduced the problem directly in Tk.

It's been around for a long time :-(

More details on this page, along with a patch for an earlier version.

http://www.qs.co.nz/Tcl/TkTabs.html

The Tk folks fixed a bug I reported with Ctrl-V behavior, but it took about a year for them to get to it. I don't have high expectations with this problem either, but I'll probably put together a patch for some of the recent version of Tk and submit the patches and bug report.  
#@-node:ekr.20040117092727:This is definitely a Tk bug
#@+node:ekr.20040118090055:Patch and bug report
https://sourceforge.net/forum/message.php?msg_id=2380238
By: dthein

I've submitted a patch and bug report to the Tk project.

The patch, #879073, for those that want to fix this problem on their systems,
is at:

http://sourceforge.net/tracker/?func=detail&aid=879073&group_id=12997&atid=31299
7

And the bug report, #879077, is at:

http://sourceforge.net/tracker/?func=detail&aid=879077&group_id=12997&atid=11299
7

The patch is for 8.4.2.  If you have a different version, you can probably figure
out the changes needed by looking at the patch file.  If not, let me know your
version and I may be able to produce a patch for it.

Note: If you use tabs for anything other than leading whitespace, you will find
this patch really helpful.  I make lots of little tables when I'm documenting
or note-taking ... this fix really helped my sanity when making those tables
inside Leo.

Dave Hein
#@nonl
#@-node:ekr.20040118090055:Patch and bug report
#@+node:ekr.20031218072017.719:Report
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1906790
By: dspeed
Open Discussion

-- Tabs are not expanded correctly in .c files, when language in preferences is set to c, and when the tabs occur in the middle of a line. The tabs are expanded as spaces until the next tab location is reached, then the tabs are expanded correctly. 
#@-node:ekr.20031218072017.719:Report
#@+node:ekr.20040105070023.5:Report 2
Leo 4.1 rc3, build 1.62 , December 19, 2003
Python 2.3.0, Tk 8.4.2
Linux 2.4.22-21mdkenterprise

1. Any tab typed before the first tab stop behaves correctly (the cursor is moved to the tab stop). Good.

2. Any tab typed after a non-tab character (even a space) _and_ after the first tab stop position doesn't behave like a tab and doesn't move the cursor to the next tab stop. Bad.

3. Any tab typed after a tab character will behave properly no matter what position on the line. Okay.

To reproduce this, set your global tab prefernence to 4. Show invisibles. And then create a node containing:

[BEGIN BODY TEXT]
@language plain
@tabwidth 8
[END BODY TEXT]

Create a child node to that one, containing:

[BEGIN BODY TEXT]
@root-code somefilename
\t\tThis works
bbb\tAnd This works
So\tdoes this

But, this \tdoes not.
Here is the two-tab \t\t behavior.
[END BODY TEXT]

I hope this is a Leo bug and not a Tk bug. 

Dave Hein 
#@nonl
#@-node:ekr.20040105070023.5:Report 2
#@+node:ekr.20031218072017.720:Minimal test
This is a test line.
#@nonl
#@-node:ekr.20031218072017.720:Minimal test
#@+node:ekr.20031218072017.721:Test File for Non Expanding Tabs
This is a test line.
put the text insertion point in the space between 'a' and 'test' above. Enter 3 tabs in a row and watch it not work.

If your expansion works correctly, then maybe something with leoconfig?  But wait, Im using the leoconfig from the beta download.

The contents of my Log Windows when opening this file:

Leo Log Window...
Pyton 2.2.2, Tk 8.3.2
reading d:\test.leo


#@-node:ekr.20031218072017.721:Test File for Non Expanding Tabs
#@+node:ekr.20031218072017.722:setTabWidth
def setTabWidth (self, w):
    
    try: # This can fail when called from scripts
        # Use the present font for computations.
        font = self.bodyCtrl.cget("font")
        root = g.app.root # 4/3/03: must specify root so idle window will work properly.
        font = tkFont.Font(root=root,font=font)
        tabw = font.measure(" " * abs(w)) # 7/2/02
        self.bodyCtrl.configure(tabs=tabw)
        self.tab_width = w
        # g.trace(w,tabw)
    except:
        g.es_exception()
        pass
#@-node:ekr.20031218072017.722:setTabWidth
#@-node:ekr.20031218072017.718:(tab bug)
#@-node:ekr.20031218072017.673:Tk bugs
#@+node:ekr.20040129133809.8:top node not saved
When opening a .leo file Leo selects the correct node but it is no longer the top most node in the window.

(no) Probably related to Leo now saving of the body pane size.
#@nonl
#@+node:ekr.20040130174232:What I did
@nocolor

- Eliminated entries like a="":  This happened because Leo no longer writes clone bits.

- Made sure Leo writes a="T" entries.  However, Leo really can't use this easily.

Another possibility would be to save the scrolling state, but that is very gui-dependent.
#@nonl
#@-node:ekr.20040130174232:What I did
#@+node:ekr.20031218072017.1579:putVnodes
def putVnodes (self):

    """Puts all <v> elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("<vnodes>") ; self.put_nl()

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            self.putVnode(p) # Write the next top-level node.

    self.put("</vnodes>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1579:putVnodes
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2 & 4.4)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = '' ; tnodeList = None ; attrDict = {}

    # we have already matched <v.
    
    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/>'): # A collapsed vnode.
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        return v
    
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste
#@nonl
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2 & 4.4)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    # Must check all parents.
    isIgnore = False
    for p2 in p.self_and_parents_iter():
        if p2.isAtIgnoreNode():
            isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("<v")
    << Put tnode index >>
    << Put attribute bits >>
    << Put tnodeList and unKnownAttributes >>
    fc.put(">")
    << Write the head text >>
    
    if not self.usingClipboard:
        << issue informational messages >>

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    fc.put(" t=") ; fc.put_in_dquotes(gnx)

    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):   attr += "T" # was a bottleneck
    if c.isCurrentPosition(p):      attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20040702085529:<< issue informational messages >>
if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@nonl
#@-node:ekr.20040702085529:<< issue informational messages >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
    fc.put("<vh>")
    fc.putEscapedString(headString)
    fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    # Delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20031218072017.3030:readOutlineOnly
def readOutlineOnly (self,theFile,fileName):

    c = self.c
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    c.beginUpdate()
    try:
        ok, ratio = self.getLeoFile(fileName,readAtFileNodesFlag=False)
    finally:
        c.endUpdate()
    c.frame.deiconify()
    vflag,junk,secondary_ratio = self.frame.initialRatios()
    c.frame.resizePanesToRatio(ratio,secondary_ratio)
    if 0: # 1/30/04: this is useless.
        # This should be done after the pane size has been set.
        if self.topPosition:
            c.frame.tree.setTopPosition(self.topPosition)
            c.redraw_now()
    # delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.3030:readOutlineOnly
#@-node:ekr.20040129133809.8:top node not saved
#@-node:ekr.20031218072017.663:Bug: can't be fixed
#@+node:ekr.20040105064959:Bugs: can wait
@nocolor
#@nonl
#@+node:ekr.20040115165036:bug in xml doc parts (hard to fix?)
@language html
@ignore
@color
#@nonl
#@+node:ekr.20040115165036.1:Demo XML comment bug
@ 
This document demonstrates what appears to be a bug in Leo 4.1 rc3, build 1.62 of December 19, 2003.

It has manifested when Leo is executed under Python 2.3.3, Tk 8.4.3 under Windows 2000.

In brief, derived XML files are not well-formed with respect to comments under some conditions.  Comments can wind up nested, which looks okay to humans but not to XML parsers.
@c
#@nonl
#@-node:ekr.20040115165036.1:Demo XML comment bug
#@+node:ekr.20040115165036.3:@file xmlcommentbug.xml
@first
@language HTML
<HiMom>
@ This will produce, in the derived file, an XML comment with another XML comment embedded.  Or, if you prefer, it will produce an unclosed XML comment followed by a well-formed one, followed by a string of text containing a comment-close marker.

This text is sitting in the inner comment, according to the first view.
@c


@
This comment is well-formed, seemingly because its content does not begin on the same line as the at-sign.
@c
</HiMom>
#@nonl
#@-node:ekr.20040115165036.3:@file xmlcommentbug.xml
#@+node:ekr.20040115165036.4:xmlcommentbug.xml
<?xml version='1.0'?>
<!--@+leo-ver=4-->
<!--@+node:@file xmlcommentbug.xml-->
<!--@@first-->
<!--@@language HTML-->
<HiMom>
<!--@+at -->
<!--
<!--@nonl-->
This will produce, in the derived file, an XML comment with another XML 
comment embedded.  Or, if you prefer, it will produce an unclosed XML comment 
followed by a well-formed one, followed by a string of text containing a 
comment-close marker.

This text is sitting in the inner comment, according to the first view.
-->
<!--@-at-->
<!--@@c-->


<!--@+at-->
<!--
This comment is well-formed, seemingly because its content does not begin on 
the same line as the at-sign.
-->
<!--@-at-->
<!--@@c-->
</HiMom>
<!--@nonl-->
<!--@-node:@file xmlcommentbug.xml-->
<!--@-leo-->
#@nonl
#@-node:ekr.20040115165036.4:xmlcommentbug.xml
#@-node:ekr.20040115165036:bug in xml doc parts (hard to fix?)
#@+node:ekr.20040125114453:Import bug?control-alt-f of python code misalloctes code (waiting for answer)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2391076
By: thyrsus

There is a lot of correct intepretation going on, but there are some errors.
As an example, the anaconda code, in text.py, contains the following lines.
I'll use periods for leading whitespace, the two characters ^I for leading tabs,
and a $ to indicate a newline:

class WaitWindow:
def pop(self):
    self.screen.popWindow()
    self.screen.refresh()

def __init__(self, screen, title, text):
    self.screen = screen
    width = 40
    if (len(text) < width): width = len(text)

    t = TextboxReflowed(width, text)

    g = GridForm(self.screen, title, 1, 1)
    g.add(t, 0, 0)
    g.draw()
    self.screen.refresh()


After importing file text.py, I get three associated nodes like so:

[class WaitWindow]
.|
.+-[pop]
.|
.+-[__init__]

However, the contents of the nodes are off.  In node [class WaitWindow] the
text is

class WaitWindow:
@others
    self.screen = screen
    width = 40
    if (len(text) < width): width = len(text)

    t = TextboxReflowed(width, text)
    g = GridForm(self.screen, title, 1, 1)
    g.add(t, 0, 0)
    g.draw()
    self.screen.refresh()

Node [pop] contains the text

def pop(self):

Node [__init__] contains the text

self.screen.popWindow()
self.screen.refresh()

def __init__(self, screen, title, text):

This anaconda code is being correctly interpreted by the python 1.5 interpreter.
I'm too green with python to pronounce on whether the formatting is conventional.
I don't consider this a bug a major problem, but it should probably be addressed
before we start touting Leo for large collections of existing code.

This is my first experience importing python; in the past I've imported perl
code, and Leo gave me just one big @file node, and I was on my own to better
structure it.  Given the perversity of perl syntax ("Nothing but perl can parse
Perl." - Tom Christiansen), that's probably the right thing to do.  It's a judgement
call for whomever wants to take responsibility for the python importer as to
whether that may be the right thing to do for python.
#@nonl
#@-node:ekr.20040125114453:Import bug?control-alt-f of python code misalloctes code (waiting for answer)
#@+node:ekr.20040129133809.5:Expand/contract may not work after drag (works for me)
sometimes after a drag of a node, 
then the expand/contract doesnt work.
click or menu has no effect.
in an open leo
maybe it is ok after you save the file
other times only fix is to exit & restart.
#@nonl
#@-node:ekr.20040129133809.5:Expand/contract may not work after drag (works for me)
#@-node:ekr.20040105064959:Bugs: can wait
#@-node:ekr.20040329185649:Known Bugs: can't be fixed or can wait
#@+node:ekr.20040217153407.1:Unify @root and @file
- There is no way to unify the syntax: a different syntax is needed to specify sections that may appear in pieces.

- I have little interest in this project, even if a better read logic for @root derived files might make automatic untangling possible.
#@-node:ekr.20040217153407.1:Unify @root and @file
#@-node:ekr.20040123102724:Can't or won't
#@-all
#@nonl
#@-node:ekr.20060207133601:@thin ../doc/leoToDoLater.txt
#@-leo
