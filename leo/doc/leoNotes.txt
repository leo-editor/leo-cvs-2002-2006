#@+leo-ver=4-thin
#@+node:ekr.20031218072017.329:@thin ../doc/leoNotes.txt
#@@nocolor

This contains my notes for the Leo project.

#@+all
#@+node:ekr.20050123161408:ExamDiff files
0 leo.py
1 leoApp.py
2 leoAtFile.py
3 leoColor.py
4 leoCommands.py
5 leoCompare.py
6 leoConfig.py
7 leoFileCommands.py
8 leoFind.py
9 leoFrame.py
10 leoGlobals.py
11 leoGui.py
12 leoImport.py
13 leoKeys.py
14 leoMenu.py
15 leoNodes.py
16 leoPlugins.py
17 leoTangle.py
18 leoTkinterComparePanel.py
19 leoTkinterDialog.py
20 leoTkinterFind.py
21 leoTkinterFontPanel.py
22 leoTkinterFrame.py
23 leoTkinterGui.py
24 leoTkinterKeys.py
25 leoTkinterMenu.py
26 leoTkinterTree.py
27 leoUndo.py
#@nonl
#@+node:ekr.20050123160215.1:Put all files in alpha order in ExamDiff
import leoGlobals as g

print '-' * 20
d = []

for p in g.top().allNodes_iter():
    s = p.headString()
    if s.startswith('@thin'):
        d.append(s[5:].strip())
        
d.sort()

for s in d:
    print s
    

        
#@-node:ekr.20050123160215.1:Put all files in alpha order in ExamDiff
#@-node:ekr.20050123161408:ExamDiff files
#@+node:ekr.20031218072017.365:How to...
#@+node:ekr.20031218072017.366:How to add and remove files from CVS repository
use the command line option in the admin menu to do the following:

add leoConfig.py and leoConfig.txt
	cvs add leoConfig.txt
	cvs add leoConfig.py
	(then do commit)

remove readme*.doc
	remove files from working area (done)
	cvs remove readme1.doc
	cvs remove readme2.doc
	...
	(then do commit)
#@nonl
#@-node:ekr.20031218072017.366:How to add and remove files from CVS repository
#@+node:ekr.20031218072017.367:How to add support for a new language
@nocolor

- Add a new entries in << define global data structures >> app

- Add a new Tk.Radiobutton in <<create the Target Language frame>>

- Add an entry to the languages list in <<configure language-specific settings>>

- Add a list of the keywords of the language to << define colorizer keywords >>

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done in this step.

TESTS

- Test the syntax coloring for the new language by using the @language directive.

- Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

- Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

- Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the <preferences> tag (near the top) contains an entry like this:

<preferences allow_rich_text="0" defaultTargetLanguage="Python">
</preferences>

but with the name of your new language instead of "Python".

- Create an @root node and verify that you can Tangle it.

@color
#@nonl
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@+node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
# Frame and title
w,target = gui.create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
    ("ActionScript", "actionscript"),
    ("Ada", "ada"),
    ("C#",    "csharp"),
    ("C/C++", "c"),
    ("CSS",   "css"),
    ("CWEB",  "cweb"),
    ("elisp", "elisp"),
    ("Forth", "forth"),
    ("HTML",  "html"),
    ("Java",  "java"),
    ("LaTeX", "latex")
   ]

for text,value in left_data:
    button = Tk.Radiobutton(lt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")

# Right column of radio buttons.
right_data = [
    ("Pascal","pascal"),
    ("Perl", "perl"),
    ("Perl+POD",   "perlpod"),
    ("PHP",        "php"),
    ("Plain Text", "plain"),
    ("Python",     "python"),
    ("RapidQ",     "rapidq"),
    ("Rebol",      "rebol"),
    ("Shell",      "shell"),
    ("tcl/tk",     "tcltk")]

for text,value in right_data:
    button = Tk.Radiobutton(rt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")
#@nonl
#@-node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords
#@nonl
#@+node:ekr.20031218072017.372:actionscript keywords
actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]
#@nonl
#@-node:ekr.20031218072017.372:actionscript keywords
#@+node:bwmulder.20041023131509:ada keywords
ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]
#@nonl
#@-node:bwmulder.20041023131509:ada keywords
#@+node:ekr.20040206072057:c# keywords
csharp_keywords = [
    "abstract","as",
    "base","bool","break","byte",
    "case","catch","char","checked","class","const","continue",
    "decimal","default","delegate","do","double",
    "else","enum","event","explicit","extern",
    "false","finally","fixed","float","for","foreach",
    "get","goto",
    "if","implicit","in","int","interface","internal","is",
    "lock","long",
    "namespace","new","null",
    "object","operator","out","override",
    "params","partial","private","protected","public",
    "readonly","ref","return",
    "sbyte","sealed","set","short","sizeof","stackalloc",
    "static","string","struct","switch",
    "this","throw","true","try","typeof",
    "uint","ulong","unchecked","unsafe","ushort","using",
    "value","virtual","void","volatile",
    "where","while",
    "yield"]
#@nonl
#@-node:ekr.20040206072057:c# keywords
#@+node:ekr.20031218072017.373:c/c++ keywords
c_keywords = [
    # C keywords
    "auto","break","case","char","continue",
    "default","do","double","else","enum","extern",
    "float","for","goto","if","int","long","register","return",
    "short","signed","sizeof","static","struct","switch",
    "typedef","union","unsigned","void","volatile","while",
    # C++ keywords
    "asm","bool","catch","class","const","const_cast",
    "delete","dynamic_cast","explicit","false","friend",
    "inline","mutable","namespace","new","operator",
    "private","protected","public","reinterpret_cast","static_cast",
    "template","this","throw","true","try",
    "typeid","typename","using","virtual","wchar_t"]
#@nonl
#@-node:ekr.20031218072017.373:c/c++ keywords
#@+node:ekr.20040401103539:css keywords
css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]
#@nonl
#@-node:ekr.20040401103539:css keywords
#@+node:ekr.20031218072017.374:elisp keywords
# EKR: needs more work.
elisp_keywords = [
    # Maybe...
    "error","princ",
    # More typical of other lisps...
    "apply","eval",
    "t","nil",
    "and","or","not",
    "cons","car","cdr",
    "cond",
    "defconst","defun","defvar",
    "eq","ne","equal","gt","ge","lt","le",
    "if",
    "let",
    "mapcar",
    "prog","progn",
    "set","setq",
    "type-of",
    "unless",
    "when","while"]
#@nonl
#@-node:ekr.20031218072017.374:elisp keywords
#@+node:ekr.20041107093834:forth keywords
# Default forth keywords: extended by leo-forthwords.txt.
forth_keywords = [
    "variable", "constant", "code", "end-code",
    "dup", "2dup", "swap", "2swap", "drop", "2drop",
    "r>", ">r", "2r>", "2>r",
    "if", "else", "then",
    "begin", "again", "until", "while", "repeat",
    "v-for", "v-next", "exit",
    "meta", "host", "target", "picasm", "macro",
    "needs", "include",
    "'", "[']",
    ":", ";",
    "@", "!", ",", "1+", "+", "-",
    "<", "<=", "=", ">=", ">",
    "invert", "and", "or", 
    ]

# Forth words which define other words: extended by leo-forthdefwords.txt.
forth_definingwords = [
    ":", "variable", "constant", "code",
    ]

# Forth words which start strings: extended by leo-forthstringwords.txt.
forth_stringwords = [
    's"', '."', '"', '."',
    'abort"',
    ]

# Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
forth_boldwords = [ ]

# Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
forth_italicwords = [ ]

# Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
# Note: on some boxen, bold italics may show in plain bold.
forth_bolditalicwords = [ ]
#@nonl
#@-node:ekr.20041107093834:forth keywords
#@+node:ekr.20031218072017.375:html keywords
# No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
    unused_keywords = [
        # html constructs.
        "a","body","cf",
        "h1","h2","h3","h4","h5","h6",
        "head","html","hr",
        "i","img","li","lu","meta",
        "p","title","ul",
        # Common tags
        "caption","col","colgroup",
        "table","tbody","td","tfoot","th","thead","tr",
        "script","style"]

    html_specials = [ "<%","%>" ]
#@nonl
#@-node:ekr.20031218072017.375:html keywords
#@+node:ekr.20031218072017.376:java keywords
java_keywords = [
    "abstract","boolean","break","byte","byvalue",
    "case","cast","catch","char","class","const","continue",
    "default","do","double","else","extends",
    "false","final","finally","float","for","future",
    "generic","goto","if","implements","import","inner",
    "instanceof","int","interface","long","native",
    "new","null","operator","outer",
    "package","private","protected","public","rest","return",
    "short","static","super","switch","synchronized",
    "this","throw","transient","true","try",
    "var","void","volatile","while"]
#@nonl
#@-node:ekr.20031218072017.376:java keywords
#@+node:ekr.20031218072017.377:latex keywords
#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
    "\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
    "\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
    "\\cot", "\\coth",	"csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
    "\\linethickness", "\\linewidth",	"\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow",	"longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi",	"\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow",	"\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone",	"\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]
#@nonl
#@-node:ekr.20031218072017.377:latex keywords
#@+node:ekr.20031218072017.378:pascal keywords
pascal_keywords = [
    "and","array","as","begin",
    "case","const","class","constructor","cdecl"
    "div","do","downto","destructor","dispid","dynamic",
    "else","end","except","external",
    "false","file","for","forward","function","finally",
    "goto","if","in","is","label","library",
    "mod","message","nil","not","nodefault""of","or","on",
    "procedure","program","packed","pascal",
    "private","protected","public","published",
    "record","repeat","raise","read","register",
    "set","string","shl","shr","stdcall",
    "then","to","true","type","try","until","unit","uses",
    "var","virtual","while","with","xor"
    # object pascal
    "asm","absolute","abstract","assembler","at","automated",
    "finalization",
    "implementation","inherited","initialization","inline","interface",
    "object","override","resident","resourcestring",
    "threadvar",
    # limited contexts
    "exports","property","default","write","stored","index","name" ]
#@nonl
#@-node:ekr.20031218072017.378:pascal keywords
#@+node:ekr.20031218072017.379:perl keywords
perl_keywords = [
    "continue","do","else","elsif","format","for","format","for","foreach",
    "if","local","package","sub","tr","unless","until","while","y",
    # Comparison operators
    "cmp","eq","ge","gt","le","lt","ne",
    # Matching ooperators
    "m","s",
    # Unary functions
    "alarm","caller","chdir","cos","chroot","exit","eval","exp",
    "getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
    "hex","int","length","localtime","log","ord","oct",
    "require","reset","rand","rmdir","readlink",
    "scalar","sin","sleep","sqrt","srand","umask",
    # Transfer ops
    "next","last","redo","go","dump",
    # File operations...
    "select","open",
    # FL ops
    "binmode","close","closedir","eof",
    "fileno","getc","getpeername","getsockname","lstat",
    "readdir","rewinddir","stat","tell","telldir","write",
    # FL2 ops
    "bind","connect","flock","listen","opendir",
    "seekdir","shutdown","truncate",
    # FL32 ops
    "accept","pipe",
    # FL3 ops
    "fcntl","getsockopt","ioctl","read",
    "seek","send","sysread","syswrite",
    # FL4 & FL5 ops
    "recv","setsocket","socket","socketpair",
    # Array operations
    "pop","shift","split","delete",
    # FLIST ops
    "sprintf","grep","join","pack",
    # LVAL ops
    "chop","defined","study","undef",
    # f0 ops
    "endhostent","endnetent","endservent","endprotoent",
    "endpwent","endgrent","fork",
    "getgrent","gethostent","getlogin","getnetent","getppid",
    "getprotoent","getpwent","getservent",
    "setgrent","setpwent","time","times","wait","wantarray",
    # f1 ops
    "getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
    "sethostent","setnetent","setprotoent","setservent",
    # f2 ops
    "atan2","crypt",
    "gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
    "index","link","mkdir","msgget","rename",
    "semop","setpgrp","symlink","unpack","waitpid",
    # f2 or 3 ops
    "index","rindex","substr",
    # f3 ops
    "msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
    # f4 & f5 ops
    "semctl","shmread","shmwrite","msgrcv",
    # Assoc ops
    "dbmclose","each","keys","values",
    # List ops
    "chmod","chown","die","exec","kill",
    "print","printf","return","reverse",
    "sort","system","syscall","unlink","utime","warn"]
#@nonl
#@-node:ekr.20031218072017.379:perl keywords
#@+node:ekr.20031218072017.380:php keywords
php_keywords = [ # 08-SEP-2002 DTHEIN
    "__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
    "and", "as", "break",
    "case", "cfunction", "class", "const", "continue",
    "declare", "default", "do",
    "else", "elseif", "enddeclare", "endfor", "endforeach",
    "endif", "endswitch",  "endwhile", "eval", "extends",
    "for", "foreach", "function", "global", "if",
    "new", "old_function", "or", "static", "switch",
    "use", "var", "while", "xor" ]
    
# The following are supposed to be followed by ()
php_paren_keywords = [
    "array", "die", "echo", "empty", "exit",
    "include", "include_once", "isset", "list",
    "print", "require", "require_once", "return",
    "unset" ]
    
# The following are handled by special case code:
# "<?php", "?>"
#@-node:ekr.20031218072017.380:php keywords
#@+node:ekr.20031218072017.381:python keywords
python_keywords = [
    "and",       "del",       "for",       "is",        "raise",    
    "assert",    "elif",      "from",      "lambda",    "return",   
    "break",     "else",      "global",    "not",       "try",      
    "class",     "except",    "if",        "or",        "yield",   
    "continue",  "exec",      "import",    "pass",      "while",
    "def",       "finally",   "in",        "print"]
#@nonl
#@-node:ekr.20031218072017.381:python keywords
#@+node:ekr.20040331145826:rapidq keywords
rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]
#@nonl
#@-node:ekr.20040331145826:rapidq keywords
#@+node:ekr.20031218072017.382:rebol keywords
rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]
#@nonl
#@-node:ekr.20031218072017.382:rebol keywords
#@+node:ekr.20040401111125:shell keywords
shell_keywords = [
    # reserved keywords
    "case","do","done","elif","else","esac","fi",
    "for","if","in","then",
    "until","while",
    "break","cd","chdir","continue","eval","exec",
    "exit","kill","newgrp","pwd","read","readonly",
    "return","shift","test","trap","ulimit",
    "umask","wait" ]
#@nonl
#@-node:ekr.20040401111125:shell keywords
#@+node:ekr.20031218072017.383:tcl/tk keywords
tcltk_keywords = [ # Only the tcl keywords are here.
    "after",     "append",    "array",
    "bgerror",   "binary",    "break",
    "catch",     "cd",        "clock",
    "close",     "concat",    "continue",
    "dde",
    "encoding",  "eof",       "eval",
    "exec",      "exit",      "expr",
    "fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
    "filename",  "flush",     "for",       "foreach",   "format",
    "gets",      "glob",      "global",
    "history",
    "if",        "incr",      "info",      "interp",
    "join",
    "lappend",   "lindex",    "linsert",   "list",      "llength",
    "load",      "lrange",    "lreplace",  "lsearch",   "lsort",
    "memory",    "msgcat",
    "namespace",
    "open",
    "package",   "parray",    "pid",
    "proc",      "puts",      "pwd",
    "read",      "regexp",    "registry",   "regsub",
    "rename",    "resource",  "return",
    "scan",      "seek",      "set",        "socket",   "source",
    "split",     "string",    "subst",      "switch",
    "tell",      "time",      "trace",
    "unknown",   "unset",     "update",     "uplevel",   "upvar",
    "variable",  "vwait",
    "while" ]
#@nonl
#@-node:ekr.20031218072017.383:tcl/tk keywords
#@-node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
#@-node:ekr.20031218072017.367:How to add support for a new language
#@+node:ekr.20031218072017.384:How to export syntax colored code preserving colors
Scite has the option to "Export as html" and "export as rtf", and it will be
full of colour and fonts - and you can define them in properties, so it will be
the same as during editing.
#@nonl
#@-node:ekr.20031218072017.384:How to export syntax colored code preserving colors
#@+node:ekr.20031218072017.385:How to Increase environment space
To increase the size of environment space, add the following to config.sys:

shell=C:\windows\command\command.com /p:4096

Notes:

1. The path C:\windows\command\command.com may vary.
Check you system for the location of command.com.

2. This works for versions of Windows prior to Me.
On Me you set the registry somehow.
No information on XP.
#@nonl
#@-node:ekr.20031218072017.385:How to Increase environment space
#@+node:ekr.20031218072017.386:How to remove cursed newlines: use binary mode
teknico ( Nicola Larosa ) 
 RE: Removing '\r' characters?   
2002-09-16 14:27  
> I am plowing through old bug reports, and I found the following, from whom 
> I don't know: 

That's from me, *again*. You are kindly advised to stop forgetting the attribution to all my bug reports. ;^) 

>> - Source files still have the dreaded \r in them. Why don't you switch 
>> to \n only, once and for all, and live happily ever after? ;^) 

> I sure whould like to do that, and I'm not sure how to do this. All 
> versions of the read code attempt to remove '\r' characters, and all 
> versions of the write code write '\n' only for newlines. 

Sorry for being a bit vague, I was talking about the Leo source files themselves. I don't know what you use to edit them, ;^))) but in version 3.6 they still have \r\n as end-of-line. 

If Leo itself does not solve the problem, may I suggest the 
Tools/scripts/crlf.py script in the Python source distibution? It's nice and simple, and skips binary files, too. That's what I use every time I install a new version of Leo. :^) 
 
#@+node:ekr.20031218072017.387:The solution
Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". The unix python interpreter ignores trailing "\r" in python source files. There are no such guarantees for other languages. Unix users should be able to get rid of the cosmetically detrimental "\r" either by running dos2unix on the offending files, or, if they're part of a .leo project, reading them into leo and writing them out again.  


By: edream ( Edward K. Ream ) 
 RE: Removing '\r' characters?   
2002-09-17 09:34  
Oh, I see. Thanks very much for this clarification. 

Just to make sure I understand you: the problem with '\r' characters is that: 

1. I am creating LeoPy.leo and LeoDocs.leo on Windows and 
2. People are then using these files on Linux. 

and the way to remove the '\r' characters: 

1. I could run dos2unix on all distributed files just before committing to CVS or making a final distribution or 
2. People could, say, do the following: 

Step 1: Read and Save the .leo files, thereby eliminating the '\r' in those files and 
Step 2: Use the Write @file nodes command on all derived files to clear the '\r' in those files. 

Do you agree so far? 

> Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". 

I am going to see if there is any way to get Python to write a "raw" '\n' to a file. I think there must be. This would solve the problem once and for all. 

Thanks again for this most helpful comment. 

Edward
#@nonl
#@-node:ekr.20031218072017.387:The solution
#@+node:ekr.20031218072017.388:cursed newline answer
In 2.3 you can open files with the "U" flag and get "universal newline"
support: 

% python
Python 2.3a0 (#86, Sep 4 2002, 21:13:00) 
[GCC 2.96 20000731 (Mandrake Linux 8.1 2.96-0.62mdk)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> f = open("crlf.txt")
>>> line = f.readline()
>>> line
'This is an example of what I have come to call the "cursed newline"
problem,\r\n'
>>> f = open("crlf.txt", "rU")
>>> line = f.readline()
>>> line
'This is an example of what I have come to call the "cursed newline" problem,\n'

#@-node:ekr.20031218072017.388:cursed newline answer
#@+node:ekr.20031218072017.389:cursed newline answer 2
> You can open the file in 'binary' mode (adding 'b' to the mode string) and
> the file will contain '\r\n' on both platforms (and any other platforms.)

Nope. Exactly wrong. In 2.2 and those before, when files are opened in
*text* mode (no "b") then reading them will provide Unix-style line endings
(newline only). When you open files in binary mode then you see the bytes
stored in the file.

On Unix systems there's no difference in the contents of a file whether in
binary or text mode. On Windows a file is shorter by the number of carriage
returns. On the Mac I have no idea what they do. Probably just carriage
returns, to be different :-)

2.3 will be a bit more flexible about such mattrers.
#@-node:ekr.20031218072017.389:cursed newline answer 2
#@-node:ekr.20031218072017.386:How to remove cursed newlines: use binary mode
#@+node:ekr.20031218072017.390:How to run Pychecker
Do the following in Idle:

import pychecker.checker ; import leo
#@nonl
#@-node:ekr.20031218072017.390:How to run Pychecker
#@+node:ekr.20031218072017.391:How to use CVS branches
@nocolor

I have a fair bit of expertise on CVS branches. It's late at night, so I don't have time for a long soapbox spiel at the moment. I will try to post something tomorrow. 

The brief picture is: 

* Check out code from CVS at the point you want to create the branch. 

* Make sure none of the files in your sandbox is modified. 

* Create the branch (cvs tag -b branchname). The branch name must start with a letter (upper or lower case) and thereafter can have alphanumeric characters, hyphens, and underscores (no periods or spaces). 

* The branch is created on the repository, but your sandbox is still checked out on the main branch. To check out on the new branch, do "cvs up -r branchname". 

When you want to merge changes back into the main branch, you can use "cvs up -r MAIN" to retrieve the main branch, then "cvs up -j branchname" to merge changes, then "cvs commit" to commit the merged version to the main branch AFTER YOU HAVE VERIFIED IT. 

I would recommend caution with merging because as you have noted, leo files are not well set up for CVS. They don't merge well because of inconsistent sentinel values. 

You may want to look at manually merging changes back into the main branch until leo implements invariant unique (UUID) sentinel indices. 

This will not hurt your ability to use branches, only your ability to automatically merge changes from one branch onto another.
#@nonl
#@-node:ekr.20031218072017.391:How to use CVS branches
#@+node:ekr.20041214135556:How to use Tile
@nocolor
https://sourceforge.net/forum/message.php?msg_id=2882718
By: nobody

if anyone is interested here is some code that Tilefied my Leo instance, its
does some patching in the LeoGui program.

@color

def createRootWindow(self):

    """Create a hidden Tk root window."""
    #import Tix
    self.root = root = Tk.Tk()
    root.tk.call( 'package', 'require', 'tile' )
    #root.tk.call( 'namespace', 'import', '-force', 'ttk::*' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::scrollbar' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::label' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::entry' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::menu' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::button' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::frame' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::menubutton' )
    root.tk.call( 'tile::setTheme', 'clam' )
    #self.root = root = Tix.Tk()
    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    self.getDefaultConfigFont(g.app.config)
    self.createGlobalWindows()

    return root
#@nonl
#@-node:ekr.20041214135556:How to use Tile
#@-node:ekr.20031218072017.365:How to...
#@+node:ekr.20040104162835.8:Mac notes: Dan Winkler
#@+node:ekr.20040104162835.9:Porting notes
Here's Apple's documentation on making Unix software run on OS X:

http://developer.apple.com/documentation/Porting/Conceptual/ 
PortingUnix/index.html
#@-node:ekr.20040104162835.9:Porting notes
#@+node:ekr.20040104162835.10:$Path, etc.
In general, Unix commands can go anywhere and they're found by the 
shell using the $PATH variable.  To know what your path is, type "echo 
$PATH" at the shell.

Typically you'll have new things added to your path by a file called 
.login in your home directory.  This runs when you log in and then the 
settings are inherited by all the shells you run.

You can also type the full path to something if you want to invoke it 
that way, such as "/usr/local/bin/python".

Fink puts everything underneath /sw so as to avoid conflicting with 
Apple's versions of things.

If you can't invoke a file, it might be that it's not set to be 
executable.  If you do "ls -l" you'll see files listed with their 
permissions.  You'll see some of r, w, and x meaning read, write and 
execute.  These appear three times for owner, group, and everyone.  You 
can do "chmod +x filename" to make it executable for the owner or you 
can use numbers as in "chmod 755 file name" which sets rwx for the 
owner (7 = 111 in binary = rwx) and rx for group and everyone (5 = 101 
in binary = r_x).

I know this might seem confusing at first but the fact that things 
won't execute without being set executable is a big curb on viruses.  
In fact, there are no OS X viruses yet.  Anyway, it's all a matter of 
what you're used to.  Windows seems confusing to someone new to it too.

#@-node:ekr.20040104162835.10:$Path, etc.
#@+node:ekr.20040104162835.11:which python
You can type "which python" to find out which version of python (or any 
other command) will run.
#@-node:ekr.20040104162835.11:which python
#@+node:ekr.20040104162835.12:get info
That error message (from import _tkinter) makes it sound like you are 
somehow running the text-only version of Python that came with OS X... 
except you said you deleted that.

You can use "get info" in the finder to check and set which program 
will be used to open a given file.  So you can select your main leo.py 
file (or whichever the one you start with is), do get info on it, and 
tell it to open with the MacPython launcher that you want.  Then you 
should be able to double click it to open it.  That's what I do to run 
Leo on my Mac.

#@-node:ekr.20040104162835.12:get info
#@+node:ekr.20040104162835.13:Fink & aqua
Yes, fink does have pre-built Pythons, both 2.1 and 2.2.  (If you don't 
see them it probably means you don't have the right servers listed in 
your /sw/etc/apt/sources.list file.)  However, the versions of Python 
you'd get through fink are set up to run under X Windows, which I don't 
think is what you want.

I think what you want is MacPython which can run Tk programs like Leo 
under Aqua.  That's what I use these days.

I can tell from your question that you don't understand the following 
differences between the versions of Python available:

1) The version that comes with OS X is a text only one which doesn't 
have Tk.  Leo can't run under that.  Also, I hate Apple for including 
this instead of one that does have Tk and I hope they'll fix it some 
day.

2) You can get a version of Python from fink with has Tk but which runs 
under X Windows.  I don't think you want that.

3). You can also get MacPython which has Tk but it's a version of Tk 
that uses the Aqua windowing system, not X Windows.

So Tk can either be present or not and if it is present it can use 
either X Windows or Aqua.  You want it present and using Aqua, I think.


#@-node:ekr.20040104162835.13:Fink & aqua
#@+node:ekr.20040104162835.14:Mac, Fink, etc.
> 1. The python that FC installs is MacPython.  I think that because the
> MacPython docs talk about Fink.

Nope.  The python installed by FC knows nothing about the Mac.  It 
thinks it's running on a Unix machine.  And it uses a version of Tk 
which thinks it's running on a Unix machine.  The window standard on 
Unix is called X (or X11 or XFree86, all the same thing).  So the main 
reason to run Leo this way would be to get an idea of how it works for 
Unix/Linux users.  But when programs run under X, they don't look like 
Mac programs.  They don't get all those glossy, translucent widgets 
that Aqua provides.  They really look like they would on a Unix/Linux 
machine.

Aqua is the native windowing system on Mac.  MacPython is set up to 
work with it.  Most Mac users will want Leo to work this way.  That's 
what I do.

>
>
> I have the TkTclAquBI (Batteries included) installer.  Is installing 
> this
> enough to get Leo to work with Aqua?  Do I have to de-install the
> present tk stuff that I installed with FC?

Yes, I think that's all I installed to get Tk to work under Aqua.  You 
don't have to deinstall the FC stuff.  All the FC stuff lives in its 
own world under /sw and runs under X.  It won't conflict with the Mac 
world.

#@-node:ekr.20040104162835.14:Mac, Fink, etc.
#@+node:ekr.20040104162835.15:Double clicking on Linux
Double-clickable things (i.e. Macintosh applications) are usually 
actually folders with a name that ends in .app.  The file you found is 
probably executable only from the command line, not by double clicking 
it.  So I think if you run it from the command line it will work but 
will not know about Tk because Apple's version was built without Tk 
support.

You can also execute the .app programs from the command line by using 
the open command, so "open foo.app" will do the same thing as double 
clicking on foo in the finder (the .app extension is suppressed).  The 
idea behind this is that an application can look like just one opaque 
icon in the finder but actually have all its resources nicely organized 
in subfolders.
#@-node:ekr.20040104162835.15:Double clicking on Linux
#@+node:ekr.20040104162835.16:Getting Leo on Fink Commander
FC gets its list of packages from the servers listed in 
/sw/etc/apt/sources.list.  So you can put Leo into any server and 
people can add it to their sources.list or you can talk to the people 
who run the default servers and get Leo hosted there (better).
#@-node:ekr.20040104162835.16:Getting Leo on Fink Commander
#@-node:ekr.20040104162835.8:Mac notes: Dan Winkler
#@+node:ekr.20031218072017.392:Python Notes...
#@+node:ekr.20031218072017.393:What's new for each version:
New in 2.2 (Do not use)

- Iterators/Generators
- Nested Scopes
- New Classes

The what's new for each version:

http://www.amk.ca/python/2.0/
http://www.amk.ca/python/2.1/
#@+node:ekr.20031218072017.394:@url http://www.python.org/2.3/highlights.html
#@-node:ekr.20031218072017.394:@url http://www.python.org/2.3/highlights.html
#@+node:ekr.20031218072017.395:@url http://www.amk.ca/python/2.1/
#@-node:ekr.20031218072017.395:@url http://www.amk.ca/python/2.1/
#@+node:ekr.20031218072017.396:@url http://www.amk.ca/python/2.0/
#@-node:ekr.20031218072017.396:@url http://www.amk.ca/python/2.0/
#@-node:ekr.20031218072017.393:What's new for each version:
#@+node:ekr.20031218072017.397:Default values & keyword arguments
@nocolor

1. You specify default values of _formal parameters_ in a def statement.

2. You specify keywords arguments in a _function call_.

3. An argument list must have any positional arguments followed by any keyword arguments, where the keywords must be chosen from the formal parameter names.  It's not important whether a formal parameter has a default value or not.

4. No argument may receive a value more than once.

5. When a final formal parameter of the form **name is present, it receives a dictionary containing all keyword arguments whose keyword doesn't correspond to a formal parameter.

EKR Notes:

1.  I have been confusing default values with keyword arguments.  _Any_ formal parameter may be specified with a keyword argument!

2.  Arbitrary keyword params can be used if the def has an **arg.
#@nonl
#@-node:ekr.20031218072017.397:Default values & keyword arguments
#@+node:ekr.20031218072017.398:How to call any Python method from the C API
In general, everything you can do in Python is accessible through the C API.

	lines = block.split('\n');
 
> That will be
 
	lines = PyObject_CallMethod(block, "split", "s", "\n");
#@-node:ekr.20031218072017.398:How to call any Python method from the C API
#@+node:ekr.20031218072017.399:How to run Python programs easily on NT,2K,XP
#@+node:ekr.20031218072017.400:setting the PATHEXT env var
It is worth noting that NT, Win2K and XP all have an alternative which is
to add .PY to the PATHEXT environment variable. Then you can run any .PY
file directly just by typing the name of the script without the extension. 

e.g.
C:\>set PATHEXT=.COM;.EXE;.BAT;.CMD

C:\>set PATH=%PATH%;c:\python22\tools\Scripts

C:\>google
'google' is not recognized as an internal or external command,
operable program or batch file.

C:\>set PATHEXT=.COM;.EXE;.BAT;.CMD;.PY

C:\>google
Usage: C:\python22\tools\Scripts\google.py querystring

C:\>
#@-node:ekr.20031218072017.400:setting the PATHEXT env var
#@+node:ekr.20031218072017.401:Yet another Python .bat wrapper
>> It has a header of just one line. All the ugly stuff is at the end.
>>
>> -------------------------------------------------------------------
>> goto ="python"
>>
>> # Python code goes here
>>
>> ''' hybrid python/batch footer:
>> @:="python"
>> @python.exe %0 %1 %2 %3 %4 %5 %6 %7 %8 %9
>> @if errorlevel 9009 echo Python may be downloaded from
>www.python.org/download
>> @rem '''
>> -------------------------------------------------------------------
>>
>>         Oren
>>
>

It's for running python scripts on windows, without having to type:

[<path to python>\]python[.exe] <scriptname> [<arguments>*]

and almost takes the place of the "shabang" line at the top of *nix
scripts.

#@-node:ekr.20031218072017.401:Yet another Python .bat wrapper
#@-node:ekr.20031218072017.399:How to run Python programs easily on NT,2K,XP
#@-node:ekr.20031218072017.392:Python Notes...
#@+node:ekr.20031218072017.434:Unused code
@ignore
@language python
@color
#@nonl
#@+node:ekr.20031218072017.2387:old_df.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20031218072017.2388:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = g.app.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.2388:<< Set ivars >>
#@+node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"" + theDir + "\" does not exist")
#@nonl
#@-node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20031218072017.2390:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and theDict.has_key("comment"):
    k = theDict["comment"]
    # 11/14/02: Similar to fix below.
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and theDict.has_key("language"):
    k = theDict["language"]
    # 11/14/02: Fix bug reported by J.M.Gilligan.
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.2390:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.2391:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20031218072017.2391:<< Test for @encoding >>
#@+node:ekr.20031218072017.2392:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20031218072017.2392:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.2393:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.2393:<< Test for @lineending >>
#@+node:ekr.20031218072017.2394:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: " + path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20031218072017.2395:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.2395:<< compute relative path from s[k:] >>
#@+node:ekr.20031218072017.2396:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: " + path)
#@-node:ekr.20031218072017.2396:<< handle absolute path >>
#@-node:ekr.20031218072017.2394:<< Test for @path >>
#@+node:ekr.20031218072017.2397:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.2397:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.2398:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20031218072017.2398:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.2399:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory() # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20031218072017.2399:<< Set current directory >>
#@+node:ekr.20031218072017.2400:<< Set comment strings from delims >>
if scripting:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end

if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20031218072017.2400:<< Set comment strings from delims >>
#@-node:ekr.20031218072017.2387:old_df.scanAllDirectives
#@+node:EKR.20040505090056:From perfect import script
@ignore
#@nonl
#@+node:EKR.20040505090056.1:class sentinel_squasher
class sentinel_squasher:
	"""
	The heart of the script.
	
	Creates files without sentinels from files with sentinels.
	
	Propagates changes in the files without sentinels back
	to the files with sentinels.
	
	"""

@others
#@nonl
#@+node:EKR.20040505090056.2:report_mismatch
# was check_lines_for_equality

def report_mismatch (self,lines1,lines2,message,lines1_message,lines2_message):

	"""
	Generate a report when something goes wrong.
	"""

	print '='*20
	print message
	
	if 0:
		print lines1_message
		print '-'*20
		for line in lines1:
		  print line,

		print '='*20
	
		print lines2_message
		print '-'*20
		for line in lines2:
			print line,
			
	print "length of files",len(lines1),len(lines2)
	
	if len(lines1) == len(lines2):
		i = 0
		while 1:
			if lines1[i] != lines2[i]:
				print "first mismatched lines:"
				print lines1[i]
				print lines2[i]
				break
			i += 1
#@nonl
#@-node:EKR.20040505090056.2:report_mismatch
#@+node:EKR.20040505090056.3:create_mapping
def create_mapping (self,lines,marker):
	"""

	'lines' is a list of lines of a file with sentinels.
 
	Returns:

	result: lines with all sentinels removed.

	mapping: a list such that result[mapping[i]] == lines[i]
	for all i in range(len(result))

	"""

	mapping = [] ; result = []
	for i in xrange(len(lines)):
		line = lines[i]
		if not is_sentinel(line,marker):
			result.append(line)
			mapping.append(i)

	# Create a last mapping entry for copy_sentinels.
	mapping.append(i)

	return result, mapping
#@nonl
#@-node:EKR.20040505090056.3:create_mapping
#@+node:EKR.20040505090056.4:old code
#@+node:EKR.20040505090056.5:OLDcopy_sentinels
@ Sentinels are NEVER deleted by this script.

If code is replaced, or deleted, then we must make sure that the sentinels are still in the Leo file.

We detect sentinel lines by checking for gaps in the mapping.
@c

def OLDcopy_sentinels (self,writer,leo_reader,mapping,startline,endline):
	"""
	
	Copy lines from leo_reader to writer if those lines contain sentinels.

	Copy all sentinels after the current reader postion up to,
	but not including, mapping[endline].

	"""

	j_last = mapping[startline]
	i = startline + 1
	while i <= endline:
		j = mapping[i]
		if j_last + 1 != j:
			leo_reader.sync(j_last + 1)
			# Copy the deleted sentinels that comprise the gap.
			while leo_reader.index() < j:
				line = leo_reader.get()
				if testing: print "Copy sentinels:", line,
				writer.push(line)
		j_last = j ; i += 1

	leo_reader.sync(mapping[endline])
#@nonl
#@-node:EKR.20040505090056.5:OLDcopy_sentinels
#@+node:EKR.20040505090056.6:OLDpull_source
def pull_source(self, sourcefile, targetfile):
	"""

	Propagate the changes of targetfile back to sourcefile.
	sourcefile has sentinels, and targetfile does not.

	This is the heart of the script.

	"""
	print testing
	if testing: g.trace(sourcefile,targetfile)
	<< init pull_source vars >>
	<< establish the loop invariant >>
	for tag, i1, i2, j1, j2 in matcher.get_opcodes():
		if testing:
			print ; print "opcode",tag,i1,i2,j1,j2 ; print
		<< update and check the loop invariant >>
		if tag == 'equal':
			<< handle 'equal' tag >>
		elif tag == 'replace':
			<< handle 'replace' tag >>
		elif tag == 'delete':
			<< handle 'delete' tag >>
		elif tag == 'insert':
			<< handle 'insert' tag >>
		else: assert 0
	<< copy the sentinels at the end of the file >>
	written = write_if_changed(writer.getlines(),targetfile,sourcefile)
	if written:
		<<final paranoia check>>
#@+node:EKR.20040505090056.7:<< init pull_source vars >>
marker = marker_from_extension(sourcefile) # The sentinel comment marker.
	
sourcelines = file(sourcefile).readlines() # Has sentinels.
targetlines = file(targetfile).readlines() # No sentinels.

strippedSourceLines,mapping = self.create_mapping(sourcelines,marker)

writer = sourcewriter() # Accumulates the new file.
i_reader = sourcereader(strippedSourceLines) # Unmodified file, no sentinels.
j_reader = sourcereader(targetlines) # Modified file, no sentinels.
leo_reader = sourcereader(sourcelines) # The file with sentinels.

matcher = difflib.SequenceMatcher(None,strippedSourceLines,targetlines)
#@nonl
#@-node:EKR.20040505090056.7:<< init pull_source vars >>
#@+node:EKR.20040505090056.8:<<establish the loop invariant>>
@ 
We compare the 'targetlines' with 'strippedSourceLines' and propagate the
changes back into 'writer' while making sure that all sentinels of 'sourcelines'
are copied as well.

The loop invariant is that all three readers are in sync. Also, writer has
accumulated the new file, which is going to replace leo_reader.
@c

# Check that all ranges returned by get_opcodes() are contiguous
i2_old = j2_old = -1

# Copy the sentinels at the beginning of the file.
while leo_reader.index() < mapping[0]:
	line = leo_reader.get()
	writer.push(line)
#@nonl
#@-node:EKR.20040505090056.8:<<establish the loop invariant>>
#@+node:EKR.20040505090056.9:<< update and check the loop invariant>>
# We need the ranges returned by get_opcodes to completely cover the source lines being compared.
# We also need the ranges not to overlap.
if i2_old != -1:
	assert i2_old == i1
	assert j2_old == j1
i2_old = i2 ; j2_old = j2

@ Loosely speaking, the loop invariant is that we have processed everything up to,
but not including, the lower bound of the ranges returned by the iterator.

We have to check the three readers, i_reader, j_reader, and leo_reader. For the
writer, the filter must reproduce the modified file up until, but not including,
j1. In addition, all the sentinels of the original Leo file, up until
mapping[i1], must be present in the new_source_file.

@code

# Check the loop invariant.
assert i_reader.i == i1
assert j_reader.i == j1
assert leo_reader.i == mapping[i1]
if testing: # A bit costly.
	t_sourcelines,t_sentinel_lines = push_filter_lines(writer.lines, marker)
	# Check that we have all the modifications so far.
	assert t_sourcelines == j_reader.lines[:j1]
	# Check that we kept all sentinels so far.
	assert t_sentinel_lines == push_filter_lines(leo_reader.lines[:leo_reader.i], marker)[1]
#@nonl
#@-node:EKR.20040505090056.9:<< update and check the loop invariant>>
#@+node:EKR.20040505090056.10:<< handle 'equal' tag >>
# nothing is to be done.  Leave the Leo file alone.
# Copy the lines from the leo file to the new sourcefile.
# This loop copies both text and sentinels.
while leo_reader.index() <= mapping[i2 - 1]:
	line = leo_reader.get()
	if 0:
		if testing: print "Equal: ", line,
	writer.push(line)

if testing:
	print "Equal: synch i", i_reader.i, i2
	print "Equal: synch j", j_reader.i, j2

i_reader.sync(i2)
j_reader.sync(j2)

# now we must copy the sentinels which might follow the lines which were equal.       
self.copy_sentinels(writer,leo_reader,mapping, i2 - 1, i2)
#@nonl
#@-node:EKR.20040505090056.10:<< handle 'equal' tag >>
#@+node:EKR.20040505090056.11:<< handle 'replace' tag >>
@ Replace lines that may span sentinels.

For now, we put all the new contents after the first sentinels.

A more complex approach: run the difflib across the different lines and try to
construct a mapping changed line => orignal line.
@c

while j_reader.index() < j2:
	line = j_reader.get()
	if testing: print "Replace:", line,
	writer.push(line)

# Copy the sentinels which might be between the changed code.         
self.copy_sentinels(writer,leo_reader,mapping,i1,i2)
i_reader.sync(i2)
#@nonl
#@-node:EKR.20040505090056.11:<< handle 'replace' tag >>
#@+node:EKR.20040505090056.12:<< handle 'delete' tag >>
# We have to delete lines.
# However, we NEVER delete sentinels, so they must be copied over.

if testing:
	print "Delete: synch i", i_reader.i, i1
	print "Delete: synch j", j_reader.i, j1
	
# sync the readers
j_reader.sync(j2)
i_reader.sync(i2)

self.copy_sentinels(writer, leo_reader, mapping, i1, i2)
#@nonl
#@-node:EKR.20040505090056.12:<< handle 'delete' tag >>
#@+node:EKR.20040505090056.13:<< handle 'insert' tag >>
while j_reader.index() < j2:
	line = j_reader.get()
	if testing: print "insert: ", line,
	writer.push(line)

# Since (only) lines are inserted, we do not have to reposition any reader.
#@nonl
#@-node:EKR.20040505090056.13:<< handle 'insert' tag >>
#@+node:EKR.20040505090056.14:<< copy the sentinels at the end of the file >>
while leo_reader.index() < leo_reader.size():
	line = leo_reader.get()
	writer.push(line)
	if testing: print "Copy last line",line
#@nonl
#@-node:EKR.20040505090056.14:<< copy the sentinels at the end of the file >>
#@+node:EKR.20040505090056.15:<<final paranoia check>>
@ For the initial usage, we check that the output actually makes sense.
	We check two things:
	1. Applying a 'push' operation will produce the modified file.
	2. Our new sourcefile still has the same sentinels as the replaced one.
@c

s_outlines,sentinel_lines = push_filter(sourcefile)

# Check that 'push' will re-create the changed file.
if s_outlines != targetlines:
	self.report_mismatch(s_outlines, targetlines,
		"Pull did not work as expected",
		"Content of sourcefile:",
		"Content of modified file:")

# Check that no sentinels got lost.
old_sentinel_lines = push_filter_lines(leo_reader.lines[:leo_reader.i], marker)[1]
if sentinel_lines != old_sentinel_lines:
	self.report_mismatch(sentinel_lines, old_sentinel_lines,
		"Pull modified sentinel lines:",
		"Current sentinel lines:",
		"Old sentinel lines:")
#@nonl
#@-node:EKR.20040505090056.15:<<final paranoia check>>
#@-node:EKR.20040505090056.6:OLDpull_source
#@-node:EKR.20040505090056.4:old code
#@+node:EKR.20040505090056.16:pull_source
def pull_source(self,sourcefile,targetfile):
	"""

	Propagate the changes of targetfile back to sourcefile.
	sourcefile has sentinels, and targetfile does not.

	"""
	if testing: g.trace(sourcefile,targetfile)
	<< init pull_source vars >>
	<< establish the loop invariant >>
	for tag, i1, i2, j1, j2 in matcher.get_opcodes():
		if testing:
			print ; print "Opcode",tag,i1,i2,j1,j2 ; print
		<< update and check the loop invariant >>
		if tag == 'equal':
			<< handle 'equal' tag >>
		elif tag == 'replace':
			<< handle 'replace' tag >>
		elif tag == 'delete':
			<< handle 'delete' tag >>
		elif tag == 'insert':
			<< handle 'insert' tag >>
		else: assert 0,"bad tag"
	<< copy the sentinels at the end of the file >>
	written = write_if_changed(write_lines,targetfile,sourcefile)
	if written:
		<<final paranoia check>>
#@+node:EKR.20040505090056.17:<< init pull_source vars >>
marker = marker_from_extension(sourcefile) # The sentinel comment marker.

sourceLines = file(sourcefile).readlines() # Has sentinels.
targetLines = file(targetfile).readlines() # No sentinels.
strippedSourceLines,mapping = self.create_mapping(sourceLines,marker)

write_lines = []
i_lines = strippedSourceLines
j_lines = targetLines
fat_lines = sourceLines
i_pos = j_pos = fat_pos = 0

matcher = difflib.SequenceMatcher(None,strippedSourceLines,targetLines)
#@nonl
#@-node:EKR.20040505090056.17:<< init pull_source vars >>
#@+node:EKR.20040505090056.18:<<establish the loop invariant>>
@
We compare the 'targetLines' with 'strippedSourceLines' and propagate the
changes back into 'write_lines' while making sure that all sentinels of 'sourceLines'
are copied as well.
@c

# Check that all ranges returned by get_opcodes() are contiguous
i2_old = j2_old = -1

# Copy the sentinels at the beginning of the file.
while fat_pos < mapping[0]:
	line = fat_lines[fat_pos]
	write_lines.append(line)
	if testing: print "copy initial line",fat_pos,line
	fat_pos += 1
#@nonl
#@-node:EKR.20040505090056.18:<<establish the loop invariant>>
#@+node:EKR.20040505090056.19:<< update and check the loop invariant>>
# We need the ranges returned by get_opcodes to completely cover the source lines being compared.
# We also need the ranges not to overlap.
if i2_old != -1:
	assert i2_old == i1,"i2_old==i1"
	assert j2_old == j1,"j2_old==j1"

i2_old = i2 ; j2_old = j2

# Check the loop invariants.
assert i_pos == i1,"i_pos==i1"
assert j_pos == j1,"j_pos==j1"
assert fat_pos == mapping[i1],"fat_pos == mapping[i1]"

if 0: # not yet.
	if testing: # A bit costly.
		t_sourcelines,t_sentinel_lines = push_filter_lines(write_lines, marker)
		# Check that we have all the modifications so far.
		assert t_sourcelines == j_lines[:j1],"t_sourcelines == j_lines[:j1]"
		# Check that we kept all sentinels so far.
		assert t_sentinel_lines == push_filter_lines(fat_lines[:fat_pos], marker)[1]
#@nonl
#@-node:EKR.20040505090056.19:<< update and check the loop invariant>>
#@+node:EKR.20040505090056.20:<< handle 'equal' tag >>
# nothing is to be done.  Leave the Leo file alone.
# Copy the lines from the leo file to the new sourcefile.
# This loop copies both text and sentinels.

# while leo_reader.index() <= mapping[i2 - 1]:
while fat_pos <= mapping[i2-1]:
	line = fat_lines[fat_pos]
	if 0:
		if testing: print "Equal: copying ", line,
	write_lines.append(line) # writer.push(line)
	fat_pos += 1

if testing:
	print "Equal: synch i", i_pos,i2
	print "Equal: synch j", j_pos,j2

i_pos = i2
j_pos = j2

# Copy the sentinels which might follow the lines.       
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i2-1,i2)
#@nonl
#@-node:EKR.20040505090056.20:<< handle 'equal' tag >>
#@+node:EKR.20040505090056.21:<< handle 'replace' tag >>
@ Replace lines that may span sentinels.

For now, we put all the new contents after the first sentinels.

A more complex approach: run the difflib across the different lines and try to
construct a mapping changed line => orignal line.
@c

while j_pos < j2:
	line = j_lines[j_pos]
	if testing: print "Replace:", line,
	write_lines.append(line)
	j_pos += 1

# Copy the sentinels which might be between the changed code.         
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)
i_pos = i2
#@nonl
#@-node:EKR.20040505090056.21:<< handle 'replace' tag >>
#@+node:EKR.20040505090056.22:<< handle 'delete' tag >>
if testing:
	print "delete: i",i_pos,i1
	print "delete: j",j_pos,j1
	
# Synch the import streams.
j_pos = j2 
i_pos = i2

# Restore any deleted sentinels.
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)
#@nonl
#@-node:EKR.20040505090056.22:<< handle 'delete' tag >>
#@+node:EKR.20040505090056.23:<< handle 'insert' tag >>
while j_pos < j2:
	line = j_lines[j_pos]
	if testing: print "Insert:", line,
	write_lines.append(line)
	j_pos += 1

# We do not have to reposition any input stream.
#@nonl
#@-node:EKR.20040505090056.23:<< handle 'insert' tag >>
#@+node:EKR.20040505090056.24:<< copy the sentinels at the end of the file >>
while fat_pos < len(fat_lines):
	line = fat_lines[fat_pos]
	write_lines.append(line)
	if testing: print "appending last line",line
	fat_pos += 1
#@nonl
#@-node:EKR.20040505090056.24:<< copy the sentinels at the end of the file >>
#@+node:EKR.20040505090056.25:<<final paranoia check>>
# Check that 'push' will re-create the changed file.
strippedLines,sentinel_lines = push_filter(sourcefile)

if strippedLines != targetLines:
	self.report_mismatch(strippedLines, targetLines,
		"Pull did not work as expected",
		"Content of sourcefile:",
		"Content of modified file:")

# Check that no sentinels got lost.
old_strippedLines,old_sentinel_lines = push_filter_lines(sourceLines, marker)

if sentinel_lines != old_sentinel_lines:
	self.report_mismatch(sentinel_lines, old_sentinel_lines,
		"Pull modified sentinel lines:",
		"Current sentinel lines:",
		"Old sentinel lines:")
#@nonl
#@-node:EKR.20040505090056.25:<<final paranoia check>>
#@-node:EKR.20040505090056.16:pull_source
#@+node:EKR.20040505090056.26:copy_sentinels
@ This script retains _all_ sentinels in the fat file.  If lines are replaced, or deleted,
we restore deleted sentinel lines by checking for gaps in the mapping.
@c

def copy_sentinels (self,write_lines,fat_lines,fat_pos,mapping,startline,endline):
	"""
	
	Copy sentinel lines from fat_lines to write_lines.

	Copy all sentinels _after_ the current reader postion up to,
	but not including, mapping[endline].

	"""

	j_last = mapping[startline]
	i = startline + 1
	while i <= endline:
		j = mapping[i]
		if j_last + 1 != j:
			fat_pos = j_last + 1
			# Copy the deleted sentinels that comprise the gap.
			while fat_pos < j:
				line = fat_lines[fat_pos]
				write_lines.append(line)
				if testing: print "Copy sentinels:",fat_pos,line,
				fat_pos += 1
		j_last = j ; i += 1

	fat_pos = mapping[endline]
	return fat_pos
#@nonl
#@-node:EKR.20040505090056.26:copy_sentinels
#@-node:EKR.20040505090056.1:class sentinel_squasher
#@+node:EKR.20040505090056.27:class sourcereader
class sourcereader:
	"""
	A simple class to read lines sequentially.
	
	The class keeps an internal index, so that each
	call to get returns the next line.
	
	Index returns the internal index, and sync
	advances the index to the the desired line.
	
	The index is the *next* line to be returned.
	
	The line numbering starts from 0.
	
	"""

@others
#@+node:EKR.20040505090056.28:__init__
def __init__(self, lines):
	self.lines = lines
	self.length = len(self.lines)
	self.i = 0
#@-node:EKR.20040505090056.28:__init__
#@+node:EKR.20040505090056.29:index
def index(self):
	return self.i
#@-node:EKR.20040505090056.29:index
#@+node:EKR.20040505090056.30:get
def get(self):
	result = self.lines[self.i]
	self.i += 1
	return result
#@nonl
#@-node:EKR.20040505090056.30:get
#@+node:EKR.20040505090056.31:sync
def sync(self, i):
	self.i = i
#@-node:EKR.20040505090056.31:sync
#@+node:EKR.20040505090056.32:size
def size(self):
	return self.length
#@-node:EKR.20040505090056.32:size
#@+node:EKR.20040505090056.33:atEnd
def atEnd(self):
	return self.index >= self.length
#@nonl
#@-node:EKR.20040505090056.33:atEnd
#@-node:EKR.20040505090056.27:class sourcereader
#@+node:EKR.20040505090056.34:class sourcewriter
class sourcewriter:
	
	"""
	Convenience class to capture output to a file.
	"""

@others


#@+node:EKR.20040505090056.35:__init__
def __init__(self):
	self.i = 0
	self.lines = []
#@-node:EKR.20040505090056.35:__init__
#@+node:EKR.20040505090056.36:push
def push(self, line):
	self.lines.append(line)
	self.i += 1
#@-node:EKR.20040505090056.36:push
#@+node:EKR.20040505090056.37:index
def index(self):
	return self.i
#@-node:EKR.20040505090056.37:index
#@+node:EKR.20040505090056.38:getlines
def getlines(self):
	return self.lines
#@-node:EKR.20040505090056.38:getlines
#@-node:EKR.20040505090056.34:class sourcewriter
#@+node:EKR.20040505090056.39:copy_time
def copy_time(sourcefilename, targetfilename):
	
	"""
	Set the modification time of target file to the
	modification time of sourcefile.
	"""

	st = os.stat(sourcefilename)

	if hasattr(os, 'utime'):
		os.utime(targetfilename, (st.st_atime, st.st_mtime))
	elif hasattr(os, 'mtime'):
		os.mtime(targetfilename, st.st_mtime)
	else:
		print "copy_time can not set file modification time."
#@nonl
#@-node:EKR.20040505090056.39:copy_time
#@+node:EKR.20040505090056.40:create_ext
def create_ext(extensions=('.py', '.c', '.cpp', '.h', '.bat'), directory=".", sourcedir=None):
	"""
	Convenience script: calls create_leo_subdirectory for all files in 'directory' with an extension in 'extensions'.
	
	NOTE THAT IF BOTH A DIRECTORY AND A SOURCEDIR ARE SPECIFIED, THIS SCRIPT WILL DELETE THE WHOLE DIRECTORY 'directory'.
	
	"""
	if sourcedir:
		# For quick testing, we make a copy of a directory.
		if os.path.exists(directory):
			shutil.rmtree(directory)
		shutil.copytree(sourcedir, directory)

		# Not sure if this is necessary, but let's delete all .pyc files
		map(os.unlink, [os.path.join(root, filename) 
			for root, dirs, files in os.walk(directory) 
				for filename in files if os.path.splitext(filename)[1] == '.pyc'])
				
	files = [f for f in os.listdir(directory) if os.path.splitext(f)[1] in extensions]
	create_leo_subdirectory (files, directory)
#@nonl
#@-node:EKR.20040505090056.40:create_ext
#@+node:EKR.20040505090056.41:create_leo_subdirectory
def create_leo_subdirectory(files, directory="."):
	"""
	Moves 'files' into a Leo subdirectory.
	
	'files' are replaced with files without sentinels.
	
	files is the list of files which should be shuffled to the subdirectory.
	
	- Checks if a Leo subdirectory exists. If yes, does nothing.
	
	- Moves the files to the Leo subdirectory.
	
	- Creates files without sentinels in the original directory.
	"""
	from os.path import exists, join, split, splitext
	assert exists(directory)
	targetfiles = [join(directory,element) for element in files]
	missing_files = [filename for filename in targetfiles if not exists(filename)]
	assert len(missing_files) == 0,"Files do not exist:%s" % missing_files
		
	leo_directory = join(directory, "Leo")
	if exists(leo_directory):
		print "Directory already exists. Exit"
		return
	os.mkdir(leo_directory)
		
	pairs = [split(filename) for filename in targetfiles]
	sourcefiles = [join(dir, 'Leo', name) for dir, name in pairs]
	full_filenames = zip(sourcefiles, targetfiles)
	for targetfile, sourcefile in full_filenames: os.rename(sourcefile, targetfile)
	push(full_filenames) 
#@-node:EKR.20040505090056.41:create_leo_subdirectory
#@+node:EKR.20040505090056.42:is_sentinel
def is_sentinel(line, marker):
	"""
	Check if line starts with a Leo marker.
	
	Leo markers are filtered away by this script.
	
	Leo markers start with a comment character, which dependends
	on the language used. That's why the marker is passed in.
	"""
	return line.lstrip().startswith(marker)
#@nonl
#@-node:EKR.20040505090056.42:is_sentinel
#@+node:EKR.20040505090056.43:marker_from_extension
def marker_from_extension(filename):
	"""
	Tries to guess the sentinel leadin
	comment from the filename extension.
	
	This code should probably be shared
	with the main Leo code.
	"""
	root, ext = os.path.splitext(filename)
	if ext == '.tmp':
		root, ext = os.path.splitext(root)
	if ext in ('.h', '.c'):
		marker = "//@"
	elif ext in (".py", ".cfg", ".bat", ".ksh"):
		marker = "#@"
	else:
		assert 0, "extension %s not handled by this plugin" % ext
	return marker
#@nonl
#@-node:EKR.20040505090056.43:marker_from_extension
#@+node:EKR.20040505090056.44:push_file
def push_file(sourcefilename, targetfilename):
	
	outlines, sentinel_lines = push_filter(sourcefilename)
	write_if_changed(outlines, sourcefilename, targetfilename)
#@nonl
#@-node:EKR.20040505090056.44:push_file
#@+node:EKR.20040505090056.45:push_filter
def push_filter(sourcefilename):
	"""
	
	Removes sentinels from the lines of 'sourcefilename'.
	
	"""

	return push_filter_lines(
		file(sourcefilename).readlines(),
		marker_from_extension(sourcefilename))
#@-node:EKR.20040505090056.45:push_filter
#@+node:EKR.20040505090056.46:push_filter_lines
def push_filter_lines(lines, marker):
	"""
	
	Removes sentinels from lines.
	
	"""

	result = [] ; sentinel_lines = []
	for line in lines:
		if is_sentinel(line, marker):
			sentinel_lines.append(line)
		else:
			result.append(line)

	return result, sentinel_lines
#@nonl
#@-node:EKR.20040505090056.46:push_filter_lines
#@+node:EKR.20040505090056.47:write_if_changed
def write_if_changed(lines, sourcefilename, targetfilename):
	"""
	
	Replaces target file if it is not the same as 'lines',
	and makes the modification date of target file the same as the source file.
	
	Optionally backs up the overwritten file.

	"""
	
	copy = not os.path.exists(targetfilename) or lines != file(targetfilename).readlines()
		
	if testing:
		if copy:
			print "Copying", sourcefilename, "to", targetfilename, "without sentinals"
		else:
			print "files are identical"

	if copy:
		if do_backups:
			<< make backup file >>
		outfile = open(targetfilename, "w")
		for line in lines:
			outfile.write(line)
		outfile.close()
		copy_time(sourcefilename,targetfilename)
	return copy
#@+node:EKR.20040505090056.48:<< make backup file >>
# Keep the old file around while we are debugging this script
if os.path.exists(targetfilename):
	count = 0
	backupname = "%s.~%s~" % (targetfilename, count)
	while os.path.exists(backupname):
		count += 1
		backupname = "%s.~%s~" % (targetfilename, count)
	os.rename(targetfilename, backupname)
	if testing:
		print "backup file in ", backupname
#@nonl
#@-node:EKR.20040505090056.48:<< make backup file >>
#@-node:EKR.20040505090056.47:write_if_changed
#@-node:EKR.20040505090056:From perfect import script
#@+node:ekr.20040301201418:c.convertTreeToSharedNodes (for conversion)
# WARNING: this only works if not g.sharedNodes.

def convertTreeToSharedNodes(self):

	c = self
	
	# Return if the tree has already been converted.
	v = c.rootVnode()
	while v:
		if v._firstChild and not v._firstChild._parent:
			# print ; print "already converted"
			return
		v = v.threadNext()

	# Init.
	v = c.rootVnode()
	while v:
		v.t.vnodeList = []
		v = v.threadNext()
		
	# Create a list of cloned nodes:
	v = c.rootVnode() ; cloneList = []
	while v:
		if v.isCloned():
			# print "clone",v
			cloneList.append(v)
		v = v.threadNext()

	# Set _firstChild in tnodes.
	v = c.rootVnode()
	while v:
		child = v.firstChild()
		# Careful: set the field only the first time we see a shared tree.
		# This logic must match the logic below.
		if child:
			if not hasattr(v.t,"_firstChild"):
				v.t._firstChild = child
		else: v.t._firstChild = None
		v = v.threadNext()
		
	v = c.rootVnode()
	while v:
		if child and not hasattr(v.t,"_firstChild"):
			v.t._firstChild = child
		v = v.threadNext()
		
	# Set v.t.vnodeList.
	v = c.rootVnode()
	while v:
		# Careful: only set one value for non-cloned joined nodes.
		if v in cloneList: # Cloned
			try:    v.t.vnodeList.append(v)
			except: v.t.vnodeList = [v]
		elif not hasattr(v.t,"vnodeList"): # Maybe joined.
			v.t.vnodeList = [v]
		v = v.threadNext()
		
	# Clear _parent field of any node whose parent is a clone.
	v = c.rootVnode() ; clearList = []
	for v in cloneList:
		child = v.firstChild()
		while child:
			clearList.append(child)
			child = child.next()

	for v in clearList:
		v._parent = None
#@nonl
#@-node:ekr.20040301201418:c.convertTreeToSharedNodes (for conversion)
#@+node:ekr.20041228094801:Config...
#@+node:ekr.20041118184748:Unused old config stuff
#@+node:ekr.20041115110846.4:Apply Config command
#@+node:ekr.20031218072017.3774:<< define help menu tables >>
self.helpMenuTopTable = (
    ("&About Leo...",None,c.about),
    ("Online &Home Page",None,c.leoHome),
    ("-",None,None),
    ("Open Online &Tutorial",None,c.leoTutorial),
)
    
self.helpMenuTop2Table = (
    ("Open &Offline Tutorial",None,f.leoHelp),
)
    
self.helpMenuTop3Table = (
    ("Open Leo&Docs.leo",None,c.leoDocumentation),
    ("-",None,None),
    ("Open Leo&Config.leo",None,c.leoConfig),
    # ("Apply &Settings",None,c.applyConfig),
)
#@nonl
#@-node:ekr.20031218072017.3774:<< define help menu tables >>
#@+node:ekr.20031218072017.2944:applyConfig
def applyConfig (self):

    c = self
    g.app.config.init()
    c.frame.reconfigureFromConfig()
#@nonl
#@-node:ekr.20031218072017.2944:applyConfig
#@-node:ekr.20041115110846.4:Apply Config command
#@+node:ekr.20041118184544:From leoFileCommands
#@+node:ekr.20031218072017.3036:<< put find settings that may exist in leoConfig.txt >> (putFindSettings)
c = self.c

if g.app.config.configsExist and not c.config.read_only:
    pass # config.update has already been called.
else:
    self.put_flag(c.batch_flag,"batch")
    self.put_flag(c.ignore_case_flag,"ignore_case")
    self.put_flag(c.mark_changes_flag,"mark_changes")
    self.put_flag(c.mark_finds_flag,"mark_finds")
    self.put_flag(c.pattern_match_flag,"pattern_match")
    self.put_flag(c.reverse_flag,"reverse")
    self.put_flag(c.search_headline_flag,"search_headline")
    self.put_flag(c.search_body_flag,"search_body")
    self.put_flag(c.suboutline_only_flag,"suboutline_only")
    self.put_flag(c.whole_word_flag,"whole_word")
    self.put_flag(c.wrap_flag,"wrap")
    self.put_flag(c.node_only_flag,"node_only")

self.put(">") ; self.put_nl()

if g.app.config.configsExist and not c.config.read_only: # 8/6/02
    self.put_tab()
    self.put("<find_string></find_string>") ; self.put_nl()
else:
    self.put_tab()
    self.put("<find_string>") ; self.putEscapedString(c.find_text)
    self.put("</find_string>") ; self.put_nl()

if g.app.config.configsExist and not c.config.read_only: # 8/6/02
    self.put_tab()
    self.put("<change_string></change_string>") ; self.put_nl()
else:
    self.put_tab()
    self.put("<change_string>") ; self.putEscapedString(c.change_text)
    self.put("</change_string>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.3036:<< put find settings that may exist in leoConfig.txt >> (putFindSettings)
#@+node:ekr.20031218072017.2067:<< put prefs that may exist in leoConfig.txt >> (putPrefs)
c = self.c
language = c.target_language
for name in xml_language_names:
    s = string.lower(name)
    s = string.replace(s,"/","")
    if s == language:
        language = name ; break

if g.app.config.configsExist and not c.config.read_only: # 8/6/02
    pass # config.update has already been called.
else:
    self.put(" defaultTargetLanguage=") ; self.put_in_dquotes(language)
    self.put(" node_only=") ; self.put_dquoted_bool(c.node_only_flag)
    self.put(" output_doc_chunks=") ; self.put_dquoted_bool(c.output_doc_flag)
    self.put(" page_width=") ; self.put_in_dquotes(str(c.page_width))
    self.put(" tab_width=") ; self.put_in_dquotes(str(c.tab_width))
    self.put(" tangle_bat=") ; self.put_dquoted_bool(c.tangle_batch_flag)
    self.put(" untangle_bat=") ; self.put_dquoted_bool(c.untangle_batch_flag)
    self.put(" use_header_flag=") ; self.put_dquoted_bool(c.use_header_flag)

self.put(">") ; self.put_nl()
# New in version 0.16
<< put default directory >>
#@nonl
#@+node:ekr.20031218072017.2068:<< put default directory >>
if g.app.config.configsExist:
    pass # Has been done earlier.
elif len(c.tangle_directory) > 0:
    self.put_tab()
    self.put("<defaultDirectory>")
    self.putEscapedString(c.tangle_directory)
    self.put("</defaultDirectory>")
    self.put_nl()
#@nonl
#@-node:ekr.20031218072017.2068:<< put default directory >>
#@-node:ekr.20031218072017.2067:<< put prefs that may exist in leoConfig.txt >> (putPrefs)
#@-node:ekr.20041118184544:From leoFileCommands
#@+node:ekr.20041117062717.27:update (config)
# Before 4.3: called when writing .leo file.  This had various unpleasant consequences.
# After  4.3: called immediately when a setting changes, and never when writing .leo files.

def update (self,verbose=False):
    
    g.trace()
    """Write the entire config file from ivars."""
    # Do nothing if the file does not exist, or if read_only.
    if self.read_only:
        if verbose:
            g.es("Read only config file",color="blue")
        return
    if not g.os_path_exists(self.configFileName):
        if verbose:
            g.es("No config file",color="blue")
        return
    
    config = ConfigParser.ConfigParser()
    self.config = config
    try:
        # 9/1/02: apparently Linux requires w+ and XP requires w.
        mode = g.choose(sys.platform=="win32","wb","wb+")
        cf = open(self.configFileName,mode)
        config.readfp(cf)
        << write recent files section >>
        for section,dict in self.sectionInfo:
            if dict:
                self.update_section(config,section,dict)
        config.write(cf)
        cf.flush()
        cf.close()
    except:
        g.es("exception writing: " + self.configFileName)
        g.es_exception()
    self.config = None
#@nonl
#@+node:ekr.20041117062717.28:<< write recent files section >>
section = self.recentFilesSection
files = self.recentFiles

section = g.toEncodedString(section,"utf-8") # 10/31/03

if config.has_section(section):
    config.remove_section(section)
config.add_section(section)

if 0: # elegant, but may be a security hole.
    config.set(section,"recentFiles",files)
else: # easier to read in the config file.
    for i in xrange(len(files)):
        f = g.toEncodedString(files[i],self.config_encoding) # 10/31/03
        config.set(section, "file"+str(i), f)
#@nonl
#@-node:ekr.20041117062717.28:<< write recent files section >>
#@-node:ekr.20041117062717.27:update (config)
#@+node:ekr.20041117062717.29:update_section
def update_section (self,config,section,dict):
    
    section = g.toEncodedString(section,self.config_encoding) # 10/31/03

    if config.has_section(section):
        config.remove_section(section)
    config.add_section(section)
    
    keys = dict.keys()
    keys.sort() # Not effective.
    for name in keys:
        val = dict [name]
        val  = g.toEncodedString(val,self.config_encoding)
        name = g.toEncodedString(name,self.config_encoding) # 10/31/03
        config.set(section,name,val)
#@nonl
#@-node:ekr.20041117062717.29:update_section
#@+node:ekr.20041117062717.25:<< convert find/change options to unicode >>
find = self.findDict.get("find_string")
if find:
    # Leo always writes utf-8 encoding, but users may not.
    find = g.toUnicode(find,"utf-8")
    self.findDict["find_string"] = find

change = self.findDict.get("change_string")
if change:
    # Leo always writes utf-8 encoding, but users may not.
    change = g.toUnicode(change,"utf-8")
    self.findDict["change_string"] = change
#@nonl
#@-node:ekr.20041117062717.25:<< convert find/change options to unicode >>
#@+node:ekr.20040324080819:<< update leoConfig.txt >>
if 0: # Not done in 4.3.
    c.setIvarsFromFind()
    c.config.setConfigFindIvars(c)
    c.setIvarsFromPrefs()
    c.config.setCommandsIvars(c)
    c.config.update()
#@nonl
#@-node:ekr.20040324080819:<< update leoConfig.txt >>
#@-node:ekr.20041118184748:Unused old config stuff
#@+node:ekr.20041121111018:Unused (find initing)
#@+node:ekr.20031218072017.2815:c.setIvarsFromFind (sets c ivars from widgets)
# This should be called whenever we need to use find values:
# i.e., before reading or writing

def setIvarsFromFind (self):
    
    c = self

    if c.findFrame:
        c.findFrame.set_ivars(c)
#@nonl
#@-node:ekr.20031218072017.2815:c.setIvarsFromFind (sets c ivars from widgets)
#@+node:ekr.20041118195812.1:configSettings.setCommandsFindIvars
def setCommandsFindIvars(self):
    
    return g.app.config.setCommandsFindIvars(self.c)
#@nonl
#@-node:ekr.20041118195812.1:configSettings.setCommandsFindIvars
#@+node:ekr.20041117062717.16:config.setCommandsFindIvars
def setCommandsFindIvars (self,c):
    
    """Set c.name_flag for each name in findFrame.intKeys."""
    
    if g.app.gui.guiName() != "tkinter":
        return

    findFrame = c.findFrame
    if not findFrame: return
    
    g.trace(c)

    for s in findFrame.intKeys:
        val = self.getBool(c,s)
        if val != None:
            setattr(c,s+"_flag",val)
            # g.trace(s+"_flag",val)

    for name in ("change_string","find_string"):
        val = self.getString(c,name)
        if val:
            settattr(c,name,val)

    g.app.findFrame.init(c)
#@nonl
#@-node:ekr.20041117062717.16:config.setCommandsFindIvars
#@+node:ekr.20041117062717.19:configSettings.etConfigFindIvars
def setConfigFindIvars (self):
    
    """Set the config ivars from the commander."""
    
    c = self.c

    # N.B.: separate c.ivars are much more convenient than a dict.
    for s in c.findFrame.intKeys: # These _are_ gui-independent.
        val = getattr(c,s+"_flag")
        g.app.config.setPref(s,val)
        # g.trace(s,val)
    
    g.app.config.setPref("change_string",c.change_text)
    g.app.config.setPref("find_string",c.find_text)
#@nonl
#@-node:ekr.20041117062717.19:configSettings.etConfigFindIvars
#@+node:ekr.20031218072017.4050:tkGui.createGlobalWindows
def createGlobalWindows (self):
    
    """Create the global windows for the application."""
    
    if 0:
        g.app.findFrame = g.app.gui.createFindPanel()
        g.app.globalWindows.append(g.app.findFrame)
#@nonl
#@-node:ekr.20031218072017.4050:tkGui.createGlobalWindows
#@-node:ekr.20041121111018:Unused (find initing)
#@+node:ekr.20041225063637.61:updateComments
def updateComments (self,p):
    
    # No longer needed now that we put the comments in the canvas.

    if self.commentWidget:
        self.commentWidget.clear()
        
        if not p or p == self.suppressComments:
            comments = ''
        elif p == self.alterComments:
            comments = self.alteredCommentsString
        else:
            comments = p.bodyString()
        
        self.commentWidget.setvalue(comments)
    
    self.suppressComments = None
    self.alterComments = None
#@nonl
#@-node:ekr.20041225063637.61:updateComments
#@+node:ekr.20041117062717.20:c.setConfigIvars  (Not used: Called only from prefs code)
# Sets config ivars from c.
def setConfigIvars (self):
    
    c = self.c
    config = g.app.config
    
    g.trace()
    
    if c.target_language and g.app.language_delims_dict.get(c.target_language):
        language = c.target_language
    else:
        language = "plain"

    self.setPref("default_tangle_directory",c.tangle_directory)
    self.setPref("default_target_language",language)
    self.setPref("output_doc_chunks",str(c.output_doc_flag))
    self.setPref("page_width",str(c.page_width))
    self.setPref("run_tangle_done.py",str(c.tangle_batch_flag))
    self.setPref("run_untangle_done.py",str(c.untangle_batch_flag))
    self.setPref("tab_width",str(c.tab_width))
    self.setPref("tangle_outputs_header",str(c.use_header_flag))
    
    self.setPref("batch",str(c.batch_flag))
    self.setPref("ignore_case",str(c.ignore_case_flag))
    self.setPref("mark_changes",str(c.mark_changes_flag))
    self.setPref("mark_finds",str(c.mark_finds_flag))
    self.setPref("pattern_match",str(c.pattern_match_flag))
    self.setPref("reverse",str(c.reverse_flag))
    self.setPref("script_change",str(c.script_change_flag))
    self.setPref("script_search",str(c.script_search_flag))
    self.setPref("search_body",str(c.search_body_flag))
    self.setPref("search_headline",str(c.search_headline_flag))
    self.setPref("selection_only",str(c.selection_only_flag))
    self.setPref("suboutline_only",str(c.suboutline_only_flag))
    self.setPref("wrap",str(c.wrap_flag))
    self.setPref("whole_word",str(c.whole_word_flag))
    
    self.setPref("change_string",c.change_text)
    self.setPref("find_string",c.find_text)
#@nonl
#@-node:ekr.20041117062717.20:c.setConfigIvars  (Not used: Called only from prefs code)
#@-node:ekr.20041228094801:Config...
#@+node:ekr.20050104131343.1:From replaceTargetFileIfDifferent
#@+node:ekr.20041005105605.213:<< delete the output file >>
try: # Just delete the temp file.
    os.remove(self.outputFileName)
except:
    g.es("exception deleting:" + self.outputFileName)
    g.es_exception()
#@nonl
#@-node:ekr.20041005105605.213:<< delete the output file >>
#@+node:ekr.20041005105605.214:<< replace the target file with the output file >>
try:
    # 10/6/02: retain the access mode of the previous file,
    # removing any setuid, setgid, and sticky bits.
    mode = (os.stat(self.targetFileName))[0] & 0777
except:
    mode = None

try: # Replace target file with temp file.
    os.remove(self.targetFileName)
    try:
        g.utils_rename(self.outputFileName,self.targetFileName)
        if mode != None: # 10/3/02: retain the access mode of the previous file.
            try:
                os.chmod(self.targetFileName,mode)
            except:
                g.es("exception in os.chmod(%s)" % (self.targetFileName))
        g.es("writing: " + self.shortFileName)
        self.fileChangedFlag = True
    except:
        # 6/28/03
        self.writeError("exception renaming: %s to: %s" % (self.outputFileName,self.targetFileName))
        g.es_exception()
except:
    self.writeError("exception removing:" + self.targetFileName)
    g.es_exception()
    try: # Delete the temp file when the deleting the target file fails.
        os.remove(self.outputFileName)
    except:
        g.es("exception deleting:" + self.outputFileName)
        g.es_exception()
#@nonl
#@-node:ekr.20041005105605.214:<< replace the target file with the output file >>
#@+node:ekr.20041005105605.215:<< rename the output file to be the target file >>
try:
    g.utils_rename(self.outputFileName,self.targetFileName)
    g.es("creating: " + self.targetFileName)
    self.fileChangedFlag = True
except:
    self.writeError("exception renaming:" + self.outputFileName +
        " to " + self.targetFileName)
    g.es_exception()
#@nonl
#@-node:ekr.20041005105605.215:<< rename the output file to be the target file >>
#@+node:ekr.20050104131343.2:<< files differ only in line endings >>
self.explicitLineEnding and
self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    ignoreLineEndings=True)
#@nonl
#@-node:ekr.20050104131343.2:<< files differ only in line endings >>
#@+node:ekr.20050104131929.3:<< old code >>
if 1: # Use rename in all cases.
    os.rename(src,dst)
else:
    # This isn't a great solution: distutils.file_util may not exist.
    if sys.platform=="win32":
        os.rename(src,dst)
    else:
        from distutils.file_util import move_file
        move_file(src,dst)
#@nonl
#@-node:ekr.20050104131929.3:<< old code >>
#@-node:ekr.20050104131343.1:From replaceTargetFileIfDifferent
#@+node:ekr.20031218072017.3974:frame.OnVisibility (Not used)
# Handle the "visibility" event and attempt to attach the Leo icon.
# This code must be executed whenever the window is redrawn.

def OnVisibility (self,event):

    if self.icon and event.widget is self.top:

        # print "OnVisibility"
        self.icon.attach(self.top)
#@nonl
#@-node:ekr.20031218072017.3974:frame.OnVisibility (Not used)
#@-node:ekr.20031218072017.434:Unused code
#@-all
#@nonl
#@-node:ekr.20031218072017.329:@thin ../doc/leoNotes.txt
#@-leo
