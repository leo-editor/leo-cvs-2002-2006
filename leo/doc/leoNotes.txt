#@+leo-ver=4-thin
#@+node:ekr.20031218072017.329:@thin ../doc/leoNotes.txt
#@@nocolor

#@+all
#@+node:ekr.20050123161408:ExamDiff files
0 leo.py
1 leoApp.py
2 leoAtFile.py
3 leoColor.py
4 leoCommands.py
5 leoCompare.py
6 leoConfig.py
7 leoFileCommands.py
8 leoFind.py
9 leoFrame.py
10 leoGlobals.py
11 leoGui.py
12 leoImport.py
13 leoKeys.py
14 leoMenu.py
15 leoNodes.py
16 leoPlugins.py
17 leoTangle.py
18 leoTkinterComparePanel.py
19 leoTkinterDialog.py
20 leoTkinterFind.py
21 leoTkinterFontPanel.py
22 leoTkinterFrame.py
23 leoTkinterGui.py
24 leoTkinterKeys.py
25 leoTkinterMenu.py
26 leoTkinterTree.py
27 leoUndo.py
#@nonl
#@+node:ekr.20050123160215.1:Put all files in alpha order in ExamDiff
import leoGlobals as g

print '-' * 20
d = []

for p in g.top().allNodes_iter():
    s = p.headString()
    if s.startswith('@thin'):
        d.append(s[5:].strip())
        
d.sort()

for s in d:
    print s
    

        
#@-node:ekr.20050123160215.1:Put all files in alpha order in ExamDiff
#@-node:ekr.20050123161408:ExamDiff files
#@+node:ekr.20031218072017.365:How to...
#@+node:ekr.20031218072017.366:How to add and remove files from CVS repository
use the command line option in the admin menu to do the following:

add leoConfig.py and leoConfig.txt
	cvs add leoConfig.txt
	cvs add leoConfig.py
	(then do commit)

remove readme*.doc
	remove files from working area (done)
	cvs remove readme1.doc
	cvs remove readme2.doc
	...
	(then do commit)
#@nonl
#@-node:ekr.20031218072017.366:How to add and remove files from CVS repository
#@+node:ekr.20031218072017.367:How to add support for a new language
@nocolor

- Add a new entries in << define global data structures >> app

- Add a new Tk.Radiobutton in <<create the Target Language frame>>

- Add an entry to the languages list in <<configure language-specific settings>>

- Add a list of the keywords of the language to << define colorizer keywords >>

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done in this step.
  
- If the language is case insensitive, add it to the list of
case_insensitiveLanguages found in  << define global colorizer data >>

TESTS

- Test the syntax coloring for the new language by using the @language directive.

- Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

- Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

- Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the <preferences> tag (near the top) contains an entry like this:

<preferences allow_rich_text="0" defaultTargetLanguage="Python">
</preferences>

but with the name of your new language instead of "Python".

- Create an @root node and verify that you can Tangle it.

@color
#@nonl
#@+node:EKR.20040623090054:<< define global colorizer data >>
case_insensitiveLanguages = ['plsql',]
#@nonl
#@-node:EKR.20040623090054:<< define global colorizer data >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","plsql","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords
#@nonl
#@+node:ekr.20031218072017.372:actionscript keywords
actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]
#@nonl
#@-node:ekr.20031218072017.372:actionscript keywords
#@+node:bwmulder.20041023131509:ada keywords
ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]
#@nonl
#@-node:bwmulder.20041023131509:ada keywords
#@+node:ekr.20040206072057:c# keywords
csharp_keywords = [
    "abstract","as",
    "base","bool","break","byte",
    "case","catch","char","checked","class","const","continue",
    "decimal","default","delegate","do","double",
    "else","enum","event","explicit","extern",
    "false","finally","fixed","float","for","foreach",
    "get","goto",
    "if","implicit","in","int","interface","internal","is",
    "lock","long",
    "namespace","new","null",
    "object","operator","out","override",
    "params","partial","private","protected","public",
    "readonly","ref","return",
    "sbyte","sealed","set","short","sizeof","stackalloc",
    "static","string","struct","switch",
    "this","throw","true","try","typeof",
    "uint","ulong","unchecked","unsafe","ushort","using",
    "value","virtual","void","volatile",
    "where","while",
    "yield"]
#@nonl
#@-node:ekr.20040206072057:c# keywords
#@+node:ekr.20031218072017.373:c/c++ keywords
c_keywords = [
    # C keywords
    "auto","break","case","char","continue",
    "default","do","double","else","enum","extern",
    "float","for","goto","if","int","long","register","return",
    "short","signed","sizeof","static","struct","switch",
    "typedef","union","unsigned","void","volatile","while",
    # C++ keywords
    "asm","bool","catch","class","const","const_cast",
    "delete","dynamic_cast","explicit","false","friend",
    "inline","mutable","namespace","new","operator",
    "private","protected","public","reinterpret_cast","static_cast",
    "template","this","throw","true","try",
    "typeid","typename","using","virtual","wchar_t"]
#@nonl
#@-node:ekr.20031218072017.373:c/c++ keywords
#@+node:ekr.20040401103539:css keywords
css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]
#@nonl
#@-node:ekr.20040401103539:css keywords
#@+node:ekr.20031218072017.374:elisp keywords
# EKR: needs more work.
elisp_keywords = [
    # Maybe...
    "error","princ",
    # More typical of other lisps...
    "apply","eval",
    "t","nil",
    "and","or","not",
    "cons","car","cdr",
    "cond",
    "defconst","defun","defvar",
    "eq","ne","equal","gt","ge","lt","le",
    "if",
    "let",
    "mapcar",
    "prog","progn",
    "set","setq",
    "type-of",
    "unless",
    "when","while"]
#@nonl
#@-node:ekr.20031218072017.374:elisp keywords
#@+node:ekr.20041107093834:forth keywords
# Default forth keywords: extended by leo-forthwords.txt.
forth_keywords = [
    "variable", "constant", "code", "end-code",
    "dup", "2dup", "swap", "2swap", "drop", "2drop",
    "r>", ">r", "2r>", "2>r",
    "if", "else", "then",
    "begin", "again", "until", "while", "repeat",
    "v-for", "v-next", "exit",
    "meta", "host", "target", "picasm", "macro",
    "needs", "include",
    "'", "[']",
    ":", ";",
    "@", "!", ",", "1+", "+", "-",
    "<", "<=", "=", ">=", ">",
    "invert", "and", "or", 
    ]

# Forth words which define other words: extended by leo-forthdefwords.txt.
forth_definingwords = [
    ":", "variable", "constant", "code",
    ]

# Forth words which start strings: extended by leo-forthstringwords.txt.
forth_stringwords = [
    's"', '."', '"', '."',
    'abort"',
    ]

# Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
forth_boldwords = [ ]

# Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
forth_italicwords = [ ]

# Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
# Note: on some boxen, bold italics may show in plain bold.
forth_bolditalicwords = [ ]
#@nonl
#@-node:ekr.20041107093834:forth keywords
#@+node:ekr.20031218072017.375:html keywords
# No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
    unused_keywords = [
        # html constructs.
        "a","body","cf",
        "h1","h2","h3","h4","h5","h6",
        "head","html","hr",
        "i","img","li","lu","meta",
        "p","title","ul",
        # Common tags
        "caption","col","colgroup",
        "table","tbody","td","tfoot","th","thead","tr",
        "script","style"]

    html_specials = [ "<%","%>" ]
#@nonl
#@-node:ekr.20031218072017.375:html keywords
#@+node:ekr.20031218072017.376:java keywords
java_keywords = [
    "abstract","boolean","break","byte","byvalue",
    "case","cast","catch","char","class","const","continue",
    "default","do","double","else","extends",
    "false","final","finally","float","for","future",
    "generic","goto","if","implements","import","inner",
    "instanceof","int","interface","long","native",
    "new","null","operator","outer",
    "package","private","protected","public","rest","return",
    "short","static","super","switch","synchronized",
    "this","throw","transient","true","try",
    "var","void","volatile","while"]
#@nonl
#@-node:ekr.20031218072017.376:java keywords
#@+node:ekr.20031218072017.377:latex keywords
#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
    "\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
    "\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
    "\\cot", "\\coth",	"csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
    "\\linethickness", "\\linewidth",	"\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow",	"longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi",	"\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow",	"\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone",	"\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]
#@nonl
#@-node:ekr.20031218072017.377:latex keywords
#@+node:ekr.20031218072017.378:pascal keywords
pascal_keywords = [
    "and","array","as","begin",
    "case","const","class","constructor","cdecl"
    "div","do","downto","destructor","dispid","dynamic",
    "else","end","except","external",
    "false","file","for","forward","function","finally",
    "goto","if","in","is","label","library",
    "mod","message","nil","not","nodefault""of","or","on",
    "procedure","program","packed","pascal",
    "private","protected","public","published",
    "record","repeat","raise","read","register",
    "set","string","shl","shr","stdcall",
    "then","to","true","type","try","until","unit","uses",
    "var","virtual","while","with","xor"
    # object pascal
    "asm","absolute","abstract","assembler","at","automated",
    "finalization",
    "implementation","inherited","initialization","inline","interface",
    "object","override","resident","resourcestring",
    "threadvar",
    # limited contexts
    "exports","property","default","write","stored","index","name" ]
#@nonl
#@-node:ekr.20031218072017.378:pascal keywords
#@+node:ekr.20031218072017.379:perl keywords
perl_keywords = [
    "continue","do","else","elsif","format","for","format","for","foreach",
    "if","local","package","sub","tr","unless","until","while","y",
    # Comparison operators
    "cmp","eq","ge","gt","le","lt","ne",
    # Matching ooperators
    "m","s",
    # Unary functions
    "alarm","caller","chdir","cos","chroot","exit","eval","exp",
    "getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
    "hex","int","length","localtime","log","ord","oct",
    "require","reset","rand","rmdir","readlink",
    "scalar","sin","sleep","sqrt","srand","umask",
    # Transfer ops
    "next","last","redo","go","dump",
    # File operations...
    "select","open",
    # FL ops
    "binmode","close","closedir","eof",
    "fileno","getc","getpeername","getsockname","lstat",
    "readdir","rewinddir","stat","tell","telldir","write",
    # FL2 ops
    "bind","connect","flock","listen","opendir",
    "seekdir","shutdown","truncate",
    # FL32 ops
    "accept","pipe",
    # FL3 ops
    "fcntl","getsockopt","ioctl","read",
    "seek","send","sysread","syswrite",
    # FL4 & FL5 ops
    "recv","setsocket","socket","socketpair",
    # Array operations
    "pop","shift","split","delete",
    # FLIST ops
    "sprintf","grep","join","pack",
    # LVAL ops
    "chop","defined","study","undef",
    # f0 ops
    "endhostent","endnetent","endservent","endprotoent",
    "endpwent","endgrent","fork",
    "getgrent","gethostent","getlogin","getnetent","getppid",
    "getprotoent","getpwent","getservent",
    "setgrent","setpwent","time","times","wait","wantarray",
    # f1 ops
    "getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
    "sethostent","setnetent","setprotoent","setservent",
    # f2 ops
    "atan2","crypt",
    "gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
    "index","link","mkdir","msgget","rename",
    "semop","setpgrp","symlink","unpack","waitpid",
    # f2 or 3 ops
    "index","rindex","substr",
    # f3 ops
    "msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
    # f4 & f5 ops
    "semctl","shmread","shmwrite","msgrcv",
    # Assoc ops
    "dbmclose","each","keys","values",
    # List ops
    "chmod","chown","die","exec","kill",
    "print","printf","return","reverse",
    "sort","system","syscall","unlink","utime","warn"]
#@nonl
#@-node:ekr.20031218072017.379:perl keywords
#@+node:ekr.20031218072017.380:php keywords
php_keywords = [ # 08-SEP-2002 DTHEIN
    "__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
    "and", "as", "break",
    "case", "cfunction", "class", "const", "continue",
    "declare", "default", "do",
    "else", "elseif", "enddeclare", "endfor", "endforeach",
    "endif", "endswitch",  "endwhile", "eval", "extends",
    "for", "foreach", "function", "global", "if",
    "new", "old_function", "or", "static", "switch",
    "use", "var", "while", "xor" ]
    
# The following are supposed to be followed by ()
php_paren_keywords = [
    "array", "die", "echo", "empty", "exit",
    "include", "include_once", "isset", "list",
    "print", "require", "require_once", "return",
    "unset" ]
    
# The following are handled by special case code:
# "<?php", "?>"
#@-node:ekr.20031218072017.380:php keywords
#@+node:ekr.20050618052653:plsql keywords
plsql_keywords = [
# reserved keywords
"abort",
"accept",
"access",
"add",
"admin",
"after",
"all",
"allocate",
"alter",
"analyze",
"and",
"any",
"archive",
"archivelog",
"array",
"arraylen",
"as",
"asc",
"assert",
"assign",
"at",
"audit",
"authorization",
"avg",
"backup",
"base_table",
"become",
"before",
"begin",
"between",
"binary_integer",
"block",
"body",
"boolean",
"by",
"cache",
"cancel",
"cascade",
"case",
"change",
"char",
"char_base",
"character",
"check",
"checkpoint",
"close",
"cluster",
"clusters",
"cobol",
"colauth",
"column",
"columns",
"comment",
"commit",
"compile",
"compress",
"connect",
"constant",
"constraint",
"constraints",
"contents",
"continue",
"controlfile",
"count",
"crash",
"create",
"current",
"currval",
"cursor",
"cycle",
"data_base",
"database",
"datafile",
"date",
"dba",
"debugoff",
"debugon",
"dec",
"decimal",
"declare",
"default",
"definition",
"delay",
"delete",
"delta",
"desc",
"digits",
"disable",
"dismount",
"dispose",
"distinct",
"distinct",
"do",
"double",
"drop",
"drop",
"dump",
"each",
"else",
"else",
"elsif",
"enable",
"end",
"end",
"entry",
"escape",
"events",
"except",
"exception",
"exception_init",
"exceptions",
"exclusive",
"exec",
"execute",
"exists",
"exists",
"exit",
"explain",
"extent",
"externally",
"false",
"fetch",
"fetch",
"file",
"float",
"float",
"flush",
"for",
"for",
"force",
"foreign",
"form",
"fortran",
"found",
"freelist",
"freelists",
"from",
"from",
"function",
"generic",
"go",
"goto",
"grant",
"group",
"groups",
"having",
"identified",
"if",
"immediate",
"in",
"including",
"increment",
"index",
"indexes",
"indicator",
"initial",
"initrans",
"insert",
"instance",
"int",
"integer",
"intersect",
"into",
"is",
"key",
"language",
"layer",
"level",
"like",
"limited",
"link",
"lists",
"lock",
"logfile",
"long",
"loop",
"manage",
"manual",
"max",
"maxdatafiles",
"maxextents",
"maxinstances",
"maxlogfiles",
"maxloghistory",
"maxlogmembers",
"maxtrans",
"maxvalue",
"min",
"minextents",
"minus",
"minvalue",
"mlslabel",
"mod",
"mode",
"modify",
"module",
"mount",
"natural",
"new",
"new",
"next",
"nextval",
"noarchivelog",
"noaudit",
"nocache",
"nocompress",
"nocycle",
"nomaxvalue",
"nominvalue",
"none",
"noorder",
"noresetlogs",
"normal",
"nosort",
"not",
"notfound",
"nowait",
"null",
"number",
"number_base",
"numeric",
"of",
"off",
"offline",
"old",
"on",
"online",
"only",
"open",
"open",
"optimal",
"option",
"or",
"order",
"others",
"out",
"own",
"package",
"package",
"parallel",
"partition",
"pctfree",
"pctincrease",
"pctused",
"plan",
"pli",
"positive",
"pragma",
"precision",
"primary",
"prior",
"private",
"private",
"privileges",
"procedure",
"procedure",
"profile",
"public",
"quota",
"raise",
"range",
"raw",
"read",
"real",
"record",
"recover",
"references",
"referencing",
"release",
"remr",
"rename",
"resetlogs",
"resource",
"restricted",
"return",
"reuse",
"reverse",
"revoke",
"role",
"roles",
"rollback",
"row",
"rowid",
"rowlabel",
"rownum",
"rows",
"rowtype",
"run",
"savepoint",
"schema",
"scn",
"section",
"segment",
"select",
"select",
"separate",
"sequence",
"session",
"set",
"set",
"share",
"shared",
"size",
"size",
"smallint",
"smallint",
"snapshot",
"some",
"sort",
"space",
"sql",
"sqlbuf",
"sqlcode",
"sqlerrm",
"sqlerror",
"sqlstate",
"start",
"start",
"statement",
"statement_id",
"statistics",
"stddev",
"stop",
"storage",
"subtype",
"successful",
"sum",
"sum",
"switch",
"synonym",
"sysdate",
"system",
"tabauth",
"table",
"tables",
"tables",
"tablespace",
"task",
"temporary",
"terminate",
"then",
"thread",
"time",
"to",
"tracing",
"transaction",
"trigger",
"triggers",
"true",
"truncate",
"type",
"uid",
"under",
"union",
"unique",
"unlimited",
"until",
"update",
"use",
"user",
"using",
"validate",
"values",
"varchar",
"varchar2",
"variance",
"view",
"views",
"when",
"whenever",
"where",
"while",
"with",
"work",
"write",
"xor" ]
#@-node:ekr.20050618052653:plsql keywords
#@+node:ekr.20031218072017.381:python keywords
python_keywords = [
    "and",       "del",       "for",       "is",        "raise",    
    "assert",    "elif",      "from",      "lambda",    "return",   
    "break",     "else",      "global",    "not",       "try",      
    "class",     "except",    "if",        "or",        "yield",   
    "continue",  "exec",      "import",    "pass",      "while",
    "def",       "finally",   "in",        "print"]
#@nonl
#@-node:ekr.20031218072017.381:python keywords
#@+node:ekr.20040331145826:rapidq keywords
rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]
#@nonl
#@-node:ekr.20040331145826:rapidq keywords
#@+node:ekr.20031218072017.382:rebol keywords
rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]
#@nonl
#@-node:ekr.20031218072017.382:rebol keywords
#@+node:ekr.20040401111125:shell keywords
shell_keywords = [
    # reserved keywords
    "case","do","done","elif","else","esac","fi",
    "for","if","in","then",
    "until","while",
    "break","cd","chdir","continue","eval","exec",
    "exit","kill","newgrp","pwd","read","readonly",
    "return","shift","test","trap","ulimit",
    "umask","wait" ]
#@nonl
#@-node:ekr.20040401111125:shell keywords
#@+node:ekr.20031218072017.383:tcl/tk keywords
tcltk_keywords = [ # Only the tcl keywords are here.
    "after",     "append",    "array",
    "bgerror",   "binary",    "break",
    "catch",     "cd",        "clock",
    "close",     "concat",    "continue",
    "dde",
    "encoding",  "eof",       "eval",
    "exec",      "exit",      "expr",
    "fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
    "filename",  "flush",     "for",       "foreach",   "format",
    "gets",      "glob",      "global",
    "history",
    "if",        "incr",      "info",      "interp",
    "join",
    "lappend",   "lindex",    "linsert",   "list",      "llength",
    "load",      "lrange",    "lreplace",  "lsearch",   "lsort",
    "memory",    "msgcat",
    "namespace",
    "open",
    "package",   "parray",    "pid",
    "proc",      "puts",      "pwd",
    "read",      "regexp",    "registry",   "regsub",
    "rename",    "resource",  "return",
    "scan",      "seek",      "set",        "socket",   "source",
    "split",     "string",    "subst",      "switch",
    "tell",      "time",      "trace",
    "unknown",   "unset",     "update",     "uplevel",   "upvar",
    "variable",  "vwait",
    "while" ]
#@nonl
#@-node:ekr.20031218072017.383:tcl/tk keywords
#@-node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
#@+node:ekr.20050618052621:Add the language name to @language default_target_language entry in leoSettings.leo
#@-node:ekr.20050618052621:Add the language name to @language default_target_language entry in leoSettings.leo
#@-node:ekr.20031218072017.367:How to add support for a new language
#@+node:ekr.20031218072017.384:How to export syntax colored code preserving colors
Scite has the option to "Export as html" and "export as rtf", and it will be
full of colour and fonts - and you can define them in properties, so it will be
the same as during editing.
#@nonl
#@-node:ekr.20031218072017.384:How to export syntax colored code preserving colors
#@+node:ekr.20031218072017.385:How to Increase environment space
To increase the size of environment space, add the following to config.sys:

shell=C:\windows\command\command.com /p:4096

Notes:

1. The path C:\windows\command\command.com may vary.
Check you system for the location of command.com.

2. This works for versions of Windows prior to Me.
On Me you set the registry somehow.
No information on XP.
#@nonl
#@-node:ekr.20031218072017.385:How to Increase environment space
#@+node:ekr.20051203084725:How to expand java .jar files
- Put whatever.jar in c:\prog
- cd: c:\prog
- jar xvf whatever.jar
#@nonl
#@-node:ekr.20051203084725:How to expand java .jar files
#@+node:ekr.20051129084430:How to install jython
@nocolor

- Download jython_Release_2_2alpha1.jar and put it anywhere (say on the desktop)

- Double-click the file.  This brings up an installer.  Follow the direction.
  (I installed to c:\jython-2.2a1

- Using the Control Panel, System, Advanced tab, environment variables,
  add c:\jython-2.2a1\jython.jar to CLASSPATH (in user variables)
#@nonl
#@+node:ekr.20051129084430.1:@url http://www.jython.org/install.html
#@-node:ekr.20051129084430.1:@url http://www.jython.org/install.html
#@-node:ekr.20051129084430:How to install jython
#@+node:ekr.20051203084725.1:How to install and run jythonShell
Install:

Put JythonShellEA.jar in c:\prog\JythonShell

(optional) Expand the jar so you can see the code:

jar xvf JythonShellEA.jar

Run:

Here is the contents of jythonShell.bat:

cd c:\prog\jythonShell
java -cp c:\jython-2.2a1\jython.jar;c:\prog\jythonShell\JythonShellEA2.1.jar org.leo.shell.JythonShell
#@nonl
#@-node:ekr.20051203084725.1:How to install and run jythonShell
#@+node:ekr.20050316092232:How to install jyLeo
- Unpack the .zip file, placing the result in c:\prog.

- Edit jleo.bat:

rem open jyLeo
rem
cd c:\prog\<path to jython>\src
java -jar c:\jython22a0\jython.jar leo.py
#@nonl
#@+node:ekr.20050716104357:Old instructions
@nocolor

- put the jyleo-nnn.jar file in c:\prog

- Execute the following command in a console window
    cd c:\prog
    jar xvf j-leo-nnn.jar

This creates a folder called j-leo-nnn

- Do the following, or execute jleo.bat

cd c:\prog\j-leo-nnn\src
java -jar c:\jython22a0\jython.jar leo.py

Note:  at present this gives KeyError: HOME

In leo.py, in computeHomeDir, I changed:
@color

home = os.getenv('HOME' )#,default=dotDir)

to:

try:
    home = os.getenv('HOME' )#,default=dotDir)
except Exception:
    home = ''
#@-node:ekr.20050716104357:Old instructions
#@+node:ekr.20050317153447:jy-Leo install instructions by Paul Paterson
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3053534
By: paulpaterson

Very interesting indeed - great work! 
 
I didn't have Java/Jython installed so for others in the same boat here's what I had to do to get it work on my platform (Win2k). Some of this is in the README but I had to do some extra but I'm not sure why. 
 
1. Install 1.5 JDK  
http://java.sun.com/j2se/1.5.0/download.jsp 
 
2. Install Jython 
http://www.jython.org/jython22a1.zip 
 
3. Edit Jython.bat file - the part that calls Java.exe to ... 
"C:\Program Files\Java\jdk1.5.0_02\jre\bin\java" -cp "C:\Program Files\Java\jdk1.5.0_02\jre\lib";"c:\Apps\Python23\Jython";"C:\Apps\jLeo\j-leo-MAR15\Icons";"C:\Apps\jLeo\j-leo-MAR15\skins";"C:\Apps\jLeo\j-leo-MAR15\src";"C:\Apps\jLeo\j-leo-MAR15\skinimages" -Dpython.home="c:\Apps\Python23\Jython" -jar jython.jar %ARGS% 
 
Where  
- Java installed at C:\Program Files\Java\jdk1.5.0_02 
- Jython at c:\Apps\Python23\Jython 
- jLeo at C:\Apps\jLeo\j-leo-MAR15 
 
Change your paths as appropriate! There must be a better way to do this - Java confuses me! 
 
4. Edit leo.py in jleo/src directory to fix failure to find HOME env variable. 
 
line 241 becomes ... 
 
....try:home = os.getenv('HOME' )#,default=dotDir) 
....except KeyError:home="" 
 
 
Then, from the Jython install directory ... 
 
Jython " 
C:\Apps\jLeo\j-leo-MAR15\src\leo.py" 
 
Works a treat!  
 
Paul
#@-node:ekr.20050317153447:jy-Leo install instructions by Paul Paterson
#@-node:ekr.20050316092232:How to install jyLeo
#@+node:ekr.20031218072017.386:How to remove cursed newlines: use binary mode
teknico ( Nicola Larosa ) 
 RE: Removing '\r' characters?   
2002-09-16 14:27  
> I am plowing through old bug reports, and I found the following, from whom 
> I don't know: 

That's from me, *again*. You are kindly advised to stop forgetting the attribution to all my bug reports. ;^) 

>> - Source files still have the dreaded \r in them. Why don't you switch 
>> to \n only, once and for all, and live happily ever after? ;^) 

> I sure whould like to do that, and I'm not sure how to do this. All 
> versions of the read code attempt to remove '\r' characters, and all 
> versions of the write code write '\n' only for newlines. 

Sorry for being a bit vague, I was talking about the Leo source files themselves. I don't know what you use to edit them, ;^))) but in version 3.6 they still have \r\n as end-of-line. 

If Leo itself does not solve the problem, may I suggest the 
Tools/scripts/crlf.py script in the Python source distibution? It's nice and simple, and skips binary files, too. That's what I use every time I install a new version of Leo. :^) 
 
#@+node:ekr.20031218072017.387:The solution
Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". The unix python interpreter ignores trailing "\r" in python source files. There are no such guarantees for other languages. Unix users should be able to get rid of the cosmetically detrimental "\r" either by running dos2unix on the offending files, or, if they're part of a .leo project, reading them into leo and writing them out again.  


By: edream ( Edward K. Ream ) 
 RE: Removing '\r' characters?   
2002-09-17 09:34  
Oh, I see. Thanks very much for this clarification. 

Just to make sure I understand you: the problem with '\r' characters is that: 

1. I am creating LeoPy.leo and LeoDocs.leo on Windows and 
2. People are then using these files on Linux. 

and the way to remove the '\r' characters: 

1. I could run dos2unix on all distributed files just before committing to CVS or making a final distribution or 
2. People could, say, do the following: 

Step 1: Read and Save the .leo files, thereby eliminating the '\r' in those files and 
Step 2: Use the Write @file nodes command on all derived files to clear the '\r' in those files. 

Do you agree so far? 

> Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". 

I am going to see if there is any way to get Python to write a "raw" '\n' to a file. I think there must be. This would solve the problem once and for all. 

Thanks again for this most helpful comment. 

Edward
#@nonl
#@-node:ekr.20031218072017.387:The solution
#@+node:ekr.20031218072017.388:cursed newline answer
In 2.3 you can open files with the "U" flag and get "universal newline"
support: 

% python
Python 2.3a0 (#86, Sep 4 2002, 21:13:00) 
[GCC 2.96 20000731 (Mandrake Linux 8.1 2.96-0.62mdk)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> f = open("crlf.txt")
>>> line = f.readline()
>>> line
'This is an example of what I have come to call the "cursed newline"
problem,\r\n'
>>> f = open("crlf.txt", "rU")
>>> line = f.readline()
>>> line
'This is an example of what I have come to call the "cursed newline" problem,\n'

#@-node:ekr.20031218072017.388:cursed newline answer
#@+node:ekr.20031218072017.389:cursed newline answer 2
> You can open the file in 'binary' mode (adding 'b' to the mode string) and
> the file will contain '\r\n' on both platforms (and any other platforms.)

Nope. Exactly wrong. In 2.2 and those before, when files are opened in
*text* mode (no "b") then reading them will provide Unix-style line endings
(newline only). When you open files in binary mode then you see the bytes
stored in the file.

On Unix systems there's no difference in the contents of a file whether in
binary or text mode. On Windows a file is shorter by the number of carriage
returns. On the Mac I have no idea what they do. Probably just carriage
returns, to be different :-)

2.3 will be a bit more flexible about such mattrers.
#@-node:ekr.20031218072017.389:cursed newline answer 2
#@-node:ekr.20031218072017.386:How to remove cursed newlines: use binary mode
#@+node:ekr.20031218072017.390:How to run Pychecker
Do the following in Idle:

import pychecker.checker ; import leo

To run Idle(Python2.3 version) directly:

cd c:\prog\leoCvs\leo\src
c:\python23\python c:\python23\Lib\idlelib\idle.py

The HOME var must be set to c:\prog\leoCVS for .pycheckrc to be effective.

To suppress warnings from the standard library set ignoreStandardLibrary=1 in .pycheckrc
#@nonl
#@-node:ekr.20031218072017.390:How to run Pychecker
#@+node:ekr.20050510071834:How to use a temp file with pdb
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3137690
By: nobody

I dont know if anyone has solved this for regular Leo, but in the JyLeo JythonShell,
when the user executes a script with Pdb it:
1. dumps the script in a tmp file system's tmp directory.
2. Executes pdb based off of that tmp file.

that way you get all the goodness that pdb can offer.
#@-node:ekr.20050510071834:How to use a temp file with pdb
#@+node:ekr.20031218072017.391:How to use CVS branches
@nocolor

I have a fair bit of expertise on CVS branches. It's late at night, so I don't have time for a long soapbox spiel at the moment. I will try to post something tomorrow. 

The brief picture is: 

* Check out code from CVS at the point you want to create the branch. 

* Make sure none of the files in your sandbox is modified. 

* Create the branch (cvs tag -b branchname). The branch name must start with a letter (upper or lower case) and thereafter can have alphanumeric characters, hyphens, and underscores (no periods or spaces). 

* The branch is created on the repository, but your sandbox is still checked out on the main branch. To check out on the new branch, do "cvs up -r branchname". 

When you want to merge changes back into the main branch, you can use "cvs up -r MAIN" to retrieve the main branch, then "cvs up -j branchname" to merge changes, then "cvs commit" to commit the merged version to the main branch AFTER YOU HAVE VERIFIED IT. 

I would recommend caution with merging because as you have noted, leo files are not well set up for CVS. They don't merge well because of inconsistent sentinel values. 

You may want to look at manually merging changes back into the main branch until leo implements invariant unique (UUID) sentinel indices. 

This will not hurt your ability to use branches, only your ability to automatically merge changes from one branch onto another.
#@nonl
#@-node:ekr.20031218072017.391:How to use CVS branches
#@+node:ekr.20041214135556:How to use Tile
@nocolor
https://sourceforge.net/forum/message.php?msg_id=2882718
By: nobody

if anyone is interested here is some code that Tilefied my Leo instance, its
does some patching in the LeoGui program.

@color

def createRootWindow(self):

    """Create a hidden Tk root window."""
    #import Tix
    self.root = root = Tk.Tk()
    root.tk.call( 'package', 'require', 'tile' )
    #root.tk.call( 'namespace', 'import', '-force', 'ttk::*' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::scrollbar' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::label' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::entry' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::menu' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::button' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::frame' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::menubutton' )
    root.tk.call( 'tile::setTheme', 'clam' )
    #self.root = root = Tix.Tk()
    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    self.getDefaultConfigFont(g.app.config)
    self.createGlobalWindows()

    return root
#@nonl
#@-node:ekr.20041214135556:How to use Tile
#@-node:ekr.20031218072017.365:How to...
#@+node:ekr.20050214055018:Mac Notes
#@+node:ekr.20050221054932:How to make monolithic Leo app on MacOS X
 @killcolor
http://sourceforge.net/forum/message.php?msg_id=3007062
By: jgleeson

Sorry to take so long to reply.  I've been buried in work and haven't kept up
with some email.

Here's the link to the site where I posted the folder you have:
<http://homepage.mac.com/jdgleeson/>  It's the small file named "Leo.zip" (23
KB), not the large file "Leo-4.3-alpha-2.dmg" (20 MB).

I agree that I did not write very clear instructions, beginnng with the first
step, where I should have also said:  "It is important to use version 1.1.8
of py2app, which is only available through svn.  The version on the py2app website
is 1.1.7, which creates buggy Tkinter apps. If you try to use version 1.1.7,
the Leo app it creates will give you a message saying that Tkinter is not properly
installed.  Your installation is fine; otherwise you could not have even built
Leo.app with py2app, because py2app copies the essential parts of Tcl/Tk into
the application bundle to make the app completely standalone."

I haven't tried intalling the Fink subversion -- I'm using DarwinPorts
<http://darwinports.opendarwin.org/>.  But there's a simpler alternative than
DarwinPorts. Metissian releases OS X packages of Subversion clients
<http://metissian.com/projects/macosx/subversion/>

AFAIK, the command "python setup.py bdist_mpkg --open" only applies to the py2app
1.1.8 distribution.  By the way, bdist_mpkg is distributed with py2app. It creates
a package around the setup.py script (more specialized than Platypus).  I don't
have any experience with bdist_mpkg yet.

'Copy the leo folder into this directory' is horrible. I'm glad you figured
it out -- I'm not sure I could have.

"python setup.py py2app -a" should be run in the folder with the readme file,
which also contains the setup.py file that the command refers to.  Most importantly,
the folder in which this command is run must contain the leo folder -- which
it does only if you are brilliant enough to decode my instructions.   ;) 

HTH

-John
#@nonl
#@-node:ekr.20050221054932:How to make monolithic Leo app on MacOS X
#@+node:ekr.20050214055018.4:@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)
#@-node:ekr.20050214055018.4:@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)
#@+node:ekr.20050214055018.5:@url http://www.wordtech-software.com/leo.html  (Mac Bundle)
#@-node:ekr.20050214055018.5:@url http://www.wordtech-software.com/leo.html  (Mac Bundle)
#@+node:ekr.20050513164506:Problems with run script command on Mac x11
@killcolor

Jon Schull <jschull@softlock.com>  
Date:  2003/12/30 Tue PM 05:50:51 EST 
To:  edreamleo@charter.net 
Subject:  Leo, Mac OS X 10.3, and VPython 
             
I've been evaluating leo or vpython programming on  Mac OS X 10.3, and 
have some observations and a suggestion.

Observations:
- Leo runs under X11 as well as under OS X.
- My X11 python configuration was created using the recipe at XXX (which enables vpython).
- The OS X configuration is vanilla MacPython from MacPython.org, along with AquaTclTk batteries included XXX.

In both environments I can run leo under python leo.py and under idle.
Under OS X we get font smoothing, but we can't run visual python programs (python crashes;  this is a known incompatibility with  MacPython.)
    
- Under X11 we can run visual python programs like this one
    #box.py
    from visual import *
    box()
            
And we can even run them under leo (under X11). HOWEVER, when the visual python program is terminated, leo vanishes (leo and the vp program apparently run in the same space)
    
Under x11, we can keep leo alive by putting the vp program in its own space:
    
    os.popen3('/sw/bin/python /Users/jis/box.py')
    
However,  this doesn't let us see the output of stderr and stdout.  
Those text streams are available...
        
    def do(cmd='ls'):
        from os import popen3
        pIn,pOut,pErr=0,1,2
        popenResults=popen3(cmd)
        print popenResults[pOut].read()
        print popenResults[pErr].read()
    
    import os	
    do('/sw/bin/python /Users/jis/box.py')
        
...but only when the vpython program terminates.
    
Here's the good news:  if we execute our vp program with 
/sw/bin/idle.py rather than with python, we get to see the program 
output in real time (under idle, under X11).
    
    import os	
    os.chdir('/sw/lib/python2.3/idlelib')
    os.popen3('/sw/bin/python idle.py -r /Users/jis/box.py')
        
#this runs as an executed script in leo, and produces a live idle 
with real time ongoing output.
    
Now, while idle is running, leo sits in suspended animation.  But when 
the vpython program terminates, we are left in idle, and when idle is 
terminated, leo becomes active again.
    
It would be even better if leo were not suspended (using os.spawn, 
perhaps) but the real point is that I would really really like leo's 
"Execute script" command to execute code this way and spare me having 
to  hard-write the path to box.py.  It ought to be possible to 
eliminate os.chdir as well.

------------------
Jon Schull, Ph.D.
Associate Professor
Information Technology
Rochester Institute of Technology
schull@digitalgoods.com 585-738-6696
#@nonl
#@-node:ekr.20050513164506:Problems with run script command on Mac x11
#@+node:ekr.20040104162835.8:Linux/Mac notes: Dan Winkler
#@+node:ekr.20040104162835.13:Fink & aqua
Yes, fink does have pre-built Pythons, both 2.1 and 2.2.  (If you don't 
see them it probably means you don't have the right servers listed in 
your /sw/etc/apt/sources.list file.)  However, the versions of Python 
you'd get through fink are set up to run under X Windows, which I don't 
think is what you want.

I think what you want is MacPython which can run Tk programs like Leo 
under Aqua.  That's what I use these days.

I can tell from your question that you don't understand the following 
differences between the versions of Python available:

1) The version that comes with OS X is a text only one which doesn't 
have Tk.  Leo can't run under that.  Also, I hate Apple for including 
this instead of one that does have Tk and I hope they'll fix it some 
day.

2) You can get a version of Python from fink with has Tk but which runs 
under X Windows.  I don't think you want that.

3). You can also get MacPython which has Tk but it's a version of Tk 
that uses the Aqua windowing system, not X Windows.

So Tk can either be present or not and if it is present it can use 
either X Windows or Aqua.  You want it present and using Aqua, I think.


#@-node:ekr.20040104162835.13:Fink & aqua
#@+node:ekr.20040104162835.14:Mac, Fink, etc.
> 1. The python that FC installs is MacPython.  I think that because the
> MacPython docs talk about Fink.

Nope.  The python installed by FC knows nothing about the Mac.  It 
thinks it's running on a Unix machine.  And it uses a version of Tk 
which thinks it's running on a Unix machine.  The window standard on 
Unix is called X (or X11 or XFree86, all the same thing).  So the main 
reason to run Leo this way would be to get an idea of how it works for 
Unix/Linux users.  But when programs run under X, they don't look like 
Mac programs.  They don't get all those glossy, translucent widgets 
that Aqua provides.  They really look like they would on a Unix/Linux 
machine.

Aqua is the native windowing system on Mac.  MacPython is set up to 
work with it.  Most Mac users will want Leo to work this way.  That's 
what I do.

>
>
> I have the TkTclAquBI (Batteries included) installer.  Is installing 
> this
> enough to get Leo to work with Aqua?  Do I have to de-install the
> present tk stuff that I installed with FC?

Yes, I think that's all I installed to get Tk to work under Aqua.  You 
don't have to deinstall the FC stuff.  All the FC stuff lives in its 
own world under /sw and runs under X.  It won't conflict with the Mac 
world.

#@-node:ekr.20040104162835.14:Mac, Fink, etc.
#@+node:ekr.20040104162835.15:Double clicking on Linux
Double-clickable things (i.e. Macintosh applications) are usually 
actually folders with a name that ends in .app.  The file you found is 
probably executable only from the command line, not by double clicking 
it.  So I think if you run it from the command line it will work but 
will not know about Tk because Apple's version was built without Tk 
support.

You can also execute the .app programs from the command line by using 
the open command, so "open foo.app" will do the same thing as double 
clicking on foo in the finder (the .app extension is suppressed).  The 
idea behind this is that an application can look like just one opaque 
icon in the finder but actually have all its resources nicely organized 
in subfolders.
#@-node:ekr.20040104162835.15:Double clicking on Linux
#@-node:ekr.20040104162835.8:Linux/Mac notes: Dan Winkler
#@-node:ekr.20050214055018:Mac Notes
#@+node:ekr.20031218072017.392:Python Notes...
#@+node:ekr.20031218072017.393:What's new for each version:
New in 2.2 (Do not use)

- Iterators/Generators
- Nested Scopes
- New Classes

The what's new for each version:

http://www.amk.ca/python/2.0/
http://www.amk.ca/python/2.1/
#@+node:ekr.20031218072017.394:@url http://www.python.org/2.3/highlights.html
#@-node:ekr.20031218072017.394:@url http://www.python.org/2.3/highlights.html
#@+node:ekr.20031218072017.395:@url http://www.amk.ca/python/2.1/
#@-node:ekr.20031218072017.395:@url http://www.amk.ca/python/2.1/
#@+node:ekr.20031218072017.396:@url http://www.amk.ca/python/2.0/
#@-node:ekr.20031218072017.396:@url http://www.amk.ca/python/2.0/
#@-node:ekr.20031218072017.393:What's new for each version:
#@+node:ekr.20031218072017.397:Default values & keyword arguments
@nocolor

1. You specify default values of _formal parameters_ in a def statement.

2. You specify keywords arguments in a _function call_.

3. An argument list must have any positional arguments followed by any keyword arguments, where the keywords must be chosen from the formal parameter names.  It's not important whether a formal parameter has a default value or not.

4. No argument may receive a value more than once.

5. When a final formal parameter of the form **name is present, it receives a dictionary containing all keyword arguments whose keyword doesn't correspond to a formal parameter.

EKR Notes:

1.  I have been confusing default values with keyword arguments.  _Any_ formal parameter may be specified with a keyword argument!

2.  Arbitrary keyword params can be used if the def has an **arg.
#@nonl
#@-node:ekr.20031218072017.397:Default values & keyword arguments
#@+node:ekr.20031218072017.398:How to call any Python method from the C API
In general, everything you can do in Python is accessible through the C API.

	lines = block.split('\n');
 
> That will be
 
	lines = PyObject_CallMethod(block, "split", "s", "\n");
#@-node:ekr.20031218072017.398:How to call any Python method from the C API
#@+node:ekr.20031218072017.399:How to run Python programs easily on NT,2K,XP
#@+node:ekr.20031218072017.400:setting the PATHEXT env var
It is worth noting that NT, Win2K and XP all have an alternative which is
to add .PY to the PATHEXT environment variable. Then you can run any .PY
file directly just by typing the name of the script without the extension. 

e.g.
C:\>set PATHEXT=.COM;.EXE;.BAT;.CMD

C:\>set PATH=%PATH%;c:\python22\tools\Scripts

C:\>google
'google' is not recognized as an internal or external command,
operable program or batch file.

C:\>set PATHEXT=.COM;.EXE;.BAT;.CMD;.PY

C:\>google
Usage: C:\python22\tools\Scripts\google.py querystring

C:\>
#@-node:ekr.20031218072017.400:setting the PATHEXT env var
#@+node:ekr.20031218072017.401:Yet another Python .bat wrapper
>> It has a header of just one line. All the ugly stuff is at the end.
>>
>> -------------------------------------------------------------------
>> goto ="python"
>>
>> # Python code goes here
>>
>> ''' hybrid python/batch footer:
>> @:="python"
>> @python.exe %0 %1 %2 %3 %4 %5 %6 %7 %8 %9
>> @if errorlevel 9009 echo Python may be downloaded from
>www.python.org/download
>> @rem '''
>> -------------------------------------------------------------------
>>
>>         Oren
>>
>

It's for running python scripts on windows, without having to type:

[<path to python>\]python[.exe] <scriptname> [<arguments>*]

and almost takes the place of the "shabang" line at the top of *nix
scripts.

#@-node:ekr.20031218072017.401:Yet another Python .bat wrapper
#@-node:ekr.20031218072017.399:How to run Python programs easily on NT,2K,XP
#@+node:ekr.20050228095252:xml tools mentioned in posts
#@+node:ekr.20050228095252.1:@url http://www.xml.com/pub/a/2003/02/12/py-xml.html
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3019151
By: e

>>code to parse and write XML ? 

something like this to get started?
Simple XML Processing With elementtree
<http://www.xml.com/pub/a/2003/02/12/py-xml.html>
look at some plugin source for a bunch
of ways to insert nodes and move them 
programatically. the piemenu is on the forum 
somewhere has nearly everything you would need.
BTW, I've got a u3 event I use all the time:
one click, insert body and headline from the clipboard.

... def u3(event ):  
... ... #insert paste body 
... ... #and create headline, cheap extract
... ... c.selectVnode(v )
... ... c.insertHeadline()
... ... #c.moveOutlineRight()
... ... cv = c.currentVnode()
... ... cv.setBodyStringOrPane(
... ... ... g.app.gui.getTextFromClipboard())
... ... s = g.app.gui.getTextFromClipboard()[:25].strip()
... ... s = ' '.join(s.split()[:3])  
... ... #later skip punctuation somehow make smarter
... ... cv.setHeadString(s)
... self.u3.bind('<Button-1>', u3 )  
THANKS! this hack saves bunches of time daily.
would work other places than the piemenu too.

I won't attempt to reiterate what many other blogs
and articles have said about elementtree.
besides which I know next to nothing deep about XML.
no clue how it compares to sax or anything else.
I will say it's great for parsing and creating and
modifying XML and HTML in the few short examples
I've read from years past and some recent. 
lately there is also a c module,
works in conjunction with Elementtree.py
very clean code compiles easily w/o error.
light, fast. how does he do it?
<http://effbot.org/zone/element-index.htm>

its html tree can work with Tidy, I actually started
a very similar project to parse HTML into nodes:
html, head, script, body, table or form etc.
using pullparser then beautifulsoup.
I got lost where if you insert a node, 
then a body then another node malformed HTML
can really screw you up. Tidy helps somewhat.
XML is probably much better formed,
I like the comment about keeping the tags in the body.
maybe easier to verify later body by body
rather than trying to match nodes & subnodes.
funny how a comment can change your perspective
of the problem from mostly chaos back to mostly order.
the really funny part is, as I pictured the node headline
it was just descriptive, the tags were in the body
but the confusion won.

the html import in Leo as many know is to a single node.
so many parsing/web scraping projects would go 
that much easier if you could isolate sections 
via a Leo import so it must happen under 
program control to be useful and non tedious.
will have to try again w/elementtree.
its parser will do all the work I didn't want to
have to do building a stack of elements and bodys.
sometimes it pays to wait for a better solution.
well formed html is not the norm.
maybe you will post your code first and I can adapt it!
#@nonl
#@-node:ekr.20050228095252.1:@url http://www.xml.com/pub/a/2003/02/12/py-xml.html
#@+node:ekr.20050228095252.2:@url http://gnosis.cx
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3019245
By: paulpaterson

I haven't used ElementTree but I do make extensive use of the gnosis XML tools.
The XML_Objectify function turns any XML into an object where the attributes
are child properties and nodes.

Just another toolkit to consider!

http://gnosis.cx/download/Gnosis_Utils-current.tar.gz
#@+node:ekr.20050228095252.3:@url http://gnosis.cx/download/Gnosis_Utils-current.tar.gz
#@-node:ekr.20050228095252.3:@url http://gnosis.cx/download/Gnosis_Utils-current.tar.gz
#@-node:ekr.20050228095252.2:@url http://gnosis.cx
#@-node:ekr.20050228095252:xml tools mentioned in posts
#@-node:ekr.20031218072017.392:Python Notes...
#@+node:ekr.20050306070535:Tk Notes
@killcolor
#@nonl
#@+node:ekr.20050306070535.1:*** How to use Tk bindtags
http://sourceforge.net/forum/message.php?msg_id=1864584
By: btheado

If you don't already know about Tk's bindtags command, then check it out.  It
should make things like this easy.  It basically allows you to dynamically add
and remove a whole group of bindings all at once without affecting any other
bindings.

i.e. if you have a window called .text:

# Enter escape mode
bind .text <Esc> {
    # add EscapeMode to .text's list of bindings by
    # using the bindtags command (not shown)
}

bind EscapeMode <Up> {
    # Add special escape mode up handling code here
    break
}
bind EscapeMode <Down> {
    # Add special escape mode down handling code
    break
}
etc.

# Leave escape mode
bind EscapeMode <Esc> {
    # remove EscapeMode from .text's list of bindings
    # by using the bindtags command (not shown)
}

See (http://wiki.tcl.tk/bindtags) for a page with more information about bindtags
and a link to the bindtags man page.

I just wanted you to be aware of this functionality if and when you do tackle
this.  I have found Tk's event handling, bindtags functionality very powerful,
easy to use, and quite elegant for the coding I've done.

Brian Theado
#@nonl
#@-node:ekr.20050306070535.1:*** How to use Tk bindtags
#@+node:ekr.20050306070535.2:Delay body display so alt+arrow keys aren't slowed (threaded colorizer?)
We need a delay on body display so alt+arrow keys arent slowed down while navigating.

EKR: Alt-Up and Alt-Down are bound to Go To Next/Prev visible. The idea is that
if we don't display the body text these keys will work faster.
#@nonl
#@-node:ekr.20050306070535.2:Delay body display so alt+arrow keys aren't slowed (threaded colorizer?)
#@+node:ekr.20050306070535.3:How to detect changes in text
http://sourceforge.net/forum/message.php?msg_id=1864564
By: btheado

WAS:RE: Leo 3.10 comments
edream wrote:

>This is due to apparent glitches in the Tk event dispatching. The problem is
that pressing a control or alt or shift key _all by themselves_ will generate
keypress events that are passed on to Leo's key handlers

This should be easy to make simpler--just bind an empty script to <Alt-KeyPress>,
<Shift-KeyPress>, etc.  Tk chooses the most specific event it can find, so the
more general <KeyPress> handler will not fire.

On a broader note, when programming the text widget in Tcl/Tk, watching key
events is not the easiest way to detect changes in the text.  The only way the
text in a text widget can change is if either the delete or the insert subcommands
(methods) are called.  Any keypresses that end up changing text will have called
one of these subcommands.

So the simplest way to detect changes is to just intercept the calls to insert
and delete.  In Tcl/Tk intercepting these calls is pretty straightforward. 
I don't know if the same is true in Tkinter.

Also note the text widget in Tk8.4 (http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm#M72)
has a built-in way of seeing if the text has changed

Brian Theado
#@nonl
#@-node:ekr.20050306070535.3:How to detect changes in text
#@-node:ekr.20050306070535:Tk Notes
#@+node:ekr.20031218072017.434:Unused code
@ignore
@language python
@color
#@nonl
#@+node:ekr.20051026144126:From idle key handlers
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event,undoType='Typing'):
    
    '''Handle any key press event in the body pane.'''

    # New in Leo 4.4.  May be called with event = None
    c = self.c
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    # g.trace(repr(ch),repr(event.keysym))

    # This translation is needed on MacOS.
    if ch == '':
        d = {'Return':'\r', 'Tab':'\t', 'BackSpace':chr(8)}
        ch = d.get(event.keysym,'')

    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()
        
    # We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
    self.c.frame.body.colorizer.interrupt()
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,ch)
#@nonl
#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)>0:
        << trace the key event >>

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.1331:onBodyWillChange
# Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""

    g.trace(g.callerList(5))
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.body.colorizer.interrupt()
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)
#@nonl
#@-node:ekr.20031218072017.1331:onBodyWillChange
#@+node:ekr.20031218072017.1321:idle_body_key & helpers
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"
    g.trace(repr(ch),g.callerList(5))

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        << handle special characters >>
    << set s to widget text, removing trailing newlines if necessary >>
    # g.trace(repr(ch),undoType)
    if undoType:
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20050526080309:<< handle special characters >>
d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width < 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width < 0:
    << handle backspace with negative tab_width >>
#@nonl
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
            newSel = c.frame.body.getTextSelection() # Fixes crasher in undo logic.
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@-node:ekr.20050526080309:<< handle special characters >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # g.trace('no real change')
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False
c.beginUpdate()
try:
    # Update dirty bits.
    if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
        redraw_flag = True
    # Update icons.
    val = p.computeIcon()
    # During unit tests the node may not have been drawn,
    # So p.v.iconVal may not exist yet.
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@+node:ekr.20031218072017.1324:doAutoIndent (David McNab)
def doAutoIndent (self,p,removeTrailing,tab_width,undoType):
    
    __pychecker__ = '--no-argsused' # 'undoType' unused, but must be present.
    
    c = self.c
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # g.trace(repr(s))
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False
            
    return removeTrailing
#@nonl
#@-node:ekr.20031218072017.1324:doAutoIndent (David McNab)
#@+node:ekr.20031218072017.1325:convertBlanksToTabs
def convertBlanksToTabs (self,tab_width):

    c = self.c
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1:
        << convert tab no matter where it is >>
    else:
        << convert only leading tabs >>
#@nonl
#@+node:ekr.20050526081024:<< convert tab no matter where it is >>
w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024:<< convert tab no matter where it is >>
#@+node:ekr.20050526081024.1:<< convert only leading tabs >>
# Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024.1:<< convert only leading tabs >>
#@-node:ekr.20031218072017.1325:convertBlanksToTabs
#@-node:ekr.20031218072017.1321:idle_body_key & helpers
#@+node:ekr.20051027045029:OLDidle_head_key
def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c ; u = c.undoer

    if not p or not p.isCurrentPosition():
        return "break"

    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    head = g.toUnicode(p.headString() or u'',"utf-8")
    done = ch in ('\r','\n')
    if done:
        << set the widget text to head >>
    << set s to the widget text >>
    changed = s != head
    if changed:
        undoData = u.beforeChangeNodeContents(p)
        << update p >>
        u.afterChangeNodeContents(p,'Change Headline',undoData,dirtyVnodeList=dirtyVnodeList)
    if done or changed:
        << reconfigure p and all nodes joined to p >>
        << update the screen >>

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
    return "break"
#@nonl
#@+node:ekr.20051027045029.1:<< set the widget text to head >>
self.setText(edit_text,head)
edit_text.mark_set("insert",index)
#@nonl
#@-node:ekr.20051027045029.1:<< set the widget text to head >>
#@+node:ekr.20051027045029.2:<< set s to the widget text >>
s = edit_text.get("1.0","end")

g.trace(repr(s),g.callerList(5))

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i > -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) > limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')
#@nonl
#@-node:ekr.20051027045029.2:<< set s to the widget text >>
#@+node:ekr.20051027045029.3:<< update p >>
c.beginUpdate()
try: # In update...
    # Update changed bit.
    if not c.changed: c.setChanged(True)
    # We must call p.setDirty even if p is dirty!
    dirtyVnodeList = p.setDirty()
    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s)
    edit_text.mark_set("insert",index)
finally:
    c.endUpdate(False) # do not redraw now.
#@nonl
#@-node:ekr.20051027045029.3:<< update p >>
#@+node:ekr.20051027045029.4:<< reconfigure p and all nodes joined to p >>
# Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))
#@nonl
#@-node:ekr.20051027045029.4:<< reconfigure p and all nodes joined to p >>
#@+node:ekr.20051027045029.5:<< update the screen >>
if done:
    # g.trace("done")
    c.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20051027045029.5:<< update the screen >>
#@-node:ekr.20051027045029:OLDidle_head_key
#@-node:ekr.20051026144126:From idle key handlers
#@+node:ekr.20051028165714:From temacs
#@+node:ekr.20051012124209:From leoEditCommands...
#@+node:ekr.20050920084036.129:zapTo
def zapTo (self,event):

    k = self.k ; c = k.c ; w = event.widget
    s = string.ascii_letters+string.digits+string.punctuation

    if len(event.char) != 0 and event.char in s:
        k.setState('zap',0)
        i = w.search(event.char,'insert',stopindex='end')
        k.resetLabel()
        if i:
            t = w.get('insert','%s+1c' % i)
            c.killBufferCommands.addToKillBuffer(t)
            w.delete('insert','%s+1c' % i)

    return 'break'
#@-node:ekr.20050920084036.129:zapTo
#@+node:ekr.20050927102645:From bufferCommandsClass
#@+node:ekr.20050920084036.46:setBufferListGetter
def setBufferListGetter (self,buffer,method):

    #Sets a method that returns a buffer name and its text, and its insert position.
    self.bufferListGetters [buffer] = method
#@nonl
#@-node:ekr.20050920084036.46:setBufferListGetter
#@+node:ekr.20050920084036.47:setBufferSetter
def setBufferSetter( self, buffer, method ):

    #Sets a method that takes a buffer name and the new contents.
    self.bufferSetters[ buffer ] = method
#@nonl
#@-node:ekr.20050920084036.47:setBufferSetter
#@+node:ekr.20050920084036.48:getBufferDict
def getBufferDict (self,event):

    w = event.widget
    meth = self.bufferListGetters [w]
    return meth()
#@nonl
#@-node:ekr.20050920084036.48:getBufferDict
#@+node:ekr.20050920084036.49:setBufferData
def setBufferData( self, event, name, data ):
    
    w = event.widget
    meth = self.bufferSetters[ w ]
    meth( name, data )
#@nonl
#@-node:ekr.20050920084036.49:setBufferData
#@+node:ekr.20050920084036.50:setBufferGoto
def setBufferGoto( self, w, method ):

    self.bufferGotos[ w ] = method
#@nonl
#@-node:ekr.20050920084036.50:setBufferGoto
#@+node:ekr.20050920084036.51:setBufferDelete
def setBufferDelete( self, w, method ):
    
    self.bufferDeletes[ w ] = method
#@nonl
#@-node:ekr.20050920084036.51:setBufferDelete
#@+node:ekr.20050920084036.52:setBufferRename
def setBufferRename( self, buffer, method ):
    
    self.renameBuffers[ buffer ] = method
#@nonl
#@-node:ekr.20050920084036.52:setBufferRename
#@-node:ekr.20050927102645:From bufferCommandsClass
#@+node:ekr.20050920085536.43:findItemsWithPrefix (Not used)
def findItemsWithPrefix (self,s,aList=None):

    '''This method returns a sorted list of matches.
    
    It returns the list of matches and the longest common prefix of all the matches.'''

    k = self ; c = k.c

    common_prefix = ''

    if s: pmatches = [a for a in aList if a.startswith(s)]
    else: pmatches = []
        
    if pmatches:
        s = pmatches[0] ; done = False
        for i in xrange(len(s)):
            prefix = s[:i]
            for z in pmatches:
                if not z.startswith(prefix):
                    done = True ; break
            if done:
                break
            else:
                common_prefix = prefix
        pmatches.sort()

    # g.trace(repr(s),len(pmatches))
    return pmatches,common_prefix
#@nonl
#@-node:ekr.20050920085536.43:findItemsWithPrefix (Not used)
#@+node:ekr.20050920084036.73:startGoto (No longer used)
def startGoto (self,event,ch=False):

    k = self.k ; state = k.getState('goto')
    k.setState('goto',state+1,handler=self.Goto)
    k.setLabelBlue('')
    return 'break'
#@nonl
#@-node:ekr.20050920084036.73:startGoto (No longer used)
#@+node:ekr.20050920084036.143:Goto (no longer used)
def Goto (self,event):

    k = self.k ; w = event.widget
    if event.keysym == 'Return':
        i = k.getLabel()
        k.resetLabel()
        state = k.getState('goto')
        k.setState('goto',0)
        if i.isdigit():
            if state == 1:
                w.mark_set('insert','%s.0' % i)
            elif state == 2:
                w.mark_set('insert','1.0 +%sc' % i)
            w.event_generate('<Key>')
            w.update_idletasks()
            w.see('insert')
    else:
        k.updateLabel(event)

    return 'break'
#@nonl
#@-node:ekr.20050920084036.143:Goto (no longer used)
#@+node:ekr.20050930091642:walkKB
def walkKB( self, event, frm, which ):# kb = self.iterateKillBuffer() ):

    k = self.k ; w = event.widget
    i = w.index( 'insert' )
    t , t1 = i.split( '.' )
    clip_text = self.getClipboard( w )    
    if self.killbuffer or clip_text:
        if which == 'c':
            self.reset = True
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()
            w.tag_delete( 'kb' )
            w.insert( frm, txt, ('kb') )
            w.mark_set( 'insert', i )
        else:
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()
            t1 = str( int( t1 ) + len( txt ) )
            r = w.tag_ranges( 'kb' )
            if r and r[ 0 ] == i:
                w.delete( r[ 0 ], r[ -1 ] )
            w.tag_delete( 'kb' )
            w.insert( frm, txt, ('kb') )
            w.mark_set( 'insert', i )
    return k._tailEnd( w )
#@nonl
#@-node:ekr.20050930091642:walkKB
#@+node:ekr.20050930095323:killSentenceHelper
def killSentenceHelper (self,event,back):
    w = event.widget
    i = w.search('.','insert',stopindex='end')
    if back:
        i = w.search('.','insert',backwards=True,stopindex='1.0')
        if not i: return 'break'
        i2 = w.search('.',i,backwards=True,stopindex='1.0') or '1.0'
        return self.kill(event,i2,'%s + 1c' % i)
    else:
        i  = w.search('.','insert',stopindex='end')
        i2 = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i)

    return 'break'
#@nonl
#@-node:ekr.20050930095323:killSentenceHelper
#@+node:ekr.20050920085536.69:tailEnd...
#@+node:ekr.20050920114619.1:utTailEnd
def utTailEnd (self,event=None):

    '''A method that Emacs will call with its _tailEnd method'''
    
    k = self ; c = k.c ; w = c.frame.bodyCtrl

    # w.event_generate('<Key>')
    w.focus_force()
    w.update_idletasks()
    # c.frame.bodyWantsFocus(w,later=True,tag='utTailEnd')

    return 'break'
#@nonl
#@-node:ekr.20050920114619.1:utTailEnd
#@+node:ekr.20050920085536.70:_tailEnd
def _tailEnd (self,w):
    
    '''This returns the tailEnd function that has been configure for the w parameter.'''
    
    k = self
    func = k.tailEnds.get(w)
    if func:
        # g.trace(func)
        return func(w)
    else:
        return 'break'
#@-node:ekr.20050920085536.70:_tailEnd
#@+node:ekr.20050920085536.71:setTailEnd
def setTailEnd (self,w,tailCall):

    '''This method sets a ending call that is specific for a particular Text widget.
       Some environments require that specific end calls be made after a keystroke
       or command is executed.'''

    k = self

    k.tailEnds [w] = tailCall
#@-node:ekr.20050920085536.71:setTailEnd
#@-node:ekr.20050920085536.69:tailEnd...
#@+node:ekr.20050920084036.44:setInBufferMode
def setInBufferMode (self,event,which):
    
    k = self.k ; w = event.widget

    k.keyboardQuit(event)
    k.setState('bufferList','start%s' % which)
    k.setLabelBlue('Choose Buffer Name: ',protect=True)
    self.bufferDict = self.getBufferDict(event)

    return 'break'
#@nonl
#@-node:ekr.20050920084036.44:setInBufferMode
#@+node:ekr.20050920084036.256:executeRegister (not used)
def executeRegister (self,event):
    
    k = self.k

    if self.method:
        self.method(event)

        if self.registerMode != 0:
            k.keyboardQuit(event)
#@nonl
#@-node:ekr.20050920084036.256:executeRegister (not used)
#@-node:ekr.20051012124209:From leoEditCommands...
#@+node:ekr.20051012141518:From bufferCommandsClass
#@+node:ekr.20050927101829.2:buildBufferList (not used)
def buildBufferList (self):

    '''Build a buffer list from an outline.'''
    
    self.positions =  {}
    self.tnodes = {}

    for p in c.allNodes_iter():
    
        t = p.v.t ; h = t.headString()
        
        theList = self.positions.get(h,[])
        theList.append(p.copy())
        self.positions [h] = theList
        
        self.tnodes [h] = t.bodyString()
#@nonl
#@-node:ekr.20050927101829.2:buildBufferList (not used)
#@+node:ekr.20050920084036.41:bufferList (to be deleted)
def bufferList (self,event):
    
    k = self.k
    state = k.getState('bufferList')
    if state.startswith('start'):
        state = state[5:]
        k.setState('bufferList',state)
        k.setLabel('')
    if event.keysym=='Tab':
        stext = k.getLabel().strip()
        if self.bufferTracker.prefix and stext.startswith(self.bufferTracker.prefix):
            k.setLabel(self.bufferTracker.next())#get next in iteration
        else:
            prefix = k.getLabel()
            pmatches =[]
            for z in self.bufferDict.keys():
                if z.startswith(prefix):
                    pmatches.append(z)
            self.bufferTracker.setTabList(prefix,pmatches)
            k.setLabel(self.bufferTracker.next())#begin iteration on new lsit
    elif event.keysym=='Return':
       bMode = k.getState('bufferList')
       c.commandsDict[bMode](event,k.getLabel())
    else:
        self.update(event)
#@nonl
#@-node:ekr.20050920084036.41:bufferList (to be deleted)
#@+node:ekr.20051012133615:switchToBuffer (not used)
def switchToBuffer (self,event,name):

    method = self.bufferGotos [event.widget]
    self.keyboardQuit(event)
    method(name)
    return 'break'
#@-node:ekr.20051012133615:switchToBuffer (not used)
#@-node:ekr.20051012141518:From bufferCommandsClass
#@+node:ekr.20050920084036.251:_ToReg (not used)
def _ToReg (self,event,which):

    if not self._chckSel(event):
        return
    if self._checkIfRectangle(event):
        return

    if event.keysym in string.letters:
        event.keysym = event.keysym.lower()
        w = event.widget
        if not self.registers.has_key(event.keysym):
            self.registers [event.keysym] = ''
        txt = w.get('sel.first','sel.last')
        rtxt = self.registers [event.keysym]
        if self.which == 'p':
            txt = txt + rtxt
        else:
            txt = rtxt + txt
        self.registers [event.keysym] = txt
#@nonl
#@-node:ekr.20050920084036.251:_ToReg (not used)
#@-node:ekr.20051028165714:From temacs
#@+node:ekr.20051106101758:From pasteText
# No longer needed in the New World Order.
#@nonl
#@+node:ekr.20051103160025:<< paste the text into w >>
ch  = g.app.gui.getTextFromClipboard()
i,j = g.app.gui.getTextSelection(w)

i = int(i.split('.')[1])
j = int(j.split('.')[1])
s = w.get('1.0','end')

if s.endswith('\n'):
    if len(s) > 1: s = s[:-1]
    else:          s = ''

if i != j:
    s = s[:i] + ch + s[j:]
else:
    i = w.index('insert')
    i = int(i.split('.')[1])
    s = s[:i] + ch + s[i:]

# g.trace(i,j,repr(s))
c.frame.widgetWantsFocus(w,later=False)
w.delete('1.0','end')
w.insert('1.0',s)
w.configure(width=f.tree.headWidth(s=s))
#@nonl
#@-node:ekr.20051103160025:<< paste the text into w >>
#@-node:ekr.20051106101758:From pasteText
#@+node:ekr.20051120091258:pasteIntoWidget
def pasteIntoWidget (self,s,w):
    
    f = self ; c = f.c

    i,j = g.app.gui.getTextSelection(w)
    i = int(i.split('.')[1])
    j = int(j.split('.')[1])
    s2 = w.get('1.0','end')
    
    if i != j:
        s = s2[:i] + s + s2[j:]
    else:
        i = w.index('insert')
        i = int(i.split('.')[1])
        s = s2[:i] + s + s2[i:]
    
    c.frame.widgetWantsFocus(w)
    w.delete('1.0','end')
    w.insert('1.0',s)
    j.app.gui.set
   
#@nonl
#@-node:ekr.20051120091258:pasteIntoWidget
#@+node:ekr.20051125081431.1:No longer used re key handling
#@+node:ekr.20051026083733:updateBody (no longer used)
def updateBody (self,event,w,undoType,
    oldSel=None,oldYview=None,newSel=None,oldText=None):

    '''Update Leo after the body have been changed.'''
    
    # g.trace(g.callers(7))
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    orignalText = oldText # for use by undo.
    removeTrailing = None # A signal to compute it later.
    # g.trace(repr(ch))
    oldSel = g.app.gui.getTextSelection(w)
    oldText = p.bodyString()
    if ch == '\t':
        self.updateTab(p,w)
    # elif ch == '\b':
        # # Not strictly correct: we should test for present delete binding...
        # self.updateBackspace(p,w)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j: w.delete(i,j)
        w.insert(i,ch)
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return # The hook claims to have handled the event.
    # Update the text and handle undo.
    if not newSel: newSel = g.app.gui.getTextSelection(w)
    newText = w.get('1.0','end')
    << remove extra Trailing newlines >> # Same logic as always.
    w.see(w.index('insert'))
    if newText == oldText:
        g.trace('no change')
        return
    c.undoer.setUndoTypingParams(p,undoType,
        orignalText or oldText,newText,oldSel,newSel,oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed: c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
#@nonl
#@-node:ekr.20051026083733:updateBody (no longer used)
#@+node:ekr.20050929163010:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):

    c = self.c ; body = c.frame.body ; p = c.currentPosition()
    
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = w and hasattr(w,'_name') and w._name or ''
    oldText = w.get('1.0','end')
    
    if body.hasTextSelection():
        oldSel = body.getTextSelection()
        body.deleteTextSelection()
    else:
        i = w.index('insert')
        g.trace(i)
        oldSel = (i,i)
        w.delete('%s-1c' % (i), '%s' % (i))
    
    # Don't assume the body has focus.
    if name.startswith('body'):
        body.onBodyChanged(p,"Delete",oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        c.frame.tree.onHeadChanged(p,'Delete')
#@nonl
#@-node:ekr.20050929163010:backwardDeleteCharacter
#@+node:ekr.20031218072017.2863:c.delete
def delete(self):

    c = self ; p = c.currentPosition()
    body = c.frame.body
    w = body.bodyCtrl.focus_get()
    
    # Don't assume the body has focus.
    if w == body.bodyCtrl:
        oldSel = body.getTextSelection()
        body.deleteTextSelection()
        body.onBodyChanged(p,"Delete",oldSel=oldSel)
    else:
        # Assume we are changing a headline...
        # This works even if the assumption is incorrect.
        start,end=g.app.gui.getTextSelection(w)
        g.app.gui.replaceSelectionRangeWithText(w,start,end,'')
        c.frame.tree.onHeadChanged(p,'Delete')
#@nonl
#@-node:ekr.20031218072017.2863:c.delete
#@-node:ekr.20051125081431.1:No longer used re key handling
#@+node:ekr.20051201111822:app.finishCreateCommanderAndFrame (not used)
def finishCreateCommanderAndFrame (self,c):
    
    '''Update all settings after possibly reading the @settings node.'''
    
    pass
#@nonl
#@-node:ekr.20051201111822:app.finishCreateCommanderAndFrame (not used)
#@+node:ekr.20051214130017:OnXXXFromMenu
#@+node:ekr.20051011072903.1:OnCopyFromMenu
if 0:
    def OnCopyFromMenu (self):
    
        ''' Called **only** when invoked using the menu instead of a shortcut.'''
        
        f = self ; c = f.c
        w = f.getFocus() ; name = hasattr(w,'_name') and w._name or ''
    
        if name.startswith('body'):
            w.event_generate(g.virtual_event_name("Copy"))
        else:
            # Necessary when not using shortcut keys.
            w.event_generate(g.virtual_event_name("Copy"))
            
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.1:OnCopyFromMenu
#@+node:ekr.20051011072049.1:OnCutFromMenu
if 0:
    def OnCutFromMenu (self):
    
        ''' Called **only** when invoked using the menu instead of a shortcut.'''
    
        f = self ; c = f.c ; p = c.currentPosition()
        w = f.getFocus() ; name = hasattr(w,'_name') and w._name or ''
    
        if name.startswith('body'):
            # Let body key handler do the cut!
            oldSel = g.app.gui.getTextSelection(w)
            oldText = w.get('1.0','end')
            w.event_generate(g.virtual_event_name("Cut"))
            c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
            c.requestRecolor()
        else:
            # Necessary
            w.event_generate(g.virtual_event_name("Cut"))
            f.tree.onHeadChanged(p,'Cut')
            
OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.1:OnCutFromMenu
#@+node:ekr.20051011072903.4:OnPasteFromMenu
if 0:
    def OnPasteFromMenu (self):
        
        ''' Called **only** when invoked using the menu instead of a shortcut.'''
        
        f = self ; c = f.c
        w = f.getFocus() ; name = hasattr(w,'_name') and w._name or ''
    
        if name.startswith('body'):
            # Let body key handler do the paste!
            oldSel = g.app.gui.getTextSelection(w)
            oldText = w.get('1.0','end')
            w.event_generate(g.virtual_event_name("Paste"))
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
            c.requestRecolor()
        else:
            # Strip trailing newlines so the truncation doesn't cause confusion.
            s = s1 = g.app.gui.getTextFromClipboard()
            while s and s[-1] in ('\n','\r'):
                s = s[:-1]
            if s != s1:
                g.app.gui.replaceClipboardWith(s)
            g.app.unitTestDict ['headWidth'] = True
            w.configure(width=f.tree.headWidth(s=s))
            w.event_generate(g.virtual_event_name("Paste"))
            f.tree.onHeadChanged(c.currentPosition(),'Paste')
            c.redraw_now()
            
OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.4:OnPasteFromMenu
#@-node:ekr.20051214130017:OnXXXFromMenu
#@+node:ekr.20051215170055:From bufferCommandsClass
#@+node:ekr.20050927101829.4:gotoNode (not used!)
def gotoNode (self,name):
    
    c = self.c
    c.beginUpdate()
    try:
        if self.positions.has_key(name):
            posis = self.positions [name]
            if len(posis) > 1:
                tl = Tk.Toplevel()
                #tl.geometry( '%sx%s+0+0' % ( ( ms[ 0 ]/3 ) *2 , ms[ 1 ]/2 ))
                tl.title("Select node by numeric position")
                fr = Tk.Frame(tl)
                fr.pack()
                header = Tk.Label(fr,text='select position')
                header.pack()
                lbox = Tk.Listbox(fr,background='white',foreground='blue')
                lbox.pack()
                for z in xrange(len(posis)):
                    lbox.insert(z,z+1)
                lbox.selection_set(0)
                def setPos (event):
                    cpos = int(lbox.nearest(event.y))
                    tl.withdraw()
                    tl.destroy()
                    if cpos != None:
                        self.gotoPosition(c,posis[cpos])
                lbox.bind('<Button-1>',setPos)
                geometry = tl.geometry()
                geometry = geometry.split('+')
                geometry = geometry [0]
                width = tl.winfo_screenwidth() / 3
                height = tl.winfo_screenheight() / 3
                geometry = '+%s+%s' % (width,height)
                tl.geometry(geometry)
            else:
                pos = posis [0]
                self.gotoPosition(c,pos)
        else:
            pos2 = c.currentPosition()
            tnd = leoNodes.tnode('',name)
            pos = pos2.insertAfter(tnd)
            self.gotoPosition(c,pos)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20050927101829.4:gotoNode (not used!)
#@+node:ekr.20050927101829.5:gotoPosition
def gotoPosition (self,c,pos):

    c.frame.tree.expandAllAncestors(pos)
    c.selectPosition(pos)
#@nonl
#@-node:ekr.20050927101829.5:gotoPosition
#@+node:ekr.20050927101829.6:deleteNode (not used?)
def deleteNode (self,name):
    
    c = self.c

    c.beginUpdate()
    try:
        if self.positions.has_key(name):
            pos = self.positions [name]
            cpos = c.currentPosition()
            pos.doDelete()
            c.selectPosition(cpos)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20050927101829.6:deleteNode (not used?)
#@+node:ekr.20050927101829.7:renameNode (not used?)
def renameNode (self,name):
    
    c = self.c

    c.beginUpdate()
    try:
        pos = c.currentPosition()
        pos.setHeadString(name)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20050927101829.7:renameNode (not used?)
#@-node:ekr.20051215170055:From bufferCommandsClass
#@+node:ekr.20051221073339:Settings dialog classes
#@+node:ekr.20041225063637.78:class settingsTree (leoTkinterTree.leoTkinterTree)
class settingsTree (leoTkinterTree.leoTkinterTree):

    @others
#@nonl
#@+node:ekr.20041225063637.79:ctor (settingsTree)
def __init__(self,c,frame,canvas,controller):
    
    # Init the base class.
    leoTkinterTree.leoTkinterTree.__init__(self,c,frame,canvas)
    
    self.controller = controller
    self.old_p = None
    self.setBindings() # New in 4.4
#@nonl
#@-node:ekr.20041225063637.79:ctor (settingsTree)
#@+node:ekr.20041225063637.80:Selecting & editing...
# This code is different because this class has a different current position.

#@+node:ekr.20041225123250:configureTextState
def configureTextState (self,p):
    
    if p:
        t = self.getTextWidget(p)
        if t:
            if p.isCurrentPosition():
                self.setSelectColors(t)
            else:
                self.setUnselectColors(t)
#@nonl
#@+node:ekr.20041225063637.89:setSelectColors
def setSelectColors (self,textWidget): 
    
    c = self.c

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'white'

    try:
        textWidget.configure(state="disabled",
        highlightthickness=0,fg=fg,bg=bg,
        selectforeground=fg,selectbackground=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20041225063637.89:setSelectColors
#@+node:ekr.20041225063637.90:setUnselectColors
def setUnselectColors (self,textWidget): 
    
    c = self.c
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'

    try:
        textWidget.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20041225063637.90:setUnselectColors
#@-node:ekr.20041225123250:configureTextState
#@+node:ekr.20041225063637.81:endEditLabel
def endEditLabel (self):
    
    pass # Editing is not allowed.
#@nonl
#@-node:ekr.20041225063637.81:endEditLabel
#@+node:ekr.20041225063637.82:editLabel
def editLabel (self,p):
    
    pass # Editing is not allowed.
#@nonl
#@-node:ekr.20041225063637.82:editLabel
#@+node:ekr.20041225063637.83:tree.select (config tree)
def select (self,p,updateBeadList=True):
    
    __pychecker__ = '--no-argsused' # updateBeadList required for compatibility.

    old_p = self.old_p
    
    # g.trace(p.headString())

    # Unselect the old
    if old_p:
        t = self.getTextWidget(old_p)
        if t: self.setUnselectColors(t)

    # Select the new
    t = self.getTextWidget(p)
    if t: self.setSelectColors(t)
    
    # N.B. Do not change the commander's notion of the present position.
    self.old_p = p

    self.controller.onTreeClick(p)
    
    # For the UNL plugin.
    g.doHook("select2",c=p.c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
#@nonl
#@-node:ekr.20041225063637.83:tree.select (config tree)
#@+node:ekr.20041225063637.91:getTextWidget
def getTextWidget (self,p):
    
    # The data is create in newText.
    data = self.visibleText.get(p.v)
    if data:
        data = data[0] # A list of one element.
        # g.trace(len(data),data)
        p2,t,theId = data
        return t
    else:
        return None
#@nonl
#@-node:ekr.20041225063637.91:getTextWidget
#@-node:ekr.20041225063637.80:Selecting & editing...
#@+node:ekr.20041225063637.92:Event handlers...
#@+node:ekr.20041225063637.93:expandAllAncestors
def expandAllAncestors (self,p):
    
    # This would be harmful because p is always c.currentPosition().

    return False # redraw_flag
#@nonl
#@-node:ekr.20041225063637.93:expandAllAncestors
#@+node:ekr.20041225063637.94:onClickBoxClick
def onClickBoxClick (self,event):
    
    tree = self

    p = self.eventToPosition(event)
    if not p: return

    # g.trace(p.isExpanded(),p.headString())

    if p.isExpanded(): p.contract()
    else:              p.expand()

    tree.active = True
    tree.redraw_now()
    tree.select(p)
    
#@nonl
#@-node:ekr.20041225063637.94:onClickBoxClick
#@-node:ekr.20041225063637.92:Event handlers...
#@+node:ekr.20041225063637.95:drawTopTree
def drawTopTree (self):
    
    """Draw the settings tree, i.e., the tree rooted at self.controller.settingsPosition()."""
    
    canvas = self.canvas
    p = self.controller.settingsPosition()
    self.redrawing = True
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    self.prevPositions = g.app.positions
    
    # Draw only the settings tree
    self.drawTree(p,self.root_left,self.root_top,0,0)

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.
    self.redrawing = False
#@nonl
#@-node:ekr.20041225063637.95:drawTopTree
#@-node:ekr.20041225063637.78:class settingsTree (leoTkinterTree.leoTkinterTree)
#@+node:ekr.20041225063637.10:class settingsController
class settingsController:
    
    @others
#@nonl
#@+node:ekr.20041225063637.13: ctor (settingsController)
def __init__ (self,c,replaceBody=True):
    
    self.createSummaryNode = True # Works either way.

    << init ivars >>
    << define Tk color names>>

    if not Pmw:
        s = 'Setting dialog requires Pmw: see http://pmw.sourceforge.net'
        g.es_print(s,color='red')
        return
    
    # Reread the settings files so any changes will take effect.
    g.app.config.readSettingsFiles(c.fileName(),verbose=True)
    self._settingsPosition = p = self.createSettingsTree()
    self.parser = settingsDialogParserClass(c,p,self)
    << set background color for widgets >>
    c.disableCommandsMessage = 'All commands disabled while settings dialog is open'
    if self.replaceBody:
        self.replaceBodyWithDialog()
        self.log = g.app.log
        self.tree.redraw_now() # To allocate widgets.
        self.tree.select(p)
    else:
        d = self.createStandAloneDialog()
        self.log = self.logClass(self.logText)
        self.tree.redraw_now() # To allocate widgets.
        self.tree.select(p)
        self.center()
        g.app.gui.widgetWantsFocus(None,None)
        if self.modal: d.activate()
#@nonl
#@+node:ekr.20050123194330:<< init ivars >>
self._settingsPosition = None
self.alterComments = None # position for which to alter comments.
self.alteredCommentsString = None
self.c = c
self.buttonNames = ('OK', 'Cancel','Apply','Revert')
self.colorSettingDict = {} # Contains entries for all changed colors.
self.commentWidget = None
self.commonBackground = None
self.dialog = None
self.initValueDict = {} # Initial value of settings in present pane.
self.fileValueDict = {} # Values of settings written to file.
self.filesInfoDict = {} # Info about all settings file in the settings outline.
    # Keys are positions, values are dicts giving info for a setting file.
self.fontRefs = {} # A dict to retain references to fonts.
self.modal = False
self.old_p = c.currentPosition()
self.old_root = c.rootPosition()
self.p = None # Used to revert settings.
self.panes = {}
self.parser = None
self.replaceBody = replaceBody
self.sc = None
self.setterLabel = None
self.suppressComments = None # position for which to suppress comments.
self.title = "Settings for %s" % g.shortFileName(c.fileName())
self.top = None
self.tree = None
#@nonl
#@-node:ekr.20050123194330:<< init ivars >>
#@+node:ekr.20050129111522:<< define Tk color names >>
self.colorNamesList = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
#@nonl
#@-node:ekr.20050129111522:<< define Tk color names >>
#@+node:ekr.20050121105232:<< set background color for widgets >>
if 0:
    # Get the color from the background color of the body text widget.
    self.commonBackground = c.frame.body.bodyCtrl.cget('background')
    
else:
    # 'LightSteelBlue1' # too blue.
    # 'gray80' # too dark.
    # 'gray90' # Possible: very light.
    # '#f2fdff' # Same as log window.  Too cute.
    
    self.commonBackground = 'gray90'
#@nonl
#@-node:ekr.20050121105232:<< set background color for widgets >>
#@-node:ekr.20041225063637.13: ctor (settingsController)
#@+node:ekr.20050212153515:replaceBodyWithDialog
def replaceBodyWithDialog (self):
    
    c = self.c ; bg = self.commonBackground
    
    << replace the body pane with the outer dialog frame >>
    << replace tree pane with settings tree >>
    << add buttons and label to interior >>
    << add setterCanvas to interior >>
#@nonl
#@+node:ekr.20041225071604:<< replace the body pane with the outer dialog frame >>
body = c.frame.component('body')
packer = body.getPacker()
unpacker = body.getUnpacker()

# The new frame must be a child of splitter1Frame.
parentFrame = c.frame.component('splitter1Frame').getFrame()
self.top = interior = Tk.Frame(parentFrame,background=bg)

c.frame.componentClass(c,'settingDialogFrame',interior,self,packer,unpacker)
c.frame.replaceBodyPaneWithComponent('settingDialogFrame')
#@nonl
#@-node:ekr.20041225071604:<< replace the body pane with the outer dialog frame >>
#@+node:ekr.20041225090725:<< replace tree pane with settings tree >>
tree = c.frame.component('tree')

# The new frame must be a child of splitter2Frame.
splitter2Frame = c.frame.component('splitter2Frame').getFrame()

# Create a Pmw scrolled canvas.
scrolledTreeCanvas = Pmw.ScrolledCanvas(splitter2Frame,
    hscrollmode='none',borderframe=3)

treeCanvas = scrolledTreeCanvas.component('canvas')
treeCanvas.configure(background='white')

# Set canvas.name ivar for chapters.py plugin.
# This must be a tab number.  The number '1' should work well enough.
treeCanvas.name = '1'

# Create the settingsTree component.
c.frame.componentClass(c,'settingsTree',scrolledTreeCanvas,self,
    tree.getPacker(),tree.getUnpacker())

c.frame.replaceTreePaneWithComponent('settingsTree')

self.tree = settingsTree(c,c.frame,treeCanvas,self)
self.tree.setColorFromConfig()
#@nonl
#@-node:ekr.20041225090725:<< replace tree pane with settings tree >>
#@+node:ekr.20041225074713:<< add buttons and label to interior >>
# Put the label on the same line as the buttons.
labelButtonFrame = Tk.Frame(interior,background=bg)
labelButtonFrame.pack(side='top',expand=0,fill='x',pady=4)
buttonFrame = Tk.Frame(labelButtonFrame,background=bg)
buttonFrame.pack(side='left',padx=10)
labelFrame = Tk.Frame(labelButtonFrame,background=bg)
labelFrame.pack(side='left')
self.setterLabel = label = Tk.Label(labelFrame,anchor='w',background=bg)
label.pack(side='right')

w = 6
for name in self.buttonNames:
    w = max(w,len(name))

for name in self.buttonNames:

    def buttonCallback(name=name):
        self.onAnyButton(name)

    b = Tk.Button(buttonFrame,text=name,command=buttonCallback,width=w)
    b.pack(side='left',padx=4)
#@nonl
#@-node:ekr.20041225074713:<< add buttons and label to interior >>
#@+node:ekr.20041225073207.1:<< add setterCanvas to interior>>
self.sc = sc = Pmw.ScrolledCanvas(interior,
    hscrollmode='dynamic',vscrollmode='dynamic',
    canvas_background = bg,
    borderframe=1,
    # A fixed size here works best.
    # Pmw does not handle the changes to the canvas very well.
    usehullsize = 1,
    hull_height = 400,
    hull_width = 800,
)

sc.pack(side='top',expand=1,fill="both")
#@nonl
#@-node:ekr.20041225073207.1:<< add setterCanvas to interior>>
#@-node:ekr.20050212153515:replaceBodyWithDialog
#@+node:ekr.20050212153646:createStandAloneDialog
def createStandAloneDialog (self):
    
    c = self.c ; title = self.title
    bg = self.commonBackground
    
    << create the dialog d >>
    << create paneFrame, a paned widget >>
    << create paneFrame2, a second paned widget >>
    << create outline and log panes in paneFrame2 >>
    << put setterCanvas in paneFrame's setter pane>>
    << put a Text widget in the comment pane >>
    
    return d
#@nonl
#@+node:ekr.20041225063637.14:<< create the dialog d >>
self.dialog = d = Pmw.Dialog(
    c.frame.top,
    title=title,
    buttons=self.buttonNames,
    # It's too upsetting to have a dialog go away on a return key.
    # defaultbutton = 'OK',
    command = self.onAnyButton
)

self.top = hull = d.component('hull')
hull.minsize(800,800)

interior = d.interior()

if 0: # Do immediately
    g.app.gui.attachLeoIcon(hull)
else: # Do at idle time.
    def setIcont(top=hull):
        g.app.gui.attachLeoIcon(top)
    hull.after_idle(setIcont)
#@nonl
#@-node:ekr.20041225063637.14:<< create the dialog d >>
#@+node:ekr.20041225063637.15:<< create paneFrame, a paned widget >>
self.paneFrame = paneFrame = Pmw.PanedWidget(interior,
    separatorthickness = 4, # default is 2
    handlesize = 8, # default is 8
    command = self.onPaneResize
)
paneFrame.pack(expand = 1, fill='both')

for name,minsize,size,label,isSetterLabel in (
    ("splitter2",50,300,None,False),
    ("setter",50,300,"",False),
    ("comments",50,200,None,False),
):
    self.panes[name] = pane = paneFrame.add(name,min=minsize,size=size)
    if label is not None:
        label = Tk.Label(pane,text=label,background=bg)
        label.pack(side = 'top', expand = 0)
        if isSetterLabel:
            self.setterLabel = label

# Set the colors of the separator and handle.
for i in (1,2):
    bar = paneFrame.component('separator-%d' % i)
    bar.configure(background='LightSteelBlue2')
    handle = paneFrame.component('handle-%d' % i)
    handle.configure(background='SteelBlue2')

# g.printDict(self.panes)
#@nonl
#@-node:ekr.20041225063637.15:<< create paneFrame, a paned widget >>
#@+node:ekr.20041225063637.16:<< create paneFrame2, a second paned widget >>
splitter2 = self.panes.get('splitter2')

self.paneFrame2 = paneFrame2 = Pmw.PanedWidget(splitter2,
    separatorthickness = 4, # default is 2
    handlesize = 8, # default is 8
    orient='horizontal',
    command = self.onPaneResize
)
paneFrame2.pack(expand = 1, fill='both')

for name,minsize,size, in (
    ('outline',50,500),
    ('log',50,300),
):
    self.panes[name] = pane = paneFrame2.add(name,min=minsize,size=size)
    
# Set the colors of the separator and handle.
i = 1
bar = paneFrame2.component('separator-%d' % i)
bar.configure(background='LightSteelBlue2')
handle = paneFrame2.component('handle-%d' % i)
handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041225063637.16:<< create paneFrame2, a second paned widget >>
#@+node:ekr.20041225063637.17:<< create outline and log panes in paneFrame2 >>
outline = self.panes.get('outline')

# Create the widget.
self.scrolledTreeCanvas = scrolledTreeCanvas = Pmw.ScrolledCanvas(outline,
    hscrollmode='none',borderframe=3)
    
# Configure the canvas component.
scrolledTreeCanvas.pack(side='top',expand=1,fill="both")

treeCanvas = scrolledTreeCanvas.component('canvas')
treeCanvas.configure(background='white')

# Create the tree.
self.tree = settingsTree(c,c.frame,treeCanvas,self)

logPane = self.panes.get('log')
self.logText = logText = Tk.Text(logPane)
logText.pack(expand=1,fill="both")
#@nonl
#@-node:ekr.20041225063637.17:<< create outline and log panes in paneFrame2 >>
#@+node:ekr.20041225063637.18:<< put setterCanvas in paneFrame's setter pane>>
# Create the widget in the 'setter' pane.
setter = self.panes.get('setter')

self.sc = sc = Pmw.ScrolledCanvas(setter,
    hscrollmode='none',vscrollmode='dynamic',
    labelpos = 'n',label_text = '')
    
sc.pack(side='top',expand=1,fill="both")

sc.component('canvas')
self.setterLabel = sc.component('label')
#@nonl
#@-node:ekr.20041225063637.18:<< put setterCanvas in paneFrame's setter pane>>
#@+node:ekr.20041225063637.19:<< put a Text widget in the comment pane >>
commentFrame = self.paneFrame.pane('comments')

self.commentWidget = commentWidget = Pmw.ScrolledText(commentFrame)
commentWidget.pack(expand=1,fill="both")

self.commentText = text = commentWidget.component('text')

background = commentFrame.cget('background')
text.configure(background=background,borderwidth=0)
#@nonl
#@-node:ekr.20041225063637.19:<< put a Text widget in the comment pane >>
#@-node:ekr.20050212153646:createStandAloneDialog
#@+node:ekr.20041225063637.21:createSettingsTree & helpers
def createSettingsTree (self):
    
    """Create a tree of vnodes representing all settings."""

    createEmptyRootNodes = False
    c = self.c ; config = g.app.config
    root_p = None ; last_p = None
    for kind,path,otherFileFlag in (
        ("Global",config.globalConfigFile,True),
        ("Home",config.homeFile,True),
        ("Local",c.fileName(),False),
    ):
        if path:
            if otherFileFlag: c2 = config.openSettingsFile(path)
            else: c2 = c
            root2 = g.app.config.settingsRoot(c2)
        else:
            root2 = None
        if root2 or createEmptyRootNodes:
            << create a node p for kind & root2 >>
    if self.createSummaryNode: root_p.expand()
    return root_p
#@nonl
#@+node:ekr.20041225063637.22:<< create a node p for  kind & root2 >>
if not root_p:
    t = leoNodes.tnode()
    root_v = leoNodes.vnode(c,t) # Using c2 --> oops: nullTree.
    root_p = leoNodes.position(root_v,[])
    if self.createSummaryNode:
        root_p.initHeadString("All settings")
        root_p.scriptSetBodyString(self.rootNodeComments())
        p = root_p.insertAsLastChild()
    else:
        p = root_p.copy()
    last_p = p.copy()
else:
    # Pychecker may complain, but last_p _is_ defined here!
    p = last_p.insertAfter()
    last_p = p.copy()

if root2:
    root2.copyTreeFromSelfTo(p)  # replace p by root2.

self.copyExpansionState(root2,p)
# g.trace(p.isExpanded(),p.headString())

<< add entry for p to filesInfoDict >>

path2 = g.choose(otherFileFlag,path,g.shortFileName(path))
p.initHeadString("%s settings: %s" % (kind,path2))
#@nonl
#@+node:ekr.20041225063637.23:<< add entry for p to filesInfoDict >>
self.filesInfoDict[p] = {
    'c': c2,
    'changes': [],
    'p': p.copy(),
    'path': path,
    'isLocal':  not otherFileFlag,
}
#@nonl
#@-node:ekr.20041225063637.23:<< add entry for p to filesInfoDict >>
#@-node:ekr.20041225063637.22:<< create a node p for  kind & root2 >>
#@+node:ekr.20041225063637.24:rootNodeComments
def rootNodeComments(self):
    
    c = self.c ; fileName = g.shortFileName(c.mFileName)
    
    s = """This tree shows Leo's global and home settings, as well as the local settings in %s."""\
        % (fileName)
    
    return s
#@nonl
#@-node:ekr.20041225063637.24:rootNodeComments
#@-node:ekr.20041225063637.21:createSettingsTree & helpers
#@+node:ekr.20041225063637.25:createWidgets & helpers
def createWidgets (self,widgets,parent,p):

    munge = g.app.config.munge

    << define creatorDispatchDict >>
    
    # g.trace(p.headString())
    
    # self.printWidgets(widgets)
    
    self.h = 0 # Offset from top of pane for first widget.
    self.createSpacerFrame(parent,size=15)
    
    if p != self.suppressComments:
        self.createComments(parent,p.copy())

    for data in widgets:
        p,kind,name,vals = data
        if kind.startswith('ints'):
            self.createInts(parent,p,kind,name,vals)
        if kind.startswith('strings'):
            self.createStrings(parent,p,kind,name,vals)
        else:
            f = creatorDispatchDict.get(munge(kind))
            if f is not None:
                try:
                    f(parent,p,kind,name,vals)
                except TypeError:
                    g.es_exception()
                    g.trace("***No handler***",kind)
#@nonl
#@+node:ekr.20041225063637.26:<< define creatorDispatchDict >>
creatorDispatchDict = {
    'bool':         self.createBool,
    'color':        self.createColor,
    'comment':      self.createOnlyComments, # New in 4.3.1
    'directory':    self.createDirectory,
    'font':         self.createFont,
    'int':          self.createInt,
    'ints':         self.createInts,
    'float':        self.createFloat,
    'path':         self.createPath,
    'ratio':        self.createRatio,
    'shortcut':     self.createShortcut,
    'shortcuts':    self.createShortcuts,
    'string':       self.createString,
    'strings':      self.createStrings,
}
#@nonl
#@-node:ekr.20041225063637.26:<< define creatorDispatchDict >>
#@+node:ekr.20041225063637.27:createBool
def createBool (self,parent,p,kind,name,val):
    
    val = g.choose(val.lower()=='true',1,0)

    # Inits the checkbutton widget. 
    var = Tk.IntVar()
    var.set(val)

    def boolCallback():
        val2 = g.choose(var.get(),True,False)
        # g.trace(name,val2)
        return val2
    
    val = g.choose(val,True,False)
    self.initValue(p,name,kind,val,boolCallback)

    box = Tk.Checkbutton(parent,text=name,variable=var,background=self.commonBackground)

    self.sc.create_window(10,self.h,anchor='w',window=box)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.27:createBool
#@+node:ekr.20041225063637.28:createColor
def createColor (self,parent,p,kind,name,val):
    
    munge = g.app.config.munge
    noColor = "<no color>"
    colorNamesList = list(self.colorNamesList)
    
    f = Tk.Frame(parent,background=self.commonBackground) # No need to pack.
    << munge val and add val to colorNamesList >>
    << create optionMenu and callback >>
    << create picker button and callback >>
    Tk.Label(f,text=name,background=self.commonBackground).pack(side='left')
    
    self.colorSettingDict [munge(name)] = val

    def getColorCallback ():
        return self.colorSettingDict.get(munge(name))

    self.initValue(p,name,kind,val,getColorCallback)

    self.sc.create_window(15,self.h+8,anchor='w',window=f)
    self.h += 30
#@nonl
#@+node:ekr.20041225063637.29:<< munge val and add val to colorNamesList >>
if val in ("None",None): val = noColor
val = str(val) # Get rid of unicode.

if noColor in colorNamesList:
    colorNamesList.remove(val)
if val is not noColor and val not in colorNamesList:
     colorNamesList.append(val)
colorNamesList.sort()
colorNamesList.insert(0,noColor)

initVal = val
if val is noColor: val = None
#@nonl
#@-node:ekr.20041225063637.29:<< munge val and add val to colorNamesList >>
#@+node:ekr.20041225063637.30:<< create optionMenu and callback >>
colorBox = Pmw.ComboBox(f,scrolledlist_items=colorNamesList)
colorBox.selectitem(initVal)
colorBox.pack(side="left",padx=2)

color = g.choose(val is None,f.cget('background'),val)
colorSample = Tk.Button(f,width=8,background=color)
colorSample.pack(side='left',padx=2)

def colorCallback (newName):
    # g.trace(repr(newName))
    if not newName or newName.lower() in ('none','<none>','<no color>'):
        self.colorSettingDict[munge(name)] = None
        color = f.cget('background')
        colorSample.configure(background=color)
    else:
        try:
            colorSample.configure(background=newName)
            self.colorSettingDict[munge(name)] = g.choose(newName is noColor,None,newName)
        except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
#@nonl
#@-node:ekr.20041225063637.30:<< create optionMenu and callback >>
#@+node:ekr.20041225063637.31:<< create picker button and callback >>
def pickerCallback (color=val):

    rgb,val = tkColorChooser.askcolor(parent=parent,color=color)
    if rgb or val:
        # g.trace(rgb,val)
        self.colorSettingDict[munge(name)] = val
        colorSample.configure(background=val,activebackground=val,text=val)

b = Tk.Button(f,text="Color Picker...",command=pickerCallback,background=self.commonBackground)
b.pack(side="left")
#@nonl
#@-node:ekr.20041225063637.31:<< create picker button and callback >>
#@-node:ekr.20041225063637.28:createColor
#@+node:ekr.20050121131613:createComments
def createComments (self,parent,p):
    
    # g.trace(p.headString())
    
    bg = self.commonBackground

    s = p.bodyString().strip()
    if not s: return
    
    f = Tk.Frame(parent,background=bg) # No need to pack.

    scrolled_text = Pmw.ScrolledText(f,
        labelpos = 'ew',label_text='comments',
        hull_background=bg,
        hull_bd=2,hull_relief='groove',
        hull_padx=6,hull_pady=6,
        text_background=bg,
        text_padx=6,text_pady=6,
        text_bd=2,text_relief='sunken',
        label_background=bg,
        text_height=5,text_width=80)
    scrolled_text.pack(side='left',pady=6,padx=6,expand=1,fill='x')
    t = scrolled_text.component('text')
    t.insert('end',s)
    t.configure(state='disabled')
    scrolled_text.component('hull')

    self.sc.create_window(10-2,self.h,anchor='w',window=f)
    self.h += 70
#@nonl
#@-node:ekr.20050121131613:createComments
#@+node:ekr.20050603065744:createOnlyComments
def createOnlyComments (self,parent,p,kind,name,val):
    
    pass # The existence of the 'comments' widget is enough.
#@nonl
#@-node:ekr.20050603065744:createOnlyComments
#@+node:ekr.20041225063637.32:createDirectory
def createDirectory (self,parent,p,kind,name,val):
    
    self.createString(parent,p,kind,name,val)
#@nonl
#@-node:ekr.20041225063637.32:createDirectory
#@+node:ekr.20041225063637.33:createFloat
def createFloat (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent,background=bg)
    Tk.Entry(f,textvariable=var,background=bg).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def floatCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            float(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val
            
    self.initValue(p,name,kind,val,floatCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.33:createFloat
#@+node:ekr.20041225063637.34:createFont
def createFont (self,parent,p,kind,fontName,val):
    
    """Create a font picker.  val is a dict containing the specified values."""
    bg = self.commonBackground
    d = val
    munge = g.app.config.munge
    f = Tk.Frame(parent,background=bg) # No need to pack.
    self.alterComments = p.copy()
    self.alteredCommentsString = d.get('comments')
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    Tk.Label(f,text=fontName,background=bg).pack(side='left')
    << define fontCallback >>

    familyBox.configure(selectioncommand=fontCallback)
    slantBox.configure(selectioncommand=fontCallback)
    weightBox.configure(selectioncommand=fontCallback)

    self.initValue(p,munge(fontName),'font',d,fontCallback)

    self.sc.create_window(15,self.h,anchor='w',window = f)
    self.h += 30
#@nonl
#@+node:ekr.20041225063637.35:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

data = d.get('family')
initialitem = 0
if data:
    name2,val = data
    if val and val in names:
        initialitem = names.index(val)

familyBox = Pmw.ComboBox(f,
    labelpos="we",label_text='Family:',
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(initialitem)
familyBox.pack(side="left",padx=2)
#@nonl
#@-node:ekr.20041225063637.35:<< create the family combo box >>
#@+node:ekr.20041225063637.36:<< create the size entry >>
Tk.Label(f,text="Size:",background=bg).pack(side="left")

sizeEntry = Tk.Entry(f,width=4)
sizeEntry.pack(side="left")

data = d.get('size')
if data:
    kind,val = data
    if val not in (None,'None','none'):
        try:
            int(val)
            sizeEntry.insert('end',val)
        except ValueError:
            s = "invalid size: %s" % val
            print s ; self.es(s,color="blue")
#@nonl
#@-node:ekr.20041225063637.36:<< create the size entry >>
#@+node:ekr.20041225063637.37:<< create the weight combo box >>
initialitem = 0
values = ['<None>','normal','bold']
data = d.get('weight')
if data:
    kind,val = data
    if val in values:
        initialitem = values.index(val)

weightBox = Pmw.ComboBox(f,
    labelpos="we",label_text="Weight:",
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=values)

weightBox.selectitem(initialitem)
weightBox.pack(side="left",padx=2)
#@nonl
#@-node:ekr.20041225063637.37:<< create the weight combo box >>
#@+node:ekr.20041225063637.38:<< create the slant combo box>>
initialitem = 0
values=['<None>','roman','italic']
data = d.get('slant')
if data:
    kind,val = data
    if val in values:
        initialitem = values.index(val)

slantBox = Pmw.ComboBox(f,
    labelpos="we",label_text="Slant:",
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=values)

slantBox.selectitem(initialitem)
slantBox.pack(side="left",padx=2)
#@nonl
#@-node:ekr.20041225063637.38:<< create the slant combo box>>
#@+node:ekr.20041225063637.39:<< define fontCallback >>
def fontCallback(*args,**keys):
    
    __pychecker__ = '--no-argsused' # not used, but needed.
    
    d2 = d.copy() # The update logic must compare distinct dicts.
    
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:   val = sizeEntry.get().strip()
        if not val or  val.lower() in ('none','<none>',): val = None

        data = d.get(key)
        name,oldval = data
        d2[key] = name,val
    
    return d2
#@nonl
#@-node:ekr.20041225063637.39:<< define fontCallback >>
#@-node:ekr.20041225063637.34:createFont
#@+node:ekr.20041225063637.40:createInt
def createInt (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')

    def intCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            int(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val
    
    self.initValue(p,name,kind,val,intCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.40:createInt
#@+node:ekr.20041225063637.41:createInts
def createInts (self,parent,p,kind,name,val):
    
    # g.trace(repr(kind),repr(name),val)
    
    bg = self.commonBackground
    
    i = kind.find('[')
    j = kind.find(']')
    if not (-1 < i < j):
        return
    
    items = kind[i+1:j].split(',')
    items.sort()
    items.insert(0,'<none>')
    
    if val in items:
        initialitem = items.index(val)
    else:
        initialitem = 0
        
    f = Tk.Frame(parent)

    intsBox = Pmw.ComboBox(f,
        labelpos="ew",label_text=name,
        label_background=bg,
        scrolledlist_items=items)

    intsBox.selectitem(initialitem)
    intsBox.pack(side="left",padx=2)
    
    def intsCallback():
        val2 = intsBox.get()
        try:
            int(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val

    self.initValue(p,name,kind,val,intsCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.41:createInts
#@+node:ekr.20041225063637.42:createPath
def createPath (self,parent,p,kind,name,val):
    
    self.createString(parent,p,kind,name,val)
#@nonl
#@-node:ekr.20041225063637.42:createPath
#@+node:ekr.20041225063637.43:createRatio
def createRatio (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def ratioCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            val2 = float(val2)
            if 0.0 <= val2 <= 1.0:
                return val2
        except TypeError:
            pass
        g.trace("bad val:",val2)
        return val
            
    self.initValue(p,name,kind,val,ratioCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.43:createRatio
#@+node:ekr.20041225063637.45:createShortcut
def createShortcut (self,parent,p,kind,name,val):
    
    g.trace(name,val)
    
    if name:
        self.createString(parent,p,kind,name,val)
#@nonl
#@-node:ekr.20041225063637.45:createShortcut
#@+node:ekr.20041225063637.46:createShortcuts
def createShortcuts (self,parent,p,kind,name,vals):
    
    __pychecker__ = '--no-argsused' # vals not used.
    
    t = self.createText(parent,p)
    
    def shortcutsCallback():
        val = t.get('1.0','end').rstrip()
        return val

    self.initValue(p,name,kind,vals,shortcutsCallback)
#@nonl
#@-node:ekr.20041225063637.46:createShortcuts
#@+node:ekr.20041225063637.47:createSpacerFrame
def createSpacerFrame (self,parent,size=10):
    
    f = Tk.Frame(parent)
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += size
#@nonl
#@-node:ekr.20041225063637.47:createSpacerFrame
#@+node:ekr.20041225063637.48:createString
def createString (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    if val in (None,'None'): val = ""
    
    # Inits the Entry widget.
    var = Tk.StringVar()
    var.set(val)
    
    f = Tk.Frame(parent) # No need to pack.
    Tk.Entry(f,textvariable=var,width=40).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def stringCallback():
        val = var.get()
        # g.trace(name,val)
        return val

    self.initValue(p,name,kind,val,stringCallback)
    
    self.sc.create_window(15,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.48:createString
#@+node:ekr.20041225063637.49:createStrings
def createStrings (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # g.trace(repr(kind),repr(name),val)
    i = kind.find('[')
    j = kind.find(']')
    if not (-1 < i < j):
        return
    
    items = kind[i+1:j].split(',')
    items.sort()
    items.insert(0,'<none>')
    if val in items:
        initialitem = items.index(val)
    else:
        initialitem = 0
        
    f = Tk.Frame(parent,background=bg)

    stringsBox = Pmw.ComboBox(f,
        labelpos="ew",label_text=name,
        label_background = bg,
        scrolledlist_items=items)

    stringsBox.selectitem(initialitem)
    stringsBox.pack(side="left",padx=2)
    
    def stringsCallback():
        return stringsBox.get()

    self.initValue(p,name,kind,val,stringsCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.49:createStrings
#@+node:ekr.20050512134219:createText
def createText (self,parent,p):
    
    bg = self.commonBackground
    f = Tk.Frame(parent,background=bg) # No need to pack.

    scrolled_text = Pmw.ScrolledText(f,
        labelpos = 'ew',label_text='shortcuts',
        hull_background=bg,
        hull_bd=2,hull_relief='groove',
        hull_padx=6,hull_pady=6,
        text_background='white',
        text_padx=6,text_pady=6,
        text_bd=2,text_relief='sunken',
        label_background=bg,
        text_height=10,text_width=80)
    scrolled_text.pack(side='left',pady=6,padx=6,expand=1,fill='x')
    t = scrolled_text.component('text')
    t.insert('end',p.bodyString().strip())
    t.configure(state='normal')
    scrolled_text.component('hull')

    self.sc.create_window(10-2,self.h,anchor='w',window=f)
    self.h += 140
    
    return t
#@nonl
#@-node:ekr.20050512134219:createText
#@-node:ekr.20041225063637.25:createWidgets & helpers
#@+node:ekr.20041225063637.50:callbacks...
#@+node:ekr.20041225063637.51:onAnyButton
def onAnyButton(self,name):
    
    c = self.c
    endDialog = name in (None,"OK","Cancel")
    
    # g.trace(name)
    
    dispatchDict = {
        "Apply":    self.writeChangedVars,
        "Cancel":   None, # Do nothing.
        "OK":       self.writeChangedVars,
        "Revert":   self.revert,
    }
    
    f = dispatchDict.get(name)
    if f: f()
        
    if self.replaceBody:
        if endDialog:
            c.frame.replaceTreePaneWithComponent('tree')
            c.frame.replaceBodyPaneWithComponent('body')
            c.disableCommandsMessage = '' # Re-enable all commands.
    else:
        if endDialog:
            self.dialog.destroy()
            c.disableCommandsMessage = '' # Re-enable all commands.
        else:
            self.dialog.withdraw()
            self.dialog.deiconify()
#@nonl
#@-node:ekr.20041225063637.51:onAnyButton
#@+node:ekr.20041225063637.52:revert
def revert (self):
    
    """Restores written vars to initial value and re-inits all widgets."""
    
    iDict = self.initValueDict
    fDict = self.fileValueDict
    munge = g.app.config.munge
    
    changedList = []
    for key in fDict.keys():

        fData = fDict.get(key)
        fp,fname,fkind,fval,getValueCallback = fData
        
        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData

        assert(ip==fp and iname==fname and ikind==fkind)
        # print "revert",key,"ival",ival,"fval",fval
        
        if ival != fval:
            # print "revert %10s -> %10s %s" % (str(fval),str(ival),fname)
            self.fileValueDict [munge(iname)] = ip,iname,ikind,ival,getValueCallback
            changedList.append((ip,iname,ikind,fval,ival),)

    self.updateSetter(self.p,updateDicts=False)
    self.writeChangedList(changedList)
    self.updateSetter(self.p) # Redraw the widgets in the pane.
#@nonl
#@-node:ekr.20041225063637.52:revert
#@+node:ekr.20041225063637.53:onPaneResize
def onPaneResize (self,sizes=None):
    
    __pychecker__ = '--no-argsused' # sizes not used, but needed.

    self.sc.resizescrollregion()
#@nonl
#@-node:ekr.20041225063637.53:onPaneResize
#@+node:ekr.20041225063637.54:handleTreeClick
def onTreeClick (self,p):

    self.p = p.copy()
    self.updateSetter(p)
#@nonl
#@-node:ekr.20041225063637.54:handleTreeClick
#@-node:ekr.20041225063637.50:callbacks...
#@+node:ekr.20041225063637.55:getters...
#@+node:ekr.20041225063637.56:findCorrespondingNode
def findCorrespondingNode (self,root1,root2,p1):
    
    """Return the node corresponding to p1 (in root1) in the root2's tree."""
    
    if p1 == root1: return root2

    # Go up tree 1, computing child indices.
    childIndices = []
    for p in p1.self_and_parents_iter():
        #g.trace(p)
        if p == root1: break
        childIndices.append(p.childIndex())
        
    childIndices.reverse()
    # g.trace(childIndices)
    
    # Go down tree 2, moving to the n'th child.
    p2 = root2.copy()
    for n in childIndices:
        # g.trace(p2)
        p2.moveToNthChild(n)

    # g.trace(p2)
    return p2
#@nonl
#@-node:ekr.20041225063637.56:findCorrespondingNode
#@+node:ekr.20041225063637.57:findSettingsRoot
def findSettingsRoot (self,p):
    
    first_p = p.copy()
    
    # Get the list of root positions.
    roots = self.filesInfoDict.keys()

    for p in p.self_and_parents_iter():
        for root in roots:
            if p == root:
                # g.trace("root of %s is %s" % (first_p.headString(),p.headString()))
                return root # Used as key.  Must NOT return a copy.
                
    g.trace("Can't happen: %s has no root node" % (first_p.headString()))
    return None
#@nonl
#@-node:ekr.20041225063637.57:findSettingsRoot
#@+node:ekr.20041225063637.58:settingsPosition
def settingsPosition (self):
    
    return self._settingsPosition.copy()
#@nonl
#@-node:ekr.20041225063637.58:settingsPosition
#@-node:ekr.20041225063637.55:getters...
#@+node:ekr.20041225063637.59:redrawing...
#@+node:ekr.20041225063637.60:updateSetter
def updateSetter (self,p,updateDicts=True):
    
    """Create a setter pane for position p."""

    sc = self.sc ; interior = sc.interior()
    
    if updateDicts:
        self.fileValueDict = {}
        self.initValueDict = {}
        self.colorSettingDict = {}
    
    # Destroy the previous widgets
    for w in interior.winfo_children():
        w.destroy()

    # Visit the node, and possibly its subtree, looking for widgets to create.
    self.parser.widgets = []
    self.suppressComments = None # May be set in parser.
    self.parser.visitNode(p)
    if self.parser.widgets:
        self.createWidgets(self.parser.widgets,interior,p)
        
    self.sc.resizescrollregion()
    self.sc.yview('moveto',0)
    self.updateSetterLabel(p)
    g.app.gui.widgetWantsFocus(None,None)
#@nonl
#@-node:ekr.20041225063637.60:updateSetter
#@+node:ekr.20041225063637.62:updateSetterLabel
def updateSetterLabel (self,p):
    
    if self.setterLabel:

        h = p.headString().strip() or ''

        for name in ('@page','@font','@ignore','@'):
            if g.match(h,0,name):
                h = h[len(name):].strip()
                i = h.find('=')
                if i > -1:
                    h = h[:i].strip()
                break

        self.setterLabel.configure(text=h)
        return h
        
    else:
        return None
#@nonl
#@-node:ekr.20041225063637.62:updateSetterLabel
#@-node:ekr.20041225063637.59:redrawing...
#@+node:ekr.20041225063637.63:value handlers...
@ These keep track of the original and changed values of all items in the present setter pane.
#@nonl
#@+node:ekr.20041225063637.64:initValue
def initValue (self,p,name,kind,val,getValueCallback):
    
    munge = g.app.config.munge
    
    # g.trace(name,kind,val)
    
    self.initValueDict [munge(name)] = (p,name,kind,val,getValueCallback)
#@nonl
#@-node:ekr.20041225063637.64:initValue
#@+node:ekr.20041225063637.65:writeChangedVars & helpers
def writeChangedVars (self):
    
    """Create per-file changes lists from diffs between what has been inited and written.
    
    Call writeChangedList to update each file from items in this list."""

    changedList = []
    fDict = self.fileValueDict
    iDict = self.initValueDict
    munge = g.app.config.munge
    
    for key in iDict.keys():

        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData
        newVal = getValueCallback()
        fData = fDict.get(key)
        if fData:
            fp,fname,fkind,fval,junk = fData
            assert(ip==fp and iname==fname and ikind==fkind)
            changed = fval != newVal ; oldVal = fval
        else:
            changed = ival != newVal ; oldVal = ival
            fval = '<none>'

        if changed:
            # print "write","key","ival",ival,"fval",fval
            if type(oldVal) == type({}):
                s = "write  %s" % (iname)
            elif ikind == 'shortcuts':
                s = 'updating shortcuts in %s' % ip.headString()
            else:
                # Convert unicode strings to strings safe for printing.
                # The calls to str are needed because g.toEncodedString only changes unicode strings.
                strOldVal = str(g.toEncodedString(oldVal,'ascii'))
                strNewVal = str(g.toEncodedString(newVal,'ascii'))
                strIname  = str(g.toEncodedString(iname,'ascii'))
                s = "write  %10s -> %10s %s" % (strOldVal,strNewVal,strIname)
            g.es_print(s,color='blue')
            self.fileValueDict [munge(iname)] = ip,iname,ikind,newVal,getValueCallback
            changedList.append((ip,iname,ikind,oldVal,newVal),)
            
    self.writeChangedList(changedList)
#@nonl
#@+node:ekr.20041225063637.66:updateConfig (settingsController)
def updateConfig(self,c,changes):
    
    """Update the core config settings from the changes list."""
    
    munge = g.app.config.munge

    for data in changes:
        p,name,kind,oldval,val = data
        if munge(kind) == 'font':
            for key in ('family','size','slant','weight'):
                data2 = val.get(key)
                if data2:
                    name2,val2 = data2
                    kind2 = g.choose(key=='size','int','string')
                    g.app.config.set(c,name2,kind2,val2)
            # Update the visible fonts: c may not be the same as self.c.
            for c2 in (c,self.c):
                c2.frame.body.setFontFromConfig()
                c2.frame.body.colorizer.setFontFromConfig()
                c2.frame.log.setFontFromConfig()
                c2.frame.tree.setFontFromConfig()
                c2.redraw_now()
        elif munge(kind) == "color":
            # g.trace("setting colors")
            g.app.config.set(c,name,kind,val)
            for c2 in (c,self.c):
                c2.frame.tree.setColorFromConfig()
                c2.frame.log.setColorFromConfig()
                c2.frame.body.setColorFromConfig()
        else:
            # g.trace(name,kind,val)
            g.app.config.set(c,name,kind,val)
#@nonl
#@-node:ekr.20041225063637.66:updateConfig (settingsController)
#@+node:ekr.20041225063637.67:updateOneNode & helper
def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1.copy())
    c1 = root1.c
    
    # Root2 is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    p2 = self.findCorrespondingNode(root1.copy(),root2.copy(),p1.copy())
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in root2:",root2.c.mFileName)
        g.trace('root1',root1)
        g.trace('root2',root2)
        g.trace('p1',p1)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind == 'shortcuts':
                # Just put the new the values in the body.
                p.setBodyStringOrPane(val)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))
#@nonl
#@+node:ekr.20041225063637.68:computeBodyFromFontDict
def computeBodyFromFontDict(self,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'<none>'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body
#@nonl
#@-node:ekr.20041225063637.68:computeBodyFromFontDict
#@-node:ekr.20041225063637.67:updateOneNode & helper
#@+node:ekr.20041225063637.69:writeChangedList
def writeChangedList (self,changedList):
    
    filesInfoDict = self.filesInfoDict
    if 0:
        << dump all the dicts in filesInfoDict >>

    # Accumulate the changes for each file in a 'changes' list for each root.
    for data in changedList:
        p,name,kind,oldVal,newVal = data
        # print "%6s %6s %10s -> %10s %s" % (g.callers(2),kind,str(oldVal),str(newVal),name)
        root = self.findSettingsRoot(p)
        d = filesInfoDict.get(root)
        changes = d.get('changes')
        changes.append(data)
        d['changes'] = changes

    for root in filesInfoDict.keys():
        d = filesInfoDict.get(root)
        # Keys are 'c','changes','path','islocal' (unused)
        c = d.get('c')
        changes = d.get('changes')
        path = d.get('path')
        # Always write the file so as to preserve expansion state.
        self.writeChangesToFile(c,changes,path)
        self.updateConfig(c,changes)
        d['changes'] = []
#@nonl
#@+node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
for key in filesInfoDict.keys():
    print ; print
    print "key",key
    g.printDict(filesInfoDict.get(key))
print ; print
#@nonl
#@-node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
#@-node:ekr.20041225063637.69:writeChangedList
#@+node:ekr.20041225063637.71:writeChangesToFile
def writeChangesToFile (self,c,changes,path):

    # Write the individual changes.
    for data in changes:
        self.updateOneNode(c,data)
        
    # Copy the expansion state of the dialog to the file.
    for d in self.filesInfoDict.values():
        c2 = d.get('c')
        if c2 and c2 == c:
            p2 = d.get('p')
            p = g.app.config.settingsRoot(c)
            # g.trace(c,p)
            if p and p2:
                p = p.copy() ; p2 = p2.copy()
                # Defensive programming: don't assume p and p2 are in synch.
                while p and p2:
                    if p2.isExpanded(): p.expand()
                    else: p.contract()
                    p.moveToThreadNext()
                    p2.moveToThreadNext()
            break

    if c.fileName():
        self.es("writing " + g.shortFilename(path))
        # Save the file corresponding to c.
        # Non-local files aren't open otherwise!
        c.beginUpdate()
        try:
            c.fileCommands.save(c.fileName())
        finally:
            c.endUpdate()
        self.tree.redraw()
    else:
        print "no settings saved.  local file not named."
#@nonl
#@-node:ekr.20041225063637.71:writeChangesToFile
#@-node:ekr.20041225063637.65:writeChangedVars & helpers
#@-node:ekr.20041225063637.63:value handlers...
#@+node:ekr.20041225063637.72:utilities...
#@+node:ekr.20041225063637.11:class logClass
class logClass:
    
    def __init__ (self,textWidget):
        self.textWidget = textWidget
        self.colorTags = []
        
    def put(self,s,color=None):
        w = self.textWidget
        << put s to w >>
        
    def putnl (self):
        w = self.textWidget
        if sys.platform == "darwin": print
        w.insert("end",'\n')
        w.see("end")
        w.update_idletasks()
#@nonl
#@+node:ekr.20041225063637.12:<< put s to w >>
if type(s) == type(u""):
    s = g.toEncodedString(s,g.app.tkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        w.tag_config(color,foreground=color)
    w.insert("end",s)
    w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        w.tag_config("black",foreground="black")
    w.tag_add("black","end")
else:
    w.insert("end",s)

w.see("end")
w.update_idletasks()
#@nonl
#@-node:ekr.20041225063637.12:<< put s to w >>
#@-node:ekr.20041225063637.11:class logClass
#@+node:ekr.20041225063637.20:center
def center(self):
    
    top = self.top

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info()
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@nonl
#@-node:ekr.20041225063637.20:center
#@+node:ekr.20041225063637.73:settingsController.es
def es(self,*args,**keys):
    
    old_log = g.app.log
    g.app.log = self.log
    g.es(*args,**keys)
    g.app.log = old_log
#@nonl
#@-node:ekr.20041225063637.73:settingsController.es
#@+node:ekr.20041225063637.74:copyExpansionState
def copyExpansionState(self,p1,p2):
 
    # Don't depend on p.nodeAfterTree, etc.
    if p1.isExpanded():
        # g.trace("p1",p1)
        # g.trace("p2",p2)
        p2.expand()
        child1 = p1.firstChild()
        child2 = p2.firstChild()
        while child1:
            self.copyExpansionState(child1,child2)
            child1 = child1.next()
            child2 = child2.next()
#@nonl
#@-node:ekr.20041225063637.74:copyExpansionState
#@+node:ekr.20041225063637.75:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self):
    
    top = self.top
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = geom.split('+')
    w,h = dim.split('x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@nonl
#@-node:ekr.20041225063637.75:get_window_info
#@+node:ekr.20041225063637.76:printChangedVars
def printChangedVars (self):

    d = self.initValueDict
    
    for key in d.keys():
        
        data = d.get(key)
        p,name,kind,val,getValueCallback = data
        newVal = getValueCallback()
        
        if val != newVal:
            name   = str(g.toEncodedString(name))
            val    = str(g.toEncodedString(val))
            newVal = str(g.toEncodedString(newVal))
            print "%10s -> %10s %s" % (val,newVal,name)
#@nonl
#@-node:ekr.20041225063637.76:printChangedVars
#@+node:ekr.20041225063637.77:printWidgets
def printWidgets (self,widgets):

    print '-'*20

    for data in widgets:
        p,kind,name,vals = data
        if type(vals) == type([]):
            print "%s %s..." % (name,kind)
            for val in vals:
                print val
        else:
            print "%45s %8s %s" % (name,kind,vals)
#@nonl
#@-node:ekr.20041225063637.77:printWidgets
#@-node:ekr.20041225063637.72:utilities...
#@-node:ekr.20041225063637.10:class settingsController
#@+node:ekr.20041225063637.96:class settingsDialogParserClass (parserBaseClass)
class settingsDialogParserClass (parserBaseClass):
    
    '''A class that traverses the settings tree creating
    a list of widgets to show in the settings dialog.'''
    
    @others
#@+node:ekr.20041225063637.97:ctor
# There is no need to call the base class ctor.
__pychecker__ = '--no-callinit'

def __init__ (self,c,p,controller):
    self.c = c
    self.controller = controller
    self.root = p.copy()
    self.widgets = [] # A list of widgets to create in the setter pane.

    # Keys are canonicalized names.
    self.dispatchDict = {
        'bool':         self.set,
        'color':        self.set,
        'directory':    self.doDirectory,
        'font':         self.doFont,
        'if':           self.doIf,
        'ifgui':        None,
        'ifplatform':   None,
        'ignore':       None,
        'int':          self.set,
        'ints':         self.doInts,
        'float':        self.set,
        'font':         self.doFont,
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.set,
        'shortcut':     None,
        'shortcuts':    self.doShortcuts,
        'string':       self.set,
        'strings':      self.doStrings,
    }
#@nonl
#@-node:ekr.20041225063637.97:ctor
#@+node:ekr.20041225063637.98:set (settingsDialogParserClass)
def set (self,p,kind,name,val):
    
    self.widgets.append((p.copy(),kind,name,val),)
#@nonl
#@-node:ekr.20041225063637.98:set (settingsDialogParserClass)
#@+node:ekr.20041225063637.99:visitNode (settingsDialogParserClass)
def visitNode (self,p):
    
    """Visit a node, and possibly append a widget description to self.widgets."""
    
    munge = g.app.config.munge
    h = p.headString().strip() or ''
    kind,name,val = self.parseHeadline(h)
    
    # g.trace(kind,name,val)

    f = self.dispatchDict.get(munge(kind)) or self.doComment
    if f is not None:
        try:
            return f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind
            return None
#@nonl
#@-node:ekr.20041225063637.99:visitNode (settingsDialogParserClass)
#@+node:ekr.20041225063637.100:kind handlers (settingsDialogParserClass)
# Most of the work is done by base class methods.
#@nonl
#@+node:ekr.20050603065400:doComment
def doComment (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used, but required.

    self.set(p,'comment',None,None)
#@nonl
#@-node:ekr.20050603065400:doComment
#@+node:ekr.20041225063637.101:doFont
def doFont (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used, but required.

    d = self.parseFont(p)
    # g.trace("\n\nfont dict...\n%s" % g.dictToString(d))
    self.set(p,kind,name,d)
#@-node:ekr.20041225063637.101:doFont
#@+node:ekr.20041225063637.102:doPage
def doPage(self,p,kind,name,val):
    
    """Create a widget for each setting in the subtree."""
    
    __pychecker__ = '--no-argsused' # args not used, but required.

    for p in p.subtree_iter():
        self.visitNode(p)
#@nonl
#@-node:ekr.20041225063637.102:doPage
#@+node:ekr.20041225063637.103:doRecentFiles & doBodyPaneList
def doBodyPaneList (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # val not used, but required.

    s = p.bodyString()
    lines = g.splitLines(s)

    vals = []
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            vals.append(line)
                
    self.set(p,kind,name,vals)
#@-node:ekr.20041225063637.103:doRecentFiles & doBodyPaneList
#@+node:ekr.20041225063637.104:doShortcuts
def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # val not used, but required.

    s = p.bodyString()
    self.set(p,kind,name,s)
    self.controller.suppressComments=p.copy()
#@nonl
#@-node:ekr.20041225063637.104:doShortcuts
#@-node:ekr.20041225063637.100:kind handlers (settingsDialogParserClass)
#@-node:ekr.20041225063637.96:class settingsDialogParserClass (parserBaseClass)
#@-node:ekr.20051221073339:Settings dialog classes
#@+node:ekr.20051025150224:k.onIdleTime
def onIdleTime (self):
    
    '''Set the focus to the body pane if the focus is in limbo.
    
    We must allow dialogs and the outer window frame to retain focus.'''
    
    k = self ; c = k.c
    if g.app.quitting: return # Essential.
    
    w = g.app.gui.get_focus(c.frame)
    if w:
        # Allow clicks in enclosing window frame or in dialogs.
        name = hasattr(w,'_name') and w._name or ''
        ok = (
            name and name[0] in string.letters # A known Leo frame.
            or w == c.frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
            # or isinstance(w,Tk.Button)
        )
        if not ok:
            # Not a name created by Leo.
             g.trace(self.idleCount,name,w)
             c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20051025150224:k.onIdleTime
#@+node:ekr.20051103114520.1:c.setFocusHelper
def setFocusHelper (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c,'frame') or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.
        
    frame = c.frame

    if frame.wantedWidget:
        w = frame.wantedWidget
        name = g.app.gui.widget_name(w)
        if 0:
            w2 = g.app.gui.get_focus(frame)
            name2 = g.app.gui.widget_name(w2)
            if name != name2: g.trace(name2,'->',name,g.callers())
        # It is possible that w no longer exists.
        try:
            g.app.gui.set_focus(c,w)
        except Exception:
            g.app.gui.set_focus(c,frame.body.bodyCtrl)
        # Essential: otherwise only calls to xWantsWidget would be honored.
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = g.app.gui.widget_name(w)
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == frame.top # The top of the Leo window
            or g.app.dialogs > 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
        ):
            #g.trace('ok',g.app.gui.widget_name(w))
            #g.app.gui.set_focus(c,w)
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        g.app.gui.set_focus(c,frame.body.bodyCtrl)
#@nonl
#@-node:ekr.20051103114520.1:c.setFocusHelper
#@+node:ekr.20051006121222:inputMode classes
<< baseInputMode class >>

@others
#@nonl
#@+node:ekr.20051006121222.8: << baseInputMode class >>
class baseInputMode:
    
    """A class to represent an input mode in the status line and all related commands."""
    
    @others
#@nonl
#@+node:ekr.20051006121222.9:ctor
def __init__ (self,c,statusLine):
    
    self.c = c
    
    self.statusLine = statusLine
    self.signon = None
    self.name = "baseMode"
    self.clear = True
    self.keys = []
#@nonl
#@-node:ekr.20051006121222.9:ctor
#@+node:ekr.20051006121222.10:doNothing
def doNothing(self,event=None):
    
    return "break"
#@nonl
#@-node:ekr.20051006121222.10:doNothing
#@+node:ekr.20051006121222.11:enterMode
def enterMode (self,event=None):
    
    # g.trace(self.name)
        
    self.initBindings()
    
    if self.clear:
        self.clearStatusLine()

    if self.signon:
        self.putStatusLine(self.signon,color="red")
        
    self.originalLine = self.getStatusLine()
    if self.originalLine and self.originalLine[-1] == '\n':
        self.originalLine = self.originalLine[:-1]

    # g.trace(repr(self.originalLine))

    self.enableStatusLine()
    self.setFocusStatusLine()
    
    return "break"
#@nonl
#@-node:ekr.20051006121222.11:enterMode
#@+node:ekr.20051006121222.12:exitMode
def exitMode (self,event=None,nextMode=None):
    
    """Remove all key bindings for this mode."""
    
    # g.trace(self.name)
    
    self.unbindAll()

    if nextMode:
        nextMode.enterMode()
    else:
        self.clearStatusLine()
        self.disableStatusLine()
        self.c.frame.body.setFocus()
        self.c.frame.body.bodyCtrl.bind(
            "<Key-Escape>",self.statusLine.topMode.enterMode)

    return "break"
#@nonl
#@-node:ekr.20051006121222.12:exitMode
#@+node:ekr.20051006121222.13:initBindings
def initBindings (self):
    
    """Create key bindings for this mode using modeTable."""
    
    t = self.c.frame.statusText
    
    self.unbindAll()

    t.bind("<Key-Escape>",self.exitMode)
#@nonl
#@-node:ekr.20051006121222.13:initBindings
#@+node:ekr.20051006121222.14:statusLine proxies
def clearStatusLine (self):
    self.c.frame.clearStatusLine()

def disableStatusLine (self):
    # g.trace()
    self.c.frame.disableStatusLine()

def enableStatusLine (self):
    # g.trace()
    self.c.frame.enableStatusLine()
    
def getStatusLine (self):
    return self.c.frame.getStatusLine()

def putStatusLine(self,s,color="black"):
    self.c.frame.putStatusLine(s,color=color)
    
def setFocusStatusLine(self):
    # g.trace()
    self.c.frame.setFocusStatusLine()
    
def statusLineIsEnabled(self):
    return self.c.frame.statusLineIsEnabled()
#@nonl
#@-node:ekr.20051006121222.14:statusLine proxies
#@+node:ekr.20051006121222.15:unbindAll
def unbindAll (self):
    
    t = self.c.frame.statusText
    
    for b in t.bind():
        t.unbind(b)
#@nonl
#@-node:ekr.20051006121222.15:unbindAll
#@-node:ekr.20051006121222.8: << baseInputMode class >>
#@+node:ekr.20051006121222.16:class topInputMode (baseInputMode)
class topInputMode (baseInputMode):
    
    """A class to represent the top-level input mode in the status line."""
    
    @others
#@nonl
#@+node:ekr.20051006121222.17:ctor
def __init__(self,c,statusLineClass):
    
    baseInputMode.__init__(self,c,statusLineClass)

    self.name = "topInputMode"
    
    
#@nonl
#@-node:ekr.20051006121222.17:ctor
#@+node:ekr.20051006121222.18:finishCreate
def finishCreate(self):
    
    s = self.statusLine
    
    self.bindings = (
        ('c','Change',s.findChangeMode),
        ('e','Edit',None),
        ('f','Find',s.findMode),
        ('h','Help',None),
        ('o','Outline',None),
        ('p','oPtions',s.optionsMode),
    )

    signon = ["%s: " % (text) for ch,text,f in self.bindings]
    self.signon = ''.join(signon)
#@nonl
#@-node:ekr.20051006121222.18:finishCreate
#@+node:ekr.20051006121222.19:initBindings
def initBindings (self):
    
    """Create key bindings for this mode using modeTable."""
    
    t = self.c.frame.statusText

    self.unbindAll()
    
    t.bind("<Key>",self.doNothing)
    t.bind("<Key-Escape>",self.exitMode)
    
    for ch,text,f in self.bindings:

        def inputModeCallback(event,self=self,ch=ch,text=text,f=f):
            return self.doKey(ch,text,f)

        t.bind("<Key-%s>" % ch, inputModeCallback)
#@nonl
#@-node:ekr.20051006121222.19:initBindings
#@+node:ekr.20051006121222.20:doKey
def doKey (self,ch,text,f):
    
    ch = ch.lower()
    
    if f is not None:
        self.exitMode(nextMode=f)
    else:
         g.trace(text)
         
    return "break"
    
    if ch == 'c':
        self.exitMode(nextMode=self.statusLine.findChangeMode)
    elif ch == 'f':
        self.exitMode(nextMode=self.statusLine.findMode)
    elif ch == 'p':
        self.exitMode(nextMode=self.statusLine.optionsMode)
    else:
        g.trace(text)
        # self.putStatusLine(text + ": ")

    return "break"
#@nonl
#@-node:ekr.20051006121222.20:doKey
#@-node:ekr.20051006121222.16:class topInputMode (baseInputMode)
#@+node:ekr.20051006121222.21:class optionsInputMode (baseInputMode)
class optionsInputMode (baseInputMode):
    
    """An input mode to set find/change options."""
    
    @others
#@nonl
#@+node:ekr.20051006121222.22:ctor
def __init__(self,c,statusLineClass):
    
    baseInputMode.__init__(self,c,statusLineClass)
    
    self.name = "optionsMode"
    self.clear = True
    self.findFrame = g.app.findFrame
    
    self.bindings = (
        ('a','Around','wrap'),
        ('b','Body','search_body'),
        ('e','Entire',None),
        ('h','Head','search_headline'),
        ('i','Ignore','ignore_case'),
        ('n','Node','node_only'),
        ('r','Reverse','reverse'),
        ('s','Suboutline','suboutline_only'),
        ('w','Word','whole_word'),
    )
    
    signon = ["%s " % (text) for ch,text,ivar in self.bindings]
    self.signon = ''.join(signon)
#@nonl
#@-node:ekr.20051006121222.22:ctor
#@+node:ekr.20051006121222.23:enterMode
def enterMode (self,event=None):
    
    baseInputMode.enterMode(self,event)
    
    # self.findFrame.top.withdraw()
    
    self.findFrame.bringToFront()
    
    # We need a setting that will cause the row/col update not to mess with the focus.
    # Or maybe we can just disable the row-col update.
    
    ### self.disableStatusLine()

    return "break"
#@nonl
#@-node:ekr.20051006121222.23:enterMode
#@+node:ekr.20051006121222.24:initBindings
def initBindings (self):
    
    """Create key bindings for this mode using modeTable."""
    
    t = self.c.frame.statusText

    self.unbindAll()
    
    t.bind("<Key>",self.doNothing)
    t.bind("<Key-Escape>",self.doEsc)
    t.bind("<Return>",self.doFindChange)
    t.bind("<Linefeed>",self.doFindChange)

    for ch,text,ivar in self.bindings:

        def initBindingsCallback(event,self=self,ch=ch,text=text,ivar=ivar):
            return self.doKey(ch,text,ivar)

        t.bind("<Key-%s>" % ch, initBindingsCallback)
#@nonl
#@-node:ekr.20051006121222.24:initBindings
#@+node:ekr.20051006121222.25:doFindChange
def doFindChange (self,event=None):
    
    g.trace(self.name)

    self.exitMode(nextMode=self.statusLine.topMode)

    return "break"
#@nonl
#@-node:ekr.20051006121222.25:doFindChange
#@+node:ekr.20051006121222.26:doEsc
def doEsc (self,event=None):
    
    # g.trace(self.name)

    self.exitMode(nextMode=self.statusLine.topMode)

    return "break"
#@-node:ekr.20051006121222.26:doEsc
#@+node:ekr.20051006121222.27:doKey
def doKey (self,ch,text,ivar):
    
    if ivar:
        intVar = self.findFrame.dict.get(ivar)
        if intVar:
            val = intVar.get()
            g.trace(text,val)
            # Toggle the value.
            intVar.set(g.choose(val,0,1))
            
        # self.findFrame.bringToFront()

    return "break"
#@nonl
#@-node:ekr.20051006121222.27:doKey
#@-node:ekr.20051006121222.21:class optionsInputMode (baseInputMode)
#@+node:ekr.20051006121222.28:class textInputMode (baseInputMode):
class textInputMode (baseInputMode):
    
    """An input mode to set the find/change string."""
    
    @others
#@nonl
#@+node:ekr.20051006121222.29:ctor
def __init__(self,c,statusLineClass,change=False,willChange=False):
    
    baseInputMode.__init__(self,c,statusLineClass)
    
    if willChange:
        self.name = "findChangeTextMode"
        self.signon = "Replace: "
        self.clear = True
    elif change:
        self.name = "changeTextMode"
        self.signon = " By: "
        self.clear = False
    else:
        self.name = "findTextMode"
        self.signon = "Find: "
        self.clear = True

    self.change = change
    self.willChange = willChange
#@-node:ekr.20051006121222.29:ctor
#@+node:ekr.20051006121222.30:doFindChange
def doFindChange (self,event=None):
    
    c = self.c
    
    # g.trace(self.name)
    
    s = self.getStatusLine()
    newText = s[len(self.originalLine):]
    if newText and newText[-1] == '\n':
        newText = newText [:-1]
    
    if self.change:
        self.statusLine.changeText = newText
    else:
        self.statusLine.findText = newText

    if self.willChange:
        nextMode = self.statusLine.changeMode
    elif self.change:
        g.trace("CHANGE",repr(self.statusLine.findText),"TO",repr(self.statusLine.changeText))
        nextMode = None
    else:
        f = g.app.findFrame
        g.trace("FIND",repr(self.statusLine.findText))
        if 0:
            f.setFindText(findText)
        else:
            f.find_text.delete("1.0","end")
            f.find_text.insert("end",self.statusLine.findText)
        f.findNextCommand(self.c)
        nextMode = None

    self.exitMode(nextMode=nextMode)

    return "break"
#@-node:ekr.20051006121222.30:doFindChange
#@+node:ekr.20051006121222.31:initBindings
def initBindings (self):
    
    """Create key bindings for this mode using modeTable."""
    
    t = self.c.frame.statusText
    
    self.unbindAll()

    t.bind("<Key-Return>",self.doFindChange)
    t.bind("<Key-Linefeed>",self.doFindChange)
    t.bind("<Key-Escape>",self.doEsc)
    t.bind("<Key>",self.doKey)
#@nonl
#@-node:ekr.20051006121222.31:initBindings
#@+node:ekr.20051006121222.32:doEsc
def doEsc (self,event=None):
    
    # g.trace(self.name)

    self.exitMode(nextMode=self.statusLine.topMode)

    return "break"
#@-node:ekr.20051006121222.32:doEsc
#@+node:ekr.20051006121222.33:doKey
def doKey (self,event=None):
    
    if event and event.keysym == "BackSpace":
        
        # t = self.c.frame.statusText
        s = self.getStatusLine()
        
        # This won't work if we click in the frame.
        # Maybe we can disable the widget??
        if len(s) <= len(self.originalLine):
            return "break"
    
    return "continue"
#@nonl
#@-node:ekr.20051006121222.33:doKey
#@-node:ekr.20051006121222.28:class textInputMode (baseInputMode):
#@-node:ekr.20051006121222:inputMode classes
#@-node:ekr.20031218072017.434:Unused code
#@-all
#@nonl
#@-node:ekr.20031218072017.329:@thin ../doc/leoNotes.txt
#@-leo
