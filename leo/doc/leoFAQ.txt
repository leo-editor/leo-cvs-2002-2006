#@+leo-ver=4-thin
#@+node:EKR.20040524105011:@file-thin leoFAQ.txt
#@+all
#@+node:edream.110203163054.1051:Learning about Leo
#@+node:edream.110203163054.1052:What's the best way to learn to use Leo?
First, read the introduction to Leo at:
http://webpages.charter.net/edreamleo/intro.html

Then study LeoPy.leo, the source code for leo.py. The best way to learn about
Leo is to spend 15 or 20 minutes just browsing through the outline, not
worrying about details but just seeing how most nodes are organized and how
directives and section references are typically used. Then read Chapter 4 to
learn the details.

When studying leo.py, I would suggest paying particular attention to the
following:

1. The (Projects) tree shows how to use clones to represent tasks.

2. The @file leoNodes.py tree shows how to define more than one class in a
single file using several @others directives. Note that the @others directives
must be in separate nodes.

3. Most other files show how to use a single @others directive to define one
class.

4. Note in particular that the vast majority of methods are defined in unnamed
nodes.
#@nonl
#@-node:edream.110203163054.1052:What's the best way to learn to use Leo?
#@+node:edream.110203163054.1053:Where are the simple examples?
The file LeoDocs.leo contains two "Hello World" programs, using @file trees and
@root trees.

The file LeoPy.leo contains a large number of other examples, some small, some
large and complex.
#@nonl
#@-node:edream.110203163054.1053:Where are the simple examples?
#@+node:edream.110203163054.1054:Why should I use clones?
Leo's clones provide an excellent way of solving any organizational problem.
The fundamental principle is this: Clones create multiple views of data.

For example, whenever I have a task to do, say a new feature to implement, or a
non-trivial bug to fix, I create a new headline to represent that task. Let's
call such a headline a task headline. By convention, I enclose the headline in
parentheses and put an @ignore in the body text of the headline, but that's
just a convention I use.

I clone all nodes that relate to that task and move the clones under the
headline. Voila. I now have a new view of Leo's source code, containing all and
only those nodes that relate to the task. It is now trivial to find the parts
of code relating to the task. Note that I can change the cloned nodes under the
headline task in any way, and the clones under the @file tree also change and
the @file node itself is marked dirty so that when I save the .leo file all
affected @file trees are also saved. The task headline is a perfect place to
place notes about the task: why some approaches didn't work, to-do lists, test
data, whatever. You could even create @file nodes to create test files if you
want.

There are situations where you need to use @root trees. However, those
situations are rare. Most of the time you can use clones to great effect. For
extended examples, look at the (Projects) section in LeoPy.leo. That section
contains a large number of views of Leo itself.
#@nonl
#@-node:edream.110203163054.1054:Why should I use clones?
#@+node:edream.110203163054.1055:Which should I use: @root trees or @file trees?
Leo's @file trees and @root trees represent derived files within an outline.
Leo outlines may contain both @root and @file trees, and I recommend using
@file trees whenever possible.

Indeed, @file trees are much easier to use than @root trees:

1. @file trees require less markup than @root trees; all sections in @root
trees must have names, but @file trees usually contain many unnamed sections.
Within @file trees, the @others directive acts like a reference to all unnamed
sections.

2. The user must explicitly tangle and untangle @root trees using the Tangle
and Untangle commands. Leo tangles and untangles @file trees automatically,
tangling all changed @file trees when writing an outline and untangling all
@file trees when reading an outline.

However, @root trees are more flexible than @file trees.

1. Within @file trees, sections must be defined in descendents of the node that
contains the section reference.

2. Within @root trees a section may be defined anywhere within the @root tree,
regardless of where the section is referenced. Moreover, the @unit directive
expands the scope of section definitions in @root trees so that a section may
be referenced in several @root trees.

3. The meaning of section definitions in @root trees are independent of their
position within the tree.
#@nonl
#@-node:edream.110203163054.1055:Which should I use: @root trees or @file trees?
#@+node:ekr.20040411074926:How can I use Leo to develop Leo itself?
There is a trick that makes it very easy to develop Leo using Leo itself.  The trick is to create a workflow that separates editing from testing.

Putting test code in LeoPy.leo would waste a lot of time.  To run tests you would have to exit Leo and reload LeoPy. A much quicker way is to put all test code in a test.leo file.  So to change and test code, do the following:

1. Save LeoPy.leo but do NOT exit Leo. 

2. Quit the copy of Leo running test.leo, then reload test.leo.

3. Run test scripts from test.leo.

That's all. Python will recompile any changed .py files in the new copy of Leo.

BTW, I create a batch file called t.bat that runs test.leo, so to the "edit-reload-test" cycle is just:

1. Control-S (in LeoPy.leo: saves the .leo file)
2. t         (in a console window: runs test.leo, compiling all changed .py files as a side effect)
3. Control-E (in test.leo: runs the test script)

The benefits of the new workflow:

- test.leo loads  _much_ more quickly than LeoPy.leo does.  This new approach can increase the speed of the edit-reload-test cycle by more than a factor of 10.  Hitting Control-S, t, Control-E takes about 5 seconds.

- LeoPy.leo runs with the _old_ code, so it is much easier to fix syntax errors or exceptions in the _new_ code: just fix the problem and save LeoPy.leo _without_ closing LeoPy.leo., then restart test.leo. Tests are run on new code; editing is done on old, stable code.

- test.leo is the perfect place to develop test.  I can create and organize those tests and when I am done, test.leo is a log of my work.
#@nonl
#@-node:ekr.20040411074926:How can I use Leo to develop Leo itself?
#@-node:edream.110203163054.1051:Learning about Leo
#@+node:edream.110203163054.1056:Unicode and special characters
#@+node:edream.110203163054.1057:Some characters in derived files look funny. What can I do?
Internally, Leo represents all strings as unicode. Leo translates from a particular encoding to unicode when reading .leo files or derived files. Leo translates from unicode to a particular encoding when writing derived files. You may see strange looking characters if your text editor is expecting a different encoding.

The encoding used in any derived file is shown in the #@+leo line like this: #@+leo-encoding=iso-8859-1. Exception: the encoding is UTF-8 if no -encoding= field exists.  You can also use the @encoding directive to set the encoding for individual derived files.

If no @encoding directive is in effect, Leo uses settings in leoConfig.leo/.txt to translate to and from unicode. These settings are in the section in leoConfig.leo called

<< General configuration options, especially read-only mode >>

Here is a summary of those settings:

default_derived_file_encoding

This is the encoding used for derived files if no @encoding directive is in
effect. This setting is also used to encode files created by the Tangle
commands. The default is UTF-8 (case not important).

new_leo_file_encoding

This is the encoding specified in the following line of new .leo files: <?xml
version="1.0" encoding="UTF-8"> The default is UTF-8 (upper case for
compatibility for old versions of Leo). Important: once a .leo file is created
the <?xml..."> line can only be changed by hand. Changing the <?xml..."> line
by hand may cause unicode errors the next time the .leo file is loaded, so you
should change the <?xml..."> line by hand only when first creating a .leo file.

tk_encoding

This is the encoding that Leo uses to communicate with Tk text widgets. You
would typically use this setting only in an emergency. The section called <<
set app.tkEncoding >> in app.finishCreate sets this encoding as follows:

a)using the tk_encoding setting if it exists,
b) using locale.getpreferredencoding if it exists, or the equivalent code in pre-python
2.3 versions,
c) using sys.getdefaultencoding
d) defaulting to "utf-8"

Neither b nor c are guaranteed to give a valid encoding in all systems, and Leo
will ignore invalid encodings returned from b or c. Therefore, setting
tk_encoding in leoConfig may be needed.
#@nonl
#@-node:edream.110203163054.1057:Some characters in derived files look funny. What can I do?
#@+node:edream.110203163054.1058:Some characters are garbled when importing files. What can I do?
The encoding used in the file being imported doesn't match the encoding in
effect for Leo. You have two options:  Use the @encoding directive in an
ancestor of the node selected when doing the Import command to specify the
encoding of file to be imported.Set the tk_encoding option in
leoConfig.leo/.txt to the encoding you normally use. See the previous answer.
#@nonl
#@-node:edream.110203163054.1058:Some characters are garbled when importing files. What can I do?
#@-node:edream.110203163054.1056:Unicode and special characters
#@+node:edream.110203163054.1059:Using derived files
#@+node:edream.110203163054.1060:How do I prevent Leo from inserting sentinels in derived files?
You have two options, depending on whether you want to be able to use sections
or not.

Option 1: Use @nosentinelsfile trees.

Files derived from @nosentinelsfile trees contain no sentinels. However, Leo
creates derived files just as in @file trees. In particular, Leo expands
section references and understands the @others directive.

Option 2: Use @silentfile trees.

Files derived from @silentfile trees contain no sentinels. Moreover, Leo does
not expand section references in @silentfile trees. In other words, Leo creates
the derived file simply by writing all body text in outline order.

Leo can't update the outline unless the derived file contains sentinels, so Leo
does not update @nosentinelfile trees or @silentfile trees automatically when
you change the derived file in an external editor.

For complete details about @nosentinelfile trees and @silentfile trees, see the
child of this node.
#@nonl
#@+node:edream.110203163054.359:Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees
An @rawfile tree is a tree whose root headline starts with @rawfile <filename>.  Similarly, for @silentfile and @nosentinelsfile trees.

Leo creates files derived from @file and @nosentinelsfile trees in exactly the same way.  The _only_ difference is that files derived from @file trees contain sentinels, while files derived from @nosentinelsfile trees do not.  Therefore, Leo can not update outlines from changed made from files derived from @nosentinelfile trees.

Leo creates files derived from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. However, Leo recognizes the @ignore directive in the _ancestors_ of @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:

1. Leo writes no sentinel lines when writing @silentfile trees.  When writing @rawfile trees, Leo writes only the @+leo, @-leo, @+node, @-node, @+body and @-body sentinels. Therefore, Leo can update @rawfile trees, but _not_ @silentfile trees from changes made in derived files. Unlike @file and @rawfile trees, the primary source of information for an @silentfile tree is the outline containing it.

2. Within @silentfile trees only, if a headline starts with @@, Leo writes everything in the headline following the @@ just before the corresponding body text.

3. Files derived from @silentfile trees contain _nothing_ not contained in body text (or @@ headlines).  In particular, if body text does not end in a newline, the first line from the next node will concatenated to the last line of the preceding node.

In short, you can get any combination of sentinels/no sentinels and references/no references using @file, @nosentinelsfile, @rawfile and @silentfile trees.  This is shown in the following table:

                     Derived files        Sections and 
    Type of tree   contain sentinels?   @others expanded?
    ------------   ------------------   -----------------
           @file   yes                  yes
@nosentinelsfile   no                   yes
        @rawfile   yes                  no
     @silentfile   no                   no

New in Leo 3.10:

@file-asis is a synonym for @silentfile.
@file-nosent is a synonym for @nosentinelsfile.
@file-noref is a synonym for @rawfile.
#@-node:edream.110203163054.359:Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees
#@-node:edream.110203163054.1060:How do I prevent Leo from inserting sentinels in derived files?
#@+node:edream.110203163054.1061:How do I prevent Leo from expanding sections?
You have two options, depending on whether you want sentinel lines in your
derived file or not.

Option 1: Use @rawfiles trees.

Leo creates files derived from @rawfile trees by writing all the nodes of the
tree to the derived file in outline order. The derived file _does_ contain some
sentinels, so you _can_ update @rawfile trees from changes made to derived
files.

Option 1: Use @silentfiles trees.

Files derived from @silentfile trees contain no sentinels. Leo creates the
derived file simply by writing all body text in outline order.

Leo can't update the outline unless the derived file contains sentinels, so Leo
does not update @silentfile trees automatically when you change the derived
file in an external editor.

For complete details about @rawfile and @silentfile trees, see the child of
this node.
#@nonl
#@+node:edream.110203163054.359:Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees
An @rawfile tree is a tree whose root headline starts with @rawfile <filename>.  Similarly, for @silentfile and @nosentinelsfile trees.

Leo creates files derived from @file and @nosentinelsfile trees in exactly the same way.  The _only_ difference is that files derived from @file trees contain sentinels, while files derived from @nosentinelsfile trees do not.  Therefore, Leo can not update outlines from changed made from files derived from @nosentinelfile trees.

Leo creates files derived from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. However, Leo recognizes the @ignore directive in the _ancestors_ of @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:

1. Leo writes no sentinel lines when writing @silentfile trees.  When writing @rawfile trees, Leo writes only the @+leo, @-leo, @+node, @-node, @+body and @-body sentinels. Therefore, Leo can update @rawfile trees, but _not_ @silentfile trees from changes made in derived files. Unlike @file and @rawfile trees, the primary source of information for an @silentfile tree is the outline containing it.

2. Within @silentfile trees only, if a headline starts with @@, Leo writes everything in the headline following the @@ just before the corresponding body text.

3. Files derived from @silentfile trees contain _nothing_ not contained in body text (or @@ headlines).  In particular, if body text does not end in a newline, the first line from the next node will concatenated to the last line of the preceding node.

In short, you can get any combination of sentinels/no sentinels and references/no references using @file, @nosentinelsfile, @rawfile and @silentfile trees.  This is shown in the following table:

                     Derived files        Sections and 
    Type of tree   contain sentinels?   @others expanded?
    ------------   ------------------   -----------------
           @file   yes                  yes
@nosentinelsfile   no                   yes
        @rawfile   yes                  no
     @silentfile   no                   no

New in Leo 3.10:

@file-asis is a synonym for @silentfile.
@file-nosent is a synonym for @nosentinelsfile.
@file-noref is a synonym for @rawfile.
#@-node:edream.110203163054.359:Appendix 1 to Chapter 4: Using @rawfile, @silentfile and @nosentinlefile trees
#@-node:edream.110203163054.1061:How do I prevent Leo from expanding sections?
#@+node:edream.110203163054.1062:How do I generate files after using the Import commands?
The import commands insert @ignore directives in the top-level node. Leo does
this so that you won't accidentally overwrite your files after importing them.
Change the filename following @file or @root as desired, then remove the
@ignore directive. Saving the outline will then create the file.
#@nonl
#@-node:edream.110203163054.1062:How do I generate files after using the Import commands?
#@+node:edream.110203163054.1063:How can I create Javascript comments?
Q: I'm writing a Windows Script Component, which is an XML file with a CData
section containing javascript. I can get the XML as I want it by setting the
language to html, but how can I get the tangling comments inside the CData
section to be java-style comments rather than html ones?

A: In @file trees you use the @delims directive to change comment delimiters.
For example:

@delims /* */ 
Javascript stuff 
@delims <-- --> 
HTML stuff

Important: Leo2 can not revert to previous delimiters automatically; you must
change back to previous delimiters using another @delims directive.

In @root trees you can work around this problem using the @silent directive.
#@nonl
#@-node:edream.110203163054.1063:How can I create Javascript comments?
#@+node:edream.110203163054.1064:How can I disable PHP comments?
Here is a letter from Zvi Boshernitzan which might be helpful:

I was having trouble disabling <?php with comments (and couldn't override the
comment character for the start of the page).

Finally, I found a solution that worked, using php's heredoc string syntax:

-------------------------------
@first <?php
@first $comment = <<<EOD
EOD;

// php code goes here.
echo "boogie";

$comment2 = <<<EOD
@last EOD;
@last ?>
--------------------

  -- or --

---------------------
@first <?php
@first /*
*/

echo "hi";

@delims /* */
@last ?>
------------------------
#@nonl
#@-node:edream.110203163054.1064:How can I disable PHP comments?
#@+node:ekr.20040201114855.108:How can I use Leo with unsuppoorted languages?
Here is a posting which might be helpful:

http://sourceforge.net/forum/message.php?msg_id=2300457

The "@first" directive is the key to output useable code in unsupported
languages.  For example, to use Leo with the Basic language:

->body of a "@file" header:
-----------------------------Snippet
@first $IFDEF LEOHEADER
@delims '
@c
$ENDIF
-----------------------------End of snippet

So this would enable a basic compiler to "jump" over the "true"
LEO-header-lines; wich gives you:

-----------------------Derived file begins with:
$IFDEF LEOHEADER <-conditionnal compilation directive 
#@verbatim
#@+leo-ver=4 <-these lines not compiled
#@verbatim
#@+node:@file QParser005.INC
#@verbatim
#@@first
#@verbatim
#@delims ' 
'@@c
$ENDIF <-... Until here!
<rest of derived code file ... >
-----------------------end of snippet

This changes the comment symbol to " ' " apostrophe... making comments parseable
by a BASIC (or other language.)
#@nonl
#@-node:ekr.20040201114855.108:How can I use Leo with unsuppoorted languages?
#@+node:edream.110203163054.1065:How do I make derived files start with a shebang line?
Use the @first directive @file or @nosentinelsfile trees. Use the @silent in
@root trees.

The @first directive allows you to place lines at the very start of files
derived from @file nodes. For example, the body text of @file spam.py might be:

@first #! /usr/bin/env python

The body text of @file foo.perl might be:

@first #/usr/bin/perl

@first directives are recognized only at the start of the body text of @file nodes.
No text may precede @first directives. More than one @first directive may exist,
like this:

@first #! /usr/bin/env python
@first # more comments.
#@-node:edream.110203163054.1065:How do I make derived files start with a shebang line?
#@+node:edream.110203163054.1066:How do I use Leo to create cweb files?
Leo has good support for cweb. In @file trees can organize any part of cweb
code using _noweb_ sections. You can also use @rawfile, @silentfile or
@nosentinelsfile trees to create cweb files.

By default, cweb colors @space, @* and @** sections using the same syntax
coloring as for LaTeX. In addition, cweb colors C // and /*..*/ comments using
LaTeX coloring by default. You may change these defaults using the
color_cweb_doc_parts_with_latex and color_cweb_comments_with_latex options in
leoConfig.leo.

See the child of this node for full details.
#@nonl
#@+node:edream.110203163054.355:About cweb mode 
Cweb mode refers to how Leo tangles an outline when @language cweb is in effect or the cweb option in the Preferences Panel is in effect.

Leo treats _all_ cweb code in cweb mode as unevaluated text.  That is, Leo treats cweb control codes, including @<...@>, @<...@>=, @c, @space, @* and @** as "raw" text within cweb mode.  Leo does _not_ expand _cweb_ section references when writing derived files in cweb mode.  However, Leo _does_ expand _noweb_ section references, so you may use noweb sections to organize cweb files! You can create _noweb_ code and doc sections using the @code and @doc directives in place of @c and @space directives.

By default, cweb colors @space, @* and @** sections using the same syntax coloring as for LaTeX.  In addition, cweb colors C // and /*..*/ comments using LaTeX coloring by default.  You may change these defaults using the color_cweb_doc_parts_with_latex and color_cweb_comments_with_latex options in leoConfig.py.
#@nonl
#@-node:edream.110203163054.355:About cweb mode 
#@-node:edream.110203163054.1066:How do I use Leo to create cweb files?
#@+node:edream.110203163054.1067:Can @file trees contain material not in the derived file?
Everything in an @file tree must be part of the derived file: orphan and
@ignore nodes are invalid in @file trees. This restriction should not be
troublesome. For example, you can organize your outline like this:

+ myClass
..+ ignored stuff
..+ @file myClass

As usual, + denotes a headline. So you simply create a new node, called
myClass, that holds your @file tree and stuff you don't want in the @file tree.
#@nonl
#@-node:edream.110203163054.1067:Can @file trees contain material not in the derived file?
#@+node:EKR.20040521090400:How can I use Leo with older C compilers
Some older C compilers don't understand the "//" comment symbol, so using @language C won't work.

Moreover, the following does not always work either:

@comment /* */

This generates the following sentinel line:

/*@@comment /* */*/"

in the output file, and not all C compilers allow nested comments, so the last "*/" genereates an error.

The solution is to use:

#if 0
@comment /* */
#endif

Leo is happy: it recognizes the @comment directive.

The C compiler is happy: the C preprocessor strips out the offending line before the C
compiler gets it.

Thanks to Rich Ries for this tip.
#@nonl
#@-node:EKR.20040521090400:How can I use Leo with older C compilers
#@-node:edream.110203163054.1059:Using derived files
#@+node:edream.110203163054.1068:Customizing Leo
There are many ways to customize Leo.  The child of this node is a clone of Chapter 8: Customizing Leo of Leo's Users Guide.
#@nonl
#@+node:edream.110203163054.322:Overview of plugins and hooks
@nocolor

What is a plugin?

A plugin is a .py file that appears in Leo's plugin subdirectory. Leo tries to
import all such files while starting up. This is done at "start1" time, that
is, in the call to doHook("start1") in the run function in leo.py. Plugins
exist to define "hook code".

New in 3.11: Leo looks in the plugins folder for .py files. Leo tries to
import all such files at startup ("start2") time.

New in 4.1: Leo enables only plugins whose name appears in pluginsManager.txt.
Leo loads plugins in the order in which they appear in pluginsManager.txt. Leo
loads no plugins if pluginsManager.txt does not exist in the plugins directory.

What is hook code?

Leo automatically calls hook code at various times during Leo's execution.
Typical hooks are:

- "start2", called at the end of Leo's startup process,
- "command1", called before executing any of Leo's commands
- "idle", called at Tk's idle time, when nothing else is happening,

See the documentation for hooks in this file for full details.

N.B. Plugins can use "start2" hooks to override any of Leo's classes. See
"Overriding functions, methods & classes" in leoPlugins.leo for several
examples of how to do this.

How do plugins work?

Plugins register themselves when Leo imports them using the following code,
which should appear as the outer level of the .py file:

@color

"""A description of this plugin"""

registerHandler("xxx", onXXX)
__version__ = "1.2"
plugin_signon(__name__)
	
@nocolor

Line by line:

1) """A description of this plugin"""

This is a Python doc string describing the plugin. This string becomes the
value of the __name__ attribute for the module (.py file).

2) registerHandler("xxx", onXXX)

This line registers a handler called onXXX for the hook called "xxx". See the
documentation for hooks for a complete list of hook names that you can use
instead of "xxx". onXXX is the name of a function or method, presumably defined
in the plugin file, that Leo will call at "xxx" time. For example:

registerHandler("idle",onIdle)

will cause Leo to call the onIdle function at "idle" time.

You can pass a list of hook names as the first argument to registerHandler. For
example:

registerHandler(("bodykey1","bodykey2","headkey1","headkey2"), onKey)

3) __version__ = "1.2"

This assigns a version attribute to module. At present this attribute is used
by the plugin code that creates Leo's Plugins menu.

4) plugin_signon(__name__)

This line increases the count of loaded modules. The present code for
plugin_signon does not actually print separate signons--it seems to verbose.

About hook handlers

See the "About hooks" section of leoPlugins.leo for full documentation about
how to write hook handler routines, like onXXX or onKey in the examples above.
Basically, each hook should have this pattern:
	
@color

def onXXX (tag,keywords):
	c = keywords.get("c")
	otherKeyword = keywords.get("otherKeyword")
	<< do something with c and otherKeyword, etc. >>
	
@nocolor

In other words, keywords is a Python dictionary containing the keyword
arguments passed to the hook handler. See the See the "About hooks" section of
leoPlugins.leo for a list of the keywords passed to each hook handler.

The tag is the name of the hook. For example, tag would one of
"bodykey1","bodykey2","headkey1","headkey2", for the onKey hook handler in the
example above.

What's next?

It's one thing to know how to create a plugin. It's another to know how to
actually change Leo. Obviously, some study is needed. The place to start your
study is LeoPy.leo. In particular, study very carefully the section called
"Overview of code". Leo is a highly modular program, and Python is ideally
suited to this style of programming.
#@nonl
#@-node:edream.110203163054.322:Overview of plugins and hooks
#@+node:edream.110203163054.1069:I'm having trouble getting plugins to work.  What should I do?
Step 1: Set use_plugins = 1 in leoConfig.leo, then execute the Tangle All
command.

Or you can set use_plugins = 1 directly in leoConfig.txt.

Step 2: For a particular @file node in leoPlugins.leo, enable the code that
calls registerHandler by changing if 0: to if 1:

For example:

if 1: # Register the handlers...
	registerHandler("start2", onStart)

#@-node:edream.110203163054.1069:I'm having trouble getting plugins to work.  What should I do?
#@+node:edream.110203163054.1070:How can I add support for a new language?
1. What's the best way to go about adding a new @language? 

In the short term, the instructions are in LeoPy.leo in the Notes:How To:How to
add support for a new language section. This section contains clones of all
relevant parts of Leo that you will change.

Longer term, I plan to move to a scheme like JEdit's, which uses language
description files. Perhaps Leo could even use these files. However, this won't
happen for quite a while...

2. How can the changes be best folded back into Leo?

For now, you can only change Leo's source code and submit the changes for
inclusion in Leo's "official" code. Longer term you will be able to create
your own language description file.
#@nonl
#@-node:edream.110203163054.1070:How can I add support for a new language?
#@+node:edream.110203163054.319:Chapter 8: Customizing Leo
@nocolor

You may customize Leo in several ways:

I.  Using leoConfig.txt

When Leo first starts, Leo looks for a file called leoConfig.txt, derived from leoConfig.leo, which contains extensive documentation for each setting.  The settings in leoConfig.txt include:

- Fonts used in Leo's body, outline and log panes.
- Colors used for syntax coloring.
- Menu shortcuts for all menu items.
- Sizes and splitter orientation for newly created windows.
- Initial entries in the Recent Files menu, and the Find, Preferences and Compare panels.
- The format of .leo files.

The section called "Using leoConfig.leo and leoConfig.txt" gives the rules for how Leo uses these two files.

II. Using plugins and hooks

New in 3.11:  It is no longer necessary to modify customizeLeo.py.  Instead of modifying customizeLeo.py you now should add plugins to the plugins directory.  In fact, customizeLeo.py will soon disappear entirely.

During startup, Leo looks for plugins, i.e., files whose name matches mod_*.py in the plugins directory.  These plugins register functions called "hooks" to be called a various times during execution.  Full details are provided below.

Plugins provide the following advantages:

- Any time you see a nice hook handler that someone has written you can just copy it to a plugin file and it runs next time you start Leo.
- You don't have to keep updating a large and growing customizeLeo.py file.
- You can disable and enable hooks by renaming the relevant plugin file.
  (or by enabling or disabling the code in the plugin that registers hook functions).
- You don't have to merge code from hooks pertaining to the same Leo event.

When executing any command or handling any event, Leo calls hook routines registered from the plugin files.  The arguments to hooks are:

- "tag", a string telling the kind of command or event about to be executed, and
- "keywords", a Python dictionary whose keys depend on the specific command or event.

This is a very simple, powerful and general mechanism for customizing Leo as you see fit.  There are dozens of kinds of hooks, including the "command1" and "command2" hooks that are called before and after each of Leo's menu commands.  Leo will allow you to override most commands and event handling.  In many cases, if a hook returns any value except None Leo will assume that the hook has completely handled the command or event and will take no further action.  The details will be explained in full below.

Leo catches all exceptions raised in hook code, so you can modify hooks without worry.

SECURITY WARNINGS: Using hooks naively can create the potential for virus-like behavior.  Please read the section called SECURITY WARNINGS for full details.

III. Using convenience routines called from hooks.

Hook routines can import any file in Leo's source code and execute routines in that file.  Leo's contains a number of convenience routines designed to make common customization tasks easier.  Hooks can use these routines to create your own menus, to translate menus into other languages, and to create entries in the Open With menu.  These convenience routines are discussed in detail below.

IV. Setting app().realMenuNameDict inside hooks to translate menus into other languages.

This is discussed below.
#@nonl
#@+node:edream.110203163054.320:Using leoConfig.leo and leoConfig.txt
@nocolor

Leo will override settings in .leo files if it finds a file called leoConfig.txt in the config subdirectory.  Leo works just as before if it does not find a leoConfig.txt file.

You should make changes to leoConfig.txt by changing leoConfig.leo and then executing the Tangle All command.  There are two advantages to changing leoConfig.txt in this manner.  First, it is just easier to change leoConfig.leo.  Second, all comments are lost in leoConfig.txt when Leo updates it, so using leoConfig.leo as the primary data file means you will always have the comments available.

Leo looks for leoConfig.txt first in the directory specified by the Python variable sys.leo_config_directory.  You would typically set this variable in Python's sitecustomize.py file.  If this variable does not exist, Leo looks in the directory from which Leo was loaded.

The child of this node contains an example of leoConfig.txt that shows all the options that may be set.

Settings in leoConfig.txt overrides preferences in .leo files, but only for those items actually in leoConfig.txt, so you can choose which settings you want to override.  Also, a Leo ignores any setting in leoConfig.txt whose value is "ignore" (without the quotes). For example:

[prefs panel options]
tab_width = ignore

If a setting is overridden, it is _not_ written to the .leo file when the outline is saved.  Note that this does not change the file format: all previous versions of Leo will be able to read such .leo files.

The preceding is probably all you need to know to use leoConfig.txt.  The following discuss some minor details: 

1. When reading a .leo file, if a setting is found neither in leoConfig.txt nor in the .leo file, Leo uses a default, hard-coded value.  In leo.py 3.0 and later these default settings are found in tables that appear in the section called:

	<< define default tables for settings >>

in the file leoConfig.py. So it is now convenient to change settings in leo.py itself as well as in leoConfig.txt.

2. Leo will update leoConfig.txt unless the read_only option is on in leoConfig.txt.  

WARNING: there are problems when Leo does write leoConfig.txt: all comments are lost and options and sections are written in a random order.  This is due to problems in Python's ConfigParser module and will not be changed any time soon.

3. Provided the read_only option is off, Leo updates leoConfig.txt whenever it saves a .leo file or whenever the Preferences panel is closed without being canceled.  When updating leoConfig.txt, Leo will write only existing settings whose value is not "ignore".

4. When Leo saves a .leo file, Leo will write a Preferences setting to the .leo file only if the setting will not be written when updating leoConfig.txt.  In particular, changes made in the Preferences Panel will become permanent immediately if Leo the read_only option is off.  Otherwise the change will become permanent when any .leo file is saved.
#@nonl
#@-node:edream.110203163054.320:Using leoConfig.leo and leoConfig.txt
#@+node:edream.110203163054.321:Using plugins and hooks
Beginning with version 3.11, you may use plugins to customize how Leo works.  You can

- override or modify any command
- add or customize menus or
- translate menus into any language.

Plugins have full access to all of Leo's source code.  In particular, several convenience methods have been added to make customizing menus and commands easier.

Plugins are permanent: they will not go away when Leo is updated.  You can take
advantage of the latest CVS updates _without_ having to throw away your modifications.

Important warning: plugins must avoid blindly executing scripts in .leo files.  Doing so could expose all parts of your computer to malicious Python code.  The section called "Security warnings and precautions" discusses how to customize Leo safely and how to avoid several pitfalls.
#@nonl
#@+node:edream.110203163054.322:Overview of plugins and hooks
@nocolor

What is a plugin?

A plugin is a .py file that appears in Leo's plugin subdirectory. Leo tries to
import all such files while starting up. This is done at "start1" time, that
is, in the call to doHook("start1") in the run function in leo.py. Plugins
exist to define "hook code".

New in 3.11: Leo looks in the plugins folder for .py files. Leo tries to
import all such files at startup ("start2") time.

New in 4.1: Leo enables only plugins whose name appears in pluginsManager.txt.
Leo loads plugins in the order in which they appear in pluginsManager.txt. Leo
loads no plugins if pluginsManager.txt does not exist in the plugins directory.

What is hook code?

Leo automatically calls hook code at various times during Leo's execution.
Typical hooks are:

- "start2", called at the end of Leo's startup process,
- "command1", called before executing any of Leo's commands
- "idle", called at Tk's idle time, when nothing else is happening,

See the documentation for hooks in this file for full details.

N.B. Plugins can use "start2" hooks to override any of Leo's classes. See
"Overriding functions, methods & classes" in leoPlugins.leo for several
examples of how to do this.

How do plugins work?

Plugins register themselves when Leo imports them using the following code,
which should appear as the outer level of the .py file:

@color

"""A description of this plugin"""

registerHandler("xxx", onXXX)
__version__ = "1.2"
plugin_signon(__name__)
	
@nocolor

Line by line:

1) """A description of this plugin"""

This is a Python doc string describing the plugin. This string becomes the
value of the __name__ attribute for the module (.py file).

2) registerHandler("xxx", onXXX)

This line registers a handler called onXXX for the hook called "xxx". See the
documentation for hooks for a complete list of hook names that you can use
instead of "xxx". onXXX is the name of a function or method, presumably defined
in the plugin file, that Leo will call at "xxx" time. For example:

registerHandler("idle",onIdle)

will cause Leo to call the onIdle function at "idle" time.

You can pass a list of hook names as the first argument to registerHandler. For
example:

registerHandler(("bodykey1","bodykey2","headkey1","headkey2"), onKey)

3) __version__ = "1.2"

This assigns a version attribute to module. At present this attribute is used
by the plugin code that creates Leo's Plugins menu.

4) plugin_signon(__name__)

This line increases the count of loaded modules. The present code for
plugin_signon does not actually print separate signons--it seems to verbose.

About hook handlers

See the "About hooks" section of leoPlugins.leo for full documentation about
how to write hook handler routines, like onXXX or onKey in the examples above.
Basically, each hook should have this pattern:
	
@color

def onXXX (tag,keywords):
	c = keywords.get("c")
	otherKeyword = keywords.get("otherKeyword")
	<< do something with c and otherKeyword, etc. >>
	
@nocolor

In other words, keywords is a Python dictionary containing the keyword
arguments passed to the hook handler. See the See the "About hooks" section of
leoPlugins.leo for a list of the keywords passed to each hook handler.

The tag is the name of the hook. For example, tag would one of
"bodykey1","bodykey2","headkey1","headkey2", for the onKey hook handler in the
example above.

What's next?

It's one thing to know how to create a plugin. It's another to know how to
actually change Leo. Obviously, some study is needed. The place to start your
study is LeoPy.leo. In particular, study very carefully the section called
"Overview of code". Leo is a highly modular program, and Python is ideally
suited to this style of programming.
#@nonl
#@-node:edream.110203163054.322:Overview of plugins and hooks
#@+node:edream.110203163054.323:New plugin architecture
@nocolor

New in 3.11: Leo looks in the plugins folder for .py files. Leo tries to
import all such files at startup ("start2") time.

New in 4.1: Leo enables only plugins whose name appears in pluginsManager.txt.
Leo loads no plugins if pluginsManager.txt does not exist in the plugins directory.

The child of this node gives an example of the code that creates the Open With
menu. The following code, appearing at the end of mod_open_with.py, registers
two different hook functions. The on_idle function is the "idle" hook. The
create_open_with_menu is the "start2","open2" and "command2" hooks.

@color

# Register the handlers... 
registerHandler("idle", on_idle) 
registerHandler(("start2","open2","command2"), create_open_with_menu) 
es("...open with")
	
@nocolor
Plugins may call registerHandler with a hook name like "idle" or a list of hook
names like ("start2","open2","command2"). Also, you can use the "all" hook name
to indicate that code will be called for all hooks. This is useful for tracing
hooks. Plugins may also call registerExclusiveHandler for hooks that should not
be redefined in other plugins.

mod_open_with.py also contains the on_idle and create_open_with functions that
actually handle the hook. Such functions have two arguments: tag and keywords.
You will find many examples of this in LeoPy.leo.

About error checking:

At present Leo will disable all hooks if any hook throws an exception. In
practice this isn't a big deal, but something better could be done.

How to send me your plugins:

It should now be _much_ easier to submit a plugin for inclusion in LeoPy.leo.
Just send me a .leo file containing @file mod_your_plugin.py. Please have this
@file node be @ignored: this is more convenient for me. Ideally, your .leo file
should contain _only_ your plugin code.
#@nonl
#@+node:edream.110203163054.324:@file plugins/mod_open_with.py
@color
@language python
@ignore

"""Open With handler"""

from customizeLeo import *
from leoGlobals import *

@others

if 1: # Register the handlers...
	registerHandler("idle", on_idle)
	registerHandler(("start2","open2","command2"), create_open_with_menu)
	es("...open with")
#@nonl
#@+node:edream.110203163054.325:on_idle
# frame.OnOpenWith creates the dict as follows:
# dict = {"c":c, "v":v, "f":f, "path":path, "time":time}

def on_idle (tag,keywords):

	import os
	a = app()
	for dict in a.openWithFiles:
		path = dict.get("path")
		c = dict.get("c")
		v = dict.get("v")
		if path and os.path.exists(path):
			try:
				time = os.path.getmtime(path)
				if time and time != dict.get("time"):
					dict["time"] = time
					<< update v's body text >>
			except: pass
#@nonl
#@+node:edream.110203163054.326:<< update v's body text >>
<< set s to the new text >>
body = v.bodyString()
<< set conflict flag >>

if conflict:
	# Report the conflict & set update.
	import leoDialog
	d = leoDialog.leoDialog()
	message = "Conflict in %s.\n\n" % (v.headString())
	message += "Replace outline with external changes?"
	update = d.askYesNo("Conflict!",message) == "yes"
else:
	update = s != body

if update:
	h = v.headString()
	es("changed:" + h)
	v.setBodyStringOrPane(s)
	c.selectVnode(v)
	v.OpenWithOldBody = s
#@+node:edream.110203163054.327:<< set s to the new text >>
try:
	# Update v from the changed temp file.
	f=open(path)
	s=f.read()
	f.close()
except:
	es("can not open " + shortFileName(path))
	break
#@-node:edream.110203163054.327:<< set s to the new text >>
#@+node:edream.110203163054.328:<< set conflict flag >>
try:
	# The OpenWithOldBody attribute does not normally exist in vnodes.
	old_body = v.OpenWithOldBody
	conflict = body != old_body and body != s
except:
	conflict = v.isDirty() and body != s
#@-node:edream.110203163054.328:<< set conflict flag >>
#@-node:edream.110203163054.326:<< update v's body text >>
#@-node:edream.110203163054.325:on_idle
#@+node:edream.110203163054.329:create_open_with_menu
def create_open_with_menu (tag,keywords):

	if  (tag in ("start2","open2") or
		(tag=="command2" and keywords.get("label")=="new")):
	
		<< create the Open With menu >>

		# Enable the idle-time hook so we can check temp files created by Open With.
		from leoGlobals import enableIdleTimeHook
		enableIdleTimeHook(idleTimeDelay=500)
#@+node:edream.110203163054.330:<< create the Open With menu >>
@ Entries in the following table are the tuple (commandName,shortcut,data).
data is the tuple (command,arg,ext).
command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the extension ext,
Otherwise, Leo computes an extension based on what @language directive is in effect.
@c

idle_arg = "c:/python22/tools/idle/idle.py -e "

if 1: # Default table.
 table = (
  ("&Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
  ("&Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
  ("Word&Pad","Alt+Shift+T",("os.startfile",None,".txt")))
else: # David McNab's table.
 table = (
  ("X&Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)))

top().frame.createOpenWithMenuFromTable(table)
#@-node:edream.110203163054.330:<< create the Open With menu >>
#@-node:edream.110203163054.329:create_open_with_menu
#@-node:edream.110203163054.324:@file plugins/mod_open_with.py
#@-node:edream.110203163054.323:New plugin architecture
#@+node:edream.110203163054.172:About hooks
@nowrap

At startup time Leo looks all files of the form mod_*.py in the plugins
directory. Leo assumes that these files are "plugins" containing Python modules
that customizes Leo's operation. Leo attempts to import each file.

Each module should register routines that are called at various times during
execution. Such times are identified by strings known as "tags". The code in in
one or more plugins corresponding to each tag are known as the "hook" routines
for that tag. Leo catches exceptions (including syntax errors) in hook
routines, so it is safe to hack away on this code.

Leo passes two argument to all hook routines: the tag and a keywords dictionary
containing additional information. For example, keywords["label"] indicates the
kind of command for "command1" and "command2" hooks.

For some hooks, returning anything other than None "overrides" Leo's default
action. Hooks have full access to all of Leo's source code. Just import the
relevant file. For example, top() returns the commander for the topmost Leo
window.

The following table summarizes the arguments passed to hooks: ( Overrides is
"yes" if returning anything other than None overrides Leo's normal command or
event processing.)

tag argument                                              keys in keywords
(hook name)  overrides       when called                  dictionary argument
---------    ---------       -----------                  -------------------
"bodyclick1"   yes      before normal click in body       c,v,event
"bodyclick2"            after  normal click in body       c,v,event
"bodydclick1"  yes      before double click in body       c,v,event
"bodydclick2"           after  double click in body       c,v,event
"bodykey1"     yes      before body keystrokes            c,v,ch,oldSel,undoType
"bodykey2"              after  body keystrokes            c,v,ch,oldSel,undoType
"bodyrclick1"  yes      before right click in body        c,v,event
"bodyrclick2"           after  right click in body        c,v,event
"boxclick1"    yes      before click in +- box            c,v,event
"boxclick2"             after  click in +- box            c,v,event
"command1"     yes      before each command               c,v,label (note 2)
"command2"              after  each command               c,v,label (note 2)
"drag1"        yes      before start of drag              c,v,event
"drag2"                 after  start of drag              c,v,event
"dragging1"    yes      before continuing to drag         c,v,event
"dragging2"             after  continuing to drag         c,v,event
"end1"                  start of app.quit()
"enddrag1"     yes      before end of drag                c,v,event
"enddrag2"              after  end of drag                c,v,event
"headclick1"   yes      before normal click in headline   c,v,event
"headclick2"            after  normal click in headline   c,v,event
"headrclick1"  yes      before right click in headline    c,v,event
"headrclick2"           after  right click in headline    c,v,event
"headkey1"     yes      before headline keystrokes        c,v,ch
"headkey2"              after  headline keystrokes        c,v,ch
"hypercclick1" yes      before control click in hyperlink c,v,event
"hypercclick2"          after  control click in hyperlink c,v,event
"hyperenter1"  yes      before entering hyperlink         c,v,event
"hyperenter2"           after  entering hyperlink         c,v,event
"hyperleave1"  yes      before leaving  hyperlink         c,v,event
"hyperleave2"           after  leaving  hyperlink         c,v,event
"iconclick1"   yes      before single click in icon box   c,v,event
"iconclick2"            after  single click in icon box   c,v,event
"iconrclick1"  yes      before right click in icon box    c,v,event
"iconrclick2"           after  right click in icon box    c,v,event
"icondclick1"  yes      before double click in icon box   c,v,event
"icondclick2"           after  double click in icon box   c,v,event
"idle"                  periodically (at idle time)       c,v
"menu1"        yes      before creating menus             c,v        (note 3)
"menu2"        yes      before updating menus             c,v
"open1"        yes      before opening any file           old_c,new_c,fileName (note 4)
"open2"                 after  opening any file           old_c,new_c,fileName (note 4)
"openwith1"    yes      before Open With command          c,v,openType,arg,ext
"openwith2"             after  Open With command          c,v,openType,arg,ext
"recentfiles1" yes      before Recent Files command       c,v,fileName,closeFlag
"recentfiles2"          after  Recent Files command       c,v,fileName,closeFlag
"save1"        yes      before any Save command           c,v,fileName
"save2"                 after  any Save command           c,v,fileName
"select1"      yes      before selecting a vnode          c,new_v,new_v
"select2"               after  selecting a vnode          c,new_v,old_v
"select3"               after  selecting a vnode          c,new_v,old_v
"set-mark"     no       when a mark is set                c,v           (new)
"start1"       no       after app.finishCreate()
"start2"                after opening first Leo window    c,v,fileName
"unselect1"    yes      before unselecting a vnode        c,new_v,old_v
"unselect2"             after  unselecting a vnode        c,old_v,old_v
"@url1"        yes      before double-click @url node     c,v           (note 5)
"@url2"                 after  double-click @url node     c,v           (note 5)

Notes:

(1) "activate" and "deactivate" hooks: These have been removed because they do
not work as expected.

(2) "commands" hooks: The label entry in the keywords dict contains the
"canonicalized" form of the command, that is, the lowercase name of the command
with all non-alphabetic characters removed.

Commands hooks now set the label for undo and redo commands "undo" and "redo"
rather than "cantundo" and "cantredo".

(3) "menu1" hook: Setting app().realMenuNameDict in this hook is an easy way of
translating menu names to other languages. Note: the "new" names created this
way affect only the actual spelling of the menu items, they do _not_ affect how
you specify shortcuts in leoConfig.txt, nor do they affect the "official"
command names passed in app().commandName. For example, suppose you set
app().realMenuNameDict["Open..."] = "Ouvre".

(4) "open1" and "open2" hooks: These are called with a keywords dict containing
the following entries:

old_c: The commander of the previously open window.
new_c: The commander of the newly opened window.
fileName: The name of the file being opened.

You can use old_c.currentVnode() and new_c.currentVnode() to get the current
vnode in the old and new windows.

Leo calls the "open1" and "open2" hooks only if the file is already open. Leo
will also call the "open1" and "open2" hooks if: a) a file is opened using the
Recent Files menu and b) the file is not already open.

(5) "@url1" and "@url2" hooks are only executed if "icondclick1" hook returns None.


New in version 3.12:

The following hooks are a new breed of hook, called "stub hooks". Conceptually,
these hooks are like calls to stub routines that can be filled in by code in
plugins.

tag argument                                                       keys in keywords
(hook name)               overrides        when called           dictionary argument
---------                 ---------        -----------           -------------------
"after-redraw-outline"       no        end of tree.redraw        c (note 6)
"clear-mark"                 no        when mark is set          c,v
"close-frame"                no        in app.closeLeoWindow     c
"color-optional-markup"      yes *     (note 7)                  colorer,v (note 7)
"create-optional-menus"      no        (note 8)                  (note 8)
"create-popup-menu-items"    no        in tree.OnPopup           c,v,event (new)
"destroy-all-global-windows" no        (note 12)                 None
"draw-outline-box"           yes       start of drawBox          tree,p,v,x,y (note 6)
"draw-outline-icon"          yes       start of tree.drawIcon    tree,p,v,x,y (note 6)
"draw-outline-node"          yes       start of tree.drawNode    tree,p,v,x,y (note 6)
"draw-outline-text-box"      yes       start of tree.drawText    tree,p,v,x,y (note 6)
"draw-sub-outline"           yes       start of tree.drawTree    tree,p,v,x,y,h,level (note 6)
"enable-popup-menu-items"    no        in tree.OnPopup           c,v,event (new)
"init-color-markup"          no        (note 7)                  colorer,v,s,i,j,colortag (note 7)
"new"                        no        start of New command      old_c,new_c (note 9)
"redraw-entire-outline"      yes       start of tree.redraw      c (note 6)
"scan-directives"            no        in scanDirectives         c,v,s,old_dict,dict,pluginsList (note 10)
"set-mark"                   no        when mark is set          c,v
"show-popup-menu"            no        in tree.OnPopup           c,v,event

Notes:

(6) These hooks are useful for testing.

(7) These stub hooks allow plugins to parse and handle markup withing doc
parts, comments and Python """ strings. Note that these hooks are _not_ called
in Python ''' strings. See the color_markup plugin for a complete example of
how to use these hooks.

(8) The "create-optional-menus" stub hook is called when Leo is creating menus,
at the place at which creating new menus is appropriate. Therefore, this hook
need only create new menus in the correct order, without worrying about the
placement of the menus in the menu bar. See the plugins_menu and scripts_menu
plugins for examples of how to use this hook. Leo now executes hooks in
alphabetical order, so that the Plugins menu will be created before the Scripts
menu.

(9) The "new" stub hook is called at the beginning of the code that implements
the New command. This provides a much easier way of recognizing when Leo is
about to create a new Leo window.

(10) The "scan-directives" stub hooks is called inside the scanDirectives
global function. The dictionary returned by scanDirectives now contains an item
whose key is "pluginsList". The value of this item is a list of tuples
(d,v,s,k) where:

- d is the spelling of the @directive, without the leading @.
- v is the vnode containing the directive, _not_ the original vnode.
- s[k:] is a string containing whatever follows the @directive. k has already
been moved past any whitespace that follows the @directive.

See the add_directives plugins directive for a complete example of how to use
the "scan-directives" stub hook.

(11) The "close-frame" stub hook is called in app.closeLeoWindow just before
removing the window from app.windowList. The hook code may remove the window
from app.windowList to prevent app.closeLeoWindow from destroying the window.

(12) Leo calls the "destroy-all-global-windows" hook in app.destroyAllGlobalWindows().
This hook gives plugins the chance to clean up after themselves when Leo shuts down.
#@nonl
#@-node:edream.110203163054.172:About hooks
#@+node:edream.110203163054.331:SECURITY WARNINGS
Naively using hooks can expose you and your .leo files to malicious attacks.  You will be safe as long as you follow these basic principles:

1. Hooks should _never_ blindly execute Python scripts in .leo files. Blindly executing scripts in .leo files runs the extreme risk of executing malicious code if you ever share any .leo file with someone else.  Moreover, using rexec instead of exec WILL NOT PROTECT YOU.  See the children of this node for further discussion of this important topic.

2. Hooks can execute any code safely _provided_ that all code is contained entirely within the plugin file. If you have a nifty customization that you want to do on a particular .leo file, put that code into a plugin.

3. Use only authentic copies of Leo that come from Leo's SourceForge site.
#@nonl
#@+node:edream.110203163054.332:The danger of trusting code in shared .leo files
I'd like to thank Stephen Schaefer for gently insisting that we must guard against malicious code in shared .leo files.  Here is a little story Stephen told on Leo's SourceForge site that makes clear what the danger is:

"I foresee a future in which the majority of leo projects come from marginally trusted sources...I see a world of leo documents sent hither and yon - resumes, project proposals, textbooks, magazines, contracts - and as a race of Pandora's, we cannot resist wanting to see "What's in the box?" And are we going to fire up a text editor to make a detailed examination of the ASCII XML? Never! We're going to double click on the cute leo file icon, and leo will fire up in all its raging glory. Just like Word (and its macros) or Excel (and its macros)."

This succinctly illustrates the fundamental problem: when we share "our" .leo files we can _not_ assume that we know what is our "own" documents.  So hooks that naively searches through .leo files looking for scripts to execute is looking for big trouble.

The following node contains an example of the kind of code that is extremely dangerous.
#@nonl
#@-node:edream.110203163054.332:The danger of trusting code in shared .leo files
#@+node:edream.110203163054.333:NEVER use this kind of code in a hook!!
@color
@ WARNING ***** Using the following routine exposes you to malicious code in .leo files! *****

Do not EVER use code that blindly executes code in .leo files!
Someone could send you malicious code embedded in the .leo file.

WARNING 1: Changing "@onloadpythonscript" to something else will NOT protect
           you if you EVER share either your files with anyone else.

WARNING 2: Replacing exec by rexec below provides NO additional protection!
           A malicious rexec script could trash your .leo file in subtle ways.
@c
if 0: # WRONG: This blindly execute scripts found in an .leo file! NEVER DO THIS!
	def onLoadFile():
		v = top().rootVnode()
		while v:
			h = v.headString().lower()
			if match_word(h,0,"@onloadpythonscript"):
				s = v.bodyString()
				if s and len(s) > 0:
					try: # SECURITY BREACH: s may be malicious!
						exec(s + '\n',__builtins__,__builtins__)
					except:
						es_exception()
			v = v.threadNext()
#@-node:edream.110203163054.333:NEVER use this kind of code in a hook!!
#@+node:edream.110203163054.334:Don't use rexec !!
@color
@ It would be most foolish to expect rexec to protect you against malicious code contained in .leo files.  Remember that Leo is a repository of source code, so any text operation is potentially malicious.

For example, consider the following script.  This script is valid in rexec mode:
@c

c = top()
thisNode = c.currentVnode()
v = c.rootVnode()
while v:
	<< change all instances of rexec to exec in v's body >>
	v = v.threadNext()
<< delete thisNode >>
<< clear the undo stack >>

@ This script will introduce a security hole the .leo file without doing anything prohibited by rexec, and without leaving any traces of the perpetrating script behind.  The damage will become permanent _outside_ this script when the user saves the .leo file.
#@+node:edream.110203163054.335:<< change all instances of rexec to exec in v's body >>
pass
#@nonl
#@-node:edream.110203163054.335:<< change all instances of rexec to exec in v's body >>
#@+node:edream.110203163054.336:<< delete thisNode >>
pass
#@nonl
#@-node:edream.110203163054.336:<< delete thisNode >>
#@+node:edream.110203163054.337:<< clear the undo stack >>
pass
#@nonl
#@-node:edream.110203163054.337:<< clear the undo stack >>
#@-node:edream.110203163054.334:Don't use rexec !!
#@-node:edream.110203163054.331:SECURITY WARNINGS
#@+node:edream.110203163054.338:Convenience routines for plugins
Hooks have full access to all of Leo's source code simply by importing it.

Moreover, several convenience methods have been added to make customizing menus and commands easier.  The following paragraphs discuss these routines and how to use them.

#@+node:edream.110203163054.339:Convenience functions to enable and disable the "idle" hook
The following routines enable and disable "idle" hooks.  They are defined in leoGlobals.py.

enableIdleTimeHook(idleTimeDelay=100)

Enables the "idle" hook. After this routine is called Leo will call the "idle" hook approximately every idleTimeDelay milliseconds.  Leo will continue to call the "idle" hook periodically until disableIdleTimeHook() is called.

disableIdleTimeHook()

Disables the "idle" hook.
#@nonl
#@-node:edream.110203163054.339:Convenience functions to enable and disable the "idle" hook
#@+node:edream.110203163054.340:Convenience methods to create, destroy and modify menus
The following convenience routines make creating menus easier.

These are methods of the leoFrame class.  Use top().frame to get the frame object for the presently active Leo window.

The plugins node in LeoPy.leo gives examples of how to use these routines to create custom menus and to add items to the Open With menu.

These convenience methods all do complete error checking and write messages to the log pane and to the console if errors are encountered.
#@nonl
#@+node:edream.110203163054.341:createMenuItemsFromTable
@nocolor
createMenuItemsFromTable (self,menuName,table,openWith=0)

This method adds items to the menu whose name is menuName.  The table argument describes the entries to be created.  This table is a sequence of items of the form (name,shortcut,command).

- name is the command name
- shortcut is the shortcut, or None to indicate no shortcut.
- command is the routine to execute when the menu item is selected.

An entry of the form ("-",None,None) indicates a separator line between menu items.

For example:
@color
table =
	("Toggle Active Pane","Ctrl-T",self.OnToggleActivePane),
	("-",None,None),
	("Toggle Split Direction",None,self.OnToggleSplitDirection))

top().frame.createMenuItemsFromTable("Window",table)
@nocolor

If the openWith keyword argument is 1 the items are added to a submenu of the Open With menu.  However, it will be more convenient to use the createOpenWithMenuFromTable method to create the Open With menu.
#@-node:edream.110203163054.341:createMenuItemsFromTable
#@+node:edream.110203163054.342:createNewMenu
createNewMenu (self,menuName,parentName="top")

This method creates a new menu:

- menuName is the name of the menu to be created.
- parentName is the name of the parent menu, or "top" if the menu is to created in the menu bar.

This method returns the menu object that was created, or None if there was a problem.  Your code need not remember the value returned by this method.  Instead, your code will refer to menus by name.
#@-node:edream.110203163054.342:createNewMenu
#@+node:edream.110203163054.343:createOpenWithMenuFromTable
createOpenWithMenuFromTable (self,table)

This method adds items to submenu of the Open With menu item in the File menu.

The table argument describes the entries to be created.  This table is a sequence of items of the form (name,shortcut,data).

- name is the command name
- shortcut is the shortcut, or None to indicate no shortcut.
- data is a tuple of the form (command,arg,ext)
- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- arg is an argument to be passed to the given command.
- ext is a file extension or None.

When the user selects the Open With item corresponding to the table item Leo executes command(arg).
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on what @language directive is in effect.

For example:

table = (
	("Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
	("Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
	("Wordpad","Alt+Shift+T",("os.startfile",None,".txt")))

top().frame.createOpenWithMenuFromTable(table)
	
#@nonl
#@-node:edream.110203163054.343:createOpenWithMenuFromTable
#@+node:edream.110203163054.344:deleteMenu
deleteMenu (self,menuName)

Deletes the menu whose name is given, including all entries in the menu.
#@nonl
#@-node:edream.110203163054.344:deleteMenu
#@+node:edream.110203163054.345:deleteMenuItem
deleteMenuItem (self,itemName,menuName="top")

Deletes the item whose name is itemName from the menu whose name is menuName.  To delete a menu in the menubar, specify menuName="top".
#@nonl
#@-node:edream.110203163054.345:deleteMenuItem
#@+node:edream.110203163054.346:Example: how to create a menu
@nocolor
The leoFrame class creates the Window menu as follows:
@color

windowMenu = self.createNewMenu("&Window")

table = (
	("&Equal Sized Panes","Ctrl-E",self.OnEqualSizedPanes),
	("Toggle &Active Pane","Ctrl-T",self.OnToggleActivePane),
	("Toggle &Split Direction",None,self.OnToggleSplitDirection),
	("-",None,None),
	("Casca&de",None,self.OnCascade),
	("&Minimize All",None,self.OnMinimizeAll),
	("-",None,None),
	("Open &Compare Window",None,self.OnOpenCompareWindow),
	("Open &Python Window","Alt+P",self.OnOpenPythonWindow))

self.createMenuEntries(windowMenu,table)
#@-node:edream.110203163054.346:Example: how to create a menu
#@-node:edream.110203163054.340:Convenience methods to create, destroy and modify menus
#@-node:edream.110203163054.338:Convenience routines for plugins
#@+node:edream.110203163054.347:Translating menus into other languages
@nocolor

It is easy for hooks to translate menus into another language.  For example, code similar to the following code would typically be found in the "start2" hook:

@color

table = (
	("Open...","&Ouvre"),
	("OpenWith","O&uvre Avec..."),
	("close","&Ferme"),
	("Undo Typing","French &Undo Typing"), # Shows you how much French I know ;-)
	("Redo Typing","French &Redo Typing"),
	("Can't Undo", "French Can't Undo"),
	("Can't Redo", "French Can't Redo"))
# Call the convenience routine to do the work.
app().setRealMenuNamesFromTable(table)
#@nonl
#@-node:edream.110203163054.347:Translating menus into other languages
#@+node:edream.121403162622:Support for unit testing
New in 4.1: The plugins test suite creates a new convention: if a plugin has a
function at the outer (module) level called unitTest, Leo will call that
function when doing unit testing for plugins. So it would be good if writers of
plugins would create such a unitTest funcion. The unitTest function should run
some tests. All unitTest needs to do to indicate failure is throw an exception
or cause an assert to fail. Leo's plugins test suite takes care of the rest.
#@nonl
#@-node:edream.121403162622:Support for unit testing
#@-node:edream.110203163054.321:Using plugins and hooks
#@+node:edream.110203163054.61:Putting the Leo icon in Leo windows
New in Leo 4.0 and Python 2.3: Leo will draw a Leo icon in all Leo windows.  There is no need to install PIL or tkIcon.

Otherwise (for versions of Leo before 4.0 and for versions of Python before 2.3) Leo will draw a Leo icon in Leo windows only if you have installed Fredrik Lundh's PIL and tkIcon packages.

Download PIL from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
#@nonl
#@-node:edream.110203163054.61:Putting the Leo icon in Leo windows
#@+node:edream.110203163054.348:Extending the format of .leo files
New in 4.0: Leo can now read and write "foreign" attributes in <v> and <t> elements in .leo files:

- When reading a .leo file, Leo will create t.unknownAttributes or v.unknownAttributes ivars for any tnode and vnode object whose corresponding <v> or <t> element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are a dictionary whose keys are the attribute names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if  a vnode or tnode contains an unknownAttributes ivar.

- The only "native" attributes that Leo expects to find are the "tx" attribute in <t> elements and the "a", "t", "vtag" and "tnodeList" attributes of <v> elements.  Everything else is a foreign attribute.

- Leo performs the usual xml escapes on these strings when reading or writing the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching unknownAttributes ivars to a vnode or tnode.  For example:

	v.unknownAttributes = {"vnodeIcon" : pathToIcon}

It would be best not to delete other foreign attributes, so the following would be preferred:

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

Another way:

	try:
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	except AttributeError:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

See the section called "Recommended conventions for plugins" for advice about how to avoid potential conflicts in naming new attributes.
#@nonl
#@-node:edream.110203163054.348:Extending the format of .leo files
#@+node:edream.120703073611:Attaching temporary attributes to vnodes and tnodes
Plugins may create (or add to) v.tempAttributes (for vnodes) or t.tempAttributes (for tnodes).  These will work just like the corresponding unknownAttributes dicts except that Leo will _not_ read or write these dictionaries when reading or writing files.  Note: nothing needs to change in Leo to support this convention.
#@nonl
#@-node:edream.120703073611:Attaching temporary attributes to vnodes and tnodes
#@+node:edream.120703073611.1:Recommended conventions for plugins
@nocolor

We wish to avoid the possibility that two plugins might unwittingly choose the same name for attributes in the unknownAttributes or tempAttributes dictionaries.  The following convention eliminates that possibility.

Each plugin should create its own dictionary _inside_ any tempAttributes or unknownAttributes dictionaries that it intends to create or modify.  Something like this:

@color

# Create the tempAttributes dict for this vnode.
if not v.hasattr("tempAttributes"):
	v.tempAttributes = {}

# Create a subdictionary for the private use of my plugin.
d = v.tempAttributes.get("myPluginName")
if d is None:
	v.tempAttributes["myPluginName"] = d = {}

@nocolor

Now the plugin can set and get fields in d.  Similar code would be used for the t.tempAttributes, v.unknownAttributes and t.unknownAttributes dictionaries.
#@nonl
#@-node:edream.120703073611.1:Recommended conventions for plugins
#@+node:edream.110603190322.6: Script Find and Script Change
@nocolor

New in 4.1: Leo now supports scripts in Leo's Find/Change dialog.

Leo's find panel now contains the Script Search radio button and the Script
Change checkbox. When the Script Search radio button is selected Leo treats the
contents of the Search Text as a script to execute whenever any kind of Find
command is executed. Similarly, when the Script Change checkbox is selected Leo
treats the context of the Change Text as a script to execute whenever any kind
of Change command is executed. See below for just how this works.

Script-based find-change is extremely powerful. In effect, Leo's Find/Change
panel becomes a new platform for running scripts interactively. Leo now has all
the find/change capability of pattern matching languages like Snobol and Icon,
just by using the capabilities of the plain Python language. Moreover, Leo can
deliver these capabilities interactively or not depending which buttons you push
in Leo's Find/Change panel.

Script-based find/change frees the user from having to control script-based
searches interactively. Rather than forcing find/change scripts to implement
their own interactive controls, it is much easier to use what Leo already has.
#@nonl
#@+node:edream.111803060152.1:How it works
Leo dedicates a Python dictionary called app.searchDict for communication
between Leo and the search and change scripts. The search and change scripts may
also use app.searchDict for communication between themselves. Leo sets
app.searchDict["type"] to "find", "change", "findAll" or "changeAll" to indicate
the kind of command being executed. Scripts may use all other entries in
app.searchDict as they please.

Leo executes the find script once when you press the Find button (or the Change
then Find button) in Leo's Find/Change dialog. Typically, the find script would
traversing the tree and highlight the found text or otherwise indicate to the
user that the find operation has suceeded. However, the script can do anything
it pleases.

Leo executes the the find script repeatedly when you press the Find All button.
Leo keeps executing the find script until app.searchDict["continue"] evaluates
to false. Initially there is no entry for app.searchDict["continue"], so the
find script must set app.searchDict["continue"] = true if it wants Leo to keep
executing it.

Leo executes the change script once when you press the Change button. Typically,
the change script would change the selected text. Usually the change script will
compute the new value of body text and call v.setBodyStringOrPane(newText) to
make that change permanent. 

The change script also may handle undo, typically by calling
c.frame.onBodyChanged(v,"Change",oldText=oldText). Leo does not handle undo
automatically. Indeed, Leo makes no assumptions whatever about what the change
script really does.

Leo executes the the change script repeatedly when you press the Change All
button. Just as with the Find All command, Leo keeps executing the change script
until app.searchDict["continue"] evaluates to false.

Most find and change scripts will ignore settings in the Find Panel like "whole
word", "pattern match", and "reverse". However, these settings are available to
the scripts via ivars such as c.whole_word_flag, etc. if desired.
#@nonl
#@-node:edream.111803060152.1:How it works
#@+node:ekr.20040201113232:Using the initScriptFind script
@nocolor

The Scripts node in LeoPy.leo contains a script called initScriptFind.  This script makes it easy to set up script based searches as follows:

1. Put the following code in the root of a tree that will contain your script search:

@color
# Initialize Leo's find panel using the named children of this node.
from leoGlobals import *
initScriptFind("Find script","Change script") # Second argument is optional.
# Start searching at the top.
top().selectVnode(c.rootVnode())
@nocolor

2. Put the search script in a child node called "Find script" (no quotes).

3. (Optional) Put the change script in a child node called "Change script"

4.  Execute the code above.  Leo does the following:

- Puts the body of the "Find script" into the find text of Leo's Find/Change dialog.
- Puts the body of the "Change script" into the change text of Leo's Find/Change dialog.
- Selects the Script Find radio button.
- Selects the Script Change checkbox if the change script exists.
- Selects the root of the entire outline.

Presto!  Leo is ready for a script search.
#@nonl
#@-node:ekr.20040201113232:Using the initScriptFind script
#@+node:edream.111803060152.2:Ideas for using scripts
@nocolor

Some ideas for using scripts:
	
Either the find and change scripts may use Python's re module.  For
example, the find script could set app.searchDict["m"] to the match object
returned by re's match method.  The change script would then compute the
result, change the text and set the undo info as usual.

There is no reason to confine find/change scripts to operate on data only
within a Leo outline. These scripts could as easily traverse your file system
as the Leo outline. But notice: scripts could pull data from the file system
into the outline so that you can see the effects of changes as the scripts
operate. Again, this can all happen interactively if you like.
#@nonl
#@-node:edream.111803060152.2:Ideas for using scripts
#@-node:edream.110603190322.6: Script Find and Script Change
#@-node:edream.110203163054.319:Chapter 8: Customizing Leo
#@-node:edream.110203163054.1068:Customizing Leo
#@+node:edream.120903151103:Importing files
#@+node:edream.120903151103.1:How can I import many files at once?
@nocolor

There is an importFiles script in LeoPy.leo.  You can use that script as follows:

@color

import leoImport
leoImport.importFiles(aDirectory, ".py")

@nocolor

This will import all .py files from aDirectory, which should be a full path to a particular directory.  You could use ".c" to import all .c files, etc.
#@nonl
#@-node:edream.120903151103.1:How can I import many files at once?
#@-node:edream.120903151103:Importing files
#@+node:edream.110203163054.1071:Other topics
#@+node:edream.110203163054.1072:How can I cut and paste nodes between different copies of Leo
leo.py v2.5 and later does this automatically.

For earlier versions, the workaround is as follows:

1. Copy the node with the Copy Node command.
2. Paste it into to _body_ text with a regular paste command.
3. Copy the body text with a regular copy or cut command.
4. Switch to the other copy of Leo, then do Paste Node.
#@nonl
#@-node:edream.110203163054.1072:How can I cut and paste nodes between different copies of Leo
#@+node:edream.110203163054.1073:How can I add support in Leo for a new language?
@nocolor

Here are the steps involved in adding a new language.

- Add a new language constant in leoGlobals.<<define global constants>>

- Add a new Tk.Radiobutton in leoPrefs.<<create the Target Language frame>>

- Add a new entry for the language in self.languageNameDict in leoConfig.py.<<initialize constant ivars>>.

This entry represents the name of the language in leoConfig.txt.

- Modify the utility routines set_delims_from_language and set_language to handle the new language.

- Modify the code in leoFileCommands.getPrefs.<< check for syntax coloring prefs >> to support the new language.

This involves making new entries in lists in each function.

- Modyify leoColor.py so that colorizeAnyLanguage will handle the new language:

a. Add an entry in the list called "languages" defined  in
	leoColor.<<configure language-specific settings>>

b. Add a list containing the keywords of the new language to
	leoColor.<< define colorizer keywords >>
	
Note: the name of this list must be x_keywords, where x is the entry in language in step a.
	
For example, to add tcltk:
	
	languages = (..., "tcltk",...) # list of names of keyword lists.
	tcltk_keywords = ("after", "append", ...) # The keyword list for the tcl/tk language.
		
c. Add any language-specifig code to leoColor.colorizeAnyLanguage.

For most languages nothing need be done in this step because colorizeAnyLanguage gets the comment delimiters from set_delims_from_language.

-  Make the following tests:

1. Test the syntax coloring for the new language by using the @language directive.

2. Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

3. Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

4. Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the <preferences> tag (near the top) contains an entry like this:

<preferences allow_rich_text="0" defaultTargetLanguage="Python">
</preferences>

but with the name of your new language instead of "Python".

5. Create an @root node and verify that you can Tangle it.

#@+node:edream.110203163054.1074:code
# We put an @color here so it is unambiguous.

@ignore
@language python
@color
#@nonl
#@+node:edream.110203163054.1075:<< define global constants >>
# General constants...
true = 1
false = 0 # Better than None
body_newline = '\n'
body_ignored_newline = '\r'
prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
prolog_prefix_string = "<?xml version=\"1.0\" encoding="
prolog_version_string1 = "UTF-8" # for leo.py 2.x
prolog_version_string2 = "ISO-8859-1" # for leo.py 3.x
prolog_postfix_string = "?>"

# These are set by the @langauge directive.
# Used by Tangle, Untangle and syntax coloring.
ada_language =		 1
c_language =		 2  # C, C++ or objective C.
cweb_language =		 3  # CWEB syntax coloring
cobol_language =	 4  # literate cobol??
fortran_language =	 5  # Comments start with C
fortran90_language =	 6  # Comments start with !
html_language =		 7
java_language =		 8
lisp_language =		 9
pascal_language =	10
plain_text_language =	11
perl_language =		12  # just ##
perlpod_language =	13  # ## and =pod and =cut
python_language =	14
shell_language =	15  # shell scripts
tcltk_language = 16
unknown_language =	17  # Set when @comment is seen.

# Synonyms for the bits returned by is_special_bits...
color_bits =    0x00001
comment_bits =	 0x00002
cweb_bits =     0x00004
header_bits =   0x00008
ignore_bits =   0x00010
language_bits = 0x00020
nocolor_bits =	 0x00040
noheader_bits = 0x00080
noweb_bits =    0x00100
#               0x00200 #unused
page_width_bits=0x00400
path_bits =	    0x00800
root_bits =	    0x01000 # Also represents < < * > > =
silent_bits =	  0x02000
tab_width_bits =0x04000
terse_bits = 	  0x08000
unit_bits = 	   0x10000
verbose_bits =	 0x20000
#@nonl
#@-node:edream.110203163054.1075:<< define global constants >>
#@+node:edream.110203163054.1076:<< Create the Target Language frame >>
# Frame and title
w,target = create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
	("C/C++",c_language), ("CWEB", cweb_language),
	("HTML", html_language), ("Java", java_language),
	("Pascal", pascal_language) ]

for text,value in left_data:
	button = Tk.Radiobutton(lt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x") 
	
# Right column of radio buttons.
right_data = [ ("Perl", perl_language), ("Perl+POD", perlpod_language),
	("Plain Text", plain_text_language), ("Python", python_language),
	("tcl/tk", tcltk_language) ]
	
for text,value in right_data:
	button = Tk.Radiobutton(rt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x")
#@nonl
#@-node:edream.110203163054.1076:<< Create the Target Language frame >>
#@+node:edream.110203163054.1077:<< define colorizer keywords >>
leoKeywords = (
	# Leo 2 directives.
	"@","@c","@code","@doc","@color","@comment",
	"@delims","@first","@language","@nocolor","@others",
	"@pagewidth","@path","@tabwidth",
	# Leo 1 directives.
	"@ignore","@root","@unit","@silent","@terse","@verbose")
	
c_keywords = (
	# C keywords
	"auto","break","case","char","continue",
	"default","do","double","else","enum","extern",
	"float","for","goto","if","int","long","register","return",
	"short","signed","sizeof","static","struct","switch",
	"typedef","union","unsigned","void","volatile","while"
	# C++ keywords
	"asm","bool","catch","class","const_cast",
	"delete","dynamic_cast","explicit","false","friend",
	"inline","mutable","namespace","new","operator",
	"private","protected","public","reinterpret_cast","static_cast",
	"template","this","throw","true","try",
	"typeid","typename","using","virtual","wchar_t")
	
cweb_keywords = c_keywords

html_keywords = (
	# HTML constructs.
	"<","</",">",
	'"',
	"<!---","<!--","<!",
	"<%","%>",
	"<a","</a",
	"<img",
	"<cf","</cf",
	# Common tags: tables
	"<table","</table",
	"<td","</td",
	"<th","</th",
	"<tr","</tr",
	"<caption","</caption",
	"<col","</col",
	"<colgroup","</colgroup",
	"<tbody","</tbody",
	"<tfoot","</tfoot",
	"<thead","</thead",	
	# Common tags: styles
	"<style","</style",
	# Common tags: scripts
	"<script","</script",
	# Escapes
	"&amp;", "&lt;", "&gt;", "&quot;" )

java_keywords = (
	"abstract","boolean","break","byte","byvalue",
	"case","cast","catch","char","class","const","continue",
	"default","do","double","else","extends",
	"false","final","finally","float","for","future",
	"generic","goto","if","implements","import","inner",
	"instanceof","int","interface","long","native",
	"new","null","operator","outer",
	"package","private","protected","public","rest","return",
	"short","static","super","switch","synchronized",
	"this","throw","transient","true","try",
	"var","void","volatile","while")

pascal_keywords = (
	"and","array","as","begin",
	"case","const","class","constructor","cdecl"
	"div","do","downto","destructor","dispid","dynamic",
	"else","end","except","external",
	"false","file","for","forward","function","finally",
	"goto","if","in","is","label","library",
	"mod","message","nil","not","nodefault""of","or","on",
	"procedure","program","packed","pascal"
	"private","protected","public","published",
	"record","repeat","raise","read","register",
	"set","string","shl","shr","stdcall",
	"then","to","true","type","try","until","unit","uses"
	"var","virtual","while","with","xor"
	# object pascal
	"asm","absolute","abstract","assembler","at","automated",
	"finalization",
	"implementation","inherited","initialization","inline","interface",
	"object","override","resident","resourcestring",
	"threadvar",
	# limited contexts
	"exports","property","default","write","stored","index","name" )

perl_keywords = (
	"continue","do","else","elsif","format","for","format","for","foreach",
	"if","local","package","sub","tr","unless","until","while","y",
	# Comparison operators
	"cmp","eq","ge","gt","le","lt","ne",
	# Matching ooperators
	"m","s"
	# Unary functions
	"alarm","caller","chdir","cos","chroot","exit","eval","exp",
	"getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
	"hex","int","length","localtime","log","ord","oct",
	"require","reset","rand","rmdir","readlink",
	"scalar","sin","sleep","sqrt","srand","umask",
	# Transfer ops
	"next","last","redo","go","dump",
	# File operations...
	"select","open",
	# FL ops
	"binmode","close","closedir","eof",
	"fileno","getc","getpeername","getsockname","lstat",
	"readdir","rewinddir","stat","tell","telldir","write",
	# FL2 ops
	"bind","connect","flock","listen","opendir",
	"seekdir","shutdown","truncate",
	# FL32 ops
	"accept","pipe",
	# FL3 ops
	"fcntl","getsockopt","ioctl","read",
	"seek","send","sysread","syswrite",
	# FL4 & FL5 ops
	"recv","setsocket","socket","socketpair",
	# Array operations
	"pop","shift","split","delete",
	# FLIST ops
	"sprintf","grep","join","pack",
	# LVAL ops
	"chop","defined","study","undef",
	# f0 ops
	"endhostent","endnetent","endservent","endprotoent",
	"endpwent","endgrent","fork",
	"getgrent","gethostent","getlogin","getnetent","getppid",
	"getprotoent","getpwent","getservent",
	"setgrent","setpwent","time","times","wait","wantarray",
	# f1 ops
	"getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
	"sethostent","setnetent","setprotoent","setservent",
	# f2 ops
	"atan2","crypt",
	"gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
	"index","link","mkdir","msgget","rename",
	"semop","setpgrp","symlink","unpack","waitpid",
	# f2 or 3 ops
	"index","rindex","substr",
	# f3 ops
	"msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
	# f4 & f5 ops
	"semctl","shmread","shmwrite","msgrcv",
	# Assoc ops
	"dbmclose","each","keys","values",
	# List ops
	"chmod","chown","die","exec","kill",
	"print","printf","return","reverse",
	"sort","system","syscall","unlink","utime","warn")

perlpod_keywords = perl_keywords
	
python_keywords = (
	"and",       "del",       "for",       "is",        "raise",    
	"assert",    "elif",      "from",      "lambda",    "return",   
	"break",     "else",      "global",    "not",       "try",      
	"class",     "except",    "if",        "or",        "yield",   
	"continue",  "exec",      "import",    "pass",      "while",
	"def",       "finally",   "in",        "print")
	
tcltk_keywords = ( # Only the tcl keywords are here.
	"after",     "append",    "array",
	"bgerror",   "binary",    "break",
	"catch",     "cd",        "clock",
	"close",     "concat",    "continue",
	"dde",
	"encoding",  "eof",       "eval",
	"exec",      "exit",      "expr",
	"fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
	"filename",  "flush",     "for",       "foreach",   "format",
	"gets",      "glob",      "global",
	"history",
	"if",        "incr",      "info",      "interp",
	"join",
	"lappend",   "lindex",    "linsert",   "list",      "llength",
	"load",      "lrange",    "lreplace",  "lsearch",   "lsort",
	"memory",    "msgcat",
	"namespace",
	"open",
	"package",   "parray",    "pid",
	"proc",      "puts",      "pwd",
	"read",      "regexp",    "registry",   "regsub",
	"rename",    "resource",  "return",
	"scan",      "seek",      "set",        "socket",   "source",
	"split",     "string",    "subst",      "switch",
	"tell",      "time",      "trace",
	"unknown",   "unset",     "update",     "uplevel",   "upvar",
	"variable",  "vwait",
	"while" )
#@nonl
#@-node:edream.110203163054.1077:<< define colorizer keywords >>
#@+node:edream.110203163054.1078:<< configure language-specific settings >>
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end

(single_comment_start,
	block_comment_start,
	block_comment_end) = set_delims_from_language(language)

has_string = language != plain_text_language

languages = ["c","cweb","html","java","pascal","perl","perlpod","python","tcltk"]

keywords = []
if language==cweb_language:
	for i in c_keywords:
		keywords.append(i)
	for i in cweb_keywords:
		keywords.append(i)
else:
	for name in languages:
		exec("if language==%s_language: keywords=%s_keywords" % (name,name))

if 1: # 7/8/02: Color plain text unless we are under the control of @nocolor.
	state = choose(flag,normalState,nocolorState)
else: # Stupid: no coloring at all in plain text.
	state = choose(language==plain_text_language,nocolorState,normalState)

lb = choose(language==cweb_language,"@<","<<")
rb = choose(language==cweb_language,"@>",">>")
#@nonl
#@-node:edream.110203163054.1078:<< configure language-specific settings >>
#@+node:edream.110203163054.1079:<< check for syntax coloring prefs >>
# Must match longer tags before short prefixes.
language = c_language # default

if self.matchTag("CWEB"):
	language = cweb_language ; self.getDquote();
elif self.matchTag("C"):
	language = c_language ; self.getDquote()
elif self.matchTag("HTML"):
	language = html_language ; self.getDquote()
elif self.matchTag("Java"):
	language = java_language ; self.getDquote()
elif self.matchTag("Pascal"):
	language = pascal_language ; self.getDquote()
elif self.matchTag("PerlPod"):
	language = perlpod_language ; self.getDquote()
elif self.matchTag("Perl"):
	language = perl_language ; self.getDquote()
elif self.matchTag("Plain"):
	language = plain_text_language ; self.getDquote()
elif self.matchTag("Python"):
	language = python_language ; self.getDquote()
elif self.matchTag("tcl/tk"):
	language = tcltk_language ; self.getDquote()
	
# print(`language`)

c.target_language = language
#@nonl
#@-node:edream.110203163054.1079:<< check for syntax coloring prefs >>
#@+node:edream.110203163054.1080:<< initialize constant ivars >>
# Language names.
self.languageNameDict = {
	c_language: "C",
	cweb_language: "CWEB",
	html_language: "HTML",
	java_language: "Java",
	pascal_language: "Pascal",
	perl_language: "Perl",
	perlpod_language: "PerlPod",
	plain_text_language: "Plain",
	python_language: "Python",
	tcltk_language: "tcl/tk" }

# Names of sections.
self.configSection = "config options"
self.compareSection = "compare options"
self.findSection = "find/change options"
self.prefsSection = "prefs panel options"
self.recentFilesSection = "recent files"
self.colorsSection = "syntax coloring options"
self.windowSection = "window options"
#@nonl
#@-node:edream.110203163054.1080:<< initialize constant ivars >>
#@+node:edream.110203163054.1081:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):
	
	# trace(`language`)

	for lang, val in [ (cweb_language, "// /* */"),
		(c_language, "// /* */"), (java_language, "// /* */"),
		(fortran_language, "C"), (fortran90_language, "!"),
		(html_language, "<!-- -->"), (pascal_language, "// { }"),
		(perl_language, "#"), (perlpod_language, "# =pod =cut"),
		(plain_text_language, "#"), # 7/8/02: we have to pick something.
		(shell_language, "#"), (python_language, "#"),
		(tcltk_language, "#") ]: # 7/18/02
		if lang == language:
			# trace(`val`)
			return set_delims_from_string(val)

	return None, None, None # Indicate that no change should be made
#@nonl
#@-node:edream.110203163054.1081:set_delims_from_language
#@+node:edream.110203163054.1082:set_language
@  Scans the @language directive that appears at s[i]. 'default' returns default_language.

Returns (language, delim1, delim2, delim3)
@c

def set_language(s,i,issue_errors_flag,default_language):

	tag = "@language"
	# trace(`get_line(s,i)`)
	assert(i != None)
	assert(match_word(s,i,tag))
	i += len(tag) ; i = skip_ws(s, i)
	# Get the argument.
	j = i
	i = skip_c_id(s,i)
	# Allow tcl/tk.
	arg = string.lower(s[j:i])
	if len(arg) > 0:
		for name, language in [ ("ada", ada_language),
			("c", c_language), ("c++", c_language),
			("cweb", cweb_language), ("default", default_language),
			("fortran", fortran_language), ("fortran90", fortran90_language),
			("html", html_language), ("java", java_language),
			("lisp", lisp_language), ("objective-c", c_language),
			("pascal", pascal_language), ("perl", perl_language),
			("perlpod", perlpod_language),
			("plain", plain_text_language), # 7/8/02
			("python", python_language),
			("shell", shell_language),
			("tcl", tcltk_language) ]: # 7/18/02.  Note: this also matches tcl/tk.
		
			if arg == name:
				delim1, delim2, delim3 = set_delims_from_language(language)
				return language, delim1, delim2, delim3

	if issue_errors_flag:
		es("ignoring: " + get_line(s,i))

	return None, None, None, None,
#@nonl
#@-node:edream.110203163054.1082:set_language
#@+node:edream.110203163054.1083:colorizeAnyLanguage
tags = (
	"blank", "comment", "cwebName", "docPart", "keyword", "leoKeyword",
	"link", "name", "nameBrackets", "pp", "string", "tab")

def colorizeAnyLanguage(self,v,body,language,flag):
	
	#trace(`language`)

	hyperCount = 0 # Number of hypertext tags
	self.body = body # For callbacks
	s = body.get("1.0", "end")
	sel = body.index("insert") # get the location of the insert point
	start, end = string.split(sel,'.')
	start = int(start)
	# trace(`self.count` + `v`)
	# trace(`body.tag_names()`)

	if 0: # Remove all tags from the selected line.
		for tag in self.tags:
			body.tag_remove(tag, index(start,0), index(start,"end"))
	else: # Remove all tags from body.
		body.tag_delete(
			"blank", "comment", "cwebName", "docPart", "keyword", "leoKeyword",
			"link", "name", "nameBrackets", "pp", "string", "tab")
	<< configure tags >>
	<< configure language-specific settings >>
	self.count += 1
	
	lines = string.split(s,'\n')
	n = 0 # The line number for indices, as in n.i
	for s in lines:
		n += 1 ; i = 0 ; sLen = len(s)
		# trace(`n` + ", " + `s`)
		while i < sLen:
			progress = i
			ch = s[i]
			if state == string3State:
				<< continue python triple string >>
				continue
			elif state == docState:
				<< continue doc part >>
				continue
			elif state == nocolorState:
				<< continue nocolor state >>
				continue
			elif state == blockCommentState:
				<< continue block comment >>
				continue
			else: assert(state == normalState)

			if has_string and ch == '"' or ch == "'":
				<< handle string >>
			elif single_comment_start and match(s,i,single_comment_start):
				<< handle single-line comment >>
			elif block_comment_start and match(s,i,block_comment_start):
				<< start block comment >>
			elif ch == '#' and language in [c_language,cweb_language]:
				<< handle C preprocessor line >>
			elif match(s,i,lb) or (language==cweb_language and match(s,i,"@(")):
				<< handle possible section ref or def >>
			elif ch == '@':
				<< handle possible @keyword >>
			elif ch in string.letters:
				<< handle possible keyword >>
			elif ch == ' ':
				<< handle blank >>
			elif ch == '\t':
				<< handle tab >>
			else:
				<< handle normal character >>
			assert(progress < i)
#@nonl
#@+node:edream.110203163054.1084:<< configure tags >>
config = app().config
assert(config)

for name in default_colors_dict:
	option_name,default_color = default_colors_dict[name]
	option_color = config.getColorsPref(option_name)
	color = choose(option_color,option_color,default_color)
	# Must use foreground, not fg.
	try:
		body.tag_config(name, foreground=color)
	except: # Recover after a user error.
		body.tag_config(name, foreground=default_color)

underline_undefined = config.getBoolColorsPref("underline_undefined_section_names")
use_hyperlinks      = config.getBoolColorsPref("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if use_hyperlinks: 
	body.tag_config("link",underline=1) # defined
	body.tag_config("name",underline=0) # undefined
else:
	body.tag_config("link",underline=0)
	if underline_undefined:
		body.tag_config("name",underline=1)
	else:
		body.tag_config("name",underline=0)

if self.showInvisibles:
	if 1: # Very poor, and vaguely usable.
		body.tag_config("blank",background="black",bgstipple="gray25")
		body.tag_config("tab",background="black",bgstipple="gray50")
	else: # Doesn't work, but does increase the spacing ;-)
		body.tag_config("blank",font="Symbol")
		body.tag_config("tab",font="Symbol")
else:
	body.tag_config("blank",background="white")
	body.tag_config("tab",background="white")
#@nonl
#@-node:edream.110203163054.1084:<< configure tags >>
#@+node:edream.110203163054.1078:<< configure language-specific settings >>
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end

(single_comment_start,
	block_comment_start,
	block_comment_end) = set_delims_from_language(language)

has_string = language != plain_text_language

languages = ["c","cweb","html","java","pascal","perl","perlpod","python","tcltk"]

keywords = []
if language==cweb_language:
	for i in c_keywords:
		keywords.append(i)
	for i in cweb_keywords:
		keywords.append(i)
else:
	for name in languages:
		exec("if language==%s_language: keywords=%s_keywords" % (name,name))

if 1: # 7/8/02: Color plain text unless we are under the control of @nocolor.
	state = choose(flag,normalState,nocolorState)
else: # Stupid: no coloring at all in plain text.
	state = choose(language==plain_text_language,nocolorState,normalState)

lb = choose(language==cweb_language,"@<","<<")
rb = choose(language==cweb_language,"@>",">>")
#@nonl
#@-node:edream.110203163054.1078:<< configure language-specific settings >>
#@+node:edream.110203163054.1085:Multiline State Handlers
#@+node:edream.110203163054.1086:<< continue doc part >>
if language == cweb_language:
	<< handle cweb doc part >>
else:
	<< handle noweb doc part >>
#@nonl
#@+node:edream.110203163054.1087:<< handle cweb doc part >>
word = self.getCwebWord(s,i)
if word and len(word) > 0:
	j = i + len(word)
	if word in ("@<","@(","@c","@d","@f","@p"):
		state = normalState # end the doc part and rescan
	else:
		# The control code does not end the doc part.
		body.tag_add("keyword", index(n,i), index(n,j))
		i = j
		if word in ("@^","@.","@:","@="): # Ended by "@>"
			j = string.find(s,"@>",i)
			if j > -1:
				body.tag_add("cwebName", index(n,i), index(n,j))
				body.tag_add("nameBrackets", index(n,j), index(n,j+2))
				i = j + 2
else:
	# Everthing up to the next "@" is in the doc part.
	j = string.find(s,"@",i+1)
	if j == -1: j = len(s)
	body.tag_add("docPart", index(n,i), index(n,j))
	i = j
#@nonl
#@-node:edream.110203163054.1087:<< handle cweb doc part >>
#@+node:edream.110203163054.1088:<< handle noweb doc part >>
if i == 0 and match(s,i,lb):
	# Possible section definition line.
	state = normalState # rescan the line.
	continue
if i == 0 and ch == '@':
	j = self.skip_id(s,i+1)
	word = s[i:j]
	word = string.lower(word)
else:
	word = ""

if word in ["@c","@code","@unit","@root","@color","@nocolor"]:
	# End of the doc part.
	body.tag_remove("docPart", index(n,i), index(n,j))
	body.tag_add("leoKeyword", index(n,i), index(n,j))
	i = j ; state = normalState
else:
	# The entire line is in the doc part.
	body.tag_add("docPart", index(n,i), index(n,sLen))
	i = sLen # skipt the rest of the line.
#@nonl
#@-node:edream.110203163054.1088:<< handle noweb doc part >>
#@-node:edream.110203163054.1086:<< continue doc part >>
#@+node:edream.110203163054.1089:<< continue python triple string >>
delim = self.delim
if delim=="'''":
	j = string.find(s,"'''",i)
elif delim=='"""':
	j = string.find(s,'"""', i)
else:
	state=normalState ; self.delim = None ; continue

if j == -1:
	# The entire line is part of the triple-quoted string.
	body.tag_add("string", index(n,i), index(n,"end"))
	i = sLen # skipt the rest of the line.
else:
	# End the string
	body.tag_add("string", index(n,i), index(n,j+3))
	i = j + 3 ; state = normalState ; self.delim = None
#@nonl
#@-node:edream.110203163054.1089:<< continue python triple string >>
#@+node:edream.110203163054.1090:<< continue block comment >>
j = string.find(s,block_comment_end,i)
if j == -1:
	# The entire line is part of the block comment.
	body.tag_add("comment", index(n,i), index(n,"end"))
	i = sLen # skipt the rest of the line.
else:
	# End the block comment.
	k = len(block_comment_end)
	body.tag_add("comment", index(n,i), index(n,j+k))
	i = j + k ; state = normalState
#@nonl
#@-node:edream.110203163054.1090:<< continue block comment >>
#@+node:edream.110203163054.1091:<< continue nocolor state >>
if i == 0 and ch == '@':
	j = self.skip_id(s,i+1)
	word = s[i:j]
	word = string.lower(word)
else:
	word = ""

if word == "@color" and language != plain_text_language:
	# End of the nocolor part.
	body.tag_add("leoKeyword", index(n,0), index(n,j))
	i = j ; state = normalState
else:
	# The entire line is in the nocolor part.
	# Add tags for blanks and tabs to make "Show Invisibles" work.
	for ch in s[i:]:
		if ch == ' ':
			body.tag_add("blank", index(n,i))
		elif ch == '\t':
			body.tag_add("tab", index(n,i))
		i += 1
#@nonl
#@-node:edream.110203163054.1091:<< continue nocolor state >>
#@-node:edream.110203163054.1085:Multiline State Handlers
#@+node:edream.110203163054.1092:<< handle string >>
if language == python_language:
	j, state = self.skip_python_string(s,i)
	body.tag_add("string", index(n,i), index(n,j))
	i = j
else:
	j = self.skip_string(s,i)
	body.tag_add("string", index(n,i), index(n,j))
	i = j
#@nonl
#@-node:edream.110203163054.1092:<< handle string >>
#@+node:edream.110203163054.1093:<< start block comment >>
k = len(block_comment_start)
body.tag_add("comment", index(n,i), index(n,i+k))
i += k ; state = blockCommentState
#@nonl
#@-node:edream.110203163054.1093:<< start block comment >>
#@+node:edream.110203163054.1094:<< handle single-line comment >>
body.tag_add("comment", index(n,i), index(n,"end"))
i = sLen
#@nonl
#@-node:edream.110203163054.1094:<< handle single-line comment >>
#@+node:edream.110203163054.1095:<< handle C preprocessor line >>
body.tag_add("pp", index(n,i), index(n,"end"))
i = sLen
#@nonl
#@-node:edream.110203163054.1095:<< handle C preprocessor line >>
#@+node:edream.110203163054.1096:<< handle possible section ref or def >>
body.tag_add("nameBrackets", index(n,i), index(n,i+2))

# See if the line contains the rb
j = string.find(s,rb+"=",i+2) ; k = 3
if j == -1:
	j = string.find(s,rb,i+2) ; k = 2
if j == -1:
	i += 2
else:
	if language != cweb_language:
		searchName = body.get(index(n,i),   index(n,j+k)) # includes brackets
		ref = findReference(searchName,v)
	
	if language == cweb_language:
		body.tag_add("cwebName", index(n,i+2), index(n,j))
	elif ref:
		body.tag_add("link", index(n,i+2), index(n,j))
		if self.use_hyperlinks:
			<< set the hyperlink >>
	elif k == 3: # a section definition
		body.tag_add("link", index(n,i+2), index(n,j))
	else:
		body.tag_add("name", index(n,i+2), index(n,j))
	body.tag_add("nameBrackets", index(n,j), index(n,j+k))
	i = j + k
#@nonl
#@+node:edream.110203163054.1097:<< set the hyperlink >>
# Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + `hyperCount`
hyperCount += 1
body.tag_delete(tagName)
body.tag_add(tagName, index(n,i+2), index(n,j))
ref.tagName = tagName
body.tag_bind(tagName,"<Control-1>",ref.OnHyperLinkControlClick)
body.tag_bind(tagName,"<Any-Enter>",ref.OnHyperLinkEnter)
body.tag_bind(tagName,"<Any-Leave>",ref.OnHyperLinkLeave)
#@nonl
#@-node:edream.110203163054.1097:<< set the hyperlink >>
#@-node:edream.110203163054.1096:<< handle possible section ref or def >>
#@+node:edream.110203163054.1098:<< handle possible @keyword >>
word = None
if language == cweb_language:
	<< Handle all cweb control codes >>
if not word:
	<< Handle non-cweb @keywords >>
#@nonl
#@+node:edream.110203163054.1099:<< Handle all cweb control codes >>
word = self.getCwebWord(s,i)
if word:
	# Color and skip the word.
	j = i + len(word)
	body.tag_add("keyword",index(n,i),index(n,j))
	i = j

	if word in ("@ ","@\t","@\n","@*","@**"):
		state = docState
		continue ;

	if word in ("@^","@.","@:","@="): # Ended by "@>"
		j = string.find(s,"@>",i)
		if j > -1:
			body.tag_add("cwebName", index(n,i), index(n,j))
			body.tag_add("nameBrackets", index(n,j), index(n,j+2))
			i = j + 2
#@-node:edream.110203163054.1099:<< Handle all cweb control codes >>
#@+node:edream.110203163054.1100:<< Handle non-cweb @keywords >>
j = self.skip_id(s,i+1)
word = s[i:j]
word = string.lower(word)
if i != 0 and word != "@others":
	word = "" # can't be a Leo keyword, even if it looks like it.

# 7/8/02: don't color doc parts in plain text.
if language != plain_text_language and (word == "@" or word == "@doc"):
	# at-space starts doc part
	body.tag_add("leoKeyword", index(n,i), index(n,j))
	# Everything on the line is in the doc part.
	body.tag_add("docPart", index(n,j), index(n,sLen))
	i = sLen ; state = docState
elif word == "@nocolor":
	# Nothing on the line is colored.
	body.tag_add("leoKeyword", index(n,i), index(n,j))
	i = j ; state = nocolorState
elif word in leoKeywords:
	body.tag_add("leoKeyword", index(n,i), index(n,j))
	i = j
else:
	i = j
#@nonl
#@-node:edream.110203163054.1100:<< Handle non-cweb @keywords >>
#@-node:edream.110203163054.1098:<< handle possible @keyword >>
#@+node:edream.110203163054.1101:<< handle possible  keyword >>
j = self.skip_id(s,i)
word = s[i:j]
if word in keywords:
	body.tag_add("keyword", index(n,i), index(n,j))
i = j
#@nonl
#@-node:edream.110203163054.1101:<< handle possible  keyword >>
#@+node:edream.110203163054.1102:<< handle blank >>
body.tag_add("blank", index(n,i)) ; i += 1
#@nonl
#@-node:edream.110203163054.1102:<< handle blank >>
#@+node:edream.110203163054.1103:<< handle tab >>
body.tag_add("tab", index(n,i)) ; i += 1
#@nonl
#@-node:edream.110203163054.1103:<< handle tab >>
#@+node:edream.110203163054.1104:<< handle normal character >>
# body.tag_add("normal", index(n,i))
i += 1
#@-node:edream.110203163054.1104:<< handle normal character >>
#@-node:edream.110203163054.1083:colorizeAnyLanguage
#@+node:edream.110203163054.1105:getPrefs
def getPrefs (self):

	c = self.commands ; config = app().config
	
	self.getTag("<preferences")
	while 1:
		if self.matchTag("allow_rich_text="):
			self.getDquote() ; self.getBool() ; self.getDquote() #ignored
		elif self.matchTag("tab_width="):
			self.getDquote() ; c.tab_width = self.getLong() ; self.getDquote()
		elif self.matchTag("page_width="):
			self.getDquote() ; c.page_width = self.getLong() ; self.getDquote()
		elif self.matchTag("tangle_bat="):
			self.getDquote() ; c.tangle_batch_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("untangle_bat="):
			self.getDquote() ; c.untangle_batch_flag = self.getBool() ; self.getDquote()
		# New in version 0.10
		elif self.matchTag("output_doc_chunks="):
			self.getDquote() ; c.output_doc_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("extended_noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("defaultTargetLanguage="):
			# New in version 0.15
			self.getDquote()
			<< check for syntax coloring prefs >>
		elif self.matchTag("use_header_flag="):
			self.getDquote() ; c.use_header_flag = self.getBool() ; self.getDquote()
		else: break
	self.getTag(">")
	while 1:
		if self.matchTag("<defaultDirectory>"):
			# New in version 0.16.
			c.tangle_directory = self.getEscapedString()
			self.getTag("</defaultDirectory>")
			if not os.path.exists(c.tangle_directory):
				es("default tangle directory not found:" + c.tangle_directory)
		elif self.matchTag("<TSyntaxMemo_options>"):
			self.getEscapedString() # ignored
			self.getTag("</TSyntaxMemo_options>")
		else: break
	self.getTag("</preferences>")
	
	# Override .leo file's preferences if settings are in leoConfig.txt.
	if config.configsExist:
		config.setCommandsIvars(c)
#@nonl
#@+node:edream.110203163054.1079:<< check for syntax coloring prefs >>
# Must match longer tags before short prefixes.
language = c_language # default

if self.matchTag("CWEB"):
	language = cweb_language ; self.getDquote();
elif self.matchTag("C"):
	language = c_language ; self.getDquote()
elif self.matchTag("HTML"):
	language = html_language ; self.getDquote()
elif self.matchTag("Java"):
	language = java_language ; self.getDquote()
elif self.matchTag("Pascal"):
	language = pascal_language ; self.getDquote()
elif self.matchTag("PerlPod"):
	language = perlpod_language ; self.getDquote()
elif self.matchTag("Perl"):
	language = perl_language ; self.getDquote()
elif self.matchTag("Plain"):
	language = plain_text_language ; self.getDquote()
elif self.matchTag("Python"):
	language = python_language ; self.getDquote()
elif self.matchTag("tcl/tk"):
	language = tcltk_language ; self.getDquote()
	
# print(`language`)

c.target_language = language
#@nonl
#@-node:edream.110203163054.1079:<< check for syntax coloring prefs >>
#@-node:edream.110203163054.1105:getPrefs
#@-node:edream.110203163054.1074:code
#@+node:edream.110203163054.1106:@root tcl/tk test
@color
@language tcl/tk
@root "c:\prog\test\tcltktest.txt"

after # 'after' is a keyword
all # 'all' is not a keyword

<< stuff >>

# A comment
// Not a comment
"A string"
'A string'
#@nonl
#@+node:edream.110203163054.1107:<< stuff >>
@ This is a tcl/tk doc part

This is code
#@nonl
#@-node:edream.110203163054.1107:<< stuff >>
#@-node:edream.110203163054.1106:@root tcl/tk test
#@-node:edream.110203163054.1073:How can I add support in Leo for a new language?
#@+node:edream.110203163054.1108:How can I create a template .leo file?
Question:

It would be nice if Leo could open empty files. I tend to be "document
oriented" rather than "application oriented" in my thinking and prefer "create
empty file at location -> open it with program" to "start program -> create new
file -> save it at location".

Answer by Paul Paterson

If you are on Windows 98/2000/XP then the procedure is as follows...

1. Start Leo
2. Click New
3. Click Save as...
4. Save the file as "c:\windows\shellnew\leofile.leo" (or c:\winnt for 2000/XP)
5. Open regedit "start...run...regedit"
6. Open HKEY_CLASSES_ROOT and find the ".leo" extension type
7. Go New ... Key from the context menu 
8. Call the new key ShellNew 
9. Select the new key, right-click, choose New ... String Value from the contextmenu
10. Call it FileName 
11. Double-click on the string, and modify it to be the filename of the leofile.leo
file you created, including the extension
12. Exit the registry editor and restart Windows Explorer (or you may need to
reboot on Windows 98)

Now you should have a New.. Leo File option in Explorer. This creates a
duplicate of the file you saved. This can be useful because you could make a
template Leo file containing some standard nodes that you always have and then
save this.
#@nonl
#@-node:edream.110203163054.1108:How can I create a template .leo file?
#@+node:ekr.20040411074926:How can I use Leo to develop Leo itself?
There is a trick that makes it very easy to develop Leo using Leo itself.  The trick is to create a workflow that separates editing from testing.

Putting test code in LeoPy.leo would waste a lot of time.  To run tests you would have to exit Leo and reload LeoPy. A much quicker way is to put all test code in a test.leo file.  So to change and test code, do the following:

1. Save LeoPy.leo but do NOT exit Leo. 

2. Quit the copy of Leo running test.leo, then reload test.leo.

3. Run test scripts from test.leo.

That's all. Python will recompile any changed .py files in the new copy of Leo.

BTW, I create a batch file called t.bat that runs test.leo, so to the "edit-reload-test" cycle is just:

1. Control-S (in LeoPy.leo: saves the .leo file)
2. t         (in a console window: runs test.leo, compiling all changed .py files as a side effect)
3. Control-E (in test.leo: runs the test script)

The benefits of the new workflow:

- test.leo loads  _much_ more quickly than LeoPy.leo does.  This new approach can increase the speed of the edit-reload-test cycle by more than a factor of 10.  Hitting Control-S, t, Control-E takes about 5 seconds.

- LeoPy.leo runs with the _old_ code, so it is much easier to fix syntax errors or exceptions in the _new_ code: just fix the problem and save LeoPy.leo _without_ closing LeoPy.leo., then restart test.leo. Tests are run on new code; editing is done on old, stable code.

- test.leo is the perfect place to develop test.  I can create and organize those tests and when I am done, test.leo is a log of my work.
#@nonl
#@-node:ekr.20040411074926:How can I use Leo to develop Leo itself?
#@-node:edream.110203163054.1071:Other topics
#@-all
#@nonl
#@-node:EKR.20040524105011:@file-thin leoFAQ.txt
#@-leo
