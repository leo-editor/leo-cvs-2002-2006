<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="943" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="10" left="10" height="624" width="768"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0" tab_width="4" page_width="132" tangle_bat="1" untangle_bat="0" output_doc_chunks="1" defaultTargetLanguage="Python" use_header_flag="0">
	<defaultDirectory>c:\prog\LeoPy</defaultDirectory>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1"><vh>About LEO's panes and icons (for newbies)</vh>
<v t="T2"><vh>This node contains text</vh></v>
<v t="T3" a="M"><vh>This headline is marked</vh></v>
<v t="T4" a="C"><vh>This is a cloned headline</vh></v>
<v t="T4" a="C"><vh>This is a cloned headline</vh></v>
<v><vh>This node contains no text</vh></v>
<v t="T5" a="C"><vh>Glossary</vh>
<v t="T6"><vh>@file node</vh></v>
<v t="T7"><vh>@file tree</vh></v>
<v t="T8"><vh>@ignore node</vh></v>
<v t="T9"><vh>@others node</vh></v>
<v t="T10"><vh>@others tree</vh></v>
<v t="T11"><vh>@root node</vh></v>
<v t="T12"><vh>@root tree</vh></v>
<v t="T13"><vh>@unit node</vh></v>
<v t="T14"><vh>@unit tree</vh></v>
<v t="T15"><vh>Body Text</vh></v>
<v t="T16"><vh>Body Text Box</vh></v>
<v t="T17"><vh>Child</vh></v>
<v t="T18"><vh>Clone</vh></v>
<v t="T19"><vh>Clone Arrow</vh></v>
<v t="T20"><vh>Chunk</vh></v>
<v t="T21"><vh>CWEB</vh></v>
<v t="T22"><vh>Derived file</vh></v>
<v t="T23"><vh>Directive</vh></v>
<v t="T24"><vh>Grandchild</vh></v>
<v t="T25"><vh>Headline</vh></v>
<v t="T26"><vh>Donald Knuth</vh></v>
<v t="T27"><vh>Leo</vh></v>
<v t="T28"><vh>Leo1 tree</vh></v>
<v t="T29"><vh>Leo2 tree</vh></v>
<v t="T30"><vh>Literate programming</vh></v>
<v t="T31"><vh>Named nodes</vh></v>
<v t="T32"><vh>noweb</vh></v>
<v t="T33"><vh>Norman Ramsey</vh></v>
<v t="T34"><vh>Node</vh></v>
<v t="T35"><vh>Offspring</vh></v>
<v t="T36"><vh>Orphan node</vh></v>
<v t="T37"><vh>Parent</vh></v>
<v t="T38"><vh>.pdf file</vh></v>
<v t="T39"><vh>Root</vh></v>
<v t="T40"><vh>Section</vh></v>
<v t="T41"><vh>Sibling</vh></v>
<v t="T42"><vh>Status Icon</vh></v>
<v t="T43"><vh>Tangling</vh></v>
<v t="T44"><vh>Tree</vh></v>
<v t="T45"><vh>Unnamed node</vh></v>
<v t="T46"><vh>Untangling</vh></v>
<v t="T47"><vh>Weaving</vh></v>
</v>
</v>
<v t="T48"><vh>Please use SourceForge to ask questions and make comments</vh></v>
<v t="T49" a="V"><vh>Release Notes</vh>
<v t="T50" a="C"><vh>Acknowledgements</vh></v>
<v t="T51" a="C"><vh>How to Install &amp; Run Leo</vh></v>
<v><vh>leo.py versions</vh>
<v a="E"><vh>version 0.09 Bug fix release</vh>
<v t="T52"><vh>How to copy an outline from Borland Leo to Leo.py</vh></v>
</v>
<v t="T53"><vh>version 0.08 Find, Change and Tangle commands &amp; major bugs fixed</vh>
<v t="T54"><vh>About the Find and Change commands</vh></v>
<v t="T55"><vh>About the Tangle command</vh></v>
<v t="T56"><vh>About hyperlinking</vh></v>
<v t="T57"><vh>Fixed significant bugs</vh></v>
<v t="T58"><vh>Other improvements</vh></v>
<v t="T59"><vh>Improved memory management</vh></v>
<v t="T60"><vh>The trace function (Sherlock tracing)</vh></v>
<v t="T61"><vh>Improved directory and file name handling</vh></v>
<v t="T62"><vh>Improvements that will be propagated back to LeoCB</vh></v>
</v>
<v t="T63"><vh>version 0.07 Stability and scripting</vh>
<v t="T64"><vh>Thorough testing</vh></v>
<v t="T65"><vh>Removed many irritations.  Some remain</vh></v>
<v t="T66"><vh>Fixed bug that can drop data</vh></v>
<v t="T67"><vh>Added Python window and scripting support</vh></v>
<v t="T68"><vh>Added Script to convert from Leo 1 to Leo 2</vh></v>
<v t="T69"><vh>Added Leo Documentation command</vh></v>
<v t="T70"><vh>Added Auto indent</vh></v>
</v>
<v t="T71"><vh>version 0.06 Minor changes for Linux</vh></v>
<v t="T72"><vh>version 0.05 The first functional version</vh>
<v t="T73"><vh>Testing &amp; Performance</vh></v>
<v t="T74"><vh>Installing and Running leo.py</vh></v>
<v><vh>Files &amp; Folders</vh></v>
<v t="T75"><vh>Functional Commands and Features</vh></v>
<v t="T76"><vh>Non-Functional Commands and Features</vh></v>
<v t="T77"><vh>Bugs, Problems and Code Quality</vh></v>
<v t="T78"><vh>New Things To Do</vh></v>
</v>
</v>
<v><vh>Borland PC versions</vh>
<v><vh>PC Leo2 versions</vh>
<v t="T79"><vh>version 2.5: Fixed several serious bugs</vh></v>
<v t="T80"><vh>version 2.4: The new Leo2 (Do not use this version)</vh>
<v t="T81"><vh>Fixed clone bugs</vh></v>
<v t="T82"><vh>.leo files now contain all data</vh></v>
<v t="T83"><vh>Replaced archive command</vh></v>
<v t="T84"><vh>Automatic update of @file trees</vh></v>
<v t="T85" a="C"><vh>Errors while reading</vh></v>
<v t="T86" a="C"><vh>Errors while writing</vh></v>
<v t="T87" a="C"><vh>Drawbacks of Leo2</vh></v>
</v>
<v t="T88"><vh>version 2.3: Do not use this version</vh>
<v t="T89"><vh>@first directive</vh></v>
<v t="T90"><vh>Archive Entire Outline command</vh></v>
<v t="T91"><vh>Fixed @c syntax coloring</vh></v>
<v t="T92"><vh>Fixed bugs in the find command</vh></v>
<v t="T93"><vh>Fixed bug involving@file dirty bits</vh></v>
<v t="T94"><vh>The Log window is now part of the Leo window</vh></v>
</v>
<v t="T95"><vh>version 2.2 (beta)</vh></v>
<v t="T96"><vh>version 2.1 (beta)</vh></v>
</v>
<v><vh>PC Leo1 versions</vh>
<v t="T97"><vh>Changes made in version 1.15</vh></v>
<v t="T98"><vh>Changes made in version 1.14</vh></v>
<v t="T99"><vh>Changes made in version 1.13</vh></v>
<v t="T100"><vh>Changes made in version 1.12</vh></v>
<v t="T101"><vh>Changes made in version 1.11</vh>
<v t="T102" a="C"><vh>Multiple parts not allowed for &lt;&lt; section name &gt;&gt;</vh></v>
<v t="T103" a="C"><vh>Untangling: updating an outline</vh></v>
</v>
<v t="T104"><vh>Changes made in version 1.10</vh></v>
<v t="T105"><vh>Changes made in version 1.9</vh>
<v t="T106"><vh>New Execute Script command</vh></v>
<v t="T107"><vh>Python window improved</vh></v>
</v>
<v t="T108"><vh>Changes made in version 1.8</vh></v>
<v t="T109"><vh>Changes made in version 1.7</vh></v>
<v t="T110"><vh>Changes made in version 1.6</vh></v>
<v t="T111"><vh>Changes made in version 1.5</vh></v>
<v t="T112"><vh>Changes made in version 1.4</vh>
<v t="T113"><vh>Outline To Noweb command</vh></v>
<v t="T114"><vh>find/change Python scripts</vh>
<v t="T115" a="C"><vh>High-level Find/Change functions</vh>
<v t="T116"><vh>leoFind.py</vh>
<v t="T117"><vh>changeAll</vh></v>
<v t="T118"><vh>changeNext</vh></v>
<v t="T119"><vh>changePrev</vh></v>
<v t="T120"><vh>findAll</vh></v>
<v t="T121"><vh>findNext</vh></v>
<v t="T122"><vh>findPrev</vh></v>
<v t="T123"><vh>reChangeAll</vh></v>
<v t="T124"><vh>reChangeNext</vh></v>
<v t="T125"><vh>reChangePrev</vh></v>
<v t="T126"><vh>reFindAll</vh></v>
<v t="T127"><vh>reFindNext</vh></v>
<v t="T128"><vh>reFindPrev</vh></v>
<v t="T129"><vh>lineAtPos</vh></v>
<v t="T130"><vh>printFindList</vh></v>
</v>
</v>
</v>
<v t="T131"><vh>v.commands() Python method</vh></v>
</v>
<v t="T132"><vh>Changes made in version 1.3</vh></v>
<v t="T133"><vh>Changes made in version 1.2</vh></v>
<v t="T134"><vh>Changes made in version 1.1</vh></v>
<v t="T135"><vh>Changes made in version 1.0</vh></v>
<v t="T136"><vh>Changes made in version 0.19</vh>
<v t="T137"><vh>Fixed directory bug</vh></v>
<v t="T138"><vh>Added @language HTML, perl and perlpod</vh></v>
<v t="T139"><vh>Eliminated @noweb &amp; replaced @cweb with @language cweb</vh></v>
<v t="T140" a="C"><vh>About CWEB   </vh></v>
<v t="T141"><vh>Improved syntax coloring</vh></v>
<v t="T142"><vh>Improved Print command</vh></v>
<v t="T143"><vh>Improved how Untangle handles block comments</vh></v>
<v t="T144"><vh>Eliminated clone windows (but not clone nodes!)</vh></v>
<v t="T145"><vh>Eliminated Extended noweb Syntax</vh></v>
</v>
<v><vh>Changes made in version 0.18</vh>
<v t="T146"><vh>File format extended</vh></v>
<v t="T147"><vh>Fixed bug in languages without block comments</vh></v>
<v t="T148"><vh>Added @header and @noheader directives</vh></v>
<v t="T149"><vh>Added @language fortran90</vh></v>
<v t="T150"><vh>Added @language perlpod</vh></v>
</v>
<v t="T151"><vh>Changes made in version 0.17</vh>
<v t="T152"><vh>Support for noweb &lt;&lt;*&gt;&gt; convention</vh></v>
<v t="T153"><vh>new @cweb, @noweb, @path, @tabwidth and @pagewidth directives</vh></v>
<v t="T154"><vh>CWEB mode now has a chance of working</vh></v>
<v t="T155"><vh>Reduced default screen size</vh></v>
</v>
<v t="T156"><vh>Changes made in version 0.16</vh>
<v t="T157"><vh>Bug fixes</vh></v>
<v t="T158"><vh>Fixed crasher involving switching windows</vh></v>
<v t="T159"><vh>new @language directive</vh></v>
<v t="T160"><vh>@language and @comment directives can be inherited</vh></v>
<v t="T161"><vh>Untangle can now handle non-C files</vh></v>
<v t="T162"><vh>Untangle now removes trailing blank lines</vh></v>
<v t="T163"><vh>new @verbose, @terse and @silent directives</vh></v>
<v t="T164"><vh>Default directories</vh></v>
<v t="T165"><vh>Import Files command now handles Pascal , Python and Java files.</vh></v>
<v t="T166"><vh>Toggle Active Pane command</vh></v>
<v t="T167"><vh>Path delimiters are now '\' instead of '/'</vh></v>
<v t="T168"><vh>Cleaned up code</vh></v>
<v t="T169"><vh>Fixed crasher involving empty section names</vh></v>
<v t="T170"><vh>Untangle warns about sections not in the outline</vh></v>
<v t="T171"><vh>A limitations involving Untangle</vh></v>
</v>
<v t="T172" a="C"><vh>Known Bugs &amp; Limitations</vh></v>
</v>
</v>
</v>
<v t="T173"><vh>Leo Documentation</vh>
<v t="T174"><vh>An overview of Leo</vh></v>
<v t="T175"><vh>Front material</vh>
<v t="T176"><vh>Title Page &amp; Summary</vh></v>
<v t="T177"><vh>Legal Notices: Leo uses the Python license</vh></v>
<v t="T178"><vh>Preface</vh></v>
<v t="T179"><vh>Dedication</vh></v>
<v t="T50" a="C"><vh>Acknowledgements</vh></v>
<v t="T172" a="C"><vh>Known Bugs &amp; Limitations</vh></v>
</v>
<v t="T180"><vh>Chapter 1: Introducing Leo</vh>
<v t="T181"><vh>Everyday programming problems &amp; their solutions</vh></v>
<v t="T182"><vh>Leo compared to browsers and editors</vh></v>
<v t="T183"><vh>What Leo looks like</vh></v>
<v t="T184"><vh>Comparison chart</vh></v>
</v>
<v t="T185"><vh>Chapter 2: Installing Leo</vh>
<v t="T51" a="C"><vh>How to Install &amp; Run Leo</vh></v>
<v t="T186"><vh>Quick start</vh></v>
</v>
<v t="T187"><vh>Chapter 3: Using Outlines &amp; Body text</vh>
<v t="T188"><vh>Editing body text</vh></v>
<v t="T189"><vh>Creating and destroying headlines</vh></v>
<v t="T190"><vh>Expanding &amp; contracting headlines</vh></v>
<v t="T191"><vh>Moving &amp; Reorganizing headlines</vh></v>
<v t="T192"><vh>Marking headlines</vh></v>
<v t="T193" a="C"><vh>Cloning headlines</vh>
<v t="T194"><vh>read me</vh></v>
<v t="T195" a="C"><vh>a</vh>
<v t="T196" a="C"><vh>b</vh>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
</v>
<v t="T200"><vh>g</vh></v>
<v t="T196" a="C"><vh>b</vh>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
</v>
</v>
<v t="T195" a="C"><vh>a</vh>
<v t="T196" a="C"><vh>b</vh>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
</v>
<v t="T200"><vh>g</vh></v>
<v t="T196" a="C"><vh>b</vh>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
</v>
</v>
<v t="T201"><vh>f</vh></v>
</v>
<v t="T202"><vh>Resizing panes</vh></v>
<v t="T203"><vh>Undoing operations</vh></v>
</v>
<v t="T204"><vh>Chapter 4: Using directives</vh>
<v t="T205"><vh>Overview</vh></v>
<v t="T206"><vh>Section names</vh></v>
<v t="T207" a="C"><vh>Directives valid in @file trees</vh></v>
<v t="T208"><vh>Directives valid in @root or @unit trees</vh>
<v t="T209"><vh>noweb and CWEB and @noweb and @cweb</vh></v>
<v t="T210"><vh>The noweb man page</vh></v>
<v t="T211"><vh>Escape sequences</vh></v>
<v t="T212"><vh>Defining sections</vh></v>
<v t="T213"><vh>Tangling Roots: @root &amp; @unit directives</vh></v>
<v t="T103" a="C"><vh>Untangling: updating an outline</vh></v>
<v t="T214"><vh>@code: Section names in headlines</vh></v>
<v t="T215"><vh>Defining sections in several places</vh></v>
<v t="T216"><vh>Organizing an outline with sections</vh></v>
<v t="T217"><vh>Including comments: @verbose, @terse and @silent directives</vh></v>
<v t="T140" a="C"><vh>About CWEB   </vh></v>
</v>
<v><vh>Directives that are valid anywhere</vh>
<v t="T218"><vh>Default directories</vh></v>
<v t="T219"><vh>Specifying the target language: @language directive</vh></v>
<v t="T220"><vh>Over-riding preferences: @path, @pagewidth and @tabwidth directives</vh></v>
<v t="T221"><vh>Syntax Coloring: @color and @nocolor</vh></v>
</v>
</v>
<v t="T222"><vh>Chapter 5: Using commands</vh>
<v><vh> The File Menu</vh>
<v t="T223"><vh>Loading, Saving and Reverting Files</vh></v>
<v t="T224"><vh>Typesetting an Outline</vh></v>
<v t="T225"><vh>Tangling Producing Derived Files</vh></v>
<v t="T103" a="C"><vh>Untangling: updating an outline</vh></v>
<v t="T226"><vh>Tangling and Untangling: the Interface with the IDE</vh></v>
<v t="T227"><vh>Importing and Exporting Outlines</vh></v>
<v t="T228"><vh>Quitting Leo</vh></v>
</v>
<v><vh> The Edit Menu</vh>
<v t="T229"><vh>Cutting, Pasting and Selecting Text</vh></v>
<v t="T230"><vh>Creating Nodes from Body Text</vh></v>
<v t="T231"><vh>Finding and Changing Text</vh>
<v t="T232"><vh>Batch</vh></v>
<v t="T233"><vh>Ignore Case</vh></v>
<v t="T234"><vh>Mark Changes</vh></v>
<v t="T235"><vh>Mark Matches</vh></v>
<v t="T236"><vh>Pattern Match</vh></v>
<v t="T237"><vh>Reverse</vh></v>
<v t="T238"><vh>Search Body Text</vh></v>
<v t="T239"><vh>Search Headline Text</vh></v>
<v t="T240"><vh>Suboutline Only</vh></v>
<v t="T241"><vh>Whole Word</vh></v>
<v t="T242"><vh>Wrap Around</vh></v>
</v>
<v t="T243"><vh>Setting Preferences (Body text commands)</vh></v>
</v>
<v a="E"><vh> The Outline Menu</vh>
<v t="T244"><vh> Creating and Deleting Headlines</vh></v>
<v t="T245"><vh> Cutting, Pasting and Deleting Headlines</vh></v>
<v t="T246"><vh> Expanding and Contracting Headlines</vh></v>
<v t="T247"><vh> Moving and Reorganizing Headlines</vh></v>
<v t="T248"><vh> Marking Headlines</vh></v>
<v t="T193" a="C"><vh>Cloning headlines</vh>
<v t="T194"><vh>read me</vh></v>
<v t="T195" a="C"><vh>a</vh>
<v t="T196" a="C"><vh>b</vh>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
</v>
<v t="T200"><vh>g</vh></v>
<v t="T196" a="C"><vh>b</vh>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
</v>
</v>
<v t="T195" a="C"><vh>a</vh>
<v t="T196" a="C"><vh>b</vh>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
</v>
<v t="T200"><vh>g</vh></v>
<v t="T196" a="C"><vh>b</vh>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
<v t="T197" a="C"><vh>c</vh>
<v t="T198"><vh>d</vh></v>
<v t="T199"><vh>e</vh></v>
</v>
</v>
</v>
<v t="T201"><vh>f</vh></v>
</v>
</v>
<v><vh> The Window Menu</vh>
<v t="T249"><vh> Resizing Panes</vh></v>
<v t="T250"><vh> Cascading &amp; Minimizing Windows</vh></v>
<v t="T251"><vh> Opening and Closing the Log Window</vh></v>
<v t="T252"><vh>Bringing the Main Window to the Front</vh></v>
<v t="T253"><vh>Toggling the Active Pane</vh></v>
</v>
<v><vh>The Help Menu</vh>
<v t="T254"><vh> Getting Leo's Version</vh></v>
</v>
</v>
<v t="T255"><vh>Chapter 6: Scripting Leo</vh>
<v t="T256"><vh>Installing Python</vh></v>
<v><vh>Overview</vh>
<v t="T257"><vh>Terminology</vh></v>
<v t="T258"><vh>Type conventions</vh></v>
<v t="T259"><vh>The Python Window in Leo</vh></v>
<v t="T260"><vh>A basic script</vh></v>
<v t="T261"><vh>Traversing outlines</vh></v>
<v t="T262"><vh>How to get and change body text</vh></v>
<v t="T263"><vh>How Scripts create objects &amp; change properties</vh></v>
<v t="T264"><vh>Updating the screen</vh></v>
</v>
<v><vh>Functions</vh>
<v t="T265"><vh>topCommand</vh></v>
<v t="T266"><vh>getCommands</vh></v>
<v t="T267"><vh>getLeoPyWindow</vh></v>
</v>
<v t="T268"><vh>The Commands class</vh>
<v t="T269"><vh>File menu commands</vh></v>
<v t="T270"><vh>Edit menu commands</vh></v>
<v t="T271"><vh>Outline menu commands</vh></v>
<v t="T272"><vh>Window menu commands</vh></v>
<v t="T273"><vh>Menu enablers</vh></v>
<v t="T274"><vh>Commands Utilities</vh></v>
</v>
<v t="T275"><vh>The LeoPyWindow class</vh></v>
<v t="T276"><vh>The Preferences class</vh></v>
<v t="T277"><vh>The vnode class</vh>
<v t="T278"><vh>Getters</vh></v>
<v t="T279"><vh>Setters</vh></v>
</v>
<v t="T280"><vh>(High-level routines)</vh>
<v t="T115" a="C"><vh>High-level Find/Change functions</vh>
<v t="T116"><vh>leoFind.py</vh>
<v t="T117"><vh>changeAll</vh></v>
<v t="T118"><vh>changeNext</vh></v>
<v t="T119"><vh>changePrev</vh></v>
<v t="T120"><vh>findAll</vh></v>
<v t="T121"><vh>findNext</vh></v>
<v t="T122"><vh>findPrev</vh></v>
<v t="T123"><vh>reChangeAll</vh></v>
<v t="T124"><vh>reChangeNext</vh></v>
<v t="T125"><vh>reChangePrev</vh></v>
<v t="T126"><vh>reFindAll</vh></v>
<v t="T127"><vh>reFindNext</vh></v>
<v t="T128"><vh>reFindPrev</vh></v>
<v t="T129"><vh>lineAtPos</vh></v>
<v t="T130"><vh>printFindList</vh></v>
</v>
</v>
<v t="T281"><vh>High-level Commands methods</vh>
<v t="T282"><vh>flatVlist</vh></v>
<v t="T283"><vh>printFlatVlist</vh></v>
<v t="T284"><vh>printVlist</vh></v>
<v t="T285"><vh>vHeadList</vh></v>
<v t="T286"><vh>vlist</vh></v>
</v>
<v t="T287"><vh>High-level vnode methods</vh>
<v t="T288"><vh>children</vh></v>
</v>
</v>
</v>
<v t="T289"><vh>Chapter 7: Comparing Leo with Literate Programming</vh>
<v t="T290"><vh>Benefits of Traditional Literate Programming</vh>
<v t="T291"><vh>Literate programming creates a new design dimension</vh></v>
<v t="T292"><vh>Design and coding happen at the highest possible level</vh></v>
<v t="T293"><vh>The visual weight of code is separate from its actual length</vh></v>
<v t="T294"><vh>Complex section names invite improvements</vh></v>
<v t="T295"><vh>Sections create a place for extensive comments</vh></v>
<v t="T296"><vh>Section names eliminate mundane comments</vh></v>
<v t="T297"><vh>Sections create comments automatically</vh></v>
<v t="T298"><vh>Literate programming clarifies the shape of functions</vh></v>
<v t="T299"><vh>I spend less time formatting code</vh></v>
</v>
<v t="T300"><vh>How Leo Improves Literate Programming</vh>
<v t="T301"><vh>Outlines add context</vh></v>
<v t="T302"><vh>Outlines provide scope for commands</vh></v>
<v t="T303"><vh>Clones create different views and focus attention</vh></v>
<v t="T304"><vh>Outlines increase flexibility</vh></v>
<v t="T305"><vh>Outlines express hierarchy directly</vh></v>
<v t="T306"><vh>Outlines create new design dimensions</vh></v>
</v>
<v t="T307"><vh>How Leo Changes Literate Programming</vh></v>
<v><vh>Leo’s Design Goals</vh>
<v t="T308"><vh>A tool that I could use successfully</vh></v>
<v t="T309"><vh>A way to ignore formatting</vh></v>
<v t="T310"><vh>An outliner as good as MORE</vh></v>
<v t="T311"><vh>A self-contained programming system</vh></v>
<v t="T312"><vh>A tool that is fun to use</vh></v>
</v>
</v>
</v>
<v t="T313"><vh>About Leo2  Please read</vh>
<v t="T314"><vh>Why you should use Leo2</vh></v>
<v t="T207" a="C"><vh>Directives valid in @file trees</vh></v>
<v t="T315"><vh>Details</vh>
<v t="T316" a="C"><vh>The @delims directive </vh></v>
<v t="T85" a="C"><vh>Errors while reading</vh></v>
<v t="T86" a="C"><vh>Errors while writing</vh></v>
</v>
<v t="T87" a="C"><vh>Drawbacks of Leo2</vh></v>
<v t="T317"><vh>Converting Leo1 files to Leo2 files</vh></v>
</v>
<v t="T318"><vh>Appendices</vh>
<v t="T319"><vh>Announcing Leo2</vh></v>
<v t="T320"><vh>Command-key Abbreviations</vh></v>
<v t="T321"><vh>Directives</vh>
<v t="T322"><vh>@c and @code</vh></v>
<v t="T323"><vh>@chapter (Macintosh only)</vh></v>
<v t="T324"><vh>@color</vh></v>
<v t="T325"><vh>@comment</vh></v>
<v t="T326"><vh>@cweb</vh></v>
<v t="T327"><vh>@doc and @(space)</vh></v>
<v t="T328"><vh>@file (not valid in @root or @unit trees)</vh></v>
<v t="T329"><vh>@ignore  (not valid in @file trees)</vh></v>
<v t="T330"><vh>@language</vh></v>
<v t="T331"><vh>@nocolor</vh></v>
<v t="T332"><vh>@noweb</vh></v>
<v t="T333"><vh>@others (valid only in @file trees)</vh></v>
<v t="T334"><vh>@pagewidth</vh></v>
<v t="T335"><vh>@path</vh></v>
<v t="T336"><vh>@root  (not valid in @file trees)</vh></v>
<v t="T337"><vh>@section (Macintosh only)</vh></v>
<v t="T338"><vh>@silent (not valid in @file trees)</vh></v>
<v t="T339"><vh>@tabwidth</vh></v>
<v t="T340"><vh>@terse  (not valid in @file trees)</vh></v>
<v t="T341"><vh>@unit   (not valid in @file trees)</vh></v>
<v t="T342"><vh>@verbose, @terse and @silent directives</vh></v>
</v>
<v><vh>Error Messages</vh>
<v t="T343"><vh>Errors while tangling</vh>
<v t="T344"><vh>Can not re-open temp file</vh></v>
<v t="T345"><vh>Can not rename temporary file name</vh></v>
<v t="T346"><vh>@code expects the header: [text of header] to contain a section name</vh></v>
<v t="T347"><vh>@directive not valid here</vh></v>
<v t="T348"><vh>Halting Tangle: too many errors</vh></v>
<v t="T349"><vh>Invalid recursive reference of &lt;&lt; section name &gt;&gt;</vh></v>
<v t="T102" a="C"><vh>Multiple parts not allowed for &lt;&lt; section name &gt;&gt;</vh></v>
<v t="T350"><vh>No file written because of errors</vh></v>
<v t="T351"><vh>Run on comment</vh></v>
<v t="T352"><vh>Run on file name in @root directive</vh></v>
<v t="T353"><vh>Run on section name</vh></v>
<v t="T354"><vh>Run on string</vh></v>
<v t="T355"><vh>Section definition not valid here.</vh></v>
<v t="T356"><vh>Sections nested too deeply</vh></v>
<v t="T357"><vh>The outline contains no roots</vh></v>
<v t="T358"><vh>Undefined section:  &lt;&lt;&lt; section name &gt;&gt;&gt;</vh></v>
<v t="T359"><vh>Unexpected @directive while putting code</vh></v>
<v t="T360"><vh>Warning: possible duplicate definition of: &lt;&lt;&lt; section name &gt;&gt;&gt;</vh></v>
<v t="T361"><vh>Warning: &lt;&lt;&lt; section name &gt;&gt;&gt; has been defined but not used</vh></v>
</v>
<v t="T362"><vh>Errors while untangling</vh>
<v t="T363"><vh>Incompatible definitions of &lt;&lt;&lt; section name &gt;&gt;&gt;</vh></v>
<v t="T364"><vh>Missing root part</vh></v>
<v t="T365"><vh>Missing root section</vh></v>
<v t="T366"><vh>Missing sentinel line for &lt;&lt;&lt; section name &gt;&gt;&gt;</vh></v>
<v t="T367"><vh>Unterminated section: &lt;&lt;&lt; section name &gt;&gt;&gt;</vh></v>
</v>
<v><vh>Errors while reading @file nodes</vh>
<v t="T368"><vh>Minor errors</vh></v>
<v t="T369"><vh>Serious errors</vh></v>
</v>
<v t="T370"><vh>Errors while writing @file nodes</vh></v>
</v>
<v><vh>Formats of Files Derived from @file</vh>
<v t="T371"><vh>Sentinels in derived files</vh>
<v t="T316" a="C"><vh>The @delims directive </vh></v>
<v t="T372"><vh>@leo &amp; comment delimiters</vh></v>
<v t="T373"><vh>@node</vh></v>
<v t="T374"><vh>@body</vh></v>
<v t="T375"><vh>@at and @doc &amp; the trailine whitespace convention</vh></v>
<v t="T376"><vh>@others</vh></v>
<v t="T377"><vh>@@delims</vh></v>
<v t="T378"><vh>@@&lt;text&gt;</vh></v>
<v t="T379"><vh>@verbatim</vh></v>
<v t="T380"><vh>@&lt;&lt;section name&gt;&gt;</vh></v>
</v>
</v>
<v t="T381"><vh>Future Features</vh>
<v t="T382"><vh>Scripting</vh></v>
<v t="T383"><vh>Styled text and graphics</vh></v>
<v t="T384"><vh>Hypertext links</vh></v>
<v t="T385"><vh>The Write CWEB command</vh></v>
<v t="T386"><vh>Lists of sections</vh></v>
<v t="T387"><vh>Tiling panes horizontally</vh></v>
<v t="T388"><vh>Pascal To Outline command</vh></v>
<v t="T389"><vh>Script-Driven Tangle and Untangle commands</vh></v>
</v>
<v t="T390"><vh>History of Leo</vh></v>
<v t="T391"><vh>History of Leo2</vh>
<v t="T392"><vh>Step 1: Deciding to do Leo2</vh></v>
<v t="T393"><vh>Step 2: A Python prototype</vh>
<v t="T394"><vh>Leo2 Prototype Code</vh>
<v t="T395"><vh>@file read.py</vh>
<v t="T396"><vh>&lt;&lt; read.py vars &gt;&gt;</vh></v>
<v t="T397"><vh>readFile</vh>
<v t="T398"><vh>&lt;&lt; open the file into buffer &gt;&gt;</vh></v>
<v t="T399"><vh>&lt;&lt; set the sentinal delims &gt;&gt;</vh></v>
</v>
<v t="T400"><vh>scanNode</vh></v>
<v t="T401"><vh>utilities</vh>
<v t="T402"><vh>match</vh></v>
<v t="T403"><vh>getName</vh></v>
<v t="T404"><vh>createChild</vh></v>
<v t="T405"><vh>error</vh></v>
</v>
</v>
<v t="T406"><vh>@file write.py</vh>
<v t="T407"><vh>writeFile</vh></v>
<v t="T408"><vh>writeNode</vh></v>
<v t="T409"><vh>write</vh></v>
<v t="T410"><vh>writeStartRef</vh></v>
</v>
</v>
</v>
<v t="T411"><vh>Step 3: User Interaction is key</vh></v>
<v t="T412"><vh>Step 4: Write code</vh></v>
<v t="T413"><vh>Step 5: Read code</vh></v>
<v t="T414"><vh>Step 6: Load/Save code</vh></v>
<v t="T415"><vh>Step 7: Attributes, mirroring and dummy nodes</vh></v>
<v t="T416"><vh>Step 8: Clones</vh></v>
<v t="T417"><vh>Step 9: Error recovery, at last</vh></v>
<v t="T418"><vh>Diary</vh>
<v><vh>July 2001</vh>
<v t="T419"><vh>7/18/01 Import commands</vh></v>
<v t="T420"><vh>7/18/01 Save Outline To command</vh></v>
<v t="T421"><vh>7/17/01 Error recovery, completed</vh></v>
<v t="T422"><vh>7/16/01 Only writing dirty @file nodes</vh></v>
<v t="T423"><vh>7/16/01 Recognizing directives</vh></v>
<v t="T424"><vh>7/16/01 Implementing error recovery</vh></v>
<v t="T425"><vh>7/15/01 Designing error recovery</vh></v>
<v t="T426"><vh>7/13/01 Mirroring must be improved</vh></v>
<v t="T427"><vh>7/13/01 @others in doc parts is very dangerous</vh></v>
<v t="T428"><vh>7/13/01 Backups, part deux</vh></v>
<v t="T429"><vh>7/13/01 Backups</vh></v>
<v t="T430"><vh>7/10/01 Cleanup</vh></v>
<v t="T431"><vh>7/9/01 Cross-file clone breakthrough!</vh>
<v t="T432"><vh>email to Speed</vh></v>
</v>
<v t="T433"><vh>7/8/01</vh></v>
<v t="T434"><vh>7/6/01 Saving orphan/ignored nodes</vh></v>
<v t="T435"><vh>7/5/01Cross-file clones</vh></v>
<v t="T436"><vh>7/4/01Many miscellaneous file changes</vh></v>
<v t="T437"><vh>7/3/01 Bug fixes</vh></v>
<v t="T438"><vh>7/3/01 Hash tables</vh></v>
<v t="T439"><vh>7/3/01 Saving orphan and ignored nodes in .leo files</vh></v>
<v t="T440"><vh>7/2/01</vh></v>
<v t="T441"><vh>7/1/01</vh></v>
</v>
<v><vh>June 2001</vh>
<v t="T442"><vh>6/30/01 Progress report to Speed Ream</vh></v>
<v t="T443"><vh>6/29/01 A new design point</vh></v>
<v t="T444"><vh>6/28/01</vh></v>
<v t="T445"><vh>6/27/01</vh></v>
<v t="T446"><vh>6/26/01</vh></v>
<v t="T447"><vh>6/25/01Read/Write works on atFile.cpp</vh></v>
<v t="T448"><vh>6/24/01</vh></v>
<v t="T449"><vh>6/23/01 Trailing newline convention</vh></v>
<v t="T450"><vh>6/20/01</vh></v>
<v t="T451"><vh>6/17/01 Clean compile/link of untangle</vh></v>
<v t="T452"><vh>6/15/01 Simplified tangle</vh></v>
<v t="T453"><vh>6/2/01 Tangle-on_write/untangle-on-read</vh></v>
</v>
</v>
<v t="T454"><vh>Letters to Speed Ream</vh>
<v t="T455"><vh>6/3/01 Breakthrough with Leo</vh></v>
<v t="T456"><vh>6/20/01 The new Leo</vh></v>
<v t="T457"><vh>6/23/01 Perfect whitespace</vh></v>
<v t="T458"><vh>6/26/01 Leo2 read/write code complete</vh>
<v t="T459"><vh>Reply from Speed</vh></v>
</v>
<v t="T460"><vh>6/26/01 A history of the new Leo</vh></v>
<v t="T461"><vh>6/30/01 Leo2 progress(!!) report</vh></v>
<v t="T462"><vh>7/6/01 First bug in read/write code</vh>
<v t="T463"><vh>Reply from Speed</vh></v>
</v>
<v t="T464"><vh>7/9/01 Leo2 is complete?!?</vh></v>
</v>
<v><vh>Notes</vh>
<v t="T465"><vh>Excerpts  from my engineering notes</vh></v>
<v t="T466"><vh>Excerpts from typed nodes</vh>
<v><vh>Writing an outline</vh>
<v t="T467"><vh>errors and warnings</vh></v>
<v t="T468"><vh>helping the Read code: two Ahas</vh>
<v t="T469"><vh>Aha: Sentinels contain 2 newlines</vh></v>
<v t="T470"><vh>Aha: Using trailing whitespace as a flag in doc parts</vh></v>
</v>
</v>
<v><vh>Reading an outline</vh>
<v t="T471"><vh>handling @node sentinels</vh></v>
<v t="T472"><vh>handling @others sentinels</vh></v>
<v t="T473"><vh>handling @at and @doc sentinels</vh></v>
</v>
<v t="T474"><vh>Cross-file clones</vh></v>
<v t="T475"><vh>clones</vh></v>
<v t="T476"><vh>escape conventions &amp; CWEB</vh></v>
<v t="T477"><vh>XML syntax not desirable</vh></v>
</v>
</v>
</v>
<v t="T172" a="C"><vh>Known Bugs &amp; Limitations</vh></v>
<v t="T478"><vh>Leo2 source language reference</vh></v>
<v><vh>Macintosh Notes</vh>
<v t="T479"><vh>Differences Between the PC and Mac Versions</vh></v>
<v t="T480"><vh>Transfering Files</vh></v>
</v>
<v t="T481"><vh>Sherlock</vh></v>
<v t="T482"><vh>XML file format</vh>
<v t="T483"><vh>&lt;?xml ... ?&gt;</vh></v>
<v t="T484"><vh>&lt;leo_file&gt; ... &lt;/leo_file&gt;</vh>
<v t="T485"><vh>&lt;leo_header ... /&gt;</vh></v>
<v t="T486"><vh>&lt;globals ... &gt; ... &lt;/globals&gt;</vh></v>
<v t="T487"><vh>&lt;preferences ... &gt; ... &lt;/preferences&gt;</vh></v>
<v t="T488"><vh>&lt;find_panel_settings ... &gt; ... &lt;/find_panel_settings&gt;</vh></v>
<v t="T489"><vh>&lt;vnodes&gt;...&lt;/vnodes&gt;</vh>
<v t="T490"><vh>&lt;v...&gt; ... &lt;/v&gt;</vh></v>
</v>
<v t="T491"><vh>&lt;tnodes&gt; ... &lt;/tnodes&gt;</vh>
<v t="T492"><vh>&lt;t...&gt; ... &lt;/t&gt;</vh></v>
</v>
<v t="T493"><vh>&lt;clone_windows&gt; ... &lt;/clone_windows&gt;</vh>
<v t="T494"><vh>&lt;clone_window ...&gt; ... &lt;/clone_window&gt;</vh></v>
</v>
</v>
<v t="T495"><vh>DTD for Leo's File Format</vh></v>
<v t="T496"><vh>An example file</vh>
<v t="T497"><vh>The file itself</vh></v>
<v><vh>The outline  from which the example file was created</vh>
<v t="T498"><vh>Headline 1</vh>
<v t="T499"><vh>Headline 2</vh>
<v><vh>Headline 3 ( No body text)</vh></v>
</v>
</v>
<v t="T500" a="C"><vh>Headline 4 ( a clone )</vh>
<v t="T501"><vh>Headline 5</vh></v>
</v>
<v t="T500" a="C"><vh>Headline 4 ( a clone )</vh>
<v t="T501"><vh>Headline 5</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="T5" a="C"><vh>Glossary</vh>
<v t="T6"><vh>@file node</vh></v>
<v t="T7"><vh>@file tree</vh></v>
<v t="T8"><vh>@ignore node</vh></v>
<v t="T9"><vh>@others node</vh></v>
<v t="T10"><vh>@others tree</vh></v>
<v t="T11"><vh>@root node</vh></v>
<v t="T12"><vh>@root tree</vh></v>
<v t="T13"><vh>@unit node</vh></v>
<v t="T14"><vh>@unit tree</vh></v>
<v t="T15"><vh>Body Text</vh></v>
<v t="T16"><vh>Body Text Box</vh></v>
<v t="T17"><vh>Child</vh></v>
<v t="T18"><vh>Clone</vh></v>
<v t="T19"><vh>Clone Arrow</vh></v>
<v t="T20"><vh>Chunk</vh></v>
<v t="T21"><vh>CWEB</vh></v>
<v t="T22"><vh>Derived file</vh></v>
<v t="T23"><vh>Directive</vh></v>
<v t="T24"><vh>Grandchild</vh></v>
<v t="T25"><vh>Headline</vh></v>
<v t="T26"><vh>Donald Knuth</vh></v>
<v t="T27"><vh>Leo</vh></v>
<v t="T28"><vh>Leo1 tree</vh></v>
<v t="T29"><vh>Leo2 tree</vh></v>
<v t="T30"><vh>Literate programming</vh></v>
<v t="T31"><vh>Named nodes</vh></v>
<v t="T32"><vh>noweb</vh></v>
<v t="T33"><vh>Norman Ramsey</vh></v>
<v t="T34"><vh>Node</vh></v>
<v t="T35"><vh>Offspring</vh></v>
<v t="T36"><vh>Orphan node</vh></v>
<v t="T37"><vh>Parent</vh></v>
<v t="T38"><vh>.pdf file</vh></v>
<v t="T39"><vh>Root</vh></v>
<v t="T40"><vh>Section</vh></v>
<v t="T41"><vh>Sibling</vh></v>
<v t="T42"><vh>Status Icon</vh></v>
<v t="T43"><vh>Tangling</vh></v>
<v t="T44"><vh>Tree</vh></v>
<v t="T45"><vh>Unnamed node</vh></v>
<v t="T46"><vh>Untangling</vh></v>
<v t="T47"><vh>Weaving</vh></v>
</v>
<v t="T502"><vh>Hello world programs</vh>
<v t="T503"><vh>Hello World for Leo1</vh>
<v t="T504"><vh>&lt;&lt; includes &gt;&gt;</vh></v>
<v t="T505"><vh>&lt;&lt; methods &gt;&gt;</vh></v>
</v>
<v t="T506"><vh>Hello World for Leo2</vh>
<v t="T507"><vh>@file hello.c</vh>
<v t="T508"><vh>&lt;&lt; includes &gt;&gt;</vh></v>
<v t="T509"><vh>main</vh></v>
</v>
</v>
</v>
<v t="T510"><vh>Sample Code</vh>
<v t="T511"><vh>Leo1 Code</vh>
<v t="T512"><vh>Nodes</vh>
<v t="T513"><vh>tnode</vh>
<v t="T514"><vh>tnode.h</vh>
<v t="T515"><vh>&lt;&lt; tnode data members &gt;&gt;</vh></v>
<v t="T516"><vh>&lt;&lt; tnode constructors &amp; destructors &gt;&gt;</vh></v>
<v t="T517"><vh>&lt;&lt; tnode debugging &gt;&gt;</vh></v>
<v t="T518"><vh>&lt;&lt; tnode getters &gt;&gt;</vh></v>
<v t="T519"><vh>&lt;&lt; tnode setters &gt;&gt;</vh></v>
</v>
<v t="T520"><vh>tnode.cpp</vh>
<v t="T521"><vh>&lt;&lt; tnode includes &gt;&gt;</vh></v>
<v t="T522"><vh>&lt;&lt; tnode abbreviations &gt;&gt;</vh></v>
</v>
<v t="T523"><vh>Birth &amp; Death</vh></v>
<v><vh>Debugging</vh>
<v t="T524"><vh>edump</vh></v>
</v>
<v><vh>Getters</vh>
<v><vh>Getting body text and selection</vh>
<v t="T525"><vh>bodyRTF</vh></v>
<v t="T526"><vh>bodyCString</vh></v>
<v t="T527"><vh>bodyCStringLength</vh></v>
<v t="T528"><vh>bodyString (tnode)</vh></v>
<v t="T529"><vh>loadBodyPaneFromTnode</vh></v>
<v t="T530"><vh>selectionLength</vh></v>
<v t="T531"><vh>selectionStart</vh></v>
</v>
<v><vh>Status bits</vh>
<v t="T532"><vh>isDirty</vh></v>
<v t="T533"><vh>isRichTextBit</vh></v>
<v t="T534"><vh>isVisited</vh></v>
</v>
<v t="T535"><vh>cloneIndex</vh></v>
<v t="T536"><vh>fileIndex</vh></v>
<v t="T537"><vh>hasBody</vh></v>
<v t="T538"><vh>joinHead</vh></v>
</v>
<v><vh>Setters</vh>
<v><vh>Setting body text</vh>
<v t="T539"><vh>saveBodyPaneToTnode</vh></v>
<v t="T540"><vh>setTnodeRTF</vh></v>
<v t="T541"><vh>setTnodeText</vh></v>
<v t="T542"><vh>setSelection </vh></v>
</v>
<v><vh>Status bits</vh>
<v t="T543"><vh>clearDirty</vh></v>
<v t="T544"><vh>clearRichTextBit</vh></v>
<v t="T545"><vh>clearVisited</vh></v>
<v t="T546"><vh>setDirty</vh></v>
<v t="T547"><vh>setRichTextBit</vh></v>
<v t="T548"><vh>setVisited</vh></v>
</v>
<v t="T549"><vh>setCloneIndex</vh></v>
<v t="T550"><vh>setFileIndex</vh></v>
<v t="T551"><vh>setJoinHead</vh></v>
</v>
</v>
<v t="T552"><vh>vnode</vh>
<v t="T553"><vh>vnode.h</vh>
<v t="T554"><vh>&lt;&lt; dvnode data members &gt;&gt;</vh></v>
<v t="T555"><vh>&lt;&lt; vnode access methods &gt;&gt;</vh></v>
<v t="T556"><vh>&lt;&lt; vnode comparisons &gt;&gt;</vh></v>
<v t="T557"><vh>&lt;&lt; vnode constructors &amp; destructors &gt;&gt;</vh></v>
<v t="T558"><vh>&lt;&lt; vnode data members &gt;&gt;</vh></v>
<v t="T559"><vh>&lt;&lt; vnode debugging &gt;&gt;</vh></v>
<v t="T560"><vh>&lt;&lt; vnode file methods &gt;&gt;</vh></v>
<v t="T561"><vh>&lt;&lt; vnode getters &gt;&gt;</vh></v>
<v t="T562"><vh>&lt;&lt; vnode private methods &gt;&gt;</vh></v>
<v t="T563"><vh>&lt;&lt; vnode setters &gt;&gt;</vh></v>
<v t="T564"><vh>&lt;&lt; vnode tree methods &gt;&gt;</vh></v>
</v>
<v t="T565"><vh>vnode.cpp</vh>
<v t="T566"><vh>&lt;&lt; vnode includes &gt;&gt;</vh></v>
<v t="T567"><vh>&lt;&lt; vnode abbreviations &gt;&gt;</vh></v>
</v>
<v t="T568"><vh>Birth &amp; Death</vh></v>
<v><vh>Comparisons</vh>
<v t="T569"><vh>atFileNodeName</vh></v>
<v t="T570"><vh>isAtFileNode</vh></v>
<v t="T571"><vh>isAtIgnoreNode</vh></v>
<v t="T572"><vh>isAtOthersNode</vh></v>
<v t="T573"><vh>matchHeadline</vh></v>
</v>
<v><vh>Dumping</vh>
<v t="T574"><vh>edump</vh></v>
<v t="T575"><vh>description</vh></v>
</v>
<v><vh>File Conversion</vh>
<v t="T576"><vh>convertTreeToString</vh></v>
<v t="T577"><vh>moreHead</vh></v>
<v t="T578"><vh>moreBody</vh></v>
</v>
<v><vh>Getters</vh>
<v><vh>Children</vh>
<v t="T579"><vh>childIndex</vh></v>
<v t="T580"><vh>firstChild</vh></v>
<v t="T581"><vh>hasChildren</vh></v>
<v t="T582"><vh>lastChild</vh></v>
<v t="T583"><vh>nthChild</vh></v>
<v t="T584"><vh>numberOfChildren</vh></v>
</v>
<v><vh>Cross-file clones</vh>
<v t="T585"><vh>xCloneName</vh></v>
<v t="T586"><vh>xCloneIndex</vh></v>
</v>
<v><vh>Structure Links</vh>
<v t="T587"><vh>back</vh></v>
<v t="T588"><vh>lastNode</vh></v>
<v t="T589"><vh>level</vh></v>
<v t="T590"><vh>next</vh></v>
<v t="T591"><vh>parent</vh></v>
<v t="T592"><vh>nodeAfterTree</vh></v>
<v t="T593"><vh>threadBack</vh></v>
<v t="T594"><vh>threadNext</vh></v>
<v t="T595"><vh>visBack</vh></v>
<v t="T596"><vh>visNext</vh></v>
</v>
<v><vh>Head &amp; Body Strings</vh>
<v t="T597"><vh>bodyCString</vh></v>
<v t="T598"><vh>bodyCStringLength</vh></v>
<v t="T599"><vh>bodyRTF</vh></v>
<v t="T600"><vh>bodyString</vh></v>
<v t="T601"><vh>headCString</vh></v>
<v t="T602"><vh>headCStringLength</vh></v>
<v t="T603"><vh>headString</vh></v>
</v>
<v><vh>Status Bits</vh>
<v t="T604"><vh>isCloned</vh></v>
<v t="T605"><vh>isDirty</vh></v>
<v t="T606"><vh>isDummy</vh></v>
<v t="T607"><vh>isExpanded</vh></v>
<v t="T608"><vh>isExpandedBitSet</vh></v>
<v t="T609"><vh>isMarked</vh></v>
<v t="T610"><vh>isOrphan</vh></v>
<v t="T611"><vh>isSelectedBitSet</vh></v>
<v t="T612"><vh>isTopBitSet</vh></v>
<v t="T613"><vh>isVisible</vh></v>
<v t="T614"><vh>isVisited</vh></v>
<v t="T615"><vh>status</vh></v>
</v>
<v><vh>VCL classes (vnode)</vh>
<v t="T616"><vh>findRoot</vh></v>
<v t="T617"><vh>commands</vh></v>
<v t="T618"><vh>leoForm</vh></v>
<v t="T619"><vh>treeNode</vh></v>
<v t="T620"><vh>treeNodes</vh></v>
<v t="T621"><vh>treeView</vh></v>
</v>
<v t="T622"><vh>currentVnode (vnode)</vh></v>
<v t="T623"><vh>iconVal</vh></v>
<v t="T624"><vh>isAncestorOf </vh></v>
<v t="T625"><vh>isRoot</vh></v>
<v t="T626"><vh>joinList</vh></v>
<v t="T627"><vh>selectionStart</vh></v>
<v t="T628"><vh>selectionLength</vh></v>
<v t="T629"><vh>t</vh></v>
</v>
<v><vh>Setters</vh>
<v><vh>cross-file clones</vh>
<v t="T630"><vh>setXCloneIndex</vh></v>
<v t="T631"><vh>setXCloneName</vh></v>
</v>
<v><vh>headline and body text</vh>
<v t="T632"><vh>appendStringToBody</vh></v>
<v t="T633"><vh>setBodyStringOrPane (new for SWIG)</vh></v>
<v t="T634"><vh>setHeadString &amp; initHeadString</vh></v>
<v t="T635"><vh>setHeadStringOrHeadline (new for SWIG)</vh></v>
<v t="T636"><vh>trimTrailingLines</vh></v>
</v>
<v><vh>icons</vh>
<v t="T637"><vh>computeIcon</vh></v>
<v t="T638"><vh>setIcon</vh></v>
<v t="T639"><vh>setIconVal</vh></v>
<v t="T640"><vh>setIconWithVal</vh></v>
</v>
<v t="T641"><vh>setJoinList</vh></v>
<v t="T642"><vh>setSelection</vh></v>
<v t="T643"><vh>setT</vh></v>
<v t="T644"><vh>setTreeNode</vh></v>
<v><vh>status bits</vh>
<v t="T645"><vh>clearClonedBit</vh></v>
<v t="T646"><vh>clearDirty &amp; clearDirtyJoined</vh></v>
<v t="T647"><vh>clearDummy</vh></v>
<v t="T648"><vh>clearMarked</vh></v>
<v t="T649"><vh>clearOrphan</vh></v>
<v t="T650"><vh>clearVisited</vh></v>
<v t="T651"><vh>initClonedBit</vh></v>
<v t="T652"><vh>initDirtyBit</vh></v>
<v t="T653"><vh>initExpandedBit (new)</vh></v>
<v t="T654"><vh>initMarkedBit</vh></v>
<v t="T655"><vh>initSelectedBit (new)</vh></v>
<v t="T656"><vh>initTopBit (new)</vh></v>
<v t="T657"><vh>initStatus</vh></v>
<v t="T658"><vh>setAncestorAtFileNodeDirty</vh></v>
<v t="T659"><vh>setClonedBit</vh></v>
<v t="T660"><vh>setDirty &amp; setDirtyJoined</vh></v>
<v t="T661"><vh>setDummy</vh></v>
<v t="T662"><vh>setOrphan</vh></v>
<v t="T663"><vh>setVisited</vh></v>
<v t="T664"><vh>setMarked</vh></v>
</v>
</v>
<v><vh>Moving, Inserting, Deleting, Cloning</vh>
<v><vh>About clones</vh></v>
<v><vh>Entry Points (vnode)</vh>
<v t="T665"><vh>clone (vnode)</vh></v>
<v t="T666"><vh>createDependents</vh></v>
<v t="T667"><vh>doDelete</vh>
<v t="T668"><vh>&lt;&lt; dump the dv list &gt;&gt;</vh></v>
</v>
<v t="T669"><vh>freeDVNodes</vh></v>
<v t="T670"><vh>insertAfter</vh></v>
<v t="T671"><vh>insertAsLastChild</vh></v>
<v t="T672"><vh>insertAsNthChild</vh></v>
<v t="T673"><vh>moveAfter</vh></v>
<v t="T674"><vh>moveToRoot</vh></v>
<v t="T675"><vh>moveToNthChildOf</vh></v>
<v t="T676"><vh>restoreOutlineFromDVnodes</vh>
<v t="T677"><vh>&lt;&lt; Insert v into the outline &gt;&gt;</vh></v>
<v t="T678"><vh>&lt;&lt; Set back and parent fields for the new vnode &gt;&gt;</vh></v>
<v t="T679"><vh>&lt;&lt; set icons for all vnodes of the result tree &gt;&gt;</vh></v>
</v>
</v>
<v t="T680"><vh>cloneTree</vh></v>
<v t="T681"><vh>copyCloneBitsTo</vh></v>
<v t="T682"><vh>copyTree</vh></v>
<v t="T683"><vh>destroyDependents</vh></v>
<v t="T684"><vh>destroyTree</vh></v>
<v t="T685"><vh>invalidOutline</vh></v>
<v t="T686"><vh>isJoinedTo</vh></v>
<v t="T687"><vh>isOnJoinListOf</vh></v>
<v t="T688"><vh>joinNodeTo</vh></v>
<v t="T689"><vh>joinTreeTo</vh></v>
<v t="T690"><vh>saveOutlineWithLevel</vh>
<v t="T691"><vh>&lt;&lt; Set the data fields of dv &gt;&gt;</vh></v>
</v>
<v t="T692"><vh>shouldBeClone</vh></v>
<v t="T693"><vh>unjoinNode</vh>
<v t="T694"><vh>&lt;&lt; Set prev to the node that points to this &gt;&gt;</vh></v>
</v>
<v t="T695"><vh>unjoinTree</vh></v>
<v t="T696"><vh>validateOutlineWithParent</vh>
<v t="T697"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="T698"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="T699"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="T700"><vh>Leo2 Code</vh>
<v><vh>atFile</vh>
<v t="T701"><vh>@file atFile.h</vh>
<v t="T702"><vh>&lt;&lt; declare public utility functions &gt;&gt;</vh></v>
<v t="T703"><vh>&lt;&lt; private atFile data &gt;&gt;</vh></v>
<v t="T704"><vh>&lt;&lt; private read methods &gt;&gt;</vh></v>
<v t="T705"><vh>&lt;&lt; private sentinel methods &gt;&gt;</vh></v>
<v t="T706"><vh>&lt;&lt; private utilities &gt;&gt;</vh></v>
<v t="T707"><vh>&lt;&lt; private write methods &gt;&gt;</vh></v>
</v>
<v t="T708"><vh>@file atFile.cpp</vh>
<v><vh>Declarations</vh>
<v t="T709"><vh>&lt;&lt; atFile includes &gt;&gt;</vh></v>
<v t="T710"><vh>&lt;&lt; atFile abbreviations &gt;&gt;</vh></v>
<v t="T711"><vh>&lt;&lt; atFile constants &gt;&gt;</vh></v>
</v>
<v><vh>Commands methods</vh>
<v t="T712"><vh>Commands::readAtFile</vh></v>
<v t="T713"><vh>Commands::writeAtFile</vh></v>
</v>
<v t="T714"><vh>atFile ctor</vh></v>
<v><vh>Reading</vh>
<v t="T715"><vh>createNthChild</vh></v>
<v t="T716"><vh>joinTrees</vh></v>
<v t="T717"><vh>read</vh>
<v t="T718"><vh>&lt;&lt; Declare read vars &gt;&gt;</vh></v>
<v t="T719"><vh>&lt;&lt; read the entire file into fileData &gt;&gt;</vh></v>
<v t="T720"><vh>&lt;&lt; Scan the file buffer  &gt;&gt;</vh></v>
<v t="T721"><vh>&lt;&lt; Issue structure error message &gt;&gt;</vh></v>
<v t="T722"><vh>&lt;&lt; Delete root's tree and body text &gt;&gt;</vh></v>
<v t="T723"><vh>&lt;&lt; Handle clone bits &gt;&gt;</vh></v>
<v t="T724"><vh>&lt;&lt; Join cloned trees &gt;&gt;</vh></v>
<v t="T725"><vh>&lt;&lt; Handle all status bits &gt;&gt;</vh></v>
<v t="T726"><vh>&lt;&lt; Issue serious error message &gt;&gt;</vh></v>
</v>
<v t="T727"><vh>readAll</vh></v>
<v t="T728"><vh>scanDoc</vh>
<v t="T729"><vh>&lt;&lt; Skip the opening sentinel &gt;&gt;</vh></v>
<v t="T730"><vh>&lt;&lt; Skip an opening block delim &gt;&gt;</vh></v>
<v t="T731"><vh>&lt;&lt; Append the next comment line to v's body &gt;&gt;</vh></v>
<v t="T732"><vh>&lt;&lt; Skip the closing sentinel &gt;&gt;</vh></v>
<v t="T733"><vh>&lt;&lt; Remove a closing block delim from v's body &gt;&gt;</vh></v>
</v>
<v t="T734"><vh>scanHeader</vh></v>
<v t="T735"><vh>scanText</vh>
<v t="T736"><vh>&lt;&lt; Set lineIndent and linep &gt;&gt;</vh></v>
<v t="T737"><vh>&lt;&lt; remove indent and append line &gt;&gt;</vh></v>
<v t="T738"><vh>&lt;&lt; handle an ending sentinel &gt;&gt;</vh></v>
<v t="T739"><vh>&lt;&lt; handle unexpected end of text &gt;&gt;</vh></v>
<v><vh>start sentinels</vh>
<v t="T740"><vh>&lt;&lt; scan @+at &gt;&gt;</vh></v>
<v t="T741"><vh>&lt;&lt; scan @+body &gt;&gt;</vh></v>
<v t="T742"><vh>&lt;&lt; scan @+doc &gt;&gt;</vh></v>
<v t="T743"><vh>&lt;&lt; scan @+leo &gt;&gt;</vh></v>
<v t="T744"><vh>&lt;&lt; scan @+node &gt;&gt;</vh>
<v t="T745"><vh>&lt;&lt; skip the node sentinel, setting headline, ref and n &gt;&gt;</vh>
<v t="T746"><vh>&lt;&lt; Set status bits in dummy vnode &gt;&gt;</vh>
<v t="T747"><vh>&lt;&lt; set index from the C=nnn, field &gt;&gt;</vh></v>
</v>
</v>
<v t="T748"><vh>&lt;&lt; copy new_ms to child's body &gt;&gt;</vh></v>
<v t="T749"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="T750"><vh>&lt;&lt; scan @+others &gt;&gt;</vh></v>
</v>
<v><vh>unpaired sentinels</vh>
<v t="T751"><vh>&lt;&lt; scan @ref &gt;&gt;</vh></v>
<v t="T752"><vh>&lt;&lt; scan @verbatim &gt;&gt;</vh></v>
<v t="T753"><vh>&lt;&lt; scan @@ &gt;&gt;</vh></v>
</v>
<v t="T754"><vh>&lt;&lt; warn about unknown sentinel &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Writing</vh>
<v t="T755"><vh>putBody</vh></v>
<v t="T756"><vh>putBodyPart (removes trailing lines)</vh>
<v t="T757"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh></v>
</v>
<v t="T758"><vh>putCodePart &amp; allies</vh>
<v t="T759"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T760"><vh>&lt;&lt; compute delta, the width of the whitespace &gt;&gt;</vh></v>
<v t="T761"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T762"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T763"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T764"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T765"><vh>findReference</vh></v>
<v t="T766"><vh>inAtOthers</vh></v>
<v t="T767"><vh>putAtOthers</vh></v>
<v t="T768"><vh>putAtOthersChild</vh></v>
</v>
<v t="T769"><vh>putDirective</vh></v>
<v t="T770"><vh>putDoc</vh>
<v t="T771"><vh>&lt;&lt; skip the @&lt;space&gt; or @doc &gt;&gt;</vh></v>
<v t="T772"><vh>&lt;&lt; set limit to the end of the doc part &gt;&gt;</vh></v>
</v>
<v t="T773"><vh>putDocPart</vh>
<v t="T774"><vh>&lt;&lt; copy words, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="T775"><vh>write</vh>
<v t="T776"><vh>&lt;&lt; Open files.  Set orphan flag and return on errors &gt;&gt;</vh>
<v t="T777"><vh>&lt;&lt; setOrphan and return if mTargetFileName is bad &gt;&gt;</vh></v>
<v t="T778"><vh>&lt;&lt; Open a temp file and set mOutputFileName &gt;&gt;</vh></v>
</v>
<v t="T779"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T780"><vh>&lt;&lt; Issue final write error message &gt;&gt;</vh></v>
<v t="T781"><vh>&lt;&lt; Replace the target with the temp file if different &gt;&gt;</vh></v>
</v>
<v t="T782"><vh>writeAll</vh>
<v t="T783"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
</v>
<v t="T784"><vh>Output</vh>
<v t="T785"><vh>putBlanks</vh></v>
<v t="T786"><vh>putChar</vh></v>
<v t="T787"><vh>putIndent</vh></v>
<v t="T788"><vh>putInt</vh></v>
<v t="T789"><vh>putString</vh></v>
<v t="T790"><vh>putTabs</vh></v>
</v>
</v>
<v><vh>Sentinels</vh>
<v t="T791"><vh>nodeSentinelText</vh>
<v t="T792"><vh>&lt;&lt; append the status-bit characters to s &gt;&gt;</vh></v>
</v>
<v t="T793"><vh>putCloseNodeSentinel</vh></v>
<v t="T794"><vh>putCloseSentinels</vh></v>
<v t="T795"><vh>putOpenLeoSentinel</vh></v>
<v t="T796"><vh>putOpenNodeSentinel</vh></v>
<v t="T797"><vh>putOpenSentinels</vh></v>
<v t="T798"><vh>putSentinel</vh></v>
<v t="T799"><vh>sentinelKind</vh></v>
<v t="T800"><vh>sentinelName</vh></v>
<v t="T801"><vh>skipSentinelStart</vh></v>
</v>
<v><vh>Utility functions</vh>
<v t="T802"><vh>compareFiles</vh></v>
<v t="T803"><vh>directiveKind</vh></v>
<v t="T804"><vh>isSectionName</vh></v>
<v t="T805"><vh>setAncestorAtFileNodeDirty</vh></v>
</v>
<v><vh>Utilites</vh>
<v t="T806"><vh>appendToBody</vh></v>
<v t="T807"><vh>atFile::scanAllDirectives</vh>
<v t="T808"><vh>&lt;&lt; Set global arguments to default values &gt;&gt;</vh></v>
<v t="T809"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="T810"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T811"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T812"><vh>&lt;&lt; Remove leading and trailing delims if they exist &gt;&gt;</vh></v>
</v>
<v t="T813"><vh>&lt;&lt; Test for @pagewidth and @tabwidth &gt;&gt;</vh></v>
<v t="T814"><vh>&lt;&lt; Set current directory if possible &gt;&gt;</vh></v>
<v t="T815"><vh>&lt;&lt; Set comment Strings from global vars &gt;&gt;</vh></v>
</v>
<v t="T816"><vh>error</vh></v>
<v t="T817"><vh>skipIndent</vh></v>
<v t="T818"><vh>updateCloneIndices</vh></v>
<v t="T819"><vh>writeError</vh></v>
</v>
</v>
</v>
<v><vh>FileCommands</vh>
<v t="T820"><vh>@file FileCommands.cpp</vh>
<v><vh>Declaratons</vh>
<v t="T821"><vh>&lt;&lt; File commands includes &gt;&gt;</vh></v>
<v t="T822"><vh>&lt;&lt; Declare File commands private functions &gt;&gt;</vh></v>
<v t="T823"><vh>&lt;&lt; Declare the EBadLeoFile class &gt;&gt;</vh></v>
</v>
<v><vh>Tag List routines</vh>
<v t="T824"><vh>deleteTagList</vh></v>
<v t="T825"><vh>getVtag</vh></v>
<v t="T826"><vh>newVtag</vh></v>
</v>
<v><vh>Export</vh>
<v t="T827"><vh>exportMoreText</vh></v>
<v t="T828"><vh>flattenOutline</vh></v>
<v t="T829"><vh>flattenOutlineWithFilename</vh></v>
<v t="T830"><vh>outlineToNoweb</vh></v>
<v t="T831"><vh>convertToNoweb</vh></v>
<v t="T832"><vh>convertCodePartToNoweb</vh>
<v t="T833"><vh>&lt;&lt; Output the section reference &gt;&gt;</vh>
<v t="T834"><vh>&lt;&lt; Set name to the file name p2..p &gt;&gt;</vh></v>
<v t="T835"><vh>&lt;&lt; point p1 and p2 at section name in v's headline &gt;&gt;</vh></v>
</v>
</v>
<v t="T836"><vh>convertDocPartToNoweb</vh></v>
<v t="T837"><vh>copyPart</vh>
<v t="T838"><vh>&lt;&lt; return p if this is a section definition &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Import</vh>
<v t="T839"><vh>convertMoreStringsToOutlineAfter</vh>
<v t="T840"><vh>&lt;&lt; Declare the vars for convertMoreStringsToOutlineAfter &gt;&gt;</vh></v>
<v t="T841"><vh>&lt;&lt; Link a new vnode v into the outline &gt;&gt;</vh></v>
<v t="T842"><vh>&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;</vh></v>
<v t="T843"><vh>&lt;&lt; Count the number of following body lines &gt;&gt;</vh></v>
<v t="T844"><vh>&lt;&lt; Add the lines to the body text of v &gt;&gt;</vh></v>
</v>
<v t="T845"><vh>importMoreText</vh>
<v t="T846"><vh>&lt;&lt; Read the file into strings &gt;&gt;</vh></v>
</v>
<v t="T847"><vh>moreHeadlineLevel</vh></v>
<v t="T848"><vh>stringsAreValidMoreFile</vh></v>
</v>
<v><vh>Reading</vh>
<v><vh>fileInfo class</vh>
<v t="T849"><vh>&lt;&lt; Declare the fileInfo class &gt;&gt;</vh></v>
<v t="T850"><vh>Birth &amp; Death</vh></v>
<v t="T851"><vh>createVnode</vh>
<v t="T852"><vh>&lt;&lt; Create a root vnode &gt;&gt;</vh></v>
</v>
<v t="T853"><vh>finishOutline (alert)</vh>
<v t="T854"><vh>&lt;&lt; Set attributes and icons for all nodes &gt;&gt;</vh></v>
<v t="T855"><vh>&lt;&lt; Create join lists of all vnodes &gt;&gt;</vh></v>
<v t="T856"><vh>&lt;&lt; Set the current node &gt;&gt;</vh></v>
</v>
<v t="T857"><vh>finishPaste (creating join lists could be a problem)</vh>
<v t="T858"><vh>&lt;&lt; Check number of created tnodes &gt;&gt;</vh></v>
<v t="T859"><vh>&lt;&lt; Set attributes and icons for all pasted nodes &gt;&gt;</vh></v>
<v t="T860"><vh>&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;</vh></v>
<v t="T861"><vh>&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;</vh></v>
</v>
<v t="T862"><vh>getT</vh></v>
<v t="T863"><vh>newCloneWindow</vh></v>
<v t="T864"><vh>newTnode (alert)</vh></v>
<v t="T865"><vh>setMaxTnodeIndex</vh></v>
<v t="T866"><vh>setNumberOfTnodes</vh></v>
</v>
<v><vh>get routines</vh>
<v t="T867"><vh>get (basic)</vh></v>
<v t="T868"><vh>getClipboardHeader</vh></v>
<v t="T869"><vh>getCloneWindows</vh></v>
<v t="T870"><vh>getEscapedString (uses large buffer)</vh>
<v t="T871"><vh>&lt;&lt; allocate mTextBuf &gt;&gt;</vh></v>
<v t="T872"><vh>&lt;&lt; increase the size of mTextBuf &gt;&gt;</vh></v>
</v>
<v t="T873"><vh>getFindPanelSettings</vh>
<v t="T874"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="T875"><vh>getGlobals</vh>
<v t="T876"><vh>&lt;&lt; set the window position &gt;&gt;</vh></v>
<v t="T877"><vh>&lt;&lt; set the log window position &gt;&gt;</vh></v>
</v>
<v t="T878"><vh>getLeoFile (reads all @file nodes)</vh></v>
<v t="T879"><vh>getLeoHeader</vh></v>
<v t="T880"><vh>getLeoOutline</vh></v>
<v t="T881"><vh>getPosition</vh></v>
<v t="T882"><vh>getPrefs</vh>
<v t="T883"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt;</vh></v>
<v t="T884"><vh>&lt;&lt; Set the default directory preference &gt;&gt;</vh></v>
<v t="T885"><vh>&lt;&lt; Set the TSyntaxMemo options &gt;&gt;</vh></v>
</v>
<v t="T886"><vh>getSize</vh></v>
<v t="T887"><vh>getTnodes</vh></v>
<v t="T888"><vh>getTnode (alert)</vh></v>
<v t="T889"><vh>getVnodes</vh></v>
<v t="T890"><vh>getVnode</vh>
<v t="T891"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
</v>
<v t="T892"><vh>skipWs</vh></v>
<v t="T893"><vh>skipWsAndNl</vh></v>
</v>
<v t="T894"><vh>open</vh>
<v t="T895"><vh>&lt;&lt; Create the TFileStream and the file buffer &gt;&gt;</vh></v>
<v t="T896"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
<v t="T897"><vh>&lt;&lt; Delete the TFileStream and the file buffer &gt;&gt;</vh></v>
</v>
<v t="T898"><vh>readLine</vh>
<v t="T899"><vh>&lt;&lt; reallocate mLineBuf &gt;&gt;</vh></v>
<v t="T900"><vh>&lt;&lt; fill mFileBuf or set mFileEmptyFlag &gt;&gt;</vh></v>
<v t="T901"><vh>&lt;&lt; return the last line, if any &gt;&gt;</vh></v>
</v>
<v t="T902"><vh>xmlUnescape</vh></v>
</v>
<v><vh>Writing</vh>
<v t="T903"><vh>assignFileIndices</vh></v>
<v t="T904"><vh>compactFileIndices</vh></v>
<v t="T905"><vh>shouldCompactOnSave</vh>
<v t="T906"><vh>&lt;&lt; Compute the number of tnodes used &gt;&gt;</vh></v>
</v>
<v><vh>put routines</vh>
<v t="T907"><vh>put (basic)</vh>
<v t="T908"><vh>&lt;&lt; put s to the mMemoryStream &gt;&gt;</vh></v>
<v t="T909"><vh>&lt;&lt; put s to mFileStream &gt;&gt;</vh></v>
</v>
<v t="T910"><vh>putClipboardHeader</vh>
<v t="T911"><vh>&lt;&lt; count the number of tnodes &gt;&gt;</vh></v>
</v>
<v t="T912"><vh>putCloneWindows</vh>
<v t="T913"><vh>&lt;&lt; put position of clone window &gt;&gt;</vh></v>
</v>
<v t="T914"><vh>putEscapedString</vh></v>
<v t="T915"><vh>putFindSettings</vh></v>
<v t="T916"><vh>putGlobals</vh>
<v t="T917"><vh>&lt;&lt; put the body/outline ratio &gt;&gt;</vh></v>
<v t="T918"><vh>&lt;&lt; put the position of this form &gt;&gt;</vh></v>
<v t="T919"><vh>&lt;&lt; put the position of the log window &gt;&gt;</vh></v>
</v>
<v t="T920"><vh>putHeader</vh>
<v t="T921"><vh>&lt;&lt; count the number of tnodes and clone windows &gt;&gt;</vh></v>
</v>
<v t="T922"><vh>putLeoOutline (writes to clipboard)</vh></v>
<v t="T923"><vh>putPrefs</vh>
<v t="T924"><vh>&lt;&lt; put syntax coloring prefs &gt;&gt;</vh></v>
<v t="T925"><vh>&lt;&lt; put default directory &gt;&gt;</vh></v>
</v>
<v t="T926"><vh>putProlog</vh></v>
<v t="T927"><vh>putPostlog</vh></v>
<v t="T928"><vh>putTnodes</vh></v>
<v t="T929"><vh>put ( tnode * )</vh></v>
<v t="T930"><vh>putVnodes</vh></v>
<v t="T931"><vh>put ( vnode * )</vh>
<v t="T932"><vh>&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;</vh></v>
<v t="T933"><vh>&lt;&lt; Put a vnode tag if this vnode has a clone window &gt;&gt;</vh></v>
<v t="T934"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="T935"><vh>&lt;&lt; write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="T936"><vh>save</vh></v>
<v t="T937"><vh>saveAs</vh></v>
<v t="T938"><vh>saveACopyAs</vh></v>
<v t="T939"><vh>saveOutlineOnlyTo</vh></v>
<v t="T940"><vh>xmlEscape</vh></v>
<v t="T941"><vh>write_LEO_file</vh>
<v t="T942"><vh>&lt;&lt; Open fileName and buffer it &gt;&gt;</vh></v>
<v t="T943"><vh>&lt;&lt; Close the file &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@nocolor

* Leo's main window contains two panes, an outline pane on top and a body pane below.

* The outline pane works like Windows Explorer:   Headlines expand and contract when you click the + or - icon.

* The other icon shows the status of the headline.  See the subheadlines of this headline for details.

* You can change the relative sizes of the panes by dragging the splitter area between the two panes.
</t>
<t tx="T2">This is the body text of this node.  Nodes containing body text are marked with a small blue box in the status icon.</t>
<t tx="T3">You can mark headlines in several ways: with the various Outline:Mark commands, with the Find or Change commands, or with the Untangle command.  The "Go To Next Marked" command will go to the nexted marked node, if any.</t>
<t tx="T4">Cloned nodes share the same body text.  Also, the headlines of all cloned headlines change whenever a change is made to any of them.</t>
<t tx="T5">@nocolor
@ignore</t>
<t tx="T6">A node with @file &lt;filename&gt; in its headline.  @file nodes create derived files using the Leo2 source format.  See the Leo2 documentation for details.</t>
<t tx="T7">The tree whose root is an @file node.  @file trees are also called Leo2 trees.</t>
<t tx="T8">A node containing the @ignore directive.  Orphan and @ignore nodes are not allowed in @file trees: no derived file is written if an @file node contains an @ignore or orphan node.</t>
<t tx="T9">A node containing @others in its body text.

The @others directive is only valid in @file trees.</t>
<t tx="T10">The tree whose root is an @others node.</t>
<t tx="T11">A node with @root in its body text.  @root nodes create derived files using the Leo1 source language, simplified noweb.</t>
<t tx="T12">The tree whose root is an @root node.  @root and @unit trees are also called Leo1 trees.</t>
<t tx="T13">A node containing the @unit directive in its body text.  All section definitions in the @unit tree are examined when tangling any @root node found in the @unit tree.</t>
<t tx="T14">The tree whose root is an @unit node.  @root and @unit trees are also called Leo1 trees.</t>
<t tx="T15">The text in the body pane.  Body text is always assoctiated with a particular headline.</t>
<t tx="T16">A small blue box in the icon just to the left of a headline that indicates that the node contains body text.</t>
<t tx="T17">A node directly contained by a node.</t>
<t tx="T18">A copy of a tree that changes whenever the original changes.  The original and all clones are treated equally:  no special status is given to the "original" node.</t>
<t tx="T19">A small red arrow in the icon just to the left of a headline that indicates that the node is a clone of another node.</t>
<t tx="T20">A named fragment of code that can be incorporated into other code by referring to the chunk name.

Another name for a section.  Chunk is the noweb term.  Section is the CWEB term.</t>
<t tx="T21">A literate programming language invented by Donald Knuth and Silvio Levy.  CWEB produces derived files for the C language.

http://www-cs-faculty.stanford.edu/~knuth/cweb.html</t>
<t tx="T22">The output of the tangling process.  A source code file in some programming language.</t>
<t tx="T23">A keyword, preceded by an '@' sign, that is used to control syntax coloring or the Tangle, Untangle or Weave commands.</t>
<t tx="T24">The child of a child of a node.</t>
<t tx="T25">The organizational unit of an outline.  A node.  Each headline contains headline text and (possibly empty) body text.</t>
<t tx="T26"></t>
<t tx="T27">Leo stands for Literate Editor with Outline.  That is, Leo supports both literate programming and outlining.</t>
<t tx="T28">A tree whose root is an @file node.</t>
<t tx="T29">A tree whose root is an @root or @unit directive.</t>
<t tx="T30">A style of programming that airms at producing the highest quality program listings.  Literate programming languages apply two fundamental operations to text: weaving and tangling.  Leo supports two literate programming languages, CWEB and noweb.

Knuth's book is the best overall introduction to literate programming:
Literate Programming, by D. E. Knuth ISBN 0-937073-80-6.

More information is available at Knuth's web site:
http://www-cs-faculty.stanford.edu/%7Eknuth/lp.html</t>
<t tx="T31">Within an @file tree, a node that contain a section name, like &lt;&lt;x&gt;&gt;, at the start of its headline text.

Within an @file tree, all nodes containing a section reference must have a descendent named node corresponding to the reference.

Within an @root or @unit tree, an @code directive is an abbreviation for &lt;&lt;x&gt;&gt;=, where &lt;&lt; x &gt;&gt; is found in the headline.

</t>
<t tx="T32">A simple literate programming language invented by Norman Ramsey.  noweb can produce derived files for any text-based programming language.

http://www.eecs.harvard.edu/~nr/noweb/</t>
<t tx="T33"></t>
<t tx="T34">The organizational unit of an outline.  A headline.  The combination of headline text and outline text.
</t>
<t tx="T35">The children, grandchildren, etc. of a node.</t>
<t tx="T36">An unnamed node that is either 1) a descendent of a named node or 2) the descendent of no @others node.

Orphan and @ignore nodes are not allowed in @file trees: no derived file is written if an @file node contains an @ignore or orphan node.</t>
<t tx="T37">The node the directly contains a node.</t>
<t tx="T38">A file that can be read by Adobe Acrobat.</t>
<t tx="T39">The first node of the entire outline.  In the PC version of Leo several nodes may be siblings of the root.</t>
<t tx="T40">A named fragment of code that can be incorporated into other code by referring to the chunk name.

Another name for a chunk.  Chunk is the noweb term.  Section is the CWEB term.</t>
<t tx="T41">Nodes with the same parent.  Siblings of the root have no parent.</t>
<t tx="T42">The icon that appears just to the left of headline text in the outline pane.  This icon shows: a blue body text box if the node contains body text, a red clone arrow if the node is cloned, and a red marker bar if the node is marked.  The icon is outlined in black if the node is dirty, that is, if the node has been changed since the file was last change.
</t>
<t tx="T43">The process by which derived files (e.g., .c, .cpp or .h files) are created from parts of an outline denoted by @unit or @root directives.

Tangling replaces all chunk names by the code defined by the chunk, like macro expansion.
</t>
<t tx="T44">Another name for an outline.</t>
<t tx="T45">A node whose headline text does not start with &lt;&lt; name &gt;&gt;.

Unnamed nodes in @file trees must be a descendent of an @others node and must not be the descendent of any named node.

For example, the following tree is invalid:

@others node
  &lt;&lt; name &gt;&gt;
    unnamed node
	
The unnamed node would be an orphan node.</t>
<t tx="T46">Updating an outline based on changes to derived files.  Untangling allows changes to be propagated from derived files back to the outline.  Especially useful when fixing syntax errors outside Leo.
</t>
<t tx="T47">The creation of typeset documentation from a source file containing noweb or CWEB directives.  CWEB defines numerous control codes to control this process.

Weaving creates documentation.  Tangling creates source code files known as derived files.  Leo does not support weaving at this time.  A print (Weave) command is under development.
</t>
<t tx="T48">@nocolor

Please use Leo's SourceForge forums at

	http://sourceforge.net/forum/?group_id=3458

to ask questions or suggest improvements.  That way other people can share in the discussions.</t>
<t tx="T49">@nocolor</t>
<t tx="T50">Leo owes much of its visual design to MORE, possibly the most elegant computer program ever written.  Leo's clone nodes are inspired by MORE.

The following users reported bugs and made suggestions for improving Leo:  Bruce Arnold, Chris Barker, Chris Elliot, Stephen Ferg, Tom Fetherston, Zak Greant, Eric S. Johansson, Klass Holwerda, Garold Johnson, Romain Guy, Robert Low, Joe Orr, Marc-Antoine Parent, Speed Ream, Rich Ries, Wolfram Schwenzer, Gabriel Valiente, Ying-Chao Wang, Dan Wharton, Wim Wijnders.

The following deserve special mention: David Brock wrote TSyntaxMemo and gave permission to distribute its object code.  Zak Greant made many important suggestions.  Eric Brown helped make Leo Open Software.  The late Prof. Bob Fitzwater kept me focused on design.  Eric S. Johansson helped port leo.py to Linux.  James Kerwin improvef the documentation. Prof. Donald Knuth invented literate programming and the CWEB language. Joe Orr created Leo stylesheets for Leo. see http://www.jserv.com/jk_orr/xml/leo.htm  John K. Ousterhout created tcl/Tk.  Marc-Antoine Parent urged me to use XML for Leo's file format and helped improve it.  Norman Ramsey created noweb and gave permission to quote from the noweb web documentation.  Julian Smart created the wxWindows system. Phil Straus has been a great friend and constant support.  Guido van Rossum created Python and Tkinter. Wim Wijnders insisted that I fix a serious bug.  Dave Winer created MORE.  Vadim Zeitlin answered endless questions about wxWindows.

Special thanks to my family.  My brother, Speed Ream, tested Leo and made many useful suggestions.  Rebecca, James and Linda make it all worthwhile.  It was during a conversation with Rebecca that I realized that MORE could be used as a prototype for Leo.  That was a crucial first step.</t>
<t tx="T51">leo.py is Leo2 written in Python and Tk.  It should work on any platform that supports Python and Tk.

Download Python from http://python.org/
Download tcl/Tk from http://tcl.activestate.com/software/tcltk/

Leo is distributed as a single compressed folder.  Simply uncompress this folder and run leo.py.  You can run leo.py by double-clicking leo.py.  You can also run leo.py from a Python interpreter as follows:

	import leo
	leo.run() # runs leo.py, opening a new outline.
	leo.go() # runs leo.py after reloading all modules.
	leo.open(fileName) # runs leo.py, reloads all modules, and opens fileName.

The Icons folder contains two Icons, called LeoApp and LeoDoc, that represent the Leo application and Leo documents respectively.

In Windows, to associate LeoDoc with .leo files, open the Setting:Folder Options:File Type panel, create an entry for .leo files.  Then choose Change Icon and select the LeoDoc icon.  Associate leo.py as the application to open .leo files.

Note for version 0.08 of leo.py:

This distribution was created with Python's distutils package.  This is a "source" distribution.  The Scripts section of LeoPy.leo contains the source for the setup.py script and sdist.bat batch file.  I have not tested `setup.py install`.</t>
<t tx="T52">1. Copy the tree in in Borland Leo.
2. Paste the tree into empty body text of leo.py.
3. Select all the body text and choose Paste from the Edit Menu.
4. Move to the tree view, and choose Paste Node.

Yes, this is clumsy.  I do not as yet know how to read the System clipboard using Tk, so I use the Tk.Text command to read it for me.  Hopefully this unpleasantness will go away soon.</t>
<t tx="T53">leo.py version 0.08                             February 3, 2002

Version 0.08 adds important new features and fixes several bugs.  All users of version 0.07 should upgrade to this version.  This code seems solid, and significant bugs may remain.  Note: this code has been tested only on Windows XP.  Please report any problems with Linux or Macintosh.

This is the first version of Leo to feel as smooth as the Borland v2.5. leo.py is now less buggy than v2.5; the Borland version will soon be upgraded to match leo.py.

Here is a summary of new features.  See the children of this node for full details.

1. The Find and Change commands are fully functional.  These commands support Tk's "advanced regular expressions" when the "pattern match" option is checked.  Tk's regular expressions are documented at:

  http://tcl.activestate.com/man/tcl8.4/TclCmd/regexp.htm

2. The Tangle commands work; leo.py now supports @root trees.  The next release will support the Untangle commands.  Converting the Untangle code to Python is almost complete.

3. Leo now ensures that the currently selected headline is always visible, scrolling the outline pane as needed.

4. Improved Leo's memory management and eliminated several serious bugs.  One bug caused errors while reading @file trees.  Eliminating this is a huge step forward.  This bug exists in the Borland version of Leo and will be fixed soon.

5. Leo now underlines undefined section references.  Added support for hyperlinking, but disabled hyperlinking because it is not very useful without browser navigation buttons.</t>
<t tx="T54">leo.py handles Find and Change commands much more smoothly than does the Borland version of Leo.  Indeed, I plan to rewrite the Borland code to match the code in leo.py.

In general, leo.py handles the Find and Change commands more smoothly than does the Borland version of Leo.  Note: the node that "anchors" wrapped searches is the current node when any change is made to the Find panel.  The anchor is recomputed after a wrapped search fails.

Changed the meaning of a Find panel setting from "batch" to "context".  This will be changed in a future Borland version.  In the meantime, setting the "context" option in leo.py will set the "batch" option in the Borland version.

The "context" option affects only the "Find All" and "Change All" commands.  When this option is in effect, more context information is printed when matches are found.

The "reverse" option affects all Searches and Changes, both those initiated from the Find Panel itself, and those initiated from menu commands.  In particular, F3 will find the previous search if the "reverse" option is in effect.</t>
<t tx="T55">The Tangle command has passed significant tests, and bugs may remain.  Be warned.

leo.py's Tangle command produces output that is slightly different from Leo v2.5. The differences are insignificant; here is the complete list:

1. The header line, i.e., the first comment line of the tangled file: leo.py produces forward slashes in the path name, Leo v2.5 produces back slashes.

2. Leading whitespace: leo.py produces "optimized" leading whitespace.  leo.py removes blanks if they do not affect the visual appearance of whitespace; this depends on the tab width specified in the Preferences Panel.  Leo v2.5 copies leading whitespace exactly.  The leo.py way is preferable; it will produce output acceptable to Python's tabnanny regardless of tab width used while running Python.

3. Trailing blanks lines in body text: leo.py removes all trailing whitespace.  Leo v2.5 does not.  Conceivably, leo.py might have to change to make the Untangle command work properly.  More likely the leo.py way is just better.</t>
<t tx="T56">Underlining "live" links clutters the screen too much, and hyperlinks from section references to section definitions isn't very useful without the standard "back" and "forward" buttons typically found in web browsers.  For these reasons, I have disabled hyperlinking.

To enable hyperlinking, just set:

	self.use_hyperlinks = true
	
in color.__init__ in the @file leoColor.py tree.</t>
<t tx="T57">1. Fixed several bugs involving cloned headlines.  One bug caused cloned headlines not to be updated in synch.  Another bug caused @file trees not to be marked as dirty under certain conditions.

Both bugs could have caused read errors while reading @file trees, so fixing these bugs is a big step forward.  I have experienced no read errors since fixing these bugs.  A huge step forward.  This bug exists in the Borland versions of Leo and should be fixed ASAP.

2. There was a big performance bug lurking in the tree code that became apparent during testing of the Find and Change commands.  Closing a window could take almost a minute if the tree had been redrawn many times.  Old widgets were never deleted until the window was closed.  This may be a problem with tkinter, and the workaround was straightforward.

3. Fixed a bug in the "Save To" command.  After doing a Save To, a following Save command used the Save To file name!  This explains why some saves "didn't take".

4. Fixed a bug in the Save commands.  Cancelling a Save dialog did not work: instead it wrote a file called ".leo".  I am not sure whether this bug occured in previous releases. 

5. All Save commands now always recompute file indices.  This old logic accomplished very little, and introduced needless differences between the various kinds of Save commands.

6. Made file and path name processing more portable.  Removed all calls to os.chdir().

7. Fixed a bug that caused a control-d to delete a character in the body pane when the Move Down command didn't do anything, i.e., when the presently selected node was the bottom node on the screen.</t>
<t tx="T58">1. Used Tk.Text widgets in headlines rather than Tk.Entry widgets.  This allows the Find/Change commands to search headlines.  Control-k no longer deletes text following the cursor in headlines.

2. Improved the performance of screen updates and markedly reduced flicker in the body pane.

3. Found a way to handle keystrokes without knowing the status of the control and alt keys.  The idle event handlers now ignore the actual keystrokes in most cases, and take action solely based on whether the headline or body text has actually changed as the result of those keystrokes.  If not, we can assume that a command has been entered and we do not set the dirty or changed bits.

4. Replaced es_newline global with app().log.es_newline, i.e., frame.es_newline.  This is better than before because each log stream now has its own newline count.

5. Reduced width of the log pane to give more space to the tree pane.

6. The LeoPy folder now contains a dummy file called __init__.py.  This file marks the LeoPy folder as a potential package.

7. Added several new functions to the file leo.py.  These are useful for invoking leo.py from a Python interpreter.  See the section "How to Install &amp; Run Leo" for details.</t>
<t tx="T59">Previous version of leo.py did not release memory when windows close.  This version does.

Memory management is remarkably easy in Python/Tk.  Added __del__ routines and corresponding destroy routines to the frame, vnode and tree classes.  The destroy routines eliminate circular references between objects. The __del__ routines do nothing except print debugging traces; we know that all references to an object have been removed when its __del__ routine is called.

Added app.deleteOnClose ivar to control memory management.  When true, Leo deletes all frame objects when a frame closes.  This is always true at present.

Fixed a memory botch: previously a dummy vnode was allocated for every vnode created while reading files.</t>
<t tx="T60">Starting with this release, you will see trace statements throughout the code.  The trace function is defined in leoUtils.py; trace implements much of the functionality of my Sherlock tracing package.  Traces are more convenient than print statements for two reasons: 1) you don't need explicit trace names and 2) you can disable them without recompiling.

In the following examples, suppose that the call to trace appears in function f.

trace(string) prints string if tracing for f has been enabled.  For example, the following statment prints from s[i] to the end of the line if tracing for f has been enabled.

	j = skip_line(s,i) ; trace(s[i:j])

trace(function) exectutes the function if tracing for f has been enabled.  For example,

	trace(self.f2)

You enable and disable tracing by calling init_trace(args).  Examples:

	init_trace("+*")         # enable all traces
	init_trace("+a","+b")    # enable traces for a and b
	init_trace(("+a","+b"))  # enable traces for a and b
	init_trace("-a")         # disable tracing for a
	traces = init_trace("?") # return the list of enabled traces

If two arguments are supplied to trace, the first argument is the "tracepoint name" and the second argument is the "tracepoint action" as shown in the examples above.  If tracing for the tracepoint name is enabled, the tracepoint action is printed (if it is a string) or exectuted (if it is a function name).

"*" will not match an explicit tracepoint name that starts with a minus sign.  For example,

	trace("-nocolor", self.disable_color)</t>
<t tx="T61">Rewrote the code that computes file names.  This should have two beneficial effects:

Note:  This code has only been tested on Windows XP.

1. The code should be more portable.  I've used os.path.join throughout to concatenate parts of filenames, and this should handle differences involving path separators on different platforms.

2. The code no longer calls os.chdir().  The "current application directory" changes only as the result of completing file open and save dialogs.  In particular, @path, @root and @file do not change the current application directory.

3. Used leo.__file__ to get the directory from which leo.py was loaded.  This seems to be reliable, though it has only been tested on Windows XP.</t>
<t tx="T62">The following features of leo.py will be incorporated into the Borland version 2.6 of Leo:

1. Improve leading whitespace handling in Tangle.

2. Fix clone bugs (rewrite vnode::setDirty).  These bugs can cause errors while reading @file nodes.

3. Improve Find/Change commands. Change "batch" to "context".  This will make the Preferences Panel work identically in both programs.

4. Always recompute file indices and compute file indices.  This will make derived files produced by v2.6 identical to the files produced by leo.py.

5. Make sure all file names end in .leo.</t>
<t tx="T63">I urge anyone using leo.py upgrade to this version.  This is the first version of leo.py that has been thoroughly tested.

See the children of this node details about this release.  Here are the highlights:

1. Fixed many bugs, including a bug that can cause body text to be lost when creating a new headline.

2. The Pytnon window now works. You can now run Python scripts from within leo.py!

3. Added a script to convert Leo files from Leo 1 to Leo 2 format.

4. @nocolor and @color are now inherited properly from ancestor nodes.

5. Added Leo Documention to Help menu.  This command opens LeoDocs.leo.
	
6. Added auto indent to body pane.

For even more details, see the diary entries for January 6-9 in LeoPy.leo.

See the To Do lists in LeoPy.leo for a list of unfinished features.  The primary unfinished features are the Find/Change commands, preferences settings and the Tangle/Untangle commands.</t>
<t tx="T64">This is the first version of leo.py that has been heavily tested.  About 70 percent of my work on leo.py has been done using leo.py itself.   I know of no remaining bugs that can cause data to be lost.</t>
<t tx="T65">I have concentrated on removing all significant irritations encountered while using leo.py.  Far fewer still remain than before.  Among the remaining irritations:

1. Syntax coloring happens at "idle time", that is, after all events have been handled.  This means that characters are initially colored black, then changed to another couple after an obvious delay.  The obvious event-handling code does not work.  Perhaps using a "virtual event" may work.

2. Keystrokes that should initiate commands _also_ get passed to widgets.  I am hoping to find a way around this, and it may take a bit of work.  The two biggest offender:  Control-k while editing a headline deletes from the cursor to the end of the headline (in addition to creating a new node!)  Control-i gets passed to the body pane as a tab.

3. The border around the tree pane gets over-written by headlines.  I'm not sure how to fix this: it is certainly a Tk bug.</t>
<t tx="T66">Fixed a bug that can cause body text to be lost when creating a new node.</t>
<t tx="T67">Choosing Open Python Window brings up IDLE, the standard Python IDE, from which scripts may be run and debugged.

Note: The path to idle.py must exist in sys.paths.  For Python2.1 on windows, this path will typically be \Python21\Tools\idle  If this path does not exist, a message will be sent to the log pane.  The usual way to add a path to sys.paths is to modify the sitecustomize.py file.

Changed names of several vnode and commands methods to make them compatible with the scripting documentation on Leo's web site.   You may now run any script that runs on Borland Leo on leo.py.

When running scripts from leo.py, you may refer to any method or instance variable (attribute) in the code for leo.py.  If you want to run those scripts on Borland Leo you should restrict yourself to the methods documented in the Scripting chapter of Leo's online documentation.</t>
<t tx="T68">To convert a tree from Leo1 format to Leo2 format, choose the root of the tree to be converted, then do the following in the Python window:

	import c2py
	c2py.leo1to2()
	
This script makes numerous changes throughout the tree.  It does not, however, change @root to @file, or insert the needed @others directives.  You must do that by hand.  Fortunately, that is easy.</t>
<t tx="T69">At long last it is possible to open this file, LeoDocs.leo, from the help menu.

This command will work only if LeoDocs.leo is located in the directory in which leo.py exists.</t>
<t tx="T70">The body pane now has auto-indent on at all times.</t>
<t tx="T71">leo.py version 0.06 (alpha)                     December 20, 2001

This version fixes several minor problems that prevented leo.py from running on Linux.  There is no need to upgrade to this version if leo.py works on your system.  This version is neither more nor less stable than version 0.05.  This file, LeoDocs.leo, has also been improved substantially.

There still may be problems running leo.py on Linux.  You may be able to fix those problems yourself after reading this file... I'll be on vacation until about January 8.  I may be able to answer questions on Leo's SourceForge site, and I'll make no code changes until then.

Problems fixed:

1.  Removed call to print_stack() in es() logic.  If there are problems during initialization this logic printed "Null log" and then printed a stack dump.  This dump was more confusing than helpful.

2.  Changed "darkblue" to "DarkBlue".  The standard colors known to Tk are listed at
	http://tcl.activestate.com/man/tcl8.4/TkCmd/colors.htm
	
If you have more problems with unknown colors, please use a color listed above.

3.  Eliminated some accelerators (Linux only).  You may take an exception in createAccelerators() in leoFrame.py if Linux does not support the accelerators defined in one of the following sections:

  &lt;&lt; control key bindings &gt;&gt;
  &lt;&lt; alt key bindings &gt;&gt;
  
Just comment out the relevant entry.  Please let me know which accelerators don't work.  I can add platform-specific code to deal with them.

4.  Added loaddir code to leo.py.  Leo tries to guess where leo.py was loaded from.  If this doesn't work leo may take an exception in leo.py.

As a temporary hack, please set loaddir correctly in the following code at the start of leo.py:

  # loaddir should be the directory that contains leo.py
  if sys.platform=="win32":
    loaddir = "c:\\prog\\LeoPy\\"
  else:
    loaddir = "LeoPy"
	
5. Removed bullet 0x95 characters from this file. They don't show up well on Linux.

6. In leoTree.py, changed the filenames from x.gif to x.GIF.  Linux is more picky about case in filenames than Windows.

Edward K. Ream
December 20, 2001</t>
<t tx="T72">leo.py version 0.05 (alpha)                      December 17, 2001

This version of Leo marks a major milestone in Leo's history.  leo.py is the first functional version of Leo written completely in Python and Tkinter, Python's interface to the tcl/Tk system.

leo.py is quite useable. leo.py should work on any machine with recent Python and tcl/Tk interpreters.  This version of Leo was created using Windows XP, Python 2.1 and tcl/Tk 8.3.

Warning: This version is alpha quality.  Use extreme caution: please save your work often and make full backups of all .leo files and derived files.

Please read this node's children before sending bug reports or feature requests.  Send all bug reports to Leo's SourceForge web site at: http://sourceforge.net/projects/leo/

Edward K. Ream</t>
<t tx="T73">I have been happily using leo.py to develop itself for the last three days without serious problems.  leo.py reads and writes all its source files exactly as does the Borland version.  This is an important test, and significant errors may remain.

Performance on a 1.2 Ghz Pentium is good to excellent.  Drawing the screen happens quickly, smoothly and without flicker.  Expanding and contracting nodes is usually excellent, and slows when a many nodes have been expanded.  Syntax coloring appears instantaneous, even with an unsophisticated algorithm.  Loading LeoPy.leo files takes about 3 seconds. This could be improved by using Python's XML classes.</t>
<t tx="T74">You must have recent versions of Python and tcl/Tk installed on your machine.
Download Python from http://python.org/
Download tcl/Tk from http://tcl.activestate.com/software/tcltk/

After installing Python and Tk, run Leo double clicking the file leo.py in the LeoPy folder.  On Windows this will bring up a Leo window and a black Python interpreter window.

The LeoPy folder contains all files in this distribution.  leo.py is the main source file; run Leo by double clicking leo.py.  The Python interpreter will create corresponding .pyc files as .py files are imported by leo.py.

LeoPy.leo is the master source code file; all .py files were derived from LeoPy.leo.  c2py.py and leoCompare.py are tools that should be run from a Python interpreter.
</t>
<t tx="T75">Functional Commands and Features

    Open, Save, Save As, Save To commands.
    Read @file Nodes command.
    Read Outline Only command.
    Write Outline Only command. Warning: this has not been tested thoroughly.
    Insert Node, Delete Node and Clone commands.
    Move Node Right/Left/Up/Down commands.
    Cut Node, Copy Node, Paste Node commands.
    Syntax coloring for Python only.
    The @color and @nocolor directives, but these are not inherited yet.</t>
<t tx="T76">Unfinished Commands and Features:

	Revert.
	All Tangle and Untangle commands.
	All Import commands.
	All Find and Change commands.
	Sort Children command.
	Toggle Split Direction, Toggle Active Pane and Cascade commands.
	Auto indent in the body pane.
	The Preferences panel is semi-functional: see note one below.
	The Find panel is non-functional.
	The Python scripting window is non-functional.
	Syntax Coloring Options and Font Options windows are not ready yet.
	@color and @nocolor directives are not inherited yet.

Notes:

1. The Preferences panel is partly functional.  The default target language option has no effect: syntax coloring is for Python only.  Tab width can not be changed; tabs are 8 characters wide.

2. Menu items are not yet dynamically dimmed and undimmed.  Some non-functional commands have undimmed menus.  Keyboard accelerators work even for dimmed menus.

3. Scripting Leo is not possible yet.  You can't control Leo from the Python interpreter because control passes to the Tk event loop.

4. Leo's Save commands do not yet save the information about which node was visible at the top of the tree.

5. The Save/SaveAs/SaveTo dialogs don't handle shortcuts to folders properly; they try to replace the shortcut with the .leo file.

6. Initialization code in leo.py computes the directory from which Leo was loaded using argv[0].  I am not sure this is proper, though I have had no problems recently.  Tree icons will not load properly if argv[0] does not specify this directory.  If the path is invalid Leo will print: os.chdir failed: `dir`

7. The tree class does not automatically ensure that the current node is visible after an outline operation.

8. The font used in the body pane is not great.  I hope to improve it.

9. Headline text is sometimes obscured.
</t>
<t tx="T77">leo.py already feels less buggy than the wxWindows versions of Leo.  Rewriting Leo in Python and Tkinter has greatly improved the code. Further improvements are possible.  BTW, work began in earnest on this version of Leo in late October, 2001.  It's been a great month.

The following problems have resisted my initial attempts at solving them.  Any help from Tk experts would be appreciated:

1. Window icons are the Tk icon, not the nifty Leo icon.  Really, there _must_ be a way to do this!

2. Can variable-width tabs can be done in Tk?  If not, Leo may have to convert tabs to blanks as specified by the preferences panel.

3. Cut, copy and paste work in the log and body panes using Control-X, Control-C and Control-V keys.  However, there are no Cut, Copy or Paste menu items in the Edit menu.  Is it possible to send simulated keystrokes to a text widget?

4. Some menu accelerators do not seem to be available in Tk.  In particular, many of the items in the submenus of the Outline menu have no accelerators yet.  These commands are useful only if they can be chosen from the keyboard rather than than the menu.

5. The border of the tree control is gray.  It can be overwritten by large headlines.  This appears to be a Tk or Tkinter bug; I haven't found any way to eliminate the border or color it white.

6. There doesn't seem to be a way to select all the headline text when editing starts.  The click that starts editing always clears the selection.

7. Changing the type of leo.py to .pyw doesn't seem to work.

8. A message flash briefly on the screen when leo.py exits, too fast to read. These messages do not appear when invoking leo.py from the Python interpreter.  They probably would be visible in a Linux window.</t>
<t tx="T78">It will be much easier to make such improvements to leo.py than to previous versions of Leo. Here is my list of new things to do:

1. Create "hyperlinks" from section references to section definitions.  This will happen in the next release.

2. Add automatic "tab nanny" checking and full syntax checking of Python body text.

3. Build a file/directory comparison window using code in leoCompare.py.

4. Build a Python debugger into Leo.  Python provides excellent hooks for debugging and tracing.  Python's stand-alone IDLE debugger doesn't seem to work well with the Tk command loop.

5. Expand Leo's file format to take advantage of the power of Tk text widgets.
</t>
<t tx="T79">This version fixes several serious bugs.  All users of Leo2 should upgrade to version 2.5 immediately.

1. Eliminated the ill-fated automatic updating feature.  This turns out to be very dangerous and disconcerting.  If one makes changes to the .leo file and does not save those changes, a later update could erase those unsaved changes!

2. Removing automatic updating also fixed another bug:  The current outline node was not being selected properly when a .leo file was read, so that in some cases the body text did not correspond to the selected outline node.  This never caused loss of data, and was disconcerting.

3. Fixed a bug that caused Find/Change settings to be saved to a file only if a find or change command was actually executed.

4. Restored several parts of Leo2(cb).leo that were inadvertantly erased due to earlier bugs.  In particular, the outlines for xbuf.c and xbuf.h have now been restored.

One bug remains.  On Windows XP, the cursor is obscured in the Find/Change dialog when it is at the far left of the Find or Change text areas.  This may be a botch in the XP text control itself.  The solution would be to create a border in the text areas, and there is no obvious way to do this using the Borland classes.</t>
<t tx="T80">Version 2.4 is a major improvement in Leo2.  I urge all users of Leo2 to upgrade to this version.  See the children of this node for full details.

The "old" Leo2 tried to save space by not writing all information in @file trees.  This was a serious mistake.  The "new" Leo2 saves all information in an outline to the .leo file, including all inforamtion in @file trees.
Once again you may back up a project merely by backing up the project's .leo file.  There is no Archive command, and no need for one.  All .leo files are now safe archives.

As the result of the change in file formats, Leo 2.4 may clear clone links when loading derived files created with previous versions of Leo.  Leo 2.4 will issue detailed messages when that happens.

The new Leo2 is much safer and more convenient to use than the old Leo2.  Error messages and error recovery have been improved.

Leo2 updates @file trees automatically when Leo2 is activated.  For example, suppose you change a derived file in another editor, say in an IDE.  Leo2 will update the @file tree when you switch to Leo, provided that you have saved the file in the IDE.  Warning: due to several apparent bugs in the Delphi code, this feature only works if the main Leo window is at least partially visible on the screen (!)
</t>
<t tx="T81">Version 2.4 fixes several bugs involving clones.

1. Version 2.4 rewrites clone indices when writing derived filed, so node sentinels accurately reflect the clone status of the node.  The node sentinel for the root node no longer contains the maximum clone index.  Leo2 clears the root's clone index on reading and writing so that the root node is not mistakenly joined so another node!

2. Version 2.4 takes more care to recreate clone links properly when reading derived files.  A derived file can be read into a .leo file different from the .leo that wrote the derived file, so Leo2 makes sure that clone links are proper in the .leo file being opened.  A minor drawback: .leo files now are "big", so reading them is a little slower.

Note: Clone links into @file trees work only if the .leo file is "in synch" with the files derived from the @file trees.  Clone links will break if the .leo file and derived files are not in synch.  Typically "backup" .leo files will be out-of-synch with present derived files, so it's best to use "backup" .leo files only in emergencies, for example to revert a project to a previous state.</t>
<t tx="T82">The "old" Leo2 tried to save space by not writing all information in @file trees.  This was a serious mistake.  The "new" Leo2 saves all information in an outline to the .leo file, including all inforamtion in @file trees.  It is once again possible to back up a project merely by backing up the project's .leo file.</t>
<t tx="T83">The archive command was a backup disaster waiting to happen.  It has been replaced by the following four file commands are located in the File:Read/Write submenu.

Read Outline Only: reads an outline using only the .leo file, not any files derived from @file nodes.  This command is useful for reverting a project to a previously saved state.

Read @file Nodes: updates all @file nodes in an outline.  This ensures that the state of an outline matches all files derived from @file nodes.  Included for completeness.  This happens automatically when a .leo file is first read, and it also happens automatically when Leo2 is reactivated.

Write Outline Only: saves an outline without writing any @file trees.  Useful for inserting an @file node into an outline without modifying a derived file with the same name.

Write @file Nodes: forces an update of all @file trees.  Surprisingly useful.</t>
<t tx="T84">Leo2 updates @file trees automatically when Leo2 is activated.  For example, suppose you change a derived file in another editor, say in an IDE.  Leo2 will update the @file tree when you switch to Leo, provided that you have saved the file in the IDE.

Warning: due to several apparent bugs in the Delphi code, this feature only works if the main Leo window is at least partially visible on the screen (!)</t>
<t tx="T85">Revised for version 2.4

Loading and saving .leo files usually keeps the .leo file and derived files "in synch".  However, if you create backup .leo files, it can easily happen that the structure of @file nodes in the backup .leo files no longer matches that structure in the derive files.  Leo2 will detect this condition the next time you next open the old .leo file.  When that happens, Leo2 discards the entire out-of-synch @file tree, and recreates it solely using the derived file.  In the process all marks and clone links from outside the file are lost. Leo2 issues the messages:

	Error reading @file &lt;filename&gt;
	-- Rereading file.  Clone links into this file will be lost.

to remind you that the .leo file you are using is out-of-date.  Saving the .leo file will bring it up to date.

If one or more sentinel lines in a derived file have been corrupted in some way, by inserting, deleting, altering or moving a sentinel, Leo issues these messages:

	Error reading @file &lt;filename&gt;
	&lt;An error message about a bad sentinel&gt;
	-- Rereading file.  Clone links into this file will be lost.
	&lt;An error message about a bad sentinel&gt; (again)
	----- File may have damaged sentinels!

Data may not actually be lost, and the outline structure will be seriously damaged.  The most sensible thing to do is to restore the derived file from a .leo file using the Read Outline Only command.

No error recovery is attempted when automatically updating @file trees.  If an error is found the update is cancelled (leaving the outline unchanged) and the following message is given:

    -- Update cancelled due to structure errors
	
We don't attempt error recovery because error recovery would clear clone links.  For example, suppose we are editing a .leo file, and for some reason we also edit a derived file _without_ saving the .leo file.  Now the files could be out of synch!  So it is best not to press on with an automatic update.
	</t>
<t tx="T86">Revised for version 2.4

If Leo2 detects orphan or ignored nodes while writing an @file node it saves all information in the @file tree in the outline (.leo) file.  No information is lost.  When the .leo file is read again Leo2 will load the information in the @file tree from the .leo file, not the derived file.

As a reminder, Leo2 marks the erroneous @file node as dirty so that saving the .leo file will attempt to rewrite the @file node.  Version 2.4 no longer marks the @file node as "stuck on dirty".  If you save the .leo file the dirty mark will be cleared.  However, the @file node will be dirty every time the file is read until all errors are corrected.
</t>
<t tx="T87">Leo2 does have drawbacks compared to Leo1.

1.  You can not use section definitions in more than one file.  For example, you can't define declarations in one file to be used in another file.  If you need all the features of noweb you must use Leo1.

2. Leo2 supports no escape conventions whatever.  Leo2 thinks that a line in a code part contains a section reference if &lt;&lt; precedes &gt;&gt; on the line, regardless of whether &lt;&lt; or &gt;&gt; are contained in strings or comments.  In practice, such "false references" occur infrequently, and the workaround is simply to split the offending line.  Moreover, noweb's escape conventions (@&lt;&lt; and @&gt;&gt;) caused significant problems in Leo1, so this "drawback" is very minor.

3. Clone links into @file trees work only if the .leo file is "in synch" with the files derived from the @file trees.  Clone links will break otherwise.

Backup .leo files will usually be out of synch with derived files.  You can restore all data from a backup .leo file using the Read Outline Only command.</t>
<t tx="T88">Note: 10/19/01: I recommend that all users upgrade to version 2.4.  There are some serious problems with version 2.3.

This version of Leo contains some significant improvements.  See the children of this node for details:

1. The new @first directive allows you to place lines at the very start of files derived from @file nodes. For example, @first #!/usr/bin/env python

2. The log window is now part of the Leo window.  Very handy.

3. Fixed several bugs involving the Find command.

4. A new Archive command saves an entire outline (including all @file trees) to a .leo file.  Use this command with caution.  Loading and then saving a .leo file created with the Archive command will revert an entire project to the state it had when the archived .leo file was created.</t>
<t tx="T89">The @first directive allows you to place lines at the very start of files derived from @file nodes. For example, the body text of @file spam.py might be:

@first #! /usr/bin/env python

The body text of @file foo.perl might be:

@first #/usr/bin/perl

@first directives are recognized only at the start of the body text of @file nodes.  No text may preceed @first directives.  More than one @first directive may exist, like this:

@first #! /usr/bin/env python
@first # more comments.</t>
<t tx="T90">The Archive command writes all nodes of an outline to a .leo file, including all parts of @file trees.  All @file trees are marked in such a way that when the archived .leo file is read 1) all @file trees will be restored from the archived outline rather from derived files and 2) all @file trees will be marked dirty so that when the archived .leo file is written all @file nodes will be updated.

Use the Archive command (and the files written by it) with caution: loading and then saving an archived .leo file will back up an entire project to its state when the archive was originally written!</t>
<t tx="T91">Added support for @c in syntax colorers for Python, Pascal, Perl, Java and HTML.</t>
<t tx="T92">Fixed a bug in the Change, Then Find command.  The Change, Then Find command would rescan the newly changed text if the "change text" contained the "find text" preceeded by other text of length greater or equal to the length of the original "find text".

For example, changing "blah" to "const blah" would result in rescanning the newly inserted "blah".  This would cause the "Change All" command to hang.

The old code advanced the search point by the length of the "find text."  The new code advances the insertion point by the length of the "change text".

Fixed the Find/Change panel: some captions were cut off.</t>
<t tx="T93">@file nodes are now marked dirty whenever any change is made in the @file tree, including changes made as the result of changing cloned nodes outside the @file tree.</t>
<t tx="T94">Made the log window part of the Leo window.  Having the log be part of the leo window is very convenient.</t>
<t tx="T95">Leo2 readme file
Borland version 2.2, 9/16/01

This version fixes several bugs in Leo2:

1. Fixed a bug that causes all data in an @file tree to be lost under the following conditions:

A. The @file tree was erroneous, i.e., it contained orphan or ignored nodes.
B. The .leo file containing the erroneous tree was saved twice.

Leo2 now marks an erroneous @file node as "stuck on dirty" until the tree is fixed.  Recall that dirty nodes have icons with a black border rather than a grey border.  Whenever a file Save operation occurs, Leo2 will attempt to write all dirty @file trees, thereby reminding you that errors remain.  However, the .leo file itself is not "stuck on unsaved", so you won't be prompted to save the .leo file endlessly.

While fixing this bug I also improved error and warning messages relating to reading and writing @file nodes.  This should make it clear that a) data in errorneous @file trees is saved to the .leo file and b) data is recovered from the .leo file when reading erroneous @file nodes.

2. Fixed a bug relating to clones that could cause loss of data.  Leo2 now marks all clones dirty when any clone changes, and makes sure to mark @file nodes dirty that contain changed clones.

3.  Changed the code that writes @file trees to end lines with "\r\n" rather than "\n".  I hope this will improve matters, though I have my doubts.  Please report any problems with the new scheme immediately.

4. Added Write @file Nodes command.  The command writes all @file nodes in the selected tree, regardless of whether they have been changed.

5. Made the commands in the Main Leo2 window functional.</t>
<t tx="T96">Version 2.1 is the first public release of Leo2.  This version appears stable, and should be used with caution.

The major feature of Leo2 is that tangling and untangling happen automatically for all code derived from @file nodes.  

Remember to back up all files derived from @file nodes; such files are original source files!  It is no longer possible to back up an entire project by backing up a single .leo file.</t>
<t tx="T97">Version 1.15 allows Leo1 (the original version of Leo) to read Leo2 files.  Leo1 warns when reading Leo2 files; changing @file trees in Leo1 is not recommended.</t>
<t tx="T98">This version corrects a problem with double-clicking Leo icons under Windows Me.  You may now launch Leo by double-click the icon for any .leo file and you may open any .leo file by double-clicking on it.</t>
<t tx="T99">This version of Leo corrects a problem with how whitespace was handled in @silent mode.</t>
<t tx="T100">Barring serious bugs, version 1.12 is likely to be the last Borland/Windows version of Leo for a while.  The wxWindows versions of Leo are usable enough to justify putting all further work into them.

There are several important improvements in version 1.12:

1. Added the Sort command to the Outline menu.  This command sorts all the children of a node into alphabetical order.

2. A major improvement to Tangle.  In @silent mode, Tangle now outputs derived files with "verbatim" whitespace, that is, without any extra blanks, tabs and newlines.  This makes Tangle much more useful for Python, and in other applications.  For example, it is now possible to do the following in Python:

if &lt;&lt;condition1&gt;&gt; &amp;&amp; &lt;&lt;condition2&gt;&gt;:
	print &lt;&lt;list of vars&gt;&gt;

In the derived file, expansions of the sections will be placed on the lines in which the reference appears.  This works in Python as long as the expansions themselves appear on a single logical line.

This "verbatim" expansion only happens in @silent mode, so these kinds of derived files can not be Untangled.

3. Tangle now reports errors more fully and less redundantly.  Errors involving missing or erroneous path names (specified in @root directives, @path directives or the Preferences Panel) are more specific.  These errors are reported only once per Tangle command, and these errors terminate the Tangle command immediately.  This is wise; we don't want to write files to the wrong directory!  Finally, Tangle no longer prints the actual text of a section when giving the "possibly duplicate section definition" error.  This should be helpful: no longer are huge error messages generated.  It should be easy enough to find the relevant section definitions using Leo's find command.</t>
<t tx="T101">This version corrects a problem that can cause the Import CWEB Files command to hang in an endless loop.

This file also contains improved documentation (see the children of this node) in two sections:

1.  Added an explation of the following error message given by the Tangle command: "Multiple parts not allowed for &lt;&lt; section name &gt;&gt;"

2.  Added a warning about using Untangle to update cloned nodes.
(See the last paragraph of the node.)</t>
<t tx="T102">Sections can be defined in several parts in two ways:

1.  Using &lt;&lt; section name &gt;&gt;= in several places with the same section name.

2.  Using several @code directives within the _same_ body text.

As a precaution against mistakenly defining a section in more than one place, it is invalid to use @code in different nodes to define multiple parts for the same section.  In particular, this error may arise when using cloned nodes.

This error may always be eliminated by using &lt;&lt; section name &gt;&gt;= instead of @code.
	
</t>
<t tx="T103">The Untangle, Untangle All and Untangle Marked commands are the reverse of the corresponding Tangle commands.  They update an outline based on changes made to one or more derived files.  These are exceptionally useful commands.

For example, suppose you create a new part of the outline and Tangle it for the first time.  When you compile the resulting derived files for the first time, you are likely to get many syntax errors.  You could fix those errors in the outline and Tangle the outline again, but there is a much easier way:  you fix the errors in the derived files using the compiler's editor, then run the untangle command on the part of the outline that created the derived file.  The Untangle command updates the selected outline to match the changes in the derived files.  It's as simple as that.  By the way, the Untangle command marks all the nodes in the outline that it updates, and you can examine all such nodes with the Go To Next Marked command in the Outline menu.

Untangle never changes the structure of an outline;  it never inserts, deletes or moves nodes.  Don't attempt to change the structure of an outline by modifying derived files; it won't work.  Also, never delete, move or alter the sentinel lines in derived files written by the Tangle command.  Such lines start with /// followed by a section name.

If you change the section name in a sentinel line Untangle will not update the code in the outline (with the old name) that generated the renamed section.  Untangle now warns about about sections that appear in a derived file but not in the outline.  Untangle has no trouble with changed section references in derived files; it is only changed sentinel lines that cause problems.

Cloned nodes that generate code in several files may cause problems for Untangle if not all the code is changed the same way in derived files.  If Untangle is run separately on these derived files, Untangle will update all cloned nodes each time it is run, so only the code in the last Untangle run will take effect.  Therefore, the only reliable way to update text in cloned nodes is to make the change in the .leo file rather than the derived files.</t>
<t tx="T104">Version 1.10 incorporates the following changes:

1. The Untangle command no longer updates @doc chunks under any circumstances.  This makes Untangle safe to use when the "Tangle outputs doc chunks" preferences is not selected.  In previous versions the Untangle command would delete all @doc chunks in the outline when a derived file had been Tangled without "Tangle outputs doc chunks".

The new version of Untangle is experimental; only one line of code has been added.  I welcome any comments about this change.  This change also fixes (or rather bypasses) a crasher reported in Untangle.

2. The shortcut for the Execute Script command has been changed from Alt-E to Shift-Alt-E to avoid conflicting with the shortcut that brings up the edit menu.

</t>
<t tx="T105">Version 1.9 contains several improvements that make Leo more Python-friendly:

1. The Execute Script command (Alt-E) in the Edit menu allows you to execute Python scripts directly from body text.

2. Several small changes make the Python window significantly easier to use.

Also, considerable reference (study-only) code has been removed from leo(CB).leo.</t>
<t tx="T106">It is now possible to execute any Python script directly from any body text.  Just select the script in the body text (including a trailing newline) and use the Execute Script (Alt-E) command from the edit menu.  The script is copied to the Python window and executed as usual.
</t>
<t tx="T107">Several small changes make the Python window significantly easier to use:

1. The paste command now works in the Python window whenever the Python window is visible.  This fixes a bug that required a mouse click in either pane before paste would work.

2. It is now possible to execute scripts multi-line scripts pasted into the input pane.  Other changes make it easier (or possible) to terminate continued code.</t>
<t tx="T108">Fixed a crasher that makes it impossible to tangle outlines containing doc parts in languages like HTML that have no single-line comment delimiter.</t>
<t tx="T109">Leo v 1.7 accepts a slightly more general file format so that it can read XML generated from external XML tools.  Leo v 1.7 can read all previous .leo files.  Leo's Save commands remain unchanged.

Leo still only understands Leo files.  However, Leo now understands a slightly generalized form of Leo files. Specifically:

1.  Attributes may now appear in any order.  (Leo writes attributes in a fixed order, but some XSLT tools rewrite Leo files with attributes in a different order.)

2.  Leo will now accept &lt;tag/&gt; instead of &lt;tag&gt;stuff&lt;/tag&gt; when "stuff" is empty.
</t>
<t tx="T110">This version corrects a small bug: the wrong text is selected when the syntax colorer changes.  This is a cosmetic bug only; the selected text will not be replaced when further typing occurs.

Unless major bugs are found, this will be the last version of Leo for several months.  I want to freeze the code so that I can work on the wxWindows version.</t>
<t tx="T111">This version is a major milestone in Leo's code.  Improvements were made throughout Leo's code in an attempt to correct an extremely hard-to-find bug that can cause data in body panes to be lost.  Only time will tell if the bug has, in fact, finally been eradicated.

This version also corrects a minor bug; icons in a newly cloned tree were not always drawn properly.  Also, the currently selected headline no longer changes if you click on the + or - icons that expand and contract headlines.  This new behavior is a result of simplifying the event handlers; I won't consider changing this behavior until it is clear that the data loss bug has finally been fixed.

Use this version of Leo with caution until the new code has been thoroughly tested.  New asserts will guard against silent data loss and other unexpected events.  I don't expect these asserts to fail, but then one never does...

The following lists the changes that were made the code.  You don't need to read the following details; they are provided only for completeness.

1.  Greatly simplified the event handlers.  This should have been done long ago.

The event handlers now handle _all_ aspects of switching tree nodes and updating data structures when the body pane changes.  In particular, this guarantees that tnodes are "synched" when the body pane changes.  This is a major simplification and a major improvement: it should no longer be possible to lose data once it appears in the body pane.

The reverse is not true: the code must still take care that the body pane is updated if tnodes are changed "by hand."  (This is typically done when new nodes are being created.  Such nodes are never the current node and so are not shown in the body pane.)  I re-checked all code to make sure this constraint is satisfied.

Removed synchVnodes and updateBodyPane methods.  These have always been the most error-prone methods in Leo.  Removing them was made possible because the global constraint that tnodes are up-to-date is now guaranteed by the event handlers.

Created a new updateSyntaxColorer routine, which is called when moving a node or changing its text might affect syntax coloring.  This routine can never affect tnodes.

2.  Removed reference counting from tnodes.  The new code deletes tnodes only during the read process.  After that, tnodes are never deleted.  This could be called a memory leak, but it ensures that tnodes can never be deleted out from under a vnode.  I don't this was ever the problem with losing data, and the new code makes sure that it can't be.

3.  Improved how icons are redrawn.  Event handlers now set the dirty bit when text changes, which simplifies matters.

4.  Added asserts to guard against silent data loss, unexpected calls to event handlers, and mismatches between vnodes and their commanders.

6.  Added the mCommands data member to vnodes.  This member ensures that the correct commander is returned by vnode::commands().  The old code got the commander by looking for the current window.  Conceivably this could have caused the wrong commander to be used in some cases.</t>
<t tx="T112">This version adds the following features:

1. Outline to noweb command.
2. Python scripts for finding and changing text in Leo outlines.
3. A Python method of the vnode class returning the commander corresponding to a vnode.
4. Documentation for Leo's import/export commands.

This may be the last version of Leo for a while; I am about to start work on a cross-platform wxWindows version of Leo.  However, bug reports and requests for new features are always welcome.

Edward K. Ream
September 19, 2000
</t>
<t tx="T113">The "Outline To Noweb" command converts the selected outline to a flat file containing noweb text.  The name of the root section is taken from the @root directive.  &lt;&lt;*&gt;&gt; is used if the @root directive is not followed by any file name.</t>
<t tx="T114">Leo's Python scripting does not support Leo's Find and Replace commands directly because these commands are interactive.  Calling these commands from a Python script would be clumsy.

Instead you can use the new find and change scripts to search and replace text.  These scripts use Python's powerful re module.</t>
<t tx="T115">@color</t>
<t tx="T116">The following scripts show how to find and change in a Leo outline.  The re scripts use the re module; the other scripts use the string.find() and string.rfind().

@language python
@silent
@root "c:\prog\LeoCB\leoProject\leoFind.py"

import leo, string, re

&lt;&lt; leoFind methods &gt;&gt;
</t>
<t tx="T117">&lt;&lt; leoFind methods &gt;&gt;=

def changeAll ( commander, findPat, changePat, bodyFlag = 1 ):
	"""
	changeAll	make changes in an entire Leo outline.
	
	commander	Commands object for a Leo outline window.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	"""
	n = len(changePat)
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, pos = changeNext(v, pos, findPat, changePat, bodyFlag)
		pos = pos + n</t>
<t tx="T118">&lt;&lt; leoFind methods &gt;&gt;=

def changeNext ( v, pos, findPat, changePat, bodyFlag = 1 ):
	"""
	changeNext:	use string.find() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from changeNext,
	changeNext(v,pos+len(findPat),findPat,changePat)
	changes the next matching string.
	"""
	n = len(findPat)
	v, pos = findNext(v, pos, findPat, bodyFlag)
	if v == None:
		return None, 0
	if bodyFlag:
		s = v.bodyString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
		print "setting head string: ", result
	return v, pos</t>
<t tx="T119">&lt;&lt; leoFind methods &gt;&gt;=

def changePrev ( v, pos, findPat, changePat, bodyFlag = 1 ):
	"""
	changePrev:	use string.rfind() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from changePrev,
	changePrev(v,pos-len(findPat),findPat,changePat)
	changes the next matching string.
	"""
	n = len(findPat)
	v, pos = findPrev(v, pos, findPat, bodyFlag)
	if v == None:
		return None, 0
	if bodyFlag:
    	s = v.bodyString()
    	# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
    	v.setBodyStringOrPane(s)
	else:
		s = v.headString()
    	#s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
    	v.setHeadStringOrHeadline(s)
	return v, pos</t>
<t tx="T120">&lt;&lt; leoFind methods &gt;&gt;=

def findAll ( commander, pattern, bodyFlag = 1 ):
	"""
	findAll		search an entire Leo outline for a pattern.
	
	commander	Commands object for a Leo outline window.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a list of tuples (v,pos) showing where matches occured.
	returns [] if no match were found.
	"""
	n = len(pattern)
	result = []
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, pos = findNext(v, pos, pattern, bodyFlag)
		if v != None:
			result.append ( (v, pos) )
		pos = pos + n
	return result</t>
<t tx="T121">&lt;&lt; leoFind methods &gt;&gt;=

def findNext ( v, pos, pattern, bodyFlag = 1 ):
	"""
	findNext:	use string.find() to find a pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a tuple (v,pos) showing where the match occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from findNext,
	findNext(v,pos+len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		pos = string.find ( s, pattern, pos )
		if pos != -1:
			return v, pos
		v = v.threadNext()
		pos = 0
	return None, 0</t>
<t tx="T122">&lt;&lt; leoFind methods &gt;&gt;=

def findPrev ( v, pos, pattern, bodyFlag = 1 ):
	"""
	findPrev:	use string.rfind() to find a pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a tuple (v,pos) showing where the match occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from findPrev,
	findPrev(v,pos-len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		pos = string.rfind ( s, pattern, 0, pos )
		if pos != -1:
			return v, pos
		v  = v.threadBack()
		pos = -1
	return None, 0
</t>
<t tx="T123">&lt;&lt; leoFind methods &gt;&gt;=

def reChangeAll ( commander, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangeAll: make changes in an entire Leo outline using re module.
	
	commander	Commands object for a Leo outline window.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	"""
	n = len(changePat)
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, mo, pos = reChangeNext(
			v, pos, findPat, changePat, bodyFlag, reFlags)
		pos = pos + n</t>
<t tx="T124">&lt;&lt; leoFind methods &gt;&gt;=

def reChangeNext ( v, pos, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangeNext: use re.search() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reChangeNext,
	reChangeNext(v,pos+len(findPat),findPat,changePat,bodyFlag)
	changes the next matching string.
	"""
	n = len(findPat)
	v, mo, pos = reFindNext(v, pos, findPat, bodyFlag, reFlags)
	if v == None:
		return None, None, 0
	if bodyFlag:
		s = v.bodyString()
		print s, findPat, changePat
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
	return v, mo, pos</t>
<t tx="T125">&lt;&lt; leoFind methods &gt;&gt;=

def reChangePrev ( v, pos, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangePrev: use re.search() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reChangePrev,
	reChangePrev(v,pos-len(findPat),findPat,changePat,bodyFlag)
	changes the next matching string.
	"""
	n = len(findPat)
	v, mo, pos = reFindPrev(v, pos, findPat, bodyFlag, reFlags)
	if v == None:
		return None, None, 0
	if bodyFlag:
    	s = v.bodyString()
    	# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
    	v.setBodyStringOrPane(s)
	else:
		s = v.headString()
    	# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
    	v.setHeadStringOrHeadline(s)
	return v, mo, pos</t>
<t tx="T126">&lt;&lt; leoFind methods &gt;&gt;=

def reFindAll ( commander, findPat, bodyFlag, reFlags = None ):
	"""
	reFindAll	search an entire Leo outline using re module.
	
	commander	Commands object for a Leo outline window.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		flags argument to re.search().
	
	returns a list of tuples (v,pos) showing where matches occured.
	returns [] if no match were found.
	"""
	n = len(findPat)
	result = []
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, mo, pos = reFindNext(v, pos, findPat, bodyFlag, reFlags)
		if v != None:
			result.append ( (v,mo,pos) )
		pos = pos + n
	return result
		</t>
<t tx="T127">&lt;&lt; leoFind methods &gt;&gt;=

def reFindNext ( v, pos, pattern, bodyFlag, reFlags = None ):
	"""
	reFindNext:	use re.search() to find pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		the flags argument to re.search()
	
	returns a tuple (v,mo,pos) showing where the match occured.
	returns (None,None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reFindNext,
	reFindNext(v,pos+len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		if reFlags == None:
			mo = re.search ( pattern, s[pos:] )
		else:
			mo = re.search ( pattern, s[pos:], reFlags )
		if mo != None:
			return v, mo, pos + mo.start()
		v = v.threadNext()
		pos = 0
	return None, None, 0</t>
<t tx="T128">&lt;&lt; leoFind methods &gt;&gt;=

def reFindPrev ( v, pos, pattern, bodyFlag, reFlags = None ):
	"""
	reFindPrev:	use re.search() to find pattern in a Leo outline.

	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		the flags argument to re.search()
	
	returns a tuple (v,mo,pos) showing where the match occured.
	returns (None,None,0) if no further match in the outline was found.
	
	Note 1: Searches vnodes in reverse (v.threadBack) direction.
	Searches text of vnodes in _forward_ direction.
	
	Note 2: if (v,pos) is a tuple returned previously from reFindPrev,
	reFindPrev(v,pos-len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		# Forward search through text...
		if reFlags == None:
			mo = re.search ( pattern, s[pos:] )
		else:
			mo = re.search ( pattern, s[pos:], reFlags )
		if mo != None:
			return v, mo, pos+mo.start()
		# Reverse search through vnodes.
		v = v.threadBack()
		pos = 0
	return None, None, 0</t>
<t tx="T129">&lt;&lt; leoFind methods &gt;&gt;=

def lineAtPos ( s, pos ):
	"""
	lineAtPos: return the line of a string containing the given index.
	s		a string
	pos		an index into s
	"""
	# find the start of the line containing the match
	if len(s) &lt; 1:
		return ""
	if pos &gt; len(s):
		pos = len(s)-1
		
    while pos &gt; 0:
        if s[pos] == '\n':
        	pos = pos + 1
        	break
        else:
        	pos = pos - 1
	# return the line containing the match
    s = s[pos:]
    list = string.split(s,"\n")
	return list[0]</t>
<t tx="T130">&lt;&lt; leoFind methods &gt;&gt;=

def printFindList( findList, bodyFlag = 1 ):
	"""
	printFindList:	Print matching lines from the list.
	
	findList:		a list of (v,pos) tuples returned from findAll().
	Only the line containing the match is printed.
	Lines are printed once for each match found on the line.
	"""
    for v,pos in findList:
		if v != None:
			if bodyFlag:
    			s = v.bodyString()
			else:
				s = v.headString()
			print lineAtPos(s, pos)</t>
<t tx="T131">The commands() method has been added to the Python vnode class.

c=v.commands()

This method returns the commander for the window containing v.  This method can be used to avoid passing commanders as arguments to vnode methods.  For example, given just v, we can call either of the following:

	v.commands().synchNode()
	v.commands().Repaint()</t>
<t tx="T132">This version corrects a problem with the Save As command;  it worked only once!  That is, after the Save As command was executed the window's title would change, but a later Save command would change the file specified before the Save As command was executed.</t>
<t tx="T133">This version of Leo introduces Python scripting.  This is a major new addition to Leo.  See the new Chapter 7 of this documentation.  Python support still has rough edges; the next release will be cleaner.  Any suggestions for improvements to Leo's support for Python would be appreciated.

Alt-V now toggles the "View All Characters" option.  This is especially useful when editing Python code.

Besides Python support, a number of minor bug fixes have been made:

Added syntax coloring for try and catch to the C parsers.

Control-K, I now indents blocks of text uniformly, regardless of the language being syntax colored, and regardless of @nocolor and @color directives.  Similarly, Control-K, U now undents blocks of text.  The old keys, control-[ and control-] only worked when the current language was C and syntax coloring was enabled.

Removed the menu items that had the enter key as a shortcut.  The only way to create a new node now is with Control-I.  Using the enter key for a shortcut is not a good idea: it causes problems throughout the code.

Fixed a bug in forgiving compare.  The code that was calling compare_comments wasn't handling mismatched whitespace properly.

Got the Import command for Python working.  I found a bug in Tangle: in @silent mode we must always output a newline in the place of the function name.  Otherwise the Python indentation will be wrong.

The Untangle is now disabled when in @silent mode.  Nothing good can happen in that case!

Fixed a minor problem with the @path directive:  ff a _new_ file has not been saved we issue a warning, not an error if no path has been specified.  We can't really test the @root command for a path because the @root command may be found much later.  Fortunately, this warning will happen very rarely.  It's important, however, to warn that the file may be written to the standard directory if no path is specified in the @root command.  Otherwise, Leo's behavior would be quite confusing.</t>
<t tx="T134">This version corrects an oversight in the Flatten Outline command.  In order to recreate the outline structure it is not enough to know whether each node has children; you must also know how many children each node has.

The new version of the Flatten Outline command represents the outline the same way the Export MORE Text does:  a child headline is indented one tab more than its parent headline.</t>
<t tx="T135">The Tangle commands now examine all nodes, including cloned nodes that have previously been visited.  Previously, such nodes were skipped during tangling.  The new logic allows clones to represent code common to more than one unit. You can always insert an @ignore directive in an ancestor of a cloned node to prevent the node from being processed during tangling.
</t>
<t tx="T136">Version 0.19 fixes some bugs and and eliminates some problematic features of Leo.  Also, the role of CWEB mode has been documented more thoroughly.

The PC version of PC is feature complete.  I will release version 1.0 after people have played with this version for a while.

As always, I'll be happy to fix bugs or add urgently needed features.
</t>
<t tx="T137">Fixed a bug that could result in Tangle outputting derived files in the wrong directory.

Tangle and Untangle now set the current directory using @path directive if it exists, otherwise the directory specified in the Preferences panel if it exists, otherwise the directory set by the Load or Save commands if it exists.  (The Save As and Save To never alter this directory.) Finally, a check to see if the @root directive specifies a full path.  If so, the current directory is not changed.

If none of these directories exists an error is raised so that no Tangling or Untangling is done.  This error can only occur if Tangling or Untangling a file that has just been created by the New command and never saved with the Save command.</t>
<t tx="T138">Added the @language html, @language perl and @language perlpod directives, and added HTML, Perl and Perl + POD items in the Preferences panel.

The HTML script is rudimentary at present.  Suggestions for improvement are welcome.</t>
<t tx="T139">The @cweb and @noweb commands are no longer functional.  The new @language cweb directive replaces @cweb, and the other @langauge directives effectively replace @noweb.  There is an new CWEB option in the Preference panel.
</t>
<t tx="T140">Please read the following carefully if you plan to use CWEB in Leo.

CWEB mode refers to how Leo tangles an outline when @language cweb is in effect or the CWEB option in the Preferences panel is in effect.  CWEB mode is a somewhat strange combination of CWEB syntax and the noweb way of tangling.

Syntax: In CWEB mode the Tangle and Untangle commands recognize all CWEB control codes (2-character codes starting with @), like @&lt; and @&gt;.  In particular, the CWEB escape sequence @@ is recognized anywhere on a line, not just at the start of the line as in noweb.

Tangling: Leo tangles code in CWEB mode just as it does everywhere else, by expanding the sections referenced in an @root node.  This is the noweb way of tangling, _not_ the CWEB way of tangling.  Indeed, Knuth's CWEB tangles a web by copying all macro defintions indicated by @d, then by expanding all "unnamed modules", that is, code delimited by @c.

There are no plans to support the "official" CWEB way of tangling.  That would mean completely rewriting both Tangle and Untangle, a huge undertaking.

In practice, the difference between the noweb and CWEB ways of tangling are minor, and it is always possible to simulate the CWEB way of tangling as follows:

1. At present, Tangle treats @c like @code when in CWEB mode.  This is wrong.  For the moment, I recommend changing @c to @&lt; c @&gt;= throughout your CWEB sources and adding a reference to @&lt; c @&gt; in all roots of CWEB files.

Leo might handle @c in CWEB mode in two ways:  @c could delimit a special kind of section, and a hidden reference to that section would be inserted at the end of each @root node.  The other way would be more explicit:  we would change all @c codes to @&lt; c @&gt;= as discussed above.  In that case, the Import CWEB files should make those changes automatically.

2.  The Import CWEB Files command doesn't do anything special with @d control codes.  You must convert @d constructs to C macros, an easy task in practice.

3.  The "offical" CWEB tangle operation copies @d constructs to the start of the derived file.  You can simulate this by creating a new section for all macro definitions and placing a reference to that section at the start of your root node.  This will ensure that all the macro definitions are visible throughout the file.</t>
<t tx="T141">Leo now parses the @language directive as you type, so if you change the language specified by the @language directive you will see the effect immediately.

There is no longer a limit of 6 languages that can be syntax colored. Let me know if you would like Leo to support another langauge.</t>
<t tx="T142">The Print command is now much more flexible and convenient: it will print any node and all its descendents, whether or not the node contains @unit, @root or @ignore directives.  
</t>
<t tx="T143">Modified massage_block_comment so that it converts the first of a series of newlines to a blank and deletes the rest; Untangle no longer mangles modified @doc sections.

A more complete solution would be for Tangle to insert a flag for inserted newlines ( say backslash newline) so that Untangle could know which newlines to remove.  I'd like to wait until all Tangle/Untangle code is converted to C++ before doing a more thorough job.
</t>
<t tx="T144">Leo no longer supports clone _windows_.  Cloned outlines, however, will remain with Leo forever.  

Clone windows were never very useful and were buggy.  Eliminating clone windows has made it possible to handle events more smoothly and powerfully.</t>
<t tx="T145">The Extended Noweb Syntax option in the Preferences panel is gone.  This option has always been deprecated.</t>
<t tx="T146">Version 0.18 changes the file format in an upward compatible way.  That is, version 0.18 can read all previous versions of Leo files, but you must have version 0.18 of Leo to read files written by version 0.18.</t>
<t tx="T147">Fixed a bug that caused @doc section not to be output properly for those langauges like Fortran and Perl that do not have block comments.</t>
<t tx="T148">The @noheader directive supresses the header line normal written by Tangle at the start of each derived file.  The @noheader directive is especially useful in Perl.  Also added the corresponding "Tangle outputs header line" checkbox in the preferences panel.  This checkbox sets the default which may be over-ridden by the @header or @noheader directives.</t>
<t tx="T149">@language fortran specifies that comments start with C.
@langauge fortran90 specifies that comments start with !.</t>
<t tx="T150">@language perlpod specifies the Perl language with block comments being delimited by =pod and =cut</t>
<t tx="T151">Version 0.17 fixes some bugs and puts some finishing touches on Leo.  In particular, the @cweb and @noweb allow CWEB and noweb programs to exist in the same outline.

The Borland C++ Builder version of Leo is now feature complete; there are no further items on the to-do list.  Yes, I'll be happy to fix bugs or add urgently needed features.
</t>
<t tx="T152">Tangle and Untangle now treat &lt;&lt;*&gt;&gt;= as a synonym for @root filename if the _headline_ starts with text of the form @root filename.  This convention allows full compatibility with noweb.
</t>
<t tx="T153">The @cweb, @noweb, @path, @tabwidth and @pagewidth directives are new.

These directives allow the user to override the defaults specified in the Prefs panel on a file-by-file basis.   For the first time, every option in the Preferences panel may be overridden by a directive.

The @cweb and @noweb allow, for the first time, CWEB and noweb programs to exist in the same outline.</t>
<t tx="T154">I fixed several severe bugs involving CWEB mode.  It is now possible to tangle and untangle files when in CWEB mode, though CWEB mode has still not been tested thoroughly.</t>
<t tx="T155">Reduced the default size of Leo windows so that they can be more easily resized on a small screen.</t>
<t tx="T156">Version 0.16 is a significant new release of Leo.  All users of the PC version of Leo should upgrade to version 0.16.

Significant chagnes have been made to Tangle and Untangle:  these commands should now be able to handle code in almost any language.  The new @language directive specifies the comment and string conventions used when Tangling and Untangling; the older @comment directive is now offically deprecated.

The @verbose, @terse and @silent directives are new:  they control how Tangle outputs comments.

The Import Files command now handles Pascal, Python and Java files in addition to C and C++ files.

Besides the major changes a number of bug fixes and other minor features have been added.

Acknowledgements:  Thanks to Zak Greant for numerous suggestions and bug fixes, and to Garold Johnson for improving this file.</t>
<t tx="T157">Version 0.16 fixes all bugs mentioned on the SourceForge site as of April 27, 2000.  These bugs involved problems with

@comment &lt;empty&gt;
@comment 2 delims
Not inheriting @comment properly
non-delimited filenames in @root directives
Crashes while Tangling
Problems with Untangle with languages other than C.

Later sections discuss some of these in more detail.</t>
<t tx="T158">Version 0.16 fixes a crasher related to changing windows.

This _may_ have been the source of crashes when cutting and pasting outlines, but don't count on it!  Make sure you back up files _before_ cutting and pasting outlines!</t>
<t tx="T159">The @language directive is new.  The @language directive actually specifies the comment delimiters and string types used by the Tangle and Untangle.

The form of this directive is

@language x

where x is one of the following: c,c++,html,java,objective-c,pascal,perl,python and shell.  Shell files have comments that start with #.  Case is ignored in the language specifiers, but not in the @language itself.  Thus, the following are equivalent:

@language html
@language HTML
@language hTmL

but the following is invalid:

@LANGUAGE html

The @comment directive is now officially deprecated: you should use the @language directive whenever possible.  At present Untangle will not process an @root or @unit node if an @comment directive is in effect.  Why?  Because Untangle can't be sure of properly parsing a derived file if the language of the derived file isn't known.  It might be possible to assume some defaults in this case, but that is not done at present and is not a high priority.</t>
<t tx="T160">Scanning for @directives is now much faster.  As a result, the @language and @comment directives will be recognized anywhere in an outline.  This means

1) child nodes will "inherit" @language or @comment directives from ancestors unless over-ridden in the child node and

2) @language and @comment directives need not be placed in @unit or @root nodes.  This is a much more intuitive and powerful way of handling these directives.</t>
<t tx="T161">Key parts of the untangle logic have been generalized so that they can handle essentially any computer language. The following routines no longer have any C-specific code and have essentially been completely rewritten:

scan_derived_file (formerly scan_c_file)
forgiving_compare (formely c_compare)

Tangle now will properly output comments using the present comment delimiters as specified by either the @language directive or the @comment directive.  As mentioned before, you should use @language instead of @comment wherever possible.</t>
<t tx="T162">As a side effect of the Untangle command, Leo now removes trailing blank lines from the body text of all nodes being untangled.  This finally crushes a long-standing bug.  If the body text ends with one or more blank lines, the altered body text contains exactly one trailing newline.

Nodes that are altered in this way are not marked, nor is the file-changed mark set.  This seems to be the most appropriate action to take:  it would be confusing to prompt the user to save a changed file if the only changes involve trailing whitespace.</t>
<t tx="T163">The @verbose, @terse and @silent directives determine how Tangle outputs comments.  When @verbose is in effect Tangle outputs all comments.  When @terse is in effect, Tangle outputs only those comments necessary for Untangle to work.  When @silent is in effect Tangle no additional comments.  Note: comments written by the user in code sections are always output: these directives control only:

1.  The comments containing doc chunks and
2.  Sentinel comments that delimit the beginning and end of code chunks.

@verbose is the default.  If more than one of these directives appear in the same body text the "most verbose" of these options will be in effect.</t>
<t tx="T164">At long last Leo has a useful notion of default directory.  By default, the default directory is the directory containing the .leo file.  This may be over-ridden using the "Tangle Default Directory" option in the Preferences panel.

The default directory is used whenever a file name in an @root directive contains no path component.
</t>
<t tx="T165">The Import Files command looks at the file extention to see how it should handle files.

Extension	Language
.c			C
.cpp		C++
.java		Java
.pas		Pascal
.py			Python

If the extension is not one of the above the Import files commands merely puts the entire file into the body text of a single node.

The Import Files command probably needs quite a bit of work.</t>
<t tx="T166">Control-T now changes the pane that is currently active.  If the outline pane was active, the body pane becomes active, and vice versa.  This command makes it possible to switch between panes without using the mouse.</t>
<t tx="T167">In previous versions of leo.leo I used slash instead of backslash as path delimiters.  This should never have worked, but somehow it did.  The present code uses the correct backslash in all @root directives.</t>
<t tx="T168">Many improvements were made to the code.  See the diary section of leo.leo if you are interested.  In particular, I created args.h and args.c to define arguments.  This cleans up the code quite a bit.</t>
<t tx="T169">Changed Tangle and Untangle so that empty section names like &lt;&lt; &gt;&gt; and &lt;&lt; &gt;&gt;= are treated as ordinary characters.  No warning is issued, which is debatable.</t>
<t tx="T170">As mentioned in the main documentation, you must not change sentinel lines in derived files in any way.  In particular, if you change the section name in a sentinel line Untangle will not update the code in the outline (with the old name) that generated the renamed section.  Untangle now warns about about sections that appear in a derived file but not in the outline.  Untangle has no trouble with changed section references in derived files; it is only changed sentinel lines that cause problems.
</t>
<t tx="T171">Leo is being used to develop HTML files for web sites.  In this context it is natural to define sections that are shared between files.  Don't expect Untangle to update such sections if you make changes to them in derived files.  The natural place to change sections shared by several roots is in the outline, not in the files derived from the outline.

If you do change code in a derived file that appears in several derived files, and try to use Untangle to update the code in the outline one of two things will happen:

1) You untangle an @root node.  Untangle will never compare examine the common section of code for changes, as the common section appear under a @unit node, not the @root node. Untangle will complain about an orphan node.
 
2) You untangle an @unit node.  Untangle will examine each @root node under the @unit node.  Unless the change is made in the last root examined, Untangle will propagate the change when it first sees it, then go right ahead and undo the change when it sees the next expansion of the node in a derived file.
 
Untangle tests for inconsistent expansions of a section only within a single derived file.  Such tests are not done between different derived files because we do not want disallow sections with the same names in different roots.</t>
<t tx="T172">This Appendix lists all known bugs and limitations in Leo.

1.  The location of the find/change command's search isn't reset when the cursor is moved in body text.  This is a "state change" problem:  sometimes we want to set the location of the start of the search and sometimes we don't.  This problem will be fixed soon.

2. Untangle has no way of updating a section(chunk) whose name has been changed in the derived file.  Because of the @unit directive, there is not even a way to issue a meaningful warning.

3. At present, Tangle treats @c like @code when in CWEB mode.  This is wrong, and probably will never be fixed.  I recommend changing @c to @&lt; c @&gt;= throughout your CWEB sources and adding a reference to @&lt; c @&gt; in all roots of CWEB files.

4. Not all syntax coloring options are saved to the file.  This will be fixed soon.
</t>
<t tx="T173">@nocolor

This outline contains the latest documentation available for Leo.

Chapter one lists Leo's many features and benefits.  Chapter two tells how to install Leo.  Chapter three tells how to use Leo's outline pane.  This will be familiar material to most computer users.

Chapters 4 through 6 contain the heart of the documentation.  Chapter 4 discusses Leo's directives.  Directives control how Leo works, especially how Leo generates output files.  Chapter 5 discusses Leo's commands.  These commands manipulate Leo's outline and data and load and save files.  Chapter 6 tells how to control via Python-language scripts.

Chapter 7 discusses the relationship of Leo to so-called "literate programming."  The Appendices contain technical details not found anywhere else.
</t>
<t tx="T174">@nocolor

The following was written by Joe Orr, a user of Leo.  For more details, see http://www.jserv.com/jk_orr/xml/leo.htm

Leo is a powerful tool for organizing text into tree structures, and for just generally attacking a number of problems from a tree-based perspective. 

&lt;opinion&gt;
There has been a lot of hype about XML and all the uses to which it can be put. But, to my mind, the greatest benefit of XML is that it allows people to easily work with tree structures. All the benefits of XML really flow from that. Leo is the best application I've seen for conceiving and planning the trees that are then put into action via varioius XML technologies.
&lt;/opinion&gt;

Outlining Editors have existed for a while (e.g. PC-Outline, MORE) but Leo takes a major leap beyond previous tools for three reasons:

You can embed a simple macro language inside of a Leo document to instruct Leo to assemble pieces of the Leo document into another file. This facilitates, among other things, one type of Literate Programming.

Leo saves its files in XML format. This means that you can easily import and export Leo documents to any number of programs that can understand XML. for example, you can use an XSLT stylesheet to export a Leo file to HTML. And you can import any XML file into Leo using another XSLT stylesheet.

Leo is fully scriptable via Python.</t>
<t tx="T175">@nocolor</t>
<t tx="T176">Leo Users Manual								December 19, 2001

Leo organizes programs using outlines.  Leo can generate programs in any text-based programming langauge, including C, C++, Java, Pascal, Fortran, Cobol, Perl, Python, Icon and Smalltalk.  Leo can also generate HTML files and make, shell and batch files.

Leo was designed and build by:

Edward K. Ream
email:  edream@tds.net
phone or fax: (608) 231-0766
</t>
<t tx="T177">COPYRIGHT

All parts of Leo are distributed under the following copyright.  This is intended to be the same as the Python license, namely that Leo is absolutely free, even for commercial use, including resale.  There is no GNU-like "copyleft" restriction.  This license is compatible with the GPL, sez RMS.

Copyright © 1997-2002 by Edward K. Ream.  All Rights Reserved.

Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the names of Edward K. Ream or Leo not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission from Edward K. Ream. 

DISCLAIMER OF WARRANTIES

EDWARD K. REAM (REAM) SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESSED OR IMPLIED, WITH RESPECT TO THIS COMPUTER SOFTWARE, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS RO A PARTICULAR PURPOSE.  IN NO EVENT SHALL REAM BE LIABLE FOR ANY LOSS OF PROFIT OR ANY COMMERCIAL DAMAGE, INCLUDING BUT NOT LIMITED TO SPECIAL, INCIDENTAL, CONSEQUENTIAL OR OTHER DAMAGES.</t>
<t tx="T178">Leo creates a significantly better way of programming by making clear the relationships between parts of programs.  The larger the program, the more valuable Leo becomes.  I would never willing program without Leo again.

Leo has hundreds of users.  They use Leo to create programs in all kinds of languages, from assembly language, C and C++ to Java, Python and Tk.  People also use Leo to build and maintain web sites and to manage large amounts of other data.

Leo's users have made significant contributions; they have extended Leo in directions I never imagined. See the Acknowledgments below.

Inventing and building Leo, and completely re-visioning Leo to create Leo2 has been the happiest and most creative part of my professional life.  Leo grew out of my attempts to understand and use Donald Knuth's CWEB system of "literate programming".  Chapter 7 discusses how Leo extends and improves literate programming. An Appendix contains a history of Leo and a detailed account of how I invented Leo2.

Future directions involve using Leo to enhance the capabilities of class browsers, debuggers and integrated development environments.  Leo may become the "ultimate" Python development environment.

Edward K. Ream
Madison Wisconsin
December, 2001</t>
<t tx="T179">To those without whom Leo could not have existed:

Dave and Peter Winer, and Doug Baron, Brad Pettit, Robert Ulrich and Steve Zellers, the designers of MORE 3.0.  Donald Knuth and Norman Ramsey, the creators of CWEB and noweb.  Guido van Rossum, the creator of Python.  Julian Smart, the creator of wxWindows.</t>
<t tx="T180">@nocolor

Leo is a programming tool.  Leo shows computer programs more clearly ever before and provides powerful operations not available elsewhere.

Leo is versatile.  You can use Leo with any text-based programming language: from assembly language, C, C++ and Fortran, to Icon, Java, Pascal, Perl, Python and Smalltalk.  Leo can generate HTML and make, shell or batch files.  People use Leo to create and maintain web sites and to handle large data sets.

Leo is useful throughout a programs life: from design through coding, debugging, testing and maintanance.</t>
<t tx="T181">We programmers contantly face difficult problems.  Leo helps solve all these problems.

Problem: We must manipulate hundreds of pages of code, spread over dozens of files.
Solution: Leo shows huge amounts of data in a compact format.

Problem: We must understand how the parts of our programs relate to each other.
Solution: Leo shows such relationships explictly and more clearly than others tools.

Problem: We must understand the big picture.
Solution: Leo hides details until needed and emphasizes important relationships.

Problem: We must gather code related to specific tasks, and explain to others how we solved those tasks.
Solution: Leo programmers can create multiple views of a program.  Task views can gather all information related a task, including code, design documents and maintanance logs.  Code can be gathered into tasks views from many different files.

Problem: We must explain our program to others, and to ourselves.
Solution: Leo reduces the need for documentation because Leo shows programs so clearly.
When copious documentation is needed, Leo provides unobtrusive places for it so that the overall view of the program remains clear.
</t>
<t tx="T182">Leo using folding (expanding and contracting headlines) in a completely new way.  Class browsers and other tools do provide folding, with many limitations.

1. Most browsers do not let the user arrange the tree as the user sees fit.  The user is not allowed to add "organizing nodes" or indeed any new kind of node.  The user is not allowed to move nodes around or reorganize the outline in any way.

2. Most browsers remember neither the selected node, nor the top visible node, nor the expansion state of nodes, and so do not restore the tree as it was when the user last examined it.

3. Most programming tools do not understand the structure implied by "folding" and have no operations that act on tree nodes as true objects.  For example, most editors do not allow a search to be limited to a particular part of a tree.

4. There is no way for the programming language to use the tree structure.  It is not possible, for example, to name a part of the tree and to reference that tree by name.

These limitations are severe.  Leo removes them all:

1. Leo allows you to arrange your program in the way that is most efficient and makes most sense to you.  Leo allows you to create multiple views of your program within a single outline.

2. Leo remembers what you were doing and expands outlines as they were.  You don't waste time finding where you left off.

3. Leo treats parts of an outline as true objects, not just collections of text.  Leo outline operations are much more powerful than those offered by browsers or text editors.  Most of Leo's operations understand outline structure, and can be customized to work only on parts of an outline.  Leo provides Python scripting that can deal with any part of an outline as a unit.

4. Leo provides a simple way of breaking parts of text into smaller pieces called chunks.  Chunks have names and program text can refer to chunks by name as needed.  Chunks decompose text.  Outlines organize program text, including chunks, into larger units.

Leo creates output files (usually program files) from outlines.  These output files contain special comments called sentinel that indicate the outline structure.  What makes Leo significant is this: a source file with embedded sentinels is simultaneously a source file and an outline.  Compilers and text editors will view the file as text.  Leo treats the file as an extremely capable outline.</t>
<t tx="T183">Leo's main window contains two panes, an outline pane and a body pane .

* The outline pane shows a tree of headlines that expand and contract as in Windows Explorer.  Headlines emphasize the overall structure of the program.

* The body pane contains the program text of the selected headline.  Body panes contain details, which are mostly hidden.  Only the body text of the presently selected headline is visible.
</t>
<t tx="T184">					Competitive advantages of Leo

Feature									  Class		 Text
									Leo  Browsers  Editors
Can join program units?				x
Can split code into chunks?			x
Can insert organization headlines?	x
Can reorganize outline?				x
Organizes any code?					x
Shows hierarchy directly?			x		x
Works with any language?			x		??
Commands use hierarchy?				x
Multiple views of a program?		x
Simplifies repetitive finds?		x
Unified project management?			x		??
Handles graphics?					x				   ??
Syntax coloring?					x		x			x

?? means rarely or possibly.</t>
<t tx="T185">@nocolor

This chapter tells how to install Leo.</t>
<t tx="T186">@nocolor

Quick start

This is the minimum you need to use Leo effectively.

1. Write body text using the noweb languages. See Using noweb, CWEB and Directives.

2. Create source files (derived files) using the Tangle command. Only @root directives under the currently selected headline are tangled by the Tangle command. Warning: The Tangle command will overwrite files specified in @root directives if they exist.

3. Use the Untangle command to propagate changes made to derived files back into the outline Untangle is useful only for making small syntactic changes. Don't attempt to change the structure of an outline by modifying derived files; it won't work.

4. Many command key abbreviations are specified in the Syntax Coloring panel.

See the Appendices for a concise summary of information about Leo.</t>
<t tx="T187">@nocolor

This chapter tells how to use Leo's outline pane.  It introduces terminology and discusses creating, moving, marking, cloning headlines.

This chapter also discusses the control keys that can be used in the body pane.  This material is excerpted from documentation at http://tcl.activestate.com/man/tcl8.4/TkCmd/text.htm</t>
<t tx="T188">Leo's body text has the following features:

Clicking mouse button 1 positions the insertion cursor just before the character underneath the mouse cursor, sets the input focus to this widget, and clears any selection in the widget. Dragging with mouse button 1 strokes out a selection between the insertion cursor and the character under the mouse. 

Double-clicking with mouse button 1 selects the word under the mouse and positions the insertion cursor at the beginning of the word. Dragging after a double click will stroke out a selection consisting of whole words. 

The ends of the selection can be adjusted by dragging with mouse button 1 while the Shift key is down; this will adjust the end of the selection that was nearest to the mouse cursor when button 1 was pressed. 

Clicking mouse button 1 with the Control key down will reposition the insertion cursor without affecting the selection. 

If any normal printing characters are typed, they are inserted at the point of the insertion cursor. 

The view in the body pane can be adjusted by dragging with mouse button 2. If mouse button 2 is clicked without moving the mouse, the selection is copied into the text at the position of the mouse cursor. The Insert key also inserts the selection, but at the position of the insertion cursor. 

If the mouse is dragged out of the body pane while button 1 is pressed, the entry will automatically scroll to make more text visible (if there is more text off-screen on the side where the mouse left the window). 

The Left and Right (arrow) keys move the insertion cursor one character to the left or right; they also clear any selection in the text. If Left or Right is typed with the Shift key down, then the insertion cursor moves and the selection is extended to include the new character. Control-Left and Control-Right move the insertion cursor by words, and Control-Shift-Left and Control-Shift-Right move the insertion cursor by words and also extend the selection. Control-b and Control-f behave the same as Left and Right, respectively. Meta-b and Meta-f behave the same as Control-Left and Control-Right, respectively. 

The Up and Down (arrow) keys move the insertion cursor one line up or down and clear any selection in the text. If Up or Right is typed with the Shift key down, then the insertion cursor moves and the selection is extended to include the new character. Control-Up and Control-Down move the insertion cursor by paragraphs (groups of lines separated by blank lines), and Control-Shift-Up and Control-Shift-Down move the insertion cursor by paragraphs and also extend the selection. Control-p and Control-n behave the same as Up and Down, respectively. 

The Next(Page Down) and Prior(Page Up) keys move the insertion cursor forward or backwards by one screenful and clear any selection in the text. If the Shift key is held down while Next or Prior is typed, then the selection is extended to include the new character. Control-v moves the view down one screenful without moving the insertion cursor or adjusting the selection. 

Home and Control-a move the insertion cursor to the beginning of its line and clear any selection in the widget. Shift-Home moves the insertion cursor to the beginning of the line and also extends the selection to that point. 

End and Control-e move the insertion cursor to the end of the line and clear any selection in the widget. Shift-End moves the cursor to the end of the line and extends the selection to that point. 

Control-Home and Meta-&lt; move the insertion cursor to the beginning of the text and clear any selection in the widget. Control-Shift-Home moves the insertion cursor to the beginning of the text and also extends the selection to that point. 

Control-End and Meta-&gt; move the insertion cursor to the end of the text and clear any selection in the widget. Control-Shift-End moves the cursor to the end of the text and extends the selection to that point. 

The Select key and Control-Space set the selection anchor to the position of the insertion cursor. They don't affect the current selection. Shift-Select and Control-Shift-Space adjust the selection to the current position of the insertion cursor, selecting from the anchor to the insertion cursor if there was not any selection previously. 

Control-/ selects the entire contents of the widget. 

Control-\ clears any selection in the widget. 

The F16 key (labelled Copy on many Sun workstations) or Meta-w copies the selection in the widget to the clipboard, if there is a selection. This action is carried out by the command tk_textCopy. 

The F20 key (labelled Cut on many Sun workstations) or Control-w copies the selection in the widget to the clipboard and deletes the selection. This action is carried out by the command tk_textCut. If there is no selection in the widget then these keys have no effect. 

The F18 key (labelled Paste on many Sun workstations) or Control-y inserts the contents of the clipboard at the position of the insertion cursor. This action is carried out by the command tk_textPaste. 

The Delete key deletes the selection, if there is one in the widget. If there is no selection, it deletes the character to the right of the insertion cursor. 

Backspace and Control-h delete the selection, if there is one in the widget. If there is no selection, they delete the character to the left of the insertion cursor. 

Meta-d deletes the word to the right of the insertion cursor. 

Control-k deletes from the insertion cursor to the end of its line; if the insertion cursor is already at the end of a line, then Control-k deletes the newline character. 

Meta-backspace and Meta-Delete delete the word to the left of the insertion cursor. 

Control-x deletes whatever is selected in the text widget. 

The following do _not_ work as in the default Tk.Text widget.

1. Triple clicking is not supported.

2. Control-d moves an outline down.  It does _not_ delete the character to the right of the insertion cursor.

3. Control-o opens a new file.  Id does _not_ "open" the line by inserting a newline character in front of the insertion cursor without moving the insertion cursor.

4. Control-t toggles the active pane.  It does _not_ reverse the order of the two characters to the right of the insertion cursor.</t>
<t tx="T189">The Insert Node command inserts a new headline into the outline.  The return key inserts a new headline into the outline if the outline pane is the active pane.  Otherwise, the return key inserts a newline into the body pane.

You can delete a headline and all its children with the Delete Node command.
</t>
<t tx="T190">You can expand or contract a headline by clicking in the standard Windows Tree View icon to the left of the status icon.

Expanding a node shows its immediate children; contracting a node hides all its children.  The Expand All Subheads command expands all of a nodes offspring (children, grandchildren, etc.)</t>
<t tx="T191">There are a number of ways to move and reorganize headlines.

The Move Up, Move Down, Move Left and Move Right commands move the currently selected outline.  The Promote command makes all the children of a headline siblings of the headline.  The Demote command makes all the siblings of a headline children of the headline.

You can cut and paste any part of a tree.  If a headline contains selected text, the cut, copy, clear or paste operation affects only the selected text. Otherwise, the cut, copy, clear or paste operations acts on the node and all nodes contained by it.  For example, you can move a headline by cutting it, selecting another location in the outline and pasting the headline in the new location.

Warning:  In practice, it is almost always wiser to move clones rather than cutting or pasting them.  Cutting and pasting outlines preserves clones, but the links between clones only exist within the part of the outline that was pasted.  Therefore, if you are cutting and pasting an outline containing clones it is best to cut and paste the _entire_ outline.  Alternatively, you can paste part of an outline, then delete all clones.  
</t>
<t tx="T192">You can mark headlines in several ways: with the various Outline:Mark commands, with the Find or Change commands, or with the Untangle command.  The "Go To Next Marked" command will go to the nexted marked node, if any.

The Mark command will unmark the selected headline if it is already marked.</t>
<t tx="T193">A cloned node is a copy of a node that changes when the original changes. Changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes.  Clones are marked by a small arrow  by their leader characters.

There is no real distinction between the "original" node and any of its clones.  This makes it possible to update any of the clones and the original node will change as well.  When the second-to-last cloned node is deleted the last cloned node becomes a regular node again.

Clones are useful for making alternate views of a program.  For example, when I begin to fix a bug I clone all the sections of the code that relate to the bug, and place those cloned sections under a new headline whose name is the name of the bug I am fixing.

The children of this headline show some complex clones.  To see how clones work, try moving the node marked f around with the nodes marked a fully expanded.  Not all moves are allowed:  you can't move a cloned node so it would become a child of another clone of itself.</t>
<t tx="T194">This is a kind of bizarre outline that I use to test clone operations.  Try moving the nodes a through g around and see what happens to the children of the various clones.</t>
<t tx="T195"></t>
<t tx="T196"></t>
<t tx="T197"></t>
<t tx="T198"></t>
<t tx="T199"></t>
<t tx="T200"></t>
<t tx="T201"></t>
<t tx="T202">You can change the relative sizes of the outline and body panes by dragging the splitter bar.  The Equal Sized Panes command resizes the panes so that each fills half of the main window.</t>
<t tx="T203">The outline pane supports one level of undo.

The body pane supports unlimited undo.  However, you can not undo an operation affecting body text after selecting a new headline.  You can undo or redo the last operation involving the outline itself.  You can not undo operations affecting headline text.</t>
<t tx="T204">@nocolor

This chapter discusses everything you need to know to write programs with Leo.  It discusses the noweb and CWEB programming languages, Leo commands and Leo directives.

The Tangle command translates noweb code into derived files, the actual source files of your program.  The Untangle command updates an outline based on changes to derived files made externally to Leo.  Leo directives are found in body text;  they control syntax coloring, printing, or the Tangle command.</t>
<t tx="T205">Directives control how Leo works.  Directives specify syntax coloring options, the format of derived files and where to put derived files.  Directives start with an @ sign in colunmn one, followed by a keyword.

There are three major groups of directives.  The first group are valid only in @root or @unit trees.  Such directives are also known as Leo1 directives.  The second group of directives are valid only in @file trees.  Such directives are also known as Leo2 directives.  A third group of directives are valid anywhere.

@file trees are a bit less flexible than @root or @unit trees.  However, @file trees are substantially easier to use: I recommend using @file trees whenever possible.</t>
<t tx="T206">Section names provide a way of referencing pieces of code.  Section names may appear in @file trees, @root trees and @unit trees, though they are used a bit differently in Leo1 and Leo2 trees.

Section names are any sequence of characters enclosed in &lt;&lt; and &gt;&gt;.  For example:

	&lt;&lt; Enter the symbol into the table &gt;&gt;

You may use @&lt; and @&gt; instead of &lt;&lt; and &gt;&gt; when CWEB is selected as the Default Source Language in the Preferences panel.  This form of section names is valid only in @root and @unit trees.  For example:

	@&lt; Enter the symbol into the table @&gt;

Leo completely ignores whitespace and case inside section names, so the following section names are equivalent:

&lt;&lt; goto done if x &lt; y &gt;&gt;
&lt;&lt;GOTO done if x  &lt;  y&gt;&gt;
&lt;&lt;gotodoneifx&lt;y&gt;&gt;

Section names may not contain newlines.
</t>
<t tx="T207">An @file node is a node with @file &lt;filename&gt; in its headline.  The @file node forms the root of a Leo2 tree.  When a .leo file is saved, Leo creates a derived file from each @file tree.

@file trees should be written as follows:

1. @file trees contain no "section definition lines".  There are no &lt;&lt;name&gt;&gt;= lines.
2. Body text starts in code mode rather than doc mode.
3. If a node contains &lt;&lt;x&gt;&gt; in its body text, then its tree must contain a node with &lt;&lt;x&gt;&gt; in its headline.  Nodes with &lt;&lt;x&gt;&gt; in its headline are called named nodes.  All other nodes are called unnamed nodes.
4. The @others directive means: put the expansion of all unnamed nodes where the @others appears.  Nodes containing @others directives are called @others nodes.  The @others directive is valid only in Leo2 trees.
5. You can organize @file trees freely.  Unnamed nodes without body text do not affect the meaning of @file trees in any way.

In short:

Rule 1. Section references place the body text of  named  nodes in the derived file.
Rule 2. @others directives place the body text of unnamed nodes in the derived file.

That's almost all there is to it.  A few more details:

Use @space (@ followed by a space, tab or newline) instead of @doc to start a doc part.  Use @c instead of @code to end a doc part.  If the doc part is empty you need neither @space nor @c.

An @file tree may have more than one @others directive, but no node may contain at more than one @others directive.  Each @others directive collects only those nodes found in its subtree.

Unnamed nodes must be a descendent of an @others node, and unnamed nodes must not be a descendent of a named node.  Otherwise, the unnamed node is called an orphan nodes and its body text is placed nowhere in the derived file.  The @ignore directive is not allowed in an @file tree.

In short:

@space and @c are optional.
Multiple @others directives are allowed in separate nodes.
Orphan and @ignore nodes are not allowed in @file trees.

The Appendix contains exact rules for how @others works.</t>
<t tx="T208">An @root node is a node with @root directive in its body text.  An @root directive has the form @file &lt;filename&gt;  Similarly, an @unit node is a node with and @unit directive in its body text.

@root nodes and @unit nodes form the roots of @root and @unit trees.  Such trees are also know as Leo1 trees.  @root trees and @unit tree create a derived files as discussed in the following sections.</t>
<t tx="T209">noweb and CWEB are computer languages that may appear only in @root or @unit trees.  The @cweb and @noweb directives specify whether the source code is noweb or CWEB code.  These directives override the default specified in the Preferences panel.  The @noweb and @cweb directives also affect syntax coloring.

CWEB is similar to noweb, but is designed only for C and C++ programs.  Unless otherwise noted, all remarks about noweb also apply to CWEB.  Full details about CWEB can be found at: http://www-cs-faculty.stanford.edu/~knuth/cweb.html

noweb and CWEB organize a program into a series of named _sections_ (also known as _chunks_).  noweb can produce derived file in any text-based programming language.  Sections may be defined in any order, and a single section many defined in several places.  Sections provide a convenient place for lengthy comments that would otherwise disrupt the visual appearance of code.  Section names help create self-documenting code.

The following sections describe noweb in detail.  The last section describes CWEB as implemented in Leo.
</t>
<t tx="T210">The following reference material is taken from the noweb man page.  This man page is a clear and concise introduction to all of the noweb syntax.

This man page is used by permission of the author, Norman Ramsey. Professor Ramsey's email address is:  nr@eecs.harvard.edu. The noweb home page is at
	http://www.eecs.harvard.edu/~nr/noweb/

-- Start of Man Page --

Noweb is a literate-programming tool like Knuth's WEB, only simpler.  A noweb file contains program source code interleaved with documentation.

Body text is is a sequence of chunks, which may appear in any order. A chunk may contain code or documentation.  Documentation chunks begin with a line that starts with an at sign (@) followed by a space or newline. They have no names.  Code chunks begin with

&lt;&lt;chunk name&gt;&gt;=

on a line by itself. The double left angle bracket (&lt;&lt;) must be in the first column. Chunks are terminated by the beginning of another chunk, or by end of file.  If the first line in the file does not mark the beginning of a chunk, it is assumed to be the first line of a documentation chunk.

Documentation chunks contain text that is ignored by the Tangle command and copied verbatim to standard output by the Print(Weave) command (except for quoted code). 

Code chunks contain program source code and references to other code chunks. Several code chunks may have the same name; the Tangle command concatenates their definitions to produce a single chunk. Code chunk definitions are like macro definitions; notangle extracts a program by expanding one chunk (by default, the chunk named &lt;&lt;*&gt;&gt;).  The definition of that chunk contains references to other chunks, which are themselves expanded, and so on.

The output of the Tangle command is readable; it preserves the indentation of expanded chunks with respect to the chunks in which they appear.

If double left and right angle brackets are not paired, they are treated as literal &lt;&lt; and &gt;&gt;. Users can force any such brackets, even paired brackets, to be treated as literal by using a preceding at sign (e.g. @&lt;&lt;).

Some programming or formatting languages may require a single @ sign in the first column.  Noweb users may achieve this effect by putting a doubled @@ in the first column; in this position only, it stands for a single @ sign.

Any line beginning with `@ ' terminates a code chunk, but if the line has the form

@ %def identifiers

it is taken to mean that the preceding chunk defines the identifiers listed in identifiers.  This list contains identifiers separated by whitespace; any sequence of non-white characters may be an identifier.

Note:  Only the @code and @doc directives terminate chunks.  Other Leo directives are ignored as far as defining chunks is concerned.

--- End of Man Page ---

The following sections discuss noweb in more detail.</t>
<t tx="T211">Escape conventions apply only in @root and @unit trees.  No escape conventions are used in @file trees.

&lt;&lt; and &gt;&gt; delimit section names only if they are paired on the same line.  Lone &lt;&lt; or &gt;&gt; symbols have no special meaning.  You can force &lt;&lt; and &gt;&gt; not to delimit section names by preceding them with the @ character.  For example:

	if ( ( a @&lt;&lt; 5) != 0 &amp;&amp; ( b @&gt;&gt; 5) != 0 ) {
		&lt;&lt; do something &gt;&gt;
	}

This escape convention can be used to help the syntax colorer.

There is one more complication.  You should not use @&lt;&lt; or @&gt;&gt; either within strings or in block comments (in C, comments delimited by /* or */.  The reason is that the Tangle command converts @&lt;&lt; to /*@*/&lt;&lt; and @&gt;&gt; to /*@*/ for the use of the Untangle command.  Note, however, that is valid to use @&lt;&lt; or @&gt;&gt; in doc chunks or in single-line comments (in C, comments that start with //.

What happens if you need to use @&lt;&lt; or @&gt;&gt; in a string or a comment.  You can compose strings out of various parts, like this "@"+"&lt;&lt;".  In comments, the best way is to separate the @ from the &lt;&lt; signs with curly brackets, like @{&lt;&lt;} or {@}&lt;&lt;.</t>
<t tx="T212">In @root or @unit trees, all body text is noweb or CWEB text.  The body text of each node should contain section definitions. A section definition consists of zero or more documentation parts and code parts.  A documentation part is always associated with the next code part.

The code part of a section definitions starts with a definition line consisting of a section name followed by =, like this:

	@
	This code enters the symbol s into the current symbol table.
	&lt;&lt; Enter the symbol in the table &gt;&gt;=

The @ sign must appear in column one on a line by itself.
The section name must be start in the first column of the line and there should be no space between the &gt;&gt; and the =.

Body text that precedes the first definition line becomes the documentation part of the first section.  Body text is ignored if it contains no definition line and no directives.  The @doc directive can be used to explicitly delimit the documentation part of a section definition.

Definition lines must start at the beginning of a line (except possibly for leading white space).  The code part of the definition begins at the following line and continues until
1) the end of the body text containing the definition, or
2) the start of another section definition, or
3) a lone @ sign or an @code or @doc directive.

The code part of a section is just C code, with one significant difference: it may contain section references.  References are simply section names.  For example the following code contains three references.

	if (&lt;&lt;condition&gt;&gt;) {
		&lt;&lt;do this&gt;&gt;
	}
	else {
		&lt;&lt;do that&gt;&gt;
	}

Here is a complete example of how a function might be defined:

	@
	This function enters name into t if it does not already exits.
	
	&lt;&lt; functions of the symbol table class &gt;&gt;=
	
	bucket* create_symbol_table_entry (char *name, symbol_table *t)
	{
		unsigned long hash = 0;
		bucket *the_bucket = NULL;
		&lt;&lt; compute the hash of name &gt;&gt;
		if ( &lt;&lt; no bucket for name exists in t &gt;&gt; ) {
			&lt;&lt; create a new bucket for name &gt;&gt;
			&lt;&lt; link the bucket into table [hash] &gt;&gt;
		}
		return bucket;
	}

A section reference is an abbreviation for the entire definition of the referenced section.  When the actual output file is created, the entire text of the definition replaces each reference.  This textual substitution is usually exactly what is wanted.  In particular, it means that the referenced text has access to the variables of the calling context.  For example, the section called &lt;&lt; compute the hash of name &gt;&gt; can access the "name" and "hash" variables directly, without needing to pass parameters.

Decomposing a program into sections is a flexible and enjoyable process, for several reasons.  First, section names can be much more descriptive than function names.  Second, it is a bit easier to define a section than a function because you doesn't need to declare a section and you can use a section before it is defined.  Third, sections can represent any text, not just executable code.  For instance, one could decompose a complex data structure like this:

	struct node {
		&lt;&lt; node fields relating to files &gt;&gt;
		&lt;&lt; node fields relating to the screen &gt;&gt;
		&lt;&lt; temporary node fields &gt;&gt;
	};
</t>
<t tx="T213">Defining sections is not enough: we must create output files, also called _derived files_.

The @root directive indicates which sections constitute an output file.  The text following a @root directive forms the entire content of the file, that is, after section references are  expanded.  An outline can contain arbitrarily many @root directives: Leo's Tangle commands will create one output file for each.  The process of creating derived files is called "tangling" because the code from the outline is rearrange to create the derived files.

For example, the following @root section shows a typical way of specifying a header file xx.h.

	@root "xx.h"
	#ifndef xx_defined
	#define xx_defined
		&lt;&lt; declarations of public constants of the xx class &gt;&gt;
		&lt;&lt; declarations of public types of the xx class &gt;&gt;
		&lt;&lt; declarations of public variables of the xx class &gt;&gt;
		&lt;&lt; public prototypes of the xx class &gt;&gt;
	#endif

The Tangle commands will create the file xx.h from this body text by expanding all the section references.  Incidentally, the introductory documentation will be included in the header file: any text preceding the @root directive is treated just like the documentation part of an section definition.

Here is a typical way of specifying the corresponding xx.c file:

	@root "xx"
	&lt;&lt; public variables of the xx class &gt;&gt;
	&lt;&lt; private types of the xx class &gt;&gt;
	&lt;&lt; private variables of the xx class &gt;&gt;
	&lt;&lt; private function prototypes of the xx class &gt;&gt;
	&lt;&lt; functions of the xx class &gt;&gt;

There are three menu commands that tangle an outline: Tangle, Tangle All and Tangle Marked.  These commands are identical except for how much of the outline is tangled.   The Tangle command tangles only the selected portion of the outline, the Tangle All command tangles the entire outline, and the Tangle Marked command tangles only marked headlines.

The @root directive has three forms.  All three forms mean exactly the same thing.

	@root filename
	@root "filename"
	@root &lt;filename&gt;

The Tangle commands format derived files so they are easy to read.  The .c file in the Examples folder shows how derived files are formatted by the Tangle commands.

There is one complication that we haven't discussed yet: the scope of section definitions.  The scope of a definition is the tree in which the definition is known.

By default, Tangle commands look for section definitions only in the suboutline of the @root node being tangled.  That is, all sections are assumed to be defined either in the body text of the headline, say h, containing the @root directive, or in the body texts of the descendants of h.

The @unit directive explicitly indicates the scope of section definitions.  When a Tangle command encounters the @unit directive it treats the suboutline containing the @unit command as the scope for all enclosed roots.   This ensures that the group of roots in the subtree use the same section definitions.

For example, suppose we have a tree organized as follows:

	@unit
		@root A
			sections in A
		@root B
			sections in B

The @unit directive insures that:
1) only sections defined in the unit can affect files A and B and
2) all sections definitions in A and B are compatible with each other.  

Finally, Tangle commands ignore any tree containing an @ignore directive.  This ensures that trees that contain cloned nodes or other subsidiary information do not cause the tangle commands to issue spurious error messages.  It also ensures that a tree can never contribute a section definition to another part of the outline by mistake.
</t>
<t tx="T214">By default headline text does not contribute at all to section definitions.  This is usually just what is wanted; one can separate the organizational text in headlines from the source code in body text.  However, there is a useful exception to the rule.  If the text of a headline starts with a section name, then the @code directive is an abbreviation for a definition line containing that section name.

For example, consider the following headline:
	&lt;&lt; functions of class x &gt;&gt;

Within the body text of this node, an @code directive is equivalent to:
	&lt;&lt; functions of class x &gt;&gt;=

Text following the section name is ignored.</t>
<t tx="T215">As mentioned earlier, sections can be defined in more than one place.  Consider the following code:

	struct node {
		&lt;&lt; fields of node &gt;&gt;
	};

It would be natural to define &lt;&lt; fields of node &gt;&gt; as follows:	

	comments about field one.
	&lt;&lt; fields of node &gt;&gt;=
	type1 field1;

	comments about field two.
	&lt;&lt; fields of node &gt;&gt;=
	type2 field2;

and so on.

When a section is defined in more than one place, the definition of the section consists of the concatenation all the code and documentation parts in the order they appear in the body text.  If the parts span more than one node, then the order used is outline order.  Outline order is the order the nodes would appear on the screen if all nodes were expanded.

In the example above, the meaning of struct node is independent of the order in which fields are declared.  It is bad programming style to have the meaning of a section depend on the order in which the parts of its definition appear.  In particular, a section comprising executable code should always be defined in a single piece in one place.</t>
<t tx="T216">The meaning of a section is almost always indpendent of its position in the outline.  (It's possible to create position-dependent sections, but it's bad style.)

Therefore you can almost always place sections wherever you want, and an outline provides the idea mechanism for organizing complex material.  I use the following rule of thumb to organize my outlines:

	Place the definition of a section S in a child
	of the node containing the reference to S.

If a section is referenced in more than one node, I usually place its definition in a node containing all the nodes that refer to it.  Using this rule of thumb creates an outline whose structure mirrors the intrinsic organization of a program.
</t>
<t tx="T217">The @verbose, @terse and @silent directives determine how Tangle outputs doc parts.  When @verbose is in effect Tangle outputs all comments.  When @terse is in effect, Tangle outputs only those comments necessary for Untangle to work.  When @silent is in effect Tangle no additional comments.  Note that Leoc always outputs comments in code sections. 

@verbose is the default.  If more than one of these directives appear in the same body text the "most verbose" of these options will be in effect.</t>
<t tx="T218">If no path is specified in an @root or @file directive, Leo writes the derived file to the directory specified by the "Tangle Default Directory" option in the Preferences panel.  If the Preferences panel also does not specify a directory, Leo writes the derived file is written to the directory from which the .leo file was loaded.  If no .leo has been loaded, Leo issues an error.</t>
<t tx="T219">The @language directive specifies the comment delimiters and string types used by the Tangle and Untangle commands. The @language directive also affects how Leo writes @file trees.  The @language directive over-rides the default specified in the Preferences panel.

The form of this directive is

	@language x

where x is one of the following: c,c++,html,java,objective-c,pascal,perl,python and shell.  Shell files have comments that start with #.  Case is ignored in the language specifiers, but not in the @language itself.  Thus, the following are equivalent:

	@language html
	@language HTML
	@language hTmL

but the following is invalid:

	@LANGUAGE html

The @comment directive is now officially deprecated: you should use the @language directive whenever possible.  Untangle will not process an @root or @unit node if an @comment directive is in effect; Untangle can't be sure of properly parsing a derived file if the language of the derived file isn't known.
</t>
<t tx="T220">The @page, @pagewidth and @tabwidth directives allow preferences to be set on a file-by-file basis: they override the corresponding defaults in the Preferences panel.

The form of the @page directive is @page filename, where filename is taken to be everything following @page to the end of the line.

The form of the @pagewidth directive is @pagewidth n, where n is a positive integer that indicates the width of tangled pages in columns.  This setting only affects how Tangle outputs block comments.

The form of the @tabwidth directive is @tabwidth n, where n is a positive integer that indicates the width of tabs in spaces.  This is used by Tangle to output leading whitespace.
</t>
<t tx="T221">Syntax coloring is on by default in all body text.  Leo formats comments and documentation parts in red, directives and C keywords in blue, strings and character constants in gray and all other text in code parts in black.

The @nocolor directive disables syntax coloring for the body text in which it appears.  No syntax coloring is done until an @color directive re-enables syntax coloring.

If a node contains neither the @color nor the @nocolor directive it may inherit the syntax coloring attribute from an ancestor.  The nearest ancestor that contains exactly one of the @color or @nocolor directives will control the syntax coloring.  Ambiguous nodes, that is, nodes containing both the @color and @nocolor directives, never affect the coloring of their offspring.  

Note:  the @color and @nocolor directives do not affect the Tangle commands in any way.  In particular, the Tangle commands will recognize section definitions as usual even after an @nocolor directive is seen.</t>
<t tx="T222">@nocolor

This chapter is discusses all of Leo's menu commands.  It is organized by menu, and by function within each menu.

A note about typography:  in this chapter command names and menu names will be capitalized, just as they would be in a menu.  This convention allows us to write, for example, the Save A Copy As command, rather than having to use distracting quotation marks, like the "Save A Copy As" command.</t>
<t tx="T223">The New command creates a new Leo main window.  The Open command opens an existing Leo file and shows it in a main window.  The Close command closes the topmost Leo window, and gives you an opportunity to save your work if you haven't yet done so.

The Save, Save As and Save A Copy As commands save the topmost Leo window to a file.  The Save As and Save A Copy As commands create a complete copy of a Leo file.  The Save command updates the file without rewriting those parts that have not been changed.  As a result, the Save command is significantly faster than the Save As and Save A Copy As commands.

The Revert command reloads a file, discarding any changes made to the file since it was last saved.

The following four file commands are located in the File:Read/Write submenu.

Read Outline Only: reads an outline using only the .leo file, not any files derived from @file nodes.  This command is useful for reverting a project to a previously saved state.

Read @file Nodes: updates all @file nodes in an outline.  This ensures that the state of an outline matches all files derived from @file nodes.  Included for completeness.  This happens automatically when a .leo file is first read, and it also happens automatically when Leo2 is reactivated.

Write Outline Only: saves an outline without writing any @file trees.  Useful for inserting an @file node into an outline without modifying a derived file with the same name.

Write @file Nodes: forces an update of all @file trees.  Surprisingly useful.</t>
<t tx="T224">The Print (Weave) command typesets and prints all roots in the presently selected headline.  This command formats the source code according to the directives contained in the body text of the roots of the selected headline.  

The Print command is under development.  The .pdf file in the Examples folder shows the output produced by the Macintosh version of the Print command.  
</t>
<t tx="T225">The Tangle, Tangle All and Tangle Marked commands create derived files from portions of an outline.  These commands indent and format the derived files so that they are easy to read and so that it is clear what sections produced the code.  The .c file in the Examples folder shows the code produced by the Tangle commands.

The three Tangle commands are identical except for how much of the outline is tangled.  The Tangle command tangles only the selected portion of the outline, the Tangle All command tangles the entire outline, and the Tangle Marked command tangles only marked headlines.

Derived files are usually .h or .c files (C), .cpp files (C++), or .m files (Objective-C) files, and they can also be other files such as "make" or "help" files.

The Tangle commands create a derived file, call it F, from each @root node.  This process is very much like macro expansion.  The contents of F are simply the body text of the @root node, with each section reference replaced by its definition.  Substitution continues until all references to sections are replaced with their definitions.

By default, Tangle commands look for section definitions only in the suboutline containing the @root directive being tangled.  That is, all sections are assumed to be defined either in the body text of the headline, say h, containing the @root directive, or in the body texts of the descendants of h.

The @unit directive changes the default scope of the tangle command, while the @ignore directive causes the tangle commands to ignore a subtree.  For more details, see the discussion of the @unit and @ignore commands in Chapter called "Using noweb, CWEB and directives". 
</t>
<t tx="T226">When using the Tangle and Untangle commands there are several issues to be aware of concerning your IDE (Integrated Development Envirnment). This section applies particularly to the Borland IDE; similar remarks apply to other IDE's.

Assuming you have added a .cpp file to your project, you update the file with the Tangle command.  When you switch to the IDE you will get a dialog asking whether you want to update the file.  Say yes and rebuild or remake.

You won't get the dialog unless the file is already open in the IDE.  There is a bug in the Borland IDE: the dialog doesn't come to the front, so it can be easy to miss.

Now suppose you compile the file and get 20 errors all over the .cpp file. You fix the errors _in the IDE_, save the file, switch to Leo, and run the Untangle command. All your changes will appear in the outline! Each changed node will be marked by the Untangle command.

If you like you can use the Go To Next Marked command to find each changed node.
</t>
<t tx="T227">The "Import Files" command converts flat files into an outline containing noweb code.  How this is done depends on the type of the file:  .c, .cpp and .cxx files are split into C/C++ functions.  .py files are split into Python functions and classes.  .pas files are split into pascal functions.  All other files are read into a single node.

The "Import CWEB Files" command converts a flat file presumably containing CWEB code into an outline.  CWEB conventions are used in the outline rather than noweb conventions.

The "Outline To Noweb" command converts the selected outline to a flat file containing noweb text.  The name of the root section is taken from the @root directive.  &lt;&lt;*&gt;&gt; is used if the @root directive is not followed by any file name.

The "Export MORE Text" command converts the selected outline to MORE format, the pastes this text into the clipboard.  The "Flatten Outline" command writes the selected outline to a file in MORE format.

The MORE format represents headlines by a line starting with + or -.  Plus indicates a node with children, minus indicates a node without children.  Indentation is indicated by tabs preceding the + or -.  Body text follows headlines.  Body text starting with + or - or backslash is preceded by a backslash.</t>
<t tx="T228">The Quit command causes Leo to exit.   You may also exit Leo by closing the main window.  In either event you will be prompted to save any file that has been altered but not saved. </t>
<t tx="T229">Leo supports the standard editing commands that appear in the edit menu: Undo, Cut, Copy, Paste and Clear.  These commands work with either headline (when a headlines text is being edited) or body text.  Text may be cut, copied and pasted between headline text and body text.

The body pane supports unlimited undo.  However, you can not undo an operation affecting body text after selecting a new headline.  You can undo or redo the last operation involving the outline itself.  You can not undo operations affecting headline text. 

The Select All command selects all text in the body pane.</t>
<t tx="T230">The Extract, Extract Section and Extract Section Names commands create child nodes whose headline is the first line of the selected body text.

The Extract command creates a new node whose headline is the first line of selected body text and whose body is all following lines of body text.  All selected text is deleted from the original body text.

The Extract Section command creates a new node whose headline is the first line of selected text and whose body is @code followed by all the other lines of selected text.  All selected text lines except the first line are deleted from the original body text. This command is enabled only if the first line contains // or /// followed by a section name.

The Extract Section Names command creates one or more child nodes, one for each section name in the selected body text.  The headline of each created node is the section name and the body text of each created node is just @code followed by a newline.</t>
<t tx="T231">The Edit menu contains four commands for searching and replacing text.  The Find and Find Again commands search through the outline for text and the Change and Change, Then Find commands change selected text.

The following check boxes options appear in the search dialog and control the operations of the find and change commands.
</t>
<t tx="T232">When checked, the Find and Change commands proceed without stopping.  Output is sent to the log window regarding the progress of the command.
</t>
<t tx="T233">When checked, the Find and Change commands ignore the case of alphabetic characters when determining matches.
</t>
<t tx="T234">When checked, the Change command marks all headlines whose headline or body text are changed by the command.
</t>
<t tx="T235">When checked, the Find and Change commands mark all headlines in which a match is found with the pattern.
</t>
<t tx="T236">When checked, the Find and Change commands treat several characters specially in the find pattern.  The '*' character matches any sequence of zero or more characters.  The '.' character matches any single character. The '^' character at the start of a pattern, or a '$' character at the end of a pattern matches a newline.

Examples:
The pattern "^abc$" matches lines that only contain "abc".
The pattern "^a" matches any line starting with "A".
The pattern "a$" matches any line ending with "a".
The pattern "^*$" matches any line at all.</t>
<t tx="T237">When checked, the Find and Change commands search backward through the file.
</t>
<t tx="T238">When checked, the Find and Change commands search body text.
</t>
<t tx="T239">When checked, the Find and Change commands search headline text.
</t>
<t tx="T240">When checked, the Find and Change commands search only the currently selected headline and its offspring.
</t>
<t tx="T241">When checked, the find pattern must match an entire word.  Words consist of an alphabetic character or underscore, followed by zero or more alphabetic characters, numbers or underscores.
</t>
<t tx="T242">When checked, the Find and Change commands continues at the top of the file when the command reaches the bottom of the file.  For reverse searches, the find or change command continues at the bottom of the file when the command reaches the top of the file.
</t>
<t tx="T243">The Syntax Coloring command brings up a dialog specifying options relating to syntax coloring.  This dialog also specifies many command-key abbreviations for commands used in the body pane.

In particular, the Indent Text and Un-indent text commands are quite useful.  However, these commands don't work unless a range of text is selected.

The Font command brings up the standard Windows Font Panel.  Changing a font changes the fonts in all body panes; there is no way to change the font in only one pane.

The Preferences command brings up the preferences dialog.  The Page Width option determines where Tangle will break lines.  The other two global options control whether the Tangle and Untangle commands will execute a Python script when they are finished.

The Default Source Langauge determines whether noweb or CWEB is used in body panes.  The Extended Noweb Syntax option is deprecated and will be eliminated.  It allows &lt;&lt;&lt; and &gt;&gt;&gt; to be used for &lt;&lt; and &gt;&gt; in noweb mode.  Don't use this unless you are using the old "SWEB" syntax.

The Default Target Language specifies the default if no @language directive is in effect.</t>
<t tx="T244">The Insert Headline command inserts a new headline as the next sibling of the currently selected headline.  If the root headline is selected, this command inserts the new headline as the first child of the root.</t>
<t tx="T245">The Cut Outline, Paste Outline, Copy Outline and Delete Outline commands work on nodes rather than text.  For example, to delete a headline, select the headline and choose the Cut Outline or Delete Outline commands.

The Cut Outline and Copy Outline copy a text representation of the outline to the clipboard.  This representation is the same as the file format with some information deleted.  You may copy this text representation into a body pane (or into any other text editor) using the Paste command in the Edit menu.

To Copy an outline from Borland Leo to leo.py:

1. Copy the tree in in Borland Leo.
2. Paste the tree into empty body text of leo.py.
3. Select all the body text and choose Paste from the Edit Menu.
4. Move to the tree view, and choose Paste Node.

Yes, this is clumsy.  I do not as yet know how to read the System clipboard using Tk, so I use the Tk.Text command to read it for me.  Hopefully this unpleasantness will go away soon.

Warning:  In practice, it is almost always wiser to move clones rather than cutting or pasting them.  Cutting and pasting outlines preserves clones, but the links between clones only exist within the part of the outline that was pasted.  Therefore, if you are cutting and pasting an outline containing clones it is best to cut and paste the _entire_ outline.  Alternatively, you can paste part of an outline, then delete all clones.</t>
<t tx="T246">The Expand command expands the currently selected node so that all its children are visible.  The Expand All Subheads command expands the currently selected node so that all its offspring are visible.  The Expand All command expands all the nodes of the entire tree.</t>
<t tx="T247">The Move Up, Move Down, Move Left and Move Right commands move the currently selected node in the indicated direction.  The Promote command makes all the children of a node siblings of the node.  The Demote command makes all the siblings of a node children of the node.</t>
<t tx="T248">The Mark Headline command marks a headline with a red marker  near the leader characters, while the Unmark Headline command removes such a mark.  Only one of these commands appear in the Outline menu at any time: the Mark Headline command appears if the currently selected headline is unmarked.  Otherwise, the Unmark Headline command appears.  The Mark Subheads command marks all offspring of the currently selected node.  The Unmark All command removes the marks from the entire tree.

The Mark Changed Items command marks all headlines whose headline or body text has been changed since the file was last saved.  The Mark Changed Roots command marks all changed headlines whose body text contains the @root directive.  This command is especially useful with the Tangle Marked command.</t>
<t tx="T249">The Equal Sized Panes command adjusts the sizes of the code and body pane of the topmost window so that they are the same height.
</t>
<t tx="T250">The Cascade command cleans up the screen by cascading all Leo windows.  The Minimize All command mimimizes all Leo windows.</t>
<t tx="T251">Various commands write progress information to the log window, opening it if necessary.

The Open Log Window command opens the window, and the Close Log Window command closes it.  Only one of these commands is present in the Window menu at any time.</t>
<t tx="T252">The Main Window command brings the Main Window to the front.</t>
<t tx="T253">This command changes the pane that is currently active.  If the outline pane was active, the body pane becomes active, and vice versa.  This command makes it possible to switch between panes without using the mouse.</t>
<t tx="T254">The About Leo command puts up a dialog box showing the version of Leo.
</t>
<t tx="T255">@nocolor
@language python</t>
<t tx="T256">Note 1: Python scripting is available at present only for the Borland/Windows version of Leo.  Some details may change for leo.py, the Python/Tk version of Leo.

To use Leo's Python window you must install Python 1.5.2 or later.  Python's installer will place the Python DLL where Leo will find it.  Leo's Python window has been tested only with Python 1.5.2.  It's not clear whether later versions will work.

To open the Python window the following files should exist in the same directory as leo.exe.  These files are part of both the leoNN.zip and leosrcNN.zip.  Note: leosrc.leo is the primary source for these .py files.

leo.py				Makes Leo's commands and data available to Python.
leoEval.py  		Manages Leo's Python window.
wxdb.py				Runs the pdb debugger from Leo's Python window.
sitecustomize.py	Optional site-specific customization called by 
					..\Python\Lib\site.py.</t>
<t tx="T257">A Commands object (also known as a _commander_) represents the operations that can be performed on a single window.  Each open window in Leo has its own Commands object.

A _vnode_ represents a headline and its associated body text.  vnode methods get and set headline text, body text and properties.

Some scripting methods return vnodes.  These routines will return None if the corresponding Leo routine returns NULL.  Similarly, scripting methods use Python strings and return Python strings if the corresponding C++ routine uses the C++ String data type.
</t>
<t tx="T258">In the following documentation, variable names will signify the types of function arguments and returns from function:

b	Python bool
c	a commander (never None)
[c] list of commanders
n	Python short int
s	Python string
v	instance of vnode class, or None.
w	instance of LeoPyWindow class.

fileName and windowName also represent Python strings.
fileNames represents a list of fileNames.

If no value is specified for the return value of method that method returns None.  None is returned for vnodes if the corresponding C++ routine would return NULL.  In general, scripts should test vnode values for None.</t>
<t tx="T259">Executing the "Open Python Window" command from Leo's Window menu brings up a window with two panes.  You enter Python source code in the top pane.  Pressing return executes the code in the top pane.  Results are sent to the bottom pane.

To run the standard pdb debugger inside Leo:

1. import wxdb

2. call the wxdb.run, wxdb.runeval and wxdb.runcall routines.  Output goes to the output pane.  Input comes from a modal dialog.  The only way to close this dialog is by typing the quit.</t>
<t tx="T260">@nocolor

The following script shows how to access the data of a Leo window:

@color

# import classes providing access to Leo's commands and data.
# not needed, leo is preloaded.
import leo

# get the commander for the topmost outline window or the main window.
c=leo.topCommand()  # c will never be None.
v=c.currentVnode()  # get the current node (vnode) or None.
if v != None:
	head=v.headString() # get v's headline string
	body=v.bodyString() # get b's body string
	print "The current headline is:  ", head
	print "The current body text is: ", body</t>
<t tx="T261">@nocolor

The following shows two different ways of accessing all the nodes of an outline in order.  The first way might be preferable if the outline were huge.  The second way is more natural.  As usual, c is the commander for the window being processed.

@color

# method 1:
c.synchVnodes() # make sure all vnodes are valid
v=c.rootVnode()
while v:
	# do something with v
	v=v.threadNext()
	
#method 2:
c.synchVnodes() # make sure all vnodes are valid
for v in c.flatVlist():
	# do something with v </t>
<t tx="T262">Leo assumes that the text in the body pane is always current.  Code that traverses the tree acting on body text should call v.synchVnodes() first to copy the text in the body pane to it's vnode.

To set text in the body pane call v.setBodyStringOrPane().  This will work whether or not v is the current vnode.  Similarly, call v.setHeadlineStringorHeadline() to set the headline for any vnode.
</t>
<t tx="T263">Scripts never create or destroy commanders or vnodes directly.  Creating and destroying commanders or vnodes can only be done using methods of the Commands class.  Scripts have no direct access to constructors or destructors.

Some vnode methods take an optional tnode parameter, but this parameter must always be empty when called from a Python script; scripts have no direct access to tnodes.

Most properties of vnodes, such as whether a vnode is marked or dirty, are set as a consequence of commands, and may not be changed directly by scripts.  For example, the marked property may be set or cleared only by using Commands methods.

The "visited" property is an exception; it may be changed directly by a script.  Typically, this property is used to manage tree-traversal, though scripts may use this property for any purpose.  See c.clearAllVisited(), v.isVisited(), v.clearVisited() and v.setVisited().  Warning: this property may be used by any Commands method, so it does not persist.</t>
<t tx="T264">@nocolor

c.BeginUpdate() suppresses all drawing until the matching c.EndUpdate() is seen.  These methods can be nested and each c.BeginUpdate() must have a corresponding c.EndUpdate().  Wrapping code in calls to c.BeginUpdate() and c.EndUpdate() eliminates screen flicker.

c.Repaint() forces an update of the entire screen.  This should seldom be necessary since all commands update the screen properly.

c.EndUpdate() calls c.Repaint(), so the typical way to update the screen is simply:

@color
@code
	c.BeginUpdate()
	# code that alters the screen.
	c.EndUpdate()</t>
<t tx="T265">c = leo.topCommand()

The topCommand() function returns the Commands object of the top Leo window.

For example:

	import leo
	c=leo.topCommand()
	v=c.rootVnode()</t>
<t tx="T266">@nocolor

[c] = leo.getCommands()

The clist=getCommands() function returns a list of commanders for all open windows.

clist[0] is the commander for the main window, so clist[0].rootVnode() will be None.  Use clist[1:] to get the list of all outline windows. For example:

@color

import leo
clist=leo.getCommands()
for c in clist[1:]:
    root=c.rootVnode()
    name=c.fileName()
    print 'The root of ', name, ' is ', root.headString()
</t>
<t tx="T267">w = leo.getLeoPyWindow()

The getLeoPyWindow() method returns the interface class for Leo's Python window.  This class contains the following routines:

w.read()
w.readline()
w.setStatus()
w.write()
</t>
<t tx="T268">@nocolor

The commands class represents the commands for a _particular_ open Leo window.  The following description is organized by the menus in Leo's outline window.  All commands return None; use Commands methods to determine whether an operation may take place _before_ attempting the operation.

The leo.topCommand() function returns the commander for the topmost outline window.  The leo.Commands() function returns a list of commanders for all open outline windows.

The Commands class provides almost all the operations for creating, deleting, moving, cloning vnodes.  The vnode class provides getters for extracting information from vnodes and setters for changing some aspects of vnodes.  When there is a choice, you should use commands in the Commands class; they are safer.

Scripts have no access to Leo's interactive Find/Change commands.  It is easy to write scripts that mimic these commands.  Indeed, these scripts will have the full power of Python's patter matching at their disposal.

@color</t>
<t tx="T269">@code

c.new(windowName)
b=c.open(fileName)
	# returns TRUE if file could be opened or was already open. 
	# brings the window to the front if it has already been opened.
c.close()
b=c.save(fileName)
b=c.saveAs(fileName)
b=c.saveACopyAs(fileName)
c.revert(windowName)

c.tangle()
c.tangleAll()
c.tangleMarked()

c.untangle()
c.untangleAll()
c.untangleMarked()

# fileNames is a list of file names

c.flattenOutline(fileNames)
c.cwebToOutline(fileNames)
c.importFiles(fileNames)
c.importMoreText(fileNames)

c.exportMoreText()  # copies MORE format text to the clipboard
</t>
<t tx="T270">@code

c.cut
c.copy
c.paste
c.delete
c.selectAll

c.editCurrentHeadline()

c.extract()
c.extractSection()
c.extractSectionNames()
c.convertBlanks()
</t>
<t tx="T271">@code

c.cutOutline()
c.copyOutline()
c.pasteOutline()
c.deleteHeadline()
c.insertHeadline()
c.clone()

c.contractSubheads()
c.contractAllSubheads()
c.contractAllHeadlines()

c.expandAllHeadlines()
c.expandAllSubheads()
c.expandSubheads()

c.expandLevel1()
c.expandLevel2()
c.expandLevel3()
c.expandLevel4()
c.expandLevel5()
c.expandLevel6()
c.expandLevel7()
c.expandLevel8()
c.expandLevel9()
c.expandNextLevel()

c.moveOutlineLeft()
c.moveOutlineRight()
c.moveOutlineUp()
c.moveOutlineDown()

c.promote()
c.demote()

c.selectThreadBack()
c.selectThreadNext()
c.selectVisBack()
c.selectVisNext()

c.markHeadline()
c.markSubheads()
c.markChangedHeadlines()
c.markChangedRoots()
c.unmarkAll()

c.goToNextDirtyHeadline()
c.goToNextMarkedHeadline()
</t>
<t tx="T272">@code

c.equalSizedPanes()
</t>
<t tx="T273">@nocolor

The following routines all return true if the corresponding Menu command should be enabled.  The actual menu commands themselves silently do nothing if they are called when the corresponding canXXX routines returns false.

@color

b=canContractAllHeadlines()
b=canContractAllSubheads()
b=canContractSubheads()
b=canCutOutline()
b=canDeleteHeadline()
b=canDemote()
b=canExpandAllHeadlines()
b=canExpandAllSubheads()
b=canExpandSubheads()
b=canExtractSection()
b=canExtractSectionNames()
b=canGoToNextDirtyHeadline ()
b=canGoToNextMarkedHeadline()
b=canMarkChangedHeadlines()
b=canMarkChangedRoots()
b=canMoveOutlineDown()
b=canMoveOutlineLeft()
b=canMoveOutlineRight()
b=canMoveOutlineUp()
b=canPasteOutline()
b=canPromote()
b=canRevert()
b=canSelectVisBack()
b=canSelectVisNext()
b=canSelectThreadBack()
b=canSelectThreadNext()
b=canSelectToEnd()
b=canSelectToStart()
b=canShiftBodyLeft()
b=canShiftBodyRight()
b=canUndo()
b=canUnmarkAll()</t>
<t tx="T274">@nocolor

These utilities are important.  There is no need to call them when using Leo's own commands, and they will come in handy when creating your own commands.

Drawing utilities...

@color

c.BeginUpdate() # suppress screen updates.
c.EndUpdate() # enable screen updates and redraw the screen.
c.Repaint() # force the screen to be redrawn

@nocolor

Enclose code in BeginUpdate/EndUpdate pairs to inhibit drawing while the screen is being changed.  BeginUpdate/EndUpdate may be nested and each BeginUpdate must be matched with a corresponding EndUpdate call.  EndUpdate calls Repaint automatically.  You can call Repaint to force the screen to be updated immediately though all commands repaint the screen properly.

c.bringToFront() brings the window corresponding to the command class to the front.  A later leo.topCommand() will return c.

Getters...

@color

v=c.currentVnode() # The currently selected vnode or None.
v=c.rootVnode() # The first vnode of the outline or None.
b=c.isChanged() # True if the outline has been changed since it was saved.
s=c.fileName() # The file to which the Save command will write the window.  May be "Untitled"

Setters...

c.bringToFront() # Bring the window to the front. see leo.topCommand().
c.clearAllVisited() # Clear all "visited" bits.
c.editVnode(v) # Enter editing mode for v's headline.
c.endEditing(v) # End editing mode for v's headline.
c.makeVisible(v) # Expand outline if necessary to make v visible.
c.selectVnode(v)  # Make v the presently selected vnode.
c.synchVnode()  # Save the body pane in its vnode.
</t>
<t tx="T275">@nocolor

This class exists to handle the interaction between the Python interpreter and Leo's Python window.  Scripts would typically not use this class.

@color

w=leo.getLeoPyWindow()
	# get the interaction class.
s=w.read()
	# Return what the user has _already_ typed.
	# This is used to start the Python interpreter
s=w.readline()
	# Put up a modal dialog to get input and return what the user types.
	# It is not possible to break out of this dialog.
	# This routine is called by the pdb debugger.
w.setStatus(n)
	# Called by leoEval.py to control how Leo's Python window works.
	# n=0: normal input of Python text.
	# n=1: continuation input.
	# n=2: immediate exit (not used).
	# n=3: call readline to get stdin input.
w.write(s)
	# Writes s to the output pane of the Python window.</t>
<t tx="T276">@nocolor

This class provides access to the Preference settings and the contents of the log window.

@color

Getters...

p = leo.getPrefs() # returns instance of the Prefs class

b=p.defaultTangleDirectory()
b=p.doLeoDoneBat()
b=p.doLeoUnBat()
s=p.logWindowString() # returns contents of log window
n=p.pageWidth()
b=p.tangleOutputsHeaderLine()
b=p.tangleOutputsDocChunks()

Setters...

p.setDefaultTangleDirectory(s)
p.setDoLeoDoneBat(b)
p.setDoLeoUnBat(b)
p.setPageWidth(n)
p.setTangleOutputsHeaderLine(b)
p.setTangleOutputsDocChunks(b)</t>
<t tx="T277">@nocolor

The vnode class represents a node containing headline text, body text and various properties.

@color</t>
<t tx="T278">@nocolor

This section lists all the methods that return data and properties of vnodes.

Returning commanders...

The following method is quite handy.  It allows us to avoid passing commanders as arguments to vnode methods.  For example, we can call
v.commands().synchNode()

@color

c=v.commands() # The commands object for the window containing v.

@nocolor

Returning vnodes...
These may return None.  Be warned.

@color

v=v.next() # the previous sibling of v.
v=v.back() # the next sibling of v.
v=v.currentVnode() # the presently selected vnode.
v=v.findRoot() # the root vnode.
v=v.firstChild() # the first child of v.
v=v.lastChild() # the last child of v.
v=v.lastNode() # the last node of the subtree of which v is the root.
v=v.nodeAfterTree()  # v.lastNode.threadNext
v=v.nthChild(n)  # the n'th child of v, starting at index 0.
v=v.parent()  # the parent node of v.  Level 0 nodes have no parent.
v=v.threadBack()  # the node before v.
v=v.threadNext()  # the node after v.
v=v.visBack() # the visible node before v.
v=v.visNext() # the visible node after v.

Returning Python strings...

s=v.bodyString()  # the body string of v.
	# Warning:  this string may not match the body text if
	# v is the current vnode.  Call c.synchVnode to make sure it does.
s=v.convertTreeToString()  # Converts v's subtree to an ascii string.
s=v.headString() # the headline string of v.

# These two are of limited use: they are called by c.convertTreeToString().
s=v.moreBody()  # the body text of v in MORE format.
s=v.moreHead(n)  # n = the first level of the converted string

Returning Python (short) ints...

n=v.childIndex()
n=v.numberOfChildren()
n=v.level()

@nocolor

Returning bools representing property bits...
Only the "visited" bit may be altered directly by scripts.

@color

b=v.hasChildren()
b=v.isAncestorOf(v2) # true if v2 is a child, grandchild, etc. of v.
b=v.isCloned()
b=v.isDirty()
b=v.isExpanded()
b=v.isMarked()
b=v.isVisible()
b=v.isVisited()</t>
<t tx="T279">@nocolor

This section lists all vnode methods that set vnode data or properties.

Altering headline or body text...

@color

v.setBodyTextOrPane(s)
	# Sets the body text of v, whether or not v is the current node.
v.setHeadStringOrHeadline(s)
	# Replaces the headline text of v, whether or not v is the current node.
v.trimTrailingLines()  # Removes all blanks lines from v.
	# Warning: will not work if v is the current vnode.

Moving nodes..

v.moveAfter(v2)  # move v after v2
v.moveToNthChildOf(v2,n)  # move v to the n'th child of v2
v.moveToRoot()  #  make v the root vnode

@nocolor

Redraws v's icon.  This is usually done automatically.

v.setIcon()

The "visited bit" may be used by commands or scripts for any purpose.  Commands use this bits for tree traversal.  See also: c.clearAllVisited()

v.clearVisited()
v.setVisited()
</t>
<t tx="T280">The following code is implemented solely in Python; there is no corresponding C code.  You are free to change the following functions and methods as you please.
</t>
<t tx="T281">@color</t>
<t tx="T282">c.flatVlist() returns a flat list of all vnodes contained in c's window.

&lt;&lt; class CommandsPtr methods &gt;&gt;=

def flatVlist(self):

	result = []
	v=self.rootVnode();
	while v:
		result.append(v)
		v=v.threadNext()
	return result</t>
<t tx="T283">c.printFlatVlist(list) prints a list created by c.flatVlist()

&lt;&lt; class CommandsPtr methods &gt;&gt;=

def printFlatVlist(self,list):
	printFlatVlist(list)
</t>
<t tx="T284">c.printVlist(list) prints a list created by c.vlist()

&lt;&lt; class CommandsPtr methods &gt;&gt;=

def printVlist(self,list):
	self.printVlistInner(list)
	print "\n"
	
def printVlistInner(self,list):
	if list == None or list == []:
		return
	elif type(list) == type([]):
		print "[",
		for i in range(len(list)):
			self.printVlistInner(list[i])
			if i + 1 &lt; len(list):
				print ", ",
		print "]",
	else:
		print list.headString(),
</t>
<t tx="T285">c.vHeadList() contains a list similar to c.vlist() containing headline strings rather than vnode instances.  In the example given for c.vlist(), the resulting list would be: ['a' ['b' 'c'] 'd' 'e' ['f' ['g'] 'h']]

&lt;&lt; class CommandsPtr methods &gt;&gt;=

def vHeadList(self):
	result = []
	v = self.rootVnode()
	while v != None:
		self.makeVHeadList(v, result)
		v = v.next()
	return result

def makeVHeadList(self, obj, result):
	if obj == None or obj == []:
		return
	elif obj.hasChildren():
		innerResult = [] #children are represented as lists
		result.append(obj.headString())
		for child in obj.children():
			self.makeVHeadList(child,innerResult)
		result.append(innerResult)
	else:
		result.append(obj.headString())
</t>
<t tx="T286">c.vlist() creates a structured list of all vnodes in c's window.  Each entry is an instance of the vnode class.  Each node is followed by a list of its children; empty lists are not created.  For example, the window looks like:

a
	b
	c
d
e
	f
		g
	h
		
The list will look like: [a [b c] d e [f [g] h]]

&lt;&lt; class CommandsPtr methods &gt;&gt;=

def vList(self):
	result = []
	v = self.rootVnode()
	while v != None:
		self.makeVList(v, result)
		v = v.next()
	return result

def makeVList(self, obj, result):
	if obj == None or obj == []:
		return
	elif obj.hasChildren():
		innerResult = [] #children are represented as lists
		result.append(obj)
		for child in obj.children():
			self.makeVList(child,innerResult)
		result.append(innerResult)
	else:
		result.append(obj)
</t>
<t tx="T287">@color</t>
<t tx="T288">v.children() returns a list of the children of v.

&lt;&lt; class vnodePtr methods &gt;&gt;=

def children(self):

	result = []
	child = self.firstChild()
	while child != None:
		result.append(child)
		child=child.next()
	return result
</t>
<t tx="T289">@nocolor

This chapter compares Leo's approach to that of so-called "literate" programming.

The first section reviews the advantages of using “traditional” (or flat) literate programming languages.  The second section discusses how Leo extends and improves upon traditional literate programming.  The third section lists Leo’s original design goals and how Leo has met them.  This chapter concludes with a discussion of whether Leo can be truly called a literate programming system.
</t>
<t tx="T290">The following sections discuss the main benefits of traditional literate programming.  It’s worth noting that Leo retains all these benefits and that none of these benefits depend on being able to produce printed output.
</t>
<t tx="T291">Sections add a new dimension to the design and coding process.  Choices about what sections do, what they are named, what order they appear in, are choices in a design space different from “normal” programming.  This an abstract concept, to be sure.  However, the following concrete discussions are really manifestations of working in this new design space.
</t>
<t tx="T292">The names of sections are constrained only by one’s design skill, not by any rules of language.  You say what you mean, and that becomes both the design and the code.  You never have to simulate a concept because concepts become section names.
</t>
<t tx="T293">This may be the most important aspect of literate programming.  The visual weight of a web section is simply the length and complexity of the section’s name, regardless of how complex the actual definition of the section is.  The results of this separation are spectacular.  No longer is one reluctant to do extensive error handling (or any other kind of minutia) for fear that it would obscure the essence of the program.  Donald Knuth stresses this aspect of literate programming and I fully agree.
</t>
<t tx="T294">A short name can be complex when it implies unwholesome dependencies between the caller (user) of the section and the section itself.  Such section names tend to be conspicuous, so that the programmer is lead to revise both the section name and its purpose.  Many times my attention has been drawn to a poorly conceived section because I didn’t like what its name implied.  I have always been able to revise the code to improve the design, either by splitting a section into parts or by simplifying its relation to colleagues.
</t>
<t tx="T295">One of the most surprising things about literate programming is how severely traditional programming tends to limit comments.  In a conventional program the formatting of code must indicate structure, and comments obscure that formatting.  Sections in literate programming provide a place for lengthy comments that do not clutter up the code at the place the section is referenced.
</t>
<t tx="T296">The section name often says it all.  The reference to the section says everything that the user needs to know, and the section name at the point of definition also eliminates the need for many comments.
</t>
<t tx="T297">@nocolor

A typical root starts out with something like.

@color

	&lt;&lt; includes for class x &gt;&gt;
	&lt;&lt; private data for class x &gt;&gt;
	&lt;&lt; private prototypes for class x &gt;&gt;
	&lt;&lt; functions of class x &gt;&gt;

@nocolor

In the derived .c file generated by the Tangle command there is a comment that looks like this:

@color

	/// &lt;&lt; includes for class x &gt;&gt;

@nocolor

It would be silly to write this comment by hand, though often programmers do just that in order to have a placeholder for a mark in the source file.  With literate programming the situation is different: the comment indicates that the code came from a particular section; that is, the comment servers a real purpose.
</t>
<t tx="T298">These last several paragraphs have discussed comments in detail because the net effect of “putting comments where they belong” is that comments don’t clutter the code.  Section references hide irrelevant detail, so larger-scale patterns within functions (or declarations) become more apparent.  Often just recasting code into web format has created Aha’s about my own code, with no special attention to recoding or redesign!  Recasting a function as a web raises the real and apparent level of abstraction.  	
</t>
<t tx="T299">Formatting no longer has to indicate overall design: sections do that.  I am less obsessive about formatting code: it simply doesn’t matter much whether different sections are formatted consistently because the format of one section has no effect on the look of other sections.  Also,  I don’t worry about most line breaks within documentation parts, or about adding beginning and ending /* and */ delimiters.
</t>
<t tx="T300">Outlines add something brand new to traditional literate programming, namely an explicit mechanism for expressing structure at any level of detail, from largest overall view to smallest detail.  The following sections elaborate on this theme.</t>
<t tx="T301">By far the biggest drawback of conventional literate programming is that there are so many sections; it becomes difficult to understand the relationships, if any, between sections.  Using an outline to express literate programming instantly solves this problem.  The programmer is always aware of how sections are related.
</t>
<t tx="T302">Outlines provide a convenient way of expressing the intended scope of commands.  For example, the Tangle command operates only on the presently selected tree.  The Extract Section command creates a new section as the last child of the present node.
</t>
<t tx="T303">Clones transform a tree into a directed graph without loops.  This is a very powerful data structure.  Nothing would be gained by cloning an arbitrary directed graph: in general, the clone would simply become the entire tree.  Cloning a tree, however, is very effective.
A set of clones becomes essentially a different view of the outline.  The set is itself part of the outline, so the outline itself contains an elegant mechanism for representing arbitrarily many views of the same data.  It is because of the power of clones that I described MORE in the dedication as possibly the most elegant computer program ever written.

It is easy to create different (and useful) views of a literate outline.  For example, I often make clones of all relevant sections of my outline while debugging or adding new features.  The clones carry along relevant suboutlines, so essential context is retained, but gathering all the clones together automatically concentrates attention on the problem at hand.
</t>
<t tx="T304">The meaning of a well written literate outline is independent of the order in which sections appear, so outlines may be reorganized at will.  In addition, headlines without body text do not affect derived files in any way; such headlines can be inserted freely at any time.  In fact, such “nonfunctional” headlines often convey the most information about the structure and design of a large system.  Decoupling structure from content in this way is precisely what is needed for flexibility: one can reorganize at will without worrying about changing the meaning of the code.  
</t>
<t tx="T305">Hierarchy is often implicit in programming: for example, the grouping of functions into files, or the organization of a single file as a set of functions, etc.  An outline directly expresses hierarchy.  For example, Leo’s Tangle or Find and Change commands may be restricted to a particular suboutline.  That’s a direct expression of a hierarchical constraint or property: I want to deal with only this part of the outline.  With outlines, I can do so effortlessly.

Traditional literate programming often simulates the hierarchy using “bridge” comments.  Those comments are far weaker than explicit structure.  Experience with the Print command clearly shows that a clear literate outline can easily become unintelligible when printed, no matter how “beautiful” the typeset printout is.

My experience shows that organizational crutches such as printed listings, tables of contents and indices are much less clear than the corresponding outline.  You could say the entire outline is a table of contents!
</t>
<t tx="T306">There are many ways to express a program as a literate outline.  Again, the choices made when doing so are choices in another design space.  Such choices are important, and add clarity to the entire program, but can only be expressed when the hierarchy is expressed explicitly.
Leo contains an integrated Tangle command.
</t>
<t tx="T307">Leo changes how "literate programming" is done in practice in at least four ways:

1. Leo shows conclusively that printed listings are neither necessary nor sufficient to understand programs written in the noweb or CWEB languages.  No printed listing can be as clear as Leo's outline view.

2. Leo reduces the need for comments within a program.  In particular, bridge or transition phrases are almost always unnecessary in a literate outline.  One never needs to say something like, “having just finished with topic x, we turn now to topic y.”  Literate outlines tend to be far less chatty than flat literate programs.

3. Flexible and standard outline organizations provide a simpler and more natural way to organize large programs than stream-of-consciousness or narrative styles of organizing programs.

Indeed, narrative style creates severe maintenance problems.  The narrative is soon forgotten.  As soon as that happens it becomes difficult to find anything.  The few times I have tried narrative organization I soon regretted it: things just weren’t where I expected them to be.

4. Leo shows that traditional literate programming encourages a _too_ creative approach to programming.  One typically wants an organization more like a dictionary than a novel.  Literate outlines provide a much more regular organization, while providing space for the most lengthy discussions when those discussions are required.

So Leo provides strong evidence that the phrase "literate programming" is a misnomer.  Indeed, chunks or sections, the “atoms” of literate programming, have little to do with literature!  One can use chunks or sections to write narrative prose, but Leo demonstrates that one is under no obligation to do so.

In short, Leo works so well because Leo can show the "big picture" of a program at _all_ levels of detail.  To do this, Leo requires only outlines and the chunking mechanism.  Narrative exposition is optional.
</t>
<t tx="T308">I had tried flat literate programming and did not succeed in producing a program that I could understand.  The design of my own literate programs were a mystery to me.  With the insight gained with two years experience with literate outlines, I believe I could now probably create flat literate outlines with some success.  But how would I do that?  By mentally simulating a literate outline!  So although it would be possible for me to use flat literate programming tools, it would never be easy or natural.

Using literate outlines instantly transformed how I program.  No longer was I confused about what I had done or what remained to do.  No longer did I need to remember section names.  No longer did I have to search for where functions and variables were defined.  March 5, 1996, the day I started using MORE as a prototype of a literate outliner, changed my programming life forever.  Within an hour of writing code in MORE, I knew that literate outlines would work, and work spectacularly well.
</t>
<t tx="T309">Printed listings, no matter how “beautiful”, simply do not convey the structure of complex programs as well as an on-screen outline.  What matters is how a program is represented on screen.  I have been using Leo since early 1996.  Not once did have I had any inclination to look at a printed listing in order to understand my program better.

noweb is much simpler than CWEB because there are no control codes to specify either the appearance of text on the screen or on the printed page.  I added the @chapter and @section directives because printed listings were completely unreadable without them.
</t>
<t tx="T310">I accomplished this by borrowing a large part of MORE’s screen design.  Consider this the sincerest form of flattery.

I did make one significant change to MORE’s design.  MORE shows body text in multiple separate windows within the main outline pane; Leo shows body text in a single body pane.  Leo’s approach simplifies switching between nodes: one simply selects a new headline and the body text appears in the body pane.  With MORE, one has to explicitly open the body pane for each individual headline, which can be clumsy.

MORE’s approach does have some advantages.  When opening body text in MORE, the subsidiary window becomes as large as necessary to show the entire body text, up to the limit of the size of the containing window.  With Leo, the body pane stays fixed unless one resizes it.  This is the reason Leo has a shortcut for resizing the body pane.

MORE leaves lots of open windows around when doing a search or change command; MORE could be called a slob in this regard.  However, one can see all the places where the search command found a match just by looking at all the open windows.  With Leo one must mark headlines to see where one has been, then use the Find Next Marked Headline command.

To summarize, MORE and Leo have far better outlining facilities than programs such as Emacs, QUED/M, Word or Word Perfect, which fake headlines by marking flat text.  Both MORE and Leo provide true outline objects and a full range of outline operations.  Leo attempts to fix the one clumsy feature of MORE, the need to explicitly open body text.  On the whole, I believe that Leo is slightly easier to use than MORE, especially for programming.
</t>
<t tx="T311">That’s why Leo had to have integrated Print, Tangle and Untangle commands.  Leo is already complete enough for daily production work.
</t>
<t tx="T312">Earlier, I listed a bunch of “highbrow” reasons for liking literate programming.  I know somebody really gets what literate programming is all about when he or she says how much fun literate programming is.  Clearly, Leo has succeeded admirably in this regard.  I would never again willingly program without a literate outliner.
</t>
<t tx="T313">@nocolor

Please, please give Leo2 a try.  Leo2 simplifies your source code and eliminates the need to tangle and untangle files.

Leo2 is compatible with Leo1, the old Leo.  Leo2 can read Leo1 files. The newest version of Leo1 can read Leo2 files.  A single .leo file may contain both @root trees (Leo1 trees) and @file trees (Leo2 tree).

The following sections document the new features of Leo2, mainly the @file and @others directives.  The file LeoPy.leo provides a large example of how to use @file nodes.
</t>
<t tx="T314">Leo2 simplifies your source code.  Within @file trees, section defintions no longer start with &lt;&lt;section_name&gt;&gt;=.  A single @others directive  replaces all such lines.  The @doc directive is optional.

All @file trees are tangled automatically when .leo files are saved.  All @file trees are untangled automatically when a .leo file is opened.

Leo2 trees are created from derived files, not vice versa.  That is, derived files become the primary source files for your projects.  CVS and other source code control systems can treat a Leo2 project exactly like any other project.

Files derived from @file nodes are simultaneiously both outlines and text.  In effect, Leo2 is a platform for creating a "universal browser" for any kind of textual information.  For example, one could represent debugger data as a Leo file! All that is required is that the program using the derived file supports some kind of comment convention.
</t>
<t tx="T315">The following sections discuss details of using Leo2.</t>
<t tx="T316">The @delims directive changes the comment strings used to mark sentinel lines.  The @delims directive contains one or two delimiters, separated by whitespace.  If only one delim is present it delimits single-line comments.  If two delims are present they delimit block comments. The @delim directive can _not_ be used to change the comment strings at the start of the derived file, that is, the comment strings for the @+leo sentinel and the initial @+body and @+node sentinels.

NB: Leo2 can not revert to previous delimiters automatically; you must change back to previous delimiters using another @delims directive.  For example:

@delims /* */
Javascript stuff
@delims &lt;-- --&gt;
HTML stuff
</t>
<t tx="T317">Converting Leo1 files to Leo2 files is straightforward, and need not be done all at once. Indeed, leo2(cb).leo, the source code for Leo2, contains both Leo1 and Leo2 code.

Leo1 creates derived files from @root nodes (nodes containing an @root direcitve in body text).  Leo2 can creates derived files from @root nodes exactly like Leo1 does.  In addition, Leo2 creates derived files from @file nodes (nodes containing @file in the headline).

Typically you would convert a Leo1 outline to a Leo2 outline by changing @root trees to @file trees as follows:

1.  Change the @root node to an @file node.  That is, delete the @root &lt;filename&gt; directive from the body text and insert @file &lt;filename&gt; in the headline.  Typically, the root node contains a reference like &lt;&lt;methods of class x&gt;&gt; as the last body text.  Replace this reference with the @others directive.  The expansion of @others is all text that is not part of a section definition.

2.  Add @&lt;space&gt; to the start of all doc parts.  Leo2 starts syntax coloring in code mode rather than doc mode, so if a doc part starts body text it should start with @&lt;space&gt; or @doc.

3.  Replace all section definition lines (like &lt;&lt;name&gt;&gt;=) by @c (or @code).  This results in the node being added to the expansion of @others.

4.  Remove all unused code from the @file tree.  Leo2 does not write derived files whose @file trees contain orphan or @ignored nodes.  If an @file tree does contain an orphan or @ignored node, Leo2 issues a warning and writes the entire @file tree to the .leo file instead of the derived file.  This prohibition of orphan an @ignored nodes is necessary to make error recovery completely safe and reliable.

5.  Make sure that all nodes defining a section have a headline that starts with &lt;&lt;section&gt;&gt;.  This will typically be true when converting Leo1 outlines that use the @code directive.

6. If a section is referenced in more than one node (a rare occurance in my code), clone the defining node and move one clone under each referencing node.

7. If a node contains the definitions of several sections, place each different definition in a different node.

It would be possible to write a Python script to do all this, and I haven't done it yet.</t>
<t tx="T318">@nocolor
@ignore</t>
<t tx="T319">@nocolor

Announcing Leo2, a major revision of Leo.  Leo2 is Open Source software distributed under the terms of the Python License.  You may download Leo2 from Leo2's Source Forge site at: 
    http://sourceforge.net/projects/leo/

The following is a terse listing of Leo2's features.  In fact, I am thrilled with Leo2.  Leo2 is the culmination of a dream I have had for over 5 years, and it elegantly solves a number of complex problems relating to what might be called "distributed outlines."

Leo2 makes outline structure an essential part of literate programming, and in so doing creates a simple and uncluttered literate programming language.  In many cases, unadorned text works as a literate program!

Leo2 changes the relationship between outline and source files; Leo1 (the original version of Leo) treats outline (.leo) files as primary documents.  Leo2 treats source files as primary documents, so source files can be edited, compiled and archived as usual.  Leo2 shows how any text file can be at once a flat text and a real, full-featured Leo outline.

Now some details...

Leo represents programs as outlines.  Leo1 stores projects in a single .leo file.   Leo1 "derives" program files from the outline using a translation process known as tangling.  When derived files change, the user updates the outline using a reverse translation process known as untangling.

With Leo2, tangling and untangling are fully automatic; Leo2 converts derived files to outlines when reading a .leo file, and automatically updates derived files when writing a .leo file.  To make tangling and untangling work reliably, Leo2 uses a simple and robust error recovery recovery mechanism.

With Leo2, all essential information resides in derived files so .leo files are typically small.  Non-essential information resides in .leo files so that derived files change only when absolutely necessary.

With Leo2, "derived" files are in fact the primary source files; Leo2 embeds outline structure in source files using comments called sentinel lines.  Leo2 requires no changes to work flow: derived files can be compiled, edited, and archived as usual using standard tools.

With Leo2, source files are plain text files as far as compilers are concerned.  However, they are also fully functional Leo2 outlines!  Indeed, Leo2 can embed outline structure in any text file provided only that the programs that use the text file provide a comment convention.  Leo2 becomes a platform for providing superior browsing capabilities for text.

Leo2 simplifies noweb, the language supported by Leo1. A new @others directive eliminates the need for "chunk header lines" such as &lt;&lt;section_name&gt;&gt;=.  Moreover, Leo2 makes outline structure an essential part of literate programming; sections must be defined in descendants of nodes containing references.  In effect, the entire outline becomes a multi-scoped symbol table.

Leo2 is fully compatible with Leo1.  Leo2 retains all of Leo1's sophisticated outline features, including clones.   Leo2 supports any text-based programming language, including C++, Objective-C, Pascal, Object Pascal, HTML, Java, Perl and Python.</t>
<t tx="T320">The following table lists the abbreviations that can be used to execute commands.

Enter	Insert Headline ( when outline pane is active )
Enter   Insert newline ( when body pane is active )

Control keys

` Clone 
= Change
- Change, Then Find
A Select All
C Copy
D Move Down
E Equal Sized Panes
F Find
G Find Again
L Move Left
M Mark/Unmark Headline
N New
O Open
P Print (Weave)
Q Quit
R Move Right
S Save
T Toggle Active Pane
U Move Up
V Paste
W Close Window
X Cut
Z Undo
[ Shift Body Left
] Shift Body Right

SHIFT+CONTROL keys

A Tangle All
B Convert Blanks
C Copy Outline
D Extract
E Extract Section
F C File To Outline
G Find Previous
H
I Import MORE Text
J
K Clone Window
L Open Log Window
M Tangle Marked
N Extract Names
O
P Page Setup
Q
R
S Save As
T
U
V Paste Outline
W
X Cut Outline
Y
Z Redo
] Demote
[ Promote
Up Go Back
Down Go Next
</t>
<t tx="T321">@ignore</t>
<t tx="T322">In @root and @unit trees, the @code directive indicates the start of a code section. The headline must contain a valid section name.

In @file trees, the @c directive indicates the start of a code section.

</t>
<t tx="T323">This directive affects only the Weave (Print) command (and possibly the Create CWEB command).  It indicates the start of a chapter.  This puts the chapter title at the top of each page.</t>
<t tx="T324">Indicates that syntax coloring is enabled for the body text in which it appears and all descendent nodes ( unless over-ridden in the descendent nodes ).</t>
<t tx="T325">This directive indicates the delimiters to be used by the Tangle command.</t>
<t tx="T326">The @cweb directive specifies that the source code is CWEB code, overriding the default specified in the Preferences panel.  This directive affects syntax coloring.</t>
<t tx="T327">In @root and @unit trees, the @doc directive indicates the start of a comment enclosed in the beginning and ending block comment delimiters ( see @comment ).

In @file trees, the @(space) (@ followed by a space, tab or newline) indicates the start of an doc part.  @(space) is optional: it is not needed if the body text contains no doc part.

</t>
<t tx="T328">Strictly speaking, @file is not a directive; it is not valid in body text.

A headline that starts with @file &lt;filename&gt; forms the root of an @file tree.  Leo writes all nodes in the tree to the derived file &lt;filename&gt; when any Save command is executed.  The @file tree is recreated from the derived file when the .leo file is opened.

The Leo2 documentation discusses how to write code in @file trees.
</t>
<t tx="T329">This directive causes the Tangle and Untangle commands to ignore this node and all its descendents.</t>
<t tx="T330">The @language directive specifies the comment delimiters and string types used by the Tangle and Untangle.

The form of this directive is

@language x

where x is one of the following: c,c++,html,java,objective-c,pascal,perl,python and shell.  Shell files have comments that start with #.  Case is ignored in the language specifiers, but not in the @language itself.  Thus, the following are equivalent:

@language html
@language HTML
@language hTmL

but the following is invalid:

@LANGUAGE html

The @comment directive is now officially deprecated: you should use the @language directive whenever possible.  At present Untangle will not process an @root or @unit node if an @comment directive is in effect.  Why?  Because Untangle can't be sure of properly parsing a derived file if the language of the derived file isn't known.  It might be possible to assume some defaults in this case, but that is not done at present and is not a high priority.</t>
<t tx="T331">Indicates that syntax coloring is disabled for the body text in which it appears and all descendent nodes ( unless over-ridden in the descendent nodes ).</t>
<t tx="T332">The @noweb directive specifies that the source code is noweb code, overriding the default specified in the Preferences panel.</t>
<t tx="T333">The @others directive is valid only in @file trees.  The @others directive causes the expansion of all unnamed nodes to be output to the derived file in the position of the @others directive.

For example, a common Python idiom is:

class myClass:
	&lt;&lt; constants of myClass &gt;&gt;
	@others
	
The @others directive inserts the expansion of all unnamed sections into the class definition, indented just as the @others directive is indented.

An @file tree may have more than one @others directive.  Each @others directive collects only those nodes found in the descendents of the node containing the @others directive.

A single node may contain at most one @others directive.  To use more than one @others directive in an @file tree, use the following pattern:

class x:
	&lt;&lt;members of x&gt;&gt;
class y:
	&lt;&lt;members of y&gt;&gt;
	
The named nodes &lt;&lt;members of x&gt;&gt; and &lt;&lt;members of y&gt;&gt; contain only an @others directive.  Define members of the x and y classes as descendents of the nodes containing @Others.

</t>
<t tx="T334">The @pagewidth directives affects how Tangle outputs block comments:  it specifies the width of output pages in columns.  The form of the @pagewidth directive is @pagewidth n, where n is a positive integer.
</t>
<t tx="T335">The @path directive specifies the directory to be used if an @root directory does not specify a full path name.  This overrides the "Default Tangle Directory" option in the Preferences panel.

The form of the @page directive is @page filename, where filename is taken to be everything following @page to the end of the line.
</t>
<t tx="T336">This directive starts the text that forms a single derived file, after all section references have been replaced by their definitions.

By default, only descendents of the @root node are examined for section definitions.  However, if the @root directive is a descendent of a node containing the @unit directive, all descendents of the the @unit node are examined for section definitions.</t>
<t tx="T337">This directive affects only the Weave (Print) command (and possibly the Create CWEB command).  It indicates the start of a section.  This puts the section title at the top of each page.</t>
<t tx="T338">The @silent causes Tangle to output no comments for doc chunks and no sentinel lines for Untangle. Comments written by the user in code sections are always output.

</t>
<t tx="T339">The @tabwidth directives affects how Tangle outputs leading whitespace:  it specifies the width of tabs in spaces.  The form of the @pagewidth directive is @tabwidth n, where n is a positive integer.
</t>
<t tx="T340">The @terse directive causes Tangle not to output comments for doc chunks.  Tangle will output only those sentinel comments needed by Untangle.  As always, comments written by the user in code sections are output.

These directives are not valid in @file trees.</t>
<t tx="T341">Expands the nodes searched for section definitions when processing an @root directive.

By default, only descendents of the @root node are examined for section definitions.  However, if the @root directive is a descendent of a node containing the @unit directive, all descendents of the the @unit node are examined for section definitions.</t>
<t tx="T342">The @verbose directive causes Tangle to output comments for doc chunks and sentinel comments needed by Untangle.  This is the default behavior if none of the @verbose, @terse or @silent directives are in effect.
</t>
<t tx="T343">The following error messages may be generated by the Tangle commands.  Such errors appear in the log window, which will be opened if necessary.	
</t>
<t tx="T344">A file error occured while trying to reopen the temporary file used during tangling.</t>
<t tx="T345">A file error occured while trying to change the name of the temporary file used during tangling.</t>
<t tx="T346">An @code directive appeared in body text whose header does not contain a section name.</t>
<t tx="T347">An @directive was seen somewhere other than the start of a line.</t>
<t tx="T348">Tangle detected more than 20 errors.</t>
<t tx="T349">A section was defined in terms of itself, either directly or indirectly.  The trace shows the chain of section defintions that resulted in the illegal definition.

This message is followed by a walkback of the section names that recursively reference the section.  The walkback looks like this:

called from &lt;&lt; section name &gt;&gt;
called from &lt;&lt; section name &gt;&gt;
...
</t>
<t tx="T350">Tangle did not write a file because errors were found.</t>
<t tx="T351">A C-language comment was not properly terminated.</t>
<t tx="T352">The file name in an @root directive was not terminated with the proper delimiter.</t>
<t tx="T353">A section name was not properly terminated before the end of the line in which it started.
</t>
<t tx="T354">A C-language string or character constant was not properly terminated.</t>
<t tx="T355">Something that looks like a section definition was seen in the middle of a line.</t>
<t tx="T356">A section was defined using more than 100 levels of section definitions (!)

You could easily create an outline containing every computer program ever written in less than 50 levels.</t>
<t tx="T357">The selected outline contained no @root directive.</t>
<t tx="T358">A reference to an undefined section was encountered.</t>
<t tx="T359">Tangle outputs 2-character WEB control code in a comment.  This message is given if we find such comments in a code definition.</t>
<t tx="T360">(The text of the duplicate definition follows.)

The section may have been defined in more than one place.</t>
<t tx="T361">The indicated section appears in the outline but is never referenced.</t>
<t tx="T362">The following error messages may be generated by the Untangle commands.  Such errors appear in the log window, which will be opened if necessary.	
</t>
<t tx="T363">Two expansions of &lt;&lt; section name &gt;&gt; were different in the derived file.  This typically arises when the programmer changes one of the expansions but not the other.</t>
<t tx="T364">No end sentinel line was found for a part of the expansion of the code in the @root node.  This is likely the result of adding, deleting or altering a sentinel line.</t>
<t tx="T365">No end sentinel line was found for the expansion of the code in the @root node.  This is likely the result of adding, deleting or altering a sentinel line.</t>
<t tx="T366">The end sentinel name for &lt;&lt; section name &gt;&gt; was expected but not found.  This is likely the result of adding, deleting or altering a sentinel line.</t>
<t tx="T367">The end of the file was reached before encountering the end sentinel line for
	&lt;&lt; section name &gt;&gt;.
This is likely the result of adding, deleting or altering a sentinel line.</t>
<t tx="T368">The following are all minor errors, meaning that no data is likely to have been lost.  You can proceed as usual.

1. Rereading file.  Clone links into this file will be lost

The .leo file is out of synch with the derived file, so non-essential information usually stored in the .leo file will be deleted.  Clone links may be severed.

2. Missing file name.  Restoring @file tree from .leo file

No file name follows @file

3. Error reading file.  Restoring @file tree from .leo file

The file name following @file could not be found

4. File name in @node sentinel does not match file's name

The name of the derived file may have been changed.

5. Ignoring text after @-leo

Some text follows the trailing @-leo sentinel line.  Make sure this text is not important.</t>
<t tx="T369">The following are all serious errors, meaning that the data in a derived file has been corrupted.  You should restore the information from a backup .leo file using the Read Outline Only commands, followed by a Write @file Nodes command.

 1. Bad @+leo sentinel in &lt;filename&gt;
 2. Bad @delims"
 3. Bad attribute field in @+node
 4. Bad child index in @+node
 5. File may have damaged sentinels!
 6. Ignoring &lt;sentinel kind&gt; sentinel.  Expecting &lt;sentinel kind&gt;
 7. Ignoring unexpected @+leo sentinel
 8. Missing &lt;sentinel kind&gt; sentinel
 9. Missing @file in root @node sentinel
10. Outline corrupted: different nodes have same clone index!
11. Replacing body text of orphan &lt;node name&gt;
12. Unexpected end of file. Expecting &lt;sentinel kind&gt; sentinel
13. Unknown sentinel: &lt;sentinel line&gt;
</t>
<t tx="T370">Errors while writing @file nodes are harmless.  No information is lost because all information is written to the .leo file rather than the derived file.

1. Bad @delims directive

2. Can not open &lt;file name&gt;

3. @ignore node: &lt;headline&gt;

The body text of &lt;headline&gt; contains an @ignore directive.

4. Missing file name: &lt;file name&gt;

@file is not followed by a file name.

5. Orphan node: &lt;headline&gt;

The node is referenced by no ancestor node, and no @others directive applies to it.

6. @others already expanded in: &lt;headline&gt;

The node contains more than one @others directive.

7.  Rename failed: no file created! (file may be read-only)

Leo's Save commands write derived files to a temporary file, and rename that file to be the derived file only if the old derived file is different from the temporary file.  This message means that a problem with the file system prevented the temporary file from being renamed.

8. Path does not exist: &lt;file name&gt;

The path may be specified by the Preferences panel, an @path directive or by a path in the @file node.

9.  undefined section: &lt;section name&gt; referenced from: &lt;headline&gt;
			
The node given by &lt;headline&gt; contains a reference to &lt;&lt;section name&gt;&gt;, 
but no named node for &lt;&lt;section name&gt;&gt; exists in the descendents of &lt;headline&gt;	</t>
<t tx="T371">The following sections describe the comment lines embedded in derived files.  It is not necessary to understand this in detail.  All you need to know is this:

1. Sentinel lines are comment lines whose first character is @.
2. Do not alter sentinel lines in derived files.  Doing so will corrupt the outline structure!</t>
<t tx="T372">A file produced by an @file node begins with an @+leo sentinel.  The last lines of the file should be the matching @-leo sentinel

The comment delimiters that delimit all sentinels are specified by the first line of the file, that is, the @+leo sentinel.  This sentinel has the form:

&lt;opening_delim&gt;@leo&lt;closing_delim&gt;

&lt;closing_delim&gt; may be empty, in which case single-line comments are used.  The Write code generates single-line comments if possible.  Presently, the Write logic generates single line comments for all languages except HTML.  (Block comments can be specifed using the @comment directive.)</t>
<t tx="T373">Suppose the parent node of a node N is P and that P has n children.  The sentinel 

  @+node:&lt;child_index&gt;:&lt;status_fields&gt;:&lt;headline&gt;

begins the expansion of node N.  The expansion continues until a matching

  @-node::&lt;child_index&gt;:&lt;status_fields&gt;:&lt;headline&gt;
  
sentinel.

The &lt;child_index&gt; field is a number from 1 to n indicating the index of the node in the list of its parent's children.

The &lt;status_field&gt; field the cloneIndex field of the form: "C=nnn", where nnn is an immutable clone index.

The &lt;headline&gt; field contains headline text, not reference text.

The indentation of the expansion is increased by the extra indentation of preceding the reference.  tree level never affects indentation level.</t>
<t tx="T374">If a node contains significant I(non-whitespace) body text, @+body and @-body sentinels surround the text.  These sentinels are nested within @node directives.
</t>
<t tx="T375">@+doc and @-doc delimit doc parts within a node that start with @doc. These sentinels are nested within @body directives.  Similarly, @+at and @-at delimit doc parts within a node that start with @&lt;whitespace&gt;.

We use the following convention to determine where putDocPart has inserted line breaks: A line in a doc part is followed by an inserted newline if and only if the newline if  preceded by whitespace.  To make this convention work, the Write deletes the trailing whitespace of all lines that are followed by a "real" newline.</t>
<t tx="T376">@+others indicates the start of the expansion of an @+others directive, which continues until the matching @-others. @others sentinels are nested within @body sentinels; the expansion of the @others directive always occurs within the body text of some node N.
</t>
<t tx="T377">The @delims directive inserts @@delims sentinels into the derived file. The new delimiter strings continue in effect until the next @@delims sentinel _in the derived file_ or the end of the derived file.

Adding, deleting or changing @@delim _sentinels_ will destroy Leo's ability to read the derived file.  Mistakes in using the @delims _directives_ have no effect on Leo, though such mistakes will thoroughly mess up a derived file as far as compilers, HTML renderers, etc. are concerned.</t>
<t tx="T378">The @@&lt;text&gt; sentinel represents any line starting with @ in body text except @&lt;whitespace&gt;, @doc and @others. Examples:

  @@nocolor
  @@pagewidth 80
  @@tabwidth 4
  @@code</t>
<t tx="T379">@verbatim indicates that the next line of the derived file is not a sentinel.  This escape convention allows body text to contain lines that would otherwise be considered sentinel lines.</t>
<t tx="T380">@&lt;&lt;section_name&gt;&gt; represents section reference.  If the reference does not end the line, the sentinel line ending the expansion is followed by the remainder of the reference line.  This allows the Read code to recreate the reference line exactly.</t>
<t tx="T381">The following is a list of features I'd like to add to Leo.
</t>
<t tx="T382">Leo should support scripting and other forms of inter-program communication.</t>
<t tx="T383">There is no way to style text in the body pane.  Leo could use two kinds of body panes: one for styled text (and possibly even graphics) and the other for syntax colored code.</t>
<t tx="T384">It would be natural to go to the definition of a section when, say, option-clicking on a reference to that section.  Other kinds of hypertext linking could be useful.</t>
<t tx="T385">This command would convert an outline to a plain text file containing CWEB source.  This will provide a "back door" for those who require the formatting capabilities of TeX.

Similarly, the Flatten Outline command will simply copy the outline to a text file.</t>
<t tx="T386">It would be useful to have easily available, possibly as a pop-up menu, a list of the most recently accessed sections, and possibly a full list of all section names as well.</t>
<t tx="T387">The user should be able to choose whether to place the outline pane above the body pane or to place the outline pane to the left of the body pane.

Placing the outline pane to the left of the body pane would be more typical, though I think the present arrangement actually works better.  Still, the user should be able to choose.
</t>
<t tx="T388">This would convert a Pascal source file to an outline, much like the C To Outline command.</t>
<t tx="T389">This would be a major piece of work, and it would allow Leo to be used much more easily for any kind of programming language.</t>
<t tx="T390">Leo grew out of my efforst to use Donald Knuth's "CWEB system of Structured documentation."  I've known of literate programming for more than 10 years, but I could never quite make it work for me: it was difficult to know when to create new sections and it was difficult to keep track of all the sections once they were created.  In hindsight I see that "flat" literate programs have too little structure.  Outlines add badly needed context.

In early 1996 I realized that there is a deep relationship between literate programs and outlines.  Webs are outlines "in disguise".  Later, I saw that I could use the MORE outliner as a prototype for a "literate outliner."  I immediately started work on my first literate outline.  It quickly became apparent that outlines work: all my old problems with literate programming vanished.  For the last two years I have done all my programming using literate outlines; I would never willingly program in any other form.

Late in 1997 I wrote a Print command to typeset an outline.  Imagine my surprise when I realized that such a "beautiful" program listing was almost unintelligible; all the structure inherent in the outline was lost!  Typesetting, no matter how well done, is no substitute for explicit structure.  Outlines are an essential addition to literate programming.

In March 1990, Christopher J. Van Wyk, the editor of the literate programming column in the Communications of the ACM, wrote a special column entitled, "Literate Programming: an Assessment."  After discussing several strengths of literate programming, he wrote:

"I know of a half-dozen systems for writing literate programs, each modeled on WEB, perhaps adding or subtracting a few features, or working with different programming languages or typesetting systems.  Unfortunately, no one has yet volunteered to write a program using another's system for literate programming.  A fair conclusion from my mail would be that one must write one's own system before one can write a literate program, and that makes me wonder how widespread literate programming is or will ever become."

An alternative conclusion is possible: we need much better framework for literate programming.  Leo is that environment.  Leo makes absolutely clear what is issential (and inessential!) about literate programming.</t>
<t tx="T391">In June and July of 2001 I extended Leo by inventing the @file and @others directives.  This extended Leo has come to be called Leo2.

The following sections give a quazi-chronological list of the major Aha's involved in creating Leo2.  These Aha's form the real design and theory of operation of Leo.  See the "Diary", "Notes" and "Letters to Speed Ream" sections below for a more accurate, less clear, history of Leo2's design.

I am writing these notes for several reasons:

1.  For fun.  Creating Leo2 has taken less than 8 weeks.  This has been some of the most creative and rewarding work I have ever done.  The result is elegant and simple and I'm proud of it.

2.  Much of the design is not expressed clearly in the code, because improved design had the effect of eliminating code altogether.  The result is so elegant that it obscures the design work that underlies it.

3.  It is not possible to appreciate Leo2 fully without understanding the many design choices that had to be made.  Someday someone else may take charge of Leo.  That person may want to know what really makes Leo2 work.</t>
<t tx="T392">The most important step was deciding to begin the design of Leo2.

This involved accepting the possibility that sentinel lines might be corrupted.  Most design issues were unresolved or even unknown.  I resolved to attempt a robust error-recovery scheme, not knowing in advance what that might involve.  I also wanted to solve what I thought of as the "cross-file clone" problem: clones that point from a .leo outline into a derived file.  With Leo1 cross-file clones do not exist; everything is in the same .leo file.  It was clear that Leo2 would have to change some aspects of clones, but all details were fuzzy.</t>
<t tx="T393">The second, and extremely important, step was to use Leo1 as a prototype to design what Leo2's body pane would look like to the user.  At the time I called the language "simplified noweb", though that terminology is fading.  The enclosed nodes contain that prototype.

It quickly became apparent that most nodes would be orphans, so the @others directive had to be invented.  I immediately saw that simplified noweb would be a joy to use.  

Doing this prototype got me excited about Leo2 for the first time.  This was important, as it motivated me to do a lot of difficult design work. What was exciting was 1) @others could replace _all_ section definition lines and 2) @doc was needed only if there was a doc part.  Indeed, I saw that plain body text could become a "literate" program!  This was an amazing discovery.</t>
<t tx="T394">@ignore

This was the Python prototype outline that convinced me that Leo2 would be a great thing.  Perhaps it is no accident that Python was involved early in the creative process.  Prototyping in Python allowed me to concentrate much more intensely on the real issues involved.

Remember, this was all done with Leo1.  I knew that the @code directives would not be needed if body text started in code mode; they were there so syntax coloring would look right.  

The code itself prototypes the code in atFile.cpp, part of LeoCB.leo.  A careful comparison will show that the final code was much simpler than this code.

This code has never been "tested" in any way.  It may even have syntax errors.  It was never intended to be run;  it was a source of ideas only.</t>
<t tx="T395">@color
@language python</t>
<t tx="T396">@code

buffer = []
start,code,ref=range(3)
codestart=[]
codeend=[]
refstart=[]
refend=[]</t>
<t tx="T397">@code

def readFile(file):
	global buffer
	root=createRoot()
	&lt;&lt; open the file into buffer &gt;&gt;
	&lt;&lt; set the sentinal delims &gt;&gt;
	text,i=scanNode(0,root,start,None)
	setText(root,text)
	return root</t>
<t tx="T398">@code

</t>
<t tx="T399">@ Sentinal delims are language-specific.  The first several lines of the file had better specify those delims somehow.

@code

</t>
<t tx="T400">@ returns (result,i)

@code

def scanNode(i,node,kind,sectionName):
	result=[]
	end=""
	if   kind==ref:  end=refend
	elif kind==code: end=codeend
	
	while i &lt; length:
		if match(i,codestart): #add no reference
			i=i+len(codestart)
    		name,i=getName(buffer,i)
			child=createChild(node,name)
			text,i=scanNode(i,child,code,name)
			setText(child,text)
		elif match(i,refstart): #add reference
			i=i+len(refstart)
			name,i=getName(buffer,i)
			refname= "&lt;&lt; " + name + " &gt;&gt;"
			child=createChild(node,refname)
			result.append(refname + "\n")
			text,i=scanNode(i,child,ref,name)
			setText(child,text)
		elif match(i,end):
			i=i+len(end)
			name,i=getName(buffer,i)
			if name==sectionName: return result,i
			else:error("Mismatched sentinal")
		else:
			# @others handled like any other text.
			# "other" nodes become code nodes (I hope).
			result.append(buffer[i])
			i=i+1
	if end != "":
		error("Missing sentinal")
	return result,i</t>
<t tx="T401">@ organizer nodes are code (non-ref) nodes without any (significant) text.  They generate no references and no text, and do not change indentation at all.</t>
<t tx="T402">@code

def match(i, pattern):
	lpat=len(pattern)
	if i + lpat &lt; length:
		return buffer[i:i+lpat]==pattern
	else:
		return 0</t>
<t tx="T403">@code

def getName(buffer,i):
	result=""
	return result,i</t>
<t tx="T404">@code

def createChild(parent, headline):
	child = None
	return child</t>
<t tx="T405">@code

def error(message)
	pass</t>
<t tx="T406">@color
@language python</t>
<t tx="T407">@ We traverse the tree as follows:

In the following description, @others will typically be treated like any other reference.

For each unvisited node, we write the text, expanding references (and @others).  Expanding a node sets the visited flag.  When visited, all nodes should be visited: give a warning if not.

Indentation.  Wen expanding references and @others, we increment the indentation by the indentation of the reference (or @others).  The expansion is a recursive process, so the indentation level will increase and decrease many times.

@code

def writeFile(self,filename, tree):
	self.file=open(filename)
	tree.unvisitall()
	self.writeNode(tree,0)</t>
<t tx="T408">@code

def writeNode(self,node,indent):
	# write node, expanding all references
	text = text(node)
	for i in text:
		if isRef(text,i):
			self.writeStartRef(...)
			#expand all refrences
		elif isAtOthers(text,i):
			# ????????????? what do we write ????????????
		else:
			self.write(text[i])</t>
<t tx="T409">@code

def write(self)
	pass</t>
<t tx="T410">@code

def writeStartRef(self):
	pass</t>
<t tx="T411">A third crucial step was overcoming a subconscious resistance of doing Leo2.

After much "daydreaming" I finally realized that I was afraid that reading and writing would be interrupted by a long series of alerts.  So designing the "user interaction" during reading and writing would be very important.  The next Aha was that I could replace a long series of alerts with messages to the log window, followed by a single "summary" alert.  Much later I saw how to eliminate alerts entirely.

At this time I thought there would be two kinds of "errors".  Warnings would alert the user that something non-serious happened.  True errors would alert the user that data might have been lost.  Indeed, if Leo2 saves orphan and ignored nodes in a .leo file under an @file node, then read errors could endanger such nodes.  Much later I saw that a robust error recovery scheme demands that @file nodes not contain orphan and @ignored nodes.  More on this subject later.  But if orphan and @ignored nodes are moved out of @file trees, there are no Read errors that can cause data loss!  So the distinction between warnings and errors finally went away.</t>
<t tx="T412">I next turned my attention to writing @file nodes.

A huge Aha: sentinel lines must contain _both_ a leading and a trailing newline.  The write code must contain absolutely no "conditional" logic because the Read code would not know how to figure out whether the condition was true or false.

So derived files contain blank lines between sentinel lines.  These "extra" newlines are very useful, because the Read (untangle) code can now easily determine exactly where every blank, tab and newline of the derived file came from.

At about this time I designed a clever way of having the Write code tell the Read code which newlines were inserted in doc parts.  To quote from my diary:

"We can use the following convention to determine where putDocPart has inserted line breaks: A line in a doc part is followed by an inserted newline if and only if the newline is  preceded by whitespace.  This is a really elegant convention, and is essentially invisible to the user.

Tangle outputs words until the line would become too long, and then it inserts a newline.  To preserve all whitespace, tangle always includes the whitespace that terminates a word on the same line as the word itself.  Therefore, split lines always end in whitespace.  To make this convention work, tangle only has to delete the trailing whitespace of all lines that are followed by a 'real' newline."</t>
<t tx="T413">After the Write code was working I turned my attention to the Read code.

The Leo1 untangle code is the most complex and difficult code I have ever written.  Imagine my surprise when I realized that the Leo2 Read code is essentially trivial!  Indeed, the Leo2 untangle code is like an assembler: the Read code scans lines of a derived files looking for "opcodes", (that is, sentinel lines) and executes some simple code for each separate opcode.  The heart of this code is the scanText routine in atFile.cpp.

The Read code was written and debugged in less than two days!  It is the most elegant code I have ever written.  While perfecting the Read code I realized that sentinel lines should show the complete nesting structure found in the outline, even if this information seems redundant.  For example, I was tempted to use a single sentinel to represent an @other directive, but finally abandoned this plan in favor of the @+other and @-other sentinels.

This redundancy greatly simplified the Read code and made the structure of derived files absolutely clear.  Moreover, it turned out that we need, in general, all the information created by the present sentinel lines.  In short, sentinels are as simple as they can be, and no simpler.

The atFile::createNthChild method is a very important: it ensures that nodes will be correctly inserted into the outline.  createNthChild must be bullet-proof if the Read code is to be robust. Note that the Write code outputs @node sentinels (that is, section definitions) in the order in which sections are referenced in the outline, not the order in which sections appear in the outline.  So createNthChild must insert the n'th node of parent p properly even if p contains fewer than n-1 children! (The Write code ensures that section references are properly nested: @node sentinels are enclosed in @node sentinels for all their ancestors in the @file tree.) createNthChild creates dummy siblings as needed, then replaces the dummy siblings later when their actual definitions (@node sentinels) are encounted.

At this point the fundamental Read/Write code was complete.  I found three minor bugs in the code over the next week or so, but it was clear that the Read/Write code formed a rock-solid base from which to continue design and implementation.  This was an entirely unexpected surprise.</t>
<t tx="T414">At this point I could read and write derived files "by hand", using temporary Read and Write commands.  The next step was to integrate the reading and writing of derived files with the loading and saving of .leo file.

From time to time I made minor changes to the drivers for the Read and Write code to accomodate the Load and Save code, but at no time did I significantly alter the Read or Write code itself.

Designing the user interaction drove the design and implementation of the Load/Store code.  The most important questions were: "what do we tell the user?", and "what does the user do with the information?" It turned out that the user can't make any complex decision during error recovery because the user doesn't have nearly enough information to make an informed choice.  In turn, this means that certain kinds of error recovery schemes are out of the question...
</t>
<t tx="T415">I now turned my attention to "attributes."

Most attributes, like user marks, are non-essential.  However, it was clear that clone information was essential; we must never lose clone links.  At this time I had a preliminary design for cross-file clones that involved a two part "pointer" consisting of a full path name and an immutable clone index within the derived file.  Eventually such pointers completely disappeared, but the immutable clone indices remain.

My first thought was that it would be good to store all attributes in @node sentinels in the derived file, but experience showed that would be irritating.  Indeed, one wants Leo2 to rewrite derived files only if something essential has changed.  For example, one doesn't want to rewrite the derived file just because a different node as been selected.

At this point I had another Aha: we can use the .leo file to store all non-essential attributes.  For example, this means that the .leo file, not the derived files, will change if we select a new node.  In effect, the .leo file "mirrors" the derived file.  The only reason to store nodes in the .leo file under an @file node is to carry these attributes, so Leo2 writes "dummy" nodes that do not reference body text.
</t>
<t tx="T416">The concept of mirroring created a huge breakthrough with cross-file clones:  Here is an excerpt of an email i sent to my brother Speed:

"I realized this morning that since a .leo file contains dummy vnodes for all nodes in a derived file, those dummy nodes can carry clone info!  I changed one line to make sure that the Write code always writes clone info in dummy vnodes and voila! Cross-file clones worked!"

All of Leo1's clone code could be used completely unchanged.  Everything "just works".
</t>
<t tx="T417">At first I thought we could make sure that the .leo file always correctly mirrors all derived file, but disasterous experience showed that is a completely false hope.  Indeed, backup .leo files will almost never mirror derived file correctly.  So it became urgent to find a completely fool-proof error recovery scheme.

I had known for quite a while that error recovery should work "as if" the mirroring nodes were deleted, then recreated afresh.  Several failed attempts at an error recovery scheme convinced me that error recovery would actually have to delete all dummy nodes and then do a complete reread.  This is what Leo2 does.

But erasing dummy nodes would destroy any orphan and ignored nodes; by definition such nodes appear nowhere in the derived file.  Therefore, I had to enforce the rule that @file nodes should contain no such nodes.  Happily, this decision greatly simplified all aspects of Leo2.  Here is an email I wrote to Speed Ream discussing what turned out to be the final error recovery scheme:

"The error recovery saga continues.  After much pondering and some trial
coding I have changed my mind about orphans and @ignored nodes.  They
simply should never appear as descendants of @file nodes.  Fortunately,
this simplifies all aspects of Leo2.

Leo2 will issue a warning (not an error) if an orphan or @ignored node
appears as the descendant of an @file node when a .leo file is being
saved.  If any warnings occur while writing the derived file, Leo2 will
write the "offending" @file tree to the .leo file instead of the derived
file.  This has several advantages:

1. The user gets warned about orphan nodes.  These are useful warnings! 
Orphan nodes arise from missing @others directives or missing section
references.

2. The user doesn't have to change anything immediately in order to save an outline. This is very important.  Besides warnings about orphans, Leo2 will also warn about undefined or unreferenced sections. User's shouldn't have to fix these warnings to do a Save!

3. No errors or alerts will occur during Reading or Writing, so the
user's anxiety level goes way down. At worst, some informational message
will be sent to the log.  The user will never have to make important
decisions during Loads or Saves.

[Note: at long last the dubious distinction between errors and warnings disappears!]

4. Error recovery can be bullet-proof.  Simple code will guarantee that
after any Read operation the structure of an @file node _will_ match the
structure of the derived file.  Also, sentinels in derived files will
now account for _all_ children of an @file node. There are no more
"missing nodes" that must be filled in using the .leo file.  Finally,
error recovery will never change the @file tree in any way: no more
"recovered nodes" nodes.

5. The present Read code can be used almost unchanged.  The only
addition is the posting of a warning if the structure of the .leo file
does not match the structure of the derived file.  We need a warning
because non-essential attribute of nodes (like user marks) may be
altered."</t>
<t tx="T418">The following is my unedited Diary from June and July 2001.  This is taken from LeoCB.leo.</t>
<t tx="T419">Modified import commands for Leo2.  The skipLeadingComments routine handles only C comments, which is strange.  Fixed a bug in skipLeading Comments: massageComment was being called with wrong arguments.</t>
<t tx="T420">Created Save Outline To command.  This is an important tool for error recovery.</t>
<t tx="T421">The only safe way to recover from read errors is to delete all the root's descendants and and body text then do a complete rescan.  It was easy to do this.  I created a distinction.  mStructureErrors counts the number of errors found in createNthChild.  mErrors counts all other errors.  After a file is opened, mErrors typically indicate serious problems: probably corrupted sentinels.

After the first pass, if mStructureErrors &gt; 0 we reset mErrors and rescan.  If mErrors is then &gt; 0, we have a serious problem.  Otherwise we report a minor problem.

Earlier, I attempted to do a "cheap" error recovery by having createNthChild mark as visited all ancestors of non-dummy nodes, ensuring that a node is finally unmarked only if all of its descendants are unmarked. However, this doesn't solve the problem; once child indices are suspect there is no way to recover.

</t>
<t tx="T422">Created vnode::setAncestorAtFileNodeDirty.  This should be called whenever the outline is modified.  Also added similar code to vnode::setDirty.

Leo2 now writes only dirty @file nodes.  If the old and new files compare equal we say "unchanged".</t>
<t tx="T423">There are three different ways of recognizing directives.  As a result, @ignored is handled slightly differently in different contexts.  This is a bug.

1. Syntax coloring

Directives are recognized at the start of any line.  However, @others is recognized anywhere in code mode.

2. While scanning text in atFile::read.

Directives are recognized at the start of any line because directiveKind() is called only at the start of a line.  An exception is that directiveKind is called twice for @others so that @others will be recoginized after leading whitespace.

3. Using vnode routines

The vnode routines isAtIgnoredNode and isAtOthersNode call the is_special utility function.  This recognizes matches after leading whitespace.</t>
<t tx="T424">At present, the read error recovery is very simple: createNthChild bumps mErrors if it has to create any node at all.  It is not clear that it would be a good idea to try to delete dummy nodes...

Reporting errors in the write logic is straightforward.  The writeError() routine puts out a starting error message before the first error.  atFile::write puts an ending error message if any errors were seen.  The result looks good.

I moved several utilities to the vnode class, and the match function to Utils.cpp.

I have just gotten quite a lesson in error recovery.  Once again, it is crucial to backup .leo files as well as derived files.  Errors during the debugging phase can cause no end of problems!

Once again, the problem was a confusion between match() and match_word().  Typically we can _not_ use match() in the atFile class!</t>
<t tx="T425">Mirroring can fail whenever the structure of a .leo file does not mirror the structure of the derived file.  And this will probably happen whenever we use backup copies of either a .leo file or a derived file, without using the other file.

So the question is not whether error recovery will happen, but rather what to do when it does happen.  After quite a bit of thought I have reached some conclusions:

1. Dealing with orphans and @ignored nodes during error recovery is really dangerous.  Moving such nodes will change child indices!  There really is no simple, foolproof way to handle such nodes during error recovery, and trying to do so is going to make error recovery brittle.

2. Creating a recovery node is bad interface design, for several reasons.  First, error recovery should change the tree as little as possible.  Second, we could end up with several such nodes as children of an @file node. 

3. Designing the messages the user see is the heart of designing Leo2.  Surely, we want to minimize messages and alerts whenever possible.  We want to eliminate errors entirely, and issue warnings or informational messages only when that information will truly benefit the user.  We want to reduce the sense of "alarm" that the user may feel.

4. Banning orphan and @ignored nodes can be done easily and smoothly, and does not cause problems for the user.  We simply issue a warning if we find such nodes, and then write the @file tree to the .leo file.

This has several advantages:

1.  We never issue error messages _anywhere_, except for rare messages pertaining to opening or closing files.  This reduces the user's anxiety.

2.  The user is warned about orphans and @ignored nodes under @file nodes.  These are helpful warnings!  Indeed, orphan nodes are typically a sign of missing @others directive, or a missing section reference.  Moving @ignored nodes from under an @file node can be done easily and naturally by the user.  Example:

Original outline:

Class header
	@file blah.h
	@file blah.cpp
		@ignored node
		
Revised outline:

Class header
	Ignored
		@ignored node
	@file blah.h
	@file blah.cpp
	
This is a natural and easy organization.

3. The error recovery phase can properly assume that it will never have to deal with orphans or @ignored nodes.  Really this is crucial.  Error recovery becomes trivial, which is the only way that it can work!</t>
<t tx="T426">Some bitter experience shows that the load process must be made much more robust.  In fact, we can expect file errors whenever we use a backup copy of a .leo file.  In other words, Rule 3 will be violated routinely and "mirroring" will fail often.  Using .lbk (backup) files might even make this problem worse.  Indeed, under the present scheme, backup copies of .leo files become the enemy of derived files.

It would be unbearable to return to the old scheme of embedding attributes into derived files; we must have the derived file change only when something significant has happened.  And the mirroring scheme solves the "orphans and ignored" problem pretty well too.

So--the Read code be must more robust:

1. We should eliminate error messages during load; they are useless anyway.  Instead, when an error is found we go into "error recovery" mode.  A final dialog alerts the user that orphan and ignored nodes have been moved.  This dialog should not offer the user any choices because the user will not know how to make a choice.

2. During error recovery, we move orphans and ignored nodes into a "recovered nodes" node that is placed after the @file node being processed; the "recovered nodes" node does not change the ordering of nodes being read.  After the derived file has been fully read, we make this "recovered nodes" node the last child of the @file node.

We want the overall effect of error recovery to be as if we had deleted the entire mirroring tree (except for orphans and @ignored) from the @file node.  In other words, the contents of the .leo file shouldn't matter (except for orphans and @ignored nodes): error recovery uses only the contents of the derived file.  With this scheme, the derived file is clearly the one true master file.

This is a clean design.  Read will always restore the outline properly, provided only that the derived file was properly written and has not been corrupted.  Moving orphan and ignored nodes is not significant, since it will not affect the derived file.

We should keep clone indices in derived files.  Error recovery needs them.  All other "mirrored" information (current vnode, marks) may be lost or altered.

3. We use various marks (I'm not sure which yet) to denote the status of nodes:

A: Regular node, properly loaded.
B: Orphan and Ignored node, properly loaded.
C: Dummy node (probably can only happen after structure error).

</t>
<t tx="T427">Oooops.  @others in a doc part can ruin an outline.

1.  @others is recognized by is_special even within doc parts.  This is wrong.

2.  If @others is mistakenly recognized, the scope of the previous @others ends, but if @others is in a doc part putCodePart will never recognize the @others, so we will lose code.

The solution is to make _sure_ that @others is not recognized in doc parts.</t>
<t tx="T428">Making backups with Leo2 is actually quite tricky.  It does look like using .lbk files might really be essential.  The problem is that once the .leo file and the derived files get out of synch things go downhill in a big hurry.  There may be bugs in Leo2 at present that make things get out of synch when they shouldn't, but the fundamental problem remains: making backups of .leo files or derived files alone just doesn't seem to work well.

One possibility for backups is making @ignored _copies_, not clones of @file nodes. As I learned from painful experience, making @ignored _clones_ of @file nodes isn't good: if the derived file gets messed up all the clones will get messed up.  Alas, clone links go away, as in ImportFiles, so this really is a last ditch solution.</t>
<t tx="T429">I just lost a file due to some problem with @file nodes: scanCText just disappeared.  This highlights a problem with Leo2: it is not so easy to do full backups because all derived files should be backed up too.

I have been wondering whether it might be a good idea to provide a "Save Backup" command.  This would work like Save To, except that it would produce a Leo Backup file, say an .lbk file.  Leo1 would read .lbk files just like .leo files.  Leo2 would read .lbk files without processing @file directives.

What should the Save, Save As and Save To commands do when applied to an .lbk file?

If they would work like the "Save Backup" command then there is no way to create derived files!  I'm even tempted to bring back the equivalent of the Tangle commands for Leo2:  Write Derived File, Write All Derived Files, Write Marked Derived files.  But doesn't that defeat the purpose of Leo2?

I suppose we could revise the _old_ Tangle command to use the Leo2 sentinels, then use the new "Untangle" code.  But that seems silly, why not do everything automatically?  Well, there is a reason: The Save command doesn't work well if there are syntax errors.

Ideally, we would like to have things work automatically by default, but allow the user to Read and Write derived files when necessary.  Of course, the Save commands force writes, so a Write command is not useful, but maybe a Read command might be useful.  I'm not in a hurry to do this, though.</t>
<t tx="T430">Changed atFile::error so it reports at most mMaxErrors messages.  If more than that are found we warn in readAll or writeAll.

Changed atFile::nodeSentinelText so that if writes clone status only if WRITE_CLONE_STATUS is defined.

Limited the number of errors reported by error to mMaxErrors.

Should we write files only if some node is dirty?  It seems reasonable: we save a lot of writing, because at present all @file nodes are written to temp files, then the temp file is compared with the present file.  However, there are problems: we must make sure that new nodes are dirty, and that the @file node is dirty if nodes are removed.  We must make sure that all changes get propagated to clones.  This may become more important as more files get converted to @file nodes.

Removed Read/Write commands.

Changed file format from 1 to 2.  The old Leo should warn about version 2 files.

Added code to old Leo so that it warns on reading Leo2 file.
</t>
<t tx="T431">Got undo to work again.  This involved using the LeoProject.bpr as a new template for Leo2Project.bpr.  But the real mystery is this: If I choose "Build with runtime packages" things don't work!!  I have no idea what is going on!  (I must use VCLX40.BPL, because that defines DirectoryExists).

A huge breakthrough.  Realized that since the vnode structure in the .leo file mirrors the vnode structure that will be created by atFile::Read, we can use the outline to carry clone info.  A few minor changes and everything just worked!

Some of the "minor changes" were bug fixes in the tnode and vnode classes(!!)

1. Changed vnode::setT()  so that it does nothing if the old tnode is the same as the new.  If we don't make the change, the code
	delete mT ;
	mT = t ;
will assign mT to the tnode we just deleted!

2. In vnode::joinNodeTo changed
	v1 -&gt; isOnJoinListOf ( v1 ) 
to
	v1 -&gt; isOnJoinListOf ( v2 )
Apparently this code was always returning FALSE !! </t>
<t tx="T432">Here is most of the email I sent to my brother, David Speed Ream, concerning the new clone scheme.

I realized this morning that since a .leo file contains dummy vnodes for
all nodes in a derived file, those dummy nodes can carry clone info!  I
changed one line to make sure that the Write code always writes clone
info in dummy vnodes and voila! Cross-file clones worked!  So Leo2 could
be called complete!

The present scheme is extraordinarily elegant, and I'd like to discuss
some issues with you.  Some of these are pretty important, and I hope
you will reply ASAP.  (The sooner you reply, the sooner you get Leo2!)

1. Mirroring can fail spectacularly.

Everything depends on the fact that a .leo file mirrors the structure of
the derived files in so-called dummy vnodes.  I believe there can be no
problems long as you follow these three rules:

Rule 1: Use only Leo2 to edit .leo files created by Leo2.
Rule 2: Don't mess with sentinels in derived files, and
Rule 3: Generate each derived file from a single .leo file.  (The
converse is not required: a single .leo file can contain many @file
nodes without violating this rule.)

As long as you follow these rules, I don't believe you can mess things
up even if you tried, for example, by renaming @file nodes, etc.

Alas, Rule 3 is pretty restrictive.  If we "innocently" break Rule 3 we
will be in trouble.  For example: Write the derived file f from A.leo. 
Read the file in B.leo, alter the structure of the derived file in the
outline, then write the file from B.leo.  The mirroring will break when
we read the derived file in B.leo.

We could try to recover by replacing the entire tree for f in B.leo with
@file f, then saving B.leo, thereby clearing all dummy vnodes. When we
reread B.leo the derived file will be fully restored under @file f, but
all orphaned or @ignored nodes under @file f will be lost.

Whenever mirroring is broken it will likely create dozens or hundreds of
mismatches between what the Read code expects to see in the outline and
what it actually does see.  This can cause data loss: the Read code can
end up replacing @ignored or orphaned nodes.  Usually the sane course of
action will be to recover from backup files.

Question:  I modified the old Leo to handle the new file format, partly
to make sure the dummy vnodes were being written properly.  I could
enforce Rule 1 by officially changing the file format from version 1 to
version 2 so that no old version of Leo could handle any new .leo file,
but that seems drastic.  What do you think?

After some debate, I have decided that dummy vnodes in a .leo file
should contain headline text.  This allows createNthChild to raise an
error if there is a mismatch between the headline in derived file and
the headline in the .leo file in the expected position.  If we get one
error we are likely to get many, so I will add code to limit the errors
and issue a summary error at the end of the Read code.

Question:  Am I making too much out of this?  Unless the sentinel lines
are corrupted, the Read code will produce an outline properly, except
for
orphan and @ignored nodes, and except for clone status and minor stuff
like marks.  In practice, I think everything will work perfectly almost
all the time.  Still, Rule 3 is a bit restrictive, and breaking it will
cause pain.  Any comments?  (Also see below.)

2. @include'd files can't use this scheme.

There have been several requests for one .leo file to be able to
@include other .leo files.  We can't mirror the @include'd .leo files
because the user can always edit the @included'd .leo file separately.
In other words, Rule 3 can not be assumed.  I probably would not
implement cross-file clones for @include'd .leo files: clones must be
contained within the same .leo file.

Although this sounds simple, it actually wouldn't be so simple to
enforce, because the user _would_ be able to create such forbidden
clones, at least in the window.  So we either implement the "hard"
cross-file clones or have the Write code issue objections.  I'll
probably leave this for later...I don't think @include is so
important.

3. Clone indices in the derived files are redundant.

It is now possible to remove the cloneIndex field from node sentinels in
the derived file: all that information is now redundant since the .leo
file contains _all_ node attributes.  The more I think about this, the
more I like removing clone indices.

Indeed, there is now a curious kind of dual master/slave relationship
between the .leo file and derived file.  In some sense, the derived file
is the master file, because the .leo file recreates the outline from the
derived file.  OTOH, one expects all structure changes to be done in
Leo2, not in derived file.  Provided Rules 1, 2 and 3 hold we can assume
the following condition always holds:

Condition 1: The structure of the derived file changes only if the
structure of the outline changes.

This being so, one could just as well imagine that it is the .leo file
that is the master file!  In short, one is justified in believing the
following two conditions will always hold:

Condition 2: The structure of the outline under an @file node is the
same as the structure of the file derived from that node.

Condition 3: Nodes are clones in the derived file if and only if they
are clones in the corresponding nodes under the @file node.

All three conditions depend on Rule 3.  OTOH, without Rule 3, _neither_
the .leo file nor the derived file can really be a master!  You might
rephrase Rule 3 this way: no derived file can more than one master .leo
file.  Maybe this only makes the restriction _seem_ more reasonable ;-)

In any event, if these conditions are all true, then we are justified in
treating clone status of nodes in the derived file as being generated
from the .leo file.  In that case, clone indices are not required. There
are pros and cons to this viewpoint.

Cons: clone status then becomes entirely dependent on the outline.  So
clone status becomes a little more error prone.  However, if mirroring
ever fails, we will have thoroughly messed everything up, and we will
have to recover from backups anyway, so this is a moot point.

Pros: we now will rewrite a derived file _only_ if something changes
really, truly, for sure.  Just creating a clone of a node (and moving
the clone outside the @file node) will _not_ cause the derived file to
be rewritten.  And of course the format of @node sentinel lines becomes
simpler.

I would certainly remove clone indices from derived files if I were not
thinking of cross-file clones and @including .leo files inside other
.leo files.  What are your thoughts?

In conclusion, it seems that Rule 3 is the only drawback to the present
implementation.  Notice that the present implementation solves problems
with orphans and @ignored code as well as clones, so I believe that we
should insist on Rule 3.  If people can't handle Rule 3 we would have to
do without dummy vnodes, and that really would be a pity.  We would then
have to issue stern warnings about orphans and @ignore'd nodes under
@file nodes.</t>
<t tx="T433">All status information is now saved in the outline in dummy vnodes.  The trickiest part was setting the current vnode.  We must wait until all derived files have been read so that the body text will exist.  If we don't, the event handlers will put empty body text into the current vnode.

No changes at all were made to createNthChild: everything just works.

Changed Extract Section command so it doesn't output @code.

I am still debating whether dummy vnodes should have headlines:

Pros:  createNthChild can do much better error correcting.
Cons: dummy vnodes look like real vnodes if read by the old Leo.

Indeed, maybe I shouldn't allow the old Leo to read Leo2 files: making any change to the dummy vnodes will disrupt createNthChild.  And we are not just talking about losing non-essential status: we are talking about disrupting body text.</t>
<t tx="T434">Today I start a major revision.  We will no longer write non-essential status bits to derived files.  Instead, these bits will be held in "dummy" vnodes that written to the .leo file.  Dummy nodes also provide a way of saving @ignored and orphaned nodes.  This is a big step forward.

Created vnode dummyBit and orphanBit accessors.  These bits are archived in the .leo file.  A dummy vnode has no headline or body text: just attribute bits.  An orphan vnode is a full vnode which should not be overwritten when a derived file is read. If it is, the structure of the derived file has changed since the .leo file was written.

Updated the getVnode and putVnode in FileCommmands.cpp to handle these bits.  Changed the atFile::Read/Write file so that only the cloneIndex is written to derived files.  No other status bits are written.

Removed atFile::mWriteExpansionState and atFile::mCurrentVnode ivars.</t>
<t tx="T435">Completed the processing of same-file clones.  Created atFile::joinTrees, similar to vnode::JoinTreeTo.

Added code to allow the current expansion state to be saved.  I'm not sure which is less annoying: a preference will probably be needed.

Added mXCloneFile and mXCloneIndex field to vnodes, with the appropriate accessors.  This is a fairly substantial increase to vnodes, but it just can't be helped.</t>
<t tx="T436">Fixed bug in put(vnode*).  If an @file name has no path we assume we _can_ write to that directory.

Created mCloneIndex field in tnodes and cloneIndex and setCloneIndex accessors.  This field contains the maximum clone index when v is an @file node.  This means we don't need the @header sentinel!  We want to put the cloneIndex in tnodes, not vnodes, because tnodes are the unit of sharing: if one vnode has a cloneIndex all vnodes that share that tnode should have the same cloneIndex.

Got same-file clones working.  On to cross-file clones!

Added mWriteExpansionState ivar.  Typically this should be off so we don't rewrite a derived file simply because we expanded or contracted one of its nodes.  Eventually we should make this a preference.  Changed Commands::write_LEO_file so it passes a dummy current node into all write routines if the current node is inside an @file node.  The current node doesn't actually change; that would be very upsetting to the user, but the current node will be different when the outline is loaded again.  This should eliminate most spurious writes of derived files.

Added code to tell when a derived file is written.  This may be the feedback that I have been looking for.</t>
<t tx="T437">Changed atFile::read and atFile::write so they handle invalid directories more smoothly.</t>
<t tx="T438">Created hash.cpp.  It is too bad that C and C++ don't have a simple hash table class. I prefer not to use STL.

I want a hash table to link all nodes with the same clone index.  With a hash table this could be done roughly as follows:

if ( &lt;&lt; v has an index i &gt;&gt; ) {
	if ( hashTable . hasKey ( i ) )
		v -&gt; setT ( hashTable . valueForKey ( i ) )
	else
		hashTable . enter ( i, v -&gt; t() )
		
Actually, derived files are likely to have very few distinct clones.  An expandable of array of entries (i, t) would suffice.</t>
<t tx="T439">Here is a letter I sent to my brother:

The new code that writes and reads derived files solves a similar
problem elegantly.  When a section in a derived file is written, Leo2
ensures that sufficient @node directives surround it so that it can be
inserted into the outline.  When a section is read, Leo2 knows that the
node will be the n'th node of its parent, but n-1 previous siblings may
not have been created as yet, so the creatNthNode will insert dummy
siblings as placeholders so the n'th node will be placed properly. 
Later, the dummy siblings are replaced by the real nodes.

Could something like this be done in the .leo file?  If a derived file
is written for an @file node we will write nothing in the .leo file
under the @file node. We won't write the derived file if the the
directory in the @file node doesn't exist or the @file is in the range
of an @ignore directive; in that case the .leo file contains all the
descendants of the @file node so no information is lost.

Anyway, at present an @file node will have no descendants in the .leo
file if the derived file is actually written.  Could we insert orphan
nodes and @ignored code in the .leo file under the @file node? We want
to make sure that they will appear in the proper places in the outline
when the derived file is read.  Suppose we have a writeOrphansAndIgnored
routine to write the required info to the .leo file.  Like the Write
code, this routine must ensure that the Read code will be able to
recreate the outline with these nodes in the proper places.  Suppose
writeOrphansAndIgnored wants to save a node N, the n'th child of its
parent p, with ancestors p, p2,...pn, where pn is the @file node
itself.  writeOrphansAndIgnored must ensure that N has n-1 previous
siblings, creating dummy outline nodes if necessary. 
writeOrphansAndIgnored must also insure that p,...,pn-1 all exist.  This
code will be similar to the putOpenSentinels and putCloseSentinels used
by the present Write code, but instead of writing sentinels to the
derived file writeOrphansAndIgnored will create vnodes in the .leo
file.  But this can be done easily! writeOrphansAndIgnored simply marks
as "visited" any nodes that are required to place orphan and ignored
nodes, then writes all visited descendants of the @file node to the .leo
file!

The Read code must recognize dummy nodes so that it can replace them
without complaining.  Again, this can be done by marking all descendants
of the @file node as "visited" before calling Read.  If Read sees a
visited node it knows it is a dummy and will replace it silently.

In short, it looks like this is doable about as cleanly as can be hoped.
</t>
<t tx="T440">Added code test path on write; we treat an @file node for an invalid directory like an ignored @file: that is, we write the outline to the .leo file rather than the derived file.

Fixed a syntax color bug: @&lt;newline&gt; wasn't colored the same as @&lt;space&gt;.  The fix was to put '\n' in the follow set rather than the pattern itself.</t>
<t tx="T441">Fixed a bug that caused Leo2 to delete all body text containing @ignore.

Converted atFile class to outline.  Leo2 appears to read and write it correctly.  The Leo2 version of atFile is now the primary source for the atFile class.

Alas, Windiff is pretty stupid.  It appears useless.

Changed put(vnode*) so that copy to clipboard forces a write of the entire tree.</t>
<t tx="T442">The new Read/Write code appears solid.  I'll do a definitive test soon.

I'm about to add support for cross-file clones to the .leo file format
and @node sentinels in the derived file.  I'll send you the new Leo
after the file formats are completely stable.  I think the design issues
related to clones have been handled, but we shall see.

I've been busy integrating the Read/Write code into the Load/Save
commands.  The actual coding has been routine, but several interesting
user interface issues have arisen that I would like to discuss with you
here.  Comments appreciated as always.

1. File errors.  Suppose that @file path/filename appears in an outline,
but that path does not exist.  We can not write the derived file.  We
could prompt the user for a valid path or we could just write the entire
@file tree to the .leo file.  I like the second option: we issue a
warning and go on without endangering any data.  The big advantage is
that the user doesn't have to fix anything in order to save the file.

2. @ignore.  There is some doubt about what this should mean.  In the
old Leo, @ignore affected Tangle and Untangle but not (obviously) Load
and Save.  In the present version of the new Leo, @ignore also affects
Load and Save.  If an @file node appears in the scope of an @ignore
directive the @file node is neither written nor read.

It would also be possible to say that @ignore only affects Tangle and
Untangle, and to always honor @file nodes.  Both ways have some
advantages, but I favor having @ignore apply to @file nodes.  It seems
natural to me.  What do you think?

3. Reread commands.  Leo needs two new commands: Reread @file Node and
Reread All @files Nodes.  Reread @file Node is very much like the
Untangle command: the current vnode must be an @file node and Leo2 will
recreate the outline under the @file node (and the body text of the
@file node) based on the (presumably changed) derived file.  Reread All
@file Nodes is like Untangle All.  Without these commands we would have
to Quit Leo (_without_ Saving!) and then reload.  Remembering not to do
a Save would be difficult, so these commands are useful.

BTW, Resave @file Node and Resave All @file Nodes commands would not be
useful.  We can write all @file nodes just by saving the outline.  Also,
Reread All @file Nodes is similar, but not the same as, the Revert
command.


So much for design issues.  As I have been working on Leo2 the last
couple of days I realized several things...

1. .leo files need no longer be CVS friendly.  The derived files will be
the significant source files.  Similarly, the file format of .leo files
won't matter much because people are unlikely to want to write
extensions that must understand the format of .leo files.

2. .leo files will be _much_ smaller.  If all @root nodes are converted
to @file nodes only the @file headlines (not even including their body
text) will be written to the .leo file.   So .leo files are likely to
contain only @file nodes and cross-file clones.

3. Derived files could be shared between .leo files.  We would only get
in trouble if two people were editing the same copy of a derived file
with two separate copies of Leo.  CVS could handle this situation as
usual.

4. We could use text derived files to share notes.  For instance the
headlines of leo(CB).leo called diary, milestone, todo and other notes
could be written to a derived file.  So .leo files need not even contain
documentation.

5. Derived files are _both_ outlines and flat files simultaneously.  As
far as Leo is concerned, derived files _are_ outlines.  As far as
compilers or text editors are concerned, derived files are flat.  I'm
just now beginning to realize how cool this is.

For example, we get essentially the same advantages using @file nodes as
we would with the @include directive (This doesn't exist yet, and it
would include one .leo file in another Leo outline).  Cross-file clones
are handled exactly the same, the advantages of @file and @include are
just about identical.

In addition, Leo 2 provides a very effective way of adding outline
structure to _any_ public flat text file.  We can do this provided
only that the file format has some kind of comment convention!  Do you
see how totally cool this is?  For example, if a debugger info file were
text and it had comment conventions we could use Leo2 to organize it!

6. It is possible that the automatic Read on Load and Write on Save code
may be just a little confusing.  Leo2 must issue enough warnings so that
users will always know what is going on, but not too many as to be
annoying.  I'll make sure everything works smoothly before sending you
Leo2.

7. Converting outlines from Leo to Leo2 is straightforward, but I doubt
it can be automated.

a) There is no @unit directive, so all nodes to be generated from an
@file node must be descendants of the @file node.

b) Usually you must use clones if you are going to use code in two
different places, because each definition node must be a descendant of
the node that uses that node.

c) All doc parts must start with @&lt;space&gt; or @doc.

That's all there is too it.

Please let me know what you think.  Are you as excited as I am by this?

Love,

Edward

P.S. The new Leo uses //@ instead of /// for sentinel lines.  Untangle
will fail horribly if you try to Untangle a file containing different
comment delimiters than presently in use.  This is a Leo bug, not a Leo
2 issue, but you should be aware of it.  Make _sure_ you have adequate
backups when using Leo 2, especially when converting files from Leo to
Leo2.</t>
<t tx="T443">What I am beginning to see is that Leo 2 significantly changes the design point of Leo files:

1. .leo files need no longer be CVS friendly.  The derived files will be the significant source files.  Therefore, tnode indices may be compacted whenever the .leo file is written.

This is important because tnodes for children of @file nodes will not be written, and the present read code complains if it finds unused tnodes.  We could just ignore those warnings, but there is no reason to write a huge number of unused tnodes!  One way would be to compact tnode indices, and only write those tnodes that get reassigned. Another way would be for the code that writes vnodes to mark required tnodes, and only write marked tnodes.  I'll have to think more about this.  At present, vnodes are written first, so this way is possible.

2. .leo files will be much smaller than with the old Leo.

3. The derived files could be shared easily between .leo files.  We would only get in trouble if a person were editing the same copy of a derived file with two separate copies of Leo.  That's not likely to happen.

I could keep all my notes, like the diary, milestone, todo-lists and other notes sections of this outline, in a "text" derived file.  Again, this file could be shared by other .leo files.


I shall have to change the format of .leo files somewhat to support cross-file clones.  This can be done in an upward-compatible manner.  vnodes will contain an "xfile" attribute and an "xindex" attribute.  Of course, the xindex attribute must be immutable.  We can just use the full file name for the xfile attribute: there are few enough cross-file clones that we don't have to replace the name with an index into a new table (which would probably have to be in the header).  This keeps the file format similar to the old format.

The read code must resolve cross-file clone references and join all descendant nodes. The read code may create a lookup routine that yeilds a vnode given an xfile name and an xindex.

I changes the Load/Save code as follows:

1.  The tnodes field is set to zero in the header.  This really isn't very useful anymore.  It could be computed, but that would require mirroring the write logic, and I don't want to do that.  The corresponding check in fileInfo::finishOutline has been #ifdef'd out.

2. The write code marks all tnodes whose vnode were written and only writes marked tnodes.  This is simple and effective.  Converting a node to an @file node can cause a large number of vnodes and tnodes to disappear from the .leo file!</t>
<t tx="T444">Created readAll and writeAll.  This simplifies the Load/Save logic.  read and write now return status.  Eventually read and write can be private.

The Load and Save code essentially work.  This involved a bit of trickery in the put(vnode *) routine.  My original try completely flatted the outline!  Fortunately I had a backup.  I must be sure to use the old Leo to make backup copies!

The present Save code writes all tnodes, even though we may not write all of them.  So the read code will warn of those nodes.  This has to be fixed.

Maybe the easiest solution would be to write vnodes first, and mark the tnodes that are really used.  Then we wouldn't write tnodes that haven't been marked.

I am a bit worried that too much is happening behind the scenes on reads and writes.  Perhaps log messages should be written when an @file node causes a file to be updated.</t>
<t tx="T445">Revised @node sentinels to include status bits.  I added several getters and setters to the vnode and Commands classes.  Removed @file sentinels: they were redundant.  Revised code to write a child index of zero for the root @node sentinel.  The read code makes sure that the root headline contains @file followed by the name of the file.

The new Read code is so simple I'm wondering why the old Load code ever needed the fileInfo class.  Actually, the Load code _does_ create vnodes on the fly.  But tnodes appear in .leo files after vnodes (I don't know why), so we need a separate pass (fileInfo::finishOutline) to assign tnodes to vnodes.  fileInfo also conceals other data structures, so it seems reasonable.  Maybe a simpler way could have been found, but the code works and I won't change it.

So we will use the old Load code, then make a separate pass over the outline to call atFile::read on all @file nodes.  We may need yet another pass to recreate cross-file clones.</t>
<t tx="T446">Should @node sentinels in derived files contain status bits like expansion/contraction state, clone bit and marked bits?  It would be possible to save this info in another file, say a .lox (Leo eXtention) file.  This would make CVS's job easier.  OTOH, I am reluctant to clutter directories with more files.

For now I'll do the following:

1. Change the format of @node sentinels so they contain a "status-bit field", delimited by ":" at both ends.
2. Change the read code so it ignores anything unknown in the status bit field.</t>
<t tx="T447">Finishing up the code.  Added code to back out of a read after errors.  Added code to set the comment delim ivars from the global vars.

There were several problems involving block delimiters.  Had to add code to scan for the closing block delim when looking for filenames and headlines.  scanDoc now works properly with block delims.  We must also remove trailing delims from @@directive sentinels.  The code now passes the simple test file with both single-line and block delims.

Created @&lt;&lt; sentinels so untangle doesn't have to figure out whether to insert a refernce into body text.  This actually simplifies the code and doesn't significantly alter the derived file.  Indeed, it is now absolutely clear what is happening in the derived file.

The read/write code now works on the Leo2 version of atFile.cpp itself.</t>
<t tx="T448">Fixed inAtOthers so it checks for @others in body text.

Changed scanText so it outputs a section reference only within body sentinels.

Created a memory stream when we see an @+body sentinel and copied the memory stream to a string when we see the matching @-body sentinel.  Checked for duplicate definitions at the time we write the body into the tnode.</t>
<t tx="T449">Another Aha!  We can use the following convention to determine where putDocPart has inserted line breaks: A line in a doc part is followed by an inserted newline if and only if the newline if  preceded by whitespace.  This is a really elegant convention, and is essentially invisible to the user.

This works as follows.  Tangle outputs words until the line would become too long, and then it inserts a newline.  But in order to preserve all whitespace, tangle always includes the whitespace that terminates a word on the same line as the word itself.  So split lines always end in whitespace.  Therefore, to make this convention work, tangle only has to delete the trailing whitespace of all lines that are followed by a "real" newline.

This convention has the following benefits:

1. The convention is largely invisible: long lines are indicated in the derived file only be trailing whitespace.
2. As the result of the convention, untangle will remove trailing whitespace from all documentation lines (that is, paragraphs) in the outline.  This is completely harmless, even useful.
3. It is easy to program this convention: the code already is solid.
4. The convention is safe: if the user removes trailing whitespace from a doc part inside the derived file the only result is that untangle will insert an extra newline into the outline.  This extra newline will be inside a doc part and will be harmless.

It is now clear that untangle can handle whitespace perfectly in all situations.</t>
<t tx="T450">Rewrote the code that scans the @+leo line: we can not call sentinelKind because that uses the sentinel delimiters we are in the process of setting.</t>
<t tx="T451">This is the most elegant code I've ever written.</t>
<t tx="T452">A big breakthrough: putSentinel always puts _both_ leading and trailing newlines.  This simplifies everything: no "extra" calls to onl() ever appear in tangle.  Also, we eliminate _all_ conditional code:  we never test for "insignificant" whitespace.  You get whatever is present in the outline.</t>
<t tx="T453">@nocolor

For about 5 years I have been wanting to embed outline structure within
derived files (like .c files). The phrase is: Tangle on Write/Untangle
on Read.  Special "sentinel" lines (similar to the lines Tangle now
writes) could be embedded into the derived files so that the Read
command can recreate the Outline.  This would be very nice because
no separate Tangle/Untangle commands would be necessary: derived files
would _be_ the outline.

Last week I had several Aha's about how to actually do this.

1. I had been worried about Read/Write errors.  Clearly, we don't want
dozens of alerts popping up while reading and writing.  I finally
realized that Read and Write could put warnings to Leo's log window,
with a "summary" warning dialog at the end of the Read or Write.  The
user could then choose whether to proceed with warnings or to fix the
offending code first.

2. I saw how I could get almost all the benefits of Leo and LP without
using LP at all(!) The new  code looks _exactly_ like ordinary code
except that it can contain section references.  Section _definitions_
are by the outline itself...

Some terminology:  The _definition node_ for &lt;&lt;secion&gt;&gt; contains
&lt;&lt;section&gt;&gt; in its headline.  Nodes that are not definition nodes are
_ordinary nodes_.  Ordinary nodes containing no body text are
_organizing nodes_.  (Organizing nodes can be used freely, they never
affect Tangle or Untangle.)

Let's look at an example of how the "new Tangle" will work.  Suppose a
node N contains a reference to  &lt;&lt;section1&gt;&gt;.  Instead of looking for
body text of the form &lt;&lt;section1&gt;&gt;= in all the body text of the program
(that is, instead of using a symbol table), we just look for the
definition node for &lt;&lt;section1&gt;&gt; among N's descendents (children,
grandchildren, etc.) In effect, the outline becomes the symbol table! 
This is super simple.

Another clever idea: the @others directive.  Suppose @others appears in
the body text of node N.  Then @others refers to the concatenation of
the body text of all descendents of N that are not defintion nodes or
descendents of defintion nodes.

For example, consider an outline with the following headlines

@file filename  (the root of the outline)
  node A
    &lt;&lt;section1&gt;&gt;
      node C
    node B1
    node N (an organizing node containing no body text).
      node B2

@others in node A refers to the body text of nodes B1 and B2.  @others
in &lt;&lt;section1&gt;&gt; refers to the body text of node C.

The @others directive saves lots of routine typing.  For example, the
body text at the root of a typical C++ file would be something like:

@file filename.cpp
&lt;&lt;includes&gt;&gt;
&lt;&lt;declarations&gt;&gt;
@others

The descendents of this node would be nodes whose headline is the name
of the method and whose body text would be plain C++ code!  There is no
more need for @code, @doc or lines like &lt;&lt;section&gt;&gt;=.

The reason why these simplifications are important is that a) they
remove a lot of tedious typing and b) they make Tangle On Write/Untangle
on Read feasible.</t>
<t tx="T454">The following are unedited letters sent to my brother, David Speed Ream, known as Speed, during the time that I was actively designing Leo2.

These letters may be the best way to understand the exact chronology of ideas, as they have not been edited in any way.  They are also very clear discussions of ideas that may have been changed later.

The correspondence continued after 7/9/01 with minor discussions.  That correspondence has not been included.</t>
<t tx="T455">I believe I have discovered how to get almost all the benefits of Leo
without using literate programming! The enclosed .leo file contains
documentation and examples of the "new" Leo.

In the new Leo the position of code in the outline corresponds to the
position of the code in the derived file.  This simplification is
usually the best and easiest way to get the job done.  OTOH, it means
that it is not possible to "rearrange" code as was possible with the
"old" Leo.  It also means (obviously) that Leo code is no longer
independent of its position within the outline.

The new Leo is important for two reasons:

1. It's easier to create Leo outlines.  Most of the time you don't need
@code or &lt;&lt; section &gt;&gt;= lines: you just write code.  The new @others
directive tells where to put code that doesn't have a section name. 
@others is an inspired invention, if I do say so myself.  The section
called Leo2 Prototype code gives an example of the new style of
programming.  Converting from old style to new style was very easy:
basically there is a lot less to type and everything "just works".

2. It should be possible to do Tangle-On-Write/Untangle-On-Read!!  I
wouldn't bother simplifying Leo if it weren't for this breakthrough. 
The section called "Overview of tangle-on-write" discusses how
everything will work.  I'm 95% certain that there are no gotcha's left. 
I am about to add two new experimental commands, New Write and New Read,
to a copy of Leo.  If these work I'll then the dream I've had for more
than 5 years will be a reality.

Tangle-On-Write/Untangle-On-Read is important because people will be
able to use Leo without changing their workflow in any way.  There is no
longer any need for separate .leo files and separate Tangling and
Untangling steps: everything will just work.  The only changes will be
additional sentinel lines in derived files and section references in
body text. Users will never have to write @doc or @code.

Let me know what you think.</t>
<t tx="T456">Perhaps it is just as well that you lost my previous email about the
"new Leo"; it wasn't all that clear, and things have changed a little.


Overview

1. The new Leo supports "Tangle on Write/Untangle on Read".  I'll call
these Read/Write for short, as distinct from the old Tangle/Untangle
commands and also distinct from the Load/Save commands.

When you Save an outline, all nodes in the outline with @file in the
headline get written using the new Write logic and only the @file node
(with no body text) gets saved in the outline.  When you Load an
outline, any @file node in the outline gets recreated using the new Read
code.

The outline code in remains the same, clones work as before, etc. 
However, the Load/Save code will change to handle @file nodes.  Clones
are handled differently by the Load/Save logic, but after Load recreates
clones everything works as before.  I'll say more about clones below.

2. The Write code is different for @file nodes than in the old Tangle
commands. (I haven't decided whether to keep the old Tangle/Untangle
commands.  They could remain, though it seems strange to support two
different ways of doing the same thing).

For @file nodes and their descendants the position of code in the
outline matters a bit more than in the old Leo.  This greatly simplifies
the new Read code, and it means that it is not possible to "rearrange"
code quite as freely as was possible with the "old" Leo.  In practice,
though, these new restrictions do not seem to matter at all.  In fact,
they are useful: the outline provides a natural scoping mechanism.


The New Source Language

Here is what you will write, but first some terminology:

Nodes with @file filename in the headline are _@file nodes_. Nodes with
&lt;&lt;section_name&gt;&gt; in their headlines are _definition nodes_. Nodes that
are neither @file nodes nor definition nodes are _ordinary nodes_. 
Ordinary nodes with no body text are _organizer nodes._  _@others_ nodes
contain the @others directive in its body text. @others nodes may be
ordinary nodes.

1. If body text of a node N contains a section reference, then the
definition of that section must appear in definition node that is a
descendant of node N.

2. All nodes are assumed to contain code by default: there is no need to
add @code or &lt;&lt;section_name&gt;&gt;= at the start of nodes.  Indeed, the
&lt;&lt;section_name&gt;&gt;= syntax no longer exists.  If you want to create a doc
part, you start the doc part with @&lt;space&gt; or @doc and end the doc part
with @code.

3. There are no escape conventions.  Any line that contains &lt;&lt;text&gt;&gt;
_is_ a section reference. In practice this is not a problem: you can
always split lines to avoid "false" section reference.  And the Write
code will warn about the undefined section so it is not possible for
code to fail silently.

Also, any line that starts with @&lt;space&gt; @doc or @code (no leading
whitespace permitted) delimits code and doc parts.  

4. There is a new feature, the @others directive.  If a node N contains
@others in its body text, the Write code replaces @others by the
expansion of all descendants of N that are neither definition nodes nor
descendants of definition nodes nor @others nodes nor descendants of
@others nodes.  In effect, @others stands for "everything else".

For example, an @file node would typically end with an @others
directive.  In the old Leo, you would typically put &lt;&lt;methods&gt;&gt; in the
last line of the an @root node, and start each method with
&lt;&lt;methods&gt;&gt;=.  In the new Leo, the @others directive in the @file node
means that all nodes that are neither definition nodes or descendants of
definition nodes become the expansion of the @others in the @file node. 
There is no need for &lt;&lt;methods&gt;&gt;= lines throughout the file!

BTW, more than one node may contain @others directives.  The expansion
of @others does not include the expansion of child @others nodes or the
descendants of such nodes.

4. In short, the new language is just about the simplest possible
literate programming language. In particular, plain code in an ordinary
node is legal, provided an @others directive exists in an ancestor node.


The Format of Derived Files

Just as with the old Leo, derived files must contain sentinel lines
that provide information to the Read code.  Sentinel lines are comment
lines with a particular format.  Starting sentinel lines have the form
&lt;d&gt;@+&lt;tag&gt; where &lt;d&gt; is the comment delimiter for the target language
and &lt;tag&gt; is the name of the sentinel.  For example, a derived file for
the C language starts with:
  //@+leo

Ending sentinel lines have the form &lt;d&gt;@-&lt;tag&gt;.  Derived files for the C
language end with:
  //@-leo

Unpaired sentinel lines have the form &lt;d&gt;@&lt;tag&gt;.  For example,
//@verbatim means that the following line is not a sentinel line even
though it looks like one.

The @+leo sentinel specifies the comment delimiters: everything before
@+leo is the opening comment delimiter and everything after @+leo is the
closing comment delimiter.  If the closing comment delimiter is empty,
single-line comments are used.  Otherwise block comments are used. 
Single-line comments are preferred.

The new leo embeds more structure into sentinel lines than does the old
leo.  Most sentinels are paired:  @+node/@-node delimit nodes,
@+body/@-body delimit body text, @+doc/@-doc delimit doc parts and
@+others/@-others delimit the expansion of the @others directive.

Some of these sentinels may seem redundant, but they are not.  It turns
out that we need @+body/@-body to tell whether a node is an organizing
node (with no body text) or an node that contains only a single
reference.  In any event, using all these sentinels makes the Read code
straightforward.

As I said on the phone, a key aha in designing these sentinels was that
sentinels lines include both the preceding and trailing newlines. 
Therefore, it is always clear exactly where sentinel lines begin and
end.  More importantly, it is always clear where body text and doc
parts begin and end. There is no need for the (!newline) kludge in the
old untangle code.  Everything just works: whitespace goes where it is
supposed to.


Cross-file clones

In the new Leo a cross file clone is a _set_ of cloned nodes, some of
which are contained in the descendants of an @file node and some of
which are outside the @file node's tree.  The nodes that are descendants
of the @file node are the master clones, the nodes outside the @file
tree are the slave clones.

As I said earlier, outline code itself remains unchanged in the new
leo.  Clones are represented within vnodes exactly as before.  However,
the Save and Load code must take care to handle clones properly.

The Save code does the following:  It represents master clones with an
immutable clone index kept in @+node sentinel lines.  It represents
slave clones as a filename and and the same immutable clone index.  The
.leo file format will have to change to represent such slave clones. 
The details don't matter here.

The Load code uses the information created by the Save code to recreate
the clone links found in the vnodes.  This should be relatively
straightforward.  As I mentioned on the phone, the key is what to do
when links are broken, that is, when the filename in slave clones no
longer exists.  This can be handled with a combination of multiple
errors sent to the log window followed by a single error dialog.


Examples

I've included test.leo and test.c.  test.leo contains the present
read/write code and the first test program I used.  test.c is the
derived file.  Read recreates the outline perfectly.

Let me know what you think.

</t>
<t tx="T457">Another big breakthrough today.  As you pointed out, we must split @doc
parts into lines so that comment lines do not become too long.  So
tangle must insert line breaks sometimes.  The question is: what
convention should be used so that untangle can figure out exactly which
newlines were inserted by tangle?

Today I came up with a really clever solution.  The convention is: a
newline has been inserted by tangle in a doc part if and only if it is
preceded by whitespace.

This works as follows.  Tangle outputs words until the line would become
too long, and then it inserts a newline.  But in order to preserve all
whitespace, tangle always includes the whitespace that terminates a word
on the same line as the word itself.  So split lines always end in
whitespace.  Therefore, to make this convention work, tangle only has to
delete the trailing whitespace of all lines that are followed by a
"real" newline.

Do you see how clever this is?

1. The convention is largely invisible: long lines are indicated in the
derived file only be trailing whitespace.
2. As the result of the convention, untangle will remove trailing
whitespace from all documentation lines (that is, paragraphs) in the
outline.  This is completely harmless, even useful.
3. It is easy to program this convention: the code already is solid.
4. The convention is safe: if the user removes trailing whitespace from
a doc part inside the derived file the only result is that untangle will
insert an extra newline into the outline.  This extra newline will be
inside a doc part and will be harmless.

I believe this is the last piece of the puzzle.  It is now clear that
untangle can handle whitespace perfectly in all situations.</t>
<t tx="T458">You won't believe this.  I converted atFile.cpp (the read/write code) to
Leo2 format and apart from two trivial errors the read/write code worked
perfectly the first time.  Amazing.  This code is so solid.

I have now to integrate the read/write code into the Load/Save commands,
and add support for cross-file clones.  Everything should work within a
week.

I now prefer to use @&lt;space&gt; to introduce doc parts and @c to switch
back to code parts.  I am going to retain @doc and @code in case
somebody wants to generate CWEB code (which uses @space and @c), but
ignoring @&lt;space&gt; and @c in CWEB mode will take extra code.

It is a bit eerie to see so much plain code: most nodes don't use @code
and no nodes use &lt;&lt;section&gt;&gt;=.  I've changed the syntax colorer to start
in @code mode.  @others really works.  This is so cool.

BTW, while writing atFile.cpp the write code complained that a section
did not exist.  Turns out it was in the wrong spot, so you could say
that the new Read code found a (minor) error.

Love,

Edward

P.S. I would send the Leo 2 version of atFile.cpp to you, but it
wouldn't look right unless I sent you the app itself with the new syntax
colorer.  Tell me if you want to have a look.</t>
<t tx="T459">Cool Edward.  I only have the one comment below.

&gt; You won't believe this.  I converted atFile.cpp (the read/write code) to
&gt; Leo2 format and apart from two trivial errors the read/write code worked
&gt; perfectly the first time.  Amazing.  This code is so solid.

In my experience, this should not be possible.  Please go back and rewrite
the code until you get numerous substaintial errors upon your first attempt.</t>
<t tx="T460">I'm amazed that the new Leo has been so easy to do.  Here are the
important steps along the road.  All quotes and dates are either from my
engineering notebook or my programming diary. (I'll spare you the
longer quotes.) It is really a treat to do historical work on my own
life.

1. The key factor was really wanting to do
Tangle-On-Write/Untangle-On-Read.  At a certain point I made up my mind
that @file was important to do, and that I was willing to accept the
fact that derived files might be corrupted by mistake.  The creative
process probably started about 5/22/01.  In my engineering notebook I
wrote on 5/22/01: "Maybe it is time to withdraw, not retire." (I was
talking about withdrawing from routine tasks.)

Leo's limitations played a significant part in this decision.  Explicit
Tangle and Untangle commands are clumsy, and Untangle will never be as
robust as I would like.  More importantly, .leo files in the old Leo are
the primary source files, which is not compatible with how most people
presently work.  The new Leo is significantly more compatible with
people's work flow. 

2. Customers had been asking for an @include command that would include
one .leo file into another. So I had been thinking about cross-file
clones. I began to feel that they could not be a major stumbling block.

3. Somehow by 5/30/01 I had begun thinking in earnest about the new
Leo. The term "Leo2" first appears in my notes on that day.

The most important step in moving Leo2 forward may have been using the
old Leo to prototype the new.  On 5/30/01 I created an outline
containing Python code to express a prototype version of
Tangle-On-Write/Untangle-On-Read.  The Read logic was what I focused
on.  Even in Python, this prototype was much more complex the the final
code: many simplifications had not been invented.  The whole process was
murky at this point, as were all details of the target language.

What was _not_ murky was that the new _source_ language (simplified
noweb) was a big win.  I was using the old syntax colorer, so I couldn't
omit @code from nodes without doc parts, but it was immediately clear
that using the tree to form a scope for section definitions was going to
work really well.  This prototyping process reminded me of the day in
March 1996 when I prototyped the old Leo using MORE.  I invented the
@others during this initial prototyping so that I didn't have to allow
sections to be defined in more than one place.  I immediately saw that
@others was important: we can get rid of all &lt;&lt;name&gt;&gt;= lines.

I went though the prototype outline, replacing &lt;&lt;name&gt;&gt;= with @code, and
noting that most of these @code lines would go away if the syntax
colorers started out in code mode by default.  The result was very
exciting.  The actual python code was not of much value, except as spur
to my subconscious to begin designing a simplified Read code.

With so much simplification I began to wonder whether it might be
possible to eliminate _all_ escape conventions.  These conventions are a
major pain anyway, they don't work well for the user and they greatly
complicate both Read and Write.  On 6/6/01 I had definitely decided not
to use any escape conventions.

4. By 6/2/01 things had become much more clear.  My programming diary
for 6/2/01 shows that I was well along in designing the new Write code.

I understood what the Load and Save commands would do.  This had not at
all been clear before. Save writes all @file nodes using the new Write
code..  Load recreates all @file nodes using the new Read code.  The
outline code remains unchanged.  Saving and restoring clone links, etc.
is the responsibility of the Write and Read code.

The Aha that Leo could handle multiple errors with a single error dialog
which follows multiple log messages was supremely important.  In
retrospect, I had been resisting Tangle-On-Write/Untangle-On-Read
because of vague fears.  This Aha clarified what I was afraid of; it
gave me confidence that the Read and Write code would never become
bogged down in errors.  I began to work on the Write/Read code in
earnest.  I started with the Write code, with the Read code in the back
of my mind.

I had created the createNthChild and putOpenSentinels algorithms. 
createNthChild is important because @node sentinels appear in the
derived file in an order different from the the order that the
corresponding nodes appear in the outline.  I first had to realize that
there was a problem.  The putOpenSentinels algorithm creates the
structure of @node sentinels sufficient to recreate the outline.

5. A big Aha on 6/15/01: sentinels must include two newlines. At this
point it became clear that Read could be very robust, an absolutely
essential requirement.  I probably finished the Write code the next day,
on 6/16/01.

After finishing the Write code I immediately began work on the Read
code.  The progress was amazingly fast: the sentinels make the Read code
very easy. The first clean compile and link of the Write code was
6/17/01.  My programming diary for that day says "This is the most
elegant code I've ever written."

I made minor changes to the sentinels.  I also firmly resolved to use
"redundant" sentinels wherever they would clarify the structure of the
derived file.  This turned out to be a very good choice; in fact, none
of the sentinels are truly redundant and they all simplify the Read
logic and clarify the derived file.

This last point is important.  The present sentinels make processing a
derived file absolutely trivial.  This means that it would be easy to
create filters that process derived files, say to convert it to XML
format or to remove sentinels.

6. Another Aha on 6/23/01: we can use trailing whitespace to denote
inserted newlines in doc parts was important.  This ensures that
a) doc parts in the derived files will look very good.
b) putDocPart and scanDoc are simple and robust.

7. At first I tried to generate section references indirectly using the
Read code for @+node sentinels.  Testing showed that this couldn't work
simply.  So I added @&lt;&lt;section_name&gt;&gt; sentinels on 6/26/01.  The Read
code translates these sentinels into the original section references.
This simplifies the Read code.  More importantly, it is now clear in the
derived files exactly where section references will be recreated.

The Read and Write code now work on the New Leo version of atFile.cpp
itself.  I have also added a new syntax colorer for C++. I expect to be
"eating my own dog food" with the new Read and Write routines within
days.  The big news is that debugging was trivial: essentially
everything "just worked."</t>
<t tx="T461">The new Read/Write code appears solid.  I'll do a definitive test soon.

I'm about to add support for cross-file clones to the .leo file format
and @node sentinels in the derived file.  I'll send you the new Leo
after the file formats are completely stable.  I think the design issues
related to clones have been handled, but we shall see.

I've been busy integrating the Read/Write code into the Load/Save
commands.  The actual coding has been routine, but several interesting
user interface issues have arisen that I would like to discuss with you
here.  Comments appreciated as always.

1. File errors.  Suppose that @file path/filename appears in an outline,
but that path does not exist.  We can not write the derived file.  We
could prompt the user for a valid path or we could just write the entire
@file tree to the .leo file.  I like the second option: we issue a
warning and go on without endangering any data.  The big advantage is
that the user doesn't have to fix anything in order to save the file.

2. @ignore.  There is some doubt about what this should mean.  In the
old Leo, @ignore affected Tangle and Untangle but not (obviously) Load
and Save.  In the present version of the new Leo, @ignore also affects
Load and Save.  If an @file node appears in the scope of an @ignore
directive the @file node is neither written nor read.

It would also be possible to say that @ignore only affects Tangle and
Untangle, and to always honor @file nodes.  Both ways have some
advantages, but I favor having @ignore apply to @file nodes.  It seems
natural to me.  What do you think?

3. Reread commands.  Leo needs two new commands: Reread @file Node and
Reread All @files Nodes.  Reread @file Node is very much like the
Untangle command: the current vnode must be an @file node and Leo2 will
recreate the outline under the @file node (and the body text of the
@file node) based on the (presumably changed) derived file.  Reread All
@file Nodes is like Untangle All.  Without these commands we would have
to Quit Leo (_without_ Saving!) and then reload.  Remembering not to do
a Save would be difficult, so these commands are useful.

BTW, Resave @file Node and Resave All @file Nodes commands would not be
useful.  We can write all @file nodes just by saving the outline.  Also,
Reread All @file Nodes is similar, but not the same as, the Revert
command.


So much for design issues.  As I have been working on Leo2 the last
couple of days I realized several things...

1. .leo files need no longer be CVS friendly.  The derived files will be
the significant source files.  Similarly, the file format of .leo files
won't matter much because people are unlikely to want to write
extensions that must understand the format of .leo files.

2. .leo files will be _much_ smaller.  If all @root nodes are converted
to @file nodes only the @file headlines (not even including their body
text) will be written to the .leo file.   So .leo files are likely to
contain only @file nodes and cross-file clones.

[Note: this point turned out to be totally wrong]

3. Derived files could be shared between .leo files.  We would only get
in trouble if two people were editing the same copy of a derived file
with two separate copies of Leo.  CVS could handle this situation as
usual.

4. We could use text derived files to share notes.  For instance the
headlines of leo(CB).leo called diary, milestone, todo and other notes
could be written to a derived file.  So .leo files need not even contain
documentation.

5. Derived files are _both_ outlines and flat files simultaneously.  As
far as Leo is concerned, derived files _are_ outlines.  As far as
compilers or text editors are concerned, derived files are flat.  I'm
just now beginning to realize how cool this is.

For example, we get essentially the same advantages using @file nodes as
we would with the @include directive (This doesn't exist yet, and it
would include one .leo file in another Leo outline).  Cross-file clones
are handled exactly the same, the advantages of @file and @include are
just about identical.

In addition, Leo 2 provides a very effective way of adding outline
structure to _any_ public flat text file.  We can do this provided
only that the file format has some kind of comment convention!  Do you
see how totally cool this is?  For example, if a debugger info file were
text and it had comment conventions we could use Leo2 to organize it!

6. It is possible that the automatic Read on Load and Write on Save code
may be just a little confusing.  Leo2 must issue enough warnings so that
users will always know what is going on, but not too many as to be
annoying.  I'll make sure everything works smoothly before sending you
Leo2.

7. Converting outlines from Leo to Leo2 is straightforward, but I doubt
it can be automated.

a) There is no @unit directive, so all nodes to be generated from an
@file node must be descendants of the @file node.

b) Usually you must use clones if you are going to use code in two
different places, because each definition node must be a descendant of
the node that uses that node.

c) All doc parts must start with @&lt;space&gt; or @doc.

That's all there is too it.

Please let me know what you think.  Are you as excited as I am by this?

Love,

Edward

P.S. The new Leo uses //@ instead of /// for sentinel lines.  Untangle
will fail horribly if you try to Untangle a file containing different
comment delimiters than presently in use.  This is a Leo bug, not a Leo
2 issue, but you should be aware of it.  Make _sure_ you have adequate
backups when using Leo 2, especially when converting files from Leo to
</t>
<t tx="T462">You will be happy to know that I found the first real bug in the new
Read/Write code.  Whitespace wasn't written properly after @others.  The
fix was truly difficult: change skip_line to skip_to_end_of_line in the
section called &lt;&lt; handle @others &gt;&gt;.</t>
<t tx="T463">&gt; You will be happy to know that I found the first real bug in the new
&gt; Read/Write code.

Yes, this pleases me a great deal.  I do still feel that you are a bit
behind the bug rate of a truly refined Oxford educated software
elocutionary. A pity, really, that you didn't complete your studies across
the pond.</t>
<t tx="T464">I realized this morning that since a .leo file contains dummy vnodes for
all nodes in a derived file, those dummy nodes can carry clone info!  I
changed one line to make sure that the Write code always writes clone
info in dummy vnodes and voila! Cross-file clones worked!  So Leo2 could
be called complete!

The present scheme is extraordinarily elegant, and I'd like to discuss
some issues with you.  Some of these are pretty important, and I hope
you will reply ASAP.  (The sooner you reply, the sooner you get Leo2!)

1. Mirroring can fail spectacularly.

Everything depends on the fact that a .leo file mirrors the structure of
the derived files in so-called dummy vnodes.  I believe there can be no
problems long as you follow these three rules:

Rule 1: Use only Leo2 to edit .leo files created by Leo2.
Rule 2: Don't mess with sentinels in derived files, and
Rule 3: Generate each derived file from a single .leo file.  (The
converse is not required: a single .leo file can contain many @file
nodes without violating this rule.)

As long as you follow these rules, I don't believe you can mess things
up even if you tried, for example, by renaming @file nodes, etc.

Alas, Rule 3 is pretty restrictive.  If we "innocently" break Rule 3 we
will be in trouble.  For example: Write the derived file f from A.leo. 
Read the file in B.leo, alter the structure of the derived file in the
outline, then write the file from B.leo.  The mirroring will break when
we read the derived file in B.leo.

We could try to recover by replacing the entire tree for f in B.leo with
@file f, then saving B.leo, thereby clearing all dummy vnodes. When we
reread B.leo the derived file will be fully restored under @file f, but
all orphaned or @ignored nodes under @file f will be lost.

Whenever mirroring is broken it will likely create dozens or hundreds of
mismatches between what the Read code expects to see in the outline and
what it actually does see.  This can cause data loss: the Read code can
end up replacing @ignored or orphaned nodes.  Usually the sane course of
action will be to recover from backup files.

Question:  I modified the old Leo to handle the new file format, partly
to make sure the dummy vnodes were being written properly.  I could
enforce Rule 1 by officially changing the file format from version 1 to
version 2 so that no old version of Leo could handle any new .leo file,
but that seems drastic.  What do you think?

After some debate, I have decided that dummy vnodes in a .leo file
should contain headline text.  This allows createNthChild to raise an
error if there is a mismatch between the headline in derived file and
the headline in the .leo file in the expected position.  If we get one
error we are likely to get many, so I will add code to limit the errors
and issue a summary error at the end of the Read code.

Question:  Am I making too much out of this?  Unless the sentinel lines
are corrupted, the Read code will produce an outline properly, except
for
orphan and @ignored nodes, and except for clone status and minor stuff
like marks.  In practice, I think everything will work perfectly almost
all the time.  Still, Rule 3 is a bit restrictive, and breaking it will
cause pain.  Any comments?  (Also see below.)

2. @include'd files can't use this scheme.

There have been several requests for one .leo file to be able to
@include other .leo files.  We can't mirror the @include'd .leo files
because the user can always edit the @included'd .leo file separately.
In other words, Rule 3 can not be assumed.  I probably would not
implement cross-file clones for @include'd .leo files: clones must be
contained within the same .leo file.

Although this sounds simple, it actually wouldn't be so simple to
enforce, because the user _would_ be able to create such forbidden
clones, at least in the window.  So we either implement the "hard"
cross-file clones or have the Write code issue objections.  I'll
probably leave this for later...I don't think @include is so
important.

3. Clone indices in the derived files are redundant.

It is now possible to remove the cloneIndex field from node sentinels in
the derived file: all that information is now redundant since the .leo
file contains _all_ node attributes.  The more I think about this, the
more I like removing clone indices.

Indeed, there is now a curious kind of dual master/slave relationship
between the .leo file and derived file.  In some sense, the derived file
is the master file, because the .leo file recreates the outline from the
derived file.  OTOH, one expects all structure changes to be done in
Leo2, not in derived file.  Provided Rules 1, 2 and 3 hold we can assume
the following condition always holds:

Condition 1: The structure of the derived file changes only if the
structure of the outline changes.

This being so, one could just as well imagine that it is the .leo file
that is the master file!  In short, one is justified in believing the
following two conditions will always hold:

Condition 2: The structure of the outline under an @file node is the
same as the structure of the file derived from that node.

Condition 3: Nodes are clones in the derived file if and only if they
are clones in the corresponding nodes under the @file node.

All three conditions depend on Rule 3.  OTOH, without Rule 3, _neither_
the .leo file nor the derived file can really be a master!  You might
rephrase Rule 3 this way: no derived file can more than one master .leo
file.  Maybe this only makes the restriction _seem_ more reasonable ;-)

In any event, if these conditions are all true, then we are justified in
treating clone status of nodes in the derived file as being generated
from the .leo file.  In that case, clone indices are not required. There
are pros and cons to this viewpoint.

Cons: clone status then becomes entirely dependent on the outline.  So
clone status becomes a little more error prone.  However, if mirroring
ever fails, we will have thoroughly messed everything up, and we will
have to recover from backups anyway, so this is a moot point.

Pros: we now will rewrite a derived file _only_ if something changes
really, truly, for sure.  Just creating a clone of a node (and moving
the clone outside the @file node) will _not_ cause the derived file to
be rewritten.  And of course the format of @node sentinel lines becomes
simpler.

I would certainly remove clone indices from derived files if I were not
thinking of cross-file clones and @including .leo files inside other
.leo files.  What are your thoughts?

In conclusion, it seems that Rule 3 is the only drawback to the present
implementation.  Notice that the present implementation solves problems
with orphans and @ignored code as well as clones, so I believe that we
should insist on Rule 3.  If people can't handle Rule 3 we would have to
do without dummy vnodes, and that really would be a pity.  We would then
have to issue stern warnings about orphans and @ignore'd nodes under
@file nodes.

I plan to putz with Leo2 for a few a day or so and then send it on to
you.  If you have any strong feelings on these issues please let me know
immediately.

</t>
<t tx="T465">Dates and quotes here are from my engineering notes.  Some of these notes appear in a handwritten notebook.  Others appear in the "Diary" section of LeoCB.leo for June and July of 2001.  (All emphasis are in the original).

5/22/01: "Maybe it is time to withdraw, not retire."

May 30, 2001 was a key date in the New Leo.  Here are some quotes from my morning pages for that day and the next.

5/30/01: "The big question--what to do about Leo?"

This following quote occured in the context of wanting to improve Python browsers.  I was not thinking of a new Leo at that time!

5/30/01: "I seem to be going full circle, or to the scripts way of doing things. 1. A _file view_, which is a _master_ view, and the view _recreated_ from a text file when the text file is read. 2. Other (subsidiary) views.  Unlike Leo clones, these are _slave_ clones. 3. Python forces me to be clear about indentation."

I think that sometime during these morning pages I shifted from considering a Python browser to considering Untangle-On-Read/Tangle-On-Write.

5/30/01: "There is no tangle/untangle!!"

5/30/01: "The editor ensures that all ref nodes exist...Errors can not happen."

This is wrong, but it was a very useful error, because it subconsciously gave me permission to go ahead.  Later, I realized that we can deal with many errors with a single dialog, but at this point I was very converned about errors during reads.

5/30/01:  I started the first design of sentinel lines.  I also looked at cross-file clones at this time.

5/31/01: "Last night I did a prototype of the 'non-LP' verion of Leo.
--It works well.
--@others is especially nice.
--There are the usual issues about scanning for &lt;&lt;name&gt;&gt;"

This shows that I hadn't firmly decided to eliminate escape conventions.

5/31/01: The morning pages has a long discussion of the pros and cons of the new Leo, as well as discussions about clones.  No doubt I was getting excited at this point.  This discussion contains the first mention of the name Leo2.

During the next couple of days I spent a lot of time daydreaming, lying in bed, taking baths, riding my bike, etc.  Major breakthroughs happened.

6/2/01: "I believe I have come up with some simplifying principles that will help with Leo2:
1. Load and Save work on entire files/windows.  Load loads an entire file.  Save saves an entire file.
2. Errors/warnings during read/write are sent to the log window, not typically a dialog.  This is much less disruptive.
...
4. _Summary alerts_ might be useful: the details would be in the log window.
Read errors are essentially benign, they might cause info to be placed in different nodes, but data will never be lost...Write errors have the potential to delete info..."

There is no doubt that at this time I was very excited about the new Leo:

6/2/01: "Let me be clear about one thing: Tangle-on-Write/Untangle-on-Read is a _major_, _major_ improvement...Tangle-on-Write/Untangle-on-Read is the culmination of a _dream_, a _dream come true_."

This day's morning pages contains a lengthy discussion of what I called at the time "tree sentinels".  (The present @node sentinels).  I continued the detailed design of sentinels.  I produced the first draft of what was to become atFile::createNthChild.  I probably created this algorithm during my previous day's bike ride.  createNthChild and putOpenSentinels are the key algorithms in the Read logic.

From 6/2/01 through 6/6/01 I considered many details of how to format the derived file.  I wasn't actually sure that I could expand @others properly, or even section references, for that matter.

6/6/01: "It looks like Tangle is going to all-new.  That's OK. A good time to clean house."

Rewriting the Read/Write logic in a new atFile class turned out to be a very good decision.  The new code is much simpler than the old.

6/6/01: "I think the decision to get rid of _all_ escape sequences is a good one."

6/6/01: "In any case, the major task is to get the recursion [in the Write routines] going."

This was followed by preliminary code fragments from the Write code.

After this there is a lull in my notes.  The next entry is 6/17/01.

6/17/01: "The new Tangle/Untangle code is shaping up to be the most elegant code I have ever written.  I am thrilled an excited.  The breakthrough was that Tangle uses newlines in a consistent way
-- before and after sentinels
-- within doc parts.
This means there are absolutely _no_ special cases for Untangle to consider. Untangle always knows exactly where any element of whitespaces comes from."

6/17/01: "Untangle is looking like it will be _simpler_ than tangle!!"

6/17/01: "Last night I did most of the first draft of Untangle. It was only a few hours of work!"

In this day's morning pages I discussed the organization of what became scanText.  The original code was a bit more confused and complex than the present code.

During these notes I realized I needed nested @at and @doc directives.  This was the last entry in the process of creating Leo.  All other entries are found in my programming diary in this outline.

The following appear in my programming diary:

6/2/01: "For about 5 years I have been wanting to embed outline structure within
derived files (like .c files). The phrase is: Tangle on Write/Untangle
on Read.  Special "sentinel" lines (similar to the lines Tangle now
writes) could be embedded into the derived files so that the Read
command can recreate the Outline.  This would be very nice because
no separate Tangle/Untangle commands would be necessary: derived files
would _be_ the outline.

Last week I had several Aha's about how to actually do this.

1. I had been worried about Read/Write errors.  Clearly, we don't want
dozens of alerts popping up while reading and writing.  I finally
realized that Read and Write could put warnings to Leo's log window,
with a "summary" warning dialog at the end of the Read or Write.  The
user could then choose whether to proceed with warnings or to fix the
offending code first.

2. I saw how I could get almost all the benefits of Leo and LP without
using LP at all(!) The new  code looks _exactly_ like ordinary code
except that it can contain section references.  Section _definitions_
are by the outline itself...

Some terminology:  The _definition node_ for &lt;&lt;secion&gt;&gt; contains
&lt;&lt;section&gt;&gt; in its headline.  Nodes that are not definition nodes are
_ordinary nodes_.  Ordinary nodes containing no body text are
_organizing nodes_.  (Organizing nodes can be used freely, they never
affect Tangle or Untangle.)

Let's look at an example of how the "new Tangle" will work.  Suppose a
node N contains a reference to  &lt;&lt;section1&gt;&gt;.  Instead of looking for
body text of the form &lt;&lt;section1&gt;&gt;= in all the body text of the program
(that is, instead of using a symbol table), we just look for the
definition node for &lt;&lt;section1&gt;&gt; among N's descendents (children,
grandchildren, etc.) In effect, the outline becomes the symbol table! 
This is super simple.

Another clever idea: the @others directive.  Suppose @others appears in
the body text of node N.  Then @others refers to the concatenation of
the body text of all descendents of N that are not defintion nodes or
descendents of defintion nodes.

For example, consider an outline with the following headlines

@file filename  (the root of the outline)
  node A
    &lt;&lt;section1&gt;&gt;
      node C
    node B1
    node N (an organizing node containing no body text).
      node B2

@others in node A refers to the body text of nodes B1 and B2.  @others
in &lt;&lt;section1&gt;&gt; refers to the body text of node C.

The @others directive saves lots of routine typing.  For example, the
body text at the root of a typical C++ file would be something like:

@file filename.cpp
&lt;&lt;includes&gt;&gt;
&lt;&lt;declarations&gt;&gt;
@others

The descendents of this node would be nodes whose headline is the name
of the method and whose body text would be plain C++ code!  There is no
more need for @code, @doc or lines like &lt;&lt;section&gt;&gt;=.

The reason why these simplifications are important is that a) they
remove a lot of tedious typing and b) they make Tangle On Write/Untangle
on Read feasible."
[end of entry for 6/2/01]

6/15/01: "A big breakthrough: putSentinel always puts _both_ leading and trailing newlines.  This simplifies everything: no "extra" calls to onl() ever appear in tangle.  Also, we eliminate _all_ conditional code:  we never test for 'insignificant' whitespace.  You get whatever is present in the outline."

6/23/01: "Another Aha!  We can use the following convention to determine where putDocPart has inserted line breaks: A line in a doc part is followed by an inserted newline if and only if the newline if  preceded by whitespace.  This is a really elegant convention, and is essentially invisible to the user."

6/25/01: "Created @&lt;&lt; sentinels so untangle doesn't have to figure out whether to insert a refernce into body text.  This actually simplifies the code and doesn't significantly alter the derived file.  Indeed, it is now absolutely clear what is happening in the derived file."</t>
<t tx="T466">The following are excerpts from undated notes kept in LeoCB.leo.  Some of these ideas changed during the creative process.  In particular, the distinction betwen errors and warnings finally disappeared entirely.</t>
<t tx="T467">An error is a condition that may cause data to be lost.  A warning is a less serious condition.  Warnings and errors are reported to the log window.  If any errors have been reported a single dialog is raised, giving the user the chance to continue or stop. 

Errors during tangling happen when a section is defined but not used. Ignoring such errors will cause the derived file to be written without data present in the outline.  This data will be permenently lost unless the outline is changed and the derived file rewritten. Errors during untangling happen when more than one reference to a section exist.  The untangle command issues an error if not all sections are identical.

Warnings during tangling arise from undefined sections.  Ignoring such warnings will result in further warnings during untangling.  Warnings during untangling arise as the result in mal-formed sentinels.  Mal-formed sentinels may alter the structure of the outline but can never result in lost data.


</t>
<t tx="T468">The Write code should contain _no_ conditional logic.  Given the choice between "elegant" output or simple logic we _must_ choose simple logic.  Actually, the output of the Write code is good looking.

The key Ahas:

1. putSentinel should output _both_ leading and trailing newlines.
2. The Read code can use trailing whitespace to determine which newlines should be removed.

These conventions are the key to making the Read code robust; they ensure that the Read code can reconstitute whitespace in all situations.</t>
<t tx="T469">Sentinels contain _both_ a preceding and trailing newline.  This was the key Aha in designing the Write command.  Let us see why these are both needed.

It has always been clear that sentinels must include a trailing newline.  Sentinels are comments, typically single-line comments, so if sentinels did not include a trailing newline any following text would be swallowed: it would become part of the comment.  If all languages had block comments we might get rid of this requirement, but Python and shell languages do not support block comments.

The real Aha was that sentinels should include _leading_ newlines.  The old Tangle command output a newline before a sentinel only if one was not already present.  With the new rule we always know exactly where preceding text ends, namely the character before the newline that starts the sentinel.  With the old code, the read code could not be sure whether a newline belonged to the sentinel or not.

The old Tangle used the (!newline) hack.  If (!newline) appeared in a sentinel the newline following the expansion of the section was not inserted into the text.  This was necessary in situations like
	&lt;&lt;do_something&gt;&gt; break ;
The sentinel ending the expansion of &lt;&lt;do_something&gt;&gt; ended with (!newline) to indicate that break ; should appear after the last line of the expansion.  With the new convention everything works without such hacks.</t>
<t tx="T470">We use the following convention to determine where putDocPart has inserted line breaks: A line in a doc part is followed by an inserted newline if and only if the newline if  preceded by whitespace.  This is a really elegant convention, and is essentially invisible to the user.

This works as follows.  The Write code outputs words until the line would become too long, and then it inserts a newline.  But in order to preserve all whitespace, the Write code always includes the whitespace that terminates a word on the same line as the word itself.  So split lines always end in whitespace.  Therefore, to make this convention work, the Write code only has to delete the trailing whitespace of lines that are followed by a "real" newline.

This convention has the following benefits:

1. The convention is largely invisible: long lines are indicated in the derived file only be trailing whitespace.
2. As the result of the convention, untangle will remove trailing whitespace from all documentation lines (that is, paragraphs) in the outline.  This is completely harmless, even useful.
3. It is easy to program this convention: the code already is solid.
4. The convention is safe: if the user removes trailing whitespace from a doc part inside the derived file the only result is that untangle will insert an extra newline into the outline.  This extra newline will be inside a doc part and will be harmless.</t>
<t tx="T471">When a node sentinel is discovered scanText does the following:

We create a new child node of the current node.  The child index field tells where the node is to be placed.  However, section references do not occur in order: earlier siblings may not have been created yet.  To handle this complication we insert "dummy siblings".  The createNthChild method handles these details. We make the new child node the current node and continue.

When the end of the section expansion is found we simply restore the current node.  That's all there is to it!  

There is no need for an @no-newline sentinel.  Tangle will have placed any text following the section reference immediately after newline that ends the @-node sentinel, and scanning will place that after the recreated section reference.  If the line following the @-node sentinel is not blank, then its text must have originally appeared following the reference in the outline.

Note that the code that handles @node sentinels does _not_ create the references to those nodes.  That is handled by @&lt;&lt; sentinels.  The reason is that it is actually difficult to know what reference should be created due to organizer nodes.  Using @&lt;&lt; sentinels simplifies the read logic and clarifies the derived file.</t>
<t tx="T472">Handling @others sentinels is trivial: we simply create the @others text in the current node.  The real work is handled by the nested @node sentinels.</t>
<t tx="T473">Creating doc parts from @+at and @+doc sentinels is easy.  (The two sentinels indicate whether @&lt;space&gt; or @doc delimited the start of the doc part.)

scanDoc scans lines until it sees the matching @-at or @-doc sentinel, removing comment delimiters and removing newlines from lines that do _not_ contain trailing whitespace.</t>
<t tx="T474">A cross-file clone is essentially a link from a .leo file to a derived file. A clone link consists of a full path name and an immutable clone index.  An index is never changed or reassigned, even if a node is deleted. This ensures that clone links can never be broken by changing an index.

In derived files, clone indices are contained in node sentinels.  In .leo files, clone indices are contained in vnodes.  The path names used in clone links get translated to an index.  The leo header will contain a list of path names and file indices.

Clone links can be broken by moving or renaming derived files so that the full file name in a clone link no longer points to a valid file.  The key to making cross-file clones work is designing the process by which links can be repaired by the user.  We might have a "Repair Clone Links" command.  A dialog may also be raised at some point.</t>
<t tx="T475">same-file clones provide an approximation of subroutines.  The &lt;clones&gt; item can support this, along with the clones attribute in &lt;node&gt; items.

The _implementation_ of clones will remain exactly the same in Leo2, that is, once clones are created in the first place.

The problem is that cross-file will contain links that can be broken.  The problem is in designing the user interaction to be used for broken links.  We can't have an endless series of dialogs.  However, we could have an "Ignore All" button on a dialog.  Maybe we will warn about broken links in the log window, but actually try to repair or delete the link only when we actually try to use the broken link.  We also probably would need a mark of some kind in the icon. Maybe we won't have to double the number of icons; there could be a 17th icon that is _only_ used for broken links.

Cross-file links would have some representation of file and node within file.  The obvious is a full path name and a reference to an immutable clone index.  (Once deleted, a clone index should never be used so that creating a new clone would not mistakenly relink a cross-file link to the wrong node.

We might have a "Repair links" command that would bring up a dialog.  This would be fairly smooth.  There might also be an option to change all links to path A to another path.  In fact, this might be all that is needed!</t>
<t tx="T476">The noweb escape conventions for @@ and @&lt;&lt; and @&gt;&gt; have caused trouble in the past.

The @delim directive specifies the sequences that start and stop section references.  The defaults are &lt;&lt; and &gt;&gt;.  (Note: @delim has not been implemented yet).

Leo2 uses no escape conventions: Within a code parts, &lt;&lt;name&gt;&gt; is _always_ a section reference, even if &lt;&lt;name&gt;&gt; appears in a comment or a string.  You must split lines that would otherwise contain "false references".  In practice, that can easily be done.

CWEB is not directly supported by Leo2; only noweb syntax is allowed.  The @noweb and @CWEB directives have no effect in Leo2.  However, it is possible to generate valid CWEB _source_ files using Leo2.  Indeed, the lack of escape sequences make it relatively easy: all CWEB control codes remain unchanged.</t>
<t tx="T477">It would be possible to use an XML-like syntax such as within sentinels. Examples:

//&lt;leo&gt;
//&lt;/leo&gt;

However, this would probably not be a good idea because we can not use XML excapes in plain text.</t>
<t tx="T478">The following documentation applies to @file trees.

@file node:			Node whose headline starts with @file filename.
Named node:			Node whose headline starts with  &lt;&lt;section_name&gt;&gt;.
Unnamed node:		Node that is neither an @file node nor a definition node.
Organizer node:		An unnamed node with no body text.
@ignore node:		Node with an @ignore directive in its body text.
@others node:		Node with an @others directive in its body text.
Orphan node:		Ordinary node that is not part of any section definition.
Directive:			A line of body text that starts with '@'.
Doc part:			Body text from an @&lt;space&gt; or @doc directive to
					the next @c or @code directive.
Code part:			Body text from an @c or @code directive to the
					next @&lt;space&gt; or @directive.
Natural tree order:	The order of nodes would appear on the screen if all nodes
					were expanded.

An @file node forms the root of a tree whose expansion forms a derived file.

The expansion of an @file node or a section definition node is the entire text of the node with all section references replaced by their definition.  Section references is any text containing &lt;&lt;section name&gt;&gt;.  Section references are recognized anywhere within code parts, even within comments or strings.

Definition nodes must be a descendant of the node containing the section reference.  If a section is referenced in more than one node, you may use clones to "copy" the definition to more than one location.

Organizer nodes never affect the generated code, except to produce sentinels.  In particular, organizer nodes do not affect indentation of code in the derived file.

The body text of each node is assumed to start in code mode.  @ or @doc are used to create a doc part.  No escape conventions are used: if a line contains &lt;&lt; followed by &gt;&gt; then everything between the &lt;&lt; and &gt;&gt; becomes a section name.

The @others directive may be used at most once in named nodes and @file nodes.  @others refers to descendant nodes that would not otherwise be included in the derived file. More exactly, the expansion of the @others directive in node N is the set of unnamed descendents of N that are the descendents of no named node or @others node other than N.

Often, a single @others appears at the end of the body text of the @file node.  The expansion of @others is the concatenation of the body text of all ordinary nodes, in natural tree order.

For a more complex example, suppose we have a tree with the following headlines:

  @file name (contains @others in body text)
    &lt;&lt;section1&gt;&gt; (contains @others in body text)
      &lt;&lt;section2&gt;&gt; (contains @others in body text)
         node A1
		 node A2
      node B
    node C1
	node C2
	
The expansion of @others in node &lt;&lt;section2&gt;&gt; is the concatenation of the expansion of the body texts of nodes A1 and A2.  Similarly, the expansion of @others in node &lt;&lt;section1&gt;&gt; is the concatenation of the expansion of the body texts of of node B.  Finally, the expansion of @others in node @file name is the concatentaion of the expansion of nodes C1 and C2.

The derived file corresponding to an @file node is not written if any descendant of the @file node is an orphan. For example, the following outline contains an orphan node:

@file name (no @others)
    &lt;&lt;section1&gt;&gt; (contains @others)
      node A
    node B (orphan node)
	
Leo2 issues a warning when a .leo file is saved if any @file node contains an orphan or @ignored node.

Typically a single @others directive in the @file node suffices.  For example, the body text of the @file node would be something like:

  &lt;&lt; preliminary definitions &gt;&gt;
  @others

Sections may be defined in any descendant of the @file node provided that the method is not a descendant of any definition node.</t>
<t tx="T479">The following is a list of the major differences between the Macintosh and PC versions of Leo.

1.  The PC version does not have a Print (Weave) command. This command is under development.

2.  The PC version implements the Untangle command.  The commercial Mac version will implement the Untangle command but the free Mac version does not.

3.  The PC version uses an XML file format.  The commercial Mac version will use the same format.  The free Mac version uses an entirely different format.

4.  The PC version implements clone windows; the Mac versions don't.

5.  Syntax coloring is partially customizable when using the PC version of Leo.  However, at present it is not possible to fully save these options.

6.  The Preferences panel is functional in the PC version.


</t>
<t tx="T480">The commercial Mac and PC versions of Leo will use the same file format, so nothing special will need to be done to transfer files between these two versions.  Transfering information between the commercial PC version and the free Mac version is relatively straightforward.

1. Create a text file in MORE format.

On the Mac, simply copy an outline in Leo and paste into a text file.  I use the Metrowerks IDE to create the text file because it handles newlines properly, but almost any text editor will do.  Use the text editor to create the text file.

On the PC, use the Export More Text command, then paste the text into any text editor and use the text editor to create the file.

2. Transfer the text file to the other machine.

3. Create an outline using the text file created in step 1.

On the Mac, load the text file into a text editor.  Select all the text and copy it to the clipboard.  In Leo, choose the Copy Outline command to create the outline.

On the PC, load the text file into a text editor.  Select all the text and copy it to the clipboard.  In Leo, choose the Import More Text command to create the outline.
</t>
<t tx="T481">Sherlock is a flexible tracing and measurment package for C, C++ and Objective C.  All parts of Sherlock are in the public domain.

You will see Sherlock macros throughout my C++ code.  The most common of these macros are FTAG, STATB, STATX, TRACEP, TRACEPB and TRACEPX.  These Sherlock macros are not functional in the production version of Leo.

Full documentation for Sherlock can be found at:
	http://personalpages.tds.net/~edream/sl_index.html</t>
<t tx="T482">This Appendix describes Leo's file format.  Most users of Leo can skip this appendix.  This technical information will be of use only to those wanting to process Leo files with special-purpose filters.

Leo's uses XML for its file format.  The following sections describe this format in detail.  The last node gives an example, and it will be useful to refer to this example frequently.

In the description below sss denotes a string with the XML escapes for the &amp; &lt; and &gt; characters:

&amp; becomes &amp;amp;
&lt; becomes &amp;lt;
&gt; becomes &amp;gt;

This translation is performed on any text that could contain the &amp; &lt; or &gt; characters.

For those of you who grok DTD's a preliminary DTD for Leo's XML follows.  This DTD is under development and may contain syntax or semantics errors.  It may also simply be inaccurate.

The format of Leo2 .leo files is very similar to the format of Leo1 .leo files.  The major differences are:

1.  Leo1 .leo files have file version 1.  Leo2 .leo files have file version 2.  This allows Leo1 to issue an important warning if a version 2 file is opened.

2.  vnodes in Leo2 .leo files contain a new cloneIndex field, which records the immutable clone indices found in derived files.

3.  vnodes in Leo2 .leo files contain a new attribute byte, the "orphan" attribute.

In all other respects Leo1 and Leo2 .leo files are identical. Leo1 can open Leo2 files, but Leo1 ignores all information unique to Leo2.  However,  Leo1 treats @file nodes as regular outline nodes: Leo1 neither reads derived files when outlines (.leo files) are loaded nor writes derived files when outlines are saved.
</t>
<t tx="T483">Leo files start out with the following line declaring the format to be formatted as a type of XML.

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</t>
<t tx="T484">The &lt;leo_file&gt; tag opens an element that contains the entire file. The &lt;/leo_file&gt; tag at the end of the file ends this element.

The following sections describe the elements that may appear between the &lt;leo_file&gt; tag and the &lt;/leo_file&gt; tag.  These elements must appear in the order given.  However, the clone_windows element is optional.
</t>
<t tx="T485">The file header element specifies information used to parse the file or to allocate data structures needed to read the file.  The header starts with &lt;leo_header and ends with /&gt;  In between are the following four required attribute fields.

file_format="1" indicates the version number of the file format: 1, 2, 3, etc.

tnodes="2" indicates the number of tnodes that appear in the file.

max_tnode_index="2"	indicates the largest tnode index.

clone_windows="0" indicates the number of clone windows specified by the file.

I'll say more about tnodes later.
</t>
<t tx="T486">The globals element specifies information relating to the entire file.  This element starts with the following the &lt;globals body_outline_ratio="0.50"&gt; tag and ends with &lt;/globals&gt; tag.

The body_outline_ratio attribute specifies the ratio of the height of the body pane to the total height of the Leo window.  It initializes the position of the splitter separating the outline pane from the body pane.

In between the &lt;globals...&gt; tag and the &lt;/globals tag&gt; are the following two elements.  These specify the position of the Leo window and Log window in global coordinates:

&lt;global_window_position top="27" left="27" height="472" width="571"/&gt;

&lt;global_log_window_position top="183" left="446" height="397" width="534"/&gt;
</t>
<t tx="T487">The preferences element specifies the preferences that the user can change using the Preferences command.  It starts with the &lt;preferences...&gt; tag and and ends with &lt;/preferences&gt; tag.

The following three attributes may appear before the &gt; that ends the &lt;preferences...&gt; tag.

allow_rich_text="1"
tab_width="4"
page_width="132"

At present the "Allow Rich Text" option is non-functional.

Following the &lt;preferences...&gt; tag is the following element.

&lt;syntax_prefs&gt;sss&lt;/syntax_prefs&gt;

The sss string encodes the settings of the TSyntaxMemo component used for body text.  This string is simply passed to and from TSyntaxMemo and is not used by Leo in any other way.  Future versions of TSyntaxMemo will allow more settings to be encoded, and those settings will appear between the &lt;preferences...&gt; and &lt;/preferences&gt; tags.
</t>
<t tx="T488">The find_panel_settings element specifies the settings of the Find panel at the time the file was saved.  This element starts with the &lt;find_panel_settings...&gt; tag and continues until the &lt;/find_panel_settings&gt; tag.

Zero or more of the following attributes may appear before the &gt; that terminates the &lt;find_panel_settings...&gt; tag. Leo writes these attributes in the order shown, but they may appear in any order.

whole_word="1"
search_body="1"
whole_word="1"
ignore_case="1"
pattern_match="1"
search_headline="1"
search_body="1"
suboutline_only="1"
mark_changes="1"
mark_finds="1"
reverse="1"

The default for all attributes is "0" (unchecked check box) and an attribute is written only if is "1" (check check box).

The following elements appear after the &lt;find_panel_settings&gt; tag and before the &lt;/find_panel_settings&gt; tag.

&lt;find_string&gt;sss&lt;/find_string&gt;
&lt;change_string&gt;sss&lt;/change_string&gt;

The sss strings indicate the find and change strings in the Find panel.  Either sss string may be empty.  Both sss strings are encoded with the usual XML escapes.
</t>
<t tx="T489">The vnodes element specifies the list of so-called vnodes of an outline.  

The vnodes element starts with &lt;vnodes...&gt; and ends with &lt;/vnodes&gt;.  In between these tags are one or more v elements.
</t>
<t tx="T490">The v element represents a single vnode and has the following form:

&lt;v...&gt;&lt;vh&gt;sss&lt;/vh&gt; (zero or more nested v elements) &lt;/v&gt;

The vh element specifies the headline text.  As usual it starts at the &lt;vh&gt; tag and continues until the &lt;/vh&gt; tag.  sss is the headline text encoded with the usual XML escapes.

As shown above, a v element may contain nested v elements.  Each vnode corresponds to a headline on the screen, and vnodes are written to the file in the order they would appear on the screen if all headlines were fully expaned.

The nesting relationship between vnodes gives the outline structure.  v elements for child vnodes are nested within the v elements of parent vnodes.  Therefore, the outline level of a v element is the number of unclosed v elements containing it.

Zero or more of the following three attributes may appear before the &gt; that terminates the &lt;v...&gt; tag.

t="T23"
vtag="V18"
a="xxxx"

The t="Tnnn" attribute specifies the tnode associated with this vnode.  (See the section describing the &lt;t&gt; tag for more details.

The vtag="Vnnn" attributes specifies the vtag number for this node.  This tag is specified only if a clone window exists for this vnode.

The a="xxxx" attribute specifies vnode attributes.  The xxxx denotes one or more upper-case letters whose meanings are as follows:

C	The vnode is a clone.
E	The vnode is expanded so its children are visible.
M	The vnode is marked.
T	The vnode is the top visible node.
V	The vnode is the current vnode.

For example, a="CEM"  specifies that the vnode is a clone, is expanded and is marked.
</t>
<t tx="T491">The tnodes element specifies the list of tnodes of an outline.

The tnodes element starts with &lt;tnodes...&gt; and ends with &lt;/tnodes&gt;.  In between these tags are zero or more t elements.  
</t>
<t tx="T492">The t element represents a single tnode.  Each tnode represents body text.  Because of cloning, a tnode may be shared among several vnodes.

tnodes have the following form:

&lt;t...&gt;&lt;tb&gt;sss&lt;/tb&gt;&lt;/t&gt;

The tb element specifies the body text.  As usual it starts at the &lt;tb&gt; tag and continues until the &lt;/tb&gt; tag.  sss is the headline text encoded with the usual XML escapes.

The tx="Tnnn" attribute must appear before the &gt; that terminates the &lt;t...&gt; tag.  It specifies the tnode index of the tnode.  Vnodes refer to this index in their t="Tnnn" attribute.

The rtf="1" attribute may appear before the &gt; that terminates the &lt;t...&gt;tag.  If present it specifies that body text is encoded as Rich Text Format.  This attribute is not used at present.
</t>
<t tx="T493">The clone_windows element is optional.  If present it specifies the list of cloned windows of an outline.

The clone_windows element starts with &lt;clone_windows&gt; and ends with &lt;/clone_windows&gt;.  In between these tags are one or more clone_window elements.  
</t>
<t tx="T494">The clone_window element specifies a single clone window to be opened when the file opens.

The clone_window element has the following form:

	&lt;clone_window vtag="Vnnn"&gt;
		&lt;global_window_position top="nnn" left="nnnn" height="nnn" width="nnn" &gt;
	&lt;/clone_window&gt;

All attributes and elements shown above are required.

The vtag attribute must match the vtag attribute in some vnode, and associates the clone window with the vnode.

The global_window_position element specifies the size and position of the clone window.  The top and left attributes specify the position of the clone window in global coordinates.  The height and width attributes specify the size of the clone window.</t>
<t tx="T495">&lt;!-- This is a comment --&gt;
&lt;!-- Version 1 of LEO DTD --&gt;

&lt;!DOCTYPE LeoOutlineDocumentType [

&lt;!-- A LEO file consists of the the following parts (clone_windows is optional) --&gt;
&lt;!ELEMENT leo_file (header, globals, prefs, find_settings, vnodes, tnodes, clone_windows?) &gt;

&lt;!ELEMENT header EMPTY &gt;
    &lt;!ATTLIST header
        file_format     CDATA #REQUIRED  &lt;!-- An integer version number --&gt;
        tnodes          CDATA #REQUIRED  &lt;!-- Unused at present --&gt;
        max_tnode_index CDATA #REQUIRED  &lt;!-- The size of the array used to resolve tnode indices --&gt;
        clone_windows   CDATA 0 &gt;  &lt;!-- Number of clone windows --&gt;

&lt;!ELEMENT globals (global_window_position? global_log_window_position?) &gt;
    &lt;!ATTLIST globals body_outline_ratio CDATA 0.5 &gt;
    &lt;!ELEMENT global_window_position EMPTY &gt;
        &lt;!ATTLIST global_window_position
            top     CDATA #REQUIRED
            left    CDATA #REQUIRED
            height  CDATA #REQUIRED
            width   CDATA #REQUIRED &gt;
    &lt;!ELEMENT global_log_window_position EMPTY &gt;
        &lt;!ATTLIST global_window_position
            top     CDATA #REQUIRED
            left    CDATA #REQUIRED
            height  CDATA #REQUIRED
            width   CDATA #REQUIRED &gt;

&lt;!ELEMENT preferences ( syntax_options? ) &gt;
    &lt;!ATTLIST preferences
        &lt;!-- The following specify defaults for preferences --&gt;
		allow_rich_text  CDATA 0
		tab_width        CDATA 4
		page_width       CDATA 132
		font_name		CDATA "Courier New"
		font_size		CDATA 9 &gt;
    &lt;!ELEMENT syntax_options (#PCDATA) &gt;

&lt;!ELEMENT find_settings (find_string? change_string?) &gt;
    &lt;!ATTLIST find_settings
        &lt;!-- The following specify defaults for the find/change panel --&gt;
        batch            CDATA 0
        wrap_around      CDATA 0
        batch            CDATA 0
        whole_word       CDATA 1
        ignore_case      CDATA 0
        pattern_match    CDATA 0
        search_head_text CDATA 0
        search_body_text CDATA 1
        suboutline_only  CDATA 0
        mark_changes     CDATA 0
        mark_finds       CDATA 0
        reverse          CDATA 0 &gt;
    &lt;!ELEMENT find_string   (#PCDATA) &gt;
    &lt;!ELEMENT change_string (#PCDATA) &gt;

&lt;!ELEMENT vnodes (v*) &gt;
    &lt;!ELEMENT v (vh, v*) &gt;  &lt;!-- The crucial change: vnode may contain other vnodes --&gt;
        &lt;!ATTLIST v
            vtag ID    #IMPLIED       &lt;!-- for use by clone_windows section --&gt;
            t    IDREF #IMPLIED       &lt;!-- the tnode for this vnode, or none --&gt;
            a    CDATA "" &gt;    &lt;!-- V=current, M=marked, C=cloned, E=expaned --&gt;
    &lt;!ELEMENT vh (#PCDATA) &gt;

&lt;!ELEMENT tnodes (t*)&gt;
    &lt;!ELEMENT t (#PCDATA) &gt;
        &lt;!ATTLIST t
            tx  ID
            rtf CDATA 0 &gt;      &lt;!-- 1 if the #PCDATA is rtf format --&gt;

&lt;!ELEMENT clone_windows (clone_window*) &gt;
    &lt;!ELEMENT clone_window (global_clone_window_position) &gt;
        &lt;!ATTLIST clone_window
            vref IDREF #REQUIRED &gt;    &lt;!-- the vtag of the vnode that owns this clone window --&gt;
        &lt;!ELEMENT global_clone_window_position EMPTY &gt;
            &lt;!ATTLIST global_clone_window_position
                top     CDATA #REQUIRED
                left    CDATA #REQUIRED
                height  CDATA #REQUIRED
                width   CDATA #REQUIRED &gt;
]
</t>
<t tx="T496">The following node contains the text of an actual leo file.  After that node is a node containing the outline that created the leo file.</t>
<t tx="T497">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="1" tnodes="4" max_tnode_index="4" clone_windows="0"/&gt;
&lt;globals body_outline_ratio="0.499"&gt;
	&lt;global_window_position top="54" left="54" height="550" width="559"/&gt;
	&lt;global_log_window_position top="2" left="630" height="397" width="336"/&gt;
&lt;/globals&gt;
&lt;preferences allow_rich_text="0" tab_width="4" page_width="72" tangle_bat="0" untangle_bat="0"&gt;
	&lt;TSyntaxMemo_options&gt;DBSoft6:OPT#8#67100656GWD#1#0GCL#11#-2147483633WRC#1#0IDS#1#1WRO#3#&amp;gt;|:FON#11#Courier NewFOS#1#9STC#8#16777215STB#7#8388608TBC#0#TBD#1#4EFF#323#18,0,0,16777215,;3,0,16777215,;4,8421504,16777215,;5,0,16777215,;6,255,16777215,;10,16711680,16777215,;11,0,16777215,;12,16711680,16777215,;14,16711680,16777215,;15,255,16777215,;16,16711680,16777215,;17,255,16777215,;18,16711680,16777215,;19,32768,16777215,;30,255,16777215,;32,0,16777215,;33,255,16777215,;36,0,16777215,;GDF#1#0MDF#1#0SDF#1#0BDF#1#0FOC#1#0RMG#1#0LNN#13#MS Sans SerifLNS#1#8LNC#11#-2147483640LNT#1#1LNE#0##END#&lt;/TSyntaxMemo_options&gt;
&lt;/preferences&gt;
&lt;find_panel_settings whole_word="1" search_body="1"&gt;
	&lt;find_string&gt;error&lt;/find_string&gt;
	&lt;change_string&gt;&lt;/change_string&gt;
&lt;/find_panel_settings&gt;
&lt;vnodes&gt;
&lt;v t="T1" a="TV"&gt;&lt;vh&gt;Headline 1&lt;/vh&gt;
&lt;v t="T2" a="E"&gt;&lt;vh&gt;Headline 2&lt;/vh&gt;
&lt;v&gt;&lt;vh&gt;Headline 3 ( No body text)&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;v t="T3" a="C"&gt;&lt;vh&gt;Headline 4 ( a clone )&lt;/vh&gt;
&lt;v t="T4"&gt;&lt;vh&gt;Headline 5&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="T3" a="C"&gt;&lt;vh&gt;Headline 4 ( a clone )&lt;/vh&gt;
&lt;v t="T4"&gt;&lt;vh&gt;Headline 5&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="T1"&gt;Text of headline 1.&lt;/t&gt;
&lt;t tx="T2"&gt;Text of headline 2.&lt;/t&gt;
&lt;t tx="T3"&gt;Text of headline 4.&lt;/t&gt;
&lt;t tx="T4"&gt;Text of headline 5.&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;</t>
<t tx="T498">Text of headline 1.</t>
<t tx="T499">Text of headline 2.</t>
<t tx="T500">Text of headline 4.</t>
<t tx="T501">Text of headline 5.</t>
<t tx="T502">@ The following show how to create source files using @root and @file trees. If you actually want to create files you must remove the @ignore directive below.

@ignore</t>
<t tx="T503">@ To create the file hello.c in the current directy.

1. Remove the @ignore directive from the parent of this node.
2. Select this headline.
3. Choose the Tangle command from the File menu.

When you look at hello.c you will see that it contains comments starting with ///.  Leave these comments alone: they are used by the Untangle command.

@root "hello.c"

&lt;&lt; includes &gt;&gt;
&lt;&lt; methods &gt;&gt;
</t>
<t tx="T504">@code

#include "stdio.h"</t>
<t tx="T505">@code

void main ( void )
{
	printf("Hello World!\n");
}</t>
<t tx="T506">@ To create the file hello.c in the current directy.

1. Remove the @ignore directive from the parent of this node.
2. Save this file.  This will create hello.c automatically.

When you look at hello.c you will see that it contains comments starting with //@.  Leave these comments alone!  They are needed to recreate the outline when reading this .leo file.</t>
<t tx="T507">@ This shows how to use Leo to create source files for Leo2.  

&lt;&lt; includes &gt;&gt;
@others
</t>
<t tx="T508">#include "stdio.h"</t>
<t tx="T509">void main ( void )
{
	printf("Hello World!\n");
}</t>
<t tx="T510">@nocolor

The following is part of Leo's actual source code.  The code is written in C++ and uses Borland's Delphi classes.

The Tangle command will generate the derived files in the Leo1 code section.  The Save command will generate the derived files in the Leo2 code section.

When looking through this outline pay particular attention to:

a) How the outline organizes classes, methods and chunks.
b) How the @root and @unit directives are used in Leo1 outlines.
c) How the @file and @others directives are used in Leo2 outlines.

@color</t>
<t tx="T511">@ignore</t>
<t tx="T512">@ The vnodes and tnodes classes form the heart of the "model" classes (using the Smalltalk model/view/controller terminology).  That is, the vnode and tnode classes represent nearly all the data contained in the outline.  These two classes also provide a way of hiding the underlying implementation.  For instance, the Delphi classes used to implement outlines (TTreeView, TTreeNode and TTreeNodes) appear only in the implementation of the vodes and tnodes class.

The developer documentation contains an extended discussion of these two classes.  To summarize:  a vnode (visual nodes) represents a headlines _at a particular location on the screen_.  When a headline is cloned, vnodes must be copied.  tnodes, (text nodes) on the other hand, represent body text: a tnode is shared by all vnodes that are clones of each other.  In other words, tnodes are the "unit of sharing" of body text.</t>
<t tx="T513">@unit
</t>
<t tx="T514">tnode.h created May 20, 1999.

tnodes represent the body text associated with headlines.

@root "tnode.h"

#ifndef tnode_h_
#define tnode_h_

#include &lt;comctrls.hpp&gt;
#include "SynParse.hpp"
#include "SyntaxEd.hpp"

class vnode;

class tnode
{
private:
	&lt;&lt; tnode data members &gt;&gt;
public:
	&lt;&lt; tnode constructors &amp; destructors &gt;&gt;
	&lt;&lt; tnode debugging &gt;&gt;
	&lt;&lt; tnode getters &gt;&gt;
	&lt;&lt; tnode setters &gt;&gt; 
};

#endif // tnode_h_</t>
<t tx="T515">@code

String * mBodyRTF ;  // The string containing the RTF.
String * mBodyString ;  // The body text itself.

@ At present we use TTReeView to keep track of the headline text.  This has advantages and disadvantages.

Pros:
	It simplifies the "normal" code.
	It reduces the in-memory storage requirements.

Cons:
	It forces us to update clone headlines manually.
	Cloned headlines are duplicated in the output file.
@code

#if 0  // Headlines are stored in the TTreeView.
	String mHeadString ;  // The headline string.
#endif

@ The following are routine tnode fields.
@code

short mStatusBits ; // Dirty bit. (not archived)
long mFileIndex ;  // File index for file format.
vnode * mJoinHead ;  // The head of the join list while a file is being read.
int mSelectionStart ;  // The start of the selected body text.
int mSelectionLength ;  // The length of the selected body text.

@ New for Leo2: the clone index of this node.  This index is immutable so that cross-file clone links will not break.

For @root nodes this field contains the maximum clone index.
@code

long mCloneIndex ;
</t>
<t tx="T516">@code

tnode ( long index = 0, char * bodyText = NULL ) ;
~tnode () ;</t>
<t tx="T517">@code

void edump ( bool verboseFlag = FALSE ) ;
</t>
<t tx="T518">@code

char * bodyCString ( void ) ;
long bodyCStringLength ( void ) ;
String bodyRTF ( void ) ;
String bodyString ( void ) ;

long cloneIndex ( void ) ;
long fileIndex ( void ) ;
bool hasBody ( void ) ;
bool isDirty ( void ) ;  // Used by the Tangle command.
bool isRichTextBit ( void ) ;
bool isVisited ( void ) ;
vnode * joinHead ( void ) ;
void loadBodyPaneFromTnode ( TSyntaxMemo * syntaxMemo ) ;  // Sets syntaxMemo.
long refCount ( void ) ;
int selectionLength ( void ) ;
int selectionStart ( void ) ;
</t>
<t tx="T519">@code

void clearDirty ( void ) ;
void clearRichTextBit ( void ) ;
void clearVisited ( void ) ;
void saveBodyPaneToTnode ( TSyntaxMemo * memo ) ;

void setCloneIndex ( long index ) ;
void setDirty ( void ) ;
void setFileIndex ( long index ) ;
void setJoinHead ( vnode * v ) ;
void setRichTextBit ( void ) ;
void setSelection ( int start, int length ) ;
void setTnodeRTF ( String s ) ; // For reading from files.
void setTnodeText ( String s ) ;
void setVisited ( void ) ;
</t>
<t tx="T520">@root "tnode.cpp"

#pragma option -w-par  // suppress warning: "Parameter is never used"

&lt;&lt; tnode includes &gt;&gt;
&lt;&lt; tnode abbreviations &gt;&gt;
&lt;&lt; tnode methods &gt;&gt;
</t>
<t tx="T521">@code

#include &lt;vcl.h&gt;
#pragma hdrstop

#include "args.h"
#include "tnode.h"

#include "Leo.h"
</t>
<t tx="T522">@code

enum {
    // Not archived...
	dirtyBit = 0x01,
	richTextBit = 0x02, // Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
	visitedBit = 0x04
} ;
</t>
<t tx="T523">&lt;&lt; tnode methods &gt;&gt;=

// Note: all params have defaults, so new tnode() is valid.

tnode::tnode ( long index , char * bodyCString  )
{
	if ( bodyCString )
		mBodyString = new String ( bodyCString ) ;
	else
		mBodyString = new String ( "" ) ;
		
	mBodyRTF = new String ("") ;

	mJoinHead = NULL ;
	mStatusBits = 0 ;
	mFileIndex = index ;
	mSelectionStart = 0 ;  // a TSyntaxMemo is not a String.
	mSelectionLength = 0 ;
	mCloneIndex = 0 ;
}

tnode::~tnode ()
{
	delete mBodyString ;
	delete mBodyRTF ;
}
</t>
<t tx="T524">&lt;&lt; tnode methods &gt;&gt;=

void tnode::edump ( bool verboseFlag )
{
	if ( verboseFlag ) {

	}
	else {

	}
}</t>
<t tx="T525">&lt;&lt; tnode methods &gt;&gt;=

String tnode::bodyRTF ( void )
{
	assert ( mBodyRTF ) ;
	return *mBodyRTF ;
}</t>
<t tx="T526">&lt;&lt; tnode methods &gt;&gt;=

char * tnode::bodyCString ( void )
{
	assert ( mBodyString ) ;
	return mBodyString -&gt; c_str() ;
}</t>
<t tx="T527">&lt;&lt; tnode methods &gt;&gt;=

long tnode::bodyCStringLength ( void )
{
	assert ( mBodyString ) ;

	#if 0 // faster
		return mBodyString -&gt; Length();
	#else // safer
		return strlen( mBodyString -&gt; c_str() );
	#endif
}</t>
<t tx="T528">&lt;&lt; tnode methods &gt;&gt;=

String tnode::bodyString ( void )
{
	assert ( mBodyString ) ;
	return *mBodyString ;
}</t>
<t tx="T529">&lt;&lt; tnode methods &gt;&gt;=

void tnode::loadBodyPaneFromTnode ( TSyntaxMemo * syntaxMemo )
{
	if (
		arg_allow_rich_text &amp;&amp; this -&gt; isRichTextBit() &amp;&amp;
		mBodyRTF &amp;&amp; mBodyRTF -&gt; Length() &gt; 0
	) {
		TMemoryStream * ms = new TMemoryStream ();	
		ms -&gt; Write ( mBodyRTF -&gt; c_str(), mBodyRTF -&gt; Length() ) ;
		ms -&gt; Position = 0 ;
		syntaxMemo -&gt; Lines -&gt; LoadFromStream (ms) ;
		delete ms ;
	}
	else if ( mBodyString &amp;&amp; mBodyString -&gt; Length() &gt; 0 ) {
		syntaxMemo -&gt; Clear();
		syntaxMemo -&gt; Text = *mBodyString ;
		syntaxMemo -&gt; SelStart = mSelectionStart ;
		syntaxMemo -&gt; SelLength = mSelectionLength ;
	}
	else {
		syntaxMemo -&gt; Clear();
		syntaxMemo -&gt; Text = "" ;
		mSelectionStart = 0 ;
		mSelectionLength = 0 ;
	}
}</t>
<t tx="T530">&lt;&lt; tnode methods &gt;&gt;=

int tnode::selectionLength ( void )
{
    return mSelectionLength ;
}
</t>
<t tx="T531">&lt;&lt; tnode methods &gt;&gt;=

int tnode::selectionStart ( void )
{
    return mSelectionStart ;
}
</t>
<t tx="T532">&lt;&lt; tnode methods &gt;&gt;=

bool tnode::isDirty ( void )
{
    return ( ( mStatusBits &amp; dirtyBit ) != 0 ) ;
}</t>
<t tx="T533">&lt;&lt; tnode methods &gt;&gt;=

bool tnode::isRichTextBit ( void )
{
    return ( ( mStatusBits &amp; richTextBit ) != 0 ) ;
}</t>
<t tx="T534">&lt;&lt; tnode methods &gt;&gt;=

bool tnode::isVisited ( void )
{
    return ( ( mStatusBits &amp; visitedBit ) != 0 ) ;
}</t>
<t tx="T535">&lt;&lt; tnode methods &gt;&gt;=

long tnode::cloneIndex ( void )
{
	return mCloneIndex ;
}</t>
<t tx="T536">&lt;&lt; tnode methods &gt;&gt;=

long tnode::fileIndex ( void )
{
	return mFileIndex ;
}</t>
<t tx="T537">&lt;&lt; tnode methods &gt;&gt;=

bool tnode::hasBody ( void )
{
	assert ( mBodyRTF &amp;&amp; mBodyString) ;  // Be default, these are String("");
	
	if ( arg_allow_rich_text &amp;&amp; this -&gt; isRichTextBit() )
		return mBodyRTF -&gt; Length() &gt; 0 ;
	else
		return mBodyString -&gt; Length() &gt; 0 ;
}</t>
<t tx="T538">&lt;&lt; tnode methods &gt;&gt;=

vnode * tnode::joinHead ( void )
{
    return mJoinHead ;
}</t>
<t tx="T539">&lt;&lt; tnode methods &gt;&gt;=

void tnode::saveBodyPaneToTnode ( TSyntaxMemo * memo )
{
	assert(memo);

	if ( this -&gt; isRichTextBit() )
	{
		TMemoryStream * ms = new TMemoryStream ();
		memo -&gt; Lines -&gt; SaveToStream( ms ); // Transfers RTF to stream.
		char * s = (char *) ( ms -&gt; Memory ) ;
		delete mBodyRTF ;
		mBodyRTF = new String ( s , ms -&gt; Size ) ;
		delete ms ;
		this -&gt; setSelection ( 0, 0 ) ;
	}
	else {
		delete mBodyString ;
		mBodyString = new String ( memo -&gt; Text ) ;
		this -&gt; setSelection ( memo -&gt; SelStart, memo -&gt; SelLength ) ;
	}
}
</t>
<t tx="T540">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setTnodeRTF ( String s )
{
	if ( this -&gt; isRichTextBit() ) {
		delete mBodyRTF ;
		mBodyRTF = new String ( s ) ;
	}
}</t>
<t tx="T541">This sets the text in the tnode from the given string.

&lt;&lt; tnode methods &gt;&gt;=

void tnode::setTnodeText ( String s )
{
	delete mBodyString ;
	mBodyString = new String ( s ) ;
}
</t>
<t tx="T542">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setSelection ( int start, int length )
{
	mSelectionStart = start ;
	mSelectionLength = length ;
}
</t>
<t tx="T543">&lt;&lt; tnode methods &gt;&gt;=

void tnode::clearDirty ( void )
{
    mStatusBits &amp;= ~ dirtyBit ;
}</t>
<t tx="T544">&lt;&lt; tnode methods &gt;&gt;=

void tnode::clearRichTextBit ( void )
{
	mStatusBits &amp;= ~richTextBit ;
}</t>
<t tx="T545">&lt;&lt; tnode methods &gt;&gt;=

void tnode::clearVisited ( void )
{
    mStatusBits &amp;= ~visitedBit ;
}</t>
<t tx="T546">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setDirty ( void )
{
    mStatusBits |= dirtyBit ;
}</t>
<t tx="T547">&lt;&lt; tnode methods &gt;&gt;=

void tnode:: setRichTextBit ( void )
{
	mStatusBits |= richTextBit ;
}
</t>
<t tx="T548">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setVisited ( void )
{
	mStatusBits |= visitedBit ;
}</t>
<t tx="T549">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setCloneIndex ( long index )
{
	mCloneIndex = index ;
}</t>
<t tx="T550">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setFileIndex ( long index )
{
	mFileIndex = index ;
}</t>
<t tx="T551">&lt;&lt; tnode methods &gt;&gt;=

void tnode::setJoinHead ( vnode * v )
{
	mJoinHead = v ;
}</t>
<t tx="T552">@unit
</t>
<t tx="T553">@ vnodes represent all additional data attached to TTreeNodes.

@root "vnode.h"

#ifndef vnode_h_
#define vnode_h_

#include &lt;vcl.h&gt;
#pragma hdrstop

#include &lt;comctrls.hpp&gt;

#undef V_XCLONES

class tnode;
class TLeoForm;
class Commands;
class vnode;

struct dvnode {
	&lt;&lt; dvnode data members &gt;&gt;
} ;

class vnode
{
private:
	&lt;&lt; vnode data members &gt;&gt;
	&lt;&lt; vnode private methods &gt;&gt;
public:
	&lt;&lt; vnode access methods &gt;&gt;
	&lt;&lt; vnode comparisons &gt;&gt;
	&lt;&lt; vnode constructors &amp; destructors &gt;&gt;
	&lt;&lt; vnode debugging &gt;&gt;
	&lt;&lt; vnode file methods &gt;&gt;
	&lt;&lt; vnode getters &gt;&gt;
	&lt;&lt; vnode setters &gt;&gt;
	&lt;&lt; vnode tree methods &gt;&gt;
};

#endif // vnode_h_</t>
<t tx="T554">The following stores all information needed to restore a vnode that is about to be deleted.  Much of this information is held in the TTreeView or TTreeNode classes, so it must be captured before actually deleting any information.

vnode::doDelete does not delete vnodes, nor does it descrease the refCount field in tnodes, so we save the pointers to these nodes here.

@code

dvnode * next ;
long level ;  // The level of the outline relative to the root.
String headline ;  // The text of the soon-to-be deleted TTreeNode.
vnode * v ;  // The vnode.  Neither v nor v -&gt; mT will be deleted by doDelete().
</t>
<t tx="T555">@code

vnode * next ( void ) ;
vnode * back ( void ) ;
vnode * nodeAfterTree ( void ) ;
vnode * threadBack ( void ) ;
vnode * threadNext ( void ) ;
vnode * visBack ( void ) ;
vnode * visNext ( void ) ;</t>
<t tx="T556">@code

String atFileNodeName ( void ) ;
bool isAtFileNode ( void ) ;
bool isAtIgnoreNode ( void ) ;
bool isAtOthersNode ( void ) ;
bool matchHeadline ( String pattern ) ;</t>
<t tx="T557">@code

vnode ( Commands * commands, tnode * t = NULL ) ;</t>
<t tx="T558">@ The commander for this vnode.  This allows us to determine reliably what the current vnode is, regardless of what window is active.  It also speeds access to the current body pane, tree view, etc.
@code

Commands * mCommands ;

@ The TTreeNode that owns this vnode.   The "Data" member of a TTreeNode points to its vnode.  Unlike the Yellow Box code, vnodes contain no structure information:  that information is retrieved from the corresponding TTreeNode.
@code

TTreeNode * mTreeNode;

@ The tnode.  tnodes contain only the body text of the vnode:  TTreeNodes contain the headline text.
@code

tnode * mT;

@ Status bits unique to vnodes.
@code

short mStatusBits;

@ The following field links all vnodes that are joined together.  Such nodes must be updated together.
@code

vnode * mJoinList;

@ The value of the image index associated with the vnode's icon.  This allows setIcon() to redraw the icon (and more importantly, refresh the screen), only if the icon actually changes.
@code

long mIconVal ;

@ New for Leo2.  Cross-file clone information.
@code

#ifdef V_XCLONES

String mXCloneName ;  // Full path name of the file containing the clone.
unsigned long mXCloneIndex ; // Immutable cloneIndex field within the file.

#endif
</t>
<t tx="T559">@code

String description ( void ) ;
void edump ( bool verboseFlag = FALSE ) ;
</t>
<t tx="T560">@code

String convertTreeToString ( void ) ;
String moreBody ( void ) ;
String moreHead ( long firstLevel ) ;</t>
<t tx="T561">@code

// Getters outside this class.
Commands * commands ( void ) ;
TLeoForm * leoForm ( void ) ;
TTreeNode * treeNode ( void ) ;
TTreeNodes * treeNodes ( void ) ;
TTreeView * treeView ( void ) ;

char * bodyCString ( void ) ;
char * headCString ( void ) ;

long bodyCStringLength ( void ) ;
long headCStringLength ( void ) ;

String bodyRTF ( void ) ;
String bodyString ( void ) ;
String headString ( void ) ;

long childIndex ( void ) ;
vnode * currentVnode ( void ) ;
vnode * findRoot ( void ) ;
vnode * firstChild ( void ) ;
bool hasChildren ( void ) ;
long iconVal ( void ) ;
bool isAncestorOf ( vnode * v ) ;
bool isCloned ( void ) ;
bool isDirty ( void ) ;
bool isDummy ( void ) ;
bool isExpanded ( void ) ;  // Uses outline class.
bool isExpandedBitSet ( void ) ; // Uses status bits.
bool isMarked ( void ) ;
bool isOrphan ( void ) ;
bool isRoot ( TTreeView * treeView ) ;
bool isSelectedBitSet ( void ) ;
bool isTopBitSet ( void ) ;
bool isVisible ( void ) ;  
bool isVisited ( void ) ;
vnode * joinList ( void ) ;
vnode * lastChild ( void ) ;
vnode * lastNode ( void ) ;
long level ( void ) ;
vnode * nthChild ( long n ) ;
long numberOfChildren ( void ) ;
vnode * parent ( void ) ;
int selectionStart ( void ) ;
int selectionLength ( void ) ;
short status ( void ) ;  // Returns all the status bits.
tnode * t ( void ) ;

#ifdef V_XCLONES
    String xCloneName ( void ) ;
    long xCloneIndex ( void ) ;
#endif</t>
<t tx="T562">The following must must not be called externally.

@code

vnode * cloneNode ( void ) ;
void linkNodeAsChildOfAtIndex (vnode * theParent, long index ) ;
void unlinkNode ( void ) ;</t>
<t tx="T563">@code

void appendStringToBody ( String s ) ;

void clearClonedBit ( void ) ;
void clearDirty ( void ) ;
void clearDirtyJoined ( void ) ;
void clearDummy ( void ) ;
void clearMarked ( void ) ;
void clearOrphan ( void ) ;
void clearVisited ( void ) ;

long computeIcon ( void ) ;

void initClonedBit ( bool val ) ;
void initDirtyBit ( void ) ;
void initExpandedBit( void ) ;
void initHeadString ( String s ) ;
void initMarkedBit ( void ) ;
void initSelectedBit ( void ) ;
void initStatus ( short status ) ;
void initTopBit ( void ) ;

void setAncestorAtFileNodeDirty ( void ) ;
void setBodyStringOrPane ( String s ) ;
void setClonedBit  ( void ) ;
void setDirty ( void ) ;
void setDirtyJoined ( void ) ;
void setDummy ( void ) ;
void setHeadString ( String s ) ;
void setHeadStringOrHeadline( String s ) ;
void setIcon ( void ) ;
void setIconVal ( long val ) ;  // sets mIconVal
void setIconWithVal ( long val ) ;  // uses val to draw icon.
void setJoinList ( vnode * v ) ;
void setMarked ( void ) ;
void setOrphan ( void ) ;
void setSelection ( int start, int length ) ;
void setT (tnode * t ) ;
void setTreeNode ( TTreeNode * treeNode ) ;
void setVisited ( void ) ;

#ifdef V_XCLONES
    void setXCloneName ( String name ) ;
    void setXCloneIndex ( long index ) ;
#endif

void trimTrailingLines ( void ) ;</t>
<t tx="T564">@code

// Entry points...(These call TTreeNode methods)
vnode * clone ( vnode * v ) ;
void createDependents ( void ) ;
dvnode * doDelete ( vnode * newVnode ) ;  // delete is a C++ keyword.
void freeDVnodes ( dvnode * dv ) ;
vnode * insertAfter ( tnode * t = NULL ) ;
vnode * insertAsLastChild ( tnode * t = NULL ) ;
vnode * insertAsNthChild ( long index, tnode * t = NULL ) ;
void moveAfter ( vnode * back ) ;
void moveToNthChildOf ( vnode * parent, long index ) ;
void moveToRoot ( void  ) ;
vnode * restoreOutlineFromDVnodes ( dvnode *dv, vnode *parent, vnode *back ) ;

// Helpers...
void clearTreeNodeFields ( void ) ;
vnode * cloneTree ( vnode *oldTree ) ;
void copyCloneBitsTo ( vnode *tree2 ) ;
void copyTree( vnode * oldRoot, vnode * newRoot ) ;
void destroyDependents ( void ) ;
void destroyTree ( void ) ;
void invalidOutline ( String message ) ;
bool isJoinedTo ( vnode *v ) ;
bool isOnJoinListOf ( vnode *v2 ) ;
void joinNodeTo ( vnode *v2 ) ;
void joinTreeTo ( vnode *tree2 ) ;
dvnode * saveOutlineWithLevel ( long level ) ;
bool shouldBeClone ( void ) ;
void unjoinNode ( void ) ;
void unjoinTree ( void ) ;
bool validateOutlineWithParent (vnode *p ) ;
</t>
<t tx="T565">vnode.w.cpp created May 19, 1999.

@root "vnode.cpp"

#pragma option -w-par  // suppress "Parameter not used" warning

&lt;&lt; vnode includes &gt;&gt;
&lt;&lt; vnode abbreviations &gt;&gt;
&lt;&lt; vnode methods &gt;&gt;</t>
<t tx="T566">@code

#include &lt;vcl.h&gt;
#pragma hdrstop

#include "CloneUnit.h"
#include "Commands.h"
#include "LeoWindow.h"
#include "MainUnit.h"
#include "tnode.h"
#include "vnode.h"
#include "Utils.h"

#include "Leo.h"
</t>
<t tx="T567">@ Define the meaning of vnode status bits.
@code

enum {
    // Archived.
	clonedBit	= 0x01 ,  // TRUE: vnode has clone mark.
	dummyBit	= 0x02 ,  // TRUE: vnode is a placeholder under @file node.
	expandedBit	= 0x04 ,  // TRUE: vnode is expanded.
    markedBit	= 0x08 ,  // TRUE: vnode is marked
	orphanBit	= 0x10 ,  // TRUE: vnode saved in .leo file, not derived file.
    selectedBit	= 0x20 ,  // TRUE: vnode was current vnode when saved.
	topBit		= 0x40 ,  // TRUE: vnode was top vnode when saved.

    // Not archived
    visitedBit	= 0x80
} ;
</t>
<t tx="T568">&lt;&lt; vnode methods &gt;&gt;=

vnode::vnode ( Commands * commands, tnode * t )
{
	assert(t);
	assert(commands);
	mCommands = commands ;
	mTreeNode = NULL ;
	mT = t ;
	mStatusBits = 0 ;
	mJoinList = NULL ;
	mIconVal = -1 ;
}
</t>
<t tx="T569">@ Returns the filename following @file in the receivers's headline, or the empty string if the receiver is not an @file node.

&lt;&lt; vnode methods &gt;&gt;=

String vnode::atFileNodeName ( void )
{
	String h = this -&gt; headString();
	char * ip = h . c_str();
	char * limit = ip + strlen(ip);
	if ( ip + 5 &lt; limit &amp;&amp; match_word(ip, limit, "@file") ) {
		ip += 5 ;
		String s (ip, limit - ip ) ;
		return s.Trim();
	}
	else return "" ;
}
</t>
<t tx="T570">@ Returns TRUE if the receiver's headline starts with @file.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isAtFileNode ( void )
{
	String s = this -&gt; atFileNodeName();
	return s . Length() &gt; 0 ;
}
</t>
<t tx="T571">@ Returns TRUE if the receiver contains @ignore in its body at the start of a line.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isAtIgnoreNode ( void )
{
	String body = this -&gt; bodyString();
	char *ip = body.c_str();
	return is_special (ip, body.Length(), "@ignore");
}
</t>
<t tx="T572">@ Returns TRUE if the receiver contains @others in its body at the start of a line.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isAtOthersNode ( void )
{
	String body = this -&gt; bodyString();
	char *ip = body.c_str();
	return is_special (ip, body.Length(), "@others");
}
</t>
<t tx="T573">@ Returns TRUE if the headline matches the pattern ignoring whitespace.  The headline may contain characters following the successfully matched pattern.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::matchHeadline ( String pattern )
{
	String headline = this -&gt; headString();
	char * ip = headline . c_str();
	char * pat = pattern . c_str();
	for (;;) {
		while ( is_ws(*pat) )
			++pat ;
		while ( is_ws(*ip) )
			++ip ;
		if ( *pat == '\0' )
			return true ; // Headline need not end.
		if (tolower(*pat) != tolower(*ip))
			return FALSE ;
		++pat ;
		++ip;
	}
}
</t>
<t tx="T574">&lt;&lt; vnode methods &gt;&gt;=

void vnode::edump ( bool verboseFlag )
{
    if ( mT )
		mT -&gt; edump ( verboseFlag ) ;
}</t>
<t tx="T575">&lt;&lt; vnode methods &gt;&gt;=

String vnode::description ( void )
{
	return "v: " + this -&gt; headString() ;
}
</t>
<t tx="T576">Convert the outline to a string in "MORE" format

&lt;&lt; vnode methods &gt;&gt;=

String vnode::convertTreeToString ( void )
{
	String s ;
	String body ;
	String newline ("\r\n") ;
	vnode * v = this ;
	long level1 = v -&gt; level() ;
	vnode * after = v -&gt; nodeAfterTree() ;

	while ( v &amp;&amp; v != after )
	{
		s += v -&gt; moreHead ( level1 ) ;
		s += newline ;
		body = v -&gt; moreBody ();
		if ( body . Length() &gt; 0 ) {
            s += body ;
			s += newline ;
		}
		v = v -&gt; threadNext() ;
	}

	// s += newline ;
	return s ;
}
</t>
<t tx="T577">Return the headline string in MORE format.

&lt;&lt; vnode methods &gt;&gt;=

String vnode::moreHead ( long firstLevel )
{
	long level = this -&gt; level() - firstLevel ;
	String s ;
	
	// 8/17/00 Protect against bad level arg in script.
	s += AnsiString::StringOfChar( '\t', max(0,level) ) ;
	s += ( this -&gt; hasChildren() ? "+ " : "- ") ;
	s += this -&gt; headString();

	return s;
}</t>
<t tx="T578">Return the body string in MORE format.

&lt;&lt; vnode methods &gt;&gt;=

String vnode::moreBody ( void )
{
	String s = this -&gt; bodyString();
	long index = 1 ;  // Strings are 1-based.

	// Insert a backslash before any leading plus, minus or backslash.
	while ( index &lt;= s . Length() ) {
		if ( index == 1 || s [ index ] == body_newline ) {
			if ( s [ index ] == body_newline )
				++ index ;
			if ( index &lt;= s . Length() ) {
				char c = s [ index ] ;
				if ( c == '+' || c == '-' || c == '\\' )
					s . Insert( "\\",  index ) ;
			}
		}
		++ index ;
	}

	return s ;
}
</t>
<t tx="T579">The first child has index 1.

&lt;&lt; vnode methods &gt;&gt;=

long vnode::childIndex ( void) 
{
	assert(mTreeNode);
	return mTreeNode -&gt; Index ;
}</t>
<t tx="T580">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::firstChild ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; getFirstChild() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="T581">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::hasChildren ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; HasChildren ;
}</t>
<t tx="T582">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::lastChild ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; GetLastChild() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="T583">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::nthChild ( long n )
{
	vnode * child = this -&gt; firstChild();
	long i = 0 ;

	while ( child ) {
		if ( i == n )
			return child ;
		++ i ;
		child = child -&gt; next();
	}
	return NULL ;
}</t>
<t tx="T584">&lt;&lt; vnode methods &gt;&gt;=

long vnode::numberOfChildren ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Count ;
}</t>
<t tx="T585">&lt;&lt; vnode methods &gt;&gt;=

#ifdef V_XCLONES

String vnode::xCloneName ( void )
{
	return mXCloneName ;
}

#endif</t>
<t tx="T586">&lt;&lt; vnode methods &gt;&gt;=

#ifdef V_XCLONES

long vnode::xCloneIndex ( void )
{
	return mXCloneIndex ;
}

#endif</t>
<t tx="T587">Return the previous sibling, or NULL.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::back ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; getPrevSibling() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="T588">This function returns the last node of the receiver's tree.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::lastNode ( void )
{
	vnode * v = this ;
	long level = this -&gt; level() ;
	vnode * result = NULL ;

	while ( v ) {
		result = v;
		v = v -&gt; threadNext() ;
		if ( v == NULL || v -&gt; level() &lt;= level )
			break;
	}

	return result;
}
</t>
<t tx="T589">This function returns the indentation level of the receiver. The root nodes have level 0, their children have level 1, and so on.

&lt;&lt; vnode methods &gt;&gt;=

long vnode::level ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Level ;
}</t>
<t tx="T590">Return the next sibling, or NULL.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::next (void)
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; getNextSibling() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="T591">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::parent ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; Parent ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="T592">Return the vnode following the tree whose root is the receiver.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::nodeAfterTree ( void )
{
    vnode * next = this -&gt; next() ;
    vnode * p = this -&gt; parent() ;

    while ( next == NULL &amp;&amp; p != NULL ) {
        next = p -&gt; next() ;
        p = p -&gt; parent() ;
    }
    return next ;
}</t>
<t tx="T593">Return the previous element of the outline, or NULL if at the start of the outline.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::threadBack ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; GetPrev() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="T594">Return the next item in the outline, or NULL if at the end of the outline.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::threadNext ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; GetNext() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="T595">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::visBack ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; GetPrevVisible() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="T596">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::visNext ( void )
{
	assert(mTreeNode);
	TTreeNode * n = mTreeNode -&gt; GetNextVisible() ;
	return n ? (vnode *) ( n -&gt; Data ) : NULL ;
}</t>
<t tx="T597">&lt;&lt; vnode methods &gt;&gt;=

char * vnode::bodyCString ( void )
{
	assert ( mT ) ;
    return mT -&gt; bodyCString() ;
}</t>
<t tx="T598">&lt;&lt; vnode methods &gt;&gt;=

long vnode::bodyCStringLength ( void )
{
	assert ( mT ) ;
    return mT -&gt; bodyCStringLength() ;
}</t>
<t tx="T599">&lt;&lt; vnode methods &gt;&gt;=

String vnode::bodyRTF ( void )
{
	assert(mT);
	return mT -&gt; bodyRTF();
}</t>
<t tx="T600">&lt;&lt; vnode methods &gt;&gt;=

String vnode::bodyString ( void )
{
	assert (mT);
    return mT -&gt; bodyString() ;
}</t>
<t tx="T601">&lt;&lt; vnode methods &gt;&gt;=

char * vnode::headCString ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Text . c_str();
}</t>
<t tx="T602">&lt;&lt; vnode methods &gt;&gt;=

long vnode::headCStringLength ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Text . Length() ;
}</t>
<t tx="T603">&lt;&lt; vnode methods &gt;&gt;=

String vnode::headString ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Text ;
}</t>
<t tx="T604">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isCloned ( void )
{
    return ( ( mStatusBits &amp; clonedBit ) != 0 ) ;
}</t>
<t tx="T605">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isDirty ( void )
{
    return mT -&gt; isDirty() ;
}</t>
<t tx="T606">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isDummy ( void )
{
    return ( ( mStatusBits &amp; dummyBit ) != 0 ) ;
}</t>
<t tx="T607">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isExpanded ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; Expanded ;
}</t>
<t tx="T608">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isExpandedBitSet ( void )
{
	return ( ( mStatusBits &amp; expandedBit ) != 0 ) ;
}</t>
<t tx="T609">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isMarked ( void )
{
    return ( ( mStatusBits &amp; markedBit ) != 0 ) ;
}</t>
<t tx="T610">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isOrphan ( void )
{
    return ( ( mStatusBits &amp; orphanBit ) != 0 ) ;
}</t>
<t tx="T611">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isSelectedBitSet ( void )
{
	return ( ( mStatusBits &amp; selectedBit ) != 0 ) ;
}</t>
<t tx="T612">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isTopBitSet ( void )
{
	return ( ( mStatusBits &amp; topBit ) != 0 ) ;
}</t>
<t tx="T613">Return TRUE if all parents are expanded.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isVisible ( void )
{
	assert(mTreeNode);
	return mTreeNode -&gt; IsVisible ;
}</t>
<t tx="T614">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isVisited ( void )
{
    return ( ( mStatusBits &amp; visitedBit ) != 0 ) ;
}</t>
<t tx="T615">&lt;&lt; vnode methods &gt;&gt;=

short vnode::status ( void )
{
    return mStatusBits ;
}</t>
<t tx="T616">Return the root (the first node) of the tree containing the receiver.  This is called by the commands class.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::findRoot ( void )
{
    vnode * v = this ;

    while ( v &amp;&amp; v -&gt; parent() )
        v = v -&gt; parent() ;

	while ( v &amp;&amp; v -&gt; back() )
		v = v -&gt; back();

    return v ;
}</t>
<t tx="T617">This method returns the active form.

&lt;&lt; vnode methods &gt;&gt;=

Commands * vnode::commands ( void )
{
	assert(mCommands);
	return mCommands;

	#if 0 // old code
    	TLeoForm * leoForm = this -&gt; leoForm() ;
    	assert(leoForm);  // Vnodes are _always_ contained in a TLeoForm.
    	return leoForm -&gt; commands();
	#endif
}</t>
<t tx="T618">This method returns the TLeoForm containing v. We can not assume that this form is the active form.

&lt;&lt; vnode methods &gt;&gt;=

TLeoForm * vnode::leoForm ( void )
{
	assert(mCommands &amp;&amp; mCommands -&gt; mLeoForm);
	return mCommands -&gt; mLeoForm ;

	#if 0 // old code
    	assert(this -&gt; mTreeNode);
        TTreeView * treeView = (TTreeView *) (this -&gt; mTreeNode -&gt; TreeView );
    	assert(treeView);
    
        // The TTreeView's parent is a TPanel.
        TWinControl * winControl = treeView -&gt; Parent ;
        assert ( String(winControl -&gt; ClassName()) == String("TPanel") );
    	TPanel * panel = dynamic_cast&lt;TPanel *&gt;(treeView -&gt; Parent) ;
    
        // The TPanel's parent is a TLeoForm.
        TWinControl * winControl2 = panel -&gt; Parent ;
        assert ( String(winControl2 -&gt; ClassName()) == String("TLeoForm") );
    	TLeoForm * leoForm = dynamic_cast&lt;TLeoForm *&gt;(panel -&gt; Parent) ;
    	return leoForm ;
	#endif
}
</t>
<t tx="T619">&lt;&lt; vnode methods &gt;&gt;=

TTreeNode * vnode::treeNode ( void )
{
	assert(mTreeNode);
    return mTreeNode ;
}</t>
<t tx="T620">&lt;&lt; vnode methods &gt;&gt;=

TTreeNodes * vnode::treeNodes ( void )
{
	assert(mTreeNode);
	TTreeView * treeView = (TTreeView *) mTreeNode -&gt; TreeView ;
	assert(treeView &amp;&amp; treeView -&gt; Items);
	return treeView -&gt; Items ;
}</t>
<t tx="T621">&lt;&lt; vnode methods &gt;&gt;=

TTreeView * vnode::treeView ( void )
{
	assert(mTreeNode &amp;&amp; mTreeNode -&gt; TreeView);
    return (TTreeView *) mTreeNode -&gt; TreeView ;
}</t>
<t tx="T622">We can not use this -&gt; treeView() -&gt; Selected because the Selected property will be NULL if the TLeoForm is not the current form.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::currentVnode ( void )
{
	assert(mCommands);
	return mCommands -&gt; currentVnode();
}</t>
<t tx="T623">&lt;&lt; vnode methods &gt;&gt;=

long vnode::iconVal ( void )
{
   return mIconVal ;
}</t>
<t tx="T624">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isAncestorOf ( vnode * v )
{
    for ( v = v -&gt; parent() ; v ; v = v -&gt; parent() )
        if ( v == this )
            return TRUE ;

    return FALSE ;
}</t>
<t tx="T625">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isRoot ( TTreeView * treeView )
{
	return this -&gt; threadBack() == NULL ;
}</t>
<t tx="T626">&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::joinList ( void )
{
	return mJoinList ;
}</t>
<t tx="T627">&lt;&lt; vnode methods &gt;&gt;=

int vnode::selectionStart ( void )
{
	return mT -&gt; selectionStart();
}
</t>
<t tx="T628">&lt;&lt; vnode methods &gt;&gt;=

int vnode::selectionLength ( void )
{
	return mT -&gt; selectionLength();
}
</t>
<t tx="T629">&lt;&lt; vnode methods &gt;&gt;=

tnode * vnode::t ( void )
{
	// This is a _highly_ useful assertion.
	assert(mT);
	return mT ;
}</t>
<t tx="T630">&lt;&lt; vnode methods &gt;&gt;=

#ifdef V_XCLONES

void vnode::setXCloneIndex ( long index )
{
	mXCloneIndex = index ;
}

#endif</t>
<t tx="T631">&lt;&lt; vnode methods &gt;&gt;=

#ifdef V_XCLONES

void vnode::setXCloneName ( String name )
{
	mXCloneName = name ;
}

#endif</t>
<t tx="T632">&lt;&lt; vnode methods &gt;&gt;=

void vnode::appendStringToBody ( String s )
{
	if ( s . Length() == 0 ) return ;
	String body = this -&gt; bodyString();
	body += s ;
	this -&gt; setBodyStringOrPane ( body ) ;
	this -&gt; setIcon();
}
</t>
<t tx="T633">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setBodyStringOrPane ( String s )
{
	Commands * c = this -&gt; commands();
	if ( c == NULL ) return ;
	vnode * current = c -&gt; currentVnode();
	if ( current == NULL ) return ;

	if ( this == current ) {
		// Replace the body text with s.
		TSyntaxMemo * memo = c -&gt; mSyntaxMemo;
		memo -&gt; Text = s ;
	}
	
	// Keep the body text in the tnode up-to-date.
	tnode * t = this -&gt; t();
	t -&gt; setTnodeText(s);
	t -&gt; setSelection(0,0);  // 9/27/00
}
</t>
<t tx="T634">&lt;&lt; vnode methods &gt;&gt;=

void  vnode::setHeadString ( String s )
{
	assert(mTreeNode);
	mTreeNode -&gt; Text = s ;
	this -&gt; setDirtyJoined();
}

void  vnode::initHeadString ( String s )
{
	assert(mTreeNode);
	mTreeNode -&gt; Text = s ;
}</t>
<t tx="T635">Unlike setBodyStringOrPane, this code will work whether or not the receiver is the presently selected vnode, because the assignment mTreeNode -&gt; Text = s updates the headline.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::setHeadStringOrHeadline ( String s )
{
	if ( mTreeNode == NULL ) return ;
	Commands * c = this -&gt; commands();
	if ( c == NULL ) return ;

	c -&gt; endEditing();
	this -&gt; setHeadString( s );
}
</t>
<t tx="T636">This trims trailing blank lines from a node.  It is surprising difficult to do this during Untangle.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::trimTrailingLines(void)
{
	String s1 = this -&gt; bodyString();
	char * s = s1 . c_str();
	long len = strlen(s) ;
	long newlines = 0 ;
	long ws = 0 ;

	for (long i = len - 1; i &gt;= 0 ; -- i ) {
		char c = s[i] ;
		if ( is_ws(c) ) { --len, ++ws ; }
		else if ( c == '\r' ) --len ;
		else if ( c == '\n' ) { --len ; ++newlines ; }
		else break ;
	}

	if ( newlines &gt; 1 || newlines &gt; 0 &amp;&amp; ws &gt; 0 ) {
		String s2 ( s, len ) ;
		this -&gt; setBodyStringOrPane ( ( newlines &gt; 0 ) ? s2 + "\n" : s2 ) ;
		// Don't set the dirty bit: it would just be annoying.
	}
}
</t>
<t tx="T637">&lt;&lt; vnode methods &gt;&gt;=

long vnode::computeIcon ( void )
{
	vnode * current = this -&gt; currentVnode();
	if ( current == NULL ) return -1 ;

    long val = 0 ;
	if ( this -&gt; t() -&gt; hasBody() ) val += 1 ;
	if ( this -&gt; isMarked() ) val += 2 ;
	if ( this -&gt; isCloned() ) val += 4 ;
	if ( this -&gt; isDirty() ) val += 8 ;
	return val ;
}
</t>
<t tx="T638">The caller must call commands -&gt; Repaint().

&lt;&lt; vnode methods &gt;&gt;=

void vnode::setIcon ( void )
{
	static long guard = 0 ;
	assert(guard == 0);  // This routine should never cause recursion.

	long val = this -&gt; computeIcon();
	if ( val != -1 ) {
    	// Update the icon.
    	++guard ;
    		this -&gt; setIconWithVal ( val );
    	--guard ;
	}
}
</t>
<t tx="T639">Calling setIconVal -1 is the idiom to force the icon to be redrawn.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::setIconVal ( long val )
{
	mIconVal = val ;
}
</t>
<t tx="T640">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setIconWithVal ( long val )
{
	if ( val != mIconVal ) {
        mIconVal = val ;
        assert(mTreeNode);
        mTreeNode -&gt; ImageIndex = val ;
        mTreeNode -&gt; SelectedIndex = val ;
	}
}</t>
<t tx="T641">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setJoinList ( vnode * v )
{
	assert(mJoinList==NULL);
	mJoinList = v ;
}</t>
<t tx="T642">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setSelection ( int start, int length )
{
	mT -&gt; setSelection ( start, length );
}
</t>
<t tx="T643">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setT (tnode * t )
{
	// Bug fix: 7/9/01: do nothing if t == mt (!)
	if ( t != mT ) {
		delete mT ;  // Delete the tnode created when reading a file.
		mT = t ;
	}
}
</t>
<t tx="T644">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setTreeNode ( TTreeNode * treeNode )
{
	assert(treeNode);
    mTreeNode = treeNode ;
}</t>
<t tx="T645">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearClonedBit ( void )
{
    mStatusBits &amp;= ~ clonedBit ;
	this -&gt; setIcon();
}</t>
<t tx="T646">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearDirty ( void )
{
	mT -&gt; clearDirty() ;
	this -&gt; setIcon();
}

void vnode::clearDirtyJoined ( void )
{
	mT -&gt; clearDirty() ;
	this -&gt; setIcon();

	for (
		vnode * v2 = this -&gt; joinList();
		v2 &amp;&amp; v2 != this ;
		v2 = v2 -&gt; joinList()
	)
		v2 -&gt; setIcon();
}
</t>
<t tx="T647">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearDummy ( void )
{
    mStatusBits &amp;= ~ dummyBit ;
}</t>
<t tx="T648">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearMarked ( void )
{
    mStatusBits &amp;= ~ markedBit ;
	this -&gt; setIcon();
}
</t>
<t tx="T649">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearOrphan ( void )
{
    mStatusBits &amp;= ~ orphanBit ;
}</t>
<t tx="T650">&lt;&lt; vnode methods &gt;&gt;=

void vnode::clearVisited ( void )
{
    mStatusBits &amp;= ~ visitedBit ;
}</t>
<t tx="T651">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initClonedBit ( bool val )
{
	if ( val )
    	mStatusBits |= clonedBit ;
	else
		mStatusBits &amp;= ~clonedBit ;
}</t>
<t tx="T652">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initDirtyBit ( void )
{
	mT -&gt; setDirty();
}
</t>
<t tx="T653">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initExpandedBit ( void )
{
    mStatusBits |= expandedBit ;
}</t>
<t tx="T654">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initMarkedBit ( void )
{
	mStatusBits |= markedBit ;
}</t>
<t tx="T655">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initSelectedBit ( void )
{
    mStatusBits |= selectedBit ;
}</t>
<t tx="T656">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initTopBit ( void )
{
    mStatusBits |= topBit ;
}</t>
<t tx="T657">&lt;&lt; vnode methods &gt;&gt;=

void vnode::initStatus ( short status )
{
	mStatusBits = status ;
}
</t>
<t tx="T658">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setAncestorAtFileNodeDirty ( void )
{
    for ( vnode * v = this ; v ; v = v -&gt; parent() ) {
		if ( ! v -&gt; isDirty() &amp;&amp; v -&gt; isAtFileNode() ) {
			v -&gt; setDirty();
			v -&gt; setDirtyJoined();
		}
	}
}
</t>
<t tx="T659">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setClonedBit ( void )
{
    mStatusBits |= clonedBit ;
	this -&gt; setIcon();
}
</t>
<t tx="T660">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setDirty ( void )
{
	mT -&gt; setDirty(); // Prevent recursion below.

	// Leo2: set the dirty bits of all ancestor @file nodes.
	for ( vnode * v = this ; v ; v = v -&gt; parent() ) {
		if ( ! v -&gt; isDirty() &amp;&amp; v -&gt; isAtFileNode() ) {
			v -&gt; setDirty();
			v -&gt; setDirtyJoined();
		}
	}

	this -&gt; setIcon();
}

void vnode::setDirtyJoined ( void )
{
	mT -&gt; setDirty();
	this -&gt; setIcon();

	for (
		vnode * v2 = this -&gt; joinList();
		v2 &amp;&amp; v2 != this ;
		v2 = v2 -&gt; joinList()
	)
		v2 -&gt; setDirty();
}
</t>
<t tx="T661">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setDummy ( void )
{
    mStatusBits |= dummyBit ;
}</t>
<t tx="T662">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setOrphan ( void )
{
    mStatusBits |= orphanBit ;
}</t>
<t tx="T663">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setVisited ( void )
{
    mStatusBits |= visitedBit ;
}</t>
<t tx="T664">&lt;&lt; vnode methods &gt;&gt;=

void vnode::setMarked ( void )
{
	mStatusBits |= markedBit ;
	this -&gt; setIcon();
}
</t>
<t tx="T665">Create a clone of back and insert it as the next sibling of back.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::clone ( vnode * back )
{
	vnode * clone = this -&gt; cloneTree ( back ) ;
	clone -&gt; createDependents() ;
	#if 0 // too slow
		this -&gt; initAllCloneBits() ;
	#endif
	// Set the clone bit in all nodes joined to back.
	back -&gt; setClonedBit() ;
	for ( vnode * v = back -&gt; mJoinList ; v &amp;&amp; v != back ; v = v -&gt; mJoinList )
		v -&gt; setClonedBit() ;
	return clone ;
}</t>
<t tx="T666">This method creates all nodes that depend on the receiver.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::createDependents ( void )
{
	vnode *v = this ;
	tnode *t = v -&gt; mT ;
	vnode *parent = v -&gt; parent();
	if ( parent == NULL ) return ;

	// Copy v as the nth child of all nodes joined to parent.
	long n = v -&gt; childIndex() ;
	vnode *p = parent -&gt; mJoinList ;
	while ( p &amp;&amp; p != parent ) {
		vnode * copy = p -&gt; insertAsNthChild ( n, t ) ;
		copy -&gt; initHeadString ( v -&gt; headString() ) ;
		copyTree( v, copy );
		this -&gt; joinTreeTo ( copy ) ;
		p = p -&gt; mJoinList ;
	}
}
</t>
<t tx="T667">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.

Deleting an outline is actually a tricky operation because of the Undo command.  We don't actually delete vnodes (or reduce the refCount field of tnodes) until the delete operation becomes undoable.  (This can happen even if unlimited undo/redo is ever implemented.)

Therefore, dvnodes can store a pointer to the tnode containing the body text, and a good thing too, because otherwise undoing a joined node would not rejoin the node.

&lt;&lt; vnode methods &gt;&gt;=

dvnode * vnode::doDelete ( vnode * newVnode )  // delete is a C++ keyword
{
	Commands * commands = this -&gt; commands();  // Needed after 'this' no longer valid.
	assert(mTreeNode);
	TTreeNode * treeNode = mTreeNode ;  // Will be cleared below.

	// Destroy all dependent vnodes &amp; TTreeNodes.
	this -&gt; destroyDependents() ;

	// Create a list of dvnodes containing all info from the outline.
	dvnode * dv = this -&gt; saveOutlineWithLevel ( 0 ) ;
	&lt;&lt; dump the dv list &gt;&gt;

	// Unjoin all nodes of the deleted tree.
	this -&gt; unjoinTree();

	// Destroy the entire tree of TTreeNodes.
	treeNode -&gt; Delete() ;

	// Bug fix: 1/18/99: we must set the currentVnode here!
	commands -&gt; selectVnode ( newVnode ) ;

	// Update all clone bits.
	commands -&gt; initAllCloneBits();

	return dv ;
}
</t>
<t tx="T668">@code

TRACEP("vnode::doDelete:dumpDVnodes",
	ecnl(); es("Dump of dvnodes: ");
	while ( dv ) {
		String s = dv -&gt; headline ;
		ecnl(); epadlong( dv -&gt; level, 2 ); ecs(); es(s.c_str());
		dv = dv -&gt; next ;
	}
	ecnls(2);
);
</t>
<t tx="T669">&lt;&lt; vnode methods &gt;&gt;=

void vnode::freeDVnodes ( dvnode * dv )
{
	while ( dv ) {
		dvnode * next = dv -&gt; next ;
		delete dv ;
		dv = next ;
	}
}
</t>
<t tx="T670">This method inserts a new vnode after the receiver.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::insertAfter ( tnode * t )
{
	assert(mTreeNode);
	vnode * back = this ;
	vnode * next = back -&gt; next() ;
	vnode * parent = back -&gt; parent() ;
	if ( t == NULL ) t = new tnode() ;
	vnode * v = new vnode( this -&gt; mCommands, t ) ;
	String s ( "NewHeadline" ) ;
	TTreeNodes * treeNodes = back -&gt; treeNodes() ;

	if ( next )
		// Insert before next.
		v -&gt; mTreeNode = treeNodes -&gt; InsertObject( next -&gt; mTreeNode, s, v ) ;
	else if ( parent )
		// Insert as the last child of parent.
		v -&gt; mTreeNode = treeNodes -&gt; AddChildObject( parent -&gt; mTreeNode, s, v ) ;
	else
		// Insert as the first sibling of back.
		v -&gt; mTreeNode = treeNodes -&gt; AddObject( back -&gt; mTreeNode, s, v ) ;

	return v ;
}
</t>
<t tx="T671">This method inserts a new node as the last child of the receiver.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::insertAsLastChild ( tnode * t )
{
	long n = this -&gt; numberOfChildren() ;
	return insertAsNthChild ( n, t ) ;
}</t>
<t tx="T672">This method inserts a new vnode as the nth child of the receiver.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::insertAsNthChild ( long index, tnode * t )
{
	assert(mTreeNode);
	vnode * parent = this ;
	if ( t == NULL ) t = new tnode() ;
	vnode * v = new vnode( this -&gt; mCommands, t );
	String s ( "NewHeadline" ) ;
	TTreeNodes * treeNodes = parent -&gt; treeNodes() ;

	if ( index == 0 )
		// Insert as the first child of parent.
		v -&gt; mTreeNode =
			treeNodes -&gt; AddChildObjectFirst( parent -&gt; mTreeNode, s, v ) ;
	else if ( index &gt;= parent -&gt; numberOfChildren() )  // bug fix: 8/28/99 (was index+1)
		// Insert as the last child of the parent. 
		v -&gt; mTreeNode =
			treeNodes -&gt; AddChildObject( parent -&gt; mTreeNode, s, v ) ;
	else {
		// Insert before the child index .
		vnode * child = parent -&gt; nthChild ( index ) ;
		assert(child);
		v -&gt; mTreeNode = treeNodes -&gt; InsertObject( child -&gt; mTreeNode, s, v ) ;
	}

	return v ;
}
</t>
<t tx="T673">This method moves the receiver after node v.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::moveAfter (vnode * v )
{
	assert(mTreeNode);
	vnode * next = v -&gt; next() ;
	vnode * parent = v -&gt; parent() ;

	this -&gt; destroyDependents() ;

	if ( next )
		// Move _before_ next.  (The documentation is incorrect.)
		mTreeNode -&gt; MoveTo ( next -&gt; mTreeNode, naInsert ) ;
	else if ( parent )
		// Move to the last child of parent.
		mTreeNode -&gt; MoveTo ( parent -&gt; mTreeNode, naAddChild ) ;
	else
		// Move to the last node.
		mTreeNode -&gt; MoveTo ( NULL, naAdd ) ;

	this -&gt; createDependents() ;
}
</t>
<t tx="T674">This method moves the receiver before node v.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::moveToRoot ( void  )
{
	assert(mTreeNode);
	this -&gt; destroyDependents() ;
	mTreeNode -&gt; MoveTo ( NULL, naAddFirst ) ;
	this -&gt; createDependents() ;
}
</t>
<t tx="T675">&lt;&lt; vnode methods &gt;&gt;=

void vnode:: moveToNthChildOf (vnode * parent, long index )
{
	assert(mTreeNode);
	this -&gt; destroyDependents() ;

	// Move the tree.
	if ( index == 0 )
		mTreeNode -&gt; MoveTo ( parent -&gt; mTreeNode, naAddChildFirst ) ;
	else if ( index + 1 &gt;= parent -&gt; numberOfChildren() )
		// Move to the last child of the parent. 
		mTreeNode -&gt; MoveTo ( parent -&gt; mTreeNode, naAddChild ) ;
	else {
		// Move before the child with index + 1.
		vnode * child = parent -&gt; nthChild ( index + 1 ) ;
		assert(child);
		mTreeNode -&gt; MoveTo ( child -&gt; mTreeNode, naInsert ) ;
	}

	this -&gt; createDependents() ;
}</t>
<t tx="T676">This method restores the tree described by dv in the position described by back and parent.  If back exists, we insert the tree after back.  Otherwise, if parent exists we insert the tree as the first child of parent.  If both back and parent are null the new tree becomes the root vnode.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::restoreOutlineFromDVnodes ( dvnode * dv, vnode * parent, vnode * back )
{
	Commands * commands = this -&gt; commands();
	TTreeNodes * treeNodes = this -&gt; treeNodes() ;
	vnode * result = NULL ;

    while ( dv ) {
        String s = dv -&gt; headline ;
        vnode *v = dv -&gt; v ;
        if ( result == NULL ) result = v;
        &lt;&lt; Insert v into the outline &gt;&gt;
        if ( dv -&gt; next ) {
        	&lt;&lt; Set back and parent fields for the new vnode &gt;&gt;
        }
        dv = dv -&gt; next ;
    }
	&lt;&lt; set icons for all vnodes of the result tree &gt;&gt;
	return result ;
}
</t>
<t tx="T677">@code

if ( back ) {
	vnode * next = back -&gt; next();
	if ( next ) {
		// Insert v before next.
		v -&gt; mTreeNode =
			treeNodes -&gt; InsertObject( next -&gt; mTreeNode, s, v ) ;
	}
	else {
		// Insert v as the last sibling of back.
		v -&gt; mTreeNode =
			treeNodes -&gt; AddObject( back -&gt; mTreeNode, s, v ) ;
	}
}
else if ( parent )
	// Insert v as the first child of parent.
	v -&gt; mTreeNode =
		treeNodes -&gt; AddChildObjectFirst( parent -&gt; mTreeNode, s, v ) ;
else {
	// Insert v as the root node.
	vnode * root = commands -&gt; rootVnode();
	v -&gt; mTreeNode =
        treeNodes -&gt; InsertObject( root -&gt; mTreeNode, s, v ) ;
}
</t>
<t tx="T678">@code

long delta = dv -&gt; next -&gt; level - dv -&gt; level ;

if ( delta &gt; 0 ) {
	assert(delta==1);
	back = NULL ;
	parent = v ;
}
else if ( delta == 0 ) {
	back = v ;
	parent = back -&gt; parent();
}
else {
	while ( ++delta &lt; 0 &amp;&amp; parent )
		parent = parent -&gt; parent();
	back = parent ;
	if ( back )
		parent = back -&gt; parent();
}
</t>
<t tx="T679">New code:  8/8/00

@code

vnode * next = result -&gt; nodeAfterTree();
for ( vnode * v = result ; v &amp;&amp; v != next ; v = v -&gt; threadNext() ) {
	v -&gt; setIconVal(-1);  // Disable usual optimization.
	v -&gt; setIcon();
}
</t>
<t tx="T680">This method creates a cloned tree after oldTree.

&lt;&lt; vnode methods &gt;&gt;=

vnode * vnode::cloneTree ( vnode * oldTree )
{
	// Create a new tree following oldTree.
	vnode * newTree = this -&gt; insertAfter ( oldTree -&gt; mT ) ;
	newTree -&gt; initHeadString ( oldTree -&gt; headString() ) ;
	copyTree ( oldTree, newTree ) ;

	// Join the trees and copy clone bits.
	oldTree -&gt; joinTreeTo ( newTree ) ;
	oldTree -&gt; copyCloneBitsTo ( newTree ) ;
	
	// 9/19/00
	vnode * next = newTree -&gt; nodeAfterTree();
    for ( vnode * v = newTree ; v &amp;&amp; v != next ; v = v -&gt; threadNext() ) {
    	v -&gt; setIconVal(-1);  // Disable usual optimization.
    	v -&gt; setIcon();
    }

	return newTree ;
}
</t>
<t tx="T681">This methods propagates clone bits from the receiver's tree to tree2.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::copyCloneBitsTo ( vnode * tree2 )
{
	vnode * tree1 = this ;
	ASSERT(tree2);

	// Set the bit in the root.
	if ( tree1 -&gt; isCloned() )
		tree2 -&gt; setClonedBit();
	else
		tree2 -&gt; clearClonedBit();

	// Recursively set the bits in all subtrees.
	vnode *child1 = tree1 -&gt; firstChild() ;
	vnode *child2 = tree2 -&gt; firstChild() ;
	while (child1)
	{
		PERM_ASSERT(child2);
		if ( child1 -&gt; isCloned() )
			child2 -&gt; setClonedBit();
		else
			child2 -&gt; clearClonedBit();
		child1 = child1 -&gt; next() ;
		child2 = child2 -&gt; next() ;
	}
	PERM_ASSERT(child2 == NULL);
}</t>
<t tx="T682">This method copies all subtrees of oldRoot to the subtrees of newRoot.  The caller is responsible for copying the headline text from oldRoot to newRoot.

This method must be given the new root as well as the old:  the Borland classes do not allow us to create an unattached outline.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::copyTree( vnode * oldTree, vnode * newTree )
{
	vnode * old_v = oldTree -&gt; firstChild();
	if ( old_v == NULL ) return ;

	// Copy the first child of oldTree to the first child of newTree.
	vnode * new_v = newTree -&gt; insertAsNthChild ( 0, old_v -&gt; mT ) ;
	new_v -&gt; initHeadString ( old_v -&gt; headString() ) ;

	// Copy all other children of oldTree after the first child of newTree.
	for ( old_v = old_v -&gt; next() ; old_v ; old_v = old_v -&gt; next() ) {
		new_v = new_v -&gt; insertAfter ( old_v -&gt; mT ) ;
		new_v -&gt; initHeadString ( old_v -&gt; headString() ) ;
	}

	// Recursively copy all descendents of oldTree.
	new_v = newTree -&gt; firstChild() ;
	old_v = oldTree -&gt; firstChild() ;
	while ( old_v ) {
		assert ( new_v ) ; 
		copyTree ( old_v, new_v ) ;
		old_v = old_v -&gt; next();
		new_v = new_v -&gt; next();
	}
	assert ( new_v == NULL ) ;
}
</t>
<t tx="T683">This method destroys all dependent vnodes and TTreeNode's associated with the receiver.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::destroyDependents ( void )
{
	vnode * parent = this -&gt; parent() ;
	if ( parent == NULL ) return ;

	// Destroy the nth child of all nodes joined to the receiver's parent.
	long n = this -&gt; childIndex();
	vnode * join = parent -&gt; mJoinList ;
	while ( join &amp;&amp; join != parent ) {
		vnode *child = join -&gt; nthChild ( n ) ;
		if ( child ) {
			child -&gt; unjoinTree() ;
			child -&gt; destroyTree() ;
		}
		join = join -&gt; mJoinList ;
	}
}
</t>
<t tx="T684">This method destroys (irrevocably deletes) a vnode tree.

This code should be called only when it is no longer possible to undo a previous delete.  It is always valid to destroy dependent trees.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::destroyTree ( void )
{
	assert(mTreeNode);
	TTreeNode * treeNode = this -&gt; mTreeNode ;  // Will be cleared below.
	
	// Delete all the vnodes of the tree.
	vnode * v = this ;
	vnode * after = this -&gt; nodeAfterTree();
	while ( v &amp;&amp; v != after ) {
		vnode * next = v -&gt; threadNext() ;
		delete v ;
		v = next ;
	}

	// Destroy the entire tree of TTreeNodes.
	treeNode -&gt; Delete() ;
}</t>
<t tx="T685">&lt;&lt; vnode methods &gt;&gt;=

void vnode::invalidOutline ( String message )
{
    vnode * parent = this -&gt; parent() ;
	String s("invalid outline: ") ;
	s += message ;
	s += '\r' ;

	if ( parent )
		s += parent -&gt; description() ;
	else
		s += this -&gt; description() ;

	alert ( s . c_str() ) ;
}
</t>
<t tx="T686">&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isJoinedTo ( vnode * v )
{
	return v &amp;&amp; this -&gt; mT == v -&gt; mT ;
}</t>
<t tx="T687">This function returns true if the nodes v1 and v2 are on the same join list.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::isOnJoinListOf ( vnode *v2)
{
	vnode * v1 = this ;
	assert( v2 &amp;&amp; v1 -&gt; mT &amp;&amp; v2 -&gt; mT );

	// v1 and v2 must share the same tnode.
	if ( v1 -&gt; mT != v2 -&gt; mT )
		return FALSE;

	// v1 and v2 must have join lists.
	if ( v1 -&gt; mJoinList == NULL || v2 -&gt; mJoinList == NULL )
		return FALSE;

	// Return TRUE if v2 is on v1's join list.
	for ( vnode * v = v1 -&gt; mJoinList ; v &amp;&amp; v != v1 ; v = v -&gt; mJoinList )
		if ( v == v2 )
			return TRUE;

	return FALSE;
}
</t>
<t tx="T688">@ This method joins the receiver to v2 if the two nodes have not already been joined.

Joining involves placing each vnode on the others join list.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::joinNodeTo ( vnode * v2 )
{
	vnode *v1 = this ;
	if ( v1 -&gt; isOnJoinListOf ( v2 ) ) return ; // Bug fix: 7/9/01 ??? (was v1)

	vnode *j1 = v1 -&gt; mJoinList ;
	vnode *j2 = v2 -&gt; mJoinList ;

	if (j1 &amp;&amp; j2) {
		// Swapping pointers joins the two cycles.
		v1 -&gt; mJoinList = j2;  // Neither join list is NULL.
		v2 -&gt; mJoinList = j1;
	}
	else if (j1) {
		v2 -&gt; mJoinList = j1;  // Link v2 after v1.
		v1 -&gt; mJoinList = v2;
	}
	else if (j2) {
		v1 -&gt; mJoinList = j2;  // Link v1 after v2.
		v2 -&gt; mJoinList = v1;
	}
	else {
		v1 -&gt; mJoinList = v2;  // point v1 and v2 at each other.
		v2 -&gt; mJoinList = v1;
	}

	#if 0
		v1 -&gt; setDirty();
		v2 -&gt; setDirty();
	#endif

	PERM_ASSERT( v1 -&gt; mJoinList &amp;&amp; v2 -&gt; mJoinList );
}
</t>
<t tx="T689">@ This function joins all nodes in the receiver and tree2.  This code makes no assumptions about the two trees, and some or all of the nodes may already have been joined.  The PERM_ASSERT's guarantee that both trees have the same topology.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::joinTreeTo ( vnode *tree2 )
{
	vnode * tree1 = this ;
	ASSERT(tree2);

	// Join the roots.
	tree1 -&gt; joinNodeTo ( tree2 ) ;

	// Recursively join all subtrees.
	vnode *child1 = tree1 -&gt; firstChild() ;
	vnode *child2 = tree2 -&gt; firstChild() ;
	while (child1)
	{
		PERM_ASSERT(child2);
		child1 -&gt; joinTreeTo ( child2 ) ;
		child1 = child1 -&gt; next() ;
		child2 = child2 -&gt; next() ;
	}
	PERM_ASSERT(child2 == NULL);
}
</t>
<t tx="T690">This method is called just before destroying a Tree of TTreeNodes.  It copies the data into the dvnode so the headlines can be restored if the deleted is undone.

&lt;&lt; vnode methods &gt;&gt;=

dvnode * vnode::saveOutlineWithLevel ( long level )
{
	vnode * v = this ;
	dvnode * root = new dvnode() ;
	dvnode * dv = root ;
	&lt;&lt; Set the data fields of dv &gt;&gt;

	vnode * child = this -&gt; firstChild();
	while ( child ) {
		// Recursively create a list of dvnodes for child's subtree.
		dv -&gt; next = child -&gt; saveOutlineWithLevel ( level + 1 ) ;
		// Move dv to the end of the list of dvnodes.
		while ( dv &amp;&amp; dv -&gt; next )
			dv = dv -&gt; next ;
		child = child -&gt; next();
	}
	return root ;
}
</t>
<t tx="T691">@code

dv -&gt; next = NULL ;
dv -&gt; level = level ;
dv -&gt; headline = v -&gt; headString();
dv -&gt; v = v ;</t>
<t tx="T692">This function returns true if the receiver should be a clone.  This can be done _very_ quickly using the receiver's join list.

The receiver is a clone if and only it is structurally _dissimilar_ to a node joined to it.  Structurally _similar_ joined nodes have non-null, distinct and joined parents, and have the same child indices.

9/16/99 We now return the node that proves that the receiver should be a clone.  This allows us to dispense with the old "survivor" logic in commands::deleteHeadline.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::shouldBeClone ( void )
{
	vnode *p = this -&gt; parent() ;
	long n = this -&gt; childIndex();

	for ( vnode * v = this -&gt; mJoinList ; v &amp;&amp; v != this ; v = v -&gt; mJoinList ) {
		vnode * vp = v -&gt; parent() ;
		if (
			p == NULL || vp == NULL ||  // Nodes joined to top level nodes are clones.
			vp == p ||  // Joined nodes with the same parent are clones.
			! p -&gt; isJoinedTo ( vp ) ||  // Nodes with unjoined parents are clones.
			v -&gt; childIndex() != n  // Nodes with different child indices are clones.
		)
			return TRUE;  // The receiver is structurally _dissimilar_ to v.
	}

	// The receiver is structurally similar to all nodes joined to it.
	return FALSE ;  
}
</t>
<t tx="T693">This code carefully unlinks the receiver from its join list.  We can not simply assume that all such links will eventually be cleared.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::unjoinNode ( void )
{
	vnode * next = this -&gt; mJoinList ;
	if ( next == NULL ) return ;
	
	if ( next -&gt; mJoinList == this ) {
		// The list contains only two elements.
		next -&gt; mJoinList = NULL ;
		this -&gt; mJoinList = NULL ;
		#if 0
			this -&gt; setDirty() ;
			next -&gt; setDirty() ;
		#endif
	}
	else {
		vnode * prev = NULL ;
		&lt;&lt; Set prev to the node that points to this &gt;&gt;
		// Remove this from the join list.
		prev -&gt; mJoinList = next;
		this -&gt; mJoinList = NULL;
		#if 0
			this -&gt; setDirty() ;
			prev -&gt; setDirty() ;
		#endif
	}
}</t>
<t tx="T694">We guard against any cycles in the join list, which would cause this loop to hang.  It's much better to cause an assert to fail.

@code

Commands * commands = this -&gt; commands() ;
commands -&gt; clearAllVisited();

for (
	prev = next;
	prev &amp;&amp; prev -&gt; mJoinList != this ;
	prev = prev -&gt; mJoinList
)
	if ( prev -&gt; isVisited() )
		assert ( 0 ) ;
	else
		prev -&gt; setVisited() ;</t>
<t tx="T695">This function unjoins all nodes of the receiver's tree.

&lt;&lt; vnode methods &gt;&gt;=

void vnode::unjoinTree ( void )
{
	vnode * v = this ;
	vnode * after = this -&gt; nodeAfterTree() ;

	while ( v &amp;&amp; v != after ) {
		v -&gt; unjoinNode() ;
		v = v -&gt; threadNext() ;
	}
}</t>
<t tx="T696">This routine checks the structure of the receiver's tree.

&lt;&lt; vnode methods &gt;&gt;=

bool vnode::validateOutlineWithParent ( vnode * p )
{
	bool result = TRUE ;  // optimists get only unpleasant surprises.
	vnode * parent = this -&gt; parent() ;
	long childIndex = this -&gt; childIndex() ;

	&lt;&lt; validate parent ivar &gt;&gt;
	&lt;&lt; validate childIndex ivar &gt;&gt;
	&lt;&lt; validate x ivar &gt;&gt;

	// Recursively validate all the children.
	for ( vnode * child = this -&gt; firstChild(); child; child = child -&gt; next() )
	{
		bool r = child -&gt; validateOutlineWithParent ( this ) ;
		if ( r == FALSE ) result = FALSE ;
	}

	return result ;
}</t>
<t tx="T697">@code

if ( parent != p )
	this -&gt; invalidOutline ( "Invalid parent link: " + parent -&gt; description() ) ;</t>
<t tx="T698">@code

if ( p )
{
	if ( childIndex &lt; 0 )
		this -&gt; invalidOutline ( "missing childIndex" + childIndex ) ;

    else if ( childIndex &gt;= p -&gt; numberOfChildren() )
		this -&gt; invalidOutline ( "missing children entry for index: " + childIndex ) ;
}
else if ( childIndex &lt; 0 )
	this -&gt; invalidOutline ( "negative childIndex" + childIndex ) ;
</t>
<t tx="T699">@code

if ( this -&gt; t() == NULL &amp;&amp; p != NULL )
	this -&gt; invalidOutline ( "NULL t" ) ;</t>
<t tx="T700">@ignore</t>
<t tx="T701">#include &lt;stdio.h&gt;

class vnode ;
class Commands ;

&lt;&lt; declare public utility functions &gt;&gt;

class atFile
{
public:
	atFile (Commands * commands) ;
	void read (vnode * v) ;
	void readAll (vnode * v) ;
	void write (vnode * v) ;
	void writeAll (vnode * v) ;
private:
	&lt;&lt; private atFile data &gt;&gt;
	&lt;&lt; private read methods &gt;&gt;
	&lt;&lt; private sentinel methods &gt;&gt;
	&lt;&lt; private utilities &gt;&gt;
	&lt;&lt; private write methods &gt;&gt;
};
</t>
<t tx="T702">bool compareFiles ( String path1, String path2 ) ;
short directiveKind (char * ip, char * limit) ;
bool isSectionName ( char *ip, char *limit, char **end_pp ) ;
bool matchHeadline ( vnode * v, String pattern ) ;
void setAncestorAtFileNodeDirty ( vnode * v ) ;</t>
<t tx="T703">@ The commander for the current window.
@c

Commands * mCommands ;

@ mErrors is number of errors seen while reading and writing.  We no longer make a distinction between warnings and errors, because there is no problem that can result in lost data.  mStructureErrors are errors reported by createNthChild.  If structure errors are found we delete the outline tree and rescan.
@c

long mErrors ;
long mStructureErrors ;

@ The files used by the output routines.  When tangling, we first write to a temporary output file.  After tangling is complete we compare the temporary file to the target file, if it exists.  If the files are equal we just delete the temporary file.  Otherwise we delete the old target file and rename the temporary file to be the target file.
@c

String mTargetFileName ;
String mOutputFileName ;

@ The stream used to write the temporary output file.
@c

TFileStream * mOutputStream ;

@ The indentation used when outputting section references or at-others sections.  We add the indentation of the line containing to reference or at-others to indent before expansion, then restore indent to its previous value when expansion is complete.

The unit of indentation is spaces, not tabs.
@c

long indent ;

@ The strings to be output before and after each sentinel line, i.e., the strings used to specify the beginning and end of sentinel comments. mEndSentinelComment is empty for single-line comments.

When writing, we set these strings to the comments delimiters specified by the Preferences Panel and any applicable @language and @comment directives, with single-line comment delimiters being used by default.  When reading, we set the strings using the characters before and after the &lt;leo&gt; tag in the first line of the file.
@c

String mStartSentinelComment ;
String mEndSentinelComment ;

@ The root of tree being written.
@c

vnode * mRoot ;
</t>
<t tx="T704">@code

vnode * createNthChild (long n, vnode * parent, String headline) ;
void joinTrees ( vnode *tree1, vnode *tree2 ) ;
char * scanDoc (TMemoryStream * ms, char *ip, char *limit, short kind) ;
char * scanHeader ( char * ip, char * limit ) ;
char * scanText (vnode *v, TMemoryStream *ms,
	char *ip, char *limit, short endSentinelKind) ;
void updateCloneIndices ( vnode * root, vnode * next ) ;</t>
<t tx="T705">@code

String nodeSentinelText ( vnode * v ) ;

void putCloseNodeSentinel ( vnode * v ) ;
void putCloseSentinels ( vnode * root, vnode * v ) ;

void putOpenLeoSentinel ( String text ) ;
void putOpenNodeSentinel ( vnode * v ) ;
void putOpenSentinels ( vnode * root, vnode * v ) ;

void putSentinel ( String text ) ;

short sentinelKind ( char *ip, char *limit ) ;
String sentinelName ( short sentinelKind ) ;

char * skipSentinelStart( char *ip, char *limit) ;</t>
<t tx="T706">@code

void appendToBody (TMemoryStream *ms, char *start, char *end);
void appendToBody (TMemoryStream *ms, String s);
void error ( String message );
void scanAllDirectives ( vnode * v );
char * skipIndent (long n, char * ip, char * limit);
void writeError ( String message );</t>
<t tx="T707">@code

// Top level...
vnode * findReference (vnode *root, char *ip, char *end_p, char *limit ) ;
bool inAtOthers (vnode * v) ;
void putAtOthers ( vnode * v, long delta ) ;
void putAtOthersChild ( vnode * v ) ;
void putBody ( vnode * root, vnode * v, long delta ) ;
void putBodyPart ( vnode * v ) ;
char * putCodePart ( vnode * v, char * ip, char * limit ) ;
char * putDirective ( char * ip, char * limit ) ;
char * putDoc ( char *ip, char *limit, short kind ) ;
char * putDocPart ( char * ip, char * limit ) ;

// Output methods...
void putBlanks (int n) ;
void putChar (char c) ;
void putIndent (int n) ;  // Outputs tabs corresponding to n spaces.
void putInt (int n) ;
char * putLeadingWs ( char * ip, char * limit_p ) ;
void putString ( String s ) ;
void putTabs (int n) ;</t>
<t tx="T708">// atFile.cpp created June 6, 2001.

#pragma option -w-par  // no warning: "Parameter is never used"
#pragma option -w-sig  // no warning: "Conversion may lose significant digits"

&lt;&lt; atFile includes &gt;&gt;
&lt;&lt; atFile abbreviations &gt;&gt;
&lt;&lt; atFile constants &gt;&gt;

@others</t>
<t tx="T709">#include &lt;vcl.h&gt;
#pragma hdrstop

#include "args.h"
#include "C_Tangle.h" // for some globals.
#include "Commands.h"
#include "hash.h"
#include "MainUnit.h" // for alert().
#include "atFile.h"
#include "tnode.h"
#include "Utils.h"
#include "vnode.h"

#include &lt;io.h&gt; // for creattemp().
#include &lt;ctype.h&gt;
#include &lt;dir.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;Filectrl.hpp&gt;  // For DirectoryExists.

#include "Leo.h"
</t>
<t tx="T710">#define oblank() this -&gt; putBlanks(1)
#define oblanks(n) this -&gt; putBlanks(n)
#define ochar(c) this -&gt; putChar(c)
#define oint(n) this -&gt; putInt(n)
#define onl() this -&gt; putChar('\n')
#define os(s) this -&gt; putString(s)
#define otab() this -&gt; putTabs(1)
#define otabs(n) this -&gt; putTabs(n)
</t>
<t tx="T711">@ These constants indicate the kind of at_directives.
@c

enum {
	noDirective,  // not an at-directive.
	docDirective, // @doc.
	atDirective,  // @&lt;space&gt; or @&lt;newline&gt;
	codeDirective, // @code
	cDirective, // @c&lt;space&gt; or @c&lt;newline&gt;
	othersDirective, // at-others
	miscDirective // All other directive
};

@ These constants indicate the kind of sentinel line.
@c

enum {
	noSentinel,  // Not a sentinel
	startAt, endAt, //@+at, @-at
	startBody, endBody, //@+body,@-body
  	startDoc, endDoc, //@+doc, @-doc
	startLeo, endLeo, // @+leo, @-leo
  	startNode, endNode, //@+node, @-node
 	startOthers, endOthers, //@+others, //@-others
	startRef, //@ &lt; &lt; ... @ &gt; &gt;
 	startVerbatim, //@verbatim
  	startDirective //@@
};
</t>
<t tx="T712">void Commands::readAtFile ( vnode * v )
{
	atFile * at = new atFile( this );
	at -&gt; read ( v ) ;
	delete at ;
}
</t>
<t tx="T713">void Commands::writeAtFile ( vnode * v )
{
	atFile * at = new atFile( this );
	at -&gt; write ( v ) ;
	delete at ;
}
</t>
<t tx="T714">atFile::atFile( Commands * theCommander )
{
	// Inialize ivars.
	mCommands = theCommander ;
	mErrors = 0 ;
	mStructureErrors = 0 ;
	mTargetFileName = "" ;
	mOutputFileName = "" ;
	mOutputStream = NULL ;
	indent = 0 ;
	mStartSentinelComment = "//" ;
	mEndSentinelComment = "" ;
	mRoot = NULL ;
}
</t>
<t tx="T715">@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c

vnode * atFile::createNthChild(long n, vnode * parent, String headline)
{
	assert(n &gt; 0);
	vnode * result = NULL ;

	// Create any needed dummy children.
	long dummies = n - parent -&gt; numberOfChildren() - 1 ;
	if ( dummies &gt; 0 )
		++ mStructureErrors ;

	while (dummies-- &gt; 0) {
		vnode * dummy = parent -&gt; insertAsLastChild(new tnode()) ;
		// The user should never see this headline.
		dummy -&gt; initHeadString ( "Dummy" ) ;
	}

	if (n &lt;= parent -&gt; numberOfChildren()) {
		result = parent -&gt; nthChild(n-1);
        if ( headline.Trim() != result -&gt; headString() . Trim() ) 
				++ mStructureErrors ;
    }
	else {
		++ mStructureErrors ;
        result = parent -&gt; insertAsLastChild(new tnode()) ;
	}

	result -&gt; initHeadString ( headline ) ;
    return result ;
}
</t>
<t tx="T716">@ This function joins all nodes in the two trees which should have the same topology. This code makes no other assumptions about the two trees; some or all of the nodes may already have been joined.

There are several differences between this method and the similar vnode:joinTreeTo method.  First, we can not assert that the two trees have the same topology because the derived file could have been edited outside of Leo.  Second, this method also merges the tnodes of all joined nodes.
@c

void atFile::joinTrees ( vnode *tree1, vnode *tree2 )
{
	assert(tree1 &amp;&amp; tree2);
	// Use a common tnode for both nodes.
	if ( tree1 -&gt; t() != tree2 -&gt; t() )
		tree1 -&gt; setT ( tree2 -&gt; t() ) ;
	// Join the roots using the vnode class.
    tree1 -&gt; joinNodeTo ( tree2 ) ;
    // Recursively join all subtrees.
    vnode *child1 = tree1 -&gt; firstChild() ;
    vnode *child2 = tree2 -&gt; firstChild() ;
    while (child1 &amp;&amp; child2) {
    	joinTrees ( child1, child2 ) ;
    	child1 = child1 -&gt; next() ;
    	child2 = child2 -&gt; next() ;
    }
	if (child1 || child2)
		error("cloned nodes have different topologies");
}
</t>
<t tx="T717">@ This is the entry point to the read code.  The root vnode should be an @file node.

If there are structure errors the first time we delete root and its body text, then rescan.  All other errors indicate potentially serious problems with sentinels.

The caller has enclosed this code in BeginUpdate/EndUpdate.
@c

void atFile::read ( vnode * root )
{
	&lt;&lt; Declare read vars &gt;&gt;
	mCommands -&gt; endEditing();  // Capture the current headline.
	mCommands -&gt; clearAllVisited() ;  // Clear the list of nodes for orphans logic.
	mTargetFileName = root -&gt; atFileNodeName();
	mRoot = root ;
	&lt;&lt; read the entire file into fileData &gt;&gt;
	if ( mErrors &gt; 0 ) return ;
	&lt;&lt; Scan the file buffer &gt;&gt;
	vnode *next = root -&gt; nodeAfterTree();
	if ( mStructureErrors &gt; 0 ) {
		mErrors = 0 ;
		&lt;&lt; Delete root's tree and body text &gt;&gt;
		&lt;&lt; Scan the file buffer &gt;&gt;
	}
	if ( mErrors == 0 ) {
		if ( mStructureErrors &gt; 0 ) {
			&lt;&lt; Issue structure error message &gt;&gt;
		}
        &lt;&lt; Handle clone bits &gt;&gt;
        &lt;&lt; Join cloned trees &gt;&gt;
        &lt;&lt; Handle all status bits &gt;&gt;
	}
	else {
		&lt;&lt; Issue serious error message &gt;&gt;
	}
}
</t>
<t tx="T718">String fileData("");
hashTable * h = NULL ;
TMemoryStream * ms = NULL ;
char *buf = NULL ;
char *ip = NULL ;
char *limit = NULL ;</t>
<t tx="T719">@c

if ( mTargetFileName . IsEmpty() )
	error("Missing file name in @file node");
else if ( FileExists ( mTargetFileName ) ) {
	TMemoryStream * ms = new TMemoryStream();
	try {
		ms -&gt; LoadFromFile(mTargetFileName);
		fileData = String ( (char *) ms -&gt; Memory, ms -&gt; Size - 1 ) ;
		buf = fileData . c_str() ;
	}
	catch (...) {
		error("Can not open " + mTargetFileName) ;
	}
	delete ms ;
}
else error ( mTargetFileName + " does not exit ");
</t>
<t tx="T720">indent = 0 ;
ip = buf ;
limit = ip + fileData.Length() ;
ms = new TMemoryStream() ;  // Must use new.

ip = scanHeader(ip, limit);
ip = scanText(root, ms, ip, limit, endLeo);

String s( (char *) ms -&gt; Memory, ms -&gt; Size);
root -&gt; setBodyStringOrPane(s);
delete ms ;
</t>
<t tx="T721">es("----- Minor error reading: ");
es(mRoot -&gt; headCString());
es(":marks have been cleared."); enl();</t>
<t tx="T722">while ( root -&gt; firstChild() )
	root -&gt; firstChild() -&gt; doDelete(root);
	
root -&gt; setBodyStringOrPane ( "" ) ;
</t>
<t tx="T723">@code

mCommands -&gt; clearAllVisited() ;

h = new hashTable() ;

for (vnode *v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() )
{
	long cloneIndex = v -&gt; t() -&gt; cloneIndex() ;
	
	// Special case: the root's cloneIndex field contains the max clone index.
	if ( v != root &amp;&amp; cloneIndex &gt; 0 ) {
		String key = h -&gt; longToString ( cloneIndex ) ;
		unsigned long hash = h -&gt; computeHash( key ) ;
		tnode * t = (tnode *) (h -&gt; lookup ( key, hash ));
		if ( t ) {
			// v is a clone: share the previous tnode.
			v -&gt; setT(t);
			t -&gt; setVisited(); // We will mark these clones later.
		}
		else h -&gt; enter ( key, v -&gt; t(), hash ) ;
	}
}

delete h ;

// Set clone marks for all visited tnodes.
for (vnode *v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() )
	if ( v -&gt; t() -&gt; isVisited() )
		v -&gt; initClonedBit(TRUE);</t>
<t tx="T724">@code

h = new hashTable() ;

for (vnode *v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() )
{
	long cloneIndex = v -&gt; t() -&gt; cloneIndex() ;
	
	// Special case: the root's cloneIndex field contains the max clone index.
	if ( v != root &amp;&amp; cloneIndex &gt; 0 ) {
		String key = h -&gt; longToString ( cloneIndex ) ;
		unsigned long hash = h -&gt; computeHash( key ) ;
		vnode * clone = (vnode *) (h -&gt; lookup ( key, hash ));
		if ( clone )
			this -&gt; joinTrees ( clone, v ) ;
		// Enter v so we can join the next clone to it.
		// The next call to lookup will find this v, not the previous.
		h -&gt; enter ( key, v, hash ) ;
	}
}

delete h ;</t>
<t tx="T725">vnode *current = NULL ;

for (vnode *v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() )
{
	v -&gt; setIcon();
	if ( v -&gt; isExpandedBitSet() )
		v -&gt; treeNode() -&gt; Expand ( FALSE ) ;
	else
		v -&gt; treeNode() -&gt; Collapse ( FALSE ) ;
	if ( v -&gt; isSelectedBitSet() )
		current = v ;
	if ( v -&gt; isTopBitSet() ) {
		// Just tell the open code we have seen the top vnode.
		mCommands -&gt; mTopVnode = v ;
	}
}

if ( current ) {
	// Indicate what the current node will be.
	mCommands -&gt; setCurrentVnode ( current ) ;
	#if 0 // old code
    	mCommands -&gt; makeVisible(current);
    	mCommands -&gt; setCurrentVnode ( NULL ) ;
    	mCommands -&gt; selectVnode ( current ) ;
	#endif
}
</t>
<t tx="T726">es("----- Serious error reading: ");
es(mRoot -&gt; headCString()); enl();
es("----- Outline may be corrupted due to damaged sentinel lines!"); enl();</t>
<t tx="T727">@ This method scans all vnodes, calling read for every @file node found.  v should point to the root of the entire tree on entry.
@c

void atFile::readAll ( vnode * root )
{
	vnode * v = root ;
	while (v) {
		if ( v -&gt; isAtIgnoreNode() )
			v = v -&gt; nodeAfterTree();
		else if ( v -&gt; isAtFileNode() ) {
			if ( ! v -&gt; isOrphan() )
            	this -&gt; read(v) ;
			v = v -&gt; nodeAfterTree();
		}
		else v = v -&gt; threadNext();
	}
	
	// Clear all dummy and orphan status bits.
	v = root ;
	while (v) {
		v -&gt; clearDummy();
		v -&gt; clearOrphan();
		v = v -&gt; threadNext();
	}
}

</t>
<t tx="T728">@ This method scans the doc part and appends the text to v's body.  The caller has already appended @&lt;space&gt; or @doc.
@c

char * atFile::scanDoc (
	TMemoryStream *ms, char *ip, char *limit, short kind )
{
	short endKind = kind == startDoc ? endDoc : endAt ;
	bool single = mEndSentinelComment . IsEmpty();
	&lt;&lt; Skip the opening sentinel &gt;&gt;
	&lt;&lt; Skip an opening block delim &gt;&gt;
	while (ip &lt; limit &amp;&amp; sentinelKind(ip, limit) != endKind ) {
		&lt;&lt; Append the next comment line to v's body &gt;&gt;
	}
	&lt;&lt; Skip the closing sentinel &gt;&gt;
	&lt;&lt; Remove a closing block delim from v's body &gt;&gt;
	return ip ;
}</t>
<t tx="T729">assert(match(ip, limit, kind == startDoc ? "+doc" : "+at"));
ip = skip_line(ip, limit); 
this -&gt; appendToBody(ms, kind == startDoc ? "@doc" : "@");
</t>
<t tx="T730">if ( ! single ) {
	char *ip1 = skip_ws(ip, limit);
	if (match(ip1, limit, mStartSentinelComment.c_str()))
		ip = skip_line(ip, limit);
}</t>
<t tx="T731">char *ip2 = skip_to_end_of_line(ip, limit);  // End of line.

// Point ip to the start of the real line.
if ( single ) {
	ip = skip_ws(ip, limit);
	if ( match(ip, limit, mStartSentinelComment.c_str()) ) {
	// Skip the opening comment delim and a blank.
		ip += mStartSentinelComment . Length();
		if (match(ip, limit, " "))
				++ip;
	}
}
else ip = skipIndent(indent, ip, limit);

// Append the line.
String line (ip, ip2-ip);
String trim = line . TrimRight();
this -&gt; appendToBody(ms, line);

// Append a newline if it is real.
if ( ip2 &lt; limit &amp;&amp; is_nl(*ip2) &amp;&amp; line == trim)
	this -&gt; appendToBody(ms, "\n");

// Finish the line.
ip = skip_line(ip, limit);
</t>
<t tx="T732">if ( sentinelKind(ip, limit) == endKind ) {
	ip = skipSentinelStart(ip, limit);
	ip = skip_line(ip, limit);
}
else error("Missing " + sentinelName(endKind) + " sentinel");
</t>
<t tx="T733">@ This code will typically only be executed for HTML files.
@c

if ( ! single )
{
	// Get what we have written so far.
	String s( (char *) ms -&gt; Memory, ms -&gt; Size);

	// Remove the ending block delimiter.
	// The delimiter includes leading and trailing newlines.
	String delim("\n");
	delim += mEndSentinelComment ;
	delim += "\n" ;
	long slen = s.Length(), dlen = delim.Length();
	if ( slen &gt; dlen ) {
		char * cs = s.c_str();
		char * ds = delim.c_str();
		if (strncmp(cs + slen - dlen, ds, dlen) == 0) {
			s = String(cs, slen - dlen);
			// Rewrite the stream.
			ms -&gt; Clear();
			ms -&gt; Write ( s.c_str(), s.Length() ) ;
        }
	}
}
</t>
<t tx="T734">@ This method sets mStartSentinelComment and mEndSentinelComment based on the first @+leo sentinel line of the file.  We can not call sentinelKind here because that depends on the comment delimiters we set here.
@c

char * atFile::scanHeader ( char * ip, char * limit )
{
    bool valid = TRUE ;
    char *tag = "@+leo" ;
    
    // Skip blank lines.
    ip = skip_ws_and_nl(ip, limit);
    char *ip0 = ip ;
    char *ip1 = ip ;
    
    // The opening comment delim is the initial non-whitespace.
    while (ip &lt; limit &amp;&amp; !match(ip,limit,tag) &amp;&amp; !is_ws(*ip) &amp;&amp; !is_nl(*ip))
    	++ip ;
    if (ip1 &lt; ip )
    	mStartSentinelComment = String (ip1, ip - ip1 ) ;
    else valid = FALSE ;
    
    // Make sure we have @+leo
    ip = skip_ws(ip, limit);
    if ( match(ip, limit, tag))
    	ip += strlen(tag) ;
    else valid = FALSE ;
    
    // The closing comment delim is the trailing non-whitespace.
    ip1 = ip = skip_ws(ip, limit);
    while (ip &lt; limit &amp;&amp; !is_ws(*ip) &amp;&amp; !is_nl(*ip))
    	++ip ;
    mEndSentinelComment = String (ip1, ip - ip1);
    
    if ( valid )
    	ip = skip_line(ip0, limit);
    else
    	error("Bad @+leo sentinel in " + mTargetFileName);
		
	return ip ;
}</t>
<t tx="T735">@ This method is the heart of the new read code.  It scans text until the given ending sentinel is found, and warns if any other ending sentinel is found instead.  It calls itself recursively to handle most nested sentinels.
@c

char * atFile::scanText (
	vnode *v, // The vnode whose body we are accumualting.
	TMemoryStream *ms,  // The stream used to accumulate the body.
	char *ip, // Pointer into the file buffer.
	char *limit,  // The end of the file buffer.
	short endSentinelKind )  // The ending sentinel we expect.
{
	long lineIndent = 0 ;  // Changed only for sentinels.
	while (ip &lt; limit) {
		short kind = sentinelKind(ip, limit) ;
		char *linep = ip ;
		if ( kind != noSentinel ) {
			&lt;&lt; set lineIndent and linep &gt;&gt;
			ip = this -&gt; skipSentinelStart(ip, limit);
		}
		switch (kind) {
		case noSentinel: &lt;&lt; remove indent and append line &gt;&gt;break ;
		case startAt: &lt;&lt; scan @+at &gt;&gt; break ;
		case startBody: &lt;&lt; scan @+body &gt;&gt;; break ;
		case startDirective: &lt;&lt; scan @@ &gt;&gt; break ;
		case startDoc: &lt;&lt; scan @+doc &gt;&gt; break ;
		case startLeo: &lt;&lt; scan @+leo &gt;&gt; break ;
  		case startNode: &lt;&lt; scan @+node &gt;&gt; break ;
 		case startOthers: &lt;&lt; scan @+others &gt;&gt; break ;
		case startRef: &lt;&lt; scan @ref &gt;&gt; break ;
 		case startVerbatim: &lt;&lt; scan @verbatim &gt;&gt; break ;
		case endAt: case endBody: case endDoc:
		case endLeo: case endNode: case endOthers:
			&lt;&lt; handle an ending sentinel &gt;&gt; break ;
		default: &lt;&lt; warn about unknown sentinel &gt;&gt;
		}
	}
	&lt;&lt; handle unexpected end of text &gt;&gt;
	return ip ;
}
</t>
<t tx="T736">@ lineIndent is the total indentation on a sentinel line.  The first "indent" portion of that must be removed when recreating text.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

{
	// All sentinels except +leo should start with a newline.
    char *ip1 = ip ;
    if ( is_nl(*ip1) )
    	ip1 = skip_nl(ip1, limit);
    	
    linep = skipIndent ( indent, ip1, limit ) ;
    
	// Calculate the total indentation on the line.
    long n = 0 ;
    while (ip1 &lt; limit) {
    	if (*ip1 == '\t') n += ( arg_tab_width - n % arg_tab_width ) ;
    	else if (*ip1 == ' ') ++ n ;
    	else break ;
    	++ ip1 ;
    }

	lineIndent = n ;
}</t>
<t tx="T737">@ The sentinelKind routine returned noSentinel, so if the line contains only a newline that newline is not part of a sentinel and it must be appended to make progress.  Otherwise, we don't want to append the trailing newline here because it might be part of a sentinel.
@c

{
	char *ip1 = skipIndent ( indent, ip, limit ) ;
	// Append only newlines that can't be part of a sentinel.
	if (ip &lt; limit &amp;&amp; is_nl(*ip))
		ip = skip_nl(ip, limit);
	else
		ip = skip_to_end_of_line(ip, limit);
	String line (ip1, ip-ip1);
	this -&gt; appendToBody(ms, line);
}</t>
<t tx="T738">ip = skip_line(ip, limit); // Skip the sentinel.

if (kind == endSentinelKind) {
	if (kind == endLeo) {
		ip = skip_ws_and_nl(ip,limit);
		if (ip &lt; limit)
			error("Ignoring text after @-leo");
	}
	return ip ;
}
else {
	// Tell of the structure error.
	String name = sentinelName(kind);
	String expect = sentinelName(endSentinelKind);
	error( "Ignoring " + name + " sentinel.  Expecting " + expect);
}</t>
<t tx="T739">// Issue the error.
String name = sentinelName(endSentinelKind);
error("Unexpected end of file. Expecting " + name + "sentinel" );</t>
<t tx="T740">assert(match(ip,limit,"+at"));
ip = scanDoc(ms, ip, limit, kind);</t>
<t tx="T741">assert(match(ip,limit,"+body"));
ip = skip_line(ip, limit); // Skip the sentinel.
ip = scanText(v, ms, ip, limit, endBody );
</t>
<t tx="T742">assert(match(ip,limit,"+doc"));
ip = scanDoc(ms, ip, limit, kind);
</t>
<t tx="T743">assert(match(ip,limit,"+leo"));
ip = skip_line(ip, limit);
error("Ignoring unexpected @+leo sentinel" );</t>
<t tx="T744">{
	long n = 0 ; // Default for bad index.
	String headline (""), ref("");
	tnode dummy_t(0,"");
	vnode dummy(mCommands, &amp;dummy_t) ;  // A dummy vnode to carry status bits.
	&lt;&lt; skip the node sentinel, setting headline, ref and n &gt;&gt;
	long cloneIndex = dummy . t() -&gt; cloneIndex();
	long oldIndent = indent ;
	indent = lineIndent ;
	if ( n == 0 ) {
		&lt;&lt; Check the filename in the sentinel &gt;&gt;
		// Put the text of the root node in the current node.
		ip = scanText(v, ms, ip, limit, endNode );
		v -&gt; t() -&gt; setCloneIndex ( cloneIndex ) ;
	}
	else {
		TMemoryStream * new_ms = new TMemoryStream() ;  // Must use new.
		vnode *child = createNthChild(n, v, headline);
		child -&gt; t() -&gt; setCloneIndex ( cloneIndex ) ;
		ip = scanText(child, new_ms, ip, limit, endNode );
		// If text followed the section reference in the outline,
		// that text will immediately follow the //@-node sentinel.
		if (ip &lt; limit &amp;&amp; !is_nl(*ip)) {
			char *ip1 = ip;
			ip = skip_line(ip, limit);
			String line (ip1, ip-ip1);
			this -&gt; appendToBody(ms, line);
		}
		&lt;&lt; copy new_ms to child's body &gt;&gt;
		delete new_ms;
	}
	indent = oldIndent ;
}
</t>
<t tx="T745">assert(match(ip,limit,"+node:"));
ip += 6 ;
ip = skip_ws(ip, limit);

// Compute the child index.
char *np = ip ; // Start of number.
while (ip &lt; limit &amp;&amp; isdigit(*ip))
	++ip ;

if (np == ip || !match(ip, limit, ":"))
	error("Bad child index in @+node");
else {
    String s(np, ip-np);
    n = s . ToInt();
    ++ip ; // Skip the ":".
}

&lt;&lt; Set status bits in dummy vnode &gt;&gt;

if ( match(ip, limit, ":") )
	++ ip ;
else
	error("Bad attribute field in @+node");

// Set headline.
char *hp = ip ;

if ( mEndSentinelComment . IsEmpty() )
	ip = skip_to_end_of_line(ip, limit);
else {
	while (
		ip &lt; limit &amp;&amp; ! is_nl(*ip) &amp;&amp;
		! match (ip, limit, mEndSentinelComment . c_str() )
	)
		++ ip ;
}
headline = String(hp, ip-hp);
headline = headline . TrimRight();

// Set reference if it exists.
ip = hp ;
ip = skip_ws(ip, limit);
char *rp = ip ;
if (match(ip, limit, "&lt;&lt;")) {
	while ( ip &lt; limit &amp;&amp; !is_nl(*ip) &amp;&amp; !match(ip, limit, "&gt;&gt;"))
		++ ip ;
	if (match(ip, limit, "&gt;&gt;"))
		ref = String(rp, ip+2-rp);
}
ip = skip_line(hp, limit);
</t>
<t tx="T746">while ( ip &lt; limit &amp;&amp; *ip != ':' &amp;&amp; !is_nl(*ip) )
{
	long index = 0 ;
	
	switch (*ip++) {
	case 'C' :
		&lt;&lt; set index from the C=nnn, field &gt;&gt;
		dummy . t() -&gt; setCloneIndex(index);
		break ;
	default : break ; // Ignore unknown status bits.
	}
}
</t>
<t tx="T747">@code

if ( *ip == '=' ) {
	++ ip ;
	char *ip1 = ip ;
	while ( ip &lt; limit &amp;&amp; isdigit(*ip) )
		++ ip ;
	String s(ip1, ip - ip1);
	index = s.ToInt();
	if ( ip &lt; limit &amp;&amp; *ip == ',' )
		++ ip ;
}
</t>
<t tx="T748">String s( (char *) new_ms -&gt; Memory, new_ms -&gt; Size);
String body = child -&gt; bodyString();

if ( child -&gt; isDummy() )
	child -&gt; clearDummy();
else if ( child -&gt; isOrphan() )
	error("Replacing body text of orphan: " + child -&gt; headString());
else if ( body . Length() &gt; 0 &amp;&amp; body != s )
	error("Duplicate definition of " + child -&gt; headString());

// At present we _always_ update the body text.
// This is reasonable, but maybe not best.
child -&gt; t() -&gt; setTnodeText ( s );
</t>
<t tx="T749">String fileName = headline.Trim();
long len = fileName.Length();
if ( len &gt; 5 &amp;&amp; fileName.SubString(1,5) == "@file") {
	fileName = fileName.SubString(6,len-5);
	if ( fileName.Trim() != mTargetFileName.Trim() )
		error("File name in @node sentinel does not match file's name");
}
else error ("Missing @file in root @node sentinel");
</t>
<t tx="T750">@ We must make sure that the generated at-others is properly indented.
@c

assert(match(ip,limit,"+others"));
ip = skip_line(ip, limit); // Skip the sentinel.

// Append the real leading whitespace and at-others.
{
	char *ip2 = skip_ws(linep, limit);
	String ws(linep, ip2 - linep );
	this -&gt; appendToBody(ms, ws);
	this -&gt; appendToBody(ms, "@others");
}
ip = scanText(v, ms, ip, limit, endOthers );
</t>
<t tx="T751">@ The sentinel contains an @ followed by a section name in angle brackets.

This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(match(ip,limit,"&lt;&lt;"));
{
	String line("");
	char *ip1 = ip ;

	if ( mEndSentinelComment . IsEmpty() ) {
    	// Append the rest of the sentinel line to the text.
    	ip = skip_to_end_of_line(ip, limit);
    	line = String(ip1, ip-ip1);
	}
	else {
		while (
			ip &lt; limit &amp;&amp; ! is_nl(*ip) &amp;&amp;
			! match (ip, limit, mEndSentinelComment . c_str() )
		)
			++ ip ;
		line = String(ip1, ip-ip1);
	}
	ip = skip_line(ip1, limit);
    this -&gt; appendToBody(ms, line);
}</t>
<t tx="T752">assert(match(ip,limit,"verbatim"));
{
	// Skip the sentinel.
	ip = skip_line(ip,limit);

	// Append the next line to the text.
	char *ip1 = skipIndent ( indent, ip, limit ) ;
	ip = skip_line(ip, limit);
	String line (ip1, ip-ip1);
	this -&gt; appendToBody(ms, line);
}</t>
<t tx="T753">assert(match(ip,limit,"@"));
{
	String line("");
	char *ip1 = ip ;  // The first '@' has already been eaten.

	if ( mEndSentinelComment . IsEmpty() ) {
    	// Append the rest of the sentinel line to the text.
    	ip = skip_line(ip, limit);
    	line = String(ip1, ip-ip1);
	}
	else {
		while (
			ip &lt; limit &amp;&amp; ! is_nl(*ip) &amp;&amp;
			! match (ip, limit, mEndSentinelComment . c_str() )
		)
			++ ip ;
		line = String(ip1, ip-ip1);
		line += "\n" ;
		ip = skip_line(ip1, limit);
	}
    this -&gt; appendToBody(ms, line);
}</t>
<t tx="T754">{
	char * ip1 = ip ;
	ip = skip_line(ip, limit);
	String line (ip1, ip-ip1);
	error("Unknown sentinel: " + line);
}</t>
<t tx="T755">@ root is an ancestor of v, or root == v.  This puts the entire expansion of v's body text enclosed in sentinel lines.
@c

void atFile::putBody ( vnode * root, vnode * v, long delta )
{
	indent += delta ;
		putOpenSentinels(root, v) ;
			putBodyPart(v);
			v -&gt; setVisited();
		putCloseSentinels(root, v) ;
	indent -= delta ;
}</t>
<t tx="T756">@ We generate the body part only if it contains something besides whitespace. The check for at-ignore is made in atFile::write.
@c

void atFile::putBodyPart ( vnode * v )
{
	char *ip = (char *) v -&gt; bodyCString() ;
	char *limit = ip + v -&gt; bodyCStringLength() ;
	char *ip2 = skip_ws_and_nl(ip, limit) ;
	if ( ip2 &gt;= limit ) return ;
	// adjust limit so there is no trailing whitespace.
	while ( limit &gt; ip &amp;&amp; is_ws( *(limit-1) ) )
		--limit ;
	putSentinel("@+body");
	&lt;&lt; put code/doc parts and sentinels &gt;&gt;
	putSentinel("@-body");
}</t>
<t tx="T757">while (ip &lt; limit) {
	short kind = directiveKind(ip, limit) ;
	char *ip1 = ip ;
	switch ( kind ) {
	case docDirective :
	case atDirective :
		ip = putDoc(ip, limit, kind); break ;
	case miscDirective :
		ip = this -&gt; putDirective(ip, limit); break ;
	case noDirective :
	case othersDirective :
		ip = this -&gt; putCodePart(v, ip, limit); break ;
	case cDirective :
	case codeDirective :
		ip = this -&gt; putDirective(ip, limit);
		ip = this -&gt; putCodePart(v, ip, limit);
		break ;
	default : assert (0);
    }
	assert (ip1 &lt; ip);  // We must make progress.
}
</t>
<t tx="T758">@ This method expands a code part, terminated by any at-directive except at-others.  It expands references and at-others and outputs @verbatim sentinels as needed.
@c

char * atFile::putCodePart ( vnode * v, char * ip, char * limit )
{
	bool atOthersSeen = FALSE ; // TRUE: at-others has been expanded.
	while (ip &lt; limit) {
		long delta = 0 ; // How much indent should change.
		&lt;&lt; handle the start of a line &gt;&gt;
		&lt;&lt; put the line &gt;&gt;
	}
done:
	return ip ;
}</t>
<t tx="T759">@ The at-others directive is the only directive that is recognized following leading whitespace, so it is just a little tricky to recognize it.
@c

&lt;&lt; compute delta, the width of the whitespace &gt;&gt;

short kind1 = directiveKind(ip, limit);
short kind2 = directiveKind(skip_ws(ip,limit), limit);

if ( kind1 == othersDirective || kind2 == othersDirective ) {
	&lt;&lt; handle @others &gt;&gt;
}
else if ( kind1 == noDirective ) {
	&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;
}
else goto done ;</t>
<t tx="T760">delta = 0 ;
{
	char * ip2 = ip ;
	while ( ip2 &lt; limit ) {
		if ( *ip2 == ' ' ) {
			++ delta ;
			++ ip2 ;
		}
		else if ( *ip2 == '\t' ) {
			delta += (arg_tab_width - (delta % arg_tab_width)) ;
			++ ip2 ;
		}
		else break ;
	}
}
</t>
<t tx="T761">// This skips all indent and delta whitespace, so putAtOthers must generate it all.

ip = skip_to_end_of_line(ip, limit);  // Bug fix: 7/6/01
if ( atOthersSeen )
	writeError( "@others already expanded in: " + v -&gt; headString());
else {
	atOthersSeen = TRUE ;
	putAtOthers(v, delta);
}
</t>
<t tx="T762">{
	String s(mStartSentinelComment);
	s += "@" ;
	if (match (ip, limit, s.c_str()))
		putSentinel("verbatim");
}
</t>
<t tx="T763">putIndent(indent);

while (ip &lt; limit ) {
    if (*ip == body_newline) {
    	onl();
    	ip = skip_nl(ip, limit);
    	break ;
    }
    else if (*ip == body_ignored_newline)
    	++ip;
	// at-others is recognized _only_ at the start of a line.
    else if (*ip == '&lt;') {
    	&lt;&lt; put possible section reference &gt;&gt;
    }
    else ochar(*ip++);
}</t>
<t tx="T764">char *end_p = NULL ;

if ( isSectionName ( ip, limit, &amp;end_p ) )
{
	// Create a reference sentinel.
	String s(ip, end_p - ip);
	putSentinel("@" + s);

	// Output the expansion.
	vnode * ref = findReference(v, ip, end_p, limit);
	if ( ref )
		putBody(v, ref, delta);
	else {
		String s("undefined section: ");
		s += String(ip, end_p - ip);
		s += "\n\treferenced from: ";
		s += v -&gt; headString();
		writeError(s);
	}
	ip = end_p ;
}
else ochar(*ip++);  // This is _not_ an error.
</t>
<t tx="T765">@ ip points to the start of a reference in root.  We search the descendents of root looking for the matching definition node.  There should be exactly one such node (descendents of other definition nodes are not searched).
@c

vnode * atFile::findReference (
	vnode * root, char * ip, char *end_p, char * limit )
{
	String pattern(ip, end_p - ip);
	vnode * next = root -&gt; nodeAfterTree();
	vnode * v = root -&gt; firstChild();
	while ( v &amp;&amp; v != next ) {
		if ( v -&gt; matchHeadline(pattern) &amp;&amp; ! v -&gt; isAtIgnoreNode() )
			return v ;
		v = v -&gt; threadNext();
	}
	return NULL ;
}</t>
<t tx="T766">@ Returns TRUE if v should be included in the expansion of the at-others directive in the body text of v's parent. v will not be included if it is a definition node or if its body text contains another at-others or @ignore directive.
@c

bool atFile::inAtOthers (vnode * v)
{
	// Return FALSE if this has been expanded previously.
	if ( v -&gt; isVisited() )
		return FALSE;
	// Return FALSE if this is a definition node.
	String h = v -&gt; headString();
	char * ip = h . c_str();
	char * limit = ip + strlen(ip);
	ip = skip_ws(ip, limit);
	if ( isSectionName(ip, limit, NULL) )
		return FALSE ;
	// Return FALSE if v's body contains an @ignore or at-others directive.
	return ! v -&gt; isAtIgnoreNode() &amp;&amp; ! v -&gt; isAtOthersNode() ;
}
</t>
<t tx="T767">@ The at-others directive is recognized only at the start of the line.  This code must generate all leading whitespace for the opening sentinel.
@c

void atFile::putAtOthers ( vnode * v, long delta )
{
	indent += delta ;
	putSentinel("@+others");
        vnode * child = v -&gt; firstChild();
        while ( child ) {
        	if ( this -&gt; inAtOthers( child ) )
        		putAtOthersChild( child ) ;
        	child = child -&gt; next();
        }
	putSentinel("@-others");
	indent -= delta ;
}
</t>
<t tx="T768">void atFile::putAtOthersChild ( vnode * v )
{
	putOpenNodeSentinel(v) ;
		// Insert the expansion of v.
		v -&gt; setVisited(); // Make sure it is never expanded again.
		putBodyPart(v);
		// Insert expansions of all children.
		vnode * child = v -&gt; firstChild();
		while ( child ) {
			if ( this -&gt; inAtOthers( child ) )
				putAtOthersChild( child ) ;
			child = child -&gt; next();
		}
	putCloseNodeSentinel(v) ;
}
</t>
<t tx="T769">@ This method outputs the directive or reference at ip in a sentinel.
@c

char * atFile::putDirective ( char * ip, char * limit )
{
	assert(ip &lt; limit &amp;&amp; *ip == '@');
	char *ip1 = ip;
	ip = skip_to_end_of_line(ip, limit);
	assert(ip1 &lt; ip);
	String directive(ip1, ip-ip1);
	ip = skip_line(ip1, limit);
	this -&gt; putSentinel ( "@" + directive ) ;
	return ip ;
}
</t>
<t tx="T770">@ This method outputs a doc section terminated by @code or end-of-text.  All other interior directives become part of the doc part.
@c

char * atFile::putDoc ( char *ip, char *limit, short kind )
{
	assert(kind == atDirective || kind == docDirective);
	&lt;&lt; skip the @&lt;space&gt; or @doc &gt;&gt;
	&lt;&lt; set limit to the end of the doc part &gt;&gt;
	String tag = kind == docDirective ? "doc" : "at" ;
	putSentinel("@+" + tag);
	ip = putDocPart(ip,limit);
	putSentinel("@-" + tag);
	return ip ;
}
</t>
<t tx="T771">@ Do not skip whitespace following the @doc or @.  It is needed by the read code.
@c

if ( kind == docDirective )
	ip += 4 ; // Skip the "@doc"
else
	++ip; // Skip the "@";
</t>
<t tx="T772">@ at-code or the end of body text terminates the doc part.
@c

char *ip2 = ip ;
while ( ip2 &lt; limit ) {
	ip2 = skip_line(ip2, limit) ;
	short kind = directiveKind(ip2, limit) ;
	if (kind == codeDirective || kind == cDirective)
		break ;
}

limit = ip2 ;
</t>
<t tx="T773">@ This method puts a comment part in comments.
@c

char * atFile::putDocPart ( char * ip, char * limit )
{
	bool single = mEndSentinelComment . IsEmpty() ;

	if (!single) {
		putIndent(indent);
		os(mStartSentinelComment.c_str()); onl();
	}
	// Put all lines.
	while (ip &lt; limit) {
		putIndent(indent);
		long leading = indent ;
		if (single) {
			os(mStartSentinelComment.c_str()); oblank();
			leading += mStartSentinelComment . Length() + 1 ;
		}
		&lt;&lt; copy words, splitting the line if needed &gt;&gt;
	}
	if (!single) {
		// This comment is like a sentinel.
		onl(); putIndent(indent);
		os(mEndSentinelComment.c_str());
		onl();  // Note: no trailing whitespace.
	}
	return ip ;
}
</t>
<t tx="T774">@ We remove trailing whitespace from lines that have _not_ been split so that a newline has been inserted by this routine if and only if it is preceded by whitespace.
@c

char *line = ip ; // Start of the current line.

while (ip &lt; limit) {
	char * word = ip;  // Start of the current word.

	// Skip the next word and trailing whitespace.
	ip = skip_ws(ip, limit);
	while (ip &lt; limit &amp;&amp; !is_nl(*ip) &amp;&amp; !is_ws(*ip))
		++ ip ;
	ip = skip_ws(ip,limit);
	
	// Output the line if no more is left.
	if (ip &lt; limit &amp;&amp; is_nl(*ip))
		break ;

	// Split the line before the current word if needed.
    long len = ip - line ;
    if (line == word || leading + len &lt; arg_page_width )
    	word = ip ; // Advance to the next word.
    else {
    	// Write the line before the current word and insert a newline.
    	String theLine(line, word-line);
    	putString(theLine);
    	onl();  // This line must contain trailing whitespace.
		line = ip = word ; // Rescan the word on the next line.
    	break ;
	}
}

// Remove trailing whitespace and output the remainder of the line.
String theLine(line, ip-line);
theLine = theLine . TrimRight();
putString(theLine);

if (ip &lt; limit &amp;&amp; is_nl(*ip) ) {
	ip = skip_nl(ip, limit);
	onl();  // No an inserted newline and no trailing whitespace.
}</t>
<t tx="T775">@ This is the entry point to the write code.  The root vnode should be an @file node.
We set the orphan flag if there are problems writing the file to force Commands::write_LEO_file to the tree to the .leo file.
@c

void atFile::write ( vnode * root )
{
	mRoot = root ;
	mCommands -&gt; endEditing();  // Capture the current headline.
	&lt;&lt; Open files.  Set orphan flag and return on errors &gt;&gt;
	mCommands -&gt; clearAllVisited() ; // Unvisited nodes will be orphans.
    vnode * next = root -&gt; nodeAfterTree();
	updateCloneIndices(root, next);
	putOpenLeoSentinel("@+leo");
		putOpenNodeSentinel(root) ;
    	putBodyPart(root);
		root -&gt; setVisited();
		putCloseNodeSentinel(root) ;
	putSentinel("@-leo");
	delete mOutputStream ;  // Close the output file.
	mOutputStream = NULL ;
	&lt;&lt; Warn about @ignored and orphans  &gt;&gt;
	if ( mErrors &gt; 0 || mRoot -&gt; isOrphan() ) {
		mRoot -&gt; setOrphan() ;
		remove ( mOutputFileName.c_str() ) ;  // Delete the temp file.
		&lt;&lt; Issue final write error message &gt;&gt;
	}
	else {
		&lt;&lt; Replace the target with the temp file if different &gt;&gt;
	}
}
</t>
<t tx="T776">@code

// Set globals from ancestors.
this -&gt; scanAllDirectives(root);
if ( mErrors &gt; 0 ) {
	mRoot -&gt; setOrphan();
	return ;
}

mTargetFileName = root -&gt; atFileNodeName();
&lt;&lt; setOrphan and return if mTargetFileName is bad &gt;&gt;
&lt;&lt; Open a temp file and set mOutputFileName &gt;&gt;
mOutputStream = new TFileStream(mOutputFileName, fmOpenWrite);
if ( mOutputStream == NULL ) {
	mRoot -&gt; setOrphan();
	return ;
}</t>
<t tx="T777">@code


if ( mTargetFileName . Length() == 0 ) {
	root -&gt; setOrphan();
	return ;
}

long index = mTargetFileName.LastDelimiter("\\");

if ( index &gt; 0 ) {
	String path = mTargetFileName.SubString(1, index - 1);
	if ( path.Length() &gt; 0 &amp;&amp; ! DirectoryExists(path) ) {
		root -&gt; setOrphan();
		return ;
	}
}
</t>
<t tx="T778">@ We create the temporary file where the target file will eventually be placed:

1. In the directory specified in mTargetFileName if it contains a full path.
2. In the directory specified in an @path directive.
3. In the directory specified in the Preferences panel.
4. In the current directory.

scanAllDirectives sets the current directory as specified by @path or the Preferences panel, so we need only check to see if mTargetFileName contains a full path.
@c

// Put the current directory path in pathname.
char pathname[MAXPATH];
strcpy(pathname, "X:\\");
pathname[0] = 'A' + getdisk(); // replace X with current drive letter
int result = getcurdir(0, &amp;pathname[3]);
if ( result == -1 ) strcat(pathname, "\\");

// Make sure pathname ends with a backslash.
long len = strlen(pathname);
if ( len == 0 || pathname[len-1] != '\\')
	strcat(pathname, "\\");

// scanAllDirectives also checks directory names.
if ( ! DirectoryExists ( pathname ) ) {
	writeError ( String("Directory \"") + pathname + "\" does not exist " );
	return ;
}

int handle = creattemp(pathname, 0);
if (handle == -1 ) {
	writeError ( String("Can not create \"") + pathname + "\"" );
	return ;
}
else close (handle);

String s ( (char *) pathname);
mOutputFileName = s ;</t>
<t tx="T779">for ( vnode * v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() ) {
	if ( ! v -&gt; isVisited() ) {
		mRoot -&gt; setOrphan();
		String s("Orphan node:  ");
		s += v -&gt; headString();
		writeError ( s.c_str() ) ;
	}
	if ( v -&gt; isAtIgnoreNode() ) {
		mRoot -&gt; setOrphan();
		String s("@ignore node: ");
		s += v -&gt; headString();
		writeError ( s.c_str() ) ;
	}
}
</t>
<t tx="T780">ecnl() ;
es("----- Not written: ");
es(mTargetFileName.c_str()); enl();</t>
<t tx="T781">if ( compareFiles ( mOutputFileName, mTargetFileName ) ) {
	// Just delete the temp file.
	remove ( mOutputFileName.c_str() ) ;
	es("Unchanged: "); es(mTargetFileName.c_str() ); enl();
}
else {
	// Replace target file with temp file.
	if ( FileExists ( mTargetFileName ) )
		remove ( mTargetFileName . c_str() ) ;
	if ( 0 != rename ( mOutputFileName . c_str(), mTargetFileName.c_str() ) ) {
		writeError("Rename failed: no file created!");
	}
	else {
		es("Writing: "); es(mTargetFileName.c_str() ); enl();
	}
}
</t>
<t tx="T782">@ This method scans all vnodes, calling write for every @file node found.  v should point to the root of the entire tree.
@c

void atFile::writeAll ( vnode * v )
{
	&lt;&lt; Clear all orphan bits &gt;&gt;
    while ( v ) {
        if ( v -&gt; isAtIgnoreNode() )
            v = v -&gt; nodeAfterTree();
        else if ( v -&gt; isAtFileNode() ) {
			if ( v -&gt; isDirty() )
            	this -&gt; write(v) ;
            v = v -&gt; nodeAfterTree();
        }
        else v = v -&gt; threadNext();
    }
}
</t>
<t tx="T783">@ We must clear these bits because they may have been set on a previous write.  Calls to atFile::write may set the orphan bits in @file nodes.  If so, write_LEO_file will write the entire @file tree.
@c

for ( vnode * v2 = v ; v2 ; v2 = v2 -&gt; threadNext() )
	v2 -&gt; clearOrphan();</t>
<t tx="T784">@ These methods write their arguments to the output file.
</t>
<t tx="T785">void atFile::putBlanks ( int n )
{
	while (n-- &gt; 0)
		ochar(' ');
}
</t>
<t tx="T786">void atFile::putChar (char c)
{
	if ( mOutputStream )
		mOutputStream -&gt; Write( &amp;c, 1 );
}
</t>
<t tx="T787">@ This methods puts tabs and spaces corresponding to n spaces, assuming that we are at the start of a line.
@c

void atFile::putIndent ( int n )
{
	if ( arg_tab_width &gt; 1 ) {
		otabs ( n / arg_tab_width ) ;
    	oblanks ( n % arg_tab_width ) ;
	}
	else
		oblanks ( n ) ;
}</t>
<t tx="T788">void atFile::putInt (int i) 
{
	char buf [100];
	long n = sprintf(buf, "%d", i);
	if ( n != EOF )
		putString(buf);
}</t>
<t tx="T789">void atFile::putString ( String s ) 
{
	if ( mOutputStream )
		mOutputStream -&gt; Write( s.c_str(), s.Length() );
}
</t>
<t tx="T790">void atFile::putTabs ( int n )
{
	while ( n-- &gt; 0 )
		ochar('\t');
}
</t>
<t tx="T791">String atFile::nodeSentinelText ( vnode * v )
{
	String s("");
	// A hack: zero indicates the root node so scanText won't create a child.
	long index = 0 ;
	if ( v != mRoot &amp;&amp; v -&gt; parent() )
		index = v -&gt; childIndex() + 1 ;
	s += String(index);
	s += ":" ;
	&lt;&lt; append the status-bit characters to s &gt;&gt;
	s += ":" ;
	s += v -&gt; headString();
	return s ;
}
</t>
<t tx="T792">@ The cloneIndex field of the @root node is really the maximum clone index.

We make the @file node the top or current node if the top or current node is a descendent of the root.  This minimizes changes to the derived file.
@c

long cloneIndex = v -&gt; t() -&gt; cloneIndex() ;

if ( cloneIndex &gt; 0 ) {
	s += "C=" ;
	s += String ( cloneIndex );
}

</t>
<t tx="T793">void atFile::putCloseNodeSentinel ( vnode * v )
{
	String s = this -&gt; nodeSentinelText(v);
	this -&gt; putSentinel( "@-node:" + s);
}
</t>
<t tx="T794">@ root is an ancestor of v, or root == v.  We call putCloseSentinel for v up to, but not including, root.
@c

void atFile::putCloseSentinels ( vnode * root, vnode * v )
{
	this -&gt; putCloseNodeSentinel(v);
	for (;;) {
		v = v -&gt; parent();
		assert(v); // root must be an ancestor of v.
		if ( v == root ) break ;
		this -&gt; putCloseNodeSentinel(v);
	}
}</t>
<t tx="T795">@ This method is the same as putSentinel except we don't put an opening newline and leading whitespace.
@c

void atFile::putOpenLeoSentinel ( String text )
{
	os(mStartSentinelComment);
	os(text);
	os(mEndSentinelComment);
	onl(); // Ends of sentinel.
}</t>
<t tx="T796">@ This method puts an open node sentinel for node v.
@c

void atFile::putOpenNodeSentinel ( vnode * v )
{
	if ( v -&gt; isAtFileNode() &amp;&amp; v != mRoot )
		writeError("@file not valid in: " + v -&gt; headString() );
	else {
		String s = this -&gt; nodeSentinelText(v);
		this -&gt; putSentinel( "@+node:" + s);
	}
}
</t>
<t tx="T797">@ root is an ancestor of v, or root == v.  We call putOpenNodeSentinel on all the descendents of root which are the ancestors of v.
@c

void atFile::putOpenSentinels ( vnode * root, vnode * v )
{
	vnode * last = root ;
	while ( last != v ) {
		// Set node to v or the ancestor of v that is a child of last.
		vnode * node = v ;
		while ( node &amp;&amp; node -&gt; parent() != last )
			node = node -&gt; parent();
		assert(node);
		this -&gt; putOpenNodeSentinel(node);
		last = node ;
	}
}</t>
<t tx="T798">@ All sentinels are eventually output by this method.

Sentinels include both the preceding and following newlines. This rule greatly simplies the code and has several important benefits:

1. Callers never have to generate newlines before or after sentinels.  Similarly, routines that expand code and doc parts never have to add "extra" newlines.
2. There is no need for a "no-newline" directive.  If text follows a section reference, it will appear just after the newline that ends sentinel at the end of the expansion of the reference.  If no significant text follows a reference, there will be two newlines following the ending sentinel.

The only exception is that no newline is required before the opening "leo" sentinel. The putLeoSentinel and isLeoSentinel routines handle this minor exception.
@c

void atFile::putSentinel ( String text )
{
	onl(); putIndent(indent); // Start of sentinel.
	os(mStartSentinelComment);
	os(text);
	os(mEndSentinelComment);
	onl(); // Ends of sentinel.
}</t>
<t tx="T799">@ This method tells what kind of sentinel appears at ip.  Typically ip will point to the newline before the actual sentinel, but it is also valid for ip to point directly at the start of a sentinel line.
@c

#define test(name,start,end)\
	if(match_word(ip,limit,name)) { return plus ? start : end ; }

short atFile::sentinelKind ( char *ip, char *limit )
{
	if (is_nl(*ip))
		ip = skip_nl(ip, limit) ;
	ip = skip_ws(ip,limit);
	if (!match(ip, limit, mStartSentinelComment.c_str()))
		return noSentinel ;
	ip += mStartSentinelComment . Length() ;
	if (!match(ip, limit, "@"))
		return noSentinel ;
	++ip ; // Skip the first '@'.
	if (match(ip, limit, "@"))
		return startDirective ;
	else if (match(ip, limit, "@verbatim"))
		return startVerbatim ;
	else if (match(ip, limit, "&lt;&lt;"))
		return startRef ;
		
	// All the following start with + or -.
	char delim = *ip++ ;
	if (delim != '+' &amp;&amp; delim != '-')
		return noSentinel ;
	bool plus = delim == '+' ;
	test("at", startAt, endAt);
	test("body", startBody, endBody);
	test("doc", startDoc, endDoc);
	test("leo", startLeo, endLeo);
	test("node", startNode, endNode);
	test("others", startOthers, endOthers);
 	return noDirective ;
}

#undef test</t>
<t tx="T800">@ This method returns the name of the sentinel for warnings.
@c

String atFile::sentinelName ( short sentinelKind )
{
	switch ( sentinelKind )
	{
	case endAt: return "@-at" ;
	case endBody: return "@-body" ;
	case endDoc: return "@-body" ;
	case endLeo: return "@-leo" ;
	case endNode: return "@-node" ;
	case endOthers: return "@-others" ;
	case noSentinel: return "&lt;no sentinel&gt;" ;
	case startAt: return "@+at" ;
	case startBody: return "@+body" ;
	case startDirective: return "@@" ;
	case startDoc: return "@+doc" ;
	case startLeo: return "@+leo" ;
  	case startNode: return "@+node" ;
 	case startOthers: return "@+others" ;
 	case startVerbatim: return "@verbatim" ;
	default: return "&lt;unknown sentinel!&gt;" ;
	}
}</t>
<t tx="T801">char * atFile::skipSentinelStart( char * ip, char * limit)
{
	if (is_nl(*ip))
		ip = skip_nl(ip, limit) ;
	ip = skip_ws(ip, limit);
	assert(match(ip, limit, mStartSentinelComment.c_str()));
	ip += mStartSentinelComment . Length() ;
	assert(ip &lt; limit &amp;&amp; *ip == '@');
	return ++ip ;
}</t>
<t tx="T802">@ Returns TRUE if two files are identical.
@c

bool compareFiles ( String path1, String path2 )
{
	char buf1[1024], buf2[1024];
	int f1 = FileOpen(path1, fmOpenRead) ;
	int f2 = FileOpen(path2, fmOpenRead) ;
	bool result = f1 &gt; -1 &amp;&amp; f2 &gt; -1 ;
    while (result) {
    	long n1 = FileRead(f1, buf1, 1024) ;
    	long n2 = FileRead(f2, buf2, 1024) ;
		if (n1 == 0 &amp;&amp; n2 == 0) break ;  // Files are equal.
    	result = (n1 == n2 &amp;&amp; memcmp(buf1, buf2, n1) == 0);
	}
	if (f1 &gt; -1) FileClose(f1);
	if (f2 &gt; -1) FileClose(f2);
	return result ;
}</t>
<t tx="T803">@ Returns the kind of at-directive or noDirective.
@c

short directiveKind ( char * ip, char * limit )
{
	if ( ip &gt;= limit || *ip != '@' )
		return noDirective ;
	else if ( match_word(ip, limit, "@c") )
		return cDirective ;
	else if ( match_word(ip, limit, "@code") )
		return codeDirective ;
	else if ( match_word(ip, limit, "@doc") )
		return docDirective ;
	else if (
		match(ip, limit, "@ ") ||
		match(ip, limit, "@\t") ||
		match(ip, limit, "@\n")
	)
		return atDirective ;
	else if (match_word(ip, limit, "@others"))
		return othersDirective ;
	else
		return miscDirective ;
}
</t>
<t tx="T804">@ Returns TRUE if ip points to the start of a section name.  If so, we set end_pp in the caller to the character past the section reference.
@c

bool isSectionName ( char *ip, char *limit, char **end_pp )
{
	if (! match(ip, limit,"&lt;&lt;"))
		return FALSE ;

	// Find the end of the section name.
	while (ip &lt; limit &amp;&amp; !is_nl(*ip) &amp;&amp; !match(ip,limit, "&gt;&gt;" ) )
		++ ip ;

	if (end_pp &amp;&amp; match(ip, limit, "&gt;&gt;"))
		*end_pp = ip + 2 ;

	return match(ip, limit, "&gt;&gt;") ;
}
</t>
<t tx="T805">@ This function sets any ancestor @file node to be dirty.
@c

void setAncestorAtFileNodeDirty ( vnode * v )
{
	while ( v ) {
		if ( v -&gt; isAtFileNode() ) {
			v -&gt; setDirty();
			v -&gt; setDirtyJoined();
		}
		v = v -&gt; parent();
	}
}</t>
<t tx="T806">void atFile::appendToBody (TMemoryStream *ms, String s)
{
	assert(ms);
	if ( s . Length() &gt; 0 )
		ms -&gt; Write( s . c_str(), s . Length() ) ;
}

void atFile::appendToBody (TMemoryStream *ms, char *start, char *end)
{
	assert(ms);
	long len = end - start ;
	if ( len &gt; 0 )
		ms -&gt; Write( start, len ) ;
}
</t>
<t tx="T807">@ This code scans the node v and all of v's ancestors looking for directives.  If found, the corresponding Tangle/Untangle globals are set.

Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node x, no @owncolor or @nocolor directives are examined in any ancestor of x.

This code is similar to Commands::scanAllDirectives, but it has been modified for use by the atFile class.
@c

#define test(bit) ((bit &amp; bits) != 0)
#define prev(bit) ((bit &amp; old_bits) != 0)

void atFile::scanAllDirectives ( vnode * v )
{
    assert(v);
    TLeoForm * form = v -&gt; leoForm() ;
	long old_bits = 0 ;  // One bit for each directive.
	long val = 0 ;
	bool path_specified = FALSE ;
	&lt;&lt; Set global arguments to default values &gt;&gt;
	&lt;&lt; Set path from @file node &gt;&gt;
	for ( ; v ; v = v -&gt; parent() ) {
		String s;  // Must have the same lifetime as ip!
		char * ip = v -&gt; bodyCString() ;
		long len = v -&gt; bodyCStringLength() ;
		char * limit = ip + len ;
		long bits = is_special_bits ( ip, len, DONT_SET_ROOT_FROM_HEADLINE ) ;
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @comment or @language &gt;&gt;
		&lt;&lt; Test for @pagewidth and @tabwidth &gt;&gt;
		old_bits |= bits ;
	}
	if ( !path_specified &amp;&amp; !prev(path_bits)) {
		// No path in @file headline and no @path directive.
		&lt;&lt; Set current directory if possible &gt;&gt;
	}
	&lt;&lt; Set comment Strings from global vars &gt;&gt;
}

#undef test
#undef prev
</t>
<t tx="T808">#if 0 // not used in atFile::scanAllDirectives.
	// CWEB flag might be useful.
    arg_allow_rich_text = default_allow_rich_text ;
    arg_extended_noweb_flag = default_extended_noweb_flag ;
    arg_output_doc_flag = default_output_doc_flag ;
    arg_tangle_batch = default_tangle_batch ;
    arg_untangle_batch = default_untangle_batch ;
    arg_use_noweb_flag = default_use_noweb_flag ;
    arg_use_CWEB_flag = default_use_CWEB_flag ;
    arg_use_header_flag = default_use_header_flag ;  // 6/1/00
    tangle_print_bits = verbose_bits ;
#endif

arg_page_width = default_page_width ;
arg_tab_width = default_tab_width ;
arg_present_language = arg_target_language = default_target_language ;
set_delims_from_language(arg_present_language);</t>
<t tx="T809">@ A directory in an @file node over-rides everything else.
@c

String s = v -&gt; atFileNodeName() ;
String dir = ExtractFileDir ( s ) ;
if ( dir.Length() &gt; 0 ) {
    path_specified = SetCurrentDir ( dir ) ;
	if ( ! path_specified )
		error ( String("Directory \"") + dir + "\" does not exist ");
}</t>
<t tx="T810">if ( prev(comment_bits) || prev(language_bits) )
	;  // Do nothing more.
else if (test(comment_bits)) {
	set_root_delims ( at_comment_ptr, len-(at_comment_ptr-ip) ) ;
	// @comment effectively disables Untangle.
	arg_present_language = unknown_language ;
}
else if (test(language_bits))
	set_language (ip, len, at_language_ptr, 0 /* issue_error_flag */ ) ;</t>
<t tx="T811">if (test(path_bits) &amp;&amp; !path_specified &amp;&amp; !prev(path_bits)) {
	char * p2 = at_path_ptr + 5 ; // Point past @path
	ip = skip_to_end_of_line(at_path_ptr, limit);
	String s(p2, ip - p2 );
	s = s . Trim();
	&lt;&lt; Remove leading and trailing delims if they exist &gt;&gt;
	s = s . Trim();
	if ( s . Length() &gt; 0 ) {
		path_specified = SetCurrentDir ( s . c_str() ) ;
		if ( ! path_specified )
			error ( "Invalid @path: " + s ) ;
	}	
	else error ("ignoring empty @path") ;
}</t>
<t tx="T812">if ( s . Length() &gt; 2 &amp;&amp; (
		s[1] == '"' &amp;&amp; s[s.Length()] == '"' ||
		s[1] == '&lt;' &amp;&amp; s[s.Length()] == '&gt;'
) ) {
	s . Delete ( s.Length(), 1 ) ;
	s . Delete ( 1, 1 ) ;
}</t>
<t tx="T813">if (test(page_width_bits) &amp;&amp; !prev(page_width_bits) ) {
	char * p2 = at_page_width_ptr + 10 ; // Point past @pagewidth
	val = 0 ;
	ip = skip_long (p2, limit, &amp; val );
	if ( ip == NULL ) {
		ip = skip_to_end_of_line(p2, limit);
		String line(at_page_width_ptr, ip - at_page_width_ptr);
		error ( "Ignoring " + line ) ;
	}
	else arg_page_width = val ;
}

if (test(tab_width_bits) &amp;&amp; !prev(tab_width_bits) ) {
	char * p2 = at_tab_width_ptr + 9 ; // Point past @tabwidth
	val = 0 ;
	ip = skip_long (p2, limit, &amp; val );
	if ( ip == NULL ) {
		ip = skip_to_end_of_line(p2, limit);
		String line(at_tab_width_ptr, ip - at_tab_width_ptr);
		error ( "Ignoring " + line ) ;
	}
	else arg_tab_width = val ;
}
</t>
<t tx="T814">@ This code is executed if no valid path was specified in the @file node or in an @path directive.  We try to set the current directory to the following:

1. The Tangle Default Directory specified in the Preferences panel.
2. The mOpenDirectory specified by the Open command.
@c

if ( form == NULL )
	path_specified = TRUE ;  // We are opening.  Do nothing.

if ( !path_specified &amp;&amp; form -&gt; mDefaultDirectory . Length() &gt; 0 ) {
	path_specified = SetCurrentDir ( form -&gt; mDefaultDirectory . c_str() ) ;
	if ( !path_specified )
		error(
			"Invalid Default Tangle Directory: " +
			form -&gt; mDefaultDirectory ) ;
}

if ( !path_specified &amp;&amp; form -&gt; mOpenDirectory . Length() &gt; 0 ) {
	path_specified = SetCurrentDir ( form -&gt; mOpenDirectory . c_str() ) ;
	if ( !path_specified )
		error (
			"Directory no longer valid: " + 
			form -&gt; mDefaultDirectory ) ;
}

if ( !path_specified ) {
	// Always issue this error.
	error ("No directory specified by @file, @path or Preferences.");
}
</t>
<t tx="T815">@ We use single-line comments if we have a choice.
@c

if ( single_comment_string ) {
	mStartSentinelComment = single_comment_string ;
	mEndSentinelComment = "" ;
}
else {
	mStartSentinelComment = start_comment_string ;
	mEndSentinelComment = end_comment_string ;
}</t>
<t tx="T816">void atFile::error ( String message )
{
	if ( message.Length() &gt; 0 ) {
		message += "\n" ;
    	put_cstring_to_log_window ( message.c_str() );
	}
	++ mErrors ;
}
</t>
<t tx="T817">@ ip points at the start of a line.  Skip past whitespace equivalent to n spaces.
@c

char * atFile::skipIndent ( long n, char * ip, char * limit )
{
	long ws = 0 ;
	while (ip &lt; limit &amp;&amp; ws &lt; n)
	{
		if (*ip == '\t') ws += ( arg_tab_width - ws % arg_tab_width ) ;
		else if (*ip == ' ') ++ ws ;
		else break ;
		++ ip ;
	}
	return ip ;
}</t>
<t tx="T818">@ Update the cloneIndex field of each vnode of root's subtree. The maximum clone index is stored in the cloneIndex field of root (root should not be cloned).  next points to the node after the tree.
@c

void atFile::updateCloneIndices ( vnode * root, vnode * next )
{
	if ( root -&gt; isCloned() ) {
		error ("Ignoring clone mark for " + root -&gt; headString());
		root -&gt; t() -&gt; setCloneIndex(0);
	}

	long maxIndex = root -&gt; t() -&gt; cloneIndex() ;

	for ( vnode * v = root ; v &amp;&amp; v != next ; v = v -&gt; threadNext() )
		if ( v -&gt; isCloned() &amp;&amp; v -&gt; t() -&gt; cloneIndex() == 0 )
			v -&gt; t() -&gt; setCloneIndex ( ++ maxIndex ) ;
			
	root -&gt; t() -&gt; setCloneIndex(maxIndex) ;
}</t>
<t tx="T819">void atFile::writeError ( String message )
{
	if ( mErrors == 0 ) {
		es("----- Errors in: "); es(mTargetFileName.c_str() ); enl();
	}
	error ( message ) ;
	mRoot -&gt; setOrphan();
}</t>
<t tx="T820">#pragma option -w-par  // suppress warning: "Parameter `param' not used."

&lt;&lt; File commands includes &gt;&gt;
&lt;&lt; Declare the fileInfo class &gt;&gt;
&lt;&lt; Declare the EBadLeoFile class &gt;&gt;
&lt;&lt; Declare File commands private functions &gt;&gt;

@others</t>
<t tx="T821">#include &lt;vcl.h&gt;
#pragma hdrstop

#include "args.h"
#include "atFile.h"
#include "Clipbrd.hpp"
#include "Commands.h"
#include "CloneUnit.h"
#include &lt;Filectrl.hpp&gt; // For DirectoryExists.
#include "FindUnit.h"  // for find globals.
#include "LeoWindow.h"
#include "MainUnit.h"  // For alert().
#include "Prefs.h"  // Alters Prefs form.
#include "Sherlock.h"  // For Sherlock.cpp (defines SherlockForm).
#include "vnode.h"
#include "tnode.h"
#include "Utils.h"

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "Leo.h"
</t>
<t tx="T822">static String convertToNoweb ( vnode * v ) ;
static char * convertCodePartToNoweb(
	vnode *v, char *p, char *limit, String&amp; result) ;
static char * convertDocPartToNoweb( char *p, char *limit, String&amp; outerResult) ;
static char * copyPart( char *p, char *limit, String&amp; result) ;</t>
<t tx="T823">class EBadLeoFile {} ;</t>
<t tx="T824">void Commands::deleteTagList( void )
{
	while ( mTagList ) {
		tag_list * next = mTagList -&gt; next ;
		delete mTagList ;
		mTagList = next ;
	}
}</t>
<t tx="T825">vnode * Commands::getVtag ( long vref )
{
	for ( tag_list * p = mTagList ; p ; p = p -&gt; next )
		if ( p -&gt; vref == vref )
			return p -&gt; v ;

	return NULL ;
}

long Commands::getVtag ( vnode * v )
{
	for ( tag_list * p = mTagList ; p ; p = p -&gt; next )
		if ( p -&gt; v == v )
			return p -&gt; vref ;

	return NULL ;
}</t>
<t tx="T826">void Commands::newVtag ( long vtag, vnode * v )
{
    // Allocate the node.
    tag_list * p = new tag_list();
    p -&gt; v = v ;
    p -&gt; vref = vtag ;
    
    // Link the node into the list.
    p -&gt; next = mTagList ;
    mTagList = p ;
}</t>
<t tx="T827">void Commands::exportMoreText ( void )
{
	vnode * v = this -&gt; currentVnode();
	if ( v == NULL ) return ;
    TClipboard * clipboard = Clipboard();
    if ( clipboard == NULL ) return ;

	String s = v -&gt; convertTreeToString() ;
	clipboard -&gt; Open();
	clipboard -&gt; Clear();
	clipboard -&gt; SetTextBuf( s . c_str() );
	clipboard -&gt; Close();
}</t>
<t tx="T828">void Commands::flattenOutline ( TStrings * files )
{
	vnode * v = this -&gt; currentVnode() ;
	if ( v == NULL ) return ;
	long count = files -&gt; Count ;
	if ( count != 1 ) return ;

	String fileName = files -&gt; Strings [ 0 ] ;
	vnode * after = v -&gt; nodeAfterTree() ;
	String s ;
	String body ;
	String newline ("\n") ;
	long firstLevel = v -&gt; level();

	try {
		int fileHandle = FileCreate( fileName) ;
	
		#if 0 // Elegant, but uses lots of memory.
			s = v -&gt; convertTreeToString() ;
			FileWrite(fileHandle, s . c_str(), s . Length() ) ;
		#else  // Redundant, but uses much less memory.
        	while ( v &amp;&amp; v != after ) {
				s  = v -&gt; moreHead ( firstLevel ) ;
				s += newline ;
        		body = v -&gt; moreBody ();  // Insert escapes.
        		if ( body . Length() &gt; 0 ) {
                    s += body ;
        			s += newline ;
        		}
    			FileWrite(fileHandle, s . c_str(), s . Length() ) ;
        		v = v -&gt; threadNext() ;
        	}
		#endif
		FileClose(fileHandle) ;
	}
	catch(...) {
		alert("File error while flattening the outline") ;
	}
}
</t>
<t tx="T829">void Commands::flattenOutlineWithFilename ( String fileName )
{
	TStringList * list = new TStringList();
	list -&gt; Add(fileName);
	flattenOutline(list);
    delete list ;
}
</t>
<t tx="T830">void Commands::outlineToNoweb( TStrings * files )
{
	vnode * v = this -&gt; currentVnode() ;
	if ( v == NULL ) return ;
	long count = files -&gt; Count ;
	if ( count != 1 ) return ;

	String fileName = files -&gt; Strings [ 0 ] ;
	vnode * after = v -&gt; nodeAfterTree() ;

	try {
		int fileHandle = FileCreate( fileName) ;
	
    	while ( v &amp;&amp; v != after ) {
			String s = convertToNoweb(v);
			if ( s . Length() &gt; 0 ) {
				// Don't rely on s.Length() when writing!
				char * cs = s.c_str();
				long len = strlen(cs);
				if ( len &gt; 0 )
					FileWrite(fileHandle, cs, len ) ;
				if ( len &gt; 0 &amp;&amp; cs[len-1] != '\n' )
					FileWrite(fileHandle, "\n", 1 ) ;
			}
    		v = v -&gt; threadNext() ;
    	}

		FileClose(fileHandle) ;
	}
	catch(...) {
		alert("File error in Outline To noweb command") ;
	}
}
</t>
<t tx="T831">@ This code converts a vnode to noweb text as follows:

Convert @root to &lt; &lt; * &gt; &gt;
Convert @doc to @
Convert @code to &lt; &lt; name &gt; &gt; =, assuming the headline contains &lt; &lt; name &gt; &gt;
Ignore other directives
Format parts so they fit in pagewidth columns.
Output code parts as is.
@c

static String convertToNoweb ( vnode * v )
{
	String result ("");
	if ( v == NULL ) return result ;
	char * p = v -&gt; bodyCString();
	char * limit = p + v -&gt; bodyCStringLength() ;
	char * p2 = skip_ws_and_nl(p, limit);
	if ( p2 == limit )
		return result ;

	while ( p &lt; limit) {
		p = skip_ws_and_nl(p, limit);
		if ( p &gt;= limit )
			break ;
		else if ( p + 3 &lt; limit &amp;&amp; strn_eq(p, "@doc", 4))
			p = convertDocPartToNoweb(p + 4, limit, result);
		else if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@code", 5))
			p = convertCodePartToNoweb(v, p, limit, result);
		else if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@root", 5))
			p = convertCodePartToNoweb(v, p, limit, result);
		else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "&lt;&lt;", 2))
			p = convertCodePartToNoweb(v, p, limit, result);
		else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "@ ", 2))
			p = convertDocPartToNoweb(p + 2, limit, result);
		else if ( *p == '@' )
			p = skip_line(p, limit);  // Ignore all other directives.
		else // Assume we are in a doc part.
			p = convertDocPartToNoweb(p, limit, result);
	}
	
	#if 0 // this is not the problem
    	TReplaceFlags flags ;
    	flags &lt;&lt; rfReplaceAll ;
    	result = StringReplace( result, "\r", "\n", flags ) ;
	#endif
	
	return result ;
}
</t>
<t tx="T832">@ The code part should start either with @code or @root or &lt;&lt; section name &gt;&gt;=
@c

static char * convertCodePartToNoweb( vnode *v, char *p, char *limit, String&amp; result)
{
	if ( p &gt;= limit )
		return p ;
	&lt;&lt; Output the section reference &gt;&gt;
	p = copyPart(p, limit, result);
	return p ;
}
</t>
<t tx="T833">if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@code", 5)) {
	p = skip_line(p, limit);
	char * p1 = NULL, *p2 = NULL ;
	&lt;&lt; point p1 and p2 at section name in v's headline &gt;&gt;
	if ( p1 &amp;&amp; p2 ) {
		String headline(p1, p2-p1);
		result += "\n" ;
		result += headline ;
		result += "=" ;
	}
	else {
		result += "\n\n&lt;&lt; *** " ;
		result += "no section name for @code ***&gt;&gt;" ;
	}
}
else if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@root", 5)) {
	String name("*");  // Default name for empty file names.
	p += 5 ;
	p = skip_ws(p, limit);
	char * p2 = p ;
	p = skip_line(p, limit);
	&lt;&lt; Set name to the file name p2..p &gt;&gt;
	result += "\n\n&lt;&lt;" ;
	result += name ;
	result += "&gt;&gt;=" ;
}
else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "&lt;&lt;", 2)) {
	// copy the line to the output.
	char * p2 = skip_line(p, limit);
	while ( p &lt;= p2 )
		result += *p++ ;
}
</t>
<t tx="T834">if ( p2 &lt; p ) {
	char delim = ' ';
	if ( *p2 == '&lt;' ) { ++ p2 ; delim = '&gt;' ; }
	if ( *p2 == '"' ) { ++ p2 ; delim = '"' ; }
	char * p3 = p2 ;
	while ( p2 &lt; p &amp;&amp; *p2 != delim &amp;&amp; ! is_nl(*p2) )
		++ p2 ;
	if ( p3 &lt; p2 ) {
		name = String(p3, p2-p3);
		name = name.Trim();
		if ( name . Length() == 0 )
			name = "*" ;
	}
}
</t>
<t tx="T835">char * hp = v -&gt; headCString();
char * hlim = hp + v -&gt; headCStringLength();

hp = skip_ws (hp, hlim);

if ( hp + 2 &lt; hlim &amp;&amp; strn_eq(hp, "&lt;&lt;", 2)) {
	p1 = hp ;
	hp += 2 ;
	while ( hp + 2 &lt;= hlim ) {
		if ( strn_eq(hp, "&gt;&gt;", 2) ) {
			p2 = hp + 2 ;
			break ;
		}
		else ++ hp ;
	}
}
</t>
<t tx="T836">static char * convertDocPartToNoweb( char *p, char *limit, String&amp; outerResult)
{
	String result("") ;
	// Ignore anything following @space or @doc.
	if (
		p + 3 &lt; limit &amp;&amp; strn_eq(p, "@doc", 4) ||
		p + 1 &lt; limit &amp;&amp; strn_eq(p, "@ ", 2)
	)
		p = skip_line(p, limit);
	
	p = skip_ws_and_nl(p, limit);
	if ( p &gt;= limit )
		return p ;
	p = copyPart(p, limit, result);
	if ( result . Length() &gt; 0 ) {
    	// We could break long lines in result here.
    	outerResult += "@ \n" ;
    	outerResult += result ;
	}
	return p ;
}</t>
<t tx="T837">@ This code copies characters to result until the end of the present section is seen.
@c

static char * copyPart( char *p, char *limit, String&amp; result)
{
	while ( p &lt; limit) {
		// We should be at the start of a line here.
		char * p2 = p ;
		p = skip_nl(p, limit);
		p = skip_ws(p, limit);

		if ( p + 3 &lt; limit &amp;&amp; strn_eq(p, "@doc", 4))
			break ;
		else if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@code", 5))
			break ;
		else if ( p + 4 &lt; limit &amp;&amp; strn_eq(p, "@root", 5))
			break ;
		else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "&lt;&lt;", 2)) {
			&lt;&lt; return p if this is a section definition &gt;&gt;
		}
		else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "@ ", 2))
			break ;
		else if ( p + 1 &lt; limit &amp;&amp; strn_eq(p, "@@", 2))
			;  // Will be handled below.
		else if ( *p == '@' ) {
			p = skip_line(p, limit);  // Ignore all other directives.
			continue ;
		}

        // Copy the entire line.
        p = p2 ;  // Copy leading whitespace.
        p2 = skip_line(p, limit);
        while ( p &lt;= p2 )
            result += *p++ ;
	}

	return p ;
}
</t>
<t tx="T838">// This code leaves p and the outer p2 unchanged.
{
	char * p1 = p ;
	char * p2 = skip_line (p, limit);
	
	while ( p1 &lt; p2 )
		if ( p1 + 3 &lt;= p2 &amp;&amp; strn_eq(p1, "&gt;&gt;=", 3) )
        	return p ;
		else
			++ p1 ;
}</t>
<t tx="T839">@ Almost all the time spent in this command is spent here.
@c

vnode * Commands::convertMoreStringsToOutlineAfter
	( TStrings * strings, vnode * firstVnode )
{
    if ( ! this -&gt; stringsAreValidMoreFile ( strings ) ) return NULL ;

	&lt;&lt; Declare the vars for convertMoreStringsToOutlineAfter &gt;&gt;
	this -&gt; BeginUpdate();
		while ( index &lt; count )
		{
			s = strings -&gt; Strings [ index ] ;
			cs = s . c_str() ;
			level = this -&gt; moreHeadlineLevel ( cs, &amp;newFlag ) - firstLevel ;

			if ( level &gt;= 0 ) {
				&lt;&lt; Link a new vnode v into the outline &gt;&gt;
				&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;
				&lt;&lt; Count the number of following body lines &gt;&gt;
				&lt;&lt; Add the lines to the body text of v &gt;&gt;
				v -&gt; setDirty();  // Set the icon and the dirty bit last.
			}
			else ++ index ;
		}
		if ( theRoot ) this -&gt; setChanged ( TRUE ) ;
	this -&gt; EndUpdate();

    return theRoot ;
}</t>
<t tx="T840">vnode * theRoot = NULL ;
vnode * lastVnode = NULL ;
vnode * v = NULL ;  // The new vnode.
long index = 0 ;
long lastLevel = -1 ;
bool junkFlag = 0 ;
bool newFlag = 0 ;
long bodyLines = 0;
long firstLevel = 0 ;
long level = 0 ;
String s("");
char * cs = NULL ;

long count = strings -&gt; Count ;
if ( count &gt; 0 ) {
	s = strings -&gt; Strings [ 0 ] ;
	cs = s . c_str();
	firstLevel = this -&gt; moreHeadlineLevel ( cs, &amp;junkFlag );
}
</t>
<t tx="T841">assert(level &gt;= 0 );

if ( lastVnode == NULL )
	theRoot = v = firstVnode -&gt; insertAfter ( ) ;
else if ( level == lastLevel )
	v = lastVnode -&gt; insertAfter ( ) ;
else if ( level == lastLevel + 1 )
	v = lastVnode -&gt; insertAsNthChild ( 0 ) ;
else {
	assert ( level &lt; lastLevel ) ;

	while ( level &lt; lastLevel ) {
		-- lastLevel ;
		lastVnode = lastVnode -&gt; parent();
		assert(lastVnode);
		assert ( lastLevel &gt;= 0 ) ;
	}
	v = lastVnode -&gt; insertAfter ( ) ;
}

lastVnode = v ;
lastLevel = level ;</t>
<t tx="T842">{
	char * cString = cs ;
	
	while ( *cString == '\t' )
		++ cString ;

    if ( ( *cString == '+' || *cString == '-' ) &amp;&amp; *(cString+1) == ' ' )
       cString += 2 ;

	v -&gt; treeNode() -&gt; Text = String ( cString ) ;
}
</t>
<t tx="T843">bodyLines = 0 ;
++ index ;  // Skip the headline.

while ( index &lt; count )
{
    s = strings -&gt; Strings [ index ] ;
	cs = s . c_str();
    level = this -&gt; moreHeadlineLevel ( cs, &amp;newFlag ) - firstLevel ;
    if ( level &gt;= 0 )
        break ;
   
    // Remove first backslash of the body line.
	if ( s . Length() &gt; 0 &amp;&amp; s [ 1 ] == '\\' )
		strings -&gt; Strings [ index ] = s . Delete ( 1, 1 ) ;

    ++ bodyLines ;
    ++ index ;
}
</t>
<t tx="T844">if ( bodyLines &gt; 0 )
{
	String body ( "" ) ;

	for ( long n = index - bodyLines ; n &lt; index ; ++ n ) {
		body += strings -&gt; Strings [ n ] ;
		if ( n != index - 1 )
			body += "\n" ;
	}

	v -&gt; t() -&gt; setTnodeText ( body ) ;
}
</t>
<t tx="T845">@ On entry, files contains at most one file to convert.
@c

void Commands::importMoreText ( TStrings * files )
{
	vnode * current = this -&gt; currentVnode() ;
	if ( current == NULL ) return ;
	if ( files -&gt; Count &lt; 1 ) return ;
	
	String fileName = files -&gt; Strings [ 0 ] ;
	TStrings * strings = new TStringList () ;
    &lt;&lt; Read the file into strings &gt;&gt;
    // Convert the string to an outline and insert it after the current node.
	vnode * newVnode = this -&gt; convertMoreStringsToOutlineAfter ( strings, current ) ;
	delete strings ;
	strings = NULL ;

    if ( newVnode ) {
		this -&gt; endEditing () ;
		this -&gt; validateOutline () ;
		this -&gt; editVnode ( newVnode ) ;
		this -&gt; setChanged ( TRUE ) ;
    }
    else {
		String s = fileName + " is not a valid MORE file." ;  
		alert ( s . c_str() ) ;
    }
}</t>
<t tx="T846">@ This code is _very_ fast.
@c

try {
	strings -&gt; LoadFromFile ( fileName ) ;
}
catch ( ... )
{
	String s ( "Not enough memory to convert: ") ;
	s += fileName ;
	alert ( s . c_str() );
	return ;
}</t>
<t tx="T847">@ return the headline level of s, or -1 if the string is not a MORE headline.
@c

long Commands::moreHeadlineLevel ( char * s, bool * plusFlag )
{
    long level = 0 ;

    while ( *s &amp;&amp; *s == '\t') {
        ++level ;
        ++s ;
    }

    if ( plusFlag ) *plusFlag = ( *s == '+' ) ;

    if ( ( *s == '+' || *s == '-' ) &amp;&amp; * (s+1) == ' ' )
        return level ;
    else
        return -1 ;
}</t>
<t tx="T848">bool Commands::stringsAreValidMoreFile ( TStrings * strings )
{
    long count = strings -&gt; Count ;
	if ( count &lt; 1 ) return FALSE ;

	bool plusFlag = 0 ;
	char *cs = strings -&gt; Strings [0] . c_str() ;
    long level1 = this -&gt; moreHeadlineLevel ( cs, &amp;plusFlag ) ;
    if ( level1 == -1 ) return FALSE ;
    long lastLevel = level1 ;

    // Check the level of all headlines.
    for ( long i = 1 ; i &lt; count ; ++ i )
    {
		bool newFlag = 0 ;
		cs =  strings -&gt; Strings [ i ] . c_str() ;
		long level = this -&gt; moreHeadlineLevel ( cs, &amp;newFlag ) ;
		
		if ( level &gt; 0 ) {
		    if ( level &lt; level1 || level &gt; lastLevel + 1 )
		        return FALSE ;  // improper level.
		    else if ( level &gt; lastLevel &amp;&amp; plusFlag == FALSE )
		        return FALSE ;  // parent of this node has no children.
		    else if ( level == lastLevel &amp;&amp; plusFlag == TRUE )
		        return FALSE ;  // last node has missing child.
		    else {
		        lastLevel = level ;
		        plusFlag = newFlag ;
		    }
		}
    }

    return TRUE ;
}</t>
<t tx="T849">@ This class buffers all information from an outline while a file is being read.  The setMaxTnodeIndex method creates the mTnodes array used to associate tnodes with tnode indices.  The createVnode method creates a vnode and also creates its tnode if it has not already been created.  The finishOutline completes the construction of the outline.

Vnode tags are not part of vnodes:  they are created by this class and destroyed when this class is destroyed.
@c

class fileInfo
{
private:
	long mTnodesSeen ;
	long mVnodesSeen ;
	long mMaxTnodeIndex ;
	long mNumberOfTnodes ;
	tnode ** mTnodes ;
	TLeoForm * mLeoForm ;
	Commands * mCommands ;
	vnode * mRootVnode ;

public:
	// Data.
	long mFileFormatNumber ;
	long mCloneWindowsSeen ;
	long mNumberOfCloneWindows ;
	vnode * mCurrentVnode ;
	double mRatio ;

	// Birth &amp; death.
	fileInfo ( TLeoForm * leoForm, Commands * commands ) ;
	~fileInfo ( void ) ;

	// Methods.
	vnode * createVnode ( vnode * parent, vnode * next,
		String headline, short attrib, long tref, long tag,
		String xfile, long xindex ) ;
	void finishOutline ( void ) ;
	vnode * finishPaste ( void ) ;
	tnode * getT ( long index ) ;
	void newCloneWindow ( long vref, long top, long left, long height, long width ) ;
	tnode * newTnode ( long index ) ;
	void setMaxTnodeIndex ( long n ) ;
	void setNumberOfTnodes ( long n ) ;
};
</t>
<t tx="T850">fileInfo::fileInfo ( TLeoForm * leoForm, Commands * commands )
{
	mLeoForm = leoForm ;
	mCommands = commands ;
	mFileFormatNumber = 0 ;
	mCloneWindowsSeen = mTnodesSeen = 0 ;
	mMaxTnodeIndex = 0 ;
	mRatio = 0.5 ;
	mNumberOfCloneWindows = mNumberOfTnodes = 0 ;
	mTnodes = NULL ;
	mRootVnode = NULL ;
	mCurrentVnode = NULL ;
}

fileInfo::~fileInfo ( void )
{
	delete [] mTnodes ;
	mCommands -&gt; deleteTagList();
}
</t>
<t tx="T851">vnode * fileInfo::createVnode ( 
	vnode * parent, vnode * back, String headline, 
	short attrib, long tref, long vtag,
	String xfile, long xindex )
{
	vnode * v = NULL ;
	tnode * t = NULL ;

	// No tnode is specified in the file for vnodes with empty body text.
	// 8/29/99: shared tnodes are placed in the file even if empty. 
	if ( tref == 0 )
		t = new tnode();
	else {
        // Bug fix: 8/26/99
		t = this -&gt; getT ( tref ) ;
		if ( t == NULL )
			t = this -&gt; newTnode ( tref ) ;
	}

	if ( back ) // create v after back.
		v = back -&gt; insertAfter ( t ) ;
	else if ( parent ) // create v as the parent's first child.
		v = parent -&gt; insertAsNthChild ( 0, t ) ;
	else {
		&lt;&lt; Create a root vnode &gt;&gt;
	}
	v -&gt; initHeadString ( headline) ;
	v -&gt; initStatus ( attrib ) ;

    #ifdef V_XCLONES
	v -&gt; setXCloneName ( xfile ) ;
	v -&gt; setXCloneIndex ( xindex ) ;
    #endif

	if ( vtag ) mCommands -&gt; newVtag ( vtag, v ) ;
	return v ;
}
</t>
<t tx="T852">v = mCommands -&gt; rootVnode();
assert(v);
v -&gt; setT(t) ;  // deletes previous root tnode.
mRootVnode = v ;
</t>
<t tx="T853">void fileInfo::finishOutline ( void )
{
	&lt;&lt; Set attributes and icons for all nodes &gt;&gt;
	&lt;&lt; Create join lists of all vnodes &gt;&gt;
	&lt;&lt; Set the current node &gt;&gt;
}</t>
<t tx="T854">this -&gt; mCommands -&gt; BeginUpdate();

for ( vnode * v = mRootVnode ; v ; v = v -&gt; threadNext() )
{
	if ( v -&gt; isExpandedBitSet() )
    	v -&gt; treeNode() -&gt; Expand ( FALSE ) ;
    else
    	v -&gt; treeNode() -&gt; Collapse ( FALSE ) ;
    
    v -&gt; clearDirty () ;  // Calls setIcon();
}

this -&gt; mCommands -&gt; EndUpdate();
</t>
<t tx="T855">@ We can create all join lists in a first pass through all vnodes using the mJoinHead field in each tnode.  The second pass circularizes each list.
@c

for ( vnode * v = mRootVnode ; v ; v = v -&gt; threadNext() )
{
	tnode * t = v -&gt; t();
	// Put v at the head of t's list of joined vnodes.
	v -&gt; setJoinList ( t -&gt; joinHead() ) ;
	t -&gt; setJoinHead ( v ) ;
}

// Circularize each non-empty list.
for ( vnode * v = mRootVnode ; v ; v = v -&gt; threadNext() )
{
	tnode * t = v -&gt; t();
	vnode * head = t -&gt; joinHead() ;
	if ( head == NULL ) continue ;

	// Make sure we don't handle this list again.
	t -&gt; setJoinHead ( NULL ) ; 

    // Clear the join list if it has only one member.
    if ( head == v &amp;&amp; v -&gt; joinList() == NULL ) {
        v -&gt; setJoinList(NULL);
        continue;
    }

	// Point last at the last vnode of the list.
	vnode * last = head ;
	while ( last &amp;&amp; last -&gt; joinList() )
		last = last -&gt; joinList() ;
	assert(last);

	// Link last to head.
	last -&gt; setJoinList(head);
}
</t>
<t tx="T856">@ Initializing the current vnode is tricky.  We must not "update" the old current node, namely the new root.

Leo2: we do not set the current node here, because it might be a dummy node. We must wait until we have a complete node so that the event handler will set the body text properly.
@c

if ( mCurrentVnode == NULL )
	mCurrentVnode = mRootVnode ;
	
// Leo2: Just indicate what the current node will be.
mCommands -&gt; setCurrentVnode ( mCurrentVnode ) ;
	
#if 0 // Leo2: this must be done later.
    mCommands -&gt; setCurrentVnode ( NULL ) ;
    mCommands -&gt; selectVnode ( mCurrentVnode ) ;
#endif
</t>
<t tx="T857">@ This method finishes pasting the outline from the clipboard.
@c

vnode * fileInfo::finishPaste ( void )
{
	mRootVnode = mCommands -&gt; rootVnode();
	if ( mCurrentVnode == NULL ) mCurrentVnode = mRootVnode ;
	vnode * after = mCurrentVnode -&gt; nodeAfterTree();
	&lt;&lt; Check number of created tnodes &gt;&gt;
	&lt;&lt; Set attributes and icons for all pasted nodes &gt;&gt;
	// Warning:  this will only join pasted clones.
	#if 1 // Don't allow clones in pasted outlines.
	&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;
	&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;
	#endif
	mCommands -&gt; compactFileIndices ( ) ;
	mCommands -&gt; selectVnode ( mCurrentVnode ) ;
	return mCurrentVnode ;
}</t>
<t tx="T858">if ( mTnodesSeen != mNumberOfTnodes )
{
	String s("Bad tnode count.  Seen: ") ;
	s += mTnodesSeen ;
	s += ", Expected: " ;
	s += mNumberOfTnodes ;
	alert( s . c_str() );
}
</t>
<t tx="T859">for ( vnode * v = mCurrentVnode ; v &amp;&amp; v != after ; v = v -&gt; threadNext() )
{
	if ( v -&gt; isExpandedBitSet() )
    	v -&gt; treeNode() -&gt; Expand ( FALSE ) ;
    else
    	v -&gt; treeNode() -&gt; Collapse ( FALSE ) ;

	#if 0 // done later.
		v -&gt; clearDirty () ;  // Calls setIcon();
	#endif
}
</t>
<t tx="T860">@ We can create all join lists in a first pass through all vnodes using the mJoinHead field in each tnode.  The second pass circularizes each list.
@c

for ( vnode * v = mCurrentVnode ; v &amp;&amp; v != after ; v = v -&gt; threadNext() )
{
	tnode * t = v -&gt; t();
	// Put v at the head of t's list of joined vnodes.
	v -&gt; setJoinList ( t -&gt; joinHead() ) ;
	t -&gt; setJoinHead ( v ) ;
}

// Circularize each non-empty list.
for ( vnode * v = mCurrentVnode ; v &amp;&amp; v != after ; v = v -&gt; threadNext() )
{
	tnode * t = v -&gt; t();
	vnode * head = t -&gt; joinHead() ;
	if ( head == NULL ) continue ;

	// Make sure we don't handle this list again.
	t -&gt; setJoinHead ( NULL ) ; 

    // Clear the join list if it has only one member.
    if ( head == v &amp;&amp; v -&gt; joinList() == NULL ) {
        v -&gt; setJoinList(NULL);
        continue;
    }

	// Point last at the last vnode of the list.
	vnode * last = head ;
	while ( last &amp;&amp; last -&gt; joinList() )
		last = last -&gt; joinList() ;
	assert(last);

	// Link last to head.
	last -&gt; setJoinList(head);
}
</t>
<t tx="T861">@ This must be done after the join lists have been created.  The saved clone bit is unreliable for pasted nodes.
@c

for ( vnode * v = mCurrentVnode ; v &amp;&amp; v != after ; v = v -&gt; threadNext() ) {
	v -&gt; initClonedBit ( v -&gt; shouldBeClone() ) ;
	v -&gt; clearDirty () ;  // Calls setIcon();
}
</t>
<t tx="T862">@ The entry for tnode i is stored at mTnodes [ i - 1 ].  An index of 0 represents NULL.
@c

tnode * fileInfo::getT ( long index )
{
	return ( index &lt; 1 || index &gt; mMaxTnodeIndex ) ?
		NULL : mTnodes [ index - 1 ] ;
}</t>
<t tx="T863">void fileInfo::newCloneWindow (
	long vref, long top, long left, long height, long width )
{
#if USE_CLONE_WINDOW
	if ( ++ mCloneWindowsSeen &gt; mNumberOfCloneWindows ) {
		String s("Unexpected number of clone windows. ") ;
		alert ( s . c_str() ) ;
	}

	vnode * v = mCommands -&gt; getVtag ( vref ) ;
	if ( v ) {
		// Create a clone window.
		assert (mLeoForm ) ;
		TCloneForm * form = new TCloneForm ( mLeoForm, v ) ;
		form -&gt; SetBounds(left, top, width, height) ;
		form -&gt; Show();
		form -&gt; SendToBack();
	}
	else {
		String s("Missing clone tag: ");
		s += vref ;
		alert ( s . c_str() ) ;
	}
#endif
}
</t>
<t tx="T864">tnode * fileInfo::newTnode ( long index )
{
	if ( index &lt;= 0 || index &gt; mMaxTnodeIndex ||
		mTnodes [ index - 1 ] != NULL
	) {
		String s("bad tnode index: ");
		s += index ;
		s += ".  Using empty text." ;
		// alert ( s . c_str() ) ;
		es(s.c_str()); enl();
		return new tnode();
	}
	else {
		++mTnodesSeen ;
		tnode * t = new tnode () ;
		mTnodes [ index - 1 ] = t ;
		t -&gt; setFileIndex ( index ) ;
		return t ;
	}
}
</t>
<t tx="T865">void fileInfo::setMaxTnodeIndex ( long n )
{
	mMaxTnodeIndex = n ;
	mCommands -&gt; mMaxTnodeIndex = n ;

	// Create the array of pointers to tnodes.
	mTnodes = (tnode **) new char [ sizeof (tnode *) * (n+1) ] ;
	
	for ( long i = 0 ; i &lt;= n ; ++ i )
		mTnodes [i] = NULL ;
}</t>
<t tx="T866">void fileInfo::setNumberOfTnodes ( long n )
{
	mNumberOfTnodes = n ;
}</t>
<t tx="T867">bool Commands::getBool ( void )
{
	skipWs();
	char c = *mLinePtr++ ;

	if ( c == '0' )
		return FALSE ;
	else if ( c == '1' )
		return TRUE ;
	else
		throw EBadLeoFile() ;
}

double Commands::getDouble ( void )
{
	skipWs();

	char *end = NULL;
	double val = strtod( mLinePtr, &amp;end );
	if ( end == NULL || end == mLinePtr || end &gt; mLineLimit )
		throw EBadLeoFile();
	mLinePtr = end ;
	return val ;
}

void Commands::getDoubleQuote ( void )
{
	getTag( "\"" );
}

long Commands::getIndex ( void )
{
	long val = getLong();
	if ( val &lt; 0 ) throw EBadLeoFile() ;
	return val ;
}

long Commands::getLong ( void )
{
	skipWs();

	bool neg = *mLinePtr == '-';
	if ( neg ) ++mLinePtr ;

	// Count the number of numerals.
	long len = 0 ;
	while ( mLinePtr + len &lt; mLineLimit &amp;&amp; isdigit( mLinePtr[len] ) )
		++len ;
	if ( len &lt; 1 ) throw EBadLeoFile() ;

	// Compute the value.
	long val = 0 ;
	for ( long i = 0 ; i &lt; len ; ++i ) {
		val *= 10 ;
		val += ( mLinePtr[i] - '0' ) ;
	}

	mLinePtr += len ;
	return neg ? - val : val ;
}

void Commands::getTag ( char * tag )
{
	if ( ! matchTag ( tag ) )
		throw EBadLeoFile() ;
}

bool Commands::matchTag ( char * tag )
{
	long len = strlen ( tag ) ;

	skipWsAndNl();
	bool result =
		( mLinePtr + len &lt;= mLineLimit &amp;&amp;
		strncmp( mLinePtr, tag, len ) == 0 ) ;
	if ( result )
		mLinePtr += len ;

	return result ;
}

bool Commands::matchChar ( char c )
{
	skipWs();
	if (*mLinePtr == c) {
		++mLinePtr ;
		return TRUE ;
	}
	else {
		return FALSE ;
	}
}
</t>
<t tx="T868">void Commands::getClipboardHeader ( fileInfo * info )
{
	// Set defaults.
	bool maxIndexSeen = FALSE ;
	bool numberSeen = FALSE ;
	info -&gt; mFileFormatNumber = 1 ;
	info -&gt; mNumberOfCloneWindows = 0 ;

	getTag("&lt;leo_header");
	
	// New in version 1.7: fields may appear in any order.
	for (;;) {
		if ( matchTag("file_format=\"") ) {
			info -&gt; mFileFormatNumber = getLong();
			getDoubleQuote();
		}
		else if ( matchTag("tnodes=\"") ) {
			numberSeen = TRUE ;
			info -&gt; setNumberOfTnodes ( getLong() ) ;
			getDoubleQuote();
		}
		else if ( matchTag("max_tnode_index=\"") ) {
			maxIndexSeen = TRUE ;
			info -&gt; setMaxTnodeIndex ( getLong() ) ;
			getDoubleQuote();
		}
		else {
			getTag("/&gt;");
			break ;
		}
	}

	if ( ! numberSeen )
		info -&gt; setNumberOfTnodes ( 0 ) ;
	if ( ! maxIndexSeen )
		info -&gt; setMaxTnodeIndex ( 0 ) ;
}</t>
<t tx="T869">void Commands::getCloneWindows ( fileInfo * info )
{
	// The clone_windows tag is optional.
	if ( ! matchTag("&lt;clone_windows&gt;") ) return ;

	long vtag, top, left, height, width ;

	while ( matchTag("&lt;clone_window vtag=\"V") ) {
		vtag = getLong(); getDoubleQuote(); getTag("&gt;");
		getTag("&lt;global_window_position");
			getPosition ( &amp;top, &amp;left, &amp;height, &amp;width ) ;
		getTag("/&gt;");
		getTag("&lt;/clone_window&gt;");
		info -&gt; newCloneWindow ( vtag, top, left, height, width );
	}
	getTag("&lt;/clone_windows&gt;");
}
</t>
<t tx="T870">String Commands::getEscapedString ( void )
{
	if ( mTextBuf == NULL ) {
		&lt;&lt; allocate mTextBuf &gt;&gt;
	}
	mTextPtr = mTextBuf ;

	// Fill mTextBuf up to the next &lt; character.
	for ( ;; ) {
		if ( mTextPtr + 1 &gt;= mTextLimit ) {
			&lt;&lt; increase the size of mTextBuf &gt;&gt;
		}
		if ( mLinePtr &gt;= mLineLimit )
			if ( ! this -&gt; readLine() )
				break ;  // 11/15/00
		if ( mLinePtr &gt;= mLineLimit || *mLinePtr == '&lt;' )
			break ;
		*mTextPtr++ = *mLinePtr++ ;
	}

	assert(mTextPtr &lt; mTextLimit );
	*mTextPtr = '\0' ;

	return this -&gt; xmlUnescape ( mTextBuf ) ;
}</t>
<t tx="T871">mTextBufSize = 1000 ;
mTextBuf = new char [ mTextBufSize ] ;
mTextPtr = mTextBuf ;
mTextLimit = mTextBuf + mTextBufSize ;</t>
<t tx="T872">{
	long offset = mTextPtr - mTextBuf ;
	char * oldBuf = mTextBuf ;

	// Allocate and fill the new buffer.
	long size = mTextBufSize + 1000 ;
	mTextBuf = (char *) new char [ size ] ;
	assert(mTextBuf);
	memset(mTextBuf, 0 , size );

	if ( oldBuf )
		memcpy( mTextBuf, oldBuf, mTextBufSize ) ;

	// Set the new buffer values.
	mTextBufSize += 1000 ;
	mTextLimit = mTextBuf + mTextBufSize ;
	mTextPtr = mTextBuf + offset ;

	if ( oldBuf ) delete [] oldBuf ;
}</t>
<t tx="T873">#define match_flag(a, b)\
	if ( matchTag(b) ) { getTag("=\""); a=getBool(); getDoubleQuote(); }

void Commands::getFindPanelSettings ( void )
{
	&lt;&lt; Set defaults of all flags &gt;&gt;
	getTag("&lt;find_panel_settings");
	for (;;) {
		     match_flag ( batch_flag, "batch" )
		else match_flag ( wrap_flag, "wrap" )
		else match_flag ( whole_word_flag, "whole_word" )
		else match_flag ( ignore_case_flag, "ignore_case" )
		else match_flag ( pattern_match_flag, "pattern_match" )
		else match_flag ( search_headline_flag, "search_headline" )
		else match_flag ( search_body_flag, "search_body" )
		else match_flag ( suboutline_only_flag, "suboutline_only" )
		else match_flag ( mark_changes_flag, "mark_changes" )
		else match_flag ( mark_finds_flag, "mark_finds" )
		else match_flag ( reverse_flag, "reverse" )
		else break;
	}
	getTag("&gt;");

	if ( matchTag("&lt;find_string&gt;") ) {
		find_text = getEscapedString();
		getTag("&lt;/find_string&gt;");
	}
	else {
		getTag("&lt;find_string/&gt;");
		find_text = "" ;
	}

	if ( matchTag("&lt;change_string&gt;") ) {
		change_text = getEscapedString();
		getTag("&lt;/change_string&gt;");
	}
	else {
		getTag("&lt;change_string/&gt;");
		change_text = "" ;	
	}
	getTag("&lt;/find_panel_settings&gt;");
	
	// Update the settings immediately.
	if ( FindForm ) FindForm -&gt; set_check_boxes();
}

#undef match_flag
</t>
<t tx="T874">batch_flag = FALSE ;
wrap_flag = FALSE ;
whole_word_flag = FALSE ;
ignore_case_flag = FALSE ;
pattern_match_flag = FALSE ;
search_headline_flag = FALSE ;
search_body_flag = FALSE ;
suboutline_only_flag = FALSE ;
mark_changes_flag = FALSE ;
mark_finds_flag = FALSE ;
reverse_flag = FALSE ;
</t>
<t tx="T875">void Commands::getGlobals ( fileInfo * info )
{
	long top, left, height, width ;

	getTag("&lt;globals") ;
		getTag("body_outline_ratio=\"");
			info -&gt; mRatio = getDouble();
		getDoubleQuote();
	getTag("&gt;");

	getTag("&lt;global_window_position");
		getPosition( &amp;top, &amp;left, &amp;height, &amp;width ) ;
		
	&lt;&lt; set the window position &gt;&gt;

	getTag("/&gt;");

	getTag("&lt;global_log_window_position");
		getPosition( &amp;top, &amp;left, &amp;height, &amp;width ) ;
		
	&lt;&lt; set the log window position &gt;&gt;

	getTag("/&gt;");

	getTag("&lt;/globals&gt;") ;
}
</t>
<t tx="T876">assert ( mLeoForm ) ;
mLeoForm -&gt; SetBounds(left, top, width, height) ;</t>
<t tx="T877">if ( SherlockForm )
	SherlockForm -&gt; SetBounds(left, top, width, height) ;</t>
<t tx="T878">double Commands::getLeoFile ( TLeoForm * leoForm )
{
	fileInfo * info = new fileInfo( leoForm, this );
	try {
		readLine();
		getTag(prolog_string);
		getTag("&lt;leo_file&gt;");
		getLeoHeader ( info );
		getGlobals ( info );
		getPrefs ( info );
		getFindPanelSettings ();
		getVnodes ( info );
		getTnodes ( info );
		getCloneWindows ( info );
		getTag ("&lt;/leo_file&gt;");
		info -&gt; finishOutline();
	}
	catch ( const EBadLeoFile&amp; err ) {
		String s = *mFileName + String(" is not a valid Leo file");
		alert( s . c_str() );
	}
	catch ( ... ) {
		String s = String("error reading ") + *mFileName ;
		alert( s . c_str() );
	}
	this -&gt; deleteTagList();
	double ratio = info -&gt; mRatio ;
	delete info  ;
	
	// Leo2: read all @file nodes and reset dummy &amp; orphan bits.
	atFile * at = new atFile( this );
	at -&gt; readAll ( this -&gt; rootVnode() ) ;
	delete at ;
	
	// Leo2: set the current node only after all nodes have been read.
	if ( mCurrentVnode )
		this -&gt; selectVnode ( mCurrentVnode ) ;

	return ratio ;
}
</t>
<t tx="T879">void Commands::getLeoHeader ( fileInfo * info )
{
	// Set defaults.
	bool maxIndexSeen = FALSE ;
	bool numberSeen = FALSE ;
	info -&gt; mFileFormatNumber = 1 ;
	info -&gt; mNumberOfCloneWindows = 0 ;

	getTag("&lt;leo_header");
	
	// New in version 1.7: attributes may appear in any order.
	for (;;) {
		if ( matchTag("file_format=\"") ) {
			info -&gt; mFileFormatNumber = getLong();
			getDoubleQuote();
		}
		else if ( matchTag("tnodes=\"") ) {
			numberSeen = TRUE ;
			info -&gt; setNumberOfTnodes ( getLong() ) ;
			getDoubleQuote();
		}
		else if ( matchTag("max_tnode_index=\"") ) {
			maxIndexSeen = TRUE ;
			info -&gt; setMaxTnodeIndex ( getLong() ) ;
			getDoubleQuote();
		}
		else if ( matchTag("clone_windows=\"") ) {
			info -&gt; mNumberOfCloneWindows = getLong();
			getDoubleQuote();
		}
		else {
			getTag("/&gt;");
			break ;
		}
	}

	if ( ! numberSeen )
		info -&gt; setNumberOfTnodes ( 0 ) ;
	if ( ! maxIndexSeen )
		info -&gt; setMaxTnodeIndex ( 0 ) ;
}
</t>
<t tx="T880">@ This method reads a Leo outline from string s.
@c

vnode * Commands::getLeoOutline ( String * s )
{
	mUsingClipboard = TRUE ;
    vnode * v = NULL ;  // The new outline.
	mMemoryStream = new TMemoryStream();
	mMemoryStream -&gt; Write ( s -&gt; c_str(), s -&gt; Length() ) ;
	mMemoryStream -&gt; Position = 0 ;

	// Allocate the file buffer.
	mFileBufSize = 1024 * 16 ;
	mFileBuf = new char [ mFileBufSize ] ;

	fileInfo * info = new fileInfo( mLeoForm, this );
	try {
		readLine();
		getTag(prolog_string);
		getTag("&lt;leo_file&gt;");
		getClipboardHeader ( info ) ;
		getVnodes ( info );
		getTnodes ( info );
		getTag ("&lt;/leo_file&gt;");
		v = info -&gt; finishPaste();
	}
	catch ( const EBadLeoFile&amp; err ) {
		String s ("The clipboard is not a valid Leo outline");
		alert( s . c_str() );
	}
	catch ( ... ) {
		String s ("Error pasting Leo outline ");
		alert( s . c_str() );
	}

	// Clean up.
	delete info  ;
	delete [] mFileBuf ;
	delete mMemoryStream ;  // 10/27/99
	mMemoryStream = NULL ;  // 10/27/99
	mFileBuf = NULL ;
	mFileBufSize = 0 ;
	mUsingClipboard = FALSE ;

	return v ;
}
</t>
<t tx="T881">void Commands::getPosition ( long *top, long *left, long *height, long *width )
{
	*top = *left = *height = *width = 0 ;
	// New in version 1.7: attributes may appear in any order.
	for(;;) {
		if ( matchTag("top=\"") ) {
			*top = getLong(); getDoubleQuote();
		}
		else if ( matchTag("left=\"") ) {
			*left = getLong(); getDoubleQuote();
		}
		else if ( matchTag("height=\"") ) {
			*height = getLong(); getDoubleQuote();
		}
		else if ( matchTag("width=\"") ) {
			*width = getLong(); getDoubleQuote();
		}
		else break ;
	}
}
</t>
<t tx="T882">void Commands::getPrefs ( fileInfo * info )
{
	TLeoForm * form = this -&gt; mLeoForm ;
	PERM_ASSERT(form);

	getTag("&lt;preferences");
	for (;;) {
		if ( matchTag("allow_rich_text=\"") ) {
			form -&gt; mAllowRichTextFlag = getBool();
			getDoubleQuote();
		}
		else if ( matchTag("tab_width=\"") ) {
			form -&gt; mTabWidth = getLong();
			getDoubleQuote();
		}
		else if ( matchTag("page_width=\"") ) {
			form -&gt; mPageWidth = getLong();
			getDoubleQuote();
		}
		else if ( matchTag("tangle_bat=\"") ) {
			form -&gt; mTangleBatchFlag = getBool();
			getDoubleQuote();
		}
		else if ( matchTag("untangle_bat=\"") ) {
			form -&gt; mUntangleBatchFlag = getBool();
			getDoubleQuote();
		}
		// New in version 0.10
		else if ( matchTag("output_doc_chunks=\"") ) {
			form-&gt; mOutputDocFlag = getBool();
			getDoubleQuote();
		}
		else if ( matchTag("noweb_flag=\"") ) {
			#if 1 // New in version 0.19
				// Ignore this flag.
				getBool();
				getDoubleQuote();
			#else
    			form -&gt; mUseNowebFlag = getBool();
    			form -&gt; mUseCwebFlag = ! form -&gt; mUseNowebFlag ;
				getDoubleQuote();
			#endif
		}
		else if ( matchTag("extended_noweb_flag=\"" ) ) {
			#if 1 // New in version 0.19
				// Ignore this flag.
				getBool();
    			getDoubleQuote();
			#else
    			form -&gt; mExtendedNowebFlag = getBool();
    			getDoubleQuote();
			#endif
		}
		else if ( matchTag ("defaultTargetLanguage=\"" ) ) {
			// New in version 0.15
			&lt;&lt; check for syntax coloring prefs &gt;&gt;
		}
		else if ( matchTag ("use_header_flag=\"" ) ) {
			form -&gt; mUseHeaderFlag = getBool();
			getDoubleQuote();
		}
		else break;
	}

	if ( ! matchTag("/&gt;") )
	{
    	getTag("&gt;");
    
    	for (;;) {
    		if ( matchTag ("&lt;defaultDirectory&gt;" ) ) {
    			// New in version 0.16.
    			&lt;&lt; Set the default directory preference &gt;&gt;
    			getTag("&lt;/defaultDirectory&gt;");
    		}
    		else if ( matchTag("&lt;TSyntaxMemo_options&gt;") ) {
    			&lt;&lt; Set the TSyntaxMemo options &gt;&gt;
    		}
    		else break ;
    	}
    
    	getTag("&lt;/preferences&gt;");
	}
}
</t>
<t tx="T883">// Must match longer tags before short prefixes.
if ( matchTag("CWEB") ) {
	form -&gt; mTargetLanguage = cweb_language ;
	getDoubleQuote();
}
else if ( matchTag("C") ) {
	form -&gt; mTargetLanguage = c_language ;
	getDoubleQuote();
}
else if ( matchTag("HTML") ) {
	form -&gt; mTargetLanguage = html_language ;
	getDoubleQuote();
}
else if ( matchTag("Java") ) {
	form -&gt; mTargetLanguage = java_language ;
	getDoubleQuote();
}
else if ( matchTag("Pascal") ) {
	form -&gt; mTargetLanguage = pascal_language ;
	getDoubleQuote();
}
else if ( matchTag("PerlPod") ) {
	form -&gt; mTargetLanguage = perlpod_language ;
	getDoubleQuote();
}
else if ( matchTag("Perl") ) {
	form -&gt; mTargetLanguage = perl_language ;
	getDoubleQuote();
}
else if ( matchTag("Plain") ) {
	form -&gt; mTargetLanguage = plain_text_language ;
	getDoubleQuote();
}
else if ( matchTag("Python") ) {
	form -&gt; mTargetLanguage = python_language ;
	getDoubleQuote();
}

mSyntaxMemo -&gt; Parser1 = TSMParser ( form -&gt; mTargetLanguage ) ;
</t>
<t tx="T884">mLeoForm -&gt; mDefaultDirectory = getEscapedString();
SetCurrentDir ( mLeoForm -&gt; mDefaultDirectory ) ;
</t>
<t tx="T885">String s = getEscapedString();
getTag("&lt;/TSyntaxMemo_options&gt;");

// Update the syntax settigns immediately.
assert(mSyntaxMemoParser1);
#if 0 // at present, this causes problems!
	mSyntaxMemoParser1 -&gt; StylesFromString( s );
	mSyntaxMemoParser1 -&gt; UpdateEditors();
#endif
</t>
<t tx="T886">void Commands::getSize ( long *height, long *width )
{
	*height = *width = 0 ;
	// New in version 1.7: attributes may appear in any order.
	for (;;) {
		if ( matchTag("height=\"") ) {
			*height = getLong(); getDoubleQuote();
		}
		else if ( matchTag("width=\"") ) {
			*width = getLong(); getDoubleQuote();
		}
		else break ;
	}
}
</t>
<t tx="T887">void Commands::getTnodes ( fileInfo * info )
{
	if ( matchTag("&lt;tnodes&gt;") ) {
		while ( matchTag("&lt;t") )
			getTnode ( info );
		getTag ("&lt;/tnodes&gt;");
	}
}</t>
<t tx="T888">void Commands::getTnode ( fileInfo * info )
{
	// we have already matched &lt;t.
	bool rtf = FALSE ;
	long index = -1 ;
	// New in version 1.7: attributes may appear in any order.
	for (;;) {
		if ( matchTag("tx=\"T") ) {
			index = getIndex();
			getDoubleQuote();
		}
		else if ( matchTag("rtf=\"1\"") )
			rtf = TRUE ;
		else if ( matchTag("rtf=\"0\"") )
			rtf = FALSE ;
		else break ;
	}
	getTag("&gt;");

	tnode * t = info -&gt; getT ( index ) ;

	if ( t == NULL ) {
		// No vnode refers to this tnode.
		String s( "No tnode with index: " ) ;
		s += index ;
		s += ".  The text will be discarded" ;
		// alert ( s . c_str() );
		es(s.c_str()); enl();
		getEscapedString();
	}
	else {
		String text = getEscapedString() ;
		if ( rtf )
			t -&gt; setTnodeRTF ( text ) ;
		else
			t -&gt; setTnodeText ( text ) ;
	}

	getTag ("&lt;/t&gt;");
}
</t>
<t tx="T889">void Commands::getVnodes ( fileInfo * info )
{
	vnode * parent = NULL, * back = NULL ;

	// We paste the first pasted vnode after the current vnode.
	if ( mUsingClipboard ) {
		back = this -&gt; currentVnode() ;
		parent = back -&gt; parent();
	}

	getTag("&lt;vnodes&gt;");
	while ( matchTag("&lt;v") )
		back = getVnode ( info, parent, back );

	getTag ("&lt;/vnodes&gt;");
}
</t>
<t tx="T890">vnode * Commands::getVnode ( fileInfo * info, vnode * parent, vnode * back )
{
	vnode * v = NULL ;  // The newly created vnode.
	tnode dummy_t(0,"");
	vnode dummy(this, &amp;dummy_t) ;  // A dummy vnode to carry status bits.
	bool currentVnodeFlag = FALSE ;  // TRUE if the 'V' attribute seen.
	bool topVnodeFlag = FALSE ;  // TRUE if 'T' attribute seen.
	long tref = 0 , vtag = 0;
	long xindex = 0 ;
	String headline("") ;
	String xfile("");

	// we have already matched &lt;v.
	for ( ;; ) {
		if ( matchTag("t=\"T") ) {
			tref = getIndex () ;
			getDoubleQuote();
		}
		else if ( matchTag("vtag=\"V") ) {
			vtag = getIndex();
			getDoubleQuote();
		}
		else if ( matchTag("a=\"") ) {
			&lt;&lt; Handle vnode attribute bits &gt;&gt;
		}
		else if ( matchTag ("xfile=\"") ) {
			// New for Leo2
			xfile = getEscapedString();
			getDoubleQuote();
		}
		else if ( matchTag ("xindex=\"") ) {
			// New for Leo2
			xindex = getIndex();
			getDoubleQuote();
		}
		else break ;
	}
	getTag("&gt;");
	
	// Leo2: headlines are optional.
	if ( matchTag("&lt;vh&gt;") ) {
		headline = getEscapedString () ;
		getTag("&lt;/vh&gt;");
	}

	// Link v into the outline using parent and back.
	v = info -&gt; createVnode (
		parent, back, headline,
		dummy.status() /*attrib*/ ,
		tref, vtag, xfile, xindex) ;

	// Remember various info that may have been specified.
	if ( currentVnodeFlag )
		info -&gt; mCurrentVnode = v ;
	if ( topVnodeFlag )
		this -&gt; mTopVnode = v ;
	if ( vtag &gt; 0 )
		this -&gt; newVtag ( vtag, v ) ;

	// Recursively create all nested nodes.
	parent = v ;  back = NULL ;
	while ( matchTag("&lt;v") )
		back = getVnode ( info, parent, back ) ;

	// End this vnode.
	getTag("&lt;/v&gt;");

	return v ;
}
</t>
<t tx="T891">// The a=" has already been seen.
for (;;) {
	if      ( matchChar('C') ) dummy.initClonedBit(TRUE);
	else if ( matchChar('D') ) dummy.setDummy();
	else if ( matchChar('E') ) dummy.initExpandedBit();
	else if ( matchChar('M') ) dummy.initMarkedBit();
	else if ( matchChar('O') ) dummy.setOrphan();
	else if ( matchChar('T') ) topVnodeFlag = TRUE ;
	else if ( matchChar('V') ) currentVnodeFlag = TRUE ;
	else break;
}
getDoubleQuote();
</t>
<t tx="T892">void Commands::skipWs ( void )
{
	while ( mLinePtr &lt; mLineLimit ) {
		char c = *mLinePtr ;
		if ( is_ws ( c ) )
			++mLinePtr;
		else break ;
	}

	// The caller is entitled to get the next character.
	if ( mLinePtr &gt;= mLineLimit )
		throw EBadLeoFile() ;
}</t>
<t tx="T893">@ This routine is part of the read logic, and as such must handle raw '\r' and '\n' characters.  This is an adjustment to help TSyntaxMemo recognize lines properly.
@c

void Commands::skipWsAndNl ( void )
{
	while ( mLinePtr &lt; mLineLimit ) {
		char c = *mLinePtr ;
		if ( is_ws ( c ) || c == '\r' )
			++mLinePtr;
		else if ( c == '\n' )
			readLine();
		else break ;
	}

	// The caller is entitled to get the next character.
	if ( mLinePtr &gt;= mLineLimit )
		throw EBadLeoFile() ;
}
</t>
<t tx="T894">void Commands::open ( String fileName )
{
	mFileName = new String( fileName ) ;  // Do not delete this!
	mLeoForm -&gt; Caption = fileName ;
	&lt;&lt; Create the TFileStream and the file buffer &gt;&gt;
	&lt;&lt; Set the default directory &gt;&gt;
	this -&gt; BeginUpdate();
		double ratio = this -&gt; getLeoFile ( mLeoForm ) ;
	this -&gt; EndUpdate();
	mLeoForm -&gt; Show();
	this -&gt; setChanged ( FALSE ) ;
	this -&gt; resizePanesToRatio ( ratio ) ;
	// This should be done after the pane size has been set.
	if ( mTopVnode )
		this -&gt; setTopVnode (mTopVnode);
	&lt;&lt; Delete the TFileStream and the file buffer &gt;&gt;
}
</t>
<t tx="T895">mFileStream = new TFileStream ( fileName, fmOpenRead | fmShareDenyWrite ) ;
mFileBufSize = 1024 * 16 ;
mFileBuf = new char [ mFileBufSize ] ;
</t>
<t tx="T896">@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

String dir = ExtractFileDir ( fileName ) ;
if ( dir . Length() &gt; 0 ) {
    mLeoForm -&gt; mOpenDirectory = dir ;
	SetCurrentDir ( dir ) ;
}
</t>
<t tx="T897">delete mFileStream ;
mFileStream = NULL ;

delete [] mFileBuf ;
mFileBuf = NULL ;

mFileBufSize = 0 ;
</t>
<t tx="T898">@ This method fills a line buffer from a TFileStream.  There is no maximum size of a line:  we reallocate mLineBuf if needed.  We return FALSE if no more lines remain.  Otherwise, mLinePtr points to the start of the line and mLineLimit points to the character after the newline that ends the line.

8/25/99: This routine now removes all body_ignored_newline characters.
@c

bool Commands::readLine ( void )
{
	mLinePtr = mLineBuf ;

	for ( ; ; ) 
	{
		// Make sure there is room for the last character and a zero byte.
		if ( mLinePtr + 1 &gt;= mLineBuf + mLineBufSize ) {
			&lt;&lt; reallocate mLineBuf &gt;&gt;
		}

		if ( mFilePtr &gt;= mFileLimit ) {
			if ( ! mFileEmptyFlag ) {
				&lt;&lt; fill mFileBuf or set mFileEmptyFlag &gt;&gt;
			}
			if ( mFileEmptyFlag ) {
				&lt;&lt; return the last line, if any &gt;&gt;
			}
		}

		// Get the next character.
		char c = *mFilePtr++ ;

		// TSyntaxMemo appears to want lines ending in '\n'
		if ( c == '\n' ) {
			*mLinePtr++ = c ;
			*mLinePtr = '\0' ;
			mLineLimit = mLinePtr ;  // Point mLimitPtr after the last valid character.
			mLinePtr = mLineBuf ;  // The next character starts the line.
			return TRUE ;
		}
		else *mLinePtr++ = c ;  // copy '\r' characters as well.
	}
}
</t>
<t tx="T899">{
	unsigned long increment = 10000 ;
	long offset = mLinePtr - mLineBuf ;
	char * oldBuf = mLineBuf ;

	// Allocate and fill the new buffer.
	long size = mLineBufSize + increment ;
	mLineBuf = (char *) new char [ size ] ;
	assert(mLineBuf);
	memset(mLineBuf, 0 , size );

	if ( oldBuf )
		memcpy( mLineBuf, oldBuf, mLineBufSize ) ;

	// Set the new buffer values.
	mLineBufSize += increment ;
	mLineLimit = mLineBuf + mLineBufSize ;
	mLinePtr = mLineBuf + offset ;

	if ( oldBuf ) delete [] oldBuf ;
}</t>
<t tx="T900">if ( mUsingClipboard ) {
	// Get the next line from the memory stream.
	if ( mMemoryStream &amp;&amp; ! mFileEmptyFlag ) {
		assert( mFileBufSize &gt; 0 ) ;
		long n = mMemoryStream -&gt; Read( mFileBuf, mFileBufSize ) ;
		mFileEmptyFlag = ( n == 0 ) ;
		mFilePtr = mFileBuf ;
		mFileLimit = mFileBuf + n ;
	}
	else mFileEmptyFlag = TRUE ;
}
else {
	// Get the next line from the file.
	if ( mFileStream &amp;&amp; ! mFileEmptyFlag ) {
		assert( mFileBufSize &gt; 0 ) ;
		long n = mFileStream -&gt; Read( mFileBuf, mFileBufSize ) ;
		mFileEmptyFlag = ( n == 0 ) ;
		mFilePtr = mFileBuf ;
		mFileLimit = mFileBuf + n ;
	}
	else mFileEmptyFlag = TRUE ;
}</t>
<t tx="T901">if ( mLinePtr == mLineBuf ) {
	mLineLimit = mLinePtr ;
	return FALSE ;
}
else {
	// End the last line with a newline
	assert(mLinePtr + 1 &lt; mLineLimit);
	*mLinePtr++ = body_newline ;
	*mLinePtr = '\0' ;
	mLineLimit = mLinePtr ;
	mLinePtr = mLineBuf ;
	return TRUE ;
}
</t>
<t tx="T902">String Commands::xmlUnescape ( char * cs )
{
	char * cs1 = cs;

	// Compute the length of the result.
	long length = 0 ;
	while (*cs)
	{
		++ length ;
		if ( *cs++ == '&amp;' ) {
			if ( strncmp ( cs, "amp;", 4 ) == 0 )
				cs += 4 ;
			else if ( strncmp ( cs, "lt;", 3 ) == 0 )
				cs += 3 ;
			else if ( strncmp ( cs, "gt;", 3 ) == 0 )
				cs += 3 ;
			else
				--length ;  // We will ignore the ampersand.
		}
	}

	// Allocate the result and copy the characters into it.
	char * result = new char [ length + 2 ] ;
	long i = 0 ;
	cs = cs1;  // rescan.
	while (*cs) {
		if ( *cs == '&amp;' ) {
			++ cs ;
			if ( strncmp ( cs, "amp;", 4 ) == 0 ) {
				cs += 4 ;
				result [i++] = '&amp;';
			}
			else if ( strncmp ( cs, "lt;", 3 ) == 0 ) {
				cs += 3 ;
				result [i++] = '&lt;' ;
			}
			else if ( strncmp ( cs, "gt;", 3 ) == 0 ) {
				cs += 3 ;
				result [i++] = '&gt;' ;
			}
			else ++ cs ;  // Skip the ampersand:  this should never happen.
		}
		else result [i++] = *cs++ ;
	}
	result [ i ] = '\0' ;
	assert ( i &lt; length + 2 ) ;
	
	// Fixes a major memory leak.
	String s2 ( result ) ;
	delete [] result ;
	return s2 ;
}
</t>
<t tx="T903">void Commands::assignFileIndices ( void )
{
	for ( vnode * v = this -&gt; rootVnode(); v ; v = v -&gt; threadNext() )
	{
		tnode * t = v -&gt; t();
		// 8/28/99.  Write shared tnodes even if they are empty.
		if ( t -&gt; hasBody() || v -&gt; joinList() != NULL ) {
			if ( t -&gt; fileIndex() == 0 )
				t -&gt; setFileIndex ( ++ mMaxTnodeIndex ) ;
		}
		else t -&gt; setFileIndex ( 0 ) ;
	}
}</t>
<t tx="T904">void Commands::compactFileIndices ( void )
{
	mMaxTnodeIndex = 0 ;
	
	// Clear all indices.
	for ( vnode * v = this -&gt; rootVnode(); v ; v = v -&gt; threadNext() ) {
		tnode * t = v -&gt; t();
		t -&gt; setFileIndex ( 0 ) ;
	}

	// Set indices for all shared tnodes or tnodes containing body text.
	for ( vnode * v = this -&gt; rootVnode(); v ; v = v -&gt; threadNext() ) {
		tnode * t = v -&gt; t();
		// 8/28/99.  Write shared tnodes even if they are empty.
		if ( t -&gt; hasBody() || v -&gt; joinList() != NULL ) {
			if ( t -&gt; fileIndex() == 0 )
				t -&gt; setFileIndex ( ++ mMaxTnodeIndex ) ;
		}
	}
}</t>
<t tx="T905">@ This method sets policy for when we should compact a file before doing a Save Command.
@c

bool Commands::shouldCompactOnSave ( void )
{
	long tnodesUsed = 0 ;
	&lt;&lt; Compute the number of tnodes used &gt;&gt;
	long tnodesUnused = mMaxTnodeIndex - tnodesUsed ;
	return ( tnodesUnused &gt; 100 ) ;
}</t>
<t tx="T906">this -&gt; clearAllVisited();

for ( vnode * v = this -&gt; rootVnode(); v ; v = v -&gt; threadNext() )
{
	tnode * t = v -&gt; t();
	if ( t &amp;&amp; ! t -&gt; isVisited() ) {
		++ tnodesUsed ;
		t -&gt; setVisited();
	}
}
</t>
<t tx="T907">@ All output eventually comes to put (char *)
@c

void Commands::put ( char * s )
{
	if ( s == NULL ) return ;
	long len = strlen(s) ;
	if ( len == 0 ) return ;

	if ( mUsingClipboard ) {
		&lt;&lt; put s to the mMemoryStream &gt;&gt;
	}
	else {
		&lt;&lt; put s to mFileStream &gt;&gt;
	}
}

void Commands::put_bool ( bool b )
{
	put ( b ?  "1" : "0" ) ;
}

void Commands::put_double_quote ( void )
{
	put ( "\"" ) ;
}

void Commands::put_nl ( void )
{
	put ( "\r\n" ) ;
}

void Commands::put_tab ( void )
{
	put ( "\t" ) ;
}

void Commands::put_tabs ( long n )
{
	while ( n-- &gt; 0 )
		put_tab();
}

void Commands::put ( String s )
{
	long length = s . Length();

	if ( length &gt; 0 ) {
		char * buffer = s . c_str();
		put (buffer);
		assert(buffer == s . c_str());
	}
}

void Commands::put ( long n )
{
	put ( String ( n ) ) ;
}

void Commands::put ( double n )
{
	put ( String ( n ) ) ;
}
</t>
<t tx="T908">@ mFileStream will be NULL if there is any file error.
@c

if ( mMemoryStream == NULL ) return ;

try {
	mMemoryStream -&gt; Write ( s, len );
}
catch (...)
{
	delete mMemoryStream ;
	mMemoryStream = NULL ;
	String s("Error writing to clipboard") ;
	alert ( s . c_str() ) ;
}</t>
<t tx="T909">@ mFileStream will be NULL if there is any file error.
@c

if ( mFileStream == NULL ) return ;

try {
	mFileStream -&gt; Write ( s, len );
	mFileSize += len ;
}
catch (...)
{
	delete mFileStream ;
	mFileStream = NULL ;
	String s = String("Error writing to ") + ( * mFileName ) ;
	alert ( s . c_str() ) ;
}</t>
<t tx="T910">void Commands::putClipboardHeader ( void )
{
	long tnodes = 0;
	&lt;&lt; count the number of tnodes &gt;&gt;
	put("&lt;leo_header");
		put(" file_format=\"");
			put ( "1" ) ; put_double_quote();
		put(" tnodes=\"");
			put(tnodes); put_double_quote();
		put(" max_tnode_index=\"");
			put( mMaxTnodeIndex ); put_double_quote();
	put("/&gt;"); put_nl();
}</t>
<t tx="T911">this -&gt; clearAllVisited();

// Count the vnode and tnodes.
vnode * current = this -&gt; currentVnode() ;
vnode * after = current -&gt; nodeAfterTree();

for ( vnode * v = current ; v &amp;&amp; v != after ; v = v -&gt; threadNext() ) {
	tnode * t = v -&gt; t();
	if (
        t &amp;&amp; ! t -&gt; isVisited() &amp;&amp;
        ( t -&gt; hasBody() || v -&gt; joinList() != NULL )
    ) {
		t -&gt; setVisited();
		++tnodes ;
	}
}</t>
<t tx="T912">void Commands::putCloneWindows ( void )
{
#if USE_CLONE_WINDOW
	if ( mLeoForm == NULL || mLeoForm -&gt; mCloneFormList == NULL ) return ;

	put("&lt;clone_windows&gt;"); put_nl();

	for ( TCloneForm * clone = mLeoForm -&gt; mCloneFormList ;
		clone ; clone = clone -&gt; mNextForm )
	{
		vnode * v = clone -&gt; mVnode ;
		long vtag = this -&gt; getVtag ( v ) ; ;

		put_tab();
			put("&lt;clone_window vtag=\"V");
				put (vtag) ; put_double_quote(); put("&gt;"); put_nl();
		put_tabs(2);
			&lt;&lt; put position of clone window &gt;&gt;
		put_tab();
			put("&lt;/clone_window&gt;"); put_nl();
	}

	put("&lt;/clone_windows&gt;"); put_nl();
#endif
}
</t>
<t tx="T913">long top = clone -&gt; Top;
long left = clone -&gt; Left;
long height = clone -&gt; Height;
long width = clone -&gt; Width;

put("&lt;global_window_position");
	put(" top=\""); put( top ); put_double_quote();
	put(" left=\""); put( left ); put_double_quote();
	put(" height=\""); put( height ); put_double_quote();
	put(" width=\"");  put( width ); put_double_quote();
put("/&gt;"); put_nl();
</t>
<t tx="T914">@ Surprisingly, the call to xmlEscape here is _much_ faster than calling put for each characters of s.c_str().
@c

void Commands::putEscapedString ( String s )
{
   put ( this -&gt; xmlEscape ( s ) ) ;
}
</t>
<t tx="T915">#define put_flag(a,b) if (a) { put(" "); put(b); put("=\"1\""); }

void Commands::putFindSettings ( void )
{
	put("&lt;find_panel_settings"); 
		put_flag ( batch_flag, "batch" ) ;
		put_flag ( wrap_flag, "wrap" ) ;
		put_flag ( whole_word_flag, "whole_word" ) ;
		put_flag ( ignore_case_flag, "ignore_case" ) ;
		put_flag ( pattern_match_flag, "pattern_match" );
		put_flag ( search_headline_flag, "search_headline" );
		put_flag ( search_body_flag, "search_body" );
		put_flag ( suboutline_only_flag, "suboutline_only" );
		put_flag ( mark_changes_flag, "mark_changes" );
		put_flag ( mark_finds_flag, "mark_finds" );
		put_flag ( reverse_flag, "reverse" );
	put("&gt;"); put_nl();
		put_tab();
			put("&lt;find_string&gt;"); putEscapedString(find_text);
			put("&lt;/find_string&gt;"); put_nl();
		put_tab();
			put("&lt;change_string&gt;"); putEscapedString(change_text);
			put("&lt;/change_string&gt;"); put_nl();
	put("&lt;/find_panel_settings&gt;"); put_nl();
}

#undef put_flag
</t>
<t tx="T916">void Commands::putGlobals ( void )
{
	long top, left, height, width ;

	put("&lt;globals");
		&lt;&lt; put the body/outline ratio &gt;&gt;
	put("&gt;"); put_nl();
		&lt;&lt; put the position of this form &gt;&gt;
		&lt;&lt; put the position of the log window &gt;&gt;
	put("&lt;/globals&gt;"); put_nl();
}</t>
<t tx="T917">{
	long treeViewH = mTreeView -&gt; Height ;
	long richViewH = mSyntaxMemo -&gt; Height ;
	double ratio = double(treeViewH) / (double) (treeViewH + richViewH) ;

	put(" body_outline_ratio=\"");
	#if 0 // Puts an innumerate number of digits
		put ( ratio );
	#else
		char buffer [ 50 ] ;
		sprintf( buffer, "%2.3f", ratio );
		put ( buffer ) ;
	#endif
	put_double_quote();
}
</t>
<t tx="T918">top = mLeoForm -&gt; Top ;
left = mLeoForm -&gt; Left;
height = mLeoForm -&gt; Height ;
width = mLeoForm -&gt; Width ;

put_tab();
put("&lt;global_window_position");
	put(" top=\""); put( top ); put_double_quote();
	put(" left=\""); put( left ); put_double_quote();
	put(" height=\""); put( height ); put_double_quote();
	put(" width=\"");  put( width ); put_double_quote();
put("/&gt;"); put_nl();
</t>
<t tx="T919">top = SherlockForm -&gt; Top ;
left = SherlockForm -&gt; Left;
height = SherlockForm -&gt; Height ;
width = SherlockForm -&gt; Width ;

put_tab();
put("&lt;global_log_window_position");
	put(" top=\""); put( top ); put_double_quote();
	put(" left=\""); put( left ); put_double_quote();
	put(" height=\""); put( height ); put_double_quote();
	put(" width=\"");  put( width ); put_double_quote();
put("/&gt;"); put_nl();
</t>
<t tx="T920">void Commands::putHeader ( void )
{
	long tnodes = 0, clone_windows = 0 ;
	#if 0 // These counts are not used in Leo2.
		&lt;&lt; count the number of tnodes and clone windows &gt;&gt;
	#endif
	put("&lt;leo_header");
		// Leo2 use file format 2 so that Leo1 can warn about altering Leo2 files.
		put(" file_format=\""); put ( "2" ) ; put_double_quote();
		put(" tnodes=\""); put(tnodes); put_double_quote();
		put(" max_tnode_index=\""); put( mMaxTnodeIndex ); put_double_quote();
		put(" clone_windows=\""); put(clone_windows); put_double_quote();
	put("/&gt;"); put_nl();
}
</t>
<t tx="T921">this -&gt; clearAllVisited();

// Count the vnode and tnodes.
for ( vnode * v = this -&gt; rootVnode(); v ; v = v -&gt; threadNext() ) {
	tnode * t = v -&gt; t();
	// 8/28/99: we write all shared tnodes, even if empty.
	if (
		t &amp;&amp; ! t -&gt; isVisited() &amp;&amp;
		( t -&gt; hasBody() || v -&gt; joinList() != NULL )
	) {
		t -&gt; setVisited();
		++tnodes ;
	}
}

#if USE_CLONE_WINDOW
	// Count the clone windows.
    if ( mLeoForm ) {
    	for (
    		TCloneForm * clone = mLeoForm -&gt; mCloneFormList ;
    		clone ;
    		clone = clone -&gt; mNextForm 
    	)
    		++clone_windows ;
    }
#endif  // USE_CLONE_WINDOW
</t>
<t tx="T922">@ This method writes a Leo outline to the clipboard.
@c

bool Commands::putLeoOutline ( TMemoryStream * ms )
{
	mMemoryStream = ms ;  // Create an alias.
	mUsingClipboard = TRUE ;
		// assignFileIndices();  // The caller does this.
		putProlog();
		putClipboardHeader();
		putVnodes();
		putTnodes();
		putPostlog();
		bool ok = ( mMemoryStream != NULL ) ;
	// The caller will delete ms.
	// Do _not_ delete mMemoryStream; it is just an alias.
	mMemoryStream = NULL ;
	mUsingClipboard = FALSE ;
	return ok ;
}
</t>
<t tx="T923">void Commands::putPrefs ( void )
{
	TLeoForm * form = this -&gt; mLeoForm ;
	PERM_ASSERT(form);

	put("&lt;preferences");
		put(" allow_rich_text=\"");
			put_bool( default_allow_rich_text ); put_double_quote();
		put(" tab_width=\"");
			put( default_tab_width ); put_double_quote();
		put(" page_width=\"");
			put( default_page_width ); put_double_quote();
		put(" tangle_bat=\"");
			put_bool( default_tangle_batch ); put_double_quote();
		put(" untangle_bat=\"");
			put_bool( default_untangle_batch ); put_double_quote();
		// New in version 0.10
		put(" output_doc_chunks=\"");
			put_bool( default_output_doc_flag ); put_double_quote();
		&lt;&lt; put syntax coloring prefs &gt;&gt; // New in version 0.15
		// New in version 0.18
		put(" use_header_flag=\"");
			put_bool( default_use_header_flag ); put_double_quote();
		// Removed in version 0.19
		#ifdef USE_CWEB
    		put(" noweb_flag=\"");
    			put_bool( default_use_noweb_flag ); put_double_quote();
    		put(" extended_noweb_flag=\"");
    			put_bool( default_extended_noweb_flag ); put_double_quote();
		#endif
	put("&gt;");
	put_nl(); put_tab();
		&lt;&lt; put default directory &gt;&gt; // New in version 0.16
		put_nl();
		put("&lt;TSyntaxMemo_options&gt;");
		putEscapedString ( mSyntaxMemoParser1 -&gt; StylesAsString() ) ;
		put ("&lt;/TSyntaxMemo_options&gt;");
	put_nl(); put("&lt;/preferences&gt;"); put_nl();
}
</t>
<t tx="T924">String key = " defaultTargetLanguage=\"" ;

switch ( default_target_language ) {
	case c_language:		put(key); put("C\""); break;
	case cweb_language:		put(key); put("CWEB\""); break;
	case html_language:		put(key); put("HTML\""); break;
	case java_language:		put(key); put("Java\""); break;
	case pascal_language:	put(key); put("Pascal\""); break;
	case perl_language:		put(key); put("Perl\""); break;
	case perlpod_language:	put(key); put("PerlPod\""); break;
	case plain_text_language: put(key); put("Plain\""); break;
	case python_language:	put(key); put("Python\""); break;
	default: put("Plain\"");
}
</t>
<t tx="T925">if ( mLeoForm -&gt; mDefaultDirectory . Length() &gt; 0 ) {
	put("&lt;defaultDirectory&gt;");
	putEscapedString ( mLeoForm -&gt; mDefaultDirectory ) ;
	put ("&lt;/defaultDirectory&gt;");
}
</t>
<t tx="T926">void Commands::putProlog ( void )
{
	put(prolog_string); put_nl();
	// internal or external DTD goes here
	put("&lt;leo_file&gt;"); put_nl();
}
</t>
<t tx="T927">void Commands::putPostlog ( void )
{
	put("&lt;/leo_file&gt;"); put_nl();
}
</t>
<t tx="T928">@ This method puts all tnodes in index order.  All tnode indices must have been assigned at this point.
@c

void Commands::putTnodes ( void )
{
	if ( mMaxTnodeIndex &lt; 1 ) return ;

	tnode ** tnodes = (tnode **) new char
		[ sizeof (tnode *) * (mMaxTnodeIndex+1) ] ;

	for ( long i = 0 ; i &lt; mMaxTnodeIndex  ; ++ i )
		tnodes [i] = NULL ;

	// Populate the tnodes array.
	if ( mUsingClipboard ) {  // Just write the current tree.
		vnode * current = this -&gt; currentVnode();
		vnode * after = current -&gt; nodeAfterTree();
		for (vnode * v = current; v &amp;&amp; v != after ; v = v -&gt; threadNext() ) {
       		tnode * t = v -&gt; t();
        	long index = t -&gt; fileIndex();
        	if ( index &gt; 0 ) {
				if ( 
		    		index &lt;= mMaxTnodeIndex &amp;&amp;
					(tnodes[index-1]==NULL || tnodes[index-1]== t )
				)
		    		tnodes [ index - 1 ] = t ;
				else
					alert ("error writing to clipboard");
        	}
		}
	}
	else {  // Write the entire outline.
		for (vnode * v = this -&gt; rootVnode(); v; v = v -&gt; threadNext() ) {
       		tnode * t = v -&gt; t();
        	long index = t -&gt; fileIndex();
        	if ( index &gt; 0 ) {
				if ( index &lt;= mMaxTnodeIndex )
		    		tnodes [ index - 1 ] = t ;
				else
					alert(
"error writing file (bad tnode)! Try using the Save To command");
        	}
		}
	}

	// Put all tnodes in index order.
	put("&lt;tnodes&gt;"); put_nl();
		for ( long i = 0 ; i &lt; mMaxTnodeIndex ; ++ i ) {
			// New for Leo2: write only those tnodes whose vnodes were written.
			tnode * t = tnodes [i] ;
			if ( t &amp;&amp; t -&gt; isVisited() )
				put ( t ) ;
		}
	put("&lt;/tnodes&gt;"); put_nl();

	delete [] tnodes ;
}
</t>
<t tx="T929">void Commands::put ( tnode * t )
{
	assert(t);
	String bodyString = t -&gt; bodyString();
	String bodyRTF = t -&gt; bodyRTF();
	bool hasBody = t -&gt; hasBody();
	bool hasRichText = arg_allow_rich_text &amp;&amp; t -&gt; isRichTextBit()
		&amp;&amp; bodyRTF . Length() &gt; 0;

	put("&lt;t tx=\"T");
		put( t -&gt; fileIndex() ); put_double_quote();
		if ( hasBody &amp;&amp; hasRichText ) put(" rtf=\"1\"");
	put("&gt;");

	if ( hasBody &amp;&amp; hasRichText )
		putEscapedString( bodyRTF ) ;
	else if ( hasBody &amp;&amp; bodyString . Length() &gt; 0 )
		putEscapedString( bodyString ) ;

	put("&lt;/t&gt;"); put_nl();
}
</t>
<t tx="T930">@ This method puts all vnodes by starting the recursion.  put(vnode*) will write all vnodes in the order in which they appear in the outline.
@c

void Commands::putVnodes ( void )
{
	// Set the global.
	mMaxVnodeTag = 0 ;

	TTreeView * treeView = this -&gt; treeView();
	TTreeNode * topNode = treeView -&gt; TopItem ;
	vnode * topVnode = (vnode *) topNode -&gt; Data ;
	assert(topVnode);
	
	// New for Leo2: put(vnode*) will visit
	// only those tnodes whose vnodes were written.
	this -&gt; clearAllVisited();

	put("&lt;vnodes&gt;"); put_nl();
		if ( mUsingClipboard )
			put (
				this -&gt; currentVnode(), // Write only current tree.
				NULL, // Don't write top vnode status bit.
				TRUE, // forceFlag.
				FALSE); // dummyFlag (don't care).
		else for ( vnode * v = this -&gt; rootVnode() ; v ; v = v -&gt; next() )
			put (
				v, // Write the next top-level node.
				topVnode,  // Write the top-vnode status bit.
				FALSE, // forceFlag,
				FALSE);  // dummyFlag.
	put("&lt;/vnodes&gt;"); put_nl();
}
</t>
<t tx="T931">@ When forceFlag is TRUE we generate full vnodes for v's tree.  Otherwise, if dummyFlag is TRUE we generate dummy vnodes only.  In particular, we generate dummy vnodes for all valid, non-ignored @file nodes.

atFile::write has already set the orphan bit for some nodes, including all invalid @file nodes.  However, we must make a separate check for atIgnored nodes.
@c

void Commands::put ( vnode * v, vnode * topVnode, bool forceFlag, bool dummyFlag )
{
	atFile * at = new atFile( this );
	
	// The heart of Leo2's write code.
	bool isAtFile = v -&gt; isAtFileNode();
	bool isIgnore = v -&gt; isAtIgnoreNode();
	bool orphanFlag = v -&gt; isOrphan() || isIgnore;
	forceFlag = forceFlag || orphanFlag ;
	#if 0 // We always write the headline now.
		bool writeHead = forceFlag || !dummyFlag || isAtFile;
	#endif
	dummyFlag = !forceFlag &amp;&amp; ( dummyFlag || isAtFile );

	put("&lt;v");
		if ( !dummyFlag || v -&gt; joinList() != NULL ) {
			&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;
		}
		&lt;&lt; Put a vnode tag if this vnode has a clone window &gt;&gt;
		&lt;&lt; Put attribute bits &gt;&gt;
	put("&gt;");
		&lt;&lt; write the head text &gt;&gt;
			
		vnode * child = v -&gt; firstChild() ;
		if ( child ) {
			put_nl();
			while ( child ) {
				put ( child, topVnode, forceFlag, dummyFlag ) ;
				child = child -&gt; next();
			}
		}
	put("&lt;/v&gt;"); put_nl();
	
	delete at ;
}
</t>
<t tx="T932">tnode * t = v -&gt; t();

if ( t &amp;&amp; t -&gt; hasBody() || v -&gt; joinList() != NULL )
{
	if ( t -&gt; fileIndex() &gt; 0 ) {
		put (" t=\"T"); put ( t -&gt; fileIndex() ); put_double_quote();
		v -&gt; t() -&gt; setVisited(); // Indicate we wrote the body text.
	}
	else {
		alert("error writing file (bad vnode)!  Try using the Save To command");
	}
}</t>
<t tx="T933">#if USE_CLONE_WINDOW

// See if any clone window has this vnode as its master.
if ( mLeoForm )
{
	bool found = FALSE ;

	for (
		TCloneForm * form = mLeoForm -&gt; mCloneFormList ;
		form &amp;&amp; ! found ; form = form -&gt; mNextForm
	)
		if ( v == form -&gt; mVnode )
			found = TRUE ;

	if ( found ) {
		long tag = ++mMaxVnodeTag ;
		this -&gt; newVtag ( tag, v ) ;
		put(" vtag=\"V"); put ( tag ); put_double_quote();
	}
}

#endif
</t>
<t tx="T934">@ Dummy vnodes carry all attributes.
@c

vnode * current = this -&gt; currentVnode();
vnode * top = this -&gt; topVnode();

if (
	v -&gt; isCloned() || v -&gt; isExpanded() || v -&gt; isMarked() ||
	forceFlag || dummyFlag ||
	v == current || v == top
) {
	put(" a=\"");
		if ( v -&gt; isCloned())	put("C");
		if ( dummyFlag )		put("D");
		if ( v -&gt; isExpanded())	put("E");
		if ( v -&gt; isMarked())	put("M");
		if ( orphanFlag )		put("O");
		if ( v == top )			put("T");
		if ( v == current )		put("V");
	put_double_quote();
}
</t>
<t tx="T935">@ Dummy vnodes have no headline text.
@c

assert(v -&gt; treeNode());
String headString = v -&gt; treeNode() -&gt; Text ;

if ( headString . Length() &gt; 0 ) {
    put("&lt;vh&gt;");
    putEscapedString( headString );
    put("&lt;/vh&gt;");
}
</t>
<t tx="T936">bool Commands::save ( String fileName )
{
	this -&gt; endEditing () ;  // Set the current headline text.

	if ( this -&gt; shouldCompactOnSave() )
		this -&gt; compactFileIndices();
	else
		this -&gt; assignFileIndices();

	try {
    	if ( this -&gt; write_LEO_file ( fileName, FALSE /* outlineOnlyFlag */ ) ) {
    		this -&gt; setChanged ( FALSE ) ;  // Clears all dirty bits.
    		this -&gt; Repaint();
			return TRUE;
    	}
	}
	catch ( ... ) {}
	return FALSE;
}</t>
<t tx="T937">bool Commands::saveAs ( String fileName )
{
	this -&gt; endEditing () ;  // Set the current headline text.
	this -&gt; compactFileIndices() ;

	try {
    	if ( this -&gt; write_LEO_file ( fileName, FALSE /* outlineOnlyFlag */ ) ) {
    		this -&gt; setChanged ( FALSE ) ;  // Clears all dirty bits.
    		this -&gt; Repaint();
			return TRUE;
    	}
	}
	catch ( ... ) {}
	return FALSE;
}</t>
<t tx="T938">bool Commands::saveACopyAs ( String fileName )
{
	try {
    	this -&gt; endEditing () ;  // Set the current headline text.
    	this -&gt; compactFileIndices() ;
    	this -&gt; write_LEO_file ( fileName, FALSE /* outlineOnlyFlag */ ) ;
		return TRUE;
	}
	catch ( ... ) {}
	return FALSE;
}</t>
<t tx="T939">bool Commands::saveOutlineOnlyTo ( String fileName )
{
	try {
    	this -&gt; endEditing () ;  // Set the current headline text.
    	this -&gt; compactFileIndices() ;
    	this -&gt; write_LEO_file ( fileName, TRUE /* outlineOnlyFlag */ ) ;
		return TRUE;
	}
	catch ( ... ) {}
	return FALSE;
}</t>
<t tx="T940">@ Surprisingly, this is a time critical routine.  This code is much faster than creating the result string by concatenations.  It is also much faster to use this routine than calling put() repeatedly for each character of s.c_str().

8/25/99:  We enforce the end-of-line convention here by turning bare '\r' or '\n' characters into cr/lf sequences.  This is an adjustment for TSyntaxMemo's difficulty recognizing lines that start with only '\r'.
@c

String Commands::xmlEscape ( String s )
{
	char * cs = s . c_str() ;
	char * cs1 = cs;

	// Compute the length of the result.
	long length = 0 ;
	while (*cs)
	{
		switch ( *cs++ ) {
		case '&amp;': length += 5 ; break;
		case '&lt;': length += 4 ; break;
		case '&gt;': length += 4 ; break;
        // Convert any combination of cr or lf to cr/lf.
        case '\r': length += 2 ;
            if ( *cs == '\n' ) ++cs;
            break;
        case '\n': length += 2 ; break;
		default : ++ length ; break ;
		}
	}

	// Allocate the result and copy the characters into it.
	char * result = new char [ length + 2 ] ;
	long i = 0 ;
	cs = cs1;  // rescan.
	while (*cs)
	{
		switch ( *cs++ ) {
		case '&amp;': strcpy( result + i, "&amp;amp;" ) ; i += 5; break;
		case '&lt;': strcpy( result + i, "&amp;lt;" ) ;  i += 4; break;
		case '&gt;': strcpy( result + i, "&amp;gt;" ) ;  i += 4; break;
        case '\r':
            strcpy ( result + i, "\r\n" ) ; i += 2 ;
            if ( *cs == '\n') ++cs;
            break ;
        case '\n': strcpy ( result + i, "\r\n" ) ; i += 2 ; break;
		default : result [ i ] = *(cs-1) ; ++i ; break ;
		}
	}
	result [ i ] = '\0' ;
	assert ( i &lt; length + 2 ) ;

	String s2 ( result ) ; 
	delete [] result ;
	return s2 ; 
}
</t>
<t tx="T941">@ The caller does any repainting.
@c

bool Commands::write_LEO_file ( String fileName, bool outlineOnlyFlag )
{
	// Leo2: write all @file nodes and set orphan bits.
	if ( ! outlineOnlyFlag ) {
    	atFile * at = new atFile( this );
    	at -&gt; writeAll ( this -&gt; rootVnode() ) ;
    	delete at ;
	}
	
	&lt;&lt; Open fileName and buffer it &gt;&gt;
	putProlog();
	putHeader();
	putGlobals();
	putPrefs();
	putFindSettings();
	putVnodes();
	putTnodes();
	putCloneWindows();
	putPostlog();
	bool ok = ( mFileStream != NULL ) ;
	&lt;&lt; Close the file &gt;&gt;
	deleteTagList();

	return ok ;
}
</t>
<t tx="T942">delete mFileName ;
mFileName = new String( fileName ) ;
mFileSize = 0 ;

try {
	mFileStream = new TFileStream ( fileName, fmCreate | fmShareDenyWrite ) ;
}
catch (...) {
	mFileStream = NULL ;
}
</t>
<t tx="T943">if ( mFileStream ) {
	mFileStream -&gt; Size = mFileSize ;  // Truncate the file.
	delete mFileStream ;
	mFileStream = NULL ;
}
</t>
</tnodes>
</leo_file>
